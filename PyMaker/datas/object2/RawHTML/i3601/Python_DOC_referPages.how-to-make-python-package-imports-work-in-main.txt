<div class="post-text" itemprop="text">
<p>I have a simple app organized like this:</p>
<pre><code>.
`-- app
    |-- __init__.py (empty)
    |-- extensions.py (just defines foo())
    `-- server.py
</code></pre>
<p>and server.py looks like this:</p>
<pre><code>from app.extensions import foo
</code></pre>
<p>Running this as <code>python app/server.py</code> doesn't work of course, because server.py is not "in" app when run from the command line. Its package name is <code>__main__</code>. I know running it as <code>python -m app.server</code> works, but for various reasons I can't do that (among them, I'm using a reloader, and <code>python -m&lt;foo&gt;</code> "helpfully" rewrites argv with the full module name).</p>
<p>I think I understand the extremely byzantine Python package/module import stuff, at least I've read up a lot. I think the standard (?) way to address this is to add the app dir to sys.path, something like <code>sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '..'))</code>. But that seems weird to me, and it's nontrivial to do correctly (see other similar SO questions on this topic). It seems like there should be some way to just tell python "this is app.server", by setting <code>__name__</code> and/or <code>__package__</code> or <code>__path__</code> or something else more hidden.</p>
<p>Is there any way to "fool" the package import system like that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't go there, there is no need to start mucking about with the Python package structure. The best method is to <strong>not put scripts in packages</strong>. </p>
<p>Have a separate <code>server.py</code> file <em>outside</em> of the package, and have it import <code>app.server</code> or other modules to do its job. That can be as simple as:</p>
<pre><code>import sys
from app.server import main

sys.exit(main(sys.argv[1:]))
</code></pre>
<p>Aside from that, <code>python -m</code> may have updated <code>sys.argv[0]</code> to point to the full filename (it is basically equal to <code>__file__</code> in the module being executed), but the <a href="https://docs.python.org/3/reference/import.html#module-spec" rel="nofollow noreferrer"><code>__spec__</code> module spec</a> object contains the original package name. Use that if you must use <code>python -m</code> <em>and</em> need to have the full qualifying name of the package being run as <code>__main__</code> as the <code>main</code> attribute:</p>
<pre><code>print(__spec__.name)
</code></pre>
<p>So for a <code>package.main</code> module, the above would print <code>package.main</code> and not <code>__main__</code>:</p>
<pre><code>$ mkdir package
$ touch package/__init__.py
$ echo 'if __name__ == "__main__": print("__spec__.name", __spec__.name)' &gt; package/main.py
$ python3 -m package.main
package.main
</code></pre>
<p>so if your reloader requires <code>sys.argv</code> to contain <code>-m package.main</code>, you could update <code>sys.argv</code> with:</p>
<pre><code>import sys

sys.argv[:1] = ['-m', __spec__.name]
</code></pre>
</div>
<span class="comment-copy">Thanks, that's good advice. Not what I wanted to hear of course, but since I haven't been able to make it work it's good to know that I should stop trying. :-/ won't stop wishing for this though; it also would make adding manual test scripts easier -- I could just put them next to the modules in question.</span>
