<div class="post-text" itemprop="text">
<p>I'm still a bit unsure about when to use <code>ensure_future</code> and I was wondering if this is a situation where I would want/need it.</p>
<p>Consider the following code</p>
<pre><code>import asyncio


loop = asyncio.get_event_loop()


async def do_work(count):
    for i in range(count):
        if i % 10000 == 0:
            await asyncio.sleep(0.1)

    print(count)
    return i


async def do_batch_work():
    res1 = do_work(100000)
    res2 = do_work(100)
    await asyncio.wait([res1, res2])
    return res1, res2


def main():
    loop = asyncio.get_event_loop()
    res1, res2 = loop.run_until_complete(do_batch_work())
    print(res1.result())
    print(res2.result())
    loop.close()

main()
</code></pre>
<p>This prints:</p>
<pre><code>100
100000
Traceback (most recent call last):
  File "more_async.py", line 30, in &lt;module&gt;
    main()
  File "more_async.py", line 26, in main
    print(res1.result())
AttributeError: 'coroutine' object has no attribute 'result'
</code></pre>
<p>The async code runs as expected and prints out in the expected order but the <code>loop.run_until_complete(...)</code> doesn't give me access to the underlying results because the <code>coroutine</code> object doesn't seem to have a way to get to the results.</p>
<p>I can fix that by changing the method as follows</p>
<pre><code>async def do_batch_work():
    res1 = asyncio.ensure_future(do_work(100000))
    res2 = asyncio.ensure_future(do_work(100))
    await asyncio.wait([res1, res2])
    return res1, res2
</code></pre>
<p>By calling <code>asyncio.ensure_future(...)</code> I make sure to get <code>Task</code>s back where I can call <code>result()</code> on.</p>
<p>I wonder, is that the right way to handle it? Do I need to use <code>ensure_future</code> if I care about the result of that coroutine or is there another way that I'm not aware of?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>async def do_batch_work():
    res1 = do_work(100000)
    res2 = do_work(100)
    await asyncio.wait([res1, res2])
    return res1, res2
</code></pre>
<p><code>res1</code> and <code>res2</code> are only coroutines in that example, not <code>Future</code> objects, therefore no result attribute. When you use <code>ensure_future()</code> <code>res1</code> and <code>res2</code> are now <code>Future</code> objects, which is why you can access the result attribute. <code>wait()</code> works the same in both cases and the results in both codes are equally generated, it's just that your function hadn't return the correct objects.</p>
<p>If you want to modify your first example, the <code>Future</code> objects that you wanted are returned as the first item by <code>wait()</code>.</p>
<pre><code>async def do_batch_work():
    res1 = do_work(100000)
    res2 = do_work(100)
    (res1, res2), _ = await asyncio.wait([res1, res2])
    return res1, res2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code is quite good - it works exactly as it should, and I think asyncio still doesn't have some strong standards being developed. But if you just want to run coroutines in parallel, there is another way, and it is seen more frequently.</p>
<p>It is <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="nofollow noreferrer">asyncio.gather()</a>.</p>
<p>Gather's doc is quite self-explanatory, it returns future with list of results, and here is an example of your code with it:</p>
<pre><code>async def do_batch_work():
    res1 = do_work(100000)
    res2 = do_work(100)
    return await asyncio.gather(res1, res2)


def main():
    loop = asyncio.get_event_loop()
    res1, res2 = loop.run_until_complete(do_batch_work())
    print(res1)
    print(res2)
    loop.close()
</code></pre>
</div>
