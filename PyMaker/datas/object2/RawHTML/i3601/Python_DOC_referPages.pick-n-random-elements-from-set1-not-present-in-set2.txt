<div class="post-text" itemprop="text">
<p>I would like to pick <code>n</code> random elements from <code>set1</code> that are not present in <code>set2</code>, if there are <code>n</code> such elements. If there are not, only those that are different should be returned or an empty set in the worst case.</p>
<p>Example 1:</p>
<ul>
<li>input: <code>n=2</code>, <code>set1={0,1,2,3,4,5,6,7}</code>, <code>set2={0,2,4,6}</code></li>
<li>example possible output: <code>{1,5}</code> (other possible outputs: <code>{1,3}</code>, <code>{1,7}</code>, <code>{3,5}</code>, <code>{3,7}</code>, <code>{5,7}</code>)</li>
</ul>
<p>Example 2:</p>
<ul>
<li>input: <code>n=5</code>, <code>set1={0,1,2,3,4,5,6,7}</code>, <code>set2={0,2,4,6}</code></li>
<li>single possible output: <code>{1,3,5,7}</code> since there are only 4 choices and number of elements to choose is 5</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Create a set of unique values and return either <code>n</code> random elements from it, or if <code>n</code> is larger than the population return all elements:</p>
<pre><code>def random_unique(x, y, n):
    ''' returns n random elements from set x not found in set y '''
    unique = x - y
    return set(random.sample(unique, min(n, len(unique))))
</code></pre>
<p>In action:</p>
<pre><code>x = {0, 1, 2, 3, 4, 5, 6, 7}    
y = {0, 2, 4, 6}

random_unique(x, y, 2)
{3, 5}

random_unique(x, y, 10)
{1, 3, 5, 7}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In two lines (we could make it one, but it's a little ugly), using sets and <a href="https://docs.python.org/3/library/random.html#random.sample" rel="nofollow noreferrer"><code>random.sample</code></a>:</p>
<pre><code>diff = set(list1).difference(list2)
random.sample(diff, min(len(diff), n))
</code></pre>
<p>Original solution (preserving duplicates in <code>list1</code>, as well as order, which doesn't really matter for random samples):</p>
<pre><code>diff = [x for x in list1 if x not in set(list2)]
random.sample(diff, min(len(diff), n))
</code></pre>
<p>If you don't care about preserving duplicates, then set difference is indeed the way to go. Checking the timing between the two implementations with the following:</p>
<pre><code>list1 = np.arange(10000)
list2 = np.random.randint(0, 10000, 1000)
</code></pre>
<p>we get:</p>
<ul>
<li>set difference: <code>1.15 ms ± 58 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</code></li>
<li>list comprehension: <code>1.13 s ± 44.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></li>
<li>list comprehension with set pre-defined: <code>1.47 ms ± 24.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</code></li>
</ul>
<p>That's a factor of 1000 faster for sets! Not much of a difference between <code>set.difference</code> and the list comprehension though if we have already built the set, but what difference is there appears to be significant (those standard deviations are tiny!).</p>
</div>
<span class="comment-copy">Are the elements in the lists always unique? If so, the first step is to convert your lists to sets (with <code>set(list1)</code> and <code>set(list2)</code>) and then do a set difference.</span>
<span class="comment-copy">Good point, let me change the question to use sets instead.</span>
<span class="comment-copy">But converting the list to a set is also a valid approach.</span>
<span class="comment-copy">@KrzysztofSłowiński the question has been raised because the usage of set depends on whether or not you want the repeating elements, if there are any, to stay.</span>
<span class="comment-copy">@KrzysztofSłowiński I think mentioning the changes you have made in your question will help the answers already given to stay relevant.</span>
<span class="comment-copy">This solution will loose duplicates in first list</span>
<span class="comment-copy">Yes, he will need to clarify his question if wants to have duplicates in list 1</span>
<span class="comment-copy">Quote (Krzysztof Słowiński): "But converting the list to a set is also a valid approach"... shouldn't be a problem here</span>
<span class="comment-copy">If you are converting the list to a set, then using set difference <code>set1 - set2</code> makes things simple</span>
<span class="comment-copy">I don't think converting everithing to set is correct because in first list there can be repeated elements that are lost in conversion to set. list1=[1,2,2,3,4,5] l2=[3,5], using set output will be [1,2,4], keeping first as list [1,2,2,4]</span>
<span class="comment-copy">@DDS comment is correct. You only want to convert the list you are comparing <i>against</i> to a set. You do this because checking membership of a set is faster than checking membership of a list (<code>O(1)</code> vs. <code>O(n)</code>), and converting is fast. If you don't want to preserve possible duplicates (or order), then you can convert both to a set.</span>
<span class="comment-copy">True. The question is not clear on that part, whether the duplicates are to be considered or not.</span>
<span class="comment-copy">@RaviTeja granted! I see you and others have asked for clarification. I will leave my answer as-is. If OP doesn't care about duplicates, then this is not the way to go.</span>
