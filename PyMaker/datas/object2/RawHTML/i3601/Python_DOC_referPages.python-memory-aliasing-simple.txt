<div class="post-text" itemprop="text">
<p>I wonder how and why this happens. Can someone explain this?</p>
<p><a href="https://i.stack.imgur.com/FjmY2.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/FjmY2.png"/></a></p>
<p>Contact is my own class that I made in my editor.</p>
<p>What should I do if I want to make them point to the same memory address?</p>
</div>
<div class="post-text" itemprop="text">
<p>Each time you call <code>Contact()</code> a new instance is created, even if you pass it identical args. How is Python to know that you want contacts with the same args to actually be the same object? In general, that would not be desirable. If you want two names for the same instance, just do a simple assignment, eg</p>
<pre><code>c1 = Contact('647-000-000', 'Andy')
c2 = c1
</code></pre>
<p>If you <em>really</em> do want two (or more) calls to <code>Contact()</code> with identical args to return the same object you can give the <code>__new__</code> constructor a cache, eg <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a>. Here's a short demo.</p>
<pre><code>from functools import lru_cache

class Contact:
    @lru_cache(None)
    def __new__(cls, *args):
        return super().__new__(cls)

    def __init__(self, phone, name):
        self.phone = phone
        self.name = name

    def __str__(self):
        return f'Contact({self.phone}, {self.name})'

c1 = Contact('647-000-000', 'Andy')
c2 = Contact('647-000-001', 'Amos')
c3 = Contact('647-000-000', 'Andy')
for c in (c1, c2, c3):
    print(c, repr(c))
</code></pre>
<p><strong>output</strong></p>
<pre><code>Contact(647-000-000, Andy) &lt;__main__.Contact object at 0xb7285d4c&gt;
Contact(647-000-001, Amos) &lt;__main__.Contact object at 0xb7285dac&gt;
Contact(647-000-000, Andy) &lt;__main__.Contact object at 0xb7285d4c&gt;
</code></pre>
<p>When you call <code>Contact</code>, its <code>__new__</code> method is called to construct the new instance object. That object is then passed to <code>__init__</code> to get initialised. In most classes, the <code>__new__</code> method isn't defined, so the <code>__new__</code> method of the parent class is called, normally that's the default <code>__new__</code> inherited from the <code>object</code> base class. </p>
<p>In the above code we define <code>__new__</code> and decorate it with <code>lru_cache</code>. So when we call <code>Contact()</code> the <code>Contact</code> type and any other args get processed by <code>lru_cache</code>, which maintains an invisible dictionary of all <code>Contact</code> instances we create, keyed by the args passed to <code>__new__</code> (including the the <code>Contact</code> type). If that key is in the dict, the corresponding instance gets returned by <code>__new__</code>. Otherwise, a new <code>Contact</code> is allocated and added to the <code>dict</code>. In either case, the instance is then passed to <code>__init__</code> for initialization.</p>
<hr/>
<p>The above code is a proof of concept. I do <em>not</em> recommend doing this in real code. The invisible <code>dict</code> maintained by <code>lru_cache</code> keeps a reference to every contact you create, so they will not get deleted when they (appear to) go out of scope, even if you pass them to <code>del</code>, until the program terminates. To force a contact to be deleted you need to clear it from the cache, you could do that with:</p>
<pre><code>Contact.__new__.cache_clear()
</code></pre>
<p>but of course that clears the entire cache.</p>
</div>
<div class="post-text" itemprop="text">
<p>Defining equivalence (<code>==</code>) for objects is pretty simple by implementing <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer"><code>__eq__</code></a> (docs linked):</p>
<pre><code>class Contact:
    def __init__(self, phone, name):
        self.phone = phone
        self.name = name

    def __eq__(self, other):
        return (self.phone == other.phone) and (self.name == other.name)

c1 = Contact('647-000-000', 'Andy')
print(c1 == Contact('647-000-000', 'Andy'))     # True
</code></pre>
<p>Here, <code>__eq__</code> is a method accepting one argument (the thing it's being compared to) and should return either <code>True</code> or <code>False</code> (or something coercible to a boolean).  This is a very simple and "flimsy" implementation as things like <code>c1 == "string"</code> will throw an error, but it demonstrates the idea.</p>
<p>However, there is no magic method you can implement to define reference equality (<code>is</code>).  In general you should think of <code>is</code> being used to test whether they're <em>the exact same</em> object, and <code>==</code> being used to test whether the two objects are <em>equivalent</em>.</p>
<p><sub>[1] Yes, it is nonetheless sort of possible with caching and either using metaclasses or <code>__new__</code>, </sub></p>
</div>
<div class="post-text" itemprop="text">
<p>Alright so basically Python has aliasing. And to check if 2 objects are an alias to each other you write</p>
<pre><code>obj1 is obj2 
</code></pre>
<p>If it returns True then they are an alias. Well, basically Python checks for the two objects id. The above statement is equivalent to:</p>
<pre><code>id(obj1) == id(obj2)
</code></pre>
<p><code>id(object)</code> is used to evaluate the address of an object in the memory.</p>
<p>When your writing <code>b is Contact('647-000-000', 'Andy')</code>
b already got an address in memory but when you're comparing it with <code>Contact('647-000-000', 'Andy')</code>, <code>Contact('647-000-000', 'Andy')</code> has a different address in memory. </p>
<p>I don't understand why are you comparing the whole class instead of the attributes.</p>
<p><code>b.number == '647-000-000'</code> and <code>b.name == 'Andy'</code> will solve your problem.</p>
</div>
<span class="comment-copy">Could you please copy and paste your code, rather than use an image.  It makes it much easier to run.</span>
<span class="comment-copy">Every "call" to <code>Contact</code> creates a new object - they will reside in different parts of memory</span>
<span class="comment-copy">It's possible to do that, but what's the point for that class? How often are you going to create 2 or more identical <code>Contact</code> instances?</span>
<span class="comment-copy">use data model to comapre in contact class for checking use this as example  x==y calls x.__eq__(y),</span>
<span class="comment-copy">Also, what Simon says. Please see <a href="http://meta.stackoverflow.com/questions/285551/why-may-i-not-upload-images-of-code-on-so-when-asking-a-question">Why may I not upload images of code on SO when asking a question?</a></span>
<span class="comment-copy">While I applaud the work that went into it, I <i>still</i> don't think that this is "the right answer", despite being explicitly asked for.  It's rarely needed, and when one <i>knows</i> it's needed they'll generally know how to accomplish it.  Anyway, +1</span>
<span class="comment-copy">Thanks, @jedwards . I <i>did</i> say "I do not recommend doing this in real code". I guess there may be <i>some</i> legitimate applications for this sort of thing, but I don't see the point of doing it with this Contacts class, as I alluded to in my comment on the question, but I guess it's just a simple example class for the sake of the question.</span>
<span class="comment-copy">I misspoke too, I should have said "the right approach" -- because it's certainly the right answer -- and may prove useful for readers.</span>
<span class="comment-copy">I appreciate your answer. To be honest, since I'm such a newbie, I couldn't get 100% of this now. But I promise that I will read thoroughly several times and will fully understand this. Thanks.</span>
<span class="comment-copy">I'm guessing my footnote wasn't enough to avoid the downvote, but I really didn't (and still don't) think that going into the (expertly crafted) detail that PM2 Ring did is worth it -- it's unlikely "the right answer", despite being explicitly asked for.</span>
<span class="comment-copy">The OP wants <code>Contact</code> to not create duplicate instances when passed the same args as an existing contact, instead he wants the original instance to be returned.</span>
<span class="comment-copy">He wanted to know how to make them point to the same memory address.</span>
<span class="comment-copy">He doesn't simply want instances with the same args to compare as equal, he wants them to be the same instance. And the only way to do that is to return the original instance.</span>
