<div class="post-text" itemprop="text">
<p>Here is my starting point. This works as is.</p>
<pre><code>l1 = [1, 2, 3, 4]
l2 = [5, 6, 7, 8]
l3 = [9, 10, 11, 12]


def interleave(iterable1, iterable2):
    for item1, item2 in zip(iterable1, iterable2):
        yield item1
        yield item2


print(interleave(l1, l2))
print('-' * 30)
print(list(interleave(l1, l2)))
</code></pre>
<p>If I want to expand it to use all three lists, I can do this:</p>
<pre><code>l1 = [1, 2, 3, 4]
l2 = [5, 6, 7, 8]
l3 = [9, 10, 11, 12]


def interleave(*args):
    for item1, item2, item3 in zip(*args):
        yield item1
        yield item2
        yield item3


print(interleave(l1, l2, l3))
print('-' * 30)
print(list(interleave(l1, l2, l3)))
</code></pre>
<p>However, I 'solved' the issue of receiving any number of input iterables using
*args, but my item assignment is still manual.</p>
<p>I want to be able to say:</p>
<pre><code>def interleave(*args):
    for *items in zip(*args):
        yield items
</code></pre>
<p>To allow me to unpack any number of input variables into *items, but I get this error:
    <code>SyntaxError: starred assignment target must be in a list or tuple</code></p>
<p>I don't want to say <code>*items = &lt;something&gt;</code>.  I want to have *items receive any number of input variables.</p>
<p>If I have six lists I don't want to say item1, item2, ..., item6, followed by the same number of yields.</p>
<p>That really isn't very scalable.</p>
<p>Is there a way to do what I am after?</p>
</div>
<div class="post-text" itemprop="text">
<p>For Python prior to 3.3, use a nested for loop.</p>
<pre><code>def interleave(*args):
    for items in zip(*args):
        for item in items:
            yield item
</code></pre>
<p>For Python 3.3+ you can use <code>yield from</code> for <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow noreferrer">generator delegation</a> which is syntactical sugar for the above.</p>
<pre><code>def interleave(*args):
    for items in zip(*args):
        yield from items
</code></pre>
<p>Or finally, if you need a more general solution that permits lists of different lengths, use the <code>roundrobin</code> function from the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a>.</p>
<pre><code>def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    num_active = len(iterables)
    nexts = cycle(iter(it).__next__ for it in iterables)
    while num_active:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            # Remove the iterator we just exhausted from the cycle.
            num_active -= 1
            nexts = cycle(islice(nexts, num_active))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A nested loop?</p>
<pre><code>def interleave(*args):
    for items in zip(*args): 
        for item in items:
            yield items
</code></pre>
</div>
<span class="comment-copy">Maybe <code>for items in zip(*args): yield from items</code>?</span>
<span class="comment-copy">That was it.  'yield from'.  Time to look it up.</span>
<span class="comment-copy">You can just use <code>from itertools import chain; chain.from_iterable(zip(*args))</code> you know.</span>
