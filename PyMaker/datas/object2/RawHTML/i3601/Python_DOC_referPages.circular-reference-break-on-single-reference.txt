<div class="post-text" itemprop="text">
<p><strong>TL;DR</strong> Is there any way to create a weak reference that will call a callback upon having 1 strong reference left instead of 0?</p>
<hr/>
<p>For those who think it's an X Y problem, here's the long explanation:</p>
<p>I have quite a challenging issue that I'm trying to solve with my code.</p>
<p>Suppose we have an instance of some class Foo, and a different class Bar which references the instance as it uses it:</p>
<pre><code>class Foo:  # Can be anything
    pass

class Bar:
    """I must hold the instance in order to do stuff"""
    def __init__(self, inst):
        self.inst = inst

foo_to_bar = {}
def get_bar(foo):
    """Creates Bar if one doesn't exist"""
    return foo_to_bar.setdefault(foo, Bar(foo))

# We can either have
bar = get_foobar(Foo())
# Bar must hold a strong reference to foo

# Or
foo = Foo()
bar = get_foobar(foo)
bar2 = get_foobar(foo)  # Same Bar
del bar
del bar2
bar3 = get_foobar(foo)  # Same Bar
# In this case, as long as foo exists, we want the same bar to show up,
# therefore, foo must in some way hold a strong reference back to bar
</code></pre>
<p>Now here's the tricky part: You can solve this issue using a circular reference, where <code>foo</code> references <code>bar</code> and <code>bar</code> references <code>foo</code>, but hey, what's the fun part in that? It will take longer to clean up, will not work in case Foo defines <code>__slots__</code> and generally will be a poor solution.</p>
<p>Is there any way, I can create a <code>foo_to_bar</code> mapping that cleans upon a <strong>single</strong> reference to both <code>foo</code> and <code>bar</code>? In essence:</p>
<pre><code>import weakref
foo_to_bar = weakref.WeakKeyDictionary()
# If bar is referenced only once (as the dict value) and foo is
# referenced only once (from bar.inst) their mapping will be cleared out
</code></pre>
<p>This way it can work perfectly as having <code>foo</code> outside the function makes sure <code>bar</code> is still there (I might require <code>__slots__</code> on <code>Foo</code> to support <code>__weakref__</code>) and having <code>bar</code> outside the function results in <code>foo</code> still being there (because of the strong reference in <code>Bar</code>).</p>
<p><code>WeakKeyDictionary</code> does not work beacuse <code>{weakref.ref(inst): bar.inst}</code> will cause circular reference.</p>
<p>Alternatively, is there any way to hook into the reference counting mechanism (in order to clean when both objects get to 1 reference each) without incurring significant overhead?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are overthinking this. You don't need to track if there is just one reference  left. Your mistake is to create a circular reference in the first place.</p>
<p>Store <code>_BarInner</code> objects in your cache, that have <em>no reference to <code>Foo</code> instances</em>. Upon access to the mapping, return a lightweight <code>Bar</code> instance that contains both the <code>_BarInner</code> and <code>Foo</code> references:</p>
<pre><code>from weakref import WeakKeyDictionary
from collections.abc import Mapping


class Foo:
    pass


class Bar:
    """I must hold the instance in order to do stuff"""
    def __init__(self, inst, inner):
        self._inst = inst
        self._inner = inner

    # Access to interesting stuff is proxied on to the inner object,
    # with the instance information included *as needed*.
    @property
    def spam(self):
        self.inner.spam(self.inst)


class _BarInner:
    """The actual data you want to cache"""
    def spam(self, instance):
        # do something with instance, but *do not store any references to that
        # object on self*.


class BarMapping(Mapping):
    def __init__(self):
        self._mapping = WeakKeyDictionary()

    def __getitem__(self, inst):
        inner = self._mapping.get(inst)
        if inner is None:
            inner = self._mapping[inst] = _BarInner()
        return Bar(inst, inner)
</code></pre>
<p>Translating this to the <a href="https://github.com/bharel/bdict/blob/master/bdict/__init__.py" rel="nofollow noreferrer"><code>bdict</code> project</a> linked in the comments, you can simplify things drastically:</p>
<ul>
<li>Don't worry about lack of support for weak references in projects. Document that your project will only support per-instance data on types that have a <code>__weakref__</code> attribute. That's enough.</li>
<li>Don't distinguish between slots and no-slots types. Always store per-instance data away from the instances. This lets you simplify your code.</li>
<li>The same goes for the 'strong' and 'autocache' flags. The flyweight should always keep a strong reference. Per-instance data should always be stored. </li>
<li>Use a single class for the descriptor return value. The <code>ClassBoundDict</code> type is all you need. Store the <code>instance</code> and <code>owner</code> data passed to <code>__get__</code> in that object, and vary behaviour in <code>__setitem__</code> accordingly.</li>
<li>Look at <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer"><code>collections.ChainMap()</code></a> to encapsulate access to the class and instance mappings for read access.</li>
</ul>
</div>
<span class="comment-copy">Comments are not for extended discussion; this conversation has been <a href="https://chat.stackoverflow.com/rooms/173630/discussion-on-question-by-bharel-circular-reference-break-on-single-reference">moved to chat</a>.</span>
<span class="comment-copy">I guess I tried optimizing too much and turned the code a little ugly. While I did know <code>ChainMap</code> beforehand, I haven't thought of always accessing the original <code>BDict</code>. It causes a little bit of overhead but creates a clean codebase. Thanks mate, you're a great teacher.</span>
