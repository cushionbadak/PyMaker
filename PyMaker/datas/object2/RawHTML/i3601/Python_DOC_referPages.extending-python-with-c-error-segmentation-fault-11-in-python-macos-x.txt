<div class="post-text" itemprop="text">
<p>I have written an extension module in C with the name <strong>extmodule.c</strong> and the code for it is as follows:</p>
<pre><code>#include &lt;Python.h&gt;

//Define a new exception object for our module
static PyObject *extError;

static PyObject* ext_cpu(PyObject* self, PyObject *args)
{
  int pid;
  int sts=0;

  //We expect at least 1 argument to this function
  if(!PyArg_ParseTuple(args, "i", &amp;pid))
  {
    return NULL;
  }


  printf("Hello, from C World! Pid: %i", pid);
  sts=pid;

  return Py_BuildValue("i", sts);
}

static PyMethodDef ext_methods[] = {
  //PythonName, C-FunctionName, argument_presentation, description
  {"cpu", ext_cpu, METH_VARARGS, "Print cpu consumption of a particular process with pid"}
};

PyMODINIT_FUNC
PyInit_ext(void)
{
    PyObject *m;

    m = PyModule_Create(&amp;ext_methods);
    if (m == NULL)
        return NULL;

    extError = PyErr_NewException("spam.error", NULL, NULL);
    Py_INCREF(extError);
    PyModule_AddObject(m, "error", extError);
    return m;
}
</code></pre>
<p>After that I have created a <strong>setup.py</strong> to build and install the extension file in my python program and the code for the setup.py is as follows:</p>
<pre><code>from distutils.core import setup, Extension

module1 = Extension('ext',
    include_dirs = ['/usr/local/include'],
    libraries = ['pthread'],
    sources = ['extmodule.c'])

setup (name = 'ext',
    version = '1.0',
    description = 'This is a C extension for Python program',
    author = 'Somdip Dey',
    url = '',
    ext_modules = [module1])
</code></pre>
<p>Now on the command prompt I have built the setup.py using the following commands:</p>
<pre><code>&gt;&gt; python setup.py build
</code></pre>
<blockquote>
<p>running build 
  running build_ext</p>
<p>building 'ext' extension gcc
  -Wno-unused-result -Wsign-compare -Wunreachable-code -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -I/Users/somdipdey/ anaconda3/include -arch x86_64 -I/Users/somdipdey/anaconda3/include
  -arch x86_64 -I/usr/local/include -I/Users/somdipdey/anaco nda3/include/python3.6m -c extmodule.c -o
  build/temp.macosx-10.7-x86_64-3.6/extmodule.o extmodule.c:34:25:
  warning: incompatible pointer types passing 'PyMethodDef (*)[1]' to
  parameter of type
        'struct PyModuleDef *' [-Wincompatible-pointer-types]
      m = PyModule_Create(&amp;ext_methods);
  /Users/somdipdey/anaconda3/include/python3.6m/modsupport.h:158:26:
  note: expanded from macro 'PyModule_Create'
          PyModule_Create2(module, PYTHON_API_VERSION)
                           ^~~~~~ /Users/somdipdey/anaconda3/include/python3.6m/modsupport.h:150:60:
  note: passing argument to parameter here PyAPI_FUNC(PyObject <em>)
  PyModule_Create2(struct PyModuleDef</em>,
                                                             ^ 1 warning generated. gcc -bundle -undefined dynamic_lookup
  -L/Users/somdipdey/anaconda3/lib -arch x86_64 -L/Users/somdipdey/anaconda3/lib -arch x86
  _64 -arch x86_64 build/temp.macosx-10.7-x86_64-3.6/extmodule.o -L/Users/somdipdey/anaconda3/lib -lpthread -o build/lib.macosx-
  10.7-x86_64-3.6/ext.cpython-36m-darwin.so</p>
</blockquote>
<pre><code>&gt;&gt; python setup.py install
</code></pre>
<p>The install command worked properly but the build one gave 1 warning. Now when I am trying to <strong>import ext</strong> in my python program and use the function <strong>ext.cpu(integer_value)</strong>, the program is giving me the following error:</p>
<blockquote>
<p>Segmentation Fault: 11</p>
</blockquote>
<p>Any idea what might be causing the issue and how to get rid of it?</p>
</div>
<div class="post-text" itemprop="text">
<p>The warning is telling you exactly what's wrong: you're passing a <code>PyMethodDef (*)[1]</code> to <code>PyModule_Create</code>, when it expected a <code>PyModuleDef *</code>. Those are completely unrelated types. The segfault you're getting is like the C version of a <code>TypeError</code>.</p>
<p><a href="https://docs.python.org/3/extending/extending.html#the-module-s-method-table-and-initialization-function" rel="nofollow noreferrer">You need to create a module definition table</a>, and pass <em>that</em> to <a href="https://docs.python.org/3/c-api/module.html#c.PyModule_Create" rel="nofollow noreferrer"><code>PyModule_Create</code></a>.</p>
<hr/>
<p>If you fix that, you may or may not have another segfault, or garbage data, or a mysterious segfault on exit, because your method table is missing the empty row at the end. C arrays don't know their size the way Python lists do, so code that uses them either needs to pass around the size in a separate variable, or use some "sentinel" value in the last slot. <code>PyMethodDef</code> uses the latter solution.</p>
<hr/>
<p>So:</p>
<pre><code>static PyMethodDef ext_methods[] = {
  //PythonName, C-FunctionName, argument_presentation, description
  {"cpu", ext_cpu, METH_VARARGS, "Print cpu consumption of a particular process with pid"},
  {NULL, NULL, 0, NULL}
};

static struct PyModuleDef ext_module = {
  PyModuleDef_HEAD_INIT,
  "ext",
  "Extension module that does stuff",
  -1,
  ext_methods
};

PyMODINIT_FUNC
PyInit_ext(void)
{
    PyObject *m;

    m = PyModule_Create(&amp;ext_module);
    // the rest is the same as before
</code></pre>
<p>With those changes, your module builds without warnings, and:</p>
<pre><code>&gt;&gt;&gt; import ext
&gt;&gt;&gt; ext.cpu(23)
Hello, from C World! Pid: 23
&gt;&gt;&gt; ^D
</code></pre>
<p>… everything works fine.</p>
<p>(Well, there might be a memory leak in there, but that's a separate issue…)</p>
</div>
<span class="comment-copy"><code>ncompatible pointer types passing 'PyMethodDef (*)[1]' to &gt; parameter of type &gt;       'struct PyModuleDef *'</code> that's a serious warning. Means that the underlying code will read a pymodule but you pass a pymethod...</span>
<span class="comment-copy">@Jean-FrançoisFabre I am following a tutorial and wrote the code, so I have no prior knowledge in how to achieve that. Do you please happen to know how I can work around it? The tutorial: <a href="https://www.youtube.com/watch?v=s6cvSkbWG3s" rel="nofollow noreferrer">youtube.com/watch?v=s6cvSkbWG3s</a></span>
<span class="comment-copy">You need to read <a href="https://docs.python.org/3/extending/extending.html" rel="nofollow noreferrer">the actual docs</a>. Also, while it's worth struggling through this once just to see what all the pieces are, unless you really like low-level C programming, you should seriously consider writing your extensions in Cython, or at least in a slightly higher-level language with a library that can automate all the annoying stuff for you, like C++ with PyCxx, Boost, or CPyExt, D with Pyd, Rust with rust-python, etc. No more screwing around with hard-to-debug tables, refcount headaches, etc.</span>
<span class="comment-copy">Alternatively, in some cases it's easier to write a C library with a plain old C API, built as a plain old dylib/so/dll, and then use either <code>cffi</code> or <code>ctypes</code> to wrap it from Python, or a library like SWIG to build a wrapper automatically.</span>
<span class="comment-copy">@abarnert I am completely new to these stuff. Was a C# programmer but now came to C domain. On top the reason for doing low-level C programming is to access each performance counters of the hardware and hence building c extension programs to be able to use it from python program (I am more comfortable using python than C for sure). Anyhow, do you think I can use Cython for such low level C programming?</span>
