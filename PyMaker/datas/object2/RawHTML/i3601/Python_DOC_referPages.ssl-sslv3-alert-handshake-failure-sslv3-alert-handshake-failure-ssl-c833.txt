<div class="post-text" itemprop="text">
<p>I have a simple TLS client in python running in Ubuntu 18.04 and openssl version 1.1.0g. The client supports a single ciphersuite. I get an error when trying to connect to a TLS 1.0 server. The cipher suite is not supported by the server. I know that the reason for the error is most likely due to lack of ciphersuite mismatch but I am looking for a more meaningful error for the user in this case. The error I am getting at the moment is pointing to SSLv3 which neither the client nor the server has anything to do with SSLv3. The client disables SSLv3 and the server as well. This is the error :</p>
<pre><code>[SSL: SSLV3_ALERT_HANDSHAKE_FAILURE] sslv3 alert handshake failure (_ssl.c:833) 
</code></pre>
<p>My question is: I need a better error message says for example (lack of ciphersuite mismatch or something like that is relevant to ciphersuite issue). Is there any? Of course I could write my own message but the socket connection can fail for various reasons and I can not make a general error that always says "ciphersuite mismatch".</p>
<p>This is the client script:</p>
<pre><code>import socket,ssl
import itertools

context = ssl.SSLContext()

context.verify_mode = ssl.CERT_NONE
context.check_hostname = False

ciphers = "ECDHE-ECDSA-AES128-GCM-SHA256"
context.set_ciphers(ciphers)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

domainName = "privatedomain.com"
sslSocket = context.wrap_socket(s, server_hostname = domainName)

try:
    sslSocket.connect((domainName, 443))
except (ssl.SSLError, ssl.SSLEOFError, ssl.CertificateError,ssl.SSLSyscallError, ssl.SSLWantWriteError, ssl.SSLWantReadError,ssl.SSLZeroReturnError) as e:
    print("Error: ",e)
sslSocket.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the client's view, it is not possible to get another message than the one sent by the server, which is <code>handshake failure</code> in your case. The error message are, for example, documented in <a href="https://tools.ietf.org/html/rfc2246" rel="nofollow noreferrer">RFC 2246</a> 7.2.</p>
<p>The reason why you see SSLv3 in your message, is that you probably send a SSLv3 Hello, which is something allowed to negotiate a TLS 1.0 or later protocol.</p>
</div>
<div class="post-text" itemprop="text">
<p>Late answer but hopefully helpful . . .</p>
<p>Both client and server must agree on the transport layer version for the connection to be successful.  Consider meeting a person for the first time.  The person (client) extends their hand to you (server) in a gesture of greeting.  If you just saw the person come out of the latrine without washing hands and you see (and/or smell) something undesirable, you will not extend your hand in return.  </p>
<p>It is similar with an SSL handshake.  The client says "Hey I'd like to communicate via TLS v1.0".  The savvy admin for the server knows TLS v1.0 is not secure and they have disabled it on the server--so the server responds to the client, "No, but how about version 1.3?" (ie: "Go wash your hands first").  If the client accepts (washes hands), the handshake is accepted and the connection is established.  If the client refuses, the server keeps asking for lower versions ("How about a gallon of Purell then?") until the client accepts or the server has no other versions to offer (walks away).</p>
<p>Basically, the handshake is designed to use the highest version that both the client and server support.</p>
<p>This page has a nice table of versions for client &amp; server (about half way down in the "SSL Contexts" section:</p>
<pre><code> https://docs.python.org/3/library/ssl.html
</code></pre>
<p>Note that TLS v1.0 is no longer considered secure (Google "POODLE attack").  If your server supports it, disable it ASAP.</p>
</div>
<span class="comment-copy">Thanks. I do not get what you mean by <code>The reason why you see SSLv3 in your message, is that you probably send a SSLv3 Hello, which is something allowed to negotiate a TLS 1.0 or later protocol.</code> but I am disabling SSLv3 manually using <code>ssl.OP_NO_SSLv3</code> in the SSL context.</span>
<span class="comment-copy">At the very beginning, the client starts the SSL handshake with a ClientHello message, and this one has its own version which is independent of the SSL/TLS version that will be negotiated for the "real" data exchange. <b>ssl.OP_NO_SSLv3</b> disables SSLv3 for the data exchange for sure, but I am not sure it will change the ClientHello version. The Python doc doesn't talk about it clearly. Take a capture and share it.</span>
