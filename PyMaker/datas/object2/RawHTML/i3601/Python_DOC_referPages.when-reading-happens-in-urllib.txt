<div class="post-text" itemprop="text">
<p>Consider the following code:</p>
<pre><code>r = urllib.request.urlopen("https://example.com")
print(r.read())  # Does reading occurs at this point?
</code></pre>
<p>My question is when does reading occur at the time of <code>urlopen()</code> is called or <code>read()</code> is called.</p>
</div>
<div class="post-text" itemprop="text">
<p>After reading again the doc and making a few tests, I can say that reading can occur in both.</p>
<p><code>urlopen</code> is a blocking call, and actually waits for the end of the headers part. At that point, the code and headers attributes are available.</p>
<p>But if the server is slooooow, <code>urlopen</code> may return before all the data part has been received. In this case, <code>read(n)</code> may block if less than n bytes have been received, and <code>read()</code> will block until all the response has been received.</p>
<p>Code demonstrating that:</p>
<p>Server:</p>
<pre><code>class ReqHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        print("GOT", self.command)
        print("Headers", self.headers)
        self.wfile.write(b"HTTP/1.1 200 OK\r\n")
        time.sleep(2)
        self.wfile.write(b"Server: BaseHTTP/0.6 Python/3.6.2\r\n\
Date: Mon, 11 Jun 2018 15:47:00 GMT\r\n\r\n")
        time.sleep(2)
        self.wfile.write("""&lt;html&gt;
&lt;header&gt;&lt;title&gt;Test page&lt;/title&gt;&lt;/html&gt;
&lt;body&gt;&lt;h1&gt;Test&lt;/h1&gt;
&lt;p&gt;This is a simple test...&lt;/p&gt;""".encode())
        time.sleep(5)
        self.wfile.write("""&lt;p&gt;and here is the end of the page&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;""".encode())

server = http.server.HTTPServer(('localhost', 8080), ReqHandler)
server.handle_request()
</code></pre>
<p>Client:</p>
<pre><code>def ask():
    print(time.asctime())
    r = urllib.request.urlopen("http://localhost:8080/test_page")
    print(time.asctime())
    print(r.read(10))
    print(time.asctime())
    print(r.read())
    print(time.asctime())

ask()
</code></pre>
<p>And here is an example of the client side:</p>
<pre class="lang-none prettyprint-override"><code>Mon Jun 11 18:13:12 2018
Mon Jun 11 18:13:15 2018
b'&lt;html&gt;\n&lt;he'
Mon Jun 11 18:13:17 2018
b'ader&gt;&lt;title&gt;Test page&lt;/title&gt;&lt;/html&gt;\n&lt;body&gt;&lt;h1&gt;Test&lt;/h1&gt;\n&lt;p&gt;Ceci est un simple test&lt;/p&gt;&lt;p&gt;mais avec des charact\xe8res accentu\xe9s&lt;/p&gt;\n&lt;/body&gt;&lt;/html&gt;'
Mon Jun 11 18:13:22 2018
</code></pre>
<p>So:</p>
<ul>
<li>urlopen wait 3 seconds, up to the end of the header part</li>
<li>first read (<code>read(10)</code>) waits 2 seconds more for the first part of the message</li>
<li>second read (<code>read()</code>) waits 5 seconds more for the end of the message</li>
</ul>
</div>
<span class="comment-copy">Some links that might be useful: <a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen" rel="nofollow noreferrer">documentation on <code>urlopen</code></a> and <a href="https://docs.python.org/3/library/http.client.html#httpresponse-objects" rel="nofollow noreferrer">documentation on <code>HTTPResponse.read()</code></a>. I'm leaning towards <code>urlopen</code>, but their language is vague.</span>
<span class="comment-copy">Perhaps this could be answered with a little experimentation: in an interactive prompt, run line 1, then disable your internet connection, then run line 2. If you still get sensible output, this implies that your computer already read the contents of the page before line 2.</span>
<span class="comment-copy">I just did that and found it occurs at calling <code>urlopen()</code>.</span>
<span class="comment-copy">That would make the most sense. Python tries to simplify the common case into a one-liner. It enwraps the entire HTTP GET request and returns the response. I would suggest using the <code>with</code> environment to ensure resources are cleaned up after use. <a href="https://docs.python.org/3/library/urllib.request.html#examples" rel="nofollow noreferrer">Examples</a>.</span>
