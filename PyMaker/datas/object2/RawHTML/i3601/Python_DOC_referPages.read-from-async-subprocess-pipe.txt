<div class="post-text" itemprop="text">
<pre><code>return asyncio.create_subprocess_exec(*_cmd, stdout=asyncio.subprocess.PIPE, limit=2 ** 32, stderr=asyncio.subprocess.PIPE, loop=loop)
</code></pre>
<p>I use this code to create an async subprecess,then get message from stdout.</p>
<pre><code>data = await  p.stdout.read(n=height * width * 3)
</code></pre>
<p>EveryThing is good,what i read from pipe is a 2k jpg 2 fps，the Image byte size is 11059200,but the max size when i read is always 8192,So i try this to get one time.</p>
<pre><code>print("start1" + str(arrow.now()))
loop_size = int(height * width * 3 / 8192 + 1)
print(loop_size)
list = [await  p.stdout.read(n=height * width * 3) for _ in range(loop_size)]
print("start2" + str(arrow.now()))
data = b"".join(list)
print("end" + str(arrow.now()))
</code></pre>
<p>It seems OK.</p>
<blockquote>
<p>start22018-06-12T19:44:30.902742+08:00
  <br/>end2018-06-12T19:44:30.909693+08:00
  <br/>2018-06-12T19:44:30.916675+08:00</p>
</blockquote>
<p>If the pipe is transform big file,the process will not enable to handle data  immediately,So the program always broke.</p>
<p>I want to know,Why the packet receive from pipe is awlay 8192,Can I read like a normal Subprocess.Pipe.read(bufsize=width*height*3)?
Any Good Suggest for this Question?</p>
<p><a href="https://i.stack.imgur.com/93JgR.png" rel="nofollow noreferrer">the image</a></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>the Image byte size is 11059200,but the max size when i read is always 8192</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader.read" rel="nofollow noreferrer"><code>StreamReader.read</code></a> reads at most the specified number of bytes, but can return fewer bytes, as much as is returned by the underlying system call. This is normally a feature, because it allows you to process the data as it arrives, while still enforcing an upper bound on the amount of data kept in memory at once.</p>
<p>In your code you want to wait until the whole image is ready, which you can do by calling <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader.readexactly" rel="nofollow noreferrer"><code>readexactly</code></a> instead of <code>read</code>:</p>
<pre><code>data = await p.stdout.readexactly(height * width * 3)
</code></pre>
</div>
<span class="comment-copy">What's the point of using await if you're still waiting for it all to <code>join</code> it?  You can disable buffering for binary files, but without a change in program structure, I'm not sure it'd matter much.</span>
<span class="comment-copy">@jedwards <code>await</code> still makes sense because it allows other coroutines to run while the data is not available. The code is incorrect as written because there is no guarantee that the data will arrive in 8192-byte chunks; my answer provides a correct alternative.</span>
<span class="comment-copy">@user4815162342 actually, i try it on  windows10 ,the data chunk size is always 8192 and the data can be resolve as image.</span>
<span class="comment-copy">No argument here, my point was that there's no <i>guarantee</i> that their size will always be 8192. That kind of thing can be affected by implementation details of asyncio or of the program that writes to the pipe.</span>
<span class="comment-copy">Yes,you are right。before i ask this question , i tried this api .it always throw IncompleteReadError,But now it seems good.OK.maybe i add some code can make it work。</span>
<span class="comment-copy">@user4999758 <code>IncompleteReadError</code> will be raised if the pipe is closed before the whole message is produced. Perhaps you had a flawed image size calculation?</span>
