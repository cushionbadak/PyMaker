<div class="post-text" itemprop="text">
<p>If I have a list <code>test</code></p>
<pre><code>test = [i for i in range(20)]
print(test)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</code></pre>
<p>and I want to get the last 3 numbers every 5 numbers such that I get a list that looks like:</p>
<pre><code>[2, 3, 4, 7, 8, 9, 12, 13, 14, 17, 18, 19]
</code></pre>
<p>Is there a way to do this with list slicing? I can do it with a modulo function like</p>
<pre><code>[i for i in test if i % 5 &gt; 1]
</code></pre>
<p>But I'm wondering if there is a way to do this with list slicing? Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer">filter</a> function:</p>
<pre><code>list(filter(lambda x: x % 5 &gt; 1, test))  # [2, 3, 4, 7, 8, 9, 12, 13, 14, 17, 18, 19]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If ordering does not matter, you can try the following:</p>
<pre><code>test[2::5] + test[3::5] + test[4::5]
</code></pre>
<p>Or more generally speaking</p>
<pre><code> start = 2 #Number of indices to skip
 n = 5
 new_test = []
 while start &lt; 5:
     b.extend(test[start::n])
     start += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, but I very much doubt it will be faster than a simple list comprehension:</p>
<pre><code>from itertools import chain, zip_longest as zipl

def offset_modulo(l, x, n):
    sentinel = object()
    slices = (l[i::n] for i in range(x, n))
    iterable = chain.from_iterable(zipl(*slices, fillvalue=sentinel))
    return list(filter(lambda x: x is not sentinel, iterable))

print(offset_modulo(range(20), 2, 5))
# [2, 3, 4, 7, 8, 9, 12, 13, 14, 17, 18, 19]
print(offset_modulo(range(24), 2, 5))
# [2, 3, 4, 7, 8, 9, 12, 13, 14, 17, 18, 19, 22, 23]
</code></pre>
<p>Basically, this approach gets the list slices that represents each the index <code>i</code> such that <code>i % n &gt;= x</code>.  It then uses <code>zip</code> and <code>chain</code> to flatten those into the output.</p>
<p>Edit:  </p>
<p>A simpler way</p>
<pre><code>def offset(l, x, n):
    diff = n-x
    slices = (l[i:i+diff] for i in range(x, len(l), n))
    return list(chain.from_iterable(slices))

offset(range(20), 2, 5)
# [2, 3, 4, 7, 8, 9, 12, 13, 14, 17, 18, 19]
offset(range(24), 2, 5)
# [2, 3, 4, 7, 8, 9, 12, 13, 14, 17, 18, 19, 22, 23]
</code></pre>
<p>Where we get the slices of the adjacent elements we want, then <code>chain</code> those together.</p>
</div>
<div class="post-text" itemprop="text">
<p>I propose this solution:</p>
<pre><code>from functools import reduce
reduce(lambda x, y: x + y, zip(test[2::5], test[3::5], test[4::5]))
</code></pre>
<p>Testing with <code>timeit</code>, it is faster than filter and comprehension list (at least on my pc).</p>
<p>Here the code to carry out an execution time comparison:</p>
<pre><code>import numpy as np
import timeit

a = timeit.repeat('list(filter(lambda x: x % 5 &gt; 1, test))',
                  setup='from functools import reduce; test = list(range(20))',
                  repeat=20,
                  number=100000)

b = timeit.repeat('[i for i in test if i % 5 &gt; 1]',
                  repeat=20,
                  setup='test = list(range(20))',
                  number=100000)

c = timeit.repeat('reduce(lambda x, y: x + y, zip(test[2::5], test[3::5], test[4::5]))',
                  repeat=20,
                  setup='from functools import reduce;test = list(range(20))',
                  number=100000)

list(map(lambda x: print("{}:\t\t {} ({})".format(x[0], np.mean(x[1]), np.std(x[1]))),
         [("filter list", a),
          ('comprehension', b),
          ('reduce + zip', c)]))
</code></pre>
<p>The previous code produce the following results:</p>
<pre><code>filter list:         0.2983790061000036 (0.007463432805174629)
comprehension:       0.15115660065002884 (0.004455055805853705)
reduce + zip:        0.11976779574997636 (0.002553487341208172)
</code></pre>
<p>I hope this can help :)</p>
</div>
<span class="comment-copy">Is always the list an ordered sequence of numbers? Or can it contain random sequences of numbers?</span>
<span class="comment-copy">ordered sequence</span>
<span class="comment-copy">Thanks. It looks like the list comprehension I have above is slightly faster still. The list comprehension in my initial code runs at 3.74 µs and the filter method runs at 6.26 µs. I'm looking for a potentially faster method than the list comprehension I have above!</span>
