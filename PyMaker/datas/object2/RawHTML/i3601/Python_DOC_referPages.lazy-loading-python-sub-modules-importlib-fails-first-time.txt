<div class="post-text" itemprop="text">
<p>I'm experimenting with the idea of lazy-loading of symbols in a package's <code>__init__.py</code> by subclassing <code>ModuleType</code> and defining properties for each of the submodules. Accessing the symbol in the package namespace would trigger the import. I've got it working, but for some reason, my call to <code>import_module</code> fails on the first attempt and I don't understand why.</p>
<p>I have a minimal example. Assume a package like this:</p>
<pre><code>my_package:
    __init__.py
    m1.py
</code></pre>
<p>this is the <code>__init__.py</code></p>
<pre><code>import sys
import importlib
from types import ModuleType


class MyModule(ModuleType):
    @property
    def m1(self):
        try:
            _m1 = importlib.import_module('.m1', __package__)
        except AttributeError:
            print('second try ...')
            _m1 = importlib.import_module('.m1', __package__)

        return _m1


old = sys.modules[__name__]
new = MyModule(__name__)
new.__path__ = old.__path__

for k, v in list(old.__dict__.items()):
    new.__dict__[k] = v

sys.modules[__name__] = new
</code></pre>
<p>The <code>import_module</code> call always fails with an <code>AttributeError: module 'my_package' has no attribute 'm1'</code>. However, the second call always succeeds. In other words, when I do <code>my_package.m1</code> I always get <code>m1</code>, but it always prints <code>'second try ...'</code>.</p>
<p>Note, the behavior is dependent on python version. The call to <code>import_lib</code> works fine the first time on python2.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is the difference between python2 vs python3.</p>
<p>In python3, the <code>importlib.import_module</code> call ultimately ends up
<a href="https://github.com/python/cpython/blob/3.6/Lib/importlib/_bootstrap.py#L959" rel="nofollow noreferrer">here</a>
which is a call to <code>setattr</code>. Since you didn't define a <code>.setter</code> for
your property, you get the <code>AttributeError</code>.</p>
<p>In python2, the <code>importlib.import_module</code> call ends up
<a href="https://github.com/python/cpython/blob/2.7/Lib/importlib/__init__.py#L37" rel="nofollow noreferrer">here</a>
which is a call to the builtin <code>__import__</code> which presumably operates
directly on the module <code>__dict__</code>.</p>
<p>The only question is how in the world it ever works in python3. I
would have thought it would <em>always</em> resulted in a <code>AttributeError</code>.</p>
<p>Your code works fine as long as you make a <code>.setter</code>:</p>
<pre><code>@m1.setter
def m1(self, mod):
    self.__dict__['m1'] = mod
</code></pre>
<p>It actually turns out that the <code>.setter</code> can do anything at all,
including <code>pass</code> since you are unconditionally making the call to
<code>import_module</code>.</p>
<p>I would consider using the <code>.setattr</code> above and changing the getter to:</p>
<pre><code>@property
def m1(self):
    if not self.__dict__.get('m1'):
        self.__dict__['m1'] = importlib.import_module('.m1', __package__)
    return self.__dict__['m1']
</code></pre>
</div>
<span class="comment-copy">Did you inspect the traceback from the <code>AttributeError</code>? Re-write as <code>except AttributeError as error</code> and call the <code>logger.exception(error)</code>.</span>
<span class="comment-copy">Check this: <a href="https://docs.python.org/3/library/logging.html#logging.Logger.exception" rel="nofollow noreferrer">docs.python.org/3/library/logging.html#logging.Logger.exception</a>. Paste the traceback in your question. It'll certainly be helpful in debugging.</span>
<span class="comment-copy">@RenatoByrro yeah, of course. That's how I know to do the try/except in the first place. This is the exception: AttributeError                            Traceback (most recent call last) &lt;ipython-input-2-26b8e7fa2688&gt; in &lt;module&gt;() ----&gt; 1 my_package.m1  AttributeError: module 'my_package' has no attribute 'm1'</span>
<span class="comment-copy">@RenatoByrro, to clarify, the AttributeError is the whole traceback. There isn't anything more to post than what I put into the original question.</span>
<span class="comment-copy">Yes, I replicated and it really doesn't help much. By running it directly from CLI I get a slightly more verbose traceback, but nothing helpful. It's really strange, I guess it's related to how Python importing is structured under the hood...</span>
