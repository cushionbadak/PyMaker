<div class="post-text" itemprop="text">
<p>when inputting a text into the definition run_length_encoder the repititive letters should be compressed 
for example,
when aaabbac is inputted the output should be  ['a','a',3,'b','b',2,'a','c']
but for my code isn't compressing.</p>
<pre><code>def run_length_encoder(string):
#def compress(string):

    res = []

    count = 1

    #Add in first character
    res.append(string[0])

    #Iterate through loop, skipping last one
    for i in range(len(string)-1):
        if(string[i] == string[i+1]):
            count+=1
            res.append(string[i+1])
        else:
            if(count &gt; 1):
                #Ignore if no repeats
                res.append(count)
            res.append(string[i+1])
            count = 1
    #print last one
    if(count &gt; 1):
        res.append(str(count))
    return res
</code></pre>
<p>for example when abbbbaa is inputed,the output is supposed to be this ['a', 'b', 'b', 4, 'a', 'a', 2] instead i am getting this ['a', 'b', 'b', 'b', 'b', 4, 'a', 'a', '2']</p>
</div>
<div class="post-text" itemprop="text">
<p>you could also do something like:</p>
<pre><code>def run_length_encoder(str_):
    compressedString = ''
    countConsecutive = 0
    strLen = len(str_)
    for i in range(strLen):
        countConsecutive += 1
        if i + 1 &gt;= strLen or str_[i] != str_[i + 1]:
            compressedString += '' + str_[i] + str(countConsecutive)
            countConsecutive = 0

    return compressedString

sample = 'aaabbac'
result = list(run_length_encoder(sample))
print(result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">Itertools</a> loves you and wants you to be happy:</p>
<pre><code>from itertools import chain, groupby

def run_length_encoder(src):
    return list(
        # chain.from_iterable flattens the series of tuples we make inside the
        # loop into a single list.
        chain.from_iterable(
            # groupby returns an iterable (item, group) where group is an
            # iterable that yields a copy of `item` as many times as that item
            # appears consecutively in the input. Therefore, if you take the
            # length of `group`, you get the run length of `item`. This
            # whole expression then returns a series of (letter, count)
            # tuples.
            (letter, len(list(group))) for letter, group in groupby(src)
        )
    )


print(run_length_encoder("aajjjjiiiiohhkkkkkkkkhkkkk"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your logic needs fixing. Fixed edit to handle even and odd end cases.</p>
<pre><code>def run_length_encoder(string):
#def compress(string):

    res = []
    count = 1
    if(len(string) == 1):
        res.append(string[0])
        res.append(count)
        return res
    else:
        current = string[0]

        for i in range(1, len(string)):

            if(string[i] == current):
                count+=1
            else:
                res.append(current)
                res.append(count)
                current = string[i]
                count = 1
            i+=1
            if(i == len(string)):
                res.append(current)
                res.append(count)
        return res
</code></pre>
<p>Tested on strings:
string = "aaabbaadddaad" OUTPUT: ['a', 3, 'b', 2, 'a', 2, 'd', 3, 'a', 2, 'd', 1]
string = "aaabbaaddd" OUTPUT: ['a', 3, 'b', 2, 'a', 2, 'd', 3]
string = "aabccdd" OUTPUT: ['a', 2, 'b', 1, 'c', 2, 'd', 2]</p>
</div>
<div class="post-text" itemprop="text">
<p>A nice way to do this would be to use list comprehensions along with <code>itertools</code>. This can basically be achieved in the shortest number of lines of code as follows:</p>
<pre><code>from itertools import groupby
string = 'aajjjjiiiiohhkkkkkkkkhkkkkaaabsbbbbssssssssssbbaa'
result = list(sum([(k,sum(1 for i in g)) for k,g in groupby(string)], ()))
</code></pre>
<p>This results in:</p>
<pre><code>['a', 2, 'j', 4, 'i', 4, 'o', 1, 'h', 2, 'k', 8,
 'h', 1, 'k', 4, 'a', 3, 'b', 1, 's', 1, 'b', 4,
 's', 10, 'b', 2, 'a', 2]
</code></pre>
<p>You could use a function as follows:</p>
<pre><code>def run_length_encoding(string):
    return list(sum([(k,sum(1 for i in g)) for k,g in groupby(string)], ()))

result = run_length_encoding('aabbbccccddddd')
</code></pre>
<p><em>Explanation:</em></p>
<ol>
<li><a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby(string)</code></a> groups each character and the resultant grouper <code>g</code> is an iterable where we add <code>1</code> to all each iteration to retrieve the count of characters in the iterable. This returns tuples of <code>('a',2) ...</code></li>
<li><a href="https://stackoverflow.com/a/10636583/7255359"><code>list(sum(...., ()))</code></a> flattens the list of tuples and converts them into a list. So <code>[('a',2), ('b',4) ... ]</code> becomes <code>['a',2,'b',4...]</code> which is the required output.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If you want it simple and clean, you can do as explained in this <a href="https://stackoverflow.com/a/34444208/5919344">answer</a> with little tweaking for list output</p>
<pre><code>def occurrence(str_):
     result = []
     count = 1
     for i in range(1, len(str_)):
         if str_[i-1] == str_[i]:
             count += 1
         else:
             result.append(str_[i-1]) 
             if count &gt; 1:  # to add the element twice if count more than one
                 result.extend([str_[i-1], count])
             count = 1
     result.append(str_[i])
     if count &gt; 1:
         result.extend([str_[i], count])
     return result
</code></pre>
<p><strong>Test</strong> </p>
<pre><code>&gt;&gt;&gt; string = 'aajjjjiiiiohhkkkkkkkkhkkkk'
&gt;&gt;&gt; occurrence(string)
['a', 'a', 2, 'j', 'j', 4, 'i', 'i', 4, 'o', 'h', 'h', 2, 'k', 'k', 8, 'h', 'k', 4]
&gt;&gt;&gt; string = 'aaabbac'
&gt;&gt;&gt; occurrence(string)
['a', 'a', 3, 'b', 'b', 2, 'a', 'c']
</code></pre>
</div>
<span class="comment-copy">Can you please explain a little more about the encoding method? For example why <code>'aaa'</code> is <code>['a','a',3]</code> instead of <code>['a',3]</code>? Also another way would be to hold a list of dictionaries, but that highly depends on how much repetition is in your strings</span>
<span class="comment-copy">You should not append the number on match, only increment the counter.</span>
<span class="comment-copy">if a letter is repeating it should be given twice with the number of times it is repeating.....for example aaa should be aa3 while a should just be a but aa should be aa2</span>
<span class="comment-copy">if a letter is repeating it should be given twice with the number of times it is repeating.....for example aaa should be aa3 while a should just be a but aa should be aa2</span>
<span class="comment-copy">if a letter is repeating it should be given twice with the number of times it is repeating.....for example aaa should be aa3 while a should just be a but aa should be aa2</span>
<span class="comment-copy">if a letter is repeating it should be given twice with the number of times it is repeating.....for example aaa should be aa3 while a should just be a but aa should be aa2</span>
<span class="comment-copy">@AnveshSunkara check the edit</span>
