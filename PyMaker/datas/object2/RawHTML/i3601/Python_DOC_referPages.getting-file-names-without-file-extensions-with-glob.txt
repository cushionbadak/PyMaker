<div class="post-text" itemprop="text">
<p>I'm searching for .txt files only</p>
<pre><code>from glob import glob
result = glob('*.txt')

&gt;&gt; result
['text1.txt','text2.txt','text3.txt']
</code></pre>
<p>but I'd like <code>result</code> without the file extensions</p>
<pre><code>&gt;&gt; result
['text1','text2','text3']
</code></pre>
<p>Is there a regex pattern that I can use with <code>glob</code> to exclude the file extensions from the output, or do I have to use a list comprehension on <code>result</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no way to do that with <code>glob()</code>, You need to take the list given and then create a new one to store the values without the extension:</p>
<pre><code>import os
from glob import glob

[os.path.splitext(val)[0] for val in glob('*.txt')]
</code></pre>
<p><code>os.path.splitext(val)</code> splits the file names into file names and extensions.  The <code>[0]</code> just returns the filenames.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you’re trying to split off a filename extension, not split an arbitrary string, it makes more sense to use <a href="https://docs.python.org/3/library/os.path.html" rel="nofollow noreferrer"><code>os.path.splitext</code></a> (or the <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib</code></a> module). While it’s true that the it makes no <em>practical</em> difference on the only platforms that currently matter (Windows and *nix), it’s still conceptually clearer what you’re doing. (And if you later start using path-like objects instead of strings, it will continue to work unchanged, to boot.)</p>
<p>So:</p>
<pre><code>paths = [os.path.splitext(path)[0] for path in paths]
</code></pre>
<hr/>
<p>Meanwhile, if this really offends you for some reason, what <code>glob</code> does under the covers is just calling <code>fnmatch</code> to turn your glob expression into a regular expression and then applying that to all of the filenames. So, you can replace it by just replacing the regex yourself and using capture groups:</p>
<pre><code>rtxt = re.compile(r'(.*?)\.txt')
files = (rtxt.match(file) for file in os.listdir(dirpath))
files = [match.group(1) for match in files if match]
</code></pre>
<p>This way, you’re not doing a listcomp on top of the one that’s already in <code>glob</code>; you’re doing one <em>instead of</em> the one that’s already in <code>glob</code>. I’m not sure if that’s a useful win or not, but since you seem to be interested in eliminating a listcomp…</p>
</div>
<div class="post-text" itemprop="text">
<p>Use index slicing:</p>
<pre><code>result = [i[:-4] for i in result]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way using <a href="https://docs.python.org/3/library/stdtypes.html#str.rsplit" rel="nofollow noreferrer"><code>rsplit</code></a>:</p>
<pre><code>&gt;&gt;&gt; result = ['text1.txt','text2.txt.txt','text3.txt']
&gt;&gt;&gt; [x.rsplit('.txt', 1)[0] for x in result]
['text1', 'text2.txt', 'text3']
</code></pre>
<p>You could do as a list-comprehension:</p>
<pre><code>result = [x.rsplit(".txt", 1)[0] for x in glob('*.txt')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>str.split</code></p>
<pre><code>&gt;&gt;&gt; result = [r.split('.')[0] for r in glob('*.txt')]
&gt;&gt;&gt; result
['text1', 'text2', 'text3']
</code></pre>
</div>
<span class="comment-copy">Your title is a little misleading, would <code>Getting file names without file extension with glob</code> be better?</span>
<span class="comment-copy">@Simon Agreed. The title as is sounds like it’s looking for libmagic or some other heuristic way to detect text files. And your rewrite sounds good to me.</span>
<span class="comment-copy">@abarnert Should I edit it myself?  Without OP consent?</span>
<span class="comment-copy">As a side note: <code>glob</code> doesn’t take regex patterns, it takes glob patterns, which are a different thing. Under the covers, it does build regex patterns to apply to a list of files, but you don’t get to see those. (If you want to see them, see the <code>fnmatch</code> module.)</span>
<span class="comment-copy">@Simon I think that’s fine. The OP can always revert if they disagree, and if not, you’ve improved their question for them.</span>
<span class="comment-copy">@abanert: Thanks for the detailed explanation.</span>
<span class="comment-copy">This works, but it’s not as clear or robust as using <code>splitext</code>, or even <code>rsplit</code>. If you later change the code to accept both <code>.txt</code> and <code>.text</code>, for example, the other solutions keep working, but this one doesn’t.</span>
<span class="comment-copy">Why not just <code>rsplit('.')</code>?</span>
<span class="comment-copy">@abarnert sure that's working too. But I think its better use <code>.txt</code> as OP is specific about .txt files.</span>
<span class="comment-copy">This will do the wrong thing for, say, <code>text.file.10.txt</code>, returning <code>text</code> instead of <code>text.file.10</code> (which would be correct on some obsolete platforms, but not on Windows or Unix).</span>
