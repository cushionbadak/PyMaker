<div class="post-text" itemprop="text">
<p>How do I get a dictionary like this:</p>
<pre><code>{'SEA': {'SFO': 6.020797289396148, 'DEN': 12.041594578792296, 'OAK': 6.029925372672534}, 'SFO': {'SEA': 6.020797289396148, 'DEN': 9.7082439194738}}
</code></pre>
<p>from something like this:</p>
<pre><code>[['SEA', ['SFO', 6.020797289396148, 'DEN', 12.041594578792296, 'OAK', 6.029925372672534]], ['SFO', ['SEA', 6.020797289396148, 'DEN', 9.7082439194738]]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a nested <code>dictionary comprehension</code> with <a href="https://docs.python.org/3.3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> and <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer"><code>dict</code></a> as:</p>
<pre><code>l = [['SEA', ['SFO', 6.020797289396148, 'DEN', 12.041594578792296, 'OAK', 6.029925372672534]], ['SFO', ['SEA', 6.020797289396148, 'DEN', 9.7082439194738]]]
d = {v[0]:{k:v1 for k,v1 in zip(v[1][::2], v[1][1::2])} for v in l}
</code></pre>
<p>Or using a for loop like so:</p>
<pre><code>d = {}
for v in l:
    temp_d = {}
    for k,v1 in zip(v[1][::2],v[1][1::2]):
        temp_d[k]=v1
    d[v[0]]=temp_d
</code></pre>
<p>Or:</p>
<pre><code>d = {v[0]:dict(zip(v[1][::2],v[1][1::2])) for v in l}
</code></pre>
<hr/>
<pre><code>print(d)
{'SEA': {'SFO': 6.020797289396148,
  'DEN': 12.041594578792296,
  'OAK': 6.029925372672534},
 'SFO': {'SEA': 6.020797289396148, 'DEN': 9.7082439194738}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple way of doing it</p>
<pre><code>d = {'SEA': {'SFO': 6.020797289396148, 'DEN': 12.041594578792296, 'OAK': 6.029925372672534}, 'SFO': {'SEA': 6.020797289396148, 'DEN': 9.7082439194738}}

l = []
for a in d.keys():
    l2 = []
    d2 = d[a]
    for b in d2.keys():
        l2.extend([b,d2[b]])
    l.extend([a,l2])
print(l)
</code></pre>
<p>You get
['SEA', ['SFO', 6.020797289396148, 'DEN', 12.041594578792296, 'OAK', 6.029925372672534], 'SFO', ['SEA', 6.020797289396148, 'DEN', 9.7082439194738]]</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>[['SEA', ['SFO', 6.020797289396148, 'DEN', 12.041594578792296, 'OAK', 6.029925372672534]], ['SFO', ['SEA', 6.020797289396148, 'DEN', 9.7082439194738]]]
</code></pre>
<p>In this on showing Array of Array which means <code>[ '1',['a',['a1','a2','a3']] ]</code>
The main Arrya 0th index <code>['1']</code> is a normal value  and the another index is a Array <code>['a',['a1','a2','a3']]</code></p>
<p>But In Second Case it's a JSON data</p>
<pre><code>{'SEA': {'SFO': 6.020797289396148, 'DEN': 12.041594578792296, 'OAK': 6.029925372672534}, 'SFO': {'SEA': 6.020797289396148, 'DEN': 9.7082439194738}}
</code></pre>
<p>Example :</p>
<pre><code>{ "SEA" :{'SFO':6.020797289396148}}
</code></pre>
<p>SEA -&gt; {} - SFO -&gt; 6.020797289396148
basically the second method contain a object of object 
the object value as a object in  that object contain the  value 6.020797289396148</p>
<blockquote>
<p>SEA.SFO using this you can get the value of this 6.020797289396148</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can do with dict comprehension,</p>
<pre><code>In [95]: {key:dict(zip(values[::2], values[1::2])) for key,values in a}
Out[95]: 
{'SEA': {'DEN': 12.041594578792296,
  'OAK': 6.029925372672534,
  'SFO': 6.020797289396148},
 'SFO': {'DEN': 9.7082439194738, 'SEA': 6.020797289396148}}
</code></pre>
<p><code>zip(values[::2], values[1::2])</code> will create list of tuples like this,</p>
<pre><code>[('SFO', 6.020797289396148),
  ('DEN', 12.041594578792296),
  ('OAK', 6.029925372672534)] 
</code></pre>
<p><code>dict(zip(values[::2], values[1::2]))</code> will generate a dictionary liks this,</p>
<pre><code>{'DEN': 12.041594578792296,
  'OAK': 6.029925372672534,
  'SFO': 6.020797289396148}
</code></pre>
</div>
<span class="comment-copy">Your first item is a list of list, your second codeblock is a dictionary. It is already a dictionary. Assuming you meant the reverse, I am editing your question.</span>
<span class="comment-copy">I would recommend giving an example using basic for loops with much larger spacing. It will greatly improve understanding and readability. Additionally, please refer documentation to the zip function and dictionary compressions.</span>
<span class="comment-copy">@Modelmat for loops are slow and requires additional variables, so better to avoid them. But given an example using for loops.</span>
<span class="comment-copy">Yes, I know about this. It's just easier to explain and understand, especially for the new user.</span>
