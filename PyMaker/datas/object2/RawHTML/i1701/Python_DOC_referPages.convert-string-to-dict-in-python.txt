<div class="post-text" itemprop="text">
<p>I am trying to convert the below type of string into Dictionary in Python.</p>
<pre><code>'F1=Value1,F2=Value2,F3=[[F4=Value4,F5=Value5]],F6=Value6'
</code></pre>
<p>I would like to make the dictionary like:</p>
<pre><code>{
    'F1': 'Value1', 
    'F2': 'Value2',
    'F3': '[[F4=Value4,F5=Value5]]',
    'F6': 'Value6'
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you will continue to use the identical string format, you may use a complex regular expression to cover various patterns.</p>
<p>The following is a regular expression for a few patterns I have anticipated. Let me know if this solves your issue. If not, please provide details on where my solution fails:</p>
<p>Edit for explaining</p>
<ol>
<li>Group one <code>(?=F\d+=\[).*?(\]){2,}(?=|,)</code>
<ul>
<li><code>(?=F\d+=\[)</code> match string begin with F, have one or more numbers, and have <code>=[</code> after them </li>
<li><code>.*?(\]){2,}</code> match string as less as it can, and it have 2 or more <code>]</code> at the end</li>
<li><code>(?=|,)</code> the string end <code>,</code> or nothing </li>
</ul></li>
<li>Group two  <code>F\d.[^,]+</code>
<ul>
<li>after matching group one, it is easy to find the string like <code>F6=Value6</code>. because the first group takes precedence over the second group, so the second group can only match the remaining strings.</li>
</ul></li>
</ol>
<p>Code</p>
<pre><code>string = "F1=Value1,F2=Value2,F3=[[F4=Value4,F5=Value5]],F6=Value6,F7=[[[BC],[AC]]]"
import re
resultset = [ele[0] if ele[0] else ele[-1] for ele in re.findall(r"((?=F\d+=\[).*?(\]){2,}(?=|,))|(F\d.[^,]+)",string)]
print({x[:x.find("=")]:x[x.find("=")+1:] for x in resultset})
</code></pre>
<p>Output</p>
<pre><code>{'F6': 'Value6', 'F2': 'Value2', 'F3': '[[F4=Value4,F5=Value5]]', 'F1': 'Value1', 'F7': '[[[BC],[AC]]]'}
</code></pre>
<p>Edit: because the former regex does not work when string is <code>F1=Value1,F2=Value2,F8=[iD=10,ig=12S],F3=[[F4=Value4,F5=Value5]],F6=Value6,F9=[iD=10,ig=12S],F7=[[[BC],[AC]]]</code></p>
<p>I changed regex to <code>((?=F\d+=\[).*?(\])+(?= |,F))|(F\d.[^,]+)</code>. And we need one trick. <em>add one blankspace after string</em>.</p>
<pre><code>string = "F1=Value1,F2=Value2,F8=[iD=10,ig=12S],F3=[[F4=Value4,F5=Value5]],F6=Value6,F9=[iD=10,ig=12S],F7=[[[BC],[AC]]]"
import re
resultset = [ele[0] if ele[0] else ele[-1] for ele in re.findall(r"((?=F\d+=\[).*?(\])+(?= |,F))|(F\d.[^,]+)",string+" ")]
print({x[:x.find("=")]:x[x.find("=")+1:] for x in resultset})
</code></pre>
</div>
<span class="comment-copy">What have you tried? What's the problem you've run into? The ideal solution would be to <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">use JSON</a> instead of an arbitrary format, but if that's not an option, you'll get better answers here if you show you're putting in the work but need a help with specific issues.</span>
<span class="comment-copy">That's cool! Thank you very much!</span>
<span class="comment-copy">@netbbq This is the victory of priority matching</span>
<span class="comment-copy">Make your example a bit more complicated, you code doesn't work any more as below. "F1=Value1,F2=Value2,F8=[iD=10,ig=12S],F3=[[F4=Value4,F5=Value5]],F6=Value6,F9=[iD=10,ig=12S],F7=[[[BC],[AC]]]"</span>
<span class="comment-copy">@netbbq see my edit, did it suit for you?</span>
