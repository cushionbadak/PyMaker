<div class="post-text" itemprop="text">
<p>I have some trouble understanding time conversions in python.
I have two identical <code>time_struct</code> objects</p>
<pre><code>In [22]: local_dt
Out[22]: datetime.datetime(2000, 1, 1, 0, 0, tzinfo=&lt;DstTzInfo 'America/Los_Angeles' PST-1 day, 16:00:00 STD&gt;)
In [23]: local_dt.timetuple()                                                                                                                             
Out[24]: time.struct_time(tm_year=2000, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=5, tm_yday=1, tm_isdst=0)
</code></pre>
<p>When I feed it to the <code>time.mktime</code> function on one machine  </p>
<pre><code>time.mktime(local_dt.timetuple())
</code></pre>
<p>it returns <code>946681200.0</code></p>
<p>On a second machine I get a different answer</p>
<pre><code>In [31]: local_dt.timetuple()                                                                                                                             
Out[31]: time.struct_time(tm_year=2000, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=5, tm_yday=1, tm_isdst=0)

In [32]: time.mktime(local_dt.timetuple())                                                                                                                
Out[32]: 946684800.0
</code></pre>
<p>The machines have different timezones, though:</p>
<pre><code>In [44]: time.tzname                                                                                                                                      
Out[44]: ('Europe', 'Europe')

In [45]: time.tzname
Out[45]: ('CET', 'CEST')
</code></pre>
<p>The documentation on the time module says: </p>
<blockquote>
<p>Use the following functions to convert between time representations:
  struct_time in local time seconds since the epoch mktime()</p>
</blockquote>
<p>As I understand my local time is "America/Los_Angeles" so seconds since epoch should be exactly the same and not be depending on the system configuration. </p>
<p>What am I misunderstanding? How do I have to calculate the timestamp correctly then? </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/time.html#time.mktime" rel="nofollow noreferrer"><code>time.mktime()</code></a> interprets the <code>timetuple</code> based on the local machine's timezone.  Notice how your <code>timetuple</code> object doesn't contain any timezone info, so the timestamp created will always vary based on timezone set on the local machine.  Thus it's entirely understandable why the same <code>time.mktime(local_dt.timetuple())</code> returns different value on those two machines.  </p>
<p>You can use <a href="https://docs.python.org/3/library/datetime.html?highlight=datetime#datetime.datetime.timestamp" rel="nofollow noreferrer"><code>local_dt.timestamp()</code></a> instead, while both are <a href="https://docs.python.org/3/library/datetime.html?highlight=datetime#datetime.dhttps://docs.python.org/3/library/datetime.html?highlight=datetime#datetime.datetime.timestampatetime.timestamp" rel="nofollow noreferrer">essentially the same</a>...</p>
<blockquote>
<p>Naive <code>datetime</code> instances are assumed to represent local time and this method relies on the platform C <code>mktime()</code> function to perform the conversion.</p>
</blockquote>
<p>... But since you're creating the <code>timestamp</code> directly from the non-naive <code>datetime</code> object, it still retains the timezone info and can shift the time accordingly:</p>
<blockquote>
<p>For aware <code>datetime</code> instances, the return value is computed as:</p>
<p><code>(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()</code></p>
</blockquote>
<p>Observe:</p>
<pre><code>&gt;&gt;&gt; est = datetime.datetime(1999, 12, 31, 19, 0).astimezone(pytz.timezone('EST'))
&gt;&gt;&gt; utc = est.astimezone(pytz.timezone('UTC'))
&gt;&gt;&gt; est
datetime.datetime(1999, 12, 31, 19, 0, tzinfo=&lt;StaticTzInfo 'EST'&gt;)
&gt;&gt;&gt; utc
datetime.datetime(2000, 1, 1, 0, 0, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; est.timestamp()
946684800.0           
&gt;&gt;&gt; utc.timestamp()
946684800.0           # same as est
&gt;&gt;&gt; time.mktime(est.timetuple())
946684800.0
&gt;&gt;&gt; time.mktime(utc.timetuple())
946702800.0           # different than est
</code></pre>
<p>The last <code>time.mktime()</code> processed <code>utc.timetuple()</code> as a local time since the timezone info was not passed.  You can notice it's offset by 18000 (<code>time.timezone</code> for EST, my time zone).</p>
</div>
<div class="post-text" itemprop="text">
<p>As you said : "The machines have different timezones, though:" and doc said: "in local time".</p>
<p>Your "local time" is not the same on both machine : one is Europe/europe (probably GMT, so UTC+0), the other one is CEST (UTC +1).</p>
<p>see <a href="https://www.timeanddate.com/time/zones/eu" rel="nofollow noreferrer">https://www.timeanddate.com/time/zones/eu</a></p>
<blockquote>
<p>Central European Time (CET) is 1 hour ahead of Coordinated Universal Time (UTC). 
  This time zone is in use during standard time in: Europe, Africa. </p>
</blockquote>
<p>I think you want to convert your datetime into "UTC+0 datetime"</p>
</div>
<span class="comment-copy">The delta between the two values is exactly 3600 seconds (one hour), which smells to me like a Daylight Savings Time issue. That said, it looks like they are set up the same, so I'm not sure why this delta exists.</span>
