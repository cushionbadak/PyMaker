<div class="post-text" itemprop="text">
<p>*EDIT: Title is incorrect, Big-Endian should be Little-Endian. Didn't want to change due to solutions provided.</p>
<p>I am trying to convert a string (ex b'\x01\x00\x00\x00' &lt;- 32 bit intger) back to an integer in my C program.</p>
<p>Client (in Python):</p>
<pre><code>example = [1,2,3]
struct.pack('i'*int(len(example)/4),packed)
&lt;Send over open socket to server&gt;
</code></pre>
<p>Server (in C):</p>
<pre><code>char buffer[1024];
numbytes = recv(sockfd,buffer,1023,0);
char message[numbytes];
memcpy(message,buffer,n);
&lt;If 'message' is sent back, I can unpack on client&gt;
??? How to unpack on C then repack to send response to client ???
</code></pre>
<p>In C, I want to 'unpack' into a array/struct</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming the <em>title</em> of your question is correct, and the values are actually in big-endian order, you want the <a href="https://linux.die.net/man/3/ntohl" rel="nofollow noreferrer"><code>ntohl</code></a> (network to host long) function. Call this function for each of the 32-bit integers to convert them into the host byte order.</p>
<p>Based on the value <code>b'\x01\x00\x00\x00'</code> it seems more likely that you're encoding the values in little-endian order, and that is in fact what the <code>struct.pack</code> call you showed will produce if you run it on a little-endian machine. Your client and server probably are both running on little-endian hardware (although you don't specify that, so it's impossible to be 100% certain).</p>
<p>In any case, whatever form you use, you need to use the same endianness on both sides. It's probably best to not make your wire protocol endianness-dependent, so you should probably ensure that both the client and the server convert bytes into and out of a common endianness. Internet standards specify big-endian as the standard for network protocols.</p>
<p>If you decide to standardize on big-endian, here's what you need to do:</p>
<ul>
<li>Change your <code>struct.pack</code> call to select big-endian encoding of integers. You can do this by adding a <code>'&gt;'</code> prefix to the struct definition.</li>
<li>Change your C code to read each integer one a time (four bytes for a 32-bit value), and then pass the values through <code>ntohl</code> to get a <code>uint32_t</code>.</li>
<li>Re-assemble the integers into your struct on the server side.</li>
</ul>
</div>
<span class="comment-copy">Note that Python's <code>struct.pack</code> as you have it defined (without any byte order prefix) will use the <i>client's</i> native byte ordering. You can check <code>sys.byteorder</code> to figure out what ordering that is, but it would probably be better to use a prefix character to ensure a specific byte ordering, either <code>&lt;</code> for little-endian or <code>&gt;</code> for big-endian. See the <a href="https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment" rel="nofollow noreferrer">documentation on the <code>struct</code> module</a> for details.</span>
<span class="comment-copy">For further clarification: what number do you expect the bytes <code>01 00 00 00</code> to represent? Big-endian, that would be 16777216; little-endian, that would be 1.</span>
<span class="comment-copy">Will this work for 2 (or n bits /4) integers (ex b'\x01\x00\x00\x00\x02\x00\x00\x00')? Is it as simple as feeding ntohl the variable containing the string?</span>
<span class="comment-copy">If you know that the client has packed the struct in the server's native byte ordering, then you can read the structure off the wire directly. But that's not portable, as it makes your wire protocol dependent on the native byte order of the server machine. You're probably better off reading words off the wire one at a time and byte-swapping them as necessary.</span>
<span class="comment-copy">The example given in the question is in little-endian order, not network order (which is big-endian)</span>
<span class="comment-copy">@interjay: Actually, the example given in the question is in <i>undefined</i> byte order. I've added a comment to clarify that. However, the title of the question indicates that the question <i>assumes</i> that it's big-endian (whether that's true or not is another story).</span>
<span class="comment-copy">I'm referring to b'\x01\x00\x00\x00' which is little endian for 1. The assumption in the title was obviously incorrect, but fixing it is not another story but an integral part of this one. Also, you need to show how to put the data in a <code>uint32_t</code>.</span>
