<div class="post-text" itemprop="text">
<p>I'm currently writing a python script with pyserial and pyqtgraph that plots data coming in from an accelerometer via the serial port. I append this data to an int array and use it to update the plot. At the moment, my graph width is 500 (I'm only displaying the most recent 500 elements) and I "roll" or "scroll" by appending an element to the end and popping from the start.</p>
<pre><code>data1 = [0] * 500

def update():
  global curve1, data1, x, ser
  if(ser != None): ## serial object. defined via a QPushButton event
    line = ser.readline()
    csv = line.decode().split(',')
    if len(csv) == 2:       
      data1.append(int(csv[1]))
      data1.pop(0)
      xdata1 = np.array(data1[-500:], dtype='int')
      curve1.setData(xdata1)
      x += 1
      curve1.setPos(x, 0)
      app.processEvents()
</code></pre>
<p>This update method is called by the QtTimer object to update the plot window</p>
<pre><code>timer = QtCore.QTimer()
timer.timeout.connect(update)
timer.start(0)
</code></pre>
<p>This way I avoid an array that keeps growing and also avoid copying values by shifting the elements left. My plot however is inconsistent and occasionally lags (When I move the sensor, the plot reacts seconds later). Is this due to me rolling my data inefficiently?</p>
</div>
<div class="post-text" itemprop="text">
<p>To have a O(1) update procedure, you can do it yourself with a double array buffer :</p>
<pre><code>size=4
buffersize=2*size
buffer=np.zeros(buffersize+1,int) # one more room  for keep trace on beginning of buffer.
sensor=iter(range(1,10**5)) # emulation

def update():
    i=buffer[buffersize] # to avoid global variable i
    buffer[i]=buffer[i+size]=next(sensor) # double copy.
    buffer[buffersize]=i=(i+1)%size
    print(i,buffer[:buffersize],buffer[i:i+size])
    # In real life : curve1.SetData(buffer[i:i+size])
</code></pre>
<p>Since <code>buffer[i:i+size]</code> is just a view, it will take no time to update <code>curve1</code>.</p>
<p>Run : </p>
<pre><code>&gt;&gt;&gt; for k in range(6): update()

1 [1 0 0 0 1 0 0 0] [0 0 0 1]
2 [1 2 0 0 1 2 0 0] [0 0 1 2]
3 [1 2 3 0 1 2 3 0] [0 1 2 3]
0 [1 2 3 4 1 2 3 4] [1 2 3 4]
1 [5 2 3 4 5 2 3 4] [2 3 4 5]
2 [5 6 3 4 5 6 3 4] [3 4 5 6]
....
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a good reference for this kind of FIFO functionality: <a href="https://dbader.org/blog/queues-in-python" rel="nofollow noreferrer">Queues in Python</a></p>
<p>To summarise from that link:</p>
<p>Consider using <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a> for this behaviour, as lists are slow.</p>
</div>
<span class="comment-copy">I thought of deque but the setData function only takes numpy arrays</span>
<span class="comment-copy">You can just convert the deque object to a list (<code>xdata1 = np.array(list(your_queue,dtype='int')</code>), but I don't know how that will affect the efficiency.</span>
<span class="comment-copy">Forgot a close-paren there, but you get the idea.</span>
