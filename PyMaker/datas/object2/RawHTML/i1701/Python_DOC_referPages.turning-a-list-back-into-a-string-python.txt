<div class="post-text" itemprop="text">
<p>The first function is able to separate each letter of a string and list how many times that letter appears. For example:</p>
<pre><code>print(rlencode("Hello!"))
[('H', 1), ('e', 1), ('l', 2), ('o', 1), ('!', 1)]
</code></pre>
<p>How do I get <code>rldecode(rle)</code>: do the the complete opposite of <code>rlencode(s)</code> so that <code>rldecode(rlencode(x)) == x</code> returns <code>True</code></p>
<pre><code>def rlencode(s):
    """
    signature: str -&gt; list(tuple(str, int))
    """
    string=[]
    count=1
    for i in range(1,len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            string.append((s[i-1], count))
            count=1
        if i == len(s)-1:
            string.append((s[i], count))
    return string



def rldecode(rle):
    """
    #signature: list(tuple(str, int)) -&gt; str
    #"""
    string=" "
    count=1
    for i in rle:
        if i == rle:
            string += i
    return string
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the fact that you can multiply a string by a number to repeat it and use `''.join() to bring the elements of the list together.</p>
<p>To show the effect of string multiplication, I multiplied <code>"a"</code> by 5</p>
<pre><code>"a"*5 #'aaaaa'
</code></pre>
<p>Using that in a comprehension will give you </p>
<pre><code>str = [char[0]*char[1] for char in rle] #['H', 'e', 'll', 'o', '!']
</code></pre>
<p>Then add in the <code>''.join()</code> and you have your answer.</p>
<pre><code>l = [('H', 1), ('e', 1), ('l', 2), ('o', 1), ('!', 1)]
str = ''.join(char[0]*char[1] for char in rle) #'Hello!'
</code></pre>
<p>So your function would be </p>
<pre><code>def rldecode(rle):
    """
    signature: list(tuple(str, int)) -&gt; str
    """
    return ''.join(char[0]*char[1] for char in rle) 
</code></pre>
<p>Also, if you would like to make your <code>rlencode</code> a little cleaner, you can simplify it a little bit by using <code>enumerate</code> to help you keep your position in the string and check if you're about to hit either a new character or the end of the string. You just have to increment the counter on each loop.</p>
<pre><code>def rlencode(s):

    output = []
    count = 0

    for i, char in enumerate(s):

        count += 1

        if (i == (len(s)-1)) or (char != s[i+1]):
            output.append((char, count))
            count = 0

    return output
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer"><code>join</code></a>:</p>
<pre><code>b = [('H', 1), ('e', 1), ('l', 2), ('o', 1), ('!', 1)]
''.join([c[0] * c[1] for c in b])
Hello!
</code></pre>
<p>You can also use list comprehensions for your initial function.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>collections.Counter.elements()</code>:</p>
<pre><code>from collections import Counter
l = [('H', 1), ('e', 1), ('l', 2), ('o', 1), ('!', 1)]
print(''.join(Counter(dict(l)).elements()))
</code></pre>
<p>This outputs:</p>
<pre><code>Hello!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple, readable solution is to iterate over all of the tuples in the list returned by <code>rlencode</code> and construct a new string from each letter (and it's frequency) like so:</p>
<pre><code>def rldecode(rle):
    string = ''
    for letter, n in rle:
        string += letter*n
    return string
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>An answer that's easy to read but also accounts for ordering in the problem:</h2>
<pre><code>def rlencode(s):
    """
    signature: str -&gt; list(tuple(str, int, list(int)))
    """
    result=[]
    frequency=1
    for i in range(len(s)):
        letters = [item[0] for item in result]
        if s[i] in letters:
            idx = letters.index(s[i])
            frequency=result[idx][1]
            frequency+=1
            positions= result[idx][2]
            positions.append(i)
            result[idx] = (s[i],count,lst)
        else:
            result.append((s[i],1,[i]))
    return result




def rldecode(rle):
    """
    #signature: list(tuple(str, int, list(int))) -&gt; str
    #"""

    frequencies = [i[1] for i in rle]
    total_length = sum(frequencies)
    char_list=[None]*total_length
    for c in rle:
        for pos in c[2]:
            char_list[pos] = c[0]
    return "".join(char_list)


text = "This is a lot of text where ordering matters" 
encoded = rlencode(text)
print(encoded)
decoded = rldecode(encoded)
print(decoded)
</code></pre>
<p>I adapted it from the answer posted by @Brian Cohan</p>
<p>It should be noted that the answer is computationally expensive because of <code>.index()</code> if <code>letter</code> grows really long as explained in <a href="https://stackoverflow.com/questions/176918/finding-the-index-of-an-item-given-a-list-containing-it-in-python">this SO post</a></p>
</div>
<span class="comment-copy">Your output does not contain information about ordering. Your 'relencode` function needs to output something more like <code>list(tuple(str, int, [positions]))</code> in order to be able to reconstruct. Do I seem to be following what you're asking for here...?</span>
<span class="comment-copy">If an answer on the page has satisfied what you need, please make sure you pick one :)</span>
<span class="comment-copy">I like this, but it would be a but more readable if you used something other than lowercase "L" as your list variable and stayed away from using variables like <code>str</code> that can be confused with built-ins.</span>
<span class="comment-copy">Appreciate the feedback. I changed it to <code>rle</code> since that's the OP's variable. Also changed <code>c</code> to <code>char</code> for legibility.</span>
<span class="comment-copy">I like the answer and it works for OPs particular input, but wouldn't it make more sense to have <code>rlencode</code> and <code>rldecode</code> preserve ordering for inputs with non-consecutively repeated characters? (I'm trying to get a little attention for my answer xD)</span>
<span class="comment-copy">It all depends on what the OP is looking for. Your algorithm might save a bit of storage space on longer strings, but that's the only benefit from it. Your code is much more difficult to read for both the programmer and the computer, as is the output, and as you indicated, your algorithm is quite computationally expensive. Running it 10 times on 5 paragraphs of lorem ipsum, my code averaged 0.0178s while yours averaged 0.0255s.</span>
<span class="comment-copy">Much appreciated! @BrianCohan</span>
<span class="comment-copy">looks ok. You could also get rid of those ugly indices by using tuple unpacking like <code>''.join(c * n for c, n in L)</code></span>
