<div class="post-text" itemprop="text">
<p>I have an IP address <code>R</code> (ie: <code>"255.255.255.0"</code>) in string form that I'm hashing, and taking the first 4 bytes of that hash. I want to then convert that hashed result to binary format:</p>
<pre><code>def H(R):
    h = hashlib.sha256(R.encode('utf-8'))
    return unhexlify(h.hexdigest())[0:4]
</code></pre>
<p>I tried doing the following, but I only get 30 bits instead of 32 (I remove the first 2 chars of the string because it's the <code>0b</code> prefix):</p>
<pre><code>bin(struct.unpack('!I', H(R))[0])[2:]
</code></pre>
<p>How can I do this correctly? The result of <code>H(R)</code> looks something like b',\xc3Z\xfb'. I've tried the methods here and none work with the format I'm converting from. <a href="https://stackoverflow.com/questions/8815592/convert-bytes-to-bits-in-python">Convert bytes to bits in python</a></p>
<ul>
<li>What I have: 4 bytes from the Hash of a 32 bit IP Address string, ie: <code>b',\xc3Z\xfb'</code></li>
<li>What I'm trying to get: the 32 binary representation as a string, ie: <code>'10101010101010101010101010101010'</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Guess this would does the work</p>
<pre><code>import hashlib
import binascii

def H(R):
    h = hashlib.sha256(R.encode('utf-8'))
    return binascii.unhexlify(h.hexdigest())[0:4]

def binstr(x: bytes) -&gt; str:
    s = ""
    for char in x:
        ch = bin(char)[2:] # 0b101 -&gt; 101
        s += "0" * (8-len(ch)) + ch # 101 -&gt; 00000101
    return s

print(binstr(H("127.0.0.1"))) # 00010010110010100001011110110100
print(binstr(H("255.255.255.255"))) # 11110100010101000110001010111111
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#bin" rel="nofollow noreferrer"><code>bin()</code></a> gives you a binary representation of an integer. The particular integer you're asking for a binary representation of in this case is the result of <code>struct.unpack('!I', b',\xc3Z\xfb')[0]</code>, which happens to be 751000315:</p>
<pre><code>&gt;&gt;&gt; struct.unpack('!I', b',\xc3Z\xfb')[0]
751000315
</code></pre>
<p>The binary representation of 751000315 that <code>bin()</code> gives you is <code>0b101100110000110101101011111011</code>, which is correct:</p>
<pre><code>&gt;&gt;&gt; bin(751000315)
'0b101100110000110101101011111011'
&gt;&gt;&gt; 0b101100110000110101101011111011
751000315
</code></pre>
<p>It has thirty digits (plus the <code>0b</code> prefix) because that's how many digits are necessary to represent that integer. if the result of <code>struct.unpack('!I', H(R))[0]</code> had been, say, the integer <code>38</code> (for example, if <code>R</code> were <code>'247.69.16.15'</code>), the binary representation <code>bin()</code> gave you would be <code>0b100110</code>, which is even shorter.</p>
<p><code>bin()</code> can't guess that you want leading zeroes, and it certainly can't guess how many. What you need to do is <a href="https://docs.python.org/3/library/string.html#formatstrings" rel="nofollow noreferrer">format</a> your integer, like this:</p>
<pre><code>&gt;&gt;&gt; '{:032b}'.format(struct.unpack('!I', b',\xc3Z\xfb')[0])
'00101100110000110101101011111011'
</code></pre>
<p>â€¦ or, in the extreme example I gave above:</p>
<pre><code>&gt;&gt;&gt; '{:032b}'.format(struct.unpack('!I', H('247.69.16.15'))[0])
'00000000000000000000000000100110'
</code></pre>
</div>
<span class="comment-copy">You ask how to do "that" correctly.  Can you describe what "that" is exactly?  In English, what is the goal of this code?  What's the surrounding use case?  Can you give example inputs and expected outputs?</span>
<span class="comment-copy">@JohnZwinck does the edit clarify?</span>
<span class="comment-copy">Did you know that an IPv4 address is 4 bytes?  Why bother hashing it then taking the first 4 bytes?  You could just use the binary value directly.</span>
<span class="comment-copy">@JohnZwinck in fairness, the idea here may be to anonymize IP addresses for logging purposes (and getting the binary representation could be to test that the anonymization scheme is sufficiently "random").</span>
