<div class="post-text" itemprop="text">
<p>I'm having problems creating indexes for a 2d array from the position of a mouse click. The program is supposed to work by checking the mouse click position against every square in the array (squares) which is only 1d. Squares is an array of objects from a class called square, which is drawn on the screen. The 2d array is an array of ones and zeros that is randomly generated to a user inputted size.</p>
<p>It should only create the new index if the mouse click position is inside a square, and only generate the index for that square.</p>
<pre><code>for n in range(len(squares)):
    for square in squares:
        if square.x &lt; x &lt; (square.x+17) and square.y &lt; y &lt; (square.y+17):
            j = int(n/width)
            i = n - j*width
            print(j,i)
</code></pre>
<p>However the program is generating the 2d array indexes for every square in the 1d array instead of just the square where the mouse click is.</p>
<p>So how would I get this code to work as intended?</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like you just need to remove the nested loop and use the index <code>n</code> to access the current square:</p>
<pre><code>for n in range(len(squares)):
    square = squares[n]
    if square.x &lt; x &lt; (square.x+17) and square.y &lt; y &lt; (square.y+17):
        j = int(n/width)
        i = n - j*width
        print(j,i)
</code></pre>
<p>The idiomatic way to iterate over the indices and the items at the same time is to <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate</a> the list:</p>
<pre><code>for n, square in enumerate(squares):
    if square.x &lt; x &lt; (square.x+17) and square.y &lt; y &lt; (square.y+17):
</code></pre>
<hr/>
<p>If you're dealing with a grid, you can also just floor divide the mouse coordinates by the tilesize to get the indices. Then just convert the 2D indices to a 1D index in this way: <code>i = x + width*y</code>. That means you don't have to iterate over the squares anymore to check for collisions.</p>
<p>Here's an example with a list of <code>pygame.Rect</code>s and colors that you can change by clicking on a cell:</p>
<pre><code>import pygame as pg


pg.init()
screen = pg.display.set_mode((640, 480))
clock = pg.time.Clock()
BG_COLOR = pg.Color('gray12')
ORANGE = pg.Color(200, 100, 0)
BLUE = pg.Color('dodgerblue1')

tilesize = 27
width = 16
height = 10
# A list of pygame.Rects + colors.
squares = [[pg.Rect(x*tilesize, y*tilesize, tilesize-1, tilesize-1), ORANGE]
           for y in range(height) for x in range(width)]

done = False
while not done:
    for event in pg.event.get():
        if event.type == pg.QUIT:
            done = True
        elif event.type == pg.MOUSEBUTTONDOWN:
            # Floor division by the tilesize to get the x and y indices.
            x, y = event.pos[0]//tilesize, event.pos[1]//tilesize
            if 0 &lt;= x &lt; width and 0 &lt;= y &lt; height:  # Inside of the grid area.
                i = x + width*y  # Index of the 1D list.
                print(x, y, i)
                # I just toggle the color here.
                squares[i][1] = BLUE if squares[i][1] == ORANGE else ORANGE

    screen.fill(BG_COLOR)
    for square, color in squares:
        pg.draw.rect(screen, color, square)
    pg.display.flip()
    clock.tick(60)

pg.quit()
</code></pre>
</div>
<span class="comment-copy">Please edit the question and post a <a href="https://stackoverflow.com/help/mcve">minimal, runnable example</a>. That would make it easier to analyze and fix the program.</span>
<span class="comment-copy">By the way, shouldn't that be <code>i = n % width</code> instead of <code>i = n - j*width</code>?</span>
