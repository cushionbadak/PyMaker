<div class="post-text" itemprop="text">
<p>I have created a function that imports a module in python as name you want. I just want to know, how this new local variable can be made accessible in global scope.</p>
<pre><code>def myimport(modulename, newname):
    exec('%s = __import__("%s")'%(newname, modulename))

myimport('os', 'pax')
</code></pre>
<p>now the <strong>pax</strong> variable can't be accessed outside the function, and I want it to be accessible.</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer is just for research purpose, as stated by Willem Van Onsem in the comment section - importing via eval / exec etc. is not considerable in productive code due to the security issues it may raise. The following code works with python 2 and python 3. The trick is to use the global() function to bind the imported module to a global variable:</p>
<pre><code>def myimport(modulename):
    module = eval('__import__("%s")' % (modulename))
    globals()[modulename] = module

myimport('os')
print(os.path) # now os can get used ...
</code></pre>
<p><strong>Update</strong></p>
<p>The following code is working without this ugly eval statement:</p>
<pre><code>def myImport(modulename):
    globals()[modulename] = __import__(modulename)

myImport("sys")
print(sys.path)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can pass in the globals dictionary as the second argument to <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code></a>. This will change the code execution scope of exec.</p>
<pre><code>def very_bad_idea(name, value):
    exec(f'{name}={repr(value)}', globals())

very_bad_idea('spam', 'eggs')
print(spam)  # prints 'eggs'
</code></pre>
<p>But please don't do this. Try to find some way that doesn't involve exec.</p>
</div>
<span class="comment-copy">Please do'nt do that.... Python has already syntax for this: <code>import os as pax</code>.</span>
<span class="comment-copy">I know there is already a syntax. But maybe in future I may need to do something else and coincide with this same problem. I just want to know how we can do it. :D tq.</span>
<span class="comment-copy">but here you basically violate two things: (a) you use <code>exec(..)</code> which is very insecure and a software anti-pattern, and second (b) you aim to create a variable <i>by name</i>. What if somebody wants to define this to <code>'1'</code>, or <code>'foo bar'</code>? Defining it that way will not help (in the end). Most IDEs will also not be able to help with such "dynamic" imports, and it will be very unclear if there is a "name clash".</span>
<span class="comment-copy">Have you considered using importlib ?<a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">myimport function can be used with try-catch for that. My concern is not about importing a module. I am just wondering if there is any way for an undefined variable name to be shifted from local scope to global.</span>
