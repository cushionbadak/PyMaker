<div class="post-text" itemprop="text">
<p>Here:</p>
<pre><code>from os.path import exists as foo
print foo.__name__
</code></pre>
<p>we get: <code>'exists'</code>.
Why not <code>'foo'</code>? Which attribute would give <code>'foo'</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can view <code>import foo as bar</code> as just an assignment. You would not expect a function to change its <code>__name__</code> attribute when you assign another name to the function.</p>
<pre><code>&gt;&gt;&gt; def foo(): pass
&gt;&gt;&gt; 
&gt;&gt;&gt; foo.__name__
'foo'
&gt;&gt;&gt; bar = foo
&gt;&gt;&gt; bar.__name__
'foo'
</code></pre>
<blockquote>
<p>Thanks. What attribute of the variable <code>bar</code> would return the string <code>'bar'</code> then?</p>
</blockquote>
<p>There is no such attribute. Names (<code>bar</code>) refer to values (the function object) unidirectionally.</p>
<p>The <code>__name__</code> attribute of a function is set as the name the function was defined with using the<br/>
<code>def ...</code> syntax. That's why you don't get a meaningful <code>__name__</code> attribute if you define an anonymous function and assign the name <code>foo</code> after it has been created.</p>
<pre><code>&gt;&gt;&gt; foo = lambda: None
&gt;&gt;&gt; foo.__name__
'&lt;lambda&gt;'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Importing an object <em>just binds a new variable</em>, and all that adding <code>as newname</code> does is let you pick an alternative name to use for the variable in the current namespace.</p>
<p>The <code>__name__</code> attribute on an object says nothing about the name it is currently bound to, you can have any number of variables as well as containers such as lists or dictionaries pointing to the same object, after all:</p>
<pre><code>def foo(): pass

bar = foo
spam = foo
list_of_functions = [foo]
dictionary_of_functions = {'monty': foo, 'python': foo}
</code></pre>
<p>The above created 4 additional references to the function object; you can't have <code>foo.__name__</code> reflect all of those, and the references in <code>list_of_functions</code> and <code>dictionary_of_functions</code> do not (directly) have names.</p>
<p>Since <code>import foo</code>, <code>import bar as foo</code>, <code>from module import foo</code> and <code>from module import bar as foo</code> all just set the name <code>foo</code> in the current module, they are treated the exact same way as other assignments. You could import the function more than once, under different names, too.</p>
<p>Instead, the <code>__name__</code> value of a function is set to name it was defined with in the <code>def &lt;name&gt;(...):</code> statement. It is a debugging aid, at most. It is used in tracebacks, for example, to make it easier to identify lines of code shown in the traceback. You'd only set the <code>__name__</code> to something else if that would help identify the location better. (Note: in Python 3, there is also the <a href="https://docs.python.org/3/library/stdtypes.html#definition.__qualname__" rel="noreferrer"><code>__qualname_</code> attribute</a>, which is used instead of <code>__name__</code> as it includes more information on where the function is defined when nested or defined on a class).</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>as</code> is syntactical sugar in the file/session of the import, while the <code>__name__</code> attribute is part of the function object.</p>
</div>
<span class="comment-copy"><code>from X import Y as Z</code> is equivalent to <code>from X import Y; Z=Y; del Y</code>. The only difference is that it does not hide something called <code>Y</code> that already existed before the import and if it existed is not deleted (<code>Y="Hi"; from X import Y as Z</code> then <code>Y == "Hi"</code>).</span>
<span class="comment-copy">@Basj there is no such attribute. Names (<code>bar</code>) refer to values (the function) unidirectionally.</span>
<span class="comment-copy">@Basj It is not strange at all. Python names are just references to memory locations. <code>bar = 'a string'</code>, then <code>'a string'</code> has no clue that it happens to be referenced by <code>bar</code>, so <code>'a string'.__name__</code> can never be <code>'bar'</code></span>
<span class="comment-copy">@DeepSpace Ok. I thought that there would be a duplicate "object" <code>bar</code> that would just make the link to <code>foo</code>, and that would have its proper <code>__name__</code>.</span>
<span class="comment-copy">@Basj Note that what you suggest would imply that: 1) the function object has to somehow be modified each time its reference is assigned or unassigned to a new variable name 2) if you assign multiple variable names to the same function reference you would have either make copies of the function or somehow keep track of all the variable names</span>
<span class="comment-copy">Another way to see this is that the same function could be referred to by multiple variables. Clearly, it can only have one name. The name is a property of the function, not of the variable.</span>
