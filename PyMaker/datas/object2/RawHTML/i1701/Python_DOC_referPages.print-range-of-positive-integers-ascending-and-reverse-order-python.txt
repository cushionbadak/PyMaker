<div class="post-text" itemprop="text">
<p>I'd like to print the output as a palindromic triangle of positive numbers (without 0's), either through user input <code>int(input())</code>:</p>
<pre><code>for i in range(1,int(input())+1):
   print(*range(1, i+1),(*range(i-1, -1, -1)))
</code></pre>
<p>or as fixed range like this:</p>
<pre><code>for n in range(1,5):
  print(*range(1, n+1),(*range(n-1, -1, -1))
</code></pre>
<p>I can get the latter to work as far as this, but I'd like it without the 0's. Two additional issues: 1) Will user input of 5 be the same as hard coded 5 in the range? 2) How to get the 5 included in output? Any idea how this can be done? Thanks in advance.</p>
<pre><code>1 0
1 2 1 0
1 2 3 2 1 0
1 2 3 4 3 2 1 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your indexing is just ever so slightly off:</p>
<pre><code>user_range = int(input("Desired limit : ")) + 1

for n in range(1, user_range):
  print(*range(1, n+1),(*range(n-1, 0, -1)))
</code></pre>
<p>output:</p>
<pre><code>1
1 2 1
1 2 3 2 1
1 2 3 4 3 2 1
1 2 3 4 5 4 3 2 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is this what you want? Rather than hardcoding 5 we are asking the input from the user. And a slight modification to the indexing as well.</p>
<pre><code>for i in range(1,int(input("Enter number : "))+1):
    print(*range(1,i+1), *range(i-1,-1,-1))
</code></pre>
<p>Ouput:</p>
<pre><code>Enter number : 7
1 0
1 2 1 0
1 2 3 2 1 0
1 2 3 4 3 2 1 0
1 2 3 4 5 4 3 2 1 0
1 2 3 4 5 6 5 4 3 2 1 0
1 2 3 4 5 6 7 6 5 4 3 2 1 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Nice fancy work with those ranges and splats. I don't see anything wrong with slicing.</p>
<pre><code>for n in range(1,5):
  print(*range(1, n+1), *range(n-1, -1, -1)[:-1])
</code></pre>
<p>Somebody else said this and it seems to work the same:</p>
<pre><code>for n in range(1,5):
  print(*range(1, n+1), *range(n-1, 0, -1))
</code></pre>
</div>
<span class="comment-copy">In case anyone is wondering about the syntax and the purpose of the asterisk, the Python docs explain: "If the syntax *expression appears in the function call, expression must evaluate to an iterable." <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow noreferrer">docs.python.org/3/reference/expressions.html#calls</a></span>
<span class="comment-copy">Very cool, thank you. Can you elaborate on the arguments passed in the print's second range: it seems that zero made the difference.</span>
<span class="comment-copy">np! In Python when you have <code>range(x, y, z)</code> or <code>range(x, y)</code>, the ending point <code>y</code> of the iterator is not inclusive. If set to <code>-1</code> the iteration will stop at 0, and if set to <code>0</code>, the iteration will stop at <code>1</code> :)</span>
<span class="comment-copy">Thank you, yes ideally prefer to have user input, but keep the range in positive numbers.</span>
<span class="comment-copy">Thanks, I missed that slicing part, if you could elaborate.</span>
<span class="comment-copy">In my example: <code>*range(n-1, -1, -1)[:-1]</code> simply cuts off everything after the <code>-1</code>nth  (the last) position in the range.</span>
<span class="comment-copy">Thanks. I see that the results only get to 4 even though the *range(1,n+1) should make it all inclusive, and so the user input is the ideal way to go.</span>
