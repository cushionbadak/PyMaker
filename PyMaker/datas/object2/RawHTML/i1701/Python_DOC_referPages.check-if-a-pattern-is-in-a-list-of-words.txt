<div class="post-text" itemprop="text">
<p>I need an output that contains words that are exactly like a pattern - same letters in same spots only (and letters shouldn't show in the word at other places) and the same length
for example:</p>
<pre><code>words = ['hatch','catch','match','chat','mates'] 
pattern = '_atc_
</code></pre>
<p>needed output:</p>
<pre><code>['hatch','match']
</code></pre>
<p>I have tried to use nested for loops but it didn't work for a pattern that starts and ends with '_'</p>
<pre><code>def filter_words_list(words, pattern):
relevant_words = []
for word in words:
    if len(word) == len(pattern):
        for i in range(len(word)):
            for j in range(len(pattern)):
                if word[i] != pattern[i]:
                    break
                if word[i] == pattern[i]:
                    relevant_words.append(word)
</code></pre>
<p>thx !</p>
</div>
<div class="post-text" itemprop="text">
<p>So you should use regex. and replace the underscore with '.' which means any single character.
so the input looks like:</p>
<pre><code>words = ['hatch','catch','match','chat','mates'] 
pattern = '.atc.'
</code></pre>
<p>and the code is:</p>
<pre><code>import re
def filter_words_list(words, pattern):
ret = []
for word in words:
    if(re.match(pattern,word)):ret.append(word)
return ret
</code></pre>
<p>Hopes tha helped</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">regular expression</a>:</p>
<pre><code>import re

words = ['hatch','catch','match','chat','mates']
pattern = re.compile('[^atc]atc[^atc]')

result = list(filter(pattern.fullmatch, words))
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['hatch', 'match']
</code></pre>
<p>The pattern <code>'[^atc]atc[^atc]'</code> matches everything that is not a or t or c (<code>[^atc]</code>) followed by <code>'atc'</code> and again everything that is not a or t or c.  </p>
<p>As an alternative you could write your own matching function that will work with any given pattern:</p>
<pre><code>from collections import Counter


def full_match(word, pattern='_atc_'):
    if len(pattern) != len(word):
        return False

    pattern_letter_counts = Counter(e for e in pattern if e != '_')  # count characters that are not wild card
    word_letter_counts = Counter(word) # count letters

    if any(count != word_letter_counts.get(ch, 0) for ch, count in pattern_letter_counts.items()):
        return False

    return all(p == w for p, w in zip(pattern, word) if p != '_')  # the word must match in all characters that are not wild card


words = ['hatch', 'catch', 'match', 'chat', 'mates']


result = list(filter(full_match, words))
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['hatch', 'match']
</code></pre>
<p><strong>Further</strong></p>
<ol>
<li>See the documentation on the built-in functions <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer">any</a> and <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow noreferrer">all</a>.</li>
<li>See the documentation on <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter</a>.</li>
</ol>
</div>
<span class="comment-copy">Just replace "_" with ".", then use your pattern as regular expression</span>
<span class="comment-copy">what do you mean by replacing? the pattern is given</span>
<span class="comment-copy">There is a standard way of writing patterns in python. Your pattern however is using "_" - which is another syntax. So you simply need to convert your syntax to the standard syntax, then you can use the standard pattern matching library see <a href="https://docs.python.org/2/library/re.html" rel="nofollow noreferrer">docs.python.org/2/library/re.html</a> ... as shown in the way of the answer from Daniel Masejo</span>
