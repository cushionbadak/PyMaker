<div class="post-text" itemprop="text">
<p>I'm trying to get how many any character repeats in a word. The repetitions must be sequential. </p>
<p>For example, the method with input "loooooveee" should return 6 (4 times 'o', 2 times 'e').</p>
<p>I'm trying to implement string level functions and I can do it this way but, is there an easy way to do this? Regex, or some other sort of things?</p>
<p>So far I tried this:</p>
<pre><code>def measure_normalized_emphasis(text):
    char = text[-1]
    emphasis_size = 0
    for i in range(1, len(text)):
        if text[-i] == char:
            emphasis_size += 1
        else:
            char = text[i - 1]

    return emphasis_size
</code></pre>
<p>And it returns 8 with "loooooveee".</p>
</div>
<div class="post-text" itemprop="text">
<h3>Original question: <code>order of repetition does not matter</code></h3>
<p>You can subtract the number of unique letters by the number of total letters. <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="noreferrer"><code>set</code></a> applied to a string will return a unique collection of letters.</p>
<pre><code>x = "loooooveee"
res = len(x) - len(set(x))  # 6
</code></pre>
<p>Or you can use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="noreferrer"><code>collections.Counter</code></a>, subtract 1 from each value, then <code>sum</code>:</p>
<pre><code>from collections import Counter

c = Counter("loooooveee")

res = sum(i-1 for i in c.values())  # 6
</code></pre>
<h3>New question: <code>repetitions must be sequential</code></h3>
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer"><code>itertools.groupby</code></a> to group sequential identical characters:</p>
<pre><code>from itertools import groupby

g = groupby("aooooaooaoo")
res = sum(sum(1 for _ in j) - 1 for i, j in g)  # 5
</code></pre>
<p>To avoid the nested <code>sum</code> calls, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="noreferrer"><code>itertools.islice</code></a>:</p>
<pre><code>from itertools import groupby, islice

g = groupby("aooooaooaoo")
res = sum(1 for _, j in g for _ in islice(j, 1, None))  # 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a regular expression if you want:</p>
<pre><code>import re

rx = re.compile(r'(\w)\1+')

repeating = sum(x[1] - x[0] - 1
                for m in rx.finditer("loooooveee")
                for x in [m.span()])
print(repeating)
</code></pre>
<p>This correctly yields <code>6</code> and makes use of the <code>.span()</code> function.<br/>
<hr/>
The expression is</p>
<pre><code>(\w)\1+
</code></pre>
<p>which captures a <em>word character</em> (one of <code>a-zA-Z0-9_</code>) and tries to repeat it as often as possible.<br/>
See <a href="https://regex101.com/r/W3zzoe/1" rel="nofollow noreferrer"><strong>a demo on regex101.com</strong></a> for the repeating pattern.
<hr/>
If you want to match any character (that is, not only word characters), change your expression to:</p>
<pre><code>(.)\1+
</code></pre>
<p>See <a href="https://regex101.com/r/W3zzoe/3" rel="nofollow noreferrer"><strong>another demo on regex101.com</strong></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>try this:</p>
<pre><code>word=input('something:')

sum = 0

chars=set(list(word)) #get the set of unique characters

for item in chars: #iterate over the set and output the count for each item
    if word.count(char)&gt;1:
       sum+=word.count(char)
    print('{}|{}'.format(item,str(word.count(char)))

print('Total:'+str(sum))
</code></pre>
<p>EDIT:</p>
<p>added total count of repetitions</p>
</div>
<div class="post-text" itemprop="text">
<p>Since it doesn't matter where the repetition is occurring or which characters are being repeated, you can make use of the <code>set</code> data structure provided in Python. It will discard the duplicate occurrences of any character or an object.</p>
<p>Therefore, the solution would look something like this:</p>
<pre><code>def measure_normalized_emphasis(text):
    return len(text) - len(set(text))
</code></pre>
<p>This will give you the exact result.</p>
<p>Also, make sure to look out for some edge cases, which you should as it is a good practice.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think your code is comparing the wrong things</p>
<p>You start by finding the last character:</p>
<pre><code>char = text[-1]
</code></pre>
<p>Then you compare this to itself:</p>
<pre><code>for i in range(1, len(text)):
    if text[-i] == char: #&lt;-- surely this is test[-1] to begin with?
</code></pre>
<p>Why not just run through the characters:</p>
<pre><code>def measure_normalized_emphasis(text):
    char = text[0]
    emphasis_size = 0
    for i in range(1, len(text)):
        if text[i] == char:
            emphasis_size += 1
        else:
            char = text[i]

    return emphasis_size
</code></pre>
<p>This seems to work.</p>
</div>
<span class="comment-copy">I think you missed the "<i>The repetitions must be sequential</i>" part of the question.</span>
<span class="comment-copy">@MuhammadAhmad Ahh. The question got edited while I was answering. However, it seems that jpp has already given a clear explanation.</span>
