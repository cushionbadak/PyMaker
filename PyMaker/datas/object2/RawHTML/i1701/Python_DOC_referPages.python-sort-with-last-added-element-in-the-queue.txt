<div class="post-text" itemprop="text">
<p>Actually my sort algorithm works, but there is a problem.
I have a class namely SortedItem which includes</p>
<pre><code>def __init__(self, point, cost):
    self.coordinate = point
    self.cost = cost
</code></pre>
<p>and I have also priority queue which sorts the this SortedItem by its cost:</p>
<pre><code>class PriorityQueue:

def __init__(self):
    self.items = []

def isEmpty(self):
    return self.items == []

def sortComparatorByCost(self, item):
    return item.cost

def enqueue(self, item):
    self.items.append(item)
    self.items.sort(key=self.sortComparatorByCost, reverse=True)


def dequeue(self):
    return self.items.pop()

def returnQueueAsString(self):
    queue_str = ""
    for eachItem in self.items:
        queue_str += str(eachItem) + " "
    return queue_str

def isQueueContainsElement(self, element):
    for eachElement in self.items:
        if eachElement[0] == element:
            return True
    return False
</code></pre>
<p>The problem occurs here:
- I have defined some order to add queue. Let's say I am adding this objects to the queue:</p>
<pre><code>obj1 = SortedItem((1,0), 10))
queue.enqueue(obj1)
obj2 = SortedItem((2,0), 15))
queue.enqueue(obj2)
obj3 = SortedItem((2,1), 15))
queue.enqueue(obj3)
</code></pre>
<ul>
<li>Now I have to get objects from queue in this order (obj1, obj2, obj3).</li>
<li>However python built-in sort function sort these objects like this: (obj1, obj3, obj2) (because obj2 and obj3 has the same cost)</li>
<li>How can i solve this issue. I mean If 2 objects cost is the same, I should get the first added one. </li>
</ul>
<p><strong>Note that: I have just created a simple example of my problem. If you try this code you may get the objects in this order: obj1, obj2, obj3</strong> </p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of sorting the items in reverse order and removing them from the right,</p>
<blockquote>
<pre><code>def enqueue(self, item):
    self.items.append(item)
    self.items.sort(key=self.sortComparatorByCost, reverse=True)

def dequeue(self):
    return self.items.pop()
</code></pre>
</blockquote>
<p>you could remove them from the left. That would avoid reversing the order of insertion of the items with the same cost. </p>
<pre><code>def enqueue(self, item):
    self.items.append(item)
    self.items.sort(key=self.sortComparatorByCost)

def dequeue(self):
    return self.items.pop(0)
</code></pre>
<p>Removing items from the beginning of a list <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">is not efficient</a>, however, so you could better use a <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>deque</code></a> (replacing <code>pop(0)</code> by <code>popleft()</code>) to fix that. A <code>deque</code> on the other hand, has no in-place <code>sort()</code> method, so would need to replace <code>self.items.sort()</code> by <code>self.items = deque(sorted(self.items))</code> as well.</p>
</div>
<span class="comment-copy">Hint: Python sort is stable.</span>
<span class="comment-copy">By the way -- why don't you use Python's builtin PQ?</span>
<span class="comment-copy">@user202729 that's means?</span>
<span class="comment-copy">@user202729 I couldn't understand built-in priority queue in python. This way is more understandable for me</span>
<span class="comment-copy">thanks, but i have the same problem.</span>
<span class="comment-copy">@monstereo You're right, that didn't work as I thought. I've found a better solution.</span>
<span class="comment-copy">thanks a lot, problem is solved ....</span>
