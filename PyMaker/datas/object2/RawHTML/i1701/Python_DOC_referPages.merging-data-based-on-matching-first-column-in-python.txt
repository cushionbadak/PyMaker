<div class="post-text" itemprop="text">
<p>I currently have two sets of data files that look like this:</p>
<p>File 1:</p>
<pre><code>test1 ba ab cd dh gf
test2 fa ab cd dh gf
test3 rt ty er wq ee
test4 er rt sf sd sa
</code></pre>
<p>and in file 2:</p>
<pre><code>test1 123 344 123
test1 234 567 787
test1 221 344 566
test3 456 121 677
</code></pre>
<p>I would like to combine the files based on mathching rows in the first column (so that "tests" match up)</p>
<p>like so:</p>
<pre><code>test1 ba ab cd dh gf 123 344 123
test1 ba ab cd dh gf 234 567 787
test1 ba ab cd dh gf 221 344 566
test3 rt ty er wq ee 456 121 677
</code></pre>
<p>I have this Code</p>
<pre><code>def combineFiles(file1,file2,outfile):
      def read_file(file):
         data = {}
         for line in csv.reader(file):
            data[line[0]] = line[1:]
         return data
      with open(file1, 'r') as f1, open(file2, 'r') as f2:
         data1 = read_file(f1)
         data2 = read_file(f2)
         with open(outfile, 'w') as out:
            wtr= csv.writer(out)
            for key in data1.keys():
               try:
                  wtr.writerow(((key), ','.join(data1[key]), ','.join(data2[key])))
               except KeyError:
                  pass
</code></pre>
<p>However the output ends up looking like this:</p>
<pre><code>test1 ba ab cd dh gf 123 344 123
test3 er rt sf sd sa 456 121 677
</code></pre>
<p>Can anyone help me with how to make the output so that test1 can be printed all three times?</p>
<p>Much Appreciated</p>
</div>
<div class="post-text" itemprop="text">
<p>While I would recommend <a href="https://stackoverflow.com/a/53292483/1822698">Brad Solomon's approach</a> as it's pretty succinct, you just need a small change in your code. </p>
<p>Since your second file is the one that has the "final say", you just need to create a dictionary for the first file. Then you can write the output file as you read from the second file, fetching values from the <code>data1</code> dictionary as you go:</p>
<pre><code>with open(file1, 'r') as f1, open(file2, 'r') as f2:
    data1 = read_file(f1)
    with open(outfile, 'w') as out:
        wtr = csv.writer(out, delimiter=' ')
        for line in csv.reader(f2, delimiter=' '):
            # only write if there is a corresponding line in file1
            if line[0] in data1:
                # as you write, get the corresponding file1 data
                wtr.writerow(line[0:] + data1[line[0]] + line[1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might want to give the <a href="https://pandas.pydata.org/pandas-docs/stable/index.html" rel="nofollow noreferrer">Pandas</a> library a try; it makes cases like this easy:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; pd.merge(df1, df2, on='testnum', how='inner')
  testnum 1_x 2_x 3_x   4   5  1_y  2_y  3_y
0   test1  ba  ab  cd  dh  gf  123  344  123
1   test1  ba  ab  cd  dh  gf  234  567  787
2   test1  ba  ab  cd  dh  gf  221  344  566
3   test3  rt  ty  er  wq  ee  456  121  677
</code></pre>
<hr/>
<p>This assumes the test column is named "testnum".</p>
<pre><code>&gt;&gt;&gt; df1
  testnum   1   2   3   4   5
0   test1  ba  ab  cd  dh  gf
1   test2  fa  ab  cd  dh  gf
2   test3  rt  ty  er  wq  ee
3   test4  er  rt  sf  sd  sa

&gt;&gt;&gt; df2
  testnum    1    2    3
0   test1  123  344  123
1   test1  234  567  787
2   test1  221  344  566
3   test3  456  121  677
</code></pre>
<p>You'd read these in with <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html" rel="nofollow noreferrer"><code>pd.read_csv()</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue is that you are overwriting the keys in the line </p>
<pre><code>data[line[0]] = line[1:]
</code></pre>
<p>Since your files have non-unique "keys," you could try manually making them unique using <a href="https://www.programiz.com/python-programming/methods/built-in/enumerate" rel="nofollow noreferrer"><code>enumerate</code></a>:</p>
<pre><code>for ind, line in enumerate(csv.reader(file)):
    unique_key = ''.join([line[0], "_", str(ind)])
    data[unique_key] = line[1:]
</code></pre>
<p>Later, when you merge the result, you can strip the keys to remove anything after the underscore:</p>
<pre><code>wtr.writerow(((key.split("_")[0], ','.join(data1[key]), ','.join(data2[key])))
</code></pre>
<p>To my taste, this is all very clumsy. If your goal is to read, manipulate, and write data to and from csv files, I would recommend looking into <a href="https://pandas.pydata.org/" rel="nofollow noreferrer">pandas</a>, as this code can be written in a few lines using <a href="https://pandas.pydata.org/pandas-docs/version/0.21/generated/pandas.DataFrame.html" rel="nofollow noreferrer">DataFrames</a> (see the answer by <a href="https://stackoverflow.com/a/53292483/10615276">Brad Solomon</a>).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try collecting your items into seperate <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict()</code></a>, then get the cartesian product of the intersecting rows with <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product()</code></a>:</p>
<pre><code>from collections import defaultdict
from itertools import product

def collect_rows(file):
    collection = defaultdict(list)

    for line in file:
        col1, *rest = line.split()
        collection[col1].append(rest)

    return collection

with open("file1.txt") as f1, open("file2.txt") as f2, open("output.txt", "w") as out:
    f1_collection = collect_rows(f1)
    f2_collection = collect_rows(f2)

    # Ordered intersection, no need to sort
    set_2 = set(f2_collection)
    intersection = [key for key in f1_collection if key in set_2]

    for key in intersection:
        for x, y in product(f1_collection[key], f2_collection[key]):
            out.write("%s\n" % " ".join([key] + x + y))
</code></pre>
<p>Which gives the following <em>output.txt</em>:</p>
<pre><code>test1 ba ab cd dh gf 123 344 123
test1 ba ab cd dh gf 234 567 787
test1 ba ab cd dh gf 221 344 566
test3 rt ty er wq ee 456 121 677
</code></pre>
<p><strong>Note:</strong> It's probably easier to follow <a href="https://stackoverflow.com/questions/53292432/merging-data-based-on-matching-first-column-in-python/53292483#53292483">Brad Solomon's</a> Pandas approach, since it can be done with one command. </p>
</div>
