<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/41807864/regex-matching-5-digit-substrings-not-enclosed-with-digits">Regex matching 5-digit substrings not enclosed with digits</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I have the following string:</p>
<pre><code>1 2 134 2009
</code></pre>
<p>And I'd like to capture the strings with between 1-3 digits, so the result should be:</p>
<pre><code>['1', '2', '134']
</code></pre>
<p>What I have now captures those, but also captures the "first 3" digits in strings that contain more than 3 digits. This is the current regex I have:</p>
<pre><code>&gt;&gt;&gt; re.findall(r'\d{1,3}', '1 2 134 2009')
['1', '2', '134', '200', '9']

# or a bit closer --

&gt;&gt;&gt; re.findall(r'\d{1,3}(?!\d)', '1 2 134 2009')
['1', '2', '134', '009']
</code></pre>
<p>What would be the correct way to make sure that another digit doesn't immediate proceed it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Add word boundaries:</p>
<pre><code>import re

result = re.findall(r'\b\d{1,3}\b', '1 2 134 2009')

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['1', '2', '134']
</code></pre>
<p>From the <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">documentation</a> <code>\b</code>:</p>
<blockquote>
<p>Matches the empty string, but only at the beginning or end of a word.
  A word is defined as a sequence of word characters. Note that
  formally, \b is defined as the boundary between a \w and a \W
  character (or vice versa), or between \w and the beginning/end of the
  string. This means that r'\bfoo\b' matches 'foo', 'foo.', '(foo)',
  'bar foo baz' but not 'foobar' or 'foo3'.</p>
<p>By default Unicode alphanumerics are the ones used in Unicode
  patterns, but this can be changed by using the ASCII flag. Word
  boundaries are determined by the current locale if the LOCALE flag is
  used. Inside a character range, \b represents the backspace character,
  for compatibility with Pythonâ€™s string literals.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>If there are only digits separated by whitespace in your string, using <code>re</code> is overkill. You can simply <code>split</code> the string and check the length of the substrings.</p>
<pre><code>&gt;&gt;&gt; numbers = '1 2 134 2009'
&gt;&gt;&gt; [n for n in numbers.split() if len(n) &lt;= 3]
&gt;&gt;&gt; ['1', '2', '134']
</code></pre>
</div>
<span class="comment-copy">What is the logic to match <code>123</code> in <code>['1', '2', '123']</code></span>
<span class="comment-copy">@Thefourthbird I suppose that it would be a 'self-contained number', for example if someone looked the above string they could see that 4 numbers were contained in it. Not sure if I can give a more rigorous explanation.</span>
<span class="comment-copy">@Thefourthbird oh I see. Sorry that was a typo -- fixed.</span>
<span class="comment-copy">hmm... the dupe targets imply that this is a regex question. I still think it's not best solved with regex.</span>
<span class="comment-copy">This shouldn't have been closed, it's distinct. Voted to reopen.</span>
<span class="comment-copy"><i>In general</i>, Python <code>str</code> operations outperform regex, so I think this solution should preferred if the formatting constraints are as per the example data.</span>
