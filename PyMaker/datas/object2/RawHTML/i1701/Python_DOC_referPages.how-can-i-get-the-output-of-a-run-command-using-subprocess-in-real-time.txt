<div class="post-text" itemprop="text">
<p>I have a flask route that uses the subprocess module to call a Python script on the server. My problem is that this script downloads files, and the time it takes to do it is not possible to determine. I want to somehow update the client by getting the output of the subprocess. Here's the whole route:</p>
<pre><code>@app.route("/adyen_request_download", methods=["POST", "GET"])
def adyen_request_download():
    merchant_manager = MerchantManager()
    error = None
    if request.method == "POST":
        pfjs = []
        prefixes = []
        extensions = []
        ftpd = "/var/ftp/CONTROLE_TESTE"
        for result in request.get_json():
            if result["name"] == "pfj-select":
                pfjs.append(result["value"])
            if result["name"] == "prefix-select":
                prefixes.append(result["value"])
            if result["name"] == "extension-select":
                extensions.append(result["value"])
            if result["name"] == "start-date":
                start_date = result["value"]

        logging.info(f"Requisição de download manual de arquivos realizada.")
        logging.info(f"&gt;&gt; PFJs: {str(pfjs)}")
        logging.info(f"&gt;&gt; Prefixos: {str(prefixes)}")
        logging.info(f"&gt;&gt; Extensões: {str(extensions)}")
        logging.info(f"&gt;&gt; Data: {start_date}")
        if prefixes and not extensions:
            run_command = f'python ../InputDataController/acquirer_file_downloader.py --acquirer "adyen" --pfj {" ".join(pfjs)} --prefix {" ".join(prefixes)} --date "{start_date}" --ftpd "{ftpd}" --force'
        elif extensions and not prefixes:
            run_command = f'python ../InputDataController/acquirer_file_downloader.py --acquirer "adyen" --pfj {" ".join(pfjs)} --ext {" ".join(extensions)} --date "{start_date}" --ftpd "{ftpd}" --force'
        elif not prefixes and not extensions:
            run_command = f'python ../InputDataController/acquirer_file_downloader.py --acquirer "adyen" --pfj {" ".join(pfjs)} --date "{start_date}" --ftpd "{ftpd}" --force'
        elif prefixes and extensions:
            run_command = f'python ../InputDataController/acquirer_file_downloader.py --acquirer "adyen" --pfj {" ".join(pfjs)} --prefix {" ".join(prefixes)} --ext {" ".join(extensions)} --date "{start_date}" --ftpd "{ftpd}" --force'
        subprocess.run(run_command, shell=True) # HERE &lt;&lt;&lt;&lt;&lt;&lt;&lt;
    return json.dumps({"result": "ok"})
</code></pre>
<p>I saw the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.getoutput" rel="nofollow noreferrer">getoutput</a> method, but it's not exactly what I want, I need to get the shell output in <em>real-time</em> in some file. Is it possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer">documentation</a>, subprocess.run has a stdout argument. So I guess if you pass a file handler to it, the output would be written live and you should be able to read it. </p>
<p>Something like that (not tested) :</p>
<pre><code>with open(yourfile, "r+") as output_file:
    subprocess.run(run_command, shell=True, stdout=output_file)
    // loop to read the file while subprocess running
</code></pre>
</div>
