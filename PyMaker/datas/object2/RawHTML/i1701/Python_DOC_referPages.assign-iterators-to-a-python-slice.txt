<div class="post-text" itemprop="text">
<p>Are iterators consumed before being assigned to a slice in Python? By "consumed before being assigned" I mean the elements are created in the memory all at the same time (put into list or tuple) before the slice assignment happens.
The other approach would be to put the elements from the iterator in the slice one-by-one, so elements are not created in the memory all at the same time.</p>
<p>For example, let`s consider this code:</p>
<pre><code>from itertools import islice
from heapq import merge

c = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5] + list(range(10))
lo, mid, hi = 0, 10, 20
c[lo:hi] = merge(islice(iter(c), lo, mid), islice(iter(c), mid, hi))
</code></pre>
<p>merge returns an iterator that picks the smallest element of the two iterators given to merge. Would these iterator be consumed before the slice assignment happens?</p>
</div>
<div class="post-text" itemprop="text">
<p>This depends on the implementation of the sequence that is being slice-assigned into. The sequence receives the iterator directly, and the details of consuming the iterator are up to the sequence.</p>
<p>For lists, the current CPython implementation <a href="https://github.com/python/cpython/blob/v3.7.1/Objects/listobject.c#L606" rel="nofollow noreferrer">consumes the iterator up front</a> before any modification to the list:</p>
<pre><code>v_as_SF = PySequence_Fast(v, "can only assign an iterable");
</code></pre>
<p><a href="https://docs.python.org/3/c-api/sequence.html#c.PySequence_Fast" rel="nofollow noreferrer"><code>PySequence_Fast</code></a> will build a list out of any argument that isn't already a list or tuple.</p>
<p>There's also self-assignment handling, because turning the input into a list isn't enough to be safe when you're slice-assigning a list into itself:</p>
<pre><code>/* Special case "a[i:j] = a" -- copy b first */
v = list_slice(b, 0, Py_SIZE(b));
</code></pre>
<p>I don't think any of this list behavior is documented.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>UPDATED ANSWER:</strong></p>
<p>Yes, the given <strong>iterables</strong> consumes before passing to slice():</p>
<p><strong>For empirical proof a simple example with memory approx. consuming:</strong></p>
<p>1.) An example code with <strong>10e6</strong> elements of array.</p>
<pre><code>from itertools import islice
from heapq import merge

c = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5] + list(range(int(10e6)))
lo, mid, hi = 0, 10, 20

c[lo:hi] = merge(islice(iter(c), lo, mid), islice(iter(c), mid, hi))
</code></pre>
<p>There's no noticable time and memory consumption.</p>
<p>2.) The same code with <strong>10e7</strong> elements of array.</p>
<pre><code>c = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5] + list(range(int(10e7)))
</code></pre>
<p>meant <strong>30%</strong> of total memory consumption of the same configuration.</p>
<p>3.) The same code with <strong>10e8</strong> elements of array.</p>
<p>Ends up in a <strong>100%+</strong> memory need of course.</p>
<blockquote>
<p>Note that the <strong>volume of slicing remained the same</strong>, but the memory
  consumption increased significantly.</p>
</blockquote>
</div>
<span class="comment-copy">Sry for misunderstanding your question see my updated answer for a bit proof.</span>
<span class="comment-copy">Oh, looks like it is not safe in general to do things like assigning a part of the sequence back to the sequence through the set of iterators (so the self-assignment workaround won`t help). Am I right?</span>
<span class="comment-copy">@OlegLokshyn: That's safe for a list - the iterator will be consumed first. The self-assignment handling is necessary to handle the one specific case where <code>PySequence_Fast</code> isn't enough.</span>
<span class="comment-copy">The question is about the iterators and slice assignment on the <code>c[lo:hi] = merge(islice(iter(c), lo, mid), islice(iter(c), mid, hi))</code> line, not about the <code>range</code>. (Also, <code>range</code> objects are lazy <i>sequences</i>, not iterators.)</span>
<span class="comment-copy">@user2357112 Yes you're right I misunderstood the question, so I revoke it and also it's true the lazy sequence too of course. I started to answer, wanted to fix it and improve it but apparently wasn't more time, anyway Thanks PS: btw. the principals are the same.</span>
<span class="comment-copy">@user2357112 see my update of empirical strengthen answer and thank you for your valuable comment.</span>
