<div class="post-text" itemprop="text">
<pre><code>def expand(nums):
    finalword = ''
    position = 0
    wordlength = len(nums)
    keypoint = ''
    while position &lt;= wordlength:
        keypoint = nums[position] * int(nums[position + 1])
        finalword = finalword + keypoint
        keypoint = 0
        position + 2
    return finalword
</code></pre>
<p>For some reason, this function does not return a value. I am trying to get the integers after a char to multiply said char. I add 2 to position due to a char being on every 2nd index</p>
<pre><code>print(expand("d3o5z2y1")) #should output: dddooooozzy
</code></pre>
<p>What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You never update <code>position</code>. </p>
<p><code>position + 2</code> just does a calculation without storing the value of that calculation anywhere. You probably wanted <code>position = position + 2</code>.</p>
<p>In addition, you are off-by-one with <code>position &lt;= wordlength</code> because the last index of <code>nums</code> is <code>len(nums) - 1</code>. Change it to <code>position &lt; wordlength</code>.</p>
<p>With these changes</p>
<pre><code>print(expand("d3o5z2y1"))
</code></pre>
<p>produces</p>
<pre><code>'dddooooozzy'
</code></pre>
<p>However, your way of extracting the characters and the counts is a bit clunky. I suggest using the <code>grouper</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipe</a> from the <code>itertools</code> docs.</p>
<pre><code>&gt;&gt;&gt; s = "d3o5z2y1"
&gt;&gt;&gt; list(zip(*[iter(s)]*2))
&gt;&gt;&gt; [('d', '3'), ('o', '5'), ('z', '2'), ('y', '1')]
&gt;&gt;&gt;
&gt;&gt;&gt; ''.join(char*int(count) for char, count in zip(*[iter(s)]*2))
&gt;&gt;&gt; 'dddooooozzy'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your line:</p>
<pre><code>position + 2
</code></pre>
<p>does not <em>changes</em> the value of the <code>position</code>. You calculate <code>position + 2</code>, and then throw that value away, you should assign the result to position, so:</p>
<pre><code>def expand(nums):
    finalword = ''
    position = 0
    wordlength = len(nums)
    keypoint = ''
    while <b>position &lt; wordlength</b>:
        keypoint = nums[position] * int(nums[position + 1])
        finalword = finalword + keypoint
        keypoint = 0
        <b>position = position + 2</b>  # or more compact: position += 2
    return finalword</code></pre>
<p>the bound check should be replaced with <code>&lt;</code> since if the position is equal to the length, we already have an index that is too large.</p>
<p>A lot of lines are also unnecessary, we can remove a lot of lines, and retain:</p>
<pre><code>def expand(nums):
    finalword = ''
    wordlength = len(nums)
    <b>for position in range(0, len(nums), 2)</b>:
        keypoint = nums[position] * int(nums[position + 1])
        finalword += keypoint
    return finalword</code></pre>
<p>That being said, you can improve the above by using an <code>iter(..)</code>ator, and <code>zip</code>:</p>
<pre><code>def expand(nums):
    inums = iter(nums)
    return ''.join(c * int(n) for c, n in zip(inums, inums))
</code></pre>
</div>
