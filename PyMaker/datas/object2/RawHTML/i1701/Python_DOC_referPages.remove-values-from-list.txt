<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1207406/how-to-remove-items-from-a-list-while-iterating">How to remove items from a list while iterating?</a>
<span class="question-originals-answer-count">
                    23 answers
                </span>
</li>
</ul>
</div>
<p>I have the following problem: </p>
<p>I have a list:</p>
<pre><code>temp= [950, 1000, 1100, 1200, 1400, 1450, 1500, 1600, 1650, 1700, 1900, 1950, 2000, 2100, 2200]
</code></pre>
<p>in this list I want to remove every value that is <code>&lt; 1200 and &gt; 1950</code>.</p>
<p>I tried the following: </p>
<pre><code>for x in temp:
    if x &lt; 1200 or x &gt; 1950:
        temp.remove(x)
</code></pre>
<p>That gives me the following result:</p>
<pre><code>[1000, 1200, 1400, 1450, 1500, 1600, 1650, 1700, 1900, 1950, 2100]
</code></pre>
<p>But the output I am aiming for would be the following: </p>
<pre><code>[1200, 1400, 1450, 1500, 1600, 1650, 1700, 1900, 1950]
</code></pre>
<p>I found a way to complete my task with slicing: </p>
<pre><code>new_temp = temp[temp.index(1200):temp.index(1950)+1]
</code></pre>
<p>That gives me the output I want:</p>
<pre><code>[1200, 1400, 1450, 1500, 1600, 1650, 1700, 1900, 1950]
</code></pre>
<p>But I would like to understand why <strong>attemp1</strong> doesnÂ´t work and if maybe there are better ways to fulfil my task than <strong>attemp2</strong></p>
<p>Can anyone help? Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would create a function for identifying valid values:</p>
<pre><code>def validated(value):
    return 1200 &lt;= value &lt;= 1950
</code></pre>
<p>Then you can use this in a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>:</p>
<pre><code>&gt;&gt;&gt; [value for value in temp if validated(value)]
[1200, 1400, 1450, 1500, 1600, 1650, 1700, 1900, 1950]
</code></pre>
<p>Or you can use <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer"><strong><code>filter</code></strong></a></p>
<pre><code>&gt;&gt;&gt; list(filter(validated, temp))
[1200, 1400, 1450, 1500, 1600, 1650, 1700, 1900, 1950]
</code></pre>
<p><strong>edit</strong>: The reason you were having trouble is because you can't modify something you are iterating over. It doesn't "know" that you've pulled the rug out from under it.</p>
<p>An alternative is to make a copy of the list and iterate over that instead.</p>
<pre><code>temp2 = temp[:]  # makes a copy
for x in temp2:
    if x &lt; 1200 or x &gt; 1950:
        temp.remove(x)
</code></pre>
<p>Also, the <code>remove</code> is a linear search (which is slow). It's usually better to do the filter. If you really need to modify the list <code>temp</code> refers to (rather than just making <code>temp</code> point at a different list) you can do:</p>
<pre><code>temp[:] = [value for value in temp if validated(value)]
</code></pre>
<p><code>[:]</code> is a slice operator which if you assign to it will replace the entire contents of the original list (rather than assigning a new list to the name).</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <strong>attempt1</strong> doesn't work because you modify the same list that you loop over. This can lead to all sort of weird behaviour like skipping some values.  Here's an example:</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2]
&gt;&gt;&gt; for val in lst:
...     lst.remove(val)
... 
&gt;&gt;&gt; lst
[2]  # wat?
</code></pre>
<p>Just don't do that: <strong>never modify the list you loop over</strong>.</p>
<p>And for the record here's the simpliest correct way (not necessarily fastest):</p>
<pre><code>result = [value for value in temp if 1200 &lt;= value &lt;= 1950]
</code></pre>
<p>Also note that your slicing method <code>temp[temp.index(1200):temp.index(1950)+1]</code> works only under the assumption that the list is sorted. And under this assumption we can get a lot faster then any of the presented method. i.e. we could do binary search + slice. But the complexity might not be worth it unless you deal with millions of values.</p>
</div>
<div class="post-text" itemprop="text">
<p>@freakish answer above is correct, I just want to make it more clearer.</p>
<p><strong>Skipping values due the list iteration</strong> is the main problem of this behaviur</p>
<p>See python list iteration visualization in <em>for</em> loop down below</p>
<hr/>
<p><em>iteration 1</em></p>
<p><code>temp= [950, 1000, 1100, 1200, 1400, 1450, 1500, 1600, 1650, 1700, 1900, 1950, 2000, 2100, 2200]</code></p>
<p><code>currentIndex = 0</code> (item with value <strong>950</strong>)</p>
<p><em>removing element with index 0</em> </p>
<p>going to second iteration</p>
<hr/>
<p><em>iteration 2</em></p>
<p>temp looks like that</p>
<p><code>temp= [1000, 1100, 1200, 1400, 1450, 1500, 1600, 1650, 1700, 1900, 1950, 2000, 2100, 2200]</code></p>
<p><code>currentIndex = 1</code> (item with value <strong>1100</strong>)</p>
<p><em>removing element with index 1</em> </p>
<p>going to third iteration</p>
<hr/>
<p><em>iteration 3</em></p>
<p>temp looks like that</p>
<p><code>temp= [1000, 1200, 1400, 1450, 1500, 1600, 1650, 1700, 1900, 1950, 2000, 2100, 2200]</code></p>
<p><code>currentIndex = 2</code> (item with value <strong>1400</strong>)</p>
<p><code>1400 &lt; 1200</code> then going to next element.</p>
<hr/>
<p>I hope it should be enought to clearly understand what's going on due such iteration. To avoid such behaviour try to use other methods list exporessions or numpy arrays.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import numpy as np
temp= np.array([950, 1000, 1100, 1200, 1400, 1450, 1500, 1600, 1650, 1700, 1900, 1950, 2000, 2100, 2200])
temp[(temp&gt;=1200) &amp; (temp&lt;=1950)]
</code></pre>
<p>Output:</p>
<pre><code>array([1200, 1400, 1450, 1500, 1600, 1650, 1700, 1900, 1950])
</code></pre>
</div>
<span class="comment-copy"><code>new_list = [num for num in temp if num &gt; 1200 and num &lt; 1950]</code></span>
<span class="comment-copy">What you want is a list comprehension with inline <code>if</code>. If you can't figure out the code from that information let me know ;)</span>
<span class="comment-copy">thanks for the answers. I dont know why my question got graded down, but i can accept that. But it would be very helpful to know why to maybe improve one day. Without any comments to my question in behave of downgrading I unfortunately can not improve myself</span>
<span class="comment-copy">There's no reason to downvote the question. I've upvoted it.</span>
<span class="comment-copy">Although there was no reason to downvote, It was downvoted because it was a rookie mistake. Don't worry everybody has their opinions.</span>
<span class="comment-copy">I've restrained myself from giving deeper explanation because this behaviour depends on concrete Python implementation, if I'm correct.</span>
<span class="comment-copy">I represent the problem above on Python 2.7.14.</span>
<span class="comment-copy">Thanks for the correction. My mistake</span>
