<div class="post-text" itemprop="text">
<pre><code>class Stack(object):

    def __init__(self):
        self.stack = []

    def __str__(self):
        return self.stack

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        popped = self.stack.pop()
        print(popped)

    def isEmpty(self):
        if len(self.stack) == 0:
            print("True")
        else:
            print("False")

    def __len__(self):
        return len(self.stack)
</code></pre>
<p>I am trying to have the list returned when I call upon the object in interactive mode. This is what keeps happening:</p>
<pre><code>&gt;&gt;&gt; s = Stack()
&gt;&gt;&gt; s.push("Plate 1")
&gt;&gt;&gt; s.push("Plate 2")
&gt;&gt;&gt; s.push("Plate 3")
&gt;&gt;&gt; s
&lt;__main__.Stack object at 0x0000017E06ED4E10&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the methodology you may be looking for is documented here:
<a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables</a></p>
<p>Modified example code:</p>
<pre><code>class Stack:
    stack_list = []
    def __init__(self, name):
        self.name = name
    def push(self, item):
        self.stack_list.append(item)
</code></pre>
<p>The 'push' method appends items to the 'stack_list' when it's called.</p>
<pre><code>stack = Stack('the_stack')
stack.push('example1')
stack.push('example2')
stack.push('example3')
stack.stack_list
['example1', 'example2', 'example3']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The Python interactive shell prints the representation, not the string, so you need to implement a <code>__repr__</code> method. But both <code>__str__</code> and <code>__repr__</code> should always return a string. So try:</p>
<pre><code>def __str__(self):
    return str(self.stack)

def __repr__(self):
    return repr(self.stack)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd suggest first to override <code>__repr__</code> instead of <code>__str__</code> to match your goal, however below you can find both approaches for the class: </p>
<pre><code>class Stack(object):
    def __init__(self):
        self.stack = []
    def __str__(self):
        return str(self.stack)
    def __repr__(self):
        return repr(self.stack)
    def push(self, item):
        self.stack.append(item)
    def pop(self):
        popped = self.stack.pop()
        print(popped)
    def isEmpty(self):
        if len(self.stack) == 0:
            print("True")
        else:
            print("False")
    def __len__(self):
        return len(self.stack)
</code></pre>
<p>Basically, what happened earlier you were triggering the representation of the object which is what you've called when you simply put <code>s</code>.</p>
<p>To have it transform to, let's say, a string representation you could do:</p>
<pre><code>def __str__(self):
    return str(self.stack)
</code></pre>
<p>Analogously, you could do it for <code>__repr__</code>.</p>
<p>A example of its execution:</p>
<pre><code>&gt;&gt;&gt; s = Stack()
&gt;&gt;&gt; print(s)
[]
&gt;&gt;&gt; s.push(1)
&gt;&gt;&gt; print(s) #this uses __str__
[1]
&gt;&gt;&gt; s  #this uses __repr__
[1]
</code></pre>
<p>For deeper reference on the differences among them, you could check following thread <a href="https://stackoverflow.com/questions/1436703/difference-between-str-and-repr">Difference between __str__ and __repr__?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of returning the '<code>self.stack</code>' from the <code>__str__()</code> function, you can return the list as shown below:</p>
<pre><code>class Stack(object):

def __init__(self):
    self.stack = []

def __str__(self):
    return str(list(plates for plates in self.stack))

def push(self, item):
    self.stack.append(item)

def pop(self):
    popped = self.stack.pop()
    print(popped)

def isEmpty(self):
    if len(self.stack) == 0:
        print("True")
    else:
        print("False")

def __len__(self):
    return len(self.stack)

s = Stack()
s.push("Plate 1")
s.push("Plate 2")
s.push("Plate 3")
print(s)
</code></pre>
<p>Output:</p>
<pre><code>['Plate 1', 'Plate 2', 'Plate 3']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are two things to note here:</p>
<ol>
<li>When the REPL evals an object, it uses its <code>__repr__</code> method for presentation.</li>
<li>Your <code>__str__</code> method will cause errors because it does not return a string.</li>
</ol>
<p>After running your code, the following behavior can be observed:</p>
<pre><code>&gt;&gt;&gt; s.stack
&gt;&gt;&gt; ['Plate 1', 'Plate 2', 'Plate 3']
&gt;&gt;&gt; print(s)
[...]
TypeError: __str__ returned non-string (type list)
&gt;&gt;&gt; repr(s)
&gt;&gt;&gt; '&lt;__main__.Stack object at 0x7fe358f7e240&gt;'
</code></pre>
<p>To fix these issues, implement <code>__repr__</code>, for example like this:</p>
<pre><code>def __repr__(self):
    return repr(self.stack)
</code></pre>
<p>Now</p>
<pre><code>&gt;&gt;&gt; s
&gt;&gt;&gt; ['Plate 1', 'Plate 2', 'Plate 3']
</code></pre>
<p>shows the content of <code>s.stack</code>. In addition, you can remove the <code>__str__</code> method, because when printing, <code>__repr__</code> will be called as a fallback when there's no <code>__str__</code> implementation.</p>
<pre><code>&gt;&gt;&gt; del Stack.__str__
&gt;&gt;&gt; print(s)
['Plate 1', 'Plate 2', 'Plate 3']
</code></pre>
<p>If you want to keep <code>__str__</code>, make sure to modify it in order to return a <code>str</code> object, otherwise you'll get a <code>TypeError</code> as demonstrated above.</p>
<hr/>
<p>A little more about <code>__repr__</code>:</p>
<p>Ideally, the method should return a string such that when copy pasted into the interpreter, an equal object will be built. Since your <code>__init__</code> method accepts no arguments, it's not possible here to display an informative string that would be evaluated as an instance of <code>Stack</code> and show the content of the stack at the same time. </p>
<p>If you changed <code>__init__</code> to</p>
<pre><code>def __init__(self, iterable=None):
    if iterable is None:
        self.stack = []
    else:
        self.stack = list(iterable)
</code></pre>
<p>you could change <code>__repr__</code> to</p>
<pre><code>def __repr__(self):
    return 'Stack({!r})'.format(self.stack)
</code></pre>
<p>which would look like this when implemented:</p>
<pre><code>&gt;&gt;&gt; s
&gt;&gt;&gt; Stack(['Plate 1', 'Plate 2', 'Plate 3'])
</code></pre>
<p>... eval'ing this string would create a <code>Stack</code> with the same content.</p>
<hr/>
<p>While we're at it, consider implementing <code>__eq__</code> for good measure...</p>
<pre><code>def __eq__(self, other):
    return isinstance(other, Stack) and self.stack == other.stack
</code></pre>
<p>... such that:</p>
<pre><code>&gt;&gt;&gt; s == eval(repr(s))
&gt;&gt;&gt; True
</code></pre>
</div>
<span class="comment-copy">The list is in <code>s.stack</code>. <code>s</code> is just an object without a <code>__repr__</code>.</span>
<span class="comment-copy">Do you mean that you want the string representation to list the contents of your stack? In which case you should define <code>__repr__</code> on your class.</span>
<span class="comment-copy">"I am trying to have the list returned when I call upon the object in interactive mode" - first, those words don't mean what you're trying to say. Second, what you're trying to do is a recipe for horrible confusion. It'd be better to display something like <code>Stack(['Plate 1', 'Plate 2', 'Plate 3'])</code>, with a constructor that accepts arguments like that.</span>
<span class="comment-copy">When you type a variable in interactive mode it prints <code>repr(s)</code>, not <code>str(s)</code>.</span>
<span class="comment-copy">The <code>__str__</code> method should always return a string.</span>
<span class="comment-copy">What's the point of calling <code>list()</code> on a list comprehension? And why do you need to make a copy when calling <code>str()</code>?</span>
<span class="comment-copy">Yes, right. Returning str(self.stack) from __str__() function will also work.</span>
