<div class="post-text" itemprop="text">
<p>I have 2 different lists:</p>
<pre><code>l1 = ['a','b','a','e','b','c','a','d']
l2 = ['t1','t2','t3','t4','t5','t6','t7','t8']
</code></pre>
<p>The lengths of <code>l1</code> and <code>l2</code> will always be the same. They're in fact logical mappings - each item in <code>l1</code> corresponds to a value in <code>l2</code>.</p>
<p>I wanted to identify distinct elements in <code>l1</code>. I did that using <code>set</code> and <code>list comprehension</code> as follows:</p>
<pre><code>used = set()
distl1 = [x for x in l1 if x not in used and (used.add(x) or True)]
</code></pre>
<p>Here, the output will be:</p>
<pre><code>distl1 = ['a','b','e','c','d']
</code></pre>
<p>which is nothing but the first occurrence of every distinct element.</p>
<p>Now, how do I build a list <code>distl2</code> so that I get the output as the value in <code>l2</code> that corresponds to the first occurrence's value i.e., <code>distl1</code>?</p>
<pre><code>distl2 = ['t1','t2','t4','t6','t8']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My idea is to use an <code>OrderedDict</code> to build a mapping of (key, value) pairs corresponding to the elements of <code>l1</code> and <code>l2</code> and then extract the <code>values</code> from that dict as a list.</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; 
&gt;&gt;&gt; l1 = ['a','b','a','e','d','c','a','b']
&gt;&gt;&gt; l2 = ['t1','t2','t3','t4','t5','t6','t7','t8']
&gt;&gt;&gt; 
&gt;&gt;&gt; d = OrderedDict()
&gt;&gt;&gt; for k, v in zip(l1, l2):
...:    if k not in d: # &lt;--- check if this key has already been seen!
...:        d[k] = v
...:        
&gt;&gt;&gt; distl2 = list(d.values())
&gt;&gt;&gt; distl2
&gt;&gt;&gt; ['t1', 't2', 't4', 't5', 't6']
</code></pre>
<p>Note for Python 3.7+ users: regular dicts are guaranteed to remember their key insertion order, so you can omit importing the <code>OrderedDict</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also do this:</p>
<pre><code>distl2 = [l2[l1.index(key)] for key in distl1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Python 3.6+</h3>
<p>Dictionaries are ordered in Python 3.6+, as an implementation detail in 3.6 and confirmed in 3.7+. So in this case you can use <code>dict</code> with an iterable which ignores duplicates. To ignore duplicates, you can use the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> <code>unique_everseen</code> recipe</a>, also available via 3rd party <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_everseen" rel="nofollow noreferrer"><code>more_itertools.unique_everseen</code></a> or <a href="https://toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.unique" rel="nofollow noreferrer"><code>toolz.unique</code></a>:</p>
<pre><code>from operator import itemgetter
from toolz import unique

l1 = ['a','b','a','e','b','c','a','d']
l2 = ['t1','t2','t3','t4','t5','t6','t7','t8']

keys, values = zip(*dict(unique(zip(l1, l2), key=itemgetter(0))).items())

print(keys)

('a', 'b', 'e', 'c', 'd')

print(values)

('t1', 't2', 't4', 't6', 't8')
</code></pre>
<h3>Python 2.7</h3>
<p>You can use <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> instead of <code>dict</code> for Python 2.7, where dictionaries are not ordered:</p>
<pre><code>from collections import OrderedDict

keys, values = zip(*OrderedDict(unique(zip(l1, l2), key=itemgetter(0))).items())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The question doesn't say if you need to preserve the order. If not, list of unique values of <code>l1</code> would be:</p>
<pre><code>distl1 = list(set(l1))
</code></pre>
<p>And the corresponding values of <code>l2</code>:</p>
<pre><code>distl2 = [l2[l1.index(value)] for value in distl1]
</code></pre>
<p>(where <code>index()</code> always returns the first occurrence)</p>
<p>The resulting lists will keep your logical mapping, in the random order:</p>
<pre><code>['b', 'e', 'c', 'd', 'a']
['t2', 't4', 't6', 't8', 't1']
</code></pre>
<p><strong>EDIT:</strong></p>
<p>Another approach (no dictionaries, no <code>index()</code> in a loop, order preserved, 2.7 friendly):</p>
<pre><code>l1 = ['a','b','a','e','b','c','a','d']
l2 = ['t1','t2','t3','t4','t5','t6','t7','t8']

distl1 = []
distl2 = []

for i, val in enumerate(l1):
    if val not in distl1:
        distl1.append(val)
        distl2.append(l2[i])
</code></pre>
</div>
<span class="comment-copy">The great thing about this solution is it removes the need to calculate keys (<code>distl1</code>) via OP's messy list comprehension. <code>list(d)</code> gives the keys for free.</span>
<span class="comment-copy">@jpp I would keep the list comprehension as well. Coz I need to maintain that in a separate list too.</span>
<span class="comment-copy">@skrowten_hermit, Why would you do that when you can use <code>list(d)</code> with @timgeb's solution?</span>
<span class="comment-copy">@jpp That was enlightening. I am glad I posted that comment. :)</span>
<span class="comment-copy">Very succinct (+1), but note that this has O(n*m) time complexity where n and m refer to the lengths of <code>distl1</code> and <code>l1</code>.</span>
<span class="comment-copy">That's true, hash tables really are always the answer</span>
<span class="comment-copy">Well it's not so clear cut. Fancy algorithms are slow for small inputs. Using dicts <i>scales</i> better but if the inputs are very small your listcomp could actually be faster.</span>
<span class="comment-copy">So, this would work decent for inputs less than, say, 20?</span>
<span class="comment-copy">@skrowten_hermit these probably will both seem instantaneous in that case. Just choose the one that is more readable for you. But the dictionary answer is better in long term and should be accepted as correct.</span>
<span class="comment-copy">OP tagged 2.7 tho :)</span>
<span class="comment-copy">Your answer is of course still usefull because all questions/answers should ideally be useful for futures readers.</span>
<span class="comment-copy">@timgeb, Added the trivial change for 2.7 :)</span>
<span class="comment-copy">@jpp I added a simple straightforward solution using <code>enumerate()</code>.</span>
