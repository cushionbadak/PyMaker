<div class="post-text" itemprop="text">
<p>I am trying to convert the JSON in the bbox (bounding box) column into a simple array of values for a DL project in python in a Jupyter notebook.</p>
<p>The possible labels are the following categories: [glass, cardboard, trash, metal, paper].</p>
<pre><code>[{"left":191,"top":70,"width":183,"height":311,"label":"glass"}]

TO

([191 70 183 311], 0)
</code></pre>
<p>I'm looking for help to convert the bbox column from the JSON object for a single CSV that contains all the image names and the related bboxes. </p>
<p><a href="https://i.stack.imgur.com/IUczs.png" rel="nofollow noreferrer"><img alt="FN and BBOX" src="https://i.stack.imgur.com/IUczs.png"/></a></p>
<p><strong>UPDATE</strong></p>
<p>The current column is a series so I keep getting a "TypeError: the JSON object must be str, bytes or bytearray, not 'Series'" any time I try to apply JSON operations on the column. So far I have tried to convert the column into JSON object and then pull out the values from the keys.</p>
<p>BB_CSV 
<a href="https://i.stack.imgur.com/OmeJ8.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/OmeJ8.png"/></a></p>
<p><a href="https://i.stack.imgur.com/kjhT5.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/kjhT5.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>You'll want to use a JSON decoder: <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">https://docs.python.org/3/library/json.html</a></p>
<p></p>
<pre><code>import json
li = json.loads('''[{"left":191,"top":70,"width":183,"height":311,"label":"glass"}]''')
d = dictionary = li[0]
result = ([d[key] for key in "left top width height".split()], 0)
print(result)
</code></pre>
<hr/>
<p><strong>Edit:</strong></p>
<p>If you want map the operation of extracting the values from the dictionary to all element of the list, you can do:</p>
<pre><code>extracted = []
for element in li:
    result = ([element[key] for key in "left top width height".split()], 0)
    extracted.append(result)

# print(extracted)
print(extracted[:10])
# `[:10]` is there to limit the number of item displayed to 10
</code></pre>
<p>Similarly, as per my comment, if you do not want commas between the extracted numbers in the list, you can use:</p>
<pre><code>without_comma = []
for element, zero in extracted:
    result_string = "([{}], 0)".format(" ".join([str(value) for value in element]))
    without_comma.append(result_string)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It looks like each row of your <code>bbox</code> column contains a <code>dictionary</code> inside of a <code>list</code>. I've tried to replicate your problem as follows. <strong>Edit:</strong> Clarifying that the below solution assumes that what you're referring to as a "JSON object" is represented as a <code>list</code> containing a single dictionary, which is what it appears to be per your example and screenshot.</p>
<pre><code># Create empty sample DataFrame with one row
df = pd.DataFrame([None],columns=['bbox'])

# Assign your sample item to the first row
df['bbox'][0] = [{"left":191,"top":70,"width":183,"height":311,"label":"glass"}]
</code></pre>
<p>Now, to simple <em>unpack</em> the row you can do:</p>
<pre><code>df['bbox_unpacked'] = df['bbox'].map(lambda x: x[0].values())
</code></pre>
<p>Which will get you a new column with a <code>tuple</code> of 5 items.</p>
<p>If you want to go further and apply your labels, you'll likely want to create a dictionary to contain your labeling logic. Per the example you're given in the comments, I've done: </p>
<pre><code>labels = {
    'cardboard': 1,
    'trash': 2,
    'glass': 3
}
</code></pre>
<p>This should get your your desired layout if you want a one-line solution without writing your own function.</p>
<pre><code>df['bbox_unpacked'] = df['bbox'].map(lambda x: (list(x[0].values())[:4],labels.get(list(x[0].values())[-1])))
</code></pre>
<p>A more readable solution would be to define your own function using the <code>.apply()</code> method. <strong>Edit:</strong> Since it looks like your JSON object is being stored as a <code>str</code> inside your <code>DataFrame</code> rows, I added <code>json.loads(row)</code> to process the string first before retrieving the keys. You'll need to <code>import json</code> to run.</p>
<pre><code>import json    

def unpack_bbox(row, labels):

    # load the string into a JSON object (in this
    # case a list of length one containing the dictionary;
    # index the list to its first item [0] and use the .values()
    # dictionary method to access the values only 

    keys = list(json.loads(row)[0].values())

    bbox_values = keys[:4]
    bbox_label = keys[-1]

    label_value = labels.get(bbox_label)

    return bbox_values, label_value

df['bbox_unpacked'] = df['bbox'].apply(unpack_bbox,args=(labels,))
</code></pre>
</div>
<span class="comment-copy">what is 0 for  ?</span>
<span class="comment-copy">@W-B 0 is the number that represents the label. 1 would be cardboard, 2 would be trash so on and so forth</span>
<span class="comment-copy">@cleme001, have you tried anything as of now in order to achieve it, that will also provide a clue what really is needed.</span>
<span class="comment-copy">You can add <code>assert dictionary["label"] in "glass cardboard trash metal paper".split()</code> if you want to check that the label is value is correct, and get an error if it isn't.</span>
<span class="comment-copy">If you do not want commas between the values in the bbox, use <code>print("([{}], 0)".format(" ".join(str(d[key]) for key in "left top width height".split())))</code></span>
<span class="comment-copy">So I managed to get this to work for my use case tweaking your code a bit but since .split only does it for the first instance of the json object the pictures that I have with multiple annotations don't get properly converted. e.g. [{"left":191,"top":70,"width":183,"height":311,"label":"glass"}, {"left":200,"top":60,"width":132,"height":318,"label":"glass"}]</span>
<span class="comment-copy">For some reason I get multiple rows when I do BB_CSV['bbox'][0] - added an image to the post.</span>
<span class="comment-copy">@cleme001 The <code>df['bbox'][0]</code> snippet was just to show how I assigned your sample list to a row of a sample <code>DataFrame</code> to replicate your issue. Have you tried <code>BB_CSV['bbox'].map(lambda x: x[0].values())</code> to unpack your rows?</span>
<span class="comment-copy">The issue seems to be that the row it self is not a string but rather a numpyndarray so I'm getting this error.   BB_CSV['bbox'][0].values() --------------------------------------------------------------------------- TypeError                                 Traceback (most recent call last) &lt;ipython-input-29-57c5ca36959f&gt; in &lt;module&gt;() ----&gt; 1 BB_CSV['bbox'][0].values()  TypeError: 'numpy.ndarray' object is not callable</span>
<span class="comment-copy">Also if you look at the image I attached to the original post you'll see that when I even try to look at a single row I get back 5 different things not just the value of the row.</span>
<span class="comment-copy">@cleme001 Does your DataFrame have duplicate values in it's index? Can you try <code>df.reset_index(drop=True, inplace=False)</code> and try it again?</span>
