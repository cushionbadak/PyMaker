<div class="post-text" itemprop="text">
<p>I am in confusion when trying to understand the order that <code>metaclass</code> creates a class instance. According to this <strong>diagram</strong> (<a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/#id28" rel="nofollow noreferrer">source</a>), <a href="https://i.stack.imgur.com/Ex3jx.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/Ex3jx.png"/></a></p>
<p>I type the following <strong>codes</strong> to verify it.</p>
<pre><code>class Meta(type):
    def __call__(self):
        print("Meta __call__")
        super(Meta, self).__call__()

    def __new__(mcs, name, bases, attrs, **kwargs):
        print("Meta __new__")
        return super().__new__(mcs, name, bases, kwargs)

    def __prepare__(msc, name, **kwargs):
        print("Meta __prepare__")
        return {}

class SubMeta(Meta):
    def __call__(self):
        print("SubMeta __call__!")
        super().__call__()

    def __new__(mcs, name, bases, attrs, **kwargs):
        print("SubMeta __new__")
        return super().__new__(mcs, name, bases, kwargs)

    def __prepare__(msc, name, **kwargs):
        print("SubMeta __prepare__")
        return Meta.__prepare__(name, kwargs)

class B(metaclass = SubMeta):
    pass

b = B()
</code></pre>
<p>However, the result seems not like this follow.</p>
<pre><code>SubMeta __prepare__
Meta __prepare__
SubMeta __new__
Meta __new__
SubMeta __call__!
Meta __call__
</code></pre>
<p>Any help will be appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Despite @torek's lenghty answer, with a lot of <em>other</em> details on class creation, what you brought together to this question is mostly correct.</p>
<p>The only thing that is wrong in your code, which propably puzzled you is that te class you call <code>Meta</code> have to be itself the  <strong>metaclass</strong> from <code>SubMeta</code> and not its parent.</p>
<p>Simply change <code>Submeta</code> declaration to:</p>
<pre><code>class SubMeta(type, metaclass=Meta):
    ...
</code></pre>
<p>(No need for it to inherit from "Meta" as well - it can derive only from <code>type</code>. It is otherwise though to think of a customization to <code>type.__call__</code> that would be usefull at the same time for creating instances of your classes (that is when <code>SubMeta.__call__</code> is called), and your classes themselves (<code>Meta.__call__</code> called))</p>
<p>Here is another, shorter example I just typed at the terminal. Sorry for the naming inconsistencies, and for being less complete - but it shows the main point:</p>
<pre><code>class M(type):
    def __call__(mmcls, *args, **kwargs):
        print("M's call", args, kwargs)
        return super().__call__(*args, **kwargs)

class MM(type, metaclass=M):
    def __prepare__(cls, *args, **kw):
        print("MM Prepare")
        return {}
    def __new__(mcls, *args, **kw):
        print("MM __new__")
        return super().__new__(mcls, *args, **kw)

class klass(metaclass=MM):
    pass
</code></pre>
<p>Upon processing the <code>klass</code> body, Python output was:</p>
<pre><code>MM Prepare
M's call ('klass', (), {'__module__': '__main__', '__qualname__': 'klass'}) {}
MM __new__
</code></pre>
<h1>Moreover</h1>
<p>As you can see from this, with a meta-meta class it is possible to customize the call order and parameters to the metaclass <code>__init__</code> and <code>__new__</code>, <em>but</em> there are still steps that can't be customized from pure-Python code, and would require native calls to API's (and possibly raw object structure manipulation) - that are:</p>
<ul>
<li>One can't control the call to <code>__prepare__</code></li>
<li>One can't control the call to <code>__init_subclass__</code> on the created classes </li>
<li>One can control when descriptors' <code>__set_name__</code> are called</li>
</ul>
<p>The last two items take place after meta-meta's <code>__call__</code> return, and before resuming the flow to the module where the class module is.</p>
</div>
<div class="post-text" itemprop="text">
<h3>The trick, identified</h3>
<p><strong>Update 2:</strong> Based on behavior, the fact that <code>M0.__call__</code> is called below <em>must</em> be a side effect of <a href="https://github.com/python/cpython/blob/cd449806fac1246cb7b4d392026fe6986ec01fb7/Python/bltinmodule.c#L214" rel="nofollow noreferrer">this line</a> in <code>builtin__build_class</code> in the CPython source (<code>Python/bltinmodule.c</code>).</p>
<p>In order to define a class that has a metaclass, we call the metaclass's <code>__prepare__</code>, <code>__new__</code>, and <code>__init__</code> as usual.  This creates a class—in the example below, <code>Meta</code>—that is callable, but its internal <code>PyFunction_GET_CODE</code> slot points not to <em>its own</em> <code>__call__</code> but rather to its metaclass's <code>__call__</code>.  Hence if we call <code>Meta()</code> (the metaclass object), we invoke <code>M0.__call__</code>:</p>
<pre><code>print("call Meta")
print("Meta returns:", Meta('name', (), {}))
print("finished calling Meta")
</code></pre>
<p>produces:</p>
<pre><code>call Meta
M0 __call__: mmcls=&lt;class '__main__.Meta'&gt;, args=('name', (), {}), kwargs={}
Meta __new__: mcs=&lt;class '__main__.Meta'&gt;, name='name', bases=(), attrs={}, kwargs={}
Meta __init__: mcs=&lt;class '__main__.name'&gt;, name='name', bases=(), attrs={}, kwargs={}
Meta returns: &lt;class '__main__.name'&gt;
finished calling Meta
</code></pre>
<p>In other words, we see that <code>Meta</code> acts like <code>type</code>, but it (rather magically and not very well documented) invokes <code>M0.__call__</code>.  This is no doubt due to looking up <code>__call__</code> in the class's type, rather than in an instance of the class (and indeed there is no instance except for the one we're creating).  This is in fact the general case: it falls out of the fact that we call <code>__call__</code> on the <em>type</em> of <code>Meta</code>, and the type of <code>Meta</code> is <code>M0</code>:</p>
<pre><code>print("type(Meta) =", type(Meta))
</code></pre>
<p>prints:</p>
<pre><code>type(Meta) = &lt;class '__main__.M0'&gt;
</code></pre>
<p>which explains where this comes from.  (I still think this should be emphasized in the documentation, which also should describe the constraints on metaclass typing—these are enforced in <a href="https://github.com/python/cpython/blob/cd449806fac1246cb7b4d392026fe6986ec01fb7/Lib/types.py#L125-L140" rel="nofollow noreferrer"><code>_calculate_winner</code> in <code>Lib/types.py</code></a> and, as C code, <a href="https://github.com/python/cpython/blob/cd449806fac1246cb7b4d392026fe6986ec01fb7/Objects/typeobject.c#L2318-L2352" rel="nofollow noreferrer">in <code>_PyType_CalculateMetaclass</code> in Objects/typeobject.c</a>.)</p>
<h3>Updated original answer</h3>
<p><s>I don't know where your diagram came from, but it's wrong.</s> <strong>UPDATE:</strong> You can in fact have a metaclass for your metaclass; see <a href="https://stackoverflow.com/a/53255735/1256452">jsbueno's answer</a>, and I've updated the example below.  New sentences / text are in <strong>bold,</strong> except for the final section describing my puzzlement at the apparent lack of documentation.</p>
<p>Your existing metaclass code has at least one error.  Most significantly, its <code>__prepare__</code> needs to be a class-method.  See also <a href="https://stackoverflow.com/q/6966772/1256452">Using the __call__ method of a metaclass instead of __new__?</a> and <a href="https://www.python.org/dev/peps/pep-3115/" rel="nofollow noreferrer">PEP 3115</a>.  <strong>And, to use a meta-meta-class, your metaclass needs to have a metaclass of its own, <em>not</em> a base class.</strong></p>
<p><a href="https://stackoverflow.com/a/53191742/1256452">Chris's answer</a> contains correct definitions.  But there are some unfortunate asymmetries between metaclass method arguments and class method arguments, which I'll illustrate below.</p>
<p>One other thing that may help: note that the metaclass <code>__prepare__</code> method is called <em>before creating any instances of class <code>B</code>:</em> it is called when <code>class B</code> itself is being defined.  To show this, here is a corrected metaclass-and-class.  I have also added a few more illustrators.  <strong>I've added a meta-metaclass as well, based on jsbueno's answer.  I cannot find formal Python documentation on this, but I've updated the output below.</strong></p>
<pre><code>class M0(type):
    def __call__(mmcls, *args, **kwargs):
        print("M0 __call__: mmcls={!r}, "
              "args={!r}, kwargs={!r}".format(mmcls, args, kwargs))
        return super().__call__(*args, **kwargs)

class Meta(type, metaclass=M0):
    def __call__(cls, *args, **kwargs):
        print("Meta __call__: cls={!r}, "
              "args={!r}, kwargs={!r}".format(cls, args, kwargs))
        return super().__call__(*args, **kwargs)

    def __new__(mcs, name, bases, attrs, **kwargs):
        print("Meta __new__: mcs={!r}, name={!r}, bases={!r}, "
              "attrs={!r}, kwargs={!r}".format(mcs, name, bases, attrs, kwargs))
        return super().__new__(mcs, name, bases, attrs)

    def __init__(mcs, name, bases, attrs, **kwargs):
        print("Meta __init__: mcs={!r}, name={!r}, bases={!r}, "
              "attrs={!r}, kwargs={!r}".format(mcs, name, bases, attrs, kwargs))
        super().__init__(name, bases, attrs, **kwargs)

    @classmethod
    def __prepare__(cls, name, bases, **kwargs):
        print("Meta __prepare__: name={!r}, "
              "bases={!r}, kwargs={!r}".format(name, bases, kwargs))
        return {}

print("about to create class A")
class A(metaclass=Meta): pass
print("finished creating class A")

print("about to create class B")

class B(A, metaclass=Meta, foo=3):
    @staticmethod
    def __new__(cls, *args, **kwargs):
        print("B __new__: cls={!r}, "
              "args={!r}, kwargs={!r}".format(cls, args, kwargs))
        return super().__new__(cls)

    def __init__(self, *args, **kwargs):
        print("B __init__: args={!r}, kwargs={!r}, ".format(args, kwargs))

print("finished creating class B")

print("about to create instance b = B()")
b = B('hello', bar=7)
print("finished creating instance b")
</code></pre>
<p>Now, let's observe what happens when I run this, and take each piece apart:</p>
<pre><code>$ python3.6 meta.py
about to create class A
Meta __prepare__: name='A', bases=(), kwargs={}
M0 __call__: mmcls=&lt;class '__main__.Meta'&gt;, args=('A', (), {'__module__': '__main__', '__qualname__': 'A'}), kwargs={}
Meta __new__: mcs=&lt;class '__main__.Meta'&gt;, name='A', bases=(), attrs={'__module__': '__main__', '__qualname__': 'A'}, kwargs={}
Meta __init__: mcs=&lt;class '__main__.A'&gt;, name='A', bases=(), attrs={'__module__': '__main__', '__qualname__': 'A'}, kwargs={}
finished creating class A
</code></pre>
<p>To create class <code>A</code> itself, Python first calls the metaclass's <code>__prepare__</code>, delivering it the name of the class (<code>A</code>), the list of base classes (an empty tuple—it's called a list but is actually a tuple), and any keyword arguments (none).  As PEP 3115 notes, the metaclass needs to return a dictionary or <code>dict</code>-like object; this one does by just returning an empty dictionary, so we are good here.</p>
<p>(I don't print <code>cls</code> itself here, but if you do, you will see it is just <code>&lt;class '__main__.Meta'&gt;</code>.)</p>
<p>Next, having gotten a dictionary from <code>__prepare__</code>, Python <strong>first calls the meta-meta <code>__call__</code>, i.e., <code>M0.__call__</code>, passing the entire set of arguments as the <code>args</code> tuple.</strong>  It then populates the <code>__prepare__</code>-supplied dictionary with all the attributes for the class, passing this as the <code>attrs</code> to the metaclass <code>__new__</code> and <code>__init__</code>.  If you print the <code>id</code> of the dictionary returned from <code>__prepare__</code> and passed to <code>__new__</code> and <code>__init__</code> you will see they all match.</p>
<p>Since class <code>A</code> has no methods or data members, we see only the magic <code>__module__</code> and <code>__qualname__</code> attributes here.  We also see no keyword arguments, so now let's move on to creating class <code>B</code>:</p>
<pre><code>about to create class B
Meta __prepare__: name='B', bases=(&lt;class '__main__.A'&gt;,), kwargs={'foo': 3}
M0 __call__: mmcls=&lt;class '__main__.Meta'&gt;, args=('B', (&lt;class '__main__.A'&gt;,), {'__module__': '__main__', '__qualname__': 'B', '__new__': &lt;staticmethod object at 0x800ad0a58&gt;, '__init__': &lt;function B.__init__ at 0x800ad2840&gt;, '__classcell__': &lt;cell at 0x800a749d8: empty&gt;}), kwargs={'foo': 3}
Meta __new__: mcs=&lt;class '__main__.Meta'&gt;, name='B', bases=(&lt;class '__main__.A'&gt;,), attrs={'__module__': '__main__', '__qualname__': 'B', '__new__': &lt;staticmethod object at 0x800ad0940&gt;, '__init__': &lt;function B.__init__ at 0x800ad27b8&gt;, '__classcell__': &lt;cell at 0x800a745b8: empty&gt;}, kwargs={'foo': 3}
Meta __init__: mcs=&lt;class '__main__.B'&gt;, name='B', bases=(&lt;class '__main__.A'&gt;,), attrs={'__module__': '__main__', '__qualname__': 'B', '__new__': &lt;staticmethod object at 0x800ad0940&gt;, '__init__': &lt;function B.__init__ at 0x800ad27b8&gt;, '__classcell__': &lt;cell at 0x800a745b8: Meta object at 0x802047018&gt;}, kwargs={'foo': 3}
finished creating class B
</code></pre>
<p>This one is rather more interesting.  Now we have one base class, namely <code>__main__.A</code>.  Class <code>B</code> also defines several methods (<code>__new__</code> and <code>__init__</code>) and we see them in the <code>attrs</code> dictionaries passed to the metaclass <code>__new__</code> and <code>__init__</code> methods (which, remember, are just the now-populated dictionary returned by the metaclass's <code>__prepare__</code>).  <strong>As before, the passing-on happens through the meta-meta-class <code>M0.__call__</code>.</strong>  We also see one keyword argument throughout, <code>{'foo': 3}</code>.  In the attribute dictionary, we can also observe the magic <code>__classcell__</code> entry: see <a href="https://stackoverflow.com/q/41343263/1256452">Provide __classcell__ example for Python 3.6 metaclass</a> for a short description as to what this is about, but to be, er, <em>super</em>-short, it's for making <code>super()</code> work.</p>
<p>The keyword argument is passed to all three metaclass methods, plus that of the meta-meta-class.  (I'm not quite sure why.  Note that modifying the dictionary in any <em>metaclass</em> method does not affect it in any other, as it's a copy each time of the original keyword arguments.  <strong>However, we <em>can</em> modify it in the meta-meta-class: add <code>kwargs.pop('foo', None)</code> to <code>M0.__call__</code> to observe this.</strong>)</p>
<p>Now that we have our classes <code>A</code> and <code>B</code>, we can get on to the process of creating an actual instance of class <code>B</code>.  Now we see the metaclass's <code>__call__</code> invoked (not the meta-meta-class's):</p>
<pre><code>about to create instance b = B()
Meta __call__: cls=&lt;class '__main__.B'&gt;, args=('hello',), kwargs={'bar': 7}
</code></pre>
<p>It's possible to change the <code>args</code> or <code>kwargs</code> passed on, but I don't; the sample code above winds up calling <code>type.__call__(cls, *args, **kwargs)</code> (through the magic of <code>super().__call__</code>).  This in turn calls <code>B.__new__</code> and <code>B.__init__</code>:</p>
<pre><code>B __new__: cls=&lt;class '__main__.B'&gt;, args=('hello',), kwargs={'bar': 7}
B __init__: args=('hello',), kwargs={'bar': 7}, 
finished creating instance b
</code></pre>
<p>which finishes the realization of the new instance of class <code>B</code>, which we then bind to the name <code>b</code>.</p>
<p>Note that <code>B.__new__</code> says:</p>
<pre><code>return super().__new__(cls)
</code></pre>
<p>so we invoke <code>object.__new__</code> to create the instance—this is more or less a requirement of all versions of Python; you can only "cheat" when you return a singleton instance (ideally, one that's non-modifiable).  It's <code>type.__call__</code> that calls <code>B.__init__</code> on this object, passing the arguments and keyword-arguments we passed it.  If we replace <code>Meta</code>'s <code>__call__</code> with:</p>
<pre><code>    def __call__(cls, *args, **kwargs):
        print("Meta __call__: cls={!r}, "
              "args={!r}, kwargs={!r}".format(cls, args, kwargs))
        return object.__new__(cls)
</code></pre>
<p>we will see that <code>B.__new__</code> and <code>B.__init__</code> are <em>never called:</em></p>
<pre><code>about to create instance b = B()
Meta __call__: cls=&lt;class '__main__.B'&gt;, args=('hello',), kwargs={'bar': 7}
finished creating instance b
</code></pre>
<p>This would, in effect, create a useless/uninitialized instance <code>b</code>.  It's therefore critical that the metaclass <code>__call__</code> method call the underlying class's <code>__init__</code>, usually by invoking <code>type.__call__</code> via <code>super().__call__</code>.  If the underlying class has a <code>__new__</code>, the metaclass should call that first, again usually by invoking <code>type.__call__</code>.</p>
<h3>Side note: what <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">the documentation</a> says</h3>
<p>To quote section 3.3.3.6:</p>
<blockquote>
<p>Once the class namespace has been populated by executing the class body, the class object is created by calling <code>metaclass(name, bases, namespace, **kwds)</code> (the additional keywords passed here are the same as those passed to <code>__prepare__</code>).</p>
</blockquote>
<p>This explains the call to <code>Meta.__call__</code> when creating <code>b</code> as an instance of class <code>B</code>, but not the fact that Python first calls <code>M0.__call__</code> before calling <code>Meta.__new__</code> and <code>Meta.__init__</code> when creating classes <code>A</code> and <code>B</code> themselves.</p>
<p>The next paragraph mentions the <code>__classcell__</code> entry; the one after that goes on to describe the use of <code>__set_name__</code> and <code>__init_subclass__</code> hooks.  Nothing here tells us how or why Python calls <code>M0.__call__</code> at this point.</p>
<p>Earlier, in sections 3.3.3.3 through 3.3.3.5, the documentation describes the process of determining the metaclass, preparing the class namespace, and executing the class body.  This is where the meta-metaclass action <em>should</em> be described, but isn't.</p>
<p>Several additional sections describe a few additional constraints.  One important one is 3.3.10, which talks about how special methods are found via the object type, bypassing both regular member attribute lookups and even (sometimes) a metaclass getattribute, saying:</p>
<blockquote>
<p>Bypassing the <code>__getattribute__()</code> machinery in this fashion provides significant scope for speed optimisations within the interpreter, at the cost of some flexibility in the handling of special methods (the special method <em>must</em> be set on the class object itself in order to be consistently invoked by the interpreter).</p>
</blockquote>
<p><strong>Update 2: This is really the secret of the trick: the special <code>__call__</code> method is found via the type's type.  If the metaclass has a metaclass, the meta-meta-class provides the <code>__call__</code> slot; otherwise the type of the metaclass is <code>type</code>, so that the <code>__call__</code> slot is <code>type.__call__</code>.</strong></p>
</div>
<span class="comment-copy">Where <i>did</i> you get that diagram? Google image search didn't turn up anything like it.</span>
<span class="comment-copy">For those arriving at this question trying to understand meta-classes in Python, have a look at <a href="https://stackoverflow.com/questions/17801344/understanding-metaclass-and-inheritance-in-python" title="understanding metaclass and inheritance in python">stackoverflow.com/questions/17801344/…</a> instead.</span>
<span class="comment-copy">The diagram is from the following blog (I've submitted an edit to the original question as well): <a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/#id28" rel="nofollow noreferrer">blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/…</a></span>
<span class="comment-copy">Despite your lenghty answer, and rather usefull information on the process of class creation, you did not touch the subject of the "meta-meta-class" call method, the OP is in doubt about. In fact, there is only a simple mistake in the OP's code - and the diagram posted in the question is actually correct.</span>
<span class="comment-copy">While I'm not sure whether I agree with jsbueno about what the mistake in the questioner's code is, I agree that you seem to have missed the meta-metaclass aspect, and that the diagram in the question is correct.</span>
<span class="comment-copy">@jsbueno: interesting. I haven't seen this described elsewhere. Indeed, <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html</a> makes no mention of it while describing how regular metaclasses work.</span>
<span class="comment-copy">@user2357112: indeed, testing shows it works—but there seems to be no hint of this in any documentation I can find.</span>
<span class="comment-copy">Thanks a million for your detailed answer, I learned a lot. The diagram comes from the blog — <a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/#putting-it-all-together" rel="nofollow noreferrer">understanding-python-metaclasses</a>.  Just like mentioned by <b>jsbueno</b>,  Meta-metaclass should  <code>class SubMeta(type, metaclass=Meta):</code> rather than <code>class SubMeta(Meta):</code>.</span>
