<div class="post-text" itemprop="text">
<p>Having some problem testing property of the class with unittest. Here is simple example</p>
<p>Example class:</p>
<pre><code>class Company(object):
    def __init__(self, name):
        self.name = name
</code></pre>
<p>TestSuite for this class with a simple case to check it's <code>name</code> property value:</p>
<pre><code>import unittest
class CompanySuite(unittest.TestCase):

    def setUp(self):
        self.company = Company

    def tearDown(self):
        del self.company

    def test_company_name(self):
        check_name = "NewestCompany"
        self.assertEqual(check_name, self.company.name, "Name isn't correct")
</code></pre>
<p>and <code>main</code> module:</p>
<pre><code>if __name__ == "__main__":
    firm = Company("NewestCompany")
    print(firm.name)
    unittest.main()
</code></pre>
<p>Alltogether it gives the result of execution of the main module:</p>
<pre><code>NewestCompany
E
======================================================================
ERROR: test_company_name (__main__.CompanySuite)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "D:/test/main 2.py", line 19, in test_company_name
    self.assertEqual(check_name, self.company.name, "Name isn't correct")
AttributeError: type object 'Company' has no attribute 'name'

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (errors=1)
</code></pre>
<p>Can't find where is the problem with it - how to properly access this <code>name</code> property from <code>__init__</code>?</p>
<hr/>
<p>EDITED:</p>
<p>Ok, turns out that it can be fixed by:</p>
<ol>
<li><p>Add fixed <code>name</code> attribute to the <code>Company</code> in <code>SetUp</code> method:</p>
<pre><code>def setUp(self):
    self.company = Company(name="NewestCompany")
</code></pre></li>
<li><p>Add concrete instanse as a <code>company</code> value:</p>
<pre><code>def setUp(self):
    self.company = firm
</code></pre></li>
</ol>
<p>So updated question - is there any way to define <code>SetUp</code> so it works with instances, that will be defined depend on the user in main?</p>
</div>
<div class="post-text" itemprop="text">
<p>Doing <code>self.company = Company(name="NewestCompany")</code> in <code>setUp</code> is the <strong>correct</strong> way to initialise for each test. (Because it is executed before each test in that class.)</p>
<p>When you create <code>firm</code> in <code>if __name__ == "__main__":</code>, then <code>self.company = firm</code> in <code>setUp</code> will refer to the same global <code>firm</code> instance for all tests. So if you change an attribute in one test, it will affect that attribute in other tests. For example, the second test <code>test_company_name_two</code> will fail:</p>
<pre><code>class CompanySuite(unittest.TestCase):

    def setUp(self):
        self.company = firm  # this is the global firm instance, created just once in main

    def tearDown(self):
        del self.company  # this won't prevent the failure in test_company_name_two
                          # since it's the same `firm` instance in setUp()

    def test_company_name(self):
        check_name = "NewestCompany"
        self.assertEqual(check_name, self.company.name, "Name isn't correct")
        self.company.name = "Newer Name"  # changes the global `firm` instance

    def test_company_name_two(self):  # this will fail since company name is now "Newer Name"
        check_name = "NewestCompany"
        self.assertEqual(check_name, self.company.name, "Name isn't correct")
</code></pre>
<p>Option 1 in your edit is the solution:</p>
<blockquote>
<ol>
<li><p>Add fixed <code>name</code> attribute to the <code>Company</code> in <code>SetUp</code> method:</p>
<pre><code>def setUp(self):
    self.company = Company(name="NewestCompany")
</code></pre></li>
</ol>
</blockquote>
<p>That creates a new instance of the company for each test.</p>
<hr/>
<blockquote>
<p>So updated question - is there any way to define SetUp so it works with instances, that will be defined depend on the user in main?</p>
</blockquote>
<p>Yes, the 2nd option in your edit does that; but wrongly. What do you want to achieve? If you want the firm's name or other attributes to be globally defined, you could always put it as a global or in if-main, along with any other attributes you want common among the test instances:</p>
<pre><code>if __name__ == "__main__":
    FIRM_NAME = "NewestCompany"
    FIRM_OTHER_ATTR = "something else"
    unittest.main()


class CompanySuite(unittest.TestCase):
    def setUp(self):
        self.company = Company(FIRM_NAME, other_attr=FIRM_OTHER_ATTR)
</code></pre>
</div>
<span class="comment-copy">In <code>setUp()</code>, put parentheses and an argument after <code>Company</code>.</span>
<span class="comment-copy">It is correct that class <code>Company</code> doesnt have attribute <code>name</code>. You should make an instance of it's class. <code>Company('test_name')</code></span>
<span class="comment-copy">You don't need that tearDown method.</span>
<span class="comment-copy">1. Well, changing it to self.company = Company(name="NewestCompany") fixed the problem. But can i somehow made it to read name from concrete 'firm' object from this - firm = Company("NewestCompany") ?</span>
<span class="comment-copy">2. Isn't instance is created by firm = Company("NewestCompany") 3. Well i can remove it, but it's not the source of the problem</span>
<span class="comment-copy">Thanks for detailed answer. I was wondered, if this could works with instanses that is created not in each test, but during the execution of the <code>main</code>. Like, there are - a basic clas, tests that covered some cases to check for this class and main module. During the execution user creates some instanses of this class and performs some executions on it. And then <code>unittest</code> test exactly those instanses created before in <code>main</code>, not that was set up for this test each test.</span>
<span class="comment-copy">If I understood what you meant: You want to <i>first</i> create several instances of this class and re-use them across multiple tests, even as they are changing? Well, in that case you can create the the global instances in main (not in <code>setUp()</code>), probably as a list or dictionary and then at the start of each test, do <code>company = companies[3]</code> or <code>company = companies['NewestCompany']</code>. It could be a valid use-case of not initialising before each test. You could also put these in <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUpClass" rel="nofollow noreferrer"><code>setUpClass()</code></a> if it's per-class.</span>
