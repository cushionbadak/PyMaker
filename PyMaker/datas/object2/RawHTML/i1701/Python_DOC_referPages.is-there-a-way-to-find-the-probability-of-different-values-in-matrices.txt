<div class="post-text" itemprop="text">
<p>I thought there would be a library that would help me to do this task instead of writing many lines of codes. I tried finding some solutions from books related to my problem, but I could not find any. </p>
<p>One of the recent books I did read related to probability:</p>
<blockquote>
<p>Python for Probability, Statistics, and Machine Learning for Jos√©
  Unpingco</p>
</blockquote>
<p>The task is that I have a matrix like this one below</p>
<pre><code>0    1
213 vha
342 gha
523 xha
121 gha
812 gha
612 vha
123 gha
</code></pre>
<p>and I want the program to calculate the steps of moving from, say, <code>vha</code> to <code>gha</code> in the second row. and from <code>gha</code> to <code>xha</code> in the third row. If any step is repeated, it will be added to the previous step. For example <code>vha</code> to <code>gha</code> in the first and second rows is repeated at the end of the matrix.</p>
<p>The desired output is will be the <code>similar steps added together</code>/ <code>total number of rows-1</code>. In the first case it is <code>vha</code> to <code>gha</code> prob = 2/7-1</p>
<p>Desired output</p>
<pre><code>vha to gha prob = 0.3
gha to xha prob = 0.16
xha to gha prob = 0.16
gha to gha prob = 0.16
gha to vha prob = 0.16

Total probs = 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> to count how many times a transition occurs and then calculate probabilities for each transition.</p>
<p>You can use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> to combine two slices of the list <code>m</code> - one with the last element removed and another with the first element removed - to get tuples for adjacent elements. <code>zip(m[:-1], m[1:])</code> does that. Then can you can count similar tuples - which represent transitions - with a <code>Counter</code>:</p>
<pre><code>from collections import Counter

m = [[213, 'vha'],
     [342, 'gha'],
     [523, 'xha'],
     [121, 'gha'],
     [812, 'gha'],
     [612, 'vha'],
     [123, 'gha']]

c = Counter([(x[1], y[1]) for x, y in zip(m[:-1], m[1:])])
probs = [(e, v / (len(m) - 1)) for e, v in c.items()]

for p in probs:
    print(p)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>(('vha', 'gha'), 0.3333333333333333)                                                                                                                
(('gha', 'xha'), 0.16666666666666666)                                                                                                               
(('xha', 'gha'), 0.16666666666666666)                                                                                                               
(('gha', 'gha'), 0.16666666666666666)                                                                                                               
(('gha', 'vha'), 0.16666666666666666)
</code></pre>
</div>
<span class="comment-copy">What datatype is this "matrix"?</span>
<span class="comment-copy">it is <code>&lt;class 'list'&gt;</code></span>
<span class="comment-copy">Amazing! the code is working. I have accepted your answer. I am just wondering if you can explain how the program works or refer me to a link with an explanation. Regards</span>
<span class="comment-copy">@AbdulazizAlJumaia I've added links to documentation an a more detailed explanation. Hope that helps!</span>
<span class="comment-copy">It does :). Thanks</span>
