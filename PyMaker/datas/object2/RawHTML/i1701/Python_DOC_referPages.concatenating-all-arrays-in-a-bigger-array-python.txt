<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/952914/how-to-make-a-flat-list-out-of-list-of-lists">How to make a flat list out of list of lists?</a>
<span class="question-originals-answer-count">
                    38 answers
                </span>
</li>
</ul>
</div>
<p>I have a big array with many subarrays inside and am trying to join all of the ones inside. I know how to concatenate arrays, but since the number of inner arrays varies, I don't know to make one function to concatenate these ones. I understand that i'll need one or possibly more loops, but am not sure how to do it. So far I have been doing it manually like this and keep going till i get to the last index:</p>
<pre><code>ldata  = ldata[0]+ldata[1]+ldata[2]+ldata[3]+ldata[4]
</code></pre>
<p>where ldata is the bigger list, and all of the indexes are the inner lists. How do I do this?</p>
<p>Edit: Here is an example</p>
<pre><code>a = [[1,2],[3,4],[5,6]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer">chain.from_iterable</a>:</p>
<pre><code>from itertools import chain

a = [[0, 1], [2, 3], [4, 5], [6, 7]]
result = list(chain.from_iterable(a))

print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[0, 1, 2, 3, 4, 5, 6, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can grab each sublist and add to a new list.</p>
<pre><code>new_ldata = []
for sublist in ldata:
    new_ldata += sublist
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use numpy concatenate for this</p>
<pre><code>import numpy as np
x = [[1,1],[2,2,2],[3],[4,4,4,4]]
concated_x = np.concatenate(x) # now in numpy array form
concated_x = list(concated_x) # if you want it back to a list form
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your lists are not too long, keep it simple:</p>
<pre><code>&gt;&gt;&gt; a
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt; sum(a, [])
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>I made some timing measurements:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('sum([[1,2,3],[4,5,6],[7,8,9]], [])')
6.547808872535825
&gt;&gt;&gt; timeit.timeit('reduce(lambda a, c: a + c, [[1,2,3],[4,5,6],[7,8,9]], [])', setup="from functools import reduce")
10.435796303674579
</code></pre>
<p>The more lists and the longer those lists, the solution with <code>chain</code> will perform much better:</p>
<pre><code>a = [list(range(20)) for x in range(30)]
def test_sum():    
    return sum(a, [])
def test_chain():
    return list(itertools.chain.from_iterable(a))
def test_add():     
    result = []
    for i in a:
        result += i
    return result
def test_list_comprehension():
    return [x for l in a for x in l]
print(timeit.timeit(test_sum), timeit.timeit(test_chain), timeit.timeit(test_add), timeit.timeit(test_list_comprehension))
</code></pre>
<p>yields</p>
<pre><code>18.778313734044787 7.5882537689758465 2.5082976589910686 13.912770285038278
</code></pre>
<p>That shows that adding up the arrays with a short function is pretty good too.</p>
</div>
<span class="comment-copy">Could you add an example?</span>
<span class="comment-copy">Look at <code>reduce()</code> or <code>functools.reduce()</code> (depending on Python version)</span>
<span class="comment-copy">Thanks for all the answers! I would accept more if I could but Hochl's one was the simplest and I saw it first.</span>
<span class="comment-copy">@AthreyaDaniel: The superficial simplicity of <code>sum</code> hides a quadratic amount of copying happening under the hood. You say you have "a big array with many subarrays inside"; with a large amount of subarrays, you could literally spend hours to weeks waiting for <code>sum</code> when a more efficient implementation would finish in under a second.</span>
<span class="comment-copy">I suggest you accept the other answer instead of mine.</span>
<span class="comment-copy">this solution seems to have the best performance, but don't name a variable <code>list</code> since that shadows <code>&lt;class 'list'&gt;</code>.</span>
<span class="comment-copy">yeah, my bad.  I was going to write 'sublist', but didn't...</span>
<span class="comment-copy">Nice! Although the documentation states "To concatenate a series of iterables, consider using itertools.chain()" (<a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#sum</a>)</span>
<span class="comment-copy">Thank you, this was a simple and effective fix!</span>
<span class="comment-copy">"why use a module if the builtin works equally well" - because it doesn't. Try to join a million lists with <code>itertools.chain</code>, and it won't even take a second. Try to do that with <code>sum</code>, and you'll have to come back in a few hours.</span>
<span class="comment-copy">Also see <a href="https://stackoverflow.com/questions/41772054/why-sum-on-lists-is-sometimes-faster-than-itertools-chain" title="why sum on lists is sometimes faster than itertools chain">stackoverflow.com/questions/41772054/â€¦</a></span>
<span class="comment-copy">actually it kicks in much sooner, I didn't anticipate that sum was so bad ...</span>
