<div class="post-text" itemprop="text">
<p>I have a model storing, among other things, a timezone datetime object. I am reaching out with an Ajax call from the website to one of my views, which does the following call: </p>
<pre><code>def uploads(request):

    user = User.objects.get(username=request.user.get_username())
    cases = Case.objects.filter(user_id=user.pk).order_by('-uploaded_on')[:5]

    return JsonResponse(serializers.serialize('json', cases, fields=('col1', 'col2', 'col3', 'uploaded_on')), safe=False)
</code></pre>
<p>When a JSON response is received at the Front End, it gets parsed with JS and analyzed. What I would like to do here, is to modify the 'uploaded_on' column with user's timezone (which I can already access with user.timezone, currently displayed as a string e.g. 'Germany/Berlin', but can easily convert it to a necessary object with e.g. pytz package).</p>
<p>When I try to iterate through the QuerySet like below, the values received on the Front End do not change:</p>
<pre><code>for case in cases:
    case.uploaded_on.astimezone(pytz.timezone(user.timezone))
</code></pre>
<p>This is probably related to the fact that QuerySets are lazy, like described in Django's documentation. Can anyone suggest how this can be done?</p>
<p>A bonus question as well: with Django's serializer, can I pass along more than one QuerySet in a single JSON response? When I try to pack a few in a list, I get a MultiValueDictKeyError:</p>
<pre><code>return JsonResponse(serializers.serialize('json', [cases, cases2]), safe=False)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To me there would be two approaches: </p>
<ol>
<li><p>Annotate the <code>cases</code> queryset with a new column, something like <code>uploaded_at_utz</code> and do timezone manipulation at database level. For example you could use <code>TruncSecond</code> function to do something like the following:</p>
<pre><code>cases = Case.objects.filter(user_id=user.pk).annotate(uploaded_at_utz=TruncSecond('uploaded_on', tzinfo=pytz.timezone(user.timezone)).order_by('-uploaded_on')[:5]
</code></pre></li>
<li><p>The other approach would be to do this at python level. For this I would go for a generator function, something like:</p>
<pre><code>def convert_to_timezone(cases, tzinfo):
    for case in cases:
        case.uploaded_on = case.uploaded_on.astimezone(tzinfo)
        yield case
</code></pre></li>
</ol>
<p>Then, in you would pass <code>convert_to_timezone(cases, pytz.timezone(user.timezone))</code> to your <code>JsonResponse</code> constructor.</p>
<p>You should also explore the use of <a href="https://docs.djangoproject.com/es/2.1/ref/utils/#django.utils.timezone.override" rel="nofollow noreferrer">timezone.override</a> and/or <a href="https://docs.djangoproject.com/es/2.1/ref/utils/#django.utils.timezone.localtime" rel="nofollow noreferrer">timezone.localtime</a> although I'm not familiar with them.</p>
</div>
<div class="post-text" itemprop="text">
<p>Regarding the date manipulation, <code>datetime.astimezone()</code> <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.astimezone" rel="nofollow noreferrer">returns a new datetime</a> rather than converting in-place. You'd need to assign the converted value back to <code>case.uploaded_on</code>.</p>
<pre><code>for case in cases:
    case.uploaded_on = case.uploaded_on.astimezone(pytz.timezone(user.timezone))
</code></pre>
<p>Regarding whether you can pass along more than one queryset in a single JSON response, you can use <code>itertools.chain</code> to do that.</p>
<pre><code>from itertools import chain

return JsonResponse(serializers.serialize('json', chain(cases, cases2)), safe=False)
</code></pre>
</div>
