<div class="post-text" itemprop="text">
<p>In this code I was trying to find the most common name in a list of strings such that the program ran in O(nlogn). I recognize that this can be done in O(n) with a dictionary. Are there any obvious ways I can make this code better?</p>
<pre><code>def mostCommonName(L):
#in these two cases I'm making sure that if L has only one element in it
#or if it's empty that the correct result is returned before the loop
if len(L) == 1:
    return L[0]
if len(L) == 0:
    return None
#this automatically makes it nlogn
newL = sorted(L)
maxCount = 0
currCount = 1
maxName = set()
currName = newL[0]
for name in range(1,len(newL)):
    if newL[name] == currName:
        currCount += 1
    else:
        if currCount &gt;= maxCount:
            maxCount = currCount
            currCount = 1
            maxName.add(currName)
            currName = newL[name]
        else:
            currCount = 1
            currName = newL[name]
if newL.count(newL[-1]) == maxCount:
    maxName.add(newL[-1])
if len(maxName) == 1:
    return maxName.pop()
return maxName
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Slightly cleaner, while maintaining the same algorithm:</p>
<pre><code>def mostCommonName(L):
    if len(L) == 0:
        return None

    newL = sorted(L)
    occurrences, current_name = 1, newL[0]    
    best_occurrences, best_name = 1, newL[0]

    for i in range(1, len(newL)):
        if newL[i] == current_name:
            occurrences += 1
        else:
            if occurrences &gt; best_occurrences:
                best_occurrences, best_name = occurrences, current_name
            occurrences = 1
            current_name = newL[i]
    return best_name
</code></pre>
<p>Alternatively:</p>
<pre><code>from collections import Counter

def mostCommonName(L):
    return Counter(L).most_common(1)[0][0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">groupby</a> instead:</p>
<pre><code>from operator import itemgetter
from itertools import groupby


def most_common_name(L):
    l = sorted(L)
    it = map(lambda pair: (pair[0], len(list(pair[1]))), groupby(l))
    r, _ = max(it, key=itemgetter(1))
    return r


result = most_common_name(['dan', 'david', 'dan', 'jen', 'james'])
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>dan
</code></pre>
<p>Or a more <em>readable</em> alternative:</p>
<pre><code>from itertools import groupby


def len_group(pair):
    return sum(1 for _ in pair[1])


def most_common_name(l):
    sorted_l = sorted(l)
    r, _ = max(groupby(sorted_l), key=len_group)
    return r


result = most_common_name(['dan', 'david', 'dan', 'jen', 'james'])
print(result)
</code></pre>
<p>In both alternatives the idea is that groupby handles the grouping of the consecutives values. Then you could find the largest group and return the key of that group. These solutions are <em>O(nlogn)</em>, if you are interested in a <em>O(n)</em> solution you could to the following using Counter:</p>
<pre><code>from operator import itemgetter
from collections import Counter


def most_common_name(l):
    counts = Counter(l)
    r, _ = max(counts.items(), key=itemgetter(1))
    return r


result = most_common_name(['dan', 'david', 'dan', 'jen', 'james'])
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>dan
</code></pre>
</div>
<span class="comment-copy">This is still <i>O(n log n)</i></span>
<span class="comment-copy">@slider The OP mentioned that he knows that it can be done in <i>O(n)</i> with a dictionary so I assumed he is looking for a solution that does not involves a dictionary. I know that it can be done with a Counter.</span>
<span class="comment-copy">Ah ok. It's strange that they're <i>trying</i> to make it <i>O(n log n)</i>.</span>
<span class="comment-copy">I updated the answer with a solution using Counter.</span>
<span class="comment-copy">A <code>Counter</code> has a more direct <code>most_common</code> method.</span>
