<div class="post-text" itemprop="text">
<p>If it were just checking whether letters in a test_string are also in a control_string, </p>
<p>I would not have had this problem.</p>
<p>I will simply use the code below.</p>
<pre><code>if set(test_string.lower()) &lt;= set(control_string.lower()):
    return True
</code></pre>
<p>But I also face a rather convoluted task of discerning whether the overlapping letters in the </p>
<p>control_string are in the same sequential order as those in test_string.</p>
<p>For example,</p>
<pre><code>test_string = 'Dih'
control_string = 'Danish'
True

test_string = 'Tbl'
control_string = 'Bottle'
False
</code></pre>
<p>I thought of using the for iterator to compare the indices of the alphabets, but it is quite hard to think of the appropriate algorithm.</p>
<pre><code>for i in test_string.lower():
    for j in control_string.lower():
        if i==j:
            index_factor = control_string.index(j)
</code></pre>
<p>My plan is to compare the primary index factor to the next factor, and if primary index factor turns out to be larger than the other, the function returns False. </p>
<p>I am stuck on how to compare those index_factors in a for loop.</p>
<p>How should I approach this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>find(letter, last_index)</code> to find occurence of desired letter after processed letters.</p>
<pre><code>def same_order_in(test, control):
    index = 0
    control = control.lower()
    for i in test.lower():
        index = control.find(i, index)
        if index == -1:
            return False
        # index += 1 # uncomment to check multiple occurrences of same letter in test string  
    return True
</code></pre>
<p>If test string have duplicate letters like:</p>
<pre><code>test_string = 'Diih'
control_string = 'Danish'
</code></pre>
<p>With commented line <code>same_order_in(test_string, control_string) == True</code></p>
<p>and with uncommented line <code>same_order_in(test_string, control_string) == False</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You could just <code>join</code> the characters in your <code>test</code> string to a <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">regular expression</a>, allowing for any other characters <code>.*</code> in between, and then <code>re.search</code> that pattern in the <code>control</code> string.</p>
<pre><code>&gt;&gt;&gt; test, control = "Dih", "Danish"
&gt;&gt;&gt; re.search('.*'.join(test), control) is not None
True
&gt;&gt;&gt; test, control = "Tbl", "Bottle"
&gt;&gt;&gt; re.search('.*'.join(test), control) is not None
False
</code></pre>
<hr/>
<p>Without using regular expressions, you can create an <code>iter</code> from the <code>control</code> string and use two nested loops,<sup>1)</sup> <code>break</code>ing from the inner loop and <code>else</code> returning <code>False</code> until all the characters in <code>test</code> are found in <code>control</code>. It is important to create the <code>iter</code>, even though <code>control</code> is already iterable, so that the inner loop will continue where it last stopped.</p>
<pre><code>def check(test, control):
    it = iter(control)
    for a in test:
        for b in it:
            if a == b:
                break
        else:
            return False
    return True
</code></pre>
<p>You could even do this in one (well, two) lines using <code>all</code> and <code>any</code>:</p>
<pre><code>def check(test, control):
    it = iter(control)
    return all(any(a == b for b in it) for a in test)
</code></pre>
<p>Complexity for both approaches should be O(n), with n being the max number of characters.</p>
<p><sup>1)</sup> This is conceptually similar to what <a href="https://stackoverflow.com/a/53299356/1639625">@jpp</a> does, but IMHO a bit clearer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's one solution. The idea is to iterate through the <code>control</code> string <em>first</em> and yield a value if it matches the next <code>test</code> character. If the total number of matches equals the length of <code>test</code>, then your condition is satisfied.</p>
<pre><code>def yield_in_order(x, y):
    iterstr = iter(x)
    current = next(iterstr)
    for i in y:
        if i == current:
            yield i
            current = next(iterstr)

def checker(test, control):
    x = test.lower()
    return sum(1 for _ in zip(x, yield_in_order(x, control.lower()))) == len(x)

test1, control1 = 'Tbl', 'Bottle'
test2, control2 = 'Dih', 'Danish'

print(checker(test1, control1))  # False
print(checker(test2, control2))  # True
</code></pre>
<p><a href="https://stackoverflow.com/a/53300477/9209546">@tobias_k's answer</a> has cleaner version of this. If you want some additional information, e.g. <em>how</em> many letters align before there's a break found, you can trivially adjust the <code>checker</code> function to return <code>sum(1 for _ in zip(x, yield_in_order(...)))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Recursion is the best way to solve such problems. 
Here's one that checks for sequential ordering.</p>
<pre><code>def sequentialOrder(test_string, control_string, len1, len2): 

    if len1 == 0:     # base case 1
        return True

    if len2 == 0:     # base case 2
        return False

    if test_string[len1 - 1] == control_string[len2 - 1]: 
        return sequentialOrder(test_string, control_string, len1 - 1, len2 - 1)  # Recursion 

    return sequentialOrder(test_string, control_string, len1, len2-1)

test_string = 'Dih'
control_string = 'Danish'

print(isSubSequence(test_string, control_string, len(test_string), len(control_string)))
</code></pre>
<p>Outputs:</p>
<pre><code>True
</code></pre>
<p>and <code>False</code> for </p>
<pre><code>test_string = 'Tbl'
control_string = 'Bottle'
</code></pre>
<p>Here's an Iterative approach that does the same thing,</p>
<pre><code>def sequentialOrder(test_string,control_string,len1,len2): 

    i = 0
    j = 0

    while j &lt; len1 and i &lt; len2: 
        if test_string[j] == control_string[i]:     
            j = j + 1    
        i = i + 1

    return j==len1 

test_string = 'Dih'
control_string = 'Danish'

print(sequentialOrder(test_string,control_string,len(test_string) ,len(control_string)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An elegant solution using a generator:</p>
<pre><code>def foo(test_string, control_string):
    if all(c in control_string for c in test_string):
        gen = (char for char in control_string if char in test_string)
        if all(x == test_string[i] for i, x in enumerate(gen)):
            return True
    return False

print(foo('Dzn','Dahis')) # False
print(foo('Dsi','Dahis')) # False
print(foo('Dis','Dahis')) # True
</code></pre>
<p>First check if all the letters in the <code>test_string</code> are contained in the <code>control_string</code>. Then check if the order is similar to the <code>test_string</code> order.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple way is making use of the <code>key</code> argument in <code>sorted</code>, which serves as a key for the sort comparison:</p>
<pre><code>def seq_order(l1, l2):
    intersection = ''.join(sorted(set(l1) &amp; set(l2), key = l2.index))
    return True if intersection == l1 else False
</code></pre>
<p>Thus this is computing the intersection of the two sets and sorting it according to the longer string. Having done so you only need to compare the result with the shorter string to see if they are the same.</p>
<p>The function returns True or False accordingly. Using your examples:</p>
<pre><code>seq_order('Dih', 'Danish')
#True

seq_order('Tbl', 'Bottle')
#False

seq_order('alp','apple')
#False
</code></pre>
</div>
<span class="comment-copy">This is actually close to my 2nd solution (did not see it), but seems overly complcated. Why <code>yield i</code> and compare to <code>j</code>? You already know they are equal. Can't you just check the number of elements yielded?</span>
<span class="comment-copy">@tobias_k, Good point. I did try <code>sum(1 for _ in yield_in_order(x, control.lower())) == len(x)</code> but I get <code>DeprecationWarning: generator 'yield_in_order' raised StopIteration</code> [which I don't understand] even though the results are correct.</span>
<span class="comment-copy">I guess that's the case when it tries to match more characters after <code>iterstr</code> is exhausted. Zipping with <code>x</code> limits the number of items asked from the generator. So it kind of makes sense to <code>zip</code> them, but the <code>==</code> is still redundant.</span>
<span class="comment-copy">@tobias_k, Yup took a min but figured it out.. can just <code>sum(1 for ...)</code>. Your solution clearer though.</span>
<span class="comment-copy">Do you mind elaborating on the functions of len1 and len2? I just started out learning python and I am not familiar with recursions.</span>
<span class="comment-copy">Recursions aren't specific to python. They are a type of approach. I'll also write it in iterative approach in a min.</span>
<span class="comment-copy">@VAnon Updated my answer.</span>
<span class="comment-copy">Why would the function return ('Ce', 'Arsenic') as True? Shouldn't it return false as order is the other way around (ec)?</span>
<span class="comment-copy">Have you tested this? It actually returns False.</span>
<span class="comment-copy">Indeed it returns False! I think I had the previous execution running.</span>
<span class="comment-copy">One issue with this solution is the repeated <code>if _ in test_string</code>.. maybe use <code>set</code> to make it O(1)?</span>
<span class="comment-copy">What you you mean <code>set</code>?</span>
<span class="comment-copy">There was a bug in the previous version @VAnon , this simple method should do what you're asking for.</span>
