<div class="post-text" itemprop="text">
<p>Say I have a list of strings. For example, this is a list of two strings.</p>
<p><code>["Hello, W", "orld!---"]</code>.</p>
<p>I already have a function <code>char2bin</code> that converts separate string characters characters into a list of binary. Note, this does not work for multiple character strings.
Ex. </p>
<pre><code>&gt;&gt;&gt;char2bin('a')
[0,1,1,0,0,0,0,1]

&gt;&gt;&gt;char2bin('abc')
(ERROR)
</code></pre>
<p>How would I convert a list of multiple strings into a list of a list of binaries?</p>
<p>For example, <code>["Hello, W", "orld!---"]</code>
would result in </p>
<p><code>[[[0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1], [0,1,1,0,1, 1, 0, 0], [0, 1, 1, 0, 1, 1, 0, 0], [0,1,1,0,1,1,1,1], [0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0], [0,1,1,1,0,1,1, 1]], [[0, 1, 1, 0, 1, 1, 1, 1], [0,1,1,1,0,0,1,0], [0,1, 1, 0, 1, 1, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0], [0,0,1,0,0,0,0,1], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1,1,1,1,0], [0, 1, 1, 1,1, 1, 1, 0]]]</code></p>
<p>As you can see, each string character has converted into a list of binaries, but since there are two separate strings, there are also two separate lists of binary lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can iterate over the characters in a string, and iterate over the words in a word_list.   So you can do the following :</p>
<pre><code>def convert_word(a):
    return [char2bin(x) for x in a]

result = [convert_word(word) for word in word_list]
</code></pre>
<p>using my own interpretation of char2bin:</p>
<pre><code>def char2bin(x):
    return list(bin(ord(x)))[2:]

def convert_word(a):
    return [char2bin(x) for x in a]


word_list = ['abc','bcd']
[convert_word(word) for word in word_list]
</code></pre>
<p>gives the result:</p>
<pre><code>[[['1', '1', '0', '0', '0', '0', '1'],
  ['1', '1', '0', '0', '0', '1', '0'],
  ['1', '1', '0', '0', '0', '1', '1']],
 [['1', '1', '0', '0', '0', '1', '0'],
  ['1', '1', '0', '0', '0', '1', '1'],
  ['1', '1', '0', '0', '1', '0', '0']]]
</code></pre>
<p>which i believe is the format you are looking for.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are three basic approaches here, comprehension, functional, and procedural. The comprehension form is considered idiomatic Python (or "pythonic").</p>
<h3>Comprehension</h3>
<p><a href="https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries" rel="nofollow noreferrer">List comprehensions</a> can build the list elements from any Python expression, including other list comprehensions--you can nest them.</p>
<p><code>[[char2bin(c) for c in word] for word in ["Hello, W", "orld!---"]]</code></p>
<p>The Python comprehension syntax has equivalents of <code>map()</code> loops and element <code>filter()</code>s without requiring an explicit lambda like those builtin functions would. We don't need filters for this task. But because you already have a function <code>char2bin()</code> declared, you can already use <code>map()</code> without the lambda, like so.</p>
<p><code>[[*map(char2bin, word)] for word in ["Hello, W", "orld!---"]]</code></p>
<p>The above version mixes a little functional style into the comprehension, and is probably the most Pythonic.</p>
<p>In Python 2 you wouldn't need to put it in the <code>[*]</code> part to make it a list, but in Python 3 <code>map()</code> makes a lazy generator instead of a list.</p>
<h3>Functional</h3>
<p>You can always rewrite comprehensions in terms of maps and filters by using lambda (anonymous functions). You usually don't use a lambda in Python when a comprehension would do.</p>
<p><code>[*map(lambda word: [*map(char2bin, word)], ["Hello, W", "orld!---"])]</code></p>
<p>And the newer unpack-into-list syntax <code>[*foo]</code> can still be done with the <code>list</code> constructor.</p>
<p><code>list(map(lambda word: list(map(char2bin, word), ["Hello, W", "orld!---"]))</code></p>
<p>The above is a more functional style, although it could be taken a bit further to point-free style with a functional library using currying and function composition. But even pure-functional languages like Haskell have comprehensions, which is where Python got them from in the first place.</p>
<h3>Procedural</h3>
<p>List comprehensions can always be converted to a procedural-style by using explicit for loops and accumulators (and if-statements when there are filters). This is much more verbose, but would be more familiar to those coming from a procedural language like C, so you still see it pretty often in Python.</p>
<pre><code>result = []
for word in ["Hello, W", "orld!---"]:
    binchars = []
    for c in word:
        binchars.append(char2bin(c))
    result.append(binchars)
</code></pre>
<p>Compare the above to my recommendation:</p>
<pre><code>[[*map(char2bin, word)] for word in ["Hello, W", "orld!---"]]
</code></pre>
</div>
<span class="comment-copy">Please share the code you're working with. It will help us understand exactly what's happening</span>
<span class="comment-copy">While this might answer the authors question, it lacks some explaining words and/or links to documentation. Raw code snippets are not very helpful without some phrases around them. You may also find <a href="https://stackoverflow.com/help/how-to-answer">how to write a good answer</a> very helpful. Please edit your answer.</span>
