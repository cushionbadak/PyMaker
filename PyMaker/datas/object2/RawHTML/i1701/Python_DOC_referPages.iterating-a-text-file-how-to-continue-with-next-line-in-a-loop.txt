<div class="post-text" itemprop="text">
<p>I'm new to python and I am having some difficulties getting my script to do what I need and I need some help. My code probably could be sorted a lot better too, I'm sorry if it is messy. The entire script is simply automating a manual task. The steps are the following:</p>
<ol>
<li>Opens a browser with two tabs </li>
<li>logging in to two websites, one in each tab</li>
<li>reads and copies 1st line in text file test.txt, containing an email</li>
<li>Paste the value of first line to textfield on webpage1 and presses RETURN</li>
<li>fetching some data on the webpage1 using selenium</li>
<li>it pastes values on webpage2 and sends an SMS on webpage2
7.copies output from webpage2</li>
<li>Opens third URL, and paste output from webpage2</li>
<li>Repeat from step 3(?)</li>
</ol>
<p>All this works wonders currently, but when the whole script is finished, I want it to return to step 3, but this time reading line 2 in the text file. Perform steps 3-8 again before reading line 3 and so on.. How can I do this?</p>
<p>The idea is that I have a .txt file containing many many email addresses, one per line, where my scripts goes through this process on each individual address.
If possible I would also like the script to append "- Successful" to each line after being read. So the script will run x amount of times, depending on how many lines there are in test.txt
If possible it would be nice to have some error handling as well, i.e move to next line in file if any errors.</p>
<p>Here is my full code, I had to remove the URL's and some sensitive values, I hope it's understandable. The part i'm having trouble with is highlighted below:</p>
<pre><code>    # coding=UTF-8
import clipboard
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import NoSuchElementException


def login():
    ## Define logins for#
    usernameB = ''
    passwordB = ''
    userMaestro = ''
    passMaestro = ''

    driver.switch_to_window(driver.window_handles[0])
    driver.get(first_url)
## Perform login in B ##
    username = driver.find_element_by_id('ctl00_logincontent_username_f')
    username.send_keys(usernameB)
    password = driver.find_element_by_id('ctl00_logincontent_password_f')
    password.send_keys(passwordB)
    loginButton = driver.find_element_by_id('ctl00_logincontent_submit')
    loginButton.click()  ##

    driver.switch_to_window(driver.window_handles[1])
    driver.get(second_url)

#### Perform login in Maestro
    usernameM = driver.find_element_by_name('username')
    usernameM.send_keys(userMaestro)
    passwordM = driver.find_element_by_name('password')
    passwordM.send_keys(passMaestro)
    loginMaestro = driver.find_element_by_name('submit')
    loginMaestro.click()


def searchB():

    driver.switch_to_window(driver.window_handles[0]) # Use first tab
    ## Search function ##
    emailSearch = driver.find_element_by_id('quicksearchinput')
    with open('C:\\Users\\user\\test.txt','r') as f:
            for email in f:
                emailSearch.send_keys(email, Keys.RETURN)
                sendSMS()


def sendSMS():
    try:
        kundenummer = driver.find_elements_by_tag_name('dd')[2].text # Grabs value from instersting tag.
        telefon = driver.find_elements_by_tag_name('dd')[4].text # Grabs value from interesting tag.
    except NoSuchElementException as exception:
        print "Element not found. Getting next email"
        searchBrikks()
    mailerText = "He"

    ## SEND SMS ##
    driver.switch_to_window(driver.window_handles[1])
    driver.get(second_url)
    driver.find_element_by_name('til').send_keys(telefon)
    driver.find_element_by_id('msgtxt').send_keys(mailerText)
    driver.find_element_by_xpath('//input[@value="Send SMS"]').click() ## We use this to send the SMS once done.
    smsRef = driver.find_elements_by_tag_name('strong')[1].text # Copies the output SMS-Ref.
    print('Successfully sent SMS and copied the referance number for log. ')
    addnoteBrikks()


def addnoteBrikks():

    smsRef = driver.find_elements_by_tag_name('strong')[1].text # Copies the output SMS-Ref.
    driver.switch_to_window(driver.window_handles[0]) # Goes to B
    kundenummer = driver.find_elements_by_tag_name('dd')[2].text # Grabs ID for URL
    telefon = driver.find_elements_by_tag_name('dd')[4].text # Grabs value from interesting tag.

    driver.get(third_url+kundenummer) # Goes to "add note" on customer in B
    fullDraft = 'SMS sendt til:'+ telefon + '. Kundenummer oppgitt: ' +kundenummer + '\n' + smsRef
    shortDraft = 'Mailer-daemon, SMS Sendt. Ref:' +str(smsRef) #For subject in Brikks. Add SMS-ref?

    emneBrikks = driver.find_element_by_id('ctl00_maincontent_uiSubject_f')
    emneBrikks.send_keys(shortDraft)
    bodyBrikks = driver.find_element_by_id('ctl00_maincontent_uiBody_f')
    bodyBrikks.send_keys(fullDraft)

    createTicket = driver.find_element_by_id('ctl00_maincontent_save')
    createTicket.click() #Create the ticket in Brikks
    searchB()


first_url = "https://"
second_url = "http://"
third_url = "https:"

driver = webdriver.Chrome(executable_path=r"chromedriver.exe")
driver.execute_script('window.open("{}");'.format(''))


def main():
    login()
    searchB()
    driver.switch_to_window(driver.window_handles[1])
    smsRef = driver.find_elements_by_tag_name('strong')[1].text # Copies the output SMS-Ref.


if __name__ == '__main__':
    main()
</code></pre>
<p>How could I achieve what I want here? Appreciate any help!</p>
<p>Edit:</p>
<p>So the part i'm interested in is this:</p>
<pre><code> def searchBrikks():

    driver.switch_to_window(driver.window_handles[0]) # Use first tab
    ## Search function ##
    emailSearch = driver.find_element_by_id('quicksearchinput')
    with open('C:\\Users\\user\\test.txt','r') as f:
            for email in f:
                emailSearch.send_keys(email, Keys.RETURN)
                sendSMS()
                ### What to write further here? ###
</code></pre>
<p>How can I make it read line 2 the next time searchB() is called?</p>
</div>
<div class="post-text" itemprop="text">
<p>The first thing i see is that <em>every</em> time <code>searchB()</code> is called you are looping through the entire contents of the test.txt file.</p>
<pre><code>with open('C:\\Users\\user\\test.txt','r') as f:
        for email in f:
</code></pre>
<p>Wont stop until it hits EOF. Instead of putting the loop in your <code>searchB()</code> function, maybe put it in the main, that way you can have more control and call <code>searchB()</code> on any line in the test.txt file you want.</p>
<p>For logging you want to take a looking at the <a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer">logging</a> library, that will allow you to specify a log file and put logging messages after something is written or a call fails. It would be super annoying to append <code>- successful</code> to the end of the lines.</p>
</div>
<div class="post-text" itemprop="text">
<p>I solved this problem by moving the loop to main function like this:</p>
<pre><code>def main():

    driver.execute_script('window.open("{}");'.format(''))
    login()

    driver.switch_to_window(driver.window_handles[0]) # Use first tab
    emailSearch = driver.find_element_by_id('quicksearchinput') # Identify Quicksearch text-field
    with open('C:\\Users\\user\\test.txt','r+') as f:
        for email in f:
            searchB(email) ## &lt;-- Added this
            print(email)
</code></pre>
<p>With my searchB() function like this:</p>
<pre><code>def searchB(mail):  ## &lt;-- Added this
    driver.switch_to_window(driver.window_handles[0]) # Use first tab
    emailSearch = driver.find_element_by_id('quicksearchinput') # Identify Quicksearch text-field
    emailSearch.send_keys(email, Keys.RETURN)
    sendSMS()
</code></pre>
</div>
<span class="comment-copy">You've posted quite a large chunk of code. Are you able to break the problem down into the smallest example that demonstrates the problem you are trying to solve?</span>
<span class="comment-copy">Hello, I edited the post now to highlight the problematic part</span>
<span class="comment-copy">Don't <code>return</code> in your loop. Returning from a function ends the execution of code within that function, even from the middle of a loop body.  You may need to reorganize your functions so that they cooperate in sequence in order for your loop to be able to continue appropriately for your situation.</span>
<span class="comment-copy">Thank you for you input, I have now removed it. That makes sense, i am not sure why I had put it there. Do you have any suggestions to how the functions should be re-organized for this to work?</span>
<span class="comment-copy">@EmilSørbrøden  I see in your answer that you created a working reorganization yourself. You wanted part of <code>searchB()</code> to happen and then to do the <code>sendSMS()</code> for each address in the file, so the loop must contain all the operations that pertain to each address and can not be in the midst of those operations.</span>
<span class="comment-copy">Thank you. I've experimented a bit with putting the loop in main(), however i am unsure how i call the function to read a specific - or the next--line. As for the logging you are right, im going to write to a separate file rather than appending</span>
<span class="comment-copy">I dont know of any good way of reading a specific lines without using f.seek() and f.read(). Those two function read byte data, which again, seems pretty annoying. Maybe try reading each line into a list and referencing them with their index <code>list[1], 2, 3, 4,....</code></span>
