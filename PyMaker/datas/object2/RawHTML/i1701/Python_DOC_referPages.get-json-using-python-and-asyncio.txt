<div class="post-text" itemprop="text">
<p>Not so long ago, I began to learn asyncio. And I ran into a problem. My code is not terminating. I can't figure it out. Help me please! </p>
<pre><code>import signal
import sys
import asyncio
import aiohttp
import json

loop = asyncio.get_event_loop()
client = aiohttp.ClientSession(loop=loop)

async def get_json(client, url):
    async with client.get(url) as response:
        assert response.status == 200
        return await response.read()

async def get_reddit_cont(subreddit, client):
    data1 = await get_json(client, 'https://www.reddit.com/r/' + subreddit + '/top.json?sort=top&amp;t=day&amp;limit=50')

    jn = json.loads(data1.decode('utf-8'))

    print('DONE:', subreddit)

def signal_handler(signal, frame):
    loop.stop()
    client.close()
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)

for key in {'python':1, 'programming':2, 'compsci':3}:
    asyncio.ensure_future(get_reddit_cont(key, client))
loop.run_forever()
</code></pre>
<p>Result:  </p>
<pre><code>DONE: compsci  
DONE: programming  
DONE: python  
...
</code></pre>
<hr/>
<p>I tried to accomplish something, but the result was not stable.  </p>
<pre><code>future = []
for key in {'python':1, 'programming':2, 'compsci':3}:
    future=asyncio.ensure_future(get_reddit_cont(key, client))
loop.run_until_complete(future)
</code></pre>
<p>Result (1 tasks instead of 3):  </p>
<pre><code>DONE: compsci  
[Finished in 1.5s]  
</code></pre>
<hr/>
<p>I solved my question in this way:  </p>
<p>Added by:</p>
<pre><code>async with aiohttp.ClientSession () as a client:
</code></pre>
<p>AT:</p>
<pre><code>async def get_reddit_cont (subreddit, client):  
</code></pre>
<p>And:</p>
<pre><code>if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    futures = [get_reddit_cont(subreddit,client) for subreddit in range(1,6)]
    result = loop.run_until_complete(asyncio.gather(*futures))
</code></pre>
<p>But when the code is completed, I get the message:  </p>
<pre><code>Unclosed client session
client_session: &lt;aiohttp.client.ClientSession object at 0x034021F0&gt;
[Finished in 1.0s]
</code></pre>
<p>I don't understand why this is happening.  </p>
<p>But when I try to execute "for key" about 60 or more times, I get an error:  </p>
<blockquote>
<p>...<br/>
  aiohttp.client_exceptions.ClientOSError: [WinError 10054] Remote host forcibly terminated an existing connection</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The answer lies in your code. Here's the clue <code>loop.run_forever()</code>. So you will need to call <code>loop.stop()</code>. I would use a condition such as an <code>if</code> clause or using a <code>while</code> loop. </p>
<pre><code>if we_have_what_we_need:
    signal_handler(signal, frame)
</code></pre>
<p>or</p>
<pre><code>while we_dont_have_what_we_need:
    loop.forever()
</code></pre>
<p>The first will stop your code when the condition is met. The latter will keep going until the condition is met.</p>
<p>[UPDATE]</p>
<p>We can also use;</p>
<h2>(Python Docs)</h2>
<pre><code>loop.run_until_complete(future)
</code></pre>
<blockquote>
<p>Run until the future (an instance of Future) has completed.</p>
<p>If the argument is a coroutine object it is implicitly scheduled to
  run as a asyncio.Task.</p>
<p>Return the Future’s result or raise its exception.</p>
</blockquote>
<pre><code>loop.run_forever()
</code></pre>
<blockquote>
<p>Run the event loop until stop() is called.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Here are a few suggested changes, with context in the comments.</p>
<p>Unless you really have a unique use-case, or are just experimenting for learning's sake, there probably shouldn't be a reason to use <code>signal</code> -- <code>asyncio</code> has top-level functions that let you decide when to close and terminate the event loop.</p>
<pre><code>import asyncio
import logging
import sys

import aiohttp

logging.basicConfig(stream=sys.stdout, level=logging.DEBUG,
                    format='%(asctime)s:%(message)s')

URL = 'https://www.reddit.com/r/{subreddit}/top.json?sort=top&amp;t=day&amp;limit=50'


async def get_json(client: aiohttp.ClientSession, url: str) -&gt; dict:
    # If you're going to be making repeated requests, use this
    # over .get(), which is just a wrapper around `.request()` and
    # involves an unneeded lookup
    async with client.request('GET', url) as response:

        # Raise if the response code is &gt;= 400.
        # Some 200 codes may still be "ok"
        response.raise_for_status()

        # Let your code be fully async.  The call to json.loads()
        # is blocking and won't take full advantage.
        #
        # And it does largely the same thing you're doing now:
        # https://github.com/aio-libs/aiohttp/blob/76268e31630bb8615999ec40984706745f7f82d1/aiohttp/client_reqrep.py#L985
        j = await response.json()
        logging.info('DONE: got %s, size %s', url, j.__sizeof__())
        return j


async def get_reddit_cont(keys, **kwargs) -&gt; list:
    async with aiohttp.ClientSession(**kwargs) as session:
        # Use a single session as a context manager.
        # this enables connection pooling, which matters a lot when
        # you're only talking to one site
        tasks = []
        for key in keys:
            # create_task: Python 3.7+
            task = asyncio.create_task(
                get_json(session, URL.format(subreddit=key)))
            tasks.append(task)
        # The result of this will be a list of dictionaries
        # It will only return when all of your subreddits
        # have given you a response &amp; been decoded
        #
        # To process greedily, use asyncio.as_completed()
        return await asyncio.gather(*tasks, return_exceptions=True)


if __name__ == '__main__':
    default = ('python', 'programming', 'compsci')
    keys = sys.argv[1:] if len(sys.argv) &gt; 1 else default
    sys.exit(asyncio.run(get_reddit_cont(keys=keys)))
</code></pre>
<p>Output:</p>
<pre><code>$ python3 asyncreddit.py 
2018-11-07 21:44:49,495:Using selector: KqueueSelector
2018-11-07 21:44:49,653:DONE: got https://www.reddit.com/r/compsci/top.json?sort=top&amp;t=day&amp;limit=50, size 216
2018-11-07 21:44:49,713:DONE: got https://www.reddit.com/r/python/top.json?sort=top&amp;t=day&amp;limit=50, size 216
2018-11-07 21:44:49,947:DONE: got https://www.reddit.com/r/programming/top.json?sort=top&amp;t=day&amp;limit=50, size 216
</code></pre>
<hr/>
<p>Edit: from your question:</p>
<blockquote>
<p>But when the code is completed, I get the message: <code>Unclosed client session</code></p>
</blockquote>
<p>This is because you need to <code>.close()</code> the <code>client</code> object, just as you would a file object.  You can do that two ways:</p>
<ul>
<li>Call it explicitly: <code>client.close()</code>.  It is safer to wrap this in a <code>try</code>/<code>finally</code> block to make sure that it's closed no matter what</li>
<li>Or (easier way), use the client as an async context manager, as in this answer.  This means that, after the <code>async with</code> block is over, the session is automatically closed via its <code>.__aexit__()</code> method.</li>
</ul>
<p>The <a href="https://aiohttp.readthedocs.io/en/stable/client_advanced.html#connectors" rel="nofollow noreferrer"><code>connector</code></a> is the underlying <code>TCPConnector</code>, which is an attribute of the session.  It handles the connection pooling, and it's what ultimately is left open in your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>I solved the problem in this way:</p>
<pre><code>import asyncio
import aiohttp
import json

async def get_json(client, url):
    async with client.get(url) as response:
        assert response.status == 200
        return await response.read()

async def get_reddit_cont(subreddit):
    async with aiohttp.ClientSession(loop=loop) as client:
        data1 = await get_json(client, 'https://www.reddit.com/r/' + subreddit + '/top.json?sort=top&amp;t=day&amp;limit=50')

        jn = json.loads(data1.decode('utf-8'))

        print('DONE:', subreddit)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    futures = [get_reddit_cont(subreddit) for subreddit in {'python':1, 'programming':2, 'compsci':3}]
    result = loop.run_until_complete(asyncio.gather(*futures))
</code></pre>
</div>
<span class="comment-copy">Yes, I understand that the matter is in it, but I don't understand how to fix it. :(</span>
<span class="comment-copy">You need to call <code>loop.stop()</code>. I woul duse a condition such as an <code>if</code> clause or using a <code>while</code> loop. You can find it in the [python docs] (<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.stop" rel="nofollow noreferrer">docs.python.org/3/library/…</a>)</span>
<span class="comment-copy">@idrees The standard idiom is <code>run_until_complete(asyncio.gather(coroutine1(), coroutine2(), ...))</code>, which will complete once <i>all</i> the coroutines complete, so you no longer have a need for <code>run_forever</code>. Brad's answer shows a variant when the number of coroutines is not known in advance.</span>
<span class="comment-copy">It's cool, but I'm even more confused))</span>
