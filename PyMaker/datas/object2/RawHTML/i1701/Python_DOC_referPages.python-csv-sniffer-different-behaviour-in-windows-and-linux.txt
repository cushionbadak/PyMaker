<div class="post-text" itemprop="text">
<p>Within a wxpython application, I am using the following code to detect the 'dialect' of a csv file:</p>
<pre><code>pathname = dlg.GetPath()
try:
    self.file = open(pathname, 'r', encoding='utf-8')
except IOError:
    wx.LogError("Cannot open file '%s'." % ntpath.basename(self.file.name))
    return

# check for file format with sniffer
sample = self.file.read(1024)
try:
    dialect = csv.Sniffer().sniff(sample)
except UnicodeDecodeError:
    wx.LogError("Cannot decode file '%s'." % ntpath.basename(self.file.name))
    return
except csv.Error:
    wx.LogError("Cannot determine dialect of '%s'." % ntpath.basename(self.file.name))
    return
</code></pre>
<p>The first lines of the csv file I am using this on are:</p>
<pre><code>t;3.1.A.;"UN ECE R51; Sound levels"
;;Is covered by the type approval of the vehicle stage 1, refer to Annex S.
t;3.2.A.;"715/2007/EC; Emissions light duty vehicles Euro 6"
;;Is covered by the type approval of the vehicle stage 1, refer to Annex S.
t;3.3.A.;"UN ECE R34; Fuel tanks"
;;Is covered by the type approval of the vehicle stage 1.
t;3.16.A.;"UN ECE R26; Exterior projections"
;3.16.A.1.;Test and inspections
</code></pre>
<p>The delimiter is supposed to be ';' and the quote char '"'I am aware that there are lots of commas, semicolons and quote chars to confuse the sniffer, but when running this code with python 3.6 on windows, it works perfectly.  Running it on Linux (also with python 3.6) invariably raises the csv.Error (also on other csv files with the same delimiters and quote chars). I have tried this with read(1024), with other values and also with readline, but always get the same results.</p>
<p>Any explanation for this different behaviour ?</p>
</div>
<div class="post-text" itemprop="text">
<p>The default end-of-record delimiter is different between windows and linux. Commonly, records will be terminated with a CR-LF "pair" on windows, while on *nix, a single LF is the norm. It may be the case that your sniffer might be fixing itself in windows-mode, and needs assistance in deciding what the real line-terminator should be. </p>
<p>From <a href="https://docs.python.org/3/library/csv.html#csv.Dialect.lineterminator" rel="nofollow noreferrer">the docs</a> it seems that sniffer defaults to <code>/r/n</code> which I think is windows-flavoured. It should cope with alternate line-terminators, but perhaps something is being forced somewhere. If your record-lengths in your data file are longer than 1024, or there's not enough to sample a line-terminator enough times to correctly guess the format, that might have something to do with it. </p>
</div>
<div class="post-text" itemprop="text">
<p>Finally found the cause of this error.  It is not related to the newline endings.  I am using Python 3.6.4, and have discovered that csv.py has a bug in this version: the regex on line 220 says:</p>
<pre><code>r'(?P&lt;delim&gt;&gt;[^\w\n"\'])(?P&lt;space&gt; ?)(?P&lt;quote&gt;["\']).*?(?P=quote)(?:$|\n)',  # ,".*?"
</code></pre>
<p>but it should be: </p>
<pre><code>r'(?P&lt;delim&gt;[^\w\n"\'])(?P&lt;space&gt; ?)(?P&lt;quote&gt;["\']).*?(?P=quote)(?:$|\n)',  # ,".*?"
</code></pre>
<p>as of python 3.6.5. the bug seems to be fixed</p>
</div>
<span class="comment-copy">Following your suggestion, I changed open(pathname, 'r', encoding='utf-8') into open(pathname, 'r', encoding='utf-8', newline='') and the error is not raised anymore.  However, there still seems to be a difference in sniffer behaviour between windows and linux, because now, the example file (for which I gave the first lines in my question) is recognized as a single column file in linux, whereas windows recognises it correctly as a 3-column file.  Other less complicated files are recognised correctly by the sniffer both in windows and linux.</span>
<span class="comment-copy">So try one of <code>open(pathname, 'r', encoding='utf-8', newline='\n')</code>  and  <code>open(pathname, 'r', encoding='utf-8', newline='\r\n')</code>  Is the file the <i>exact</i> same file? Or is it a copy? Sometimes moving a file across operating systems can cause it to change (some transmission programs are "helpful" in this respect, and corrupt the file as it is copied)  But it does seem to me that it's this CRLF vs LF difference across unix/windows conventions that's causing you the grief here.</span>
<span class="comment-copy">I have been looking a bit deeper into the csv sniffing and can see the following behaviour:</span>
<span class="comment-copy">...opening file with "newline''" in the statement avoids the error in linux but then it fails to detect the delimiter correctly both in windows and linux and treats it as single column.  When opening without "newline", and looking with a debugger at the content of the "sample" variable, both in linux and in windows, lines are separated by a \n.  The sniffer receives the same data in windows and linux, but the regex used by csv.Sniffer reacts differently depending on the OS... in windows, a match is found for the delimiter and the quotechar, in linux, for whatever reason, no match is found.</span>
