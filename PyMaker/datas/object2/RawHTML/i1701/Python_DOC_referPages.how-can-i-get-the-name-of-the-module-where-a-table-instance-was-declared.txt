<div class="post-text" itemprop="text">
<p>I have a sqlalchemy table defined like so</p>
<pre><code>from sqlalchemy.sql.schema import Table

my_table = Table(
    "my_table",
    metadata,
    Column("my_id", BigInteger(), primary_key=True),
    ...
)
</code></pre>
<p>I am trying to inspect this instance to get the module where it was created. I have tried using <code>sqlalchemy.inspect(my_table).__module__</code>, <code>my_table.__module__</code>, and <code>inspect.getmodule(my_table)</code> however, all three return <code>sqlalchemy.sql.schema</code> which is the module where <code>Table</code> is defined rather than where <code>my_table</code> is defined.</p>
<p><strong>How can I retrieve the name of the module where I have instantiated <code>my_table</code>?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>You could add the functionality by subclassing <code>Table</code>. In SQLAlchemy, <code>Table</code> specifically overrides <a href="https://github.com/zzzeek/sqlalchemy/blob/0a07fd99dbb8122f8b0786d693506c849db58d9e/lib/sqlalchemy/sql/schema.py#L468" rel="nofollow noreferrer"><code>Table.__init__()</code></a> to make it a no-op:</p>
<pre><code>def __init__(self, *args, **kw):
    """Constructor for :class:`~.schema.Table`.
    This method is a no-op.   See the top-level
    documentation for :class:`~.schema.Table`
    for constructor arguments.
    """
    # __init__ is overridden to prevent __new__ from
    # calling the superclass constructor.
</code></pre>
<p>The key being that it does not invoke <code>super().__init__()</code>, so that sqlalchemy can take command of instantiation and whatever you do, that needs to be maintained.</p>
<pre><code>from sqlalchemy.sql.schema import Table

class MyTable(Table):

    def __init__(self, *args, **kwargs):
        self._where_am_i = __file__

my_table = MyTable(
    "my_table",
    metadata,
    Column("my_id", BigInteger(), primary_key=True)
)
</code></pre>
<p>In this case, <code>MyTable.__init__()</code> is still blocking the superclass constructor, but it also adds an attribute to the instance which will be the name of the module that the class is instantiated within. I specifically chose an obscure attribute name (<code>_where_am_i</code>) that is unlikely to be overwritten by sqlalchemy and using <code>__file__</code> returns the path of the module (but you can make that anything you want).</p>
<p>I tested that inserts and selects still work:</p>
<pre><code>import logging
from sqlalchemy.sql import select
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)
logging.basicConfig(level=logging.INFO)
Base.metadata.drop_all(engine)
Base.metadata.create_all(engine)
conn = engine.connect()
conn.execute(my_table.insert(), [{"my_id": i} for i in range(1, 6)])
s = select([my_table])
result = conn.execute(s)
for row in result:
    print(row)
# (1,)
# (2,)
# (3,)
# (4,)
# (5,)
</code></pre>
<p>And instantiation location:</p>
<pre><code>print(my_table._where_am_i)  # 53302898.py (that's the name of my module).
</code></pre>
<p>External module:</p>
<pre><code># external_module.py

from sqlalchemy_app import Base
from sqlalchemy.sql.schema import Table
from sqlalchemy import Column, BigInteger

metadata = Base.metadata

class MyTable(Table):

    def __init__(self, *args, **kwargs):
        self._where_am_i = __file__

my_table = MyTable(
    "my_table",
    metadata,
    Column("my_id", BigInteger(), primary_key=True)
)
</code></pre>
<p>And:</p>
<pre><code># 53302898.py

from external_module import my_table

if __name__ == '__main__':
    print(my_table._where_am_i)  # prints C:\Users\peter_000\OneDrive\git\test\external_module.py
</code></pre>
<p>Note how it returned the relative file path in the first test and the absolute file path in the external module test. You can read about that here: <a href="https://stackoverflow.com/questions/7116889/python-file-attribute-absolute-or-relative">Python __file__ attribute absolute or relative?</a> but you can make that <code>_where_am_i</code> attribute return whatever you need to suit your application.</p>
<p><strong>EDIT</strong>
The above solution requires subclassing the <code>Table</code> class <em>inside</em> the module where instances are formed, otherwise it will peg the module where the Class is instantiated, not the instances. If you only want to subclass <code>Table</code> once in your project you'd need to pass the location to the constructor.</p>
<p>This works:</p>
<pre><code>class MyTable(Table):

    def __init__(self, *args, _where_am_i=None, **kwargs):
        self._where_am_i = _where_am_i
</code></pre>
<p>...but you get a warning upon instantiation:</p>
<p><code>SAWarning: Can't validate argument '_where_am_i'; can't locate any SQLAlchemy dialect named '_where'</code>.</p>
<p>To avoid that, you'd have to override sqlalchemy's alternate constructor, <code>Table._init()</code>, strip out the location parameter and then delegate back up the chain:</p>
<pre><code>class MyTable(Table):

    def _init(self, *args, _where_am_i=None, **kwargs):
        self._where_am_i = _where_am_i
        super()._init(*args, **kwargs)
</code></pre>
<p>Import from external module:</p>
<pre><code># 53302898.py
from external_module import MyTable

my_table = MyTable(
    "my_table",
    metadata,
    Column("my_id", BigInteger(), primary_key=True),
    _where_am_i = __file__
)

if __name__ == '__main__':
    print(my_table._where_am_i)  # 53302898.py
</code></pre>
<p>All above tests still pass.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't.  If you refer to <a href="https://docs.python.org/3/genindex-_.html" rel="nofollow noreferrer">the Python documentation index</a>, you see that there are three entries for <code>__module__</code>: one for <a href="https://docs.python.org/3/reference/datamodel.html#index-48" rel="nofollow noreferrer">a class attribute</a>, one for <a href="https://docs.python.org/3/reference/datamodel.html#index-34" rel="nofollow noreferrer">a function attribute</a>, and one for <a href="https://docs.python.org/3/reference/datamodel.html#index-36" rel="nofollow noreferrer">a method attribute</a>.  Only those types of objects have the module in which they were declared recorded.  <code>my_table</code> is none of these; it's just an instance of the <code>Table</code> class, so the only <code>__module__</code> you can find on it is <code>Table.__module__</code>.</p>
</div>
<span class="comment-copy">Unfortunately, this solution doesn't scale well. If I put <code>MyTable</code> into a separate file so that I can share it between several tables, it gets the location of that file rather than the file where the table was instantiated.</span>
<span class="comment-copy">Then your only option is to pass it in at instantiation time. See edit.</span>
