<div class="post-text" itemprop="text">
<p>I'm test a method which makes external API calls which are mocked using a <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer"><code>patch</code></a> decorator. However, I'd like to be able to set an environment variable, <code>MAKE_EXTERNAL_REQUESTS</code>, such that if it is truthy, the patch is not applied.</p>
<p>Essentially, I'm looking to something similar to the <code>skipIf</code> and <code>skipUnless</code> decorators (cf. <a href="https://docs.python.org/3.7/library/unittest.html#skipping-tests-and-expected-failures" rel="nofollow noreferrer">https://docs.python.org/3.7/library/unittest.html#skipping-tests-and-expected-failures</a>), but like <code>patchIf</code> and <code>patchUnless</code>. As far as I can tell, though, no such functionality is built into <code>patch</code>. Should I write my own decorator?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could write your own decorator that checks the environment variable and then calls the regular <code>patch()</code> if needed. You could also use the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock" rel="nofollow noreferrer"><code>wraps</code> argument</a> in the regular <code>patch()</code> decorator.</p>
<blockquote>
<p><em>wraps</em>: Item for the mock object to wrap. If <em>wraps</em> is not <code>None</code> then calling the Mock will pass the call through to the wrapped object (returning the real result). Attribute access on the mock will return a Mock object that wraps the corresponding attribute of the wrapped object (so attempting to access an attribute that doesnâ€™t exist will raise an <code>AttributeError</code>).</p>
</blockquote>
<p>I think that means you could check the environment variable before setting the return variable in your test. If you don't set a return value, then calls will be passed through to the wrapped object.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could just manually monkey patch out the dependency you're trying to mock/fake. This is what the <code>patch</code> decorator is doing under the hood (it also unpatches for you at the end of the function).</p>
<pre><code>def test_something():
  original_func = my_module.my_func
  if 'MAKE_EXTERNAL_REQUESTS' not in os.environ:
    # Monkey patch manually
    my_module.my_func = lambda x: x

  # do some logic that depends on my_module.my_func
  ...

  # Unpatch
  my_module.my_func = original_func
</code></pre>
<p>Note that when you assign to the given module attribute you're trying to patch over, that patch is live for <em>the entire</em> session of your interpreter. So if you just patch and don't unpatch, that patch will be live for <em>other</em> tests in your test suite.</p>
<p>If you're doing it one time this might be nice as a quick/dirty solution, if it's many times you might want a decorator to do it.</p>
<p>HTH.</p>
</div>
