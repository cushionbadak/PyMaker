<div class="post-text" itemprop="text">
<p>I have two Byte objects.
One comes from using the Wave module to read a "chunk" of data:</p>
<pre><code>def get_wave_from_file(filename):
    import wave
    original_wave = wave.open(filename, 'rb')
    return original_wave
</code></pre>
<p>The other uses MIDI information and a Synthesizer module (fluidsynth) </p>
<pre><code>def create_wave_from_midi_info(sound_font_path, notes):
    import fluidsynth
    s = []
    fl = fluidsynth.Synth()
    sfid = fl.sfload(sound_font_path) # Loads a soundfont
    fl.program_select(track=0, soundfontid=sfid, banknum=0, presetnum=0) # Selects the soundfont

    for n in notes:
        fl.noteon(0, n['midi_num'], n['velocity'])
         s = np.append(s, fl.get_samples(int(44100 * n['duration']))) # Gives the note the correct duration, based on a sample rate of 44.1Khz
        fl.noteoff(0, n['midi_num'])
    fl.delete()
    samps = fluidsynth.raw_audio_string(s)
    return samps
</code></pre>
<p>The two files are of different length.
I want to combine the two waves, so that both are heard simultaneously.
Specifically, I would like to do this "one chunk at a time".</p>
<p>Here is my setup:</p>
<pre><code>def get_a_chunk_from_each(wave_object, bytes_from_midi, chunk_size=1024, starting_sample=0)):
    from_wav_data  = wave_object.readframes(chunk_size)
    from_midi_data = bytes_from_midi[starting_sample:starting_sample + chunk_size]
    return from_wav_data, from_midi_data
</code></pre>
<p>Info about the return from get_a_chunk_from_each():
type(from_wav_data), type(from_midi_data)
 
len(from_wav_data), type(from_midi_data)
4096 1024</p>
<p>Firstly, I'm confused as to why the lengths are different (the one generated from wave_object.readframes(1024) is exactly 4 times longer than the one generated by manually slicing bytes_from_midi[0:1024]. This may be part of the reason I have been unsuccessful.</p>
<p>Secondly, I want to create the function which combines the two chunks. The following "pseudocode" illustrates what I want to happen:</p>
<pre><code>def combine_chunks(chunk1, chunk2):
    mixed = chunk1 + chunk2
    # OR, probably more like:
    mixed = (chunk1 + chunk2) / 2
    # To prevent clipping?
    return mixed
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It turns out there is a very, very simple solution.
I simply used the library audioop:</p>
<p><a href="https://docs.python.org/3/library/audioop.html" rel="nofollow noreferrer">https://docs.python.org/3/library/audioop.html</a></p>
<p>and used their "add" function ("width" is the sample width in bytes. Since this is 16 bit audio, that's 16 / 8 = 2 bytes):</p>
<pre><code>    audioop.add(chunk1, chunk2, width=2)
</code></pre>
</div>
<span class="comment-copy">Have you made sure the formats are the same? i.e. both are stereo or mono, and have the same bit depth and sample rate?</span>
<span class="comment-copy">@RandomDavis I believe both are stereo, 16bit, 44.1khz. For the purpose of the question, we can assume they are the same. If I find that they are not, I would adjust my inputs accordingly rather than trying to convert formats in code.</span>
