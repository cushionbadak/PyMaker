<div class="post-text" itemprop="text">
<p>I realize that title may be confusing, so allow me to explain.</p>
<p>I take input from a list that looks like  <code>L = [21.123, 22.123, 23.123, 21.123]</code>
I remove the decimals, and sort the list high to low. I also change it to a dictionary with occurrences, which looks like 
<code>newlist = {23: 1, 22: 1, 21: 2}</code> </p>
<p>What I need to do is to make a list of keys and values, which I can do. This gives me two lists, of <code>[23, 22, 21]</code> and <code>[1, 1, 2]</code> one for values and one for occurrences. I need to turn my occurrence list into the number of occurrences that are the same as, or lower than it's corresponding key.</p>
<p>I would like my list to look like <code>[23, 22, 21]</code> (which is easy to do) and <code>[4, 3, 2]</code> because 4 of the times are 23 seconds or less, 3 of the times are 22 seconds or less, and 2 of the times are 21 seconds or less. </p>
<p>I'm pretty sure I need a for loop to iterate through every frequency value, and change that value to be the total number of times entered into the list, and subtract any value more than it. I'm not sure how to go about this, so any help would be greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You want a dictionary where, for each item in your data, the key is the rounded value (<code>int(item)</code>) and the value is the number of of items that are smaller than or equal to this rounded value.</p>
<p>A <em>dictionary comprehension</em> (combined with a <em>list comprehension</em>) can do this:</p>
<pre><code>data = [21.123, 22.123, 23.123, 21.123]

aggregate = {
    item: len([n for n in data if int(n) &lt;= item])
    for item in set(map(int, data))
}

print(aggregate)  # -&gt; {21: 2, 22: 3, 23: 4}
</code></pre>
<p>which is the single-statement form of writing such a loop:</p>
<pre><code>aggregate = {}
for item in set(map(int, data)):
    aggregate[item] = len([n for n in data if int(n) &lt;= item])
}
</code></pre>
<p>Using <code>set()</code> makes the list unique. This way the loop only runs as often as necessary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a functional solution. The marginally tricky part is the backwards cumulative sum, which is possible feeding a reversed tuple to <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate</code></a> and then reversing the result.</p>
<pre><code>from collections import Counter
from itertools import accumulate
from operator import itemgetter

L = [21.123, 22.123, 23.123, 21.123]

c = Counter(map(int, L))                       # Counter({21: 2, 22: 1, 23: 1})
counter = sorted(c.items(), reverse=True)      # [(23, 1), (22, 1), (21, 2)]
keys, counts = zip(*counter)                   # ((23, 22, 21), (1, 1, 2))

cumsum = list(accumulate(counts[::-1]))[::-1]  # [4, 3, 2]
</code></pre>
<p>Your desired result is stored in <code>keys</code> and <code>cumsum</code>:</p>
<pre><code>print(keys)

(23, 22, 21)

print(cumsum)

[4, 3, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you get the counts correctly from <code>[21.123, 22.123, 23.123, 21.123]</code>, a simple nested loop with a <em>running sum</em> can do the rest:</p>
<pre><code>from collections import Counter

newlist = {23: 1, 22: 1, 21: 2}

counts = Counter()
for k in newlist:
    for v in newlist:
        if v &lt;= k:
            counts[k] += newlist[v]

print(counts)
# Counter({23: 4, 22: 3, 21: 2})
</code></pre>
<p>You could also use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product()</code></a> to condense the double loops into one:</p>
<pre><code>from itertools import product
from collections import Counter

newlist = {23: 1, 22: 1, 21: 2}

counts = Counter()
for k, v in product(newlist, repeat=2):
    if v &lt;= k:
        counts[k] += newlist[v]

print(counts)
# Counter({23: 4, 22: 3, 21: 2})
</code></pre>
<p>The above stores the counts in a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code></a>, you can get <code>[4, 3, 2]</code> by calling <code>list(counts.values())</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>I found my own solution which seems relatively simple. Code looks like</p>
<pre><code>counter = 0
print(valuelist)
for i in valuelist:
    print(int(solves - counter))
    counter = counter + i
    redonevalues.append(solves - counter + 1)
</code></pre>
<p>It takes my values, goes to the first one, adds the occurrences to counter, subtracts counter from solves, and adds 1 to even it out</p>
</div>
<span class="comment-copy">What have you tried, and what exactly is the problem with it?</span>
<span class="comment-copy">Hint: use the <i>cummulative sum</i>.</span>
<span class="comment-copy">For your fist problem, try Counter from the standard library collections module <code>collections.Counter(map(int, [21.123, 22.123, 23.123, 21.123]))</code>. When asking questions here, avoid asking multiple questions at the same time, and include your best effort code. Even if your code doesn't work, it helps us understand exactly what you are trying to do.</span>
<span class="comment-copy">I'm trying to figure out how to calculate how many occurrences are more than the corresponding key, so if i'm on the value from valuelist that corresponds to the number of times 22 occurs, I don't know how to calculate the number of times numbers 22- min value occur, and exclude the 1 time 23 occurs. Then subtract the amount more than corresponding key from total number of times, which is 4 (amount of times total) minus 1 (one time &gt; 22 seconds)</span>
<span class="comment-copy">It is hard to tell what <code>[4, 3, 2]</code> is honestly. What do you exactly mean by <i>"4 of the times are 23 seconds or less"</i>?</span>
<span class="comment-copy"><code>len([n for n in data if int(n) &lt;= item])</code> in a loop seems overkill. It works, of course, but you are performing more summations than necessary via a cumulative summation of counts. Regardless, cleaner IMO is to  at least avoid the list creation, something like <code>sum(int(n) &lt;= item for n in data)</code>.</span>
<span class="comment-copy">Fair point, I agree. I thought the idea <i>"count the number of items that are smaller than X"</i> might be more intuitive to the OP in form of a list comprehension.</span>
<span class="comment-copy">I like this one. All the reversing is a little confusing but better variable names could help. Also may want to note that <code>keys</code> and <code>cumsum</code> hold the two lists he wants.</span>
<span class="comment-copy">it's completely unclear to me what this code does. What's <code>redonevalues</code>? What's <code>solves</code>? What's <code>valuelist</code>? Why does <code>solves - counter + 1</code> result in anything of significance?</span>
