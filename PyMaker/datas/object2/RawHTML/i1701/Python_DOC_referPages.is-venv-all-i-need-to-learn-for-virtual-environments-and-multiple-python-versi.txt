<div class="post-text" itemprop="text">
<p>Python 3.3 includes in its standard library the new package <code>venv</code>. What does it do, and how does it differ from all the other packages that seem to match the regex <code>(py)?(v|virtual|pip)?env</code>?</p>
</div>
<div class="post-text" itemprop="text">
<h1>PyPI packages not in the standard library:</h1>
<ul>
<li><p><strong><a href="https://pypi.python.org/pypi/virtualenv" rel="noreferrer"><code>virtualenv</code></a></strong> is a very popular tool that creates isolated Python environments for Python libraries. If you're not familiar with this tool, I highly recommend learning it, as it is a very useful tool, and I'll be making comparisons to it for the rest of this answer.</p>
<p>It works by installing a bunch of files in a directory (eg: <code>env/</code>), and then modifying the <code>PATH</code> environment variable to prefix it with a custom <code>bin</code> directory (eg: <code>env/bin/</code>). An exact copy of the <code>python</code> or <code>python3</code> binary is placed in this directory, but Python is programmed to look for libraries relative to its path first, in the environment directory. It's not part of Python's standard library, but is officially blessed by the PyPA (Python Packaging Authority). Once activated, you can install packages in the virtual environment using <code>pip</code>.</p></li>
<li><p><strong><a href="https://github.com/yyuu/pyenv" rel="noreferrer"><code>pyenv</code></a></strong> is used to isolate Python versions. For example, you may want to test your code against Python 2.6, 2.7, 3.3, 3.4 and 3.5, so you'll need a way to switch between them. Once activated, it prefixes the <code>PATH</code> environment variable with <code>~/.pyenv/shims</code>, where there are special files matching the Python commands (<code>python</code>, <code>pip</code>). These are not copies of the Python-shipped commands; they are special scripts that decide on the fly which version of Python to run based on the <code>PYENV_VERSION</code> environment variable, or the <code>.python-version</code> file, or the <code>~/.pyenv/version</code> file. <code>pyenv</code> also makes the process of downloading and installing multiple Python versions easier, using the command <code>pyenv install</code>.</p></li>
<li><p><strong><a href="https://github.com/yyuu/pyenv-virtualenv" rel="noreferrer"><code>pyenv-virtualenv</code></a></strong> is a plugin for <code>pyenv</code> by the same author as <code>pyenv</code>, to allow you to use <code>pyenv</code> and <code>virtualenv</code> at the same time conveniently. However, if you're using Python 3.3 or later, <code>pyenv-virtualenv</code> will try to run <code>python -m venv</code> if it is available, instead of <code>virtualenv</code>. You can use <code>virtualenv</code> and <code>pyenv</code> together without <code>pyenv-virtualenv</code>, if you don't want the convenience features.</p></li>
<li><p><strong><a href="https://pypi.python.org/pypi/virtualenvwrapper" rel="noreferrer"><code>virtualenvwrapper</code></a></strong> is a set of extensions to <code>virtualenv</code> (see <a href="http://virtualenvwrapper.readthedocs.io/en/latest/" rel="noreferrer">docs</a>). It gives you commands like <code>mkvirtualenv</code>, <code>lssitepackages</code>, and especially <code>workon</code> for switching between different <code>virtualenv</code> directories. This tool is especially useful if you want multiple <code>virtualenv</code> directories.</p></li>
<li><p><strong><a href="https://github.com/yyuu/pyenv-virtualenvwrapper" rel="noreferrer"><code>pyenv-virtualenvwrapper</code></a></strong> is a plugin for <code>pyenv</code> by the same author as <code>pyenv</code>, to conveniently integrate <code>virtualenvwrapper</code> into <code>pyenv</code>.</p></li>
<li><p><strong><a href="https://pypi.python.org/pypi/pipenv" rel="noreferrer"><code>pipenv</code></a></strong>, by Kenneth Reitz (the author of <code>requests</code>), is the newest project in this list. It aims to combine <code>Pipfile</code>, <code>pip</code> and <code>virtualenv</code> into one command on the command-line. The <code>virtualenv</code> directory typically gets placed in <code>~/.local/share/virtualenvs/XXX</code>, with <code>XXX</code> being a hash of the path of the project directory. This is different from <code>virtualenv</code>, where the directory is typically in the current working directory.</p>
<p>The Python Packaging Guide <a href="https://packaging.python.org/guides/tool-recommendations/#application-dependency-management" rel="noreferrer">recommends <code>pipenv</code></a> when developing
Python applications (as opposed to libraries). There does not seem to
be any plans to support <code>venv</code> instead of <code>virtualenv</code> (<a href="https://github.com/pypa/pipenv/issues/15" rel="noreferrer">#15</a>).
Confusingly, its command-line option <code>--venv</code> refers to the
<code>virtualenv</code> directory, not <code>venv</code>, and similarly, the environment
variable <code>PIPENV_VENV_IN_PROJECT</code> affects the location of the
<code>virtualenv</code> directory, not <code>venv</code> directory (<a href="https://github.com/pypa/pipenv/issues/1919" rel="noreferrer">#1919</a>).</p></li>
</ul>
<h1>Standard library:</h1>
<ul>
<li><p><strong><code>pyvenv</code></strong> is a script shipped with Python 3 but <a href="https://docs.python.org/dev/whatsnew/3.6.html#id8" rel="noreferrer">deprecated in Python 3.6</a> as it had problems (not to mention the confusing name). In Python 3.6+, the exact equivalent is <code>python3 -m venv</code>.</p></li>
<li><p><strong><a href="https://docs.python.org/3/library/venv.html" rel="noreferrer"><code>venv</code></a></strong> is a package shipped with Python 3, which you can run using <code>python3 -m venv</code> (although for some reason some distros separate it out into a separate distro package, such as <code>python3-venv</code> on Ubuntu/Debian). It serves a similar purpose to <code>virtualenv</code>, and works in a very similar way, but it doesn't need to copy Python binaries around (except on Windows). Use this if you don't need to support Python 2. At the time of writing, the Python community seems to be happy with <code>virtualenv</code> and I haven't heard much talk of <code>venv</code>.</p></li>
</ul>
<p>Most of these tools complement each other. For instance, <code>pipenv</code> integrates <code>pip</code>, <code>virtualenv</code> and even <code>pyenv</code> if desired. The only tools that are true alternatives to each other here are <code>venv</code> and <code>virtualenv</code>.</p>
<h1>Recommendation for beginners:</h1>
<p>This is my personal recommendation for beginners: start by learning <code>virtualenv</code> and <code>pip</code>, tools which work with both Python 2 and 3 and in a variety of situations, and pick up the other tools once you start needing them.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would just avoid the use of <code>virtualenv</code> after Python3.3+ and instead use the standard shipped library <code>venv</code>. To create a new virtual environment you would type:</p>
<pre><code>$ python3 -m venv &lt;MYVENV&gt;  
</code></pre>
<p><code>virtualenv</code> tries to copy the Python binary into the virtual environment's bin directory. However it does not update library file links embedded into that binary, so if you build Python from source into a non-system directory with relative path names, the Python binary breaks. Since this is how you make a copy distributable Python, it is a big flaw. BTW to inspect embedded library file links on OS X, use <code>otool</code>. For example from within your virtual environment, type:</p>
<pre><code>$ otool -L bin/python
python:
    @executable_path/../Python (compatibility version 3.4.0, current version 3.4.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)
</code></pre>
<p>Consequently I would avoid <code>virtualenvwrapper</code> and <code>pipenv</code>. <code>pyvenv</code> is deprecated. <code>pyenv</code> seems to be used often where <code>virtualenv</code> is used but I would stay away from it also since I think <code>venv</code> also does what <code>pyenv</code> is built for.  </p>
<p><code>venv</code> creates virtual environments in the shell that are <em>fresh</em> and <em>sandboxed</em>, with <em>user-installable libraries</em>, and it's <em>multi-python safe</em>. <em>Fresh</em> because virtual environments only start with the standard libraries that ship with python, you have to install any other libraries all over again with <code>pip install</code> while the virtual environment is active. <em>Sandboxed</em> because none of these new library installs are visible outside the virtual environment, so you can delete the whole environment and start again without worrying about impacting your base python install. <em>User-installable libraries</em> because the virtual environment's target folder is created without <code>sudo</code> in some directory you already own, so you won't need <code>sudo</code> permissions to install libraries into it. Finally it is <em>multi-python safe</em>, since when virtual environments activate, the shell only sees the python version (3.4, 3.5 etc.) that was used to build that virtual environment.   </p>
<p><code>pyenv</code> is similar to <code>venv</code> in that it lets you manage multiple python environments. However with <code>pyenv</code> you can't conveniently rollback library installs to some start state and you will likely need <code>admin</code> privileges at some point to update libraries. So I think it is also best to use <code>venv</code>.  </p>
<p>In the last couple of years I have found many problems in build systems (emacs packages, python standalone application builders, installers...) that ultimately come down to issues with <code>virtualenv</code>. I think python will be a better platform when we eliminate this additional option and only use <code>venv</code>.</p>
</div>
<span class="comment-copy">And to preempt the close votes, I felt this was a more general question than <a href="http://stackoverflow.com/questions/29950300/what-is-the-relationship-between-virtualenv-and-pyenv" title="what is the relationship between virtualenv and pyenv">stackoverflow.com/questions/29950300/…</a> , and so I didn't feel comfortable editing that question or posting an overly general answer on that post.</span>
<span class="comment-copy">This guide is both useful &amp; constantly updated as python continues to add more &amp; more "one &amp; only one obvious way" to do things:  <a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" rel="nofollow noreferrer">docs.python-guide.org/en/latest/dev/virtualenvs</a></span>
<span class="comment-copy">As of 3.6 I found it easier to get virtualenv working in comparison to pyenv on macOS (I'm a pyNoob)</span>
<span class="comment-copy">@HashRocketSyntax <code>virtualenv</code> and <code>pyenv</code> do not perform the same function, and are not alternatives to each other. See my answer.</span>
<span class="comment-copy">I love it when people answer questions I didn't even know I had.</span>
<span class="comment-copy">This is very helpful! So why are there 8 tangled things instead of 1? (“There should be one – and preferably only one – obvious way to do it.” -- The Zen of Python)</span>
<span class="comment-copy">@Jerry101, the introduction of venv is in part a response to that mess. If you want to help improve the situation, I suggest you use venv and encourage others to do the same.</span>
<span class="comment-copy">"the introduction of venv is in part a response to that mess" How come when there are too many things that do 'something like X', people always think they can improve that mess by making an other thing that does 'something like X'. Its kind of funny actually. We are now 4 years later... so may be pertinent to ask, did <code>venv</code> actually solve that problem?</span>
<span class="comment-copy">The only two tools on the list that truly cover what is arguably the same territory are virtualenv and venv, so the characterization that we're dealing with a mess caused by several competing tools is not very precise.  The list does, however, consist of several virtual environment-related tools, all with similar-sounding names. That can be confusing, especially to users who are just learning about them.  Did venv improve the situation? It did offer a more light-weight alternative to other virtual environment tools, benefiting from native modifications and a spot in the standard library. …</span>
<span class="comment-copy"><code>add2virtualenv</code> tweaks your <code>PYTHONPATH</code> by adding a custom <code>_virtualenv_path_extensions.pth</code> file under <code>site-packages</code>. Alternatively you could update the <code>PYTHONPATH</code> environment variable in the <code>bin/activate</code> file which you call every time you activate the virtual environment. Or you could add symlinks under <code>site-packages</code> to point to the extra directories. Both of these alternatives are more transparent to the traditional command line tools developers widely use to troubleshoot. The use of a custom <code>.pth</code> with an undocumented name, makes it seem more magical IMO.</span>
<span class="comment-copy">Editing <code>PYTHONPATH</code> must work, see this <a href="https://stackoverflow.com/questions/4757178/how-do-you-set-your-pythonpath-in-an-already-created-virtualenv" title="how do you set your pythonpath in an already created virtualenv">stackoverflow.com/questions/4757178/…</a> . If you run into a problem post a comment there and I'll troubleshoot for you. <code>PYTHONPATH</code> takes paths to the <i>parent folder</i> not the module itself. See also this question if you get stuck <a href="https://stackoverflow.com/questions/19917492/how-to-use-pythonpath" title="how to use pythonpath">stackoverflow.com/questions/19917492/how-to-use-pythonpath</a> (or the manual! <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" rel="nofollow noreferrer">docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH</a>)</span>
<span class="comment-copy">Okay so I've confirmed on <a href="https://stackoverflow.com/questions/48130371/python-venv-modulenotfounderror" title="python venv modulenotfounderror">stackoverflow.com/questions/48130371/…</a> that a correct update to <code>PYTHONPATH</code> obviates the need for <code>add2virtualenv</code>. Regarding lack of help on SO from your first comment, my only suggestion is upvote answers if they fix your problem, to motivate people to troubleshoot for you when you post? A half an hour of investigation+write-up in exchange for a mouse click? Sounds like a good trade...</span>
<span class="comment-copy">No, you are right on -- I try to be good about upvoting. Heck, if you were in my area I would buy you a beer. I'll keep good on my promise and see if the python doc folks will let me add the change to /bin/activate the official docs for clarity. Though I'm not great, I'm not awful at python. If it was hard for me... Anyway, thank you for your time - wish you the best.</span>
<span class="comment-copy">@MalikA.Rumi the blessing has been slightly reduced to "the Pipenv creator diligently marketed to us and others, which is why we mention Pipenv".</span>
