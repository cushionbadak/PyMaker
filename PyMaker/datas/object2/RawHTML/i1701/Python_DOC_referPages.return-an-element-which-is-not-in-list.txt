<div class="post-text" itemprop="text">
<p>I have a list containing 3 elements, for example '1', '2', '3' and I wanna write a function which returns element which is not an function argument. For example:</p>
<pre><code> def get_char(a, b):
     crs = ['1', '2', '3']
     return something

 x = get_char('1', '2')
 x = '3'

 x = get_char('3', '2')
 x = '1'
</code></pre>
<p>You can see what I'm trying to accomplish. I know that I can get it by using if statements but is there any simpler way of doing it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a general response:</p>
<pre><code>def get_chars(*args):
    chars = {'1', '2', '3'}
    return (chars^set(args)).pop()
</code></pre>
<p>Though you may want to do something to handle the case that you pass in 3 arguments or 1 argument. Depends on your usecase.</p>
<p>Note also that you could change your <code>chars</code> set to have more characters, and this function would still work.</p>
<hr/>
<p>As ShadowRanger points out in the comments, it probably makes more sense to do set subtraction than bit-wise xor. Something like this:</p>
<pre><code>def get_chars(*args):
    return ({'1', '2', '3'} - set(args)).pop()
</code></pre>
<p>This is still subject to the same problem if passing in the wrong number of arguments, which you could check using something like this:</p>
<pre><code>def get_chars(*args):
    diff = {'1', '2', '3'} - set(args)
    if len(diff) != 1:
        # Handle the incorrect number of args (or use error)
        return None
    return diff.pop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use two lists, an iteration and the  not in function:</p>
<pre><code>x = [1,2,3]

y = [1,5,7]


def compare(original_list, list_to_compare):
    for i in original_list:
        if i not in list_to_compare:
            print(i)


compare(x,y)
# result 2, 3
compare(y,x)
*emphasized text*# result 5,3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may use <code>if</code> and <code>in</code> to test if the variable is present in the arguments list (<code>args</code> here):</p>
<pre><code>&gt;&gt;&gt; def get_char(*args):
...     crs = ['1', '2', '3']
...     for x in crs:
...             if x not in args:
...                     return x
...     return Null
... 
&gt;&gt;&gt; x = get_char('1', '2')
&gt;&gt;&gt; 
&gt;&gt;&gt; x
'3'
</code></pre>
<p>This returns the very first element in <code>crs</code> that is not also present in <code>args</code>, returns <code>Null</code> if all are present.</p>
</div>
<div class="post-text" itemprop="text">
<p>I guess that this could be what you are asking for:</p>
<pre><code>def elements_from_crs_not_in_args(*args): 
     crs = ['1','2','3']
     return [i for i in crs if i not in args] 
</code></pre>
<p>Then:</p>
<pre><code>input: elements_from_crs_not_in_args('1','2')
result: ['3']
</code></pre>
<p>If you are planning to return a single element (first of the list?) instead of a list, return[..][0]</p>
</div>
<div class="post-text" itemprop="text">
<p>I would do two things first if set of <code>char</code> are same I will pull them outside the function so it does not get executed each time. Second use set operation symmetric difference <code>^</code>to find all the elements which are present in only one list of two lists or difference to find the difference of one set from another. In the end you have to convert the set into a tuple in order to get the first element as set do not support indexes</p>
<pre><code>crs = set(['1', '2', '3'])
def get_char(a, b):
    return (crs ^ set((a,b))).pop()

print(get_char('1', '2')) #'3'
</code></pre>
<p>Or better </p>
<pre><code>crs = set(['1', '2', '3'])
def get_char(a, b):
     return (crs - set((a,b))).pop()

print(get_char('1', '2')) #'3'
</code></pre>
<p>In Python3 you can use set literal as pointed out by @ShadowRanger</p>
<pre><code>crs = {'1', '2', '3'}
def get_char(a, b):
    return (crs - {a, b}).pop()

print(get_char('1', '2')) #'3'
</code></pre>
</div>
<span class="comment-copy">Is it always <code>n</code> elements and you provide <code>n-1</code> elements as an input to the function?</span>
<span class="comment-copy"><code>set(['1', '2', '3'])^set(a,b)</code></span>
<span class="comment-copy">Yes, it should always work that way.</span>
<span class="comment-copy">@mad_: <code>^</code> is a little off from the desired behavior, and this is Python 3, so you can use <code>set</code> literals; <code>{'1', '2', '3'} - {a, b}</code> is cleaner and more correct.</span>
<span class="comment-copy">Thank you! That's what i wanted to do!</span>
<span class="comment-copy">You want <code>-</code>, not <code>^</code> here; <code>^</code> would return elements in <code>chars</code> that aren't in <code>args</code> <i>and</i> elements in <code>args</code> that aren't in <code>chars</code>, while <code>chars - set(args)</code> (or <code>chars.difference(args)</code>, the named methods don't require the arguments to be explicitly converted to <code>set</code>) would only return the values in <code>chars</code> not found in <code>args</code>.</span>
<span class="comment-copy">@ShadowRanger Good call.</span>
<span class="comment-copy">Is there some reason you don't use <code>set</code> literals? They've been available since <a href="https://docs.python.org/3/whatsnew/2.7.html#python-3-1-features" rel="nofollow noreferrer">2.7</a>/<a href="https://docs.python.org/3/whatsnew/3.0.html#new-syntax" rel="nofollow noreferrer">3.0</a> (over eight years now), and they're both faster and clearer than calling the <code>set</code> constructor on <code>list</code>/<code>tuple</code> literals.</span>
<span class="comment-copy">@ShadowRanger yup I have a local environment of 2.7 from old age still running.</span>
