<div class="post-text" itemprop="text">
<p>Using Python:</p>
<p>I have a dictionary where the 'key' represents the value of a coin. And the 'value' represents the number of that coin.</p>
<p>Such as:</p>
<pre><code>dict =  {2: [0], 1: [0], 0.5: [0], 0.2: [0], 0.1: [0], 0.05: [1], 0.02: [1, 1, 1, 1], 0.01: [1, 1, 1]}
</code></pre>
<p>or</p>
<pre><code>dict = {2: [], 1: [], 0.5: [], 0.2: [], 0.1: [], 0.05: [1], 0.02: [1, 1, 1, 1], 0.01: [1, 1, 1]}
</code></pre>
<p>or</p>
<pre><code>dict = {2: 0, 1: 0, 0.5: 0, 0.2: 0, 0.1: 0, 0.05: 1, 0.02: 4, 0.01: 3}
</code></pre>
<p>(I am not sure which is best to use - it could also just be represented as a list of 8 integers, eg. [0,0,0,0,0,1,4,3] or a list of lists eg [[],[],[],[],[],[1],[1,1,1,1],[1,1,1]])</p>
<p>I want to create a dictionary which shows all possible combinations of different coins where the 'key' would be the total value of the coins and the 'value' would be a list of 8 integers representing the number of each coin.</p>
<p>EDIT: I realised what I want to do is impossible with dictionaries as you cant have multiple assignments to a single key name: How would one use the function itertools.combinations(iterable, r) to return a list of tuples ? </p>
</div>
<div class="post-text" itemprop="text">
<p>I think the easiest way to solve this is by using <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a>.</p>
<p>To use this, you first need to convert your <code>dict</code> of coin counts into a <code>list</code> of coins:</p>
<pre class="lang-py prettyprint-override"><code>coins = {2: 0, 1: 0, 0.5: 0, 0.2: 0, 0.1: 0, 0.05: 1, 0.02: 4, 0.01: 3}
# stores a list of all coin values, ie [0.2, 0.2, 1] if one has two 20c and 1 $1
coin_list = []
for value, count in coins.items():
    if count &gt; 0:
        coin_list += [value] * count
</code></pre>
<p>Then, one can use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> to get every possible combination for every possible combination size, sum it up, and save if to an output <code>dict</code>.</p>
<p>Since you want to store every possible combination of coins for each value, you could turn each item in the <code>dict</code> to a <code>set</code> of <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>. The <code>set</code> would only store unique coin counts: </p>
<pre class="lang-py prettyprint-override"><code>import itertools
import collections
output_dict = dict()
for comb_size in range(len(coin_list)):
    # gets every combination of every size from coin_list
    for combination in itertools.combinations(coin_list, comb_size):
        # sums up all coins in combination
        value = sum(combination)
        # get the set of existing coins for value/create if it doesn't exist
        value_set = output_dict.get(value, set())
        # collections.Counter counts up each coin in a combination
        counter = collections.Counter(combination)
        # we need to convert counter to a hashable form to add it to a set()
        value_set.add(tuple(sorted(counter.items())))
        output_dict[value] = value_set
</code></pre>
<p>Finally, because adding up floating points can cause weird results (like <code>0.1 + 0.2 = 0.300000001</code>), when printing you can round the value of the sums to the nearest cent (and use the module <code>pprint</code> to make the formatting nicer):</p>
<pre><code>import pprint
pprint.pprint({round(x, 2): y for x,y in output_dict.items()})
</code></pre>
<p>Which would print out a <code>dict</code> of <code>set</code> for each coin value sum. Each <code>set</code> contains <code>tuples</code> of pairs of (coin value, number of coins), ie for 3 cents, one can either have 3 * 1c coins (<code>((0.01, 3),)</code>), or a 1c + 2c (<code>((0.01, 1), (0.02, 1))</code>):</p>
<pre><code>{0: {()},
 0.01: {((0.01, 1),)},
 0.02: {((0.02, 1),), ((0.01, 2),)},
 0.03: {((0.01, 3),), ((0.01, 1), (0.02, 1))},
 0.04: {((0.02, 2),), ((0.01, 2), (0.02, 1))},
 0.05: {((0.01, 1), (0.02, 2)), ((0.05, 1),), ((0.01, 3), (0.02, 1))},
 0.06: {((0.02, 3),)},
 0.07: {((0.01, 1), (0.02, 3))},
 0.08: {((0.01, 2), (0.02, 3))},
 0.09: {((0.01, 3), (0.02, 3))},
 0.1: {((0.01, 3), (0.02, 1), (0.05, 1)), ((0.01, 2), (0.02, 4))},
 0.11: {((0.01, 3), (0.02, 4))},
 0.12: {((0.01, 3), (0.02, 2), (0.05, 1))},
 0.13: {((0.01, 2), (0.02, 3), (0.05, 1)), ((0.02, 4), (0.05, 1))},
 0.14: {((0.01, 1), (0.02, 4), (0.05, 1)), ((0.01, 3), (0.02, 3), (0.05, 1))},
 0.15: {((0.01, 2), (0.02, 4), (0.05, 1))}}
</code></pre>
</div>
<span class="comment-copy">Great! What have you tried to solve this?</span>
<span class="comment-copy">So far i have tried this but i have no idea what the solution is tbh           import itertools for key in dictionary:         itertools.combinations(dictionary[key] , len(dictionary[key]))</span>
<span class="comment-copy">thank you so much!</span>
<span class="comment-copy">I just realised this is wrong (at least for what i intended) for example the 'key' 0.07 should appear twice: (0.02, 0.02,0.02,0.1) and (0.5, 0.2). As you cant have multiple assignments to one key name I realised it is impossible to do with dictionaries. How would one use the same function from itertools to create a list of tuples so that you could have multiple tuples totalling the same value?</span>
