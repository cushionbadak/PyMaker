<div class="post-text" itemprop="text">
<p>By default, <code>asyncio</code> runs coroutines synchronously. If they contain blocking IO code, they still wait for it to return. A way around this is <a href="https://docs.python.org/3/library/asyncio-eventloop.html#executing-code-in-thread-or-process-pools" rel="nofollow noreferrer"><code>loop.run_in_executor()</code></a>, which converts the code into threads. If a thread blocks on IO, another thread can start executing. So you don't waste time waiting for IO calls.</p>
<p>If you use <code>asyncio</code> without executors, you loose those speedups. So I was wondering, why do you have to use executors explicitly. Why not enable them by default ?
(In the following, I'll focus on http requests. But they really only serve as an example. I'm interested in the general principles.) </p>
<p>After some searching I found <a href="https://aiohttp.readthedocs.io/en/stable/" rel="nofollow noreferrer">aiohttp</a>. It's a library that essentially offers a combination of <code>asyncio</code> and <code>requests</code>: Non blocking HTTP calls. With executors, <code>asyncio</code> and <code>requests</code> behave pretty much just like <code>aiohttp</code>. Is there a reason to implement a new library, do you pay a performance penalty for using executors?</p>
<p>This question was answered: <a href="https://stackoverflow.com/questions/53260688/why-doesnt-asyncio-always-use-executors">Why doesn't asyncio always use executors?</a>
Mikhail Gerasimov has explained to me that executors will spin up OS-threads and they can become expensive. So it makes sense not to have them as default behaviour. <code>aiohttp</code> is better than using the <code>requests</code> module in an executor, since it offers non-blocking code with only coroutines.</p>
<p>Which brings me to this question. <a href="https://aiohttp.readthedocs.io/en/stable/" rel="nofollow noreferrer">aiohttp</a> advertises itself as :</p>
<blockquote>
<p>Asynchronous HTTP Client/Server for asyncio and Python.</p>
</blockquote>
<p>So <code>aiohttp</code> is based on <code>asyncio</code>? Why doesn't <code>asyncio</code> offer non-blocking code with only coroutines then? That would be the ideal default.</p>
<p>Or did <code>aiohttp</code> implement this new event-loop (without OS-threads) itself ?
In that case I don't understand why they advertise themselves as based on <code>asyncio</code>. <code>Async/await</code> are a language feature. <code>Asyncio</code> is an event-loop. And if <code>aiohttp</code> has its own event-loop there should be little intersection with <code>asyncio</code>. Actually, I would argue that such an event loop would be a much bigger feature than http requests.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>asyncio</code> is asynchronous because coroutines <em>cooperate voluntarily</em>. <strong>All</strong> <code>asyncio</code> code must be written with cooperation in mind, that's the point entirely.  Otherwise you may as well use threading exclusively to achieve concurrency.</p>
<p>You can't run 'blocking' functions (non-coroutine functions or methods that won't cooperate) in an executor because you can't just <em>assume</em> that that code <strong>can</strong> be run in a separate executor thread. Or even if it <em>needs</em> to be run in an executor.</p>
<p>The Python standard library is full of really useful code, that <code>asyncio</code> projects will want to make use of. The majority of the standard library consists of regular, 'blocking' function and class definitions. They do their work quickly, so even though they 'block', they return in reasonable time.</p>
<p>But most of that code is also not thread-safe, it doesn't need to be usually. But as soon as <code>asyncio</code> would run all such code in an executor <em>automatically</em>, then you can't use non-thread-safe functions any more. Besides, creating a thread to run synchronous code in is not free, creating the thread object costs time, and your OS won't let you run an infinite number of threads either. Loads of standard library functions and methods are <em>fast</em>, why would you want to run <code>str.splitlines()</code> or <code>urllib.parse.quote()</code> in a separate thread when it would be much quicker to just execute the code and be done with it?</p>
<p>You may say that those functions are not blocking by your standards. You didn't define 'blocking' here, but 'blocking' just means: <em>won't voluntarily yield.</em>. If we narrow this down to <em>won't voluntarily yield when it has to wait for something and the computer could be doing something else instead</em>, then the next question would be <em>how would you detect that it <strong>should</strong> have yielded</em>?</p>
<p>The answer to that is that <em>you can't.</em> <code>time.sleep()</code> is a blocking function where you'd want to yield to the loop for, but that's a C function call. Python can't <em>know</em> that <code>time.sleep()</code> is going to block for longer, because a function that calls <code>time.sleep()</code> will look up the name <code>time</code> in the global namespace, and then the attribute <code>sleep</code> on the result of the name lookup, only when actually executing the <code>time.sleep()</code> expression. Because Python's namespaces can be altered <em>at any point during execution</em>, you can't know what <code>time.sleep()</code> will do until you actually execute the function.</p>
<p>You could say that the <code>time.sleep()</code> implementation should automatically yield when called then, but then you'd have to start identifying all such functions. And there is no limit to the number of places you'd have to patch and you can't ever know all the places. Certainly not for third-party libraries. For example the <a href="https://github.com/google/python-adb" rel="noreferrer"><code>python-adb</code> project</a> gives you a synchronous USB connection to an Android device, using the <code>libusb1</code> library. That's not a standard I/O codepath, so how would Python know that creating and using those connections are good places to yield?</p>
<p>So you can't just assume that code needs to be run in an executor, not all code <em>can</em> be run in an executor because it is not thread-safe, and Python can't detect when code is blocking and should really be yielding.</p>
<p>So how do coroutines under <code>asyncio</code> cooperate? By using <a href="https://docs.python.org/3/library/asyncio-task.html#task-object" rel="noreferrer"><em>task</em> objects</a> per logical piece of code that needs to run concurrently with other tasks, and by using <a href="https://docs.python.org/3/library/asyncio-future.html#future-object" rel="noreferrer"><em>future</em> objects</a> to signal to the task that the current logical piece of code wants to cede control to other tasks. That's what makes asynchronous <code>asyncio</code> code asynchronous, voluntarily ceding control. When the loop gives control to one task out of many, the task executes a single 'step' of the coroutine call chain, until that call chain produces a future object, at which point the task adds a <em>wakeup</em> callback to the future object 'done' callback list and returns control to the loop. At some point later, when the future is marked done, the wakeup callback is run and the task will execute another coroutine callchain step.</p>
<p>Something <em>else</em> is responsible for marking the future objects as done. When you use <code>asyncio.sleep()</code>, a callback to be run at a specific time is given to the loop, where that callback would mark the <code>asyncio.sleep()</code> future as done. When you use a <a href="https://docs.python.org/3/library/asyncio-stream.html" rel="noreferrer">stream object</a> to perform I/O, then (on UNIX), the loop uses <a href="https://docs.python.org/3/library/select.html#select.select" rel="noreferrer"><code>select</code> calls</a> to detect when it is time to wake up a future object when the I/O operation is done. And when you use a <a href="https://docs.python.org/3/library/asyncio-sync.html" rel="noreferrer">lock or other synchronisation primitive</a>, then the synchronisation primitive will maintain a pile of futures to mark as 'done' when appropriate (Waiting for a lock? add a future to the pile. Freeing a held lock? Pick the next future from the pile and mark it as done, so the next task that was waiting for the lock can wake up and acquire the lock, etc.).</p>
<p>Putting synchronous code that blocks into an executor is just another form of cooperation here. When using <code>asyncio</code> in a project, it is up to the <em>developer</em> to make sure that you use the tools given to you to make sure your coroutines cooperate. You are free to use blocking <code>open()</code> calls on files instead of using streams, and you are free to use an executor when you know the code needs to be run in a separate thread to avoid blocking too long.</p>
<p>Last but not least, the whole point of using <code>asyncio</code> is to <em>avoid</em> using threading as much as possible. Using threads has downsides; code needs to be <em>thread-safe</em> (control can switch between threads <em>anywhere</em>, so two threads accessing a shared piece of data should do so with care, and 'taking care' can mean that the code is <em>slowed down</em>). Threads execute no matter if they have anything to do or not; switching control between a fixed number of threads that <em>all</em> wait for I/O to happen is a waste of CPU time, where the <code>asyncio</code> loop is free to find a task that is not waiting.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>So <code>aiohttp</code> is based on <code>asyncio</code>?</p>
</blockquote>
<p>Yes, it builds on asyncio's abstractions such as <a href="https://docs.python.org/3/library/asyncio-future.html" rel="nofollow noreferrer">futures</a>, <a href="https://docs.python.org/3/library/asyncio-protocol.html" rel="nofollow noreferrer">transports and protocols</a>, <a href="https://docs.python.org/3/library/asyncio-sync.html" rel="nofollow noreferrer">synchronization primitives</a>, and so on.</p>
<blockquote>
<p>Why doesn't <code>asyncio</code> offer non-blocking code with only coroutines then?</p>
</blockquote>
<p>If you use asyncio APIs, that's exactly what it does. It offers non-blocking code to <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.create_connection" rel="nofollow noreferrer">connect to a server</a>, <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.getaddrinfo" rel="nofollow noreferrer">resolve a host name</a>, <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.create_server" rel="nofollow noreferrer">create a server</a>, and even <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" rel="nofollow noreferrer">run blocking code</a> in a separate thread pool without blocking the event loop.</p>
<p>aiohttp uses all this functionality to implement a capable http client and server on top of asyncio.</p>
<blockquote>
<p>Or did <code>aiohttp</code> implement this new event-loop (without OS-threads) itself ?</p>
</blockquote>
<p>No, aiohttp hooks into asyncio's event loop. More precisely, the <em>application</em> that uses aiohttp spins up the asyncio event loop and hooks aiohttp (and other asyncio-based libraries) into it.</p>
<blockquote>
<p>Async/await are a language feature. Asyncio is an event-loop.</p>
</blockquote>
<p>Async/await are a language feature, like generators. Asyncio is a library that uses them, like itertools. There are other libraries that use coroutines, e.g. <a href="https://github.com/dabeaz/curio" rel="nofollow noreferrer">curio</a> and <a href="https://github.com/python-trio/trio" rel="nofollow noreferrer">trio</a>.</p>
</div>
<span class="comment-copy">Asyncio is non-blocking by default. But code you run inside of the event loop might be blocking.</span>
<span class="comment-copy">The entire point of <code>asyncio</code> and coroutines is to run non-blocking code without threads. The very first example of <code>aiohttp</code> shows it using <code>asyncio</code> to run non-blocking code. If you decide to run blocking code inside <code>asyncio</code>, that's not <code>asyncio</code>'s fault. You could just as well ask why <code>int("my bank account")</code> is not capable of returning your current account balance.</span>
<span class="comment-copy">Re, "'blocking' just means: won't voluntarily yield." I'm not a <i>real</i> Python programmer, but that's messed up.  In every other multi-threaded environment that I've used, "blocking" means that the function <i>will</i> yield to other threads.  No doubt, the confusion relates in some way to Python's horrible, awful GIL. (i.e., "blocking" could mean, "blocks the calling thread," or it could mean "blocks the entire process.")</span>
<span class="comment-copy">@SolomonSlow The blocking/non-blocking distinction has nothing to do with threads or the GIL. It is about yielding in the sense of coroutines - that means not blocking <i>the same thread</i>. Python has no problem with one thread yielding control <i>to other threads</i>.</span>
<span class="comment-copy">@SolomonSlow: threads <b>don't yield</b>. Your OS switches control between threads all the time, the code running in the threads don't have control over that. <i>Yielding</i> is a concious choice made by code executing that something else can run instead At most, threads can use synchronisation primitives such as locks and semaphores to stop doing <i>any work</i> while they wait for other threads to do something. But <b>a waiting thread is still doing something</b>, wasting CPU, the thread will still be given control to wait some more before control is moved to other threads again.</span>
<span class="comment-copy">@SolomonSlow: the GIL is one such lock; the Python evaluation loop uses a lock to coordinate access to the evaluation loop internals. You can have 19 threads all waiting for the GIL to be released while thread #20 holds the lock to interpret Python bytecodes. Threads that are running code that doesn't need to interpret Python bytecode should release the lock and get on with their work, they don't need to wait.</span>
<span class="comment-copy">@SolomonSlow: <code>asyncio</code> works entirely differently: an event loop hands control to one task until that task gives control back, at which point another task is run, etc. with tasks using callbacks to put themselves back in the running at a later time. At no point is control taken away from the task, tasks control when they yield.</span>
