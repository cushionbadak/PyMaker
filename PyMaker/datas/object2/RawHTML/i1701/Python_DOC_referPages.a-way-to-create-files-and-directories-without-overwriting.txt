<div class="post-text" itemprop="text">
<p>You know how when you download something and the downloads folder contains a file with the same name, instead of overwriting it or throwing an error, the file ends up with a number appended to the end? For example, if I want to download <code>my_file.txt</code>, but it already exists in the target folder, the new file will be named <code>my_file(2).txt</code>. And if I try again, it will be <code>my_file(3).txt</code>.</p>
<p>I was wondering if there is a way in Python 3.x to check that and get a unique name (not necessarily create the file or directory). I'm currently implementing it doing this:</p>
<pre><code>import os
def new_name(name, newseparator='_')
    #name can be either a file or directory name

    base, extension = os.path.splitext(name)
    i = 2
    while os.path.exists(name):
        name = base + newseparator + str(i) + extension
        i += 1

    return name
</code></pre>
<p>In the example above, running <code>new_file('my_file.txt')</code> would return <code>my_file_2.txt</code> if <code>my_file.txt</code> already exists in the cwd. <code>name</code> can also contain the full or relative path, it will work as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer">PathLib</a> and do something along these lines:</p>
<pre><code>from pathlib import Path 

def new_fn(fn, sep='_'):
    p=Path(fn)
    if p.exists():
        if not p.is_file(): 
            raise TypeError
        np=p.resolve(strict=True)
        parent=str(np.parent)
        extens=''.join(np.suffixes)  # handle multiple ext such as .tar.gz
        base=str(np.name).replace(extens,'')
        i=2
        nf=parent+base+sep+str(i)+extens    
        while Path(nf).exists():
            i+=1
            nf=parent+base+sep+str(i)+extens    
        return nf   
    else:       
        return p.parent.resolve(strict=True) / p 
</code></pre>
<p>This only handles files as written but the same approach would work with directories (which you added later.) I will leave that as a project for the reader.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way of getting a new name would be using the built-in <code>tempfile</code> module:</p>
<pre><code>from pathlib import Path
from tempfile import NamedTemporaryFile

def new_path(path: Path, new_separator='_'):
    prefix = str(path.stem) + new_separator
    dir = path.parent
    suffix = ''.join(path.suffixes)

    with NamedTemporaryFile(prefix=prefix, suffix=suffix, delete=False, dir=dir) as f:
        return f.name
</code></pre>
<p>If you execute this function from within Downloads directory, you will get something like:</p>
<pre><code>&gt;&gt;&gt; new_path(Path('my_file.txt'))
'/home/krassowski/Downloads/my_file_90_lv301.txt'
</code></pre>
<p>where the <code>90_lv301</code> part was generated internally by the Python's <code>tempfile</code> module.</p>
<p><strong>Note</strong>: with the <code>delete=False</code> argument, the function will create (and leave undeleted) an empty file with the new name. If you do not want to have an empty file created that way,  just remove the <code>delete=False</code>, however keeping it will prevent anyone else from creating a new file with such name before your next operation (though they could still overwrite it).</p>
<p>Simply put, having <code>delete=False</code> prevents concurrency issues if you (or the end-user) were to run your program twice at the same time.</p>
</div>
<span class="comment-copy">I don't understand: your problem is that the python function override the files/directories without telling you the problem? Or do you want a built-in function that automatically adds the number to the filename if the file already exists? You will never find the latter because it's application specific and has nothing to do with the OS.</span>
<span class="comment-copy"><code>pathlib</code> is really helpful for stuff like this: <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer">docs.python.org/3/library/pathlib.html</a> in particular, check out <code>Path.touch(mode=0o666, exist_ok=True)</code></span>
<span class="comment-copy">So... You've coded a solution that solves your problem, but you want to know if it's already been solved somewhere and is part of the standard Python 3 distribution? Do you mind explaining why? I don't really see the point to be honest</span>
<span class="comment-copy">@Karl: it's better than the far more usual "plz what built-in function does the following complicated task: (<i>list of requirements</i>)".</span>
<span class="comment-copy">Yeah that's true. I don't know if my tone came across as sarcastic. Not really meant that way, I'm just curious. If OP has come up with a good solution, why not just keep it?</span>
<span class="comment-copy">An upvote for that final line alone! I just <i>had</i> to read the documentation to confirm you weren't making a silly mistake <code>;)</code> So, the slash operator is overloaded?</span>
<span class="comment-copy">@usr2564301: Yes, <code>/</code> is overloaded for the equivelent of <code>os.path.join</code>. See <a href="https://www.python.org/dev/peps/pep-0428/#joining" rel="nofollow noreferrer">PEP 428</a> The effect of <code>p.parent.resolve(strict=True) / p</code> is to return an absolute path regardless if called with an absolute, local, or relative path.</span>
<span class="comment-copy">Bonus points for teaching some of the strengths of PathLib, which I didn't know (sutff like <code>Path.suffixes</code> and <code>Path.resolve</code>). I'll try to move from os to PathLib. Also: I take it there is no strictly built-in way to do it, so I'll accept his answer.</span>
<span class="comment-copy">I'm not famliar with the notation ´def fun( var : Class)´ and googling stuff with punctuation marks is a hastle. Does that run some sort of assertion to chech that the value passed is an instance of tha class?</span>
<span class="comment-copy">No, it won't raise any exception if given type doesn't match the expected one, it is just for the programmer to hint him about the expected type (and for the IDE to show better suggestions). It is called <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">type hint</a>(ing) and was introduced in Python 3.5</span>
<span class="comment-copy">Very nice. I'm curious as to why I haven't seen it mor often.</span>
