<div class="post-text" itemprop="text">
<p>I have come across two approaches for calculating lcm. The first approach makes use of recursion while the later makes use of <code>caret</code> operator. I have even observed the first approach throws an error if there is deep recursion. Apart from using a caret in approach #2,  I believe there must be a pattern or some intuitive logic. If it is so, can you explain to me, please?</p>
<h1>Approach #1</h1>
<pre><code>def gcd(a,b): 

 if (a == b): 
    return a 

 if (a &gt; b): 
    return gcd(a-b, b) 

 return gcd(a, b-a) 


def lcm(a,b): 
   return (a*b) / gcd(a,b) 
</code></pre>
<h1>Approach #2</h1>
<pre><code>def gcd(a,b):

  while (b != 0) :
    a %= b
    a ^= b
    b ^= a
    a ^= b

  return a

def lcm(a,b):
  return (a * b) // gcd(a,b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using 3 XOR operations is just a silly way to swap two variables.</p>
<pre><code>a ^= b
b ^= a
a ^= b
</code></pre>
<p>is the same as</p>
<pre><code>a,b = b,a
</code></pre>
<p>The two approaches use different calculations but both converge the same way by computing the remainder of the division of the larger number by the smaller one.   The recursive method uses multiple subtractions to obtain the equivalent of a modulo while the iterative method uses the modulo operator directly. The recursive method will perform more iterations and would thus be a lot less efficient for numbers that are very far apart.</p>
<p>Combining use of the modulo operator with the recursive approach would allow both functions to be one-line definitions:</p>
<pre><code>def gcd(a,b): return a if b == 0 else gcd(b,a%b)
def lcm(a,b): return (a*b)//gcd(a,b) 
</code></pre>
<p>By the way, those are implementations of the Euclidean algorithm for computing the GCD:  <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Euclidean_algorithm</a></p>
</div>
<span class="comment-copy"><a href="https://en.wikipedia.org/wiki/XOR_swap_algorithm" rel="nofollow noreferrer">en.wikipedia.org/wiki/XOR_swap_algorithm</a></span>
<span class="comment-copy">I know the use of the modulo operator, however, will it be a substitute for '-' operator i.e  Instead of gcd(a,b-a) or gcd(a-b,b), you have written gcd(a,a%b) ?</span>
<span class="comment-copy">Using successive subtractions instead of a modulo 1) is inefficient and 2) requires a comparison to determine which number is larger.   e.g. with subtractions: 21-6 --&gt; 15; 15-6 --&gt; 9 ; 9-6 --&gt; 3; now 6 is larger ... 6-3 --&gt; 3 ; 3-3 --&gt; 0 ==&gt; gcd is 3 (5 iterations).   but with modulo:  21%6 --&gt; 3 ; 6%3 --&gt; 0 ==&gt; gcd is 3 (2 iterations)</span>
