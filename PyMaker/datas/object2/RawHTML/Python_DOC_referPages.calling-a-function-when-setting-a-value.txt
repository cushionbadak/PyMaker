<div class="post-text" itemprop="text">
<p>Using the observer pattern, I have a subclass of <code>dict</code> where i override <code>__setitem__</code> to call a function whenever a value in the dict is changed. This works great for direct assignments such as <code>my_dict[key] = 1234</code> but does not work when I want to change a value in an array stored in the dict such as <code>my_dict[key][0] = 1</code>.</p>
<p>Since this is an asynchronous app, one thought I had was to schedule a future in <code>__getitem__</code> where the app waits a moment and then compares the old contents at the key to the current contents but that could obviously cause a race condition.</p>
<p>What is the best way to handle this? I'd prefer not to have to use a custom array any time I want to store an array in my dict.</p>
<p>EDIT: here's the class</p>
<pre><code>class SettingsTable(dict):
    def __init__(self, seq=None, **kwargs):
        super().__init__({}, **kwargs)
        self._post_process_map = {}

    def add_post_process(self, key, process, *args):
        if not self._post_process_map.__contains__(key):
            self._post_process_map[key] = []
        self._post_process_map[key].append((process, *args))

    def __setitem__(self, key, value):
        old_val = None
        if self.keys().__contains__(key):
            old_val = self[key]

        super().__setitem__(key, value)
        self._run_on_change_funcs(key, value, old_val)

    def _run_on_change_funcs(self, key, value, old_val):
        if not old_val.__eq__(value):
            if self._post_process_map.__contains__(key):
                for func in self._post_process_map[key]:
                    if func[1]:
                        func[0](func[1])
                    else:
                        func[0]()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you can write a subclass of <code>list</code> and also override its <code>__getitem__</code> function, you will use this class whenever your <code>dict</code> subclass <code>__getitem__</code> function receive a <code>list</code> type value. This is kinda hacky solution but it should work in your case</p>
<pre><code>def change_item(val):
    print 'item changed: ' + str(val)

class MyList(list):
    def __setitem__(self, key, val):
        change_item(val)
        list.__setitem__(self, key, val)

class MyDict(dict):
    def __setitem__(self, key, val):
        change_item(val)
        if isinstance(val, list):
            dict.__setitem__(self, key, MyList(val))
        else:
            dict.__setitem__(self, key, val)

md = MyDict()
md['a'] = 1
md['d'] = ['c', 'd', 'e', 'f']
md['d'][0] = 'b'
</code></pre>
<p>The output test I got was:</p>
<pre><code>item changed: 1
item changed: ['c', 'd', 'e', 'f']
item changed: b
</code></pre>
<p>Update:
I just checked out your code. I did the same approach as I suggested but I also store the dictionary reference and its key into the <code>MyList</code> object so that whenever the a <code>MyList</code> object change, it will create a duplicate <code>MyList</code> object, assign the new value to it and assign the dictionary object's value at key reference to be equal to the duplicate <code>MyList</code> object, thus triggering <code>SettingsTable</code>'s <code>__setitem__</code> function. I added a <code>print(value)</code> line in the <code>__setitem__</code> function in order to test if it is called or not when the code go through <code>md['d'][0]='b'</code> line</p>
<pre><code>class MyList(list):
    def __init__(self, dictionary, key, *args):
        super().__init__(*args)
        self.dictionary = dictionary
        self.key = key
    def __setitem__(self, key, val):
        new_list = MyList(self.dictionary, self.key, list(self))
        list.__setitem__(new_list, key, val)
        self.dictionary[self.key] = new_list

class SettingsTable(dict):
    def __init__(self, seq=None, **kwargs):
        super().__init__({}, **kwargs)
        self._post_process_map = {}

    def add_post_process(self, key, process, *args):
        if not self._post_process_map.__contains__(key):
            self._post_process_map[key] = []
        self._post_process_map[key].append((process, *args))

    def __setitem__(self, key, value):
        old_val = None
        if self.keys().__contains__(key):
            old_val = self[key]

        if isinstance(value, list):
            value = MyList(self, key, value)

        super().__setitem__(key, value)
        self._run_on_change_funcs(key, value, old_val)

    def _run_on_change_funcs(self, key, value, old_val):
        print(value)
        if not old_val.__eq__(value):
            if self._post_process_map.__contains__(key):
                for func in self._post_process_map[key]:
                    if func[1]:
                        func[0](func[1])
                    else:
                        func[0]()

md = SettingsTable()
md['a'] = 1
md['d'] = ['c', 'd', 'e', 'f']
md['d'][0] = 'b'

</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>AFAIR, it used to be a bad idea to subclass built-in types in Python some years ago. That aside, I don't think there is a concise solution through which a dict can be made aware of changes in any of its values. What do you need this functionality for?</p>
</div>
<span class="comment-copy">What about <a href="https://stackoverflow.com/questions/16676177/setting-an-item-in-nested-dictionary-with-setitem">this question</a> didn't help? It sounds like they have the same issue.</span>
<span class="comment-copy">You can make your <code>__setitem__</code> accept tuples, so that instead of <code>my_dict[key][0] = 1</code> you do <code>my_dict[key, 0] = 1</code>. Then all the special casing is in your <code>dict</code> subclass. Of course, that doesn't keep people from doing it the first way. However, comparing is right out; you'd need to keep a copy of any list that gets changed.</span>
<span class="comment-copy">In <code>my_dict[key][0] = 1</code>, <code>my_dict</code> knows nothing about any assignment; all that object sees is a lookup of <code>key</code>.  The only way to make this work would be to have every lookup of a mutable object return a wrapped version of the actual object, that has a <code>__setitem__()</code> override of its own.</span>
<span class="comment-copy">When assigning to an item of a subscriptable value, do you want the same function called?</span>
<span class="comment-copy"><a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> of your class?</span>
<span class="comment-copy">This is most likely what I'm going to do. This also allows for nested lists/dicts as well, as they can be chained together.</span>
<span class="comment-copy"><code>...is a bad idea to subclass built-in types in Python</code> - why is that, I've made some useful subclasses.</span>
<span class="comment-copy">For earlier versions of Pythons, I remember some online caveats about subclassing built-in types, maybe because there were no guarantees on API compatibility as the language evolved. I am not sure what the general practice is today.</span>
<span class="comment-copy">That would have been a long, long time ago, probably before the class/type unification in Python 2.2.</span>
