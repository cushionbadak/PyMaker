<div class="post-text" itemprop="text">
<p>While trying to tackle a more complex problem, I came to compare access speed to local variable vs member variables.</p>
<p>Here a test program:</p>
<pre><code>#!/usr/bin/env python

MAX=40000000

class StressTestMember(object):
    def __init__(self):
        self.m = 0

    def do_work(self):
        self.m += 1
        self.m *= 2

class StressTestLocal(object):
    def __init__(self):
        pass

    def do_work(self):
        m = 0
        m += 1
        m *= 2

# LOCAL access test
for i in range(MAX):
    StressTestLocal().do_work()

# MEMBER access test
for i in range(MAX):
    StressTestMember().do_work()
</code></pre>
<p>I know it might look like a bad idea to instantiate <code>StressTestMember</code> and <code>StressTestLocal</code> on each iterations but it makes sense in the modeled program where these are basically Active Records.</p>
<p>After a simple benchmark,</p>
<ul>
<li>LOCAL access test: 0m22.836</li>
<li>MEMBER access test: 0m32.648s</li>
</ul>
<p>The local version is ~33% faster while still part of a class. Why?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>self.m += 1</code> means you have to look up a local variable called <code>self</code> and then find the attribute called <code>m</code></p>
<p>Of course if you just have to look up a local variable, it will be faster without the extra step.</p>
<p>It can be useful to look at what is happening under the hood:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(StressTestLocal.do_work)
 18           0 LOAD_CONST               1 (0)
              3 STORE_FAST               1 (m)

 19           6 LOAD_FAST                1 (m)
              9 LOAD_CONST               2 (1)
             12 INPLACE_ADD         
             13 STORE_FAST               1 (m)

 20          16 LOAD_FAST                1 (m)
             19 LOAD_CONST               3 (2)
             22 INPLACE_MULTIPLY    
             23 STORE_FAST               1 (m)
             26 LOAD_CONST               0 (None)
             29 RETURN_VALUE        
&gt;&gt;&gt; dis.dis(StressTestMember.do_work)
 10           0 LOAD_FAST                0 (self)
              3 DUP_TOP             
              4 LOAD_ATTR                0 (m)
              7 LOAD_CONST               1 (1)
             10 INPLACE_ADD         
             11 ROT_TWO             
             12 STORE_ATTR               0 (m)

 11          15 LOAD_FAST                0 (self)
             18 DUP_TOP             
             19 LOAD_ATTR                0 (m)
             22 LOAD_CONST               2 (2)
             25 INPLACE_MULTIPLY    
             26 ROT_TWO             
             27 STORE_ATTR               0 (m)
             30 LOAD_CONST               0 (None)
             33 RETURN_VALUE        
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Local names is faster because Python does some optimization that local names don't need dict access, on the other hand, instance attributes need to access the <code>__dict__</code> of the object.</p>
<p>This is also the reason why local names are faster than global names.</p>
</div>
<span class="comment-copy">+1 Very good, clear answer.</span>
<span class="comment-copy">very nice. this deserves the accept.</span>
<span class="comment-copy">So does it follow that it'd be wise to create a new reference to a class variable in local scope? e.g., <code>m = self.m</code>? It wouldn't make any difference in this test, but my version of <code>do_work()</code> is a loop that runs millions of times.</span>
<span class="comment-copy">@JamesS, It's always best to measure your exact use case if it's important enough to tune it. If you were referencing <code>self.m</code> a few times I'd expect it to be faster to pull into a local var. Remember to save the local back to the attribute if you are mutating it.</span>
