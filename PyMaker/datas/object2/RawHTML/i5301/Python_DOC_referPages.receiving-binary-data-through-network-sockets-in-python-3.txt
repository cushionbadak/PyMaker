<div class="post-text" itemprop="text">
<p>In my networking class a lab i have is to make a client to receive 5 familiar 32-bit integers in big endian order and to intemperate them. I decided to use python and everything works well enough but i am receiving strange hex code.</p>
<blockquote>
<p>\x00\x00\x00o\x00\x00\x00\xe4\x00\x00\x01\xb3\x00\x00\x01\xdb\x00\x00\x01\xec</p>
</blockquote>
<p>I can convert most of it easily but the x00o is really confusing me, 228 435 475 492 where the 4 after that I believe. Can you help me intemperate the server message?  </p>
<pre><code>import socket 
import sys
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
except socket.error:
    print('Failed to create socket')
    sys.exit()
print('Socket Created')

host = 'localhost'
port = 5071

try:
    remote_ip = socket.gethostbyname(host)

except socket.gaierror:
    #could not resolve
    print('Hostname could not be resolved. Exiting')
    sys.exit()

s.connect((remote_ip , port))

print('Socket Connected to ' + host + ' on ip ' + remote_ip)

reply = s.recv(4096)

print(reply)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>code.py</em>:</p>
<pre><code>import sys
import struct


def convert_data_to_ints(data, big_endian=True):
    int_count = len(data) // 4  # Assuming uint is 4 bytes long !!!
    fmt = "&gt;" if big_endian else "&lt;"
    fmt += "I" * int_count
    return struct.unpack(fmt, data[:int_count * 4])


def main():
    print("Python {} on {}\n".format(sys.version, sys.platform))
    data = b"\x00\x00\x00o\x00\x00\x00\xe4\x00\x00\x01\xb3\x00\x00\x01\xdb\x00\x00\x01\xec"
    ints_be = convert_data_to_ints(data)
    print("Big endian: {}".format(ints_be))
    ints_le = convert_data_to_ints(data, big_endian=False)
    print("Little endian: {}".format(ints_le))


if __name__ == "__main__":
    main()
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li><code>convert_data_to_ints</code>:

<ul>
<li>Uses <a href="https://docs.python.org/3/library/struct.html#struct.unpack" rel="nofollow noreferrer">[Python]: struct.<strong>unpack</strong>(<em>fmt, buffer</em>)</a> to perform the conversion (might also check <a href="https://stackoverflow.com/questions/37990060/python-struct-pack-behavior">[SO]: Python struct.pack() behavior</a> for more details on how integers are being represented in memory - and also in the server response)</li>
<li>Conversion is done to <em><strong>unsigned</strong> int</em> (<code>"I"</code> format). Check the "<em>Format Strings</em>" section in on the (1<sup>st</sup>) above page</li>
<li>Relies on the fact that <em>int</em> is 4 bytes long (I didn't want to hardcode the <code>"IIIII"</code>, wanted to make it more general). If the string length is not a multiple of 4 (an integral number of <em>int</em>s), the incomplete <em>int</em> at the end (at most 3 bytes) is discarded (of course, a nicer way to pad the string and also convert the "incomplete" data, but that's outside the question scope)</li>
<li>Returns a tuple containing the converted integers</li>
</ul></li>
<li><code>main</code>:

<ul>
<li>Calls the above function on the data that you received from socket</li>
<li>As a bonus, it also converts it using <em>little endian</em> (but those values don't make much sense)</li>
<li>The data is a <a href="https://docs.python.org/3/library/stdtypes.html#bytes-objects" rel="nofollow noreferrer">[Python]: Bytes Objects</a> instance (I think <code>socket.recv</code> returns it in this form). If (I'm wrong and) it returns the data as a string, just use <a href="https://docs.python.org/3/library/stdtypes.html#str.encode" rel="nofollow noreferrer">[Python]: str.<strong>encode</strong>(<em>encoding="utf-8", errors="strict"</em>)</a></li>
</ul></li>
</ul>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>E:\Work\Dev\StackOverflow\q048508018&gt;"c:\install\Python\3.4.3\x86\python.exe" code.py
Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 24 2015, 22:43:06) [MSC v.1600 32 bit (Intel)] on win32

Big endian: (111, 228, 435, 475, 492)
Little endian: (1862270976, 3825205248, 3003187200, 3674275840, 3959488512)
</code></pre>
</blockquote>
</div>
<span class="comment-copy">If the value of a byte in the buffer corresponds to a printable character, Python shows it as that character when printing the buffer as a string. If the value does not match a printable character, Python shows the byte as two hex digits after a <code>\x</code> prefix.  So your <code>\x00o</code> represents a byte with value zero followed by a byte whose value is the value of the character 'o'.  The numeric value of that byte is <code>ord('o')</code> which is 111 decimal, 6f hexadecimal.</span>
