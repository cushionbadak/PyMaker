<div class="post-text" itemprop="text">
<p>I have this issue and I can't figure out how to solve it. I have this string:</p>
<pre><code>data = '\xc4\xb7\x86\x17\xcd'
</code></pre>
<p>When I tried to encode it:</p>
<pre><code>data.encode()
</code></pre>
<p>I get this result:</p>
<pre><code>b'\xc3\x84\xc2\xb7\xc2\x86\x17\xc3\x8d'
</code></pre>
<p>I only want:</p>
<pre><code>b'\xc4\xb7\x86\x17\xcd'
</code></pre>
<p>Anyone knows the reason and how to fix this. The string is already stored in a variable, so I can't add the literal b in front of it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot convert a string into bytes or bytes into string <em>without</em> taking an encoding into account. The whole point about the <code>bytes</code> type is an encoding-independent sequence of bytes, while <code>str</code> is a sequence of <a href="https://en.wikipedia.org/wiki/Code_point" rel="nofollow noreferrer">Unicode code points</a> which <em>by design</em> have no unique byte representation.</p>
<p>So when you want to convert one into the other, you must tell <em>explicitly</em> what encoding you want to use to perform this conversion. When converting into bytes, you have to say how to represent each character as a byte sequence; and when you convert from bytes, you have to say what method to use to map those bytes into characters.</p>
<p>If you don’t specify the encoding, then <a href="https://en.wikipedia.org/wiki/UTF-8" rel="nofollow noreferrer">UTF-8</a> is the default, which is a sane default since UTF-8 is ubiquitous, but it's also just <em>one</em> of many valid encodings.</p>
<p>If you take your original string, <code>'\xc4\xb7\x86\x17\xcd'</code>, take a look at what Unicode code points these characters represent. <code>\xc4</code> for example is the <a href="http://www.fileformat.info/info/unicode/char/00c4/index.htm" rel="nofollow noreferrer"><code>LATIN CAPITAL LETTER A WITH DIAERESIS</code></a>, i.e. <code>Ä</code>. That character happens to be encoded in UTF-8 as <code>0xC3 0x84</code> which explains why that’s what you get when you encode it into bytes. But it also has an encoding of <code>0x00C4</code> in UTF-16 for example.</p>
<hr/>
<p>As for how to solve this <em>properly</em> so you get the desired output, there is no clear correct answer. The solution that Kasramvd mentioned is also somewhat imperfect. If you read about the <code>raw_unicode_escape</code> codec <a href="https://docs.python.org/3/library/codecs.html#text-encodings" rel="nofollow noreferrer">in the documentation</a>:</p>
<blockquote>
<p><code>raw_unicode_escape</code></p>
<p>Latin-1 encoding with <code>\uXXXX</code> and <code>\UXXXXXXXX</code> for other code points. Existing backslashes are not escaped in any way. It is used in the Python pickle protocol.</p>
</blockquote>
<p>So this is just a <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">Latin-1 encoding</a> which has a built-in fallback for characters outside of it. I would consider this fallback somewhat harmful for your purpose. For Unicode characters that cannot be represented as a <code>\xXX</code> sequence, this might be problematic:</p>
<pre><code>&gt;&gt;&gt; chr(256).encode('raw_unicode_escape')
b'\\u0100'
</code></pre>
<p>So the code point 256 is <em>explicitly outside</em> of Latin-1 which causes the <code>raw_unicode_escape</code> encoding to instead return the encoded bytes for the string <code>'\\u0100'</code>, turning that one character into 6 bytes which have little to do with the original character (since it’s an escape sequence).</p>
<p>So if you wanted to use Latin-1 here, I would suggest you to use that one explictly, without having that escape sequence fallback from <code>raw_unicode_escape</code>. This will simply cause an exception when trying to convert code points outside of the Latin-1 area:</p>
<pre><code>&gt;&gt;&gt; '\xc4\xb7\x86\x17\xcd'.encode('latin1')
b'\xc4\xb7\x86\x17\xcd'
&gt;&gt;&gt; chr(256).encode('latin1')
Traceback (most recent call last):
  File "&lt;pyshell#28&gt;", line 1, in &lt;module&gt;
    chr(256).encode('latin1')
UnicodeEncodeError: 'latin-1' codec can't encode character '\u0100' in position 0: ordinal not in range(256)
</code></pre>
<p>Of course, whether or not code points outside of the Latin-1 area can cause problems for you depends on where that string actually comes from. But if you can make guarantees that the input will only contain valid Latin-1 characters, then chances are that you don't really need to be working with a string there in the first place. Since you are actually dealing with some kind of bytes, you should look whether you cannot simply retrieve those values as bytes in the first place. That way you won’t introduce <em>two</em> levels of encoding there where you can corrupt data by misinterpreting the input.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>'raw_unicode_escape'</code> as your encoding:</p>
<pre><code>In [14]: bytes(data, 'raw_unicode_escape')
Out[14]: b'\xc4\xb7\x86\x17\xcd'
</code></pre>
<p>As mentioned in comments you can also pass the encoding directly to the <code>encode</code> method of your string.</p>
<pre><code>In [15]: data.encode("raw_unicode_escape")
Out[15]: b'\xc4\xb7\x86\x17\xcd'
</code></pre>
</div>
<span class="comment-copy">Note that <i>“without change in encoding”</i> is a misleading requirement. When converting a string into bytes or vice-versa, you <i>have</i> to take an encoding into account in order to perform the conversion.</span>
<span class="comment-copy">I just read this answer. Very good. Deserves more upvotes!</span>
<span class="comment-copy">what about <code>data.encode("raw_unicode_escape")</code> ?</span>
<span class="comment-copy">@Jean-FrançoisFabre That's even better in this case!</span>
<span class="comment-copy">@avan989 don't "thank you". accept the answer instead.</span>
<span class="comment-copy">those string &lt;=&gt; bytes conversions are really hell :) can you explain why performing a default encoding adds this trash? (honest question, I don't know the answer). If you can't, well, never mind.</span>
<span class="comment-copy">@Jean-FrançoisFabre What you mean exactly by <i>hell</i> and <i>trash</i> because there are many problems with such conversions depend on the situation! ;))</span>
