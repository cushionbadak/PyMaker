<div class="post-text" itemprop="text">
<p>I stumbled upon a problem at Project Euler, <a href="https://projecteuler.net/problem=15" rel="nofollow noreferrer">https://projecteuler.net/problem=15</a>
. I solved this by combinatorics but was left wondering if there is a dynamic programming solution to this problem or these kinds of problems overall. And say some squares of the grid are taken off - is that possible to navigate? I am using Python. How should I do that? Any tips are appreciated. Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is also a mathematical solution (which is probably what you used):</p>
<pre><code>def factorial(n):
  result = 1
  for i in range(1, n + 1):
    result *= i
  return result

def paths(w, h):
  return factorial(w + h) / (factorial(w) * factorial(h))
</code></pre>
<p>This works because the number of paths is the same as the number of ways to choose to go right or down over <code>w + h</code> steps, where you go right w times, which is equal to <code>w + h choose w</code>, or <code>(w + h)! / (w! * h!)</code>.</p>
<p>With missing grid squares, I think there is a combinatoric solution, but it's very slow if there are many missing squares, so dynamic programming would probably be better there.</p>
<p>For example, the following <em>should</em> work:</p>
<pre><code>missing = [
  [0, 1],
  [0, 0],
  [0, 0],
]

def paths_helper(x, y, path_grid, missing):
  if path_grid[x][y] is not None:
    return path_grid[x][y]

  if missing[x][y]:
    path_grid[x][y] = 0
    return 0
  elif x &lt; 0 or y &lt; 0:
    return 0
  else:
    path_count = (paths_helper(x - 1, y, path_grid, missing) +
                  paths_helper(x, y - 1, path_grid, missing))
    path_grid[x][y] = path_count
    return path_count

def paths(missing):
  arr = [[None] * w for _ in range(h)]
  w = len(missing[0])
  h = len(missing)
  return paths_helper(w, h, arr, missing)

print paths()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do a simple backtrack and explore an implicit graph like this: (comments explain most of it)</p>
<pre><code>def explore(r, c, n, memo):
    """
        explore right and down from position (r,c)
        report a rout once position (n,n) is reached
        memo is a matrix which saves how many routes exists from each position to (n,n)
    """

    if r == n and c == n:
        # one path has been found
        return 1

    elif r &gt; n or c &gt; n:
        # crossing the border, go back
        return 0

    if memo[r][c] is not None:
        return memo[r][c]

    a= explore(r+1, c, n, memo)    #move down
    b= explore(r, c+1, n, memo)  #move right

    # return total paths found from this (r,c) position
    memo[r][c]= a + b

    return a+b

if __name__ == '__main__':
    n= 20
    memo = [[None] * (n+1) for _ in range(n+1)]

    paths = explore(0, 0, n, memo)
    print(paths)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Most straight-forwardly with python's built-in memoization util <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a>. You can encode missing squares as a <code>frozenset</code> (hashable) of missing grid points (pairs):</p>
<pre><code>from functools import lru_cache

@lru_cache(None)
def paths(m, n, missing=None):
    missing = missing or frozenset()
    if (m, n) in missing:
        return 0
    if (m, n) == (0, 0):
        return 1
    over = paths(m, n-1, missing=missing) if n else 0
    down = paths(m-1, n, missing=missing) if m else 0
    return over + down

&gt;&gt;&gt; paths(2, 2)
6
# middle grid point missing: only two paths
&gt;&gt;&gt; paths(2, 2, frozenset([(1, 1)]))
2
&gt;&gt;&gt; paths(20, 20)
137846528820
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/6342710/lattice-paths-algorithm-does-not-finish-running-for-20-x-20-grid">Lattice paths algorithm does not finish running for 20 X 20 grid</a></span>
<span class="comment-copy">You can find some interesting solutions for Project Euler problems if you check out their forums. For example, for this one, about halfway down the page there's a solution in Ruby using dynamic programming. So this at least confirms that the same is possible in Python, too.</span>
<span class="comment-copy">Thought you already had it :D. The solution you mentioned is indeed the same one I used; now all that's left is the elimination.</span>
<span class="comment-copy">@Kurns My answer has been edited to include elimination.</span>
<span class="comment-copy">Thanks. The question only remains how do I eliminate the missing squares, but thanks for the cache tip! I will certainly keep that in mind.</span>
<span class="comment-copy">@Kurns I added some code to account for missing grid points.</span>
