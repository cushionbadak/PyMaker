<div class="post-text" itemprop="text">
<p>Is it possible to define a data object in python that behaves like a normal integer when used in mathematical operations or comparisons, but is also able to store instance variables?</p>
<p>In other words, it should be possible to do the following things:</p>
<pre><code>pseudo_integer = PseudoInteger(5, hidden_object="Hello World!")
print(5 + pseudo_integer) # Prints "10"
print(pseudo_integer == 5) # Prints "True"
print(pseudo_integer.hidden_object) # Prints "Hello World!"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it is. You can create your own custom class. Python has many magic methods to help you archive that.</p>
<p>Check the code:</p>
<pre><code>class PseudoInteger:
    def __init__(self, x, s):
        self.x = x
        self.s = s

    def __add__(self, num):
        return self.x + num

    def __eq__(self, num):
        return self.x == num


a = PseudoInteger(5, 'hello, world')
print(a + 3)
print(a == 5)
print(a == 2)
</code></pre>
<p>Or you can just inherit from int, after creating an instance, you are able to assign attributes to the inherited int object. You can't assign attributes to int directly, because int does not support item assignment :</p>
<pre><code>class PseudoInteger(int):
    pass

a = PseudoInteger(5)
a.hidden = 'hello, world'

print(a)
print(a == 5)
print(a + 3)
print(a.hidden)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You simply need a class for this:</p>
<pre><code>class PseudoInteger(object):
    def __init__(self, num, hidden=None):
        self.num = num
        self.hidden = hidden

    def __add__(self,  otherVal):
        if isinstance(otherVal, PseudoInteger):
            return self.num + otherVal.num
        else:
            return self.num + otherVal

p = PseudoInteger(4, 'Tiger')
q = PseudoInteger(6, 'lion')

print (p+q)
print (p+4)
</code></pre>
<p>This prints out:</p>
<pre><code>10
8
</code></pre>
<p>You have to add the other operations (division, substraction, eq, ...) you need to the class on your own :)</p>
</div>
<div class="post-text" itemprop="text">
<p>So, all answers above is fine, but probably you don't want to re-define all existing methods.</p>
<p>Normally, in python you can just subclass any built-in class (type). But with immutable types (and integers in python is immutable) is slightly tricky. TL;DR:</p>
<pre><code>class PseudoInt(int):
    def __new__(cls, x, hidden, *args, **kwargs):
        instance = int.__new__(cls, x, *args, **kwargs)
        instance.hidden = hidden
        return instance

x = PseudoInt(5, 'secret')
x.hidden  # 'secret'
x + 4  # 9
x * 3  # 15
</code></pre>
<p>Normally, you should reload <code>__init__</code> method, but with immutable bases you should use <code>__new__</code>. You can read more about data model in <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">corresponding docs section</a></p>
<p>All this is viable only if you need single signature for constructing your object. If its fine to have 1 call for creating, and dedicated calls to populate object with attributes - <a href="https://stackoverflow.com/questions/48464960/is-it-possible-to-define-an-integer-like-object-in-python-that-can-also-store-in/48465216#48465216">Kevin's answer</a> is all you need</p>
</div>
<div class="post-text" itemprop="text">
<p>Look into implementing the <a href="https://docs.python.org/3/reference/datamodel.html#object.__add__" rel="nofollow noreferrer">__add__</a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer">__eq__</a> methods for your <code>PseudoInteger</code> class</p>
</div>
<span class="comment-copy">have you already tried smth? please post your tries here</span>
<span class="comment-copy">So what would you expect the <code>hidden_object</code> to be, after a addition ?</span>
<span class="comment-copy">@messerbill: I wouldn't know how to tackle the problem so I haven't tried anything.</span>
<span class="comment-copy">@liliscent: There is no need to call <code>hidden_object</code> after an addition, so it's okay if it's gone. I just need it to either be able to be added, compared or <code>hidden_object</code> to be obtained.</span>
<span class="comment-copy">What type do you want <code>5 + pseudo_integer</code> to have? Should it have type <code>int</code>, or type <code>PseudoInteger</code>? What about <code>pseudo_integer + pseudo_integer</code>?</span>
<span class="comment-copy">I updated my answer, take a look.</span>
<span class="comment-copy">Thanks! This helps me a lot.</span>
<span class="comment-copy">Hi, thank you very much, this looks promising. i have one question: is this also possible without manually having to define all these methods, like add , sub, eq, gt etc? So basically that it inherits all these methods from the "original" Integer class and I just add the instance variables and methods that I need to it?</span>
<span class="comment-copy">No, <a href="https://stackoverflow.com/a/3238445/7216865">https://stackoverflow.com/questions/3238350/subclassing-int-in-python</a></span>
<span class="comment-copy">Ok, thanks! This will help me a lot.</span>
<span class="comment-copy">@MauriceMeyer, you're actually pointing to the post that shows <i>how to do this</i>, not why it's impossible ;)</span>
<span class="comment-copy">The OP will still have to override existing methods like <code>__add__</code> if they want the result of <code>PseudoInt(5) + 3</code> to be a <code>PseudoInt</code>.</span>
<span class="comment-copy">True. The same applies to in-place math, like <code>PseudoInt(5) += 4</code> will return 9. But I guess, this is what OP wanted - int-like object. To return same class with math ops, __ methods should be reloaded, you're right.</span>
<span class="comment-copy">I'd hope that <code>PseudoInt(5) += 4</code> would be a <code>SyntaxError</code>! <code>&lt;/nitpick&gt;</code></span>
<span class="comment-copy">Thanks! This helps me a lot.</span>
