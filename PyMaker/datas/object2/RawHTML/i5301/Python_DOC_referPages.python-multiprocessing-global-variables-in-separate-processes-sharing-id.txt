<div class="post-text" itemprop="text">
<p>From <a href="https://stackoverflow.com/questions/11055303/python-multiprocessing-global-variable-updates-not-returned-to-parent?noredirect=1&amp;lq=1">this question</a> I learned that:</p>
<blockquote>
<p>When you use multiprocessing to open a second process, an entirely new
  instance of Python, with its own global state, is created. That global
  state is not shared, so changes made by child processes to global
  variables will be invisible to the parent process.</p>
</blockquote>
<p>To verify this behavior, I made a test script:</p>
<pre><code>import time
import multiprocessing as mp
from multiprocessing import Pool
x = [0]  # global
def worker(c):
    if c == 1:  # wait for proc 2 to finish; is global x overwritten by now?
        time.sleep(2)
    print('enter: x =', x, 'with id', id(x), 'in proc', mp.current_process())
    x[0] = c
    print('exit: x =', x, 'with id', id(x), 'in proc', mp.current_process())
    return x[0]

pool = Pool(processes=2)
x_vals = pool.map(worker, [1, 2])
print('parent: x =', x, 'with id', id(x), 'in proc', mp.current_process())
print('final output', x_vals)
</code></pre>
<p>The output (on CPython) is something like</p>
<pre><code>enter: x = [0] with id 140138406834504 in proc &lt;ForkProcess(ForkPoolWorker-2, started daemon)&gt;
exit: x = [2] with id 140138406834504 in proc &lt;ForkProcess(ForkPoolWorker-2, started daemon)&gt;
enter: x = [0] with id 140138406834504 in proc &lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt;
exit: x = [1] with id 140138406834504 in proc &lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt;
parent: x = [0] with id 140138406834504 in proc &lt;_MainProcess(MainProcess, started)&gt;
final output [1, 2]
</code></pre>
<p>How should I explain the fact that the <code>id</code> of <code>x</code> is shared in all the processes, yet <code>x</code> takes different values? Isn't <a href="https://stackoverflow.com/a/15667328/4115369"><code>id</code> conceptually the memory address of a Python object</a>? 
I guess this is possible if the memory space gets cloned in the child processes. Then is there something I can use to get the actual physical memory address of a Python object?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Shared State</strong></p>
<blockquote>
<p>When you use multiprocessing to open a second process, an entirely new instance of Python, with its own global state, is created. That global state is not shared, so changes made by child processes to global variables will be invisible to the parent process.</p>
</blockquote>
<p>The crucial point here seems to be:</p>
<blockquote>
<p><em>That</em> global state is not shared..." </p>
</blockquote>
<p>...refering to <strong><em>that</em></strong> global state of the child process. But that doesn't mean that part of the global state from the parent can't be shared with the child process as long the child process doesn't attempt to write to <em>this</em> part. When this happens, <em>this</em> part get's copied and changed and will not be visible to the parent.</p>
<p>Background:</p>
<p>On Unix <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">'fork'</a> is the default way for starting the child process:</p>
<blockquote>
<p>The parent process uses os.fork() to fork the Python interpreter. The child process, when it begins, is effectively identical to the parent process. All resources of the parent are inherited by the child process. Note that safely forking a multithreaded process is problematic.</p>
<p>Available on Unix only. The default on Unix.</p>
</blockquote>
<p>Fork is implemented using <a href="https://unix.stackexchange.com/questions/58145/how-does-copy-on-write-in-fork-handle-multiple-fork">copy-on-write</a>, so unless you assign a new object to <code>x</code> no copying takes place and the child process shares the same list with its parent.</p>
<hr/>
<p><strong>Memory address</strong></p>
<blockquote>
<p>How should I explain the fact that the id of x is shared in all the processes, yet x takes different values?</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/5365580/fork-same-memory-addresses">Fork creates a child process in which the virtual address space is identical to the virtual address space of the parent. The virtual addresses will all map to the same physical addresses until copy-on-write occurs.</a></p>
<blockquote>
<p>Modern OSes use virtual addressing. Basically the address values (pointers) you see inside your program are not actual physical memory locations, but pointers to an index table (virtual addresses) that in turn contains pointers to the actual physical memory locations. Because of this indirection, you can have the same virtual address point to different physical addresses IF the virtual addresses belong to index tables of separate processes. <a href="https://kaushikghose.wordpress.com/2016/08/26/python-global-state-multiprocessing-and-other-ways-to-hang-yourself/" rel="nofollow noreferrer">link</a></p>
</blockquote>
<hr/>
<blockquote>
<p>Then is there something I can use to get the actual physical memory address of a Python object?</p>
</blockquote>
<p>There doesn't seem to be a way to get the actual physical memory address (<a href="https://stackoverflow.com/questions/45449764/get-memory-address-in-python-identify-if-it-is-list-or-a-dictionary-and-update">link</a>). <code>id</code> returns the <a href="https://en.wikipedia.org/wiki/Virtual_memory" rel="nofollow noreferrer">virtual</a> (logical) memory address (CPython). The actual translation from virtual to physical memory address falls to the <a href="https://en.wikipedia.org/wiki/Memory_management_unit" rel="nofollow noreferrer">MMU</a>.</p>
</div>
