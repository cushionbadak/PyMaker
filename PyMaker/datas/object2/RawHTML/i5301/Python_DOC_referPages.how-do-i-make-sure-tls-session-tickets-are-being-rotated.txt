<div class="post-text" itemprop="text">
<p>I have established a simple TLS 1.2 session between a client and a server using <a href="https://docs.python.org/3/library/ssl.html#ssl.SSLSession" rel="nofollow noreferrer">Python's SSL module</a> (running LibreSSL 2.2.7 under the hood) and am wondering if session tickets are automatically rotated.</p>
<p>It looks like the server is hinting at the client that the session ticket should only be valid for 300 seconds (<code>Session Ticket Lifetime Hint: 300 seconds</code>)</p>
<p><a href="https://i.stack.imgur.com/fG08O.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/fG08O.png"/></a></p>
<p>But it's been almost an hour and a new session ticket hasn't been issued like I expected. Meanwhile I exchanged some application data between the two parties but that didn't seem to trigger anything.</p>
<p>Per <a href="https://tools.ietf.org/html/rfc4507" rel="nofollow noreferrer">RFC 4507</a> I understand the 300 seconds hint is not strictly required to be followed</p>
<blockquote>
<p>The ticket_lifetime_hint field contains a hint from the server
  about how long the ticket should be stored. The value indicates
  the lifetime in seconds as a 32-bit unsigned integer in network
  byte order. A value of zero is reserved to indicate that the
  lifetime of the ticket is unspecified. A client SHOULD delete the
  ticket and associated state when the time expires. It MAY delete
  the ticket earlier based on local policy. A server MAY treat a
  ticket as valid for a shorter or longer period of time than what is
  stated in the ticket_lifetime_hint.</p>
</blockquote>
<p>But then how do I know if ticket rotation is happening? How do I check how long my client waits before rotating tickets?</p>
</div>
<div class="post-text" itemprop="text">
<p>The session ticket is given by the server during the handshake. And to initiate a handshake you must either start with a new connection with an empty ticket (by playing with the HTTP keep alives for example), or force a rehandshake in an established connection. Unfortunately, keeping a connection opened for a long time and waiting to see anything happen like a ticket update is not likely to happen.</p>
<p>If you want to restart with new connections, either program your client to close and reopen new connections from time to time, or try the HTTP Keep-Alive header on the server side which is supposed to inform the client on how it should behave.
Unluckily we are unsure of this header behaviour because we know this header exists in <a href="https://tools.ietf.org/html/rfc2068#section-19.7.1.1" rel="nofollow noreferrer">RFC 2068</a> , but its use is described in an <a href="https://tools.ietf.org/id/draft-thomson-hybi-http-timeout-01.html#rfc.section.2.1" rel="nofollow noreferrer">RFC draft</a> which is now expired.
An example of use :</p>
<blockquote>
<p>Keep-Alive: timeout=300</p>
</blockquote>
<p>The SSL rehandshake is possible if you have access to a low-level API. Then the server can send an <a href="https://tools.ietf.org/html/rfc5246#section-7.4.1.1" rel="nofollow noreferrer">HelloRequest</a> forcing the client to start a rehandshake and at this moment it is supposed to ask for a new ticket if the previous is considered expired.</p>
<p>In both cases, you should confirm with a network capture that it is behaving as expected. There is probably no way to see anything if you're not coding with a low level language (Java for example allows to code rehandshakes, but I'm not sure coding an entire server is worth).</p>
</div>
<span class="comment-copy">Thank you very much for your help!  If I understand correctly, although the server is recommending a 300 seconds lifetime, the client is not rotating the session key because the implementation (Python's SSL module) is not programmed to do anything about it?  So the session ticket is just the state of the client-server session which I can hook into and perhaps manually renegotiate a master secret? Fundamentally, all I want to do is periodically rotate encryption and authentication keys (which are derived from the master secret, so my goal is to rotate the master secret)</span>
<span class="comment-copy">I don't know the Python implementation internals, but from your capture we see it's not rehandshaking by itself (I mean a rehandshaking in an established connection). It's interesting that both client and server can decide a rehandshake ; if you know that your client is keeping the connection alive for a long time but not sending data so often (over the hint time for example), maybe you can rehandshake before every request by calling <a href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.do_handshake" rel="nofollow noreferrer">docs.python.org/3/library/ssl.html#ssl.SSLSocket.do_handshake</a> . Anyway, it's a marginal benefit if you're already using good cipher suites.</span>
<span class="comment-copy"><code>do_handshake()</code> seems to do nothing on the open socket, I see nothing happen in Wireshark. However closing the socket and establishing the session again works and has the same effect.</span>
<span class="comment-copy">ok, so python's implementation is weak for this. We're learning interesting things :)</span>
