<div class="post-text" itemprop="text">
<p>How do I register class methods with a decorator and use inheritance at the same time.  I've found a lot of semi-helpful posts/tutorials online, however, I haven't been able to find exactly what I'm looking for. In the process, I think I've confused myself (class decorators vs metaclasses).  Here's the expected operation of what I am hoping to build. (FYI using Python 3.6)</p>
<pre><code>class Parent:
    @property
    def tagged(self):
        return # TODO: return list of "tagged" methods
    @property
    def parent1(self):
        return 'parent1'
    @tag
    @property
    def parent2(self):
        return 'parent2'

class Child1(Parent):
    @tag
    @property
    def child1_1(self):
        return 'child1_1'
    @tag
    @property
    def child1_2(self):
        return 'child1_2'

class Child2(Parent):
    @property
    def child2_1(self):
        return 'child2_1'
    @tag
    @property
    def child2_2(self):
        return 'child2_2'

c1 = Child1()
c2 = Child2()

print(c1.tagged)
# expect: ['parent2', 'child1_1', 'child1_2']

print(c2.tagged)
# expect: ['parent2', 'child2_2']
</code></pre>
<p>EDIT:
Here is what I have actually tried (originally omitted to try and keep the post size down)</p>
<p>In this attempt, I tried to use a class decorator.  I was hoping to use the <code>tag</code> function as a decorator for the class methods to add a attribute to the method.  My understanding is that everything in Python is an object (even functions) so adding an arbitrary attribute should be do-able.  My thought was to then use the class decorator (<code>tagger</code>) to add a <code>_tagged</code> attribute of the class that would then contain a list of method names that were "tagged". This obviously does not work as I intended. The added attribute to class methods is not "seen" by the class decorator.  </p>
<pre><code>def tagger(cls):
    cls._tagged = []
    for methodname in dir(cls):
        method = getattr(cls, methodname)
        if hasattr(method, 'tagged'):
            cls._tagged.append(methodname)
    return cls

def tag(f):
    def decorator():
        f.tagged = True
        return f
    return decorator


@tagger
class Parent:
    @property
    def tagged(self):
        return self._tagged

    def parent1(self):
        return 'parent1'

    @tag
    @property
    def parent2(self):
        return 'parent2'


@tagger
class Child1(Parent):
    @tag
    @property
    def child1_1(self):
        return 'child1_1'

    @tag
    @property
    def child1_2(self):
        return 'child1_2'

@tagger
class Child2(Parent):
    @property
    def child2_1(self):
        return 'child2_1'

    @tag
    @property
    def child2_2(self):
        return 'child2_2'


c1 = Child1()
c2 = Child2()

print(c1.tagged)
# expect: ['parent2', 'child1_1', 'child1_2']
# got: []

print(c2.tagged)
# expect: ['parent2', 'child2_2']
# got: []
</code></pre>
<p>In this attempt I tried to use a MetaClass.  Similar to the last approach, the idea was to add an attribute to the class method and then use that as a key for building the list of "tagged" methods.  This didn't work either as I ran into what I think is the same fundamental issue as before where the attribute added to the function is not maintained. To start with, I was trying to shy away from this method because it required a global variable (<code>tagged</code>).  I'm hoping to find a cleaner solution. </p>
<pre><code>from collections import defaultdict

tagged = defaultdict(dict)


class TaggableType(type):
    def __init__(cls, name, bases, attrs):
        for name, method in attrs.items():
            if hasattr(method, 'tagged'):
                tagged[cls.__name__][name] = method


def tag(f):
    def decorator():
        f.tagged = True
        return f

    return decorator


class Parent(metaclass=TaggableType):

    @property
    def tagged(self):
        return tagged[self.__class__.__name__]

    def parent1(self):
        return 'parent1'

    @tag
    @property
    def parent2(self):
        return 'parent2'


class Child1(Parent, metaclass=TaggableType):

    @tag
    @property
    def child1_1(self):
        return 'child1_1'

    @tag
    @property
    def child1_2(self):
        return 'child1_2'


class Child2(Parent, metaclass=TaggableType):

    @property
    def child2_1(self):
        return 'child2_1'

    @tag
    @property
    def child2_2(self):
        return 'child2_2'


c1 = Child1()
c2 = Child2()

print(c1.tagged)
# expect: ['parent2', 'child1_1', 'child1_2']
# got: {}

print(c2.tagged)
# expect: ['parent2', 'child2_2']
# got: {}
</code></pre>
<p>I dislike both the metaclass and class decorator approaches (provided that they even work) because they require some operator by the child class (either the decorator or explicitly adding the metaclass value).  I would ideally like to have a clean and simple solution wherein the child object does not need to have any special configuration outside of inheriting the parent class. </p>
</div>
<div class="post-text" itemprop="text">
<p>As I mentioned in the comments, you are basically on the right track. You have a decorator <code>tag</code> that marks your attributes for addition to the list. Either a metaclass or a class decorator is a perfectly valid tool to compile the list and add it to your class as an attribute.</p>
<p>There are two main problems with your implementation.</p>
<ol>
<li><p>You seem to have a misunderstanding of how function decorators work (which is strange given that you seem to understand class decorators perfectly, but totally understandable because I too have read the same misleading tutorials). As with class decorators, function decorators can return anything at all, not necessarily the nested function that is so often given in examples. For example, <code>@property</code> returns a data descriptor that is not even callable!</p>
<p>Remember that the result of the decorator replaces whatever the input was. So in your current implementation, you start with some function that returns a property value. You then replace it with a function of no arguments that sets an attribute on the original function object. But the original function object is basically discarded and can't be called. That makes no sense. What you probably want is a function that sets an attribute on the original function and just returns that original function, so it does <em>not</em> get replaced:</p>
<pre><code>def tag(f):
    f.tagged = True
    return f
</code></pre></li>
<li><p>You can't decorate a property in the way you are thinking. The <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer"><code>@property</code></a> decorator does not return a function. It returns an immutable object, and you can not set an attribute on it (except changing the docstring as of Py3.6). The reason that your code did not fail with an <code>AttributeError: 'property' object has no attribute 'tagged'</code> is that your <code>tag</code> decorator does not do what you think it does.</p>
<p>A possible solution for this to apply <code>@tag</code> before applying <code>@property</code> (given the version of <code>tag</code> shown above). Now, instead of checking if each "method" is <code>tagged</code>, you have to also check if the "method" is really a property object, and check if it's <code>fset</code> attribute is <code>tagged</code>. Alternatively, you can check if the input to <code>tag</code> is a <code>property</code>, and tag the <code>fset</code> attribute instead of the property itself. This will make your decorators order-independent again.</p></li>
</ol>
<p>Fixing these two problems will give you the tagged items in each child class. It will not, however, give you the complete list including the parent classes. Luckily, the parents of your class object are fully known for both a class decorator and a metaclass, so you can create a complete list based on simple inheritance.</p>
<p>Before showing code, I also want to mention something about metaclasses vs. decorators for your code. Functionally, there will not be much difference between the two in the sense that they both look up attributes with <code>tagged</code> set and fill in a list on the class. There is going to be a usage difference though. You will only have to set the metaclass once for the parent to get the same behavior for all the children because the type of the parent is generally the type of the subclass (you do not need to have <code>metaclass=TaggableType</code> in all your child classes). A decorator would have to be applied to every child individually. I can see pros and cons for both approaches, so I will show both.</p>
<p><strong>Using Class Decorators</strong></p>
<pre><code>def tagger(cls):
    cls._tagged = set()
    for methodname in dir(cls):
        method = getattr(cls, methodname)
        if isinstance(method, property):
            method = method.fget
        if hasattr(method, 'tagged'):
            cls._tagged.add(methodname)
    return cls

def tag(f):
    if isinstance(f, property):
        f.fget.tagged = True
    else:
        f.tagged = True
    return f

@tagger
class Parent:
    @property
    def tagged(self):
        tags = set()
        # Support multiple inheritance out of the box
        for t in type(self).__mro__:
            if hasattr(t, '_tagged'):
                tags.update(t._tagged)
        return tags

    @property
    def parent1(self):
        return 'parent1'

    @tag
    @property
    def parent2(self):
        return 'parent2'


@tagger
class Child1(Parent):
    @tag
    @property
    def child1_1(self):
        return 'child1_1'

    @tag
    @property
    def child1_2(self):
        return 'child1_2'

@tagger
class Child2(Parent):
    @property
    def child2_1(self):
        return 'child2_1'

    @tag
    @property
    def child2_2(self):
        return 'child2_2'

c1 = Child1()
c2 = Child2()

print(c1.tagged)
print(c2.tagged)
</code></pre>
<p>Results in</p>
<pre><code>{'child1_2', 'parent2', 'child1_1'}
{'parent2', 'child2_2'}
</code></pre>
<p>There is a slight conceptual disconnect here, because the decorator needs to be applied to every child to gather the data, but only the parent needs to have a <code>tagged</code> property for it to work on all children.</p>
<p><strong>Using a Metaclass</strong></p>
<pre><code>class TaggableType(type):
    def __init__(cls, name, bases, attrs):
        cls._tagged = set()
        for name, method in attrs.items():
            if isinstance(method, property):
                method = method.fget
            if hasattr(method, 'tagged'):
                cls._tagged.add(name)

def tag(f):
    if isinstance(f, property):
        f.fget.tagged = True
    else:
        f.tagged = True
    return f

class Parent(metaclass=TaggableType):
    @property
    def tagged(self):
        tags = set()
        for t in type(self).__mro__:
            if hasattr(t, '_tagged'):
                tags.extend(t._tagged)
        return tags

    def parent1(self):
        return 'parent1'

    @tag
    @property
    def parent2(self):
        return 'parent2'


class Child1(Parent):
    @tag
    @property
    def child1_1(self):
        return 'child1_1'

    @tag
    @property
    def child1_2(self):
        return 'child1_2'

class Child2(Parent):
    @property
    def child2_1(self):
        return 'child2_1'

    @tag
    @property
    def child2_2(self):
        return 'child2_2'

c1 = Child1()
c2 = Child2()

print(c1.tagged)
print(c2.tagged)
</code></pre>
<p>Results in:</p>
<pre><code>['child1_1', 'child1_2', 'parent2']
['child2_2', 'parent2']
</code></pre>
<p>Another thing to keep in mind is that in the metaclass option, you have the MRO option available up front. You can therefore construct a complete list of tags right there and then. I do not like redundant information because it usually ends up being a maintenance burden. A better alternative would be to define the property in the metaclass, and assign it to each child you create as a bonus.</p>
<p><strong>Update</strong></p>
<p>In fact, my last suggestion makes the metaclass option objectively better because it allows you to circumvent explicitly using MRO, instead delegating the resolution to <code>super</code>, as you should:</p>
<pre><code>class TaggableType(type):
    def __init__(cls, name, bases, attrs):
        tagged = set()
        for name, method in attrs.items():
            if isinstance(method, property):
                method = method.fget
            if hasattr(method, 'tagged'):
                tagged.add(name)

        @property
        def tagged(self):
            tags = tagged.copy()
            try:
                tags.update(super(cls, self).tagged)
            except AttributeError:
                pass
            return tags

        cls.tagged = tagged
</code></pre>
<p>Now none of the classes need to explicitly define a <code>tagged</code> property at all.</p>
</div>
<div class="post-text" itemprop="text">
<p>The main issue with your two attempted implementations is that your <code>tag</code> decorator isn't working the way you intend. For a simple decorator that doesn't need to be passed any arguments (like <code>@foo(x)</code>) and returns the original function, you don't need a nested function at all:</p>
<pre><code>def tag(f):
    f.tagged = True
    return f
</code></pre>
<p>You still have a problem though, since not all objects allow you to set arbitrary attributes on them. Functions do, but instances of <code>property</code> do not.</p>
<p>One way to work around that for that would be to change the order of the decorators on your property methods, so that <code>tag</code> gets applied first (on the function, where it will work), and the <code>property</code> decorator applies afterwards. Then you'd just need to check each <code>property</code> in the class to see if it's <code>getter</code> is tagged later on.</p>
<pre><code>class Child1(Parent):
    @property      # swap decorator order!
    @tag           # this gets applied first, then property applies to the result
    def child1_1(self):
        return 'child1_1'

    @property      # same here (and in the other classes)
    @tag
    def child1_2(self):
        return 'child1_2'
</code></pre>
<p>Now to address the question of how best to gather up the list of tagged methods. Either of the approaches you tried can be made to work with just a little tweaking (such as looking inside of <code>property</code> instances to see the tag on the getter). But another option would be to make the <code>tagged</code> method in the <code>Parent</code> class do all the work. This might be slow the first time you checked for tags, but you could cache the result for later calls:</p>
<pre><code>class Parent:
    @property
    @classmethod
    def tagged(cls):
        if '_tagged' not in cls.__dict__: # check in dict directly to avoid inherited _tagged
            tagged = []
            for name in dir(cls):
                var = cls.getattr(name)
                if (hasattr(var, 'tagged') or
                        isinstance(var, property) and hasattr(var.getter, 'tagged')):
                    tagged.append(name)
            cls._tagged = tagged
        return cls._tagged

    ...
</code></pre>
<p>If you want to go with metaclasses, you don't need to worry about every class needing the <code>metaclass=...</code> declaration. Metaclasses are inherited, you only need to explicitly declare the metaclass in <code>Parent</code>. All classes that inherit from <code>Parent</code> will use it's metaclass too. The only downside to this is that they can't declare some other metaclass of their own, as you'll get a metaclass conflict (though you might be able to work around it by making the other metaclass inherit from <code>TaggableType</code> or even creating a new metaclass that inherits from both <code>TaggableType</code> and the other desired metaclass).</p>
</div>
<span class="comment-copy">So what have you actually tried? This code is just showing what you want.</span>
<span class="comment-copy">@MadPhysicist- updated. I should have included my original efforts earlier, but I was trying to keep the post size down.</span>
<span class="comment-copy">Post size should never be a concern when weighed against completeness. Your question went from totally inappropriate to actually pretty good because of that edit. Please don't hold back next time.</span>
<span class="comment-copy">Please do fix your indentation though and add a little prose to explain what you are doing in each case.</span>
<span class="comment-copy">I'll write you an answer in about 30 mins. Downvote flipped and close vote removed :)</span>
<span class="comment-copy">This is wildly helpful.  Thank you so much!  I proposed some updates, so you should check them out.  I was unable to simply copy/paste the code have have it work, but the updates should help anyone else that comes along be able to get going quicker.   I defiantly like the metaclass example better.  Somehow along the line in my research, I got the assumption that metaclasses were not inherited. Thanks for the detailed explanation and correcting my misunderstandings! Everything you outlined made sense, and I'll have to read-up on MRO (my first exposure).</span>
<span class="comment-copy">@user5038859. It is generally very bad form to make such drastic code changes to someone else's post, but I really like your suggestions so I will accept them.</span>
<span class="comment-copy">I hope you don't have to use mro ever again. This is my second actual use case for it ever. The first was even more obscure.</span>
<span class="comment-copy">Apologies.  I don't post here much, so the norms of what is and is not "bad form" slips past me. Thanks again, your suggestion is super helpful!</span>
<span class="comment-copy">@user5038859. Your edit to the <code>tag</code> decorator introduced a pretty major bug. Figuring out what it is will test your understanding of decorators. Can you tell me what the difference between your original edit and my cleanup is?</span>
