<div class="post-text" itemprop="text">
<p>Let's say I have a row vector composed of 5 integers, where the first integer is int1 and the second is int2</p>
<pre><code>int1   int2   int3   int4   int5
</code></pre>
<p>and i want to create a list of all possible combinations assuming each one of the integers can be between 1 and 99.</p>
<p>One possibility would be to write 5 nested loops:</p>
<pre><code>my list = []

for i in range(1,99):
    for j in range(1,99):
        for k in range(1,99):
            for l in range(1,99):
                for m in range(1,99):
                    my_list.append([[m,l,k,j,i]])
</code></pre>
<p>This would be pretty inefficient, and we would need 9,509,900,499 iterations.</p>
<p><strong>is there a more efficient way of adding all possible combinations to a list (i.e. an alternative to 5 nested loops)?</strong></p>
<p>i will write the code in python but the response needs not be python specific.</p>
</div>
<div class="post-text" itemprop="text">
<p>Taking this important comment into account, there is a simple solution:</p>
<blockquote>
<p>yep, i do not need to hold the list in memory, actually I can do
  something with each combination and move on â€“ <em>Alejandro Simkievich</em></p>
</blockquote>
<p>All you have to do is:</p>
<pre><code>import itertools
my_list = itertools.product(xrange(1,99+1), repeat=5)
</code></pre>
<p>This executes in a fraction of a second and takes almost no memory. It does not actually create a list of 99^5 integers. Actually, it does not even create list of 99 integers. It fakes all of it.</p>
<p>Even though there is no list in the memory, <code>my_list</code> can be iterated through as if it was such a list:</p>
<pre><code>for int1, int2, int3, int4, int5 in my_list:
    # do_whatever, but this will be executed 9509900499 times, of course
    # try e.g.
    print int1, int2, int3, int4, int5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I just realized there may be a way to expedite this running things in parallel.</p>
<p>Let's say you have a machine with 99 cores, you could run four nested loops on 99 cores in parallel. in each one of the 99 cores, the first integer is a constant. you would have an efficiency gain of 100x (a bit less in practice I guess).</p>
<p>I actually have access to a machine with 128 cores, so this may be an option.</p>
</div>
<span class="comment-copy">If there are 9,509,900,499 combinations, there is no way around the fact that you need to add 9,509,900,499 items to the list.</span>
<span class="comment-copy">Nesting a loop doesn't make it slower.  Nested loops are considered "slow" because the total number of iterations gets large quickly. But you have a specific number of iterations that need to execute. You could write out 9,509,900,499 separate <code>append</code> statements and it would not be measurably faster (ignoring problems caused by loading such a large program!).</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/13885234/python-nested-looping-idiom">Python nested looping Idiom</a></span>
<span class="comment-copy">Although note that there are simpler ways to write the program: see <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html</a></span>
<span class="comment-copy">99% of the time, questions like this are an XY problem. I suggest you try to convince us that you're in the remaining 1%.</span>
<span class="comment-copy">This is nicer code than OP's; but I note that it's functionally identical to his 5 nested loops, as long as the inner code is processing the set of ints without storing them.</span>
<span class="comment-copy">@Blorgbeard Unlike the OP's code, this (first code in my answer) does not spend hours to fill 70 GB of data into a list. Other than that, it is no better, but there is no way to optimize the core functionality which OP is hiding from us... The second code is a loop which shows that this can be used just like the list. I've updated my answer to explain that better (hopefully)</span>
<span class="comment-copy">I know - my point was that the main improvement in your answer can be applied to the 5 nested loops - <code>print</code> instead of <code>append</code>. itertools or 5 nested loops doesn't matter, "as long as the inner code is processing the set of ints without storing them".</span>
<span class="comment-copy">Sure; the same way you could use a machine with 11 cores to calculate groups of 9 starting digits in parallel for eg. I don't think that's particularly insightful though? In any case it still sounds like a duplicate of <a href="https://stackoverflow.com/questions/10262138/how-do-i-multi-process-the-itertools-product-module">this</a></span>
<span class="comment-copy">I do not know if it is insightful, but it helps me solve the problem. none of the folks who bashed my question thought of it anyway. it could be a duplicate, I give you that.</span>
<span class="comment-copy">@AlejandroSimkievich Running on 99 cores, you could create 99 partial lists, yes. In the end, you would have to merge them, if you want to have one large list. Note also that (assuming any overhead), 99^5 integers require 70 GB of RAM on a 64 bit machine. Note also that there is absolutely no information stored in those 70 GB of memory. List of all combinations is not information. So, what is the purpose?</span>
<span class="comment-copy">@zvone Good luck trying to get the actual purpose out of him. I tried but got the impression that he really doesn't want to tell. For some reason it apparently needs to remain secret.</span>
