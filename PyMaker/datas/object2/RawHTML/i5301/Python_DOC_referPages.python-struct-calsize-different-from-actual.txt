<div class="post-text" itemprop="text">
<p>I am trying to read one short and long from a binary file using python <code>struct</code>. </p>
<p>But the </p>
<pre><code>print(struct.calcsize("hl")) # o/p 16
</code></pre>
<p>which is wrong, It should have been 2 bytes for short and 8 bytes for long. I am not sure i am using the <code>struct</code> module the wrong way. </p>
<p>When i print the value for each it is </p>
<pre><code>print(struct.calcsize("h")) # o/p 2
print(struct.calcsize("l")) # o/p 8
</code></pre>
<p>Is there a way to force python to maintain the precision on <code>datatypes</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>By default struct alignment rules, 16 is the correct answer. Each field is aligned to match its size, so you end up with a <code>short</code> for two bytes, then six bytes of padding (to reach the next address aligned to a multiple of eight bytes), then eight bytes for the <code>long</code>.</p>
<p>You can use a <a href="https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment" rel="nofollow noreferrer">byte order prefix</a> (any of them disable padding), but they <em>also</em> disable machine native sizes (so <code>struct.calcsize("=l")</code> will be a fixed 4 bytes on all systems, and <code>struct.calcsize("=hl")</code> will be 6 bytes on all systems, not 10, even on systems with 8 byte <code>long</code>s).</p>
<p>If you want to compute struct sizes for arbitrary structures using machine native types with non-default padding rules, you'll need to go to the <code>ctypes</code> module, define your <a href="https://docs.python.org/3/library/ctypes.html#ctypes.Structure" rel="nofollow noreferrer"><code>ctypes.Structure</code></a> subclass with the desired <code>_pack_</code> setting, then use <a href="https://docs.python.org/3/library/ctypes.html#ctypes.sizeof" rel="nofollow noreferrer"><code>ctypes.sizeof</code></a> to check the size, e.g.:</p>
<pre><code>from ctypes import Structure, c_long, c_short, sizeof

class HL(Structure):
    _pack_ = 1  # Disables padding for field alignment
    # Defines (unnamed) fields, a short followed by long
    _fields_ = [("", c_short),
               ("", c_long)]

print(sizeof(HL))
</code></pre>
<p>which outputs <code>10</code> as desired.</p>
<p>This could be factored out as a utility function if needed (this is a simplified example that doesn't handle all <code>struct</code> format codes, but you can expand if needed):</p>
<pre><code>from ctypes import *

FMT_TO_TYPE = dict(zip("cb?hHiIlLqQnNfd",
                       (c_char, c_byte, c_bool, c_short, c_ushort, c_int, c_uint,
                        c_long, c_ulong, c_longlong, c_ulonglong, 
                        c_ssize_t, c_size_t, c_float, c_double)))

def calcsize(fmt, pack=None):
    '''Compute size of a format string with arbitrary padding (defaults to native)'''
    class _(Structure):
        if packis not None:
            _pack_ = pack
        _fields_ = [("", FMT_TO_TYPE[c]) for c in fmt]
    return sizeof(_)
</code></pre>
<p>which, once defined, lets you compute sizes padded or unpadded like so:</p>
<pre><code>&gt;&gt;&gt; calcsize("hl")     # Defaults to native "natural" alignment padding
16
&gt;&gt;&gt; calcsize("hl", 1)  # pack=1 means no alignment padding between members
10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is what the <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">doc</a> says:</p>
<blockquote>
<p>By default, the result of packing a given C struct includes pad bytes in order to maintain proper alignment for the C types involved; similarly, alignment is taken into account when unpacking. This behavior is chosen so that the bytes of a packed struct correspond exactly to the layout in memory of the corresponding C struct. To handle platform-independent data formats or omit implicit pad bytes, use <code>standard</code> size and alignment instead of <code>native</code> size and alignment</p>
</blockquote>
<p>Changing it from standard to native is pretty easy: you just append the prefix <code>=</code> before the format characters. </p>
<pre><code>print(struct.calcsize("=hl"))
</code></pre>
<hr/>
<p>EDIT</p>
<p>Since from the native to standard mode, some default sizes are changed, you have two options:</p>
<ul>
<li><p>keeping the native mode, but switching the format characters, in this way: <code>struct.calcsize("lh")</code>. In C even the order of your variable inside the struct is important. Here the padding is 8 bytes, it means that every variable has to be referenced at multiple of 8 bytes.</p></li>
<li><p>Using the format characters of the standard mode, so: <code>struct.calcsize("=hq")</code></p></li>
</ul>
</div>
<span class="comment-copy">I am not sure why, the output for me is 0. <a href="https://repl.it/repls/TenseWhirlwindIbadanmalimbe" rel="nofollow noreferrer">repl.it/repls/TenseWhirlwindIbadanmalimbe</a></span>
<span class="comment-copy">@IvinPoloSony: It was a typo in my original post (now fixed). I'm testing on one machine, hand-jamming it over to this machine (which lacks Python). Meant to type <code>_fields_</code>, typoed it as <code>_field_</code> (which is not a special attribute, so the structure ended up with no fields at all). <a href="https://tio.run/##TY@9isMwEIR7PcWQNBK4CekOrkuRIt2VIRhFP7Y4eSUkmeC8vE@2D5NttphvdmbjVPpA53m2KQxQZYomww0xpIKfkkZVxmQaqNYH6pad@yo1yO5tgmVMeZkzrje@w@KLoU4bpfpt8Y0TcMTFZfn09XSUWjvqYEOCdcZrSO86GgyV1VZRYx1Vko9EcjBabFxuILGGV6/34WU0nhOWWlveRi2Jd3447FVFs8qf8y8vVvFgLCZHhW8P8etNiHn@Aw" rel="nofollow noreferrer">It's now fixed</a>.</span>
<span class="comment-copy">As I noted in my answer, the problem here is that any of those prefixes not only disable padding, but switch from native size/alignment to "standard" size/alignment. So <code>struct.calcsize("hl")</code> on a system with 64 bit <code>long</code>s reports 16 (2 bytes for <code>short</code>, 6 pad bytes, 8 bytes for <code>long</code>), but moving to <code>struct.calcsize("=hl")</code> doesn't get you 10, it gets you 6, because it not only removed the pad bytes, it also "standardized" the size of a <code>long</code> to 4.</span>
<span class="comment-copy">@ShadowRanger you're right. I made some tests and I noticed it too. In that case he can use the <code>q</code> prefix</span>
