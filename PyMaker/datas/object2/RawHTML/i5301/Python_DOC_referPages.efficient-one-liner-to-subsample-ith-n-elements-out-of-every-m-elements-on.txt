<div class="post-text" itemprop="text">
<p>I am looking for a memory/cpu efficient one-liner to subsample n out of every m elements on a list. So far I have got:</p>
<pre><code>sb = [11,12,21,22,31,32]*4 #stream buffer, e.g. 4 identical frames
ci = 1 #1-indexed channel index
cs = 2 #channel (sample) size
nc = 3 #number of channels in each frame
fs = nc*cs #frame size

[i for l in [sb[j+ci-1:j+ci-1+cs] for j
    in [x*fs+ci-1 for x in xrange(len(sb)/fs)]] for i in l]

Out: [11, 12, 11, 12, 11, 12, 11, 12]
</code></pre>
<p>Breaking it down I am creating a list of sample lists and then flattening it to a one dimensional list with <code>[i for l in ll for i in l]</code></p>
<p>Alternatively, not a one liner, but easier to read, I can do:</p>
<pre><code>os = []
for i in [sb[j+ci-1:j+ci-1+cs] for j in [x*fs+ci-1 for x in xrange(len(sb)/fs)]]: os = os+i
</code></pre>
<p>Both solutions look way too convoluted when compared, for example, with the super simple shorthand for <code>cs=1</code> particular case: <code>sb[ci-1::fs]</code>.</p>
<p>Can you help me come up with a decent solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>I moved most of the indexing into a <code>range()</code> computation. Its faster then manifesting the indexes into a sublist - see timing down below:</p>
<pre><code>sb = [11,12,21,22,31,32]*4 #stream buffer, e.g. 4 identical frames
ci = 1 #1-indexed channel index
cs = 2 #channel size
nc = 3 #number of channels in each frame
fs = nc*cs #frame size

for ci in range(1,4):
    print [x for y in [sb[x:x+cs] for x in range((ci-1)*cs,len(sb),fs)] for x in y] 
</code></pre>
<p>Output:</p>
<pre><code>[11, 12, 11, 12, 11, 12, 11, 12]
[21, 22, 21, 22, 21, 22, 21, 22]
[31, 32, 31, 32, 31, 32, 31, 32]
</code></pre>
<p>I moved most of the work into the <code>range()</code> call - producing list of sublists, the rest is a simple decomposition of the sublists into one list.</p>
<pre><code>range((ci-1)*cs,len(sb), fs)
         |         |     |________  frame size, range will use steps the size of the frame
         |         |______________  till end of data
         |________________________  starting at (ci-1) * channel size   

for ci = 1 it starts at 0,   6,12,18,....
for ci = 2 it starts at 2,   8,14,....
for ci = 3 it starts at 4,  10,...  
for ci = 4 it starts at 6,  ...  
    and increases by fs = 6 until end of data. The list comp then gets a sublist of len cs
    and the rest of the list-comp flattens it down from list of list to a simpler list
</code></pre>
<hr/>
<p>Timing:</p>
<pre><code>import timeit

print timeit.timeit(stmt='''
sb = [11,12,21,22,31,32]*4*5 #stream buffer, e.g. 4 identical frames
ci = 1 #1-indexed channel index
cs = 2 #channel size
nc = 3 #number of channels in each frame
fs = nc*cs #frame size
for ci in range(1,4):
    [x for y in [sb[x:x+cs] for x in range((ci-1)*cs,len(sb),fs)] for x in y] 

''', setup='pass', number=10000)  #  0.588474035263

print timeit.timeit(stmt='''
sb = [11,12,21,22,31,32]*4*5 #stream buffer, e.g. 4 identical frames
ci = 1 #1-indexed channel index
cs = 2 #channel size
nc = 3 #number of channels in each frame
fs = nc*cs #frame size
for ci in range(1,4):
    [i for l in [sb[j+ci-1:j+ci-1+cs] for j in [x*fs+ci-1 for x in xrange(len(sb)/fs)]] for i in l] 

''', setup='pass', number=10000)   # 0.734045982361
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following seems fairly readable to me (and is also fairly efficient):</p>
<pre><code>from itertools import chain

sb = [11, 12, 21, 22, 31, 32]*4  # stream buffer, e.g. 4 identical frames

ci = 1      # 1-indexed channel index
cs = 2      # channel size
nc = 3      # number of channels in each frame
fs = nc*cs  # frame size

result = list(chain.from_iterable(sb[i: i+cs] for i in xrange(ci-1, len(sb), fs)))
print(result)  # -&gt; [11, 12, 11, 12, 11, 12, 11, 12]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I advise to <em>use more clear variable names</em> instead of comments and <em>not to use one-liners</em>.</p>
<p><strong>Given</strong></p>
<pre><code>import itertools as it 


stream = [11, 12, 21, 22, 31, 32] * 4
ch_idx = 1
ch_size = 2 
num_chs = 3
</code></pre>
<p><strong>Code</strong></p>
<p>Using the <code>grouper</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipe</a>:</p>
<pre><code>channels = grouper(ch_size, stream)
frames = grouper(num_chs, channels)
list(it.chain.from_iterable(*it.islice(zip(*frames), ch_idx)))
# [11, 12, 11, 12, 11, 12, 11, 12]
</code></pre>
<p>As a one-liner, it looks as follows:</p>
<pre><code>list(it.chain.from_iterable(*it.islice(zip(*grouper(num_chs, grouper(ch_size, stream))), ch_idx)))
# [11, 12, 11, 12, 11, 12, 11, 12]
</code></pre>
<hr/>
<p><strong>Details</strong></p>
<p>The <code>grouper</code> recipe is implemented as follows:</p>
<pre><code>def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
<p>See also the <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> third-party library for pre-implemented recipes.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Code</strong>:</p>
<pre><code>sb = [11,12,21,22,31,32] * 4
ci = 0
cs = 2
nc = 3
fs = cs * nc
result = list(sum(zip(*[sb[i::fs] for i in range(ci, ci+cs)]),()))
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>[11, 12, 11, 12, 11, 12, 11, 12]
</code></pre>
<p>I recommend setting <code>ci</code> to 0 based index to match python's syntax, but if you insist, it's simple to update the func, just replace all the <code>ci</code> with <code>ci-1</code>.</p>
<p>It's essentially the same idea as your original approach, just a bit cleaner, and it can scale to different <code>ci</code>, <code>cs</code> and <code>nc</code>.</p>
</div>
<span class="comment-copy">do you need random sampling? <code>random.sample([11,12,21,22,31,32]*4,8) </code> would draw 8 random samples from the list, without repeating any index on sampling - your solution looks more like a linear every n.th sublis sampling</span>
<span class="comment-copy">@Patrick Artner: No. I need to extract a channel out of a stream (channel demultiplexing). The stream is flattened on a list of elements. Every channel takes cs contiguous elements per sample. Every frame on the stream contains nc consecutive samples, one per channel. I want to extract every sample from a particular channel from the stream onto a new list, keeping the order, of course.</span>
<span class="comment-copy">Are you trying to get the first <i>n</i> number of the identical frames from the stream buffer, which in this case is 2 elements in each of the 4 identical frame?</span>
<span class="comment-copy">@Idlehands: more or less. Yes in this case 2 elements in each of the 4 identical frames, from the selected channel. (Sorry about the first comment it was me misunderstanding what you wrote).</span>
<span class="comment-copy">I like it better your way as it is a little bit more readable, but it is essentially the same solution, right? It is still too complex and it does not improve performance. Isn't there a simpler way?</span>
<span class="comment-copy">@NotGaeL Essentially I get rid of one manifested list by doing the indexing-math in the range() object which is highly optimized generator, so if "should" perfom somethwat better. You would need to measuere it against your data to make sure.</span>
<span class="comment-copy">@NotGaeL upped it to *20 and performed it 10000 times, my version is almost 20% faster</span>
<span class="comment-copy">wow, that's way more than I would imagine. It still pains me that it is so difficult to read, but definitely a great improvement Thanks for the help!</span>
<span class="comment-copy">if you remove the costly data setup from the execution, the timed portions change to 0.281064033508 vs 0.385651111603 - about 72.88% of your solution</span>
<span class="comment-copy">I was also looking into itertools, it is clearer if you are familiar with it so it is a good option. Still I would expect an even simpler solution from a library that's supposed to help you iterate and just that. Is this such an uncommon problem I am trying to solve?</span>
<span class="comment-copy">@NotGaeL can you describe the simplicity you're looking for?</span>
<span class="comment-copy">NotGaeL: You may not realize it, but the argument being passed to <code>chain.from_iterable()</code> is what is known as a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a>, which means it, too, is being executed in an iterative fashion. That's part of what I meant when I said the code was fairly efficient. The main point being that Python does some things iteratively without you needing to use <code>itertools</code> to make it happen. Sounds like you expect some existing library function to do all the specialized stuff you want done.</span>
<span class="comment-copy">@pylang: <code>sb[ci-1::fs]</code></span>
<span class="comment-copy">@martineau: I am expecting an itertools specialized library to provide the iteration tools to simplify some specialized iterative stuff (iterate and select the <code>k</code>th <code>n</code> elements out of every <code>m</code> elements). It is such a simple task even natural language does the work in one sentence. I don't want to bring down the discussion to sarcasm, I mean it's just what it's expected from a whole library dedicated to facilitate the iteration over elements.</span>
<span class="comment-copy">Please explain the downvote.  Much appreciated.</span>
<span class="comment-copy">This does not produce that output and also it is not a single list but a list of lists.</span>
<span class="comment-copy">Okay, let me take a look.  I'm still trying to decypher what <code>ci</code> is supposed to be.  That's why my comment asks if you're only looking for <i>n</i> elements from a given frame size.</span>
<span class="comment-copy">ci is the 1-indexed channel index</span>
<span class="comment-copy">if <code>ci==1 and cs==2</code> then you take the first and second element on each frame of <code>nc*cs</code> elements from the list. If <code>ci==2 and cs==2</code> then you would be taking the 3rd and 4th element from each frame and so on...</span>
<span class="comment-copy">use <code>list(it.chain(*results))</code></span>
