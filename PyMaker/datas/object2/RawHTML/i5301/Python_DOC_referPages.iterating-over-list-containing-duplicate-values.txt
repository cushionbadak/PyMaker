<div class="post-text" itemprop="text">
<p>I am looking to iterate over a list with duplicate values. The 101 has 101.A and 101.B which is right but the 102 starts from 102.C instead of 102.A</p>
<pre><code>import string
room_numbers = ['101','103','101','102','104','105','106','107','102','108']
door_numbers = []
num_count = 0
for el in room_numbers:
    if room_numbers.count(el) == 1:
        door_numbers.append("%s.%s" % (el, string.ascii_uppercase[0]))
    elif room_numbers.count(el) &gt; 1:
        door_numbers.append("%s.%s" % (el, string.ascii_uppercase[num_count]))
        num_count += 1

door_numbers = ['101.A','103.A','101.B','102.C','104.A',
                '105.A','106.A','107.A','102.D','108.A']   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Given</strong></p>
<pre><code>import string
import itertools as it
import collections as ct


room_numbers = ['101','103','101','102','104','105','106','107','102','108']
letters = string.ascii_uppercase
</code></pre>
<p><strong>Code</strong></p>
<p><em>Simple, Two-Line Solution</em></p>
<pre><code>dd = ct.defaultdict(it.count)    
print([".".join([room, letters[next(dd[room])]]) for room in room_numbers])
</code></pre>
<p>or </p>
<pre><code>dd = ct.defaultdict(lambda: iter(letters))
print([".".join([room, next(dd[room])]) for room in room_numbers])
</code></pre>
<p>Output</p>
<pre><code>['101.A', '103.A', '101.B', '102.A', '104.A', '105.A', '106.A', '107.A', '102.B', '108.A']
</code></pre>
<hr/>
<p><strong>Details</strong></p>
<p>In the first example we are using <em><code>itertools.count</code></em> as a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict.default_factory" rel="nofollow noreferrer">default factory</a>.  This means that a new <code>count()</code> iterator is made whenever a new room number is added to the defaultdict <code>dd</code>.  Iterators are useful because they are lazily evaluated and memory efficient.  </p>
<p>In the list comprehension, these iterators get initialized per room number.   The next number of the counter is yielded, the number is used as an index to get a letter, and the result is simply joined as a suffix to each room number.</p>
<p>In the second example (recommended), we use an <em>iterator of strings</em> as the default factory.  The callable requirement is satisfied by returning the iterator in a lambda function. An iterator of strings enables us to simply call <code>next()</code> and directly get the next letter.  Consequently, the comprehension is simplified since slicing <code>letters</code> is no longer required.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem in your implementation is that you have a value <code>num_count</code> which is continuously incremented for each item in the list than just the specific items' count. What you'd have to do instead is to count the number of times each of the item has occurred in the list.</p>
<p>Pseudocode would be
1. For each room in room numbers
2. Add the room to a list of visited rooms
3. Count the number of times the room number is available in visited room
4. Add the count to 64 and convert it to an ascii uppercase character where <code>65=A</code>
5. Join the required strings in the way you want to and then append it to the <code>door_numbers</code> list.</p>
<p>Here's an implementation</p>
<pre><code>import string
room_numbers = ['101','103','101','102','104','105','106','107','102','108']
door_numbers = []

visited_rooms = []
for room in room_numbers:
    visited_rooms.append(room)
    room_count = visited_rooms.count(room)
    door_value = chr(64+room_count) # Since 65 = A when 1st item is present
    door_numbers.append("%s.%s"%(room, door_value))
</code></pre>
<p><code>door_numbers</code> now contains the final list you're expecting which is </p>
<pre><code>['101.A', '103.A', '101.B', '102.A', '104.A', '105.A', '106.A', '107.A', '102.B', '108.A']
</code></pre>
<p>for the given input <code>room_numbers</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The naive way, simply count the number of times the element is contained in the list up until that index:</p>
<pre><code>&gt;&gt;&gt; door_numbers = []
&gt;&gt;&gt; for i in xrange(len(room_numbers)):
...     el = room_numbers[i]
...     n = 0
...     for j in xrange(0, i):
...         n += el == room_numbers[j]
...     c = string.ascii_uppercase[n]
...     door_numbers.append("{}.{}".format(el, c))
...
&gt;&gt;&gt; door_numbers
['101.A', '103.A', '101.B', '102.A', '104.A', '105.A', '106.A', '107.A', '102.B', '108.A']
</code></pre>
<p>This two explicit for-loops make the quadratic complexity pop out. Indeed, (1/2) * (N * (N-1)) iterations are made. I would say that in most cases you would be better off keeping a <code>dict</code> of counts instead of counting each time.</p>
<pre><code>&gt;&gt;&gt; door_numbers = []
&gt;&gt;&gt; counts = {}
&gt;&gt;&gt; for el in room_numbers:
...     count = counts.get(el, 0)
...     c = string.ascii_uppercase[count]
...     counts[el] = count + 1
...     door_numbers.append("{}.{}".format(el, c))
...
&gt;&gt;&gt; door_numbers
['101.A', '103.A', '101.B', '102.A', '104.A', '105.A', '106.A', '107.A', '102.B', '108.A']
</code></pre>
<p>That way, there's no messing around with indices, and it's more time efficient (at the expense of auxiliary space).</p>
</div>
<div class="post-text" itemprop="text">
<p>Using iterators and comprehensions:</p>
<ol>
<li>Enumerate the rooms to preserve the original order</li>
<li>Group rooms by room number, sorting first as required by <code>groupby()</code></li>
<li>For each room in a group, append <code>.A</code>, <code>.B</code>, etc.</li>
<li>Sort by the enumeration values from step 1 to restore the original order</li>
<li>Extract the door numbers, e.g. '101.A'</li>
</ol>
<p>.</p>
<pre><code>#!/usr/bin/env python3

import operator
from itertools import groupby
import string

room_numbers = ['101', '103', '101', '102', '104',
                '105', '106', '107', '102', '108']
get_room_number = operator.itemgetter(1)
enumerated_and_sorted = sorted(list(enumerate(room_numbers)),
                               key=get_room_number)
# [(0, '101'), (2, '101'), (3, '102'), (8, '102'), (1, '103'),
#  (4, '104'), (5, '105'), (6, '106'), (7, '107'), (9, '108')]  
grouped_by_room = groupby(enumerated_and_sorted, key=get_room_number)
# [('101', [(0, '101'), (2, '101')]),
#  ('102', [(3, '102'), (8, '102')]),
#  ('103', [(1, '103')]),
#  ('104', [(4, '104')]),
#  ('105', [(5, '105')]),
#  ('106', [(6, '106')]),
#  ('107', [(7, '107')]),
#  ('108', [(9, '108')])] 
door_numbers = ((order, '{}.{}'.format(room, char))
                for _, room_list in grouped_by_room
                for (order, room), char in zip(room_list,
                                               string.ascii_uppercase))
# [(0, '101.A'), (2, '101.B'), (3, '102.A'), (8, '102.B'),
#  (1, '103.A'), (4, '104.A'), (5, '105.A'), (6, '106.A'),
#  (7, '107.A'), (9, '108.A')] 
door_numbers = [room for _, room in sorted(door_numbers)]
# ['101.A', '103.A', '101.B', '102.A', '104.A',
#  '105.A', '106.A', '107.A', '102.B', '108.A']                                         
</code></pre>
</div>
<span class="comment-copy">Do you mean given the room numbers list above, you need to generate the possible door numbers starting from A for each given room number? Why don't you use a counter and generate the door numbers?</span>
<span class="comment-copy">You are sharing <code>num_count</code></span>
<span class="comment-copy">@SudheeshSinganamalla  If room number list has duplicate value it means room has more that one doors. first door number should have ".A" suffix and following door should have ".B" suffix. So room number 102 shows up twice so it should be (102.A and 102.B) not (102.C and 102.D)</span>
<span class="comment-copy">@juanpa.arrivillaga yea. not sure how to count unique values and use that to drive the letters.</span>
<span class="comment-copy">@Azubike the straightforward way is to simply count the <i>occurrence</i> of the element up to that point. Let me illustrate with an answer</span>
<span class="comment-copy">If result order doesnâ€™t matter: <code>["{}.{}".format(rn, rl)) for (rn, c) in collections.Counter(room_numbers).items() for rl in string.ascii_uppercase[:c]]</code></span>
<span class="comment-copy">This is a straight-forward itertools approach.  I suggest adding some commentary to improve it.  It looks like you are recording order with <code>enumerate</code>, grouping by room numbers, zipping letters to values of the groups and resorting according to the enumeration.</span>
<span class="comment-copy">I tried to make it self documenting with good variable names and comments showing the results at each stage, formatted for clarity.</span>
<span class="comment-copy">Those are indeed good, but a little narrative would eliminate ambiguity.  It's a lot to take in.</span>
