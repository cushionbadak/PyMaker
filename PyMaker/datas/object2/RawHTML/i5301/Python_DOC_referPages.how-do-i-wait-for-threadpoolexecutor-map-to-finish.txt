<div class="post-text" itemprop="text">
<p>I have the following code, which has been simplified:</p>
<pre><code>import concurrent.futures

pool = concurrent.futures.ThreadPoolExecutor(8)

def _exec(x):
    return x + x

myfuturelist = pool.map(_exec,[x for x in range(5)])

# How do I wait for my futures to finish?

for result in myfuturelist:
    # Is this how it's done?
    print(result)

#... stuff that should happen only after myfuturelist is
#completely resolved.
# Documentation says pool.map is asynchronous
</code></pre>
<p>The documentation is weak regarding ThreadPoolExecutor.map. Help would be great.</p>
<p>Thanks! </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Executor.map</strong> will run jobs in parallel and wait futures to finish, collect results and return a generator. It has done the wait for you. If you set a timeout, it will wait until timeout and throw exception in generator.</p>
<blockquote>
<p>map(func, *iterables, timeout=None, chunksize=1)</p>
<ul>
<li>the iterables are collected immediately rather than lazily; </li>
<li>func is executed asynchronously and several calls to func may be made    concurrently.</li>
</ul>
</blockquote>
<p>To get a list of futures and do the wait manually, you can use:</p>
<pre><code>myfuturelist = [pool.submit(_exec, x) for x in range(5)]
</code></pre>
<p><strong>Executor.submit</strong> will return a <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future" rel="nofollow noreferrer">future</a> object, call <code>result</code> on future will explicitly wait for it to finish:</p>
<pre><code>myfutrelist[0].result() # wait the 1st future to finish and return the result
</code></pre>
</div>
