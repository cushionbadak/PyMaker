<div class="post-text" itemprop="text">
<p>I have a SOAP web service I have to work with, and one of the commands it supports is a "SQL like" query where I input a select, from, and where statements. I think the "where" clause will be most demonstrative of what I'm trying to do so here: </p>
<pre><code>def sql_soap(tablename, where):
   sql_where = [soap_object(where_statement) for where_statement in where]
   return query

sql_soap('student',where=[{'Condition':'=','Field':'Subject','Value':'Calculus'}]) 
</code></pre>
<p>Basically, the way I've thought to do this is to package a list of where-clause dictionaries. But the dictionaries should always have the same keys. Is there a way to define this type in the function definition? I don't want kwargs or args because I know in advance the data structure. </p>
<p>One thing I looked at was</p>
<pre><code>def sql_soap(tablename, *, where): 
</code></pre>
<p>Apparently this is only available in newer versions of Python (which I have) but my understanding is the where clause after this is expecting a dictionary, and I want a list of dictionaries. </p>
<p>Generally speaking how do I define a function argument, when I want a dictionary inside of a list, or something else nested? Is there any way besides a dictionary, that I can get a single function parameter (where) to accept all of the arguments I need to make the SOAP where object? </p>
</div>
<div class="post-text" itemprop="text">
<p>I do not know if this helps, but you could use *where to expect an arbitrary amount of args:</p>
<pre><code>def sql_soap(tablename, *where):
   sql_where = [soap_object(where_statement) for where_statement in where]
   return query

sql_soap('student',
         {'Condition':'=','Field':'Subject','Value':'Calculus'},
         {'Condition':'=','Field':'Subject2','Value':'Calculus2'},
)
</code></pre>
<p>One thing you can also do, but you would to have to change probaply a lot of code for that, is use namedtuple instead of dictionaries:</p>
<pre><code>from collections import namedtuple

wheretuple = namedtuple("wheretuple", "field condition value")
sql_soap('student', wheretuple("Subject", "=", "Calculus"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have not specified anything about types. The <code>*</code> syntax in a function definition only specifies how a caller can provide arguments for the parameters. Parameters before it can be filled with both positional arguments and keyword arguments, those that follow the <code>*</code> can only be specified with keyword arguments.</p>
<p>Put differently, the following calls are now legal:</p>
<pre><code>sql_soap('student', where=[...])  # one positional, one keyword argument
sql_soap(tablename='student', where=[...])  # two keyword arguments
</code></pre>
<p>but the following is not:</p>
<pre><code>sql_soap('student', [...])  # two positional arguments
</code></pre>
<p>You'll instead get a <code>TypeError</code> exception, <code>TypeError: sql_soap() takes 1 positional argument but 2 were given</code>.</p>
<p>Using <code>*</code> in a function definition does not say anything about what type of objects the parameter accepts. You can still pass anything you like to the function call.</p>
<p>Perhaps you got confused with the <code>*args</code> and <code>**kwargs</code> syntax in function definitions, where those parameters capture <em>all remaining positional or keyword arguments passed in</em>, which did not address any of the other parameters. They don't say anything about the argument types <em>either</em>; instead they put those remaining argument values in a tuple and dictionary, respectively.</p>
<p>Python does now support <a href="https://www.python.org/dev/peps/pep-0484/" rel="nofollow noreferrer"><em>type hinting</em></a>, but even type hinting will not let you specify what keys to use in a dictionary.</p>
<p>I'd use <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="nofollow noreferrer"><em>named tuples</em></a> instead here, together with type hints:</p>
<pre><code>from typing import NamedTuple, Sequence

class WhereClause(NamedTuple):
    condition: str
    field: str
    value: str


def sql_soap(tablename: str, where: Sequence[WhereClause]):
    ...
</code></pre>
<p>This lets the type checker know that the <code>where</code> argument <em>must</em> be a sequence type (like a list), that contains only <code>WhereClause</code> instances. And those instances will have specific attributes.</p>
<p>Anytime you want to use any of the <code>WhereClause</code> instances, you can use attributes to get at the contents, so <code>whereclause.condition</code> and <code>whereclause.value</code>.</p>
</div>
<span class="comment-copy">The only difference with the second version is that you can't pass <code>where</code> positionally. Also your first version doesn't seem to be syntactically valid.</span>
<span class="comment-copy"><code>where</code> is just expecting a Python object, no more specific. It doesn't expect a dictionary or a list of dictionaries or anything so specific.</span>
<span class="comment-copy">The only thing you did is specify that <code>where</code> can only be used as a keyword argument, so <code>sql_soap('student', [...])</code> is not accepted, but <code>sql_soap('student', where=[...])</code> <i>is</i>.</span>
