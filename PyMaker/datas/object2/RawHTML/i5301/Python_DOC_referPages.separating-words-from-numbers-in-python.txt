<div class="post-text" itemprop="text">
<p>I have to search a string for words that have a number as prefix or suffix (Example, "abc21" or "943xyz". Then, I need to split the number from the word.</p>
<p>For example,
"abc12" has to converted to "abc 12"
or "12abc" has to be converted to "12 abc"</p>
<p>However, if the number lies in between letters, for example, "a12bc", then it should be left as it is. How can we do this? Is there a simpler way than regex?</p>
</div>
<div class="post-text" itemprop="text">
<p>Something simple like one of these.<br/>
All that's needed is to protect the boundary's with these <code>(?&lt;! [\da-z] ) .. (?! [\da-z] )</code><br/>
which does 2 things:<br/>
- it stops the engine from matching between like kinds (digits or alphas).<br/>
- insures no bookend types.  </p>
<p>Way 1:  </p>
<p>Find <code>(?&lt;![\da-z])(?:([a-z]+)(\d+)|(\d+)([a-z]+))(?![\da-z])</code><br/>
Replace <code>$1$3 $2$4</code></p>
<p><a href="https://regex101.com/r/k4gNoE/1" rel="nofollow noreferrer">https://regex101.com/r/k4gNoE/1</a></p>
<pre><code> (?&lt;! [\da-z] )
 (?:
      ( [a-z]+ )             # (1)
      ( \d+ )                # (2)
   |  
      ( \d+ )                # (3)
      ( [a-z]+ )             # (4)
 )
 (?! [\da-z] )
</code></pre>
<hr/>
<p>Way 2:  </p>
<p>Find <code>(?&lt;![\da-z])(?:([a-z]+(?=\d)|\d+(?=[a-z]))((?&lt;=\d)[a-z]+|(?&lt;=[a-z])\d+))(?![\da-z])</code>
Replace <code>$1 $2</code></p>
<p><a href="https://regex101.com/r/LbWnkg/1" rel="nofollow noreferrer">https://regex101.com/r/LbWnkg/1</a></p>
<pre><code> (?&lt;! [\da-z] )
 (?:
      (                        # (1 start)
           [a-z]+ 
           (?= \d )
        |  \d+ 
           (?= [a-z] )
      )                        # (1 end)
      (                        # (2 start)
           (?&lt;= \d )
           [a-z]+ 
        |  (?&lt;= [a-z] )
           \d+ 
      )                        # (2 end)
 )
 (?! [\da-z] )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>def split_vals(s):
  return ' '.join(re.findall('^\d+|\d+$|^[a-zA-Z]\d+[a-zA-Z]+$|^[a-zA-Z]+$|[a-zA-Z]+', s))
s = ["abc21", "943xyz", '12abc', "a12bc"]
new_s = list(map(split_vals, s))
</code></pre>
<p>Output:</p>
<pre><code>['abc 21', '943 xyz', '12 abc', 'a12bc']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a> to insert that space:</p>
<pre><code>re.sub(r'\b(?:(\D+)(\d+)|(\d+)(\D+))\b', r"\1\3 \2\4", word)
</code></pre>
<p>This matches digits followed by non-digits or vice-versa.</p>
<p>The <code>\b</code> boundaries make sure the word is matched in its entirety, so that we don't match numbers in the middle of a word.</p>
<p>The replacement pattern <code>\1\3 \2\4</code> takes advantage of the fact that unmatched groups are replaced with the empty string. We know that <em>either</em> group 1 and 2 <em>or</em> group 3 and 4 will match, and the other groups will be empty, so <code>\1\3 \2\4</code> will always produce a valid result (without duplicating any part of the input).</p>
<hr/>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt; re.sub(r'\b(?:(\D+)(\d+)|(\d+)(\D+))\b', r"\1\3 \2\4", "abc12")
'abc 12'
&gt;&gt;&gt; re.sub(r'\b(?:(\D+)(\d+)|(\d+)(\D+))\b', r"\1\3 \2\4", "12abc")
'12 abc'
&gt;&gt;&gt; re.sub(r'\b(?:(\D+)(\d+)|(\d+)(\D+))\b', r"\1\3 \2\4", "a12bc")
'a12bc'
</code></pre>
</div>
<span class="comment-copy">Please show what you have tried already to solve this problem.</span>
<span class="comment-copy">this is pretty close : <a href="https://stackoverflow.com/questions/430079/how-to-split-strings-into-text-and-number" title="how to split strings into text and number">stackoverflow.com/questions/430079/â€¦</a></span>
<span class="comment-copy">@jmunsch pretty close + too broad = closing to me :) thanks for the link</span>
<span class="comment-copy">That's a pretty far-fetched duplicate, so I'm gonna leave a hint for the OP: The regex in that question <code>\D+\d+</code> matches only words with digits at the end. Duplicate that and turn it around, you get <code>\D+\d+|\d+\D+</code> which matches words with digits on either end. From there you just need to figure out how to insert a space. (Hint #2: <code>re.sub</code>)</span>
<span class="comment-copy">@Rawing actually, I think <code>\w</code> matches alphanumeric, so that might not play well, perhaps best to use <code>\d\D</code></span>
<span class="comment-copy">Thank you! I did almost the same thing, but I didn't put \b in. That's why I was getting the error.</span>
