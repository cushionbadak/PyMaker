<div class="post-text" itemprop="text">
<p>I read a webpage using <code>urllib.request.urlopen</code>:</p>
<pre><code>import urllib.request
import shutil

my_response = urllib.request.urlopen('https://google.com') # object of HTTPResponse type
</code></pre>
<p>Then, I want both to save it as a file and use the variable for future processing in the code. If I try, for example, the following:</p>
<pre><code>shutil.copyfileobj(my_response, open('gpage.html', 'wb')) # saved successfully
my_content = my_response.read() # empty
</code></pre>
<p>file is successfully saved but <code>my_response</code> becomes empty after that.<br/>
Vice versa, if I call <code>.read()</code> first, I can get the content but saved file will be empty:</p>
<pre><code>my_content = my_response.read() # works as expected
shutil.copyfileobj(my_response, open('gpage.html', 'wb')) # empty file
</code></pre>
<p>i.e. I can only access <code>my_content</code> once. I remember this behavior is typical for some other types of python objects (all iterators?) but not sure what is the correct term for it.
What would be recommended solution in my case, if I want both to write content to the file and keep it in a variable? (so far I use workaround with writing to the file and then reading it)</p>
</div>
<div class="post-text" itemprop="text">
<p>This is normal behaviour for any buffer (In this example it is a buffered reader), the opposite would be to read from a stream (stream readers). You can easily circumvent it by first writing it into your variable and do your operations on that variable:</p>
<pre><code>my_content = my_response.read() # read from buffer and store in variable
with open('gpage.html', 'wb') as fp: 
    fp.write(my_content) # use the variable instead of the reader again
# do more stuff with my_content
</code></pre>
<p>The buffer gets emptied if you consume the data that is in it to make space for more data. In this case <code>shutils.copyfileobj</code> also calls <code>.read()</code> on the object and thus only the first one gets what's in the buffer. </p>
<p>Also: The documentation of <a href="https://docs.python.org/3/library/urllib.request.html#examples" rel="nofollow noreferrer"><code>urllibb.request</code></a> recommends to open the url just like any other resource:</p>
<pre><code>with open(urllib.request.urlopen('https://google.com')) as request:
    my_content = request.read()
</code></pre>
<p>this way the resource gets directly freed again after everything was read from the buffer and you are consuming less memory as soon as the <code>with ...:</code> scope ends.</p>
<p>Together that would make:</p>
<pre><code>my_content = ""
with open(urllib.request.urlopen('https://google.com')) as request:
    my_content = request.read()
with open('gpage.html', 'wb') as fp: 
    fp.write(my_content)
</code></pre>
</div>
<span class="comment-copy">thank you @Jan! So, the solution here is just to avoid <code>shutil.copyfileobj</code> and use file's <code>.write()</code> instead?</span>
<span class="comment-copy">I edited the post to add my full recommendation. The problem with shutil.copyfileobj is that it needs an object that has a .read() function which the variable doesn't have so you can't use it with a buffered reader if you also want to do other stuff with it.</span>
