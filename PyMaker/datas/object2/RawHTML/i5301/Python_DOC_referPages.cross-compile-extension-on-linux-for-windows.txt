<div class="post-text" itemprop="text">
<p>I've managed to build some DLLs on Linux that are necessary for my Python extension using MinGW.  Something along these lines:</p>
<pre><code>from setuptools.command.build_py import build_py

class BuildGo(build_py):

    def run(self):
        if # need to build windows binaries
            self.build_win()
        build_py.run(self)

    def build_win(self):
        if # compilers and toolchain available
            try:
                # builds extra libraries necessary for this extension
            except subprocess.CalledProcessError as e:
                print(e.stderr)
                raise
            try:
                result = subprocess.check_output([
                    'x86_64-w64-mingw32-gcc-win32',
                    '-shared',
                    '-pthread',
                    '-o',
                    EXTRA_DLL,
                    FAKE_WIN_BINDINGS,
                    ARCHIVE_GENERATED_IN_PREVIOUS_STEP,
                    '-lwinmm',
                    '-lntdll',
                    '-lws2_32',
                ])
                print(result)
            except subprocess.CalledProcessError as e:
                print(e.stderr)
                raise
</code></pre>
<p>I was now hoping I could avoid extending <code>build_ext</code> in the same painful way to get it to cross-compile Cython code for Windows...  I looked into the abyss of "elegant interplay of <code>setuptools</code>, <code>distutils</code> and <code>cython</code>", and before the abyss has a chance to look back into me... Isn't there a way to just specify some flag... like a name of compiler and Python binary for desired platform and... it would just do it?</p>
<p>I've read this article: <a href="http://whatschrisdoing.com/blog/2009/10/16/cross-compiling-python-extensions/" rel="nofollow noreferrer">http://whatschrisdoing.com/blog/2009/10/16/cross-compiling-python-extensions/</a> - it's almost 10 years old.  And it just made me want to cry... did anything change since it was written?  Or are these steps more or less what I'll have to do to compile for the platform other than the one I'm running on?</p>
<p>Or, is there an example project on the web which does it?</p>
<h1>Goal</h1>
<p>My ultimate goal is to produce an <code>egg</code> package which will contain both PE and ELF binaries in it and will install them in the correct location on either platform when installed by <code>pip</code> or <code>pipenv</code>.  It should compile on Linux (compiling it on MS Windows isn't necessary).</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm posting this as community wiki because it's a pretty unsatisfactory answer: it only tells you why it's very hard rather than offers really solutions.</p>
<p>The official Python distributions on Windows are <a href="https://wiki.python.org/moin/WindowsCompilers#Which_Microsoft_Visual_C.2B-.2B-_compiler_to_use_with_a_specific_Python_version_.3F" rel="nofollow noreferrer">compiled with Microsoft Visual C (MSVC)</a>, and when compiling a Python extension it's generally necessary to use the same version as the one that Python was compiled with. This shows you that an exact compiler match is pretty important.</p>
<p>It is possible to get versions of Python compiled with Mingw, and these would then be compatible with modules compiled with Mingw. This could probably be made to work as a cross-compiler on Linux but the modules would only be useful to a very small subset of people that have this custom build of Python (so doesn't help create a useful distributable .egg file).</p>
<p>A reasonable effort has gone also into making a version of Mingw that can build compatible Python extensions on Windows: <a href="https://mingwpy.github.io/" rel="nofollow noreferrer">https://mingwpy.github.io/</a> (and I think also <a href="https://anaconda.org/msys2/m2w64-toolchain" rel="nofollow noreferrer">https://anaconda.org/msys2/m2w64-toolchain</a>). The main driver for this seems to be the lack of freely Fortran compiler for Windows that is compatible with MSVC, hence the ability to build Fortran modules is very useful. The mingwpy toolchain worked pretty well in my experience, until Python 3.4 when the switch to a more recent version of MSVC brought <a href="https://mingwpy.github.io/issues.html#the-vs-14-2015-runtime" rel="nofollow noreferrer">a whole exciting new set</a> of <a href="https://github.com/winpython/winpython/issues/67" rel="nofollow noreferrer">compatibility issues</a>.</p>
<p>My feeling would be that any viable solution would probably be based around these mostly-working Mingw compilers for windows.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/3/distutils/builtdist.html" rel="nofollow noreferrer">https://docs.python.org/3/distutils/builtdist.html</a> , <code>distutils</code> only supports cross-compiling between <code>win32</code> and <code>win_amd64</code> as of this writing (<code>3.7</code>).</p>
<p>Moreover, <a href="https://docs.python.org/3/extending/windows.html?highlight=msvc#using-dlls-in-practice" rel="nofollow noreferrer">building extensions with compilers other than the MSVC that Python is built with is not officially supported</a>.</p>
<p>It is theoretically possible by getting a Linux toolchain for <code>win32/64</code> (including the necessary headers and link libraries), a set of the necessary Python for Windows binaries to link against, then <a href="https://stackoverflow.com/questions/45479617/how-can-i-use-python-distutils-to-cross-compile-an-extension-module-to-a-differe">forge compiler and linker paths and/or options in <code>setup.py</code></a> -- though it will still be an unsupported setup.</p>
<p>So you'll be better off using a Windows VM or an online build service like AppVeyor.</p>
</div>
<div class="post-text" itemprop="text">
<p>I had the same issue once, but I just used a virtual machine to compile my most painfuly microsoft dependant programs.</p>
<p><a href="https://developer.microsoft.com/en-us/windows/downloads/virtual-machines" rel="nofollow noreferrer">https://developer.microsoft.com/en-us/windows/downloads/virtual-machines</a></p>
<p>If you don't have access to a windows machine or your programs uses very specific machiney like a fortran compiler optimized or some POSIX dependant stuff or newest features from VS redistributable versions, you better give  a try to a virtual machine based compilation system.</p>
</div>
<span class="comment-copy">One problem is that Python on Windows is heavily tied to <i>specific versions</i> of MSVC and modules compiled with mingw generally aren't compatible. (There's been some effort recently to make a version of mingw that does create compatible Python modules, but it isn't perfect. You're in for a whole world of fun trying to use gfortran with Python on Windows, for example)</span>
<span class="comment-copy">@DavidW for a moment I thought to disregard your advise... I found this post: <a href="https://stackoverflow.com/questions/32361119/error-when-trying-to-cross-compile-swig-python-extension-for-mingw32-using-distu" title="error when trying to cross compile swig python extension for mingw32 using distu">stackoverflow.com/questions/32361119/â€¦</a> and hoped I could do the same... but these tools don't work together any more, and the import library generated from Python DLL doesn't meet the <code>mingw</code> requirements... time for sackcloth and ashes.</span>
<span class="comment-copy">This is not possible to be done reliably that will not break in horrible, not easy to troubleshoot, ways. Compile the extension on Windows with the same <a href="https://wiki.python.org/moin/WindowsCompilers#Which_Microsoft_Visual_C.2B-.2B-_compiler_to_use_with_a_specific_Python_version_.3F" rel="nofollow noreferrer">MSVC as was used for that Python version</a>. Mixing shared objects/modules built with different compilers is generally a big no-no. Even with only GCC the same version needs to be used, let alone between MingW and MSVC.</span>
<span class="comment-copy">@danny, @DavidW do you happen to know why the infrastructure around this issue is so bad? I mean, Ruby is no different from Python in how it is set up in principle, but in Ruby world it's not a problem. Is this issue known to CPython developers? Had it been mentioned on the mailing list? I mean, this is so obviously broken and what we get in Python 3.7 is some renaming of <code>type</code> function? How does this make any sense...</span>
<span class="comment-copy">I know nothing about Ruby but <a href="https://stackoverflow.com/questions/11480430/how-to-compile-a-ruby-c-extension-and-link-libcurl-on-windows">this</a> implies that the same applies with Ruby. I think the difference might be that they picked Mingw as the default option, which makes cross-compiling on Linux pretty straight forward. The Python devs would probably argue that MSVC is the "native" compiler and is freely available, so is a sensible choice.</span>
<span class="comment-copy">Just to add that <a href="https://conda.io/miniconda.html" rel="nofollow noreferrer">conda</a> was specifically designed with this problem in mind. It offers a cross platform toolchain that can build packages for Linux, OSX and Windows and greatly simplifies building and shipping cross platform native code extensions and other native code binaries and libraries. Its con is that it is not a 'native' feature of any OS so users will have to install it first and that it offers similar capabilities as pip binary wheels. That said, its bootstrap is simple and painless.</span>
<span class="comment-copy">You're welcome to edit that in to this answer (or post it separately) if you want. It doesn't quite solve the problem, but it's certainly a relevant alternative.</span>
<span class="comment-copy">I've given up this idea long time ago. I didn't update my question, but I actually wrote to the Python mailing list only to discover that this is, basically, impossible. For now, I've switched to Anaconda, because it has... well, better toolchain than python.org. But, in the future, I'll try to stay away from Python when possible.</span>
