<div class="post-text" itemprop="text">
<p>Simple problem: I have <code>u = [1, 2, 3, 4, 5, 6]</code>. I want <code>v = [(1,2), (3,4), (5,6)]</code>. How?</p>
<p>Obviously, one solution is:</p>
<pre><code>v = []
for i in range(len(u)):
    j = 2*i
    v += [(u(j), u(j+1))]
</code></pre>
<p>But this is so ugly and lame I hate looking at it every time I do it. Is there a better way?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3.6/library/functions.html#zip" rel="nofollow noreferrer">zip</a> is a pythonic solution.</p>
<pre><code>list(zip(u[::2], u[1::2]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a more general solution for iterables that don't support slice notation</p>
<pre><code>def n_clusters(iterable, n=2):
    return zip(*[iter(iterable)]*n)
</code></pre>
<p>Note that any leftover values (say your input list has an odd number of elements) aren't included in the output.  We an correct this by using the <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a> function.</p>
<pre><code>from itertools import zip_longest

def n_clusters(iterable, n=2, fillvalue=None):
    return zip_longest(*[iter(iterable)]*n, fillvalue=fillvalue)
</code></pre>
<p>Both of the above will return iterators over the grouped values.  You can either build a list out of them manually</p>
<pre><code>grouped_values = list(n_cluster([1, 2, 3, 4]))
# [(1, 2), (3, 4)]
</code></pre>
<p>or iterate over them directly</p>
<pre><code>for a, b in n_cluster([1, 2, 3, 4]):
    ...
</code></pre>
</div>
<span class="comment-copy">I forgot you could do <code>[::2]</code> in Python!</span>
