<div class="post-text" itemprop="text">
<p>I am starting a process by doing:</p>
<pre><code>for i in range(1, processes + 1):
            hup = MyURLParser() //A class I made
            p = Process(target = hup.run)
            p.start()
</code></pre>
<p>After that, so that the main thread doesn't exit immediately I do:</p>
<pre><code> while (True):
        print("Main sleeping...")
        sleep(20)
</code></pre>
<p>Instead of doing this, how can I check that each of the child processes are still running from the main thread ? Then instead of having the infinite loop I can break out of the loop at the right time and do something else....</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.is_alive" rel="nofollow noreferrer"><code>p.is_alive()</code></a> tells you whether the process is running.</p>
<p>To wait until it's ended, use <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.join" rel="nofollow noreferrer"><code>p.join()</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Add all processes to a list, and <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.Process.join" rel="nofollow noreferrer"><code>join()</code></a> each of them in turn:</p>
<pre><code>processes = []
for i in range(1, processes + 1):
    hup = MyURLParser() //A class I made
    p = Process(target = hup.run)
    p.start()
    processes.append(p)

for p in processes:
    p.join()
</code></pre>
<p>The <code>join()</code> call blocks until the process is finished. It doesn't matter in which order you call them; calling <code>join()</code> on a process that's already complete will just return immediately.</p>
<p>You may also want to check out the other functionality in the <a href="https://docs.python.org/3.6/library/multiprocessing.html" rel="nofollow noreferrer"><code>multiprocessing</code> module</a>; in particular the <code>Pool</code> class might help you simplify this code.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can use the <code>join</code> method (read more in <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.Process" rel="nofollow noreferrer">docs</a>):</p>
<p>First, keep the <code>Process</code> objects you create:</p>
<pre><code>your_processes = []
...
   p.start()
   your_processes.append(p)
</code></pre>
<p>After starting all your processes, use <code>join</code> to wait each one of them to finish executing.:</p>
<pre><code>for p in your_processes:
    p.join()
... #the rest of your code
</code></pre>
<p>Basically <code>join</code> makes the main process wait for process p to finish and only then to proceed to the next line of code.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do like this:</p>
<pre><code>P = []
for i in range(1, processes + 1):
            hup = MyURLParser() //A class I made
            p = Process(target = hup.run)
            p.start()
            P.append(p)

for p in P:
            p.join()
</code></pre>
<p>To only check if the process is alive, use <code>.is_alive()</code></p>
<p>Read more here: <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">https://docs.python.org/3/library/multiprocessing.html</a></p>
</div>
