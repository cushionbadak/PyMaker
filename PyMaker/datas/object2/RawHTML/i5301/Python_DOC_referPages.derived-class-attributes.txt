<div class="post-text" itemprop="text">
<pre><code>Class A(): 
    x=0 

class B(A): 
    b=1
</code></pre>
<p>1-<code>print(B.__dict__)</code> # no x attribute in B.<strong>dict</strong></p>
<pre><code>if B.x==0:
    B.x=1
</code></pre>
<p>2-<code>print(B.__dict__)</code> # there is x attribute in B.<strong>dict</strong>
 Why the output is different in 1 and 2?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>x</code> belongs to <code>A</code>. Note, <code>B</code> has access to the <code>A</code> namespace, since it inherits from <code>A</code>, but that doesn't mean that the two namespaces are equivalent. <code>B</code> has an <code>x</code> attribute in your second example because you gave an <code>x</code> attribute to <code>B</code>: i.e. <code>B.x=1</code> </p>
<p>It is important to familiarize yourself with the <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow noreferrer">Python Data Model</a>. Note, in the standard type hierachy under "custom classes" there is some highly relevant information:</p>
<blockquote>
<p>Custom class types are typically created by class definitions (see
  section Class definitions). A class has a namespace implemented by a
  dictionary object. Class attribute references are translated to
  lookups in this dictionary, e.g., <code>C.x</code> is translated to
  <code>C.__dict__["x"]</code> (although there are a number of hooks which allow
  for other means of locating attributes). <strong>When the attribute name is
  not found there, the attribute search continues in the base classes.</strong>
  This search of the base classes uses the C3 method resolution order
  which behaves correctly even in the presence of ‘diamond’ inheritance
  structures where there are multiple inheritance paths leading back to
  a common ancestor. Additional details on the C3 MRO used by Python can
  be found in the documentation accompanying the 2.3 release at
  <a href="https://www.python.org/download/releases/2.3/mro/" rel="nofollow noreferrer">https://www.python.org/download/releases/2.3/mro/</a>.</p>
<p>...</p>
<p><strong>Class attribute assignments update the class’s dictionary, never the dictionary of a base class.</strong></p>
</blockquote>
</div>
<span class="comment-copy">Can you improve the formatting of your question. Its difficult to grasp what you are asking.</span>
<span class="comment-copy">Because <code>x</code> belongs to <code>A</code>. Note, <code>B</code> has <i>access</i> to the <code>A</code> namespace, since it inherits from <code>A</code>, but that doesn't mean that the two namespaces are equivalent. <code>B</code> has an <code>x</code> attribute in your second example <b>because you gave an <code>x</code> attribute to <code>B</code></b>: i.e. <code>B.x=1</code></span>
<span class="comment-copy">This is why the MRO should probably be called the ARO.</span>
<span class="comment-copy">@wim yeah that would make more sense.</span>
