<div class="post-text" itemprop="text">
<p>Is it possible to run an async while loop independently of another one? </p>
<p>Instead of the actual code I isolated the issue I am having in the following example code</p>
<pre><code>import asyncio, time

class Time:
    def __init__(self):
        self.start_time = 0

    async def dates(self):
        while True:
            t = time.time()
            if self.start_time == 0:
                self.start_time = t
            yield t
            await asyncio.sleep(1)

    async def printer(self):
        while True:

            print('looping') # always called

            await asyncio.sleep(self.interval)

    async def init(self):
        async for i in self.dates():
            if i == self.start_time: 
                self.interval = 3 
                await self.printer()
            print(i) # Never Called

loop = asyncio.get_event_loop()
t = Time()
loop.run_until_complete(t.init())
</code></pre>
<p>Is there a way to have the print function run independently so <code>print(i)</code> gets called each time?</p>
<p>What it should do is <code>print(i)</code> each second and every 3 seconds call <code>self.printer(i)</code></p>
<p>Essentially self.printer is a separate task that does not need to be called very often, only every <code>x</code> seconds(in this case 3). </p>
<p>In JavaScript the solution is to do something like so
<code>setInterval(printer, 3000);</code></p>
<p>EDIT: Ideally self.printer would also be able to be canceled / stopped if a condition or stopping function is called</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>asyncio</code> equivalent of JavaScript's <code>setTimeout</code> would be <code>asyncio.ensure_future</code>:</p>
<pre><code>import asyncio

async def looper():
    for i in range(1_000_000_000):
        print(f'Printing {i}')
        await asyncio.sleep(0.5)

async def main():
    print('Starting')
    future = asyncio.ensure_future(looper())

    print('Waiting for a few seconds')
    await asyncio.sleep(4)

    print('Cancelling')
    future.cancel()

    print('Waiting again for a few seconds')
    await asyncio.sleep(2)

    print('Done')

if __name__ == '__main__':
    asyncio.get_event_loop().run_until_complete(main())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You'd want to register your <code>self.printer()</code> coroutine as a separate task; pass it to <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future" rel="nofollow noreferrer"><code>asyncio.ensure_future()</code></a> rather than await on it directly:</p>
<pre><code>asyncio.ensure_future(self.printer())
</code></pre>
<p>By passing the coroutine to <code>asyncio.ensure_future()</code>, you put it on the list of events that the loop switches between as each awaits on further work to be completed.</p>
<p>With that change, your test code outputs:</p>
<pre><code>1516819094.278697
looping
1516819095.283424
1516819096.283742
looping
1516819097.284152
# ... etc.
</code></pre>
<p>Tasks are the asyncio equivalent of threads in a multithreading scenario.</p>
</div>
<span class="comment-copy">Did you mean <code>asyncio.ensure_future(self.printer())</code> like in Blender's answer? Thanks btw!</span>
<span class="comment-copy">Yes, sorry about that.</span>
