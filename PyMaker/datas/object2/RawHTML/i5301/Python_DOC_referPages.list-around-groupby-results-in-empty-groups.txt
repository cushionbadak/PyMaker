<div class="post-text" itemprop="text">
<p>I was playing around to get a better feeling for itertools <code>groupby</code>, so I grouped a list of tuples by the number and tried to get a list of the resulting groups. When I convert the result of <code>groupby</code> to a list however, I get a strange result: all but the last group are empty. Why is that? I assumed turning an iterator into a list would be less efficient but never change behavior. I guess the lists are empty because the inner iterators are traversed but when/where does that happen?</p>
<pre><code>import itertools

l=list(zip([1,2,2,3,3,3],['a','b','c','d','e','f']))
#[(1, 'a'), (2, 'b'), (2, 'c'), (3, 'd'), (3, 'e'), (3, 'f')]

grouped_l = list(itertools.groupby(l, key=lambda x:x[0]))
#[(1, &lt;itertools._grouper at ...&gt;), (2, &lt;itertools._grouper at ...&gt;), (3, &lt;itertools._grouper at ...&gt;)]

[list(x[1]) for x in grouped_l]
[[], [], [(3, 'f')]]


grouped_i = itertools.groupby(l, key=lambda x:x[0])
#&lt;itertools.groupby at ...&gt;
[list(x[1]) for x in grouped_i]
[[(1, 'a')], [(2, 'b'), (2, 'c')], [(3, 'd'), (3, 'e'), (3, 'f')]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><strong><code>itertools.groupby()</code></strong> documentation</a>:</p>
<blockquote>
<p>The returned group is itself an iterator that shares the underlying iterable with <code>groupby()</code>. Because the source is shared, when the <code>groupby()</code> object is advanced, the previous group is no longer visible.</p>
</blockquote>
<p>Turning the output from <code>groupby()</code> into a list advances the <code>groupby()</code> object.</p>
<hr/>
<p>Hence, you shouldn't be type-casting <code>itertools.groupby</code> object to list. If you want to store the values as <code>list</code>, then you should be doing something like this <em>list comprehension</em> in order to create copy of <code>groupby</code> object:</p>
<pre><code>grouped_l = [(a, list(b)) for a, b in itertools.groupby(l, key=lambda x:x[0])]
</code></pre>
<p>This will allow you to iterate your list <em>(transformed from <code>groupby</code> object)</em> multiple times. However, if you are interested in only iterating the result once, then the second solution you mentioned in the question will suffice your requirement. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>groupby</code> is super lazy. Here's an illuminating demo. Let's group three <code>a</code>-values and four <code>b</code>-values, and print out what's happening:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; def letters():
        for letter in 'a', 'a', 'a', 'b', 'b', 'b', 'b':
            print('yielding', letter)
            yield letter
</code></pre>
<p><br/></p>
<h3>Going through the groups WITHOUT looking at their members</h3>
<p>Let's roll:</p>
<pre><code>&gt;&gt;&gt; groups = groupby(letters())
&gt;&gt;&gt; 
</code></pre>
<p>Nothing got printed yet! So until now, <code>groupby</code> did <strong>nothing</strong>. What a lazy bum. Let's ask it for the first group:</p>
<pre><code>&gt;&gt;&gt; next(groups)
yielding a
('a', &lt;itertools._grouper object at 0x05A16050&gt;)
</code></pre>
<p>So <code>groupby</code> tells us that this is a group of <code>a</code>-values, and we could go through that <code>_grouper</code> object to get them all. But wait, why did "yielding a" get printed only once? Our generator is yielding <strong>three</strong> of them, isn't it? Well, that's because <code>groupby</code> is lazy. It did read <strong>one</strong> value to <strong>identify</strong> the group, because it needs to tell us what the group is about, i.e., that it's a group of <code>a</code>-values. And it <strong>offers</strong> us that <code>_grouper</code> object for us to get all the group's members <strong>if we want to</strong>. But we didn't ask to go through the members, so the lazy bum didn't go any further. It simply didn't have a reason to. Let's ask for the next group:</p>
<pre><code>&gt;&gt;&gt; next(groups)
yielding a
yielding a
yielding b
('b', &lt;itertools._grouper object at 0x05A00FD0&gt;)
</code></pre>
<p>Wait, what? Why "yielding a" when we're now dealing with the <strong>second</strong> group, the group of <code>b</code>-values? Well, because <code>groupby</code> previously stopped after the first <code>a</code> because that was enough to give us all we had asked for. But now, to tell us about the second group, it has to <strong>find</strong> the second group, and for this it asks our generator until it sees something other than <code>a</code>. Note that "yielding b" is again only printed <strong>once</strong>, even though our generator yields <strong>four</strong> of them. Let's ask for the third group:</p>
<pre><code>&gt;&gt;&gt; next(groups)
yielding b
yielding b
yielding b
Traceback (most recent call last):
  File "&lt;pyshell#32&gt;", line 1, in &lt;module&gt;
    next(groups)
StopIteration
</code></pre>
<p>Ok so there is no third group and thus <code>groupby</code> issues a <code>StopIteration</code> so the consumer (e.g., a loop or list comprehension) would know to stop. But before that, the remaining "yielding b" get printed, because <code>groupby</code> got off its lazy butt and walked over the remaining values in hopes to find a new group.</p>
<p><br/></p>
<h3>Going through the groups WITH looking at their members</h3>
<p>Let's try again, this time let's ask for the members:</p>
<pre><code>&gt;&gt;&gt; groups = groupby(letters())
&gt;&gt;&gt; key, members = next(groups)
yielding a
&gt;&gt;&gt; key
'a'
</code></pre>
<p>Again, <code>groupby</code> asked our generator for just a single value, in order to <strong>identify</strong> the group so it can tell us that it's an <code>a</code>-group. But this time, we'll also ask for the group members:</p>
<pre><code>&gt;&gt;&gt; list(members)
yielding a
yielding a
yielding b
['a', 'a', 'a']
</code></pre>
<p>Aha! There are the remaining "yielding a". Also, already the first "yielding b"! Even though we didn't even ask for the second group yet! But of course <code>groupby</code> has to go this far because we asked for the group members, so it has to keep looking until it gets a non-member. Let's get the next group:</p>
<pre><code>&gt;&gt;&gt; key, members = next(groups)
&gt;&gt;&gt; 
</code></pre>
<p>Wait, what? Nothing got printed at all? Is <code>groupby</code> sleeping? Wake up! Oh wait... that's right... it already found out that the next group is <code>b</code>-values. Let's ask for all of them:</p>
<pre><code>&gt;&gt;&gt; list(members)
yielding b
yielding b
yielding b
['b', 'b', 'b', 'b']
</code></pre>
<p>Now the <strong>remaining</strong> three "yielding b" happen, because we asked for them so <code>groupby</code> has to get them.</p>
<p><br/></p>
<h3>Why doesn't it work to get the group members afterwards?</h3>
<p>Let's try it your initial way with <code>list(groupby(...))</code>:</p>
<pre><code>&gt;&gt;&gt; groups = list(groupby(letters()))
yielding a
yielding a
yielding a
yielding b
yielding b
yielding b
yielding b
&gt;&gt;&gt; [list(members) for key, members in groups]
[[], ['b']]
</code></pre>
<p>Note that not only is the first group empty, but also, the second group only has one element (you didn't mention that).</p>
<p>Why?</p>
<p>Again: <code>groupby</code> is super lazy. It <strong>offers</strong> you those <code>_grouper</code> objects so you <strong>can</strong> go through each group's members. But if you don't ask to see the group members and instead just ask for the next group to be identified, then <code>groupby</code> just shrugs and is like "Ok, you're the boss, I'll just go find the next group".</p>
<p>What your <code>list(groupby(...))</code> does is it asks <code>groupby</code> to identify all groups. So it does that. But if you then at the end ask for the members of each group, then <code>groupby</code> is like "Dude... I'm sorry, I offered them to you but you didn't want them. And I'm lazy, so <strong>I don't keep things around for no good reason</strong>. I can give you the last member of the last group, because I still remember that one, but for everything before that... sorry, I just don't have them anymore, you should've told me that you wanted them".</p>
<p>P.S. In all of this, of course "lazy" really means "efficient". Not something bad but something good!</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Summary:</strong> The reason is that itertools generally do not store data.  They just consume an iterator.  So when the outer iterator advances, the inner iterator must as well.</p>
<p><strong>Analogy:</strong> Imagine you are a flight attendant standing at the door, admitting a single line passengers to an aircraft.  The passengers are arranged by boarding group but you can only see and admit them one at a time.  Periodically, as people enter  you will learn when one boarding group has ended and then next has begun.</p>
<p>To advance to the next group, you're going to have to admit all the remaining passengers in the current group.   You can't see what is downstream in line without letting all the current passengers through.</p>
<p><strong>Unix comparison:</strong> The design of <a href="https://docs.python.org/2.7/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><em>groupby()</em></a> is algorithmically similar to the Unix <a href="https://www.computerhope.com/unix/uuniq.htm" rel="nofollow noreferrer"><em>uniq</em></a> utility.</p>
<p><strong>What the docs say:</strong> "The returned group is itself an iterator that shares the underlying iterable with groupby(). Because the source is shared, when the groupby() object is advanced, the previous group is no longer visible."</p>
<p><strong>How to use it:</strong> If the data is needed later, it should be stored as a list:</p>
<pre><code>groups = []
uniquekeys = []
data = sorted(data, key=keyfunc)
for k, g in groupby(data, keyfunc):
    groups.append(list(g))      # Store group iterator as a list
    uniquekeys.append(k)
</code></pre>
</div>
