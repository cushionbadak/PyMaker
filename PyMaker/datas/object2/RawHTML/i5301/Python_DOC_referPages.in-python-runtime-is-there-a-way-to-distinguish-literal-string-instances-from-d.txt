<div class="post-text" itemprop="text">
<p>In Python runtime, is there a way to distinguish literal string instances from dynamically created ones?</p>
<p>For example, I want to be able to tell the difference between these two values:</p>
<pre><code>val1 = "Foo"
var2 = "%s" % "Foo"
</code></pre>
<p>An example use case for this check is to protect a <code>string.Template</code>-like function from any attacks, like exposing value of local variables.</p>
<p>If it's not possible, is there any good reason for it?</p>
<hr/>
<p>And a side note...</p>
<p><a href="https://www.python.org/dev/peps/pep-0498/" rel="nofollow noreferrer">PEP 498 -- Literal String Interpolation</a> introduces <strong>f-strings</strong>, which are string literals which may split into literals and expressions at tokenization time.</p>
<p>F-strings work fairly similar to <code>string.Template()</code>, but has the enforcement of the input being a literal string, at the cost of syntax update for the language.</p>
<p>If this kind of check has been available on runtime, f-strings could have been implemented as a function.</p>
<hr/>
<h1>Update 1</h1>
<p>As noted by @kevin in his answer, CPython has optimizations that allows it to reuse existing instances when there's no need to create new ones. In my first example, <code>"%s" % "Foo"</code> is skipped with just linking to existing <code>"Foo"</code> instance.</p>
<p>But that's not a language requirement, and in fact doesn't always happen. Any string formatting other than some obvious ones would result in creation of a new instance.</p>
<p>In the following example, you can see that although the strings are equal by value, they are not the same object. Using <a href="https://docs.python.org/3/library/sys.html#sys.intern" rel="nofollow noreferrer"><code>sys.intern()</code></a> would give us the same instance, though.</p>
<pre><code>In [1]: import dis
   ...: import sys
   ...:
   ...: def foo():
   ...:     var1 = "Foo Bar"
   ...:     var2 = "%s %s" % ("Foo", "Bar")
   ...:     print(f'plain eq: {var1 == var2}')
   ...:     print(f'plain is: {var1 is var2}')
   ...:     print(f'intern is: {sys.intern(var1) is sys.intern(var2)}')
   ...:
   ...: dis.dis(foo)
   ...: foo()
   ...:
  5           0 LOAD_CONST               1 ('Foo Bar')
              2 STORE_FAST               0 (var1)

  6           4 LOAD_CONST               9 ('Foo Bar')
              6 STORE_FAST               1 (var2)

  7           8 LOAD_GLOBAL              0 (print)
             10 LOAD_CONST               5 ('plain eq: ')
             12 LOAD_FAST                0 (var1)
             14 LOAD_FAST                1 (var2)
             16 COMPARE_OP               2 (==)
             18 FORMAT_VALUE             0
             20 BUILD_STRING             2
             22 CALL_FUNCTION            1
             24 POP_TOP

  8          26 LOAD_GLOBAL              0 (print)
             28 LOAD_CONST               6 ('plain is: ')
             30 LOAD_FAST                0 (var1)
             32 LOAD_FAST                1 (var2)
             34 COMPARE_OP               8 (is)
             36 FORMAT_VALUE             0
             38 BUILD_STRING             2
             40 CALL_FUNCTION            1
             42 POP_TOP

  9          44 LOAD_GLOBAL              0 (print)
             46 LOAD_CONST               7 ('intern is: ')
             48 LOAD_GLOBAL              1 (sys)
             50 LOAD_ATTR                2 (intern)
             52 LOAD_FAST                0 (var1)
             54 CALL_FUNCTION            1
             56 LOAD_GLOBAL              1 (sys)
             58 LOAD_ATTR                2 (intern)
             60 LOAD_FAST                1 (var2)
             62 CALL_FUNCTION            1
             64 COMPARE_OP               8 (is)
             66 FORMAT_VALUE             0
             68 BUILD_STRING             2
             70 CALL_FUNCTION            1
             72 POP_TOP
             74 LOAD_CONST               0 (None)
             76 RETURN_VALUE
plain eq: True
plain is: False
intern is: True
</code></pre>
<p>As documented in <a href="https://docs.python.org/3/library/sys.html#sys.intern" rel="nofollow noreferrer"><code>sys.intern()</code></a>, "Normally, the names used in Python programs are automatically interned, and the dictionaries used to hold module, class or instance attributes have interned keys." In other words, normally, runtime string instances are not interned.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, you can't do that.  Or at least, you can't do it at runtime.  If you're willing to accept the limitations of compile-time analysis, you can parse and examine Python code with <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer"><code>ast</code></a>, but that is probably a far more involved tool than what you are looking for, and certainly will not allow you to "implement f-strings as a function."</p>
<p>For the specific case of your example, the Python language specification permits <code>var1</code> and <code>var2</code> to both point to the same object (and they definitely will if you pass both of them through the <a href="https://docs.python.org/3/library/sys.html#sys.intern" rel="nofollow noreferrer"><code>sys.intern()</code></a> function and compare the results).  Since a conforming Python implementation could alias them, there is no reliable way to tell them apart.  In fact, when I tried it in CPython 3.6.1, they were aliased:</p>
<pre><code>import dis

def foo():
    var1 = "Foo"
    var2 = "%s" % "Foo"
    return var1 is var2

dis.dis(foo)
print(foo())
</code></pre>
<p>Output:</p>
<pre><code>  4           0 LOAD_CONST               1 ('Foo')
              2 STORE_FAST               0 (var1)

  5           4 LOAD_CONST               3 ('Foo')
              6 STORE_FAST               1 (var2)

  6           8 LOAD_FAST                0 (var1)
             10 LOAD_FAST                1 (var2)
             12 COMPARE_OP               8 (is)
             14 RETURN_VALUE
True
</code></pre>
<p>Notice that it didn't even waste time computing <code>var2</code>.  It got <a href="https://en.wikipedia.org/wiki/Constant_folding" rel="nofollow noreferrer">constant-folded</a> into the literal value <code>'Foo'</code>, which was then deduplicated with the other <code>'Foo'</code> which the function was already using for <code>var1</code>.</p>
<p>(A more aggressive optimizer could have then propagated those constants and converted <code>var1 is var2</code> into <code>True</code>, but CPython does not do that (yet?), probably because it is rare to use <code>is</code> for immuntable values like strings.  Most of the other operations which could plausibly benefit from constant propagation are subject to various kinds of <a href="https://en.wikipedia.org/wiki/Monkey_patch" rel="nofollow noreferrer">monkey patching</a>, which prevents this optimization in the vast majority of real-world use cases.  As such, I presume that it is not worth implementing.)</p>
<blockquote>
<p>If it's not possible, is there any good reason for it?</p>
</blockquote>
<p>Because Python, like most imperative languages, uses <a href="https://en.wikipedia.org/wiki/Eager_evaluation" rel="nofollow noreferrer">eager evaluation</a>, which throws this information away immediately.  With a lazy-evaluated language, this question would at least be reasonable to ask, but I don't believe most of them preserve this information either.  The question of whether a string is literal or non-literal simply isn't considered a part of the string's value, in most programming languages that deal with strings.</p>
</div>
<span class="comment-copy"><code>string.Template</code> will only fill in what you pass to <code>.substitute()</code>, can you demonstrate the attack you're worried about?</span>
<span class="comment-copy">It is very common to pass in all the local variables to <code>. substitute()</code> or <code>.format()</code>, using <code>locals()</code> (or <code>*locals()</code>).</span>
<span class="comment-copy">To paraphrase my physician, "If it leaks information when you do that, don't do that."</span>
<span class="comment-copy">Thanks, @kevin, for the insightful answer. I have updated the question with more details to better show the current state of the interpreter.</span>
<span class="comment-copy">Regarding <i>eager evaluation</i>, IMHO there's still no reason <b>not</b> differentiate between literal string vs. formatted string. Yes, if different, it may result in more memory usage for the interpreter, but that doesn't mean that Python, the language, is not capable of having the feature.</span>
<span class="comment-copy">You're missing the point.  If the language is <i>allowed</i> to alias A and B, then there is no reliable way to differentiate them, even if they happen to be separate instances at runtime.</span>
<span class="comment-copy">Right. Right. That comment was towards the second part of the question: "why not?". It looks like the language <i>can</i> have the option to differentiate them, although it doesn't have it at the moment.</span>
<span class="comment-copy">A language <i>can</i> do almost anything.  Whether it is worth the engineering effort, CPU cycles, and RAM required to store an extra flag on every string (of which there are a lot, since Python's variables and other names exist at runtime in the form of strings) is the real question.  Most programming languages choose not to do so, both because it doesn't appear to be worth it, and because it partially defeats the string interning optimization which I described above.</span>
