<div class="post-text" itemprop="text">
<p>I have a class, <code>cacheHelper</code>, that I include as follows:</p>
<pre><code>import sys
sys.path.append('../../../utilities/')
from cache import cacheHelper
</code></pre>
<p>Later on, in my code, I use this class to access caches:</p>
<pre><code>helper = cacheHelper(folder='../../cache/', fileName='fileName', attr=attrs)
</code></pre>
<p>The parts relating to <code>folder</code> are quite trivial:</p>
<pre><code>class cacheHelper():

    def __init__(self, fileName, attr=[], folder='../cache/', sanitize=True):
        # sanitize: round input numbers.
        self.folder = folder
</code></pre>
<p>Now, everytime I start <code>cacheHelper</code> in my project, I need to tell it  the <code>folder</code> where it can read/write. I can't use the default value in the constructor, as that cannot be project-specific. </p>
<p>One way to do so would be to carry along a reference to <code>cacheFolder</code> in every function that I want to cache in, and then pass on <code>cacheHelper(folder=cacheFolder)</code>. </p>
<p>That appears messy. Is there something I can do on a file-level, perhaps during inclusion of the file?</p>
<p>My dream solution would be something along the lines of</p>
<pre><code>from cache import cacheHelper(folder='../../cache')
</code></pre>
<p>, and then magically everytime I use an instance of <code>cacheHelper</code>, it already has that preset. Now, I know this doesn't work the way I wrote it - but is there anything that comes close?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just write a helper function that calls the function for you with the right defaults:</p>
<pre><code>def newCacheHelper (fileName, attr, sanitize=True, folder='../../cache/'):
    return cacheHelper(fileName, attr, folder, sanitize)
</code></pre>
<p>You could even replace the existing one with your new one:</p>
<pre><code>originalCacheHelper = cacheHelper
def cacheHelper (fileName, attr, sanitize=True, folder='../../cache/'):
    return originalCacheHelper(fileName, attr, folder, sanitize)
</code></pre>
<p>Put that into your own module and import the <code>cacheHelper</code> from there, and you donâ€™t need to adjust anything in your code to use the correct folder.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about inheritance:</p>
<pre><code>class ProcjetCacheHelper(cacheHelper):

    def __init__(self, fileName, attr=[], folder='../../cache_project/', sanitize=True):
        super().__init__(fileName=fileName, attr=attr, folder=folder, sanitize=sanitize)


helper = ProcjetCacheHelper('fn')
print(helper.folder)
</code></pre>
<p>Output:</p>
<pre><code>../../cache_project/
</code></pre>
<p>Of course, you can change the names accordingly, so you can keep writing <code>cacheHelper</code>all over the place:</p>
<pre><code>from cache import cacheHelper as OriginalCacheHelper

class ProcjetCacheHelper(OriginalCacheHelper):

    def __init__(self, fileName, attr=[], folder='../../cache_project/', sanitize=True):
        super().__init__(fileName=fileName, attr=attr, folder=folder, sanitize=sanitize)

cacheHelper = ProcjetCacheHelper 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all, I recommend to think on this problem one more time; in most cases global state is not the thing you need.</p>
<p>On high level, you want a <a href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="nofollow noreferrer">singleton</a></p>
<p>On one way, you can implement this by hand within <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a> method, but I'd not recommend this. Python import system machinery is heavily cached. Meaning, only one instance of every module (together with all classes inside) exists at time. So, if you feel that such functionality really needed, you can put your state in module scope, like</p>
<pre><code>_path = '../folder'
class Cache:
    def do_some(self, arg):
        return arg * _path
</code></pre>
<p>And once per app you just call `cache_module._path = '../other'</p>
<p>Other dirty way is to put this path inside class, like class attribute</p>
<pre><code>class Cache:
    path = '../folder'
    @classmethod
    def do_some(cls, arg):
        return arg * cls.path
</code></pre>
<p>And once per app you setup cache with <code>Cache.path = '../other'</code>. Cache class and cache module will be the same across all codebase per single python interpreter.</p>
</div>
<span class="comment-copy">@BenjaminBarrois So basically, instead of carrying along <code>cacheFolder</code>, I would have to carry around <code>cacheHelperInstance</code>..</span>
<span class="comment-copy">So far, this is my preferred approach. Perhaps it'd be slightly cleaner with usage of  <code>*args, **kwargs</code>: <code>def cacheHelper(folder='../cache/', *args, **kwargs):     return cacheHelperOriginal(folder=folder, *args, **kwargs)</code></span>
<span class="comment-copy">OP is <i>not</i> looking for a singleton. OP originally wanted to call <code>cacheHelper()</code> to create a new instance of the object whenever they need it but that would require to pass the correct path all the time hence this question. There is not a single word about that the cache helper should be the same instance all the time.</span>
