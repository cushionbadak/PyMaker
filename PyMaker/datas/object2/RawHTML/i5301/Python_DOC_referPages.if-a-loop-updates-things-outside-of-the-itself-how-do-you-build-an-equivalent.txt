<div class="post-text" itemprop="text">
<p>The question is how to use list comprehension/lambda+maps (in order to push the task of performing the actual loop to the underlying c) when the loop references and updates things outside of itself?</p>
<p>My example is this:</p>
<pre><code>words = []
wordCount = {}

for i in tqdm_notebook(range (0,len(sentences_wiki))):
   sentences_wiki[i]
     for j in range (0,len(sentences_wiki[i])):
       word = sentences_wiki[i][j]
       if word not in words:
         words.append(word)
         wordCount[word]= 1
       else:
         wordCount[word] = wordCount[word] + 1 
</code></pre>
<p>Note sentences_wiki is a an array of sentences - each of which is an array of words.</p>
<p>As an attempt I ended up with the following non functional example</p>
<pre><code>def blah(listy_words,words,wordCount):
  if word not in listy_words:
    words.append(word)
    wordCount[word]= 1
  else:
    wordCount[word] = wordCount[word] + 1     
  return(words)

words = []
wordCount = {}

a = map(lambdap:list(map(blah(p, words, wordCount), sentences_wiki[i])), sentences_wiki)
p=list(a)
</code></pre>
<p>I</p>
</div>
<div class="post-text" itemprop="text">
<p>You shouldn't use <code>map</code> or a list comprehension just for the side effects of the function you're applying. You should only use it when the resulting list contains meaningful data. In your case, you'd be creating a big nested list of lists containing a whole bunch of repeated references to the same <code>words</code> list you created at the global level. That's not useful at all.</p>
<p>Furthermore, your entire reason for making the change seems to be based on the premise that using <code>map</code> or a comprehension is sure to be faster. That's probably not true. They may be about the same speed, or may be slower. I think it's very unlikely that anything you can do will make the comprehension/<code>map</code> version faster than the explicit loop. The main reason is that function calls in Python are pretty slow, and so the need to pack some of the loop logic into a function makes that part slower than it was with the explicit loops.</p>
<p>What often can be faster is using builtin functions or types to do the iteration for you in C without ever reaching back out to Python code. In your example, you want to be counting the words in your list of lists, so using <code>collections.Counter</code> is probably a good idea. I'd probably do something like this, eliminating the inner loop while keeping the outer one:</p>
<pre><code>from collections import Counter

word_counts = Counter()
for sentence in sentences_wiki:
    word_counts.update(sentence)
words = list(word_counts) # get a list of keys, if you really need it separate from the count
</code></pre>
<p>As <a href="https://stackoverflow.com/users/6779307/patrick-haugh">Patrick Haugh</a> commented, it's even possible to eliminate both loops using <code>itertools</code> if you want to create the counter in one line:</p>
<pre><code>import itertools
from collections import Counter

word_counts = Counter(itertools.chain.from_iterable(sentences_wiki))
words = list(word_counts)
</code></pre>
</div>
<span class="comment-copy">List comprehensions and lambda+map don't push the work into C.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">docs.python.org/3/library/collections.html#collections.Counter</a></span>
<span class="comment-copy">Don't. Comprehensions and lambdas are great tools, but using them for this is putting a square peg in a round hole.  Here, I would either use a <code>for</code> loop, or maybe something like <code>collections.Counter(itertools.chain.from_iterable(sentences_wiki))</code></span>
<span class="comment-copy">Thank you, your answer is very clear.</span>
