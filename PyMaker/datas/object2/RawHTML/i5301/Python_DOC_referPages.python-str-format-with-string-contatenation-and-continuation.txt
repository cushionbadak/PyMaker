<div class="post-text" itemprop="text">
<p>I'd like to specify a string with both line continuation and catenation characters. this is really useful if I'm echoing a bunch of related values. Here is a simple example with only two parameters:</p>
<pre><code>temp = "here is\n"\
    +"\t{}\n"\
    +"\t{}".format("foo","bar")
print(temp)
</code></pre>
<p>here's what I get:</p>
<pre><code>here is
    {}
    foo
</code></pre>
<p>And here is what I expect:</p>
<pre><code>here is
    foo
    bar
</code></pre>
<p>What gives?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try something like this :</p>
<pre><code>temp = ("here is\n"
        "\t{}\n"
        "\t{}".format("foo","bar"))
print(temp)
</code></pre>
<p>Or like :</p>
<pre><code># the \t have been replaced with
# 4 spaces just as an example
temp = '''here is
    {}
    {}'''.format

print(temp('foo', 'bar'))
</code></pre>
<p>vs. what you have:</p>
<pre><code>a = "here is\n"
b = "\t{}\n"
c = "\t{}".format("foo","bar")
print( a + b + c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>str.format</code> is called before your strings are concatenated. Think of it like <code>1 + 2 * 3</code>, where the multiplication is evaluated before the addition.</p>
<p>Just wrap the whole string in parentheses to indicate that you want the strings concatenated before calling <code>str.format</code>:</p>
<pre><code>temp = ("here is\n"
      + "\t{}\n"
      + "\t{}").format("foo","bar")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python in effect sees this:</p>
<pre><code>Concatenate the result of
    "here is\n"
with the resuslt of
    "\t{}\n"
with the result of
    "\t{}".format("foo","bar")
</code></pre>
<p>You have 3 separate string literals, and only the last one has the <code>str.format()</code> method applied.</p>
<p>Note that the Python interpreter is concatenating the strings <em>at runtime</em>.</p>
<p>You should instead use <em>implicit string literal concatenation</em>. Whenever you place two string literals side by side in an expression <em>with no other operators in between</em>, you get a single string:</p>
<pre><code>"This is a single" " long string, even though there are separate literals"
</code></pre>
<p>This is stored with the bytecode as a single constant:</p>
<pre><code>&gt;&gt;&gt; compile('"This is a single" " long string, even though there are separate literals"', '', 'single').co_consts
('This is a single long string, even though there are separate literals', None)
&gt;&gt;&gt; compile('"This is two separate" + " strings added together later"', '', 'single').co_consts
('This is two separate', ' strings added together later', None)
</code></pre>
<p>From the <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-literal-concatenation" rel="nofollow noreferrer"><em>String literal concatenation</em> documentation</a>:</p>
<blockquote>
<p>Multiple adjacent string or bytes literals (delimited by whitespace), possibly using different quoting conventions, are allowed, and their meaning is the same as their concatenation. Thus, <code>"hello" 'world'</code> is equivalent to <code>"helloworld"</code>.</p>
</blockquote>
<p>When you use implicit string literal concatenation, any <code>.format()</code> call at the end is applied to that <em>whole, single string</em>.</p>
<p>Next, you don't want to use <code>\</code> backslash line continuation. Use parentheses instead, it is cleaner:</p>
<pre><code>temp = (
    "here is\n"
    "\t{}\n"
    "\t{}".format("foo","bar"))
</code></pre>
<p>This is called <a href="https://docs.python.org/3/reference/lexical_analysis.html#implicit-line-joining" rel="nofollow noreferrer"><em>implicit line joining</em></a>.</p>
<p>You might also want to learn about <em>multiline</em> string literals, where you use three quotes at the start and end. Newlines are allowed in such strings and remain part of the value:</p>
<pre><code>temp = """\
here is
\t{}
\t{}""".format("foo","bar")
</code></pre>
<p>I used a <code>\</code> backslash after the opening <code>"""</code> to escape the first newline.</p>
</div>
<div class="post-text" itemprop="text">
<p>The format function is only being applied to the last string.</p>
<pre><code>temp = "here is\n"\
    +"\t{}\n"\
    +"\t{}".format("foo","bar")
</code></pre>
<p>Is doing this:</p>
<pre><code>temp = "here is\n" + "\t{}\n"\ + "\t{}".format("foo","bar")
</code></pre>
<p>The key is that the <code>.format()</code> function is only happening to the last string:</p>
<pre><code>"\t{}".format("foo","bar")
</code></pre>
<p>You can obtain the desired result using parentheses:</p>
<pre><code>temp = ("here is\n"\
    +"\t{}\n"\
    +"\t{}").format("foo","bar")
print(temp)

#here is
#   foo
#   bar
</code></pre>
</div>
<span class="comment-copy">Your second solution will have 2 additional "\n", you need to remove the 2 typed "\n".</span>
<span class="comment-copy">For your second code block, you'll have to use <code>temp = '''\</code> to make the whitespace consistent.</span>
<span class="comment-copy">Just remove the <code>+</code> concatenation, and leave it to the compiler to concatenate the literals.</span>
<span class="comment-copy">@MartijnPieters: I'll take the performance hit if it means clearer code. Implicit string concatenation has caused me more than enough problems.</span>
