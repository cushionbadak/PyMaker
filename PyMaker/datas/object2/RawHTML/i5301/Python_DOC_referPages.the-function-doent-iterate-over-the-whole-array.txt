<div class="post-text" itemprop="text">
<p>I have the following code which gets two arrays and finds the location of each item in the second array based on the first array. For example, for 23 from <code>loc1</code>, which is between 20 and 25 in array it should return 20.</p>
<pre><code>matrix_x = []
def binarySearch(alist, loc):
    for item in loc:
        midpoint = len(alist)//2
        if midpoint == 1:
            if item&lt;alist[midpoint]:
                return matrix_x.append(alist[midpoint-1])
            else:
                return matrix_x.append(alist[midpoint])         
        else:
            if item&lt;alist[midpoint]:
                return binarySearch(alist[:midpoint],loc)
            else:
                return binarySearch(alist[midpoint:],loc)
    return matrix_x

array = [5,10,15,20,25]
loc1= [23,7,11]

print(binarySearch(array, loc1))
print(matrix_x)
</code></pre>
<p>I expect to receive this array as the result:</p>
<pre><code>[20,5,10]
</code></pre>
<p>But I receive only the first item like this:</p>
<pre><code>[20]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just use the <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code> module</a>:</p>
<pre><code>import bisect

def binarySearch(alist, loc):
    return [alist[bisect.bisect(alist, i) - 1] for i in loc]

array = [5,10,15,20,25]
loc1= [23,7,11]
print(binarySearch(array, loc1))
</code></pre>
<p>Output:</p>
<pre><code>[20, 5, 10]
</code></pre>
<p>Finding the index is simpler:</p>
<pre><code>def binarySearchIndex(alist, loc):
    return [bisect.bisect(alist, i) - 1 for i in loc]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're returning the <code>matrix_x.append</code> statement, so it only ever appends 1 item, in this case <code>20</code>. To get the behavior you want, you may need to restructure your function some. </p>
</div>
<span class="comment-copy">remove the <code>return</code> keyword by using the return statement you end the script  execution.</span>
<span class="comment-copy">Your algorithm is questionable as it combined two very different features into a single function; my recommendation is to decouple the two, first being the recursive <code>binarySearch</code> into its own thing that takes the list and <b>one</b> location, the other being the iteration through the list of locations and passing that to the decoupled <code>binarySearch</code> function.</span>
<span class="comment-copy">Thanks it works. Your solution is the best! Do you know how can we get the index of each item instead of the item itself? For example, in this question, it should give me [4, 0, 1].</span>
<span class="comment-copy">Updated my answer.</span>
<span class="comment-copy">Great that it helped. BTW, you have the privilege to <a href="http://stackoverflow.com/help/privileges/vote-up">upvote</a>. ;)</span>
<span class="comment-copy">Thanks. I receive this error: IOPub data rate exceeded.</span>
<span class="comment-copy">This is problem with <a href="https://stackoverflow.com/questions/43288550/iopub-data-rate-exceeded-when-viewing-image-in-jupyter-notebook">Jupyter Notebook</a>.</span>
