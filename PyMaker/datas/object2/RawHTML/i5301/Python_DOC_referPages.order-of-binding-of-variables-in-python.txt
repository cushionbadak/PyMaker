<div class="post-text" itemprop="text">
<p>I'm trying to modify a function which uses a module-level variable variable defined below it, similar to this:</p>
<pre><code>def say_hello():
    print(MESSAGE)

MESSAGE = "Hello, world!"

say_hello()
</code></pre>
<p>I would like to make the message a parameter, like so:</p>
<pre><code>MESSAGE = "Hello, world!"

def say_hello(message=MESSAGE):
    print(message)

say_hello()
</code></pre>
<p>I've noticed that in order for this to work, I had to move the definition of <code>MESSAGE</code> up in the code. Apparently, all module-levels are first 'bound' and are then available within function bodies, but when provided as default function arguments, they have to be defined before the function. Is this correct? </p>
<p>(I would also like to read up on this to fully understand it; any references would be much appreciated).</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>... when provided as default function arguments, they have to be defined before the function. Is this correct?</p>
</blockquote>
<p>Correct.  Default arguments are evaluated at function <em>definition</em> time.  </p>
<p>If you need them evaluated at function <em>call</em> time, this common pattern works:</p>
<pre><code>def say_hello(message=None):
    if message is None:
        message = MESSAGE
    print(message)

MESSAGE = "Hello, world!"

say_hello()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def say_hello():
    print(MESSAGE)
#         ^^^^^^^ This...
</code></pre>
<p>...is evaluated when <code>say_hello</code> is <em>called</em>. As long as <code>MESSAGE</code> has been assigned by the time <code>say_hello</code> is called, <code>say_hello</code> will see the value.</p>
<pre><code>#                     vvvvvvv This...
def say_hello(message=MESSAGE):
    print(message)
</code></pre>
<p>...is evaluated when <code>say_hello</code> is <em>defined</em>. Python evaluates default argument values at function definition time, so <code>MESSAGE</code> has to be assigned before <code>say_hello</code> is even defined for this to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>While you're learning about default argument binding, give this a try:</p>
<pre><code>def foo(bar=[]):
    bar.append(3)
    print(bar)

baz = []
faz = []

foo(baz)
foo(faz)

foo()
foo()
</code></pre>
<p>The calls with their own arguments will do what you expect - each one prints only one variable.  But the calls to foo with the default argument may surprise you.  The first time you call it, you get the expected result: <code>[3]</code>.  The second time you call it, you may be surprised that the result is <code>[3, 3]</code>.</p>
<p>There's actually nothing in this answer that isn't in the others.  As others have said, the default argument is evaluated at the time the function is defined.  What you see here is a consequence of that - the arguments are evaluated <strong>only</strong> at the time that the function is defined.  <code>bar=[]</code> is evaluated once, giving you one list.</p>
<p>If you do object creation or function calls as part of your default argument, they only happen once, with the net result being a surprisingly static-acting argument.  Most of the time, this is not what we're looking for.</p>
<p>The definitive reference for python is found at docs.python.org .  The specific reference for defining functions is at <a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/controlflow.html#defining-functions</a>.</p>
</div>
<span class="comment-copy">Thanks, I was indeed looking for something like this, since in my 'real' application the <code>MESSAGE</code> takes up many lines and would detract attention from the actual code.</span>
