<div class="post-text" itemprop="text">
<p>I'm in an argument with my lecturer -- he insists that an object can be passed to mock.patch as value of side_effect to mock out an original function in program, while still taking the arguments passed to that function -- in this particular case, storing them inside the object.</p>
<p>Basically:</p>
<pre><code>with mock.patch('function_to_be_mocked', side_effect=my_object) as m:
    function_to_be_mocked(arg1, arg2)
</code></pre>
<p>After these two lines of code, arg1 and arg2 will be stored as attributes in my_object.</p>
<p>However according to documentation for <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow noreferrer">side_effect</a>, the only objects that can be passed to side_effect are either Exceptions or  iterables, and neither cares about the arguments passed to original function.</p>
<p>I tried to point out this error, but my lecturer said there's a way to get it around.</p>
<p>Is there actually a way to do it, or just my lecturer refused to admit his mistake?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think he is right. We can assign callables to side_effect, and the callable will be called with the same arguments the <code>function_to_be_mocked</code> was called with <code>arg1</code>, <code>arg2</code>.</p>
<p>source and examples:
<a href="https://docs.python.org/3.6/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow noreferrer">https://docs.python.org/3.6/library/unittest.mock.html#unittest.mock.Mock.side_effect</a></p>
</div>
