<div class="post-text" itemprop="text">
<p>I have 2 lists </p>
<pre><code>list_a = [1, 1, 2, 2, 4, 5]
list_b = ['good', 'bad', 'worst', 'cheap', 'waste', 'waste1']
</code></pre>
<p>I am trying to write a python script and my mapping element in <code>list_a</code> with element in <code>list_b</code> and  if someone inputs value <code>1</code> all the related values should populate. Eg if I enter <code>1</code> as input parameter the output should be</p>
<pre><code>good
bad
</code></pre>
<p>if I enter <code>2</code> as input parameter output should be</p>
<pre><code>worst
cheap
</code></pre>
<p>I tried python dictionaries but dictionary is not allowing duplicate keys. Is there is a way to achieve this in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>A rare use case for <a href="https://docs.python.org/3/library/itertools.html#itertools.compress" rel="nofollow noreferrer"><code>itertools.compress</code></a>:</p>
<pre><code>idx = get_index(...)  # Get index to check by whatever means

for x in itertools.compress(list_b, (idx == i for i in list_a)):
    print(x)
</code></pre>
<p><code>compress</code> takes an iterable of values, and an iterable of "truthy or falsy" values, returning the items from the first iterable when the second iterable provides a truthy paired value. So in this case, we want items from <code>list_b</code>, when the value in <code>list_a</code> matches the provided index, which we compute on the fly with a generator expression.</p>
<p>Mind you, for repeated lookups, a <code>dict</code> is a better bet. Simply using:</p>
<pre><code>lookup = {1: ['good', 'bad'], 2: ['worst', 'cheap'], 4: ['waste'], 5: ['waste1']}
</code></pre>
<p>will allow you to efficiently do <code>for x in lookup[idx]: print(x)</code> as many times as needed (possibly catching <code>KeyError</code> to ignore the case when the key doesn't exist, or to produce a friendlier error message).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simply create the dictionary out of the two lists. Might save some of your typing...</p>
<pre><code>list_a = [1, 1, 2, 2, 4, 5]
list_b = ['good', 'bad', 'worst', 'cheap', 'waste', 'waste1']

d = {}
for x, y in zip(list_a, list_b):
  if d.get(x):
    d[x] += [y]
  else:
    d[x] = [y]

print(d[2])
</code></pre>
</div>
<span class="comment-copy">Hint: your dictionary values can be lists.</span>
<span class="comment-copy">Dictionaries can contain lists like <code>{1: ['good', 'bad'], 4: ['waste']}</code></span>
<span class="comment-copy">I got this idea. Is there is a way to do this?</span>
<span class="comment-copy">He literally just typed it for you.</span>
<span class="comment-copy">Why is it rare?</span>
<span class="comment-copy">@swimingduck: Because it's really only useful for doing a single streaming pass of huge data (inputs too large to hold in memory at once); for multiple passes and/or small data, you could just make a lookup <code>dict</code> of the form I added in my edit.</span>
<span class="comment-copy">@ShadowRanger Thanks for the solution. Could you please let me know how can we generate lookup = {1: ['good', 'bad'], 2: ['worst', 'cheap'], 4: ['waste'], 5: ['waste1']} from above lists</span>
<span class="comment-copy">@sudhir: <code>result = collections.defaultdict(list)</code>, <code>for k, v in zip(list_a, list_b): result[k].append(v)</code>, <code>result = dict(result)</code> (last bit optional, to convert back to plain <code>dict</code> that won't auto-vivify missing keys).</span>
<span class="comment-copy">Awesome. This is what I am looking. I am so dumb I have been using tuple(zip(list_a, list_b)) instead of dict</span>
