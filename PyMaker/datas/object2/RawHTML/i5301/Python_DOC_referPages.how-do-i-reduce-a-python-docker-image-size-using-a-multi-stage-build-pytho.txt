<div class="post-text" itemprop="text">
<p>I am looking for a way to create multistage builds with python and Dockerfile:</p>
<p>For example, using the following images: </p>
<p><strong>1st image</strong>: install all compile time requirements, and install all needed python modules</p>
<p><strong>2nd image</strong>: copy all compiled / built packages from first image to the second, without the compilers themselves (gcc, postgers-dev, python-dev etc..)</p>
<p>The final objcetive is to have a smaller image, running python and the python packages that I need. </p>
<p>In short: <strong>how can I 'wrap' all the compiled modules</strong> (site-packages / external libs) that were created in the first image, and <strong>copy them in a 'clean' manner</strong>, to the 2nd image.</p>
</div>
<div class="post-text" itemprop="text">
<p>ok so my solution is using wheel, it lets us compile on first image, create wheel files for all dependencies and install them in the second image, without installing the compilers</p>
<pre><code>FROM python:2.7-alpine as base

RUN mkdir /svc
COPY . /svc
WORKDIR /svc

RUN apk add --update \
    postgresql-dev \
    gcc \
    musl-dev \
    linux-headers

RUN pip install wheel &amp;&amp; pip wheel . --wheel-dir=/svc/wheels

FROM python:2.7-alpine

COPY --from=base /svc /svc

WORKDIR /svc

RUN pip install --no-index --find-links=/svc/wheels -r requirements.txt
</code></pre>
<p>You can see my answer regarding this in the following blog post</p>
<p><a href="https://galnevis.wixsite.com/website/single-post/2018/02/10/Python-and-Docker-multistage-build" rel="nofollow noreferrer">https://galnevis.wixsite.com/website/single-post/2018/02/10/Python-and-Docker-multistage-build</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I hope the following examples helps</p>
<pre><code>FROM yourbaseimage as builder

RUN echo install dependencies etc. \
 &amp;&amp; echo build

FROM yoursmallbaseimage

RUN mkdir -p /bin/

COPY --from=builder /bin/binary /bin/binary

#[...]

ENTRYPOINT ["/bin/binary"]
</code></pre>
<p>you can also tar them in the first building image and extract the image in the smaller base image.
or create a official package like deb, rpm with only the minimum of files.
maybe you only need base python and a venv which you could transfer as a tar etc.</p>
<p>it is easier to find infos to make a clean package for your task - so you can google whats the best for your project and maybe install the package</p>
</div>
<div class="post-text" itemprop="text">
<p>The docs on this explain exactly how to do this.</p>
<p><a href="https://docs.docker.com/engine/userguide/eng-image/multistage-build/#before-multi-stage-builds" rel="nofollow noreferrer">https://docs.docker.com/engine/userguide/eng-image/multistage-build/#before-multi-stage-builds</a></p>
<p>Basically you do exactly what you've said. The magic of multistage build feature though is that you can do this all from one dockerfile.</p>
<p>ie:</p>
<pre><code>FROM golang:1.7.3
WORKDIR /go/src/github.com/alexellis/href-counter/
RUN go get -d -v golang.org/x/net/html  
COPY app.go .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest  
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=0 /go/src/github.com/alexellis/href-counter/app .
CMD ["./app"]  
</code></pre>
<p>This builds a go binary, then the next image runs the binary. The first image has all the build tools and the seccond is just a base linux machine that can run a binary.</p>
</div>
<span class="comment-copy">did you figure out how to do this? i need to do the same</span>
<span class="comment-copy">i ended up removing compile time dependencies after installing project dependencies. i wrote this post describing the solution <a href="https://galnevis.wixsite.com/website/single-post/2018/02/08/Docker---Reduced-image-size-and-reduced-build-time---design-pattern" rel="nofollow noreferrer">galnevis.wixsite.com/website/single-post/2018/02/08/â€¦</a></span>
<span class="comment-copy">This is very helpful! You still have the wheels files in the result though, in addition to their installed form. I guess using Rocker is the right solution, since Docker refuses to give us mounting during builds.</span>
<span class="comment-copy">Important note - instead of /shadow_reporting/wheels it should be /srv/wheels or any other dir you copy wheels to</span>
<span class="comment-copy">this is a general solution and not a python specific</span>
<span class="comment-copy">what i am looking for is a way packing all the dependencies (like egg / wheel file), to execute the copy command with</span>
<span class="comment-copy">I just did this: COPY --from=base /usr/local /usr/local. Since all python installs are in /usr/local/lib/pythonXX/site-packages. I got the whole /usr/local to get the bin as well, but the trick works.</span>
<span class="comment-copy">this is a general solution and not a python specific</span>
<span class="comment-copy">adapt it to what you need... get a linux image install postgresql on it or whatever build tools you need etc... This gets you the light final image you requested, you then need to use whatever the bundling system that suits you. <a href="https://docs.python.org/3/library/zipapp.html" rel="nofollow noreferrer">docs.python.org/3/library/zipapp.html</a></span>
<span class="comment-copy">so what exactly do you need to copy from first image to work in the second image, that is the question.. "adapt it to what you need" does not help at all</span>
