<div class="post-text" itemprop="text">
<p>I would like to be able to keep track of instances of geometric Point objects in order to know what names are already "taken" when automatically naming a new one. </p>
<p>For instance, if Points named "A", "B" and "C" have been created, then the next automatically named Point is named "D". If Point named "D" gets deleted, or its reference gets lost, then name "D" becomes available again.</p>
<p>The main attributes of my <code>Point</code> objects are defined as properties and are the quite standard <code>x</code>, <code>y</code> and <code>name</code>.</p>
<h2>Solution with a problem and a "heavy" workaround</h2>
<p>I proceeded as described <a href="https://stackoverflow.com/a/18321898/3926735">here</a>, using a <code>weakref.WeakSet()</code>. I added this to my <code>Point</code> class:</p>
<pre><code># class attribute
instances = weakref.WeakSet()

@classmethod
def names_in_use(cls):
    return {p.name for p in Point.instances}
</code></pre>
<p>Problem is, when I instanciate a Point and then delete it, it is most of the time, but not <em>always</em>, removed from <code>Point.instances</code>. I noticed that, if I run the tests suite (<code>pytest -x -vv -r w</code>), then <strong>if a certain exception is raised in the test</strong>, then the instance <strong>never</strong> gets deleted (probable explanation to be read somewhat below).</p>
<p>In the following test code, after the first deletion of <code>p</code>, it always gets removed from <code>Point.instances</code>, but after the second deletion of <code>p</code>, it never gets deleted (test results are always the same) and the last <code>assert</code> statement fails:</p>
<pre><code>def test_instances():
    import sys
    p = Point(0, 0, 'A')
    del p
    sys.stderr.write('1 - Point.instances={}\n'.format(Point.instances))
    assert len(Point.instances) == 0
    assert Point.names_in_use() == set()
    p = Point(0, 0, 'A')
    with pytest.raises(TypeError) as excinfo:
        p.same_as('B')
    assert str(excinfo.value) == 'Can only test if another Point is at the ' \
        'same place. Got a &lt;class \'str\'&gt; instead.'
    del p
    sys.stderr.write('2 - Point.instances={}\n'.format(Point.instances))
    assert len(Point.instances) == 0
</code></pre>
<p>And here the result:</p>
<pre><code>tests/04_geometry/01_point_test.py::test_instances FAILED

=============================================================================== FAILURES ===============================================================================
____________________________________________________________________________ test_instances ____________________________________________________________________________

    def test_instances():
        import sys
        p = Point(0, 0, 'A')
        del p
        sys.stderr.write('1 - Point.instances={}\n'.format(Point.instances))
        assert len(Point.instances) == 0
        assert Point.names_in_use() == set()
        p = Point(0, 0, 'A')
        with pytest.raises(TypeError) as excinfo:
            p.same_as('B')
        assert str(excinfo.value) == 'Can only test if another Point is at the ' \
            'same place. Got a &lt;class \'str\'&gt; instead.'
        del p
        sys.stderr.write('2 - Point.instances={}\n'.format(Point.instances))
&gt;       assert len(Point.instances) == 0
E       assert 1 == 0
E        +  where 1 = len(&lt;_weakrefset.WeakSet object at 0x7ffb986a5048&gt;)
E        +    where &lt;_weakrefset.WeakSet object at 0x7ffb986a5048&gt; = Point.instances

tests/04_geometry/01_point_test.py:42: AssertionError
------------------------------------------------------------------------- Captured stderr call -------------------------------------------------------------------------
1 - Point.instances=&lt;_weakrefset.WeakSet object at 0x7ffb986a5048&gt;
2 - Point.instances=&lt;_weakrefset.WeakSet object at 0x7ffb986a5048&gt;
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Interrupted: stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
================================================================= 1 failed, 82 passed in 0.36 seconds ==================================================================
</code></pre>
<p>Yet, the code tested in the catched exception does not create a new Point instance:</p>
<pre><code>def same_as(self, other):
    """Test geometric equality."""
    if not isinstance(other, Point):
        raise TypeError('Can only test if another Point is at the same '
                        'place. Got a {} instead.'.format(type(other)))
    return self.coordinates == other.coordinates
</code></pre>
<p>and coordinates are basically:</p>
<pre><code>@property
def coordinates(self):
    return (self._x, self._y)
</code></pre>
<p>where <code>_x</code> and <code>_y</code> basically contain numbers.</p>
<p>The reason seems to be (quoting from <a href="https://docs.python.org/3/reference/datamodel.html#object.__del__" rel="noreferrer">python's doc</a>):</p>
<blockquote>
<p>CPython implementation detail: It is possible for a reference cycle to prevent the reference count of an object from going to zero. In this case, the cycle will be later detected and deleted by the cyclic garbage collector. A common cause of reference cycles is when an exception has been caught in a local variable.</p>
</blockquote>
<h2>The workaround</h2>
<p>Adding this method to <code>Point</code> class:</p>
<pre><code>def untrack(self):
    Point.instances.discard(self)
</code></pre>
<p>and using <code>myPoint.untrack()</code> before <code>del myPoint</code> (or before losing reference to the Point in another way) seems to solve the problem.</p>
<p>But this is quite heavy to have to call <code>untrack()</code> each time... in my tests there are a lot of Points I will need to "untrack" only to ensure all names are available, for instance.</p>
<h2>Question</h2>
<p>Is there any better way to keep track of these instances? (either by improving the tracking method used here, or by any other better mean).</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't try to track available names based on all <code>Point</code> objects that exist in the entire program. Predicting what objects will exist and when objects will cease to exist is difficult and unnecessary, and it will behave very differently on different Python implementations.</p>
<p>First, why are you trying to enforce Point name uniqueness at all? If, for example, you're drawing a figure in some window and you don't want two points with the same label in the same figure, then have the figure track the points in it and reject a new point with a taken name. This also makes it easy to explicitly remove points from a figure, or have two figures with independent point names. There are a number of other contexts where a similar explicit container object may be reasonable.</p>
<p>If these are free-floating points not attached to some geometry environment, then why name them at all? If I want to represent a point at (3.5, 2.4), I don't care whether I name it A or B or Bob, and I certainly don't want a crash because some other code somewhere halfway across the program decided to call their point Bob too. Why do names or name collisions matter?</p>
<p>I don't know what your use case is, but for most I can imagine, it'd be best to either only enforce name uniqueness within an explicit container, or not enforce name uniqueness at all.</p>
</div>
<span class="comment-copy">Agreed. This strikes me as an instinct that a C++ programmer might have, where you are working with explicit destructors to free objects from memory, in which case, this could make some sense or at least be reliable. But at the end of the day, that is essentially like calling <code>untrack</code>. The Python solution is definitely to create some container that does the tracking.</span>
