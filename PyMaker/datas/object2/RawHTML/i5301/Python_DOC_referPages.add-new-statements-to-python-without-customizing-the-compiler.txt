<div class="post-text" itemprop="text">
<p>I'd like to add a new keyword to Python and @EliBendersky's <a href="https://stackoverflow.com/a/9108164/198825">wonderful answer</a> explains how to do this by changing the code and re-distributing   the Python compiler.</p>
<p>Is it possible to introduce a new keyword <strong>without</strong> changing the compiler code? Perhaps introduce it through a library?</p>
<p><strong>Edit:</strong></p>
<p>For example, I'd like to add a shorthand for regex matching by adding a keyword like <code>matches</code> that can be used like:</p>
<pre><code>"You can't take the sky from me" matches '.+sky.+'
</code></pre>
<p>I can add new, custom behavior using AST transformations, but the above case will fail on a syntax error. </p>
</div>
<div class="post-text" itemprop="text">
<h3>One cannot introduce a new keyword without changing the language</h3>
<p>The parser is the tool/program that reads through the code, and decides what makes sense and what doesn't.
Although it's a rather coarse definition, the consequence is that the language is <strong>defined</strong> by its parser.</p>
<p>The parser relies on the language's (formal) grammar, specified in the <a href="https://docs.python.org/3/library/ast.html#abstract-grammar" rel="nofollow noreferrer"><code>ast</code> module documentation</a>.</p>
<p>While defining a mere function only introduces a new feature without modifying the language, adding a keyword is tantamount to introducing a new syntax, which in turn changes the language's grammar.</p>
<p>Therefore, adding a new keyword, in the sense of adding a new syntax to a language, cannot be made without changing the grammar's language, which requires editing the compilation and execution chain.</p>
<h3>However...</h3>
<p>There might be some smart ways to introduce a new feature, that looks like a new syntax but in fact only uses the existing syntax.
For instance, the <a href="http://entrian.com/goto/" rel="nofollow noreferrer">goto module</a> relies on a not-so-well-known property of the language, that the spaces around a dot in a qualified identifier are ignored.</p>
<p>You can try this by yourself:</p>
<pre><code>&gt;&gt;&gt; l = [1, 2, 3]
&gt;&gt;&gt; l    .append(4)
&gt;&gt;&gt; l
[1, 2, 3, 4]
&gt;&gt;&gt; l.    append(5)
&gt;&gt;&gt; l
[1, 2, 3, 4, 5]
</code></pre>
<p>This allows using the following, that looks like a new syntax, but really is not:</p>
<pre><code>label .myLabel
goto .myLabel
</code></pre>
<p>Now, the <code>goto</code> module uses the way the interpreter internally works to perform break from one <code>goto</code> to a given <code>label</code>...
But that's another problem.</p>
<hr/>
<p>I'd like to add that Python is quite an open-minded language.
It provides a nice amount of seldom used operators, for instance, <code>@</code>.
This operator, introduced from Python 3.5, was primarily meant for matrix multiplication, and falls back to a call to <code>__matmul__</code>.
I have to say, I've never seen it in code.
So, why not use it for your purpose?</p>
<p>Let's do it step-by-step.
I propose to define a <code>r</code> class, that will behave as a regex.</p>
<pre><code>import re

class r:
    def __init__(self, pattern):
        self.regex = re.compile(pattern)
</code></pre>
<p>Now, I want to be able to use the <code>@</code> operator with this class, together with a string, with the semantic of a <code>match</code> between the string and the pattern.
I'll define the <code>__matmul__</code> method, just as follows:</p>
<pre><code>class r:
    def __matmul__(self, string):
        return bool(self.regex.match(string))
</code></pre>
<p>Now, I can do the following:</p>
<pre><code>&gt;&gt;&gt; r("hello") @ "hello"
True
&gt;&gt;&gt; r("hello"] @ "world"
False
</code></pre>
<p>Pretty nice, but not that yet.
I'll define the <code>__rmatmul__</code> method as well, so it merely falls back to a call to <code>__matmul__</code>.
In the end, the <code>r</code> class looks like this:</p>
<pre><code>class r:
    def __init__(self, pattern):
        self.regex = re.compile(pattern)

    def __matmul__(self, string):
        return bool(self.regex.match(string))

    def __rmatmul__(self, string):
        return self @ string
</code></pre>
<p>Now, the reverse operation works as well:</p>
<pre><code>&gt;&gt;&gt; "hello" @ r("hello")
True
&gt;&gt;&gt; "123456" @ r("\d+")
True
&gt;&gt;&gt; "abc def" @ r("\S+$")
False
</code></pre>
<p>This is very near from what you were attempting, except, I didn't have to introduce a new keyword!
Of course, now the <code>r</code> identifier must be protected, just like <code>str</code> or <code>list</code>...</p>
</div>
<div class="post-text" itemprop="text">
<p>For your particular "problem" (shorten the way to match a regex), a solution would be to create a subclass of <code>str</code> and use an unused binary operator (ex: minus, maybe a better choice could be done, unfortunately we cannot use <code>~</code> as it's unary)</p>
<p>example:</p>
<pre><code>import re

class MyStr(str):
    def __sub__(self,other):
        return re.match(other,self)

a = MyStr("You can't take the sky from me")
print(a - '.+sky.+')
print(a - '.+xxx.+')
</code></pre>
<p>result:</p>
<pre><code>&lt;_sre.SRE_Match object; span=(0, 30), match="You can't take the sky from me"&gt;
None
</code></pre>
<p>So "subbing" the regex from your string object returns the match object.</p>
<p>The disavantage is that now you have to write string literals wrapped in the new object (not possible to define this new operator into <code>str</code> itself)</p>
</div>
<span class="comment-copy">Out of curiosity, why?</span>
<span class="comment-copy">new keyword, well, seems difficult. But you could use <code>from xxx import yyy</code>: that defines <code>yyy</code> as a "keyword".</span>
<span class="comment-copy">No. keywords are built in to the lexer, which would need to be re-compiled. keywords are part of the official grammar definition.</span>
<span class="comment-copy">XY problem. You want your library used? stick to official python :)</span>
<span class="comment-copy">The bar for adding a keyword is very high, because by definition the compiler needs to recognize it, which precludes it from being used as an identifier <i>anywhere</i> else.</span>
<span class="comment-copy">Great idea. And I don't even need to add the new class. I can just transform it using AST</span>
