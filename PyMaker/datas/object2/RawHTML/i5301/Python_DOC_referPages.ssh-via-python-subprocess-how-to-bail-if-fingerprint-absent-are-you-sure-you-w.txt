<div class="post-text" itemprop="text">
<p>I'm using a python script to manage ssh fingerprint problems after a workstation(s) is reimaged.</p>
<p>I attempt to connect, and if I get a "REMOTE HOST IDENTIFICATION HAS CHANGED!" error, then script removes the old fingerprint, scans for the new one and adds it.</p>
<p>This all works great, until I get a message like this:</p>
<pre><code> Warning: the ECDSA host key for 'workstation-1-s' differs from the key for the IP address '192.168.1.132'
Offending key for IP in /home/me/.ssh/known_hosts:16
Matching host key in /home/me/.ssh/known_hosts:60
Are you sure you want to continue connecting (yes/no)?
</code></pre>
<p>The script waits for user input before continuing and removing the offending key.</p>
<p>How can I get the script to push through, or enter "no" so the script can continue with its fingerprint repair job?</p>
<p>Here's the relevant method:</p>
<pre><code>def ssh_fingerprint_changed(node):
    """
    Checks if a node's ssh fingerprint has changed or an old key is found, which can occur when a node is reimaged.
    It does this by attempting to connect via ssh and inspecting stdout for an error message.
    :param node: the ip or hostname of the node
    :return: True if the node's fingerprint doesn't match the client's records. Else False.
    """
    cmd = ["ssh", "-q", ADMIN_USER + "@" + node, "exit"]
    completed = subprocess.run(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    if completed.stdout.find("REMOTE HOST IDENTIFICATION HAS CHANGED!") == -1:
        print("REMOTE HOST IDENTIFICATION HAS CHANGED!")
        return True
    elif completed.stdout.find("Offending key") == -1:
        print("Offending key found.") # need to type "no" before this prints
        return True
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>run</code> (or legacy <code>call</code>) doesn't allow your controlling of the input/output of the process interactively. When you get the output, the process has already ended. So you're too late for the party.</p>
<p>Some would direct you to <code>pexpect</code>, or <code>paramiko</code> (which doesn't require calling <code>ssh</code> command).</p>
<p>Here's a workaround with <code>Popen</code>. I dropped your <code>return</code> logic. If you want to keep that, remember that at this point the process is still running, so you have to kill it (or wait for it to complete):</p>
<pre><code>cmd = ["ssh", "-q", ADMIN_USER + "@" + node, "exit"]
p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)
# loop on lines
for l in p.stdout:
    if b"Offending key" in l:
        print("Offending key found.")
        p.stdin.write(b"no\n")   # provide no + newline as the answer
rc = p.wait()  # wait for process to end, get return code
</code></pre>
<p>if you're sure that the only answer will be "no", and a given number of times, an alternative to the loop would be</p>
<pre><code>out,err = p.communicate(b"no\n"*10)  # send 10 times no+linefeed
</code></pre>
<p>note the "b" prefix when scanning strings/writing data, as standard input/output/error are binary. Doesn't matter in python 2, but in python 3, omitting the <code>b</code> compares strings with bytes, and you'll never get a match.</p>
<p>Aside, I've done that with <code>plink</code> on Windows, but after a while, I got tired and rebuilt a version of <code>plink</code> with all security messages disabled/defaulting to the "optimistic" value. If the network is a company network behind firewalls and you're going to answer anything to get pass those prompts, better create a non-interactive tool from the start.</p>
</div>
<span class="comment-copy">you need <code>Popen</code> with stdin redirected and provide <code>no</code> when you meet the message. Note that I have hacked my version of <code>plink</code> to get rid of some interactive stuff. But it's not safe.</span>
<span class="comment-copy">Can you provide an example with <code>Popen</code>?</span>
<span class="comment-copy">looking through the <code>Popen</code> docs, it suggests using  <code>Popen.communicate</code>.  Would that be better? <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">no because communicate doesn't allow you to filter the output line by line and decide what to reply. If you know that you're going to answer "no" a given number of times, then it's possible with comunicate.</span>
<span class="comment-copy">why the b in <code>b"Offending key</code> for the strings? doesn't <code>universal_newlines=True</code> cause <code>stdout</code> to be strings?</span>
<span class="comment-copy">it's different. It's CR+LF / LF conversion. Output is still <code>bytes</code> if using python 3.</span>
<span class="comment-copy">Last Q!  Can make a new question if you prefer.  Now I'm getting caught on the password request (if "offending key" is NOT found) but I can't <code>proc.terminate()</code> after the loop because it never reaches past the loop?</span>
