<div class="post-text" itemprop="text">
<p>I would like to re-implement my code using asyncio coroutines instead of multi-threading.</p>
<p>server.py</p>
<pre><code>def handle_client(client):
    request = None
    while request != 'quit':
        request = client.recv(255).decode('utf8')
        response = cmd.run(request)
        client.send(response.encode('utf8'))
    client.close()

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('localhost', 15555))
server.listen(8)

try:
    while True:
        client, _ = server.accept()
        threading.Thread(target=handle_client, args=(client,)).start()
except KeyboardInterrupt:
    server.close()
</code></pre>
<p>client.py</p>
<pre><code>server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.connect(('localhost', 15555))
request = None

try:
    while request != 'quit':
        request = input('&gt;&gt; ')
        if request:
            server.send(request.encode('utf8'))
            response = server.recv(255).decode('utf8')
            print(response)
except KeyboardInterrupt:
    server.close()
</code></pre>
<p>I know there are some appropriate asynchronous network librairies to do that. But I just want to only use asyncio core library on this case in order to have a better understanding of it.</p>
<p>It would have been so nice to only add async keyword before handle client definition... Here a piece of code which seems to work, but I'm still confused about the implementation.</p>
<p>asyncio_server.py</p>
<pre><code>def handle_client(client):
    request = None
    while request != 'quit':
        request = client.recv(255).decode('utf8')
        response = cmd.run(request)
        client.send(response.encode('utf8'))
    client.close()

def run_server(server):
    client, _ = server.accept()
    handle_client(client)

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('localhost', 15555))
server.listen(8)

loop = asyncio.get_event_loop()
asyncio.async(run_server(server))
try:
    loop.run_forever()
except KeyboardInterrupt:
    server.close()
</code></pre>
<p>How adapt this in the best way and using async await keywords.</p>
</div>
<div class="post-text" itemprop="text">
<p>The closest literal translation of the threading code would create the socket as before, and use <code>asyncio</code> <a href="https://docs.python.org/3/library/asyncio-eventloop.html#low-level-socket-operations" rel="nofollow noreferrer">low-level socket operations</a> to implement the server. Here is an example, sticking to the more relevant server part (the client is single-threaded and likely fine as-is):</p>
<pre><code>import asyncio, socket

async def handle_client(client):
    request = None
    while request != 'quit':
        request = (await loop.sock_recv(client, 255)).decode('utf8')
        response = str(eval(request)) + '\n'
        await loop.sock_sendall(client, response.encode('utf8'))
    client.close()

async def run_server():
    while True:
        client, _ = await loop.sock_accept(server)
        loop.create_task(handle_client(client))

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('localhost', 15555))
server.listen(8)
server.setblocking(False)

loop = asyncio.get_event_loop()
loop.run_until_complete(run_server())
</code></pre>
<p>The above works, but is not the intended way to use <code>asyncio</code>. While the correct abstraction will depend on the application, you probably want to at least utilize <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.start_server" rel="nofollow noreferrer"><code>asyncio.start_server</code></a> and not work with raw sockets. This significantly reduces the line count of code:</p>
<pre><code>async def handle_client(reader, writer):
    request = None
    while request != 'quit':
        request = (await reader.read(255)).decode('utf8')
        response = str(eval(request)) + '\n'
        writer.write(response.encode('utf8'))

loop = asyncio.get_event_loop()
loop.create_task(asyncio.start_server(handle_client, 'localhost', 15555))
loop.run_forever()
</code></pre>
<p>See <a href="https://docs.python.org/3.7/library/asyncio-stream.html#streams-coroutine-based-api" rel="nofollow noreferrer">the documentation</a> for additional details.</p>
</div>
<span class="comment-copy">Have you gone through some manner of tutorial entirely focused on <code>asyncio</code> yet?  It may be more prudent to do that first, instead of translating something you already have working.  I would recommend <a href="https://www.blog.pythonlibrary.org/2016/07/26/python-3-an-intro-to-asyncio/" rel="nofollow noreferrer">this</a> to start you off.</span>
<span class="comment-copy">I have updated the question. As I am still confused about the asyncio lib, I think this use case may be relevant for a better understanding.</span>
<span class="comment-copy">Thank you for this, I'm gonna try and send you a feedback.</span>
<span class="comment-copy">It works so fine, even if I'm still confused about why asynchronous and sockets seem to be such intricated to be wrapped in the same library...</span>
<span class="comment-copy">@srjjio Network (socket) programming constitutes a huge chunk of the <i>motivation</i> for needing asynchronous IO in the first place. An asyncio library that didn't provide support for sockets wouldn't be of much use.</span>
<span class="comment-copy">I see, thank you very much for your help @user4815162342</span>
<span class="comment-copy">Does this keep a socket open for each <i>client</i> or is a new socket created for each request/response?</span>
