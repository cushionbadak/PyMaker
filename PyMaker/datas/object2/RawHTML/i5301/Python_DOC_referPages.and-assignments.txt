<div class="post-text" itemprop="text">
<p>I was surprised to find the following, in Python 3, the first two raise nothing:</p>
<pre><code>&gt;&gt;&gt; [] = ()
&gt;&gt;&gt; () = ()
&gt;&gt;&gt; {} = ()
  File "&lt;stdin&gt;", line 1
SyntaxError: can't assign to literal
</code></pre>
<p>In Python 2.7, only the first one raises nothing:</p>
<pre><code>&gt;&gt;&gt; [] = ()
&gt;&gt;&gt; () = ()
  File "&lt;stdin&gt;", line 1
SyntaxError: can't assign to ()
&gt;&gt;&gt; {} = ()
  File "&lt;stdin&gt;", line 1
SyntaxError: can't assign to literal
</code></pre>
<p>What is going on here? Why are any of then not raising errors? And why was the <code>() = ()</code> presumably added to be valid in Python 3?</p>
<p>*Note, you can replace the right hand side with any empty iterable (e.g. <code>[] = set()</code>), I just choose an empty tuple for the illustration</p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://bugs.python.org/issue23275" rel="nofollow noreferrer">Issue23275</a>, these are basically quirks causing no real harm but also no utility. Note that <code>[] = ()</code> does not alter the <code>list</code> literal:</p>
<pre><code>&gt;&gt;&gt; [] = ()
&gt;&gt;&gt; type([])
&lt;class 'list'&gt;
</code></pre>
<p><code>[] = x</code> statements basically assert that <code>x</code> is iterable and that <code>x</code> is empty (although no-one would recommend using them this way), e.g.</p>
<pre><code>&gt;&gt;&gt; [] = (1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'int' object is not iterable
&gt;&gt;&gt; [] = (1,)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: too many values to unpack
</code></pre>
<p>As <a href="https://stackoverflow.com/users/95852/john-y">John Y</a> comments it is best to think of <code>[] = ()</code> as not an assignment but a way of being consistent with Python's iterable unpacking syntax.</p>
<p>As <a href="https://stackoverflow.com/users/4619006/arrowcase">ArrowCase</a> comments, this syntax also extends to multiple assignments:</p>
<pre><code>&gt;&gt;&gt; a = [] = ()
&gt;&gt;&gt; a
()
</code></pre>
<p>Looking at the CPython bytecode of the multiple assignment illustrates that this operations are similar to the normal iterable unpacking syntax, using the <a href="https://docs.python.org/3/library/dis.html#opcode-UNPACK_SEQUENCE" rel="nofollow noreferrer"><code>UNPACK_SEQUENCE</code></a> instruction:</p>
<pre><code>&gt;&gt;&gt; dis.dis('a = [] = ()')
  1           0 BUILD_TUPLE              0
              2 DUP_TOP
              4 STORE_NAME               0 (a)
              6 UNPACK_SEQUENCE          0
              8 LOAD_CONST               0 (None)
             10 RETURN_VALUE
&gt;&gt;&gt; dis.dis('[a, b] = (1, 2)')
  1           0 LOAD_CONST               3 ((1, 2))
              2 UNPACK_SEQUENCE          2
              4 STORE_NAME               0 (a)
              6 STORE_NAME               1 (b)
              8 LOAD_CONST               2 (None)
             10 RETURN_VALUE
</code></pre>
<p>The same Issue23275 states that <code>() = ()</code> was added as valid syntax to Python 3 for concordance. It was decided that removing <code>[] = ()</code> would break code needlessly, since it causes no harm and fits with iterable unpacking logic. <code>{} = ()</code> is still invalid because the unpacking syntax does not make sense in this context with braces.</p>
<p>In case anyone is wondering, syntax like <code>list() = ()</code> is simply syntactically invalid, because you can never assign to function call.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a way to assign variables from an iterable:</p>
<pre><code>&gt;&gt;&gt; a, b = iter((1, 2))
&gt;&gt;&gt; a
1
&gt;&gt;&gt; b
2
&gt;&gt;&gt; [c, d] = iter((4, 5))
&gt;&gt;&gt; c
4
&gt;&gt;&gt; d
5
</code></pre>
<p>The <code>[] = …</code> and <code>() = …</code> assignments seem to be special cases of these.</p>
</div>
<div class="post-text" itemprop="text">
<p>The left hand side of an assignment statement is <em>not</em> an expression, it is a <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="noreferrer">target list</a>. Short summary:</p>
<ul>
<li>If the target list is an identifier, the name is just bound to the right hand side. </li>
<li>If the target list is a comma seperated list of targets, the right hand side is unpacked and the unpacked elements are assigned to the listed targets.</li>
<li>A target list may be enclosed in parentheses or square brackets. In particular, that allows creating empty target lists, as seen in your examples.</li>
</ul>
<p>This explains why <code>[]</code> and <code>()</code> are valid left hand sides for assignments: they are valid target lists. However, <code>{}</code> is not, as it is not a valid target list. </p>
<p>Of course, <code>{}</code> might be part of a target, for example as the primary of a subscription: <code>{}[()] = 0</code> is valid python (but completely useless, of course).</p>
</div>
<div class="post-text" itemprop="text">
<p>This is syntax to unpack a two-element iterable into two assignment targets:</p>
<pre><code>[x, y] = whatever
</code></pre>
<p>This generalizes up to three or more targets, but it also generalizes down:</p>
<pre><code>[x] = whatever
</code></pre>
<p>unpacks a one-element iterable into one assignment target, and</p>
<pre><code>[] = whatever
</code></pre>
<p>unpacks a zero-element iterable into zero assignment targets (which does nothing if <code>whatever</code> is a zero-element iterable, and throws an exception if it's not).</p>
<p><code>() = whatever</code> also unpacks a zero-element iterable, but <code>{} = whatever</code> does not; there is no unpacking assignment syntax that involves braces.</p>
</div>
<span class="comment-copy">I knew it was about unpacking. Then I though, in JavaScript this was certainly not possible (it’s called destructuring there). I was completely surprised that things like <code>let [] = [];</code> and <code>({}) =&gt; 1</code> are valid in JS.</span>
<span class="comment-copy">Great question, never realise this was possible until now</span>
<span class="comment-copy">It should not be surprising that you can't assign (or unpack) an empty tuple to a <i>dictionary</i>.</span>
<span class="comment-copy">@Munir So you're saying you can't assign to a dict because  you can't assign to a dict? Not a very enlightening explanation...</span>
<span class="comment-copy">@StefanPochmann - You can't <i>actually</i> assign to a tuple or list either. But those are sequences, and as such you can <i>unpack</i> (assign sequentially) to their <b>elements</b>. A dictionary isn't a sequence, and it doesn't have "elements" per se, it has key-value pairs.</span>
<span class="comment-copy">@Munir But those do not do anything on the given iterable.</span>
<span class="comment-copy">@Munir No it's not the same. You can do <code>{}[0] = (1, 2)</code> but not <code>[] = (1, 2)</code>.</span>
<span class="comment-copy">You don't actually have to say <code>iter(...)</code>. You can simply do <code>a, b = 1, 2</code></span>
<span class="comment-copy">@DeepSpace There's no way glglgl doesn't know that. Looks intentional to me, to somewhat "anonymize" the tuple, to emphasize that it can be any iterable.</span>
<span class="comment-copy">@StefanPochmann Right. First I wanted to do something with <code>itertools</code> and looked for something like <code>limit</code> or so, but an arbitrary iterator yielding the right number of items seemed ok for me then.</span>
<span class="comment-copy">This should be the accepted answer. This behavior also explains why <code>[] = {}</code> and <code>() = {}</code> are possible, but not the reverse. The values in the dictionary can be iterated and assigned to the variables in the list/tuple, but it can't be reversed because the dictionary can't be used to hold a "list of variables" to assign to like the other two.</span>
<span class="comment-copy">It would be better to refer to the cases in question as degenerate rather than special. They arise from consistent application of behavior.</span>
