<div class="post-text" itemprop="text">
<p>I'm writing a specialised unit testing tool that needs to save the results of tests to be compared against in the future. Thus I need to be able to consistently map parameters that were passed to each test to the test result from running the test function with those parameters for each version. I was hoping there was a way to just hash the tuple and use that hash to name the files where I store the test results.</p>
<p>My first impulse was just to call <code>hash()</code> on the tuple of parameters, but of course that won't work since <code>hash</code> is randomized between interpreter instances now.</p>
<p>I'm having a hard time coming up with a way that works for whatever arbitrary elements that might be in the tuple (I guess restricting it to a mix of ints, floats, strings, and lists\tuples of those three would be okay). Any ideas?</p>
<p>I've thought of using the <code>repr</code> of the tuple or pickling it, but repr isn't guaranteed to produce byte-for-byte same output for same input, and I don't think pickling is either (is it?)</p>
<p>I've seen <a href="https://stackoverflow.com/questions/5884066/hashing-a-dictionary">this</a> already, but the answers are all based on that same assumption that doesn't hold anymore and don't really translate to this problem anyway, a lot of the discussion was about making the hash not depend on the order items come up and I do want the hash to depend on order.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if I understand your question fully, but will just give it a try.</p>
<p>Before you do the hash, just serialize the result to a JSON string, and do the hash computing on your JSON string.</p>
<pre><code>params = (1, 3, 2)
hashlib.sha224(json.dumps(params)).hexdigest()
# '5f0f7a621e6f420002d54ee28b0c169b8112ef72d8a6b60e6a25171c'
</code></pre>
<p>If your params is a dictionary, use sort_keys=True to ensure your keys are sorted. </p>
<pre><code>params = {'b': 123, 'c': 345}
hashlib.sha224(json.dumps(params, sort_keys=True)).hexdigest()
# '2e75966ce3f1185cbfb4eccc49d5552c08cfb7502a8765fe1dce9303'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One approach for simple tests would be to <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED" rel="nofollow noreferrer">disable the hash randomization entirely</a> by setting <code>PYTHONHASHSEED=0</code> in the environment that launches your script, e.g., in <code>bash</code>, doing:</p>
<pre><code>export PYTHONHASHSEED=0
</code></pre>
</div>
<span class="comment-copy">I would pickle the tuple of the parameters <i>and</i> the results into the same file whose name is the hashed tuple of parameters. That way, you should not need to worry about the randomization, because the original tuple is in the file.</span>
<span class="comment-copy">@DYZ Right, I'm doing that too, but I need the tuple to be hashed repeatably to be able to find the file in the first place.</span>
<span class="comment-copy">Is <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED" rel="nofollow noreferrer">disabling the hash randomization</a> acceptable?</span>
<span class="comment-copy">@ShadowRanger That... would work, I suppose, but it's horribly inelegant and does technically mean someone can DOS my CI server with a specially crafted merge request.</span>
<span class="comment-copy">@Schilcote: So if this is a public facing server, that's a bad idea; the question made it sound like this was just for repeatable (assumed local) unit tests.</span>
<span class="comment-copy">Is the JSON result guaranteed to be the same every time?</span>
<span class="comment-copy">@Schilcote For <i>lists</i> or <i>tuples</i> (and any stable primitives in such) it should be.</span>
<span class="comment-copy">If you're serializing a tupple / list, then yes.</span>
<span class="comment-copy">And for dictionaries, you can set <code>sort_keys</code> to <code>True</code>.</span>
<span class="comment-copy">@DYZ: A caution: <code>sort_keys</code> only works on Python 3 if the keys are homogeneous types (or otherwise have defined comparisons for all pairs of heterogeneous types, e.g. a mix of <code>int</code> and <code>float</code> is fine, but <code>int</code> and <code>str</code> is not). On Python 2, the fallback comparison allows it to (usually) work (though not necessarily repeatably, since the same-type fallback comparison is based on memory address, which isn't repeatable), but on Python 3 you'll just get a <code>TypeError</code>.</span>
<span class="comment-copy">Note: This is only for the case where the tests are local; doing it on a public facing web service would expose you to denial of service attacks (which is what hash randomization was designed to protect you from).</span>
