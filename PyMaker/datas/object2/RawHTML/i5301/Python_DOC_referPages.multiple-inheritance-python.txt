<div class="post-text" itemprop="text">
<p>I read Python's <a href="https://docs.python.org/3/tutorial/classes.html#multiple-inheritance" rel="nofollow noreferrer">documentation</a> and can't understand this piece of information</p>
<blockquote>
<pre><code>class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre>
<p>For most purposes, in the simplest cases, you can think of the search
  for attributes inherited from a parent class as depth-first,
  left-to-right, not searching twice in the same class where there is an
  overlap in the hierarchy. Thus, if an attribute is not found in
  <code>DerivedClassName</code>, it is searched for in <code>Base1</code>, then (recursively) in
  the base classes of <code>Base1</code>, and if it was not found there, it was
  searched for in <code>Base2</code>, and so on.</p>
</blockquote>
<p>If it is new-style class, why does Python search recursively in the base classes of Base1 and not going to Base2 then Base3?</p>
<pre><code>class A(object): 
    attr = 1

class B(A):
    pass
class C(A):
    attr = 2
class D(B,C):
    pass
x = D() 
print(x.attr)# 2
</code></pre>
<p>Sample from Mark Lutz's book.  Python goes to D then B then C. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you continue to read, then the documentation says "In fact, it is slightly more complex than that".
The thing you mention is oriented to single inheritance language. Python works different, and they implemented <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">super()</a>. You can either read on the documentation to know how does it work, or/and (depends on your level of curiosity) you can go read the answer on <a href="https://stackoverflow.com/questions/3277367/how-does-pythons-super-work-with-multiple-inheritance?rq=1">here</a> and start playing with the code and see what happens.</p>
<p>Good Luck</p>
</div>
<div class="post-text" itemprop="text">
<p>Attribute lookup occurs according to the method resolution order (MRO) established when the class is first defined. One important rule of the MRO is that no class appears before any of its children. This means the MRO for <code>D</code> is <code>[D, B, C, A, object]</code>, not <code>[D, B, A, object, C]</code> as you would expect from a pure depth-first search.</p>
</div>
<span class="comment-copy">It's not clear why you think your example disagrees with the description. Also, please use appropriate block quote formatting to clarify what is a quote (and include specifically from where).</span>
<span class="comment-copy">Are you asking why <code>C</code> comes before <code>A</code> in the resolution order? If so, the answer is that the order <i>isn't</i> just a depth first search in Python 3. (Hence the hedging: <i>"For most purposes, in the simplest cases, you can think of..."</i> Also hence the next line after your quote: <i>"In fact, it is slightly more complex than that..."</i>)</span>
<span class="comment-copy">That's the tutorial. It says "<i>For most purposes</i>, <i>in the simplest cases</i>, you can <i>think of</i> the search for attributes inherited from a parent class as...". It is obviously not trying to say that the description is completely accurate or general.</span>
