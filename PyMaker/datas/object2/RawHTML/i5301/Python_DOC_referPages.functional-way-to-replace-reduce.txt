<div class="post-text" itemprop="text">
<p>In Python 3, <code>reduce()</code> has been moved to <a href="https://docs.python.org/3.0/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce()</code></a> and <a href="https://stackoverflow.com/a/13638960/8080186">apparently</a> it's better to use list comprehensions or plain loops for better readability.</p>
<p>I want to print the XOR'ed value of all elements in a list. </p>
<pre><code># My implementation with functools
from functools import reduce
print(reduce(lambda a, b: a^b, [1, 3, 2, 3, 4, 4, 5, 2, 1]))
</code></pre>
<p>And I have this:</p>
<pre><code># My implementation without functools
def XOR(x):
    ans = 0
    for i in x:
        ans = ans ^ i
    return ans

print(XOR([1, 3, 2, 3, 4, 4, 5, 2, 1]))
</code></pre>
<p><strong>How can write a more functional version of this code without <code>reduce()</code>?</strong></p>
<p>(Please provide references or code in Python 3, if any.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Although Guido van Rossum didn't much care for <code>reduce()</code>, enough of the community did want it, which is why it was moved to <code>functools</code> and not removed outright. It is performant, and <em>ideally</em> suited to your use case. <strong>Just use it</strong>.</p>
<p>You can make your case faster and more readable by using <a href="https://docs.python.org/3/library/operator.html#operator.xor" rel="nofollow noreferrer"><code>operator.xor()</code></a> to avoid the overhead of a new Python frame for a lambda:</p>
<pre><code>from functools import reduce
from operator import xor

reduce(xor, [1, 3, 2, 3, 4, 4, 5, 2, 1])
</code></pre>
<p>Both <code>xor()</code> and <code>reduce()</code> are implemented in C. Calling back to the Python interpreter loop for the <code>lambda</code> is quite slow compared to calling another C function.</p>
<p>If you really must use a function, then use</p>
<pre><code>def xor_reduce(values):
    result = 0
    for value in values:
        result ^= value
    return result
</code></pre>
<p>using in-place XOR, and better variable names.</p>
</div>
<span class="comment-copy">Just stick with <code>reduce()</code>. This is an excellent case for it, <b>there is no reason not to use it</b>.</span>
<span class="comment-copy">Improvement: <a href="https://docs.python.org/3/library/operator.html#operator.xor" rel="nofollow noreferrer"><code>from operator import xor</code></a>, then use <code>reduce(xor, yourlist)</code>.</span>
<span class="comment-copy">@AjitZero built-in <code>xor</code> is most likely written in C, which involves less Python runtime.</span>
<span class="comment-copy">And, by the way, regarding "<i>reduce() has been moved to functools.reduce() and apparently it's better to use list comprehensions or plain loops for better readability</i>" â€“ listcomps (and, more generally, generator expressions) can't replace <code>reduce</code> (the fold function), they target <code>map</code> and <code>filter</code>. <code>reduce</code> is a perfectly fine function, there is no reason for you to avoid it, if you don't adhere to Guido van Rossum's distaste for functional programming.</span>
<span class="comment-copy">Not doing any self-promotion, but <a href="https://stackoverflow.com/a/44071474/7051394">here is a purely functional reduce</a>, that uses only <code>lambda</code>s. Not that it's extremely useful... But I found it pretty relevant.</span>
<span class="comment-copy">How do you feel about using <code>itertools.accumulate</code> in these situations? like <code>for x in accumulate([1, 3, 2, 3, 4, 4, 5, 2, 1], lambda a, b: a^b): pass</code> then <code>print(x)</code></span>
<span class="comment-copy">@Chris_Rands: if the goal is to have the intermediate values, sure. But that is a different use case; <code>functools.reduce()</code> is going to be faster if all you wanted was the <i>final result</i>. And I still would use <code>operator.xor()</code>.</span>
