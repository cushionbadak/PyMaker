<div class="post-text" itemprop="text">
<p>Gnome desktop has 2 clipboards, the X.org (saves every selection) and the legacy one (CTRL+C). I am writing a simple python script to clear both clipboards, securely preferably, since it may be done after copy-pasting a password.</p>
<p>The code that I have seen over here is this:</p>
<pre><code># empty X.org clipboard
os.system("xclip -i /dev/null")  

# empty GNOME clipboard
os.system("touch blank")  
os.system("xclip -selection clipboard blank")  
</code></pre>
<p>Unfortunately this code creates a file named <code>blank</code> for some reason, so we have to remove it:</p>
<pre><code>os.remove("blank")
</code></pre>
<p>However the main problem is that by calling both of these scripts, it leaves the <code>xclip</code> process open, even after I close the terminal.</p>
<h2>So we have 2 problems with this option:</h2>
<h2>1) It creates a blank file, which seems like a flawed method to me</h2>
<h2>2) It leaves a process open, which could be a security hole.</h2>
<p>I also know about this method:</p>
<pre><code> os.system("echo "" | xclip -selection clipboard")  # empty clipboard
</code></pre>
<p>However this one leaves a <code>\n</code> newline character in the clipboard, so I would not call this method effective either.</p>
<p>So how to do it properly then?</p>
</div>
<div class="post-text" itemprop="text">
<h1>Misconceptions</h1>
<ol>
<li>GNOME doesn't "have clipboards"; <em>X11</em> has <a href="https://en.wikipedia.org/wiki/X_Window_selection" rel="nofollow noreferrer">selections and cut buffers</a>.  There are more than 2 of them, but mostly we worry about the selections <code>PRIMARY</code> and <code>CLIPBOARD</code>.  Neither of them is "legacy".</li>
<li>You can't "securely" clear these (by writing something else into the memory they occupy), since they aren't stored in your process.  Cut buffers (which <em>are</em> obsolete) are stored in the X server, and selections are stored (if anywhere) in the process providing them.  (If there is a clipboard manager running, they may be stored in several places and be impossible to kill completely.)</li>
<li><code>xclip</code> <em>has</em> to leave a background process running to serve the selection it sets to any processes requesting it.  It's mostly useless when the selection is empty, but it does go away as soon as anything else is selected/copied, and it is surely not a security risk.</li>
<li>Never use <code>os.system</code> (or <code>system</code> in any language), except to run a shell command specified by the user (like <code>!</code> in <code>less</code>).  It uses the shell (specifically, <a href="https://stackoverflow.com/questions/48122804/how-to-discard-the-output-from-a-system-command#comment83223373_48122847"><code>/bin/sh</code></a>), which (because it is meant for interactive use) requires various kinds of quoting to avoid misinterpretation of generated input, it <a href="https://stackoverflow.com/questions/34457955/perl-forward-sigint-to-parent-process-from-system-command">affects signal handling</a>, it can't set up the child's open files directly, and it makes it all too easy to ignore the exit status of the child.</li>
</ol>
<h1>Tools</h1>
<ol>
<li>There of course exist Python bindings for Xlib, including <a href="https://github.com/python-xlib/python-xlib/blob/master/examples/put_selection.py" rel="nofollow noreferrer">manipulating selections</a>.  Probably overkill if selection-clearing is your only use case.</li>
<li>Tkinter, as mentioned, probably supports this (Tk <a href="https://www.tcl.tk/man/tcl/TkCmd/selection.htm" rel="nofollow noreferrer">certainly does</a>), but I haven't found a reference for it.</li>
<li><p><code>xclip</code> and <code>xsel</code>, as mentioned, are widely available (both are in the Ubuntu repositories, for instance).  You <a href="https://stackoverflow.com/questions/89228/calling-an-external-command-in-python">run external programs in Python</a> using <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer"><code>subprocess</code></a>; in Python 3.5 or better it looks like one of</p>
<pre><code>subprocess.run("xclip",stdin=subprocess.DEVNULL)
subprocess.run(["xclip","-selection","clipboard"],input="")
subprocess.run(["xsel","-c"])
</code></pre>
<p>(The choice between <code>stdin</code> and <code>input</code> matters more if you don't immediately wait on the program to exit.)  <code>xsel</code> has an explicit <code>--clear</code> option, which avoids the need for input and a background process.</p></li>
</ol>
<p>With any of these, you'll need to treat each of the two common selection types.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know three ways to clear the clipboard from Python. First using tkinter:</p>
<pre><code>try:
    from Tkinter import Tk
except ImportError:
    from tkinter import Tk
r = Tk()
r.withdraw()
r.clipboard_clear()
r.destroy()
</code></pre>
<p>Second with xclip, but I use xclip like this:</p>
<pre><code>echo -n | xclip -selection clipboard
</code></pre>
<p>Does it create a new line?</p>
<p>Finally, it's possible to user xsel:</p>
<pre><code>xsel -bc
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have figured out:</p>
<pre><code>#CLIPBOARD cleaner
subprocess.run(["xsel","-bc"])

#PRIMARY cleaner
subprocess.run(["xsel","-c"])
</code></pre>
<p>This one cleans both buffers, and leaves no zombie processes at all. Thanks for everyone who suggested some of them.</p>
</div>
<span class="comment-copy">I'd recommend having a look at <a href="https://github.com/mrichar1/clipster" rel="nofollow noreferrer">clipster</a> which is an X clipboard manager written entirely in python, which will either do what you want, or provide enough code to help you solve the problem.</span>
<span class="comment-copy">Try <code>echo -n</code> instead of <code>echo ""</code></span>
<span class="comment-copy">@DavisHerring please write your suggestion as answer, I am curious about how to do it with subprocess. I was only familiar with the os package, but I assume it was not the most efficient way of doing it.</span>
<span class="comment-copy">A big honking +1 for the "misconceptions" section. The Unix clipboard is a huge mess (and a barely working one FWIW), but there is no such a thing as a "gnome legacy clipboard".</span>
<span class="comment-copy">The script works, but the processes remain hanging in there: <a href="https://stackoverflow.com/q/48499398/9213435">stackoverflow.com/q/48499398/9213435</a></span>
<span class="comment-copy">The echo command seems good now, no new lines. What is the difference between doing it like that or throug the xsel command?</span>
<span class="comment-copy">Also the tkinter solution requires that package installed, it's not installed by default, I could install it ,but I'd prefer not to at this moment. Also these only clear the legacy clipboard ,but leave the X.org one intact.</span>
<span class="comment-copy">By examining the man pages, I could see no significant security improvement either one has over the other. xsel has less dependencies tho, while xclip seems to have more features.</span>
<span class="comment-copy">Do you even need <code>input</code> with <code>-c</code>?</span>
<span class="comment-copy">@DavisHerring How do you suggest it? Please edit the answer if you found a better way.</span>
<span class="comment-copy">My answer already contains <code>xsel -c</code> with no <code>input=""</code>.  You’re quite right that adding <code>-b</code> targets <code>CLIPBOARD</code>; I took that to be obvious from the man page.</span>
<span class="comment-copy">@DavisHerring yes you are correct, the input is not needed, works fine this way too.</span>
