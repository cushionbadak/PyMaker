<div class="post-text" itemprop="text">
<p>I have a fairly basic code that tests both generator functions and generator expressions. It works like a charm, but I can't figure out how to get the generator expression <code>genPairs</code> to stop printing once it reaches the final value. I have tried using <code>for i in range (0, xyz)</code> for xyz being a number of different len() calls, but I've gotten an error anytime I try to use the size of my generator expression. To save you time, my question is about the final 3 lines of the python code. </p>
<p>Code:</p>
<pre><code>import re
def genLetters(string):

    for letter in string:
        yield letter


letterTable = {}
print("Input your string")
regex = re.compile('[^a-zA-Z]')
inStr = input()
newString = regex.sub("",inStr).lower()
test = genLetters(newString)

for i in range(0,len(newString)):
    temp = next(test)
    if temp  not in letterTable:
        letterTable[temp] = 1
    else:
        letterTable[temp] +=1


letterTable = iter(sorted(letterTable.items()))

genPairs = (item for item in letterTable)
while genPairs:
    print(next(genPairs))
</code></pre>
<p>Output:</p>
<pre><code>    Input your string
porkpork
('k', 2)
('o', 2)
('p', 2)
('r', 2)
Traceback (most recent call last):
  File "hw2-1.py", line 27, in &lt;module&gt;
    print(next(genPairs))
StopIteration
</code></pre>
<p>What can I do to get it to not print the <code>traceback...stop iteration</code> nonsense? 
Is there a way to limit</p>
</div>
<div class="post-text" itemprop="text">
<p>A for loop will exhaust the generator and catch the <code>StopIteration</code> for you:</p>
<pre><code>for element in genPairs:
    print(element)
</code></pre>
<p>Using the code <code>while genPairs</code> doesn't make sense, because the generator expression itself will always be truthy.  </p>
</div>
<div class="post-text" itemprop="text">
<p>There appears to be a large amount of unnecessary code and generators which don't yield any benefit. I've cleaned it up for you below.</p>
<p>This solution removes the need for iterating generators, and includes <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> to perform the counting for you.</p>
<pre><code>from collections import Counter
import re

print('Input your string')
regex = re.compile('[^a-zA-Z]')
inStr = input()
newString = regex.sub('', inStr).lower()

letterTable = Counter(newString)

for k in sorted(letterTable):
    print((k, letterTable[k]))
</code></pre>
</div>
<span class="comment-copy"><code>while genPairs:</code> will run infinitely because your generator is truthy.</span>
<span class="comment-copy">And that keeps it out of memory still until I want it to be called?</span>
<span class="comment-copy">For the generator itself, yes.  But do note that you already expanded all this data to memory by using <code>sorted</code> earlier.</span>
<span class="comment-copy">Dang, good point. I was trying to avoid that so's to actually benefit from the generator expression rather than list comprehension. The problem was I wanted it sorted alphabetically. What might you suggest to sort without expanding the memory?</span>
<span class="comment-copy">@Podo You have at most 26 items, why do you care about memory?</span>
<span class="comment-copy">You can't.  Sorting is an operation that needs access to the entire sequence.</span>
