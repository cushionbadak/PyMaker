<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/8116666/itertools-groupby-not-grouping-correctly">itertools.groupby() not grouping correctly</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>I am trying to separate a list of integers into odd and even groups.</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; L = [1,2,3,4]
&gt;&gt;&gt; grouped = [list(g) for k,g in groupby(L, key=lambda x: x % 2)]
&gt;&gt;&gt; grouped
[[1], [2], [3], [4]]
</code></pre>
<p>Clearly, not what I want. However, if I sort L first, using the same lambda key, it works as intended:</p>
<pre><code>&gt;&gt;&gt; L.sort(key=lambda x: x % 2)
&gt;&gt;&gt; L
[2, 4, 1, 3]
&gt;&gt;&gt; grouped = [list(g) for k,g in groupby(L, key=lambda x: x % 2)]
&gt;&gt;&gt; grouped
[[2, 4], [1, 3]]
</code></pre>
<p>I don't understand why presorting is necessary. It seems groupby should iterate through the integers in list, assign each a value based on key function, and then group them -- regardless of the list order.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>itertools.groupby</code> will group <em>consecutive</em> items that satisfy the key function.  See the (key, group) pairs below.  Notice at the end what happens to the adjacent even items:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby


&gt;&gt;&gt; lst = [1, 2, 3, 4, 6, 8]
&gt;&gt;&gt; grouped = [(k, list(g)) for k, g in groupby(lst, key=lambda x: x % 2)]
&gt;&gt;&gt; grouped
[(1, [1]), (0, [2]), (1, [3]), (0, [4, 6, 8])]
</code></pre>
<p>Here are some ways to get groups of evens and odds:</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 4]

# OK, post-process groupby iterator
&gt;&gt;&gt; grouped = [(k, list(g)) for k, g in groupby(lst, key=lambda x: x % 2)]
&gt;&gt;&gt; evens = [x[1][0] for x in grouped if not x[0]]
&gt;&gt;&gt; odds = [x[1][0] for x in grouped if x[0]]
&gt;&gt;&gt; evens, odds
([2, 4], [1, 3])

# Better, pre-"sort"/rearrange iterable then groupby (see comments)
&gt;&gt;&gt; key = lambda x: x % 2
&gt;&gt;&gt; rearranged = sorted(lst, key=key)
&gt;&gt;&gt; evens, odds = [(list(g)) for k, g in groupby(rearranged, key=key)]
&gt;&gt;&gt; evens, odds
([2, 4], [1, 3])

# Even Better, simple list comprehensions
&gt;&gt;&gt; evens, odds = [x for x in lst if not x % 2], [x for x in lst if x % 2]
&gt;&gt;&gt; evens, odds
([2, 4], [1, 3])
</code></pre>
<p>See <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">docs</a> and this <a href="https://stackoverflow.com/questions/773/how-do-i-use-pythons-itertools-groupby">post</a> for more on <code>itertools.groupby</code>.</p>
<hr/>
<p><em>Alternatives</em></p>
<p>For complex groupings, you may map a function and collect values in a <a href="https://docs.python.org/3.7/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>.</p>
<pre><code>&gt;&gt;&gt; import collections as ct


&gt;&gt;&gt; def even_odd(elem):
...     key = "odd" if elem % 2 else "even"
...     return key, elem

&gt;&gt;&gt; dd = ct.defaultdict(list)
&gt;&gt;&gt; for k, v in map(even_odd, range(1, 5)):
...     dd[k].append(v)  
&gt;&gt;&gt; dd
defaultdict(list, {'even': [2, 4], 'odd': [1, 3]})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Got it. I had read the docs previously and thought I understood, but clearly I did not. Here is the salient point: </p>
<p>"It generates a break or new group every time the value of the key function changes (<em>which is why it is usually necessary to have sorted the data using the same key function</em>)." [Emphasis mine.]</p>
<p>I should have re-read this before posting my question. Sorry.</p>
</div>
<span class="comment-copy">Please read the <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">documentation</a> first, so you know what the functions you're using are actually supposed to do.</span>
<span class="comment-copy">It is quite clearly explained in the docs: <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">docs.python.org/2/library/itertools.html#itertools.groupby</a></span>
<span class="comment-copy">"it seems" why does it seem? Did you read the documentation?</span>
<span class="comment-copy">You are supposed to sort the iterable by that key first, then group it! like: <code>L = sorted(L,key=lambda x:x%2)</code></span>
<span class="comment-copy">Got it. I had read the docs previously and thought I understood, but clearly I did not. Here is the salient point: "It generates a break or new group every time the value of the key function changes (which is why it is usually necessary to have sorted the data using the same key function)."  I should have re-read this before posting my question. Sorry.</span>
