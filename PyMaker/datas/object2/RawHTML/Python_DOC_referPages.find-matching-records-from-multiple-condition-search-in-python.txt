<div class="post-text" itemprop="text">
<p>I have a set of related integers which I need to search for across a huge number of data, and am wondering what's considered to be the most Pythonic or efficient method for going about this.</p>
<p>For example, if I have a list of integers: </p>
<pre><code>query = [1,5,7,8]
</code></pre>
<p>And need to find all objects that contain these values:</p>
<pre><code>record_1 = [0,5,7,8,10,11,12]
record_2 = [1,3,5,8,10,13,14]
record_3 = [1,4,5,6,7,8,11]
record_4 = [1,5,6,7,8,10,14]
record_5 = [1,5,8,9,11,13,16]
</code></pre>
<p>I know it wouldn't be too difficult to load each record into a larger list and iteratively test each for whether or not they contain <em>all</em> the integers found in the query, but I am wondering if there's a more Pythonic way of doing it, or if there's a more efficient method than testing every value (which will become expensive when scaling).</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>If the numbers in queries and records are unique I would represent them a <a href="https://docs.python.org/3.7/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer"><code>sets</code></a> (or frozensets for better performance). Lets assume you have a list of records and a query:</p>
<p>The filter function is applied onto the list of records. For each record the lambda function is executed to see if it is true. The lambda function checks if query is a subset of the current record. Thus the filtered list contains our results. The result is converted to a list.</p>
<pre><code>query = set([1,5,7,8])

records = [
    set([0,5,7,8,10,11,12]),
    set([1,3,5,8,10,13,14]),
    set([1,4,5,6,7,8,11]),
    set([1,5,6,7,8,10,14]),
    set([1,5,8,9,11,13,16]),
]

matches = list(filter(lambda r: query.issubset(r), records))
print(matches)

</code></pre>
<p>Output:</p>
<pre><code>[{1, 4, 5, 6, 7, 8, 11}, {1, 5, 6, 7, 8, 10, 14}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>list</code> <code>map</code> with <code>issubset</code></p>
<pre><code>for y,x in zip(records,map(lambda x : query.issubset(x),records)):
    if x :
        print(y)


{1, 4, 5, 6, 7, 8, 11}
{1, 5, 6, 7, 8, 10, 14}
</code></pre>
</div>
<span class="comment-copy">If you want to know if the value is there, you have no other choice but to check if it is there. If you have full control over your data and the way it's processed, you can always trigger some flag/state in the "head" of your data (here, probably a class ?), that you'll check, instead of going over the whole list.</span>
<span class="comment-copy">This is too broad, I think it would be better if you provide some <i>code</i> of yours and a specific question. Otherwise you are asking for opinions. At least in python, membership is tested better with sets or dictionaries. But again, it depends on your case.</span>
<span class="comment-copy">What does this have to do with numpy or pandas?</span>
<span class="comment-copy">@roganjosh: nothing on it own; I apologize if this isn't correct procedure, but I tagged numpy &amp; pandas because I know generally that there are search functions and could see there being a specific function that I had somehow missed, so the tage was there help direct the question to potentially appropriate groups. Again, apologies if that's not an acceptable use of tags (and if so, I won't do that again).</span>
<span class="comment-copy">Thank you! I think this is the way in which I might go. Will test with a larger dataset and report back if there are any issues I run into, but I suspect it will run fine.</span>
<span class="comment-copy">not need for <code>list(map(...))</code>, just <code>map</code> is fine, unpacks automatically</span>
<span class="comment-copy">@RafaelC yes you are right updated thanks</span>
