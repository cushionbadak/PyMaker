<div class="post-text" itemprop="text">
<p>I've little bit test to fully understand metaclass in python.</p>
<pre><code>class Test(object):
    pass


print Test.__class__
print Test.__class__.__class__
print Test.__class__.__class__.__class__
</code></pre>
<p>All of result is same <code>type</code>. but each of their address is not same<br/>
I can't really understand why metaclass has a metaclass recursively.<br/>
Explain me please?</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually, addresses are the same:</p>
<pre><code>&gt;&gt;&gt; id(Test.__class__)
6384576
&gt;&gt;&gt; id(Test.__class__.__class__)
6384576
&gt;&gt;&gt; id(Test.__class__.__class__.__class__)
6384576
</code></pre>
<p>Everything is an object in Python, and each object must have a class (it should belong to some type).  You can access that class/type reference by <code>__class__</code> attribute, e.g.:</p>
<pre><code>&gt;&gt;&gt; (1).__class__
&lt;type 'int'&gt;
</code></pre>
<p>Everything includes classes itself, which are of class/type called <code>type</code>:</p>
<pre><code>&gt;&gt;&gt; (1).__class__.__class__
&lt;type 'type'&gt;
</code></pre>
<p>In the same time <code>type 'type'&gt;</code> is also an object and should reference to some class/type.  But since this is kind of special object, its <code>__class__</code> attribute refers to itself:</p>
<pre><code>&gt;&gt;&gt; (1).__class__.__class__.__class__ is (1).__class__.__class__
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you do <code>Test.__class__</code>, you get back the type of <code>Test</code>, which is <code>type</code> (because <code>Test</code> is a class identifier).</p>
<p><code>type</code> itself is again a class identifier, so you can call <code>__class__</code> (which is inherited from <code>object</code>) on it and you get back that its type is, again, <code>type</code> because it is a class identifier.</p>
<p>Because you will always get back <code>type</code> which is a class itself, you can do this infinitely many times and will always get back that the current object's type is <code>type</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>All classes are classes which means they are derived from a class called class...</p>
</div>
<div class="post-text" itemprop="text">
<p>All the python's class object is build by the built-in function type(). You could also try this.</p>
<pre><code>&gt;&gt;&gt; T.__class__ == type
True
&gt;&gt;&gt; type(type)
&lt;type 'type'&gt;
</code></pre>
<p>The T.<strong>class</strong> is equal to the build-in function type which is also an object implemented the <strong>call</strong> function. It's a attribute will be interpret as <strong>class</strong>(T). As your T class have no base class so type() is used which will return the type object.</p>
<p>You could check the python doc about <a href="http://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow">customizing class creation</a> to get detail about class creation. </p>
<p>To determining the appropriate metaclass</p>
<ul>
<li>if no bases and no explicit metaclass are given, then type() is used</li>
<li>if an explicit metaclass is given and it is not an instance of type(), then it is used directly as the metaclass</li>
<li>if an instance of type() is given as the explicit metaclass, or bases are defined, then the most derived metaclass is used</li>
</ul>
</div>
<span class="comment-copy">Thanks, I misunderstood their address is not same.</span>
