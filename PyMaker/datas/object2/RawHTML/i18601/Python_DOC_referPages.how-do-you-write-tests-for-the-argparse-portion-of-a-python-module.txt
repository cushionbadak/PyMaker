<div class="post-text" itemprop="text">
<p>I have a Python module that uses the argparse library. How do I write tests for that section of the code base?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should refactor your code and move the parsing to a function:</p>
<pre><code>def parse_args(args):
    parser = argparse.ArgumentParser(...)
    parser.add_argument...
    # ...Create your parser as you like...
    return parser.parse_args(args)
</code></pre>
<p>Then in your <code>main</code> function you should just call it with:</p>
<pre><code>parser = parse_args(sys.argv[1:])
</code></pre>
<p>(where the first element of <code>sys.argv</code> that represents the script name is removed to not send it as an additional switch during CLI operation.)</p>
<p>In your tests, you can then call the parser function with whatever list of arguments you want to test it with:</p>
<pre><code>def test_parser(self):
    parser = parse_args(['-l', '-m'])
    self.assertTrue(parser.long)
    # ...and so on.
</code></pre>
<p>This way you'll never have to execute the code of your application just to test the parser.</p>
<p>If you need to change and/or add options to your parser later in your application, then create a factory method:</p>
<pre><code>def create_parser():
    parser = argparse.ArgumentParser(...)
    parser.add_argument...
    # ...Create your parser as you like...
    return parser
</code></pre>
<p>You can later manipulate it if you want, and a test could look like:</p>
<pre><code>class ParserTest(unittest.TestCase):
    def setUp(self):
        self.parser = create_parser()

    def test_something(self):
        parsed = self.parser.parse_args(['--something', 'test'])
        self.assertEqual(parsed.something, 'test')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>"argparse portion" is a bit vague so this answer focuses on one part: the <code>parse_args</code> method. This is the method that interacts with your command line and gets all the passed values. Basically, you can mock what <code>parse_args</code> returns so that it doesn't need to actually get values from the command line. The <code>mock</code> <a href="https://pypi.org/project/mock/" rel="nofollow noreferrer">package</a> can be installed via pip for python versions 2.6-3.2. It's part of the standard library as <code>unittest.mock</code> from version 3.3 onwards.</p>
<pre><code>import argparse
try:
    from unittest import mock  # python 3.3+
except ImportError:
    import mock  # python 2.6-3.2


@mock.patch('argparse.ArgumentParser.parse_args',
            return_value=argparse.Namespace(kwarg1=value, kwarg2=value))
def test_command(mock_args):
    pass
</code></pre>
<p>You have to include all your command method's args in <code>Namespace</code>  even if they're not passed. Give those args a value of <code>None</code>. (see the <a href="https://docs.python.org/dev/library/argparse.html#option-value-syntax" rel="nofollow noreferrer">docs</a>) This style is useful for quickly doing testing for cases where different values are passed for each method argument. If you opt to mock <code>Namespace</code> itself for total argparse non-reliance in your tests, make sure it behaves similarly to the actual <code>Namespace</code> class.</p>
<p>Below is an example using the first snippet from the argparse library.</p>
<pre><code># test_mock_argparse.py
import argparse
try:
    from unittest import mock  # python 3.3+
except ImportError:
    import mock  # python 2.6-3.2


def main():
    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('integers', metavar='N', type=int, nargs='+',
                        help='an integer for the accumulator')
    parser.add_argument('--sum', dest='accumulate', action='store_const',
                        const=sum, default=max,
                        help='sum the integers (default: find the max)')

    args = parser.parse_args()
    print(args)  # NOTE: this is how you would check what the kwargs are if you're unsure
    return args.accumulate(args.integers)


@mock.patch('argparse.ArgumentParser.parse_args',
            return_value=argparse.Namespace(accumulate=sum, integers=[1,2,3]))
def test_command(mock_args):
    res = main()
    assert res == 6, "1 + 2 + 3 = 6"


if __name__ == "__main__":
    print(main())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Make your <code>main()</code> function take <code>argv</code> as an argument rather than letting it <a href="https://docs.python.org/3/library/argparse.html#parsing-arguments" rel="noreferrer">read from <code>sys.argv</code> as it will by default</a>:</p>
<pre><code># mymodule.py
import argparse
import sys


def main(args):
    parser = argparse.ArgumentParser()
    parser.add_argument('-a')
    process(**vars(parser.parse_args(args)))
    return 0


def process(a=None):
    pass

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
</code></pre>
<p>Then you can test normally.</p>
<pre><code>import mock

from mymodule import main


@mock.patch('mymodule.process')
def test_main(process):
    main([])
    process.assert_call_once_with(a=None)


@mock.patch('foo.process')
def test_main_a(process):
    main(['-a', '1'])
    process.assert_call_once_with(a='1')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>Populate your arg list by using <code>sys.argv.append()</code> and then call
<code>parse()</code>, check the results and repeat.</li>
<li>Call from a batch/bash file with your flags and a dump args flag.</li>
<li>Put all your argument parsing in a separate file and in the <code>if __name__ == "__main__":</code> call parse and dump/evaluate the results then test this from a batch/bash file.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>A simple way of testing a parser is:</p>
<pre><code>parser = ...
parser.add_argument('-a',type=int)
...
argv = '-a 1 foo'.split()  # or ['-a','1','foo']
args = parser.parse_args(argv)
assert(args.a == 1)
...
</code></pre>
<p>Another way is to modify <code>sys.argv</code>, and call <code>args = parser.parse_args()</code></p>
<p>There are lots of examples of testing <code>argparse</code> in <code>lib/test/test_argparse.py</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I did not want to modify the original serving script so I just mocked out the <code>sys.argv</code> part in argparse.</p>
<pre><code>from unittest.mock import patch

with patch('argparse._sys.argv', ['python', 'serve.py']):
    ...  # your test code here
</code></pre>
<p>This breaks if argparse implementation changes but enough for a quick test script. Sensibility is much more important than specificity in test scripts anyways.</p>
</div>
<div class="post-text" itemprop="text">
<p>When passing results from <code>argparse.ArgumentParser.parse_args</code> to a function, I sometimes use a <code>namedtuple</code> to mock arguments for testing.</p>
<pre><code>import unittest
from collections import namedtuple
from my_module import main

class TestMyModule(TestCase):

    args_tuple = namedtuple('args', 'arg1 arg2 arg3 arg4')

    def test_arg1(self):
        args = TestMyModule.args_tuple("age &gt; 85", None, None, None)
        res = main(args)
        assert res == ["55289-0524", "00591-3496"], 'arg1 failed'

    def test_arg2(self):
        args = TestMyModule.args_tuple(None, [42, 69], None, None)
        res = main(args)
        assert res == [], 'arg2 failed'

if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>parse_args</code> throws a <code>SystemExit</code> and prints to stderr, you can catch both of these:</p>
<pre class="lang-py prettyprint-override"><code>import contextlib
import io
import sys

@contextlib.contextmanager
def captured_output():
    new_out, new_err = io.StringIO(), io.StringIO()
    old_out, old_err = sys.stdout, sys.stderr
    try:
        sys.stdout, sys.stderr = new_out, new_err
        yield sys.stdout, sys.stderr
    finally:
        sys.stdout, sys.stderr = old_out, old_err

def validate_args(args):
    with captured_output() as (out, err):
        try:
            parser.parse_args(args)
            return True
        except SystemExit as e:
            return False
</code></pre>
<p><em>You inspect stderr (using <code>err.seek(0); err.read()</code> but generally that granularity isn't required.</em></p>
<p>Now you can use <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertTrue" rel="nofollow noreferrer"><code>assertTrue</code></a> or whichever testing you like:</p>
<pre><code>assertTrue(validate_args(["-l", "-m"]))
</code></pre>
<hr/>
<p>Alternatively you might like to catch and rethrow a different error (instead of <code>SystemExit</code>):</p>
<pre><code>def validate_args(args):
    with captured_output() as (out, err):
        try:
            return parser.parse_args(args)
        except SystemExit as e:
            err.seek(0)
            raise argparse.ArgumentError(err.read())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found that the easiest way, for me at least, was just to check sys.argv[0] so see if python was ran as <code>python -m unittest</code> and not parse anything if that was the case.</p>
<pre><code>import sys
import argparse

parser = argparse.ArgumentParser()

parser.add_argument('--outdir', help='Directory to output to', \
    default='out')
parser.add_argument('--file', help='Input file', \
    default='section')
parser.add_argument('--word', help='Word to look up')

if sys.argv[0] == 'python -m unittest':
    args = parser.parse_args([])
else:
    args = parser.parse_args()
</code></pre>
</div>
<span class="comment-copy">argparse is a command line interface. Write your tests to invoke the application via the command line.</span>
<span class="comment-copy">Thanks for your answer. How do we test for errors when a certain argument is not passed?</span>
<span class="comment-copy">@PratikKhadloya If the argument is required and it's not passed, argparse will raise an exception.</span>
<span class="comment-copy">Right, but i am trying to test the message in the exception as well. I am not able to get a hold of the message in the exception object. <a href="https://gist.github.com/tispratik/aebff28b8c5afd7bee59" rel="nofollow noreferrer">gist.github.com/tispratik/aebff28b8c5afd7bee59</a></span>
<span class="comment-copy">@PratikKhadloya Yes, the message is unfortunately not really helpful :( It's just <code>2</code>... <code>argparse</code> is not very test friendly since it prints directly to <code>sys.stderr</code>...</span>
<span class="comment-copy">@ViktorKerkez You may be able to mock sys.stderr to check for a specific message, either mock.assert_called_with or by examining mock_calls, see <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html</a> for more detail. See also <a href="http://stackoverflow.com/questions/6271947/how-can-i-simulate-input-to-stdin-for-pyunit" title="how can i simulate input to stdin for pyunit">stackoverflow.com/questions/6271947/â€¦</a> for an example of mocking stdin. (stderr should be similar)</span>
<span class="comment-copy">But now your unittest code also depends on <code>argparse</code> and its <code>Namespace</code> class. You should mock <code>Namespace</code>.</span>
<span class="comment-copy">@DrunkenMaster apologies for the snarky tone. I updated my answer with explanation and possible uses. I'm learning here as well so if you would, can you (or someone else) provide cases where mocking the return value is beneficial? (or at least cases where <i>not</i> mocking the return value is detrimental)</span>
<span class="comment-copy"><code>from unittest import mock</code> is now the correct import method - well at least for python3</span>
<span class="comment-copy">@MichaelHall thanks. I updated the snippet and added contextual info.</span>
<span class="comment-copy">It would be really useful to have an example here.</span>
