<div class="post-text" itemprop="text">
<p>I'd like to save to disk all the variables I create within a particular function in one go, so that I can load them later. Something of the type:</p>
<pre><code>&gt;&gt;&gt; def test():
      a=1
      b=2
      save.to.file(filename='file', all.variables)

&gt;&gt;&gt; load.file('file')
&gt;&gt;&gt; a
&gt;&gt;&gt; 1
</code></pre>
<p>Is there a way to do this in python? I know cPickle can do this, but as far as I know, one has to type cPickle.dump() for every single variable, and my script has dozens. Also, it seems that cPickle stores only the values and not the names of the variables, so one has to remember the order the data was originally saved.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming all of the variables you want to save are local to the current function, you <em>can</em> get at them via the <a href="http://docs.python.org/3.3/library/functions.html#locals" rel="nofollow"><code>locals</code></a> function. This is almost always a very bad idea, but it is doable.</p>
<p>For example:</p>
<pre><code>def test():
    a=1
    b=2
    pickle.dump(file, locals())
</code></pre>
<p>If you <code>print locals()</code>, you'll see that it's just a dict, with a key for each local variable. So, when you later <code>load</code> the pickle, what you'll get back is that same dict. If you want to inject it into your local environment, you can… but you have to be very careful. For example, this function:</p>
<pre><code>def test2():
    locals().update(pickle.load(file))
    print a
</code></pre>
<p>… will be compiled to expect <code>a</code> to be a global, rather than a local, so the fact that you've updated the local <code>a</code> will have no effect.</p>
<p>This is just one of the reasons it's a bad idea to do this.</p>
<p>So, what's the <em>right</em> thing to do?</p>
<p>Most simply, instead of having a whole slew of variables, just have a dict with a slew of keys. Then you can pickle and unpickle the dict, and everything is trivial.</p>
<p>Or, alternatively, explicitly pickle and unpickle the variables you want by using a tuple:</p>
<pre><code>def test():
    a = 1
    b = 2
    pickle.dump(file, (a, b))

def test2():
    a, b = pickle.load(file)
    print a
</code></pre>
<hr/>
<p>In a comment, you say that you'd like to pickle a slew or variables, skipping any that can't be pickled.</p>
<p>To make things simpler, let's say you actually just want to pickle a dict, skipping any values that can't be pickled. (The above should show why this solution is still fully general.)</p>
<p>So, how do you know whether a value can be pickled? Trying to predict that is a tricky question. Even if you had a perfect list of all pickleable types, that still wouldn't help—a list full of integers can be pickled, but a list full of bound instance methods can't.</p>
<p>This kind of thing is exactly why <a href="http://docs.python.org/3/glossary.html#term-eafp" rel="nofollow">EAFP</a> ("Easier to Ask Forgiveness than Permission") is an important principle in duck-typed languages like Python.* The way to find out if something can be pickled is to pickle it, and see if you get an exception.</p>
<p>Here's a simple demonstration:</p>
<pre><code>def is_picklable(value):
    try:
        pickle.dumps(value)
    except TypeError:
        return False
    else:
        return True

def filter_dict_for_pickling(d):
    return {key: value for key, value in d.items() if is_picklable((key, value))}
</code></pre>
<p>You can make this a bit less verbose, and more efficient, if you put the whole stashing procedure in a wrapper function:</p>
<pre><code>def pickle_filtered_dict(d, file):
    for key, value in d.items():
        pickle.dump((key, value), file)
    except TypeError:
        pass

def pickles(file):
    try:
        while True:
            yield pickle.load(file)
    except EOFError:
        pass

def unpickle_filtered_dict(file):
    return {key: value for key, value in pickles(file)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use pickle to store objects in files:</p>
<pre><code>&gt;&gt;&gt; a = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; a
{'a': 1, 'c': 3, 'b': 2}
&gt;&gt;&gt;
&gt;&gt;&gt; import pickle
&gt;&gt;&gt; pickle.dump(a, open('a.dump', 'wb'))
&gt;&gt;&gt;
&gt;&gt;&gt; a = None
&gt;&gt;&gt; a
&gt;&gt;&gt;
&gt;&gt;&gt; a = pickle.load(open('a.dump', 'rb'))
&gt;&gt;&gt; a
{'a': 1, 'c': 3, 'b': 2}
&gt;&gt;&gt;
</code></pre>
<p>More information at: <a href="http://docs.python.org/2/library/pickle.html" rel="nofollow">http://docs.python.org/2/library/pickle.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can pickle multiple variables by making them attributes of an object, or elements in a dictionary. In either case it saves the name as well.  It's not quite as convenient as save in MATLAB, but it's better than nothing.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are not satisfied with the API of <code>pickle</code>, consider <a href="http://docs.python.org/2/library/shelve.html" rel="nofollow">shelve</a> which does the pickling for you with a nicer <code>dict</code>-like front end.</p>
<p>ex.</p>
<pre><code>&gt;&gt;&gt; import shelve
&gt;&gt;&gt; f = shelve.open('demo')
&gt;&gt;&gt; f
&lt;shelve.DbfilenameShelf object at 0x000000000299B9E8&gt;
&gt;&gt;&gt; list(f.keys())
['test', 'example']
&gt;&gt;&gt; del f['test']
&gt;&gt;&gt; del f['example']
&gt;&gt;&gt; list(f.keys())
[]
&gt;&gt;&gt; f['a'] = 1
&gt;&gt;&gt; list(f.keys())
['a']
&gt;&gt;&gt; list(f.items())
[('a', 1)]
</code></pre>
</div>
<span class="comment-copy">Why not pickle the whole function? You can use <code>test.a</code> or <code>test.b</code> to retrieve the variable.</span>
<span class="comment-copy">@zhangyangyu: Nope. Function attributes aren't local variables.</span>
<span class="comment-copy">Why do you have dozens of variables, each of which needs to be saved? It sounds to me like either you're using too many variables where something like a list would be more appropriate, or you're trying to save everything instead of considering which things need to be saved and which should be reset or reconstructed when the program restarts.</span>
<span class="comment-copy">Thanks, that's exactly what I was looking for. Basically, I just want to save all variables within a given session in a file, for future reference (just in case I need to go back and see what values were assigned to what variables).  But is there a way to tell pickle to save only those objects that are "pickleable", or perhaps telling locals() not to save the "non-pickleable" ones (I'm getting an error message - ValueError - due to these).</span>
<span class="comment-copy">@user2635863: Let me update the answer with something that might help for your new problem.</span>
<span class="comment-copy">many thanks for both the clear explanation and demonstration.</span>
