<div class="post-text" itemprop="text">
<p>I am developing a Python 3 script that analyses a logfile line by line.
It takes the logfile to analyse as a parameter, and processes it:</p>
<pre><code>parser = argparse.ArgumentParser(description="logfile analysis")
    parser.add_argument("logfile", help="log file to analyse")
    args = parser.parse_args()
    with open(args.logfile, 'r') as f:
        for line in f:
            (... processing ...)
</code></pre>
<p>Sometimes, though, the log files contain very weird characters.
I don't even know how to copy and paste those characters here, so here is a screenshot from a text editor:
<img alt="Weird characters appearing in the logs" src="https://i.stack.imgur.com/zNQje.png"/></p>
<p>And in those cases, I have the following exception:</p>
<pre><code>Traceback (most recent call last):
  File "loganalysis.py", line 525, in &lt;module&gt;
    main()
  File "loganalysis.py", line 512, in main
    for line in f:
  File "/usr/lib/python3.2/codecs.py", line 300, in decode
    (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc0 in position 2265: invalid start byte
</code></pre>
<p>How can I sanitize the content of the lines before processing them, or simply ignore them without having my script to crash?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/3/library/functions.html#open" rel="nofollow">open</a> accepts <code>errors</code> option.</p>
<blockquote>
<p>errors is an optional string that specifies how encoding and decoding
  errors are to be handled–this cannot be used in binary mode. A variety
  of standard error handlers are available, though any error handling
  name that has been registered with codecs.register_error() is also
  valid. The standard names are:</p>
<ul>
<li>'strict' to raise a ValueError exception if there is an encoding error. The default value of None has the same effect.</li>
<li>'ignore' ignores errors. Note that ignoring encoding errors can lead to data loss.</li>
<li>'replace' causes a replacement marker (such as '?') to be inserted where there is malformed data.</li>
<li>'surrogateescape' will represent any incorrect bytes as code points in the Unicode Private Use Area ranging from U+DC80 to U+DCFF. These
  private code points will then be turned back into the same bytes when
  the surrogateescape error handler is used when writing data. This is
  useful for processing files in an unknown encoding.</li>
<li>'xmlcharrefreplace' is only supported when writing to a file. Characters not supported by the encoding are replaced with the
  appropriate XML character reference &amp;#nnn;.</li>
<li>'backslashreplace' (also only supported when writing) replaces unsupported characters with Python’s backslashed escape sequences.</li>
</ul>
</blockquote>
<p>Pass <code>errors='ignore'</code> to ignore encoding errors.</p>
<pre><code>open(args.logfile, 'r', errors='ignore')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could always sanitise the strings before processing, e.g.:</p>
<pre><code>parser = argparse.ArgumentParser(description="logfile analysis")
parser.add_argument("logfile", help="log file to analyse")
args = parser.parse_args()
with open(args.logfile, 'r') as f:
    for line in f:
        line = repr(line)
        (... processing ...)
</code></pre>
<p>This should result in a line with any special characters represented as \xc0, etc.</p>
</div>
<span class="comment-copy">Thanks! Looks like it fixed my issue :)</span>
<span class="comment-copy">Thanks Steve, the problem is that the exception is raised on the "for line in f:" line, not after.</span>
