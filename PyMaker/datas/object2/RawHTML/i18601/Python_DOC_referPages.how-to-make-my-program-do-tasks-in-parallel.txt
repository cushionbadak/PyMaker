<div class="post-text" itemprop="text">
<p>I wrote a program in python &amp; it works great,<br/>
It reads file names with specific extensions, searches a database on the network &amp; renames them to a new name .<br/>
But it's too slow. It does this task for one file a time,<br/>
How can i make it do this read-search-rename thing for multiple files, say 3 or 4 files at a time?  What topic is it related to? Parallel programming?
I hope i used the correct term i.e doing tasks in " Parallel ". </p>
</div>
<div class="post-text" itemprop="text">
<p>Sometimes it is easier to use gnu parallel, I have written a lot of code that looks something like:</p>
<pre><code>ls | parallel -j 4 ./pythonScript {}
</code></pre>
<p>This takes whatever inputs and puts it where {} is.  (As mentioned you have to be careful when doing parallel things, you can use -j int to specify a max.)</p>
<p>For dates I use something like:</p>
<pre><code>seconds_in_a_day=$(( 24 * 60 * 60 ))
startDay=$(( `date --date="7/27/2013" +%s`))
finishDay=$(( `date --date="7/29/2013" +%s` ))

seq $startDay $seconds_in_a_day $finishDay | parallel -j 4 ./scirptThatRunsWithATimestamp {} "&gt;"{}.txt
</code></pre>
<p>This writes to a file with the timestamp.txt as the name.</p>
<p>Parallel does a really good job of handling cancelling and pausing jobs, making it easier to run jobs across several machines.  Plus if you learn how to use it, you can write parallel code in any language or take linear code and easily modify it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the multiprocessing module in the python standard library to parallelise your work. Multiple I/O bound processes might slow your system down so be careful about your limits. </p>
</div>
<div class="post-text" itemprop="text">
<p>Multiprocessing is one option, but since your bottleneck is probably the network access, I suggest you use threading. It's much easier to share data between threads then it is between processes. And threads where created to parallelize slow io tasks.</p>
<p>Take a look at the Python threading library, keep in mind though that introducing any kind of parallelism that requires you to share data makes your program orders of magnitude harder to understand and debug.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since all the work you describe is I/O bound you could consider implementing this using the Python <a href="http://docs.python.org/3/library/threading.html#module-threading" rel="nofollow">threading module</a>. You could create three threads. The first would read the directory of interest and identify the candidate files. The second thread would do the database query and the third thread would do the file renaming, The threads would be connected with threading.Queue queues.</p>
<p>As the first thread identified a file, it would pass the name of the file over the queue to the database query thread. When the database query thread completes and the new file name has been determined, pass this data to the file rename thread over the queue connecting those processes.</p>
<p>The whole process terminates when the first thread that identifies the files has no more work to do and sends a sentinel message, probably a <code>None</code> object to the database query thread and then terminates. The database query thread forwards the message to the file rename thread and then terminates itself. Finally when the file rename thread receives the sentinel, it terminates itself.</p>
</div>
<span class="comment-copy">Threading is only marginally more parallel than non-threading, because of Python's Global Interpreter Lock (GIL). Multiprocessing uses the same API as threading, but runs code in separate processes, so, assuming multiple CPUs/cores, code using multiprocessing will actually run in parallel.</span>
<span class="comment-copy">Threading was invented specifically for speeding up potentially long running blocking io requests. When used correctly the GIL does not interfere with threading, only when you attempt to parallelize computation with threading will the GIL interfere, but this is where multiprocessing comes into play. Read the Python wiki (<a href="http://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">wiki.python.org/moin/GlobalInterpreterLock</a>) for a more in-depth look at the problem, it stats specifically that the GIL does NOT interfere with io, as this happens outside of its content.</span>
