<div class="post-text" itemprop="text">
<p>There doesn't appear to be a way to add headers to the urlparse command.  This essentially causes Python to use its default user agent, which is blocked by several web pages.  What I am trying to do is essentially do the equivalent of this:</p>
<pre><code>req = Request(INPUT_URL,headers={'User-Agent':'Browser Agent'})
</code></pre>
<p>But using urlparse:</p>
<pre><code>parsed = list(urlparse(INPUT_URL))
</code></pre>
<p>So how can I modify this urlparse in order for it to take headers, or be usable with my Request that I created?  Any help is appreciated, thanks.</p>
<p>Also, for anyone wondering the exact error I am getting:</p>
<pre><code>urllib.error.HTTPError: HTTP Error 403: Forbidden
</code></pre>
<p>At this:</p>
<pre><code>urlretrieve(urlunparse(parsed),outpath)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Headers are part of a request, of which the URL is one part. Python creates a request for you when you pass in just a URL to <code>urllib.request</code> functions.</p>
<p>Create a <a href="http://docs.python.org/3/library/urllib.request.html#urllib.request.Request" rel="nofollow"><code>Request</code> object</a>, add the headers to that object and use that instead of a string URL:</p>
<pre><code>request = Request(urlunparse(parsed), headers={'User-Agent': 'My own agent string'})
</code></pre>
<p>However, <code>urlretrieve()</code> is marked as 'legacy API' in the code and doesn't support using a <code>Request</code> object. Removing a few lines supporting 'file://' urls is easy enough:</p>
<pre><code>import contextlib
import tempfile
from urllib.error import ContentTooShortError
</code></pre>
<p>    from urllib.request import urlopen</p>
<pre><code>_url_tempfiles = []
def urlretrieve(url, filename=None, reporthook=None, data=None):
    with contextlib.closing(urlopen(url, data)) as fp:
        headers = fp.info()

        # Handle temporary file setup.
        if filename:
            tfp = open(filename, 'wb')
        else:
            tfp = tempfile.NamedTemporaryFile(delete=False)
            filename = tfp.name
            _url_tempfiles.append(filename)

        with tfp:
            result = filename, headers
            bs = 1024*8
            size = -1
            read = 0
            blocknum = 0
            if "content-length" in headers:
                size = int(headers["Content-Length"])

            if reporthook:
                reporthook(blocknum, bs, size)

            while True:
                block = fp.read(bs)
                if not block:
                    break
                read += len(block)
                tfp.write(block)
                blocknum += 1
                if reporthook:
                    reporthook(blocknum, bs, size)

    if size &gt;= 0 and read &lt; size:
        raise ContentTooShortError(
            "retrieval incomplete: got only %i out of %i bytes"
            % (read, size), result)

    return result
</code></pre>
</div>
<span class="comment-copy">What makes you think headers have anything to do with URL parsing? Headers are added to a request, not to the URL.</span>
<span class="comment-copy">I think I may see where I've gone wrong here, I'll do a quick re-work of my code and report back.  I think I've majorly messed up when I was initially reading documentation for the command.</span>
<span class="comment-copy">@Rybo: Oops, you are correct. Updated with a port of the code minus the <code>file://</code> support to make this work with a <code>Request</code> object too.</span>
<span class="comment-copy">This appears to have worked properly, thanks.</span>
