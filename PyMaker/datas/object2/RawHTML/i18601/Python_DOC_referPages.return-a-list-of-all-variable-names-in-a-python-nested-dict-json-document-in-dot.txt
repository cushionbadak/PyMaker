<div class="post-text" itemprop="text">
<p>I'm looking for a function that operates on a python arbitrarily nested dict/array in JSON-esque format and returns a list of strings keying all the variable names it contains, to infinite depth.  So, if the object is...</p>
<pre><code>x = {
    'a': 'meow',
    'b': {
        'c': 'asd'
    },
    'd': [
        {
            "e": "stuff",
            "f": 1
        },
        {
            "e": "more stuff",
            "f": 2
        }
    ]
}
</code></pre>
<p><code>mylist = f(x)</code> would return...</p>
<pre><code>&gt;&gt;&gt; mylist
['a', 'b', 'b.c', 'd[0].e', 'd[0].f', 'd[1].e', 'd[1].f']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def dot_notation(obj, prefix=''):
     if isinstance(obj, dict):
         if prefix: prefix += '.'
         for k, v in obj.items():
             for res in dot_notation(v, prefix+str(k)):
                 yield res
     elif isinstance(obj, list):
         for i, v in enumerate(obj):
             for res in dot_notation(v, prefix+'['+str(i)+']'):
                 yield res
     else:
         yield prefix
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; list(dot_notation(x))
['a', 'b.c', 'd[0].e', 'd[0].f', 'd[1].e', 'd[1].f']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a fun one. I solved it using recursion.</p>
<pre><code>def parse(d):
    return parse_dict(d)

def parse_dict(d):
    items = []
    for key, val in d.iteritems():
        if isinstance(val, dict):
            # use dot notation for dicts
            items += ['{}.{}'.format(key, vals) for vals in parse_dict(val)]
        elif isinstance(val, list):
            # use bracket notation for lists
            items += ['{}{}'.format(key, vals) for vals in parse_list(val)]
        else:
            # just use the key for everything else
            items.append(key)
    return items

def parse_list(l):
    items = []
    for idx, val in enumerate(l):
        if isinstance(val, dict):
            items += ['[{}].{}'.format(idx, vals) for vals in parse_dict(val)]
        elif isinstance(val, list):
            items += ['[{}]{}'.format(idx, vals) for vals in parse_list(val)]
        else:
            items.append('[{}]'.format(val))
    return items
</code></pre>
<p>Here is my result:</p>
<pre><code>&gt;&gt;&gt; parse(x)
['a', 'b.c', 'd[0].e', 'd[0].f', 'd[1].e', 'd[1].f']
</code></pre>
<h2>EDIT</h2>
<p>Here it is again using generators, because I liked the answer by F.j</p>
<pre><code>def parse(d):
    return list(parse_dict(d))

def parse_dict(d):
    for key, val in d.iteritems():
        if isinstance(val, dict):
            # use dot notation for dicts
            for item in parse_dict(val):
                yield '{}.{}'.format(key, item)
        elif isinstance(val, list):
            # use bracket notation
            for item in parse_list(val):
                yield '{}{}'.format(key, item)
        else:
            # lowest level - just use the key
            yield key

def parse_list(l):
    for idx, val in enumerate(l):
        if isinstance(val, dict):
            for item in parse_dict(val):
                yield '[{}].{}'.format(idx, item)
        elif isinstance(val, list):
            for item in parse_list(val):
                yield '[{}]{}'.format(idx, item)
        else:
            yield '[{}]'.format(val)
</code></pre>
<p>The same result:</p>
<pre><code>&gt;&gt;&gt; parse(x)
['a', 'b.c', 'd[0].e', 'd[0].f', 'd[1].e', 'd[1].f']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the top level of your object can be a list (array, in JSON terminology), your output format doesn't work: for e.g <code>["foo", "bar"]</code> you'd logically return <code>['[0]', '[1]']</code>, which probably isn't what you want. You can solve this by also passing in the name of the object to a slight modification of F.J's answer:</p>
<pre><code>def paths(container, name):
    if isinstance(container, list):
        for i, element in enumerate(container):
            for path in paths(element, "%s[%d]" % (name, i)):
                yield path
    elif isinstance(container, dict):
        for k, element in container.items():
            for path in paths(element, "%s.%s" % (name, k)):
                yield path
    else:
        yield name
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; list(paths(x, "x"))
['x.a', 'x.b.c', 'x.d[0].e', 'x.d[0].f', 'x.d[1].e', 'x.d[1].f']
&gt;&gt;&gt; list(paths(["foo", "bar"], "array"))
['array[0]', 'array[1]']
</code></pre>
<p>Python 3.3 introduces a <a href="http://docs.python.org/3/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator" rel="nofollow"><code>yield from</code></a> syntax which makes this a little cleaner:</p>
<pre><code>def paths(container, name):
    if isinstance(container, list):
        for i, element in enumerate(container):
            yield from paths(element, "%s[%d]" % (name, i))
    elif isinstance(container, dict):
        for k, element in container.items():
            yield from paths(element, "%s.%s" % (name, k))
    else:
        yield name
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Python 3.3+ only:</h2>
<pre><code>def f(x, parent=''):
    if isinstance(x, dict):
        if parent:
            parent += '.'
        for key in x:
            yield parent + key
            yield from f(x[key], parent + key)
    elif isinstance(x, list):
        for idx, subx in enumerate(x):
            yield from f(subx, '{}[{}]'.format(parent, idx))
</code></pre>
<h2>Python 2.x ~ Python 3.2</h2>
<pre><code>def f(x, parent=''):
    if isinstance(x, dict):
        if parent:
            parent += '.'
        for key in x:
            yield parent + key
            for y in f(x[key], parent + key): yield y
    elif isinstance(x, list):
        for idx, subx in enumerate(x):
            for y in f(subx, '{}[{}]'.format(parent, idx)): yield y
</code></pre>
<hr/>
<pre><code>&gt;&gt;&gt; x = {'a': 'meow', 'b': {'c': 'asd'}, 'd':[{"e":"stuff","f":1}, {"e":"more stuff","f":2}]}
&gt;&gt;&gt; list(f(x))
['d', 'd[0].e', 'd[0].f', 'd[1].e', 'd[1].f', 'a', 'b', 'b.c']
</code></pre>
</div>
<span class="comment-copy">Should <code>d</code> be in the list? If not, is <code>b</code> really supposed to be there?</span>
<span class="comment-copy">Is your top-level object always a dict? If not, what would you return for e.g. <code>["foo", "bar"]</code>? (<code>['[0]', '[1]']</code> presumably <i>wouldn't</i> be right).</span>
<span class="comment-copy">Good point, @Zero.  Yes, I can always assume the top level is a dict.</span>
<span class="comment-copy">+1 great, can't make it shorter!</span>
