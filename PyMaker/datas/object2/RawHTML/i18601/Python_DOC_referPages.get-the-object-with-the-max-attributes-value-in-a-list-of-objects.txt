<div class="post-text" itemprop="text">
<p>This is the code I written so far, and the point with the program is to read 20 people from a file and then assign them their attributes, then normalise their values from a input given by the user.</p>
<pre><code>class One:
    def __init__(self):
        self.attrOne = ()
        self.attrTwo = ()
        self.attrThree = ()
        self.attrFour = ()
        self.attrFive= ()
        self.attrSix = ()
        self.attrSeven = ()
        self.attrEight = ()
        self.attrNine = ()


class Two:

    def __init__(self):
        self.allPersons = []

   def importFromList(self, filename): 
       file= open(filename, "rU")
       for line in file:
           partOfList = line.split()                        
           x = Partner() 
           x.attrOne = partOfList[0]
           x.attrTwo = partOfList[1]
           x.attrThree = partOfList[2]
           x.attrFour = partOfList[3]
           x.attrFive = partOfList[4]
           x.attrSix = partOfList[5]
           x.attrSeven = partOfList[6]
           x.attrEight= partOfList[7]
           x.attrNine = partOfList[8]
           self.addPerson(x)
        file.close()

def addPerson(self, x):
    self.allPersons.append(x) 
</code></pre>
<p>What I wonder is how to loop through the attributes of the persons that is placed in allPersons list and then compare them against eachother to find out the max value. This is what I tried so far, but I can't get it to work </p>
<pre><code>def getMaxValue(self): 
    o = One()
    for eachPartner in self.allPartners:
        maxValuesAttrOne = max(O.attrOne))
</code></pre>
<p>All help will be appreciated, and I'm open for new solutions, also I imagine the importFromList method is not the most effective one, so if you got any objections I'm willing to listen and learn!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>max()</code> takes a <code>key</code> parameter, a function that when passed one of the objects returns the value by which to compare them.</p>
<p>Use <code>operator.attrgetter()</code> to get that value:</p>
<pre><code>from operator import attrgetter

max(self.allPartners, key=attrgetter('attrOne'))
</code></pre>
<p>This returns the matching object for which that attribute is the maximum. If you wanted to store just that maximum value itself, you have two options:</p>
<ul>
<li><p>Take the attribute from the returned object:</p>
<pre><code>max(self.allPartners, key=attrgetter('attrOne')).attrOne
</code></pre></li>
<li><p>Pass just the attributes instead to <code>max()</code> with a generator expression:</p>
<pre><code>max(p.attrOne for p in self.allPartners)
</code></pre></li>
</ul>
<p>If you find that you need to order the <code>One</code> classes in various directions by the same attribute again and again (to find the minimum, maximum, sort them, etc.) you may want to make your class <em>orderable</em> as well.</p>
<p>To do that, you'll need to implement <em>some</em> of the <a href="http://docs.python.org/3/reference/datamodel.html#basic-customization" rel="nofollow noreferrer">basic customization hooks</a> Python will look for. With some extra trickery, you can get away with just the lower-than and equals operations, and by using the <a href="http://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow noreferrer"><code>funtools.total_ordering</code> class decorator</a>:</p>
<pre><code>from functools import total_ordering

@total_ordering
class One:
    # ...
    def __lt__(self, other):
        if not isinstance(other, type(self)): return NotImplemented
        return self.attrOne &lt; other.attrOne

    def __eq__(self, other):
        if not isinstance(other, type(self)): return NotImplemented
        return self.attrOne == other.attrOne
</code></pre>
<p>Now your <code>One</code> class is orderable, entirely on the basis of <code>attrOne</code>; for the <code>max()</code> function, that means you can drop the <code>key</code> parameter altogether.</p>
</div>
<span class="comment-copy">Is there a reason you have 9 separate attributes named <code>attrOne</code> through <code>attrNine</code> instead of, say, a single attribute which is a list of 9 values, or a dict mapping 9 names to values?</span>
<span class="comment-copy">Also, why does class <code>One</code> have 9 attributes all set to an empty tuple, while <code>Partner</code> has 9 attributes with the same names each set to a string? That seems like a recipe for confusion…</span>
<span class="comment-copy">The attributes are definitions of a person, for example name, age and wealth. Renamned them before posting here. Is it better to do self.name = name instead of an empty tuple?  Also how do you mean by having a dict mapping 9 names to values, we didn't dig to deep on how to use dictionaries in the course I did, but would love an example! @abarnert</span>
<span class="comment-copy">If you actually have a name that you want to store, certainly it's better to store <code>self.name = name</code> instead of storing an empty tuple and then forgetting the name! But if you don't have a name, using <code>()</code> as an "initializing value" for an attribute meant to hold strings is very weird. Either don't initialize it at all (so there will be no <code>attrOne</code> attribute until you have a real value to store there—which is perfectly fine; you're allowed to add new attributes to objects after <code>__init__</code>), or initialize it to <code>''</code> or <code>None</code>.</span>
<span class="comment-copy">As for the <code>dict</code> idea… if these are real attributes like <code>name</code> and <code>age</code>, you probably don't want to do that. When you have a bunch of attributes with names like <code>attrOne</code> and <code>attrTwo</code>, that implies that you're going to be writing code that tries to read an attribute chosen dynamically based on some index or something, and that's almost always a bad idea. It doesn't sound like you have any intention of doing anything like that. So, don't worry about that part.</span>
<span class="comment-copy">tried the itemgetter solution, and I keep getting this error</span>
<span class="comment-copy">That's because there is an error in my answer; it should be <code>attrgetter</code> not <code>itemgetter</code>. Mea Culpa!</span>
<span class="comment-copy">For the record, <code>itemgetter</code> is used for item access. <code>dictionary['somekey']</code> or <code>alist[1]</code> are examples of item access, and the <code>itemgetter</code> callable is used for those. Attribute access on the other hand is <code>someobject.attrOne</code>, and you'd use <code>attrgetter</code> for that. Trying to use <code>itemgetter</code> anyway would raise a <code>TypeError</code> because your class doesn't define a <code>__getitem__</code> method...</span>
<span class="comment-copy">Tried the itemgetter solution, and I keep getting this error:           maxValues = max(self.allPartners, key=itemgetter('age'))     TypeError: 'Partner' object is not subscriptable  Please note that the names of the classes/methods may differ, sorry. Age is one of the attributes I want to get the max value from. If I understood objects correctly I should now have 20 (the number of persons in the file) partners placed in the allPartners list. For example writing in console.      p = Partners()     print (p.allPartners[0].age) gives the age of person 1.  Ps. Could only edit for 5 minutes.</span>
<span class="comment-copy">Attrgetter stopped the error from coming! Though maxValues = max(self.allPartners, key=attrgetter('age')) prints out Tony, the name of person nr 5. While max(self.allPartners, key=attrgetter('wealth')) prints out Victor the name of person 3. Haha i feel so confused right now. :) @Martijn Pieters</span>
