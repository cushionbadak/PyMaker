<div class="post-text" itemprop="text">
<p>I have this nested list:</p>
<pre><code>l = [['40', '20', '10', '30'], ['20', '20', '20', '20', '20', '30', '20'], ['30', '20', '30', '50', '10', '30', '20', '20', '20'], ['100', '100'], ['100', '100', '100', '100', '100'], ['100', '100', '100', '100']]
</code></pre>
<p>Now, what I want to do is convert each element in a list to float. My solution is this:</p>
<pre><code>newList = []
for x in l:
  for y in x:
    newList.append(float(y))
</code></pre>
<p>But can this be done using nested list comprehension, right?</p>
<p>what I've done is:</p>
<pre><code>[float(y) for y in x for x in l]
</code></pre>
<p>But then the result is bunch of 100's with the sum of 2400.</p>
<p>any solution, an explanation would be much appreciated. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is how you would do this with a nested list comprehension:</p>
<pre><code>[[float(y) for y in x] for x in l]
</code></pre>
<p>This would give you a list of lists, similar to what you started with except with floats instead of strings.  If you want one flat list then you would use <code>[float(y) for x in l for y in x]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is how to convert nested for loop to nested list comprehension:</p>
<p><a href="https://i.stack.imgur.com/0GoV5.gif" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/0GoV5.gif"/></a></p>
<p>Here is how nested list comprehension works:</p>
<pre><code>            l a b c d e f
            ↓ ↓ ↓ ↓ ↓ ↓ ↓
In [1]: l = [ [ [ [ [ [ 1 ] ] ] ] ] ]
In [2]: for a in l:
   ...:     for b in a:
   ...:         for c in b:
   ...:             for d in c:
   ...:                 for e in d:
   ...:                     for f in e:
   ...:                         print(float(f))
   ...:                         
1.0

In [3]: [float(f)
         for a in l
   ...:     for b in a
   ...:         for c in b
   ...:             for d in c
   ...:                 for e in d
   ...:                     for f in e]
Out[3]: [1.0]

#Which can be written in single line as
In [4]: [float(f) for a in l for b in a for c in b for d in c for e in d for f in e]
Out[4]: [1.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; l = [['40', '20', '10', '30'], ['20', '20', '20', '20', '20', '30', '20'], ['30', '20', '30', '50', '10', '30', '20', '20', '20'], ['100', '100'], ['100', '100', '100', '100', '100'], ['100', '100', '100', '100']]
&gt;&gt;&gt; new_list = [float(x) for xs in l for x in xs]
&gt;&gt;&gt; new_list
[40.0, 20.0, 10.0, 30.0, 20.0, 20.0, 20.0, 20.0, 20.0, 30.0, 20.0, 30.0, 20.0, 30.0, 50.0, 10.0, 30.0, 20.0, 20.0, 20.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure what your desired output is, but if you're using list comprehension, the order follows the order of nested loops, which you have backwards. So I got the what I think you want with:</p>
<pre><code>[float(y) for x in l for y in x]
</code></pre>
<p>The principle is: use the same order you'd use in writing it out as nested for loops.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since i am little late here but i wanted to share how actually list comprehension works especially nested list comprehension :</p>
<pre><code>   New_list= [[float(y) for x in l]
</code></pre>
<p>is actually same as :</p>
<pre><code>New_list=[]
for x in l:
    New_list.append(x)
</code></pre>
<p>And now nested list comprehension :</p>
<pre><code>[[float(y) for y in x] for x in l]
</code></pre>
<p>is same as ;</p>
<pre><code>new_list=[]
for x in l:
    sub_list=[]
    for y in x:
        sub_list.append(float(y))

    new_list.append(sub_list)

print(new_list)
</code></pre>
<p>output:</p>
<pre><code>[[40.0, 20.0, 10.0, 30.0], [20.0, 20.0, 20.0, 20.0, 20.0, 30.0, 20.0], [30.0, 20.0, 30.0, 50.0, 10.0, 30.0, 20.0, 20.0, 20.0], [100.0, 100.0], [100.0, 100.0, 100.0, 100.0, 100.0], [100.0, 100.0, 100.0, 100.0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't like nested list comprehensions, you can make use of the <a href="https://docs.python.org/2/tutorial/datastructures.html" rel="nofollow"><strong>map</strong></a> function as well, </p>
<pre><code>&gt;&gt;&gt; from pprint import pprint

&gt;&gt;&gt; l = l = [['40', '20', '10', '30'], ['20', '20', '20', '20', '20', '30', '20'], ['30', '20', '30', '50', '10', '30', '20', '20', '20'], ['100', '100'], ['100', '100', '100', '100', '100'], ['100', '100', '100', '100']] 

&gt;&gt;&gt; pprint(l)
[['40', '20', '10', '30'],
['20', '20', '20', '20', '20', '30', '20'],
['30', '20', '30', '50', '10', '30', '20', '20', '20'],
['100', '100'],
['100', '100', '100', '100', '100'],
['100', '100', '100', '100']]

&gt;&gt;&gt; float_l = [map(float, nested_list) for nested_list in l]

&gt;&gt;&gt; pprint(float_l)
[[40.0, 20.0, 10.0, 30.0],
[20.0, 20.0, 20.0, 20.0, 20.0, 30.0, 20.0],
[30.0, 20.0, 30.0, 50.0, 10.0, 30.0, 20.0, 20.0, 20.0],
[100.0, 100.0],
[100.0, 100.0, 100.0, 100.0, 100.0],
[100.0, 100.0, 100.0, 100.0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had a similar problem to solve so I came across this question. I did a performance comparison of Andrew Clark's and narayan's answer which I would like to share. </p>
<p>The primary difference between two answers is how they iterate over inner lists. One of them uses builtin <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer">map</a>, while other is using list comprehension. <a href="https://stackoverflow.com/a/1247490/5741172">Map function has slight performance advantage to its equivalent list comprehension if it doesn't require the use lambdas</a>. So in context of this question <code>map</code> should perform slightly better than list comprehension. </p>
<p>Lets do a performance benchmark to see if it is actually true. I used python version 3.5.0 to perform all these tests. In first set of tests I would like to keep elements per list to be <em>10</em> and vary number of lists from <em>10-100,000</em></p>
<pre><code>&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,10))]*10]"
&gt;&gt;&gt; 100000 loops, best of 3: 15.2 usec per loop   
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,10))]*10]"
&gt;&gt;&gt; 10000 loops, best of 3: 19.6 usec per loop 

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,10))]*100]"
&gt;&gt;&gt; 100000 loops, best of 3: 15.2 usec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,10))]*100]"
&gt;&gt;&gt; 10000 loops, best of 3: 19.6 usec per loop 

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,10))]*1000]"
&gt;&gt;&gt; 1000 loops, best of 3: 1.43 msec per loop   
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,10))]*1000]"
&gt;&gt;&gt; 100 loops, best of 3: 1.91 msec per loop

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,10))]*10000]"
&gt;&gt;&gt; 100 loops, best of 3: 13.6 msec per loop   
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,10))]*10000]"
&gt;&gt;&gt; 10 loops, best of 3: 19.1 msec per loop

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,10))]*100000]"
&gt;&gt;&gt; 10 loops, best of 3: 164 msec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,10))]*100000]"
&gt;&gt;&gt; 10 loops, best of 3: 216 msec per loop
</code></pre>
<p><a href="https://i.stack.imgur.com/dSbr5.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/dSbr5.png"/></a></p>
<p>In the next set of tests I would like to raise number of elements per lists to <em>100</em>.</p>
<pre><code>&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,100))]*10]"
&gt;&gt;&gt; 10000 loops, best of 3: 110 usec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,100))]*10]"
&gt;&gt;&gt; 10000 loops, best of 3: 151 usec per loop

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,100))]*100]"
&gt;&gt;&gt; 1000 loops, best of 3: 1.11 msec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,100))]*100]"
&gt;&gt;&gt; 1000 loops, best of 3: 1.5 msec per loop

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,100))]*1000]"
&gt;&gt;&gt; 100 loops, best of 3: 11.2 msec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,100))]*1000]"
&gt;&gt;&gt; 100 loops, best of 3: 16.7 msec per loop

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,100))]*10000]"
&gt;&gt;&gt; 10 loops, best of 3: 134 msec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,100))]*10000]"
&gt;&gt;&gt; 10 loops, best of 3: 171 msec per loop

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,100))]*100000]"
&gt;&gt;&gt; 10 loops, best of 3: 1.32 sec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,100))]*100000]"
&gt;&gt;&gt; 10 loops, best of 3: 1.7 sec per loop
</code></pre>
<p><a href="https://i.stack.imgur.com/hHCab.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/hHCab.png"/></a></p>
<p>Lets take a brave step and modify the number of elements in lists to be <em>1000</em></p>
<pre><code>&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,1000))]*10]"
&gt;&gt;&gt; 1000 loops, best of 3: 800 usec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,1000))]*10]"
&gt;&gt;&gt; 1000 loops, best of 3: 1.16 msec per loop

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,1000))]*100]"
&gt;&gt;&gt; 100 loops, best of 3: 8.26 msec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,1000))]*100]"
&gt;&gt;&gt; 100 loops, best of 3: 11.7 msec per loop

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,1000))]*1000]"
&gt;&gt;&gt; 10 loops, best of 3: 83.8 msec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,1000))]*1000]"
&gt;&gt;&gt; 10 loops, best of 3: 118 msec per loop

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,1000))]*10000]"
&gt;&gt;&gt; 10 loops, best of 3: 868 msec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,1000))]*10000]"
&gt;&gt;&gt; 10 loops, best of 3: 1.23 sec per loop

&gt;&gt;&gt; python -m timeit "[list(map(float,k)) for k in [list(range(0,1000))]*100000]"
&gt;&gt;&gt; 10 loops, best of 3: 9.2 sec per loop
&gt;&gt;&gt; python -m timeit "[[float(y) for y in x] for x in [list(range(0,1000))]*100000]"
&gt;&gt;&gt; 10 loops, best of 3: 12.7 sec per loop
</code></pre>
<p><a href="https://i.stack.imgur.com/BdJPU.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/BdJPU.png"/></a></p>
<p>From these test we can conclude that <code>map</code> has a performance benefit over list comprehension in this case. This is also applicable if you are trying to cast to either <code>int</code> or <code>str</code>.  For small number of lists with less elements per list, the difference is negligible. For larger lists with more elements per list one might like to use <code>map</code> instead of list comprehension, but it totally depends on application needs.</p>
<p>However I personally find list comprehension to be more readable and idiomatic than <code>map</code>. It is a de-facto standard in python. Usually people are more proficient and comfortable(specially beginner) in using list comprehension than <code>map</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can do it with such a code:</p>
<pre><code>l = [[float(y) for y in x] for x in l]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This Problem can be solved without using for loop.Single line code will be sufficient for this. Using Nested Map with lambda function will also works here.</p>
<pre><code>l = [['40', '20', '10', '30'], ['20', '20', '20', '20', '20', '30', '20'], ['30', '20', '30', '50', '10', '30', '20', '20', '20'], ['100', '100'], ['100', '100', '100', '100', '100'], ['100', '100', '100', '100']]

map(lambda x:map(lambda y:float(y),x),l)
</code></pre>
<p>And Output List would be as follows:</p>
<pre><code>[[40.0, 20.0, 10.0, 30.0], [20.0, 20.0, 20.0, 20.0, 20.0, 30.0, 20.0], [30.0, 20.0, 30.0, 50.0, 10.0, 30.0, 20.0, 20.0, 20.0], [100.0, 100.0], [100.0, 100.0, 100.0, 100.0, 100.0], [100.0, 100.0, 100.0, 100.0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best way to do this in my opinion is to use python's <code>itertools</code> package.</p>
<pre><code>&gt;&gt;&gt;import itertools
&gt;&gt;&gt;l1 = [1,2,3]
&gt;&gt;&gt;l2 = [10,20,30]
&gt;&gt;&gt;[l*2 for l in itertools.chain(*[l1,l2])]
[2, 4, 6, 20, 40, 60]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes you can do the following.</p>
<pre><code>[[float(y) for y in x] for x in l]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>    deck = [] 
    for rank in ranks:
        for suit in suits:
            deck.append(('%s%s')%(rank, suit))
</code></pre>
<p>This can be achieved using list comprehension:</p>
<pre><code>[deck.append((rank,suit)) for suit in suits for rank in ranks ]
</code></pre>
</div>
<span class="comment-copy">Do you <i>also</i> want to flatten your list?</span>
<span class="comment-copy">@GregHewgill: OP didn't reply, but based on the answer they accepted, seems they wanted to keep the nesting as is.</span>
<span class="comment-copy">Super useful! Makes it clear that loops (top-to-bottom) are ordered left to right in the generator. This not obvious since in <code>(f(x) for x in l)</code> places the second line of the for-loop equivalent on the left.</span>
<span class="comment-copy">this should be the answer, as some times we don't want to square bracket the iteratool</span>
<span class="comment-copy">this may not be the correct answer as it outputs a non nested list, but it is what I was looking for, specially <i>the principle</i>. Thanks!</span>
<span class="comment-copy">Your code generates map objects instead of lists:  <code>&gt;&gt;&gt; float_l = [map(float, nested_list) for nested_list in l]</code> <code>[[&lt;map at 0x47be9b0&gt;],  [&lt;map at 0x47be2e8&gt;],  [&lt;map at 0x47be4a8&gt;],  [&lt;map at 0x47beeb8&gt;],  [&lt;map at 0x484b048&gt;],  [&lt;map at 0x484b0b8&gt;]] </code>  but adding an additional call to list it works as expected:  <code>&gt;&gt;&gt; float_l = [list(map(float, nested_list)) for nested_list in l]</code></span>
<span class="comment-copy">@pixelperfect that is due to the (<i>misinformed</i> ..) change in <code>python3</code> to return generators out of comprehensions.</span>
<span class="comment-copy"><code>[float(y) for y in x for x in l]</code> this would result to a bunch of 100's with a sum of 2400.</span>
<span class="comment-copy">Do lambdas has any performance benefits over say @Andrew Clark or Harry Binswanger's solutions (the more vanilla list comprehension)? As lambdas seem harder to read.</span>
<span class="comment-copy">This does not appear to address the question on top at all. Please note that everything posted as an answer must be an attempt to answer the question it is posted to.</span>
<span class="comment-copy">While this code snippet may solve the question, <a href="//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers">including an explanation</a> really helps to improve the quality of your post. Remember that you are answering the question for readers in the future, and those people might not know the reasons for your code suggestion. Please also try not to crowd your code with explanatory comments, this reduces the readability of both the code and the explanations!</span>
<span class="comment-copy">Nested for loop using  list comprehension,</span>
<span class="comment-copy">Ok, so apparently, this is an attempt to answer the question. However, this appears to be about an entirely different scenario than in OP, you don't even deal with nested lists as input, and even if you change that your suggestion is pretty much what OP already tried. Also, I don't see how an example about cards helps when the question is about converting strings to float.</span>
