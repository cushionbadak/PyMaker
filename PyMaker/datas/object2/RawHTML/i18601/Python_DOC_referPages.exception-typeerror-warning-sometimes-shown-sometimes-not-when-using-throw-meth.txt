<div class="post-text" itemprop="text">
<p>There is this code:</p>
<pre><code>class MyException(Exception):
  pass

def gen():
  for i in range(3):
    try:
      yield i
    except MyException:
      print("MyException!")


a = gen()
next(a) 
a.throw(MyException)
</code></pre>
<p>Running this code:</p>
<pre><code>$ python3.3 main.py
MyException!
$ python3.3 main.py
MyException!
Exception TypeError: TypeError('catching classes that do not inherit from BaseException is not allowed',) in &lt;generator object gen at 0xb712efa4&gt; ignored
$ python3.3 main.py
MyException!
$ python3.3 main.py
MyException!
$ python3.3 main.py
MyException!
Exception TypeError: TypeError('catching classes that do not inherit from BaseException is not allowed',) in &lt;generator object gen at 0xb714afa4&gt; ignored
</code></pre>
<p>The thing which I don't understand is why sometimes there is printed this <code>Exception TypeError</code> warning. Is there something wrong with custom exception?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are seeing a  <code>__del__</code> hook misbehaving somewhere.</p>
<p>The <code>TypeError</code> is being thrown while <em>shutting down</em>, as the Python interpreter is exiting everything is deleted and any exceptions thrown in a <code>__del__</code> deconstructor hook are being ignored (but <em>are</em> printed). </p>
<p>On exit, Python clears everything in the namespace by rebinding everything to <code>None</code>, but the order in which this happens is not set. The still running generator is closed (<code>a.close()</code> is called) when deleted, which triggers a <code>GeneratorExit</code> exception in the generator, which Python tests against your <code>except MyException:</code> line. If, however, <code>MyException</code> has <em>already</em> been cleared up and Python sees <code>except None:</code> the <code>TypeError</code> is thrown and you see that message printed.</p>
<p>You can trigger the error without exiting Python by adding:</p>
<pre><code>MyException = None
del a
</code></pre>
<p>If you use <code>list(a)</code> and consume the rest of the generator, or explicitly close the generator with <code>a.close()</code> before Python exits and deletes <code>MyException</code>, the error message goes away.</p>
<p>Another work-around would be to handle <code>GeneratorExit</code> first:</p>
<pre><code>def gen():
  for i in range(3):
    try:
      yield i
    except GeneratorExit:
      return
    except MyException:
      print("MyException!")
</code></pre>
<p>and Python will not evaluate the next <code>except</code> handler.</p>
<p>The error cannot be reproduced with Python 3.2 or earlier, so it looks like <a href="http://docs.python.org/3/whatsnew/3.3.html#builtin-functions-and-types" rel="noreferrer">hash randomization</a> (introduced in Python 3.3) randomizes the order objects are cleared; this certainly explains why you see the error only on <em>some</em> of your runs, but not on earlier Python runs where the hash order is fixed.</p>
<p>Note that the interaction of <code>.__del__()</code> hooks and other global objects in Python is documented with a big red warning in the <a href="http://docs.python.org/3/reference/datamodel.html#object.__del__" rel="noreferrer"><code>.__del__()</code> documentation</a>:</p>
<blockquote>
<p><strong>Warning</strong>: Due to the precarious circumstances under which <code>__del__()</code> methods are invoked, exceptions that occur during their execution are ignored, and a warning is printed to <code>sys.stderr</code> instead. Also, when <code>__del__()</code> is invoked in response to a module being deleted (e.g., when execution of the program is done), other globals referenced by the <code>__del__()</code> method may already have been deleted or in the process of being torn down (e.g. the import machinery shutting down). For this reason, <code>__del__()</code> methods should do the absolute minimum needed to maintain external invariants. Starting with version 1.5, Python guarantees that globals whose name begins with a single underscore are deleted from their module before other globals are deleted; if no other references to such globals exist, this may help in assuring that imported modules are still available at the time when the <code>__del__()</code> method is called.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I was having this same error in Python 3.3 on Windows, with the difference that I was defining the exception in its own file. These were my code files:</p>
<pre><code>$ cat FooError.py 
class FooError(Exception):
    pass

$ cat application.py
import FooError
try:
    raise FooError('Foo not bar!')
Except FooError as e:
    print(e)
</code></pre>
<p>This was the exception that I was getting:</p>
<blockquote>
<p>TypeError: catching classes that do not inherit from BaseException is not allowed.</p>
</blockquote>
<p><strong>Changing <code>import FooError</code> to <code>from FooError import *</code> resolved the issue. Here is the final code, for clarity's sake:</strong></p>
<pre><code>$ cat FooError.py 
class FooError(Exception):
    pass

$ cat application.py
from FooError import *
try:
    raise FooError('Foo not bar!')
Except FooError as e:
    print(e)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had the same problem - but I was missing the import to the exception class. So the interpreter didn't resolve the class on the except clause.</p>
<p>So just add the import and hopefully everything will work.</p>
</div>
<span class="comment-copy">in python 2.7 the warning is never shown and code posted is the only code in the file.</span>
<span class="comment-copy">Python 3.2 also doesn't print that.</span>
<span class="comment-copy">With <code>del</code>, the much more logical NameError is raised.</span>
<span class="comment-copy">@PavelAnossov: Because then the exception is not rebound to <code>None</code>. I've updated my answer to better reflect that. :-)</span>
<span class="comment-copy">Seems like a bad idea to execute python code after rebinding a bunch of names to <code>None</code>.</span>
<span class="comment-copy">Would have worked if you just Except FooError.FooError since you can't catch the module :)</span>
<span class="comment-copy">@GuyL: Thanks! I don't have a Windows machine to test, but I suppose that <code>from FooError import FooError</code> would have worked as well.</span>
