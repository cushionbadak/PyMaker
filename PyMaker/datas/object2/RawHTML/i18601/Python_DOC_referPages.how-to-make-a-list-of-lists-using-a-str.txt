<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks">How do you split a list into evenly sized chunks?</a>
<span class="question-originals-answer-count">
                    57 answers
                </span>
</li>
</ul>
</div>
<p>I have a list</p>
<pre><code>['r', 'o', 'c', 'o', 'c', 'o']` 
</code></pre>
<p>and wish to make it </p>
<pre><code>[['r','o'], ['c', 'o'], ['c', 'o']]
</code></pre>
<p>how would I do this?
moreover, I need to make the new list grouped to whatever "n" is
in the above example, n is 2
if n is 3, the result should be:
[['r', 'o', 'c']['o','c','o']]</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertools</code> recipes</a> have a general-purpose function that does exactly what you're looking for with any kind of iterator, called <code>grouper</code>:</p>
<pre><code>&gt;&gt;&gt; values = ['r', 'o', 'c', 'o', 'c', 'o']
&gt;&gt;&gt; groups = grouper(values, 3)
</code></pre>
<p>However, this returns you an iterator. If you want a list, you have to ask for one explicitly:</p>
<pre><code>&gt;&gt;&gt; groups = list(grouper(values, 3))
&gt;&gt;&gt; print(groups)
[('r', 'o', 'c'), ('o', 'c', 'o')]
</code></pre>
<p>Also, note that this gives you a list of <em>tuples</em>, not a list of <em>lists</em>. Most likely this doesn't actually matter to you. But if it does, you'll have to convert them:</p>
<pre><code>&gt;&gt;&gt; list_groups = [list(group) for group in grouper(values, 3)]
&gt;&gt;&gt; print(list_groups)
[['r', 'o', 'c'], ['o', 'c', 'o']]
</code></pre>
<hr/>
<p>If you install <a href="https://pypi.python.org/pypi/more-itertools" rel="nofollow"><code>more_itertools</code></a> off PyPI, you can just <code>from more_itertools import grouper</code>. Otherwise, you'll have to copy and paste from the recipes into your code.</p>
<p>But either way, it's worth understanding how <code>grouper</code> works:</p>
<pre><code>def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx
    args = [iter(iterable)] * n
    return zip_longest(fillvalue=fillvalue, *args)
</code></pre>
<p>First, it creates an iterator out of your iterable. (This is something that keeps track of its current position and returns values one by one as you call <code>next</code> on it, until you've reached the end.) Then it makes <code>n</code> references to that iterator. This is the tricky bit—you don't want <code>n</code> separate iterators to the same list, you want <code>n</code> references to the <em>same</em> iterator, so if you grab the <code>next</code> value out of the first iterator, they <em>all</em> move forward. That's why it does the funny <code>[iter(iterable)] * n</code> bit. Then it just <code>zip</code>s the iterators together. So, the first pass through the <code>zip</code> calls <code>next</code> on the first iterator, then the second, then the third; the second pass through the <code>zip</code> again calls <code>next</code> on the first iterator, then the second, then the third; and so on.</p>
<p>The reason it uses <code>zip_longest</code> instead of just <code>zip</code> (or, in Python 2.x, <code>izip_longest</code> vs. <code>izip</code>) is so <code>list(grouper(['r', 'o', 'c', 'o'], 3))</code> will give you <code>[('r', 'o', 'c'), ('o', None, None)]</code> instead of just <code>[('r', 'o', 'c')]</code>. If that's not what you want, it's trivial to just use the other function instead.</p>
<p>For further explanation, see <a href="http://stupidpythonideas.blogspot.com/2013/08/how-grouper-works.html" rel="nofollow">this blog post</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Something like this?</p>
<pre><code>&gt;&gt;&gt; a = ['r', 'o', 'c', 'o', 'c', 'o']
&gt;&gt;&gt; zip(*[iter(a)]*2)
[('r', 'o'), ('c', 'o'), ('c', 'o')]

&gt;&gt;&gt; zip(*[iter(a)]*3)
[('r', 'o', 'c'), ('o', 'c', 'o')]
</code></pre>
<p>You can change the <code>2 and 3</code> to the number you want.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>[l[i:i+n] for i in range(0, len(l), n)]
</code></pre>
</div>
<span class="comment-copy">This is a more comprehensive version of my answer (which I deleted). +1, this is the correct way to do it.</span>
<span class="comment-copy">@arshajii: But your answer was more concise, which is why I upvoted it… I guess we don't really need two versions of the same thing, but I liked yours.</span>
<span class="comment-copy">this is good, but other solutions are more readable imo</span>
<span class="comment-copy">A potential problem here is that elements will start getting left out if the list can't be evenly partitioned. Try this with <code>4</code>, for example.</span>
<span class="comment-copy">@arshajii: That may or may not be what you want, of course. Usually it isn't, in which case you need to use <code>zip_longest</code> (and optionally pass a <code>fillvalue</code>).</span>
<span class="comment-copy">By the way, this is effectively equivalent to the <code>grouper</code> recipe; the only reason it's less readable is that it isn't wrapped up in a function (with a nice name for the function and params, and possibly comments). And, as I said in my answer, it really is worth being able to understand why this answer works.</span>
<span class="comment-copy">Yes, it just uses <code>zip()</code> instead of <code>zip_longest()</code>, should have used that though. Your answer was perfect @abarnert. :)</span>
