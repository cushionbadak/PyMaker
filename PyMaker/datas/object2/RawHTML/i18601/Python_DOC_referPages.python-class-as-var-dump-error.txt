<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/4984647/accessing-dict-keys-like-an-attribute">Accessing dict keys like an attribute?</a>
<span class="question-originals-answer-count">
                    23 answers
                </span>
</li>
</ul>
</div>
<p>I'm trying to make a VarDump class, where I can do:</p>
<pre><code>vd.attribute = value
</code></pre>
<p>and </p>
<pre><code>print vd.attribute
</code></pre>
<p>So, this is the code:</p>
<pre><code>class VarDump:

    def __init__(self):
        self.dump={}

    def __setattr__(self,item,var):
        self.dump[item]=var

    def __getattr__(self,item):
        if not item in self.dump: return ""
        return self.dump[item]

vd = VarDump()
vd.foo="bar"
print vd.foo
</code></pre>
<p>But I'm getting this error:</p>
<pre><code>File "classAsVarDump.py", line 9, in __getattr__
    if not item in self.dump: return ""
RuntimeError: maximum recursion depth exceeded
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>self.dump={}</code> calls <code>__setattr__</code> to set <code>dump</code>, which calls <code>__getattr__</code> to get the <code>dump</code> to put <code>dump</code> into, which calls <code>__getattr__</code> to get the <code>dump</code>, etc. You could resolve this with <code>object.__setattr__</code>, but the easier way is to just do this:</p>
<pre><code>class Namespace(object):
    def __getattr__(self, attr):
        return ''
</code></pre>
<p><code>__getattr__</code> is only called when the attribute isn't found by normal means, so this doesn't need to handle looking up attributes that have actually been set.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.3, use the new <a href="http://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow"><code>types.SimpleNamespace()</code> type</a> instead:</p>
<pre><code>&gt;&gt;&gt; from types import SimpleNamespace
&gt;&gt;&gt; vd = SimpleNamespace()
&gt;&gt;&gt; vd.foo = 'bar'
&gt;&gt;&gt; print(vd.foo)
bar
</code></pre>
<p>The documentation gives you a backwards-compatible version on a platter:</p>
<pre><code>class SimpleNamespace:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)
    def __repr__(self):
        keys = sorted(self.__dict__)
        items = ("{}={!r}".format(k, self.__dict__[k]) for k in keys)
        return "{}({})".format(type(self).__name__, ", ".join(items))
</code></pre>
<p>The only difference between your version and this one is that this one doesn't use <code>__setattr__</code> and <code>__getattr__</code> (not needed at all), this version takes initial values in the initializer, and it includes a nice representation:</p>
<pre><code>&gt;&gt;&gt; vd
namespace(foo='bar')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No need to override <code>__setattr__</code> or <code>__getattr__</code></p>
<pre><code>&gt;&gt;&gt; class VarDump(object):
...     pass
... 
&gt;&gt;&gt; c = VarDump()
&gt;&gt;&gt; c.bar = 2
&gt;&gt;&gt; print c.bar
2
</code></pre>
</div>
<span class="comment-copy">Actually, if that's all you need, <code>class VarDump(object): pass</code> is sufficient.</span>
<span class="comment-copy">+1, beat me to it :)</span>
<span class="comment-copy">Great, however I'm using Python 2.7</span>
<span class="comment-copy">@NacibNeme: That's why I included the backwards-compatible Python version right here in the answer. It works directly on Python 2.7.</span>
<span class="comment-copy">The problem is that I don't want they to be written to self.__dict__</span>
