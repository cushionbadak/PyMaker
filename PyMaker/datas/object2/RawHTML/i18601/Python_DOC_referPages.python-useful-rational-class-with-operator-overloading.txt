<div class="post-text" itemprop="text">
<p>So I'm trying to create the following class in python:</p>
<p>The class should use integer instance variables to store the numerator and denominator of the rational number.
The rational number must be stored in simplified form.
The sign of the rational number is reflected in the sign of the numerator.
The class must perform data verification to ensure the denominator is not zero.</p>
<p>Moreover I want to incorporate the following overloading opeartors:
+ and -
Arithmetic Operators
+   -   *   /   //
These operators should work with the following combination of parameter types:
(Rational, Rational)
(Rational, int)
(int, Rational)
Relational Operators
These are the binary operators   &lt;   &lt;=   ==   &gt;=   &gt;   !=
These operators should work with the following combination of parameter types:
(Rational, Rational)
(Rational, int)
(int, Rational)</p>
<p>I also want two different accessor methods:
numerator, which returns the rational number's numerator
denominator, which returns the rational number's denominator</p>
<p>Thanks guys!</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/fractions.html" rel="nofollow"><code>fractions.Fraction</code></a> does everything you need.</p>
</div>
<div class="post-text" itemprop="text">
<p>This task is relatively straightforward.</p>
<pre><code>class Rational(object):
    __slots__ = ['numerator', 'denominator']
    def __init__(self, numerator, denominator=1):
        # initialize and verify, divide both parameters by GCD of both
</code></pre>
<p>To implement operators, use the special method names:</p>
<pre><code>def __add__(self, other):
    # add rational to something else
def __radd__(self, other):
    # same, but with operands reversed
    return self + other
</code></pre>
<p>And then continue implementing <code>__sub__</code>, <code>__mul__</code>, etc.  A full list is available in the <a href="http://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow">Python Data Model: 3.37 Emulating numeric types</a> documentation section.  Comparison operators are named <code>__lt__</code>, <code>__le__</code>, etc.  You can implement the operations in the following way:</p>
<pre><code>def __add__(self, other):
    x_numer = self.numerator
    x_denom = self.denominator
    if isinstance(other, Rational):
        y_numer = other.numerator
        y_denom = other.denominator
    elif isinstance(other, int):
        y_numerator = other
        y_denominator = 1
    else:
        return NotImplemented
    return Rational(x_numer * y_denom + y_numer * x_denom, x_denom * y_denom)
</code></pre>
<p>There are other operators you probably to implement, like <code>__repr__</code> and <code>__str__</code>.</p>
<p>I hope this is enough to get you started, the other methods will be written just like <code>__add__</code> above.</p>
</div>
<span class="comment-copy">Dear Stackoverflow: I have this idea for something I've decided is marginally useful, please build it for me. Hire a contractor, we aren't here to do your work for you.</span>
<span class="comment-copy">*Volunteers to be hired for pay :D</span>
<span class="comment-copy">Timothy Budd's "Data Structures In C++" has a terrific Rational class implementation.  Port it to Python: <a href="https://rads.stackoverflow.com/amzn/click/com/0201508893" rel="nofollow noreferrer">amazon.com/Classic-Data-Structures-Timothy-Budd/dp/0201508893/â€¦</a></span>
<span class="comment-copy">that is awesome, thanks a lot!</span>
<span class="comment-copy">i'm not sure how to define the <b>init</b> part, any idea? thank you!</span>
<span class="comment-copy">1) Check that parameters have the correct type. 2) Divide numerator and denominator by the GCD of the numerator and denominator. 3) Store the results in the object.</span>
