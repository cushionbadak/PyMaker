<div class="post-text" itemprop="text">
<p>I have python 3 code that is not working as expected:</p>
<pre><code>def addFunc(x,y):
    print (x+y)

def subABC(x,y,z):
    print (x-y-z)

def doublePower(base,exp):
    print(2*base**exp)

def  RootFunc(inputDict):
    for k,v in inputDict.items():
        if v[0]==1:
            d[k] = addFunc(*v[1:])
        elif v[0] ==2:
            d[k] = subABC(*v[1:])
        elif  v[0]==3:
            d[k] = doublePower(*v[1:])


d={"s1_7":[1,5,2],"d1_6":[2,12,3,3],"e1_3200":[3,40,2],"s2_13":[1,6,7],"d2_30":[2,42,2,10]}
RootFunc(d)

#test to make sure key var assignment works
print(d)
</code></pre>
<p>I get:</p>
<pre><code>{'d2_30': None, 's2_13': None, 's1_7': None, 'e1_3200': None, 'd1_6': None}
</code></pre>
<p>I expected:</p>
<pre><code>{'d2_30': 30, 's2_13': 13, 's1_7': 7, 'e1_3200': 3200, 'd1_6': 6}
</code></pre>
<p>What's wrong? </p>
<p>Semi related: I know dictionaries are unordered but is there any reason why python picked this order? Does it run the keys through a randomizer?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>print</code> does not return a value. It returns <code>None</code>, so every time you call your functions, they're printing to standard output and returning <code>None</code>. Try changing all <code>print</code> statements to <code>return</code> like so:</p>
<pre><code> def addFunc(x,y):
     return x+y
</code></pre>
<p>This will give the value <code>x+y</code> back to whatever called the function.</p>
<p>Another problem with your code (unless you meant to do this) is that you define a dictionary <code>d</code> and then when you define your function, you are working on this dictionary <code>d</code> and not the dictionary that is 'input':</p>
<pre><code>def  RootFunc(inputDict):
    for k,v in inputDict.items():
        if v[0]==1:
            d[k] = addFunc(*v[1:])
</code></pre>
<p>Are you planning to always change <code>d</code> and <em>not</em> the dictionary that you are iterating over, <code>inputDict</code>?</p>
<p>There may be other issues as well (accepting a variable number of arguments within your functions, for instance), but it's good to address one problem at a time.</p>
<hr/>
<p><strong>Additional Notes on Functions:</strong></p>
<p>Here's some sort-of pseudocode that attempts to convey how functions are often used:</p>
<pre><code>def sample_function(some_data):
     modified_data = []
     for element in some_data:
          do some processing
          add processed crap to modified_data
     return modified_data
</code></pre>
<p>Functions are considered 'black box', which means you structure them so that you can dump some data into them and they always do the same stuff and you can call them over and over again. They will either <code>return</code> values or <code>yield</code> values or update some value or attribute or something (the latter are called 'side effects'). For the moment, just pay attention to the <code>return</code> statement. </p>
<p>Another interesting thing is that functions have 'scope' which means that when I just defined it with a fake-name for the argument, I don't actually have to have a variable called "some_data". I can pass whatever I want to the function, but inside the function I can refer to the fake name and create other variables that really only matter within the context of the function.</p>
<p>Now, if we run my function above, it will go ahead and process the data:</p>
<pre><code> sample_function(my_data_set)
</code></pre>
<p>But this is often kind of pointless because the function is supposed to return something and I didn't <em>do</em> anything with what it returned. What I should do is assign the value of the function and its arguments to some container so I can keep the processed information.</p>
<pre><code>my_modified_data = sample_function(my_data_set)
</code></pre>
<p>This is a really common way to use functions and you'll probably see it again.</p>
<hr/>
<p><strong>One Simple Way to Approach Your Problem:</strong></p>
<p>Taking all this into consideration, here is one way to solve your problem that comes from a really common programming paradigm:</p>
<pre><code>def  RootFunc(inputDict):
    temp_dict = {}
    for k,v in inputDict.items():
        if v[0]==1:
            temp_dict[k] = addFunc(*v[1:])
        elif v[0] ==2:
            temp_dict[k] = subABC(*v[1:])
        elif  v[0]==3:
            temp_dict[k] = doublePower(*v[1:])
    return temp_dict


  inputDict={"s1_7":[1,5,2],"d1_6":[2,12,3,3],"e1_3200":[3,40,2],"s2_13":[1,6,7],"d2_30"[2,42,2,10]}
  final_dict = RootFunc(inputDict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As erewok stated, you are using "print" and not "return" which may be the source of your error.  And as far as the ordering is concerned, you already know that dictionaries are unordered, according to python doc at least, the ordering is not random, but rather implemented as hash tables. </p>
<p>Excerpt from the <a href="http://docs.python.org/3/library/stdtypes.html#typesmapping" rel="nofollow">python doc</a>:  [...]A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary.  [...] </p>
<p>Now key here is that the order of the element is not really random.  I have often noticed that the order stays the same no matter how I construct a dictionary on some values... using lambda or just creating it outright, the order has always remained the same, so it can't be random, but it's definitely arbitrary. </p>
</div>
<span class="comment-copy">Your functions need to <code>return</code> values, not just print them.</span>
<span class="comment-copy">Your solution does work.  However I tried changing the part where I assign values (d[k]) to a variable with the value of inputDict. Items( your suggestion was what I wanted as my previous code would've had me change d[k] to foo[k] every time I wanted to use a new dictionary. This did not change the d dictionary. How do I change the table while using your modular approach?</span>
<span class="comment-copy">I think what you're describing is a new problem. You pass <code>inputDict</code> into the function, then you do some stuff with <code>inputDict</code> and then nothing happens after that. The reason for this is that, again, you aren't returning anything. Thus, at the end you should <code>return</code> the dictionary that has been modified. That's not the whole picture, however, because something would need to capture that value. Typically it works like this: functions process some data and give back the processed stuff with <code>return</code>. You then call the functions like this: <code>some_capturing_variable=RootFunc(d)</code></span>
<span class="comment-copy">Ok I think I'm starting to get it. However returning inputDict won't do anything because I am modifying inputDict.items(). Returning this doesn't do anything either. When I return either one any print d I get the original value of d</span>
<span class="comment-copy">It's also generally a bad idea to modify something that you are iterating over. You will usually create an empty container to hold the values you want, iterate over the input data, and while iterating and processing, you will add the processed data to your container. Check out my notes on functions and they may be useful.</span>
<span class="comment-copy">Where are these notes? Sorry to be such a pest!  And I take it there is no way to get around the return inputDict.items not changing anything problem?</span>
