<div class="post-text" itemprop="text">
<p>I observe a strange behaviour with Python 3 unittest. Following Testcase tests in function <code>testValue</code> a module that does not exist.</p>
<pre><code>import sys
import unittest

class ModuleTest(unittest.TestCase):

    def testValue(self):
        import unknown_module
        result = unknown_module.value

        self.assertEqual(0.0, result)


if __name__ == "__main__":
    print(sys.version)
    unittest.main()
</code></pre>
<p>Python2 gives correctly following output:</p>
<pre><code>2.7.5 (default, May 15 2013, 22:44:16) [MSC v.1500 64 bit (AMD64)]
E
======================================================================
ERROR: testValue (__main__.ModuleTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\bin\WinPython-64bit-2.7.5.1\workspace\unknown_module_test.py", line 7, in testValue
    import unknown_module
ImportError: No module named unknown_module

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (errors=1)
</code></pre>
<p>But Python 3 claims an AttributeError when the <code>unknown_module.value</code> is referenced.</p>
<pre><code>3.3.0 (v3.3.0:bd8afb90ebf2, Sep 29 2012, 10:55:48) [MSC v.1600 32 bit (Intel)]
E
======================================================================
ERROR: testValue (__main__.ModuleTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "unknown_module_test.py", line 8, in testValue
    result = unknown_module.value
AttributeError: 'module' object has no attribute 'value'

----------------------------------------------------------------------
Ran 1 test in 0.016s

FAILED (errors=1)
</code></pre>
<p>Why doesn't throw Python 3 an <code>ImportError</code> as Python 2 does?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are importing an <em>implicit namespace</em> package. Quoting from the <a href="http://docs.python.org/3/whatsnew/3.3.html#pep-420-implicit-namespace-packages" rel="nofollow noreferrer">Python 3.3 What's New page</a>:</p>
<blockquote>
<p>Native support for package directories that donâ€™t require __init__.py marker files and can automatically span multiple path segments (inspired by various third party approaches to namespace packages, as described in PEP 420)</p>
</blockquote>
<p>and <a href="http://www.python.org/dev/peps/pep-0420/" rel="nofollow noreferrer">PEP 420 Implicit Namespace Packages</a>:</p>
<blockquote>
<p>If the scan completes without returning a module or package, and at least one directory was recorded, then a namespace package is created. The new namespace package:</p>
<ul>
<li>Has a <code>__path__</code> attribute set to an iterable of the path strings that were found and recorded during the scan.</li>
<li>Does not have a <code>__file__</code> attribute.</li>
</ul>
</blockquote>
<p>and</p>
<blockquote>
<p>Namespace packages and regular packages are very similar. The differences are:</p>
<ul>
<li>Portions of namespace packages need not all come from the same directory structure, or even from the same loader. Regular packages are self-contained: all parts live in the same directory hierarchy.</li>
<li>Namespace packages have no <code>__file__</code> attribute.</li>
<li>Namespace packages' <code>__path__</code> attribute is a read-only iterable of strings, which is automatically updated when the parent path is modified.</li>
<li>Namespace packages have no <code>__init__.py</code> module.</li>
<li>Namespace packages have a different type of object for their <code>__loader__</code> attribute.</li>
</ul>
</blockquote>
<p>Remove the <code>unknown_module</code> directory from your <code>sys.path</code> and your test will fail the way it did in earlier Python versions.</p>
</div>
<span class="comment-copy">No, can't reproduce this. I just get an <code>ImportError</code>. What is the <i>real</i> name of your unknown module? Are you 100% certain that you didn't find a module added to Python 3 you did not know about? What does <code>print(unknown_module.__file__)</code> tell you was imported?</span>
<span class="comment-copy">I think the module <code>unknown_module</code> exists somewhere in Python 3.3 module search path. (not in Python 2.7 module path).</span>
<span class="comment-copy">@Martijn Pieters : It gives the error <code>AttributeError: 'module' object has no attribute '__file__'</code>.</span>
<span class="comment-copy">@Holger: but there <i>is</i> a module object? Sounds like a built-in module in that case. What does <code>print(unknown_module.__name__)</code> give? Or better still, give us <code>print(dir(unknown_module))</code>.</span>
<span class="comment-copy">@Martijn Pieters : It gives <code>unknown_module</code> and <code>['__doc__', '__initializing__', '__loader__', '__name__', '__package__', '__path__']</code> on the module search path. I found out that I have an empty directory <code>unknown_module</code>, but there is no file <code>__init__.py</code> in it. But this is still mandatory to declare a package in <code>Python 3</code>, isn't it?</span>
<span class="comment-copy">Ok, that's new in 3.3. But, isn't that in contradiction to what is written below <a href="http://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer">documentation</a>. There it is written <i>The <b>init</b>.py files are required to make Python treat the directories as containing packages</i>. I relied on that.</span>
<span class="comment-copy">It doesn't quite contradict the new namespace feature (you still need a <code>__init__.py</code> if the directory is <i>not</i> a namespace package, e.g. it contains actual modules). Yet the tutorial could do with some updating there.</span>
<span class="comment-copy">OK, thank you very much.</span>
