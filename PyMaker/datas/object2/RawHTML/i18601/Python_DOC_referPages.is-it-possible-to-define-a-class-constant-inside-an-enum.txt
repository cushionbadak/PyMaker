<div class="post-text" itemprop="text">
<p>Python 3.4 introduces a new module <a href="http://docs.python.org/3.4/library/enum.html"><code>enum</code></a>, which adds an <a href="http://en.wikipedia.org/wiki/Enumerated_type">enumerated type</a> to the language. The documentation for <code>enum.Enum</code> provides <a href="http://docs.python.org/3.4/library/enum.html#planet">an example</a> to demonstrate how it can be extended:</p>
<pre><code>&gt;&gt;&gt; class Planet(Enum):
...     MERCURY = (3.303e+23, 2.4397e6)
...     VENUS   = (4.869e+24, 6.0518e6)
...     EARTH   = (5.976e+24, 6.37814e6)
...     MARS    = (6.421e+23, 3.3972e6)
...     JUPITER = (1.9e+27,   7.1492e7)
...     SATURN  = (5.688e+26, 6.0268e7)
...     URANUS  = (8.686e+25, 2.5559e7)
...     NEPTUNE = (1.024e+26, 2.4746e7)
...     def __init__(self, mass, radius):
...         self.mass = mass       # in kilograms
...         self.radius = radius   # in meters
...     @property
...     def surface_gravity(self):
...         # universal gravitational constant  (m3 kg-1 s-2)
...         G = 6.67300E-11
...         return G * self.mass / (self.radius * self.radius)
...
&gt;&gt;&gt; Planet.EARTH.value
(5.976e+24, 6378140.0)
&gt;&gt;&gt; Planet.EARTH.surface_gravity
9.802652743337129
</code></pre>
<p>This example also demonstrates a problem with <code>Enum</code>: in the <code>surface_gravity()</code> property method, a constant <code>G</code> is defined which would normally be defined at class level - but attempting to do so inside an <code>Enum</code> would simply add it as one of the members of the enum, so instead it's been defined inside the method.</p>
<p>If the class wanted to use this constant in other methods, it'd have to be defined there as well, which obviously isn't ideal.</p>
<p>Is there any way to define a class constant inside an <code>Enum</code>, or some workaround to achieve the same effect?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is advanced behavior which will not be needed in 90+% of the enumerations created.</p>
<p>According to the docs:</p>
<blockquote>
<p>The rules for what is allowed are as follows: <code>_sunder_</code> names (starting and ending with a single underscore) are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of <code>__dunder__</code> names and <code>descriptors</code> (methods are also descriptors).</p>
</blockquote>
<p>So if you want a class constant you have several choices:</p>
<ul>
<li>create it in <code>__init__</code></li>
<li>add it after the class has been created</li>
<li>use a mixin</li>
<li>create your own <code>descriptor</code></li>
</ul>
<p>Creating the constant in <code>__init__</code> and adding it after the class has been created both suffer from not having all the class info gathered in one place.</p>
<p>Mixins can certainly be used when appropriate (<a href="https://stackoverflow.com/a/18075283/1733117">see dnozay's answer for a good example</a>), but that case can also be simplified by having a base <code>Enum</code> class with the actual constants built in.</p>
<p>First, the constant that will be used in the examples below:</p>
<pre><code>class Constant:  # use Constant(object) if in Python 2
    def __init__(self, value):
        self.value = value
    def __get__(self, *args):
        return self.value
    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.value)
</code></pre>
<p>And the single-use Enum example:</p>
<pre><code>from enum import Enum

class Planet(Enum):
    MERCURY = (3.303e+23, 2.4397e6)
    VENUS   = (4.869e+24, 6.0518e6)
    EARTH   = (5.976e+24, 6.37814e6)
    MARS    = (6.421e+23, 3.3972e6)
    JUPITER = (1.9e+27,   7.1492e7)
    SATURN  = (5.688e+26, 6.0268e7)
    URANUS  = (8.686e+25, 2.5559e7)
    NEPTUNE = (1.024e+26, 2.4746e7)

    # universal gravitational constant
    G = Constant(6.67300E-11)

    def __init__(self, mass, radius):
        self.mass = mass       # in kilograms
        self.radius = radius   # in meters
    @property
    def surface_gravity(self):
        return self.G * self.mass / (self.radius * self.radius)

print(Planet.__dict__['G'])             # Constant(6.673e-11)
print(Planet.G)                         # 6.673e-11
print(Planet.NEPTUNE.G)                 # 6.673e-11
print(Planet.SATURN.surface_gravity)    # 10.44978014597121
</code></pre>
<p>And, finally, the multi-use Enum example:</p>
<pre><code>from enum import Enum

class AstronomicalObject(Enum):

    # universal gravitational constant
    G = Constant(6.67300E-11)

    def __init__(self, mass, radius):
        self.mass = mass
        self.radius = radius
    @property
    def surface_gravity(self):
        return self.G * self.mass / (self.radius * self.radius)

class Planet(AstronomicalObject):
    MERCURY = (3.303e+23, 2.4397e6)
    VENUS   = (4.869e+24, 6.0518e6)
    EARTH   = (5.976e+24, 6.37814e6)
    MARS    = (6.421e+23, 3.3972e6)
    JUPITER = (1.9e+27,   7.1492e7)
    SATURN  = (5.688e+26, 6.0268e7)
    URANUS  = (8.686e+25, 2.5559e7)
    NEPTUNE = (1.024e+26, 2.4746e7)

class Asteroid(AstronomicalObject):
    CERES = (9.4e+20 , 4.75e+5)
    PALLAS = (2.068e+20, 2.72e+5)
    JUNOS = (2.82e+19, 2.29e+5)
    VESTA = (2.632e+20 ,2.62e+5

Planet.MERCURY.surface_gravity    # 3.7030267229659395
Asteroid.CERES.surface_gravity    # 0.27801085872576176
</code></pre>
<hr/>
<p><strong>Note</strong>:</p>
<p>The <code>Constant</code> <code>G</code> really isn't.  One could rebind <code>G</code> to something else:</p>
<pre><code>Planet.G = 1
</code></pre>
<p>If you really need it to be constant (aka not rebindable), then use the <a href="https://pypi.python.org/pypi/aenum" rel="noreferrer">new aenum library</a> [1] which will block attempts to reassign <code>constant</code>s as well as <code>Enum</code> members.</p>
<hr/>
<p><sup>1</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="noreferrer">Advanced Enumeration (<code>aenum</code>)</a>  library.</p>
</div>
<div class="post-text" itemprop="text">
<p>The most elegant solution (IMHO) is to use mixins / base class to provide the correct behavior.</p>
<ul>
<li>base class to provide the behavior that's needed for all implementation that's common to e.g. <code>Satellite</code> and <code>Planet</code>.</li>
<li><a href="https://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-are-they-useful">mixins are interesting</a> if you decide to provide optional behavior (e.g. <code>Satellite</code> and <code>Planet</code> may have to provide a different behavior)</li>
</ul>
<p>Here is an example, where you first define your behavior:</p>
<pre><code>#
# business as usual, define your class, methods, constants...
#
class AstronomicalObject:
    # universal gravitational constant
    G = 6.67300E-11
    def __init__(self, mass, radius):
        self.mass = mass       # in kilograms
        self.radius = radius   # in meters

class PlanetModel(AstronomicalObject):
    @property
    def surface_gravity(self):
        return self.G * self.mass / (self.radius * self.radius)

class SatelliteModel(AstronomicalObject):
    FUEL_PRICE_PER_KG = 20000
    @property
    def fuel_cost(self):
        return self.FUEL_PRICE_PER_KG * self.mass
    def falling_rate(self, destination):
        return complicated_formula(self.G, self.mass, destination)
</code></pre>
<p>Then create your <code>Enum</code> with the correct base classes / mixins.</p>
<pre><code>#
# then create your Enum with the correct model.
#
class Planet(PlanetModel, Enum):
    MERCURY = (3.303e+23, 2.4397e6)
    VENUS   = (4.869e+24, 6.0518e6)
    EARTH   = (5.976e+24, 6.37814e6)
    MARS    = (6.421e+23, 3.3972e6)
    JUPITER = (1.9e+27,   7.1492e7)
    SATURN  = (5.688e+26, 6.0268e7)
    URANUS  = (8.686e+25, 2.5559e7)
    NEPTUNE = (1.024e+26, 2.4746e7)

class Satellite(SatelliteModel, Enum):
    GPS1 = (12.0, 1.7)
    GPS2 = (22.0, 1.5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from enum import Enum


class classproperty(object):
    """A class property decorator"""

    def __init__(self, getter):
        self.getter = getter

    def __get__(self, instance, owner):
        return self.getter(owner)


class classconstant(object):
    """A constant property from given value,
       visible in class and instances"""

    def __init__(self, value):
        self.value = value

    def __get__(self, instance, owner):
        return self.value


class strictclassconstant(classconstant):
    """A constant property that is
       callable only from the class """

    def __get__(self, instance, owner):
        if instance:
            raise AttributeError(
                "Strict class constants are not available in instances")

        return self.value


class Planet(Enum):
    MERCURY = (3.303e+23, 2.4397e6)
    VENUS   = (4.869e+24, 6.0518e6)
    EARTH   = (5.976e+24, 6.37814e6)
    MARS    = (6.421e+23, 3.3972e6)
    JUPITER = (1.9e+27,   7.1492e7)
    SATURN  = (5.688e+26, 6.0268e7)
    URANUS  = (8.686e+25, 2.5559e7)
    NEPTUNE = (1.024e+26, 2.4746e7)
    def __init__(self, mass, radius):
        self.mass = mass       # in kilograms
        self.radius = radius   # in meters

    G = classconstant(6.67300E-11)

    @property
    def surface_gravity(self):
        # universal gravitational constant  (m3 kg-1 s-2)
        return Planet.G * self.mass / (self.radius * self.radius)


print(Planet.MERCURY.surface_gravity)
print(Planet.G)
print(Planet.MERCURY.G)

class ConstantExample(Enum):
    HAM  = 1
    SPAM = 2


    @classproperty
    def c1(cls):
        return 1

    c2 = classconstant(2)

    c3 = strictclassconstant(3)

print(ConstantExample.c1, ConstantExample.HAM.c1)
print(ConstantExample.c2, ConstantExample.SPAM.c2)
print(ConstantExample.c3)


# This should fail:
print(ConstantExample.HAM.c3)
</code></pre>
<p>The reason why @property does NOT work and classconstant DOES work is quite simple, and explained in the <a href="https://stackoverflow.com/a/6193656/918959">answer here</a></p>
<blockquote>
<p>The reason that the actual property object is returned when you access
  it via a class Hello.foo lies in how the property implements the
  <code>__get__(self, instance, owner)</code> special method. If a descriptor is accessed on an instance, then that instance is passed as the
  appropriate argument, and owner is the class of that instance.</p>
<p>On the other hand, if it is accessed through the class, then instance
  is None and only owner is passed. <em>The property object recognizes this
  and returns self.</em></p>
</blockquote>
<p>Thus, the code in <code>classproperty</code> is actually a generalization of <code>property</code>, lacking the <code>if instance is None</code> part.</p>
</div>
<div class="post-text" itemprop="text">
<p>A <a href="http://docs.python.org/3.4/library/functions.html#property" rel="nofollow"><code>property</code></a> can be used to provide most of the behaviour of a class constant:</p>
<pre><code>class Planet(Enum):

    # ...

    @property
    def G(self):
        return 6.67300E-11

    # ...

    @property
    def surface_gravity(self):
        return self.G * self.mass / (self.radius * self.radius)
</code></pre>
<p>This would be a little unwieldy if you wanted to define a large number of constants, so you could define a helper function outside the class:</p>
<pre><code>def constant(c):
    """Return a class property that returns `c`."""
    return property(lambda self: c)
</code></pre>
<p>... and use it as follows:</p>
<pre><code>class Planet(Enum):

    # ...

    G = constant(6.67300E-11)
</code></pre>
<p>One limitation of this approach is that it will only work for instances of the class, and not the class itself:</p>
<pre><code>&gt;&gt;&gt; Planet.EARTH.G
6.673e-11
&gt;&gt;&gt; Planet.G
&lt;property object at 0x7f665921ce58&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>TLDR; NO, it can not be done inside an Enum class. </p>
<p>This said, as the other answers showed, there are ways to get such class owned values associated to an Enum (i.e. via class inheritance / mixins) but such values are not "defined .. inside an Enum".    </p>
</div>
<span class="comment-copy">What's the problem with a module-level constant?</span>
<span class="comment-copy">@delnan sometimes a constant is specific to a class.</span>
<span class="comment-copy">I know the example is from the official docs, but is it really a good idea? This could be a <code>has-a</code> relationship instead of <code>is-a</code>.</span>
<span class="comment-copy">Is there an advantage or disadvantage to your <code>Constant</code> class over the <code>classconstant()</code> function returning a closure that @AnttiHaapala suggested? I notice that <code>Planet.__dict__['G']</code> has a slightly nicer <code>repr</code> in your version; is there anything else?</span>
<span class="comment-copy">@ZeroPiraeus: It's simpler and easier to read, therefore more <i>pythonic</i> ;) .  If you want a nice <code>__repr__</code>, add one.  I just did.</span>
<span class="comment-copy">Hmm indeed, I am thinking like what was I thinking when using a closure.</span>
<span class="comment-copy">I understand what you mean; but to me a canonical answer means best/standard/authoritative which is different from exhaustive/complete.</span>
<span class="comment-copy">@dnozay: I did not mean to offend.  Both my original solution and yours have their place.  Because of that, the canonical answer should include both of them.</span>
<span class="comment-copy">You have a small error: <code>G = Constant(6.67300E-11)</code> should be <code>G = 6.67300E-11</code>.</span>
<span class="comment-copy">@ZeroPiraeus, fixed it, thanks for catching that.</span>
<span class="comment-copy">I reworked my answer to point to yours for the mixin example.  Please don't ever delete your answer.  ;)</span>
<span class="comment-copy">Something has been changed from python 2; in python 2 at some point if <b>get</b> throws any AttributeError, on the outside it is shown simply as "Bar object has no attribute foo", but does not seem to be the case on Python 3 anymore.</span>
