<div class="post-text" itemprop="text">
<p>Trying to address <a href="https://github.com/facebook/tornado/issues/868">this issue</a>, I'm trying to wrap my head around the various functions in the Python standard library aimed at supporting <a href="http://tools.ietf.org/html/rfc2231">RFC 2231</a>. The main aim of that RFC appears to be three-fold: allowing non-ASCII encoding in header parameters, noting the language of a given value, and allowing header parameters to span multiple lines. The <a href="http://docs.python.org/3/library/email.util.html#email.utils.decode_rfc2231"><code>email.util</code> library</a> provides several functions to deal with various aspects of this. As far as I can tell, they work as follows:</p>
<p><a href="http://docs.python.org/3/library/email.util.html#email.utils.decode_rfc2231"><code>decode_rfc2231</code></a> only splits the value of such a parameter into its parts, like this:</p>
<pre><code>&gt;&gt;&gt; email.utils.decode_rfc2231("utf-8''T%C3%A4st.txt")
['utf-8', '', 'T%C3%A4st.txt']
</code></pre>
<p><a href="http://docs.python.org/3/library/email.util.html#email.utils.decode_params"><code>decode_params</code></a> takes care of detecting RFC2231-encoded parameters. It collects parts which belong together, and also decodes the url-encoded string to a byte sequence. This byte sequence, however, is then encoded as latin1. And all values are enclosed in quotation marks. Furthermore, there is some special handling for the first argument, which still has to be a tuple of two elements, but those two get passed to the result without modification.</p>
<pre><code>&gt;&gt;&gt; email.utils.decode_params([
...   (1,2),
...   ("foo","bar"),
...   ("name*","utf-8''T%C3%A4st.txt"),
...   ("baz*0","two"),("baz*1","-part")])
[(1, 2), ('foo', '"bar"'), ('baz', '"two-part"'), ('name', ('utf-8', '', '"TÃ¤st.txt"'))]
</code></pre>
<p><a href="http://docs.python.org/3/library/email.util.html#email.utils.collapse_rfc2231_value"><code>collapse_rfc2231_value</code></a> can be used to convert this triple of encoding, language and byte sequence into a proper unicode string. What has me confused, though, is the fact that if the input was such a triple, then the quotes will be carried over to the output. If, on the other hand, the input was a single quoted string, then these quotes will be removed.</p>
<pre><code>&gt;&gt;&gt; [(k, email.utils.collapse_rfc2231_value(v)) for k, v in
...  email.utils.decode_params([
...   (1,2),
...   ("foo","bar"),
...   ("name*","utf-8''T%C3%A4st.txt"),
...   ("baz*0","two"),("baz*1","-part")])[1:]]
[('foo', 'bar'), ('baz', 'two-part'), ('name', '"Täst.txt"')]
</code></pre>
<p>So it seems that in order to use all this machinery, I'd have to add yet another step to unquote the third element of any tuple I'd encounter. Is this true, or am I missing some point here? I had to figure out a lot of the above with help from the source code, since the docs are a bit vague on the details. I cannot imagine what could be the point behind this selective unquoting. Is there a point to it?</p>
<p><strong>What is the best reference on how to use these functions?</strong></p>
<p>The best I found so far is the <a href="http://docs.python.org/3/library/email.message.html#email.message.Message"><code>email.message.Message</code></a> <a href="http://hg.python.org/cpython/file/c3896275c0f6/Lib/email/message.py">implementation</a>. There, the process seems to be roughly the one outlined above, but every field gets unquoted via <a href="http://hg.python.org/cpython/file/c3896275c0f6/Lib/email/message.py#l95"><code>_unquotevalue</code></a> after the <code>decode_params</code>, and only <a href="http://docs.python.org/3/library/email.message.html#email.message.Message.get_filename"><code>get_filename</code></a> and <a href="http://docs.python.org/3/library/email.message.html#email.message.Message.get_boundary"><code>get_boundary</code></a> collapse their values, all others return a tuple instead. I hope there is something more useful.</p>
</div>
<div class="post-text" itemprop="text">
<p>Currently the functions from <code>email.utils</code> are rarely used besides within <code>email.message</code>. Most users seem to prefer using <code>email.message.Message</code> directly. There's even a somewhat old <a href="http://bugs.python.org/issue17733" rel="nofollow">issue report</a> on adding unit tests (that would certainly be usable as examples) to Python, even if I'm not sure on how it relates to <code>email.util</code>.</p>
<p>A short example I found is <a href="http://blog.magiksys.net/parsing-email-using-python-content" rel="nofollow">this blogpost</a> which, however, doesn't contain more than once sentence and a few SLOCs of information about RFC2231 parsing. The author notes, however, that many MTAs use <a href="https://www.ietf.org/rfc/rfc2047.txt" rel="nofollow">RFC2047</a> instead. Depending on your usecase, that might also be an issue.</p>
<p>Judging from the few examples I could find I assume your way of parsing using <code>email.util</code> is the only way to go, even if the long list comprehension is somewhat ugly.</p>
<p>Because of the lack of examples in some respect it could be wise to write a new RFC2231 parser (if you really need a better, maybe faster or more beautiful codebase). A new implementation could be based on existing implementations like the <a href="http://hg.dovecot.org/dovecot-1.2/file/96b5d6d8dd2c/src/lib-mail/rfc2231-parser.c" rel="nofollow">Dovecot RFC2231 parser</a> for compatibility reasons (you could even use the <a href="http://opensource.apple.com/source/dovecot/dovecot-239.4/dovecot/src/lib-mail/test-rfc2231-parser.c" rel="nofollow">Dovecot unit test</a>. As the C code seems quite complex to me and since I can't find any python implementation besides <code>email.util</code> and Python2 backports of <code>email.util</code> the task of porting to Python won't be easy (note that Dovecot is <a href="http://www.dovecot.org/doc/COPYING" rel="nofollow">LGPL-licensed</a>, which might be an issue in your project)</p>
<p>I think the <code>email.util</code> RFC2231 API has not been designed for easy standalone usage but more as a pile of utility methods for use in <code>email.message.Message</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Old question, but I could not find a complete answer that works on this. So this is what I ended up doing (on Python 2.7):</p>
<pre><code>def decode_rfc2231_header(header):
    """Decode a RFC 2231 header"""
    # Remove any quotes
    header = email.utils.unquote(header)
    encoding, language, value = email.utils.decode_rfc2231(header)
    value = urllib.unquote(value)
    return email.utils.collapse_rfc2231_value((encoding, language, value))
</code></pre>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; name = u'èéêëēėęûüùúūàáâäæãåāāîïíīįì test ôöòóœøōõssśšłžźżçćčñń'
&gt;&gt;&gt; encoded_header = email.utils.encode_rfc2231(name.encode("utf8"), 'utf8', 'en')
&gt;&gt;&gt; print encoded_header 
utf8'en'%C3%A8%C3%A9%C3%AA%C3%AB%C4%93%C4%97%C4%99%C3%BB%C3%BC%C3%B9%C3%BA%C5%AB%C3%A0%C3%A1%C3%A2%C3%A4%C3%A6%C3%A3%C3%A5%C4%81%C4%81%C3%AE%C3%AF%C3%AD%C4%AB%C4%AF%C3%AC%20test%20%C3%B4%C3%B6%C3%B2%C3%B3%C5%93%C3%B8%C5%8D%C3%B5ss%C5%9B%C5%A1%C5%82%C5%BE%C5%BA%C5%BC%C3%A7%C4%87%C4%8D%C3%B1%C5%84
&gt;&gt;&gt; print decode_rfc2231_header(encoded_header)
èéêëēėęûüùúūàáâäæãåāāîïíīįì test ôöòóœøōõssśšłžźżçćčñń
</code></pre>
</div>
<span class="comment-copy">Not an answer, but we had a long discussion about RFC 2231 that might be useful to you in another question. It was about form fields, though. — <a href="http://stackoverflow.com/questions/20591599/why-arent-post-names-with-unicode-sent-correctly-when-using-multipart-form-data/20592910#20592910" title="why arent post names with unicode sent correctly when using multipart form data">stackoverflow.com/questions/20591599/…</a></span>
<span class="comment-copy">@RobStarling: Thanks! RFC 2231 has been <a href="http://stackoverflow.com/q/13514713/1468366">haunting me for some time now</a>, particularly since <a href="https://github.com/facebook/tornado/pull/869#issuecomment-23632083" rel="nofollow noreferrer">someone pointed out</a> that <a href="http://www.w3.org/html/wg/drafts/html/master/forms.html#multipart-form-data" rel="nofollow noreferrer">HTML5 requires <i>not</i> using it for file names</a>. But HTML5 isn't a standard yet…</span>
<span class="comment-copy">oh great. the HTML5 folks are tweaking HTTP? Ugh.</span>
<span class="comment-copy">I would go either higher (use <code>Message</code> interface, i.e., always <code>unquote</code>) or lower (inline <code>decode_params</code>, <code>collapse_rfc2231_value</code>  -- don't add unnecessary quotes in the first place)</span>
