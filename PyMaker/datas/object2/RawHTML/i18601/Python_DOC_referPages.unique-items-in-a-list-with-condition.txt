<div class="post-text" itemprop="text">
<p>If i have a list in python say</p>
<pre><code>thing = [[20,0,1],[20,0,2],[20,1,1],[20,0],[30,1,1]]
</code></pre>
<p>I would want to have a resulting list</p>
<pre><code>thing = [[20,1,1],[20,0,2],[30,1,1]]
</code></pre>
<p>That is if the first element is the same, remove duplicates and give priority to the number 1 in the second element. Lastly the 3rd element must also be unique to the first element.</p>
<p>In this <a href="https://stackoverflow.com/questions/17827536/django-template-not-iterating-through-list">previous question</a> we solved a complicated method where for a transaction it details a purchased unit. I want to output other units in that course. If two transactions exist that relate to two units in one course it will display them a duplicate (or times each subsequent unit).</p>
<p>The aim of this question it to ensure that this duplication is stopped. Because of the complication of this solution it has resulted in a series of question. Thanks for everyone that has helped so far.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure you would like this, but it works with your example:</p>
<pre><code>[list(i) + j for i, j in dict([(tuple(x[:2]), x[2:]) for x in sorted(thing, key=lambda x:len(x))]).items()]
</code></pre>
<p>EDIT:</p>
<p>Here a bit more detailed (note that it fits better to your description of the problem, sorting ONLY by the length of each sublist, may not be the best solution):</p>
<pre><code>thing = [[20,0,1],[20,0,2],[20,1,1],[20,0],[30,1,1]]
dico = {}
for x in thing:
    if not tuple(x[:2]) in dico:
        dico[tuple(x[:2])] = x[2:]
        continue
    if tuple(x[:2])[1] &lt; x[1]:
        dico[tuple(x[:2])] = x[2:]

new_thing = []
for i, j in dico.items():
    new_thing.append(list(i) + j)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might want to try using the <code>unique_everseen</code> function from the <a href="http://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">itertools recipes</a>.</p>
<p>As a first step, here is a solution excluding <code>[20, 0]</code>:</p>
<pre><code>from itertools import filterfalse

def unique_everseen(iterable, key=None):
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D
    # unique_everseen('ABBCcAD', str.lower) --&gt; A B C D
    seen = set()
    seen_add = seen.add
    if key is None:
        for element in filterfalse(seen.__contains__, iterable):
            seen_add(element)
            yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen_add(k)
                yield element

thing = [[20,0,1],[20,0,2],[20,1,1],[30,1,1]]

thing.sort(key=lambda x: 0 if x[1] == 1 else 1)

print(list(unique_everseen(thing, key=lambda x: (x[0], x[2]))))
</code></pre>
<p>Output:</p>
<pre><code>[[20, 1, 1], [30, 1, 1], [20, 0, 2]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>thing = [[20,0,1],[20,0,2],[20,1,1],[20,0,1],[30,1,1]]

d = {}
for e in thing:
    k = (e[0], e[2])
    if k not in d or (d[k][1] != 1 and e[1] == 1):
        d[k] = list(e)

print d.values()

[[20, 0, 2], [30, 1, 1], [20, 1, 1]]
</code></pre>
<p>if you don't need initial list:</p>
<pre><code>thing = [[20,0,1],[20,0,2],[20,1,1],[20,0,1],[30,1,1]]

d = {}
for e in thing:
    k = (e[0], e[2])
    if k not in d or (d[k][1] != 1 and e[1] == 1):
        d[k] = e

thing = d.values()

[[20, 0, 2], [30, 1, 1], [20, 1, 1]]
</code></pre>
<p>if you want to keep order of your lists, use OrderedDict</p>
<pre><code>from collections import OrderedDict
d = OrderedDict()
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/6926928/get-unique-items-from-list-of-lists">Get unique items from list of lists?</a></span>
<span class="comment-copy">No this is different as you can see we are looking at the individual values in a multidimensional list.</span>
<span class="comment-copy">use sets to remove duplicates, but sets come with a disadvantage as it's not ordered however there's a geeky function yourset.oderedDict() or something to order it or so(not sure but check on pythons official documentation for sets)</span>
<span class="comment-copy">I am ok with no ordering as i will use a for loop and an id statement on the first element in display. My problem is the duplication. Not my strongest point, so it would be awesome and point worthy if someone made a cool loop for me. Thanks</span>
<span class="comment-copy">Shouldn't resulting list be <code>thing = [[20,1,1],[30,1,1]]</code>? Why you save <code>[20,0,2]</code> element? And what about third element? Where should it come from?</span>
<span class="comment-copy">can you give a bit more explanation around how this works?</span>
<span class="comment-copy">It doesn't work for input <code>thing = [[20,0,1],[20,0,2],[20,1,1],[20,1,2]]</code>, output should be <code>[[20, 1, 2], [20, 1, 1]]</code> and your solution gives <code>[[20, 1, 2], [20, 0, 2]]</code></span>
<span class="comment-copy">@RomanPekar I think it do have to return [[20, 1, 2], [20, 0, 2]]... but I can be missunderstanding something...</span>
<span class="comment-copy"><code>[list(i) + j for i, j in {tuple(x[:2]): x[2:] for x in sorted(thing, key=len)}.items()]</code> would be a cleaner version of the original list comprehension.</span>
<span class="comment-copy">I don't know, may be it's my English, by I see a "give priority to the number 1 in the second element" in the description of the question. Your solution doesn't check for this condition.</span>
<span class="comment-copy">That ignores the requirement to put priority for items with <code>i[1]==1</code>.</span>
<span class="comment-copy">@simon, i really like this solution except the priority to '1' is absent.</span>
<span class="comment-copy">Updated for this requirement.</span>
<span class="comment-copy">@Simon thanks for your help, your solution is long winded, however does work. Check out the two ones at the top they are short and i assume less resource intensive.</span>
<span class="comment-copy">Roman Pekar this solution is so elegant! Thank you very much for your help.</span>
<span class="comment-copy">Apologies Roman, there exists two working solutions, and fransua's was the first one given, so i have to give the accepted solution based on that merit.</span>
<span class="comment-copy">no prob, Alex, but I don't think that fransua's solution works for arbitrary input of given problem. Also I think that long list/dictionary comrehensions is less readable and maintainable that simple loops</span>
<span class="comment-copy">I am just implementing the solution now. Will let you know how i go.</span>
<span class="comment-copy">Both solutions work, but yours maintains order. Thanks Roman, awesome job.</span>
