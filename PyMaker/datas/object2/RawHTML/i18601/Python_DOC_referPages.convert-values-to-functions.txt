<div class="post-text" itemprop="text">
<p>The following code converts values to functions:</p>
<pre><code>&gt;&gt;&gt; a = map(lambda(x): lambda: x, [1, 2])
&gt;&gt;&gt; [func() for func in a]
[1, 2]
</code></pre>
<p>However the following snippet fails:</p>
<pre><code>&gt;&gt;&gt; a = [lambda: x for x in [1, 2]]
&gt;&gt;&gt; [func() for func in a]
[2, 2]
</code></pre>
<p>Is this aberration a parameter name binding artifact?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is about scope. Functions define new scope; iterations of a list comprehension, like <code>for</code> loops and other block statements, do not.</p>
<p>The Python Programming FAQ question <a href="http://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" rel="nofollow">Why do lambdas defined in a loop with different values all return the same result?</a> explains this at a high level. I'll try a different explanation, skimming over the high level and then diving deeper.</p>
<p>You first version is calling a function that returns <code>lambda: x</code> for each element. Because functions define new scopes, each such returned function has its own separate <code>x</code>.</p>
<p>Your second version is just defining a <code>lambda: x</code> for each element. Because you're doing this all in the same scope, each such defined function has the same <code>x</code>. In fact, because <code>x</code> is found at global scope, it's the global <code>x</code> that each one has, as you can see by doing this:</p>
<pre><code>&gt;&gt;&gt; b = [lambda: x for x in [1, 2]]
&gt;&gt;&gt; x = 20
&gt;&gt;&gt; [func() for func in b]
[20, 20]
</code></pre>
<hr/>
<p>You can fix this by defining and calling a function, making the second version equivalent to the first, or work around it in the usual ways, such as the "default parameter hack":</p>
<pre><code>&gt;&gt;&gt; c = [lambda x=x: x for x in [1, 2]]
&gt;&gt;&gt; [func() for func in c]
[1, 2]
</code></pre>
<hr/>
<p>It's worth looking at what's stored in the function objects to see the difference:</p>
<pre><code>&gt;&gt;&gt; a = map(lambda(x): lambda: x, [1, 2])
&gt;&gt;&gt; [f.__closure__ for f in a]
[(&lt;cell at 0x106523e50: int object at 0x7fb6a3c10298&gt;,),
 (&lt;cell at 0x106523fa0: int object at 0x7fb6a3c10280&gt;,)]
&gt;&gt;&gt; [f.__code__.co_freevars for f in a]
(('x',), ('x',))
</code></pre>
<p>So, here, each function is a closure with a single cell, each named <code>x</code>, but each holding a reference to a different <code>int</code> objects (the value <code>x</code> was bound to each time through the loop).</p>
<pre><code>&gt;&gt;&gt; b = [lambda: x for x in [1, 2]]
&gt;&gt;&gt; [f.__closure__ for f in b]
[None, None]
&gt;&gt;&gt; [f.__code__.co_freevars for f in b]
((), ())
&gt;&gt;&gt; [f.__code__.co_names for f in b]
(('x',), ('x',))
</code></pre>
<p>So these aren't closures at all, just functions that reference a global variable.</p>
<pre><code>&gt;&gt;&gt; c = [lambda x=x: x for x in [1, 2]]
&gt;&gt;&gt; [f.__closure__ for f in b]
[None, None]
&gt;&gt;&gt; [f.__code__.co_freevars for f in c]
((), ())
&gt;&gt;&gt; [f.__code__.co_names for f in c]
((), ())
&gt;&gt;&gt; [f.__code__.co_varnames for f in c]
(('x',), ('x',))
&gt;&gt;&gt; [f.__defaults__ for f in c]
((1,), (2,))
</code></pre>
<p>Here, no closure, and no globals; we've got a local variable bound to the first parameter whose default value is 1 or 2, respectively. Since you're calling <code>func</code> with no arguments, you get the default value.</p>
<hr/>
<p>Alternatively, you can look at the disassembly:</p>
<pre><code>&gt;&gt;&gt; dis.dis(a[0])
  1           0 LOAD_DEREF               0 (x)
              3 RETURN_VALUE        
&gt;&gt;&gt; dis.dis(b[0])
  1           0 LOAD_GLOBAL              0 (x)
              3 RETURN_VALUE        
&gt;&gt;&gt; dis.dis(c[0])
  1           0 LOAD_FAST                0 (x)
              3 RETURN_VALUE        
</code></pre>
<p>But I doubt there are too many people who know Python bytecode, but don't know the inspectable values of functions, so… this probably doesn't help too much.</p>
<hr/>
<p>Finally, this is all probably a lot easier to think about—and maybe to read—if you move the function-defining functions out-of-line, and use <code>def</code> instead of <code>lambda</code>.</p>
<pre><code>&gt;&gt;&gt; def make_function(x):
...     def function():
...         return x
...     return function
&gt;&gt;&gt; a = map(make_function, [1, 2])
&gt;&gt;&gt; b = [make_function(x) for x in [1, 2]]
</code></pre>
<p>Now both <code>a</code> and <code>b</code> are doing the same thing—calling a function that returns a function—and there's nothing to get confused about.</p>
</div>
<span class="comment-copy"><code>lambda x=x: x</code></span>
<span class="comment-copy">@JBernardo: If you explain that instead of just giving him code he won't understand, that will be a perfect answer.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/2295290/what-do-lambda-function-closures-capture-in-python">What do (lambda) function closures capture in Python?</a></span>
<span class="comment-copy">I used to think the most common thing that confuses people in these cases is that a <code>for</code> loop looks like it's defining a scope, to people coming from C++ derived languages. Which is what most of the answers there assume. But that can't be it. Nobody would expect a new scope here (unless they know how CPython 3.x implements listcomps under the covers… but anyone who knows that much would have already gotten through this question long before). So… why <i>is</i> this confusing? (Clearly it is; <i>everyone</i> makes this mistake at some point while learning Python, not just Fred Loney.)</span>
