<div class="post-text" itemprop="text">
<p>I have these two implementations to compute the length of a finite generator, while keeping the data for further processing:</p>
<pre><code>def count_generator1(generator):
    '''- build a list with the generator data
       - get the length of the data
       - return both the length and the original data (in a list)
       WARNING: the memory use is unbounded, and infinite generators will block this'''
    l = list(generator)
    return len(l), l

def count_generator2(generator):
    '''- get two generators from the original generator
       - get the length of the data from one of them
       - return both the length and the original data, as returned by tee
       WARNING: tee can use up an unbounded amount of memory, and infinite generators will block this'''
    for_length, saved  = itertools.tee(generator, 2)
    return sum(1 for _ in for_length), saved
</code></pre>
<p>Both have drawbacks, both do the job. Could somebody comment on them, or even offer a better alternative?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have to do this, the first method is much better - as you consume all the values, <code>itertools.tee()</code> will have to store all the values anyway, meaning a list will be more efficient.</p>
<p>To quote from <a href="http://docs.python.org/3/library/itertools.html#itertools.tee">the docs</a>:</p>
<blockquote>
<p>This itertool may require significant auxiliary storage (depending on
  how much temporary data needs to be stored). In general, if one
  iterator uses most or all of the data before another iterator starts,
  it is faster to use list() instead of tee().</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I ran Windows 64-bit Python 3.4.3 <code>timeit</code> on a few approaches I could think of:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; from textwrap import dedent as d
&gt;&gt;&gt; timeit(
...     d("""
...     count = -1
...     for _ in s:
...         count += 1
...     count += 1
...     """),
...     "s = range(1000)",
... )
50.70772041983173
&gt;&gt;&gt; timeit(
...     d("""
...     count = -1
...     for count, _ in enumerate(s):
...         pass
...     count += 1
...     """),
...     "s = range(1000)",
... )
42.636973504498656
&gt;&gt;&gt; timeit(
...     d("""
...     count, _ = reduce(f, enumerate(range(1000)), (-1, -1))
...     count += 1
...     """),
...     d("""
...     from functools import reduce
...     def f(_, count):
...         return count
...     s = range(1000)
...     """),
... )
121.15513102540672
&gt;&gt;&gt; timeit("count = sum(1 for _ in s)", "s = range(1000)")
58.179126025925825
&gt;&gt;&gt; timeit("count = len(tuple(s))", "s = range(1000)")
19.777029680237774
&gt;&gt;&gt; timeit("count = len(list(s))", "s = range(1000)")
18.145157531932
&gt;&gt;&gt; timeit("count = len(list(1 for _ in s))", "s = range(1000)")
57.41422175998332
</code></pre>
<p>Shockingly, the fastest approach was to use a <code>list</code> (not even a <code>tuple</code>) to exhaust the iterator and get the length from there:</p>
<pre><code>&gt;&gt;&gt; timeit("count = len(list(s))", "s = range(1000)")
18.145157531932
</code></pre>
<p>Of course, this risks memory issues.  The best low-memory alternative was to use enumerate on a NOOP <code>for</code>-loop:</p>
<pre><code>&gt;&gt;&gt; timeit(
...     d("""
...     count = -1
...     for count, _ in enumerate(s):
...         pass
...     count += 1
...     """),
...     "s = range(1000)",
... )
42.636973504498656
</code></pre>
<p>Cheers!</p>
</div>
<span class="comment-copy">There is no way to know the length of an iterable generator without consuming the entire thing.</span>
<span class="comment-copy">I know. That is not the question</span>
<span class="comment-copy">note: if if you don't need the precise length then you could use <a href="http://docs.python.org/dev/library/operator#operator.length_hint" rel="nofollow noreferrer"><code>operator.length_hint()</code> (Python 3.4+)</a> that returns an estimated length without consuming the iterator. See <a href="http://www.python.org/dev/peps/pep-0424/" rel="nofollow noreferrer">PEP 424 - A method for exposing a length hint</a></span>
<span class="comment-copy">@J.F.Sebastian That's a nice addition for 3.4</span>
<span class="comment-copy">@gonvaled: length_hint will call __length_hint__(), which is tricky to implement on a generator.</span>
<span class="comment-copy">Well, in both cases I am consuming the generator, and storing the full data. In the first by creating a <code>list</code>, in the second just because <code>tee</code> has to do the same (or a similar thing). I think that getting the length of the list is faster (already part of the list object?), that is why I tend to prefer the first method. From the point of view of memory consumption, both seem equivalent, right?</span>
<span class="comment-copy">@gonvaled Memory usage will probably be similar, but as I quote from the docs, making a list will be faster.</span>
<span class="comment-copy">ok, that was my impression too. Thanks.</span>
