<div class="post-text" itemprop="text">
<p>So, I'm trying to be a good Python programmer and duck-type wherever I can, but I've got a bit of a problem where my input is either a <code>dict</code> or a <code>list</code> of <code>dict</code>s.</p>
<p>I can't distinguish between them being iterable, because they both are.</p>
<p>My next thought was simply to call <code>list(x)</code> and hope that returned my list intact and gave me my dict as the only item in a list; alas, it just gives me the list of the dict's keys.</p>
<p>I'm now officially out of ideas (short of calling <code>isinstance</code> which is, as we all know, not very pythonic). I just want to end up with a list of dicts, even if my input is a single solitary dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>Really, there is no obvious pythonic way to do this, because it's an unreasonable input format, and the obvious pythonic way to do it is to fix the input…</p>
<p>But if you can't do that, then yes, you need to write an adapter (as close to the input edge as possible). The best way to do that depends on the actual data. If it really is either a dict, or a list of dicts, and nothing else is possible (e.g., you're calling <code>json.loads</code> on the results from some badly-written service that returns an object or an array of objects), then there's nothing wrong with <code>isinstance</code>.</p>
<p>If you want to make it a bit more general, you can use the appropriate <a href="http://docs.python.org/3/library/collections.abc.html" rel="nofollow">ABCs</a>. For example:</p>
<pre><code>if isinstance(dict_or_list, collections.abc.Mapping):
    return [dict_or_list]
else:
    return dict_or_list
</code></pre>
<p>But unless you have some good reason to need this generality, you're just hiding the hacky workaround, when you're better off keeping it as visible as possible. If it's, e.g., coming out of <code>json.loads</code> from some remote server, handling a <code>Mapping</code> that isn't a <code>dict</code> is not useful, right?</p>
<p>(If you're using some third-party client library that just returns you "something dict-like" or "something list-like containing dict-like things", then yes, use ABCs. Or, if that library doesn't even support the proper ABCs, you can write code that tries a specific method like <code>keys</code>. But if that's an issue, you'll know the specific details you're working around, and can code and document appropriately.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Accessing a <code>dict</code> using a non-<code>int</code> key will get you either an item, or a <code>KeyError</code>. It will get you a <code>TypeError</code> with a <code>list</code>. So you can use exception handling:</p>
<pre><code>def list_dicts(dict_or_list):
    try:
        dict_or_list[None]
        return [dict_or_list]  # no error, we have a dict
    except TypeError:
        return dict_or_list    # wrong index type, we have a list
    except Exception:
        return [dict_or_list]  # probably KeyError but catch anything to be safe
</code></pre>
<p>This function will give you a <code>list</code> of <code>dicts</code> regardless of whether it got a <code>list</code> or a <code>dict</code>. (If it got a <code>dict</code>, it makes a list of one item out of it.) This should be fairly safe type-wise, too; other <code>dict</code>-like or <code>list</code>-like objects would probably be considered broken if they didn't have similar behavior.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe I'm being naive, but how about something like</p>
<pre><code>try:
    data.keys()
    print "Probs just a dictionary"    
except AttributeError:
    print "List o' dictionaries!"
</code></pre>
<p>Can you just go ahead and do whatever you were going to do anyways with the data, and decide whether it's a dict or list when something goes awry?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could check for the presence of an <code>items</code> attribute.</p>
<p><code>dict</code> has it and <code>list</code> does not.</p>
<pre><code>&gt;&gt;&gt; hasattr({}, 'items')
True

&gt;&gt;&gt; hasattr([], 'items')
False
</code></pre>
<hr/>
<p>Here's a complete list of the differences in attribute names between <code>dict</code> and <code>list</code> (in Python 3.3.2).</p>
<p>Attributes on <code>list</code> but not <code>dict</code>:</p>
<pre><code>&gt;&gt;&gt; print('\n'.join(sorted(list(set(dir([])) - set(dir({}))))))
__add__
__iadd__
__imul__
__mul__
__reversed__
__rmul__
append
count
extend
index
insert
remove
reverse
sort
</code></pre>
<p>Attributes on <code>dict</code> but not <code>list</code>:</p>
<pre><code>&gt;&gt;&gt; print('\n'.join(sorted(list(set(dir({})) - set(dir([]))))))
fromkeys
get
items
keys
popitem
setdefault
update
values
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Don't</strong> use the types module:</p>
<pre><code>import types

d = {}
print type(d) is types.DictType

l = [{},{}]
print type(l) is types.ListType and len(l) and type(l[0]) is types.DictType
</code></pre>
</div>
<span class="comment-copy">Where does this input come from? If you can make <i>it</i> consistent, that's really your best option. If you can't for some reason, then yeah, doing it as close to the edge as possible is your only real option…</span>
<span class="comment-copy"><code>isinstance</code> is not very pythonic? I'm going to go ahead and break that rule if so. Also, there's a few recipes in the Python cookbook with it. If you guys say <code>isinstance</code> is not Pythonic enough, I'm going to start wondering what kind of a monastery I've joined.</span>
<span class="comment-copy">It is consistent... it's coming from JSON. Obviously <code>isinstance</code> will work for just about all input. It's really just a philosophical question... I'm asking because I'm sure there's some brilliant, terse, pythonic way I haven't thought of, that will make me feel better.</span>
<span class="comment-copy">@erewok I meant in the sense that <code>isinstance</code> necessarily prevents ducktyping, which is not pythonic IMHO.</span>
<span class="comment-copy">@MorganHarris: A badly-written JSON service was my first guess. Yeah, nothing you can do about that except write a workaround and document it clearly.</span>
<span class="comment-copy">Yeah. I was more wondering in a general sense. I didn't realise that even stuff like <code>dict</code> and <code>list</code> inherited from the <code>collections</code> ABCs, though, that's cool to know.</span>
<span class="comment-copy">@MorganHarris: The cool thing about ABCs (compared to, say, Java interfaces) is classes can be registered with an ABC without actually inheriting from it. So, even though <code>list</code> is actually a builtin-type that doesn't inherit from anything, <code>isinstance([], Sequence)</code> is still True.</span>
<span class="comment-copy">... wat? How do you do that? Not that I can ever imagine actually needing to, but it'd be cool to know.</span>
<span class="comment-copy">@MorganHarris: It's explained in the docs, but it may be easier to just look at <a href="http://hg.python.org/cpython/file/3.3/Lib/collections/abc.py#l727" rel="nofollow noreferrer">the source</a>. See that call to <code>MutableSequence.register(list)</code>? That's all it takes to tell Python that <code>list</code> implements <code>MutableSequence</code> (and therefore all of its ancestors <code>Sequence</code>, <code>Sized</code>, <code>Iterable</code>, <code>Container</code>).</span>
<span class="comment-copy">First, comparing types for equality is a bad idea. If you get, say, an <code>OrderedDict</code>, <code>isinstance(dict)</code> or <code>isinstance(Mapping)</code> will be true, but <code>type is dict</code> will not. <a href="http://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="nofollow noreferrer">PEP 8</a> recommends <code>isinstance</code> for exactly this reason.</span>
<span class="comment-copy">Second, unless you're writing Python 1.x code or something, why use <code>types.DictType</code> and <code>types.ListType</code>? In 3.x, those redundant types don't even exist; in 2.x, they do, but <a href="http://docs.python.org/2/library/types.html" rel="nofollow noreferrer">the documentation</a> explicitly says that the builtins are "the preferred way to access the type instead of using the <code>types</code> module".</span>
<span class="comment-copy">Finally, quoting <a href="http://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="nofollow noreferrer">PEP 8</a>: "For sequences, (strings, lists, tuples), use the fact that empty sequences are false." And the example of what not to do is exactly what you did: using <code>len(l)</code> to check for an empty sequence.</span>
<span class="comment-copy">Hey thanks abarnert for your thorough response.</span>
