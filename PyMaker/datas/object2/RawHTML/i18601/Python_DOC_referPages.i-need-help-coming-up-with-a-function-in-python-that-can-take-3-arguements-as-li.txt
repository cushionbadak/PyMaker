<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/464864/how-to-get-all-possible-combinations-of-a-list-s-elements">How to get all possible combinations of a listâ€™s elements?</a>
<span class="question-originals-answer-count">
                    24 answers
                </span>
</li>
</ul>
</div>
<p>What I have so far does pretty much nothing </p>
<blockquote>
<pre><code>def dress_me(shirt, tie, suit):


 #    if type(shirt) != list or type(tie) != list or type(suit) != list:
    #        return None
            combinations = dress_me(shirt, tie, suit)
            for combo in combinations:
                print(combo)
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a>:</p>
<pre><code>def dress_me(shirt, tie, suit):
    if type(shirt) != list or type(tie) != list or type(suit) != list:
        return None
    return list(itertools.product(shirt, tie, suit))
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; dress_me([1,2,3],[4,5,6],[7,8,9])
[(1, 4, 7), (1, 4, 8), (1, 4, 9), (1, 5, 7), (1, 5, 8), (1, 5, 9), (1, 6, 7), (1, 6, 8), (1, 6, 9), (2, 4, 7), (2, 4, 8), (2, 4, 9), (2, 5, 7), (2, 5, 8), (2, 5, 9), (2, 6, 7), (2, 6, 8), (2, 6, 9), (3, 4, 7), (3, 4, 8), (3, 4, 9), (3, 5, 7), (3, 5, 8), (3, 5, 9), (3, 6, 7), (3, 6, 8), (3, 6, 9)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or, for completeness, in the generator-fashion without an extra function:</p>
<pre><code>import itertools

for combination in itertools.product(shirts, ties, suits):
    whatever_you_want_to_do(combination)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def dress_me(shirt, tie, suit):
    all_combinations = []
    for s in shirt:
        for t in tie:
            for su in suit:
                all_combinations.append((s,t,su))
    return all_combination
</code></pre>
<p>Maybe there is a more pythonic way to do it :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Since it looks like you were trying to come up with a recursive solution, here is the general form of it:</p>
<pre><code>def all_perms(thing):
    if len(thing) &lt;=1:
        yield thing
    else:
        for perm in all_perms(thing[1:]):
            for i in range(len(perm)+1):
                yield perm[:i] + thing[0:1] + perm[i:]
</code></pre>
<p>This works for most kinds of iterables.  Demo:</p>
<pre><code>In [5]: list(all_perms(('shirt','tie','suit')))
Out[5]: 
[('shirt', 'tie', 'suit'),
 ('tie', 'shirt', 'suit'),
 ('tie', 'suit', 'shirt'),
 ('shirt', 'suit', 'tie'),
 ('suit', 'shirt', 'tie'),
 ('suit', 'tie', 'shirt')]
</code></pre>
<p>Recursion is difficult to understand at first, but the general form is:</p>
<pre><code>if simplest_case:
    return simplest_case
else:
    #recurse
</code></pre>
<p>In this case, <code>return</code> is replaced by <code>yield</code> in order to make a generator, which is more memory-friendly.  You still shouldn't expect this to be the best-performing solution, but I'm including it for completeness since "USE ITERTOOLS" doesn't end up teaching you much other than itertools is cool.</p>
</div>
<span class="comment-copy">I think it would be more Pythonic if there were no list test. Any iterable would actually work. I'm not sure it makes a whole lot of sense to return <code>None</code> if one of the inputs is invalid; that seems counter-intuitive. I'd expect an exception if I passed it a non-iterable; it would make tracking my problem down easier. If returning <code>None</code> is actually required, then see <a href="http://stackoverflow.com/a/4668647/1394393">this answer</a> for checking for iterable types.</span>
<span class="comment-copy">Yes. What you say is reasonable. But first I just answer the question the OP seems to want. And then test if is Iterable is no good. What if a string is passed? I would lead to error. try...except is a good choice. I like that too.</span>
<span class="comment-copy">A string is an iterable; you'd get a product of all the characters, which might be exactly what the caller wants. (I checked, and the answer I linked works for strings, at least in 2.7.) I would assume that the programmer calling the function is aware that strings are iterable, and if it's not the output they wanted, they'll see that very quickly.</span>
<span class="comment-copy">If a string is passed, what you get is apprently not the OP wants.</span>
