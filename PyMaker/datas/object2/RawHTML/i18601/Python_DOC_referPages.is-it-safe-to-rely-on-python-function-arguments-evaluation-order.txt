<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/46288616/is-pythons-order-of-evaluation-of-function-arguments-and-operands-deterministic">Is Python's order of evaluation of function arguments and operands deterministic (+ where is it documented)?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>Is it safe to assume that function arguments are evaluated from left to right in Python?</p>
<p>Reference states that it happens that way but perhaps there is some way to change this order which may break my code.</p>
<p>What I want to do is to add time stamp for function call:</p>
<pre><code>l = []
l.append(f(), time.time())
</code></pre>
<p>I understand that I can evaluate the arguments sequentially:</p>
<pre><code>l = []
res = f()
t = time.time()
l.append(res, t)
</code></pre>
<p>But it looks less elegant so I'd prefer the first way if I can rely on it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, Python always evaluates function arguments from left to right.</p>
<p>This goes for any comma seperated list as far as I know:</p>
<pre><code>&gt;&gt;&gt; from __future__ import print_function
&gt;&gt;&gt; def f(x, y): pass
...
&gt;&gt;&gt; f(print(1), print(2))
1
2
&gt;&gt;&gt; [print(1), print(2)]
1
2
[None, None]
&gt;&gt;&gt; {1:print(1), 2:print(2)}
1
2
{1: None, 2: None}
&gt;&gt;&gt; def f(x=print(1), y=print(2)): pass
...
1
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Quoting from the <a href="http://docs.python.org/3/reference/expressions.html#evaluation-order" rel="nofollow noreferrer">reference documentation</a>:</p>
<blockquote>
<p>Python evaluates expressions from left to right.</p>
</blockquote>
<p>So yes, you can count on that (with one exception, see below).</p>
<p>A <em>call</em> (the <code>(...)</code> part after a primary, such as a function name) is just another <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow noreferrer">expression primary</a>, and the arguments for the call are just more expressions.</p>
<p><strong>Note</strong>: There is one exception to this rule. When using <code>*expression</code> in a call (to expand an iterable to form additional positional arguments), then this expression is evaluated <em>before any keyword argument expressions</em>:</p>
<pre><code>&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; def bar(n, r=(), c=count()): print(f'{next(c)}: bar({n!r})'); return r
...
&gt;&gt;&gt; def foo(*args, **kwargs): pass
...
&gt;&gt;&gt; foo(bar('a1'), spam=bar('a2'), *bar('varargs'), **bar('kwargs', {}))
0: bar('a1')
1: bar('varargs')
2: bar('a2')
3: bar('kwargs')
</code></pre>
<p>The linked documentation states:</p>
<blockquote>
<p>A consequence of this is that although the <code>*expression</code> syntax may appear after explicit keyword arguments, it is processed before the keyword arguments[.]</p>
</blockquote>
</div>
<span class="comment-copy">If the reference says so and it doesn't say explicitly that this may change in the future, then you can rely on it.</span>
<span class="comment-copy"><code>"some way to change this order"</code> How could it be changed? (Functions don't get a choice of how their arguments are evaluated, they're evaluated before they're ever passed to the function)</span>
<span class="comment-copy">In your use case, evaluation order doesn't seem to matter, except if <code>f()</code> is a long running function.</span>
<span class="comment-copy">@DavidRobinson As far as I remember in C you can't rely on that. Usually the arguments are evaluated form right to left according to __stdcall (or others) so that the order in the stack is convenient. I thought that perhaps in python there is a similar trick to change that order</span>
<span class="comment-copy">I disagree that the sequential version is less elegant; it makes the dependency explicit.  How many people who read your code will know that Python enforces order for sure?</span>
<span class="comment-copy">Unfortunately, examples can't prove that this is not <i>undefined behavior</i>.</span>
<span class="comment-copy">Actually, there is a bug in dictionary literal, which is against this specification. See <a href="http://bugs.python.org/issue11205" rel="nofollow noreferrer">bugs.python.org/issue11205</a>.</span>
<span class="comment-copy">@nymk: Yup, and that's why it is a bug.</span>
<span class="comment-copy">This is a better answer than the other, pointing out where it can be found in the language reference. The other one just shows that it is this way, but it doesn't prove it is supposed to be always this way.</span>
<span class="comment-copy">Is there a reference to the idea that <i>function arguments</i> are an "expression" (which is therefore evaluated from left to right)? This is not fully obvious (even though one can expect it) and this is important for fully answering the question.</span>
<span class="comment-copy">@EOL: grumble, I see that the documentation indeed specifically calls out that <code>*expression</code> is evaluated before keyword arguments. I'll reflect this in this post, <i>and</i> ask for an update to the evaluation order section.</span>
