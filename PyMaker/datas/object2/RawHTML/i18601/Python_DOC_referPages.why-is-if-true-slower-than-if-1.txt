<div class="post-text" itemprop="text">
<p>Why is <code>if True</code> slower than <code>if 1</code> in Python? Shouldn't <code>if True</code> be faster than <code>if 1</code>?</p>
<p>I was trying to learn the <code>timeit</code> module. Starting with the basics, I tried these:</p>
<pre><code>&gt;&gt;&gt; def test1():
...     if True:
...         return 1
...     else:
...         return 0

&gt;&gt;&gt; print timeit("test1()", setup = "from __main__ import test1")
0.193144083023


&gt;&gt;&gt; def test2():
...     if 1:
...         return 1
...     else:
...         return 0

&gt;&gt;&gt; print timeit("test2()", setup = "from __main__ import test2")
0.162086009979


&gt;&gt;&gt; def test3():
...     if True:
...             return True
...     else:
...             return False

&gt;&gt;&gt; print timeit("test3()", setup = "from __main__ import test3")
0.214574098587

&gt;&gt;&gt; def test4():
...     if 1:
...             return True
...     else:
...             return False

&gt;&gt;&gt; print timeit("test4()", setup = "from __main__ import test4")
0.160849094391
</code></pre>
<p>I am confused by these things:</p>
<ol>
<li>According to the response from Mr. Sylvain Defresne in <a href="https://stackoverflow.com/questions/100732/why-is-if-not-someobj-better-than-if-someobj-none-in-python">this question</a>, everything is implicitly converted to a <code>bool</code> first and then checked. So why is <code>if True</code> slower than <code>if 1</code>?</li>
<li>Why is <code>test3</code> slower than <code>test1</code> even though only the <code>return</code> values are different?</li>
<li>Like Question 2, but why is <code>test4</code> a little <em>faster</em> than <code>test2</code>?</li>
</ol>
<p>NOTE: I ran <code>timeit</code> three times and took the average of the results, then posted the times here along with the code.</p>
<p>This question does not relate to how to do micro benchmarking(which I did in this example but I also understand that it is too basic) but why checking a 'True' variable is slower than a constant.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>True</code> and <code>False</code> are not keywords in <a href="http://docs.python.org/2/reference/lexical_analysis.html#keywords" rel="noreferrer">Python 2</a>. </p>
<p>They must resolve at runtime. This has been changed in <a href="http://docs.python.org/3/reference/lexical_analysis.html#keywords" rel="noreferrer">Python 3</a></p>
<p>Same test on Python 3:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('test1()',setup="from __main__ import test1", number=10000000)
2.806439919999889
&gt;&gt;&gt; timeit.timeit('test2()',setup="from __main__ import test2", number=10000000)
2.801301520000038
&gt;&gt;&gt; timeit.timeit('test3()',setup="from __main__ import test3", number=10000000)
2.7952816800000164
&gt;&gt;&gt; timeit.timeit('test4()',setup="from __main__ import test4", number=10000000)
2.7862537199999906
</code></pre>
<p>Time error is in 1%, which is acceptable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Bytecode disassembly makes difference obvious.</p>
<pre><code>&gt;&gt;&gt; dis.dis(test1)
  2           0 LOAD_GLOBAL              0 (True)
              3 JUMP_IF_FALSE            5 (to 11)
              6 POP_TOP             

  3           7 LOAD_CONST               1 (1)
             10 RETURN_VALUE        
        &gt;&gt;   11 POP_TOP             

  5          12 LOAD_CONST               2 (0)
             15 RETURN_VALUE        
             16 LOAD_CONST               0 (None)
             19 RETURN_VALUE        
</code></pre>
<p>As Kabie mentioned, <code>True</code> and <code>False</code> are globals in Python 2. Lots of stuff is going on to access them.</p>
<pre><code>&gt;&gt;&gt; dis.dis(test2)
  3           0 LOAD_CONST               1 (1)
              3 RETURN_VALUE        
</code></pre>
<p>Python compiler was able to recognize <code>1</code> as a constantly "truthy" expression and optimize redundant condition away!</p>
<pre><code>&gt;&gt;&gt; dis.dis(test3)
  2           0 LOAD_GLOBAL              0 (True)
              3 JUMP_IF_FALSE            5 (to 11)
              6 POP_TOP             

  3           7 LOAD_GLOBAL              0 (True)
             10 RETURN_VALUE        
        &gt;&gt;   11 POP_TOP             

  5          12 LOAD_GLOBAL              1 (False)
             15 RETURN_VALUE        
             16 LOAD_CONST               0 (None)
             19 RETURN_VALUE        
</code></pre>
<p>Pretty much the same as <code>test1</code>, with one more <code>LOAD_GLOBAL</code>.</p>
<pre><code>&gt;&gt;&gt; dis.dis(test4)
  3           0 LOAD_GLOBAL              0 (True)
              3 RETURN_VALUE        
</code></pre>
<p>See <code>test2</code>. But <code>LOAD_GLOBAL</code> is a bit more costly than <code>LOAD_CONST</code>.</p>
</div>
<span class="comment-copy">I think your tests are too small. And the average of three runs isn't enough :p</span>
<span class="comment-copy">I understand :) even the test case is too basic to think. However, we need to start somewhere right :)</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/2857470/how-long-does-a-microbenchmark-need-to-run">How long does a microbenchmark need to run?</a></span>
<span class="comment-copy">@JarrodRoberson Thanks for the link :-) However, my question is not related to generic micro bench marks. It is about why does using a keyword to check for boolean is slower than check for a constant.</span>
<span class="comment-copy">True takes 4 times longer to type than the number 1</span>
<span class="comment-copy">try <code>True,False=False,True</code></span>
