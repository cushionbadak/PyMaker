<div class="post-text" itemprop="text">
<p>I only need to read the first line of a huge file and change it.</p>
<p>Is there a trick to only change the first line of a file and save it as another file using Python? All my code is done in python and would help me to keep consistency.</p>
<p>The idea is to not have to read and then write the whole file.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobjeobj" rel="noreferrer"><code>shutil.copyfileobj()</code></a> should be much faster than running line-by-line. Note from the docs:</p>
<blockquote>
<p>Note that if the current file position of the [from_file] object is not 0,
  only the contents from the current file position to the end of the
  file will be copied.</p>
</blockquote>
<p>Thus:</p>
<pre><code>import shutil

from_file = open("filename") 
line = from_file.readline()

# make any changes to line here

to_file = open("filename",mode="w")
to_file.write(line)
shutil.copyfileobj(from_file, to_file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to modify the top line of a file and save it under a new file name, it is not possible to simply modify the first line without iterating over the entire file. On the bright side, as long as you are not printing to the terminal, modifying the first line of a file is VERY, VERY fast even on vasy large files.</p>
<p>Assuming you are working with text-based files (not binary,) this should fit your needs and perform well enough for most applications.</p>
<pre><code>import os
newline = os.linesep # Defines the newline based on your OS.

source_fp = open('source-filename', 'r')
target_fp = open('target-filename', 'w')
first_row = True
for row in source_fp:
    if first_row:
        row = 'the first row now says this.'
        first_row = False
    target_fp.write(row + newline)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unless the new line is the same length as the old line, you can not do this. If it is, you could solve this problem through a <a href="http://docs.python.org/2/library/mmap.html" rel="nofollow">mmap</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>sh</code> module worked for me:</p>
<pre><code>import sh

first = "new string"
sh.sed("-i", "1s/.*/" + first + "/", "file.x")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternate solution that does not require iterating over the lines that are not of interest.</p>
<pre><code>def replace_first_line( src_filename, target_filename, replacement_line):
    f = open(src_filename)
    first_line, remainder = f.readline(), f.read()
    t = open(target_filename,"w")
    t.write(replacement_line + "\n")
    t.write(remainder)
    t.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The solution i would use is to use  create a file missing old first line</p>
<p><code>from_file.readline() # and discard
    shutil.copyfileobj(from_file, tail_file)</code></p>
<p>then create a file with the new first line</p>
<p>then use the following to concatenate the newfirstline file and tail_file</p>
<pre><code>for f in ['newfirstline.txt','tail_file.txt']:
with open(f,'rb') as fd:
    shutil.copyfileobj(fd, wfd, 1024*1024*10
</code></pre>
</div>
<span class="comment-copy">Is the new line going to be exactly the same length as the old one?</span>
<span class="comment-copy">Can you have the first line as a variable, then change it based on an argument from another file?</span>
<span class="comment-copy">@EmilVikstr√∂m no the new line would be of different length.</span>
<span class="comment-copy">@ChristopherMarshall i think i could</span>
<span class="comment-copy">I suppose you know this isn't a Python limitation but rather that of file system operations. There were line-oriented filetypes in the dark, remote past which are now blissfully dead.</span>
<span class="comment-copy">Wow! That is so much faster.</span>
<span class="comment-copy">If you don't mind a full working example would help.</span>
<span class="comment-copy">Added a working example for myself and for @RafaelAlmeida</span>
<span class="comment-copy">this is highly risky (if the process/computer crashes while writing, you lose the contents of the file) and not portable, for example on windows it doesn't work</span>
<span class="comment-copy">thanks! this is indeed an alternative solution quite slow for a huge file but from other answers seems this may be the only way...</span>
<span class="comment-copy"><code>'\r\n'</code> is almost never correct in any context. If you want to read/write text files with python use <code>'rt'</code> or <code>'wt'</code> mode.</span>
<span class="comment-copy">i did some quick digging and unfortunately i have not been able to derive anything better.. if i do find something, i'll be sure to update!</span>
<span class="comment-copy">@msw: <code>wt</code> and <code>rt</code> appear to be Python 3-specific implementations. generally, it's best to write code which is python 2.5+ and 3 compatible if at all possible. Python 2.7 Docs: <a href="http://docs.python.org/2.7/library/functions.html#open" rel="nofollow noreferrer">docs.python.org/2.7/library/functions.html#open</a> Python 3.3 Docs: <a href="http://docs.python.org/3.3/library/functions.html#open" rel="nofollow noreferrer">docs.python.org/3.3/library/functions.html#open</a></span>
<span class="comment-copy">right you are; thanks.</span>
<span class="comment-copy">thanks! i'd have thought this was easily done but i think you are right, good answer.  In my case though the new line is of different length to the old line.</span>
<span class="comment-copy">the <code>-i</code> doesn't work n-place, though. But nice find</span>
<span class="comment-copy">Doesn't this require reading <i>the entire file</i> into memory? Such an operation will not only iterate over the file in the background, but also be impossible on very large files.</span>
