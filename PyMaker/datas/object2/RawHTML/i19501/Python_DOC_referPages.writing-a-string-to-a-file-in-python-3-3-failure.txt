<div class="post-text" itemprop="text">
<p>I'm using this python code to extract email addresses from a given file (source_file.txt) and to write those email addresses in a separate file. (I'm using python 3.3)</p>
<pre><code>import urllib.request
import re
import fileinput, glob, string, sys, os
from os.path import join
import os

filePath = "source_file.txt"

if not filePath:
    print("Sorry! Source File could not be located!")
else:
    page = open(filePath, "r")
    pageContent = page.read()
    page.close()

style_normal = re.compile("[-a-zA-Z0-9._]+@[-a-zA-Z0-9_]+.[a-zA-Z0-9_.]+")
style_text_one = re.compile('[-a-zA-Z0-9._]+\s+at\s+[-a-zA-Z0-9_]+\s+dot\s+[a-zA-Z0-9_.]+')
style_text_two = re.compile('[-a-zA-Z0-9._]+\(at\)[-a-zA-Z0-9_]+\(dot\)[a-zA-Z0-9_.]+')

style_normal_list = style_normal.findall(str(pageContent))
style_text_one_list = style_text_one.findall(str(pageContent))
style_text_two_list = style_text_two.findall(str(pageContent))

f = open('emails_file.txt', 'a')
f.write('testing')

for item in style_normal_list:
    print("%s" %item)
    f.write("%s" %item)
for item in style_text_one_list:
    text_one = item.replace(' at ','@')
    text_two = text_one.replace(' dot ','.')
    print(text_two)
    f.write(text_two)

for item in style_text_two_list:
    text_one = item.replace('(at)','@')
    text_two = text_one.replace('(dot)','.')
    f.write(text_two)
</code></pre>
<p>The problem is that when I run this the file gets created, but nothing gets written in the file. Not even the text 'testing'. File is created but it is blank.</p>
<p>I have used the print statements to check whether other parts of the code is working correctly.
According to the <a href="http://docs.python.org/3.3/tutorial/inputoutput.html" rel="nofollow">python doc</a> the syntax is correct.
Can any of you point out any mistakes I have made in this code?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you call <code>write</code> on a file, the data doesn't actually get written to disk immediately, it gets stored in a buffer. Every so often, the buffer is flushed. You can explicitly call <code>flush</code> if you want to control it, but it's usually better not to—when you <code>close</code> the file, it automatically flushes.</p>
<p>But you have to <code>close</code> the file for this to work. When a file object gets deleted, it closes itself, but you can't rely on the file object getting deleted at any particular time, or even ever. (You can learn the details of how it works in CPython 2.7, CPython 3.3, IronPython, etc., and how CPython 3.3 handles exit differently on Unix vs. Windows, and so on, but you still wouldn't want to rely on those details.)</p>
<p>So, if you add an explicit <code>f.close()</code> at the end of your code, that <em>almost</em> solves the problem… but not completely. What if some other line raises an exception? Then it will never get to the <code>close()</code> call.</p>
<p>You can solve this with <code>try</code>/<code>finally</code>, but there's a better way, the <code>with</code> statement:</p>
<pre><code>with open('emails_file.txt', 'a') as f:    
    f.write('testing')
    # ...
    for item in style_text_two_list:
        text_one = item.replace('(at)','@')
        text_two = text_one.replace('(dot)','.')
        f.write(text_two)
</code></pre>
<p>This guarantees that as soon as you get to the end of the indented <code>with</code> block—even if that happens because of an exception, or quitting the program (or <code>return</code>ing from the function, if you're in a function, or <code>break</code>ing from the loop, if you're in a loop, etc.), <code>f</code> will be closed.</p>
<p>This is all explained in <a href="http://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects" rel="nofollow">Methods of File Object</a> in the official tutorial, but looking over how it's explained, I can imagine a lot of new programmers wouldn't get any of that out of what's written. And the <a href="http://docs.python.org/3/reference/compound_stmts.html#with" rel="nofollow"><code>with statement</code></a> documentation only really makes sense if you already understand what it does, and likewise for the explanations about file objects being buffered… <a href="http://www.python.org/dev/peps/pep-0343/" rel="nofollow">PEP 343</a>, which introduced the <code>with</code> statement is a little better, but it spends as much time talking about what's wrong with the two previous related PEPs as about why the feature is useful. So, I guess it's understandable that many developers don't know any of this.</p>
</div>
<span class="comment-copy">It might not matter, but try adding <code>f.close()</code> at the end of the script.</span>
<span class="comment-copy">Or, better replace <code>f = open('emails_file.txt', 'a')</code> with <code>with open('emails_file.txt', 'a') as f:</code> and indent the rest of the script.</span>
<span class="comment-copy">I tried @WarrenWeckesser 's method f.close() actually worked. Can't imagine i was struggling for this long because of this kind of simple thing :) Thank you!!! Got to try that too abarnert Thank you too!</span>
