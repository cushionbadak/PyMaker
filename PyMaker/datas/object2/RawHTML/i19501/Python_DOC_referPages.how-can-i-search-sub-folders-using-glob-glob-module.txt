<div class="post-text" itemprop="text">
<p>I want to open a series of subfolders in a folder and find some text files and print some lines of the text files. I am using this:</p>
<pre><code>configfiles = glob.glob('C:/Users/sam/Desktop/file1/*.txt')
</code></pre>
<p>But this cannot access the subfolders as well. Does anyone know how I can use the same command to access subfolders as well?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.5 and newer use the new recursive <code>**/</code> functionality:</p>
<pre><code>configfiles = glob.glob('C:/Users/sam/Desktop/file1/**/*.txt', recursive=True)
</code></pre>
<p>When <code>recursive</code> is set, <code>**</code> followed by a path separator matches 0 or more subdirectories. </p>
<p>In earlier Python versions, <code>glob.glob()</code> cannot list files in subdirectories recursively.</p>
<p>In that case I'd use <a href="http://docs.python.org/2/library/os.html#os.walk" rel="noreferrer"><code>os.walk()</code></a> combined with <a href="http://docs.python.org/2/library/fnmatch.html#fnmatch.filter" rel="noreferrer"><code>fnmatch.filter()</code></a> instead:</p>
<pre><code>import os
import fnmatch

path = 'C:/Users/sam/Desktop/file1'

configfiles = [os.path.join(dirpath, f)
    for dirpath, dirnames, files in os.walk(path)
    for f in fnmatch.filter(files, '*.txt')]
</code></pre>
<p>This'll walk your directories recursively and return all absolute pathnames to matching <code>.txt</code> files. In this <em>specific</em> case the <code>fnmatch.filter()</code> may be overkill, you could also use a <code>.endswith()</code> test:</p>
<pre><code>import os

path = 'C:/Users/sam/Desktop/file1'

configfiles = [os.path.join(dirpath, f)
    for dirpath, dirnames, files in os.walk(path)
    for f in files if f.endswith('.txt')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://pypi.python.org/pypi/glob2" rel="noreferrer">glob2</a> package supports wild cards and is reasonably fast</p>
<pre><code>code = '''
import glob2
glob2.glob("files/*/**")
'''
timeit.timeit(code, number=1)
</code></pre>
<p>On my laptop it takes approximately 2 seconds to match <a href="https://github.com/jsdelivr/jsdelivr/tree/master/files" rel="noreferrer">&gt;60,000 file paths</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To find files in immediate subdirectories:</p>
<pre><code>configfiles = glob.glob(r'C:\Users\sam\Desktop\*\*.txt')
</code></pre>
<p>For a recursive version that traverse all subdirectories, you could use <code>**</code> and pass <code>recursive=True</code> <a href="https://docs.python.org/3/library/glob.html#glob.glob" rel="noreferrer">since Python 3.5</a>:</p>
<pre><code>configfiles = glob.glob(r'C:\Users\sam\Desktop\**\*.txt', recursive=True)
</code></pre>
<p>Both function calls return lists. You could use <code>glob.iglob()</code> to return paths one by one. Or <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.rglob" rel="noreferrer">use <code>pathlib</code></a>:</p>
<pre><code>from pathlib import Path

path = Path(r'C:\Users\sam\Desktop')
txt_files_only_subdirs = path.glob('*/*.txt')
txt_files_all_recursively = path.rglob('*.txt') # including the current dir
</code></pre>
<p>Both methods return iterators (you can get paths one by one).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://pypi.python.org/pypi/formic" rel="noreferrer">Formic</a> with Python 2.6</p>
<pre><code>import formic
fileset = formic.FileSet(include="**/*.txt", directory="C:/Users/sam/Desktop/")
</code></pre>
<p>Disclosure - I am the author of this package.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a adapted version that enables <code>glob.glob</code> like functionality without using <code>glob2</code>. </p>
<pre><code>def find_files(directory, pattern='*'):
    if not os.path.exists(directory):
        raise ValueError("Directory not found {}".format(directory))

    matches = []
    for root, dirnames, filenames in os.walk(directory):
        for filename in filenames:
            full_path = os.path.join(root, filename)
            if fnmatch.filter([full_path], pattern):
                matches.append(os.path.join(root, filename))
    return matches
</code></pre>
<p>So if you have the following dir structure</p>
<pre><code>tests/files
├── a0
│   ├── a0.txt
│   ├── a0.yaml
│   └── b0
│       ├── b0.yaml
│       └── b00.yaml
└── a1
</code></pre>
<p>You can do something like this</p>
<pre><code>files = utils.find_files('tests/files','**/b0/b*.yaml')
&gt; ['tests/files/a0/b0/b0.yaml', 'tests/files/a0/b0/b00.yaml']
</code></pre>
<p>Pretty much <code>fnmatch</code> pattern match on the whole filename itself, rather than the filename only. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>configfiles = glob.glob('C:/Users/sam/Desktop/**/*.txt")</code> </p>
<p>Doesn't works for all cases, instead use glob2  </p>
<pre><code>configfiles = glob2.glob('C:/Users/sam/Desktop/**/*.txt")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you can install glob2 package...    </p>
<pre><code>import glob2
filenames = glob2.glob("C:\\top_directory\\**\\*.ext")  # Where ext is a specific file extension
folders = glob2.glob("C:\\top_directory\\**\\")
</code></pre>
<p>All filenames and folders: </p>
<pre><code>all_ff = glob2.glob("C:\\top_directory\\**\\**")  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're running Python 3.4+, you can use the <a href="https://docs.python.org/3.6/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib</code></a> module. The <a href="https://docs.python.org/3.6/library/pathlib.html#pathlib.Path.glob" rel="nofollow noreferrer"><code>Path.glob()</code></a> method supports the <code>**</code> pattern, which means “this directory and all subdirectories, recursively”. It returns a generator yielding <a href="https://docs.python.org/3.6/library/pathlib.html#pathlib.Path" rel="nofollow noreferrer"><code>Path</code></a> objects for all matching files.</p>
<pre><code>from pathlib import Path
configfiles = Path("C:/Users/sam/Desktop/file1/").glob("**/*.txt")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As pointed out by Martijn, glob can only do this through the <code>**</code>operator introduced in Python 3.5. Since the OP explicitly asked for the glob module, the following will return a lazy evaluation iterator that behaves similarly</p>
<pre><code>import os, glob, itertools

configfiles = itertools.chain.from_iterable(glob.iglob(os.path.join(root,'*.txt'))
                         for root, dirs, files in os.walk('C:/Users/sam/Desktop/file1/'))
</code></pre>
<p>Note that you can only iterate once over <code>configfiles</code> in this approach though. If you require a real list of configfiles that can be used in multiple operations you would have to create this explicitly by using <code>list(configfiles)</code>.</p>
</div>
<span class="comment-copy">related to: <a href="http://stackoverflow.com/q/2186525/1463143">Use a Glob() to find files recursively in Python</a></span>
<span class="comment-copy">I can see: <b>glob.glob('/path to directory/*/*.txt")</b> working for me. This is bascially using the Unix shell rule.</span>
<span class="comment-copy">@User123: that doesn't list directories <i>recursively</i>. You are listing all text files <i>one level deep</i>, but not in further subdirectories or even directly in <code>path to directory</code>.</span>
<span class="comment-copy">This is not completely related, but why does setting <code>recursive=False</code> together with the <code>**/</code>  functionality does not provide the list of files just in the given folder, but rather in its children?</span>
<span class="comment-copy">@Dr_Zaszuś: sorry? <code>**/</code> gives a list of <i>directory names</i> in the current working directory, because the pattern ends in <code>/</code>, and with <code>recursive=False</code> you basically have a double <code>*</code>, matching just the same as <code>*/</code>, just less efficient.</span>
<span class="comment-copy">@Dr_Zaszuś: use <code>*/*</code> if you need all files in all subdirectories.</span>
<span class="comment-copy">Yes, I understood that; but I didn't expect <code>glob()</code> to support patterns in directories either.</span>
<span class="comment-copy">Comment deleted, I see now that it gave the wrong impression; besides, the patch includes a documentation update for the <code>**</code> recursion case. But for <code>**</code> to work, you <i>have</i> to set the <code>recursion=True</code> switch, btw.</span>
<span class="comment-copy">Works well. Is a good solution.</span>
