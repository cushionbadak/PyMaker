<div class="post-text" itemprop="text">
<p>I am not new to it, but I do not use Python much and my knowledge is rather broad and not very deep in the language, perhaps someone here more knowledgeable can answer my question. I find myself in the situation when I need to add items to a list and keep it sorted as items as added. A quick way of doing this would be.</p>
<pre><code>list.append(item)                  // O(1)
list.sort()                        // ??
</code></pre>
<p>I would imagine if this is the only way items are added to the list, I would hope the sort would be rather efficient, because the list is sorted with each addition. However there is also this that works:</p>
<pre><code>inserted = False
for i in range(len(list)):         // O(N)
    if (item &lt; list[i]): 
        list.insert(i, item)       // ??
        inserted = True
        break
if not inserted: list.append(item)
</code></pre>
<p>Can anyone tell me if one of these is obviously more efficient? I am leaning toward the second set of statements, however I really have no idea.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you are looking for is the bisect module and most possible the <a href="http://docs.python.org/2/library/bisect.html#bisect.insort_left" rel="noreferrer">insort_left</a></p>
<p>So your expression could be equivalently written as</p>
<p>from</p>
<pre><code>some_list.append(item)                  // O(1)
some_list.sort()                        // ??
</code></pre>
<p>to</p>
<pre><code>bisect.insort_left(some_list, item)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Insertion anywhere except near the end takes O(n) time, as it has to move (copy) all elements which come after the insertion point. But on the other hand, all comparison-based sorting algorithm must, on average, make Omega(n log n) comparisons. Many sorts (including timsort, which Python uses) will do significantly better on many inputs, likely including yours (the "almost sorted" case). They still have to move <em>at least</em> that as many elements as inserting in the right position right away though. They also have to do quite a bit of additional work (inspecting <em>all</em> element to ensure they're in the right order, plus more complicated logic that often improves performance, but not in your case). For these reasons, it's probably slower, at least for large lists.</p>
<p>Due to being written in C (in CPython; but similar reasoning applies for other Pythons), it may still be faster than your Python-written linear scan. That leaves the question of how to find the insertion point. Binary search can do this part in O(log n) time, so it's quite useful here (of course, insertion is still O(n), but there's no way around this if you want a sorted list). Unfortunately, binary search is rather tricky to implement. Fortunately, it's already implemented in the standard library: <a href="http://docs.python.org/3/library/bisect.html" rel="nofollow"><code>bisect</code></a>.</p>
</div>
<span class="comment-copy"><a href="http://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a> shows that <code>.insert()</code> is O(N) and <code>.sort()</code> is O(N log N).</span>
<span class="comment-copy">(Also note that your proposed second case doesn't work at all for adding an item that's less than everything already in the list.)</span>
<span class="comment-copy">@Wooble, <code>.sort()</code> is O(N) in this case because the list is already sorted apart from the new item.</span>
<span class="comment-copy">A <a href="http://docs.python.org/2/library/heapq.html" rel="nofollow noreferrer">heapq</a> may be a better choice for this depending on your requirements</span>
<span class="comment-copy">If you need to keep the data sorted while allowing for frequent inserts, a tree can be a better option than a list. Unfortunately Python doesn't come with a sorted sorted tree type. Fortunately there are several libraries available. See the links in @Princess Of the Universe's answer for more information.</span>
<span class="comment-copy">` sorting takes up O(n log n) time.`, you mean best case complexity</span>
<span class="comment-copy">@Abhijit I don't think that's the right term (for many sorting algorithms, the best case is an already-sorted input and they handle that in O(n) time). But you're right, my wording is not optimal. I'll see how I can improve that part.</span>
<span class="comment-copy">@Abhijit: timsort is O(N log N) in the average and worst case, O(N) in the best case.</span>
