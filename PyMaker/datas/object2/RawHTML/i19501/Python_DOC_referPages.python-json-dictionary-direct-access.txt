<div class="post-text" itemprop="text">
<p>I am confused why I have to use `.get('key') when trying to access an array of objects from a json file    </p>
<pre><code>req = urllib2.Request("http://website.com/entertainment/entertainment_news.json", None)
opener = urllib2.build_opener()
f = opener.open(req)
stories = json.load(f)
for new_story in stories:
    #Why can't I access variables using
    new_story.title

    #I have to do
    new_story.get('title')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that when the <code>json</code> module parses a JSON object, it returns a Python <code>dict</code> - which is a more suitable data structure in Python for the data at hand.</p>
<p>This means you don't want to try and access the field on it, but rather access the item in the <code>dict</code>. The Python syntax for accessing items of <code>dict</code>s (or <code>dict</code>-like objects) is:</p>
<pre><code>dict[name]
</code></pre>
<p>So in your case:</p>
<pre><code>new_story['title']
</code></pre>
<p>See <a href="http://docs.python.org/3/library/stdtypes.html#mapping-types-dict">the documentation for <code>dict</code>s</a> for more information.</p>
<p>The <a href="http://docs.python.org/3/library/stdtypes.html#dict.get"><code>dict.get()</code></a> function allows you to easily get a default value (which is, by default <code>None</code>) if the key doesn't exist (normally this will produce a <code>KeyError</code>. You do not normally want this behaviour (it is generally better to fail out sooner and see where the problem is, than get <code>None</code> value and have errors later when you try and use it).</p>
<p>Also note that this is a good use case for the <code>with</code> statement, to ensure that the connection is closed properly. As <code>urllib2</code> doesn't support context managers by default, we use <a href="http://docs.python.org/3/library/contextlib.html#contextlib.closing"><code>contextlib.closing()</code></a> to make one:</p>
<pre><code>from contextlib import closing
req = urllib2.Request("http://website.com/entertainment/entertainment_news.json", None)
opener = urllib2.build_opener()
with closing(opener.open(req)) as f:
    stories = json.load(f)
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because you have to use new_story['title'], but if this key wont exist, it will throw you exception</p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to <em>Lattyware's</em> answer: in order to be able to access the dict using <code>.some_attribute</code> convention, you can use a trick:</p>
<pre><code>class Story:
  def __init__(self, **kwargs):
    self.__dict__.update(kwargs)

#...    
stories = [Story(story) for story in json.load(f)]
for new_story in stories:
    # now you can do it!
    new_story.title
</code></pre>
<p>...although it do it if you <em>really</em> want to stick with "dot" notation. It just brings another complication to your program (apart of many other drawbacks, like <code>story.title.somethingelse</code> will not work in this simple scenario without some recursive initialization)</p>
<p>You can also consider using <a href="http://docs.python.org/2/library/collections.html" rel="nofollow">namedtuple</a>.</p>
</div>
<span class="comment-copy">If I was to do this hack (which I wouldn't, but I digress), I'd probably do it by making a <code>__getattr__()</code> method that just did <code>return self[key]</code>.</span>
<span class="comment-copy">You can also do <code>params = type("Parameters",(object,), dict_with_parameters)</code></span>
