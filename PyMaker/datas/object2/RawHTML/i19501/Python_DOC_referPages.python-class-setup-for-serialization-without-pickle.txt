<div class="post-text" itemprop="text">
<h3>Scenario</h3>
<p>I am looking for an object oriented approach in python that makes it possible to save an instance of a class in a data file and also load it again in at a later point in time. My current approach looks like this:</p>
<pre><code>class A(object):
    def __init__(self, ComplexParam1, ComplexParam2):
        self.ComplexParam1 = ComplexParam1
        self.ComplexParam2 = ComplexParam2

    @staticmethod
    def Create(EasyParam1, EasyParam2):
        #do some complex calculation to get ComplexParam1 and ComplexParam2 from EasyParam1 and EasyParam2
        return A(ComplexParam1, ComplexParam2)        

    def Save(self, Filename):
        #write ComplexParam1 and ComplexParam2 to disc

    @staticmethod
    def Load(Filename):
        #read ComplexParam1 and ComplexParam2 and call constructor
        return A(ComplexParam1, ComplexParam2)
</code></pre>
<p>As you can see <code>ComplexParam1</code> and <code>ComplexParam2</code> are to be calculated parameters and are not used for a first creation of the object <code>A</code> since they are very complex to get, whereas <code>EasyParam1</code> and <code>EasyParam2</code> are "known" parameters. Think of it as if the <code>EasyParameters</code> are integers and the <code>ComplexParameters</code> are large matricies that are constructed based on <code>EasyParameters</code></p>
<p>So I am using the setup above to <code>Save</code> and <code>Load</code> objects to and from file, where <code>Create</code> uses the constructor since <code>ComplexParam1</code> and <code>ComplexParam2</code> are stored in file and do not need to be calculated again.</p>
<h3>Problem</h3>
<p>Up until now, the approach shown above worked just fine for me. Problems however arise, when this scheme is also used with class inheritances. So I am looking for a nicer and cleaner solution to my problem.</p>
<p>In C++ I would overload the constructor and make two possible creations of the class available, but this is not supported in python.</p>
<p>Any help, link and suggestion is appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this is a case for the <a href="http://docs.python.org/3/library/functions.html#classmethod" rel="nofollow"><code>@classmethod</code></a> decorator.  For example, if you change the <code>Load</code> method to the following:</p>
<pre><code>    @classmethod
    def Load(cls, Filename):
        # Do stuff
        return cls(ComplexA, ComplexB)
</code></pre>
<p>Then you could override the constructor:</p>
<pre><code>class B(A):
    def __init__(self, complexA, complexB):
        # Whatever you want, including calling the parent constructor
</code></pre>
<p>And, finally, you could call <code>B.Load(some_file)</code> which would invoke <code>B.__init__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Overloading in not needed, just use a <code>classmethod</code> for alternative contructor methods. Look at <a href="https://stackoverflow.com/questions/682504/what-is-a-clean-pythonic-way-to-have-multiple-constructors-in-python">this questions</a> and it's answers.</p>
<pre><code>class A (object):

    @classmethod
    def Load(cls, Filename):
        #read ComplexParam1 and ComplexParam2 and call constructor
        return cls(ComplexParam1, ComplexParam2)
</code></pre>
<p>By using the cls parameter for the class, it works nice with inheritance.</p>
</div>
