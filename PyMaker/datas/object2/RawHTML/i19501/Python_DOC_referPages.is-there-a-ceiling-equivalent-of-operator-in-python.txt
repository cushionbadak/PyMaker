<div class="post-text" itemprop="text">
<p>I found out about the <code>//</code> operator in Python which in Python 3 does division with floor.</p>
<p>Is there an operator which divides with ceil instead? (I know about the <code>/</code> operator which in Python 3 does floating point division.)</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no operator which divides with ceil.  You need to <code>import math</code> and use <code>math.ceil</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can just do upside-down floor division:</p>
<pre><code>def ceildiv(a, b):
    return -(-a // b)
</code></pre>
<p>This works because <a href="http://python-history.blogspot.com/2010/08/why-pythons-integer-division-floors.html" rel="noreferrer">Python's division operator does floor division</a> (unlike in C, where integer division truncates the fractional part).</p>
<p>This also works with Python's big integers, because there's no (lossy) floating-point conversion.</p>
<p>Here's a demonstration:</p>
<pre><code>&gt;&gt;&gt; from __future__ import division   # a/b is float division
&gt;&gt;&gt; from math import ceil
&gt;&gt;&gt; b = 3
&gt;&gt;&gt; for a in range(-7, 8):
...     print(["%d/%d" % (a, b), int(ceil(a / b)), -(-a // b)])
... 
['-7/3', -2, -2]
['-6/3', -2, -2]
['-5/3', -1, -1]
['-4/3', -1, -1]
['-3/3', -1, -1]
['-2/3', 0, 0]
['-1/3', 0, 0]
['0/3', 0, 0]
['1/3', 1, 1]
['2/3', 1, 1]
['3/3', 1, 1]
['4/3', 2, 2]
['5/3', 2, 2]
['6/3', 2, 2]
['7/3', 3, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do <code>(x + (d-1)) // d</code> when dividing <code>x</code> by <code>d</code>, i.e. <code>(x + 4) // 5</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can always just do it inline as well</p>
<pre><code>((foo - 1) // bar) + 1
</code></pre>
<p>In python3, this is just shy of an order of magnitude faster than forcing the float division and calling ceil(), provided you care about the speed. Which you shouldn't, unless you've proven through usage that you need to.</p>
<pre><code>&gt;&gt;&gt; timeit.timeit("((5 - 1) // 4) + 1", number = 100000000)
1.7249219375662506
&gt;&gt;&gt; timeit.timeit("ceil(5/4)", setup="from math import ceil", number = 100000000)
12.096064013894647
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Note that math.ceil is limited to 53 bits of precision. If you are working with large integers, you may not get exact results.</p>
<p>The <a href="http://code.google.com/p/gmpy/" rel="noreferrer">gmpy2</a> libary provides a <code>c_div</code> function which uses ceiling rounding.</p>
<p>Disclaimer: I maintain gmpy2.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Solution 1: Convert floor to ceiling with negation</h2>
<pre><code>def ceiling_division(n, d):
    return -(n // -d)
</code></pre>
<p>Reminiscent of the <a href="https://www.youtube.com/watch?v=D87DSLe4Eqw" rel="nofollow noreferrer">Penn &amp; Teller levitation trick</a>, this "turns the world upside down (with negation), uses plain floor division (where the ceiling and floor have been swapped), and then turns the world right-side up (with negation again)"</p>
<h2>Solution 2: Let divmod() do the work</h2>
<pre><code>def ceiling_division(n, d):
    q, r = divmod(n, d)
    return q + bool(r)
</code></pre>
<p>The <a href="https://docs.python.org/3/library/functions.html#divmod" rel="nofollow noreferrer"><em>divmod()</em></a> function gives <code>(a // b, a % b)</code> for integers (this may be less reliable with floats due to round-off error).  The step with <code>bool(r)</code> adds one to the quotient whenever there is a non-zero remainder.</p>
<h2>Solution 3: Adjust the numerator before the division</h2>
<pre><code>def ceiling_division(n, d):
    return (n + d - 1) // d
</code></pre>
<p>Translate the numerator upwards so that floor division rounds down to the intended ceiling. Note, this only works for integers.</p>
<h2>Solution 4: Convert to floats to use math.ceil()</h2>
<pre><code>def ceiling_division(n, d):
    return math.ceil(n / d)
</code></pre>
<p>The <a href="https://docs.python.org/3/library/math.html#math.ceil" rel="nofollow noreferrer">math.ceil()</a> code is easy to understand, but it converts from ints to floats and back.  This isn't very fast and it may have rounding issues.  Also, it relies on Python 3  semantics where "true division" produces a float and where the <em>ceil()</em> function returns an integer.</p>
</div>
<div class="post-text" itemprop="text">
<p>I came here because of binary modular groups, and wanting to interact with both the shared middles of a list. For example <code>[1,2,3,4]</code> has <code>2</code> and <code>4</code>.</p>
<p>To interact with the middle of the list and use a ceiling operator:</p>
<pre><code>foo    = [1,2,3,4]
length = len(foo)
floor  = (len(foo)//2) -1
ceil   = floor+1
</code></pre>
</div>
<span class="comment-copy">"divide-then-ceil" isn't really a common thing in maths, while <code>//</code> is based on the integer division-with-modulus operation.</span>
<span class="comment-copy">Important: do you want an int or float result?</span>
<span class="comment-copy">You should change accepted answer to dlitz's.   math.ceil is for floats, it does not work with Python's arbitrary-precision long ints.</span>
<span class="comment-copy">so foobar = math.ceil(foo / bar)? Hmm, I can live with that, don't know of anywhere I wanted to use that, was just curious, thanks</span>
<span class="comment-copy">–1  <b>do not use</b>, this will begin to fail for very large integers.  Either use a multiple-precision arithmetic library or stay in the integer domain with <a href="https://stackoverflow.com/a/17511341/674039">this</a> approach.</span>
<span class="comment-copy">do you have a recommendation for a multiple-precision library?</span>
<span class="comment-copy">definitely stay in the integer domain. that's almost guaranteed to be more performant <i>and</i> less of a headache.</span>
<span class="comment-copy">@David天宇Wong  gmpy2 (mentioned in another answer here) is good.</span>
<span class="comment-copy">@apadana I agree this is very smart, but not very readable and hard to maintain! I have decided to import ceil from math so that when one of my colleagues reads my line of code he will understand what it does!</span>
<span class="comment-copy">@apadana I disagree. The question asked whether there "is" an operator for this "in" Python. Based on the responses, the answer appears to be "no." I'm upvoting dlitz's answer for its usefulness, though.</span>
<span class="comment-copy">@SlimCheney Toss this method into a documented function and you're good to go. Performance + readability in one sweeping motion.</span>
<span class="comment-copy">This is the classic method I've used forever. Doesn't work for negative divisors though.</span>
<span class="comment-copy">It produces the <a href="https://repl.it/FZGd/5" rel="nofollow noreferrer">same result</a> as <code>math.ceil()</code>.</span>
<span class="comment-copy">@Abhijeet Yes, that's what the question asks. Except it works better for big integers above <code>sys.float_info.max</code>, and it doesn't require an import.</span>
<span class="comment-copy">just ran those tests myself I get about 12.5 seconds, ehrm, why wouldn't I care about speed when it is such a huge speed difference?</span>
<span class="comment-copy">@Cradam Note that he's using doing 100 million calls (<code>number=100000000</code>). Per single call, the difference is pretty insignificant.</span>
<span class="comment-copy">ahh, thanks, i'll be using ceil method then</span>
<span class="comment-copy">Because code clarity trumps all. Clarity is objective in this case probably. But you should always make readable/maintainable first. When, and only when, you've discovered a performance checkpoint, do you get to break the rules. Modern machines are so fast, and so often all of the other stuff your program is doing renders this kind of difference lost in the noise.</span>
<span class="comment-copy">@TravisGriggs using integer math instead of floating point math isn't just for speed.  For large enough integers float math gives the wrong answer</span>
<span class="comment-copy">This package would be useful if I was doing something heavily mathematics or science orientated, I prefer the answer which uses core libraries though. I am giving an upvote though as it is a useful answer</span>
<span class="comment-copy">Wow, can confirm. <code>python2 -c 'from math import ceil;assert ceil(11520000000000000102.9)==11520000000000000000'</code> (as well as substituting <code>python3</code>) BOTH are <code>True</code></span>
