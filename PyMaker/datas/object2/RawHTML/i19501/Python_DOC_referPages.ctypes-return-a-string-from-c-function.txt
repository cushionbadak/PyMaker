<div class="post-text" itemprop="text">
<p>I'm a Python veteran, but haven't dabbled much in C. After half a day of not finding anything on the internet that works for me, I thought I would ask here and get the help I need.</p>
<p>What I want to do is write a simple C function that accepts a string and returns a different string. I plan to bind this function in several languages (Java, Obj-C, Python, etc.) so I think it has to be pure C?</p>
<p>Here's what I have so far. Notice I get a segfault when trying to retrieve the value in Python.</p>
<h3>hello.c</h3>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

const char* hello(char* name) {
    static char greeting[100] = "Hello, ";
    strcat(greeting, name);
    strcat(greeting, "!\n");
    printf("%s\n", greeting);
    return greeting;
}
</code></pre>
<h3>main.py</h3>
<pre><code>import ctypes
hello = ctypes.cdll.LoadLibrary('./hello.so')
name = "Frank"
c_name = ctypes.c_char_p(name)
foo = hello.hello(c_name)
print c_name.value # this comes back fine
print ctypes.c_char_p(foo).value # segfault
</code></pre>
<p>I've read that the segfault is caused by C releasing the memory that was initially allocated for the returned string. Maybe I'm just barking up the wrong tree?</p>
<p>What's the proper way to accomplish what I want?</p>
</div>
<div class="post-text" itemprop="text">
<p>n hello.c you return a local array. You have to return a pointer to an array, which has to be dynamically declared using malloc.</p>
<pre><code>char* hello(char* name)
{ 
    char hello[] = "Hello ";
    char excla[] = "!\n";
    char *greeting = malloc ( sizeof(char) * ( strlen(name) + strlen(hello) + strlen(excla) + 1 ) );
    if( greeting == NULL) exit(1);
    strcpy( greeting , hello);
    strcat(greeting, name);
    strcat(greeting, excla);
    return greeting;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that greeting was allocated on the stack, but the stack is destroyed when the function returns. You could allocate the memory dynamically:</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

const char* hello(char* name) {
    char* greeting = malloc(100);
    snprintf("Hello, %s!\n", 100, name)
    printf("%s\n", greeting);
    return greeting;
}
</code></pre>
<p>But that's only part of the battle because now you have a memory leak. You could plug that with another ctypes call to free().</p>
<p>...or a much better approach is to read up on the official C binding to python (python 2.x at <a href="http://docs.python.org/2/c-api/" rel="noreferrer">http://docs.python.org/2/c-api/</a> and python 3.x at <a href="http://docs.python.org/3/c-api/" rel="noreferrer">http://docs.python.org/3/c-api/</a>). Have your C function create a python string object and hand that back. It will be garbage collected by python automatically. Since you are writing the C side, you don't have to play the ctypes game.</p>
<p>...edit..</p>
<p>I didn't compile and test, but I think this .py would work:</p>
<pre><code>import ctypes

# define the interface
hello = ctypes.cdll.LoadLibrary('./hello.so')
# find lib on linux or windows
libc = ctypes.CDLL(ctypes.util.find_library('c'))
# declare the functions we use
hello.hello.argtypes = (ctypes.c_char_p,)
hello.hello.restype = ctypes.c_char_p
libc.free.argtypes = (ctypes.c_void_p,)

# wrap hello to make sure the free is done
def hello(name):
    _result = hello.hello(name)
    result = _result.value
    libc.free(_result)
    return result

# do the deed
print hello("Frank")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's what happens. And why it's breaking. When hello() is called, the C stack pointer is moved up, making room for any memory needed by your function. Along with some function call overhead, all of your function locals are managed there. So that <code>static char greeting[100]</code>, means that 100 bytes of the increased stack are for that string. You than use some functions that manipulate that memory. At the you place a pointer on the stack to the greeting memory. And then you return from the call, at which point, the stack pointer is retracted back to it's original before call position. So those 100 bytes that were on the stack for the duration of your call, are essentially up for grabs again as the stack is further manipulated. Including the address field which pointed to that value and that you returned. At that point, who knows what happens to it, but it's likely set to zero or some other value. And when you try to access it as if it were still viable memory, you get a segfault.</p>
<p>To get around, you need to manage that memory differently somehow. You can have your function <code>alloc</code>ate the memory on the heap, but you'll need to make sure it gets <code>free()</code>'ed at a later date, by your binding. OR, you can write your function so that the binding language passes it a glump of memory to be used.</p>
</div>
<span class="comment-copy">You need to set <code>foo.restype</code> appropriately. Do you really want to use <code>static</code>? Not threadsafe. Wouldn't you be better allocating memory in Python and letting the C code populate it with content? Or allocate in the C code, and export a deallocator too.</span>
<span class="comment-copy">You should probably return a copy of the string; use <code>strdup</code> or <code>malloc</code> for that. But really, if you want to do this kind of things in C, then invest in a C book. C is quite different from higher-level languages such as Python.</span>
<span class="comment-copy">Aside from the problem you describe, your buffer is <code>static</code>, so there's only one for all calls, so the next call would change what the first return value points at. Keeping it local and not <code>static</code> means its lifetime ends when the function returns, which makes it unsuitable. That's not even touching on the buffer overflow vulnerability!</span>
<span class="comment-copy">Heh, obviously a C noob here. :) If I remove <code>static</code> gcc gives me a warning. What's the proper way to allocate the memory for return? I'm just looking for something safe and straightforward.</span>
<span class="comment-copy">There is little safe or straightforward in C ;-) At least not if you work with a Python mindset. Read a good C book. Reading <i>existing</i> questions and answers here on Stackoverflow works in a pinch but I wouldn't bet on it. (Btw, gcc gives a warning for the very reason I hinted at: It's incorrect, you're returning the address of something that doesn't exist any more.)</span>
<span class="comment-copy">Very nice! Thank you. A followup question on this answer: Since we're allocating the memory here, where/when is it deallocated? If I call this function 10k times, will I have an awful leak?</span>
<span class="comment-copy">Beat me to it. This should do the job (unless there is any other unforeseen problems).  The reason it didn't work before was that the by creating the string like you did, it was allocated on the stack and was thus lost once the function exited. The solution instead uses malloc to allocate on the heap, and returns to Python the location where to find the string.</span>
<span class="comment-copy">@ThaneBrimhall Of course for every malloc you need to make a <a href="http://www.cplusplus.com/reference/cstdlib/free/" rel="nofollow noreferrer">free</a></span>
<span class="comment-copy">I suppose I'd have to free it in the Python binding? Or where else would I do that?</span>
<span class="comment-copy">Perfect, thank you! See <a href="http://stackoverflow.com/questions/13445568/python-ctypes-how-to-free-memory-getting-invalid-pointer-error">this</a> question for one way to do it.</span>
<span class="comment-copy">I can't do the "much better approach" you recommended (return a Python object) because I need to bind this function in multiple languages.</span>
<span class="comment-copy">Okay, that can be a problem! Another option is SWIG, which can bind several languages (<a href="http://www.swig.org/compat.html#SupportedLanguages" rel="nofollow noreferrer">swig.org/compat.html#SupportedLanguages</a>). I use ctypes from time to time, but it can be unwieldy when the interface is complex.</span>
<span class="comment-copy">I added the python code to the example - its not tested but looks right to me (lol).</span>
<span class="comment-copy">Excellent explanation of how it all works. How would I deallocate the memory once I use the result in my binding?</span>
<span class="comment-copy"><code>free(pointer)</code>. That's the opposite of <code>malloc</code> and friends. You'll have to provide a binding for that, or hope that you have one already, most languages that bind to C have some mechanism for doing that.</span>
