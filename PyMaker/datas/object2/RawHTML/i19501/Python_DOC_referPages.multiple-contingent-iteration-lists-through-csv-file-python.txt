<div class="post-text" itemprop="text">
<p>I'm on a Windows 7 x64 workstation running Python 2.7.3.</p>
<p>I have a CSV file containing rows of item IDs, with each row belonging to a group ID, like so:</p>
<pre><code>GroupID ItemID
a   1
a   2
a   3
b   4
b   5
b   6
c   7
c   8
c   9
etc…    
</code></pre>
<p>What I need to do is generate a list of tuples, wherein each tuple is a string of the GroupID and a list of each ItemID associated with the GroupID, like so:</p>
<pre><code>[('a', [1, 2, 3]), ('b', [4, 5, 6]), ('c', [7 , 8, 9])]
</code></pre>
<p>So far I've thought of using a function or list to set conversion to de-duplicate the GroupID column, then doing some sort of comparison if statement on a second loop through. Could anyone give me some advice please? Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You are looking for <a href="http://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby()</code></a>:</p>
<blockquote>
<p>Make an iterator that returns consecutive keys and groups from the
  iterable. The key is a function computing a key value for each
  element. If not specified or is None, key defaults to an identity
  function and returns the element unchanged. Generally, the iterable
  needs to already be sorted on the same key function.</p>
</blockquote>
<p>For example:</p>
<pre><code>import csv
from itertools import groupby
from operator import itemgetter

with open("test.csv") as file:
    reader = csv.reader(file)
    next(reader) #Skip header
    data = groupby(reader, itemgetter(0))
    print([(key, [item for _, item in items]) for key, items in data])
</code></pre>
<p>We combine this with an <a href="http://docs.python.org/3.3/library/operator.html#operator.itemgetter" rel="nofollow"><code>operator.itemgetter()</code></a> to say we want to group by the first item in the row, then we use a nested <a href="http://www.youtube.com/watch?v=pShL9DCSIUw" rel="nofollow">list comprehension</a> to extract the data we want. </p>
<p>Which gives us:</p>
<pre><code>[('a', ['1', '2', '3']), ('b', ['4', '5', '6']), ('c', ['7', '8', '9'])]
</code></pre>
<p>Naturally, unless you <em>need</em> a list, it is better to use a generator expression here to do the operation lazily. (We use a list comprehension here to get nice output).</p>
<p>Note that I assume your file is comma separated like you say, not as shown in your example. If it's tab separated, use <code>csv.reader(file, dialect=csv.excel_tab)</code> to parse it correctly.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the grouping key is sequential, then something like:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

data = [('a', 1), ('a', 2), ('b', 3), ('b', 5)]

grouped = [(k, map(itemgetter(1), g)) for k, g in groupby(data, itemgetter(0))]
# [('a', [1, 2]), ('b', [3, 5])]
</code></pre>
<p>Otherwise, use a <code>collections.defaultdict</code>.</p>
</div>
<span class="comment-copy">Note that using <code>map()</code> and an <code>operator.itemgetter()</code> is hugely less readable and also significantly (⅓ in my tests) slower than using a list comprehension and indexing or tuple unpacking and throwing away the first part (<code>[i[1] for i in g]</code> or <code>[i for _, i in g]</code> respectively).</span>
<span class="comment-copy">@Lattyware "hugely less readable" I dispute, but otherwise - fair enough point.</span>
