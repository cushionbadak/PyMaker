<div class="post-text" itemprop="text">
<p>Using the LRU Cache decorator found here:
<a href="http://code.activestate.com/recipes/578078-py26-and-py30-backport-of-python-33s-lru-cache/" rel="noreferrer">http://code.activestate.com/recipes/578078-py26-and-py30-backport-of-python-33s-lru-cache/</a></p>
<pre><code>from lru_cache import lru_cache
class Test:
    @lru_cache(maxsize=16)
    def cached_method(self, x):
         return x + 5
</code></pre>
<p>I can create a decorated class method with this but it ends up creating a global cache that applies to <strong>all</strong> instances of class Test. However, my intent was to create a per instance cache. So if I were to instantiate 3 Tests, I would have 3 LRU caches rather than 1 LRU cache that for all 3 instances.</p>
<p>The only indication I have that this is happening is when calling the cache_info() on the different class instances decorated methods, they all return the same cache statistics (which is extremely unlikely to occur given they are being interacted with very different arguments):</p>
<pre><code>CacheInfo(hits=8379, misses=759, maxsize=128, currsize=128)
CacheInfo(hits=8379, misses=759, maxsize=128, currsize=128)
CacheInfo(hits=8379, misses=759, maxsize=128, currsize=128)
</code></pre>
<p>Is there a decorator or trick that would allow me to easily cause this decorator to create a cache for each class instance?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you don't want to modify the code (e.g., because you want to be able to just port to 3.3 and use the stdlib <a href="http://docs.python.org/3/library/functools.html#functools.lru_cache"><code>functools.lru_cache</code></a>, or use <a href="http://pypi.python.org/pypi/functools32/"><code>functools32</code></a> out of PyPI instead of copying and pasting a recipe into your code), there's one obvious solution: Create a new decorated instance method with each instance.</p>
<pre><code>class Test:
    def cached_method(self, x):
         return x + 5
    def __init__(self):
         self.cached_method = lru_cache(maxsize=16)(self.cached_method)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this: a <em>function</em> decorator that wraps the <em>method</em> with <code>lru_cache</code> the first time it's called on each instance?</p>
<pre><code>def instance_method_lru_cache(*cache_args, **cache_kwargs):
    def cache_decorator(func):
        @wraps(func)
        def cache_factory(self, *args, **kwargs):
            print('creating cache')
            instance_cache = lru_cache(*cache_args, **cache_kwargs)(func)
            instance_cache = instance_cache.__get__(self, self.__class__)
            setattr(self, func.__name__, instance_cache)
            return instance_cache(*args, **kwargs)
        return cache_factory
    return cache_decorator
</code></pre>
<p>Use it like this:</p>
<pre><code>class Foo:
    @instance_method_lru_cache()
    def times_2(self, bar):
        return bar * 2

foo1 = Foo()
foo2 = Foo()

print(foo1.times_2(2))
# creating cache
# 4
foo1.times_2(2)
# 4

print(foo2.times_2(2))
# creating cache
# 4
foo2.times_2(2)
# 4
</code></pre>
<p><a href="https://gist.github.com/z0u/9df24dda2b1fe0613a85e7349d5f7d62" rel="nofollow">Here's a gist on GitHub</a> with some inline documentation.</p>
</div>
<span class="comment-copy">Remember, a decorator is just syntax sugar for <code>def method: pass; method = decorate(method)</code>. So you can mechanically translate this to create the decorated method in your <code>__init__</code>.</span>
<span class="comment-copy">Are you sure that you know what a "class method" is for? Because I think you look for a normal method. If a class method is instance specific, it is, by definition, a normal method of an instance. Or why exactly do you even need a class method? Or why do you want a "per-instance" cache?</span>
<span class="comment-copy">Awesome. But how can I do this for a get-only @property?</span>
<span class="comment-copy">How does this work?</span>
<span class="comment-copy">@Gilly you don't, you just make a _variable attribute and store the cached values there.</span>
