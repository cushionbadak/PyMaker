<div class="post-text" itemprop="text">
<p>Assuming I have a path such as <code>/resource/123/resourceb/b/someotherresource/</code>.  In this case <code>someotherresource</code> has no resource id.  This example has 3 resources, but I need to handler anywhere between 1-4 resources.</p>
<p>What is a pythonic way to split it into <code>[(a,b), (c,d), (e, None)]</code></p>
<p>Example:</p>
<pre><code>x =  '/resource/123/resourceb/b/someotherresource/'
xplit = x.split('/')
&gt;&gt;&gt; [ 'resource', '123', 'resourceb', 'b', 'someotherresource']
import magic
# ideal result
&gt;&gt;&gt; [ ('resource', '123'), ('resourceb', 'b'), ('someotherresource', None)]
</code></pre>
<p>I know I can do it the stupid way, but is there a simple way to split &amp; pair an array of odd length ? </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [24]: x
Out[24]: '/resource/123/resourceb/b/someotherresource/'

In [25]: s = x.strip('/').split('/')

In [26]: zip(s[::2], s[1::2] + [None])
Out[26]: [('resource', '123'), ('resourceb', 'b'), ('someotherresource', None)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>itertools.izip_longest()</code> and <code>iter</code> magic:</p>
<pre><code>import itertools
list(itertools.izip_longest(*[iter(xplit[1:])]*2))
</code></pre>
<p>We start at index 1 because the leading <code>/</code> slash gives you an empty element at the start.</p>
<p>Alternatively, strip of the slashes at start and end:</p>
<pre><code>list(itertools.izip_longest(*[iter(x.strip('/').split('/'))]*2))
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; list(itertools.izip_longest(*[iter(x.strip('/').split('/'))]*2))
[('resource', '123'), ('resourceb', 'b'), ('someotherresource', None)]
</code></pre>
<p>Wrapped up as magic method:</p>
<pre><code>import itertools

def split_to_pairs(path):
    path = path.strip('/').split('/')
    return list(itertools.izip_longest(*[iter(path)]*2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check out the <code>grouper()</code> <a href="http://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">recipie from <code>itertools</code></a>:</p>
<pre><code>def grouper(n, iterable, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper(3, 'ABCDEFG', 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
<p>(In 2.x, <code>zip_longest()</code> is <code>izip_longest()</code>)</p>
</div>
<span class="comment-copy">Would adapting <a href="http://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks-in-python">this answer</a> to handle odd numbers do the trick, or is that the stupid way of which you speak.</span>
<span class="comment-copy">@cms_mgr The top answer to that question is sub-optimal as it only works on sequences, not arbitrary iterables.</span>
<span class="comment-copy">+1 I like this one. No strings attached, no dependencies. No lambdas. Just striding slices and zip. Nice</span>
<span class="comment-copy">This does rely on <code>s</code> being a list, instead of an arbitrary iterable, which is a little sub-optimal depending on usage. (It also wouldn't scale well to different sized groups).</span>
<span class="comment-copy">Won't you need <code>izip_longest</code> to get the <code>None</code> in there?</span>
<span class="comment-copy">@mgilson: indeed, travel tiredness made me slow!</span>
<span class="comment-copy">The fudgesickle that I happened to be snacking on slowed me down ;-)</span>
