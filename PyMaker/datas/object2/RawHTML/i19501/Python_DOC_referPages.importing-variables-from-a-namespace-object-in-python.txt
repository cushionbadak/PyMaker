<div class="post-text" itemprop="text">
<p>Say I have a namespace <code>args</code> that I obtain from calling <code>parser.parse_args()</code>, which parses the command line arguments.</p>
<p>How can I import all variables from this namespace to my current namespace?</p>
<p>e.g.</p>
<pre><code>parser.add_argument('-p', '--some_parameter', default=1)

args = parser.parse_args()

# ... code to load all variables defined in the namespace args ...

print some_parameter
</code></pre>
<p>I could certainly do:</p>
<pre><code>some_parameter = args.some_parameter
</code></pre>
<p>but if I have a large number of parameters I would need one such line for each parameter.</p>
<p>Is there another way of importing variables from a namespace without having to go through them one by one?</p>
<p><strong>PS</strong>: <code>from args import *</code> does not work.</p>
<p><strong>PS2</strong>: I am aware that this is a bad practice, but this can help in some corner cases, such us when prototyping code and tests <strong>very</strong> quickly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Update your local namespace with the result of the <a href="http://docs.python.org/3/library/functions.html#vars" rel="nofollow"><code>vars()</code> function</a>:</p>
<pre><code>globals().update(vars(args))
</code></pre>
<p>This is generally <em>not</em> that great an idea; leave those attributes in the namespace instead.</p>
<p>You could create more problems than you solved with this approach, especially if you accidentally configure arguments with a <a href="http://docs.python.org/3/library/argparse.html#dest" rel="nofollow"><code>dest</code> name</a> that shadows a built-in or local you care about, such as <code>list</code> or <code>print</code> or something. Have fun hunting down <em>that</em> bug!</p>
<p>Tim Peters already stated this in his Zen of Python:</p>
<blockquote>
<p>Namespaces are one honking great idea -- let's do more of those!</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Probably the worst idea ever: since you can pass an arbitrary object to <code>parse_args()</code>, pass the <code>__builtins__</code> module, so that all attributes can be looked up as local variables.</p>
<pre><code>p = argparse.ArgumentParser()
p.add_argument("--foo")
p.parse_args( "--foo bar".split(), __builtins__)
print foo
</code></pre>
<p>This will even "work" for parameters whose destinations aren't valid Python identifiers:</p>
<pre><code># To use the example given by Francis Avila in his comment on Martijn Pieters' answer
getattr(__builtins__, '2my-param')
</code></pre>
</div>
<span class="comment-copy">You could loop over <code>__dict__</code> or use <code>inspect</code>...</span>
<span class="comment-copy">Or just <code>locals().update(namespace._get_kwargs())</code>.</span>
<span class="comment-copy">Why do you <i>want</i> to do this? Why not just access <code>args.some_parameter</code>? (Especially since, in a non-trivial program, you're probably going to want to pass the options to other functions, which means if you've got lots of options you're probably going to end up building a <code>dict</code> or other object equivalent to the namespace you pulled apartâ€¦)</span>
<span class="comment-copy">you can also use <code>vars(args)</code> to get a <code>dict</code></span>
<span class="comment-copy">+1. I forgot that <code>vars(namespace)</code> and <code>namespace._get_kwargs()</code> will return the same thing.</span>
<span class="comment-copy">It's not merely a bad idea that makes for hard-to-read code--it's also a rich source of unintended bugs and security holes. You could easily overwrite globals and builtins--e.g. suppose you have a parameter named <code>list</code>? Or a parameter which can't be an identifier, like <code>2my-param</code>?</span>
<span class="comment-copy">@FrancisAvila: It's not necessarily a security hole, provided the parser has been set up with sane argument names. You cannot inject <i>arbitrary</i> argument destinations in any case. Besides, the user of this program already has local-user access to be able to run it..</span>
<span class="comment-copy">tsk,tsk.  You shouldn't modify <code>locals</code>.  quoting from the <a href="http://docs.python.org/2/library/functions.html#locals" rel="nofollow noreferrer">documentation</a> "The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter."</span>
<span class="comment-copy">@mgilson: That mostly applies to functions; grab a parent function in the current call stack and try to update it's <code>f_locals</code> structure with new values for example and it'll fail.. But for modules (where <code>locals()</code> == <code>globals()</code> anyway, it'll work just fine. :-)</span>
