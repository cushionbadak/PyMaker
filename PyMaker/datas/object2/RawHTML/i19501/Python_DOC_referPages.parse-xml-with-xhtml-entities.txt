<div class="post-text" itemprop="text">
<p>Trying to parse XML, with ElementTree, that contains undefined entity (i.e. <code>&amp;nbsp;</code>) raises:  </p>
<p><code>ParseError: undefined entity &amp;nbsp;</code></p>
<p>In Python 2.x XML entity dict can be updated by creating parser (<a href="http://effbot.org/elementtree/elementtree-xmlparser.htm#tag-ET.XMLParser.entity">documentation</a>):</p>
<pre><code>parser = ET.XMLParser()
parser.entity["nbsp"] = unichr(160)
</code></pre>
<p>but how to do the same with Python 3.x?</p>
<hr/>
<p>Update: There was misunderstanding from my side, because I overlooked that I was calling <code>parser.parser.UseForeignDTD(1)</code> before trying to update XML entity dict, which was causing error with the parser. Luckily, @m.brindley was patient and pointed that XML entity dict still exists in Python 3.x and can be updated the same way as in Python 2.x</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue here is that the only valid mnemonic entities in XML are <code>quot</code>, <code>amp</code>, <code>apos</code>, <code>lt</code> and <code>gt</code>. This means that almost all (X)HTML named entities must be defined in the DTD using the <a href="http://www.w3.org/TR/2006/REC-xml11-20060816/#sec-entity-decl">entity declaration markup</a> defined in the <a href="http://www.w3.org/TR/2006/REC-xml11-20060816/">XML 1.1 spec</a>. If the document is to be standalone, this should be done with an inline DTD like so:</p>
<pre><code>&lt;?xml version="1.1" ?&gt;
&lt;!DOCTYPE naughtyxml [
    &lt;!ENTITY nbsp "&amp;#0160;"&gt;
    &lt;!ENTITY copy "&amp;#0169;"&gt;
]&gt;
&lt;data&gt;
    &lt;country name="Liechtenstein"&gt;
        &lt;rank&gt;1&amp;nbsp;&amp;gt;&lt;/rank&gt;
        &lt;year&gt;2008&amp;copy;&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor name="Austria" direction="E"/&gt;
        &lt;neighbor name="Switzerland" direction="W"/&gt;
    &lt;/country&gt;
&lt;/data&gt;
</code></pre>
<p>The <code>XMLParser</code> in <code>xml.etree.ElementTree</code> uses an <code>xml.parsers.expat</code> to do the actual parsing. In the init arguments for <code>XMLParser</code>, there is a space for '<a href="http://docs.python.org/3/library/xml.etree.elementtree.html#xmlparser-objects">predefined HTML entities</a>' but that argument is not implemented yet. An empty dict named <code>entity</code> is created in the init method and this is what is used to look up undefined entities.</p>
<p>I don't think expat (by extension, the ET XMLParser) is able to handle switching namespaces to something like XHMTL to get around this. Possibly because it will not fetch external namespace definitions (I tried making <code>xmlns="http://www.w3.org/1999/xhtml"</code> the default namespace for the data element but it did not play nicely) but I can't confirm that. By default, expat will raise an error against non XML entities but you can get around that by defining an external DOCTYPE - this causes the expat parser to pass undefined entity entries back to the <code>ET.XMLParser</code>'s <code>_default()</code> method.</p>
<p>The <code>_default()</code> method does a look up of the <code>entity</code> dict in the <code>XMLParser</code> instance and if it finds a matching key, it will replace the entity with the associated value. This maintains the Python-2.x syntax mentioned in the question.</p>
<p><strong>Solutions:</strong></p>
<ul>
<li>If the data does not have an external DOCTYPE and has (X)HTML mnemonic entities, you are out of luck. It is not valid XML and expat is right to throw an error. You should add an external DOCTYPE.</li>
<li>If the data has an external DOCTYPE, you can just use your old syntax to map mnemonic names to characters. <em>Note: you should use <code>chr()</code> in py3k - <code>unichr()</code> is not a valid name anymore</em>
<ul>
<li>Alternatively, you could update <code>XMLParser.entity</code> with <code>html.entities.html5</code> to map all valid HTML5 mnemonic entities to their characters.</li>
</ul></li>
<li>If the data is XHTML, you could subclass <code>HTMLParser</code> to handle mnemonic entities but this won't return an <code>ElementTree</code> as desired.</li>
</ul>
<p>Here is the snippet I used - it parses XML with an external DOCTYPE through <code>HTMLParser</code> (to demonstrate how to add entity handling by subclassing), <code>ET.XMLParser</code> with entity mappings and <code>expat</code> (which will just silently ignore undefined entities due to the external DOCTYPE). There is a valid XML entity (<code>&amp;gt;</code>) and an undefined entity (<code>&amp;copy;</code>) which I map to <code>chr(0x24B4)</code> with the <code>ET.XMLParser</code>.</p>
<pre><code>from html.parser import HTMLParser
from html.entities import name2codepoint
import xml.etree.ElementTree as ET
import xml.parsers.expat as expat

xml = '''&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE data PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;data&gt;
    &lt;country name="Liechtenstein"&gt;
        &lt;rank&gt;1&amp;gt;&lt;/rank&gt;
        &lt;year&gt;2008&amp;copy;&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor name="Austria" direction="E"/&gt;
        &lt;neighbor name="Switzerland" direction="W"/&gt;
    &lt;/country&gt;
&lt;/data&gt;'''

# HTMLParser subclass which handles entities
print('=== HTMLParser')
class MyHTMLParser(HTMLParser):
    def handle_starttag(self, name, attrs):
        print('Start element:', name, attrs)
    def handle_endtag(self, name):
        print('End element:', name)
    def handle_data(self, data):
        print('Character data:', repr(data))
    def handle_entityref(self, name):
        self.handle_data(chr(name2codepoint[name]))

htmlparser = MyHTMLParser()
htmlparser.feed(xml)


# ET.XMLParser parse
print('=== XMLParser')
parser = ET.XMLParser()
parser.entity['copy'] = chr(0x24B8)
root = ET.fromstring(xml, parser)
print(ET.tostring(root))
for elem in root:
    print(elem.tag, ' - ', elem.attrib)
    for subelem in elem:
        print(subelem.tag, ' - ', subelem.attrib, ' - ', subelem.text)

# Expat parse
def start_element(name, attrs):
    print('Start element:', name, attrs)
def end_element(name):
    print('End element:', name)
def char_data(data):
    print('Character data:', repr(data))
print('=== Expat')
expatparser = expat.ParserCreate()
expatparser.StartElementHandler = start_element
expatparser.EndElementHandler = end_element
expatparser.CharacterDataHandler = char_data
expatparser.Parse(xml)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I was having a similar issue and got around it by using <a href="http://lxml.de/" rel="nofollow">lxml</a>. Its <code>etree.XMLParser</code> has a <code>recover</code> keyword argument which forces it to try to ignore broken XML.</p>
</div>
<span class="comment-copy">Thanks for exploring the problem, but I somehow doubt that Python 3.x SPL doesn't allow updating XML entities table. At least I couldn't find such announcement. Sorry, but using regex to prepare remote XHTML data is not acceptable as an idea.</span>
<span class="comment-copy">I had some more time to play with this and worked out why expat was not passing up to the <code>_default()</code> method in <code>XMLParser</code>. See my edit - you are able map entities provided an external DOCTYPE is defined.</span>
<span class="comment-copy">I wanted this question to be more general, but let's filter the problem more "locally": I have XHTML data with <code>xhtml1-transitional.dtd</code> and I know upfront that only undefined XML entity is <code>&amp;nbsp;</code>. I use lxml by default, and if not available fallback to SPL, but return ET.</span>
<span class="comment-copy">How exactly is the parsing failing out? If the XMLParser gets the undefined entity passed up to it and can't map it, the error raised is like 'undefined entity %s: line %d column %d' and if expat does not pass it up, the %s is not included.</span>
<span class="comment-copy">That's already included in my question: <code>ParseError: undefined entity &amp;nbsp;</code></span>
