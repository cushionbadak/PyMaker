<div class="post-text" itemprop="text">
<p>According to the <a href="http://docs.python.org/3.3/whatsnew/3.3.html#abc" rel="nofollow">docs</a> it should work to combine <code>@property</code> and <code>@abc.abstractmethod</code> so the following should work in python3.3:</p>
<pre><code>import abc

class FooBase(metaclass=abc.ABCMeta):

    @property
    @abc.abstractmethod
    def greet(self):
        """ must be implemented in order to instantiate """
        pass

    @property
    def greet_comparison(self):
        """ must be implemented in order to instantiate """
        return 'hello'

class Foo(FooBase):
    def greet(self):
        return 'hello'
</code></pre>
<p>test the implementation:</p>
<pre><code>In [6]: foo = Foo()
In [7]: foo.greet
Out[7]: &lt;bound method Foo.greet of &lt;__main__.Foo object at 0x7f935a971f10&gt;&gt;

In [8]: foo.greet()
Out[8]: 'hello'
</code></pre>
<p>so it is obviously not a property, because then it should work like that:</p>
<pre><code>In [9]: foo.greet_comparison
Out[9]: 'hello'
</code></pre>
<p>Maybe I'm to stupid or it simply doesn't work, somebody has an idea?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want <code>greet</code> to be a property, you still need to use the <code>@property</code> decorator in your implementation:</p>
<pre><code>class Foo(FooBase):
    @property
    def greet(self):
        return 'hello'
</code></pre>
<p>All that an ABC metaclass does is test wether or not you have provided the same name in the concrete class; it doesn't care if it is a method or a property or a regular attribute.</p>
<p>Because it doesn't care, it doesn't magically apply <code>property</code> decorators either. This is a <em>good</em> thing; perhaps in a specific implementation a static attribute is enough to satisfy the requirement, and a property would be overkill.</p>
<p>The purpose of a ABC metaclass is to help you detect gaps in your implementation; it never was intended to enforce the types of the attributes.</p>
<p>Note that before Python 3.3 you can not combine a <code>@property</code> with an <code>@abstractmethod</code>. You would have to use an <a href="http://docs.python.org/3/library/abc.html#abc.abstractproperty" rel="nofollow"><code>@abstractproperty</code> decorator</a> instead. There is an ambiguity there when your property needs more than a simple getter in that case; Python 3.3 covers that case much better (see <a href="http://bugs.python.org/issue11610" rel="nofollow">issue 11610</a> for the painful details).</p>
</div>
<span class="comment-copy">Just beat me to it :)</span>
<span class="comment-copy">If you were to have an abstract setter, would decorating greet fulfill the override requirement? Just a point of interest.</span>
<span class="comment-copy">@m.brindley: if <code>greet in dir(Foo)</code> works, it satisfies as an override. See this <a href="http://stackoverflow.com/questions/14441619/actual-difference-in-implementing-overriding-using-abstractproperty-and-abstra/14441682#14441682">previous answer of mine</a> on how ABC checks for overrides.</span>
<span class="comment-copy">Thanks for the explanation, one small thing on your last sentence, i i used it because the <a href="http://docs.python.org/dev/whatsnew/3.3.html#improved-modules" rel="nofollow noreferrer">python3.3 docs</a> mention, that the <code>@abstractproperty</code> decorator is deprecticated.</span>
<span class="comment-copy">Ah, I had not seen that yet; thanks for pointing that out! It does make sense; by supporting property methods like that an ambiguity (that I was not aware of) is resolved very nicely!</span>
