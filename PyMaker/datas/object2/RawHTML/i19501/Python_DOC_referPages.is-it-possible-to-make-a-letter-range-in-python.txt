<div class="post-text" itemprop="text">
<p>Is there a way to do a letter range in python like this:</p>
<pre><code>for x in range(a,h,)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Something like:</p>
<pre><code>for x in [chr(i) for i in range(ord('a'),ord('h')]
</code></pre>
<p>(or maybe:</p>
<pre><code>for x in map(chr, range(*map(ord,['a', 'h']))) 
</code></pre>
<p>)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>ord()</code> to convert the letters into character ordinals and back:</p>
<pre><code>def char_range(start, end, step=1):
    for char in range(ord(start), ord(end), step):
        yield chr(char)
</code></pre>
<p>It seems to work just fine:</p>
<pre><code>&gt;&gt;&gt; ''.join(char_range('a', 'z'))
    'abcdefghijklmnopqrstuvwxy'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no built in letter range, but you can write one:</p>
<pre><code>def letter_range(start, stop):
    for c in xrange(ord(start), ord(stop)):
        yield chr(c)


for x in letter_range('a', 'h'):
    print x,
</code></pre>
<p>prints:</p>
<pre><code>a b c d e f g
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import string

def letter_range(f,l,al = string.ascii_lowercase):
    for x in al[al.index(f):al.index(l)]:
        yield x

print ' '.join(letter_range('a','h'))
</code></pre>
<p>result</p>
<pre><code>a b c d e f g
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this is easier for me at least to read/understand (and you can easily customize which letters are included, and in what order):</p>
<pre><code>letters = 'abcdefghijklmnopqrstuvwxyz'
for each in letters:
    print each

result:
a
b
c
...
z
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Emanuele's solution is great as long as one is only asking for a range of single characters, which I will admit is what the original questioner posed.  There are also solutions out there to generate all multi-character combinations: <a href="https://stackoverflow.com/questions/16189505/how-to-generate-a-range-of-strings-from-aa-to-zz">How to generate a range of strings from aa... to zz</a>.  However I suspect that someone who wants a character like range function might want to be able to deal with generating an arbitrary range from say 'y' to 'af' (rolling over from 'z' to 'aa').  So here is a more general solution that includes the ability to either specify the last member of the range or its length.</p>
<pre><code>def strange(start, end_or_len, sequence='ABCDEFGHIJKLMNOPQRSTUVWXYZ'):
    """Create a generator of a range of 'sequential' strings from
    start to end_or_len if end_or_len is a string or containing
    end_or_len entries if end_or_len is an integer.

    &gt;&gt;&gt; list(strange('D', 'F'))
    ['D', 'E', 'F']
    &gt;&gt;&gt; list(strange('Y', 'AB'))
    ['Y', 'Z', 'AA', 'AB']
    &gt;&gt;&gt; list(strange('Y', 4))
    ['Y', 'Z', 'AA', 'AB']
    &gt;&gt;&gt; list(strange('A', 'BAA', sequence='AB'))
    ['A', 'B', 'AA', 'AB', 'BA', 'BB', 'AAA', 'AAB', 'ABA', 'ABB', 'BAA']
    &gt;&gt;&gt; list(strange('A', 11, sequence='AB'))
    ['A', 'B', 'AA', 'AB', 'BA', 'BB', 'AAA', 'AAB', 'ABA', 'ABB', 'BAA']
    """
    seq_len = len(sequence)
    start_int_list = [sequence.find(c) for c in start]
    if isinstance(end_or_len, int):
        inclusive = True
        end_int_list = list(start_int_list)
        i = len(end_int_list) - 1
        end_int_list[i] += end_or_len - 1
        while end_int_list[i] &gt;= seq_len:
            j = end_int_list[i] // seq_len
            end_int_list[i] = end_int_list[i] % seq_len
            if i == 0:
                end_int_list.insert(0, j-1)
            else:
                i -= 1
                end_int_list[i] += j
    else:
        end_int_list = [sequence.find(c) for c in end_or_len]
    while len(start_int_list) &lt; len(end_int_list) or start_int_list &lt;= end_int_list:
        yield ''.join([sequence[i] for i in start_int_list])
        i = len(start_int_list)-1
        start_int_list[i] += 1
        while start_int_list[i] &gt;= seq_len:
            start_int_list[i] = 0
            if i == 0:
                start_int_list.insert(0,0)
            else:
                i -= 1
                start_int_list[i] += 1


if __name__ =='__main__':
    import doctest
    doctest.testmod()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>how about slicing an already pre-arranged list?</p>
<pre><code>import string

s = string.ascii_lowercase
print( s[ s.index('b'):s.index('o')+1 ] )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Malcom's example works great, but there is a little problem due to how Pythons list comparison works.  If 'A' to "Z" or some character to "ZZ" or "ZZZ" will cause incorrect iteration.</p>
<p>Here "AA" &lt; "Z" or "AAA" &lt; "ZZ" will become false.</p>
<p>In Python [0,0,0] is smaller than [1,1] when compared with "&lt;" or "&gt;" operator.</p>
<p>So below line</p>
<pre><code>while len(start_int_list) &lt; len(end_int_list) or start_int_list &lt;= end_int_list:
</code></pre>
<p>should be rewritten as below</p>
<pre><code>while len(start_int_list) &lt; len(end_int_list) or\
        ( len(start_int_list) == len(end_int_list) and start_int_list &lt;= end_int_list):
</code></pre>
<p>It is well explained here
<a href="https://docs.python.org/3/tutorial/datastructures.html#comparing-sequences-and-other-types" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html#comparing-sequences-and-other-types</a></p>
<p>I rewrote the code example below.</p>
<pre><code>def strange(start, end_or_len, sequence='ABCDEFGHIJKLMNOPQRSTUVWXYZ'):

    seq_len = len(sequence)
    start_int_list = [sequence.find(c) for c in start]
    if isinstance(end_or_len, int):
        inclusive = True
        end_int_list = list(start_int_list)
        i = len(end_int_list) - 1
        end_int_list[i] += end_or_len - 1
        while end_int_list[i] &gt;= seq_len:
            j = end_int_list[i] // seq_len
            end_int_list[i] = end_int_list[i] % seq_len
            if i == 0:
                end_int_list.insert(0, j-1)
            else:
                i -= 1
                end_int_list[i] += j
    else:
        end_int_list = [sequence.find(c) for c in end_or_len]

    while len(start_int_list) &lt; len(end_int_list) or\
         (len(start_int_list) == len(end_int_list) and start_int_list &lt;= end_int_list):**
        yield ''.join([sequence[i] for i in start_int_list])
        i = len(start_int_list)-1
        start_int_list[i] += 1
        while start_int_list[i] &gt;= seq_len:
            start_int_list[i] = 0
            if i == 0:
                start_int_list.insert(0,0)
            else:
               i -= 1
                start_int_list[i] += 1
</code></pre>
<p>Anyway, Malcom's code example is a great illustration of how iterator in Python works.</p>
</div>
<span class="comment-copy">possible dup of <a href="http://stackoverflow.com/questions/7001144/range-over-character-in-python" title="range over character in python">stackoverflow.com/questions/7001144/…</a> and <a href="http://stackoverflow.com/questions/3190122/python-how-to-print-range-a-z" title="python how to print range a z">stackoverflow.com/questions/3190122/…</a> (each of which have lots of good answers)</span>
<span class="comment-copy">Note that this doesn't include the last letter, so if you wanted to do the whole alphabet you'd do something like:      [chr(i) for i in range(ord('a'),ord('z') + 1]</span>
<span class="comment-copy">... new to the site, how do I make a code block appear correctly? (as opposed to what I put above?)</span>
<span class="comment-copy">select the code and hit the <code>{}</code> button, or indent each code line at least four spaces</span>
