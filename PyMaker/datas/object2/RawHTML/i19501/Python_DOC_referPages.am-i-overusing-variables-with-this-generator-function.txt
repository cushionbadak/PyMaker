<div class="post-text" itemprop="text">
<p>I have these two functions which work together.  The first generates the next prime number.  The second appends that prime number to a list of primes.  I feel like I am overusing variables in the second function when I basically say i = next(n) = nextPrime(primeList).  Is there a better way to write this?</p>
<pre><code>def nextPrime(primeList):
    checkNum = 3
    while True:
        for i in primeList:
            if checkNum % i == 0:
                break
            if i &gt; math.sqrt(checkNum):
                yield checkNum
                break
        checkNum += 2


def primeNumbers(limit):
    primeList = [2]
    i = 0
    n = nextPrime(primeList)
    while i &lt;= limit:
        i = next(n)
        primeList.append(i)
    return primeList

primeList = primeNumbers(200000)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Does this work out okay?</p>
<pre><code>def primeNumbers(limit):
    primeList = [2]
    for i in nextPrime(primeList):
        if i &gt; limit:
            break
        primeList.append(i)
    return primeList
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/3/library/itertools.html#itertools.takewhile" rel="nofollow"><code>itertools.takewhile</code></a> to do most of the work for you:</p>
<pre><code>import itertools

def primeNumbers(limit):
    primes = nextPrime((2,))

    # Limit to `limit`.
    primes = itertools.takewhile(lambda i: i &lt;= limit, primes)

    # Return a list.
    return list(primes)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This doesn't use two functions to do it, but here is the general (and I believe the fastest) method of generating primes up to 'n', using the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="nofollow">Sieve of Eratosthenes</a>:</p>
<pre><code>def prevPrimes(n):
    """Generates a list of primes up to 'n'"""
    from numbers import Integral as types #'Integral' is a class of integers/long-numbers
    if not isinstance(n, types): raise TypeError("n must be int, not " + str(type(n)))
    if n &lt; 2: raise ValueError("n must greater than 2")
    primes_dict = {i : True for i in range(2, n + 1)} # initializes the dictionary
    for i in primes_dict:
        if primes_dict[i]: #avoids going through multiples of numbers already declared False
            num = 2
            while (num * i &lt;= n): #sets all multiples of i (up to n) as False
                primes_dict[num*i] = False
                num += 1
    return [num for num in primes_dict if primes_dict[num]]
</code></pre>
<p>As Jack J pointed out, avoiding all even numbers makes this code faster.</p>
<pre><code>def primes(n):
    """Generates a list of primes up to 'n'"""
    primes_dict = {i : True for i in range(3, n + 1, 2)} # this does not
    for i in primes_dict:
        if primes_dict[i]:
            num = 3
            while (num * i &lt;= n):
                primes_dict[num*i] = False
                num += 2
    primes_dict[2] = True
    return [num for num in primes_dict if primes_dict[num]]
</code></pre>
<p>Then running the tests:</p>
<pre><code>from timeit import timeit
def test1():
    return primes(1000)

print 'Without Evens: ', timeit(test1, number=1000)
print 'With Evens: ', timeit(stmt='prevPrimes(1000)', setup='from nums import prevPrimes', number=1000)
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; 
Without Evens:  1.22693896972
With Evens:  3.01304618635
</code></pre>
</div>
<span class="comment-copy">I think it is twice as fast if primes_dict range counts only the odd numbers beginning with 3, and just before return, primes_dict[2] = True.  Also num would have to react in the same way by beginning at 3 and incrementing by two, but yes, this is much faster than my two functions.  Thanks.</span>
<span class="comment-copy">@JackJ That's a really good point, I rewrote my code, and it's about 2.5x faster (for 10000 calls) and doing <code>prevPrimes(1000)</code> --- this is using the <code>timeit.timeit</code> function.</span>
<span class="comment-copy">Even better, you can begin num = i instead of 3. Example: by the time you get to i = 11, 33 is now False, as is 55, as is 77, as is 99, but not yet 121, 143, and so on.  Also, I think setting values in a list is more efficient than setting values in a dict.  <a href="http://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a></span>
