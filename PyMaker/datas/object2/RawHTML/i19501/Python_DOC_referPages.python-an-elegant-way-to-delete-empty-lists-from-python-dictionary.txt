<div class="post-text" itemprop="text">
<p>I have a dictionary as:</p>
<pre><code>default = {'a': ['alpha'], 'b': ['beta','gamma'], 'g': []}
</code></pre>
<p>I wish to eliminate the empty values as:</p>
<pre><code>default = {'a': ['alpha'], 'b': ['beta','gamma']}
</code></pre>
<p>I wrote a function (following an example found on the web)</p>
<pre><code>def remove_empty_keys(d):
    for k in d.keys():
        try:
            if len(d[k]) &lt; 1:
                del[k]
        except:
            pass
        return(d)
</code></pre>
<p>I have the following questions:</p>
<p>1- I didn't find the mistake why it always returns following - </p>
<pre><code>remove_empty_keys(default)
 {'a': ['alpha'], 'b': ['beta'], 'g': []}
</code></pre>
<p>2- Is there a built-in function to eliminate/delete Null/None/empty values from Python dictionary without creating a copy of the original dictionary?</p>
</div>
<div class="post-text" itemprop="text">
<p>To fix your function, change <code>del[k]</code> to <code>del d[k]</code>. There is no function to delete values in place from a dictionary.</p>
<p>What you are doing is deleting the variable <code>k</code>, not changing the dictionary at all. This is why the original dictionary is always returned. </p>
<p>Rewritten, your function might look like:</p>
<pre><code>def remove_empty_keys(d):
    for k in d.keys():
        if not d[k]:
            del d[k]
</code></pre>
<p>This assumes you want to eliminate both empty list and <code>None</code> values, and actually removes any item with a "false" value.  </p>
</div>
<div class="post-text" itemprop="text">
<p>There's no builtin for this (AFAIK), but you can do it easily with a dict comprehension:</p>
<pre><code>new_dict = {k:v for k,v in original_dict.items() if v}
</code></pre>
<p>If you're stuck with an older version of python (pre 2.7 without dict comprehensions), you can use the dict constructor:</p>
<pre><code>new_dict = dict((k,v) for k,v in original_dict.items() if v)
</code></pre>
<p>Note that this doesn't operate in place (as per your second question).  And dictionaries don't support slice assignment like lists do, so the best* you can really do to get this all done in place is:</p>
<pre><code>new_dict = {k:v for k,v in original_dict.items() if v}
original_dict.clear()
original_dict.update(new_dict)
</code></pre>
<p>*of course the term "best" is completely subjective.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>dict((k, v) for k, v in default.iteritems() if v)
</code></pre>
<p>This filters all items which are not empty strings, empty dict/tuple/list.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use dict comprehension: -</p>
<pre><code>&gt;&gt;&gt; default = {'a': ['alpha'], 'b': ['beta','gamma'], 'g': []}

&gt;&gt;&gt; {key: value for key, value in default.iteritems() if value}
{'a': ['alpha'], 'b': ['beta', 'gamma']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/14813529/284795">Michael's answer</a> is correct.</p>
<p>Stepping back, you might be able to avoid creating those empty lists at all, by use of <a href="http://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict(list)</code></a></p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; d = collections.defaultdict(list)
&gt;&gt;&gt; d
defaultdict(&lt;type 'list'&gt;, {})
&gt;&gt;&gt; d["hobbits"].append("Frodo")
&gt;&gt;&gt; d["hobbits"].append("Sam")
&gt;&gt;&gt; d
defaultdict(&lt;type 'list'&gt;, {'hobbits': ['Frodo', 'Sam']})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One more option is the following (without creating a new dict):</p>
<pre><code>for e in [k for k,v in default.iteritems() if len(v) == 0]: default.pop(e)
</code></pre>
</div>
<span class="comment-copy">Your question seems to mix the idea of <code>None</code> with empty lists. It makes it harder to understand.</span>
<span class="comment-copy">Perhaps a better way to say it would be "Is there a function to eliminate falsy values from a dictionary"</span>
<span class="comment-copy">Your <code>try...except</code> clause seems to serve no purpose except to hide your own errors from yourself.  If you really want to use try/except, then you should always specify the exception(s) that you expect (in this case KeyError).  That way, they won't unintentionally hide unrelated bugs.  But in this case, unless there's code in a parallel thread that's modifying <code>d</code>, you won't ever get a key error because <code>k</code> <i>must</i> be in <code>d</code> since it was returned by <code>d.keys()</code>.</span>
<span class="comment-copy">In Python 2, iterating over <code>d.keys()</code> (which was a list) made it possible to delete the values in the loop. In Python 3, <code>d.keys()</code> is <a href="https://docs.python.org/3/library/stdtypes.html#dict-views" rel="nofollow noreferrer">lazier</a>. Iterate over <code>list(d)</code> instead, or construct a new dictionary as in <a href="https://stackoverflow.com/a/14813423/1307866">@mgilson's answer</a></span>
<span class="comment-copy">The problem isn't modifying the dict as you're iterating over it -- I actually think that might be OK (though don't quote me on that).  It's that OP is doing <code>del [k]</code> instead of <code>del d[k]</code>.  It seems to me that the first form is creating a list and then deleting it (though I could be wrong about that since <code>del</code> is a statement ...</span>
<span class="comment-copy">@mgilson. Yeah just noticed that. I'll remove that line.</span>
