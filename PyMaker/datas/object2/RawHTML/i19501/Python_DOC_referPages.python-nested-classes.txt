<div class="post-text" itemprop="text">
<p>First of all, here's my test code, I'm using python 3.2.x:</p>
<pre><code>class account:
    def __init__(self):
        pass

    class bank:
        def __init__(self):
            self.balance = 100000

        def balance(self):
            self.balance

        def whitdraw(self, amount):
            self.balance -= amount

        def deposit(self, amount):
            self.balance += amount
</code></pre>
<p>when I do:</p>
<pre><code>a = account()
a.bank.balance
</code></pre>
<p>I expected to get the value of balance returned, instead I get the function "balance", why is this? It returns the value of balance when I do:</p>
<pre><code>class bank:
    def __init__(self):
        self.balance = 100000

    def balance(self):
        self.balance

    def whitdraw(self, amount):
        self.balance -= amount

    def deposit(self, amount):
        self.balance += amount

a = bank()
a.balance
</code></pre>
<p>So I want to know why this is and it would be great if someone could come up with a way to give me the value of balance in the nested version.</p>
</div>
<div class="post-text" itemprop="text">
<p>My version of your code, with comments:</p>
<pre><code>#
# 1. CamelCasing for classes
#
class Account:
    def __init__(self):
        # 2. to refer to the inner class, you must use self.Bank
        # 3. no need to use an inner class here
        self.bank = self.Bank()

    class Bank:
        def __init__(self):
            self.balance = 100000

        # 4. in your original code, you had a method with the same name as 
        #    the attribute you set in the constructor. That meant that the 
        #    method was replaced with a value every time the constructor was 
        #    called. No need for a method to do a simple attribute lookup. This
        #    is Python, not Java.

        def withdraw(self, amount):
            self.balance -= amount

        def deposit(self, amount):
            self.balance += amount

a = Account()
print(a.bank.balance)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are several problems:</p>
<ol>
<li>You're using the name <code>balance</code> for both the data member and for the function.</li>
<li>You're missing a <code>return</code> statement in <code>balance()</code>.</li>
<li><code>balance()</code> operates on an <em>instance</em> of <code>bank</code>. There is no instance in <code>a.bank.balance</code>: here, <code>a.bank</code> refers to the inner class itself.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p><code>a.bank</code> is the <strong>class</strong> (not instance) since you've never created an <em>instance</em> of the bank on <code>a</code>.  So if <code>a.bank</code> is a class, <code>a.bank.balance</code> is a method bound to that class.</p>
<p>This works however:</p>
<pre><code>class account:
    def __init__(self):
        self.bank = account.bank()

    class bank:
        def __init__(self):
            self.balance = 100000

        def whitdraw(self, amount):
            self.balance -= amount

        def deposit(self, amount):
            self.balance += amount

a = account()
print a.bank.balance
</code></pre>
<p>Of course, as you show working code without nested classes, It really begs the question about <em>why</em> you want to use nested classes for this.  I would argue that the non-nested version is much cleaner.</p>
</div>
<span class="comment-copy">May be a.bank.balance() (note: trailing brackets) will return correct value?</span>
<span class="comment-copy">TypeError: ret_balance() takes exactly 1 argument (0 given)</span>
<span class="comment-copy">Don't you need an instance of bank? i.e., in the <code>__init__</code> method of <code>account</code>, you need something like <code>self.my_bank = bank()</code>, I think. Then check with <code>a = account()</code> and <code>balance = a.my_bank.balance</code> should be 100000.</span>
<span class="comment-copy">You need to read a Python tutorial. See for instance <a href="http://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">docs.python.org/3/tutorial/classes.html</a></span>
<span class="comment-copy">There's almost never any need to nest class <i>definitions</i>. Certainly, there is no need to do it here.</span>
<span class="comment-copy">this is what I was looking for, thankyou :)</span>
<span class="comment-copy">changed the balance function's name to ret_balance and added return in it's body, same result though</span>
<span class="comment-copy">@Daquicker: See the third point.</span>
<span class="comment-copy">reading the other comments I'm convinced you're explanation of WHY it doesn't work is correct, do you have an idea on a way it would work?</span>
<span class="comment-copy">@Daquicker: You need to create an <i>instance</i> of <code>bank</code> within the instance of <code>account</code> (just make sure the class and the instance don't have the same name).</span>
<span class="comment-copy">Tried that by adding my_bank = bank() to the end of the account class, kinda doesn't work either, gives me this: &lt;bound method bank.ret_balance of &lt;__main__.bank object at 0x02D68E70&gt;&gt;</span>
<span class="comment-copy">@Daquicker -- classes are really neat, and nesting them isn't really a problem once you understand python's scoping rules (which is definitely worth investing some time to learn).  The main thing that I was trying to point out is that from a program design, it doesn't really make much sense in this case -- Actually, I tend to believe it doesn't make much sense in <i>most</i> cases, but maybe that's just because I haven't met those cases yet ;-).  Anyway, this is still useful stuff to work through as an exercise.</span>
<span class="comment-copy">I wanted to nest them because I need more things in account than only a bank and building classes for each major part seemed to be the neatest way to do it... I just want to keep everyhing together so it doesn't get scattered all across the code...</span>
