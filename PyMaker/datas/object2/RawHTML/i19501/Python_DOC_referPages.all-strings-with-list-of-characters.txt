<div class="post-text" itemprop="text">
<p>I'm making a specialized utility similar to John the Ripper, and I'd like to use a loop that returns all strings up to x characters that can be formed from the string. For example, if the "seed" string is <code>abcd</code>, it should return:</p>
<pre><code>a
b
c
d
aa
ab
ac
</code></pre>
<p>and so on. If the character limit is 10, it would generate <code>aaaaaaaaaa</code>, <code>abcddcbaaa</code>, and so on. Is there a simple <code>for</code> loop to do this, or is it more complicated than that?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'll self-plagiarize from <a href="https://stackoverflow.com/questions/14381940/python-pair-alphabets-after-loop-is-completed/14382997#14382997">this answer</a> and add a maximum length:</p>
<pre><code>from itertools import product

def multiletters(seq, max_length):
    for n in range(1, max_length+1):
        for s in product(seq, repeat=n):
            yield ''.join(s)
</code></pre>
<p>which gives</p>
<pre><code>&gt;&gt;&gt; list(multiletters("abc", 2))
['a', 'b', 'c', 'aa', 'ab', 'ac', 'ba', 'bb', 'bc', 'ca', 'cb', 'cc']
&gt;&gt;&gt; list(multiletters("abcd", 4))[:8]
['a', 'b', 'c', 'd', 'aa', 'ab', 'ac', 'ad']
</code></pre>
<p>and so on.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def all_strings(alphabet, length_limit=None):
  n_letters = len(alphabet)
  length = 0
  n_strings = 1
  buf = []
  while True:
    for i in xrange(0, n_strings):
      k = i
      for j in xrange(length - 1, -1, -1):
        buf[j] = alphabet[k % n_letters]
        k /= n_letters
      yield ''.join(buf)
    length += 1
    if length == length_limit:
      break
    n_strings *= n_letters
    buf.append(alphabet[0])

for s in all_strings('abcd', length_limit=4):
  print s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As pointed out in the comment's use <code>itertools.premutations</code> or even better take a look @DSM's answer, as this one misses the doubles:</p>
<pre><code>In [194]: from itertools import chain, permutations

In [195]: s = 'abcd'

In [196]: map(''.join,chain.from_iterable(permutations(s,x) 
                               for x in range(1,len(s)+1)))
Out[196]: 
['a',
 'b',
 'c',
 'd',
 'ab',
 'ac',
 'ad',
 'ba',
 'bc',
 'bd',
  ...
 'dbca',
 'dcab',
 'dcba']
</code></pre>
<p>Anyway,  here's a version of @DSM's answer that returns a list:</p>
<pre><code>from itertools import product

def ms(seq, max_length):
    return [''.join(s) for n in range(1, max_length+1)
                       for s in product(seq,repeat=n)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use itertools.permuataions.</p>
<pre><code>for i in range(2,4):
    tuples = itertools.permutations('abca' , i)
    print( list(tuples))
</code></pre>
<p>The example code sequence generates:</p>
<p>[('a', 'b'), ('a', 'c'), ('a', 'a'), ('b', 'a'), ('b', 'c'), ('b', 'a'), ('c', 'a'), ('c', 'b'), ('c', 'a'), ('a', 'a'), ('a', 'b'), ('a', 'c')]</p>
<p>[('a', 'b', 'c'), ('a', 'b', 'a'), ('a', 'c', 'b'), ('a', 'c', 'a'), ('a', 'a', 'b'), ('a', 'a', 'c'), ('b', 'a', 'c'), ('b', 'a', 'a'), ('b', 'c', 'a'), ('b', 'c', 'a'), ('b', 'a', 'a'), ('b', 'a', 'c'), ('c', 'a', 'b'), ('c', 'a', 'a'), ('c', 'b', 'a'), ('c', 'b', 'a'), ('c', 'a', 'a'), ('c', 'a', 'b'), ('a', 'a', 'b'), ('a', 'a', 'c'), ('a', 'b', 'a'), ('a', 'b', 'c'), ('a', 'c', 'a'), ('a', 'c', 'b')]</p>
</div>
<span class="comment-copy">You are looking for <a href="http://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>itertools.permutations()</code></a>.</span>
<span class="comment-copy">Is this answer <a href="http://stackoverflow.com/questions/14381940/python-pair-alphabets-after-loop-is-completed/14382997#14382997">here</a> the sort of thing you have in mind?  [It'd be easily modified to add a size limit.]</span>
<span class="comment-copy">@Lattyware man, Python is <i>awesome</i>.</span>
<span class="comment-copy">@Lattyware: <code>itertools.product()</code>, no? Permutations don't include repeated values, so no <code>'aaaaaaaa'</code>.</span>
<span class="comment-copy">@tkbx: You got those two backwards. <code>abc</code> has only one combination of 3 (<code>abc</code>) but six permutations of 3. (<code>abc</code> does, however, have 3 combinations of 2 and 3 combinations of 1, one of which is indeed <code>a</code>).</span>
<span class="comment-copy">This won't give <code>aa</code>, though.</span>
<span class="comment-copy">@DMS -- Arhhh. I guess, <code>product</code> it is then :)</span>
