<div class="post-text" itemprop="text">
<p>I have a Flask server running in standalone mode (using <code>app.run()</code>). But, I don't want any messages in the console, like</p>
<pre><code>127.0.0.1 - - [15/Feb/2013 10:52:22] "GET /index.html HTTP/1.1" 200 -
...
</code></pre>
<p>How do I disable verbose mode?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can set set level of the Werkzeug logger to ERROR, in that case only errors are logged:</p>
<pre><code>import logging
log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)
</code></pre>
<p>Here are a full working example testet on OSX, Python 2.7.5, Flask 0.10.0:</p>
<pre><code>from flask import Flask
app = Flask(__name__)

import logging
log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)

@app.route("/")
def hello():
    return "Hello World!"

if __name__ == "__main__":
    app.run()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another reason you may want to change the logging output is for tests, and redirect the server logs to a log file.</p>
<p>I couldn't get the suggestion above to work either, it looks like loggers are setup as part of the app starting. I was able to get it working by changing the log levels <strong>after</strong> starting the app:</p>
<pre><code>... (in setUpClass)
server = Thread(target=lambda: app.run(host=hostname, port=port, threaded=True))
server.daemon = True
server.start()
wait_for_boot(hostname, port)  # curls a health check endpoint

log_names = ['werkzeug']
app_logs = map(lambda logname: logging.getLogger(logname), log_names)
file_handler = logging.FileHandler('log/app.test.log', 'w')

for app_log in app_logs:
    for hdlr in app_log.handlers[:]:  # remove all old handlers
        app_log.removeHandler(hdlr)

    app_log.addHandler(file_handler)
</code></pre>
<p>Unfortunately the <code>* Running on localhost:9151</code> and the first health check is still printed to standard out, but when running lots of tests it cleans up the output a ton.</p>
<p>"So why <code>log_names</code>?", you ask.  In my case there were some extra logs I needed to get rid of.  I was able to find which loggers to add to log_names via:</p>
<pre><code>from flask import Flask
app = Flask(__name__)

import logging
print(logging.Logger.manager.loggerDict)
</code></pre>
<p>Side note: It would be nice if there was a flaskapp.getLogger() or something so this was more robust across versions.  Any ideas?</p>
<p>Some more key words: flask test log remove stdout output</p>
<p>thanks to:</p>
<ul>
<li><a href="http://code.activestate.com/lists/python-list/621740/" rel="nofollow noreferrer">http://code.activestate.com/lists/python-list/621740/</a> and </li>
<li><a href="https://stackoverflow.com/questions/13839554/how-to-change-filehandle-with-python-logging-on-the-fly-with-different-classes-a">How to change filehandle with Python logging on the fly with different classes and imports</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>@Drewes solution works most of the time, but in some cases, I still tend to get werkzeug logs. If you really don't want to see any of them, I suggest you disabling it like that.</p>
<pre><code>from flask import Flask
import logging

app = Flask(__name__)
log = logging.getLogger('werkzeug')
log.disabled = True
app.logger.disabled = True
</code></pre>
<p>For me it failed when <code>abort(500)</code> was raised.</p>
</div>
<div class="post-text" itemprop="text">
<p>In case you are using WSGI server , please set the log to None</p>
<pre><code>gevent_server = gevent.pywsgi.WSGIServer(("0.0.0.0", 8080), app,log = None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This solution provides you a way to get your own prints and stack traces but without information level logs from flask suck as <code>127.0.0.1 - - [15/Feb/2013 10:52:22] "GET /index.html HTTP/1.1" 200</code></p>
<pre class="lang-py prettyprint-override"><code>from flask import Flask
import logging

app = Flask(__name__)
log = logging.getLogger('werkzeug')
log.disabled = True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A <strong>brute force</strong> way to do it if you really don't want anything to log into the console beside print() statements is to <code>logging.basicConfig(level=logging.FATAL)</code>. This would disable all logs that are of status under fatal. It would not disable printing but yeah, just a thought :/</p>
<p>EDIT:
I realized it would be selfish of me not to put a link to the documentation I used :)
<a href="https://docs.python.org/3/howto/logging.html#logging-basic-tutorial" rel="nofollow noreferrer">https://docs.python.org/3/howto/logging.html#logging-basic-tutorial</a></p>
</div>
<span class="comment-copy">Can I ask <i>why</i> you don't want the HTTP request logs?!..</span>
<span class="comment-copy">So now you have an app kicking off threads (which are difficult enough to debug themselves) and now you're going to suppress logging on <i>top</i> of that? Eesh, sounds like the opposite of what I'd do.. The more verbose your logging the better (obviously as long as it's relevant ;)).</span>
<span class="comment-copy">@DemianBrecht The thing is, the logs are send to <code>stderr</code> but they are just logging each HTTP transaction, kinda irrelevant for me...</span>
<span class="comment-copy">Doesn't work for me.</span>
<span class="comment-copy">This doesn't seem to stop HTTP logs going to stderr; It DOES stop the "starting" message (which clearly has the "werkzeug" module name in the log format".</span>
<span class="comment-copy">Works for me. The request debug messages are supressed. Using Python 3.5.2, Flask 0.12 and Werkzeug 0.11.11</span>
<span class="comment-copy">Also works using Python 3.6, Flask 0.12 and Werkzeug 0.11.15.</span>
<span class="comment-copy">Unfortunately no longer fully works due to Flask using <code>click.secho</code></span>
<span class="comment-copy">This doesn't work either.</span>
