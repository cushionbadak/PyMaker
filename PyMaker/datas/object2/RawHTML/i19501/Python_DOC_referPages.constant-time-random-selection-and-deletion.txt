<div class="post-text" itemprop="text">
<p>I'm trying to implement an edge list for a MultiGraph in Python.</p>
<p><strong>What I've tried so far:</strong></p>
<pre><code>&gt;&gt;&gt; l1 = Counter({(1, 2): 2, (1, 3): 1})
&gt;&gt;&gt; l2 = [(1, 2), (1, 2), (1, 3)]
</code></pre>
<p><code>l1</code> has constant-time deletion of all edges between two vertices (e.g. <code>del l1[(1, 2)]</code>) but linear-time random selection on those edges (e.g. <code>random.choice(list(l1.elements()))</code>). Note that you have to do a selection on <code>elements</code> (vs. <code>l1</code> itself).</p>
<p><code>l2</code> has constant-time random selection (<code>random.choice(l2)</code>) but linear-time deletion of all elements equal to a given edge (<code>[i for i in l2 if i != (1, 2)]</code>).</p>
<p>Question: is there a Python data structure that would give me both constant-time random selection and deletion?</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think what you're trying to do is achievable in theory.</p>
<p>If you're using weighted values to represent duplicates, you can't get constant-time random selection. The best you could possibly do is some kind of skip-list-type structure that lets you binary-search the element by weighted index, which is logarithmic.</p>
<p>If you're <em>not</em> using weighted values to represent duplicates, then you need some structure that allows you to store multiple copies. And a hash table isn't going to do itâ€”the dups have to be independent objects (e.g., <code>(edge, autoincrement)</code>),, meaning there's no way to delete all that match some criterion in constant time.</p>
<p>If you can accept logarithmic time, the obvious choice is a tree. For example, using <a href="http://stutzbachenterprises.com/blist/sortedlist.html" rel="nofollow"><code>blist</code></a>:</p>
<pre><code>&gt;&gt;&gt; l3 = blist.sortedlist(l2)
</code></pre>
<p>To select one at random:</p>
<pre><code>&gt;&gt;&gt; edge = random.choice(l3)
</code></pre>
<p><a href="http://docs.python.org/2/library/random.html#random.choice" rel="nofollow">The documentation</a> doesn't seem to guarantee that this won't do something O(n). But fortunately, the source for both <a href="http://hg.python.org/cpython/file/3.3/Lib/random.py#l246" rel="nofollow">3.3</a> and <a href="http://hg.python.org/cpython/file/2.7/Lib/random.py#l272" rel="nofollow">2.7</a> shows that it's going to do the right thing. If you don't trust that, just write <code>l3[random.randrange(len(l3))]</code>.</p>
<p>To delete all copies of an edge, you can do it like this:</p>
<pre><code>&gt;&gt;&gt; del l3[l3.bisect_left(edge):l3.bisect_right(edge)]
</code></pre>
<p>Or:</p>
<pre><code>&gt;&gt;&gt; try:
...     while True:
...         l3.remove(edge)
... except ValueError:
...     pass
</code></pre>
<p>The documentation explains the exact performance guarantees for every operation involved. In particular, <code>len</code> is constant, while indexing, slicing, deleting by index or slice, bisecting, and removing by value are all logarithmic, so both operations end up logarithmic.</p>
<p>(It's worth noting that <code>blist</code> is a B+Tree; you might get better performance out of a red-black tree, or a treap, or something else. You can find good implementations for most data structures on PyPI.)</p>
<hr/>
<p>As pointed out by senderle, if the maximum number of copies of an edge is much smaller than the size of the collection, you can create a data structure that does it in time quadratic on the maximum number of copies. Translating his suggestion into code:</p>
<pre><code>class MGraph(object):
    def __init__(self):
        self.edgelist = []
        self.edgedict = defaultdict(list)
    def add(self, edge):
        self.edgedict[edge].append(len(self.edgelist))
        self.edgelist.append(edge)
    def remove(self, edge):
        for index in self.edgedict.get(edge, []):
            maxedge = len(self.edgelist) - 1
            lastedge = self.edgelist[maxedge]
            self.edgelist[index], self.edgelist[maxedge] = self.edgelist[maxedge], self.edgelist[index]
            self.edgedict[lastedge] = [i if i != maxedge else index for i in self.edgedict[lastedge]]
            del self.edgelist[-1]
        del self.edgedict[edge]
    def choice(self):
        return random.choice(self.edgelist)
</code></pre>
<p>(You could, of course, change the replace-list-with-list-comprehension line with a three-liner find-and-update-in-place, but that's still linear in the number of dups.)</p>
<p>Obviously, if you plan to use this for real, you may want to beef up the class a bit. You can make it look like a <code>list</code> of edges, a <code>set</code> of <code>tuple</code>s of multiple copies of each edge, a <code>Counter</code>, etc., by implementing a few methods and letting the appropriate <a href="http://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow"><code>collections.abc.Foo</code></a>/<a href="http://docs.python.org/2/library/collections.html#collections-abstract-base-classes" rel="nofollow"><code>collections.Foo</code></a> fill in the rest.</p>
<hr/>
<p>So, which is better? Well, in your sample case, the average dup count is half the size of the list, and the maximum is 2/3rds the size. If that were true for your real data, the tree would be much, much better, because <code>log N</code> will obviously blow away <code>(N/2)**2</code>. On the other hand, if dups were rare, senderle's solution would obviously be better, because <code>W**2</code> is still 1 if <code>W</code> is 1. </p>
<p>Of course for a 3-element sample, constant overhead and multipliers are going to dominate everything. But presumably your real collection isn't that tiny. (If it is, just use a <code>list</code>...)</p>
<p>If you don't know how to characterize your real data, write both implementations and time them with various realistic inputs.</p>
</div>
<span class="comment-copy">Is <code>l1</code> a list? What is <code>l1.elements()</code>?</span>
<span class="comment-copy"><code>del l1[(1, 2)]</code> gives me a <code>list indices must be integers, not tuple</code> error</span>
<span class="comment-copy"><code>l1</code> is a list; perhaps you have reversed <code>l1</code> and <code>l2</code> in your descriptions?</span>
<span class="comment-copy">As far as I am aware, there is no built-in data structure that will do this for you. However, you can use Abstract Base Classes to create a dict-alike with the additional ability to select a random item. See <a href="http://stackoverflow.com/q/12587352/577088">this similar question</a> for more details.</span>
<span class="comment-copy">@abarnert, you can definitely get constant time random selection -- in just the way <code>l2</code> achieves it. You simply insert weighted edges into a list multiple times. Then you maintain a dictionary of lists of indices into the list where the key is present. To remove an item, pop an item from the end of the list and put it where the item to remove is; then update the dictionary. It's true that removal will then be linear in the maximum <i>weight</i> because you'd have to scan the list of indices for the one to change. But it's close to what the OP requested.</span>
<span class="comment-copy">ok, so at a high level, my edgedict is actually keeping track of the list of indices that particular edge occupies within edgelist. Those indices are then used when I need to remove an edge so that I don't have to scan the entire list. Or exactly the way senderle said it. And if instead of deleting an edge I wanted to change a node in it (e.g. I'm merging nodes and need to redirect edges accordingly), the dict-of-indices still allows me to do that in linear-on-weights time. Do I have that right?</span>
<span class="comment-copy">@MikeRand: Again, it's quadratic-on-weights, not linear-on-weights. But otherwise, yes. Think about it this way: You can always simulate a change with a delete and an add. If delete is quadratic-on-weight, and add is constant, then change has to be quadratic-on-weight at worst, right?</span>
<span class="comment-copy">good point about change-as-add+delete. Thanks.</span>
