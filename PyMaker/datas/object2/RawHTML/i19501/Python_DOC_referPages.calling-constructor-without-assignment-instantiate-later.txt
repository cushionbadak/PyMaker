<div class="post-text" itemprop="text">
<p>Let's say I have this code:</p>
<p>models.py :</p>
<pre><code>class Square:
  def __init__(self, name, value):
    self._name = name
    self._value = value
</code></pre>
<p>mymodule.py :</p>
<pre><code>from models import Square
Square('hello', 'there')
</code></pre>
<p>main.py</p>
<pre><code>m = __import__('mymodule')
for i in dir(m):
  if i == 'Square':
     models.append(getattr(m, i))
</code></pre>
<p>My question is: how do I instantiate the Square I appended (with the arguments I gave in mymodule.py, of course)?</p>
<p>The idea is to instantiate the Square later.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You have a flaw in your <code>mymodule.py</code> file; you never <em>store the instance</em>. Store it in a variable:</p>
<pre><code>somevariable = Square('hello', 'there')
</code></pre>
<p>You cannot just call the constructor and let it dangle.</p>
<p>Looping over the attributes of <code>mymodule</code> looking for something named <code>Square</code> is not going to get what you want, you'll find the class reference, not the instance.</p>
<p>Perhaps you should be looking for objects of the <code>Square</code> type instead:</p>
<pre><code>from models import Square

for value in vars(m).itervalues():
    if isinstance(value, Square):
         models.append(value)
</code></pre>
<p>If you want to avoid having to import the <code>Square</code> class, you'd have to test for the type name instead, which is more fragile:</p>
<pre><code>for value in vars(m).itervalues():
    if getattr(type(value), '__name__', None) == 'Square':
         models.append(value)
</code></pre>
<p>If you want to really postpone construction, instead construct it later with a set of pre-set values, use <a href="http://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial()</code></a>:</p>
<pre><code>from models import Square
from functools import partial

somevariable = partial(Square, 'hello', 'there')
</code></pre>
<p>If you now import <code>somevariable</code> and <em>call</em> it, the partial will apply the arguments already passed in and create the instance:</p>
<pre><code>instance = somevariable()  # calls Square('hello', 'there')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually you <em>are</em> instantiating it in mymodule.py, but it gets discarded. To stop that you need to store the <code>Square</code> created there in something with a name, otherwise it will be garbage-collected since nothing refers to it. Here's what I mean:</p>
<p>mymodule.py :</p>
<pre><code>from models import Square
a_square = Square('hello', 'there') # name it
</code></pre>
<p>Then you can access it directly and more quickly using that name in main.py like this:</p>
<p>main.py</p>
<pre><code>models = []
mod = __import__('mymodule')
models.append(vars(mod)['a_square'])  # access it by name
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>"The idea is to instantiate the Square later."</strong></p>
<p>You can do that by storing the callable and its arguments.</p>
<pre><code>import models
# save as (callable, args, keywords). This does not create a Square
my_model = (model.Squares, ('hello', 'there'), {})
# sometime later, create the square
my_square = my_model[0](*my_model[1], **my_model[2])
</code></pre>
<p>Or if you want to get super fancy and generate a lot of models, you can make a list:</p>
<p>models.py:</p>
<pre><code>class Square(object):
  def __init__(self, name, value):
    self._name = name
    self._value = value

class Round(object):
  def __init__(self, name, value, otherstuff=None):
    self._name = name
    self._value = value
    self._otherstuff = otherstuff
</code></pre>
<p>mymodule.py:</p>
<pre><code>import models
my_models = (
  (models.Square, ('hello', 'there'), {}),
  (models.Round, ('goodbye', 'there'), {'otherstuff':'stuff'})
)
</code></pre>
<p>main.py</p>
<pre><code>m = __import__('mymodule')
models = [model[0](*model[1], **model[2]) for model in m.my_models]
</code></pre>
</div>
<span class="comment-copy">Where did <code>models</code> in main.py come from?</span>
<span class="comment-copy">@martineau Just some python list.</span>
<span class="comment-copy">OK, it was confusing because of the <code>from models...</code> you have in mymodule.py and there was no definition for it anywhere in your main.py.</span>
<span class="comment-copy">Wouldn't that just reference the class though? I would be interested in instantiating it with the arguments I gave initially.</span>
<span class="comment-copy">Where do name and value come from though? I want to use the 'hello' and 'there' that I passed in mymodule.py (that specific call).</span>
<span class="comment-copy">Sorry, I misread your question; rereading led to a <i>different</i> answer..</span>
<span class="comment-copy">Right, but that would instantiate the Square right there, which I don't want. I want to instantiate it later.</span>
<span class="comment-copy">Further expanded.</span>
