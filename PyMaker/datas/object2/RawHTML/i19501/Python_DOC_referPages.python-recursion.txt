<div class="post-text" itemprop="text">
<p>I have to generate all the possible combinations of letters that represents a number sequence in a telephone... for example: if the entry is '423', the output should be:</p>
<pre><code>GAD   GAE   GAF   GBD   GBE   GBF   GCD   GCE   GCF    
HAD   HAE   HAF   HBD   HBE   HBF   HCD   HCE   HCF   
IAD   IAE   IAF   IBD   IBE   IBF   ICD   ICE   ICF
</code></pre>
<p>I must use recursion to solve this... I started using a dictionary like this:</p>
<pre><code>dic = {'2' : 'ABC', '3' : 'DEF', '4' : 'GHI', '5' : 'JKL', '6' : 'MNO', '7' : 'PQRS',     '8' : 'TUV', '9' : 'WXYZ'}
</code></pre>
<p>But I don't know how can I use a recursion here... Could someone help?</p>
<p>I thought something like this to start with:</p>
<pre><code>def telephoneSequence(str):
    for i in range (len(str)):
        return dic[str[i]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you're looking for <a href="http://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a>:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list(itertools.product('GHI','ABC','DEF'))
[('G', 'A', 'D'), ('G', 'A', 'E'), ('G', 'A', 'F'), ('G', 'B', 'D'), ('G', 'B', 'E'), ('G', 'B', 'F'), ('G', 'C', 'D'), ('G', 'C', 'E'), ('G', 'C', 'F'), ('H', 'A', 'D'), ('H', 'A', 'E'), ('H', 'A', 'F'), ('H', 'B', 'D'), ('H', 'B', 'E'), ('H', 'B', 'F'), ('H', 'C', 'D'), ('H', 'C', 'E'), ('H', 'C', 'F'), ('I', 'A', 'D'), ('I', 'A', 'E'), ('I', 'A', 'F'), ('I', 'B', 'D'), ('I', 'B', 'E'), ('I', 'B', 'F'), ('I', 'C', 'D'), ('I', 'C', 'E'), ('I', 'C', 'F')]
</code></pre>
<p>This gives you a bunch of tuples, but you can <code>''.join</code> them easily.</p>
<pre><code>&gt;&gt;&gt; list(''.join(p) for p in itertools.product('GHI','ABC','DEF'))
['GAD', 'GAE', 'GAF', 'GBD', 'GBE', 'GBF', 'GCD', 'GCE', 'GCF', 'HAD', 'HAE', 'HAF', 'HBD', 'HBE', 'HBF', 'HCD', 'HCE', 'HCF', 'IAD', 'IAE', 'IAF', 'IBD', 'IBE', 'IBF', 'ICD', 'ICE', 'ICF']
</code></pre>
<p>Of course, this isn't recursive and won't help you out if you have other constraining forces (a professor perhaps?).  I leave this answer to demonstrate how powerful the python standard library is and to show that recursion really isn't the best tool for this sort of problem (at least not in python).</p>
</div>
<div class="post-text" itemprop="text">
<p>If you do not want to use itertools.product and implement it recursively, you can do something like:</p>
<pre><code>d = { 
    '0': "0",
    '1': "1",
    '2': "ABC",
    '3': "DEF",
    '4': "GHI",
    '5': "JKL",
    '6': "MNO",
    '7': "PQRS",
    '8': "TUV",
    '9': "WXYZ",
}

def permutatePhoneNum(number):
    result = []
    if len(number) == 1:
        return [i for i in d[number]]
    restPerm = permutatePhoneNum(number[1:])
    for chr in d[number[0]]:
        for rest in restPerm:
            result.append(chr + rest)
    return result
</code></pre>
<p>Then, you can use it as following:</p>
<pre><code>&gt;&gt;&gt; permutatePhoneNum("423")
['GAD', 'GAE', 'GAF', 'GBD', 'GBE', 'GBF', 'GCD', 'GCE', 'GCF', 'HAD', 'HAE', 
'HAF', 'HBD', 'HBE', 'HBF', 'HCD', 'HCE', 'HCF', 'IAD', 'IAE', 'IAF', 'IBD', 
'IBE', 'IBF', 'ICD', 'ICE', 'ICF']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Doing being limited to only using recursion was trickier to get right than I expected -- being somewhat out of practice since Python has several useful built-ins that make doing such things fairly easy. But, FWIW, here it is:</p>
<pre><code>KEYPAD = {
    '0': '0',   '1': '1',   '2': 'ABC',  '3': 'DEF', '4': 'GHI',
    '5': 'JKL', '6': 'MNO', '7': 'PQRS', '8': 'TUV', '9': 'WXYZ',
}

def teleseq(digits, letters=[], result=None):
    if result is None: result = []
    if len(digits) == 1:
        result.extend(''.join(letters+[letter]) for letter in KEYPAD[digits[0]])
    else:
        for letter in KEYPAD[digits[0]]:
            teleseq(digits[1:], letters+[letter], result)
    return result

print sorted(teleseq('432'))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>['GDA', 'GDB', 'GDC', 'GEA', 'GEB', 'GEC', 'GFA', 'GFB', 'GFC', 'HDA', 'HDB',
 'HDC', 'HEA', 'HEB', 'HEC', 'HFA', 'HFB', 'HFC', 'IDA', 'IDB', 'IDC', 'IEA',
 'IEB', 'IEC', 'IFA', 'IFB', 'IFC']
</code></pre>
</div>
<span class="comment-copy">Start with generating entries of length 1. Than ask yourself how can an entry of length 1 be turned to a legal entry of length 2.</span>
<span class="comment-copy">Welcome to Stack Overflow! It looks like you want us to write some code for you. While many users are willing to produce code for a coder in distress, they usually only help when the poster has already tried to solve the problem on their own. A good way to demonstrate this effort is to include the code you've written so far, example input (if there is any), the expected output, and the output you actually get (console output, stack traces, compiler errors - whatever is applicable). The more detail you provide, the more answers you are likely to receive.</span>
<span class="comment-copy">@user2083363, don't post code in comments. Edit your question and add the code to it.</span>
<span class="comment-copy">One general approach is: to generate all the outputs for the number <code>423</code> (e.g.: <code>letters(number='423')</code>, you need to go through all the possible letters for <code>4</code> (<code>for char in dic[4]:</code>), and for each of these letters append all the outputs for the number <code>23</code> (<code>letters(number='23')</code>) As you can see, a part of the solution description ("all the outputs for the numberâ€¦") reads the same as the whole problem, that's where you recurse. (Until you no longer need to generate the "tail" of the number because the number only has one digit.)</span>
<span class="comment-copy">That would be the sensitive solution, but OP says he must use recursion...</span>
<span class="comment-copy">Oh, right.  I missed the recursive part ... Well, maybe this will be useful for someone without that restriction.</span>
<span class="comment-copy">or to check his result is correct.</span>
<span class="comment-copy">You haven't answered the OP's question.</span>
<span class="comment-copy">@martineau -- I think a "don't do it that way" is a reasonable answer to a question ... Recursion in python has lots of issues and this is nothing more than a nested loop.  <code>itertools.product</code> is the tool that <i>should</i> be used to solve this problem in any production code which is why I leave it as an answer in hopes that future visitors don't stumble across this and think that recursion is the right way to do this (even if it is what OP asked for).</span>
