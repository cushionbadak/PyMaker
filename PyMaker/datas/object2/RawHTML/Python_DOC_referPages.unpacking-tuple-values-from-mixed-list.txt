<div class="post-text" itemprop="text">
<p>Imagine I have the following list</p>
<pre><code>lst = [("key1", "2"), ("key3", "4"), "somestring", 12345]
</code></pre>
<p>And I'd like to build a dict out of it (using a dictcomp, that is):</p>
<pre><code>d = {key: value 
     for item in lst 
     for key, value in [item]
     if isinstance(item, tuple)}
</code></pre>
<p>This will blow up with a <code>ValueError</code> (too many values to unpack).<br/>
When is the <code>if</code> clause being evaluated (which is crucial for the unpacking, of course) ?<br/>
Note: I know I could use a <code>filter/lambda</code> before but wanted to know if it's possible in one step.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think that is what you are looking for :</p>
<pre><code>&gt;&gt;&gt; lst = [("key1", "2"), ("key3", "4"), "somestring", 12345]
&gt;&gt;&gt; dict([i for i in lst if type(i) is tuple])
{'key1': '2', 'key3': '4'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use the following dictcomp:</p>
<pre><code>{i[0]: i[1] for i in lst if isinstance(i, tuple)}
# {'key1': '2', 'key3': '4'}
</code></pre>
</div>
<span class="comment-copy">Move the if up one level</span>
<span class="comment-copy"><code>for key, value in item</code>, do not put <code>item</code> in square bracket!</span>
<span class="comment-copy">Wouldn't the <code>filter</code> be cleaner, e.g.: <code>dict(filter(lambda item: isinstance(item, tuple), lst))</code>, or just a generator function <code>dict(item for item in lst if isinstance(item, tuple))</code></span>
<span class="comment-copy">@adrtam that won't work. But making a pointless list is pretty ugly</span>
<span class="comment-copy">@juanpa.arrivillaga: Put it as an answer, it worked.</span>
<span class="comment-copy">It's idiomatic to use <code>isinstance(i, tuple)</code> instead of <code>type(i)</code>.</span>
