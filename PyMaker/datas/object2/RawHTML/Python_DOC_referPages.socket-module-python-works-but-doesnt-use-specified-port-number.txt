<div class="post-text" itemprop="text">
<p>I'm using the <code>socket</code> module from Python 3.7 (shouldn't matter, as I tried activating a different Python version from different venv's). </p>
<p>The problem is that I've created a TCP connection listening at port 65432, an arbitrary number that I selected for this simple demo. </p>
<p><code>server.py</code> looks like the following: </p>
<pre><code>import socket

HOST = '127.0.0.1' # Standard loopback interface address (localhost)
PORT = 65432 # Non-privileged ports are &gt; 1024

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen() 
    conn, addr = s.accept() 
    with conn:
        print('Connected by', addr)
        while True:
            data = conn.recv(1024)
            if not data:
                break
            conn.sendall(data)
</code></pre>
<p><code>client.py</code> is relatively straightforward as it makes a connection with 127.0.0.1:65432. </p>
<pre><code>import socket

HOST = '127.0.0.1' # The server's hostname or IP address
PORT = 65432 # Port used by the server

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    # Send its message and then read the server's reply and prints it
    s.sendall(b'Hello, world')
    data = s.recv(1024)

print('Received', repr(data))
</code></pre>
<p>Executing <code>server.py</code> to open the port 65432 for listening (in first console) and then executing <code>client.py</code> to send a simple 'hello world' message (in a second console). This is what got printed to the first console:</p>
<p><code>Connected by ('127.0.0.1', 56051)</code></p>
<p>So far so good. Port 56051 connecting to port 65432, right? No. </p>
<p>I execute <code>netstat -am</code> (command tool utility to see state of sockets on the host machine) and found this:</p>
<pre><code>Active Internet connections (including servers)
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)    
tcp4       0      0  127.0.0.1.51495        *.*                    LISTEN 
</code></pre>
<p><strong>Instead of 127.0.0.1.65432 as local address</strong>, it is using port 51495 instead.</p>
<p>Doing another verification check, this time firing off <code>lsof -i -n</code>:</p>
<pre><code>COMMAND     PID     FD   TYPE             DEVICE SIZE/OFF NODE NAME
Code\x20H 51214    37u  IPv4 0x1af15eb424ba89f3      0t0  TCP 127.0.0.1:51495 (LISTEN)
</code></pre>
<p>Both verifications confirmed that port 51495 is being used instead of 65432 as specified in my <code>server.py</code> and <code>client.py</code> scripts. Any leads or tips? Many thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>65432 is the port number of your server socket, not your client socket. As the client end is not attached with any specific port number, it will be dynamically allocated with port number, every time you run the client code.
As far as I understood, you mentioned - </p>
<pre><code>Connected by ('127.0.0.1', 56051)
</code></pre>
<p>is shown on the first console which is your server console. so this port number is port number of client socket. not the server socket.</p>
<p>In the server code, you are using, s.accept(), this function returns the connection temporary id and the address of the client which made the request. same thing you are trying to print in the code.</p>
</div>
<div class="post-text" itemprop="text">
<p>As @ottomeister pointed out, the process name was the first giveaway. The process name should have been Python but it showed VS Code instead, which is indicative that the port 51495 is opened by the VS Code process and has nothing to do with our socket module code.</p>
<p>The way the context manager was setup means that the connection will be closed the moment the last line (in this case, <code>socket.sendall()</code>) is executed. So the server socket is not active anymore. </p>
<p>I run <code>netstat</code> after the client socket has connected, by this point the server port is closed. </p>
<p>When I monitor the ports status while the server port is open (before the client socket connects with it) then sure enough 65432 is what appeared. This is confirmed in <code>netstat</code>, <code>lsof</code> and also <code>nmap</code>. A simple print statement after the socket connection is successful will also confirmed that the server port is in fact using the specified port number, which is 65432. </p>
<p>Sorry for the inconvenience, and again much appreciation to Ottomeister for first pointing this out. </p>
</div>
<span class="comment-copy">Your program behaves as expected for me.  How do you know that those <code>netstat</code> and <code>lsof</code> results refer to your Python program?  I see that that process name in the <code>lsof</code> output is not <code>python</code> but <code>Code\x20H</code>.  Note that your client will break the connection immediately after receiving data, and that will cause the server to close its listening and connected sockets, so you need to be looking for the listening socket (<code>netstat -an | grep 65432</code>) after the server starts and before the client runs.  Have the client sleep or loop to give enough time to see the connected sockets.</span>
<span class="comment-copy">@ottomeister you are, of course, correct. Due to the way the connection was set up (context manager) the connection was closed immediately after the .sendall() call so it wasn't showing up. If I keep the port in "listening" status it does show up - silly me as a simple print statement in the function call would have given this away. I'm thinking if you posted this as answer I could mark as correct; otherwise I'll close the issue. Thanks for the help!</span>
<span class="comment-copy">Yes 65432 is the port of my server socket. That was clear. However, the expected behaviour is that 127.0.0.1.65432 would be the local address in the output of netstat and lsof. Not 51495</span>
