<div class="post-text" itemprop="text">
<p>I am trying to understand the package and module name shadowing rules in python and stumbled across a case where I do not understand why the results that I see make any sense. This cases happens for python 2 (with <code>from future import absolute_imports</code>) and python 3.</p>
<p>Assuming I have the following folder structure:</p>
<pre><code>├── mypackage
│   ├── argparse.py
│   └── __init__.py
└── script.py
</code></pre>
<p><code>mypackage</code> is my custom top-level package, where I have a module shadowing the standard <code>argparse</code> module. Inside my script I execute the following code:</p>
<pre><code>import argparse
print(argparse)
from mypackage.argparse import foo
print(argparse)
</code></pre>
<p>The results are the ones I expect:</p>
<pre><code>&lt;module 'argparse' from '/usr/lib/python3.5/argparse.py'&gt;
&lt;module 'argparse' from '/usr/lib/python3.5/argparse.py'&gt;
</code></pre>
<p>However, if I change my script to execute a function from my package and execute the same import and print statements in the <code>__init__.py</code> of my package, i.e.:</p>
<p>script:</p>
<pre><code>from mypackage import main
main()
</code></pre>
<p><code>__init__.py</code>:</p>
<pre><code>import argparse
print(argparse)
from mypackage.argparse import foo
print(argparse)

def main():
    pass
</code></pre>
<p>As a result I see:</p>
<pre><code>&lt;module 'argparse' from '/usr/lib/python3.5/argparse.py'&gt;
&lt;module 'mypackage.argparse' from '/tmp/test/src/mypackage/argparse.py'&gt;
</code></pre>
<p>Why does in this case (and not in the other one) the <code>from X import Y</code> statement override the previous global import of <code>argparse</code> to the local module?</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider how you access submodules, you would write <code>mypackage.argparse</code> to access the submodule of <code>mypackage</code>. </p>
<p>Now consider how attribute lookup for modules work, it searches for the attribute in the modules global namespace.</p>
<p>Putting these two together, the only way to access submodules is by adding them to the packages global namespace, this is the intended behaviour.</p>
</div>
<span class="comment-copy">Is this somehow documented somewhere? I have the feeling this make 50% of the benefits gained with absolute import useless.</span>
<span class="comment-copy">The <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer">documentation on packages</a> is seriously lacking in explaining how the <code>__init__.py</code> woks in many regards. :/</span>
<span class="comment-copy">Ok, thanks. So I have no chance to deal with this apart from arranging my imports in an unusual way just to ensure that argparse is imported after the from X.... statement?</span>
<span class="comment-copy">either way if you <code>import argparse</code> from the top level of your package then using <code>mypackage.argparse</code> is extremely ambiguous, I'd recommend importing <code>as</code> a different name (maybe <code>as _std_argparse</code>)</span>
<span class="comment-copy">well, no because then nothing else can use <b>your</b> <code>argparse</code> submodule...</span>
