<div class="post-text" itemprop="text">
<p><strong>Short version:</strong> If we use <code>PyObject_CallFunctionObjArgs</code> with <code>PyType_Type</code> in Python 3 as a replacement for <code>PyClass_New</code>, then the dictionary has to be populated before the creation of the class. However, <code>PyMethod_New</code> requires the class to be known before the creation of the method. How can we add a method to the dictionary of a new class in Python 3?</p>
<p>In Python 2, I was used to define new classes with <code>PyClass_New</code>. Here is a minimal working example (for Python 2), where I define a new class <code>example.MyClass</code> with a method <code>hello</code>:</p>
<pre><code>#include &lt;Python.h&gt;
#include &lt;stdio.h&gt;

PyObject *
callback(PyObject *obj, PyObject *args)
{
    printf("Hello world!\n");
    return Py_None;
}

int
main(int argc, char *argv[])
{
    Py_SetProgramName(argv[0]);
    Py_Initialize();
    PyObject *module = PyModule_New("example");
    PyDict_SetItemString(PyImport_GetModuleDict(), "example", module);
    PyObject *dict = PyDict_New();
    PyObject *classname = PyBytes_FromString("MyClass");
    PyObject *class = PyClass_New(PyTuple_New(0), dict, classname);
    PyMethodDef method_def;
    method_def.ml_name = "method_closure";
    method_def.ml_meth = callback;
    method_def.ml_flags = 1;
    method_def.ml_doc = "Method closure";
    PyObject *closure = PyCFunction_New(&amp;method_def, NULL);
    PyObject *method = PyMethod_New(closure, NULL, class);
    PyDict_SetItemString(dict, "hello", method);
    PyModule_AddObject(module, "MyClass", class);
    PyRun_SimpleString("from example import MyClass\nMyClass().hello()");
    Py_Finalize();
    return 0;
}
</code></pre>
<p><code>PyClass_New</code> was removed from the Python 3 C API. I read that <code>PyObject_CallFunctionObjArgs</code> can be used as replacement, for example in the answer of the following question: <a href="https://stackoverflow.com/questions/29301824/what-is-the-pyclass-new-equivalent-in-python-3">What is the PyClass_New equivalent in Python 3?</a></p>
<p>However, it appears that the dictionary that <code>PyObject_CallFunctionObjArgs</code> takes for last argument is copied during the creation of the new class: indeed, the fields that are set to <code>dict</code> before calling <code>PyObject_CallFunctionObjArgs</code> are available in the instances of the class, but not the fields that are set after the call.
That prevents us from using <code>PyMethod_New</code> as above because the class has to be known before creating the method, but the method has to be added to <code>dict</code> before creating the class.</p>
<p>This dependency loop can be solved by using <code>PyInstanceMethod_new</code>, since the latter does not take a reference for a class. I obtained thus the following working example (for Python 3, I only give the code for <code>main</code>, the preambule and the callback is the same as in the first example).</p>
<pre><code>int
main(int argc, char *argv[])
{
    wchar_t progname[FILENAME_MAX + 1];
    mbstowcs(progname, argv[0], strlen(argv[0]) + 1);
    Py_SetProgramName(progname);
    Py_Initialize();
    PyObject *module = PyModule_New("example");
    PyDict_SetItemString(PyImport_GetModuleDict(), "example", module);
    PyObject *dict = PyDict_New();
    PyMethodDef method_def;
    method_def.ml_name = "method_closure";
    method_def.ml_meth = callback;
    method_def.ml_flags = 1;
    method_def.ml_doc = "Method closure";
    PyObject *closure = PyCFunction_New(&amp;method_def, NULL);
    PyObject *method = PyInstanceMethod_New(closure);
    PyDict_SetItemString(dict, "hello", method);
    PyObject *classname = PyUnicode_FromString("MyClass");
    PyObject *class = PyObject_CallFunctionObjArgs(
        (PyObject *) &amp;PyType_Type, classname, PyTuple_New(0), dict);
    PyModule_AddObject(module, "MyClass", class);
    PyRun_SimpleString("from example import MyClass\nMyClass().hello()");
    Py_Finalize();
    return 0;
}
</code></pre>
<p>However, I wonder whether I could achieve to write a solution closer to the Python 2 version, using <code>PyMethod_new</code>: it should be possible to dynamically change the class after its creation for adding the new method, but I don't figure out how to do that.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're not actually using the C API for creating types.</p>
<p>The normal way to define a type through the C API is by defining your object's layout as a C struct and declaring a global <code>PyTypeObject</code> with <code>tp_*</code> fields defining its properties. This is documented under <a href="https://docs.python.org/3/extending/newtypes.html" rel="nofollow">Extending and Embedding the Python Interpreter: Defining New Types</a>. <code>PyObject_CallFunctionObjArgs</code> is not involved.</p>
<p>Using <code>PyObject_CallFunctionObjArgs</code> with <code>PyType_Type</code> would be analogous to creating a type by calling <code>type</code> manually in Python. In this case, the type's dict should not contain method objects. Just like if you were doing it in Python, the dict should contain Python function objects, and method objects will be created dynamically on attribute access.</p>
</div>
