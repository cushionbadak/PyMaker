<div class="post-text" itemprop="text">
<p>Consider the following code snippet. It flags a syntax error at the break statement.</p>
<pre><code>digits = list(str(102))
dummy = list(str(102/2))
for j in digits:
    dummy.remove(j) if j in dummy else break
</code></pre>
<p>How do I fix this?(I want to still use the ternary operator)</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edit:</strong></p>
<p><em>(see my conversation with <a href="https://stackoverflow.com/users/1672429/stefan-pochmann">Stefan Pochmann</a> in the comments)</em></p>
<p>Ternary operator is not for <em>only</em> statement, but rather for assignment or for expression (and <code>break</code> is an <em>only</em> statement):</p>
<pre><code>a = 5 if cond else 3 #OK
do() if cond else dont() #also OK
do() if cond else break #not OK
</code></pre>
<p>use normal <code>if-else</code> statement to do statements:</p>
<pre><code>if cond:
    do()
else:
    break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You cannot use break in Your loop logic can be re written using <em>itertools.takewhile</em> if you want a more succinct solution</p>
<pre><code>digits = list(str(102))
dummy = list(str(102/2))

from itertools import takewhile

for d in takewhile(dummy.__contains__, digits):
    dummy.remove(d)
</code></pre>
<p>You can also remove the need for the else using a for loop by reversing your logic, check if j is not in dummy breaking when that is True:</p>
<pre><code>for j in digits:
    if j not in dummy:
        break
    dummy.remove(j)
</code></pre>
<p>Also if you want to remove all occurrences of any of the initial elements from digits that are in dummy, remove won't do that for any repeating elements but using a list comp after creating a set of elements to remove will:</p>
<pre><code>digits = str(102)
dummy = list(str(102/2))
st = set(takewhile(dummy.__contains__, digits))
dummy[:] = [d for d in dummy if d not in st]

print(dummy)
</code></pre>
<p>You can also iterate over a string so no need to call list on digits unless you plan on doing some list operations with it after. </p>
</div>
<span class="comment-copy"><code>break</code> is a statement, and as such it <i>can't</i> be used inside a ternary. Sorry.</span>
<span class="comment-copy">I don't think you can use ternary operator for that case...</span>
<span class="comment-copy">To remove an element from a list you probably need to be careful (safer is to do the reverse way). check this out: <a href="http://stackoverflow.com/questions/35618307/how-to-transform-string-into-dict/35618686#35618686" title="how to transform string into dict">stackoverflow.com/questions/35618307/â€¦</a> see also Padraic's answer</span>
<span class="comment-copy">@MarkRansom That's wrong reasoning, as expressions are statements and they can be used inside a ternary.</span>
<span class="comment-copy">@StefanPochmann:  Expressions are statements - but not all statements are expressions (break being an example), and the ternary operator requires expressions (not statements).</span>
<span class="comment-copy">Your examples aren't quite the same, as they <i>are</i> valid syntax</span>
<span class="comment-copy">@TheChetan: no, there isn't. Python focuses on readability, not conciseness.</span>
<span class="comment-copy">@TheChetan hmm... depends on the case, you could in fact make for loop and store the functions in <code>list</code> first for instance</span>
<span class="comment-copy">@sparkandshine ah I get it... that is because <code>exit</code> is a function. If you use tool like <code>PyCharm</code> you can see that.. it is like function returning nothing</span>
<span class="comment-copy">@Ian Ah, ok. The problem is that they're <i>only</i> statements, not expressions, and you <a href="https://docs.python.org/3/reference/expressions.html#conditional-expressions" rel="nofollow noreferrer">need an expression</a> there.</span>
<span class="comment-copy">Ugh, it's awkward to avoid the dunder method here; you can use <code>functools.partial</code> and <code>operator.contains</code>, e.g. <code>in_dummy = partial(contains, dummy)</code>. This seems like a lot of work to avoid the underscore method though, and no real benefits. A lambda could be used alternatively, e.g. <code>lambda e: e in dummy</code>.</span>
<span class="comment-copy">@JaredGoguen, yep,  I don't mind using <code>__contains__</code> in a case like this, definitely better than a lambda, might be interesting to time the comparisons.</span>
