<div class="post-text" itemprop="text">
<p>So I've seen <a href="https://www.google.com/search?q=django+invalid+keyword+argument+for+this+function&amp;oq=django+invalid+ke&amp;aqs=chrome.0.0j69i57j0l4.7827j0j7&amp;sourceid=chrome&amp;ie=UTF-8#" rel="nofollow">similar questions</a> about this error, and they all seem to be related to use cases where there are ManyToMany relationships. However, I'm getting this issue even though my model doesn't have M2M relationships, so I wanted to ask and see why this was happening.</p>
<p>Here is my model:</p>
<pre><code>class Course(models.Model):
    name = models.CharField(max_length=64)
    credit = models.IntegerField
    notes = models.CharField(max_length=128)
    resources = models.TextField
    description = models.TextField
    topic = models.CharField(max_length=128)
</code></pre>
<p>Whenever I create a new instance of this model, I get the <code>TypeError</code> for the <code>credit</code>, <code>resources</code>, and <code>description</code> fields.</p>
<p>I instantiate it like so:</p>
<pre><code>c = Course(
    name='some name',
    credit='8',
    notes='N/A',
    resources='no resources',
    description='N/A',
    topic='some topic'
)
</code></pre>
<p><em>However</em> if I change the affected fields to <code>models.IntegerField(max_length=8)</code> and <code>models.TextField(max_length=8)</code>, then the error goes away.</p>
<p>Why does this happen? I was under the impression that the <code>max_length</code> parameter was optional for <code>TextField</code>; I don't even know what it means in the context of an <code>IntegerField</code>. Can someone explain this behavior, and/or what I'm doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are defining the <strong>fields</strong> as their classes' references, and not as an instance of those classes. It should be</p>
<pre><code>class Course(models.Model):
    name = models.CharField(max_length=64)
    credit = models.IntegerField()
    notes = models.CharField(max_length=128)
    resources = models.TextField()
    description = models.TextField()
    topic = models.CharField(max_length=128)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If anyone's interested I think what happens in the <code>django.db.models.ModelBase</code> metaclass is fairly interesting. Overly verbose for answering this question? Almost certainly, I was originally not going to post but perhaps it will help (assuming what I have is correct of course). I've always found it more useful to understand why something works rather than why it doesn't. I'm not going to attempt to try to explain every little part that would be a monumental task, and am sticking to what's (hopefully) directly relevant.   ¯\_(ツ)_/¯</p>
<p>(Also, it's likely I made a few errors in places, I don't dive into source code very often, please do <em>feel free to correct</em>)</p>
<p>Let's create a random model:</p>
<pre><code>class RandomModel(models.Model):

     field1 = models.TextField()
</code></pre>
<p>Let's see what happens behind the scenes for something this deceptively simple. For the more complicated stuff, it's turtles all the way down.</p>
<p>We have <code>models.Model</code> as the base class, but it has <code>ModelBase</code> as it's metaclass. And, <code>ModelBase</code> has a <code>__new__</code> method:</p>
<p>The source for the <code>__new__</code> method of this metaclass is fairly long. Here's a <a href="https://docs.djangoproject.com/en/1.9/_modules/django/db/models/base/" rel="nofollow noreferrer">link</a> to the contents of the file in <code>django\db\models\base.py</code>.</p>
<p>There's two other classes we'll be concerned with <code>django/db/models/options.py -&gt; class Option</code> and <code>django/db/models/fields/__init__.py -&gt; class Field</code>.</p>
<p>Were you to print <code>dir(field1)</code> or if you were to simply look inside <code>__init__.py</code> in <code>/fields</code> you would see the <code>Field</code> class and a method named <code>contribute_to_class</code>.</p>
<p>Remember the <code>contribute_to_class</code> method, more on this later.</p>
<p>Let's break down the relevant components of the <code>__new__</code> method. If you've ever seen a metaclass then you should be familiar with the arguments to the new function.</p>
<p>If not then check this link out: <a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">What is a metaclass in Python</a></p>
<pre><code>class ModelBase(type):

    def __new__(..., attrs):

         ....
</code></pre>
<p><code>attrs</code> here is the dictionary that contains all methods, attributes, etc.</p>
<p>Stuff happens, then we have this line:</p>
<pre><code>new_class.add_to_class('_meta', Options(meta, app_label))
</code></pre>
<p>Now, what is add to class? It is this function:</p>
<pre><code>def add_to_class(cls, name, value):

    # We should call the contribute_to_class method only if it's bound
    if not inspect.isclass(value) and hasattr(value, 'contribute_to_class'):
        value.contribute_to_class(cls, name)
    else:
        setattr(cls, name, value)
</code></pre>
<p>We could stop right here, and I could have actually started with this function. This is the entire problem. You never <em>initialize</em> models.FieldName and thus it is not an instance that passes the condition <code>hasattr(value, 'contribute_to_class')</code>. Instead, the else statement is executed and it simply becomes a class attribute (which doesn't contribute). As the name suggests <code>hasattr</code> simply checks if the object has said attribute available (passed as a string to hasattr).</p>
<p>If you just did <code>print(field1)</code> with <code>field1 = models.TextField</code> you'd see that it was simply a reference to the class <code>django.db.models.fields.TextField</code>.</p>
<p>Getting back on track, let's keep going! What if it <em>does</em> pass this condition? Then, we have that <code>add_to_class</code> now calls <code>contribute_to_class</code> with the parameters <code>cls</code> and <code>name</code>.</p>
<p>But, what does <code>contribute_to_class</code> do?! </p>
<p>Here's the function <code>contribute_to_class</code>:</p>
<pre><code>def contribute_to_class(self, cls, name, virtual_only=False):

   self.set_attributes_from_name(name)
   self.model = cls
   if virtual_only:
       cls._meta.add_field(self, virtual=True)
   else:
       cls._meta.add_field(self)
    if self.choices:
        setattr(cls, 'get_%s_display' % self.name,
                curry(cls._get_FIELD_display, field=self))
</code></pre>
<p>Really, what we care about here is <code>cls._meta.add_field(self)</code>.</p>
<p>Now, we need to backtrack. At this point things are probably starting to get confusing, but hopefully all will be clear in a moment.</p>
<p>Recall the <code>add_to_class</code> line:</p>
<pre><code>new_class.add_to_class('_meta', Options(meta, app_label))
</code></pre>
<p>Depending upon how long you've been using Django at some point it is very likely you've used the <code>._meta</code> attribute more than likely like this <code>_meta.fields</code>.</p>
<p>Well, here it is!!</p>
<p>Now, recall (again) the <code>add_to_class</code> function the <code>Options</code> class instance has no method <code>contribute_to_class</code> and is thus added to the class as an <em>attribute</em> <code>_meta</code>.</p>
<p>I'm not going to paste the <code>contribute_to_class</code> function here. It's also a bit long-winded and is fairly well commented. You can find it <a href="https://docs.djangoproject.com/en/1.9/_modules/django/db/models/options/" rel="nofollow noreferrer">here</a> and it's about 1/4 of the way down. I'd recommend reading the comments and once you have the function should be more or less intuitive.</p>
<p>So, now there's this new attribute <code>_meta</code> (which is an Option class instance) that has the class method <code>add_field</code> available to it.</p>
<p>And, here's the <code>add_field</code> method:</p>
<pre><code> def add_field(self, field, virtual=False):
    # Insert the given field in the order in which it was created, using
    # the "creation_counter" attribute of the field.
    # Move many-to-many related fields from self.fields into
    # self.many_to_many.
    if virtual:
        self.virtual_fields.append(field)
    elif field.is_relation and field.many_to_many:
        self.local_many_to_many.insert(bisect(self.local_many_to_many, field), field)
    else:
        self.local_fields.insert(bisect(self.local_fields, field), field)
        self.setup_pk(field)
</code></pre>
<p>The comments are fairly self explanatory again. However, what might be confusing is the line <code>bisect(list, thing_in_list)</code>. Here, <code>bisect</code> is simply short for <a href="https://docs.python.org/3/library/bisect.html#bisect.bisect_right" rel="nofollow noreferrer">bisect.bisect_right</a> from the python module bisect. As the comments says the fields are inserted in the order in which they are created, which is a sorted order. Using bisect allows the list to retain sorted order while inserting, it locates the proper insertion index.</p>
<p>What's next in the <code>__new__</code> method of the <code>ModelBase</code> metaclass?</p>
<p>We have the following line:</p>
<pre><code> # Add all attributes to the class.
 for obj_name, obj in attrs.items():
      new_class.add_to_class(obj_name, obj)
</code></pre>
<p>Now, recall that <code>attrs</code> is the dict containing well everything. So, it's looping through the object names (keys) and the objects (values) of this dictionary. And, as discussed earlier looking for instances with the <code>contribute_to_class</code> method otherwise it is simply added as an attribute to the class instance (the new class to be created remember <code>__new__</code> is actually <em>creating</em> the class here). And, that process sort of repeats.</p>
<p>Then, the next two lines:</p>
<pre><code>    new_fields = chain(
        new_class._meta.local_fields,
        new_class._meta.local_many_to_many,
        new_class._meta.virtual_fields
    )
    field_names = {f.name for f in new_fields}
</code></pre>
<p>Here, <a href="http://ihttps://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer">itertools.chain</a> is flatting these lists into a single list and returns a chain object.</p>
<p>This chain object is then iterated over calling the attribute <code>name</code> from the <code>Field</code> class (remember the fields are actually instances of (subclasses) <code>Field</code>) into a <code>set</code> and a <code>set</code> is simply a collection of objects without duplicates.</p>
<p>More things happen, but I'm just going to end here as I think everything else is fairly redundant at this point for this example.</p>
</div>
<span class="comment-copy"><code>models.TextField</code> should be <code>models.TextField(**kwargs)</code> and models.IntegerField as well</span>
<span class="comment-copy">oh...duh. I'm still new to Django so that didn't occur to me.</span>
<span class="comment-copy">Took me a moment to find the link, but if you don't mind digging through some metaclass magic this may also be helpful <a href="https://docs.djangoproject.com/en/1.9/_modules/django/db/models/base/" rel="nofollow noreferrer">docs.djangoproject.com/en/1.9/_modules/django/db/models/base</a></span>
