<div class="post-text" itemprop="text">
<p>I want to keep track of objects of a certain type that are currently in use. For example: Keep track of all instances of a class or all classes that have been created by a metaclass.</p>
<p>It is easy to keep track of instances like this:</p>
<pre><code>class A():
    instances = []
    def __init__(self):
        self.instances.append(self)
</code></pre>
<p>But if an instance is not referenced anywhere outside of that list it will not be needed anymore and I do not want to process that instance in a potentially time consuming loop.</p>
<p>I tried to remove objects that are only referenced in the list using sys.getrefcount.</p>
<pre><code>for i in A.instances:
    if sys.getrefcount(i) &lt;=3: # in the list, in the loop and in getrefcount
        # collect and remove after the loop
</code></pre>
<p>The problem I have is that the reference count is very obscure.
Opening a new shell and creating a dummy class with no content returns 5 for</p>
<pre><code>sys.getrefcount(DummyClass)
</code></pre>
<p>Another idea is to copy the objects then deleting the list and checking which objects have been scheduled for garbage collecting and in the last step removing those objects. Something like:</p>
<pre><code>Copy = copy(A.instances)
del A.instances
A.instances = [i for i in Copy if not copy_of_i_is_in_GC(i)]
</code></pre>
<p>The objects don't have to be removed immediately when the reference count goes to 0. I just don't want to waste too much ressources on objects that are not used anymore.</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer is the same as Kevin's but I was working up an example implementation with weak references and am posting it here. Using weak references solves the problem where an object is referenced by the <code>self.instance</code> list, so it will never be deleted.</p>
<p>One of the things about creating a weak reference for an object is that you can include a callback when the object is deleted. There are issues such as the callback not happening when the program exits... but that may be what you want anyway.</p>
<pre><code>import threading
import weakref

class A(object):
    instances = []
    lock = threading.RLock()

    @classmethod
    def _cleanup_ref(cls, ref):
        print('cleanup') # debug
        with cls.lock:
            try:
                cls.instances.remove(ref)
            except ValueError:
                pass

    def __init__(self):
        with self.lock:
            self.instances.append(weakref.ref(self, self._cleanup_ref))

# test
test = [A() for _ in range(3)]
for i in range(3,-1,-1):
    assert len(A.instances) == i
    if test:
        test.pop()

print("see if 3 are removed at exit")
test = [A() for _ in range(3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The standard way to solve this problem is through <a href="https://docs.python.org/3/library/weakref.html">weak references</a>.  The basic idea is that you keep a list of weak references to objects instead of the objects themselves, and periodically prune the dead weak references from the list.</p>
<p>For dictionaries and sets, there are some more abstract types such as <code>weakref.WeakKeyDictionary()</code> which can be used when you want to put weak references in more complex places like the keys of a dictionary.  These types do not require manual pruning.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try the <code>gc.get_referrers(obj)</code>. <a href="https://docs.python.org/2/library/gc.html#gc.get_referrers" rel="nofollow">The <code>gc</code> module Documentation</a></p>
<pre><code>len(gc.get_referrers(my_obj))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to @Barmar for pointing out to use <em>weakref</em>. We can combine it with the <code>__del__</code> method to implement a self managing instance list of a class. Thus, the <code>class A</code> in OP's post can be extended as:</p>
<pre><code>from weakref import ref
class A():
    instances = []
    def __init__(self):
        self.instances.append(ref(self))

    @staticmethod
    def __del__():
      if A:
        A.instances = [i for i in A.instances if not i() is None]
</code></pre>
<p>Testing</p>
<pre><code>#python2.7
print dict((len(A.instances), A()) for i in range(5)).keys() # 0,1,2,3,4
print len(A.instances) # 0
</code></pre>
<p>The destructor <code>__del__</code> can be declared as a static method or a object-bound method like <code>def __del__(self):</code>, although it is not documented. The latter can stop the object from being destroyed by creating another reference to it. Here I use the static one because there is no need for another reference to the dieing object. The code above is tested in both Python 2.7 and 3.3.</p>
<p>The <code>weakref.ref</code> callback behaves similar to <code>__del__</code> except that it is bound to the "weakref" object. So if you create multiple weakrefs for the same object with the same callback function, it will be called exact the same time as the number of weakrefs.</p>
</div>
<span class="comment-copy">Use a <a href="https://docs.python.org/3.5/library/weakref.html" rel="nofollow noreferrer">weak reference</a></span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/12101958/keep-track-of-instances-in-python" title="keep track of instances in python">stackoverflow.com/questions/12101958/…</a></span>
<span class="comment-copy"><a href="http://effbot.org/pyfaq/how-do-i-get-a-list-of-all-instances-of-a-given-class.htm" rel="nofollow noreferrer">effbot.org/pyfaq/…</a></span>
<span class="comment-copy">In the Python shell (3.5.1) the assertion in the test loop fails because the cleanup callback has not been called when the loop reaches the assertion the second time. Printing anything to stdout before the assert statement or after test.pop() fixes it. So, placing "False" before "assert" fixes it, while placing "None" doesn't fix it.</span>
<span class="comment-copy">@uzumaki interesting. I tested with Python 3.4. I'm puzzled why the callback hasn't happened in 3.5.</span>
<span class="comment-copy">Note that <a href="https://docs.python.org/3.5/reference/datamodel.html#object.__del__" rel="nofollow noreferrer"><code>__del__</code></a> shouldn't be a static method. Also <code>not i() is None</code> is better written as <code>i() is not None</code>. Also, as tdelaney shows <code>weakref.ref</code> already provides the means of adding a callback called when the object gets destroyed.</span>
<span class="comment-copy">@Bakuriu : thanks for comment, pls see the updated answer for discussion about <code>__del__</code> and <code>weakref.ref</code></span>
