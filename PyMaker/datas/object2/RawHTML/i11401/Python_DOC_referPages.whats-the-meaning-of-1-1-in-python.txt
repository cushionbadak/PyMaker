<div class="post-text" itemprop="text">
<p>I'm testing the tuple structure, and I found it's strange when I use the <code>==</code> operator like:</p>
<pre><code>&gt;&gt;&gt;  (1,) == 1,
Out: (False,)
</code></pre>
<p>When I assign these two expressions to a variable, the result is true:</p>
<pre><code>&gt;&gt;&gt; a = (1,)
&gt;&gt;&gt; b = 1,
&gt;&gt;&gt; a==b
Out: True
</code></pre>
<p>This questions is different from <a href="https://stackoverflow.com/questions/7992559/python-tuple-trailing-comma-syntax-rule">Python tuple trailing comma syntax rule</a> in my view. I ask the group of expressions between <code>==</code> operator. </p>
</div>
<div class="post-text" itemprop="text">
<p>Other answers have already shown you that the behaviour is due to operator precedence, as documented <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="noreferrer">here</a>.  </p>
<p>I'm going to show you how to find the answer yourself next time you have a question similar to this.  You can deconstruct how the expression parses using the <a href="https://docs.python.org/3/library/ast.html" rel="noreferrer"><code>ast</code></a> module:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; source_code = '(1,) == 1,'
&gt;&gt;&gt; print(ast.dump(ast.parse(source_code), annotate_fields=False))
Module([Expr(Tuple([Compare(Tuple([Num(1)], Load()), [Eq()], [Num(1)])], Load()))])
</code></pre>
<p>From this we can see that the code gets parsed <a href="https://stackoverflow.com/a/37313506/674039">as Tim Peters explained</a>: </p>
<pre><code>Module([Expr(
    Tuple([
        Compare(
            Tuple([Num(1)], Load()), 
            [Eq()], 
            [Num(1)]
        )
    ], Load())
)])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is just operator precedence.  Your first</p>
<pre><code>(1,) == 1,
</code></pre>
<p>groups like so:</p>
<pre><code>((1,) == 1),
</code></pre>
<p>so builds a tuple with a single element from the result of comparing the one-element tuple <code>1,</code> to the integer <code>1</code> for equality  They're not equal, so you get the 1-tuple <code>False,</code> for a result.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you do </p>
<pre><code>&gt;&gt;&gt; (1,) == 1,
</code></pre>
<p>it builds a tuple with the result from comparing the <em>tuple</em> <code>(1,)</code> with an <em>integer</em> and thus returning <code>False</code>.</p>
<p>Instead when you assign to variables, the two <em>equal tuples</em> are compared with each other.</p>
<p>You can try:</p>
<pre><code>&gt;&gt;&gt; x = 1,
&gt;&gt;&gt; x
(1,)
</code></pre>
</div>
<span class="comment-copy">Looking at a <a href="http://stackoverflow.com/questions/37312512/whats-the-difference-between-1-and-1-in-python">previous question</a> by the OP just 2 hours ago, It seems wonderful (or strange) that how just framing of a question differently can lead to different results (and acceptance among the community).</span>
<span class="comment-copy">@AKS These are different qestions</span>
<span class="comment-copy">@AKS While the questions are marginally different here, I agree completely with your point. Herd effect aka HNQ.</span>
<span class="comment-copy">@PythonNewHand Indeed, it is completely acceptable. That's why I added that <i>framing a question differently</i>.</span>
<span class="comment-copy">@CiroSantilli巴拿馬文件六四事件法轮功 how do you figure? I skimmed those answers and saw nothing that seemed to cover this particular situation.</span>
<span class="comment-copy">Another useful tool is <code>dis</code> -- In this case, you'd see two <code>LOAD_CONST</code> with different values (<code>(1,)</code> and <code>1</code>) and a <code>BUILD_TUPLE</code> opp-code.</span>
<span class="comment-copy">That's the strangest manifestation of operator precedence I've ever seen...</span>
<span class="comment-copy">Not really, but 1-tuples have odd syntax.  In general, you'd be far more surprised if, e.g., <code>1+2, 2==3, 4*7</code> did <i>not</i> group as <code>(1+2), (2==3), (4*7)</code>.  In practice, 1-tuples are hardly ever used (well, outside of StackOverflow questions ;-) ).</span>
<span class="comment-copy">Perhaps "unexpected" would have been a better word to use than "strange." I feel a bit like I'm looking at <a href="http://www.today.com/pets/rabbit-or-duck-124-year-old-drawing-has-both-if-t73606" rel="nofollow noreferrer">one of those drawings that can be two things, depending on your perspective and focus</a>. The equality operator is so large compared to the commas, it's easy to focus on it and assume the result will be <code>True</code>/<code>False</code>. Now that I understand what's happening, it's perfectly obvious and reasonable.</span>
<span class="comment-copy">And now you know what the "Zen of Python" means by saying that the one obvious way to do it "may not be obvious at first unless you're Dutch" ;-)</span>
<span class="comment-copy">It's a little bit confusing when you read the doc and see that what makes a tuple is the comma, not the parentheses! So in this statement the comma in the right hand is not considered as a part of the test but it's considered as a separator! Unexpected behavior!</span>
