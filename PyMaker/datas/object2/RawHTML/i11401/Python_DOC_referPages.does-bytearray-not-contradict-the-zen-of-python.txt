<div class="post-text" itemprop="text">
<p>Python <a href="https://www.python.org/dev/peps/pep-3137/" rel="nofollow noreferrer">PEP 3137</a> introduced <a href="https://docs.python.org/3.1/library/functions.html#bytearray" rel="nofollow noreferrer"><code>bytearray</code></a> as a mutable 8-bit array type. However, a <a href="https://docs.python.org/3.1/library/functions.html#list" rel="nofollow noreferrer"><code>list</code></a> of the immutable <a href="https://docs.python.org/3.1/library/functions.html#bytes" rel="nofollow noreferrer"><code>bytes</code></a> type accomplishes the same goal, and actually has <a href="http://dabeaz.blogspot.co.il/2010/01/few-useful-bytearray-tricks.html" rel="nofollow noreferrer">better</a> <a href="https://stackoverflow.com/questions/17162609/python-bytearray-verses-list-of-bytes#">performance</a>, albeit perhaps a clunkier syntax. This new type contradicts the <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">Zen of Python</a> </p>
<blockquote>
<p>There should be one-- and preferably only one --obvious way to do it.</p>
</blockquote>
<p>So my question is: is there any documented major advantage or design consideration for using a <code>bytearray</code> over a <code>list</code> of <code>bytes</code>? </p>
<p>So far, I have not found a piece of motivation documented in the PEP or in the documentation pages. In fact, the documentation treats them as near-equals:</p>
<blockquote>
<p>The bytearray type is a mutable sequence of integers in the range 0 &lt;= x &lt; 256. It has most of the usual methods of mutable sequences...</p>
</blockquote>
<p>And then,</p>
<blockquote>
<p>List and bytearray objects support additional operations that allow in-place modification of the object. Other mutable sequence types (when added to the language) should also support these operations. </p>
</blockquote>
<p>As <code>bytearray</code>s are statically typed (as 8-bit unsigned integers) one might expect a performance increase, but as mentioned above the inverse is probably true. Also, there should be no memory advantage for a <code>bytearray</code> over a <code>list</code> of <code>bytes</code>. I could imagine that there was a need to a <code>itertools.chain</code>-style mutable type, but this is not mentioned anywhere and does not seem to be the design goal.</p>
</div>
<div class="post-text" itemprop="text">
<p>First,  a <code>list</code>-style container for sequences of objects that can seamlessly iterate through them (something that <code>itertools.chain</code> provides, actually) definitely seems convenient. As <a href="https://www.python.org/dev/peps/pep-3137/" rel="nofollow">PEP 3137</a> mentions, the <a href="https://docs.python.org/3/library/array.html" rel="nofollow">array module</a> might have served for this purpose, but was "far from ideal". </p>
<p>The authors wished for "both a mutable and an immutable bytes type", which might mean that the design goal was having the same interface for both a mutable (perhaps using non-contiguous memory for fast insertions and deletions), as well as an immutable (definitely contiguous memory) implementation. This created, as far as I can appreciate, a jumble of sequence types, including <code>array.array</code>, <code>bytes</code>, <code>bytearray</code>, <code>str</code>, <code>unicode</code>, <code>list</code>, <code>tuple</code> and <code>generator</code>. In essence, they provide interfaces to statically typed or ducked type, mutable or unmutable sequences which are stored in memory or evaluated on-the-fly (generators). Most of these do follow the rationale of the <a href="https://www.python.org/dev/peps/pep-3119" rel="nofollow">Abstract Base Classes</a>, but I do think that there is more design to be done before this can be deemed Pythonic.</p>
<p>Note: I'm leaving this answer open for editing hoping that people might contribute insights or corrections.</p>
</div>
<span class="comment-copy">A bytearray can do things that a list cannot</span>
<span class="comment-copy">If you are concerned about performance, you should probably be using NumPy.</span>
<span class="comment-copy">Also, I find this dubious: "Also, there should be no memory advantage for a bytearray over a list of bytes." A <code>list</code> is going to contain a reference (4 or 8 bytes depending on platform) to each <code>bytes</code> value, which is stored elsewhere. A <code>bytearray</code> is going to use exactly 1 byte per value. This should be a significant memory savings.</span>
<span class="comment-copy">have you seen <a href="https://docs.python.org/3/library/stdtypes.html#binaryseq" rel="nofollow noreferrer">the interface supported by <code>bytearray</code></a>? It is quite different from the generic <code>list</code>. You might as well ask, why <code>bytes</code> exists if we could put bytes into a <code>tuple</code>. <code>bytearray</code> is mutable sequence of bytes. <code>bytes</code> is an immutable sequence of bytes.</span>
<span class="comment-copy">@kindall - <code>bytearray</code> should probably be implemented as non-contiguous memory; otherwise you suffer from reallocation with every call to <code>extend()</code> and then we might as well have concatendated <code>bytes</code> together.</span>
