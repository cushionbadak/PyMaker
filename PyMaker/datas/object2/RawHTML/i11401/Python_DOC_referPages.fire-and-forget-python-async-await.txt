<div class="post-text" itemprop="text">
<p>Sometimes there is some non-critical asynchronous operation that needs to happen but I don't want to wait for it to complete.  In Tornado's coroutine implementation you can "fire &amp; forget" an asynchronous function by simply ommitting the <code>yield</code> key-word.</p>
<p>I've been trying to figure out how to "fire &amp; forget" with the new <code>async</code>/<code>await</code> syntax released in Python 3.5.  E.g., a simplified code snippet:</p>
<pre class="lang-python prettyprint-override"><code>async def async_foo():
    print("Do some stuff asynchronously here...")

def bar():
    async_foo()  # fire and forget "async_foo()"

bar()
</code></pre>
<p>What happens though is that <code>bar()</code> never executes and instead we get a runtime warning:</p>
<pre class="lang-python prettyprint-override"><code>RuntimeWarning: coroutine 'async_foo' was never awaited
  async_foo()  # fire and forget "async_foo()"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Upd:</strong></p>
<p>Replace <code>asyncio.ensure_future</code> with <code>asyncio.create_task</code> everywhere if you're using Python &gt;= 3.7 It's newer, nicer way <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task" rel="noreferrer">to spawn task</a>.</p>
<hr/>
<h2>asyncio.Task to “fire and forget”</h2>
<p>According to python docs for <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task" rel="noreferrer"><code>asyncio.Task</code></a> it is possible to start some coroutine to <strong>execute "in background"</strong>. The task created by <code>asyncio.ensure_future</code> <a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.ensure_future" rel="noreferrer">function</a> won't block the execution (therefore the function will return immediately!). This looks like a way to “fire and forget” as you requested.</p>
<pre><code>import asyncio


async def async_foo():
    print("async_foo started")
    await asyncio.sleep(1)
    print("async_foo done")


async def main():
    asyncio.ensure_future(async_foo())  # fire and forget async_foo()

    # btw, you can also create tasks inside non-async funcs

    print('Do some actions 1')
    await asyncio.sleep(1)
    print('Do some actions 2')
    await asyncio.sleep(1)
    print('Do some actions 3')


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
</code></pre>
<p>Output:</p>
<pre><code>Do some actions 1
async_foo started
Do some actions 2
async_foo done
Do some actions 3
</code></pre>
<h2>What if tasks are executing after event loop complete?</h2>
<p>Note that asyncio expects task would be completed at the moment event loop completed. So if you'll change <code>main()</code> to:</p>
<pre><code>async def main():
    asyncio.ensure_future(async_foo())  # fire and forget

    print('Do some actions 1')
    await asyncio.sleep(0.1)
    print('Do some actions 2')
</code></pre>
<p>You'll get this warning after the program finished:</p>
<pre><code>Task was destroyed but it is pending!
task: &lt;Task pending coro=&lt;async_foo() running at [...]
</code></pre>
<p>To prevent that you can just <a href="https://stackoverflow.com/a/27910822/1113207">await all pending tasks</a> after event loop completed:</p>
<pre><code>async def main():
    asyncio.ensure_future(async_foo())  # fire and forget

    print('Do some actions 1')
    await asyncio.sleep(0.1)
    print('Do some actions 2')


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())

    # Let's also finish all running tasks:
    pending = asyncio.Task.all_tasks()
    loop.run_until_complete(asyncio.gather(*pending))
</code></pre>
<h2>Kill tasks instead of awaiting them</h2>
<p>Sometimes you don't want to await tasks to be done (for example, some tasks may be created to run forever). In that case, you can just cancel() them instead of awaiting them:</p>
<pre><code>import asyncio
from contextlib import suppress


async def echo_forever():
    while True:
        print("echo")
        await asyncio.sleep(1)


async def main():
    asyncio.ensure_future(echo_forever())  # fire and forget

    print('Do some actions 1')
    await asyncio.sleep(1)
    print('Do some actions 2')
    await asyncio.sleep(1)
    print('Do some actions 3')


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())

    # Let's also cancel all running tasks:
    pending = asyncio.Task.all_tasks()
    for task in pending:
        task.cancel()
        # Now we should await task to execute it's cancellation.
        # Cancelled task raises asyncio.CancelledError that we can suppress:
        with suppress(asyncio.CancelledError):
            loop.run_until_complete(task)
</code></pre>
<p>Output:</p>
<pre><code>Do some actions 1
echo
Do some actions 2
echo
Do some actions 3
echo
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is not entirely asynchronous execution, but maybe <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.run_in_executor" rel="noreferrer">run_in_executor()</a> is suitable for you.</p>
<pre><code>def fire_and_forget(task, *args, **kwargs):
    loop = asyncio.get_event_loop()
    if callable(task):
        return loop.run_in_executor(None, task, *args, **kwargs)
    else:    
        raise TypeError('Task must be a callable')

def foo():
    #asynchronous stuff here


fire_and_forget(foo)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thank you Sergey for the succint answer. Here is the decorated version of the same. </p>
<pre><code>import asyncio
import time

def fire_and_forget(f):
    def wrapped(*args, **kwargs):
        return asyncio.get_event_loop().run_in_executor(None, f, *args, *kwargs)

    return wrapped

@fire_and_forget
def foo():
    time.sleep(1)
    print("foo() completed")

print("Hello")
foo()
print("I didn't wait for foo()")
</code></pre>
<p>Produces</p>
<pre><code>&gt;&gt;&gt; Hello
&gt;&gt;&gt; foo() started
&gt;&gt;&gt; I didn't wait for foo()
&gt;&gt;&gt; foo() completed
</code></pre>
</div>
<span class="comment-copy">Related? <a href="http://stackoverflow.com/q/32808893/1639625">stackoverflow.com/q/32808893/1639625</a> In fact, I think it's a duplicate, but I don't want to instant-dupe-hammer it. Can someone confirm?</span>
<span class="comment-copy">@tobias_k, I don't think it's duplicate. Answer at the link is too broad to be answer for this question.</span>
<span class="comment-copy">Does (1) your "main" process continue running forever ? Or (2) do you want to allow your process to die but allowing forgotten tasks continue their job ? Or (3) do you prefer your main process waiting for forgotten tasks just before ending ?</span>
<span class="comment-copy">Wow, excellent and thorough answer.  Thank you!</span>
<span class="comment-copy">I copied and past the first block and simply ran it on my end and for some reason I got: line 4     async def async_foo():             ^  As if there is some syntax error with the function definition on line 4: "async def async_foo():"  Am I missing something?</span>
<span class="comment-copy">@GilAllen this syntax works only in Python 3.5+. Python 3.4 needs old syntax (see <a href="https://docs.python.org/3.4/library/asyncio-task.html" rel="nofollow noreferrer">docs.python.org/3.4/library/asyncio-task.html</a> ). Python 3.3 and below doesn't support asyncio at all.</span>
<span class="comment-copy">@MikeN - thank you!</span>
<span class="comment-copy">How would you kill the tasks in a thread?…̣I have a thread that creates some tasks and I want to kill all the pending ones when the thread dies in its <code>stop()</code> method.</span>
<span class="comment-copy">Brilliant answer, Addresses the need of OP</span>
<span class="comment-copy">Nice concise answer.  It is worth noting that the <code>executor</code> will default to calling <code>concurrent.futures.ThreadPoolExecutor.submit()</code>.  I mention because creating threads is not free; fire-and-forgetting 1000 times a second will probably put a big strain on thread management</span>
