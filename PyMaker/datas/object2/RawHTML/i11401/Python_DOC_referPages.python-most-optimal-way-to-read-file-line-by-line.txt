<div class="post-text" itemprop="text">
<p>I have a large input file I need to read from so I don't want to use <code>enumerate</code> or <code>fo.readlines()</code>.
<code>for line in fo:</code> in the traditional way won't work and I'll state why, but I feel some modification to that is what I need right now. Consider the following file:</p>
<pre><code> input_file.txt:
 3 # No of tests that will follow
 3 # No of points in current test
 1 # 1st x-coordinate
 2 # 2nd x-coordinate
 3 # 3rd x-coordinate
 2 # 1st y-coordinate
 4 # 2nd y-coordinate
 6 # 3rd y-coordinate
 ...
</code></pre>
<p>What I need is to be able to read variable chunks of lines, pair the coordinates in  tuple, add tuple to a list of cases and move back to reading a new case from the file.</p>
<p>I thought of this:</p>
<pre><code>with open(input_file) as f:
    T = int(next(f)) 
    for _ in range(T):
        N = int(next(f))
        for i in range(N):
            x.append(int(f.next()))
        for i in range(N):
            y.append(int(f.next()))
</code></pre>
<p>Then couple the two lists into a tuple. I feel there must be a cleaner way to do this. Any suggestions?</p>
<p>EDIT: The y-coordinates will have to have a separate for loop to read. They are x and y coordinates are n lines apart. So Read line i; Read line (i+n); Repeat n times - for each case.</p>
</div>
<div class="post-text" itemprop="text">
<p>This might not be the shortest possible solution but I believe it is “pretty optimal”.</p>
<pre><code>def parse_number(stream):
    return int(next(stream).partition('#')[0].strip())

def parse_coords(stream, count):
    return [parse_number(stream) for i in range(count)]

def parse_test(stream):
    count = parse_number(stream)
    return list(zip(parse_coords(stream, count), parse_coords(stream, count)))

def parse_file(stream):
    for i in range(parse_number(stream)):
        yield parse_test(stream)
</code></pre>
<p>It will eagerly parse all coordinates of a single test but each test will only be parsed lazily as you ask for it.</p>
<p>You can use it like this to iterate over the tests:</p>
<pre><code>if __name__ == '__main__':
    with open('input.txt') as istr:
        for test in parse_file(istr):
            print(test)
</code></pre>
<p>Better function names might be desired to better distinguish eager from lazy functions. I'm experiencing a lack of naming creativity right now.</p>
</div>
<div class="post-text" itemprop="text">
<p>how about this with the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">grouper recipe</a></p>
<pre><code>from itertools import zip_longest

def grouper(iterable, n, fillvalue=None):
    """Collect data into fixed-length chunks or blocks
        grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"""
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)

with open(input_file) as archi:
    T = int(next(archi))
    N = int(next(archi))
    points = [ g for g in grouper(map(int,archi),N) ]
    print(points) # [(1, 2, 3), (2, 4, 6)]
    result = list( zip(*points) )
    print(result) #  [(1, 2), (2, 4), (3, 6)]
</code></pre>
<p>here I use grouper to read N lines at the time getting a list of tuples with all the x and all the y, then use zip to pair all those together</p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you're not really trying to "read a file line by line."  It sounds like you want to skip around the file, treating it like a large list/array but without triggering excessive memory consumption.</p>
<p>Have you looked at the <a href="https://docs.python.org/2/library/mmap.html" rel="nofollow">mmap</a> module?
With that you can use methods like <code>.find()</code> to find newlines, optionally starting at some offset (such as just past your current test header) and <code>.seek()</code> to move the file pointer to the nth item you've found and then <code>.readline()</code> and so on.</p>
<p>An <code>mmap</code> object shares some methods and properties of a string or byte array and some from file like objects.  So you can use a mixture of methods like <code>.find()</code> (normal for strings and byte arrays) and <code>.seek()</code> (for files).</p>
<p>Additionally the Python memory mapping uses your operating system's features for mapping files into memory.  (On Linux and similar systems this is the same mechanism by which your shared libraries are mapped into the address space for all of your running processes, for example).  The key point is that you memory is only used as a cache for the contents of the file, and the operating system will transparently perform the necessary I/O for loading and release memory buffers with the file's contents.</p>
<p>I don't see a method for finding the "nth" occurrence of some character or string ... so there's no way to skip to some line.  As far as I can tell you'll have to loop over <code>.find()</code> but then you can skip back to any such line using Python's slice notation.  You could write a utility class/object to scan for 1000 line terminators at a time, storing them in an index/list.  Then you can use values from that in slices of the memory mapping.</p>
</div>
<span class="comment-copy">so you want to read n lines in 1 iteration?</span>
<span class="comment-copy">I'm not sure I fully understand your input format and desired output stream of data structures. Could you provide a short example, please?</span>
<span class="comment-copy">What is wrong with enumerate()?</span>
<span class="comment-copy">@Copperfield I want to read 2 lines separated by N lines between them.</span>
<span class="comment-copy">@5gon12eder the outputs the above case would be [(1,2),(2,4),(4,6)]... That's the first test case</span>
<span class="comment-copy">+1 for the clean and clear code. <code>zip(parse_coords(stream, count), parse_coords(stream, count))</code> Doesn't this tuple have the same element twice? What am I missing here.</span>
<span class="comment-copy">I admit this is a bit tricky. Since <code>parse_coords</code> is evaluated eagerly, the first call consumes the <code>count</code> <i>x</i> coordinates from the stream and the second call will consume the <code>count</code> <i>y</i> coordinates. The <code>zip</code> will then zip two already fully constructed <code>list</code>s. Note that the <code>stream</code> is passed by-reference and mutated by the functions.</span>
<span class="comment-copy">You should read again the example file in the question, noting what is the number of cases and what is the the number of points in a case. Hint: the OP made the same mistake and so you can say you've been misleaded...</span>
<span class="comment-copy">@gboffi Right you are. I've corrected that.  +1 for the an amazing use of grouper. However, the reason I haven't accepted, and the reason I'm not using my <code>f.next()</code> version is because I'm looking for something that's more concise or, let's say, elegant.</span>
