<div class="post-text" itemprop="text">
<p>Imagine you have a background processing daemon which could be controlled by a web interface.</p>
<p>So, the app is an object with some methods responsible for handling requests and one special method that needs to be called repeatedly from time to time, regardless of requests state.</p>
<p>When using <code>aiohttp</code>, the web part is fairly straightforward: you just instantiate an application instance, and set things up as per <code>aiohttp.web.run_app</code> source. Everything is clear. Now let's say your app instance has that special method, call it <code>app.process</code>, which is structured like so:</p>
<pre><code>async def process(self):
    while self._is_running:
        await self._process_single_job()
</code></pre>
<p>With this approach you could call <code>loop.run_until_complete(app.process())</code>, but it blocks, obviously, and thus leaves no opportunity to set up the web part. Surely, I could have split these two responsibilities into separate processes and establish their communication by means of a database, but that would complicate things, so I would prefer to avoid this way if at all possible.</p>
<p>So, how do I make the event loop call some method repeatedly while still running a web app?</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to schedule the execution of <code>app.process()</code> as a task using <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.create_task" rel="nofollow">loop.create_task</a>:</p>
<pre><code>import asyncio
from aiohttp import web

class MyApp(web.Application):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.process_task = self.loop.create_task(self.process())
        self.on_shutdown.append(lambda app: app.process_task.cancel())

    async def process(self):
        while True:
            print(await asyncio.sleep(1, result='ping'))

if __name__ == '__main__':
    web.run_app(MyApp())
</code></pre>
</div>
