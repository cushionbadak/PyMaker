<div class="post-text" itemprop="text">
<p>Below is an abstracted piece of code that simplifies an issue that I have.
In this example, I have a program that has a login and logout attributes.
The login is version-independent and logout is version-dependent.</p>
<pre><code>class A(class):
    def __init__(self):
        self.version = "1.0"

        self.login = "logged in"
        self.login_message = "hello logger"
        self.logout = {"1.0": "logged out",
                       "2.0": "logged out 2.0"}
        self.logout_message = {"1.0": "goodbye logger",
                               "2.0": "goodbye logger 2.0"}

    def perform(self, executor):
        executor.do(self.login)
        executor.do(self.logout)
</code></pre>
<p><code>executor</code> is an external interface that performs the actual action, and it should receive a string. The <code>do</code> function cannot be altered.
The version can and will change at run-time, so I was looking for some sort of global decorator/property that will call a function when the decorated attribute is accessed. The objective is to select the correct string per version before it is sent to <code>executor.do</code>.</p>
<p>The obvious answer is to change the <code>perform</code> function to <code>executer.do(self.logout[self.version])</code>, but <code>self.login</code> and <code>self.logout</code> should not be accessed differently. There are inheritances in which <code>self.logout</code> is only a string, and <code>perform</code> is shared.</p>
<p>I was thinking of something like:</p>
<pre><code>self.version = "1.0"

self.login = "logged in"        
self.login_message = "hello logger"
@by_version
self.logout = {"1.0": "logged out",
               "2.0": "logged out 2.0"}
@by_version
self.logout_message = {"1.0": "goodbye logger",
                       "2.0": "goodbye logger 2.0"}

def by_version(self, attribute):
    return attribute[self.version]
</code></pre>
<p>That obviously doesn't work.
Is this even possible?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Manual Solution</h2>
<p>Looks like a use case for a <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow"><code>property</code></a> decorator:</p>
<pre><code>class A(object):
    def __init__(self):
        self.version = "1.0"

        self.login = "logged in"
        self.login_message = "hello logger"

    @property    
    def logout(self):
        return {"1.0": "logged out", "2.0": "logged out 2.0"}[self.version]

    @property    
    def logout_message(self):
        return {"1.0": "goodbye logger", "2.0": "goodbye logger 2.0"}[self.version]
</code></pre>
<p>Now:</p>
<pre><code>&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.login
'logged in'
&gt;&gt;&gt; a.logout
'logged out'
&gt;&gt;&gt; a.version = '2.0'
&gt;&gt;&gt; a.logout
'logged out 2.0'     
</code></pre>
<h2>Automated Solution 1</h2>
<p>If you have lot such properties, you can automate a bit:</p>
<pre><code>class A(object):
    def __init__(self):
        self.version = '1.0'
        self.login = 'logged in'
        self.login_message = 'hello logger'
        property_attrs = {'logout': {'1.0': 'logged out', 
                                     '2.0': 'logged out 2.0'},
                          'logout_message': {'1.0': 'goodbye logger',
                                             '2.0': 'goodbye logger 2.0'}}
        for name, value in property_attrs.items():
            setattr(self.__class__, name, property(lambda x: value[x.version]))
</code></pre>
<p>Now:</p>
<pre><code>&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.login_message
'hello logger'
&gt;&gt;&gt; a.logout
'goodbye logger'
&gt;&gt;&gt; a.version = '2.0'
&gt;&gt;&gt; a.logout
'goodbye logger 2.0'
</code></pre>
<h2>Automated Solution 2</h2>
<p>The "Automated Solution 1" redefines the properties every time you make
a new instance of <code>A</code>. This solutions avoids this but is bit more involved.
It makes use of a class decorator.</p>
<pre><code>property_attrs = {'logout': {'1.0': 'logged out', '2.0': 'logged out 2.0'},
                  'logout_message': {'1.0': 'goodbye logger', '2.0': 'goodbye logger 2.0'}}

def add_properties(property_attrs):
    def decorate(cls):
        for name, value in property_attrs.items():
            setattr(cls, name, property(lambda self: value[self.version]))
        return cls
    return decorate

@add_properties(property_attrs)
class A(object):
    def __init__(self):
        self.version = '1.0'
        self.login = 'logged in'
        self.login_message = 'hello logger'
</code></pre>
<p>Now:</p>
<pre><code>&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.logout
'goodbye logger'
&gt;&gt;&gt; a.version = '2.0'
&gt;&gt;&gt; a.logout
'goodbye logger 2.0'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You say that "<code>self.login</code> and <code>self.logout</code> should not be accessed differently. The code below keeps the <code>self.logout</code> dictionary but renames it to <code>self.logouts</code> so that we can access it as a property. Similar remarks apply to <code>self.logout_message</code>.</p>
<p>This code runs on Python 2 or 3.</p>
<pre><code>from __future__ import print_function

class Executor(object):
    def do(self, s):
        print('Executing %r' % s)


class A(object):
    def __init__(self, version="1.0"):
        self.version = version

        self.login = "logged in"
        self.login_message = "hello logger"
        self.logouts = {
            "1.0": "logged out",
            "2.0": "logged out 2.0",
        }
        self.logout_messages = {
            "1.0": "goodbye logger",
            "2.0": "goodbye logger 2.0",
        }

    @property
    def logout(self):
        return self.logouts[self.version]

    @property
    def logout_message(self):
        return self.logout_messages[self.version]

    def perform(self, executor):
        executor.do(self.login)
        executor.do(self.logout)

executor = Executor()
executor.do('Tests')

#Test

a = A()
a.perform(executor)
print('msg', a.logout)
a.version = "2.0"
a.perform(executor)
print('msg', a.logout)
print()

b = A("2.0")
b.perform(executor)
print('msg', b.logout)
b.version = "3.0"
b.perform(executor)
</code></pre>
<p><strong>output</strong></p>
<pre class="lang-none prettyprint-override"><code>Executing 'Tests'
Executing 'logged in'
Executing 'logged out'
msg logged out
Executing 'logged in'
Executing 'logged out 2.0'
msg logged out 2.0

Executing 'logged in'
Executing 'logged out 2.0'
msg logged out 2.0
Executing 'logged in'
Traceback (most recent call last):
  File "./qtest.py", line 69, in &lt;module&gt;
    b.perform(executor)
  File "./qtest.py", line 50, in perform
    executor.do(self.logout)
  File "./qtest.py", line 42, in logout
    return self.logouts[self.version]
KeyError: '3.0'
</code></pre>
</div>
<span class="comment-copy">Ninja'd again.  Oh well, I might as well post my code. :)</span>
<span class="comment-copy">That will work. Thanks! However I was thinking of a global function that will be called before any access to a decorated attribute (much like the getter), and then return the appropriate value. Can the property decorator accept an attribute as parameter? That way it will be global that can be reused. If there's no such option, I will accept this answer.</span>
<span class="comment-copy">What do you mean by "reused"? We only have one class here. Do you want to do the same in other classes? Just inheriting from <code>A</code> should give you quite a bit of reuse.</span>
<span class="comment-copy">I mean I have to create <code>@property def &lt;name&gt;(self): return {parameters}[self.version]</code> for each attribute. There are many many <code>self.logout</code>-like attributes, so I was wandering if there is a global getter that will accept an attribute (like <code>self.logout</code>) and will return the appropriate string according to <code>self.version</code>.  Much like my example of <code>def by_version(self, attribute):</code> and decorate the attribute with <code>@by_version</code> above. It might not be possible, just making sure.</span>
<span class="comment-copy">Added a version that generates properties from a dictionary.</span>
