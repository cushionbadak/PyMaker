<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/5206466/why-empty-string-is-on-every-string">Why empty string is on every string? [duplicate]</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>As I am going through tutorials on Python 3, I came across the following:</p>
<pre><code>&gt;&gt;&gt; '' in 'spam'
True
</code></pre>
<p>My understanding is that <code>''</code> equals no blank spaces.</p>
<p>When I try the following the shell terminal, I get the output shown below it:</p>
<pre><code>&gt;&gt;&gt; '' in ' spam '
True
</code></pre>
<p>Can someone please help explain what is happening?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>''</code> is the empty string, same as <code>""</code>. The empty string is a substring of <em>every</em> other string.</p>
<p>When <code>a</code> and <code>b</code> are strings, the expression <code>a in b</code> checks that <code>a</code> is a substring of <code>b</code>. That is, the sequence of characters of <code>a</code> must exist in <code>b</code>; there must be an index <code>i</code> such that <code>b[i:i+len(a)] == a</code>. If <code>a</code> is empty, then any index <code>i</code> satisfies this condition.</p>
<p>This does not mean that when you iterate over <code>b</code>, you will get <code>a</code>. Unlike other sequences, while every element produced by <code>for a in b</code> satisfies <code>a in b</code>, <code>a in b</code> does not imply that <code>a</code> will be produced by iterating over <code>b</code>.</p>
<p>So <code>'' in x</code> and <code>"" in x</code> returns True for any string <code>x</code>:</p>
<pre><code>&gt;&gt;&gt; '' in 'spam'
True
&gt;&gt;&gt; "" in 'spam'
True
&gt;&gt;&gt; "" in ''
True
&gt;&gt;&gt; '' in ""
True
&gt;&gt;&gt; '' in ''
True
&gt;&gt;&gt; '' in ' ' 
True
&gt;&gt;&gt; "" in " "
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow">string literal</a> <code>''</code> represents the empty string. This is basically a string with a length of zero, which contains no characters.</p>
<p>The <code>in</code> operator is defined <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow">for sequences</a> to return “<code>True</code> if an item of <code>s</code> is equal to <code>x</code>, else <code>False</code>” for an expression <code>x in s</code>. For general sequences, this means that one of the items in <code>s</code> (usually accessible using iteration) equals the tested element <code>x</code>. For strings however, the <code>in</code> operator has <em>subsequence</em> semantics. So <code>x in s</code> is true, when <code>x</code> is a substring of <code>s</code>.</p>
<p>Formally, this means that for a substring <code>x</code> with a length of <code>n</code>, there must be an index <code>i</code> which satisfies the following expression: <code>s[i:i+n] == x</code>.</p>
<p>This is easily understood with an example:</p>
<pre><code>&gt;&gt;&gt; s = 'foobar'

&gt;&gt;&gt; x = 'foo'
&gt;&gt;&gt; n = len(x) # 3
&gt;&gt;&gt; i = 0
&gt;&gt;&gt; s[i:i+n] == x
True

&gt;&gt;&gt; x = 'obar'
&gt;&gt;&gt; n = len(x) # 4
&gt;&gt;&gt; i = 2
&gt;&gt;&gt; s[i:i+n] == x
True
</code></pre>
<p>Algorithmically, what the <code>in</code> operator (or the underlying <code>__contains__</code> method) needs to do is iterate the <code>i</code> to all possible values (<code>0 &lt;= i &lt; len(s) - n</code>) and check if the condition is true for any <code>i</code>.</p>
<p>Looking back at the empty string, it becomes clear why the <code>'' in s</code> check is true for every string <code>s</code>: <code>n</code> is zero, so we are checking <code>s[i:i]</code>; and that is the empty string itself for every valid index <code>i</code>:</p>
<pre><code>&gt;&gt;&gt; s[0:0]
''
&gt;&gt;&gt; s[1:1]
''
&gt;&gt;&gt; s[2:2]
''
</code></pre>
<p>It is even true for <code>s</code> being the empty string itself, because sequence slicing is defined to return an empty sequence when a range outside of the sequence is specified (that’s why you could do <code>s[74565463:74565469]</code> on short strings).</p>
<p>So that explains why the containment check with <code>in</code> always returns <code>True</code> when checking the empty string as a substring. But even if you think about it logically, you can see the reason: A substring is part of a string which you can find in another string. The empty string however can be find <em>between</em> every two characters. It’s like how you can add an infinite amount of zeros to a number, you can add an infinite amount of empty strings to a string without actually modifying that string.</p>
</div>
<div class="post-text" itemprop="text">
<p>As Rushy Panchal points out, <code>in</code> inclusion operator follows set-theoretic convention and assumes that an empty string is a substring of any string.</p>
<p>You can try to persuade yourself why this makes sense by considering the following: let <code>s</code> be a string such that <code>'' in s == False</code>. Then <code>'' in s[len(s):]</code> better be false by transitivity (or else there is a subset of <code>s</code> that contains <code>''</code>, but <code>s</code> does not contain <code>''</code>, etc). But then <code>'' in '' == False</code>, which isn't great either. So you cannot pick any string <code>s</code> such that <code>'' not in s</code> which does not create a problem.</p>
<p>Of course, when in doubt, simulate it:</p>
<pre><code>s = input('Enter any string you dare:\n')

print('' in '')
print(s == s + '' == '' + s)
print('' in '' + s)
</code></pre>
</div>
<span class="comment-copy">If empty string, by definition, must exist in ever other string, why is it not part of the iterator set?  I.E. for i in 'spam': print(i)</span>
<span class="comment-copy">@Brightlights That's an interesting question. I may have phrased that incorrectly – essentially, <code>a</code> in <code>b</code> (for strings) checks that all elements of <code>a</code> are in <code>b</code>. Thus, if <code>a</code> is empty, every element of it (which are no elements) exist in any <code>b</code>. See my updated answer.</span>
<span class="comment-copy">@RushyPanchal: That's not how the check works. <code>a</code> in <code>b</code> for strings checks that <code>a</code> is a substring of <code>b</code>. For the check to evaluate to <code>True</code>, there must be some index <code>i</code> such that <code>b[i:i+len(a)] == a</code>. (This is completely different from all the other built-in sequence types.)</span>
<span class="comment-copy">@Brightlights The iterator for strings iterates over every 1-character substring (i.e. over each character). The empty string is not a character of the string. However, the <code>in</code> operator, the containment check, just checks whether a string <code>a</code> is contained as a substring within <code>b</code>. You can find the empty string in every zero-length substring of a string, so <code>'' in x</code> is true for every string <code>x</code>.</span>
<span class="comment-copy">@Brightlights: <code>for i in 'spam': print(i)</code> will also not print <code>'am'</code>, even though 'am' is a substring of <code>'spam'</code>.  That's because <code>for i in 'spam'</code> does not iterate over all substrings, it iterates over all characters.  If you somehow iterated over all substrings, it would indeed include <code>''</code>.</span>
