<div class="post-text" itemprop="text">
<p>I have two strings and I would like to find a union of them. While doing so I would like to maintain the order. My aim of doing this is that I'm trying several ways to OCR an image and get different results. I would like to combine all the different results into one result which will have the most content. </p>
<p>This is atleast what I'm after:</p>
<pre><code>#example1
string1 = "This is a test trees are green roses are red"
string2 = "This iS a TEST trees 12.48.1952 anthony gonzalez"
finalstring = "this is a test trees are green roses are red 12.48.1952 anthony gonzalez" 

#example2
string2 = "This is a test trees are green roses are red"
string1 = "This iS a TEST trees 12.48.1952 anthony gonzalez"
finalstring = "this is a test trees are green roses are red 12.48.1952 anthony gonzalez"

#example3
string1 = "telephone conversation in some place big image on screen"
String2 = "roses are red telephone conversation in some place big image on screen"
finalstring = "roses are red telephone conversation in some place big image on screen"
#or the following - both are fine in this scenario.
finalstring = "telephone conversation in some place big image on screen roses are red "
</code></pre>
<p>This is what I've tried:</p>
<pre><code>&gt;&gt;&gt; string1 = "This is a test trees are green roses are red"
&gt;&gt;&gt; string2 = "This iS a TEST trees 12.48.1952 anthony gonzalez"
&gt;&gt;&gt; list1 = string1.split(" ")
&gt;&gt;&gt; list2 = string2.split(" ")
&gt;&gt;&gt; " ".join(list(set(list1) | set(list2))).lower()
'a gonzalez this is trees anthony roses green are test 12.48.1952 test is red'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="https://docs.python.org/3/library/difflib.html#sequencematcher-objects" rel="nofollow"><code>difflib.SequenceMatcher</code></a> for this:</p>
<pre><code>import difflib
def merge (l, r):
    m = difflib.SequenceMatcher(None, l, r)
    for o, i1, i2, j1, j2 in m.get_opcodes():
        if o == 'equal':
            yield l[i1:i2]
        elif o == 'delete':
            yield l[i1:i2]
        elif o == 'insert':
            yield r[j1:j2]
        elif o == 'replace':
            yield l[i1:i2]
            yield r[j1:j2]
</code></pre>
<p>Used like this:</p>
<pre><code>&gt;&gt;&gt; string1 = 'This is a test trees are green roses are red'
&gt;&gt;&gt; string2 = 'This iS a TEST trees 12.48.1952 anthony gonzalez'

&gt;&gt;&gt; merged = merge(string1.lower().split(), string2.lower().split())
&gt;&gt;&gt; ' '.join(' '.join(x) for x in merged)
'this is a test trees are green roses are red 12.48.1952 anthony gonzalez'
</code></pre>
<p>If you want to perform the merge on a character level, you can simply modify the call to operate on the string directly (instead of a list of words):</p>
<pre><code>&gt;&gt;&gt; merged = merge(string1.lower(), string2.lower())
&gt;&gt;&gt; ''.join(merged)
'this is a test trees 12.48.1952 arenthony gronzaleen roses are redz'
</code></pre>
<p>This solution properly maintains the order of the individual parts of the string. So if both strings end with a common part but have a different segment before the end, then both those different segments will still appear <em>before</em> the common end in the result. For example merging <code>A B D</code> and <code>A C D</code> will give you <code>A B C D</code>.</p>
<p>So you can find each of the original strings in the correct order by simply removing parts of the resulting string. If you remove the <code>C</code> from that example result, you get back the first string; and if you remove the <code>B</code> instead, you get back the second string. And this also works with more complex merges.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Do not</strong> use a set for this. As you must have noticed, only one <em>are</em> made it to the final result as <code>set()</code> keeps unique objects.</p>
<pre><code>string1 = "This is a test trees are green roses are red"
string2 = "This iS a TEST trees 12.48.1952 anthony gonzalez"

str_lst = string1.split()

for s, t in zip(string1.split(), string2.split()):
    if s.lower() == t.lower():
        continue
    else:
        str_lst.append(t)

string = " ".join(s.lower() for s in str_lst)
#this is a test trees are green roses are red 12.48.1952 anthony gonzalez
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>" ".join(x if i &gt;= len(string2.split()) or x == string2.lower().split()[i] else " ".join((x, string2.split()[i])) for i, x in enumerate(string1.lower().split()))
</code></pre>
<p>You can use a generator comprehension and <code>join</code> like this to accomplish what you want. This sets <code>i</code> to the index of a word in <code>string1</code> and <code>x</code> to that word. It then checks if that word is in <code>string2</code>, and if not, adds the word in <code>string2</code> at <code>i</code> to <code>x</code> to put both words in the final string.</p>
</div>
<span class="comment-copy">Do you want to do this on a per-word basis, or a per character basis (the latter would result in a very different result). Also, apparently you want to ignore the case?</span>
<span class="comment-copy">yes, to make matters less complex I am willing to ignore the case. I hadn't thought of doing it on per character basis. I can't imagine how that would work...</span>
<span class="comment-copy">A possible result for a character-based result (using the built-in difflib) would be <code>'This is a test trees 12.48.1952 arenthony gronzaleen roses are redz'</code>.</span>
<span class="comment-copy">Do you have any logic in mind on how to handle the order of the union of "foo bar" and "bar foo"?</span>
<span class="comment-copy">@YakymPirozhenko I don't think that will be the case for my scenario. In the different techniques I'm trying for OCR one will either pick a result or won't pick a result. I don't envision a scenario when two techniques both pick the result but one is swapped.</span>
<span class="comment-copy">if you swap string1 and string2 in this then the result is: This iS a TEST trees 12.48.1952 anthony gonzalez are green roses. However, in that case also I'm after this is a test trees are green roses are red 12.48.1952 anthony gonzalez</span>
<span class="comment-copy">@Anthony The merge algorithm in my code prioritizes the left over the right string. If you want different behavior, you need to specify some rule to pick one over the other. Right now, it’s completely content independent.</span>
<span class="comment-copy">looking at this merge solution and the added examples in the question - I think the merge should always happen at the end of the string...</span>
<span class="comment-copy">Then it’s not really a merge though. You are just adding the words from the second string that are missing from the first string to the end of the result? So you are looking more for a <code>string1 + ' '.join(w for w in string2.split() if w not in string1.split())</code>?</span>
<span class="comment-copy">if you swap string1 and string2 in this then the result is: <code>This iS a TEST trees 12.48.1952 anthony gonzalez are green roses</code>. However, in that case also I'm after <code>this is a test trees are green roses are red 12.48.1952 anthony gonzalez</code></span>
<span class="comment-copy">The code has been updated</span>
<span class="comment-copy">This does not work with matches found at the end of the string, e.g. <code>'foo bar'</code> and <code>'baz bar'</code> results in <code>'foo bar baz'</code> but should probably result in something more like <code>'foo baz bar'</code>.</span>
<span class="comment-copy">OP has just recently updated his/her question</span>
<span class="comment-copy">I'm trying to make sense of it. It is hard for me to read it. but it gives me this result: <code>&gt;&gt;&gt; "".join(x if x not in string2.lower() else " ".join((x, string2.split()[i])) for i, x in enumerate(string1.lower().split())) 'this Thisis iSa atest TESTtrees treesaregreenrosesarered'</code></span>
<span class="comment-copy">@Anthony Sorry didn't do any testing, fixed it.</span>
<span class="comment-copy">This does not seem to remove duplicates on inner matches properly, e.g. with strings <code>'x y x'</code> and <code>'y'</code>, you get a result of <code>'x y y x'</code>.</span>
