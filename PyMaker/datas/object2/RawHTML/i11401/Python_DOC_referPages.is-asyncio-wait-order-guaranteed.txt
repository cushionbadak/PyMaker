<div class="post-text" itemprop="text">
<p>I'm trying to implement fair queuing in my library that is based on asyncio.</p>
<p>In some function, I have a statement like (assume <code>socketX</code> are tasks):</p>
<pre><code>done, pending = asyncio.wait(
    [socket1, socket2, socket3],
    return_when=asyncio.FIRST_COMPLETED,
)
</code></pre>
<p>Now I read the documentation for <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait" rel="nofollow"><code>asyncio.wait</code></a> many times but it does not contain the information I'm after. Mainly, I'd like to know if:</p>
<ul>
<li><code>socket1</code>, <code>socket2</code> and <code>socket3</code> happened to be already ready when I issue the call. Is it guaranteed that <code>done</code> will contain them all or could it be that it returns only one (or two) ?</li>
<li>In the second case, does the order of the tasks passed to <code>wait()</code> matter ?</li>
</ul>
<p>I'm trying to assert if I can just apply fair-queuing in the set of <code>done</code> tasks (by picking one and leaving the other tasks for later resolution) or if I also need to care about the order I pass the tasks in.</p>
<p>The documentation is kinda silent about this. Any idea ?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is only taken according to the <a href="https://hg.python.org/cpython/file/3.5/Lib/asyncio/tasks.py#l402" rel="nofollow">source code</a> of Python 3.5.</p>
<p>If the future is done before calling <code>wait</code>, they will all be placed in the <code>done</code> set:</p>
<pre><code>import asyncio

async def f(n):
    return n

async def main():
    (done, pending) = await asyncio.wait([f(1), f(2), f(3)], return_when=asyncio.FIRST_COMPLETED)
    print(done)     # prints set of 3 futures
    print(pending)  # prints empty set

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
loop.close()
</code></pre>
</div>
<span class="comment-copy">I also tried that out but it didn't occur to me to check Python's source code. Not enough sleep I guess.Thanks a lot for trying it on your side. I guess what we can conclude is that there is no guarantee that it will always behave like that but that the current implementation does so on all platforms.</span>
