<div class="post-text" itemprop="text">
<p>I often find myself dealing with issues similar to the failure triggered by the following code. As you can see, the counter-measures I used in this example are futile: for some reason it looks like <code>while len(some_list) &gt; n + 1</code> eventually gives "false positives".</p>
<p>Of course I could use <a href="https://docs.python.org/2/tutorial/controlflow.html#pass-statements" rel="nofollow"><code>pass</code></a> statement to override this "funny behaviour" (even through I think it would be kinda "hacky", it would work). However, <strong>the point is: why is this happening, actually?</strong></p>
<pre><code>some_list = [2,3,2]

some_list.sort(reverse=True)

n = 0
while len(some_list) &gt; 1 and n &lt; len(some_list) - 1:
    try:
        while len(some_list) &gt; n + 1:
            # This `if` statement was my last counter-measure
            if n + 1 &gt;= len(some_list):
                break
            while some_list[n] == some_list[n+1]:
                some_list[n] += some_list.pop(n+1)
            else:
                n += 1
    except:
        print "WTF!!! len =",len(some_list),", n =",n
        raise
</code></pre>
<p>This is the response on command-line:</p>
<pre><code>WTF!!! len = 2 , n = 1
  Traceback (most recent call last):
    File "example.py", line 11, in &lt;module&gt;
      while some_list[n] == some_list[n+1]:
IndexError: list index out of range
</code></pre>
<h2>Clarifications:</h2>
<ul>
<li>I am deliberately using <code>.pop()</code> to eliminate that element on purpose.</li>
<li>The purpose of the question is determining the causes of this kind of error, nothing else.</li>
<li>The code is just an example that triggers the exception I wanted to expose in the question.</li>
<li>The "purpose" of the code is eliminating list duplicates adding them to the adjacent element(which is expected to be equal).</li>
</ul>
<hr/>
<h3>Bad formulated question because a wrong guess</h3>
<p>After using the debugger recommnded by @Kevin M granger:</p>
<pre><code>-&gt; while len(some_list) &gt; n + 1:
(Pdb) print len(some_list), "&gt;", n + 1
3 &gt; 2
(Pdb) next
&gt; /tmp/kpasa.py(10)&lt;module&gt;()
-&gt; if n + 1 &gt;= len(some_list):
(Pdb) print n + 1, "&gt;=", len(some_list)
2 &gt;= 3
(Pdb) next
&gt; /tmp/kpasa.py(13)&lt;module&gt;()
-&gt; while some_list[n] == some_list[n+1]:
(Pdb) print len(some_list), n
3 1
(Pdb) next
&gt; /tmp/kpasa.py(14)&lt;module&gt;()
-&gt; some_list[n] += some_list.pop(n+1)
(Pdb) next
&gt; /tmp/kpasa.py(13)&lt;module&gt;()
-&gt; while some_list[n] == some_list[n+1]:
(Pdb) print len(some_list), n
2 1
(Pdb) next
IndexError: 'list index out of range'
</code></pre>
<p>I realized my own stupidity. There wasn't "false positive" at all. <strong>This question actually is stupid</strong>, so I agree it must be erased.</p>
<p>I am so sorry for my rudeness and stupidity.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>while some_list[n] == some_list[n+1]:
    some_list[n] += some_list.pop(n+1)
</code></pre>
<p>The <code>pop</code> here reduces the length of the list, and on the next <code>while</code> iteration there is no guarantee that <code>len(some_list) &gt; n + 1</code>, so the exception can occur. You can change the inner <code>while</code> to:</p>
<pre><code>while len(some_list) &gt; n + 1 and some_list[n] == some_list[n+1]:
    some_list[n] += some_list.pop(n+1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your trouble is here:</p>
<pre><code>while some_list[n] == some_list[n+1]:
    some_list[n] += some_list.pop(n+1)
</code></pre>
<p>When n=1, you pop the last item off of some_list and add it to some_list[1].  The "pop" modifies the list, so now some_list is now [3, 4].  Then you return to the "while" condition, where you check some_list[1] == some_list[2], but some_list no longer has an item at index 2; you just popped it.</p>
<p>Here's a different approach that seems (at least to me) clearer (although I'm guessing about what you want to do:</p>
<pre><code>some_list = [2,3,2]

some_list.sort(reverse=True)

new_list = []
prior_value = None
for old_value in some_list:
    if old_value == prior_value:
        new_list[-1] += old_value
    else:
        new_list.append(old_value)
        prior_value = old_value

print new_list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the line <code>some_list[n] += some_list.pop(n+1)</code> you reduce the size of your list. When it next evaluates <code>while some_list[n] == some_list[n+1]:</code>, <code>some_list[n+1]</code> raises an IndexError, because the list is now less than n+1 elements long.</p>
</div>
<span class="comment-copy">What is the purpose of this code? What is your expected result?</span>
<span class="comment-copy">Use <a href="https://docs.python.org/3/library/pdb.html" rel="nofollow noreferrer">a debugger</a> to step through the code, line by line, while monitoring the variables and their values.</span>
<span class="comment-copy">Also, think about what will happen when <code>n</code> is equal to the next to last index in the list (<code>1</code> in your example), and you pop the last element from the list. What element will then <code>n + 1</code> reference?</span>
<span class="comment-copy">The code itself doesn't matter. I am trying to learn more about this issue, nothing else. However, for the sake of completeness, the "purpose" in this example is eliminate list duplicates adding them to the adjacent element(which is expected to be equal). I just isolated the issue summarizing it as much as possible.</span>
<span class="comment-copy">Python comes with a built-in debugger. <code>python -m pdb ./scriptname.py</code></span>
<span class="comment-copy">even through to your approach solves the problem (btw thanks), the doubt about why "false positives" are produced is still a mistery. I will try the debugger to see what happens, and see if I can find out the answer...</span>
<span class="comment-copy">@SebasSBM There are no "false positives". You are changing the list after the outer <code>while</code> loop has checked its length, so that condition is no longer true.</span>
<span class="comment-copy">I just realized some hours ago. I've left evidence as an answer. I have been too rude about this, realizing my mistake took me too long...</span>
<span class="comment-copy">That's what I thought at first, but, even so, looks like it happens because <code>while len(some_list) &gt; n + 1:</code> returned True (<code>while 2 &gt; 2</code> shouldn't)... There is my actual confusion. +1 for the effort, it helped me to have a wider point of view</span>
