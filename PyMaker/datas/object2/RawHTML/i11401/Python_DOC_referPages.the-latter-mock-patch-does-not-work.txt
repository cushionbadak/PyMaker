<div class="post-text" itemprop="text">
<p>See the following code</p>
<h2>mock-test/ymath.py</h2>
<pre><code>def add(x, y):
    return x + y
</code></pre>
<h2>mock-test/calc.py</h2>
<pre><code>from ymath import add

def calc(x, y):
    return add(x, y)
</code></pre>
<h2>mock-test/main.py</h2>
<pre><code>import mock


class YAdd:
    def __init__(self, a):
        print 'YAdd init with a %s' % (a, )
        self.a = a

    def __call__(self, x, y, **kwargs):
        return x + y + self.a


def calc(x, y):
    print 'calc called...'

    @mock.patch('ymath.add', YAdd(x))
    def inner():
        from calc import calc
        print calc(x, y)
    inner()


calc(8, 3)  # Expected: 8 + 8 + 3 = 19
calc(4, 5)  # Expected: 4 + 4 + 5 = 13
</code></pre>
<p>The result as following shown, the expected value of the second invoke was 13</p>
<pre><code>calc called...

YAdd init with a 8

19

calc called...

YAdd init with a 4

17
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're patching in the wrong place. You should be patching <code>calc.add</code>, not <code>ymath.add</code>. See the docs on <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow">where to patch</a>.</p>
<p>Note also there's no reason to define an inner function just to use the patch decorator: you can use it as a context manager instead.</p>
<pre><code>def calc(x, y):
    print 'calc called...'

    with mock.patch('calc.add', YAdd(x)):
        from calc import calc
        print calc(x, y)
</code></pre>
</div>
<span class="comment-copy">Thanks for your reply. But I also want to know why the second invoke does not work. By the way, using an inner function makes code more clean when patching multiple objects</span>
<span class="comment-copy">And I hope to patch <code>ymath.add</code> directly, since in a more complex scenario, the method would be used in multiple modules. I hope the patch could work in all place.</span>
