<div class="post-text" itemprop="text">
<p>I know that C++ should be much faster than Python 3 because it is a compiled language as opposed to an interpreted language.  </p>
<p>I wrote 2
two programs that use the Monte <em>Carlo Simulation</em> to calculate <strong>Pi</strong>, one in Python 3 and the other in C++.  </p>
<p>Python turned out to be approximately 16x faster than C++. As seen in the photos bellow, with a repetition value of (<em>10,000,000</em>), Python takes 8.5 seconds whilst C++ takes 137.4 seconds.</p>
<p>I'm new to C++ but I can't find posts online that explains this behavior.</p>
<p>According to <a href="https://stackoverflow.com/a/801671/3883263">this post</a> C++ in general should be 10x - 100x faster than Python, which is clearly not the case with me.</p>
<p>Please help me understand why Python is significantly faster than C++ in my case.</p>
<p><strong>My results</strong>:</p>
<p><strong>Monte Carlo Simulation (Estimation of Pi) in C++</strong>
<a href="https://i.stack.imgur.com/rmFWG.png" rel="nofollow noreferrer"><img alt="Monte Carlo Simulation (Estimation of Pi) using C++" src="https://i.stack.imgur.com/rmFWG.png"/></a></p>
<p><strong>Monte Carlo Simulation (Estimation of Pi) in Python 3</strong>
<a href="https://i.stack.imgur.com/tFzz3.png" rel="nofollow noreferrer"><img alt="Monte Carlo Simulation (Estimation of Pi) using python 3" src="https://i.stack.imgur.com/tFzz3.png"/></a></p>
<p><strong>Python Source Code:</strong></p>
<pre><code>from random import random
import time
import sys

class MonteCarloSimulator(object):

    def __init__(self, value):
        self.value = value

        if sys.platform == "win32":
            self.G = ''
            self.R = ''
            self.END = ''
        else:
            self.G = '\033[92m'
            self.R = '\033[1;31m'
            self.END = '\033[0m'

    def unit_circle(self, x, y):
        if (x ** 2 + y ** 2) &lt;= 1:
            return True
        else:
            return False

    def simulate(self):
        print("\nProcessing calculations with a repetition value of " + self.R +
        str(self.value) + self.END + " times.")

        area_of_circle = 0
        area_of_square = 0

        start = time.clock()

        for i in range(1, self.value):
            x = random()
            y = random()

            if self.unit_circle(x, y):
                area_of_circle += 1
            area_of_square += 1

        pi = (area_of_circle * 4) / area_of_square

        runtime = time.clock() - start

        print("\tCalculated Pi = " + self.G + str(pi) + self.END +
        " ({0} seconds, {1} minutes)".format(round(runtime, 10),
        round(runtime / 60, 10)))

        print("Estimated Num of Pi is off by", abs(pi - 3.14159265359))

def main():
    values = [1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000, 10000000000]
    for value in values: MonteCarloSimulator(value).simulate()
if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nQuitting...")
        sys.exit(1)
</code></pre>
<p><strong>C++ Source Code:</strong></p>
<pre><code>#include &lt;iostream&gt;                     // std library
#include &lt;random&gt;                       // random number generator
#include &lt;ctime&gt;                        // calculating runtime
#include &lt;cmath&gt;                        // absolute value function
#include "MonteCarloSimmulation.hpp"    // function prototypes

using namespace std;

const double g_PI {3.141592653589793238463};

int main()
{
    // repitition values
    long values[5] = {1000, 10000, 100000, 1000000, 10000000};//, 100000000, 1000000000, 10000000000};

    // runs the simulation with the different repetition values
    for (auto value : values)
        simulate(value);

    cout &lt;&lt; "\nPress return to exit";
    cin.get();

    return 0;
}

/**
 * The actual simulation
 */
void simulate(unsigned long value)
{
    // start time for calculating runtime
    const clock_t startTime = clock();

    // area's variables
    unsigned long area_of_circle = 0;
    unsigned long area_of_square = 0;

    // print the repitiion value
    cout &lt;&lt; "\nProcessing calculations with a repetition value of " &lt;&lt; value &lt;&lt;
    " times." &lt;&lt; endl;

    for (unsigned long i = 0; i != value; i++)
    {
        // gets random values from 0 to 1 for (x) and (y)
        float x = randomFloat();
        float y = randomFloat();

        // checks if (x, y) are in a unit circle, if so increment circle area
        if (unit_circle(x, y))
            area_of_circle++;
        area_of_square++;
    }

    // pi = area of circle * 4 / area of square
    double calculatedPi = static_cast&lt;double&gt;(area_of_circle * 4) / area_of_square;

    float endTime = static_cast&lt;float&gt;(clock() - startTime) / CLOCKS_PER_SEC;

    // prints the value of calculated pi
    cout &lt;&lt; "\tCalculated Value of Pi: " &lt;&lt; calculatedPi &lt;&lt;
    " (" &lt;&lt; endTime &lt;&lt; " seconds, " &lt;&lt; endTime/60 &lt;&lt; " minutes)" &lt;&lt; endl;

    // difference between the calc value and pi
    cout &lt;&lt; "Estimated Num of Pi is off by " &lt;&lt; abs(calculatedPi - g_PI) &lt;&lt; '\n';
}

/**
 * returns a random number from 0 to 1
 */
float randomFloat()
{
    random_device rd;
    default_random_engine generator(rd()); // rd() provides a random seed
    uniform_real_distribution&lt;float&gt; distribution(0,1);

    float x = distribution(generator);

    return x;
}

/**
 * checks if the two input parameters are inside a unit circle
 */
bool unit_circle(float x, float y)
{
    if ((x*x + y*y) &lt;= 1)
        return true;
    else
        return false;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The main problem is that you're reseeding a random number generator for each random number in your C++ code. Additionally you're not compiling with optimizations enabled (<code>-O3</code>).</p>
<p>I moved the initialization of the random number generator outside the <code>randomFloat</code> function (equally, you could use <code>static</code> variables inside the function):</p>
<pre><code>random_device rd;
default_random_engine generator(rd()); // rd() provides a random seed
uniform_real_distribution&lt;float&gt; distribution(0,1);

float randomFloat() {
    float x = distribution(generator);
    return x;
}
</code></pre>
<p>and compiled with <code>-O3</code> and now C++ is considerably faster than Python</p>
<hr/>
<p>Another possibility could be that python and C++ code use a different random number generator. Python <a href="https://docs.python.org/3/library/random.html" rel="nofollow noreferrer"><code>random</code> module</a> (<a href="https://github.com/python/cpython/blob/master/Modules/_randommodule.c" rel="nofollow noreferrer">C code here</a>) uses a MT19937 <a href="https://en.wikipedia.org/wiki/Mersenne_Twister" rel="nofollow noreferrer">Mersenne Twister</a> random number generator that is a fast PRNG optimized specifically for numerical problems such as Monte Carlo; the algorithm of <code>default_random_engine</code> in C++ is implementation-defined. As pointed out by <a href="https://stackoverflow.com/users/996886/melak47">Melak47</a>, you can force the use of <a href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine" rel="nofollow noreferrer">MT19937</a> PRNG in C++ with:</p>
<pre><code>mt19937 generator(rd());
</code></pre>
<p>or</p>
<pre><code>mt19937_64 generator(rd());
</code></pre>
<hr/>
<p>P.S., Python outperforming C++ is not unheard of; the C++ algorithms value genericity whereas the Python algorithms are often quite optimized for some use cases. See for example this question on <a href="https://stackoverflow.com/questions/29058914/string-matching-performance-gcc-versus-cpython">substring matching</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The main cost is your randomFloat() c++ method.</p>
<p>building a random_device, default_random_engine and uniform_real_distribution every iteration is incredibly wasteful.</p>
<p>By making these static I was able to increase the speed of the c++ implementation by over a factor of 100. But you'd be better served injecting them, or wrapping this in a class and making them instance members.</p>
<pre><code>#include &lt;iostream&gt;                     // std library
#include &lt;random&gt;                       // random number generator
#include &lt;ctime&gt;                        // calculating runtime
#include &lt;cmath&gt;                        // absolute value function

using namespace std;

const double g_PI {3.141592653589793238463};

void simulate(unsigned long value);
float randomFloat();
bool unit_circle(float x, float y);

int main()
{
    // repitition values
    long values[5] = {1000, 10000, 100000, 1000000, 10000000};//, 100000000, 1000000000, 10000000000};

    // runs the simulation with the different repetition values
    for (auto value : values)
        simulate(value);

    cout &lt;&lt; "\nPress return to exit";
    cin.get();

    return 0;
}

/**
 * The actual simulation
 */
void simulate(unsigned long value)
{
    // start time for calculating runtime
    const clock_t startTime = clock();

    // area's variables
    unsigned long area_of_circle = 0;
    unsigned long area_of_square = 0;

    // print the repitiion value
    cout &lt;&lt; "\nProcessing calculations with a repetition value of " &lt;&lt; value &lt;&lt;
    " times." &lt;&lt; endl;

    for (unsigned long i = 0; i != value; i++)
    {
        // gets random values from 0 to 1 for (x) and (y)
        float x = randomFloat();
        float y = randomFloat();

        // checks if (x, y) are in a unit circle, if so increment circle area
        if (unit_circle(x, y))
            area_of_circle++;
        area_of_square++;
    }

    // pi = area of circle * 4 / area of square
    double calculatedPi = static_cast&lt;double&gt;(area_of_circle * 4) / area_of_square;

    float endTime = static_cast&lt;float&gt;(clock() - startTime) / CLOCKS_PER_SEC;

    // prints the value of calculated pi
    cout &lt;&lt; "\tCalculated Value of Pi: " &lt;&lt; calculatedPi &lt;&lt;
    " (" &lt;&lt; endTime &lt;&lt; " seconds, " &lt;&lt; endTime/60 &lt;&lt; " minutes)" &lt;&lt; endl;

    // difference between the calc value and pi
    cout &lt;&lt; "Estimated Num of Pi is off by " &lt;&lt; abs(calculatedPi - g_PI) &lt;&lt; '\n';
}

/**
 * returns a random number from 0 to 1
 */
float randomFloat()
{
    static random_device rd;
    static default_random_engine generator(rd()); // rd() provides a random seed
    static uniform_real_distribution&lt;float&gt; distribution(0,1);

    float x = distribution(generator);

    return x;
}

/**
 * checks if the two input parameters are inside a unit circle
 */
bool unit_circle(float x, float y)
{
    if ((x*x + y*y) &lt;= 1)
        return true;
    else
        return false;
}
</code></pre>
<hr/>
<p><strong><em>Original implmentation Log</em></strong></p>
<pre><code>Processing calculations with a repetition value of 1000 times.
    Calculated Value of Pi: 3.08 (0.019227 seconds, 0.00032045 minutes)
Estimated Num of Pi is off by 0.0615927

Processing calculations with a repetition value of 10000 times.
    Calculated Value of Pi: 3.124 (0.162044 seconds, 0.00270073 minutes)
Estimated Num of Pi is off by 0.0175927

Processing calculations with a repetition value of 100000 times.
    Calculated Value of Pi: 3.14568 (1.72181 seconds, 0.0286968 minutes)
Estimated Num of Pi is off by 0.00408735

//Couldn't be bothered to wait :P
</code></pre>
<p><strong><em>Using static random generator</em></strong></p>
<pre><code>Processing calculations with a repetition value of 1000 times.
    Calculated Value of Pi: 3.136 (0.000144 seconds, 2.4e-06 minutes)
Estimated Num of Pi is off by 0.00559265

Processing calculations with a repetition value of 10000 times.
    Calculated Value of Pi: 3.1824 (0.000596 seconds, 9.93333e-06 minutes)
Estimated Num of Pi is off by 0.0408073

Processing calculations with a repetition value of 100000 times.
    Calculated Value of Pi: 3.14044 (0.005889 seconds, 9.815e-05 minutes)
Estimated Num of Pi is off by 0.00115265

Processing calculations with a repetition value of 1000000 times.
    Calculated Value of Pi: 3.14278 (0.058896 seconds, 0.0009816 minutes)
Estimated Num of Pi is off by 0.00118335

Processing calculations with a repetition value of 10000000 times.
    Calculated Value of Pi: 3.14165 (0.589034 seconds, 0.00981723 minutes)
Estimated Num of Pi is off by 6.09464e-05
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not meant as an answer to your question why python is faster, just to show that python can get event faster and neater for this problem.</p>
<p>To possibilities to speed things up in python:</p>
<p>Use numpy vectorization:</p>
<pre><code>import numpy as np

def pi(N):
    x, y = np.random.uniform(-1, 1, size=(2, N))
    in_circle = np.sum(x**2 + y**2 &lt;= 1)
    return 4 * in_circle / N
</code></pre>
<p>And / or numba just in time compilation:</p>
<pre><code>from numba import jit
import random

@jit
def pi(N):
    in_circle = 0
    for i in range(N):
        x = 2 * random.random() - 1
        y = 2 * random.random() - 1

        if x**2 + y**2 &lt;= 1:
            in_circle += 1
     return 4 * in_circle / N
</code></pre>
</div>
<span class="comment-copy">The source code is obviously needed, I think.</span>
<span class="comment-copy">And, usually when C++ is slow that is because it is run in debug mode with  no optimizations enabled. So, how did you produce <code>a.out</code>?</span>
<span class="comment-copy">Try enabling compiler optimizations by compiling with <code>g++ -std=c++11 -O2 main.cpp</code></span>
<span class="comment-copy">Well in the C++ code you don't need to recreate the random device <code>rc</code> or the <code>generator</code> more than once. Doing that in a loop will slow things down. You might also want to experiment with the <code>inline</code> keyword to give hints to the compiler that the small function can be inlined. Lastly, the <code>unit_circle</code> function can be implemented as a single <code>return</code> statement.</span>
<span class="comment-copy">python is not faster than c++, it's your program in python is faster than your program in c++. Most probably it means you have low skills to write programs in c++. For example, in this case you using random number generator in completely wrong way and build program without optimization.</span>
<span class="comment-copy">I've also applied <code>std::mt19937</code>, and used <code>&lt;chrono&gt;</code> instead of <code>&lt;ctime&gt;</code> here: <a href="http://coliru.stacked-crooked.com/a/5196578dcc974518" rel="nofollow noreferrer">coliru.stacked-crooked.com/a/5196578dcc974518</a></span>
<span class="comment-copy">Thank you, the program is much faster now.</span>
