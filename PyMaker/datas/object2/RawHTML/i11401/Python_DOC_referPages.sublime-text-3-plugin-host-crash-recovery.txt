<div class="post-text" itemprop="text">
<p>I develop a plugin for Sublime Text 3 and my python code uses c type bindings to clang. Sometimes calling libclang would segfault with <code>libclang: crash detected during reparsing</code> (I don't understand the reason yet, but it is irrelevant to this question). This then leads to crashing plugin host.</p>
<p>So the question is: is there any way in python to recover from a failure in the underlying c binding? I would gladly just skip this action on this particular file where I experience the crash.</p>
<p>Thanks! </p>
<p>UPD: There was a short discussion in comments and it makes sense to elaborate further on the lack of a proper small reproducible example. It is not vecause of my laziness, I do try to make it as easy as possible to understand the issue for the people I expect help from. But in this case it is really hard. The original issue is caused by libclang segfaulting in some strange situation which I haven't nailed down yet. It probably has something to do with one library being compiled with no c++11 support and the other one using it while being compiled with c++11 support, but I want to emphasize - this is irrelevant to the question. The issue here is that there is a segfault in something that python is calling and this segfault causes Sublime Text plugin_host to exit. So there is simple example here, but not for the lack of trying. I am also open to suggestions if you have ideas how to construct one. And sorry for the poor quality of this question, this is currently my best.</p>
</div>
<div class="post-text" itemprop="text">
<p>Working with the detail that I have, I'm reasonably sure your question boils down to "can Python handle errors that occurred when using the foreign function interface."  </p>
<p>I'm pretty sure that the answer is "no", and I put together the following test scenario to explain why:</p>
<p>Here's our test C++ module (with a bit of C for name-mangling purposes) that will blow up in our face, <code>test.cc</code> :</p>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;iostream&gt;
#include &lt;signal.h&gt;

class Test{
    public:
        void test(){
            std::cout &lt;&lt; "stackoverflow" &lt;&lt; std::endl;
            // this will crash us. shouldn't really matter what SIG as long as it crashes Python
            raise (SIGABRT);
        }
};


extern "C" {
    Test* Test_new(){ return new Test(); }
    void Test_example(Test* test){ test-&gt;test(); }
}

clang -shared -undefined dynamic_lookup -o test.so test.cc
</code></pre>
<p>And our calling script, <code>test.py</code>:</p>
<pre class="lang-py prettyprint-override"><code>from ctypes import cdll

test_so = cdll.LoadLibrary("test.so")

class PyTest:
    def __init__(self):
        self.obj = test_so.Test_new()

    def output(self):
        test_so.Test_example(self.obj)

if __name__ == "__main__":
    p = PyTest()
    p.output()
</code></pre>
<p>Call it:</p>
<pre><code>Ξ /tmp/29_may → python test.py
stackoverflow
[1]    55992 abort      python test.py
</code></pre>
<p>This crashes Python as expected and generates a nice "report error" detail on OS X:</p>
<pre class="lang-none prettyprint-override"><code>Crashed Thread:        0  Dispatch queue: com.apple.main-thread

Exception Type:        EXC_CRASH (SIGABRT)
Exception Codes:       0x0000000000000000, 0x0000000000000000

Thread 0 Crashed:: Dispatch queue: com.apple.main-thread
0   libsystem_kernel.dylib          0x00007fff95bf48ea __kill + 10
1   test.so                         0x0000000110285006 Test::test() + 70
2   test.so                         0x0000000110284fb5 Test_example + 21
3   _ctypes.so                      0x000000011026d7c7 ffi_call_unix64 + 79
4   _ctypes.so                      0x000000011026dfe6 ffi_call + 818
5   _ctypes.so                      0x000000011026970b _ctypes_callproc + 867
6   _ctypes.so                      0x0000000110263b91 PyCFuncPtr_call + 1100
7   org.python.python               0x000000010fd18ad7 PyObject_Call + 99
8   org.python.python               0x000000010fd94e7f PyEval_EvalFrameEx + 11417
9   org.python.python               0x000000010fd986d1 fast_function + 262
10  org.python.python               0x000000010fd95553 PyEval_EvalFrameEx + 13165
11  org.python.python               0x000000010fd91fb4 PyEval_EvalCodeEx + 1387
12  org.python.python               0x000000010fd91a43 PyEval_EvalCode + 54
13  org.python.python               0x000000010fdb1816 run_mod + 53
14  org.python.python               0x000000010fdb18b9 PyRun_FileExFlags + 133
15  org.python.python               0x000000010fdb13f9 PyRun_SimpleFileExFlags + 711
16  org.python.python               0x000000010fdc2e09 Py_Main + 3057
17  libdyld.dylib                   0x00007fff926d15ad start + 1
</code></pre>
<p>I copy and pasted this because it's cleaner/easier to parse than an strace (also, I'm lazy ;).
The call to <code>__kill</code> is where we crashed; we never see a return to Python, which means it's out of our control.</p>
<p>To prove this, modify our <code>test.py</code> into <code>test_handle_exception.py</code> to try to catch the exception:</p>
<pre class="lang-py prettyprint-override"><code>from ctypes import cdll

test_so = cdll.LoadLibrary("test.so")

class PyTest:
    def __init__(self):
        self.obj = test_so.Test_new()

    def output(self):
        test_so.Test_example(self.obj)

if __name__ == "__main__":
    p = PyTest()

    try:
        p.output()
    except:
        print("If you're reading this, we survived somehow.")
</code></pre>
<p>And running it again:</p>
<pre><code>Ξ /tmp/29_may → python test_handle_exception.py
stackoverflow
[1]    56297 abort      python test_handle_exception.py
</code></pre>
<p>Unfortunately, and as far as I know, we cannot catch the exception/crash at the Python layer because it happened "beneath" the control of bytecode.  A non-specific <code>Exception</code> clause will try to catch <em>any</em> exception that occurs, where the following statement is the action taken when an exception gets caught. <code>If you're reading this, we survived somehow.</code> was never sent to stdout, and we crashed, which means Python doesn't get a chance to react.</p>
<p>If you can, handle this exception in your C++ code.  You may be able to get creative and use <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow">multiprocessing</a> to fork into a process that can crash without taking down your main process, but I doubt it.</p>
</div>
<span class="comment-copy">Questions seeking debugging help (<b>"why isn't this code working?"</b>) must include the desired behavior, <i>a specific problem or error</i> and <i>the shortest code necessary</i> to reproduce it <b>in the question itself</b>. Questions without <b>a clear problem statement</b> are not useful to other readers. See: <a href="http://stackoverflow.com/help/mcve">How to create a Minimal, Complete, and Verifiable Example</a>.</span>
<span class="comment-copy">@MattDMo thank you for the suggestion, I always try to do a simple example but in this case I do not know how. I am not an expect in python, so it is hard to create an example that would fail sublime. I just know that it should happen should the c library used from python end in a segfault. I am sorry for the poor quality of this question, but I cannot do it better, so any suggestions would be welcome!</span>
<span class="comment-copy">I'm a bit skeptical about "<i>What is the error?</i>" being irrelevant to "<i>How to recover from the error?</i>". Or that lack of any details is necessary.</span>
<span class="comment-copy">@AndrasDeak this is a valid point. I would love to provide the details, but the original issue of the fail is another esoteric issue connected to libclang. It is connected to one library being compiled with c++11 support and then trying to use this library while compiling code with c++11. At least that is my best guess for now. So it is hard for me to frame this better. I do understand that this sounds sketchy, but that's really all I have now and not for the lack of trying. Ultimately, there is a segfault in c code called from python.</span>
<span class="comment-copy">@niosus is there <i>any</i> way you can provide a way for others to reproduce this? I think that's the fundamental issue with the question - we'd love to help you, but without a way to reproduce what you're seeing, we just can't, and the question is off-topic.</span>
<span class="comment-copy">awesome, this is the example I've hoped for. I somehow tried to to the same with dereferencing NULL, but that didn't seem to work. Didn't think about raise. So you say, that we cannot do much about the code failing under python, right?</span>
<span class="comment-copy">@niosus glad I could help you. I'd follow the advice in Andras Deak's and MattDmo's comments as it's possible there's something specific to your scenario that could help someone help you.  Re: handling failing C/C++ code at the Python layer: no, unfortunately, and as far as I know, Python doesn't have a chance to handle the exception.  If you track down what causes the segfault, you could maybe write a C++ function to handle that error (realistically: probably not), but that might be more effort than addressing the root cause.</span>
<span class="comment-copy">I believe, that despite the poor quality of the question you nailed the cause and provided the example that I should have provided in the first place. This is definitely an answer to my question, even though it is a negative one. Thanks a lot. As for the root cause, I will either find ways to solve it or to showcase it to ask about it here. For now it is too esoteric to me and doesn't happen always.</span>
<span class="comment-copy">Glad I could help -- sometimes it's difficult to know what detail to include.  Good luck with your plugin.</span>
<span class="comment-copy">@niosus (and tristan) unfortunately, Sublime Text 3's internal version of Python that it uses for running plugin code does not contain the <code>multiprocessing</code> module, so that suggestion's a no-go. However, it <i>does</i> include <a href="https://docs.python.org/3.3/library/threading.html" rel="nofollow noreferrer"><code>threading</code></a>, and <code>plugin_host</code> is (generally) thread-safe, so that <i>might</i> be a way to go. However, as mentioned in the answer, it's possible that you'll just have to pin down where the segfault is occurring and add appropriate error handing there in C++.</span>
