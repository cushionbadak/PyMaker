<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6114251/how-to-make-name-main-when-running-module">How to make __name__ == '__main__' when running module</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>I have a python script (actually, lots of scripts) with code that is executed only when this module is run as the main script:</p>
<pre><code>if __name__ == '__main__':
    print("I am the main script")
</code></pre>
<p>But now I want a testing script to load them as modules, so that it can then poke in their internal state. Rewriting (to turn the code block into a function) is not an option. How do I import a module in such a way that it thinks its name is <code>__main__</code>? I'm sure I've seen this done before, with the help of some import library or other, but it's not coming up in my searches.</p>
</div>
<div class="post-text" itemprop="text">
<p>You'd have to bypass the import machinery, and use <code>exec</code> instead:</p>
<pre><code>import imp

main = imp.new_module('__main__')
with open(module_filename, 'r') as source:
    exec(source.read(), vars(main))
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; source = '''\
... if __name__ == '__main__':
...     print("I am the main script")
... '''
&gt;&gt;&gt; import imp
&gt;&gt;&gt; main = imp.new_module('__main__')
&gt;&gt;&gt; exec(source, vars(main))
I am the main script
</code></pre>
<p>Rather than go this route, consider creating a function you call from the <code>__main__</code> guard instead, so you can just import that function for testing:</p>
<pre><code>def main():
    print("I am the main script")

if __name__ == '__main__':
    main()
</code></pre>
</div>
<span class="comment-copy">Use <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer"><code>importlib</code></a></span>
<span class="comment-copy">It's a common approach to test these things via a site-local standard that you use <code>if __name__ == '__main__': main()</code>, making the main function callable.</span>
<span class="comment-copy">@Charles indeed that would eliminate the problem. But this is about dozens of student assignments, and I haven't told them to wrap their code in <code>main()</code>.</span>
<span class="comment-copy">I guess my question is a duplicate. Here's the solution: <a href="http://stackoverflow.com/a/6114411/699305">stackoverflow.com/a/6114411/699305</a></span>
<span class="comment-copy">Looks good, but is there really no simpler way? I could swear I've seen it done in one step...</span>
<span class="comment-copy">Found it! <a href="http://stackoverflow.com/a/6114411/699305">stackoverflow.com/a/6114411/699305</a>. Ok it's two lines, not one.</span>
<span class="comment-copy">@alexis: ah, yes, <code>imp.find_module()</code> avoids the need to know the filename up front and <code>imp.load_module()</code> does basically what I do with <code>imp.new_module()</code> and <code>exec()</code> above, with added support for loading a <code>.pyc</code> file if it is available.</span>
