<div class="post-text" itemprop="text">
<p>I have a python script named "prog.py". I want to add a feature that opens a new process that watches the operation of the current script. When the script terminates, the process recognizes the termination and then invokes a certain function. Here is a pseudo-code:</p>
<pre><code>while (script is active):    

    sleep(1) # check its status once a second

func()
</code></pre>
<p>Do you have any idea how to do it? </p>
</div>
<div class="post-text" itemprop="text">
<p>Is there a reason the other process needs to be launched first? Seems like you could do this more efficiently and reliably by just <a href="https://docs.python.org/3/library/os.html#os.execl" rel="nofollow"><code>exec</code>ing</a> when the first process completes. For example:</p>
<pre><code>import atexit
import os

atexit.register(os.execlp, 'afterexitscript.py', 'afterexitscript.py', 'arg1', 'arg2')
</code></pre>
<p>When the current Python process exits, it will seamlessly replace itself with your other script, which need not go to the trouble of including a polling loop. Or you could just use <a href="https://docs.python.org/3/library/atexit.html" rel="nofollow"><code>atexit</code></a> to execute whatever <code>func</code> is directly in your main script and avoid a new Python launch.</p>
</div>
<span class="comment-copy">+1 for the last sentence.  Just use <code>atexit</code>, and don't bother with processes unless there is a specific reason you have to.</span>
<span class="comment-copy">The problem is with the following note in atexit documentation:  " The functions registered via this module are not called when the program is killed by a signal not handled by Python, when a Python fatal internal error is detected, or when os._exit() is called."  I'm looking for a solution that work in any case of script termination...</span>
<span class="comment-copy">@CrazySynthax: In that case, it would still be simpler to have the monitor process manage the "main" process, rather than the "main" process spawning a monitor that then tries to monitor the main process in turn. The former is a dead simple use of <code>subprocess</code>, the latter involves generally non-portable OS specific process detach steps and rigmarole.</span>
