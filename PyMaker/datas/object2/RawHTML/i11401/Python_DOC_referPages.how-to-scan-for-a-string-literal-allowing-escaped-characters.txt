<div class="post-text" itemprop="text">
<p>I would like to parse an input string and determine if it contains a sequence of characters surrounded by double quotes (<code>"</code>).
The sequence of characters itself is not allowed to contain further double quotes, unless they are escaped by a backslash, like so: <code>\"</code>.</p>
<p>To make things more complicated, the backslashes can be escaped themselves, like so: <code>\\</code>. A double quote preceded by two (or any even number of) backslashes (<code>\\"</code>) is therefore not escaped.
And to make it even worse, single non-escaping backslashes (i.e. followed by neither <code>"</code> nor <code>\</code>) are allowed.</p>
<p>I'm trying to solve that with Python's <code>re</code> module.
The <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">module documentation</a> tells us about the pipe operator <code>A|B</code>:</p>
<blockquote>
<p>As the target string is scanned, REs separated by <code>'|'</code> are tried from left to right. When one pattern completely matches, that branch is accepted. This means that once <code>A</code> matches, <code>B</code> will not be tested further, even if it would produce a longer overall match. In other words, the <code>'|'</code> operator is never greedy.</p>
</blockquote>
<p>However, this doesn't work as I expected:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.match(r'"(\\[\\"]|[^"])*"', r'"a\"')
&lt;_sre.SRE_Match object; span=(0, 4), match='"a\\"'&gt;
</code></pre>
<p>The idea of this regex is to first check for an escaped character (<code>\\</code> or <code>\"</code>) and only if that's not found, check for any character that's not <code>"</code> (but it could be a single <code>\</code>).
This can occur an arbitrary number of times and it has to be surrounded by literal <code>"</code> characters.</p>
<p>I would expect the string <code>"a\"</code> not to match at all, but apparently it does.
I would expect <code>\"</code> to match the <code>A</code> part and the <code>B</code> part not to be tested, but apparently it is.</p>
<p>I don't really know how the backtracking works in this very case, but is there a way to avoid it?</p>
<p>I guess it would work if I check first for the initial <code>"</code> character (and remove it from the input) in a separate step.
I could then use the following regular expression to get the content of the string:</p>
<pre><code>&gt;&gt;&gt; re.match(r'(\\[\\"]|[^"])*', r'a\"')
&lt;_sre.SRE_Match object; span=(0, 3), match='a\\"'&gt;
</code></pre>
<p>This would include the escaped quote. Since there wouldn't be a closing quote left, I would know that overall, the given string does not match.</p>
<p>Do I have to do it like that or is it possible to solve this with a single regular expression and no additional manual checking?</p>
<p>In my real application, the <code>"</code>-enclosed string is only one part of a larger pattern, so I think it would be simpler to do it all at once in a single regular expression.</p>
<p>I found similar questions, but those don't consider that a single non-escaping backslash can be part of the string: <a href="https://stackoverflow.com/q/10208694/500098">regex to parse string with escaped characters</a>, <a href="https://stackoverflow.com/q/25163186/500098">Parsing for escape characters with a regular expression</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you use <code>"(\\[\\"]|[^"])*"</code>, you match <code>"</code> followed by 0+ sequences of <code>\</code> followed by either <code>\</code> or <code>"</code>, or non-<code>"</code>, and then followed by a "closing" <code>"</code>. Note that when your input is <code>"a\"</code>, the <code>\</code> is matched by the second alternative branch <code>[^"]</code> (as the backslash is a valid non-<code>"</code>).</p>
<p>You need to exclude the <code>\</code> from the non-<code>"</code>:</p>
<pre><code>"(?:[^\\"]|\\.)*"
      ^^
</code></pre>
<p>So, we match <code>"</code>, then either non-<code>"</code> and non-<code>\</code> (with <code>[^\\"]</code>) or any escape sequence (with <code>\\.</code>), 0 or more times.</p>
<p>However, this regex is not efficient enough as there is much backtracking going on (caused by the alternation and the quantifier). Unrolled version is:</p>
<pre><code>"[^"\\]*(?:\\.[^"\\]*)*"
</code></pre>
<p>See the <a href="https://regex101.com/r/zI2gK8/2" rel="nofollow">regex demo</a></p>
<p>The last pattern matches:</p>
<ul>
<li><code>"</code> - a double quote</li>
<li><code>[^"\\]*</code> - zero or more characters other than <code>\</code> and <code>"</code></li>
<li><code>(?:\\.[^"\\]*)*</code> - zero or more sequences of

<ul>
<li><code>\\.</code> - a backslash followed with any character but a newline</li>
<li><code>[^"\\]*</code> - zero or more characters other than <code>\</code> and <code>"</code> </li>
</ul></li>
<li><code>"</code> - a double quote</li>
</ul>
</div>
<span class="comment-copy">See this: <code>"(?:[^\\"]|\\.)*"</code> --&gt; <code>"[^"\\]*(?:\\.[^"\\]*)*"</code></span>
<span class="comment-copy">Thanks, that works great! What do you mean by the arrow? Is one of the alternatives better than the other? Are they exactly equivalent?</span>
<span class="comment-copy">Yes, there is a difference. All right, let me put that as an answer, since that works for you.</span>
<span class="comment-copy">That's definitely the way to go, but I'm still wondering why my original expression matches <code>\</code> instead of <code>\"</code>, where latter is <code>A</code> (on the left side of <code>|</code>). The docs say "once <code>A</code> matches, <code>B</code> will not be tested further". How comes that <code>B</code> matches in this case?</span>
<span class="comment-copy">The answer is: backtracking makes it possible for the <code>[^"]</code> to match <code>\</code>, not <code>\"</code>. Your <code>\\["\\]</code> is the first and after <code>"a</code> are matched with 2 passes of <code>[^"]</code> the <code>\"</code> are grabbed by the first alternative. BUT, the last <code>"</code> is <i>obligatory</i>, it means the regex engine will try to re-group the captured values it found so far to accommodate some place for the <code>"</code>. The engine backtracks, and finds a <code>\</code> before <code>"</code> that can be matched with the second alternative branch <code>[^"]</code>. See <a href="https://regex101.com/r/dZ4bB2/2" rel="nofollow noreferrer">your regex in action</a>, Steps 12, 13 on the <i>regex debugger</i> page.</span>
<span class="comment-copy">Thanks for the explanation, now I think I understand! I'm new to this whole regex thing and I didn't know the <i>regex debugger</i>, which is a really great tool for understanding how those regexes work.</span>
<span class="comment-copy">Great I could help. The backtracking is both good and evil in regex, you will quickly realize it. Unfortunately, <code>re</code> Python module does not support possessive quantifiers, nor atomic groups (you can use them with the <a href="https://pypi.python.org/pypi/regex" rel="nofollow noreferrer">PyPi <code>regex</code> module</a> though), then, you could prevent this, e.g. <a href="https://regex101.com/r/dD9xW3/1" rel="nofollow noreferrer"><code>"(\\[\\"]|[^"])*+"</code></a>. Another way is through backreferences/capturing inside a positive lookahead: <a href="https://regex101.com/r/dD9xW3/2" rel="nofollow noreferrer"><code>"(?:(?=(\\[\\"]|[^"]))\1)*"</code></a> (this will work even with Python <code>re</code>).</span>
