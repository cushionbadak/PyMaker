<div class="post-text" itemprop="text">
<p>I want an array X of shape (n_samples,n_cols,n_rows,n_channels). I want an array y with a shape (n_sample,n_cols,n_rows,n_channels)</p>
<p>I have tried </p>
<pre><code>import glob
from skimage import io, color
import numpy as np

def loadfunc(files)
    for fl in files:
        img = color.rgb2lab(io.imread(fl))
        L = img[:,:,:1]
        ab = img[:,:,1:]
        yield L,ab

X,y = np.fromiter(loadfunc(glob.glob('path/to/images/*.png')),float)
</code></pre>
<p>and I get this error: ValueError: setting an array element with a sequence.</p>
<p>I figure this must be a somewhat common operation - any time someone wants to load image data into an array in numpy so there must be something Im missing? </p>
</div>
<div class="post-text" itemprop="text">
<p><code>np.fromiter</code> requires that you state the dtype. If you use <code>dtype=float</code>, then each value from the iterable must be a float. If you yield single NumPy arrays from <code>loadfunc</code>, you could use their <code>flat</code> attribute to obtain iterators over the flatten array values which could be concatenated with <code>itertools.chain.from_iterable</code> and then passed to <code>np.fromiter</code>:</p>
<pre><code>def loadfunc(files):
    for fl in files:
        img = skcolor.rgb2lab(skio.imread(fl)[..., :3])
        yield img

arrs = loadfunc(files)
Z = np.fromiter(IT.chain.from_iterable([arr.flat for arr in arrs]), dtype=float)
</code></pre>
<p>Since <code>np.fromiter</code> returns a 1D array, you would then need to reshape it:</p>
<pre><code>Z = Z.reshape(len(files), h, w, n)
</code></pre>
<p>Note that this relies on each image having the same shape.
Finally, to load the <code>L</code> values into <code>X</code> and the <code>ab</code> values into <code>y</code>:</p>
<pre><code>X = Z[..., :1]
y = Z[..., 1:]
</code></pre>
<hr/>
<pre><code>import glob
import itertools as IT
import numpy as np
import skimage.io as skio
import skimage.color as skcolor

def loadfunc(files):
    for fl in files:
        img = skcolor.rgb2lab(skio.imread(fl)[..., :3])
        yield img

files = glob.glob('path/to/images/*.png')
arrs = loadfunc(files)
first = next(arrs)
h, w, n = first.shape

Z = np.fromiter(IT.chain.from_iterable(
    [first.flat] + [arr.flat for arr in arrs]), dtype=float)
Z = Z.reshape(len(files), h, w, n)
X = Z[..., :1]
y = Z[..., 1:]
</code></pre>
<hr/>
<p>Regarding the <a href="https://stackoverflow.com/questions/37379696/how-do-i-load-a-list-of-images-into-an-array-for-each-channel-in-numpy/37380070?noredirect=1#comment62271684_37380070">question in the comments</a>:</p>
<blockquote>
<p>If I wanted to do extra processing to L and ab, where would I do that?</p>
</blockquote>
<p>I believe in separating the loading from the processing of the data. By keeping the two functions distinct, you leave open the possibility of passing different data from different sources to the same processing function. If you put both the loading and the processing of the data (such as a KNN classification of the ab values) into <code>loadfunc</code> then there is no way to reuse the KNN classification code without loading the data from files.</p>
<hr/>
<p>If you allow us to change the order of the axes from 
<code>(n_samples, n_cols, n_rows, n_channels)</code> to
<code>(n_cols, n_rows, n_channels, n_samples)</code>,
then the code could be simplified using <code>np.stack</code>:</p>
<pre><code>import glob
import numpy as np
import skimage.io as skio
import skimage.color as skcolor

def loadfunc(files):
    for fl in files:
        img = skcolor.rgb2lab(skio.imread(fl)[..., :3])
        yield img

files = glob.glob('path/to/images/*.png')
Z = np.stack(loadfunc(files), axis=-1)
X = Z[..., :1, :]
Y = Z[..., 1:, :]
</code></pre>
<p>This code is simpler and therefore preferable to the code (using <code>np.fromiter</code>) above. </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.fromiter.html" rel="nofollow"><code>numpy.fromiter</code></a> does not support simultaneous array creation and then return them as a tuple, (to be unpacked into <code>X,y</code>)  It is possible there is a way to do this in <code>np</code> but not to my knowledge, you may need to split the iterator into a <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow"><code>tee</code></a> instead</p>
<pre><code># the built in map in python 3 uses iteration,
# uncomment the added imap import if you are using python 2
from itertools import tee #, imap as map

from operator import itemgetter

iter_a, iter_b = tee(loadfunc(glob.glob('path/to/images/*.png')))

X = np.fromiter(map(itemgetter(0),iter_a), float) #array from the first elements
y = np.fromiter(map(itemgetter(1),iter_b), float) #array from the second elements
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Usually when we create an array with iteration we either collect the values in a list, and create the array from that.  Or we allocate an empty list and assign values to slots.</p>
<p>Here's a way of doing the assignment, where the generator returns a tuple of arrays:</p>
<pre><code>def mk_array(N):
    for i in range(N):
        img=np.ones((2,3,3),int)
        L=img[:,:,:1]*i
        ab=img[:,:,1:].astype(float)*i/10
        yield L,ab
</code></pre>
<p>I made one an array of ints, the other an array of floats.  That reduces the temptation to concatenate them into one.        </p>
<pre><code>In [157]: g=mk_array(4)

In [158]: for i,v in enumerate(g):
    print(v[0].shape,v[1].shape)
   .....:     
(2, 3, 1) (2, 3, 2)
(2, 3, 1) (2, 3, 2)
(2, 3, 1) (2, 3, 2)
(2, 3, 1) (2, 3, 2)
</code></pre>
<p>Lets allocate target arrays of the right shape; here I put the iteration axis 3rd, but it could be anywhere</p>
<pre><code>In [159]: L, ab = np.empty((2,3,4,1),int), np.empty((2,3,4,2),float)

In [160]: for i,v in enumerate(g):
    L[...,i,:], ab[...,i,:] = v
</code></pre>
<p>My guess this is as fast as any <code>fromiter</code> or <code>stack</code> alternative.  And when the components are generated by reading from files, that step is bound to be the most expensive - more so than the iteration mechanism or array copies.</p>
<p>================</p>
<p>If the iterator returned a tuple of scalars, we can use <code>fromiter</code>:</p>
<pre><code>def mk_array1(N):
    for i in range(N):
        img=np.ones((2,3,3),int)
        L=img[:,:,:1]*i
        ab=img[:,:,1:].astype(float)*i/10
        for i,j in zip(L.ravel(),ab.ravel()):
            yield i,j

In [184]: g=mk_array1(2)

In [185]: V=np.fromiter(g,dtype=('i,f'))
</code></pre>
<p>producing a 1d structured array:</p>
<pre><code>In [186]: V
Out[186]: 
array([(0, 0.0), (0, 0.0), (0, 0.0), (0, 0.0), (0, 0.0), (0, 0.0),
       (1, 0.10000000149011612), (1, 0.10000000149011612),
       (1, 0.10000000149011612), (1, 0.10000000149011612),
       (1, 0.10000000149011612), (1, 0.10000000149011612)], 
      dtype=[('f0', '&lt;i4'), ('f1', '&lt;f4')])
</code></pre>
<p>which can be reshaped, and arrays separated by field name:</p>
<pre><code>In [187]: V['f0']
Out[187]: array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], dtype=int32)

In [188]: V.reshape(2,2,3)['f0']
Out[188]: 
array([[[0, 0, 0],
        [0, 0, 0]],

       [[1, 1, 1],
        [1, 1, 1]]], dtype=int32)

In [189]: V.reshape(2,2,3)['f1']
Out[189]: 
array([[[ 0. ,  0. ,  0. ],
        [ 0. ,  0. ,  0. ]],

       [[ 0.1,  0.1,  0.1],
        [ 0.1,  0.1,  0.1]]], dtype=float32)
</code></pre>
<p>================</p>
<p>What if I define a more complex <code>dtype</code>, one where each field has an array:</p>
<pre><code>In [200]: dt=np.dtype([('f0',int,(2,3,1)),('f1',float,(2,3,2))])

In [201]: g=mk_array(2)   # the original generator

In [202]: V=np.fromiter(g,dtype=dt)

In [203]: V['f0']
Out[203]: 
array([[[[0],
         [0],
         [0]],
        ....

        [[1],
         [1],
         [1]]]])

In [204]: _.shape
Out[204]: (2, 2, 3, 1)
</code></pre>
<p>This use of a compound dtype with <code>fromiter</code> is also described in <a href="https://stackoverflow.com/a/12473478/901925">https://stackoverflow.com/a/12473478/901925</a></p>
<p>This is, in effect, a variation on the usual way of building a structured array - from a list of tuples.  More than once I've use the expression:</p>
<pre><code>np.array([tuple(x)  for x in something], dtype=dt)
</code></pre>
<p>In sum we can time two methods of creating 2 arrays:</p>
<pre><code>def foo1(N):
    g = mk_array(N)                                       
    L, ab = np.empty((N,2,3,1),int), np.empty((N,2,3,2),float)
    for i,v in enumerate(g):
        L[i,...], ab[i,...] = v
    return L, ab

def foo2(N):
    dt=np.dtype([('f0',int,(2,3,1)),('f1',float,(2,3,2))])
    g = mk_array(N)
    V=np.fromiter(g, dtype=dt)
    return V['f0'], V['f1']
</code></pre>
<p>For a wide range of <code>N</code> these 2 functions take nearly the same time.  I have to push run times to 1s before I starting an advantage for <code>foo1</code>.</p>
</div>
<span class="comment-copy">sorry, added import statements</span>
<span class="comment-copy"><a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.fromiter.html" rel="nofollow noreferrer"><code>np.fromiter</code></a> takes an iterable that produces the elements of an array, <i>one array</i>.  So your code is actually trying to make an array of 2 element tuples.... I'm trying to find a way to do what you are trying now...</span>
<span class="comment-copy">Do you want <code>X</code> to contain the <code>L</code> arrays, and <code>y</code> the <code>ab</code> arrays?</span>
<span class="comment-copy">@unutbu yes thats the goal</span>
<span class="comment-copy"><b>for any future viewer</b> that is trying to make multidimensional arrays with <code>fromiter</code> please refer to <a href="http://stackoverflow.com/questions/12467743/how-to-construct-an-np-array-with-fromiter">How to construct an np.array with fromiter</a> (assuming the answer here doesn't help you)</span>
<span class="comment-copy">If I wanted to do extra processing to L and ab, where would I do that? For instance, I would like to perform a KNN classification on the ab values. Computationally, does it make more sense to do what you suggested and then pull Y apart and form an additional array from the classifications? Or does it make more sense to do that before Y is created? If I wanted to do this, where would I - something like @Tadhg McDonald-Jensen suggests below?</span>
<span class="comment-copy">I assume the above comment was referring to <a href="http://stackoverflow.com/questions/37379696/how-do-i-load-a-list-of-images-into-an-array-for-each-channel-in-numpy/37379875?noredirect=1#comment62270895_37379875">this comment</a> which is actually <i>above</i> here in my browser.</span>
<span class="comment-copy">@BigBoy1337: I think it is preferable to separate the loading from the processing of the data. I add a few words explaining why, above.</span>
<span class="comment-copy">hmm so would loadfunc still yield X and y in each iteration like the function I have in my question?</span>
<span class="comment-copy">yes, I was making an assumption that <code>loadfunc</code> might actually be a lot bigger / complicated so I suggested an edit that doesn't require rewriting it at all, you could also rework <code>loadfunc</code> to only produce one or the other depending on an additional argument. And then call it twice.</span>
<span class="comment-copy">hmm can you run this successfully? I am still getting this when I try and run this: ValueError: setting an array element with a sequence. I believe it is on the last 2 lines for setting X and y</span>
<span class="comment-copy">I wasn't because <code>color.rgb2lab(io.imread(fl))</code> kept failing with the images I was testing but I found one that worked and yes I got the same error, actually I got the same error without any special stuff, just <code>yield L</code> and <code>X = np.fromiter(iter_a, float)</code> so I tried searching "numpy fromiter 2d" and found <a href="http://stackoverflow.com/questions/12467743/how-to-construct-an-np-array-with-fromiter">this very relevent question</a></span>
<span class="comment-copy">@BigBoy1337 it seems that <code>fromiter</code> is only capable of creating 1D results...</span>
