<div class="post-text" itemprop="text">
<p>My problem is simple: I have a list of dicts, and I want to make a count aggregation of this into a new dictionary, on a particular key. Just like <a href="https://stackoverflow.com/questions/17873046/best-way-to-aggregate-a-list-of-items-and-collect-totals">this</a>, but in Python.</p>
<h2>Original data</h2>
<pre><code>mylist = [
    {'date': '16-01-2016', 'name': 'A'},
    {'date': '16-01-2016', 'name': 'B'},
    {'date': '17-01-2016', 'name': 'C'},
    {'date': '17-01-2016', 'name': 'D'},
    {'date': '17-01-2016', 'name': 'E'},
    {'date': '18-01-2016', 'name': 'F'},
]
</code></pre>
<h2>Result</h2>
<pre><code>{'17-01-2016': 3, '16-01-2016': 2, '18-01-2016': 1}
</code></pre>
<h2>How to?</h2>
<p>What is the best solution to achieve this? I would like to do it a more beautiful and pythonic way than that ugly piece of code:</p>
<pre><code>result = {}
for item in mylist:
    if not item['date'] in result:
        result[item['date']] = 1
    else:
        result[item['date']] += 1
</code></pre>
<p>Many thanks for considering my request!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><em>collections.Counter</em></a> dict with <em>map</em> and <a href="https://docs.python.org/3/library/operator.html" rel="nofollow"><em>operator.itemgetter</em></a>:</p>
<pre><code>from collections import Counter
from operator import itemgetter

mylist = [
    {'date': '16-01-2016', 'name': 'A'},
    {'date': '16-01-2016', 'name': 'B'},
    {'date': '17-01-2016', 'name': 'C'},
    {'date': '17-01-2016', 'name': 'D'},
    {'date': '17-01-2016', 'name': 'E'},
    {'date': '18-01-2016', 'name': 'F'},
]

counts = Counter(map(itemgetter("date"), mylist))
</code></pre>
<p>Output:</p>
<pre><code>Counter({'17-01-2016': 3, '16-01-2016': 2, '18-01-2016': 1})
</code></pre>
<p>Or using just a gen exp:</p>
<pre><code>counts = Counter(d["date"] for d in mylist)
</code></pre>
<p>If you are using <em>python2</em>, use <a href="https://docs.python.org/2/library/itertools.html#itertools.imap" rel="nofollow">itertools.imap</a> in place of map.</p>
<p>On a side note, <code>if item['date'] not in result</code> reads better than <code>if not item['date'] in result</code>.</p>
<p>If speed really matters, the map and itemgetter will be a little faster:</p>
<pre><code>In [16]: timeit  Counter(map(itemgetter("date"), mylist))
10 loops, best of 3: 23.9 ms per loop

In [17]: timeit  Counter(d["date"] for d in mylist)
10 loops, best of 3: 26.8 ms per loop

In [18]: timeit Counter(map(lambda x: x['date'], mylist))
10 loops, best of 3: 34.9 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a <code>Counter</code></p>
<pre><code>from collections import Counter 

Counter(map(lambda x: x['date'], mylist))
# Counter({'17-01-2016': 3, '16-01-2016': 2, '18-01-2016': 1})
</code></pre>
<p><code>Counter</code> is a <code>dict</code> subclass, so you don't have to worry about having <code>Counter</code> prefixing your printed result. </p>
</div>
<span class="comment-copy">I'm partial to the generator expression version -- fewer imports, shorter code, easier to read ... What's not to like?  :-).</span>
<span class="comment-copy">@mgilson,  some folk,  including myself like the old functional approach ;) I also knew map would rear its head at some stage and most likely with a lambda.</span>
