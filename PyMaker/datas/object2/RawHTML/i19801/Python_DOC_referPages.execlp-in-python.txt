<div class="post-text" itemprop="text">
<p>I was reading programming python 4th edition by Mark Luze, Oreilly, by teaching myself.
There's an example on how to fork a child process, which I do not quite understand:</p>
<pre><code>os.execlp('python', 'python', 'child.py', #other args#)
</code></pre>
<p>In an interactive shell(like bash), I know I can type <code>python child.py #args#</code> to ask python interpreter to run child.py with args.
Why are there TWO 'python' in the execlp() function? If I put only one python in the function, I would get an error complainting cannot find file or directory, which is the 1st args of child.py</p>
</div>
<div class="post-text" itemprop="text">
<p>The first argument is the program to execute (found on the <code>PATH</code>). The rest are the <code>sys.argv</code> arguments to the program.</p>
<p>The <em>first</em> such argument is the program name used to invoke it, and the display value used in the OS process list. It is the value of <code>sys.argv[0]</code> in a python script.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, <code>execlp</code> is rarely used today. In most cases, you'd use the <a href="http://docs.python.org/3/library/subprocess.html" rel="nofollow">subprocess</a> module, like this:</p>
<pre><code>subprocess.call(['python', 'child.py'])
</code></pre>
<p>The first argument of <a href="http://linux.die.net/man/3/execlp" rel="nofollow"><code>execlp</code></a> is the file you want to execute.</p>
<p>The latter arguments form the argument array to that program (<a href="http://docs.python.org/3/library/sys.html#sys.argv" rel="nofollow"><code>sys.argv</code></a> in Python). The first argument is then the name the program got invoked with. For example, Python sets the name to <code>'-c'</code> if the program is being run with the <code>-c</code> option. Similarly, <a href="http://linux.die.net/man/1/grep" rel="nofollow">grep</a> behaves differently depending on the first argument, so that users can execute <code>rgrep</code> to imply <code>grep -r</code>.</p>
</div>
<span class="comment-copy">This originates in the <code>execlp</code> libc funciton, which you can get more info about using the command <code>man execlp</code>.</span>
<span class="comment-copy">Here's the Open Group spec for the <a href="http://pubs.opengroup.org/onlinepubs/009604499/functions/exec.html" rel="nofollow noreferrer">exec family</a> of POSIX functions. The general pattern of fork/exec in Unix hasn't changed much in 40 years.</span>
<span class="comment-copy">Yeah. I got it. The 1st python is python file path, 2nd python is argv[0], and the rests are more args.</span>
<span class="comment-copy">It's a pity this got downvoted, it looks as if <a href="http://stackoverflow.com/questions/14174366/when-using-os-execlp-why-python-need-python-as-argv0/">someone misunderstood this answer</a>.</span>
<span class="comment-copy">I wouldn't assume that the latest edition is outdated -- it was published seven years after the <code>subprocess</code> module was included in the standard library.  It may be demonstrating how <code>fork()</code> and <code>exec()</code> work if you ever need to dig deeper.</span>
<span class="comment-copy">@DietrichEpp Yeah, you're right. Updated.</span>
<span class="comment-copy">thanks all the same</span>
<span class="comment-copy">subprocess.call does not replace the current process with the process it calls, which is an essential element of using execlp. subprocess.call is not a replacement for execlp.</span>
