<div class="post-text" itemprop="text">
<p><a href="http://www.python.org/dev/peps/pep-0412/">PEP 412</a>, implemented in Python 3.3, introduces improved handling of attribute dictionaries, effectively reducing the memory footprint of class instances.  <a href="http://docs.python.org/3/reference/datamodel.html?highlight=__slots__#object.__slots__"><code>__slots__</code></a> was designed for the same purpose, so is there any point in using <code>__slots__</code> any more?</p>
<p>In an attempt to find out the answer myself, I run the following test, but the results don't make much sense:</p>
<pre><code>class Slots(object):
    __slots__ = ['a', 'b', 'c', 'd', 'e']
    def __init__(self):
        self.a = 1
        self.b = 1
        self.c = 1
        self.d = 1
        self.e = 1  

class NoSlots(object):
    def __init__(self):
        self.a = 1
        self.b = 1
        self.c = 1
        self.d = 1
        self.e = 1
</code></pre>
<p>Python 3.3 Results:</p>
<pre><code>&gt;&gt;&gt; sys.getsizeof([Slots() for i in range(1000)])
Out[1]: 9024
&gt;&gt;&gt; sys.getsizeof([NoSlots() for i in range(1000)])
Out[1]: 9024
</code></pre>
<p>Python 2.7 Results:</p>
<pre><code>&gt;&gt;&gt; sys.getsizeof([Slots() for i in range(1000)])
Out[1]: 4516
&gt;&gt;&gt; sys.getsizeof([NoSlots() for i in range(1000)])
Out[1]: 4516
</code></pre>
<p>I would have expected the size to differ at least for Python 2.7, so I assume there is something wrong with the test.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, PEP 412 does <em>not</em> make <code>__slots__</code> redundant.</p>
<hr/>
<p>First, Armin Rigo is right that you're not measuring it properly. What you need to measure is the size of the object, plus the values, plus the <code>__dict__</code> itself (for <code>NoSlots</code> only) and the keys (for <code>NoSlots</code> only).</p>
<p>Or you could do what he suggests:</p>
<pre><code>cls = Slots if len(sys.argv) &gt; 1 else NoSlots
def f():
    tracemalloc.start()
    objs = [cls() for _ in range(100000)]
    print(tracemalloc.get_traced_memory())
f()
</code></pre>
<p>When I run this on 64-bit CPython 3.4 on OS X, I get <code>8824968</code> for <code>NoSlots</code> and <code>25624872</code> for <code>Slots</code>. So, it looks like a <code>NoSlots</code> instance takes 88 bytes, while a <code>Slots</code> instance takes 256 bytes.</p>
<hr/>
<p>How is this possible?</p>
<p>Because there are still two differences between <code>__slots__</code> and a key-split <code>__dict__</code>.</p>
<p>First, the hash tables used by dictionaries are kept below 2/3rds full, and they grow exponentially and have a minimum size, so you're going to have some extra space. And it's not hard to work out how much space by looking at the nicely-commented <a href="http://hg.python.org/cpython/file/default/Objects/dictobject.c" rel="nofollow">source</a>: you're going to have 8 hash buckets instead of 5 slots pointers.</p>
<p>Second, the dictionary itself isn't free; it has a standard object header, a count, and two pointers. That might not sound like a lot, but when you're talking about an object that's only got a few attributes (note that <em>most</em> objects only have a few attributes…), the dict header can make as much difference as the hash table.</p>
<p>And of course in your example, the values, so the only cost involved here is the object itself, plus the the 5 slots or 8 hash buckets and dict header, so the difference is pretty dramatic. In real life, <code>__slots__</code> will rarely be <em>that</em> much of a benefit.</p>
<hr/>
<p>Finally, notice that PEP 412 only claims:</p>
<blockquote>
<p>Benchmarking shows that memory use is reduced by 10% to 20% for object-oriented programs</p>
</blockquote>
<p>Think about where you use <code>__slots__</code>. Either the savings are so huge that not using <code>__slots__</code> would be ridiculous, or you really need to squeeze out that last 15%. Or you're building an ABC or other class that you expect to be subclassed by who-knows-what and the subclasses might need the savings. At any rate, in those cases, the fact that you get half the benefit without <code>__slots__</code>, or even two thirds the benefit, is still rarely going to be enough; you'll still need to use <code>__slots__</code>.</p>
<p>The real win is in the cases where it isn't worth using <code>__slots__</code>; you'll get a small benefit for free.</p>
<p>(Also, there are definitely some programmers who overuse the hell out of <code>__slots__</code>, and maybe this change can convince some of them to put their energy into micro optimizing something else not quite as irrelevant, if you're lucky.)</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is <code>sys.getsizeof()</code>, which rarely returns what you expect.  For example in this case it counts the "size" of an object without accounting for the size of its <code>__dict__</code>.  I suggest you retry by measuring the real memory usage of creating 100'000 instances.</p>
<p>Note also that the Python 3.3 behavior was inspired by PyPy, in which <code>__slots__</code> makes no difference, so I would expect it to make no difference in Python 3.3 too.  As far as I can tell, <code>__slots__</code> is almost never of any use now.</p>
</div>
<span class="comment-copy">Have you measured the differences in real-world situations yet? :-) Also, <code>__slots__</code> can be (ab)used for it's side effects, such as the fact it prevents arbitrary attributes being added.</span>
<span class="comment-copy">Yes, I'm aware of the problem with <b>slots</b>, it was more of an academic question than relating to a specific use case.  I tried running a few tests, but got found no difference between using slots and not, in python 3.3 or 2.7.  But perhaps my test is faulty, so I'll post it too.</span>
<span class="comment-copy">You gave the memory sizes for <code>NoSlots</code> and <code>Slots</code> instances, but are you sure of the order? Shouldn't <code>Slots</code> instances be lighter than <code>NoSlots</code> ones? This is what I obtain on Win 7 64 bits with Python 3.4.</span>
<span class="comment-copy">I just ran the suggested test with 64-bit Python 3.4; according to <code>tracemalloc</code>, <code>[Slots() for _ in range(100000)]</code> allocates <code>8824968</code>, while with <code>NoSlots</code> it's <code>25624872</code>. See <a href="http://pastebin.com/EF96k4na" rel="nofollow noreferrer">code</a> to make sure I didn't do anything stupid.</span>
<span class="comment-copy">Also, I can't see how it could make <i>no</i> difference. There's still the slack from keeping the hash table only two thirds loaded (that could be fixed by using an indirect indexed array for the values, or compacting the hash table when the first new copy is seen, or various other tricks, but none of them are being done). Also, the <code>dict</code> header itself isn't free—it may be only a small constant overhead, but by comparison with a minimum-sized table and 5 references to the small int <code>1</code>, it's the biggest part of the object.</span>
<span class="comment-copy">I didn't look in detail at the CPython 3.3 implementation, so I can't tell you why it still makes such a big difference to use <code>__slots__</code>.  All I can tell for sure is that <code>__slots__</code> make strictly no difference in PyPy (both PyPy2 and PyPy3).</span>
<span class="comment-copy">I haven't looked in detail at your PyPy implementation, but I'm guessing that you use indirect indexing instead of matched-slot indexing, so the values table is just an compact array rather than a 33%+ empty bucket array, and that a dict isn't 3x as big as a generic object?</span>
<span class="comment-copy"><a href="http://morepypy.blogspot.ch/2010/11/efficiently-implementing-python-objects.html" rel="nofollow noreferrer">morepypy.blogspot.ch/2010/11/…</a></span>
