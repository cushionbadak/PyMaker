<div class="post-text" itemprop="text">
<p>I would like to write a function that pickles all objects in the current namespace which are instances of classes from a given module. the idea is that during an ipython session a user creates many objects from <code>mymodule</code>, and may need to  save all of them  quickly. </p>
<p>so, for example i want something like this </p>
<pre><code>from mymodule import cat, dog, pickle_all
c= cat(), d=dog()
pickle_all('killer_sesh.p')
</code></pre>
<p>end session, forget about for a month, come back and start new session,</p>
<pre><code>from mymodule import upickle_all 
objs = unpickle_all('killer_sesh.p')
</code></pre>
<p>so my first attempt (show below) works when pasted into the current namespace. if i define as a function, or put it somewhere else, like in mymodule, then the <code>dir()</code> command doesnt return the current namespace, but the namespace as seen by the function.  even if i pass the result of dir() as an argument, the objects are not available  within the function.  </p>
<pre><code>import pickle
filename= 'killer_sesh.p'
module='mymodule'
module_objects = {}
for k in dir():
    try:
        if eval(k).__module__.split('.')[0] == module:
            if k[0]!='_':
                print(k)
                module_objects[k] = eval(k)
    except(AttributeError):
        pass
    file= open(filename,'w')
pickle.dump(module_objects, file)
file.close()
</code></pre>
<p>is a function like this possible?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>if i define as a function, or put it somewhere else, like in mymodule, then the dir() command doesnt return the current namespace, but the namespace as seen by the function. even if i pass the result of dir() as an argument, the objects are not available within the function.</p>
</blockquote>
<p>Right, that's because you're using <code>eval</code> to evaluate them, which evaluates them in the current namespace. You <em>could</em> pass the <code>globals</code> and <code>locals</code> from a different mainspace, and call <code>eval</code> with those parameters. In other words, instead of <code>foo(dir())</code>, foo(dir(), globals(), locals())`.</p>
<p>However, this whole design is a bad idea. Using <code>eval</code> to get the members of a scope is a bad idea. In fact, using <code>eval</code> for almost <em>anything</em> is a bad idea.</p>
<p>A much better solution is to pass the thing you want to evaluate the members of, and use <a href="http://docs.python.org/3/library/functions.html#getattr" rel="nofollow"><code>getattr</code></a> to get them.</p>
<p>And an even better solution is to avoid using <code>dir</code> and then figuring out how to get the attributes with those names; if you want to inspect things, that's what the <a href="http://docs.python.org/3/library/inspect.html" rel="nofollow">inspect</a> module is for. (And even when you want to do something that <code>inspect</code> doesn't quite offer, reading its source code—which is linked from the docs—will usually tell you the best way to do it.)</p>
</div>
<span class="comment-copy">You should never use <code>eval()</code> for anything like this - it's a bad method of doing it. Take a look at <code>getattr()</code>.</span>
<span class="comment-copy">+1 to Lattyware's comment. Also, you likely want to use the <code>inspect</code> module rather than manually iterating <code>dir</code> and figuring out what to do with it.</span>
<span class="comment-copy">those are both good suggestions, but the real problem is accessing  the objects outside a functions namespace.</span>
<span class="comment-copy">@alex: You need to have a reference to that namespace. Once you have that, you can use <code>inspect</code>, or <code>getattr</code>, to access the objects in it. If you don't have it, but you have something you can use to access it (e.g., the name of a module that you can look up with <code>sys.modules[name]</code>), or enough to fake it (<code>globals()</code> and <code>locals()</code> called from that namespace), that's OK too. But otherwise, there's no way to access the objects, and there's no way anything could possibly help. (If you're coming from JS, Python doesn't have a global <code>window</code> object that's the default context.)</span>
<span class="comment-copy">passing the output of <code>locals()</code> solves the namespace problem, and the <code>inspect</code> module is indeed usefule in determining the source module.</span>
