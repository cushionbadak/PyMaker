<div class="post-text" itemprop="text">
<p>Given that <code>range</code> objects were made subscriptable, why aren't <code>itertools.repeat</code> objects subscriptable?</p>
<pre><code>In [10]: range(3, 10)[3]
Out[10]: 6

In [11]: import itertools as it

In [12]: it.repeat(5)[3]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-12-1ef74480e0a7&gt; in &lt;module&gt;()
----&gt; 1 it.repeat(5)[3]

TypeError: 'itertools.repeat' object is not subscriptable
</code></pre>
<p><strong>Note that range objects and itertools.repeat objects are part of Python 3.</strong></p>
<p>I would prefer:</p>
<pre><code>class repeat_(itertools.repeat):
    def __init__(self, object_, times=None):
        super().__init__(object_, times)

        self.object_ = object_
        self.times = times

    def __reversed__(self):
        return self

    def __getitem__(self, key):
        return self.object_

    def __contains__(self, key):
        return key == self.object_

    def __len__(self):
        if self.times is None:
            raise ValueError
        return self.times
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>repeat</code> just yields the same object over and over again.  I'm not really sure what subscripting it would actually do for you ... You would be just as well to call <code>next(repeat_object)</code>.  Perhaps you are thinking about <code>cycle</code> (as I did when I originally read your question)?</p>
<p>Part the the wonder of <code>itertools</code> is that it attempts to operate as lazily as it possibly can.  In light of this, what do you expect to happen if you pass a generator expression to <code>itertools.cycle</code>?  <code>cycle</code> has <strong>NO WAY</strong> to know the length of the object you passed in short of casting the whole thing to a tuple and inquiring.  Doing that would probably break the API in a bunch of other places (now you consume your iterable when you subscript your repeat object) or it would take a whole lot more intermediate storage via an unnecessary <code>itertools.tee</code> -- which is what <code>itertools</code> tries to avoid.  As it is currently implemented, <code>cycle</code> on a huge generator expression that you can't hope to hold in memory works (as long as you don't actually iterate over all the elements), but that wouldn't be the case if you tried to subscript it at a large index.</p>
<p>Finally, as the name implies, <code>itertools</code> is a library for creating <code>iterable</code> objects.  As such, there is no reason to expect that the objects are subscriptable.  (It's not called <code>subscripttools</code> after all :).</p>
<p>As a side note, you might be able to do what you want with <code>itertools.islice</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/itertools.html#itertools.repeat" rel="nofollow">itertool.repeat()</a> method returns an iterator, not a list, as is the case with <code>range</code> function. So, you can't subscript on it.</p>
<p>Here's what documentation says: -</p>
<blockquote>
<p>Make an iterator that returns object over and over again. Runs
  indefinitely unless the times argument is specified.</p>
</blockquote>
<p>From <a href="http://docs.python.org/2/tutorial/controlflow.html" rel="nofollow">documentation of range</a>: -</p>
<blockquote>
<p>If you do need to iterate over a sequence of numbers, the built-in
  function range() comes in handy. It generates lists containing
  arithmetic progressions</p>
</blockquote>
<hr/>
<p>In <em>Python 3</em>, difference is that, <code>range()</code> creates a <code>Generator</code> object. Which <code>xrange</code> function in <em>Python 2</em> did.</p>
</div>
<span class="comment-copy">Yeah, <code>list(range(50000000)[:5])</code> produces the same thing as <code>islice(range(50000000), 5)</code>, so why can't <code>list(repeat(4)[:5])</code> produce the same as <code>list(islice(repeat(4), 5))</code>?  It seems like a simpler way to say exactly the same thing.</span>
<span class="comment-copy">@endolith: Good answers here: <a href="http://www.quora.com/Python-programming-language-1/Why-are-generators-in-python-not-subscriptable" rel="nofollow noreferrer">quora.com/Python-programming-language-1/â€¦</a></span>
<span class="comment-copy">@endolith: Thanks, but I disagree that itertools.repeat had to be an iterator.  It could have been a plain old iterable.  As it is, I had to subclass <code>itertools.repeat</code>.</span>
<span class="comment-copy"><code>itertools.repeat()</code> just repeats the object over and over again. Are you thinking of <code>.cycle()</code> instead?</span>
<span class="comment-copy">@MartijnPieters -- Yes, I was thinking of <code>cycle</code> ... I suppose I'll have to edit now.</span>
<span class="comment-copy">@mgilson, although your <code>islice</code> trick is nice, +1 for that.</span>
<span class="comment-copy">I'm using repeat objects polymorphically (in a sequence of sequence objects.) I don't know a priori that the sequence I've got is a repeat object. I try subscripting all of my sequence objects, but it unfortunately fails for repeat objects</span>
<span class="comment-copy">@endolith -- because you can't sanely islice it more than once.  e.g. <code>a = iter(range(30)); b = a[:5]; c = a[:3]</code> would give very different results than slicing a list in this situation which would probably make the code less clear.</span>
<span class="comment-copy">In Python 3, range does not return a list, and it is nevertheless subscriptable.</span>
<span class="comment-copy">yes, in Python 3, it returns a "range object", which is not a list, but nevertheless supports subscripting.</span>
<span class="comment-copy">@NeilG: Note that it doesn't make sense <i>at all</i> for <code>.repeat()</code> to be subscriptable. It repeats the same element <i>over</i> and <i>over</i> again. So <code>repeat(10)[1]</code> is the same thing as <code>repeat(10)[101]</code>. So you may as well use <code>repeat(10).next()</code> instead.</span>
<span class="comment-copy">@RohitJain: In python 3, <code>range()</code> is a type, not a function. So the returned value is a <a href="http://docs.python.org/3/library/stdtypes.html#typesseq-range" rel="nofollow noreferrer">special sequence type</a>.</span>
<span class="comment-copy">@MartijnPieters: I'm using repeat objects polymorphically (in a sequence of sequence objects.)  I don't know a priori that the sequence I've got is a repeat object.  I try subscripting all of my sequence objects, but it unfortunately fails for repeat objects.</span>
