<div class="post-text" itemprop="text">
<p>I need to make a league table for a project. There has to be 3 files,2 files consist of 1 class and the last file is for running a program. I have done all of the parts but when I call a method to add a team, the program adds the name but it does not insert it into the list of teams(which should do). When I try to display the items in the list, the program displays an error message instead of showing the actual team.</p>
<p>How can I fix it?Any help would be appreciated. :)</p>
</div>
<div class="post-text" itemprop="text">
<p>A few things here:</p>
<blockquote>
<p>When I try to display the items in the list, the program displays: team.Team object at 0x000000000332A978 insted of showing the actual team.</p>
</blockquote>
<p>The default display for a user class is something like <code>&lt;team.Team object at 0x000000000332A978&gt;</code>. If you want it to display something different, you have to tell Python what you want to display. There are two separate functions for this: <a href="http://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow"><code>__repr__</code> and <code>__str__</code></a>. The idea is that the first is a representation for the programmer, the second for the user. If you don't need two different representations, just define <code>__repr__</code> and it'll use that whenever it needs <code>__str__</code>.</p>
<p>So, a really simple way to fix this is to add this to the <code>Team</code> class:</p>
<pre><code>def __repr__(self):
    return 'Team("{}")'.format(self._name)
</code></pre>
<p>Now, if you call <code>league.addTeam('Dodgers')</code>, then <code>print(l._table)</code>, you'll get <code>[Team("Dodgers")]</code> instead of <code>[&lt;team.Team object at 0x000000000332A978&gt;]</code>.</p>
<p>Meanwhile, these two methods are probably not what you want:</p>
<pre><code>def removeTeam(self,team):
    self._table.remove(team)
def returnPosition(self,team):
    return self._table.index(team)
</code></pre>
<p>These will remove or find a team given the <code>Team</code> object—not the name, or even a new <code>Team</code> created from the name, but a reference to the exact same object stored in the <code>_table</code>. This is not all that useful, and you seem to want to call them with just names.</p>
<p>There are two ways to fix this: You could change <code>Team</code> so that it compares by name instead of by object identity, by adding this method to the class:</p>
<pre><code>def __eq__(self, other):
    return self._name == other._name
</code></pre>
<p>What this means is that if you say <code>Team('Giants') == Team('Giants')</code>, it will now be true instead of False. Even if the first team is in a different league, and has a different W-L record, and so on (e.g., like the baseball "Giants" from San Francisco vs. the football "Giants" from New York), as far as Python is concerned, they're now the same team. Of course if that's not what you want, you can write any other <code>__eq__</code> function that seems more appropriate. </p>
<p>Anyway, if you do this, the <code>index</code> and <code>remove</code> functions will now be able to find any <code>Team</code> with the same name, instead of just the exact same team, so:</p>
<pre><code>def removeTeam(self,team_name):
    self._table.remove(Team(team_name))
def returnPosition(self,team_name):
    return self._table.index(Team(team_name))
</code></pre>
<p>If you go this way, you might want to consider defining all of the <a href="http://docs.python.org/3/reference/expressions.html#comparisons" rel="nofollow">comparison methods</a>, so you can, e.g., sort a list of teams, and they sort by name.</p>
<p>Or you could change these methods so they don't work based on equality, e.g., by redefining them like this:</p>
<pre><code>def removeTeam(self,team_name):
    self._table = [team for team in self._table if team._name != team_name]
def returnPosition(self,team_name):
    return [team._name for team in self._table].index(team_name)
</code></pre>
<p>To understand how these work, if you're not used to reading list comprehensions, turn each one back into the equivalent loop:</p>
<pre><code>self._table = [team for team in self._table if team._name != team_name]

temp = []
for team in self._table:
    if team._name != team_name:
        temp.append(team)
self._table = temp
</code></pre>
<p>If you step through this, <code>temp</code> ends up with a list of every team in the table, except the one you wanted to remove, and then you replace the old <code>self._table</code> with the new filtered one. (Another way to write the same idea is with <a href="http://docs.python.org/3/library/functions.html#filter" rel="nofollow"><code>filter</code></a>, if you know that function.)</p>
<p>It's usually better to create a new filtered list than to modify a list in-place. Sometimes there are performance reasons not do this, and sometimes it ends up being very complex and hard to understand, but it's usually both faster and simpler to reason about. Also, modifying lists in place leads to problems like this:</p>
<pre><code>for i, value in enumerate(mylist):
    if value == value_to_remove:
        del mylist[i]
</code></pre>
<p>Play with this for a while, and you'll see that it doesn't actually work. Understanding why is a bit complicated, and you probably don't want to learn that until later. The usual trick to solve the problem is to iterate over a copy of the list… but once you're doing that, you've now got the worst of filtering and the worst of deleting-in-place at the same time.</p>
<p>The second function may be a little too clever, but let's look at it:</p>
<pre><code>def returnPosition(self,team_name):
    return [team._name for team in self._table].index(team_name)
</code></pre>
<p>First, I'm creating a list like the original one, but it's a list of just the names instead of the team objects. Again, let's decompose the list comprehension:</p>
<pre><code>temp = []
for team in self._table:
    temp.append(team._name)
</code></pre>
<p>Or try to translate it into English: This is a list of the team name of every team in the table.</p>
<p>Now, because this is a list of team names, I can use <code>index(team_name)</code> and it will find it. And, because the two lists have the same shape, I know that this is the right index to use in the original <code>team</code> list as well.</p>
<p>A much simpler solution would be to change <code>_tables</code> from a <code>list</code> of <code>Team</code>s into a <code>dict</code> mapping names to <code>Team</code>s. This is probably the most Pythonic solution—it looks a lot simpler than writing list comprehensions to do simple operations. (It's also probably the most efficient, but that's hardly relevant unless you have some truly gigantic leagues.) And then you don't even need <code>returnPosition</code> for anything. To do that:</p>
<pre><code>def __init__(self):
    self._table={}
def addTeam(self,name):
    self._table[name]=Team(name)
def removeTeam(self,team_name):
    del self._table[team_name]
def returnPosition(self,team_name):
    return team_name
def updateLeague(self,team1_name1,team_name2,score1,score2):
    if score1&gt;score2:
        self._table[team_name1].win()
        self._table[team_name2].loss()
    elif score1==score2:
        self._table[team_name1].draw()
        self._table[team_name2].draw()
    elif score1&lt;score2:
        self._table[team_name1].loss()
        self._table[team_name2].win()
</code></pre>
<p>Note that I've defined <code>returnPosition</code> to just return the team name itself as the position. If you think about it, <code>dict</code> keys are used exactly the same way as <code>list</code> indices, so this means any code someone wrote for the "old" API that required <code>returnPosition</code> will still work with the "new" API. (I probably wouldn't try to sell this to a teacher who assigned a problem that required us to use <code>returnPosition</code>, but for a real-life library where I wanted to make it easier for my 1.3 users to migrate to 2.0, I probably would.)</p>
<p>This only requires a few other changes. In <code>displayList</code> and <code>saveList</code>, you iterate over <code>self._table.values()</code> rather than <code>self._table</code>; in <code>loadList</code>, you change <code>self._table.append(team)</code> to <code>self._table[a] = team</code>. Speaking of <code>loadList</code>: You might want to consider renaming those local variables from <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> to <code>name</code>, <code>wins</code>, <code>losses</code>, and <code>draws</code>.</p>
<p>A few other comments:</p>
<ul>
<li>As kreativitea says in the comments, you should not create "private" variables and then add do-nothing accessor methods in Python. It's just more boilerplate that hides the real code, and one more thing you can get wrong with a silly typo that you'll spend hours debugging one day. Just have members named <code>name</code>, <code>wins</code>, <code>losses</code>, etc., and access them directly. (If someone told you that this is bad style because it doesn't let you replace the implementation in the future without changing the interface, that's only true in Java and C++, not in Python. If you ever need to replace the implementation, just read up on <a href="http://docs.python.org/3/library/functions.html#property" rel="nofollow"><code>@property</code></a>.)</li>
<li>You don't need <code>print("""""")</code>—and it's very easy to accidentally miscount the number of <code>"</code> characters. (Especially since some IDEs will actually be confused by this and think the multi-line string never ends.) Just do <code>print()</code>.</li>
<li>You've got the same ending condition both in the <code>while</code> loop (<code>while x!="q":</code>) and in an internal <code>break</code>. You don't need it in both places. Either change it to <code>while True:</code>, or get rid of the <code>break</code> (just make <code>options("q")</code> do <code>print("Goodbye")</code>, so you don't need to special-case it at all inside the loop).</li>
<li>Whenever you have a long chain of <code>elif</code> statements, think about whether you can turn it into a <code>dict</code> of short functions. I'm not sure it's a good idea in this case, but it's always worth thinking about and making the explicit decision. </li>
</ul>
<p>The last idea would look something like this:</p>
<pre><code>def addTeam():
    name=input("Enter the name of the team:")
    l.addTeam(name)
def removeTeam():
    teamToRemove=input("Enter the name of the team you want to remove:")
    l.removeTeam(teamToRemove)
def recordGame():
    team1=input("What is the name of the team?")
    ans1=int(input("Enter the number of goals for the first team:"))
    team2=input("What is the name of the team?")
    ans2=int(input("Enter the number of goals for the second time:"))
    l.updateLeague(team1,team2,ans1,ans2)
optionsdict = {
    "a": addTeam,
    "d": l.displayList,
    "s": l.saveList,
    "l": l.loadList,
    "r": removeTeam,
    "rec": recordGame,
}
def options(x):
    func = optionsdict.get(x)
    if func:
        func()
</code></pre>
<p>As I said, I'm not sure it's actually clearer in this case, but it's worth considering.</p>
</div>
<span class="comment-copy">A quick side note: You've got a variable called <code>_looses</code> instead of <code>_losses</code>, which is almost guaranteed to lead to a bug at some point when you set <code>_losses</code> and it doesn't affect the value of <code>_looses</code>…</span>
<span class="comment-copy">thanks,corrected ;)</span>
<span class="comment-copy">Also, you don't need all those get methods.. <code>team._wins</code> will return the number of wins.  Do you already know java?</span>
<span class="comment-copy">I'm confused about what the problem is here. You say "when I call a method to add a team, the program adds the name but it does not insert it into the list of teams", but actually it <i>does</i> insert it into the list of teams. The next line says that printing out the list of teams shows garbage instead of the team name—my answer shows how to fix that. But then your test code seems to have a different problem, calling <code>updateLeague</code> incorrectly—simon's answer shows how to fix that. Are either of these the problem you're trying to solve, or something different?</span>
<span class="comment-copy">@kreativitea: +1, but you should mention that he should also not try to "privatize" the variables: call it <code>team.wins</code> instead of <code>team._wins</code>.</span>
<span class="comment-copy">this is true, and good advice, but it does not solve the problem with the OP's code</span>
<span class="comment-copy">@simon: I think it does. The code as written does actually insert the team into the league (you can run it and test it—it works), but the OP was confused because he didn't realize the default display actually -was_ the team object. I may have misunderstood, but he said "I have done all of the parts but when I call a method to add a team, the program adds the name but it does not insert it into the list of teams".</span>
<span class="comment-copy">ah, very good, I see you've incorporated my insight into your answer now :) your answer is now correct and more comprehensive than mine, so I'll delete mine :)</span>
<span class="comment-copy">@simon: The only problem is that I can no longer +1 your answer…</span>
<span class="comment-copy">@abarnert thanks,that was soooo helpful:)i changed a few bits but couldn't get it done in the way you said at the end because creating <code>returnPosition</code> method is one of the requirements. And I have another question:could you explain a little bit why is it written in that way?<code>team for team in _table if team._name != team_name</code>in  <code>removeTeam</code> method and <code>team._name for team in self._table].index(team_name)</code> in <code>returnPosition</code> method.I know it uses a list comprehension but i didn't quite get the way it's written.</span>
