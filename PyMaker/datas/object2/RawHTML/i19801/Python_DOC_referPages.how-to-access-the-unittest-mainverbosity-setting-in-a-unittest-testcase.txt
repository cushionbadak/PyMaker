<div class="post-text" itemprop="text">
<p>According to the documentation I can set the verbosity level of a python unittest when calling <code>unittest.main</code>, e.g.</p>
<pre><code>unittest.main(verbosity=2)
</code></pre>
<p>How can I access this information within a <code>unittest.TestCase</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with any method based on patching or subclassing <code>unittest.TestProgram</code> is that you have to get the patch in place before <code>unittest.TestProgram</code> is started. But that's not going to be possible if your test case is being run via discovery:</p>
<pre><code>python -m unittest discover -v
</code></pre>
<p>An approach that works in the discovery case is to use the <a href="https://docs.python.org/3/library/inspect.html" rel="noreferrer"><code>inspect</code></a> module to search up the stack until a method on <code>unittest.TestProgram</code> is found:</p>
<pre><code>import inspect
import unittest

def unittest_verbosity():
    """Return the verbosity setting of the currently running unittest
    program, or 0 if none is running.

    """
    frame = inspect.currentframe()
    while frame:
        self = frame.f_locals.get('self')
        if isinstance(self, unittest.TestProgram):
            return self.verbosity
        frame = frame.f_back
    return 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A way to achieve this is to subclass <code>unittest.TestCase</code> and <code>unittest.main</code> in a file. Here, you define a variable (e.g. <code>globalverb</code>) the can be used globally or as class or Singleton, and then you override <code>unittest.main</code>:</p>
<pre><code>def main(*args, **kwargs):

    # parse arguments etc to get the verbosity number or whatever
    # ...
    # set this number to the defined class
    globalverb = verbose_number
    return unittest.main(*args, **kwargs)
</code></pre>
<p>Later, you subclass <code>unittest.TestCase</code>:</p>
<pre><code>class MyTestCase(unittest.TestCase):
    def my_special_function(self):
        if globalverb ...
</code></pre>
<p>With this approach it is possible to use the verbose,verbosity or any other number and information in a (derived) TestCase, from arguments passed on to a unittest. </p>
<p>Comments welcome. </p>
</div>
<div class="post-text" itemprop="text">
<p>I wasn't able to get Martjin Pieters' solution to work, I think because unittest.main runs the tests when it is initialized, before its result has been assigned to the global.</p>
<p>Instead, I replaced my initialiation with:</p>
<pre>
    def new_parseArgs(self, argv):
        global old_parseArgs,verbosity
        old_parseArgs(self, argv)
        verbosity = self.verbosity

    if __name__ == '__main__':
        # monkeypatch unittest.TestProgram.parseArgs() to save verbosity
        # in a global variable
        old_parseArgs = unittest.TestProgram.parseArgs
        unittest.TestProgram.parseArgs = new_parseArgs

        unittest.main()
</pre>
<p>In the test cases that need to know the verbosity, I use something like:</p>
<pre>
            global verbosity

    ...

            if verbosity &gt;= 2:
                print("Keys' order: %s" % dd.keys())
</pre>
</div>
<div class="post-text" itemprop="text">
<p>If you just want to access the <code>-v</code> option, you can check it with <code>self._resultForDoCleanups.showAll</code> in your test (inheriting from <code>unittest.TestCase</code>). The field is true if <code>-v</code> is called for that test.</p>
</div>
<div class="post-text" itemprop="text">
<p>My solution was quite different. Instead of monkeypatching I took advantage that all my tests are triggered via specially crafted launch script. It gathers various config variables and setups environment so it was pretty straight forward to just add one extra export.</p>
<p>It might be sensible solution for more generic cases, instead of running tests directly, create test-runner.sh (or whatever) that will make exactly the same shell call but with extra export prefixed to it.</p>
<p>Because one picture is worth thousands of words:</p>
<p>This is my test runner:</p>
<pre><code>#!/usr/bin/env bash

VERBOSE=false

while getopts ":vt:" opt; do
    case $opt in
        t)
            TEST_TO_RUN=$OPTARG
            ;;
        v)
            VERBOSE=true
            ;;
        \?)
          echo "Invalid option: -$OPTARG" &gt;&amp;2
          exit 1
          ;;
        :)
          echo "Option -$OPTARG requires an argument." &gt;&amp;2
          exit 1
      ;;
    esac
done

ENVS=""
ENVS+=" PYTHONPATH=$PYTHONPATH:$PWD"

PARAMS=""
PARAMS+=" -s --nologcapture --with-id"
PARAMS+=" --cov-config=.apirc --cov-report html --with-cov"

SERVER_PRIMER="coverage run --rcfile=.apirc"

if [[ ! -z "$TEST_TO_RUN" ]]; then
    PARAMS+=" $TEST_TO_RUN"
fi

if [[ "$VERBOSE" = true ]]; then
    PARAMS+=" -v"
    ENVS+=" TEST_VERBOSITY=2"
fi

eval "$ENVS nosetests $PARAMS"

RESULT_TEST=$?
</code></pre>
<p>And then I have this method on unit test:</p>
<pre><code>@property
def verbosity(self):
    return int(os.environ.get('TEST_VERBOSITY', 0))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Climb the stack, find the "TestProgram" instance created by unittest.main( ), and access the verbosity field:</p>
<pre><code>class MyTestCase(unittest.TestCase):

    def test_verbosity(self):
        """Return current verbosity"""
        for f in inspect.getouterframes(inspect.currentframe() ):
            args, _,_, local_dict = inspect.getargvalues(f[0])
            if args: 
                first_arg = args[0] 
                first_value = local_dict[first_arg]
                if type(first_value).__name__ == "TestProgram":
                    return first_value.verbosity
</code></pre>
</div>
