<div class="post-text" itemprop="text">
<p>I wrote a small threading example in python. I am facing problem that when there's an exception inside a thread, that thread keeps on running and it won't exit. I have following code:</p>
<pre><code>class Producer (threading.Thread):

    def __init__(self, threadId):
        threading.Thread.__init__(self)
        self.threadId  = threadId
        self.killReceived = False

    def produce(self):
        while 1:
            if self.killReceived == True:
                print self.threadId+"inside kill section"
                return False
            print "running"
            time.sleep(1) 
            raise Exception('boo')

    def run(self):
        try:
            self.produce()
        except Exception as e:
            ThreadManager.getInstance().shutdown(self.threadId)

    def stop(self):
        self.killReceived = True

class ThreadManager:
    _instance = None

    @staticmethod
    def getInstance():
        if ThreadManager._instance == None:
            ThreadManager._instance = ThreadManager()
        return ThreadManager._instance

    def __init__(self):
        ''' some initializations '''

    def shutdown(self, threadId):
        while threading.active_count() &gt; 1:
            for thread in threading.enumerate():    
                if type(thread) != threading._MainThread: #never kill main thread directly
                    thread.stop()
                    #print thread.threadId+" is alive? "+str(thread.isAlive())
</code></pre>
<p>When I raise exception inside producer it gets caught and I fire shutdown method of ThreadManager, which in turn calls stop() method of all running threads except main thread. Consumer exits using this strategy but producer hangs. If I run <code>isAlive</code> method I see that producer threads are still running, however it's run method is no longer running. Because it no longer print <code>running</code>.As exception bubbles out of <code>produce</code> method which is inside run(), so thread should automatically finish. But it doesn't. So where exactly is the producer? How can I make it stop when some exception occurs?</p>
</div>
<div class="post-text" itemprop="text">
<p>ThreadManager's <code>shutdown</code> is not properly synchronized; it basically is a while <code>threading.active_count() &gt; 1</code> loop that is never exited. If two or more threads end up in this method, they (and the program) will never exit.</p>
<p>Instead of continually calling random threads (which may not even be related to yours), simply keep an inventory of all started threads in ThreadManager, and call <code>stop</code> of each of them once. Also, the code that actually calls stop should move into the ThreadManager, where it logically belongs.</p>
<p>Additionally, <code>ThreadManager.getInstance</code> is not thread-safe; you may end up with multiple ThreadManagers as it stands. You should use a <a href="http://docs.python.org/3/library/threading.html#lock-objects" rel="nofollow">lock</a>.</p>
<p>All in all, it looks like you're reimplementing a <a href="http://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor" rel="nofollow"><code>ThreadPoolExecutor</code></a>. Why don't you use that instead?</p>
</div>
<span class="comment-copy">Yes you are right with that loop thing. The call never ends so producer never seems to exit. ThreadPoolExecutor, that's a great suggestion, I will look into it. thanks for guiding me.  58K points !!!(salute)</span>
