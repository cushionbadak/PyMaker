<div class="post-text" itemprop="text">
<p>I am trying to port some C Code but I am really stuck cause of the use of memcpy I tried with ctypes (did not work). I am hoping to find a python way of using an equivalent function of memcpy</p>
<p>Any ideas</p>
<p>Here is an example of the C Code I am trying to port</p>
<pre><code>i = l + 5;
t = htons(atoi(port));
memcpy((buf+i), &amp;t, 2);
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You almost certainly don't need to call <code>htons</code> and then copy the 2 bytes into a bufferâ€”see Keith's answer for why.</p>
<p>However, if you <em>do</em> need to do this (maybe you're crafting IP packets to compare to captured wire packets as a test or something?), you can.</p>
<p>First, if you're using a <code>bytearray</code> (or anything else that meets the writable buffer protocol), you just use normal <code>list</code>-style slice assignment:</p>
<pre><code># like C's memcpy(buf+i, foo, 2)
buf[i:i+2] = foo
</code></pre>
<p>You don't have that two-byte string <code>foo</code>; you have a short integer. In C, you can turn that into a pointer to two bytes just by using the <code>&amp;</code> operator to get its address, but Python can't do that. Fortunately, there's a standard library module called <a href="http://docs.python.org/3/library/struct.html" rel="noreferrer"><code>struct</code></a> designed for exactly this kind of thing:</p>
<pre><code>t = socket.htons(int(port))
buf[i:i+2] = struct.pack('h', t)
</code></pre>
<p>Or, because <code>struct</code> can handle endianness for you:</p>
<pre><code>t = int(port)
buf[i:i+2] = struct.pack('!h', t)
</code></pre>
<p>However, often you don't even need the buffer copying; you can define the entire structure all at once inside <code>struct</code>. For example, if you're trying to pack an IP address and port into a 6-byte array, you could do this:</p>
<pre><code>buf = bytearray(6)
i = 0
addrbytes = [int(part) for part in addr.split('.')]
buf[i:i+4] = struct.pack('4B', addrbytes[0], addrbytes[1], addrbytes[2], addrbytes[3])
i += 4
portshort = int(port)
buf[i:i+2] = struct.pack('!h', portshort)
</code></pre>
<p>But this is much simpler:</p>
<pre><code>addrbytes = [int(part) for part in addr.split('.')]
portshort = int(port)
buf = struct.pack('!4Bh', addrbytes[0], addrbytes[1], addrbytes[2], addrbytes[3], portshort)
</code></pre>
<p>I've just defined a structure that's in network order, with four bytes followed by a short, and packed my data into it.</p>
<p>One last thing to mention: If you really want to deal with C-style variables using C-style code, the <a href="http://docs.python.org/3/library/ctypes.html" rel="noreferrer">ctypes</a> module is another option. It's made specifically for interacting with C code, so in general it's pretty low-level (and the only module in the standard library that lets you segfault your code), but it let you build some nice mid-level stuff that looks a little more like C:</p>
<pre><code>class ADDRPORT(ctypes.BigEndianStructure):
    _fields_ = [("addr", ctypes.c_char*4),
                ("port", ctypes.c_short)]

addrport = ADDRPORT(addrbytes, portshort)
</code></pre>
<p>Since your C code is progressively filling up a buffer, rather than setting elements of a <code>struct</code>, this probably isn't what you want. But it's worth being aware of, because it probably will be what you want at some point.</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like you are trying to get a port number from user input or a string.</p>
<p>In Python:</p>
<pre><code>port = int(port)
</code></pre>
<p>Then you can pass that directly to a socket instantiation:</p>
<pre><code>socket = socket.socket(("127.0.0.1", port))
</code></pre>
<p>Python does the <code>htons</code> translation for you. You only need to supply an address to a socket (in the case of TCP) as a tuple of a string and integer.</p>
</div>
<span class="comment-copy">What are you actually trying to achieve? Show your python code.</span>
<span class="comment-copy">That appears to be socket related code. The Python <a href="http://docs.python.org/2/library/socket.html" rel="nofollow noreferrer"><code>socket</code></a> library does a lot of that stuff for you, so you don't have to worry about using <code>htons()</code> etc in Python code. So it's hard to say without seeing more of your C code.</span>
<span class="comment-copy">Very, very rarely do you want to do a direct line-by-line transcoding.  This is inefficient and fails to leverage the strengths of the new language.</span>
<span class="comment-copy">I would be asking what @marcin is - what is it that you're trying to do... what's the end goal for instance?</span>
<span class="comment-copy">Unless he's trying to, e.g., craft raw IP packets instead of just creating a socket, this is the right answer.</span>
