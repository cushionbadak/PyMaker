<div class="post-text" itemprop="text">
<p>For simplification purposes lets assume the shell script is the <code>cat</code> command. In the shell it would be normally called like this:</p>
<pre><code>$ cat /some/path/myfile.txt
</code></pre>
<p>Now the file will be created dynamically and writing it to disk would be a major performance hit, present security issues and increase the file management overhead in a multiuser environment. The script cannot be modified nor can read from stdin (<code>cat</code> was just a working sample).</p>
<p>I tried this:</p>
<pre><code>import os
pin, pout = os.pipe()
pin, pout = os.fdopen(pin, 'r'), os.fdopen(pout,'w')

from subprocess import Popen
pout.write("test")
pout.flush()
p = Popen('cat /proc/self/fd/%s' % pout.fileno(), shell=True)
</code></pre>
<p>Even if I close <code>pout</code> <code>p.poll()</code> still returns nothing showing that the command is still waiting more input from the pipe. </p>
<p>How can I tell the command there's no more data coming from the pipe?
Is there any other approach to solve this?</p>
<p><strong>Edit</strong></p>
<p>In bash, if the file content is generated by a program named <code>prog1</code> this would be solved in this manner:</p>
<pre><code>$ cat &lt;(prog1)
</code></pre>
<p><strong>Edit 2</strong></p>
<p>If you don't need the shell then the other option mentioned by Alfe is better, though the problem still exists (i.e. the process is not finishing after reading the file contents)</p>
<pre><code>#...same as before
p = Popen(['cat', '/dev/stdin'], stdin=pout)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is what I did at the end but is not nice. </p>
<p>Because I'm working on CentOS and the problem I'm having (I've asked about it here: <a href="https://stackoverflow.com/questions/13511422/python-popen-cant-open-bash-shell-in-centos-red-hat">Python Popen can't open bash shell in CentOS/Red Hat</a>) I can't use <code>execute='/bin/bash'</code> that's why the solution looks a little different than the question.</p>
<p>What I'm passing in some configuration to the process using bash process substitution and here-documents:</p>
<pre><code>file_contents = '...'
p = Popen(['/bin/bash', '-c', "cat &lt;(cat&lt;&lt;'EOF_CFG'\n%s\nEOF_CFG\n)" % file_contents])
</code></pre>
<p>I'm now considering using tmpfs for creating named pipes on it. I think that starting the script on it first and then writing to the pipe should work... If I'm successfull I'll write it here too.</p>
</div>
<div class="post-text" itemprop="text">
<p>Fiddled around a little bit, seems that closing the pipe on the one side does not generate an eof on the associated pseudo file /proc/self/fd/&lt;#&gt; of the child process.  Did you try it with /dev/stdin and simple piping your input to the subprocess's stdin?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try using a named pipe for this.  On it, EOFs are properly propagated:</p>
<pre><code>$ mkfifo bla
$ python
from subprocess import Popen
p = Popen('cat bla', shell=True)
with file('bla', 'w') as f:
  f.write('test')
</code></pre>
<p>You can create named pipes on the fly from Python as well, of course, just use <code>os.mkfifo()</code>.</p>
</div>
<span class="comment-copy">I don't understand what you want. If you don't find a good solution, consider using <a href="http://docs.python.org/3/library/tempfile.html" rel="nofollow noreferrer">tempfile</a>.</span>
<span class="comment-copy">@BlaXpirit tempfile is writing to disk, the only condition is not to do that. I'll edit the question and try to explain more</span>
<span class="comment-copy">I'm not sure what you mean. The script being run expects a file and cannot read from stdin (that's why I said <code>cat</code> is only a simple example, the real script can't do that)</span>
<span class="comment-copy">/dev/stdin is a fake-file which is associated with the current process's stdin.  Try:  <code>ls | cat file_a /dev/stdin file_b</code>.</span>
<span class="comment-copy">I wasn't aware of that! It's a better option, but it has just the same problem. There's no EOF being sent... The good thing is that it doesn't need the shell. Though in my particular case I need to source files, to setup the environment.</span>
<span class="comment-copy">Actually you seem to have the problem that if a process (your consumer) opens a file instead of reading from a pipe, another process cannot signal it about closing the pipe (normally this would raise a SIGPIPE).  So there is no way for you to do what you want to do.  <i>Maybe</i> your consumer also can read from a pipe and will handle the SIGPIPE properly; in that case <i>maybe</i> he also handles it when reading from a file.  So you <i>could</i> try sending him that SIGPIPE manually.  But I would not bet on that all the maybes are going to work here.</span>
<span class="comment-copy">indeed that was my latest consideration. I have to check if that works in my particular case, because the Popen happens down in the class hierarchy and triggers a communicate which is expected to block until the script finishes. The subclass would then have to pass "something" that would act like a file. I have to try it out, but I think I'd need two processes for this,</span>
