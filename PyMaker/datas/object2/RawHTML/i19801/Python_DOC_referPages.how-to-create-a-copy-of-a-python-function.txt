<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6527633/how-can-i-make-a-deepcopy-of-a-function-in-python">How can I make a deepcopy of a function in Python?</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>Is there a possibility to create real copies of python functions? The most obvious choice was <a href="http://docs.python.org/2/library/copy.html">http://docs.python.org/2/library/copy.html</a> but there I read:</p>
<blockquote>
<p>It does “copy” functions and classes (shallow and deeply), by
  returning the original object unchanged;</p>
</blockquote>
<p>I need a real copy, because I might change some attributes of the function.</p>
<p><strong>Update:</strong></p>
<p>I'm aware of all the possibilities which are mentioned in the comments. My use case is based on meta programming where I construct classes out of some declarative specifications. Complete details would be too long for SO, but basically I have a function like</p>
<pre><code>def do_something_usefull(self,arg):
    self.do_work()
</code></pre>
<p>I will add this method to various classes. Thoses classes can be completly unrelated. Using mixin classes is not an option: I will have many such functions and would end up adding a base class for each function. My current "workaround" would be to wrap this function in a "factory" like this:</p>
<pre><code>def create_do_something():
    def do_something_usefull(self,arg):
        self.do_work()
</code></pre>
<p>That way I always get a new do_something_useful function, but I have to wrap all my functions like this.</p>
<p>You can trust me, that I'm aware, that this is no "normal" OO programming. I know how to solve something like that "normally". But this is a dynamic code generator and I would like to keep everything as lightweight and simple as possible. And as python functions are quite normal objects, I don't think it's too strange to ask how to copy them!?</p>
</div>
<div class="post-text" itemprop="text">
<p>In <strong>Python3</strong>:</p>
<pre><code>import types
import functools

def copy_func(f):
    """Based on http://stackoverflow.com/a/6528148/190597 (Glenn Maynard)"""
    g = types.FunctionType(f.__code__, f.__globals__, name=f.__name__,
                           argdefs=f.__defaults__,
                           closure=f.__closure__)
    g = functools.update_wrapper(g, f)
    g.__kwdefaults__ = f.__kwdefaults__
    return g

def f(arg1, arg2, arg3, kwarg1="FOO", *args, kwarg2="BAR", kwarg3="BAZ"):
    return (arg1, arg2, arg3, args, kwarg1, kwarg2, kwarg3)
f.cache = [1,2,3]
g = copy_func(f)

print(f(1,2,3,4,5))
print(g(1,2,3,4,5))
print(g.cache)
assert f is not g
</code></pre>
<p>yields</p>
<pre><code>(1, 2, 3, (5,), 4, 'BAR', 'BAZ')
(1, 2, 3, (5,), 4, 'BAR', 'BAZ')
[1, 2, 3]
</code></pre>
<hr/>
<p>In <strong>Python2</strong>:</p>
<pre><code>import types
import functools
def copy_func(f):
    """Based on http://stackoverflow.com/a/6528148/190597 (Glenn Maynard)"""
    g = types.FunctionType(f.func_code, f.func_globals, name=f.func_name,
                           argdefs=f.func_defaults,
                           closure=f.func_closure)
    g = functools.update_wrapper(g, f)
    return g

def f(x, y=2):
    return x,y
f.cache = [1,2,3]
g = copy_func(f)

print(f(1))
print(g(1))
print(g.cache)
assert f is not g
</code></pre>
<p>yields</p>
<pre><code>(1, 2)
(1, 2)
[1, 2, 3]
</code></pre>
</div>
<span class="comment-copy">Use <code>copy.deepcopy</code> if you really must. But I think there's a deeper design flaw somewhere. Why do you want to copy functions in the first place?</span>
<span class="comment-copy">Can you help us understand a bit about what you want to do -- your question is a little strange/vague.  In the thousands of lines of python I've written, I've never copied a function.</span>
<span class="comment-copy">If you need to maintain state, why not use classes and instances? Why functions that need to be <i>copied</i> somehow?</span>
<span class="comment-copy">If you're changing attributes on a function you're probably better off wrapping the function in an object then changing attributes on the object.  It will make your code cleaner.  If you add a <code>__call__</code> method to your object it can be called just like a function.</span>
<span class="comment-copy">I don't see why treating function like any other object should be a problem, in python. I do have the same need: decorated functions are passed to internal <b>and external</b> code which expect a function object. Copying a function in order to change its decoration is thus useful and working around with objects that look-a-like function but are not is just overly complicated.</span>
<span class="comment-copy">The function dictionary should also be copied: <code>g.__dict__.update(f.__dict__)</code></span>
<span class="comment-copy">Is <code>func_code</code> (and friends) the Python 2 equivalent of <code>__code__</code> (and friends)?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functools.html?highlight=functools.update_wrapper#functools.update_wrapper" rel="nofollow noreferrer"><code>functools.update_wrapper</code></a> would update all the metadata other then <code>__kwdefaults__</code> like <code>__doc__</code> and <code>__module__</code></span>
<span class="comment-copy">@BenMares: With <code>g = functools.update_wrapper(g, f)</code>, you get <code>g.__wrapped__</code> which equals <code>f</code>. If you use <code>fn.__dict__.update(f.__dict__)</code> you do not get the <code>__wrapped__</code> attribute. I'm not aware of any other difference due to <code>update_wrapper</code>.</span>
<span class="comment-copy">@BenMares: A more dramatic difference is made by the <a href="https://stackoverflow.com/questions/13503079/how-to-create-a-copy-of-a-python-function/13503277?noredirect=1#comment63227017_13503277">inclusion of <code>g.__kwdefaults__ = f.__kwdefaults__</code></a>.  With this, <code>g(1,2,3)</code> returns <code>(1, 2, 3, (), 'FOO', 'BAR', 'BAZ')</code>. Without it, <code>g(1,2,3)</code> raises <code>TypeError: f() missing 3 required positional arguments: 'arg1', 'arg2', and 'arg3'</code>.</span>
