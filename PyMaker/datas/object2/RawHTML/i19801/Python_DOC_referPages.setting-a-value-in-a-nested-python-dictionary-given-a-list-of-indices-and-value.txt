<div class="post-text" itemprop="text">
<p>Sorry if this question has been answered before - I've been searching for solutions but I maybe am not using the correct search terms.</p>
<p>Anyway, what I'm trying to do is to programmatically set a value in a dictionary, potentially nested, given a list of indices and a value.</p>
<p>So for example, let's say my list of indices is:</p>
<pre><code>['person', 'address', 'city'] 
</code></pre>
<p>and the value is</p>
<pre><code>'New York'
</code></pre>
<p>I want as a result a dictionary object like:</p>
<pre><code>{ 'Person': { 'address': { 'city': 'New York' } }
</code></pre>
<p>Basically, the list represents a 'path' into a nested dictionary. </p>
<p>I think I can construct the dictionary itself, but where I'm stumbling is how to set the value. Obviously if I was just writing code for this manually it would be:</p>
<pre><code>dict['Person']['address']['city'] = 'New York'
</code></pre>
<p>But how do I index into the dictionary and set the value like that programmatically if I just have a list of the indices and the value?</p>
<p>Hope this makes sense and isn't too dumb a question... :) Thanks for any help.</p>
</div>
<div class="post-text" itemprop="text">
<p>Something like this could help:</p>
<pre><code>def nested_set(dic, keys, value):
    for key in keys[:-1]:
        dic = dic.setdefault(key, {})
    dic[keys[-1]] = value
</code></pre>
<p>And you can use it like this:</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; nested_set(d, ['person', 'address', 'city'], 'New York')
&gt;&gt;&gt; d
{'person': {'address': {'city': 'New York'}}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First off, you probably want to look at <a href="http://docs.python.org/2/library/stdtypes.html" rel="nofollow noreferrer">setdefault</a></p>
<p>As a function I'd write it as </p>
<pre><code>def get_leaf_dict( dict, key_list):
    res=dict
    for key in key_list:
        res=dict.setdefault( key, {} )
    return res
</code></pre>
<p>This would be used as:</p>
<pre><code>get_leaf_dict( dict, ['Person', 'address', 'city']) = 'New York'
</code></pre>
<p>This could be cleaned up with error handling and such, also using <code>*args</code> rather than a single key-list argument might be nice; but the idea is that
you can iterate over the keys, pulling up the appropriate dictionary at each level.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's another option:</p>
<pre><code>from collections import defaultdict
recursivedict = lambda: defaultdict(recursivedict)
mydict = recursivedict()
</code></pre>
<p>I originally got this from here: <a href="https://stackoverflow.com/a/10218517/1530754">https://stackoverflow.com/a/10218517/1530754</a>.</p>
<p>Quite clever and elegant if you ask me.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my simple solution: just write</p>
<pre><code>terms = ['person', 'address', 'city'] 
result = nested_dict(3, str)
result[terms] = 'New York'  # as easy as it can be
</code></pre>
<p>You can even do:</p>
<pre><code>terms = ['John', 'Tinkoff', '1094535332']  # account in Tinkoff Bank
result = nested_dict(3, float)
result[terms] += 2375.30
</code></pre>
<p>Now the backstage:</p>
<pre><code>from collections import defaultdict


class nesteddict(defaultdict):
    def __getitem__(self, key):
        if isinstance(key, list):
            d = self
            for i in key:
                d = defaultdict.__getitem__(d, i)
            return d
        else:
            return defaultdict.__getitem__(self, key)
    def __setitem__(self, key, value):
        if isinstance(key, list):
            d = self[key[:-1]]
            defaultdict.__setitem__(d, key[-1], value)
        else:
            defaultdict.__setitem__(self, key, value)


def nested_dict(n, type):
    if n == 1:
        return nesteddict(type)
    else:
        return nesteddict(lambda: nested_dict(n-1, type))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I took the freedom to extend the code from the answer of <a href="https://stackoverflow.com/a/13688108/3469861">Bakuriu</a>. Therefore upvotes on this are optional, as his code is in and of itself a witty solution, which I wouldn't have thought of. </p>
<pre><code>def nested_set(dic, keys, value, create_missing=True):
    d = dic
    for key in keys[:-1]:
        if key in d:
            d = d[key]
        elif create_missing:
            d = d.setdefault(key, {})
        else:
            return dic
    if keys[-1] in d or create_missing:
        d[keys[-1]] = value
    return dic
</code></pre>
<p>When setting <code>create_missing</code> to True, you're making sure to only set already existing values:</p>
<pre><code># Trying to set a value of a nonexistent key DOES NOT create a new value
print(nested_set({"A": {"B": 1}}, ["A", "8"], 2, False))
&gt;&gt;&gt; {'A': {'B': 1}}

# Trying to set a value of an existent key DOES create a new value
print(nested_set({"A": {"B": 1}}, ["A", "8"], 2, True))
&gt;&gt;&gt; {'A': {'B': 1, '8': 2}}

# Set the value of an existing key
print(nested_set({"A": {"B": 1}}, ["A", "B"], 2))
&gt;&gt;&gt; {'A': {'B': 2}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use these pair of methods</p>
<pre><code>def gattr(d, *attrs):
    """
    This method receives a dict and list of attributes to return the innermost value of the give dict
    """
    try:
        for at in attrs:
            d = d[at]
        return d
    except:
        return None


def sattr(d, *attrs):
    """
    Adds "val" to dict in the hierarchy mentioned via *attrs
    For ex:
    sattr(animals, "cat", "leg","fingers", 4) is equivalent to animals["cat"]["leg"]["fingers"]=4
    This method creates necessary objects until it reaches the final depth
    This behaviour is also known as autovivification and plenty of implementation are around
    This implementation addresses the corner case of replacing existing primitives
    https://gist.github.com/hrldcpr/2012250#gistcomment-1779319
    """
    for attr in attrs[:-2]:
        # If such key is not found or the value is primitive supply an empty dict
        if d.get(attr) is None or isinstance(d.get(attr), dict):
            d[attr] = {}
        d = d[attr]
    d[attrs[-2]] = attrs[-1]
</code></pre>
</div>
<span class="comment-copy">What's wrong with <code>dict[x][y][z] = value</code>?  Where do you get <code>value</code> from? What's with the weird format?</span>
<span class="comment-copy">@kreativitea It's wrong because he may have variable-length number of nested keys.</span>
<span class="comment-copy">You may be able to avoid nesting by using tuple keys:  <code>d[tuple(da_list)] = value</code></span>
<span class="comment-copy">The question is: "why do you have to turn this into a nested dictionary?" Are you sure you really need a nested dictionary? Things like this can often be coded better with tuple keys, or other data structures.</span>
<span class="comment-copy">Ultimately the constructed object will be spit out as JSON...where the hierarchy is necessary. But if there's a better way to go from my strings to a stringified JSON object I'm very open to it :) I may be over-engineering the solution!?</span>
<span class="comment-copy">Any clue please why this works? (I've tried it and works) And why a pure for loop does not?</span>
<span class="comment-copy">@charisz This works because inside the <code>for</code> look you re-assign the <code>dic</code> variable to point to the inner dictionary. In the example, when <code>nested_set</code> is set, initially you have <code>dic == d</code>. Then the <code>for</code> loop performs the call <code>dic = dic.setdefault("person", {})</code> which adds the pair <code>"person": {}</code> to <code>d</code> and also <i>returns the referenced <code>{}</code></i>. Now <code>dic is d["person"]</code>, so the next loop sets the key <code>address</code> in the inner dictionary, setting <code>dic</code> to point to the inner-inner dictionary. Etc.  The last key is treated in a special way because you don't want to create dictionaries anymore.</span>
<span class="comment-copy">@Bakuriu It will break for the attached case as it doesn't replace for a pre-assigned key. Refer my implementation for the correct behavior <a href="https://imgur.com/a/pST93yQ" rel="nofollow noreferrer">imgur.com/a/pST93yQ</a></span>
<span class="comment-copy">@nehemiah That's a different behaviour than what the question required. As you can see it adds quite a bit of complexity in the implementation.</span>
<span class="comment-copy">And thank you for this...Bakuriu's answer is slightly more comprehensive/concise, but you were on the same track and I appreciate how quickly you replied.</span>
<span class="comment-copy">This is what I was looking for. thx</span>
<span class="comment-copy">Don't use a bare <code>except:</code>, it should <b>never</b> appear in code. You want to use <code>except KeyError</code> instead. Also your solution breaks if someones uses a different mapping type than <code>dict</code>. You may want to use <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping" rel="nofollow noreferrer"><code>abc.MutableMapping</code></a> or <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping" rel="nofollow noreferrer"><code>abc.Mapping</code></a></span>
