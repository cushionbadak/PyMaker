<div class="post-text" itemprop="text">
<pre><code>from tkinter import *

class GameBoard(Frame):
  def __init__(self):
    top = Toplevel()
    Frame.__init__(self)
    self.master.title("test")
    self.grid()
    #button frame
    self.__buttonPane = Frame(self)
    self.__buttonPane.grid()
    #buttons
    self.__buttonA1 = Button(self.__buttonPane,text = "A1",command = self._test("A"))
    self.__buttonA1.grid()

 def _test(self,test):
    if self.__buttonA1["state"] == NORMAL:
       print(test)


def main():
  GameBoard().mainloop()

main()
</code></pre>
<p>This code will not work due to the variable and if I remove the variable test and make it</p>
<pre><code>from tkinter import *

class GameBoard(Frame):
  def __init__(self):
    top = Toplevel()
    Frame.__init__(self)
    self.master.title("test")
    self.grid()
    #button frame
    self.__buttonPane = Frame(self)
    self.__buttonPane.grid()
    #buttons
    self.__buttonA1 = Button(self.__buttonPane,text = "A1",command = self._test)
    self.__buttonA1.grid()

  def _test(self):
    if self.__buttonA1["state"] == NORMAL:
      print("hi")

def main():
  GameBoard().mainloop()

main()
</code></pre>
<p>How would I fix my code so it would allow for input of a variable?
This is just a test I am doing so I can make it work in a much bigger code.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you specify <code>command = self._test</code>, <code>self._test</code> is a function that will be called. <code>self._test("A")</code> is not a function, it's a call to a function (that returns <code>None</code> because there's no <code>return</code> statement in the definition).</p>
<p>You can write 'a function that calls <code>self._test("A")</code> as either <code>lambda: self._test("A")</code>, or <code>functools.partial(self._test, "A")</code>, or explicitly in <code>GameBoard.__init__</code>:</p>
<pre><code>def _f():
    self._test("A")
self.__buttonA1 = Button(self.__buttonPane,text = "A1",command = _f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is when you do <code>command = self._test("A")</code>, you are calling the function, and using the returned value (which is <code>None</code> in this case).</p>
<p>The solution is to use <a href="http://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial()</code></a>, which takes a function and some values, then gives you a new function which just calls the given function with the values you passed it (and any additional others you pass when you run it):</p>
<pre><code>command = functools.partial(self._test, "A")
</code></pre>
<p>You could also do this manually by making your function return a function:</p>
<pre><code>def _test(self, test):
    def f(self):
        if self.__buttonA1["state"] == NORMAL:
           print(test)
    return f
</code></pre>
<p>Do note that this would impair your ability to call <code>_test()</code> normally elsewhere.</p>
</div>
<div class="post-text" itemprop="text">
<p>When creating handlers for buttons, it is a good idea to pass the button itself to the handler. That way, a single handler can handle many buttons, and the handler is free to examine all the properties of the button.</p>
<p>Here's a simple way to achieve that based on your code:</p>
<pre><code>    self.__buttonA1 = Button(self.__buttonPane,text = "A1")
    self.__buttonA1.grid()
    self._connect_button(self.__buttonA1, self._test)
    self.__buttonA2 = Button(self.__buttonPane,text = "A2")
    self.__buttonA2.grid()
    self._connect_button(self.__buttonA2, self._test)

  def _connect_button(self, button, handler):
    button['command'] = lambda: handler(button)

  def _test(self, button=None):
    if button is not None:
      print("test:text:", button["text"])
      print("test:state", button["state"])
</code></pre>
</div>
<span class="comment-copy">It doesn't make sense to include a variable there, since pressing a button isn't an action you can specify a "value" for: you just either press the button or you don't.  Where do you want the variable value to come from?</span>
<span class="comment-copy">How does the code in the first block not work? What happens in the second block where you have removed the variable? When do you want to enter the input for the variable?</span>
<span class="comment-copy">the lambda worked for me, could you clarify as to why it worked, I tried to read on the function and I would just like to know what it is actually doing here!</span>
<span class="comment-copy">@user1867117 A lambda is a bad way to do this - <code>functools.partial()</code> exists with the purpose of doing this job - use it.</span>
<span class="comment-copy">@user1867117 Writing <code>def _f(): self._test("A")</code> is exactly like writing <code>_f = lambda: self._test("A")</code>. They both set the variable <code>_f</code> to be a function. My example goes with the <code>lambda</code>, but instead of assigning the lambda to a variable, I just use it directly. Lambdas are very slightly slower than <code>functools.partial</code> but are clearer and easier to read. If you are running a lambda more than dozens of times a second, you might want to replace it with a call to <code>functools.partial</code>.</span>
