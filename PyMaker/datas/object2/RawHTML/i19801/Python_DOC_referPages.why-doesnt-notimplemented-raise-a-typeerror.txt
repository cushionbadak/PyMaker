<div class="post-text" itemprop="text">
<p>Suppose I define a class <code>A</code> and I don't want anyone to write an inequality of that class without getting away.</p>
<pre><code>class A():
    def __ne__(self, other):
        return NotImplemented
print(A() != A())
</code></pre>
<p>But this prints out <code>True</code> and doesn't raise a <code>TypeError</code> although I have deliberately "turned off" the <code>!=</code> operator?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you return <code>NotImplemented</code> you indicate that you do not <em>know</em> if <code>__ne__</code> should return <code>True</code> or <code>False</code>.</p>
<p>Normally, Python will then swap the operands; if <code>a != b</code> results in <code>NotImplemented</code>, it'll try <code>b != a</code> instead. That'll fail here too, since you use the same type on both sides of the operator. For the <code>!=</code> operator, Python will then fall back to comparing their memory addresses, and these are not the same (two separate instances), so False is returned.</p>
<p>See the <a href="http://hg.python.org/cpython/file/e456da396ad9/Objects/object.c#l540" rel="nofollow"><code>do_richcompare</code> C function for details</a>.</p>
<p>You'll have to raise <code>TypeError()</code> manually if that is your expected outcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>It gives you True because you are <strong>returning</strong> an exception, an not <strong>raising</strong> it. This means that you are returning a non-Null object (the exception) as result of the test. Non-Null objects are evaluated as True unless otherwise specified.
Remember that the exception is a normal object until you raise it.</p>
<p>so you should have a method looking like this:</p>
<pre><code>class A():
    def __ne__(self, other):
        raise NotImplementedError
</code></pre>
</div>
<span class="comment-copy">The simplicity of the 3.x rich comparison implementation is a welcome relief. In 2.x instead of calling <code>__ne__</code> twice, Python calls it 6 times (twice when <code>slot_tp_richcompare</code> is called by <code>PyObject_RichCompare</code>, then 4 more times when <code>try_rich_compare</code> tries in normal and swapped order). Finally it gets to the pointer comparison in <code>default_3way_compare</code>, complicated by having to cast to <code>uintptr_t</code> to support ordering.</span>
<span class="comment-copy">Yeah, I was quite relieved to see the <code>python-3.x</code> tag on this question. Having to go into detail on how this all works in python 2 would have lead to a <i>slightly</i> longer answer. However, I count only <i>4</i> calls to <code>__ne__</code> for <code>A() != A()</code>, in the order LR, RL, RL, LR (for the left-hand and right-hand instances).</span>
<span class="comment-copy">No, it is <i>not</i> an exception. Read the documentation for <a href="http://docs.python.org/3/reference/datamodel.html#object.__ne__" rel="nofollow noreferrer"><code>__ne__</code></a>; it is a singleton for just this purpose.</span>
<span class="comment-copy">True, I was thinking about the exception. Don't get me wrong, but the documentation is flawed in this sense, as the bool() of NotImplemented return True, and doesn't give any kind a meaningful error. So, the correct procedure is to raise an exception, as least in the intention of the OP (as far as I can understand it)</span>
<span class="comment-copy">No, <code>NotImplemented</code> is a very useful sentinel value (that is, a value to indicate that there is no implementation for something).</span>
<span class="comment-copy"><code>NotImplemented</code> is a special singleton used for this kind of context. The Python comparison code tests for it specifically. I feel a dedicated exception would perhaps have been a better choice (such as <code>StopIteration</code>) but this is a holdover from the very early days of Python, I guess. However, there are probably edge cases where an exception is not the appropriate response. There are more uses of <code>NotImplemented</code> (and the C API equivalent <code>Py_NotImplemented</code>), in numeric coercion, for example.</span>
