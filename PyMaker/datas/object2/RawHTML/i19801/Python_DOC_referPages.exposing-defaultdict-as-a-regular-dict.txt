<div class="post-text" itemprop="text">
<p>I am using <code>defaultdict(set)</code> to populate an internal mapping in a very large data structure. After it's populated, the whole structure (including the mapping) is exposed to the client code. At that point, I don't want anyone modifying the mapping. </p>
<p>And nobody does, intentionally. But sometimes, client code may by accident refer to an element that doesn't exist. At that point, a normal dictionary would have raised <code>KeyError</code>, but since the mapping is <code>defaultdict</code>, it simply creates a new element (an empty set) at that key. This is quite hard to catch, since everything happens silently. But I need to ensure this doesn't happen (the semantics actually doesn't break, but the mapping grows to a huge size).</p>
<p>What should I do? I can see these choices:</p>
<ol>
<li><p>Find all the instances in current and future client code where a dictionary lookup is performed on the mapping, and convert it to <code>mapping.get(k, {})</code> instead. This is just terrible.</p></li>
<li><p>"Freeze" <code>defaultdict</code> after the data structure is fully initialized, by converting it to <code>dict</code>. (I know it's not really frozen, but I trust client code to not actually write <code>mapping[k] = v</code>.) Inelegant, and a large performance hit.</p></li>
<li><p>Wrap <code>defaultdict</code> into a <code>dict</code> interface. What's an elegant way to do that? I'm afraid the performance hit may be huge though (this lookup is heavily used in tight loops).</p></li>
<li><p>Subclass <code>defaultdict</code> and add a method that "shuts down" all the <code>defaultdict</code> features, leaving it to behave as if it's a regular <code>dict</code>. It's a variant of 3 above, but I'm not sure if it's any faster. And I don't know if it's doable without relying on the implementation details.</p></li>
<li><p>Use regular <code>dict</code> in the data structure, rewriting all the code there to first check if the element is in the dictionary and adding it if it's not. Not good.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="noreferrer"><code>defaultdict</code></a> docs say for <code>default_factory</code>:</p>
<blockquote>
<p>If the default_factory attribute is None, this raises a KeyError
  exception with the key as argument.</p>
</blockquote>
<p>What if you just set your defaultdict's default_factory to <code>None</code>? E.g.,</p>
<pre><code>&gt;&gt;&gt; d = defaultdict(int)
&gt;&gt;&gt; d['a'] += 1
&gt;&gt;&gt; d
defaultdict(&lt;type 'int'&gt;, {'a': 1})
&gt;&gt;&gt; d.default_factory = None
&gt;&gt;&gt; d['b'] += 2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'b'
&gt;&gt;&gt; 
</code></pre>
<p>Not sure if this is the best approach, but seems to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>Once you have finished populating your defaultdict, you can simply create a regular dict from it:</p>
<pre><code>my_dict = dict(my_default_dict)
</code></pre>
<p>The regular dict is of course effectively frozen.</p>
<p>If your default dict is a recursive default dict, see <a href="https://stackoverflow.com/a/30921635/832230">this answer</a> which uses a recursive solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could make a class that holds a reference to your dict and prevent <strong>setitem</strong>()</p>
<pre><code>from collections import Mapping

class MyDict(Mapping):
    def __init__(self, d):
        self.d = d;

    def __getitem__(self, k):
        return self.d[k]

    def __iter__(self):
        return self.__iter__()

    def __setitem__(self, k, v):
        if k not in self.d.keys():
            raise KeyError
        else:
            self.d[k] = v
</code></pre>
</div>
<span class="comment-copy">the "rewriting" would just use the <code>dict.setdefault</code> method... No big deal</span>
<span class="comment-copy">@JBernardo Are you talking about option 4? All I know about <code>defaultdict</code> is that it overrides <code>__getitem__</code> to add an element if needed. Maybe it does that using <code>setdefault</code> method, maybe it implements the same logic directly without ever calling <code>setdefault</code>. Without relying on implementation details, I can't assume anything, can I?</span>
<span class="comment-copy">He is referring to your option #5. Just use your data.setdefault() in your code in replacement of defaultdict</span>
<span class="comment-copy">I think you should be able to get away with just calling <code>dict</code> on teh <code>defaultdict</code> to dictify it</span>
<span class="comment-copy">@inspectorG4dget the size of the data structure is over 1 GB, so copying all the data (as would happen if I call <code>dict</code>) is too expensive.</span>
<span class="comment-copy">Who knew that the solution I proposed was already implemented as a feature of <code>defaultdict</code>?  Great find.  (+1)</span>
<span class="comment-copy">Wow, this is perfect. I hope it's safe to change <code>default_factory</code> for an existing <code>defaultdict</code> object (I don't see why not).</span>
<span class="comment-copy">first rate solution. +1 I learned something new!</span>
<span class="comment-copy">@max -- The documentation specifically says that <code>default_factory</code> is a <b>writable</b> attribute, so it should be safe.</span>
<span class="comment-copy">@max: Use the source: <a href="http://hg.python.org/cpython/file/3d0686d90f55/Modules/_collectionsmodule.c#l1253" rel="nofollow noreferrer"><code>defdictobject</code></a>, <a href="http://hg.python.org/cpython/file/3d0686d90f55/Modules/_collectionsmodule.c#l1375" rel="nofollow noreferrer"><code>defdict_members</code></a> (name, type, offset, flags, doc; <code>flags==0</code> means it's writable), <a href="http://hg.python.org/cpython/file/3d0686d90f55/Modules/_collectionsmodule.c#l1262" rel="nofollow noreferrer"><code>defdict_missing</code></a>.</span>
<span class="comment-copy">Wouldn't it be super slow, given that it uses pure python for critical methods?</span>
<span class="comment-copy">For the getitem method?  Not sure the performance overhead with that vs. defaultdict's</span>
<span class="comment-copy">Either way, I think Neal's solution is best for your problem</span>
