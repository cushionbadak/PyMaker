<div class="post-text" itemprop="text">
<p>Both these functions compute the same thing (the numbers of integers such that the length of the associated Collatz sequence is no greater than n) in essentially the same way. The only difference is that the first one uses sets exclusively whereas the second uses both sets and lists.</p>
<p>The second one leaks memory (in IDLE with Python 3.2, at least), the first one does not, and  I have no idea why. I have tried a few "tricks" (such as adding <code>del</code> statements) but nothing seems to help (which is not surprising, those tricks <em>should be</em> useless).</p>
<p>I would be grateful to anybody who could help me understand what goes on.</p>
<p><em>If you want to test the code, you should probably use a value of <code>n</code> in the 55 to 65 range, anything above 75 will almost certainly result in a (totally expected) memory error.</em></p>
<pre class="lang-py prettyprint-override"><code>def disk(n):
    """Uses sets for explored, current and to_explore. Does not leak."""
    explored = set()
    current = {1}
    for i in range(n):
        to_explore = set()
        for x in current:
            if not (x-1) % 3 and ((x-1)//3) % 2 and not ((x-1)//3) in explored:
                to_explore.add((x-1)//3)
            if not 2*x in explored:
                to_explore.add(2*x)
        explored.update(current)
        current = to_explore
    return len(explored)

def disk_2(n):
    """Does exactly the same thing, but Uses a set for explored and lists for
        current and to_explore. 
       Leaks (like a sieve :))
    """
    explored = set()
    current = [1]
    for i in range(n):
        to_explore = []
        for x in current:
            if not (x-1) % 3 and ((x-1)//3) % 2 and not ((x-1)//3) in explored:
                to_explore.append((x-1)//3)
            if not 2*x in explored:
                to_explore.append(2*x)
        explored.update(current)
        current = to_explore
    return len(explored)
</code></pre>
<p><strong>EDIT</strong> : This also happens when using the interactive mode of the interpreter (without IDLE), but not when running the script directly from a terminal (in that case, memory usage goes back to normal some time after the function has returned, or as soon as there is an explicit call to <code>gc.collect()</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>CPython <a href="http://hg.python.org/cpython/file/3d0686d90f55/Objects/obmalloc.c#l20" rel="nofollow">allocates small objects</a> (obmalloc.c, 3.2.3) out of 4 KiB pools that it manages in 256 KiB blocks called arenas. Each active pool has a fixed block size ranging from 8 bytes up to 256 bytes, in steps of 8. For example, a 14-byte object is allocated from the first available pool that has a 16-byte block size. </p>
<p>There's a potential problem if arenas are allocated on the heap instead of using mmap (this is tunable via <a href="http://www.gnu.org/software/libc/manual/html_node/Malloc-Tunable-Parameters.html" rel="nofollow">mallopt's <code>M_MMAP_THRESHOLD</code></a>), in that the heap cannot shrink below the highest allocated arena, which will not be released so long as 1 block in 1 pool is allocated to an object (CPython doesn't float objects around in memory).</p>
<p>Given the above, the following version of your function should probably solve the problem. Replace the line <code>return len(explored)</code> with the following 3 lines:</p>
<pre><code>    result = len(explored)
    del i, x, to_explore, current, explored
    return result + 0
</code></pre>
<p>After deallocating the containers and all referenced objects (releasing arenas back to the system), this returns a new <code>int</code> with the expression <code>result + 0</code>. The heap cannot shrink as long as there's a reference to the first result object. In this case that gets automatically deallocated when the function returns.</p>
<p>If you're testing this interactively without the "plus 0" step, remember that the REPL (Read, Eval, Print, Loop) keeps a reference to the last result accessible via the pseudo-variable  "<code>_</code>". </p>
<p>In Python 3.3 this shouldn't be an issue since the object allocator was modified to <a href="http://hg.python.org/cpython/file/bd8afb90ebf2/Objects/obmalloc.c#l595" rel="nofollow">use anonymous mmap for arenas</a>, where available. (The upper limit on the object allocator was also bumped to 512 bytes to accommodate 64-bit platforms, but that's inconsequential here.)</p>
<p>Regarding manual garbage collection, <code>gc.collect()</code> does a full collection of tracked container objects, but it also <a href="http://hg.python.org/cpython/file/bd8afb90ebf2/Modules/gcmodule.c#l802" rel="nofollow">clears freelists</a> of objects that are maintained by built-in types (e.g. frames, methods, floats). Python 3.3 added additional API functions to clear freelists used by lists (<a href="http://docs.python.org/3/c-api/list.html#PyList_ClearFreeList" rel="nofollow"><code>PyList_ClearFreeList</code></a>), dicts (<a href="http://docs.python.org/3/c-api/dict.html#PyDict_ClearFreeList" rel="nofollow"><code>PyDict_ClearFreeList</code></a>), and sets (<a href="http://docs.python.org/3/c-api/set.html#PySet_ClearFreeList" rel="nofollow"><code>PySet_ClearFreeList</code></a>). If you'd prefer to keep the freelists intact, use <code>gc.collect(1)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I doubt it leaks, I bet it is just that garbage collection doesn't kick in yet, so memory used keeps growing. This is because every round of outer loop, the previous current list becomes elgible for garbage collection, but will not be garbage collected until whenever.</p>
<p>Furthermore, even if it is garbage collected, memory isn't normally released back to the OS, so you have to use whatever Python method to get current used heap size.</p>
<p>If you add garbage collection at end of every outer loop iteration, that may reduce memory use a bit, or not, depending on how exactly Python handles its heap and garbage collection without that.</p>
</div>
<div class="post-text" itemprop="text">
<p>You do not have a memory leak. Processes on linux do not release memory to the OS until they exit. Accordingly, the stats you will see in e.g. <code>top</code> will only ever go up. </p>
<p>You only have a memory leak if after running the same, or smaller size of job, Python grabs more memory from the OS, when it "should" have been able to reuse the memory it was using for objects which "should" have been garbage collected.</p>
</div>
<span class="comment-copy">How do you measure the memory leak? Did you tried checking it outside of interactive environment like IDLE?</span>
<span class="comment-copy">Show your measurements of the leak. In both cases, you are allocating lists and sets, and in both cases, all of those objects remain reachable through the activation of the function, so they will not be garbage collected.</span>
<span class="comment-copy">@Marcin : the problem is not memory usage while the function is executed. That is about what you would expect (an upward trend, with occasional decreases when some former version of <code>current</code> or <code>to_explore</code> gets garbage-collected). The problem is that the memory is not freed after <code>disk_2</code> has returned (even if you call <code>gc.collect()</code> explicitly). For n=65, usage peaks at 800MB and stays at ~200MB after <code>disk_2</code> has returned.</span>
<span class="comment-copy">@user36732 What do you mean "the memory is not freed"? Do you mean that the process image does not take up less memory? If so, that is probably because you are running this on linux, right?</span>
<span class="comment-copy">1) If your running CPython, the gc.collect() won't matter here, as you don't create any reference cycles (those are just a <code>set()</code> and a <code>list()</code> with numbers right?). In this case CPython "collects" objects as soon as they loose their last reference. 2) We still don't know how you measure the memory usage, which could be the crux of the problem.</span>
<span class="comment-copy">When I say it leaks, I mean that memory usage does not go back to normal after the function has returned (even if you call gc.collect() explicitly).</span>
<span class="comment-copy">Even if the memory doesn't go back to "normal" after a <code>gc.collect()</code> call that doesn't mean there's a leak unless overall it keeps getting larger doing the thing over and over.</span>
<span class="comment-copy">@user36732 are you looking at memory reserved from OS, or what? Memory is not not released back to OS even if it is garbage collected and made unallocated heap memory.</span>
<span class="comment-copy">@hyde I was wrong that the list being added to the set - I see that the set is being <code>updated</code>, so the list is not added to the set at all. When an item is <code>add</code>ed to a set, a reference to that item is stored in that set. That is fundamentally what <code>add</code> does.</span>
<span class="comment-copy">@Marcin Why would <code>explored</code> contain a reference to <code>current</code> ? <code>some_set.update(some_list)</code> should be equivalent to <code>some_set.update(set(some_list))</code>, right?</span>
