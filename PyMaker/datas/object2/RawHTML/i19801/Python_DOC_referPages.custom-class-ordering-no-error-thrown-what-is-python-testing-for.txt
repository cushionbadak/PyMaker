<div class="post-text" itemprop="text">
<p>Without specifying the equality comparison properties of objects, Python is still doing something when using <code>&gt;</code> and <code>&lt;</code>. What is Python actually comparing these objects by if you don't specify <code>__gt__</code> or <code>__lt__</code>? I would expect an unsupported operand error here, as you get when trying to add two objects together without defing <code>__add__</code>. </p>
<p><pre><code>
In [1]: class MyObject(object):
   ...:     pass
   ...: 
In [2]: class YourObject(object):
   ...:     pass
   ...: 
In [3]: me = MyObject()
In [4]: you = YourObject()
In [5]: me &gt; you
Out[5]: False
In [6]: you &gt; me
Out[6]: True
</code></pre></p></div>
<div class="post-text" itemprop="text">
<p>An arbitrary order is imposed for objects. The ordering is only defined to be <a href="http://docs.python.org/2/reference/expressions.html#not-in" rel="nofollow">stable within a program execution</a>.</p>
<p>This means it's up to the Python implementation to define an ordering when comparing arbitrary objects. CPython uses the memory address if the types are the same (from the <a href="http://hg.python.org/cpython/file/23ebb8936bf6/Objects/object.c#l756" rel="nofollow">C source</a>):</p>
<pre><code>if (v-&gt;ob_type == w-&gt;ob_type) {
    /* When comparing these pointers, they must be cast to
     * integer types (i.e. Py_uintptr_t, our spelling of C9X's
     * uintptr_t).  ANSI specifies that pointer compares other
     * than == and != to non-related structures are undefined.
     */
    Py_uintptr_t vv = (Py_uintptr_t)v;
    Py_uintptr_t ww = (Py_uintptr_t)w;
    return (vv &lt; ww) ? -1 : (vv &gt; ww) ? 1 : 0;
}
</code></pre>
<p>The same value is the basis for the <code>id()</code> function, and is also represented in the default <code>repr()</code> string for custom classes, so it may <em>appear</em> that the <code>repr()</code> of classes determine ordering. It's only the memory address that does.</p>
<p>For objects that are <em>not</em> the same type, the type <em>name</em> is used instead (with number-like types sorting before others), and if the types differ but their <em>names</em> are the same, the code falls back to the memory address of the type (as opposed to the memory address of the instance when the types are the same).</p>
<p>This implicit ordering has been considered an error in the language, and has been <a href="http://docs.python.org/3/whatsnew/3.0.html#ordering-comparisons" rel="nofollow">remedied in Python 3</a>:</p>
<blockquote>
<p>The ordering comparison operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>) raise a <code>TypeError</code> exception when the operands donâ€™t have a meaningful natural ordering.</p>
</blockquote>
<p>This applies to custom classes that do not implement the necessary <a href="http://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow">ordering hooks</a>:</p>
<pre><code>&gt;&gt;&gt; class Foo(): pass
... 
&gt;&gt;&gt; Foo() &lt; Foo()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: Foo() &lt; Foo()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>EDIT: See the update after reading! The completely correct answer is "undefined, but consistent".</p>
<p>It's testing <code>repr(me)</code> vs <code>repr(you)</code> which essentially is doing string comparison. Here is an easy to see example:</p>
<pre><code>class A(object): pass

class B(object): pass

x = A() # &lt;__main__.A object at 0x7f7014e4e2d0&gt;
y = B() # &lt;__main__.B object at 0x7f7014e4e310&gt;
z = A() # &lt;__main__.A object at 0x7f7014e4e390&gt;

x &lt; z &lt; y # True (assuming that the memory addresses are ordered as above)
</code></pre>
<p>I agree that this seems a little strange to me. Perhaps there's a good reason for this that I am not aware of?</p>
<p><strong>UPDATE</strong>: I am wrong about <code>repr</code>, though it does look like it uses the base <code>object</code> repr in test. <a href="http://docs.python.org/2/reference/expressions.html#not-in" rel="nofollow">http://docs.python.org/2/reference/expressions.html#not-in</a></p>
<p>There is a line there that states "The choice whether one object is considered smaller or larger than another one is made arbitrarily but consistently within one execution of a program." In other words, it <em>might</em> be using <code>repr</code> but that's not guaranteed. It will, however, be consistently done.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python uses the object's <code>repr()</code> if there are no rich comparison operators. (At least, this is valid for Py2; I don't know for Py3).</p>
<p>So if you do</p>
<pre><code>class A(object): pass
class B(object): pass
l = [A() if i % 2 else B() for i in range(1000)]
l.sort()
</code></pre>
<p>the objects are sorted by their <code>repr()</code>, the <code>A()</code> coming first and then the <code>B()</code>.</p>
</div>
<span class="comment-copy">OK, so its the string representaion of the memory address that is being compared? i.e. <code>0x162afd0</code> vs <code>0x162afd0</code></span>
<span class="comment-copy">@reptilicus: it's the actual memory address that is being compared. The <i>default</i> <code>repr()</code> return value contains a hex representation of the memory address, but that's not what is used for the comparison. You can provide a <i>custom</i> <code>__repr__()</code> hook for example, and that won't change the ordering (or the memory address).</span>
<span class="comment-copy">@reptilicus It uses the memory if the classes are the same type. Martijn's answer is good and more thorough than my own.</span>
<span class="comment-copy">gotcha. THanks, going to mark this as accepted. I still don't like or understand the logic though!</span>
<span class="comment-copy">@reptilicus: logic is that it was a mistake and it is now fixed in py3k.</span>
<span class="comment-copy">any reference regarding <code>repr</code> testing?</span>
<span class="comment-copy">Is there documentation on this?</span>
<span class="comment-copy">This is demonstrably wrong. Custom classes with a <code>__repr__()</code> hook cannot alter their ordering by returning different values for <code>repr(instance)</code>.</span>
<span class="comment-copy">@MartijnPieters You are correct, I updated my answer.</span>
<span class="comment-copy">So, there is nothing whatsoever indicating that <code>repr</code> is involved in ordering then.</span>
<span class="comment-copy">In the case presented above, it is using <code>repr</code>, not <code>id</code>.</span>
<span class="comment-copy">I just tested and stand corrected.</span>
<span class="comment-copy">yeah, Its not the objects ID, I tested that.</span>
