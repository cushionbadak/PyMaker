<div class="post-text" itemprop="text">
<p>I've written a simple Python script to copy a file from one place to another. (It's for class, so that's why I'm not using something simpler like <code>shutil</code>. I have a check at the end that compares the hash of the two files, and it consistently tells me they're different, even though the copying is successful - both are text files that say "hello world".</p>
<p>Here is my code:</p>
<pre><code>import os

def validity_checker(address1, dest_name):
    try:
        src = open(address1, 'rb')
        dest = open(dest_name, 'wb+')
    except IOError:
        return False
    return True


def copaste(address1, address2):
    # concatenate address2 into filename
    file_ending = address1.split('\\').pop()
    dest_name = address2 + '\\' + file_ending

    # copy file after calling checker
    if validity_checker(address1, dest_name):
        src = open(address1, 'rb')
        dest = open(dest_name, 'wb+')
        contents = src.read()
        dest.write(contents)
        src.close()
        dest.close()
    else:
        print("File name bad. No action taken")

    print src
    print dest
    print(hash(src))  #hash the file not the string
    print(hash(dest))
    return
</code></pre>
<p>And the output:</p>
<pre><code>&lt;closed file 'C:\\Users\\user\\Downloads\\hello.txt', mode 'rb' at 0x04B7D1D8&gt;
&lt;closed file 'C:\\Users\\user\\Downloads\\dest\\hello.txt', mode 'wb+' at 0x04C2B860&gt;
-2042961099
4991878
</code></pre>
<p>Plus the file is copied.</p>
<p>I'm fairly sure the hash is checking the file itself, not the string. Is it maybe something to do with metadata? Any help would be greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are using the <strong>Python-specific</strong> <a href="https://docs.python.org/3/library/functions.html#hash" rel="nofollow noreferrer"><code>hash()</code> function</a>, which calculates a hash for use on <em>dictionary keys and <code>set</code> contents</em>.</p>
<p>For file objects, the <code>hash()</code> is based on the object identity; you can't base it on anything else because two distinct file objects are never <em>equal</em>, the <code>fileobject.__eq__</code> method returns <code>True</code> only if both objects are one and the same in memory (so <code>is</code> would be true too). The file contents, the name of the file, the mode or any of the other object attributes play no role in the hash value produced.</p>
<p>From the function documentation:</p>
<blockquote>
<p>Return the hash value of the object (if it has one). Hash values are integers. <strong>They are used to quickly compare dictionary keys during a dictionary lookup.</strong></p>
</blockquote>
<p>If you need to validate that the file copy contains the same data, you need to hash the •file contents* using a <em>cryptographic hash function</em>, which is something completely different. Use the <a href="https://docs.python.org/3/library/hashlib.html" rel="nofollow noreferrer"><code>hashlib</code> module</a>; for your usecase the simple and fast <code>MD5</code> algorithm will do:</p>
<pre><code>for closed_file in (src, dest):
    with open(closed_file.name, 'rb') as reopened:  # opened in binary mode!
        print(reopened.name)
        print(hashlib.md5(reopened.read()).hexdigest())
</code></pre>
<p>If the binary contents of the two files is exactly the same, then their cryptographic hash will also be the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are getting the python hash of the <code>file</code> object. Not the contents of the file. As a minimum you should </p>
<pre><code>print(hash(open(address1, 'rb').read())
print(hash(open(dest_name, 'rb').read())
</code></pre>
<p>But since this still risks collisions, you should do as Martijn suggests and use a <code>hashlib</code> function.</p>
</div>
<span class="comment-copy"><code>hash()</code> is not a cryptographic hash function.</span>
<span class="comment-copy">What is <code>file</code> here? You never defined that name. Did you mean <code>print(hash(src))</code> perhaps? Not that that'll change the outcome.</span>
<span class="comment-copy">I did, thanks - fixed</span>
<span class="comment-copy">Thanks for your answer, I feel very foolish. However, even after switching to the hashlib library, the problem still exists. I've updated the question to reflect this.</span>
<span class="comment-copy">Please don’t do that; your original error has been resolved , you have a new problem warranting a new question. I’ve rolled back your edit. Your new problem is that you didn’t reopen the <code>src</code> file, nor did you do a seek back to the start so <code>src.read()</code> produces an empty string the second time. You are comparing the hash of <code>b''</code> so the comparison fails. Please do use the code I posted in my answer!</span>
<span class="comment-copy">My apologies for the breach of etiquette, and thanks once again for the help. I'd assumed that closing and re-opening the file couldn't have been important - now I know better!</span>
