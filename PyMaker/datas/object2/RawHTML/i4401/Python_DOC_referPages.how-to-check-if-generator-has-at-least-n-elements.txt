<div class="post-text" itemprop="text">
<p>Python doesn't provide <code>len()</code> on generators. What is most efficient way to check if generator contains at least N elements.</p>
<p>Some test cases:</p>
<pre><code>&gt;&gt;&gt; iter_len_at_least(range(3), 3) 
True
&gt;&gt;&gt; iter_len_at_least(range(3), 4)
False
</code></pre>
<p>My naive implementation:</p>
<pre><code>import itertools

def iter_len_at_least(i, n):
    return len(list(None for x in itertools.islice(i, 0, n))) == n
</code></pre>
<p>Is there any more pythonic way to do this check?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> the iterator with <code>range(n)</code> and then iterate and count the elements:</p>
<pre><code>def iter_len_at_least(i, n):
    return sum(1 for _ in zip(range(n), i)) == n
</code></pre>
<hr/>
<p>Keep in mind that this will consume the next <code>n</code> elements of the iterator:</p>
<pre><code>it = iter(range(5))
iter_len_at_least(it, 3)
print(list(it))
# output: [3, 4]
</code></pre>
<p>There's no way to avoid this, but we can split the iterator into two with <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>itertools.tee</code></a> and return one of the new iterators along with the result:</p>
<pre><code>def iter_len_at_least(i, n):
    i, it = itertools.tee(i)
    return it, sum(1 for _ in zip(range(n), i)) == n
</code></pre>
<pre><code>it = iter(range(5))
it, result = iter_len_at_least(it, 3)
print(result)
print(list(it))
# output:
# True
# [0, 1, 2, 3, 4]
</code></pre>
</div>
<span class="comment-copy">Note that <code>itertools.islive()</code> will chomp up the first n entries from the input iterator. (Also note that <code>range()</code> does not return an iterator but a range object since python 3)</span>
