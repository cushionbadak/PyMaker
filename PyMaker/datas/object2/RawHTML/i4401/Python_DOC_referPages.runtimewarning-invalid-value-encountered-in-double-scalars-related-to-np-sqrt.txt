<div class="post-text" itemprop="text">
<p>I have defined a mathematical function with np.sqrt(a positive number) in it.
It returns me RuntimeWarning.</p>
<p>After I simplify it to a very simple mathematical function that anyone can solve manually, it still return me the error.
Below is the simplified function:</p>
<pre><code>import numpy as np
n=30
def f0(x,k):
    bot = 9.37 * 10**(-4) * k**(0.25)
    x_0 = 2*bot
    #print(x_0)
    E_c = 4730 * np.sqrt(k)
    #print(E_c)
    r = E_c/(E_c - k/bot)
    #print(r)
    top = x/(1+(x/x_0)**n)**(1/n) 

    return (top/bot)**r

a = f0(-0.001,36)
</code></pre>
<p>It returns:</p>
<pre><code>RuntimeWarning: invalid value encountered in double_scalars
</code></pre>
<p>And <code>a</code> is <code>nan</code></p>
<p>It works well if the input <code>x &gt;= 0</code>, or I remove <code>np.sqrt()</code> to the result of the square root of the number inside the <code>np.sqrt()</code>.</p>
<p>What's reason of that.</p>
<p>I have noticed the type of np.sqrt is a bit different to another number. Is this the reason?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your issue is not with the <code>numpy</code> square root. The value you are trying to return to <code>a</code>, involves raising a negative number to a non-integer power. This is mathematically undefined.</p>
<p>The mathematical operation, although I am quite sure python uses a different numerical approximation, is:</p>
<pre><code>x = 5
r = 1.234
x**r # 7.2866680501380845
import math
math.exp(r*math.log(x)) # 7.286668050138084
</code></pre>
<p>Now imagine what happens if <code>r</code> is negative: you try to take the natural logarithm of a negative number. This will result in a <code>NaN</code>. Depending on the function used, you will be presented with a range of errors.</p>
<p>The solution is to enforce the quantity <code>top/bot</code> to be positive.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you call your function with the values <code>f0(-0.001,36)</code>, you can see the value of your variables.</p>
<pre><code>(top/bot) # value -0.43569721500945896
r # value 2.2355433614695648
</code></pre>
<p>Sometimes, the roots you will find are imaginary when you have negative number and fractional exponential, however sometimes it will just throw you an error. For a little more information you can check <a href="https://stackoverflow.com/a/27949775/2237916">this respose</a>.</p>
</div>
<span class="comment-copy">Thank you for you answer. Excluding the solution in the other answer, is there any other solution? Since the value r will vary by changing the input and I can't avoid the base to be negative. Dirty fix may not be allowed as the function will be applied into more sophisticated algorithm that probably induce unexpected error.</span>
<span class="comment-copy">This is entirely dependent on the application. If you need it to go into complex math, you'll need to add provisions for that. If you don't, it might be solved just by exception handling. (encasing it in a <code>try</code>....<code>except 'AssertionError'</code> , with <code>assert top/bot &gt;=0</code></span>
<span class="comment-copy">if you'd like it to be complex, <code>return complex(top/bot)**r</code> would do the trick. See the documentation page for more info on how to work with complex numbers in python: <a href="https://docs.python.org/3/library/cmath.html" rel="nofollow noreferrer">docs.python.org/3/library/cmath.html</a></span>
<span class="comment-copy">That is pretty clear. Thank you!</span>
