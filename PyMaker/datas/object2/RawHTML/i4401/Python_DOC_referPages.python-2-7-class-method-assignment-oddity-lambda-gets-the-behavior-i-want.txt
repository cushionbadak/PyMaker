<div class="post-text" itemprop="text">
<p>I have the following Python 2.7 code:</p>
<pre><code>from collections import namedtuple

Point = namedtuple('Point',['x','y'])
Point2 = namedtuple('Point2',['x','y'])

Point._revert = tuple
Point2._revert = lambda s: tuple(s)

for pointClass in [Point,Point2]:
    instance = pointClass(x=10,y=20)
    print "{} reverts to {}".format(instance,instance._revert())
</code></pre>
<p>The output is;</p>
<pre><code>Point(x=10, y=20) reverts to ()
Point2(x=10, y=20) reverts to (10, 20)
</code></pre>
<p>So, what about the lambda is making the Point2._revert call work?</p>
<hr/>
<p>A simpler, standalone, example, requiring no imports:</p>
<pre><code>class A(tuple):

    fTuple = tuple
    fLambda = lambda s: tuple(s)


a = A((1,2))

print repr(a.fTuple())
print repr(a.fLambda())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>tuple</code> is a class, that does not require a parameter to be constructed.</p>
<p>Calling <code>instance.tuple()</code> returns <code>tuple()</code> which is just an empty tuple.</p>
<p>The difference with your anonymous function is that it is a function. When calling a class function from outside of the functional scope using <code>instance.function()</code>, <code>self</code> is automatically passed in as a parameter. Classes don't have this same treatment.</p>
<p>What's passed in is <code>._revert(instance)</code>, which calls <code>tuple(instance)</code> which actually reverts your tuple. </p>
<pre><code>from collections import namedtuple

Point = namedtuple('Point',['x','y'])
Point2 = namedtuple('Point2',['x','y'])


class test:
    def __init__(self):
        print(self)

def func(a):
    print(a)


Point._revert = test
Point2._revert = func

instance = Point(x=10,y=20)
instance._revert()
&gt;&gt;&gt;&lt;__main__.test object at 0x0000020ECAE1DFD0&gt;

instance = Point2(x=10,y=20)
instance._revert()
&gt;&gt;&gt;Point2(x=10, y=20)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The brief answer is that the lambda implements the method <code>__get__</code>:</p>
<pre><code>&gt;&gt;&gt; (lambda s: tuple(s)).__get__
&lt;method-wrapper '__get__' of function object at 0x101a37b90&gt;
</code></pre>
<p>See the <a href="https://docs.python.org/2/howto/descriptor.html" rel="nofollow noreferrer">descriptor documentation</a> for what this means, but basically, when the value stored in an attribute has a <code>__get__</code> method, reading that attribute returns the result of the <code>__get__</code> method on the value, not the value itself.</p>
<p>So, in the code:</p>
<pre><code>globalLambda  = lambda s: tuple(s)

class A(object):
    attrLambda = globalLambda

a = A()
print globalLambda # --&gt; &lt;function &lt;lambda&gt; at 0x102137b90&gt;
print A.attrLambda # --&gt; &lt;unbound method A.&lt;lambda&gt;&gt;
print a.attrLambda # --&gt; &lt;bound method A.&lt;lambda&gt; of &lt;__main__.A object at 0x102134790&gt;&gt;
</code></pre>
<p>these are three different things.</p>
<p>Since <code>tuple</code> is a <code>type</code> object, it has no <code>__get__</code> method, the access <code>a.fTuple</code> just returns <code>tuple</code>.</p>
</div>
<span class="comment-copy">So, read <a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="nofollow noreferrer">this</a>. Essentially, function objects are descriptors which bind the instance as the first argument to the function, class objects are not descriptors.</span>
<span class="comment-copy">So, when I call instance.f(), somehow the call inspects the value of instance.f, and decided whether to pass instance to f as an argument?</span>
<span class="comment-copy">Requiring a parameter is not the difference. If you used a class that required a parameter, the class wouldn't receive the parameter.</span>
<span class="comment-copy">the difference is that <code>tuple()</code> is a class and that self is not passed into classes</span>
<span class="comment-copy">@user2357112 alright i edited it to make it a bit more clear what i was trying to say</span>
<span class="comment-copy">@ThomasAndrews the difference is that functions are <i>descriptors</i> with a <code>__get__</code> method that does the instance binding. This is why you can call methods on instances like <code>my_instance.my_method()</code> even though you defined your method with <code>def my_method(self): ...</code> This is how methods work.</span>
