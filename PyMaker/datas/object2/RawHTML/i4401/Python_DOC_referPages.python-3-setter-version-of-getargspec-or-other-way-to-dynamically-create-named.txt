<div class="post-text" itemprop="text">
<p>I happen to have some code which uses introspection to learn what the arguments of a function are, and then does some logic based on what these names are. So for example, I might create some functions like</p>
<pre><code>def func1(a,b):
    return a+b

def func2(a):
    return a

def func3(b):
    return b
</code></pre>
<p>and by using e.g. <code>inspect.getargspec(func1)</code> I can get the list ["a","b"] returned. In this way the code I have can check if some functions have the same argument names.</p>
<p>So now, I want to create a bunch of functions dynamically, with say another function. Schematically I want to do e.g.</p>
<pre><code>def make_funcs():
    func_list = []
    for i in 10:
        def f(x_i): ***here x_i should be x_1, or x_2, etc.
            return x_i:
        func_list += [f]
    return func_list
</code></pre>
<p>where, "x_i" should actually be x_1, x_2, etc. So that when I inspect these functions with <code>getargspec</code> the result is "x_1", "x_2", etc. It would also be acceptable to somehow set the argument names after the function is created. So for example I could create the functions with a generic argument name and then change it later to the specific names needed.</p>
<p>Is there some way to do either of these things?</p>
</div>
<div class="post-text" itemprop="text">
<p>What about using <code>**kwargs</code> as parameter, so parameter names are not set on function definition but can be retrieved from dict <code>kwargs</code>?</p>
<p>Btw, you should provide an example, because I don't clearly get the point of a function that could not rely on the name of its parameter to work ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you only need to change how <code>inspect.getargspec</code> reads the function's signature, you can hand-craft a <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature" rel="nofollow noreferrer"><code>inspect.Signature</code></a> object and assign it to the function's <code>__signature__</code> attribute:</p>
<pre><code>import inspect

def f(x_i):
    return x_i

i = 0
param = inspect.Parameter('x_{}'.format(i), inspect.Parameter.POSITIONAL_ONLY)
f.__signature__ = inspect.Signature([param])
</code></pre>
<p>(See also the documentation of the <a href="https://docs.python.org/3/library/inspect.html#inspect.Parameter" rel="nofollow noreferrer"><code>inspect.Parameter</code></a> constructor.)</p>
<p>Setting the signature like this interacts correctly with <a href="https://docs.python.org/3/library/inspect.html#inspect.getfullargspec" rel="nofollow noreferrer"><code>inspect.getfullargspec</code></a> (the not-deprecated version of <a href="https://docs.python.org/3/library/inspect.html#inspect.getargspec" rel="nofollow noreferrer"><code>inspect.getargspec</code></a>) and <a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow noreferrer"><code>inspect.signature</code></a>:</p>
<pre><code>&gt;&gt;&gt; inspect.getfullargspec(f)
FullArgSpec(args=['x_0'], varargs=None, varkw=None, defaults=None,
            kwonlyargs=[], kwonlydefaults=None, annotations={})
</code></pre>
<p>However, it does not actually change the name of the parameter, so keyword arguments don't work correctly:</p>
<pre><code>&gt;&gt;&gt; f(x_0=3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: f() got an unexpected keyword argument 'x_0'
&gt;&gt;&gt; f(x_i=3)
3
</code></pre>
<p>If you need keyword arguments to work correctly, the easiest solution is to create the function dynamically with <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code></a>:</p>
<pre><code>i = 0

globs = {}
code = """
def f(x_{0}):
    return x_{0}
""".format(i)
exec(code, globs)
f = globs['f']
</code></pre>
<pre><code>&gt;&gt;&gt; f(3)
3
&gt;&gt;&gt; f(x_0=3)
3
</code></pre>
</div>
<span class="comment-copy"><code>getargspec</code> does not create arguments. Your question is a bit unclear - post a minimal snippets of exactly what you want to do, and mark the line of pseudo code you're asking about.</span>
<span class="comment-copy">Yes I know it doesn't create arguments. It gets them. I am trying to create the functions such that getargspec returns the result I indicated in the question. I have marked the line of pseudocode that I want to control better.</span>
<span class="comment-copy">The actual code that does the introspection is not particularly simple or relevant to the question so I am not sure it helps to post it. But it is part of an optimisation routine, where I am minimising a product of function. If the parameters for these functions are independent then I can minimise each component of the product independently, but otherwise I must do a larger-dimension minimisation. So I need to know which of the functions require the same arguments and which are independent. Thus using **kwargs is no good since then the dependency structure is hidden.</span>
<span class="comment-copy">Ok, so basically, the idea is to define a new function at runtime, whose parameter lists is not fixed yet, and its code neither, right?</span>
<span class="comment-copy">Well the code can be fixed, that's no problem. In fact these functions will all be identical, but I need the arguments to be named differently. Otherwise yes that's the idea.</span>
<span class="comment-copy">I don't know if this is achievable. One (ugly!) possibility would be to write function as a string, and then use <code>eval</code> to create that function.</span>
<span class="comment-copy">Haha, yeah I thought about that, but I thought I would check first if there was a better way...</span>
<span class="comment-copy">Ahh, so close. I do actually need the keyword arguments to work correctly, half the point of introspecting for these argument names is to know what keyword arguments to use for them.</span>
<span class="comment-copy">@BenFarmer I updated my answer.</span>
<span class="comment-copy">Haha ok, I tried to avoid it, but alright, exec it is.</span>
