<div class="post-text" itemprop="text">
<p>I want to be clear, I am not seeing the behavior described by this question. Instead <em>my</em> question is about the question itself:</p>
<p>The <a href="https://docs.python.org/3/faq/design.html#why-isn-t-all-memory-freed-when-cpython-exits" rel="nofollow noreferrer">python 3 official FAQ</a> says this verbatim:</p>
<blockquote>
<p>Why isn't all memory freed when CPython exits?</p>
</blockquote>
<p>And provides this answer:</p>
<blockquote>
<p>Objects referenced from the global namespaces of Python modules are
  not always deallocated when Python exits. This may happen if there are
  circular references. There are also certain bits of memory that are
  allocated by the C library that are impossible to free (e.g. a tool
  like Purify will complain about these). Python is, however, aggressive
  about cleaning up memory on exit and does try to destroy every single
  object.</p>
<p>If you want to force Python to delete certain things on deallocation
  use the <a href="https://docs.python.org/3/library/atexit.html#module-atexit" rel="nofollow noreferrer">atexit</a> module to run a function that will force those
  deletions.</p>
</blockquote>
<p>This, assuming a managed memory operating system (Linux, Mac, Windows, GNU, BSD, Solaris...), sounds like total nonsense.</p>
<p>On a program exiting (be it Python or anything else) any memory it requested from the OS is freed (as the OS has control of the virtual page tables, etc, etc). The program doesn't have to de-allocate or de-construct anything (something programs used to have to do, as highlighted by the time someone's use of <code>cp</code> got <a href="http://lists.gnu.org/archive/html/coreutils/2014-08/msg00012.html" rel="nofollow noreferrer">bottlenecked by a hash table deconstruction</a>), but I don't think any OS' Python 3 supports puts this requirement on programs.</p>
<p>Does this make sense in some context I'm not aware of? What is this referring to?</p>
</div>
<div class="post-text" itemprop="text">
<p>The FAQ just says that cpython itself does not actively deallocate all the memory it has acquired when it terminates</p>
<p>If you run cpython on a any normal server/desktop OS that releases all memory of a process when it exits, then there's no issue with memory leaks. The OS takes care of deallocating all memory when the process has exited.</p>
<p>The FAQ is more to inform you that cpython does not call free() or similar on all the memory it has allocated with malloc() or similar. This can have consequences if you run cpython on an OS that does not release all memory acquired by the process when the process exits (These operating systems exists, it is in particular the case with many embedded kernels). And if you run cpython under a memory profiler/leak detector, that detector might report the memory not free()'d as leaks.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two cases in which this could make sense.</p>
<p>First, running a memory leak analyzer on Python will report memory that hasn't been explicitly freed by the time Python exits, because it indicates a leak, even if it all gets cleaned up by the OS.</p>
<p>Second, Python is designed to be embedded into other programs, and in such a situation, Python may be shut down (and even restarted) without the whole process ending. The OS will not clean up Python's memory until the whole process ends. See the <a href="https://docs.python.org/3/extending/embedding.html" rel="nofollow noreferrer">tutorial</a> for embedding Python in another application, and the <a href="https://docs.python.org/3/c-api/index.html" rel="nofollow noreferrer">Python C API docs</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the question in the FAQ is slightly disambiguous. The memory, once the Python process has exited is freed by the operating system and is able to be given to other processes. As you rightly point out, there is no way for the memory to be allocated (or not free) to a non-existent process.</p>
<p>I think what the FAQ is referring to is that to is that while shutting down a python process, it is possible to end up in states where memory is still allocated to the process cannot be gracefully garbage collected and deallocated. This can happen (as the FAQ mentions) if you have circular references etc.</p>
</div>
