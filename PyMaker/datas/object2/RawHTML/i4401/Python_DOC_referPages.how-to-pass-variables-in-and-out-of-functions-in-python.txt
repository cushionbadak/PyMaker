<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/354883/how-to-return-multiple-values-from-a-function">How to return multiple values from a function? [closed]</a>
<span class="question-originals-answer-count">
                    14 answers
                </span>
</li>
</ul>
</div>
<p>When I write functions in Python, I typically need to pass quite a few variables to the function. Also, output of such functions contains more than a few variables. In order to manage this variables I/O, I resort to the dictionary datatype, where I pack all input variables into a dictionary to inject into a function and then compile another dictionary at the end of the function for returning to the main program. This of course needs another unpacking of the output dictionary. </p>
<pre><code>dict_in = {'var1':var1,
           'var2':var2,
           'varn':varn}    

def foo(dict_in):
    var1 = dict_in['var1']
    var2 = dict_in['var2']
    varn = dict_in['varn']

    """ my code """

    dict_out = {'op1':op1,
                'op2':op2,
                'op_m':op_m}
    return dict_out
</code></pre>
<p>As the list of variables grows, I suspect that this will be an inefficient approach to deal with the variables I/O. </p>
<p>Can someone suggest a better, more efficient and less error-prone approach to this practice?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could take advantage of kwargs to unpack named variables</p>
<pre><code>def foo(**kwargs):
    kwargs['var1'] = do_something(kwargs['var1'])
    ...
    return kwargs
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you find yourself writing a lot of functions that act on the same data, one better way would be using classes to contain your data.</p>
<pre><code>class Thing:
    def __init__(self, a, b, c):
        var_1 = a
        var_2 = b
        var_3 = c

    # you can then define methods on it

    def foo(self):
        self.var_1 *= self.var_2

# and use it
t = Thing(1, 2, 3)
t.foo()
print(t.var_1)
</code></pre>
<p>There are a number of methods of creating these in an easier way. Some of them include:</p>
<h3><a href="https://pypi.python.org/pypi/attrs/" rel="nofollow noreferrer">attrs</a>:</h3>
<pre><code>&gt;&gt;&gt; @attr.s
... class SomeClass(object):
...     a_number = attr.ib(default=42)
...     list_of_numbers = attr.ib(default=attr.Factory(list))
...
...     def hard_math(self, another_number):
...         return self.a_number + sum(self.list_of_numbers) * another_number
</code></pre>
<h3><a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuples</a></h3>
<pre><code>&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])
&gt;&gt;&gt; p = Point(11, y=22)     # instantiate with positional or keyword arguments
&gt;&gt;&gt; p.x + p.y               # fields accessible by name
33
</code></pre>
<h3>Dataclasses</h3>
<p>These are not in python yet, but <a href="https://www.python.org/dev/peps/pep-0557/" rel="nofollow noreferrer">will be added in 3.7</a>. I am adding them in here here because they will likely be the tool of choice in the future.</p>
</div>
<span class="comment-copy"><i>better, more efficient and less error-prone approach</i> --&gt; <b>pythonic way</b></span>
<span class="comment-copy">Packaging into an object is necessary for multiple return values, but unless the input values are very closely related, forcibly grouping them in an object is just going to complicate things, and isn't necessarily conceptually sounds.</span>
<span class="comment-copy">@Carcigenicate Python allows multiple return values without packaging... I'm not following your comment.</span>
<span class="comment-copy">@TemporalWolf That's just implicit tuple packaging afaik. It's only 1 return value, that one return just happens to be a tuple with multiple elements.</span>
<span class="comment-copy">Actually, it's not even implicit. From the second answer of the dupe target, a comma is all that's required to create a tuple, so my example is just explicitly creating a tuple then returning it.</span>
<span class="comment-copy">+1 for namedtuple. It is easy to use and it holds the data in a immutable sequence type that you don't have to worry about. Perfect for storing data in a "I don't care what this is, I just want to get the data across" way. For geometric points I would use a class (maybe <code>__add__</code> would be helpful, but for stuff like mailing addresses, url, etc., I think namedtuples are definitely underrated. (I was about to type up a namedtuple answer but you got it before I can, so I'm going to put my praise rant here instead.)</span>
