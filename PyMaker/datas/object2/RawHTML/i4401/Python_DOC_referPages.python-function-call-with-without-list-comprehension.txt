<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/11964130/list-comprehension-vs-generator-expressions-weird-timeit-results">List comprehension vs generator expression's weird timeit results?</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>I have below two functions:</p>
<pre><code>def foo(n=50000):
    return sum(i*i for i in range(n))  # just called sum() directly without 

def bar(n=50000):
    return sum([i*i for i in range(n)])  # passed constructed list to sum()
</code></pre>
<p>I was hoping that <code>foo</code> will run faster then <code>bar</code> but I have checked in ipython with <code>%%timeit</code> that <code>foo</code> is taking slightly longer then <code>bar</code> </p>
<pre><code>In [2]: %%timeit
   ...: foo(50000)
   ...: 
100 loops, best of 3: 4.22 ms per loop

In [3]: %%timeit
   ...: bar(50000)
   ...: 
100 loops, best of 3: 3.45 ms per loop
In [4]: %%timeit
   ...: foo(10000000)
   ...: 
1 loops, best of 3: 1.02 s per loop

In [5]: %%timeit
   ...: bar(10000000)
   ...: 
1 loops, best of 3: 869 ms per loop
</code></pre>
<p>The difference increases as I increase value of n hence I tried to check function with <code>dis.dis(foo)</code> and <code>dis.dis(bar)</code> but it was identical.</p>
<p>So what would be the cause of such time difference between both methods?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are plenty of great answers about generators, so I won't elaborate on that.</p>
<p>Generators keep <em>state</em>. They are slightly slower if you do very <em>fast</em> operations (like using <code>sum</code>, but if you use an I/O command there won't be much difference).
The upside for generators is that <em>they don't load all the items to memory in advance</em>, where lists does.</p>
<p>This is what happens when you iterate a list (in very high-level):</p>
<ul>
<li>You load all items of the list to memory</li>
<li>Asking for the next element just gives you the pointer to that object</li>
</ul>
<p>Compare that to a generator:</p>
<ul>
<li>You don't have all the items on memory. Just <strong>one</strong> item at a time.</li>
<li>Asking for the next element resumes the generator object, running the code until it reaches the yield statement.</li>
<li>Then it yields the object's address in memory so you can access it.</li>
</ul>
<p>This extra step in the middle, is the diff in your tests.</p>
<p>So, generators are used commonly where you deal with <em>huge</em> amount of data that needs to be loaded on to memory. (There are more use-cases for generators ofcourse, like coroutines)</p>
<p>Do an expirement with huge files and a for loop printing the lines. At some point you will get out of memory exception when using lists. Then try using generators, they won't go out of memory..</p>
</div>
<span class="comment-copy">Question aside, remember the main reason using a generator expression is preferred in these cases is for improved memory usage rather than speed optimisation</span>
<span class="comment-copy">I could've sworn we had a couple of questions about this phenomenon already, but I can't find any...</span>
<span class="comment-copy">@IljaEverilä Nice find!</span>
<span class="comment-copy">This is contradictory because a list-comprehension: <code>[...]</code> is stated in the documentation to be basically syntactic sugar for <code>list()</code> called on a generator. So using a list-comp still has to iterate over the generator asking for the next element, running the code till the yield etc. it just does this at declaration and stores the results in memory rather than on the fly. So I am still personally confused why it is faster to do this at first rather than during the <code>sum()</code> call imo your answer doesn't address this you are focusing on memory.</span>
<span class="comment-copy"><code>list()</code> builds the data structure first, and loads it to memory. then forwards a list data structure to <code>sum</code>. <i>The list is already built and available</i>. Where generators yields just one item at a time, and retrieving the next element takes longer as it is executes more code (until next yield) than just getting a pointer back.</span>
<span class="comment-copy">Yes, I agree that is how it works, but don't see how that would mean lists are faster. The added time of creating the list and loading into memory must cancel out the time saved using a pointer to access the entries?</span>
<span class="comment-copy">Not entirely correct. Creating a list out of range is quick, and you do it once and load it to memory. Then when <i>iteration</i> starts it accesses list[index]. All items are accessed in <i>O(1)</i> while with generators, accessing an item is a different story - you actually executes code, and yield <i>one</i> object. Then again on next iteration, and again.. so yielding an element (in the OP scenario) is more <i>expensive</i> in terms of time than just accessing a <i>ready</i> list. Also, I'm pretty sure there are some optimizations when generating a list.</span>
<span class="comment-copy">@joe-iddon Are you possibly referring to <a href="https://docs.python.org/3/whatsnew/3.0.html#changed-syntax" rel="nofollow noreferrer">this</a>? Note that it states that the <i>semantics</i> changed so that they are closer to <code>list(&lt;gen expr&gt;)</code> (like generator expressions they no longer leak the loop control variable, for example), but the implementation is still different: <a href="https://stackoverflow.com/questions/30096351/are-list-comprehensions-syntactic-sugar-for-listgenerator-expression-in-pyth" title="are list comprehensions syntactic sugar for listgenerator expression in pyth">stackoverflow.com/questions/30096351/…</a>. In short your statement that a list-comp still has to iterate over a generator is wrong.</span>
