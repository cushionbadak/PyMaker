<div class="post-text" itemprop="text">
<p>I am trying to write a class that search for all files on my computer with a specific extension. To make the process faster I use threading. It searchs all hard disks at the same time.</p>
<p>I know it finds all the paths when I print them <code>print(file_path)</code></p>
<p>But the values won't be appended in the <code>self.ALLFILES</code> and I do not know why.</p>
<p>Here is the code:</p>
<pre><code>from concurrent import futures
import time
import win32api
import os


class SearchThreader():
    def __init__(self):
        self.allfiles = []
        self.harddisks = win32api.GetLogicalDriveStrings().split('\000')[:-1]
        #skip the folders that shouldn't have files with this extension
        self.exlude = {
            "$SysReset", "AMD", "inetpub", "NVIDIA", "PerfLogs",
            "Windows.old", "Windows", "ProgrammData",
            "Programm Files (x86)", "Programm Files",
            "Doc", "Fotos", "Lib", "lib", "libs"
            "Scripts", "Tools", "bin", "Config", "Logs", "log",
            "mods", "win"
            }

        self.fullThreadSearch()

    def SearchHarddisk(self, hd):
        for root, dirs, files in os.walk(hd, topdown=True):
            dirs[:] = [d for d in dirs if d not in self.exlude]
            for f_name in files:
                file_path = os.path.join(root, f_name)
                if file_path.endswith(".mp3"):
                    self.allfiles.append(file_path)
                    print(file_path)

    def fullThreadSearch(self):
        with futures.ProcessPoolExecutor(max_workers=len(self.harddisks)) as thr:
            for harddisk in self.harddisks:
                thr.submit(self.SearchHarddisk, harddisk)

if __name__ == "__main__":
    starttime = time.time()
    ST = SearchThreader()
    print(ST.allfiles)
    print(time.time() - starttime)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned in @Trap's <a href="https://stackoverflow.com/a/49741012/355230">answer</a>, you need to return the results from the <code>SearchHarddisk()</code> method instead of trying to append them to the <code>self.allfiles</code> in <code>fullThreadSearch()</code>. This is because each invocation of <code>SearchHarddisk()</code> runs in its own address space, so there's effectively a different <code>self.allfiles</code> list object in each one.</p>
<p>Here's something with those changes made that seems to work on my Windows machine. Note that I based it on the sample code shown in the <a href="https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor-example" rel="nofollow noreferrer">ProcessPoolExecutor Example</a> section of the documentation which uses the <code>ProcessPoolExecutor.map()</code> method instead of calling <code>ProcessPoolExecutor.submit()</code> repeatedly.</p>
<pre><code>import concurrent.futures as futures
import os
import time
import win32api

class SearchThreader():
    def __init__(self):
        self.allfiles = []
        self.harddisks = win32api.GetLogicalDriveStrings().split('\000')[:-1]
        #skip the folders that shouldn't have files with this extension
        self.exlude = {
            "$SysReset", "AMD", "inetpub", "NVIDIA", "PerfLogs",
            "Windows.old", "Windows", "ProgrammData",
            "Programm Files (x86)", "Programm Files",
            "Doc", "Fotos", "Lib", "lib", "libs"
            "Scripts", "Tools", "bin", "Config", "Logs", "log",
            "mods", "win"
            }

        self.fullThreadSearch()

    def SearchHarddisk(self, hd):
        allfiles = []  # Local variable.
        for root, dirs, files in os.walk(hd, topdown=True):
            dirs[:] = [d for d in dirs if d not in self.exlude]
            for f_name in files:
                file_path = os.path.join(root, f_name)
                if file_path.endswith(".mp3"):
                    allfiles.append(file_path)  # Append to local list.
                    print(file_path)
        return allfiles  # Return all found on this harddisk.

    def fullThreadSearch(self):
        with futures.ProcessPoolExecutor() as executor:
            for harddisk, matching_files in zip(
                    self.harddisks, executor.map(self.SearchHarddisk, self.harddisks)):
                print('harddisk: {}, matching_files: {}'.format(harddisk, matching_files))
                self.allfiles.extend(matching_files)

if __name__ == "__main__":
    starttime = time.time()
    ST = SearchThreader()
    print(ST.allfiles)
    print(time.time() - starttime)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've never used the ProcessPoolExecutor class, but I think your error is due to the fact that self.allfiles is not shared across the processes created.
Your SearchHarddisk method should return a value, and after the process are done, you have to gather every results and append them to self.allfiles.
This is what I would have done, but since I'm not running Windows, I can't test so I'm not sure it will work.</p>
<pre><code>from concurrent import futures
import time
import win32api
import os


class SearchThreader():
    def __init__(self):
        self.allfiles = []
        self.harddisks = win32api.GetLogicalDriveStrings().split('\000')[:-1]
        #skip the folders that shouldn't have files with this extension
        self.exlude = {
            "$SysReset", "AMD", "inetpub", "NVIDIA", "PerfLogs",
            "Windows.old", "Windows", "ProgrammData",
            "Programm Files (x86)", "Programm Files",
            "Doc", "Fotos", "Lib", "lib", "libs"
            "Scripts", "Tools", "bin", "Config", "Logs", "log",
            "mods", "win"
            }

        self.fullThreadSearch()

    def SearchHarddisk(self, hd):
        files = []
        for root, dirs, files in os.walk(hd, topdown=True):
            dirs[:] = [d for d in dirs if d not in self.exlude]
            for f_name in files:
                file_path = os.path.join(root, f_name)
                if file_path.endswith(".mp3"):
                    files.append(file_path)
                    print(file_path)

        return files

    def fullThreadSearch(self):
        with futures.ProcessPoolExecutor(max_workers=len(self.harddisks)) as thr:
            future_objects = [thr.submit(self.SearchHarddisk, harddisk) for harddisk in self.harddisks]
            self.allfiles = [future.result() for future in future_objects]


if __name__ == "__main__":
    starttime = time.time()
    ST = SearchThreader()
    print(ST.allfiles)
    print(time.time() - starttime)
</code></pre>
</div>
<span class="comment-copy">Thank you. Do you think it would be better to call a futur.ProxessPoolExecuter for every folder (not Subfolder) to make it even faster.</span>
<span class="comment-copy">Perhaps, but it seems like that might add a fair amount of complexity to the code for an uncertain gainâ€”and <a href="https://en.wikipedia.org/wiki/Program_optimization#When_to_optimize" rel="nofollow noreferrer">premature optimization</a> is generally a poor idea anyway. Regardless, the only way to know for sure if it would be faster would be to time it implemented both ways (see the <a href="https://docs.python.org/3/library/timeit.html#module-timeit" rel="nofollow noreferrer"><code>timeit</code></a> module).</span>
<span class="comment-copy">I get the following Error: <code>Traceback (most recent call last): File "D:/Code Project's/MusicplayerApp/thread_searching.py", line 21, in __init__     self.fullThreadSearch()   File "D:/Code Project's/MusicplayerApp/thread_searching.py", line 36, in fullThreadSearch     with futures.ProcessPoolExecutor(max_workers=len(self.harddisks)) as thr: UnboundLocalError: local variable </code>futures` referenced before assignment. As I changed futures to <code>futures1</code> and <code>[future.result() for future in futures1]</code> and became a infinity loop</span>
<span class="comment-copy">You're right, I shouldn't have called this variable futures as it will shadow the futures module you import. The last list comprehension [future.result() for future in futures1] is not an infinity loop, but it will wait until every process are done searching for files. But again, as I can't test myself, I can only make supposition here.</span>
