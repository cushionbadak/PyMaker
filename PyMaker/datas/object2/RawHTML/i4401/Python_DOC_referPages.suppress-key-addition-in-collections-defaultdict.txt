<div class="post-text" itemprop="text">
<p>When a missing key is queried in a <code>defaultdict</code> object, the key is <em>automatically added</em> to the dictionary:</p>
<pre><code>from collections import defaultdict

d = defaultdict(int)
res = d[5]

print(d)
# defaultdict(&lt;class 'int'&gt;, {5: 0})
# we want this dictionary to remain empty
</code></pre>
<p>However, often we want to only add keys when they are assigned explicitly or implicitly:</p>
<pre><code>d[8] = 1  # we want this key added
d[3] += 1 # we want this key added
</code></pre>
<p>One use case is simple counting, to avoid the higher overhead of <code>collections.Counter</code>, but this feature may also be desirable generally.</p>
<hr/>
<p><strong>Counter example</strong> [pardon the pun]</p>
<p>This is the functionality I want:</p>
<pre><code>from collections import Counter
c = Counter()
res = c[5]  # 0
print(c)  # Counter()

c[8] = 1  # key added successfully
c[3] += 1 # key added successfully
</code></pre>
<p>But <code>Counter</code> is significantly slower than <code>defaultdict(int)</code>. I find the performance hit usually ~2x slower vs <code>defaultdict(int)</code>.</p>
<p>In addition, obviously <code>Counter</code> is only comparable to <code>int</code> argument in <code>defaultdict</code>, while <code>defaultdict</code> can take <code>list</code>, <code>set</code>, etc.</p>
<hr/>
<p>Is there a way to implement the above behaviour efficiently; for instance, by subclassing <code>defaultdict</code>?</p>
<hr/>
<p><strong>Benchmarking example</strong></p>
<pre><code>%timeit DwD(lst)           # 72 ms
%timeit dd(lst)            # 44 ms
%timeit counter_func(lst)  # 98 ms
%timeit af(lst)            # 72 ms
</code></pre>
<p>Test code:</p>
<pre><code>import numpy as np
from collections import defaultdict, Counter, UserDict

class DefaultDict(defaultdict):
    def get_and_forget(self, key):
        _sentinel = object()
        value = self.get(key, _sentinel)

        if value is _sentinel:
            return self.default_factory()
        return value

class DictWithDefaults(dict):
    __slots__ = ['_factory']  # avoid using extra memory

    def __init__(self, factory, *args, **kwargs):
        self._factory = factory
        super().__init__(*args, **kwargs)

    def __missing__(self, key):
        return self._factory()

lst = np.random.randint(0, 10, 100000)

def DwD(lst):
    d = DictWithDefaults(int)
    for i in lst:
        d[i] += 1
    return d

def dd(lst):
    d = defaultdict(int)
    for i in lst:
        d[i] += 1
    return d

def counter_func(lst):
    d = Counter()
    for i in lst:
        d[i] += 1
    return d

def af(lst):
    d = DefaultDict(int)
    for i in lst:
        d[i] += 1
    return d
</code></pre>
<p><strong>Note Regarding Bounty Comment</strong>:</p>
<p><a href="https://stackoverflow.com/a/49778990/9209546">@Aran-Fey's solution</a> has been updated since Bounty was offered, so please disregard the Bounty comment.</p>
</div>
<div class="post-text" itemprop="text">
<p>Rather than messing about with <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> to make it do what we want, it seems easier to implement our own:</p>
<pre><code>class DefaultDict(dict):
    def __init__(self, default_factory, **kwargs):
        super().__init__(**kwargs)

        self.default_factory = default_factory

    def __getitem__(self, key):
        try:
            return super().__getitem__(key)
        except KeyError:
            return self.default_factory()
</code></pre>
<p>This works the way you want:</p>
<pre><code>d = DefaultDict(int)

res = d[5]
d[8] = 1 
d[3] += 1

print(d)  # {8: 1, 3: 1}
</code></pre>
<p>However, it can behave unexpectedly for mutable types:</p>
<pre><code>d = DefaultDict(list)
d[5].append('foobar')

print(d)  # output: {}
</code></pre>
<p>This is probably the reason why <code>defaultdict</code> remembers the value when a nonexistant key is accessed.</p>
<hr/>
<p>Another option is to extend <code>defaultdict</code> and add a new method that looks up a value without remembering it:</p>
<pre><code>from collections import defaultdict

class DefaultDict(defaultdict):
    def get_and_forget(self, key):
        return self.get(key, self.default_factory())
</code></pre>
<p>Note that the <code>get_and_forget</code> method calls the <code>default_factory()</code> every time, regardless of whether the key already exists in the dict or not. If this is undesirable, you can implement it with a sentinel value instead:</p>
<pre><code>class DefaultDict(defaultdict):
    def get_and_forget(self, key):
        _sentinel = object()
        value = self.get(key, _sentinel)

        if value is _sentinel:
            return self.default_factory()
        return value
</code></pre>
<p>This has better support for mutable types, because it allows you to choose whether the value should be added to the dict or not.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you just want a <code>dict</code> that returns a default value when you access a non-existing key then you could simply subclass <code>dict</code> and implement <a href="https://docs.python.org/reference/datamodel.html#object.__missing__" rel="nofollow noreferrer"><code>__missing__</code></a>:</p>
<blockquote>
<h2><code>object.__missing__(self, key)</code></h2>
<p>Called by <code>dict.__getitem__()</code> to implement <code>self[key]</code> for dict subclasses when <code>key</code> is not in the dictionary.</p>
</blockquote>
<p>That would look like this:</p>
<pre><code>class DictWithDefaults(dict):
    # not necessary, just a memory optimization
    __slots__ = ['_factory']  

    def __init__(self, factory, *args, **kwargs):
        self._factory = factory
        super().__init__(*args, **kwargs)

    def __missing__(self, key):
        return self._factory()
</code></pre>
<p>In this case I used a <code>defaultdict</code>-like approach so you have to pass in a <code>factory</code> that should provide the default value when called:</p>
<pre><code>&gt;&gt;&gt; dwd = DictWithDefaults(int)
&gt;&gt;&gt; dwd[0]  # key does not exist
0 
&gt;&gt;&gt; dwd     # key still doesn't exist
{}
&gt;&gt;&gt; dwd[0] = 10
&gt;&gt;&gt; dwd
{0: 10}
</code></pre>
<p>When you do assignments (explicitly or implicitly) the value will be added to the dictionary:</p>
<pre><code>&gt;&gt;&gt; dwd = DictWithDefaults(int)
&gt;&gt;&gt; dwd[0] += 1
&gt;&gt;&gt; dwd
{0: 1}

&gt;&gt;&gt; dwd = DictWithDefaults(list)
&gt;&gt;&gt; dwd[0] += [1]
&gt;&gt;&gt; dwd
{0: [1]}
</code></pre>
<p>You wondered how <code>collections.Counter</code> is doing it and as of CPython 3.6.5 it also uses <a href="https://github.com/python/cpython/blob/v3.6.5/Lib/collections/__init__.py#L537-L540" rel="nofollow noreferrer"><code>__missing__</code></a>:</p>
<pre><code>class Counter(dict):
    ...

    def __missing__(self, key):
        'The count of elements not in the Counter is zero.'
        # Needed so that self[missing_item] does not raise KeyError
        return 0

    ...
</code></pre>
<h2>Better performance?!</h2>
<p>You mentioned that speed is of concern, so you could make that class a C extension class (assuming you use CPython), for example using Cython (I'm using the Jupyter magic commands to create the extension class):</p>
<pre><code>%load_ext cython

%%cython

cdef class DictWithDefaultsCython(dict):
    cdef object _factory

    def __init__(self, factory, *args, **kwargs):
        self._factory = factory
        super().__init__(*args, **kwargs)

    def __missing__(self, key):
        return self._factory()
</code></pre>
<h2>Benchmark</h2>
<p>Based on your benchmark:</p>
<pre><code>from collections import Counter, defaultdict

def d_py(lst):
    d = DictWithDefaults(int)
    for i in lst:
        d[i] += 1
    return d

def d_cy(lst):
    d = DictWithDefaultsCython(int)
    for i in lst:
        d[i] += 1
    return d

def d_dd(lst):
    d = defaultdict(int)
    for i in lst:
        d[i] += 1
    return d
</code></pre>
<p>Given that this is just counting it would be an (unforgivable) oversight to not include a benchmark simply using the <code>Counter</code> initializer.</p>
<p>I have recently written a small benchmarking tool that I think might come in handy here (but you could do it using <code>%timeit</code> as well):</p>
<pre><code>from simple_benchmark import benchmark
import random

sizes = [2**i for i in range(2, 20)]
unique_lists = {i: list(range(i)) for i in sizes}
identical_lists = {i: [0]*i for i in sizes}
mixed = {i: [random.randint(0, i // 2) for j in range(i)]  for i in sizes}

functions = [d_py, d_cy, d_dd, d_c, Counter]

b_unique = benchmark(functions, unique_lists, 'list size')
b_identical = benchmark(functions, identical_lists, 'list size')
b_mixed = benchmark(functions, mixed, 'list size')
</code></pre>
<p>With this result:</p>
<pre><code>import matplotlib.pyplot as plt

f, (ax1, ax2, ax3) = plt.subplots(1, 3, sharey=True)
ax1.set_title('unique elements')
ax2.set_title('identical elements')
ax3.set_title('mixed elements')
b_unique.plot(ax=ax1)
b_identical.plot(ax=ax2)
b_mixed.plot(ax=ax3)
</code></pre>
<p>Note that it uses log-log scale for better visibility of differences:</p>
<p><a href="https://i.stack.imgur.com/W7Nl3.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/W7Nl3.png"/></a></p>
<p>For long iterables the <code>Counter(iterable)</code> was by far the fastest. <code>DictWithDefaultCython</code> and <code>defaultdict</code> were equal (with <code>DictWithDefault</code> being slightly faster most of the times, even if that's not visible here) followed by <code>DictWithDefault</code> and then <code>Counter</code> with the manual <code>for</code>-loop. Funny how <code>Counter</code> is fastest and slowest.</p>
<h2>Implicitly add the returned value <em>if</em> it is modifie</h2>
<p>Something I glossed over is the fact that it differs considerably from <code>defaultdict</code> because of the desired "just return the default don't save it" with mutable types:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; dd = defaultdict(list)
&gt;&gt;&gt; dd[0].append(10)
&gt;&gt;&gt; dd
defaultdict(list, {0: [10]})

&gt;&gt;&gt; dwd = DictWithDefaults(list)
&gt;&gt;&gt; dwd[0].append(10)
&gt;&gt;&gt; dwd
{}
</code></pre>
<p>That means you actually need to set the element when you want the modified value to be visible in the dictionary.</p>
<p>However this somewhat intrigued me so I want to share a way how you could make that work (if desired). But it's just a quick test and only works for <code>append</code> calls using a proxy. Please don't use that in production code (from my point of view this just has entertainment value):</p>
<pre><code>from wrapt import ObjectProxy

class DictWithDefaultsFunky(dict):
    __slots__ = ['_factory']  # avoid using extra memory

    def __init__(self, factory, *args, **kwargs):
        self._factory = factory
        super().__init__(*args, **kwargs)

    def __missing__(self, key):
        ret = self._factory()
        dict_ = self

        class AppendTrigger(ObjectProxy):
            def append(self, val):
                self.__wrapped__.append(val)
                dict_[key] = ret

        return AppendTrigger(ret)
</code></pre>
<p>That's a dictionary that returns a proxy object (instead of the real default) and it overloads a method that, if called, adds the return value to the dictionary. And it "works":</p>
<pre><code>&gt;&gt;&gt; d = DictWithDefaultsFunky(list)
&gt;&gt;&gt; a = d[10]
&gt;&gt;&gt; d
[]

&gt;&gt;&gt; a.append(1)
&gt;&gt;&gt; d
{10: [1]}
</code></pre>
<p>But it does have a few pitfalls (that could be solved but it's just a proof-of-concept so I won't attempt it here):</p>
<pre><code>&gt;&gt;&gt; d = DictWithDefaultsFunky(list)
&gt;&gt;&gt; a = d[10]
&gt;&gt;&gt; b = d[10]
&gt;&gt;&gt; d
{}
&gt;&gt;&gt; a.append(1)
&gt;&gt;&gt; d
{10: [1]}
&gt;&gt;&gt; b.append(10)
&gt;&gt;&gt; d  # oups, that overwrote the previous stored value ...
{10: [10]}
</code></pre>
<p>If you really want something like that you probably need to implement a class that really tracks changes within the values (and not just <code>append</code> calls).</p>
<h2>If you want to avoid implicit assignments</h2>
<p>In case you don't like the fact that <code>+=</code> or similar operations add the value to the dictionary (opposed to the previous example which even tried to add the value in a very implicit fashion) then you probably should implement it as method instead of as special method.</p>
<p>For example:</p>
<pre><code>class SpecialDict(dict):
    __slots__ = ['_factory']

    def __init__(self, factory, *args, **kwargs):
        self._factory = factory

    def get_or_default_from_factory(self, key):
        try:
            return self[key]
        except KeyError:
            return self._factory()

&gt;&gt;&gt; sd = SpecialDict(int)
&gt;&gt;&gt; sd.get_or_default_from_factory(0)  
0
&gt;&gt;&gt; sd  
{}
&gt;&gt;&gt; sd[0] = sd.get_or_default_from_factory(0) + 1
&gt;&gt;&gt; sd  
{0: 1}
</code></pre>
<p>Which is similar to the behavior of Aran-Feys answer but instead of <code>get</code> with a sentinel it uses a <code>try</code> and <code>catch</code> approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your bounty message says Aran-Fey's answer "does not work with mutable types". (For future readers, the bounty message is "The current answer is good, but it does not work with mutable types. If the existing answer can be adapted, or another option solution put forward, to suit this purpose, this would be ideal.")</p>
<p>The thing is, it does work for mutable types:</p>
<pre><code>&gt;&gt;&gt; d = DefaultDict(list)
&gt;&gt;&gt; d[0] += [1]
&gt;&gt;&gt; d[0]
[1]
&gt;&gt;&gt; d[1]
[]
&gt;&gt;&gt; 1 in d
False
</code></pre>
<p>What <em>doesn't</em> work is something like <code>d[1].append(2)</code>:</p>
<pre><code>&gt;&gt;&gt; d[1].append(2)
&gt;&gt;&gt; d[1]
[]
</code></pre>
<p>That's because this doesn't involve a store operation on the dict. The only dict operation involved is an item retrieval.</p>
<p>There is <em>no difference</em> between what the dict object sees in <code>d[1]</code> or <code>d[1].append(2)</code>. The dict is not involved in the <code>append</code> operation. Without nasty, fragile stack inspection or something similar, there is no way for the dict to store the list only for <code>d[1].append(2)</code>.</p>
<hr/>
<p>So that's hopeless. What should you do instead?</p>
<p>Well, one option is to use a regular <code>collections.defaultdict</code>, and just not use <code>[]</code> when you don't want to store defaults. You can use <code>in</code> or <code>get</code>:</p>
<pre><code>if key in d:
    value = d[key]
else:
    ...
</code></pre>
<p>or</p>
<pre><code>value = d.get(key, sentinel)
</code></pre>
<p>Alternatively, you can turn off the default factory when you don't want it. This is frequently reasonable when you have separate "build" and "read" phases, and you don't want the default factory during the read phase:</p>
<pre><code>d = collections.defaultdict(list)
for thing in whatever:
    d[thing].append(other_thing)
# turn off default factory
d.default_factory = None
use(d)
</code></pre>
</div>
<span class="comment-copy">How would a <code>dict</code> know when you want to assign something to it and when you're just reading from it? If it didn't create a key when you try to access it with <code>d[5]</code> it would throw a <code>KeyError</code> because <code>d[5]</code> couldn't be found at that time. Also, <code>d[3] += 1</code> is essentially <code>d[3] = d[3] + 1</code> and it would fail on the <code>d[3]</code> retrieval (much before the assignment) for the same reason. <code>collections.defaultdict()</code> purposefully circumvents the get part of the <code>dict</code> to create a key if it doesn't exist to avoid the default behavior.</span>
<span class="comment-copy">Well, I was thinking more along the lines of overwriting the <code>get</code> method so that it first checks if the key exists; if it doesn't, return the default value <i>without adding the key</i>. If this is not separable from <code>d[]</code> syntax, maybe it's possible to have a <code>get2</code> method that does this?</span>
<span class="comment-copy">I don't understand what you mean by <i>"it does not work with mutable types"</i>. Not adding the value to the dict when it's queried is exactly equivalent to not supporting mutable types. It's part of your specification. It's impossible to have both.</span>
<span class="comment-copy">@Aran-Fey, Well, then <i>maybe</i> defining a new method of <code>defaultdict</code> is the only way? I know you advise against this, but I'm entirely open to creating a new method <code>get2</code> or the like for the "allow querying" condition. It could be <code>res = d.get2(5)</code> to get round the problem you describe.</span>
<span class="comment-copy">why not just use <code>dict()</code></span>
<span class="comment-copy">@jpp Well, it's not 100% clear what you want the <code>get</code> method to do - should it work exactly the same as <code>__getitem__</code>, or should it return the value of its <code>default</code> parameter when the key doesn't exist? But anyway, you can fix that by simply deleting the custom <code>get</code> method (as I've done now).</span>
<span class="comment-copy">This looks good now. I wanted <code>d.get</code> to return the value for the key <i>if it exists</i>, otherwise the default value. This is exactly what your <code>UserDict</code> does. I'll wait a day or two to see if there are other views / solution that handles mutable types, before accepting.</span>
<span class="comment-copy">Thanks for your solution, offering a bounty instead. Maybe attract some more downvotes to the question, though I don't think <i>with the update</i> it is utterly ridiculous.</span>
<span class="comment-copy">The sentinel version is excellent. I've got a lot to learn about OOP. Thanks for your patience. I'm going to give this question some air-time on Bounty <i>in case</i> their are alternative views / solutions. Hopefully others appreciate this solution too.</span>
<span class="comment-copy">I added some more explanation to my question. <code>Counter</code> is a good example of a dictionary which effectively acts as having a default value <i>but</i> doesn't automatically add keys when queried. But this class is restricted to counting. I haven't seen how <code>Counter</code> manages it, presumably in pure Python, but the logic there may well only be reusable for immutable types such as <code>int</code>.</span>
<span class="comment-copy">@jpp Not sure what you mean. Just returning a value without adding it to the dict is as simple as implementing <code>__missing__</code> (see first example). It's only a problem to detect changes when you don't assign to the dictionary directly. Could you indicate what kind of behavior you want (i.e. a code snippet that you want to work)?</span>
<span class="comment-copy">Not sure if you saw my question update. Let's stick with <code>int</code> first. I want to have the <i>counting</i> functionality of <code>Counter</code> but without the 2x overhead. <code>defaultdict(int)</code> does not share the property with <code>Counter</code> because querying it adds keys. If we're querying keys frequently with <code>defaultdict(int)</code> the dictionary blows up in size (not so with <code>Counter</code>). I was hoping there was a way to <i>mimic</i> what <code>Counter</code> is doing by <i>not</i> adding keys automatically.</span>
<span class="comment-copy"><code>c[3] += 1 # key added successfully</code> &lt;-- that's counting, no? You are saying there's one more 3. So the value increments by 1 (sorry, not trying to be awkward). This behaviour is shared with <code>defaultdict(int)</code>.</span>
<span class="comment-copy">it works but is a little slow.. See benchmarking in my question update.</span>
<span class="comment-copy">[Fyi, Aran-Fey's answer was updated <i>after</i> bounty offer.] Thanks for showing the <code>default_factory</code> parameter. That's exactly the kind of advice that I was looking for. I will have a play around and see what works best.</span>
