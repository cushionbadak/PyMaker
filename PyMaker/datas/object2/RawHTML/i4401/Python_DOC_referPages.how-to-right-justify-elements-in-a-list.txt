<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/8234445/python-format-output-string-right-alignment">Python: Format output string, right alignment</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>I need my func to print out the following:</p>
<pre><code>  apples Alice  dogs
 oranges   Bob  cats
cherries Carol moose
  banana David goose
</code></pre>
<p>all items are aligned to the right</p>
<p>and I have solution but it's kinda workaround, could you please help me to correct my solution? </p>
<pre><code>tableData = [['apples', 'oranges', 'cherries', 'banana'],
             ['Alice', 'Bob', 'Carol', 'David'],
             ['dogs', 'cats', 'moose', 'goose']]

def printData(lst):
  colWidths = [0] * len(tableData)

  for a in range(len(tableData)):
    colWidths[a] = len(max(tableData[a], key=len))

  for i in range(len(lst[0])):
    output = ''
    for j in range(len(lst)):
      output += (str(lst[j][i])).rjust(colWidths[0])
    print(output)


print(printData(tableData))

  apples   Alice    dogs
 oranges     Bob    cats
cherries   Carol   moose
  banana   David   goose
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" rel="nofollow noreferrer">format specification mini language</a> together with <code>str.format</code></p>
<pre><code>tableData = [['apples', 'oranges', 'cherries', 'banana'],
             ['Alice', 'Bob', 'Carol', 'David'],
             ['dogs', 'cats', 'moose', 'goose']]

for tup in zip(*tableData):
    print("{:&gt;9} {:&gt;9} {:&gt;9}".format(*tup))
</code></pre>
<p>prints</p>
<pre><code>   apples     Alice      dogs
  oranges       Bob      cats
 cherries     Carol     moose
   banana     David     goose
</code></pre>
<p>EDIT:</p>
<p>You can generate these strings dynamically, if you don't know what size you want the columns when you write the code</p>
<pre><code>from itertools import chain

def gen_format_str(widths):
    return ' '.join(["{{:&gt;{}}}".format(width) for width in widths])

def n_of_width(n, width):
    return gen_format_str([width] * n)

def all_widest(list_of_lists):
    return n_of_width(len(list_of_lists), max(map(len, chain.from_iterable(list_of_lists))))

format_str = all_widest(tableData)

for tup in zip(*tableData):
    print(format_str.format(*tup))
</code></pre>
<p><code>format_str</code> is <code>'{:&gt;8} {:&gt;8} {:&gt;8}'</code>, because the longest word, "cherries" is 8 characters long.</p>
</div>
<div class="post-text" itemprop="text">
<p>Doing this:</p>
<pre><code>for index in range(len(tableData)):
</code></pre>
<p>is wrong about 80% of the time. Try it first with <code>for a in mylist</code> or with <code>for index,a in enumerate(mylist)</code>. That is usually a simpler approach.</p>
<p>In this case:</p>
<pre><code>&gt;&gt;&gt; tableData = [['apples', 'oranges', 'cherries', 'banana'],
             ['Alice', 'Bob', 'Carol', 'David'],
             ['dogs', 'cats', 'moose', 'goose']]
&gt;&gt;&gt; fruits, persons, pets = tableData
&gt;&gt;&gt; for n,fruit in enumerate(fruits):
        print (f"{fruit:&gt;8s} {persons[n]:&gt;8s} {pets[n]:&gt;8s}")
  apples    Alice     dogs
 oranges      Bob     cats
cherries    Carol    moose
  banana    David    goose
</code></pre>
<p>But that doesn't handle scaling the column widths to take the least amount of space needed. To include that refinement, compute the column widths and include them in the formatting:</p>
<pre><code>&gt;&gt;&gt; widths = [max(len(x) for x in d) for d in tableData]
&gt;&gt;&gt; for n,fruit in enumerate(fruits):
        print (f"{fruit:&gt;{widths[0]}s} {persons[n]:&gt;{widths[1]}s} {pets[n]:&gt;{widths[2]}s}")

  apples Alice  dogs
 oranges   Bob  cats
cherries Carol moose
  banana David goose
</code></pre>
</div>
<span class="comment-copy">beat me for a second</span>
<span class="comment-copy">but how to know that 9 is enough?</span>
<span class="comment-copy">@nikkitikitavi You don't.  I'll include a way to dynamically generate these format strings based on some criteria.</span>
<span class="comment-copy">@nikkitikitavi see my edit. Play around with the format language, it's pretty powerful, and less complicated than the docs make it appear.  Chack out <a href="https://pyformat.info/" rel="nofollow noreferrer">pyformat.info</a>, the tutorial there is pretty good.</span>
