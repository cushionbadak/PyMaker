<div class="post-text" itemprop="text">
<p>This is the lists that i want to inflate:</p>
<p><img alt="https://i.stack.imgur.com/bX7Rn.png" src="https://i.stack.imgur.com/bX7Rn.png"/></p>
<p>Thats the sample run of the program that i want to make:</p>
<p><img alt="https://i.stack.imgur.com/AYDOG.png" src="https://i.stack.imgur.com/AYDOG.png"/> </p>
<pre><code>aList = [ "zero", "none", "nil", "null" ]
bList = [ "one", "won", "juan" ]
cList = [ "two", "to", "too", "tu" ]
dList = [ "three" ]
eList = [ "four", "for", "fore" ]
fList = [ "five" ]
gList = [ "six" ]
hList = [ "seven" ]
iList = [ "eight", "ate" ]
jList = [ "nine" ]
kList = [ "ten" ]
lList = [ "eleven" ]
mList = [ "twelve", "dozen" ]
nList = [ "never" ]
oList = [ "half" ]
pList = [ "once" ]
qList = [ "twice" ]
rList = [ "single" ]
sList = [ "double" ]
tList = [ "first" ]
uList = [ "second" ]
vList = [ "third" ]
wList = [ "fourth", "forth" ]


userInput = input( "Enter your sentence to inflate: " )
userInput = userInput.lower()


for i in userInput.split():
    if i in aList:
        userInput = userInput.replace( i, "one" )
    elif i in bList:
        userInput = userInput.replace( i, "two" )
</code></pre>
<p>Whenever i run this code it kinda works but it conflicts with other lists
for example this is the sample run of my code:</p>
<p><img alt="https://i.stack.imgur.com/xhDy4.png" src="https://i.stack.imgur.com/xhDy4.png"/></p>
<p>Any ideas of how i can make this program works ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, don't use a variable for each word. Use one big nested list, like this:</p>
<pre><code>replacements = [
    [["zero", "none", "nil", "null"], "one"],
    [["one", "won", "juan"], "two"],
    [["two", "to", "too", "tu"], "three"],
    [["three"], ""],
    [["four", "for", "fore"], ""],
    [["five"], ""],
    [["six"], ""],
    [["seven"], ""],
    [["eight", "ate"], ""],
    [["nine"], ""],
    [["ten"], ""],
    [["eleven"], ""],
    [["twelve", "dozen"], ""],
    [["never"], ""],
    [["half"], ""],
    [["once"], ""],
    [["twice"], ""],
    [["single"], ""],
    [["double"], ""],
    [["first"], ""],
    [["second"], ""],
    [["third"], ""],
    [["fourth", "forth"], ""],
]
</code></pre>
<p>(you can fill in the rest)</p>
<p>Then you can loop through that list to do your replacements. This has been covered in other answers.</p>
<p>To fix your problem, since <code>one</code> can be replaced by <code>two</code> and <code>two</code> can be replaced by <code>three</code> and so on, that means you need to replace all <code>three</code>s <em>before</em> replacing <code>two</code>s, and replace all <code>two</code>s before replacing <code>one</code>s... so you need to loop through the list and perform the replacements in a particular order. I don't want to give it away completely (although I pretty much have), take some time to think about it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should replace:</p>
<pre><code>for i in userInput.split():
    if i in aList:
        userInput = userInput.replace( i, "one" )
    elif i in bList:
        userInput = userInput.replace( i, "two" )
</code></pre>
<p>With just:</p>
<pre><code>for i in aList:
    userInput = userInput.replace( i, "one" )
for i in bList:
    userInput = userInput.replace( i, "two" )
</code></pre>
<p>It just goes through each item in each list, and replaces it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Rather than checking whether each input word is in one of your lists, you should check whether one of the words from your lists is in the input.  e.g. </p>
<pre><code>for word in aList: 
    if word in userInput: 
        userInput.replace(word, 'one')
...
</code></pre>
<p>And rather than having a ton of lists with a lot of copy-pasting, you could structure your lists differently to be able to iterate over them.  Maybe something like:</p>
<pre><code>from collections import namedtuple
Replacement = namedtuple('Replacement', ['before', 'after'])
replacements = [
    Replacement(["zero", "none", "nil", "null"], "one"),        
    Replacement(["one", "won", "juan"],          "two"),
    ...
]
for replacement in replacements: 
    for word in replacement.before:
        userInput = userInput.replace(word, replacement.after)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you structure your data carefully, you can do away with just two loops:</p>
<pre><code>lists = [
 { 
  "infl": "one", 
  "list": [ "zero", "none", "nil", "null" ] 
 },

 { "infl": "two",   "list": [ "one", "won", "juan" ] },
 { "infl": "three", "list": [ "two", "to", "too", "tu" ] },
 { "infl": "four",  "list": [ "three" ] },
 { "infl": "five",  "list": [ "four", "for", "fore" ] },
 # etc.... etc...
]

for lst in lists:
  for i in lst["list"]:
    userInput = userInput.replace(i, lst["infl"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had a lot of fun with this. Using <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a> you can really take advantage of using the function parameter of <code>sub</code> to accomplish this. This is super helpful since each captured group will be replaced only once (by finding non-overlapping patterns) so no repeated scans of the same string.</p>
<p>This solution is <strong>not</strong> prone to replacement issues of different numbers, but only the order that you place your words in the list such that a word in the list isn't contained in a successive word in the same list. So make sure that "to" comes after <em>"too"</em> otherwise <em>"tool"</em> would be replaced with <em>"threeol"</em> instead of <em>"threel"</em>.</p>
<pre><code>from re import sub, IGNORECASE
subs = {    #The new words are the keys. Respective values are the old words to replace
    "one": [ "zero", "none", "nil", "null" ],
    "two": [ "one", "won", "juan" ],
    "three": [ "two", "too", "to", "tu" ],
    "four": [ "three" ],
    "five": [ "four", "for", "fore" ],
    "six": [ "five" ],
    "seven": [ "six" ],
    "eight": [ "seven" ],
    "nine": [ "eight", "ate" ],
    "ten": [ "nine" ],
    "eleven": [ "ten" ],
    "twelve": [ "eleven" ],
    "thirteen": [ "twelve", "dozen" ],
    "once": [ "never" ],
    "one and a half": [ "half" ],
    "twice": [ "once" ],
    "thrice": [ "twice" ],
    "double": [ "single" ],
    "triple": [ "double" ],
    "second": [ "first" ],
    "third": [ "second" ],
    "fourth": [ "third" ],
    "fifth": [ "fourth", "forth" ]
}

#Flatten list of substitutes into regular expression with named capture groups
all_replacements = '|'.join('(?P&lt;{}&gt;{})'.format(new.replace(' ', '_'), '|'.join(olds)) for new, olds in subs.items())

def inc(match):     #increment 1 from the match
    return str(int(match.group()) + 1)

def inflate(match): #Get the next named capture group that exists and send new
    return next(new for new, old in match.groupdict().items() if old)

def replace(string):
    string = sub(r'\d+', inc, string)  #Increment all numbers
    string = sub(all_replacements, inflate, string, flags=IGNORECASE) #Inflate all words
    return string

print(replace("I wonder"))
print(replace(""))
print(replace("It was the best of times."))
print(replace("A Tale of 2 Cities"))
print(replace("A WoNder if 18 is bigger than 1919191"))
</code></pre>
<p>Results in the following printed items</p>
<pre><code>I twoder

It was the best of times.
A Tale of 3 Cities
A twoder if 19 is bigger than 1919192
</code></pre>
<p>Ultimately, your list can be scaled very easily while maintaining readability since you don't have to change any code if you decide to add to your list of substitutions.</p>
</div>
<span class="comment-copy">In the future, only use snippets for HTML, CSS, or Javascript code, they do not work for any other languages.</span>
<span class="comment-copy">Sure, didn't know how to implement a python code other then that way.</span>
<span class="comment-copy">Don't post screenshots of text please. Code formatting applies to anything you seen in a console as well. Please use it!</span>
<span class="comment-copy">Unrelated, but don't use individually named lists <code>aList</code>, <code>bList</code>, etc. Use a single list <code>stuff = [["zero", "none", "nil", "null"], ["one", "won", "juan"], ...]</code>.</span>
<span class="comment-copy">A single dict <code>{"zero": "one", "none": "one", "nil": "one", "null": "one", "one": "two", ...}</code> would be better, given the requirements in the second image.</span>
<span class="comment-copy">You need to assign the result of <code>.replace</code>. The <code>in</code> check is also not necessary.</span>
