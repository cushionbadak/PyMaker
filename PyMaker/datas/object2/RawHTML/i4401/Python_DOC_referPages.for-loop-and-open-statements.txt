<div class="post-text" itemprop="text">
<p>I understand why the first <code>for</code> loop works; that loop is essentially looping through a list, as per the <code>readlines()</code> method.</p>
<p>The <em>second</em> <code>for</code> loop doesn't make sense to me. The loop is opening the file, but since the default for an <code>open</code> statement is <em>read</em>, shouldn't the output be the whole file in one big string upon each iteration, instead of a single line?</p>
<p>Here's the code:</p>
<pre><code>#The two for loops do the same thing:

for line in open('test.txt').readlines():
    print(line.rstrip())
for line in open('test.txt'): # Use iterators: best for text input
    print(line.rstrip())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You misunderstood the 'default' here. The default you found talks about the <em>file mode</em>; the default is to open the file <strong>for</strong> reading. The file won't be read at that point, it tells the OS that you want to access a file that already has to exist and is readable by your process.</p>
<p><code>open()</code> returns a file object, always. And file objects are iterables, so you can loop over one, provided it is opened for reading (so the mode is <code>'r'</code>, or <code>'w+'</code> or <code>'a+'</code>).</p>
<p>From the <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer"><code>open()</code> documentation</a>:</p>
<blockquote>
<p>Open <em>file</em> and return a corresponding <a href="https://docs.python.org/3/glossary.html#term-file-object" rel="nofollow noreferrer">file object</a>.</p>
</blockquote>
<p>and</p>
<blockquote>
<p><em>mode</em> is an optional string that specifies the mode in which the file is opened. It defaults to <code>'r'</code> which means open for reading in text mode. Other common values are <code>'w'</code> for writing (truncating the file if it already exists), <code>'x'</code> for exclusive creation and <code>'a'</code> for appending[.]</p>
</blockquote>
<p><code>open()</code> always returns an object that inherits from <a href="https://docs.python.org/3/library/io.html#io.IOBase" rel="nofollow noreferrer"><code>io.IOBase</code></a>, and it says this about iteration:</p>
<blockquote>
<p><code>IOBase</code> (and its subclasses) supports the iterator protocol, meaning that an <code>IOBase</code> object can be iterated over yielding the lines in a stream. Lines are defined slightly differently depending on whether the stream is a binary stream (yielding bytes), or a text stream (yielding character strings).</p>
</blockquote>
<p>You should always use iteration over the file over iteration over <code>.readlines()</code>; the latter reads <strong>all</strong> lines into memory in one step, puts all those lines into a list, then returns that list. This will certainly cause issues when the file you opened is large. If all you need is access to the individual lines, one by one, iteration over the file itself will only create lines as needed, and buffering takes care of making this efficient (the OS is asked to give data in convenient chunks for Python to process into lines).</p>
<p>Note that even <em>if</em> <code>open()</code> returned a <em>single</em> string containing all of the file contents, iteration would then take place on a sequence of characters; you would not see the file contents repeated. You could try this out with the <code>file.read()</code> command:</p>
<pre><code>&gt;&gt;&gt; with open('/tmp/demo.txt', 'w') as outputfile:  # opened for writing
...     outputfile.write(  # write 3 lines
...         'Neque porro quisquam\n'
...         'est qui dolorem ipsum\n'
...         'quia dolor sit amet\n')
...
63
&gt;&gt;&gt; for i, value in enumerate(open('/tmp/demo.txt').read()):  # read everything into a string
...     if i &gt; 5:  # limit the output, enumerate provided us with an index
...         break
...     print(value)
...
N
e
q
u
e
</code></pre>
<p>Another reason that the file data wouldn't repeat is that files are a lot like classical magnetic tape: files have a <em>file position</em>, which moves forward along the file as you read data from it, and this position doesn't automatically go back to the start once you reach the end. Without re-opening a file, or using the <code>file.seek()</code> method to set the file position to the start again, you only get to read the data <em>once</em>:</p>
<pre><code>&gt;&gt;&gt; with open('/tmp/demo.txt') as inputfile:
...     print(len(inputfile.read()))  # get all data, and print the length
...     print(len(inputfile.read()))  # try again, note that we got no data this time!
...     __ = inputfile.seek(0)   # rewind to the start
...     print(len(inputfile.read()))  # try again, now we get data again
...
63
0
63
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A loop</p>
<pre><code>for i in iterable: 
    # some code with i
</code></pre>
<p>is <em>basically</em> a shorthand for</p>
<pre><code>iterator = iter(iterable)
while True:
    try:
        i = next(iterator)            
    except StopIteration:
        break
    # some code with i
</code></pre>
<p>So the <code>for</code> loop extracts values from an iterator constructed from the iterable one by one and automatically recognizes when that iterator is exhausted and stops.</p>
<p>It just happens that the return value of <code>open</code> is an iterator that gives you <strong>one line</strong> for each call to its <code>__next__</code> method.</p>
<p>Bonus:</p>
<p>In your case, <code>open('test.txt')</code> returns an iterator, so calling <code>__iter__</code> on it returns the iterator itself.</p>
<pre><code>&gt;&gt;&gt; it = open('test.txt')
&gt;&gt;&gt; iter(it) is it
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check python documentation:
<a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#open</a></p>
<blockquote>
<p>The default mode is 'r' (open for reading text, synonym of 'rt'). For binary read-write access, the mode 'w+b' opens and truncates the file to 0 bytes. 'r+b' opens the file without truncation.</p>
<p>As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including 'b' in the mode argument) return contents as bytes objects without any decoding. In text mode (the default, or when 't' is included in the mode argument), the contents of the file are returned as str, the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given.</p>
</blockquote>
<p>It's because of default setting of <code>open()</code> function</p>
</div>
<span class="comment-copy"><i>default for an open statement is read</i>: I'm not sure what you mean there. Are you getting confused with the <i>mode</i> of the file? The default mode is <code>'r'</code>, which is to <i>open for reading</i>, not <i>read all the data</i>.</span>
<span class="comment-copy">"And file objects are iterables, so you can loop over one" &lt;-- ah i missed that point. thanks for the quick response!</span>
<span class="comment-copy">The information you provided about the 'open()' inheriting from io.IOBase and how IOBase objects works really hit it home for me..thanks a bunch!</span>
