<div class="post-text" itemprop="text">
<p>I write python script that read JSON from file, transform it and at the end write modified JSON to file. JSON that I read doesn't have white characters, because I need minimal size. </p>
<p>The problem is when I read JSON from file and call <code>json.loads(json_content)</code> I get <code>dictionary</code> object and python adds spaces between key and values. </p>
<p>JSON in file:</p>
<p><code>{"metadata":{"info":"important info"},"timestamp":"2018-04-06T12:19:38.611Z","content":{"id":"1","name":"name test","objects":[{"id":"1","url":"http://example.com","properties":[{"id":"1","value":"1"}]}]}}
</code></p>
<p>My script:</p>
<pre><code>def get_contents_from_json(file_path):
    with open(file_path) as file:
        contents = file.read()
        print(contents)
        print(type(contents))
        print(sys.getsizeof(contents))
        print(len(contents))
        return json.loads(contents)


if __name__ == '__main__':
    data = get_contents_from_json(STACK_JSON)
    print(data)
    print(type(data))
    print(sys.getsizeof(data))

    string_data = json.dumps(data)
    print(string_data)
    print(type(string_data))
    print(sys.getsizeof(string_data))
    print(len(string_data))

    trimmed = string_data.replace(" ", "")
    print(contents)
    print(type(trimmed))
    print(sys.getsizeof(trimmed))
    print(len(trimmed))
</code></pre>
<p>And the output of this piece of code is:</p>
<pre><code>{"metadata":{"info":"important info"},"timestamp":"2018-04-06T12:19:38.611Z","content":{"id":"1","name":"name test","objects":[{"id":"1","url":"http://example.com","properties":[{"id":"1","value":"1"}]}]}}

&lt;class 'str'&gt;
255
206
{'metadata': {'info': 'important info'}, 'timestamp': '2018-04-06T12:19:38.611Z', 'content': {'id': '1', 'name': 'name test', 'objects': [{'id': '1', 'url': 'http://example.com', 'properties': [{'id': '1', 'value': '1'}]}]}}
&lt;class 'dict'&gt;
240
{"metadata": {"info": "important info"}, "timestamp": "2018-04-06T12:19:38.611Z", "content": {"id": "1", "name": "name test", "objects": [{"id": "1", "url": "http://example.com", "properties": [{"id": "1", "value": "1"}]}]}}
&lt;class 'str'&gt;
273
224
{"metadata":{"info":"importantinfo"},"timestamp":"2018-04-06T12:19:38.611Z","content":{"id":"1","name":"nametest","objects":[{"id":"1","url":"http://example.com","properties":[{"id":"1","value":"1"}]}]}}
&lt;class 'str'&gt;
252
203
</code></pre>
<p>Explanation:</p>
<p>Python reads JSON from file as string that is the same in the file. Length of <code>contents</code> is 206 and size is 255 because empty string in python has 49 bytes. </p>
<p>Calling <code>json.loads(contents)</code> returns <code>dict</code> object that has size 240. JSON represented as <code>dict</code> object has added spaces between key names and values. And this is the cause why after call <code>string_data = json.dumps(data)</code> size of <code>string_data</code> is equal to 274 and length is equal to 224. Therefore I tried to remove white spaces from <code>string_data</code> using function <code>.replace(" ", "")</code>, but I forget that some values have white spaces and after this operation JSON is not correct.</p>
<p>I need to read JSON as dict object to convenient transformations and at the same time I have to keep minimal size of JSON.</p>
<p>Is there any way to remove unnecessary white spaces from <code>dict</code> object?</p>
</div>
<div class="post-text" itemprop="text">
<p>All you need to care about is the <strong>length</strong> of a string, so use <code>len()</code> to compare results. </p>
<p>If you care about generated JSON sizes, you can trivially tell <code>json.dumps()</code> to not use any spaces:</p>
<pre><code>string_data = json.dumps(data, separators=(',', ':'))
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; sample = '''{"metadata":{"info":"important info"},"timestamp":"2018-04-06T12:19:38.611Z","content":{"id":"1","name":"name test","objects":[{"id":"1","url":"http://example.com","properties":[{"id":"1","value":"1"}]}]}}'''
&gt;&gt;&gt; data = json.loads(sample)
&gt;&gt;&gt; len(sample)
205
&gt;&gt;&gt; len(json.dumps(data))
224
&gt;&gt;&gt; len(json.dumps(data, separators=(',', ':')))
205
</code></pre>
<p>With <code>separators</code> specified, the output length matches the original input. The <code>separators</code> option is documented as:</p>
<blockquote>
<p>If specified, <em>separators</em> should be an <code>(item_separator, key_separator)</code> tuple. The default is <code>(', ', ': ')</code> if <em>indent</em> is <code>None</code> and <code>(',', ': ')</code> otherwise. <strong>To get the most compact JSON representation, you should specify <code>(',', ':')</code> to eliminate whitespace.</strong></p>
</blockquote>
<p>(Bold emphasis mine).</p>
<p><code>sys.getsizeof()</code> is the wrong tool to make comparisons here. The function gives you the memory footprint of an object (without recursing), and this memory footprint is a <em>implementation detail</em> of your current Python implementation and operating system specific data type sizes.</p>
<p>The <code>dict</code> object uses 240 bytes on your OS, but this is a over-allocated hash table of references. On a different OS with different size pointers, the memory size would be different, and either way, you didn't include the size of the referenced string objects. For string objects, the memory footprint depends heavily on the highest Unicode codepoint; the string <code>'a'</code> has a different footprint from <code>'ìêë'</code>, even both have length 1, because the latter contains a non-BMP codepoint so <em>4 bytes</em> are needed to store just that one character, plus Python object overhead.</p>
<p>Next, all you saved was 19 spaces. Compression would have saved you much more, and spaces don't matter much when compressing:</p>
<pre><code>&gt;&gt;&gt; import zlib
&gt;&gt;&gt; len(zlib.compress(json.dumps(data).encode('utf8'), 9))
155
&gt;&gt;&gt; len(zlib.compress(json.dumps(data, separators=(',', ':')).encode('utf8'), 9))
154
</code></pre>
<p>Compression saved 50 bytes there, while using the compact JSON separators saved another single byte.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>json.dumps</code> function accepts several arguments that let you specify how you want the data formatted when you write your dictionary back out to a JSON string. From it's docstring:</p>
<blockquote>
<p>If <code>indent</code> is a non-negative integer, then JSON array elements and
      object members will be pretty-printed with that indent level. An indent
      level of 0 will only insert newlines. <code>None</code> is the most compact
      representation.</p>
<p>If specified, <code>separators</code> should be an <code>(item_separator, key_separator)</code>
      tuple.  The default is <code>(', ', ': ')</code> if <em>indent</em> is <code>None</code> and
      <code>(',', ': ')</code> otherwise.  To get the most compact JSON representation,
      you should specify <code>(',', ':')</code> to eliminate whitespace.</p>
</blockquote>
<p>So try <code>string_data = json.dumps(data, indent=None, separators=(',', ':'))</code> for the most compact representation.</p>
</div>
<span class="comment-copy">You are looking at implementation details of the memory footprints of objects, not their string length. Not sure why you are doing that.</span>
<span class="comment-copy">If you need minimal size you can apply some <a href="https://docs.python.org/3/library/archiving.html" rel="nofollow noreferrer">compression</a> on that output file. You will gain much more size reduction than just by fiddling with spaces.</span>
