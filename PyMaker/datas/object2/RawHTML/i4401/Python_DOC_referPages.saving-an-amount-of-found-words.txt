<div class="post-text" itemprop="text">
<p>I've been doing this checkio tasks and I got stuck.
I was given a list of some words and a string followed by a text. The task is I need to count the number of words from the list in the text and create a dictionary where the key is a word and value is amount. It must look like this:</p>
<pre><code>popular_words('''

When I was One

I had just begun

When I was Two

I was nearly new

''', ['i', 'was', 'three', 'near'])
</code></pre>
<p>and the output:</p>
<pre><code>{

'i': 4,

'was': 3,

'three': 0,

'near': 0

}
</code></pre>
<p>I did almost everything but I don't know how to add a word to this dictionary which is not in text (like 'near' : 3)</p>
<p>That's what I got:</p>
<pre><code>result = {}
number = 0
list1 = []

words = '''

When I was One

I had just begun

When I was Two

I was nearly new

'''

check = ['i', 'was', 'three', 'near']
a = list(words.split())

for word in a:
    if word.lower() in check:
        wc = words.count(word)
        result[word] = wc


print(result)
</code></pre>
<p>I tried:</p>
<pre><code>for word in a:
        if word.lower() in check:
            wc = words.count(word)
            if words.count(word) == 0:
                result[word] = 0
            else:
                result[word] = wc
</code></pre>
<p>But it doesn't work :(</p>
</div>
<div class="post-text" itemprop="text">
<p>first, word.split() already gives you a list. No need to convert it into a list again.</p>
<p>Second, what you should be doing is iterating through check (you only care about words in check), instead of through a.</p>
<p>Third, you could use dictionary comprehension to speed things up:</p>
<pre><code>a = words.lower().split()
results = {word:a.count(word) for word in check}
</code></pre>
<p>going over the code, words.split() is the same as list(words.split())
The code for results in a pythonic (and faster) way of doing the following:</p>
<pre><code>results = {}
for word in check:
    results[word] = a.count(word)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this, it should be faster than iterating yourself. The <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter</a> class has the added benefit of handling words not found in the text.</p>
<pre><code>from collections import Counter
result = {k: Counter(words.lower().split())[k] for k in check}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import Counter

words = '''

When I was One

I had just begun

When I was Two

I was nearly new

'''

check = ['i', 'was', 'three', 'near']

words = Counter(words.split())
newcounter = {}


for i in words:
    if i.lower() in check:
        newcounter[i.lower()] = words[i]


print(newcounter)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code is not very efficient, as you're looping through the whole text, word by word, but then using <code>.count(word)</code> which also loops through the whole text. You might want to increment a counter (which happens to be your dictionary) like this:</p>
<pre><code>if word.lower() in check:
    if word in result:
       word[result] += 1
    else:
       word[result] = 1
</code></pre>
<p>. 
After looping through your text, you can loop through your list of popular words and adding them to the dic if they're not in: </p>
<pre><code>if not pop_word in result:
   result[pop] = 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should initialize the result dictionary from the given list of interesting words, and then increase the count each time you find a word:</p>
<pre><code>def popular_words(txt, wordlist):
    result = { w.lower():0 for w in wordlist }  # initialize count to 0
    for word in txt.split():
        w = word.lower()                        # only considere lower case
        if w in result:
            result[w] += 1                      # increase for each occurence
    return result
</code></pre>
</div>
