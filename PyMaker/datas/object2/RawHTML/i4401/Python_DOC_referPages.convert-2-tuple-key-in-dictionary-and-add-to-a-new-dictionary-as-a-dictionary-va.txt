<div class="post-text" itemprop="text">
<p>So I have the values:</p>
<pre><code>values = {(0, 0): 0, (0, 1): 1, (1, 0): 1, (1, 1): 0}
</code></pre>
<p>and I want to convert the above dictionary to be:</p>
<pre><code>values = {0: {0: 0, 1: 1}, 1: {0: 1, 1: 0}}
</code></pre>
<p>my function:</p>
<pre><code>def convert(values : {(int,int): int}) -&gt; {int: {int: int}}:
    dictionary = {}
    l = []

    for k in d.keys():
        l.append(k)

    for k,v in d.items():
        for i in l:
            if i == k:
                dictionary[v] = dict(l)

    return dictionary
</code></pre>
<p>but I'm getting this as my output instead:</p>
<pre><code>values = {0: {0: 1, 1: 1}, 1: {0: 1, 1: 1}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A loop and <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="noreferrer"><code>dict.setdefault()</code></a> can do that like:</p>
<h3>Code:</h3>
<pre><code>values = {(0, 0): 0, (0, 1): 1, (1, 0): 1, (1, 1): 0}

result = {}
for k, v in values.items():
    result.setdefault(k[0], {})[k[1]] = v

print(result)
</code></pre>
<h3>Results:</h3>
<pre><code>{0: {0: 0, 1: 1}, 1: {0: 1, 1: 0}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You just want to group things. The idiomatic way is to use a <code>defaultdict</code>:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; values = {(0, 0): 0, (0, 1): 1, (1, 0): 1, (1, 1): 0}
&gt;&gt;&gt; new_values = defaultdict(dict)
&gt;&gt;&gt; for (x,y), v in values.items():
...     new_values[x][y] = v
...
&gt;&gt;&gt; new_values
defaultdict(&lt;class 'dict'&gt;, {0: {0: 0, 1: 1}, 1: {0: 1, 1: 0}})
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I propose for you a more general approach:</p>
<pre><code>from collections import defaultdict

def tree():
    def the_tree():
        return defaultdict(the_tree)
    return the_tree()

t = tree()
for (x, y), z in values.items():
    t[x][y] = z
</code></pre>
<p>To "close" any node of the tree from further additions, just set its default factory to <code>None</code>.  For example, to seal it at the trunk:</p>
<pre><code>&gt;&gt;&gt; t.default_factory = None
&gt;&gt;&gt; t[2]
# KeyError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A solution for an arbitrary depth:</p>
<pre><code>def convert_tupledict(d):
    result = {}
    for ks, v in d.items():
        subresult = result
        *kis, ks = ks
        for ki in kis:
            if ki in subresult:
                subresult = subresult[ki]
            else:
                subresult[ki] = subresult = {}
        subresult[ks] = v
    return result
</code></pre>
<p>We can then call it with:</p>
<pre><code>convert_tupledict({(0, 0): 0, (0, 1): 1, (1, 0): 1, (1, 1): 0})
</code></pre>
<p>For 2-tuples, the following sulution should be sufficient:</p>
<pre><code>def convert_2tupledict(d):
    result = {}
    for (k1, k2), v in d.items():
        result.setdefault(k1, {})[k2] = v
    return result
</code></pre>
</div>
<span class="comment-copy">Are there only 2-tuples? Or can this have an arbitrary depth?</span>
<span class="comment-copy">can you explain what is happening in <code>[k[1]] = v</code></span>
<span class="comment-copy">@pyd The <code>k[1]</code> fetches the second element of <code>k</code>, then the outer <code>[]</code> means that that element is used as a key to be assigned the value <code>v</code> in the <code>result</code> dictionary (actually not directly inside <code>result</code>, but inside the dictionary associated with the key <code>k[0]</code> of <code>result</code>).  Frankly, I hate to see <code>setdefault</code>. I'd rather use <code>collections.defaultdict(dict)</code>, then that line would simply look like: <code>result[k[0]][k[1]] = v</code>. Here you can easily see that it's just a nested assignement.</span>
<span class="comment-copy">Clearer than the accepted answer. You should convert to a dict when youâ€™re done filling it it.</span>
