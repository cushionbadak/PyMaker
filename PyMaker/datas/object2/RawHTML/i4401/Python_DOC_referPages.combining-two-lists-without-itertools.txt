<div class="post-text" itemprop="text">
<p>For part of a project, I have to show all possible combinations of three-colorings for a given graph, defined in a dictionary. This does not check for valid colorings, as it is simply a helper method.</p>
<p><strong>Example</strong></p>
<pre><code>three_color({"A":["B"], "B":["A"]})

 Should give us:

 [{'A': '1', 'B': '1'},
 {'A': '1', 'B': '2'},
 {'A': '1', 'B': '3'},
 {'A': '2', 'B': '1'},
 {'A': '2', 'B': '2'},
 {'A': '2', 'B': '3'},
 {'A': '3', 'B': '1'},
 {'A': '3', 'B': '2'},
 {'A': '3', 'B': '3'}]
</code></pre>
<p>However, we are prohibited from importing any libraries. Currently, I am working with this solution and trying to transfer it without using product()</p>
<pre><code>coloring = ([dict(zip(graph, p)) for p in product(colors,repeat = len(graph))])
</code></pre>
<p>My current solution is based on the fact, according to the documentation, <code>product(A, B)</code> returns the same as <code>((x,y) for x in A for y in B).</code></p>
<p>Currently, I have</p>
<pre><code>def three_color(graph):
    colors = ['1','2','3']

    coloring = ([dict(zip(graph, p)) for p in ((x,y) for x in colors for y in (range(1,4)))])
    #coloring = ([dict(zip(graph, p)) for p in product(colors,repeat = len(graph))])

    return coloring
</code></pre>
<p>This gives me the correct answer when using graph <code>{"A":["B"], "B":["A"]}</code>, but it doesn't seem to work when with any other number of vertices.</p>
<p><strong>Example 2</strong></p>
<pre><code>three_color({"A":["B","C"], "B":["A"], "C":["A"]})

Should give us:
[{'A': '1', 'B': '1', 'C': '1'},
 {'A': '1', 'B': '1', 'C': '2'},
 {'A': '1', 'B': '1', 'C': '3'},
 {'A': '1', 'B': '2', 'C': '1'},
 {'A': '1', 'B': '2', 'C': '2'},
 {'A': '1', 'B': '2', 'C': '3'},
 {'A': '1', 'B': '3', 'C': '1'},
 {'A': '1', 'B': '3', 'C': '2'},
 {'A': '1', 'B': '3', 'C': '3'},
 {'A': '2', 'B': '1', 'C': '1'},
 {'A': '2', 'B': '1', 'C': '2'},
 {'A': '2', 'B': '1', 'C': '3'},
 {'A': '2', 'B': '2', 'C': '1'},
 {'A': '2', 'B': '2', 'C': '2'},
 {'A': '2', 'B': '2', 'C': '3'},
 {'A': '2', 'B': '3', 'C': '1'},
 {'A': '2', 'B': '3', 'C': '2'},
 {'A': '2', 'B': '3', 'C': '3'},
 {'A': '3', 'B': '1', 'C': '1'},
 {'A': '3', 'B': '1', 'C': '2'},
 {'A': '3', 'B': '1', 'C': '3'},
 {'A': '3', 'B': '2', 'C': '1'},
 {'A': '3', 'B': '2', 'C': '2'},
 {'A': '3', 'B': '2', 'C': '3'},
 {'A': '3', 'B': '3', 'C': '1'},
 {'A': '3', 'B': '3', 'C': '2'},
 {'A': '3', 'B': '3', 'C': '3'}]

But it gives me:
[{'A': '1', 'B': 1},
 {'A': '1', 'B': 2},
 {'A': '1', 'B': 3},
 {'A': '2', 'B': 1},
 {'A': '2', 'B': 2},
 {'A': '2', 'B': 3},
 {'A': '3', 'B': 1},
 {'A': '3', 'B': 2},
 {'A': '3', 'B': 3}]
</code></pre>
<p>Any guidance or assistance is greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you check out the <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code> documentation</a>, they provide implementations of most of their builtin functions.</p>
<p>For <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>product</code></a>, the only difference in the one they provide is that the <code>itertools</code> implementation does not build up intermediate results in memory.  </p>
<p>You can take the function provided in the documentation, and use it as your product function in your example:</p>
<pre><code>def product(*args, repeat=1):
    pools = [tuple(pool) for pool in args] * repeat
    result = [[]]
    for pool in pools:
        result = [x+[y] for x in result for y in pool]
    for prod in result:
        yield tuple(prod)

def coloring(graph):
  colors = ['1','2','3']
  return [dict(zip(graph, p)) for p in product(colors,repeat = len(graph))]

print(coloring({"A":["B","C"], "B":["A"], "C":["A"]}))
</code></pre>
<p>Output:</p>
<pre><code>[{'A': '1', 'B': '1', 'C': '1'}, {'A': '1', 'B': '1', 'C': '2'}, {'A': '1', 'B': '1', 'C': '3'}, {'A': '1', 'B': '2', 'C': '1'}, {'A': '1', 'B': '2', 'C': '2'}, {'A': '1', 'B': '2', 'C': '3'}, {'A': '1', 'B': '3', 'C': '1'}, {'A': '1', 'B': '3', 'C': '2'}, {'A': '1', 'B': '3', 'C': '3'}, {'A': '2', 'B': '1', 'C': '1'}, {'A': '2', 'B': '1', 'C': '2'}, {'A': '2', 'B': '1', 'C': '3'}, {'A': '2', 'B': '2', 'C': '1'}, {'A': '2', 'B': '2', 'C': '2'}, {'A': '2', 'B': '2', 'C': '3'}, {'A': '2', 'B': '3', 'C': '1'}, {'A': '2', 'B': '3', 'C': '2'}, {'A': '2', 'B': '3', 'C': '3'}, {'A': '3', 'B': '1', 'C': '1'}, {'A': '3', 'B': '1', 'C': '2'}, {'A': '3', 'B': '1', 'C': '3'}, {'A': '3', 'B': '2', 'C': '1'}, {'A': '3', 'B': '2', 'C': '2'}, {'A': '3', 'B': '2', 'C': '3'}, {'A': '3', 'B': '3', 'C': '1'}, {'A': '3', 'B': '3', 'C': '2'}, {'A': '3', 'B': '3', 'C': '3'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use simple recursion with a generator function, then use <code>zip</code> to pair the full colorings to the graph:</p>
<pre><code>def full_product(d, d1, current = []):
   if d == len(current):
      yield current
   else:
      for i in range(d):
        for b in range(1, d1):
           yield from full_product(d, d1, current + [b])

def final_results(data):
  def wrapper():
    for colors in data():
       full_set = set(reduce(lambda x, y:x+y, [[a]+b for a, b in colors.items()]))
       result = list(full_product(len(full_set), 4))
       last_result = [a for i, a in enumerate(result) if all(a != c for c in result[:i])]
       yield [dict(zip(full_set, i)) for i in last_result]
  return wrapper

@final_results
def full_results():
   return [{"A":["B"], "B":["A"]}, {"A":["B","C"], "B":["A"], "C":["A"]}]

print(list(full_results()))
</code></pre>
<p>Output:</p>
<pre><code>[[{'A': 1, 'B': 1}, {'A': 1, 'B': 2}, {'A': 1, 'B': 3}, {'A': 2, 'B': 1}, {'A': 2, 'B': 2}, {'A': 2, 'B': 3}, {'A': 3, 'B': 1}, {'A': 3, 'B': 2}, {'A': 3, 'B': 3}], [{'A': 1, 'B': 1, 'C': 1}, {'A': 1, 'B': 1, 'C': 2}, {'A': 1, 'B': 1, 'C': 3}, {'A': 1, 'B': 2, 'C': 1}, {'A': 1, 'B': 2, 'C': 2}, {'A': 1, 'B': 2, 'C': 3}, {'A': 1, 'B': 3, 'C': 1}, {'A': 1, 'B': 3, 'C': 2}, {'A': 1, 'B': 3, 'C': 3}, {'A': 2, 'B': 1, 'C': 1}, {'A': 2, 'B': 1, 'C': 2}, {'A': 2, 'B': 1, 'C': 3}, {'A': 2, 'B': 2, 'C': 1}, {'A': 2, 'B': 2, 'C': 2}, {'A': 2, 'B': 2, 'C': 3}, {'A': 2, 'B': 3, 'C': 1}, {'A': 2, 'B': 3, 'C': 2}, {'A': 2, 'B': 3, 'C': 3}, {'A': 3, 'B': 1, 'C': 1}, {'A': 3, 'B': 1, 'C': 2}, {'A': 3, 'B': 1, 'C': 3}, {'A': 3, 'B': 2, 'C': 1}, {'A': 3, 'B': 2, 'C': 2}, {'A': 3, 'B': 2, 'C': 3}, {'A': 3, 'B': 3, 'C': 1}, {'A': 3, 'B': 3, 'C': 2}, {'A': 3, 'B': 3, 'C': 3}]]
</code></pre>
</div>
<span class="comment-copy">Welcome to StackOverflow.  Please read and follow the posting guidelines in the help documentation, as suggested when you created this account.  <a href="http://stackoverflow.com/help/mcve">Minimal, complete, verifiable example</a> applies here.  We cannot effectively help you until you post your MCVE code and accurately describe the problem. We should be able to paste your posted code into a text file and reproduce the problem you described.</span>
<span class="comment-copy">For starters, when you have three arguments, <code>product()</code> behaves differently than it does with two arguments. Don't bang your head against the wall making this a one-liner; split it out into your own <code>product()</code> function.</span>
