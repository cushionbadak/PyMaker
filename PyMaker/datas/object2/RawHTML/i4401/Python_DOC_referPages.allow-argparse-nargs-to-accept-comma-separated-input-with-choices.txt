<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/48714523/comma-separated-inputs-instead-of-space-separated-inputs-for-argsparse">Comma separated inputs instead of space separated inputs for Argsparse</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I want to use argparse's {choices} parameter, but allow the user to input any number of items from choices. For example if choices is [1,2,3], I would like the following to be valid:</p>
<pre><code>--arg 1
--arg 1,2
--arg 1,3
</code></pre>
<p>etc.</p>
<p>However it seems like choices doesn't accept a comma-separated input when using nargs="+". Is there any way around this? I still want to enforce that the passed in options are within the set of choices that I defined, to error-check for weird inputs.</p>
</div>
<div class="post-text" itemprop="text">
<p>This one-line code gives you all possible subsets of your choices.</p>
<pre><code>    from itertools import combinations, chain
    allsubsets = lambda n: list(chain(*[combinations(range(n), ni) for ni in range(n+1)]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I agree - You would think that the API would allow someone to do that by now right?</p>
<p>Well anyways, the workaround I've always used was the following:</p>
<pre><code>p = argparse.ArgumentParser(description="Why doesn't argparse support list of args?")
parser.add_argument('--arg', type=str)
arg_list = parser.parse_args().args.split(",")
# if you wanted integers:
arg_list = [int(x) for x in arg_list]
</code></pre>
<p>AKA: Take in a string and process it yourself.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my approach to achieve this  :</p>
<pre><code>import argparse
arg=argparse.ArgumentParser()
arg.add_argument( "--lista",  nargs="*", type=int, default=[1, 2, 3], )

args = arg.parse_args()
print("lista: {0}" .format(args.lista))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import argparse, sys
print(sys.argv)
parser = argparse.ArgumentParser()
parser.add_argument('--arg', nargs='+', choices=[1,2,3], type=int)
args = parser.parse_args()
print(args)
</code></pre>
<p>some runs</p>
<pre><code>1455:~/mypy$ python stack49824248.py --arg 1 
['stack49824248.py', '--arg', '1']
Namespace(arg=[1])

1455:~/mypy$ python stack49824248.py --arg 1 3 2 1
['stack49824248.py', '--arg', '1', '3', '2', '1']
Namespace(arg=[1, 3, 2, 1])

1456:~/mypy$ python stack49824248.py --arg 1,2
['stack49824248.py', '--arg', '1,2']
usage: stack49824248.py [-h] [--arg {1,2,3} [{1,2,3} ...]]
stack49824248.py: error: argument --arg: invalid int value: '1,2'
</code></pre>
<p>The shell, together with the interpreter, splits the input on spaces, and provides a list of strings in <code>sys.argv</code>.  That's what <code>parser</code> handles.</p>
<p>With <code>+</code>, the <code>--arg</code> action accepts a list of strings (to the end or next flag).  Each string is passed through the <code>type</code> function, and the result compared to the <code>choices</code> (if provided). In this case, <code>type</code> is <code>int</code>, so the choices can be integers as well.  Without the <code>type</code>, <code>choices</code> would have to be <code>['1','2','3']</code>.</p>
<p>If I change the argument to:</p>
<pre><code>parser.add_argument('--arg', nargs='+', choices=['1','2','3','1,2','2,3'])
</code></pre>
<p>it will accept some strings with commas:</p>
<pre><code>1456:~/mypy$ python stack49824248.py --arg 1
['stack49824248.py', '--arg', '1']
Namespace(arg=['1'])
1505:~/mypy$ python stack49824248.py --arg 1,2
['stack49824248.py', '--arg', '1,2']
Namespace(arg=['1,2'])
1505:~/mypy$ python stack49824248.py --arg 1,2,3
['stack49824248.py', '--arg', '1,2,3']
usage: stack49824248.py [-h] [--arg {1,2,3,1,2,2,3} [{1,2,3,1,2,2,3} ...]]
stack49824248.py: error: argument --arg: invalid choice: '1,2,3' (choose from '1', '2', '3', '1,2', '2,3')
</code></pre>
<p>I didn't include the '1,2,3' choice, so it rejected that.  Note also that I dropped the <code>int</code> <code>type</code>, since <code>int('1,2')</code> will fail.</p>
<p>So if you need to accept '1,2,3', do your own split and choices test after parsing (or possibly as a custom <code>Action</code> class).</p>
<pre><code>In [16]: [(int(x) in [1,2,3]) for x in '1,2,3'.split(',')]
Out[16]: [True, True, True]
In [17]: [(int(x) in [1,2,3]) for x in '1,2,4'.split(',')]
Out[17]: [True, True, False]
In [18]: [(int(x) in [1,2,3]) for x in '1,a,4'.split(',')]
....
ValueError: invalid literal for int() with base 10: 'a'
</code></pre>
</div>
<span class="comment-copy">Does the list have to be comma-separated? The standard <code>argparse</code> format would be space separated: <a href="https://docs.python.org/3/library/argparse.html#nargs" rel="nofollow noreferrer">docs.python.org/3/library/argparse.html#nargs</a></span>
<span class="comment-copy">Hey sorry, I actually changed my question a bit. I want to enforce using "choices", which I didn't initially mention - any ideas on how to have that work?</span>
<span class="comment-copy">Do you need to use choices? Why not just use a set and check the results afterwards?</span>
<span class="comment-copy">I like the CLI that choices provides, offering the user feedback if they enter an incorrect option. Honestly I think I'm leaning towards just not using comma-separated inputs :P</span>
<span class="comment-copy">That's fair. I think then you should take @toheedNiaz's answer :)</span>
