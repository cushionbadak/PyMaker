<div class="post-text" itemprop="text">
<p>I have a string:  'AAAAATTT'</p>
<p>I want to write a program that would count each time 2 values are identical. 
So in 'AAAAATTT' it would give a count of:</p>
<p>AA: 4
TT: 2</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>collections.defaultdict</code> for this. This is an O(n) complexity solution which loops through adjacent letters and builds a dictionary based on a condition.</p>
<p>Your output will be a dictionary with keys as repeated letters and values as counts.</p>
<p>The use of <code>itertools.islice</code> is to avoid building a new list for the second argument of <code>zip</code>.</p>
<pre><code>from collections import defaultdict
from itertools import islice

x = 'AAAAATTT'

d = defaultdict(int)

for i, j in zip(x, islice(x, 1, None)):
    if i == j:
        d[i+j] += 1
</code></pre>
<p>Result:</p>
<pre><code>print(d)

defaultdict(&lt;class 'int'&gt;, {'AA': 4, 'TT': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <code>Counter</code>:</p>
<pre><code>from collections import Counter

s = 'AAAAATTT'
print([(k*2, v - 1) for k, v in Counter(list(s)).items() if v &gt; 1])

#output: [('AA', 4), ('TT', 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> with <em>dictionary comprehension</em> and <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> as:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; s = 'AAAAATTT'

&gt;&gt;&gt; {k: v for k, v in Counter(zip(s, s[1:])).items() if k[0]==k[1]}
{('A', 'A'): 4, ('T', 'T'): 2}
</code></pre>
<p>Here's another alternative to achieve this using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>, but this one is not as clean as the above solution <em>(also will be slow in terms of performance)</em>. </p>
<pre><code>&gt;&gt;&gt; from itertools import groupby

&gt;&gt;&gt; {x[0]:len(x) for i,j in groupby(zip(s, s[1:]), lambda y: y[0]==y[1]) for x in (tuple(j),) if i}
{('A', 'A'): 4, ('T', 'T'): 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way may be as following using <code>Counter</code>:</p>
<pre><code>from collections import Counter
string = 'AAAAATTT'
result = dict(Counter(s1+s2 for s1, s2 in zip(string, string[1:]) if s1==s2))
print(result)
</code></pre>
<p>Result:</p>
<pre><code>{'AA': 4, 'TT': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try it with just <code>range</code> method without importing anything :</p>
<pre><code>data='AAAAATTT'
count_dict={}
for i in range(0,len(data),1):
    data_x=data[i:i+2]
    if len(data_x)&gt;1:
        if data_x[0] == data_x[1]:

            if data_x not in count_dict:
                count_dict[data_x] = 1
            else:
                count_dict[data_x] += 1



print(count_dict)
</code></pre>
<p>output:</p>
<pre><code>{'TT': 2, 'AA': 4}
</code></pre>
</div>
<span class="comment-copy">well, if you want, why not do it?</span>
<span class="comment-copy">This produces the same result for the given example. But this will give <code>[('AA', 4), ('TT', 2)]</code>  for <code>'ATATATAA'</code> when the result should be <code>[('AA', 1)]</code>.</span>
<span class="comment-copy">Ahh, I missed that requirement. Apologies.</span>
