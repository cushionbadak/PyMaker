<div class="post-text" itemprop="text">
<p>I know there are a few questions and answers related to hanging threads in Python, but my situation is slightly different as the script is hanging AFTER all the threads have been completed. The threading script is below, but obviously the first 2 functions are simplified massively. </p>
<p>When I run the script shown, it works. When I use my real functions, the script hangs AFTER THE LAST LINE. So, all the scenarios are processed (and a message printed to confirm), <code>logStudyData()</code> then collates all the results and writes to a csv. <code>"Script Complete"</code> is printed. And THEN it hangs.</p>
<p>The script with threading functionality removed runs fine.</p>
<p>I have tried enclosing the main script in <code>try...except</code> but no exception gets logged. If I use a debugger with a breakpoint on the final <code>print</code> and then step it forward, it hangs.</p>
<p>I know there is not much to go on here, but short of including the whole 1500-line script, I don't know hat else to do. Any suggestions welcome! </p>
<pre><code>def runScenario(scenario):
    # Do a bunch of stuff
    with lock:
        # access global variables
        pass
    pass

def logStudyData():
    # Combine results from all scenarios into a df and write to csv
    pass

def worker():
    global q
    while True:
        next_scenario = q.get() 
        if next_scenario is None:
            break
        runScenario(next_scenario)
        print(next_scenario , " is complete")
        q.task_done() 

import threading
from queue import Queue 
global q, lock
q = Queue()  
threads = []

scenario_list = ['s1','s2','s3','s4','s5','s6','s7','s8','s9','s10','s11','s12']
num_worker_threads = 6  
    lock = threading.Lock()
    for i in range(num_worker_threads):
        print("Thread number ",i)
        this_thread = threading.Thread(target=worker)
        this_thread.start()
        threads.append(this_thread)
    for scenario_name in scenario_list:
        q.put(scenario_name)  
    q.join()
    print("q.join completed")
    logStudyData() 
    print("script complete")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As the docs for <a href="https://docs.python.org/3/library/queue.html#queue.Queue.get" rel="nofollow noreferrer"><code>Queue.get</code></a> say:</p>
<blockquote>
<p>Remove and return an item from the queue. If optional args <code>block</code> is true and <code>timeout</code> is <code>None</code> (the default), block if necessary until an item is available. If <code>timeout</code> is a positive number, it blocks at most timeout seconds and raises the <code>Empty</code> exception if no item was available within that time. Otherwise (<code>block</code> is false), return an item if one is immediately available, else raise the <code>Empty</code> exception (timeout is ignored in that case).</p>
</blockquote>
<p>In other words, there is no way <code>get</code> can ever return <code>None</code>, except by you calling <code>q.put(None)</code> on the main thread, which you don't do.</p>
<p>Notice that the example directly below those docs does this:</p>
<pre><code>for i in range(num_worker_threads):
    q.put(None)
for t in threads:
    t.join()
</code></pre>
<p>The second one is technically necessary, but you usually get away with not doing it.</p>
<p>But the first one is absolutely necessary. You need to either do this, or come up with some other mechanism to tell your workers to quit. Without that, your main thread just tries to exit, which means it tries to join every worker, but those workers are all blocked forever on a <code>get</code> that will never happen, so your program hangs forever.</p>
<hr/>
<p>Building a thread pool may not be rocket science (if only because rocket scientists tend to need their calculations to be deterministic and hard real-time…), but it's not trivial, either, and there are plenty of things you can get wrong. You may want to consider using one of the two already-built threadpools in the Python standard library, <a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor" rel="nofollow noreferrer"><code>concurrent.futures.ThreadPoolExecutor</code></a> or <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.dummy" rel="nofollow noreferrer"><code>multiprocessing.dummy.Pool</code></a>. This would reduce your entire program to:</p>
<pre><code>import concurrent.futures

def work(scenario):
    runScenario(scenario)
    print(scenario , " is complete")

scenario_list = ['s1','s2','s3','s4','s5','s6','s7','s8','s9','s10','s11','s12']
with concurrent.futures.ThreadPoolExecutor(max_workers=6) as x:
    results = list(x.map(work, scenario_list))
print("q.join completed")
logStudyData() 
print("script complete")
</code></pre>
<p>Obviously you'll still need a lock around any mutable variables you change inside <code>runScenario</code>—although if you're only using a mutable variable there because you couldn't figure out how to return values to the main thread, that's trivial with an <code>Executor</code>: just <code>return</code> the values from <code>work</code>, and then you can use them like this:</p>
<pre><code>for result in x.map(work, scenario_list):
    do_something(result)
</code></pre>
</div>
<span class="comment-copy">Thanks @abarnert This is great, and it no longer hangs. BUT it raises an exception <code>AttributeError: 'NoneType' object has no attribute '_condition'</code> on <code>concurrent.futures.wait(futs)</code></span>
<span class="comment-copy">@doctorer Sorry; I should have paid more attention while I was writing that; I've edited it. <code>map</code> returns an iterator over the results, and already does the <code>wait</code> and <code>get</code> on the underlying futures. If you don't have any return values, you can in fact just ignore the results to implicitly wait on them at the end of the <code>with</code> statement, or pass them to a <code>collections.deque(maxlen=0)</code> to explicit discard them. If you want the results, you can iterate over them or put them in a list to iterate later (as I showed in the updated answer). But really, read the docs; they have some nice examples.</span>
<span class="comment-copy">Thanks @abernert - that's working now (without passing results - using a single instance of <code>lock</code> for now ) and I'll have a proper read of the docs and incorporate the results.</span>
