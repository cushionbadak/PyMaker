<div class="post-text" itemprop="text">
<p>I wrote an extension in C which uses threads. In order to try to stay cross-platfrom, I used Apache Portable Runtime wrappers around platform-specific functions related to parallelism.  However, the installation of such package for Windows users will be really painful.  Another concern that I have is that I don't really need the entire APR library, only the part which deals with threads.</p>
<p>Before I started working on this project, I considered different libraries for this task, and when looking into Python's implementation of threads, all the exported API I could find was dealing with GIL. In principle, I could create thread objects, and have them run C functions to do the work, however, I'm wondering if it makes sense?  Do Python threads map to underlying OS threads (like, in case of Linux, <code>pthreads</code> library), or are they basically a prototype for <code>asyncio</code>, where they don't do any work in parallel (and maybe only wait in parallel)?  The only exported API I found is the set of functions related to <code>PyThreadState</code>.  I can see Python wrappers for <code>pthreads</code> and NT threads in the source code, but they don't seem to be available for extensions.  Or am I missing something?</p>
</div>
<div class="post-text" itemprop="text">
<p>It could make sense to wrap your C code with Python threads as long as your long running tasks in C don't access python objects and so they can release the GIL:</p>
<blockquote>
<p>Calling system I/O functions is the most common use case for releasing
  the GIL, but it can also be useful before calling long-running
  computations which don’t need access to Python objects</p>
</blockquote>
<p><a href="https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock" rel="nofollow noreferrer">https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock</a></p>
</div>
<span class="comment-copy">See <a href="https://www.quora.com/Does-the-Python-threading-module-create-user-level-threads-or-kernel-level-threads" rel="nofollow noreferrer">this Quora question</a> about python threads being user level threads.</span>
<span class="comment-copy">Well, this could still "make sense" if Python threads aren't system level threads, because they can only wait in parallel. But this quote is too vague to derive any conclusions from it.</span>
<span class="comment-copy">it doesn't matter; it's obvious that if you release the GIL your threads will run C-side code in parallel. The "vague" quote specifies the condition you need to comply with C-side. Read the link.</span>
<span class="comment-copy">But this was not the question... I'm asking if PyThread_XXX methods will create system level threads or "fake" user-level threads, which they later may or may not map to system level threads. As stated in my earlier question, I can use real system-level threads by mean of another library (APR), I was just wondering if <code>PyThread_XXX</code> methods provide a conceptually similar wrapper around OS-level primitives, or do they do something like <code>libfibre</code> / <code>libwire</code> / <code>libevent</code> etc.</span>
<span class="comment-copy">in short, yes: <a href="https://github.com/python/cpython/blob/4ae06c5337e01bdde28bce57b6b9166ad50947e3/Python/thread.c" rel="nofollow noreferrer">github.com/python/cpython/blob/…</a> and <a href="https://github.com/python/cpython/blob/aa0735f597b072c0eb00404c4d7df359ddc26755/Modules/_threadmodule.c" rel="nofollow noreferrer">github.com/python/cpython/blob/…</a></span>
<span class="comment-copy">But these functions aren't available to extensions: they are neither documented, nor even named conventionally, nor are they exported in <code>Python.h</code> (which is the only header extension writers are supposed to include). I saw the files you linked and after seeing them, I asked this question. Also, I don't know if the files linked here describe the code used by threads created through Python, or are they used for some internal interpreter needs.</span>
