<div class="post-text" itemprop="text">
<p>My text file is like below.</p>
<pre><code>[0, "we break dance not hearts by Short Stack is my ringtone.... i LOVE that !!!.....\n"]
[1, "I want to write a . I think I will.\n"]
[2, "@va_stress broke my twitter..\n"]
[3, "\" &amp;quot;Y must people insist on talking about stupid politics on the comments of a bubblegum pop . Sorry\n"]
[4, "aww great  &amp;quot;Picture to burn&amp;quot;\n"]
[5, "@jessdelight I just played ur joint two s ago. Everyone in studio was feeling it!\n"]
[6, "http://img207.imageshack.us/my.php?image=wpcl10670s.jpg her s are so perfect.\n"]
[7, "cannot hear the new  due to geographic location. i am geographically undesirable. and tune-less\n"]
[8, "\" couples in public\n"]
[9, "damn wendy's commerical got that damn  in my head.\n"]
[10, "i swear to cheese &amp;amp; crackers @zyuuup is in Detroit like every 2 months &amp;amp; i NEVER get to see him!  i swear this blows monkeyballs!\n"]
[11, "\" getting ready for school. after i print out this\n"]
</code></pre>
<p>I want to read every second element from the list mean all the text tweets into array.</p>
<p>I wrote </p>
<pre><code>tweets = []
for line in open('tweets.txt').readlines():
    print line[1]
    tweets.append(line)
</code></pre>
<p>but when I see the output, It just takes 2nd character of every line. </p>
</div>
<div class="post-text" itemprop="text">
<p>When you read a text file in Python, the lines are just strings. They aren't automatically converted so some other data structure.</p>
<p>In your case, it looks like each line in your file contains a JSON list. In that case, you can parse the line first using <code>json.loads()</code>. This converts the string to a Python <code>list</code> which you can then take the second element of:</p>
<pre><code>import json
with open('tweets.txt') as fp:
    tweets = [json.loads(line)[1] for line in fp]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rather than guessing what format the data is in, you should <em>find out</em>.</p>
<ul>
<li>If you're generating it yourself, and don't know how to parse back in what you're creating, change your code to generate something that can be easily parsed with the same library used to generate it, like JsonLines or CSV.</li>
<li>If you're ingesting it from some API, read the documentation for that API and parse it the way it's documented.</li>
<li>If someone handed you the file and told you to parse it, ask that someone what format it's in.</li>
</ul>
<hr/>
<p>Occasionally, you <em>do</em> have to deal with some crufty old file in some format that was never documented and nobody remembers what it was. In that case, you do have to reverse engineer it. But what you want to do then is guess at likely possibilities, and try to parse it with as much validation and error handling as possible, to verify that you guessed right.</p>
<p>In this case, the format looks a lot like either <a href="http://jsonlines.org/" rel="nofollow noreferrer">JSON lines</a> or <a href="http://ndjson.org/" rel="nofollow noreferrer">ndjson</a>. Both are slightly different ways of encoding multiple objects with one JSON text per line, with specific restrictions on those texts and the way they're encoded and the whitespace between them.</p>
<p>So, while a quick&amp;dirty parser like this will probably work:</p>
<pre><code>with open('tweets.txt') as f:
    for line in f:
        tweet = json.loads(line)
        dosomething(tweet)
</code></pre>
<p>You probably want to use a library like <a href="https://pypi.python.org/pypi/jsonlines" rel="nofollow noreferrer"><code>jsonlines</code></a>:</p>
<pre><code>with jsonlines.open('tweets.txt') as f:
    for tweet in f:
        dosomething(tweet)
</code></pre>
<p>The fact that the quick&amp;dirty parser works on JSON lines is, of course, part of the point of that format—but if you don't actually know whether you have JSON lines or not, you're better off making sure.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since your input looks like Python expressions, I'd use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a> to parse them.</p>
<p>Here is an example:</p>
<pre><code>import ast

with open('tweets.txt') as fp:
    tweets = [ast.literal_eval(line)[1] for line in fp]

print(tweets)
</code></pre>
<p>Output:</p>
<pre><code>['we break dance not hearts by Short Stack is my ringtone.... i LOVE that !!!.....\n', 'I want to write a . I think I will.\n', '@va_stress broke my twitter..\n', '" &amp;quot;Y must people insist on talking about stupid politics on the comments of a bubblegum pop . Sorry\n', 'aww great  &amp;quot;Picture to burn&amp;quot;\n', '@jessdelight I just played ur joint two s ago. Everyone in studio was feeling it!\n', 'http://img207.imageshack.us/my.php?image=wpcl10670s.jpg her s are so perfect.\n', 'cannot hear the new  due to geographic location. i am geographically undesirable. and tune-less\n', '" couples in public\n', "damn wendy's commerical got that damn  in my head.\n", 'i swear to cheese &amp;amp; crackers @zyuuup is in Detroit like every 2 months &amp;amp; i NEVER get to see him!  i swear this blows monkeyballs!\n', '" getting ready for school. after i print out this\n']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>May be you should consider to use json.loads method :</p>
<pre><code>import json

tweets = []
for line in open('tweets.txt').readlines():
    print json.loads(line)[1]
    tweets.append(line)
</code></pre>
<p>There is more pythonic way in @Erik Cederstrand 's comment.</p>
</div>
<span class="comment-copy">that's because it's evaluating it as a string not a list</span>
<span class="comment-copy">So What should I do to get to serve it as a list? I want a second tweet text element from a text file</span>
<span class="comment-copy">You probably want <code>ast.literal_eval</code> on the line first (but I would remove the newline characters, as they can confuse the parser).</span>
<span class="comment-copy">Why do you have this format? If it's something you're creating, a much smarter solution is to change your code that generates the file into something that uses a format you know how to parse back in. If it's something you're getting from elsewhere, you should look at how it's documented—for example, this could be JsonLines, in which case what you want to do is use a JsonLines parser, but it could just be accidentally very close to JsonLines, in which case you don't.</span>
<span class="comment-copy">It works fine. Can you please my answer at <a href="https://stackoverflow.com/questions/49778665/how-can-i-get-the-nth-element-of-string-for-list-of-list-in-python/49779833#49779833" title="how can i get the nth element of string for list of list in python">stackoverflow.com/questions/49778665/…</a> ?</span>
<span class="comment-copy">Or Can you tell me How can I read the tweets.txt file so that tweets contains the line as array and not as string?</span>
<span class="comment-copy">Uhm, that's what my example code does? Just remove the <code>[1]</code> if you want all elements instead of just the second one.</span>
<span class="comment-copy">My question is what if I want tweets[] as a full line from the text file and want to access the second element for the tweets[]?</span>
<span class="comment-copy">It will be good if you can look at my question at <a href="https://stackoverflow.com/questions/49778665/how-can-i-get-the-nth-element-of-string-for-list-of-list-in-python/49779833#49779833" title="how can i get the nth element of string for list of list in python">stackoverflow.com/questions/49778665/…</a></span>
<span class="comment-copy">Will not work because of the newline characters</span>
<span class="comment-copy">I disagree. It works fine for me.</span>
<span class="comment-copy">Working . Thanks.</span>
<span class="comment-copy"><code>ast.literal_eval('[7, "cannot hear the new  due to geographic location. i am geographically undesirable. and tune-less\n"]')</code> -&gt; <code>SyntaxError: EOL while scanning string literal</code></span>
<span class="comment-copy">@mdurant Presumably the file contains literal <code>` and </code>n<code>, not the single </code>\n` character you're using.</span>
<span class="comment-copy">It's working perfectly fine. But, Can you tell me why it gives me this error?  Traceback (most recent call last):   File "k_means.py", line 28, in &lt;module&gt;     print json.loads(line)[1]   File "C:\Python27\lib\encodings\cp437.py", line 12, in encode     return codecs.charmap_encode(input,errors,encoding_map) UnicodeEncodeError: 'charmap' codec can't encode character u'\u2122' in position 78: character maps to &lt;undefined&gt;</span>
