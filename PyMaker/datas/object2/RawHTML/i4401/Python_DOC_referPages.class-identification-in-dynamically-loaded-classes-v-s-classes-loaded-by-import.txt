<div class="post-text" itemprop="text">
<p>Here's the minimal reproduction for something I'm working on. This is using Python 3.6.5:</p>
<p>sample.py:</p>
<pre><code>import importlib.util
import inspect

from test import Test

t = Test()

spec = importlib.util.spec_from_file_location('test', './test.py')
module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(module)

loaded_test = None
for name, obj in inspect.getmembers(module):
    if inspect.isclass(obj):
        loaded_test = obj

print(type(t))
print(loaded_test)
print(isinstance(t, loaded_test))
print(issubclass(t.__class__, loaded_test))
</code></pre>
<p>test.py (in the same directory):</p>
<pre><code>class Test(object):
    pass
</code></pre>
<p>Running this code will give you the following output:</p>
<pre><code>&lt;class 'test.Test'&gt;
&lt;class 'test.Test'&gt;
False
False
</code></pre>
<p>So why is the object that we load using importlib, which is identified as 'test.Test', not an instance or subclass of the 'test.Test' class I created using import? Is there a way to programmatically check if they're the same class, or is it impossible because the context of their instantiation is different?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why is the object that we load using <code>importlib</code>, which is identified as <code>test.Test</code>, not an instance or subclass of the <code>test.Test</code> class I created using import? </p>
</blockquote>
<p>A class is "just" an instance of a metaclass. The import system generally prevents class objects from being instantiated more than once: classes are usually defined at a module scope, and if a module has already been imported the existing module is just reused for subsequent import statements.  So, different references to the same class all end up pointing to an identical class object living at the same memory location.</p>
<p><strong>By using <code>exec_module</code> you prevented this "cache hit" in sys.modules</strong>, forcing the class declaration to be executed again, and a new class object to be created in memory.</p>
<p><code>issubclass</code> is not doing anything clever like a deep inspection of the class source code, it's more or less just looking for identity (CPython's implementation <a href="https://github.com/python/cpython/blob/f320be77ffb73e3b9e7fc98c37b8df3975d84b40/Objects/abstract.c#L2444" rel="nofollow noreferrer">here</a>, with a fast-track for exact match and some complications for supporting <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">ABCs</a>) </p>
<blockquote>
<p>Is there a way to programmatically check if they're the same class, or is it impossible because the context of their instantiation is different?</p>
</blockquote>
<p>They are not the same class.  Although the source code is identical, they exist in different memory locations.  You don't need the complications of <code>exec_module</code> to see this, by the way, there are simpler ways to force recreation of the "same" class:</p>
<pre><code>&gt;&gt;&gt; import test
&gt;&gt;&gt; t = test.Test()
&gt;&gt;&gt; isinstance(t, test.Test)
True
&gt;&gt;&gt; del sys.modules['test']
&gt;&gt;&gt; import test
&gt;&gt;&gt; isinstance(t, test.Test)
False
</code></pre>
<p>Or, define the class in a function block and return it from the function call.  Or, create classes from the same source code by using the three-argument version of <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer"><code>type(name, bases, dict)</code></a>.  The <code>isinstance</code> check (CPython implementation <a href="https://github.com/python/cpython/blob/f320be77ffb73e3b9e7fc98c37b8df3975d84b40/Objects/abstract.c#L2369" rel="nofollow noreferrer">here</a>) is simple and will not detect these misdirections.</p>
</div>
<span class="comment-copy">Related (maybe duplicate):  <a href="https://stackoverflow.com/q/33924950/674039">Are classobjects singletons?</a></span>
<span class="comment-copy">A clue: <code>import test</code> / <code>print(module, test, module == test)</code>. Apparently the classes are different because they live in different modules.</span>
<span class="comment-copy">Because despite the fact that Python goes to great lengths to ensure that casually used classes and modules are effectively singletons, it still allows you the freedom to do almost anything you want.</span>
