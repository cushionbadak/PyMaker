<div class="post-text" itemprop="text">
<p>Related to <a href="https://stackoverflow.com/q/34097845/2988730">Determine the endianness of a numpy array</a></p>
<p>Given an array</p>
<pre><code>x = np.arange(3)
</code></pre>
<p>I can get the byte order by doing</p>
<pre><code>&gt;&gt;&gt; x.dtype.byteorder
'='
</code></pre>
<p>How do I find out if this is big or little endian? I would like to get <code>'&lt;'</code>, <code>'&gt;'</code> or <code>'|'</code> as the output, not <code>'='</code>.</p>
<p>To be clear, I am not hung up on what format the information comes in. I just want to know "big endian", "little endian" or "irrelevant", but I don't care if it's "native" or not.</p>
</div>
<div class="post-text" itemprop="text">
<p>Probably just check <a href="https://docs.python.org/3/library/sys.html#sys.byteorder" rel="nofollow noreferrer"><code>sys.byteorder</code></a>. Even the <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.byteorder.html#numpy.dtype.byteorder" rel="nofollow noreferrer"><code>numpy.dtype.byteorder</code> examples</a> in the docs use <code>sys.byteorder</code> to determine what's native.</p>
<pre><code>endianness_map = {
    '&gt;': 'big',
    '&lt;': 'little',
    '=': sys.byteorder,
    '|': 'not applicable',
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can swap the endianness twice to make numpy reveal the true endianness:</p>
<pre><code>dtype_nonnative = dtype.newbyteorder('S').newbyteorder('S')
dtype_nonnative.byteorder
</code></pre>
</div>
<span class="comment-copy">I might be missing your question here, but just check the native byteorder with <code>sys.byteorder</code>?</span>
<span class="comment-copy">Maybe this? <a href="https://stackoverflow.com/a/1346039/4909087">stackoverflow.com/a/1346039/4909087</a></span>
<span class="comment-copy">@miradulo. I think you are understanding perfectly. I am very surprised that there is no way to get that from numpy directly, given that numpy has to access that information at some point, presumably.</span>
<span class="comment-copy">In that case, I don't have much choice unfortunately.</span>
<span class="comment-copy">I was thinking of something more like <code>nativecode = '&gt;' if sys.byteorder == 'big' else '&lt;'; x.dtype.byteorder.replace('=', nativecode)</code></span>
<span class="comment-copy">I think I understand why that happens under the hood, but seriously, whyyyyyyyyy?</span>
<span class="comment-copy">How about a PR to add a property to <code>dtype</code> to always get <code>&lt;</code>, <code>&gt;</code> or <code>|</code>?</span>
<span class="comment-copy">That's a surprise, considering that even explicitly constructing <code>dtype('&lt;i4')</code> will produce a <code>byteorder</code> of <code>'='</code> if native is little-endian. I would consider this a bug.</span>
<span class="comment-copy">@user2357112 A bug in which direction? Explicitly constructed dtypes should product explicit byteorders, or <code>newbyteorder</code> should toggle between <code>=</code> and one of <code>{&lt;, &gt;}</code>?</span>
<span class="comment-copy">@miradulo: I'd expect <code>newbyteorder</code> to produce <code>'='</code> when the resulting byte order is the same as the native byte order. (The fact that explicit <code>dtype('&lt;i4')</code> produces <code>'='</code> when native is little-endian is documented, while the <code>newbyteorder</code> behavior isn't.)</span>
