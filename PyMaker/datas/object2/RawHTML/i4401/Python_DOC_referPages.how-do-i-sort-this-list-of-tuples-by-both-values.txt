<div class="post-text" itemprop="text">
<p>I have a list of tuples: <code>[(2, Operation.SUBSTITUTED), (1, Operation.DELETED), (2, Operation.INSERTED)]</code></p>
<p>I would like to sort this list in 2 ways:</p>
<p>First by its 1st value by ascending value, i.e. <code>1, 2, 3... etc</code>
Second by its 2nd value by reverse alphabetical order, i.e. <code>Operation.SUBSTITITUTED, Operation.INSERTED, Operation, DELETED</code></p>
<p>So the above list should be sorted as:</p>
<p><code>[(1, Operation.DELETED), (2, Operation.SUBSTITUTED), (2, Operation.INSERTED)]</code></p>
<p>How do I go about sort this list?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since sorting is <a href="https://docs.python.org/3/howto/sorting.html#sort-stability-and-complex-sorts" rel="nofollow noreferrer">guaranteed to be stable</a>, you can do this in 2 steps:</p>
<pre><code>lst = [(2, 'Operation.SUBSTITUTED'), (1, 'Operation.DELETED'), (2, 'Operation.INSERTED')]

res_int = sorted(lst, key=lambda x: x[1], reverse=True)
res = sorted(res_int, key=lambda x: x[0])

print(res)

# [(1, 'Operation.DELETED'), (2, 'Operation.SUBSTITUTED'), (2, 'Operation.INSERTED')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this particular case, <em>because the order of comparison can be easily inverted for integers</em>, you can sort in one time using negative value for integer key &amp; reverse:</p>
<pre><code>lst = [(2, 'Operation.SUBSTITUTED'), (1, 'Operation.DELETED'), (2, 'Operation.INSERTED')]
res = sorted(lst, key=lambda x: (-x[0],x[1]), reverse=True)
</code></pre>
<p>result:</p>
<pre><code>[(1, 'Operation.DELETED'), (2, 'Operation.SUBSTITUTED'), (2, 'Operation.INSERTED')]
</code></pre>
<p>negating the integer key cancels the "reverse" aspect, only kept for the second string criterion.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use this:</p>
<pre><code>from operator import itemgetter
d = [(1, 'DELETED'), (2, 'INSERTED'), (2, 'SUBSTITUTED')]
d.sort(key=itemgetter(1),reverse=True)
d.sort(key=itemgetter(0))
print(d)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way using <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>itemgetter</code></a> from <a href="https://docs.python.org/3/library/operator.html#module-operator" rel="nofollow noreferrer"><code>operator</code></a> module:</p>
<pre><code>from operator import itemgetter

lst = [(2, 'Operation.SUBSTITUTED'), (1, 'Operation.DELETED'), (2, 'Operation.INSERTED')]

inter = sorted(lst, key=itemgetter(1), reverse=True)
sorted_lst = sorted(inter, key=itemgetter(0))

print(sorted_lst)

# [(1, 'Operation.DELETED'), (2, 'Operation.SUBSTITUTED'), (2, 'Operation.INSERTED')]                                
</code></pre>
</div>
<span class="comment-copy">can be done in 1 pass, see my answer :)</span>
<span class="comment-copy">Nice, I think it should be accepted.</span>
<span class="comment-copy">that's some fair play here :) TBH I think I saw this trick somewhere here some time ago (but where?)</span>
<span class="comment-copy">you should edit your answer to emphasis the fact that it works with any type. Mine doesn't.</span>
<span class="comment-copy">I get this error when trying your solution: <code>TypeError: '&lt;' not supported between instances of 'Operation' and 'Operation'</code></span>
<span class="comment-copy">This should be the accepted answer. But note, by construction, this is specific to ordering in the 2-item case. If you have ascending / descending / ascending across 3-items, this may not work.</span>
<span class="comment-copy">yes, your solution is more generic. Also, if the tuples were <i>strings</i>, that would not work either (because there's no easy way to invert string comparison, maybe prefix by <code>z</code> :))</span>
<span class="comment-copy">I tried this, but I get this error: <code>TypeError: '&lt;' not supported between instances of 'Operation' and 'Operation'</code></span>
<span class="comment-copy">we wrongly thought that your input data second field was a <i>string</i> when it was an object.</span>
