<div class="post-text" itemprop="text">
<p>After learning about lists and box-and-pointer diagrams, I decided to create random stuff for myself and test out my knowledge. I am going to use the words shallow copy and suspected shallow copies as I'm not really sure whether they are correct by definition. My queries are in the reasons provide for the behaviour of such code, please tell me whether I'm thinking soundly.</p>
<p>Code A</p>
<pre><code>from copy import *

x=[1,[2,[3,[4]]]] #normal copy/hardcopy
a=x
v=list(x) #suspected shallow copy
y=x.copy() #shallow copy
z=deepcopy(x) #theoretical deep copy
w=x[:] #suspected shallow copy

def test():
    print("Original:",x)
    print("hardcopy:",a)
    print("suspected shallow copy",v)
    print("shallow copy",y)
    print("deep copy:",z)
    print("suspected shallow copy",w)

x[1]=x[1]+[4]
test()
</code></pre>
<p>Output A:</p>
<pre><code>Original: [1, [2, [3, [4]], 4]]
hardcopy: [1, [2, [3, [4]], 4]]
suspected shallow copy [1, [2, [3, [4]]]]
shallow copy [1, [2, [3, [4]]]]
deep copy: [1, [2, [3, [4]]]]
suspected shallow copy [1, [2, [3, [4]]]]
</code></pre>
<p>Code B</p>
<pre><code>a=(1,2,[1,2,3])

def shallow_copy(x):
    tup=()
    for i in x:
        tup+=(i,)
    return tup


def hardcopy(x):
    return x

b=hardcopy(a)
c=shallow_copy(a)

a[2]+=[3] 
</code></pre>
<p>Output B:
I see TypeError in IDLE here, but the mutation of the list element is still done, and across ALL a,b,c</p>
<p>Continuation from output B:</p>
<pre><code>a[2][0]=a[2][0]+99
a,b,c
</code></pre>
<p>Output C:</p>
<pre><code>((1, 2, [100, 2, 3, 3]), (1, 2, [100, 2, 3, 3]), (1, 2, [100, 2, 3, 3]))
</code></pre>
<p>Code D:</p>
<pre><code>a=[1,2,(1,2,3)]

def shallow_copy(x):
    tup=[]
    for i in x:
        tup+=[i]
    return tup


def hardcopy(x):
    return x

b=hardcopy(a)
c=shallow_copy(a)
d=a.copy()
a[2]=a[2]+(4,)
a,b,c,d
</code></pre>
<p>Output D:</p>
<pre><code>[1, 2, (1, 2, 3, 4)], [1, 2, (1, 2, 3, 4)], 
[1, 2, (1, 2, 3)], [1, 2, (1, 2, 3)]
</code></pre>
<blockquote>
<p>From Output A, we observe the following:
  1)For lists which have shallow copies, doing <code>x[1]=x[1]+[4]</code> does not affect the shallow copies. My reasons for the above could be </p>
<p>a) <code>=</code> followed by <code>+</code> does <code>__add__</code> instead of <code>__iadd__</code>(which is <code>+=</code>), and doing <code>__add__</code> should not modify the object, only changing the value for one pointer(x and its hardcopy in this case)</p>
</blockquote>
<p>This is further supported in Output B but somehow contradicted in Output C, could be partly due to reason (b) below, but can't be too sure.</p>
<blockquote>
<p>b) We executed this in the first layer(only 1 slice operator), maybe there's some kind of rule which prevents these elements from being modified.</p>
</blockquote>
<p>This is supported by both Output B and Output C, though Output B might be argued to be in the first layer, think of it as increasing the elements in the 2nd layer, and it fits the above observation.</p>
<blockquote>
<p>2)What is the reason why the TypeError appeared in Output B, but is still executed? I know that whether an Exception might be triggered is based on the final sequence you are actually changing(the list in this case), but why is there still <code>TypeError: 'tuple' object does not support item assignment</code> ?</p>
</blockquote>
<p>I have presented my views for the above questions. I appreciate any thoughts(theoretical solutions preferably) on this question as I'm still relatively new to programming.</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer question 1, which looks complex but whose answer is probably quite simple: </p>
<p>when you have a another name referencing the original object, you will see the changes in the original. Those changes will not reflect in other copies (being those either shallow or deep) if(!) you change the objects using the form <code>x[1] = x[1] + [4]</code>. This is because you are assigning a new object into <code>x[1]</code>, instead of making an in-place change like in <code>x[1].append(4)</code>.</p>
<p>You can check that with the <code>id()</code> function.</p>
<p>To answer your question 2, and adapted from the official docs:</p>
<p>let's make </p>
<pre><code>a = (['hello'],)
</code></pre>
<p>then</p>
<pre><code>a[0] += [' world']
</code></pre>
<p>this is the same as</p>
<pre><code>a[0] = operator.iadd(a[0],[' world'])
</code></pre>
<p>The <code>iadd</code> changes the list in place, but then the assignment fails because you can't assign to a tuple (immutable type) index.</p>
<p>If you make</p>
<pre><code>a[0] = a[0] + [' world']
</code></pre>
<p>the concatenation goes into a new list object, then the assignment to the tuple index fails too. But the new object gets lost. <code>a[0]</code> wasn't changed in place.</p>
<p>To clarify OP's comment, directly from the docs in <a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer">here</a> it says that</p>
<blockquote>
<p>Many operations have an “in-place” version. Listed below are functions providing a more primitive access to in-place operators than the usual syntax does; for example, the statement x += y is equivalent to x = operator.iadd(x, y). Another way to put it is to say that z = operator.iadd(x, y) is equivalent to the compound statement z = x; z += y.</p>
<p>In those examples, note that when an in-place method is called, the
  computation and assignment are performed in two separate steps. The
  in-place functions listed below only do the first step, calling the
  in-place method. The second step, assignment, is not handled.</p>
</blockquote>
<p>As for your Output D:
Writing</p>
<pre><code>b = hardcopy(a)
</code></pre>
<p>does nothing more than writing</p>
<pre><code>b = a
</code></pre>
<p>really, <code>b</code> is a new name referencing the same object that <code>a</code> references.
This is because <code>a</code> is mutable and so a reference pointing to the original object is passed into local function name <code>x</code>. Returning <code>x</code> just returns the same reference into <code>b</code>.</p>
<p>That's why you see further changes in <code>a</code> reflected in <code>b</code>. Again you make <code>a[2]</code> a new different object tuple by assignment, so now <code>a[2]</code> and <code>b[2]</code> reference a new tuple <code>(1,2,3,4)</code>, while <code>c</code> and <code>d</code> still reference the old tuple object. And now because they are tuples you can't change them in place, like lists.</p>
<p>As for the term "hardcopy", I wouldn't use it. It doesn't appear even once in official docs, and the mentions in Python SO questions beside this one, appear in other contexts. And it is ambiguous (contrary to "shallow" and "deep" which give a good clue for their meaning). I would think exactly the opposite (an object copy) for the term "hardcopy" you describe (an additional name/reference/pointer to the same object). Of course there are eventually many ways to say the same thing. We say "copy" because its shorter, and for immutables it doesn't matter if the copy happens or not (you can't change them anyway). For mutables saying "copy" usually means "shallow copy", because you have to "go further" in your code if you want a "deep copy".</p>
</div>
<span class="comment-copy">use <code>id(your obj)</code> to get a unique id -  print and compare them - its easy to determaine if things are the same that way.  <code>a = x</code> is just another "name" for the data b has, its no copy at all.</span>
<span class="comment-copy">@PatrickArtner I know of that method of checking in a practical exam. However, this kind of questions like to appear in my written examination, so I have to derive a way to understand them from a theoretical perspective.</span>
<span class="comment-copy">To clarify my understanding, do u mean that writing a[0] += [' world'], is not directly equivalent to doing iadd alone? I take it that official docs on &lt;iadd&gt; says &lt;Implement self+=value&gt; , the word Implement and not return gives a big hint that assignment was not automatically done, while typing += actually means doing iadd followed by an assignation?</span>
<span class="comment-copy">Yes, i am editing the answer</span>
<span class="comment-copy">see my edit @PrashinJeevaganth</span>
<span class="comment-copy">For your answer to Q1, when u said "you will see the changes in the original, while those changes will not reflect in other copies", do u mean the copies of [2,[3,[4]]]? Because shallow copy means that the outer list is different, but they still contain the items with the same references. If shallow copies were referring to those of [1,[2,[3,[4]]]], the explanation of "you didn't change the inner objects, but the surface level list." still doesn't seem v intuitive to me.</span>
<span class="comment-copy">Because that part of explanation is wrong. I am fixing it.</span>
