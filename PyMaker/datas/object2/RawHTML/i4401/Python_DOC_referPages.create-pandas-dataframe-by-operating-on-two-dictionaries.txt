<div class="post-text" itemprop="text">
<p>I'm trying to create a pandas dataframe with <code>row</code> from one dictionary and <code>column</code> from another, and the values for row[i]-column[j] defined by any operation done on the key-value pair of both dictionaries (i.e. value of <code>row[dict1[key]]-column[dict2[key]]</code> can be calculated from a function which accepts values: dict1[key] and dict2[key]).</p>
<p>So far my code looks like this:</p>
<pre><code># -*- coding: utf-8 -*-
import sys
import os
import pandas as pd
from optparse import OptionParser
from sklearn.preprocessing import MinMaxScaler
from joblib import Parallel, delayed
import pybedtools
from subprocess import call
from collections import defaultdict
import numpy as np
from skbio.sequence import DNA
from skbio.alignment import local_pairwise_align_ssw
class sequenceCompare:

class sequenceCompare:

    '''Common class for comparing multifasta files'''

    def __init__(
        self,
        fasta1,
        fasta2
        ):
        self.fasta1 = fasta1
        self.fasta2 = fasta2

    def computeScore(self):
        sequenceList1 = {}
        sequenceList2 = {}
        score_matrix = pd.DataFrame([])
        with open(self.fasta1) as file_one:
            sequenceList1 = {line.strip("&gt;\n"):next(file_one).rstrip() for line in file_one}        
        with open(self.fasta2) as file_two:
            sequenceList2 = {line.strip("&gt;\n"):next(file_two).rstrip() for line in file_two} 
        #Is there any way to make following step parallel 
        for key1, value1 in sequenceList1.items():
            for key2, value2 in sequenceList2.items():
                    alignment, score, start_end_positions = local_pairwise_align_ssw(DNA(value1), DNA(value2))
                    #Store value of score in dataframe column key1 and row key2
</code></pre>
<p>Eg. </p>
<pre><code>Sequence list 1: 
&gt;A1
AAACCTTGGG
&gt;A2
CCCAAAATTT
&gt;A3
CCTTAAGGG

Sequence list 2:
&gt;B1
GGTTAACC
&gt;B2
GATCATCCA
&gt;B3
CCAAAATTC
</code></pre>
<p>And the resulting dataframe after doing operations on the two dictionaries should look like this: </p>
<pre><code>Dataframe: 
       A1          A2          A3
B1 dist(A1,B1) dist(A2,B1) dist(A3,B1)
B2 dist(A1,B2) dist(A2,B2) dist(A3,B2)
B3 dist(A1,B3) dist(A2,B3) dist(A3,B3)
</code></pre>
<p>What would be the most efficient(and hopefully parallel) way to do this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Checking the documentation, it seems that it is more efficient to build a <a href="http://scikit-bio.org/docs/0.4.2/generated/skbio.alignment.StripedSmithWaterman.html" rel="nofollow noreferrer"><code>StripedSmithWaterman</code></a> object and use it multiple times instead of using <a href="http://scikit-bio.org/docs/0.4.2/generated/skbio.alignment.local_pairwise_align_ssw.html" rel="nofollow noreferrer"><code>local_pairwise_align_ssw</code></a> every time. However, it does not seem to provide parallelism on its own (which is strange, because <a href="http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0082138" rel="nofollow noreferrer">the library on which it is based</a> claims to implement <a href="https://en.wikipedia.org/wiki/SIMD" rel="nofollow noreferrer">SIMD parallelism</a>, so I may be wrong), but you can use regular <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">Python multiprocessing</a> to parallelize things:</p>
<pre><code># -*- coding: utf-8 -*-
import sys
import os
import pandas as pd
from optparse import OptionParser
from sklearn.preprocessing import MinMaxScaler
from joblib import Parallel, delayed
import pybedtools
from subprocess import call
from multiprocessing import Pool
from itertools import repeat
from collections import defaultdict
import numpy as np
from skbio.sequence import DNA
from skbio.alignment import StripedSmithWaterman


def compute_scores(dna1, dnas2):
    # StripedSmithWaterman docs:
    # http://scikit-bio.org/docs/0.4.2/generated/skbio.alignment.StripedSmithWaterman.html
    ssw1 = StripedSmithWaterman(dna1)
    # AlignmentStructure docs:
    # http://scikit-bio.org/docs/0.4.2/generated/skbio.alignment.AlignmentStructure.html
    return [ssw1(dna2).optimal_alignment_score for dna2 in dnas2]

class sequenceCompare:

    '''Common class for comparing multifasta files'''

    def __init__(
        self,
        fasta1,
        fasta2
        ):
        self.fasta1 = fasta1
        self.fasta2 = fasta2

    def computeScore(self):
        sequenceList1 = {}
        sequenceList2 = {}
        score_matrix = pd.DataFrame([])
        with open(self.fasta1) as file_one:
            sequenceList1 = {line.strip("&gt;\n"):next(file_one).rstrip() for line in file_one}
        with open(self.fasta2) as file_two:
            sequenceList2 = {line.strip("&gt;\n"):next(file_two).rstrip() for line in file_two}
        with Pool(os.cpu_count()) as p:
            values2 = list(sequenceList2.values())
            data = p.starmap(compute_scores, zip(sequenceList1.values(), repeat(values2)))
            df = pd.DataFrame(data, columns=list(sequenceList1.keys()), index=list(sequenceList2.keys()))
            # df contains the resulting data frame
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This piece of code will do the trick:</p>
<pre><code>dict1 = {'B2': 'GATCATCCA', 'B3': 'CCAAAATTC', 'B1': 'GGTTAACC'}
dict2 = {'A2': 'CCCAAAATTT', 'A3': 'CCTTAAGGG', 'A1': 'AAACCTTGGG'}
finaldict = {}
for key1, value1 in dict1.items():
    for key2, value2 in dict2.items():
        #--&gt; apply func taking (value2, value1) as input &lt;..#
        try:
            finaldict[key2].update({key1:func})
        except:
            finaldict[key2] = {key1:func}
pd.DataFrame(finaldict)
</code></pre>
</div>
<span class="comment-copy">Oh wait, I didn't notice you were already using <a href="https://pythonhosted.org/joblib/" rel="nofollow noreferrer">Joblib</a>, so I guess you could use that instead of the standard multithrading Pool if you prefer...</span>
<span class="comment-copy">You might need to change value1 with dna1 in function compute_score() in answer :).   I prefer to keep things simple, hence joblib! I always treated SIMD parallelism differently from embarrassing parallel loop constructs (like the one I'm aiming for now); but then again my concepts are bit rusty.</span>
<span class="comment-copy">@Siddharth Thanks, fixed now. I mentioned SIMD because the linked paper describing the SSW library that scikit-bio uses uses that term, but scikit-bio itself does not seem to expose an API that exploits that (or maybe the SIMD part of the library does not refer to computing distances between multiple pairs). For the code I posted (which does not make use of the SIMD possibilities of the library), yes, I would probably use "embarrassingly parallel" too</span>
