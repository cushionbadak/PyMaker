<div class="post-text" itemprop="text">
<p>In python 2.7 if program <code>master</code> uses subprocess.Popen to start <code>subprocess</code> and then exits, <code>subprocess</code> will continue to run. I think that this is consistent with process handling in general, at least for *nix. </p>
<p>This seems to imply that if some of my <code>subprocess</code> programs run forever and I kill <code>master</code> the subprocesses will continue to run. Is that correct? (I ask because of the possibility that killing a process behaves differently than simply having it exit of its own accord).</p>
<p>In StackOverflow entries about command shells (not Python) there is mention of being able to create a subprocess that actually will terminate if its creator process dies. They seem to be called "daemonic" processes. </p>
<p>Is there a similar way to make this happen automatically in Python? That is, is there a way I can use subprocess.Popen or another method to start a subprocess that will automatically die if the parent dies?</p>
<p>The child processes are very different so threading is not an option.</p>
</div>
<div class="post-text" itemprop="text">
<p>The term "daemon" is probably more confusing than helpful here. It means something you don't have to wait/join. For a thread, that actually means a thread that will be implicitly killed on exit—but for a child process, it means one that will run in the background and continue to do so even if its parent, its session, its tty, etc. all die. The <code>subprocess</code> docs don't even mention the term, possibly to avoid this confusion.</p>
<p>At any rate, if you want children that automatically go away with the parent no matter what on all platforms, you need to do that explicitly.</p>
<p>For a nice design where there's a top-level script that has access to all the <code>Popen</code> object, the easy way to do that is at the top level:</p>
<pre><code>if __name__ == '__main__':
    try:
        # do a bunch of stuff, including launching lots of children
    finally:
        for p in childprocs:
            p.kill()
        for p in childprocs:
            p.wait()
</code></pre>
<p>You can of course get fancier by waiting with a timeout and then terminating, or just terminate them without trying to kill first, or send different signals, or… whatever you want. But this is the basic idea.</p>
<p>In some cases, it's even nicer to use a <code>with</code> statement with an <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow noreferrer"><code>ExitStack</code></a> that you add the children to as they're created.</p>
<p>On the other hand, in some complex scripts, there's really no good way to access the children from the top level, and you have to use something cruftier like <a href="https://docs.python.org/3/library/atexit.html" rel="nofollow noreferrer"><code>atexit</code></a> handlers.</p>
<hr/>
<p>But there's another simple design that often works. If you're not running too many children, you can spawn a thread just to <code>wait</code> on each one, or even to just <code>run</code> them instead of creating a <code>Popen</code>. If you are running lots of children, a single thread can loop through them waiting with a timeout, although this can be a lot more fiddly to get right (and waste resources if you don't). Then it's just a matter of managing your threads, and they automatically manage your children.</p>
</div>
<span class="comment-copy">If you want to refer to other StackOverflow questions, please put links to them.</span>
