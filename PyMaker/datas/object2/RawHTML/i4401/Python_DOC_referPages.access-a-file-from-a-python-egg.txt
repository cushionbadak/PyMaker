<div class="post-text" itemprop="text">
<p>Hi I am working with python packaging. I have 3 <code>non-code</code> files namely <code>['synonyms.csv', 'acronyms.csv', 'words.txt']</code>. </p>
<ul>
<li>These files exist in a folder structure <code>Wordproject/WordProject/Repository/DataBank/</code> </li>
<li>I have a <code>RepositoryReader</code> class at the path <code>Wordproject/WordProject/Repository/</code> </li>
<li>I've written a code that pulls the current location of the <code>RepositoryReader</code> and then looks for a <code>subdirectory</code> called <code>DataBank</code> and looks for the 3 files there.</li>
</ul>
<p>The problem is when I create an <code>egg</code> out of the code, and then run it, </p>
<p>My code gives me the error: </p>
<blockquote>
<p>Could not find the file at X:\1. Projects\Python\Wordproject\venv\lib\site-packages\Wordproject-1.0-py3.6.egg\Wordproject\Repository\DataBank\synonyms.csv</p>
</blockquote>
<p>It's not able to fetch the file or read it from the path if the path is of an egg. Is there any way around it? These files have to be in an <code>egg</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two different things you could be trying to do here:</p>
<ul>
<li>Treat the data files as part of your package, like the Python modules, and access them at runtime as if your package were a normal directory tree even if it isn't.</li>
<li>Get the data files installed somewhere else at <code>pip install</code> time, to a location you can access normally.</li>
</ul>
<p>Both are explained in <a href="http://setuptools.readthedocs.io/en/latest/setuptools.html#including-data-files" rel="nofollow noreferrer">the section on data files</a> in the PyPA/<code>setuptools</code> docs. I think you want the first one here, which is covered in the subsection on <a href="http://setuptools.readthedocs.io/en/latest/setuptools.html#accessing-data-files-at-runtime" rel="nofollow noreferrer">Accessing Data Files at Runtime</a>:</p>
<blockquote>
<p>Typically, existing programs manipulate a package’s <code>__file__</code> attribute in order to find the location of data files. However, this manipulation isn’t compatible with PEP 302-based import hooks, including importing from zip files and Python Eggs. It is strongly recommended that, if you are using data files, you should use the <a href="http://setuptools.readthedocs.io/en/latest/pkg_resources.html#resourcemanager-api" rel="nofollow noreferrer">ResourceManager API</a> of <code>pkg_resources</code> to access them. The <code>pkg_resources</code> module is distributed as part of <code>setuptools</code>, so if you’re using <code>setuptools</code> to distribute your package, there is no reason not to use its resource management API. See also <a href="http://peak.telecommunity.com/DevCenter/PythonEggs#accessing-package-resources" rel="nofollow noreferrer">Accessing Package Resources</a> for a quick example of converting code that uses <code>__file__</code> to use <code>pkg_resources</code> instead.</p>
</blockquote>
<p>Follow that link, and you find what look like some crufty old PEAK docs, but that's only because they really are crufty old PEAK docs. There is a <a href="http://setuptools.readthedocs.io/en/latest/pkg_resources.html" rel="nofollow noreferrer">version buried inside the <code>setuptools</code> docs</a> that you may find easier to read and navigate once you manage to find it.</p>
<p>As it says, you <em>could</em> <code>try</code> using <code>get_data</code> (which will work inside an egg/zip) and then fall back to accessing a file (which will work when running from source), but you're better off using the wrappers in <code>pkg_resources</code>. Basically, if your code was doing this:</p>
<pre><code>path = os.path.join(__file__, 'Wordproject/WordProject/Repository/DataBank/', datathingy)
with open(path) as f:
    for line in f:
        do_stuff(line)
</code></pre>
<p>… you'll change it to this:</p>
<pre><code>path = 'Wordproject/WordProject/Repository/DataBank/' + datathingy
f = pkg_resources.resource_stream(__name__, path)
for line in f:
    do_stuff(line.decode())
</code></pre>
<p>Notice that <code>resource_stream</code> files are always opened in binary mode. So if you want to read them as text, you need to wrap a <code>TextIOWrapper</code> around them, or decode each line.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>egg</code> files are just renamed .zip files.</p>
<p>You can use the <a href="https://docs.python.org/2/library/zipfile.html" rel="nofollow noreferrer"><code>zipfile</code></a> library to open the egg and extract or read the file you need.</p>
<pre><code>import zipfile

zip = zipfile.ZipFile('/path/to/file.egg', 'r')

# open file from within the egg
f = zip.open('synonyms.csv', 'r')
txt = f.read()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on the <a href="https://docs.python.org/3/library/zipfile.html" rel="nofollow noreferrer">documentation</a>,  We can read the contents of file in multiple ways. </p>
<p><strong>Solution 1: Read the contents of file directly into the memory.</strong></p>
<p>Without extracting the file locally.</p>
<pre><code>import zipfile, tempfile
tfile = tempfile.NamedTemporaryFile()
with zipfile.ZipFile('/path/to/egg.egg') as myzip:
    with myzip.open('relative/path/to/file.txt') as myfile:
        tfile.write(myfile.read())

# .. do something with temporary file

tfile.close()
</code></pre>
<p>Now <code>tfile</code> is your local temporary file handle. It's name is <code>tfile.name</code> and all file operations such as <code>open(tfile)</code> etc. work as usual on this. <code>tfile.close()</code> must be called at the end to close the handle.  </p>
<p>Contents of file can be read by <code>myfile.read()</code> itself but we lose myfile handle as soon as we exit the context. So contents of file are copied into a temporary file if it needs to be passed around for other operations.</p>
<p><strong>Solution 2 : Extract the member of egg locally</strong></p>
<p>zipfile provides an API for extracting the specific member</p>
<pre><code>import zipfile
x = zipfile.ZipFile('/path/to/egg.egg')
x.extractall(path='temp/dest/folder', members=['path/to/file.txt'])
</code></pre>
<p><strong>Solution 3 : Extract the whole egg</strong></p>
<p>Another solution is to extract the egg in temporary folder and then read the file. Egg can be extracted on command line as following</p>
<pre><code>python -m zipfile -e path/to/my.egg ./temp_destination
</code></pre>
</div>
<span class="comment-copy">Is your goal to have these files installed somewhere accessible at <code>pip install</code> time, or to have them embedded in the package directory and access them the same way you can access submodules?</span>
<span class="comment-copy">@abarnert actually I can't push this code to <code>PyPI</code> since it's an organizational thing. But I am more interested in <code>obfuscation</code> of the code such that even with the access no one can actually decompile the package. And hence I want the files to be embedded inside the package itself.</span>
<span class="comment-copy">Well, you're not going to get much obfuscation out of an egg file. It's basically just a zipfile plus a manifest telling you where all the interesting files are, which might slow down a novice hacker for about 60 seconds…</span>
<span class="comment-copy">@abarnert anything that you would recommend for this kinda requirement?</span>
<span class="comment-copy">Depends on why you're trying to obfuscate things, but the usual best answer is: don't try; almost anything you come up with will cost more than it's worth and will only give you a false sense of security that prevents you from a better solution. There are rare cases where obfuscating Python code (and engaging in a potentially unending arms race with some opponent) is worth doing, but 99% of the time when people ask for this, they don't even have any idea who the attacker might be, and there probably won't be one, and the way they're trying to protect things wouldn't help anyway.</span>
<span class="comment-copy">TBH My first intuition was using the resource manager API itself. But I couldn't get it to work. When I passed in the file name with a folder structure, it threw me an error and hence I opted for the question here. It would be of great help if you could showcase a sample code for this where the file egg is <code>WordProject</code> while it has a subdirectory <code>Repository</code> and inside that directory I have another directory <code>DataBank</code> and I am reading files from there.</span>
<span class="comment-copy">@iam.Carrot I can't build a sample that matches your layout, because I don't know your layout. But you can give us an <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> that shows exactly what you tried, and exactly what error you got, and then we can help debug that.</span>
<span class="comment-copy">yeah I kinda saw that one coming. I'll see if I can work on something for it</span>
<span class="comment-copy">I have one last question, I was using <code>pandas</code> to read the <code>csv</code> file as a Dataframe, is there a way I can achieve this using the resource manager API?</span>
<span class="comment-copy">@iam.Carrot I haven’t tried it, but I think Pandas can use a resource stream the same way it uses an actual open file. If not… I assume the file is too big to read the whole thing into memory and then tell Pandas to parse it as a string or you would have just done that, so you might have to create a tempfile, copy the stream to the tempfile, then have Pandas open that, but that’s a worst-comes-to-worst fallback.</span>
<span class="comment-copy">so you mean I unzip the file egg at runtime and then read through it? Where do I unzip it?</span>
<span class="comment-copy">@iam.Carrot Updated my answer to show how to read files directly out of the zip archive, no need to extract the data to disk.</span>
<span class="comment-copy">I am using <code>pandas</code> to read the <code>csv</code>, is there a way in pandas through which I can read the file?</span>
<span class="comment-copy">@iam.Carrot The object returned from <code>zip.open</code> is a file-like object that you should be able to feed directly to <code>pandas.read_csv</code></span>
<span class="comment-copy">great! I'll test it out. thanks</span>
