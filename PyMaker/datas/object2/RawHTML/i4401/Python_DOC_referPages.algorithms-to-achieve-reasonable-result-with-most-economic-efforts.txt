<div class="post-text" itemprop="text">
<p>Suppose that there are six kinds of problems to be handled when reading a book,<br/>
I illustrate the details as follow:</p>
<pre><code>while True:
    if encounter A :
        handle A
    #during handling the problem, it might spawn new problems of
    #A, B, C, D, E,
        produce  (A,B..E or null)
        continue

    if B occurs:
        handle B
    #during hanlding the problem, it might spwan new problems
    #A, B, C, D, E,
        produce  (A,B..E or null)
        continue

    if C happens:
        handle C
        produce (A,B..E or null)
        continue
    ...

    if there are no problmes:
        break
</code></pre>
<p>Assume I have 3 problems,<br/>
the above program might endless loop on first one and never touch the second.</p>
<p>Take an example that I am reading a book,<br/>
'Problem A' is defined as encounter a 'new word', handle it is to look up dictionary.<br/>
When looking up, I might come acorss another new word, another and another.<br/>
In this case, I will never end up reading one sentence of a book.   </p>
<p>As a solution,<br/>
I introduce a container to collect problems, value-weighted them then determine to execute which one.    </p>
<pre><code>def solve_problems(problems)
    problem_backet = list(problems)
    while True:
        if problem_backet not is null:
            #value-weighted all the problem 
            #and determine one to implement
            value_weight problems
            problem = x

        if problem == A:
            handle A
            problem_backet.append(new_problem)
            continue

        if problem == B:
            handle B
            problem_backet.append(new_problem)
            continue
        ...
        if problem_backet is null:
            return 
</code></pre>
<p>I tried alternatively to seek inspiration and improve efficiency.</p>
<pre><code>def solve_problems(problems):
    global problem_backet
    problem_backet = list(problems)
    value_weight problems
    problem = x
    if problem == A:
        handle A
        problem_backet.append(new_problem)
        solve_problems(problem_backet)
    if problem == B:
        handle B
        problem_backet.append(new_problem)
        solve_problems(problem_backet)
    if problem == C:
        handle C
        problem_backet.append(new_problem)
        solve_problems(problem_backet)
    ...
    if problem_backet is null:
        return
</code></pre>
<p>Again, the value_weighted process consume huge efforts and time. </p>
<p>How to solve such a problem in a proper algorithms?  </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>'Problem A' is defined as encounter a 'new word', handle it is to look up dictionary.
  When looking up, I might come across another new word, another and another.
  In this case, I will never end up reading one sentence of a book.</p>
</blockquote>
<p>Looks like it will eventually end up reading the sentence, since the number of new words is limited by dictionary size. In general it sounds OK to me, unless there are some other restrictions not explicitly mentioned, like finish sentence reading in a limited time.</p>
<blockquote>
<p>How to solve such a problem in a proper algorithms?</p>
</blockquote>
<p>Well, if there is no a "limited time" restriction, your original algorithm is almost perfect. To make it even better in therms of overall performance, we might handle all problems <code>A</code> first, then move to <code>B</code> and so on. It will increase the data locality and overall performance of our algorithm.</p>
<p>But if there is a "limited time" restriction, we can end up reading full sentence in that time (without full understanding) or end up reading part of the sentence (fully understanding that part) or something in between (like suggested by @Lauro Bravar).</p>
<p>From the example above it is not quite clear how we do the <code>value_weight</code>, but the proper name for this kind of problems is <strong>Priority Queueing</strong>. There are variety of algorithms and implementations, please have a look at Wikipedia page for the details: <a href="https://en.wikipedia.org/wiki/Priority_queue" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Priority_queue</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can do several things to approach such a problem.</p>
<p>One of them is to set a value of "max-iterations" or "max-effort" in a Machine Learning style that you can invest into reading a book. Therefore you will execute (handle) only up to a number of actions, until the limit has been reached. This solution will look like:</p>
<pre><code>while(effortRemaining &gt; 0){
     # Do your actions
}
</code></pre>
<p>The actions you do should be the ones that report more benefit/less effort according to some metric that you need to define.</p>
<p>When you perform a certain action (handle) you substract the cost/effort of that action from <code>effortRemaining</code> and you continue with your flow.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have already the algorithm (with the help of Andriy for the priority queue), but you lack the design. When I see your multple <code>if</code>s that check the type of the problem, I think to polymorphism.
Why not try OOP? You have two objects to define: a problem and a priority queue. Fortunately, the priority queue is defined in the <code>heapq</code> module. Let's focus on the problem:
in its core definition, it is handled and may be compared to other problems (it is more or less urgent). Note that, guided by the OOP principles, I do not talk of the structure or implementation of a problem,
but only of the <em>functions</em> of a problem:</p>
<pre><code>class Problem()
    def handle(self, some args): # we may need a dictionary, a database connection, ...
        ...

    def compare(self, other):
        ...
</code></pre>
<p>But you said that when a problem is handled, it may add new problems to the queue. So let's add a precision to the definition of <code>handle</code>:</p>
<pre><code>def handle(self, queue, some args): # we still may need a dictionary, a database connection, ...
    ...
</code></pre>
<p>In Python, <code>compare</code> is a <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">special method</a> named <code>__lt__</code>, for "lower than". (You have other special comparison methods, but <code>__lt__</code> will be sufficient here.)</p>
<p>Here's a basic implementation example:</p>
<pre><code>class Problem():
    def __init__(self, name, weight):
        self.__name = name
        self.__weight = weight

    def handle(self, queue):
        print ("handle the problem {}".format(self))
        while random.random() &gt; 0.75: # randomly add new problems for the example
            new_problem = Problem(name*2, random.randint(0, 100))
            print ("-&gt; Add the problem {} to the queue".format(new_problem))
            heapq.heappush(queue, new_problem) # add the problem to the queue

    def __lt__(self, other):
         return self.__weight &gt; other.__weight # note the &gt;

    def __repr__(self): # to show in lists
        return "Problem({}, {})".format(self.__name, self.__weight)
</code></pre>
<p>Wait! Why "lower than" and a <code>&gt;</code>? That's because the module <code>heapq</code> is a min-heap: it returns the smallest element first. Thus, we define the big weights as smaller than the little weights.</p>
<p>Now, we can build a begin queue with fake data for the example:</p>
<pre><code>queue = []
for name in ["foo", "bar", "baz"]:
    problem = Problem(name, random.randint(0, 100))
    heapq.heappush(queue, problem) # add the problem to the queue
</code></pre>
<p>And run the main loop:</p>
<pre><code>while queue:
    print ("Current queue", queue)
    problem = heapq.heappop(queue) # the problem with the max weight in O(lg n)
    problem.handle(queue)
</code></pre>
<p>I guess you will be able to subclass the <code>Problem</code> class to represent the various problems you might want to handle.</p>
</div>
<span class="comment-copy">"Looks like it will eventually end up reading the sentence" - that assumes looking up the word means not having to look the same word up again, something the OP didn't mention.</span>
<span class="comment-copy">@גלעדברקן well, I guess a "new word" OP mentioning means exactly that, i.e. a word we have never seen before...</span>
<span class="comment-copy">Not necessarily. For someone without a memory, every word is new :)</span>
<span class="comment-copy">@גלעדברקן so why bother looking up the new words at all then? ;)</span>
<span class="comment-copy">Huh, good point!</span>
<span class="comment-copy">I searched but found few materials reference to "max-effort" and "max-iteration",could you please introduce a link?</span>
<span class="comment-copy">Sure. What I meant by "max-iterations" is similar to the concept of <a href="https://stackoverflow.com/questions/31155388/meaning-of-an-epoch-in-neural-networks-training">epoch</a> in Neural Networks. Also you could see it as the max-capacity of a knapsack in the <a href="https://en.wikipedia.org/wiki/Knapsack_problem" rel="nofollow noreferrer">knapsack problem</a>. I'd love to explain it to you in more detail but in a comment it's kinda hard :)</span>
