<div class="post-text" itemprop="text">
<p>I search the fastest way to draw many couple of two values from a list so those two values are always different in the couple. The naive method I coded is very slow, so I'm pretty sure that they are more efficient way to do that.</p>
<pre><code>import numpy
listx = range(10)
number_of_couples=10000
data=numpy.empty([number_of_couples,2])

for i in xrange(number_of_couples):
   data[i] =numpy.random.choice(listx,size=2,replace=False)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My suggestion is to use <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>itertools.permutations</code></a> to cache all combinations in a list before drawing pairs from it with <code>random.choice</code>:</p>
<pre><code>import itertools
import random
import numpy

listx = range(10)
number_of_couples = 10000
permutations = list(itertools.permutations(listx, 2))
data = numpy.array([random.choice(permutations) for _ in range(number_of_couples)])
</code></pre>
<p>By testing your solution with IPython, it takes an average of 489 ms:</p>
<pre><code>489 ms ± 13.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<p>My suggestion is more than 25x faster:</p>
<pre><code>17.2 ms ± 225 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
<p>Note that for <code>permutations</code>, <code>(x, y)</code> is different than <code>(y, x)</code>:</p>
<pre><code>&gt;&gt;&gt; print(list(itertools.permutations(range(3), 2)))
[(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]
</code></pre>
<p>If in your case <code>(x, y)</code> and <code>(y, x)</code> are the same information, then use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a>:</p>
<pre><code>&gt;&gt;&gt; print(list(itertools.combinations(range(3), 2)))
[(0, 1), (0, 2), (1, 2)]
</code></pre>
<p>Just one more thing: the major problem with your solution is the <code>data[i] =</code> operation, which is quite costly. Instead of creating an empty array and modifying it with the selected couples, simply creating a new array from a <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a> can greatly speed up the solution:</p>
<pre><code>import numpy
listx = range(10)
number_of_couples=10000
data = numpy.array([numpy.random.choice(listx,size=2,replace=False) for i in range(number_of_couples)]) # Create a new array from the choices
</code></pre>
<p>Look how faster it is:</p>
<pre><code>24.3 ns ± 0.554 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should be fast enough for most applications, see timings below:</p>
<pre><code># make an example
&gt;&gt;&gt; import string
&gt;&gt;&gt; listx = list(string.ascii_letters)
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; L = len(listx)
&gt;&gt;&gt; number_of_couples = 10_000_000
&gt;&gt;&gt; 
&gt;&gt;&gt; idx = np.array((np.random.randint(0, L, (number_of_couples,)), np.random.randint(0, L-1, (number_of_couples,))))
&gt;&gt;&gt; idx[1, idx[0] == idx[1]] = L-1
&gt;&gt;&gt; 
&gt;&gt;&gt; result = np.array(listx)[idx.T]
&gt;&gt;&gt; 
&gt;&gt;&gt; result
array([['p', 't'],
       ['O', 'F'],
       ['M', 'S'],
       ...,
       ['Q', 'k'],
       ['N', 'm'],
       ['f', 'x']], dtype='&lt;U1')
&gt;&gt;&gt; 
# sanity checks
# distribution looks flat
&gt;&gt;&gt; np.bincount(idx.ravel())
array([384357, 385561, 384175, 384998, 385799, 384446, 384356, 384684,
       384305, 384072, 384993, 384346, 385302, 384518, 384659, 384142,
       383554, 384790, 384424, 384032, 383950, 385103, 384092, 384653,
       383428, 385388, 384074, 384197, 384644, 384741, 384343, 384282,
       384192, 385791, 384106, 383872, 384506, 385161, 384401, 384661,
       383978, 385547, 385571, 385941, 385416, 385325, 383997, 385201,
       383998, 384199, 385105, 384624])
# pairs are distinct
&gt;&gt;&gt; np.any(idx[0] == idx[1])
False
</code></pre>
<p>Timings compared with <code>itertools</code> solution:</p>
<pre><code>&gt;&gt;&gt; def f_np(listx, number_of_couples):
...     L = len(listx)
...     idx = np.array((np.random.randint(0, L, (number_of_couples,)), np.random.randint(0, L-1, (number_of_couples,))))
...     idx[1, idx[0] == idx[1]] = L-1
...     return np.array(listx)[idx.T]
... 
&gt;&gt;&gt; def f_it(listx, number_of_couples):
...     permutations = list(itertools.permutations(listx, 2))
...     return numpy.array([random.choice(permutations) for _ in range(number_of_couples)])
... 
&gt;&gt;&gt; from time import perf_counter
&gt;&gt;&gt; t = perf_counter(); f_it(listx, number_of_couples); s = perf_counter()
array([['s', 'm'],
       ['G', 'w'],
       ['w', 'S'],
       ...,
       ['V', 'R'],
       ['P', 'Q'],
       ['Q', 'J']], dtype='&lt;U1')
&gt;&gt;&gt; s-t
10.544860829017125
&gt;&gt;&gt; t = perf_counter(); f_np(listx, number_of_couples); s = perf_counter()
array([['C', 'T'],
       ['X', 'y'],
       ['U', 's'],
       ...,
       ['U', 'M'],
       ['t', 'i'],
       ['m', 'c']], dtype='&lt;U1')
&gt;&gt;&gt; s-t
0.3759624689701013
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use method <a href="https://docs.python.org/2/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">combinations</a> from itertools.</p>
<p>The difference with Matheus Portela's answer is that combinations are emitted in lexicographic sort order, so ['A','B'] will yield ['AB'], wherease perumation would yield ['AB', 'BA']</p>
</div>
<span class="comment-copy">Do you want all two length combinations that are different?</span>
<span class="comment-copy">Is <code>listx</code> really that small in practice? Because that has a major impact on what is an "efficient" answer.</span>
<span class="comment-copy">I added data[i]=numpy.choice... is it clearer? I need that data[i,0]!=data[i,1] and the drawn couple data[i] in a list without replacement</span>
<span class="comment-copy">I need that AB and BA can be drawn. TY anyway for this precision.</span>
<span class="comment-copy">In this case, see Matheus' answer, which details both solutions with performance information</span>
