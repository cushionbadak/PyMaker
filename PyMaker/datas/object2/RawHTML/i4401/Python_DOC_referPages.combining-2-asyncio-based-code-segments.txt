<div class="post-text" itemprop="text">
<p>I'm using the Autobahn asyncio system (to talk the Websocket WAMP protocol), which works fine and I can handle incoming RPC calls and pubsub.
My problem is I now have to connect TCP sockets and send information over these sockets as soon as an RPC call comes in through the Autobahn part.</p>
<p>The autobahn part works fine like this :</p>
<pre><code>from autobahn.asyncio.component import Component, run
from asyncio import sleep
from autobahn.asyncio.wamp import ApplicationSession, ApplicationRunner

@comp.on_join
async def joined(session, details):
    print("Connected to websocket")

    def on_message(msg):
        msg = json.loads(msg)
        print(msg)

    def some_rpc(with_data):
        print("Doing something with the data")
        return json.dumps({'status': 'OK'})

    try:
        session.subscribe(on_message, u'some_pubsub_topic')
        session.register(some_rpc, u'some_rpc_call')
        print("RPC and Pubsub initialized")

    except Exception as e:
        print("could not subscribe to topic: {0}".format(e))

if __name__ == "__main__":
     run([comp])
</code></pre>
<p>However now I need to be able to connect to multiple regular TCP sockets :</p>
<pre><code>class SocketClient(asyncio.Protocol):
    def __init__(self, loop):
        self.data = b''
        self.loop = loop

    def connection_made(self, transport):
        self.transport = transport
        print('connected')

    def data_received(self, data):
        print('Data received: {!r}'.format(data.decode()))

    def send(self, data):
        self.transport.write(data)

    def connection_lost(self, exc):
        print('The server closed the connection')
        print('Stop the event loop')
        self.loop.stop()

loop = asyncio.get_event_loop()

c=loop.create_connection(lambda: SocketClient(loop),
                              '192.168.0.219', 6773)
loop.run_until_complete(c)
loop.run_forever()
loop.close()
</code></pre>
<p>The problem is that, when I combine both and do this :</p>
<pre><code>def some_rpc(with_data):
    c.send('test')
    return json.dumps({'status': 'OK'})
</code></pre>
<p>It barks at me and tells me :</p>
<blockquote>
<p>StopIteration</p>
<p>During handling of the above exception, another exception occurred:</p>
<p>Traceback (most recent call last):   File
  "/usr/lib/python3.5/site-packages/autobahn/wamp/websocket.py", line
  95, in onMessage
      self._session.onMessage(msg)   File "/usr/lib/python3.5/site-packages/autobahn/wamp/protocol.py", line
  894, in onMessage
      on_reply = txaio.as_future(endpoint.fn, *invoke_args, **invoke_kwargs)   File "/usr/lib/python3.5/site-packages/txaio/aio.py", line 400, in
  as_future
      return create_future_error(create_failure())   File "/usr/lib/python3.5/site-packages/txaio/aio.py", line 393, in
  create_future_error
      reject(f, error)   File "/usr/lib/python3.5/site-packages/txaio/aio.py", line 462, in reject
      future.set_exception(error.value)   File "/usr/lib64/python3.5/asyncio/futures.py", line 365, in set_exception
      raise TypeError("StopIteration interacts badly with generators " TypeError: StopIteration interacts badly with generators and cannot be
  raised into a Future</p>
</blockquote>
<p>Does anyone have any idea on how to call the send function from within the RPC call function ?</p>
</div>
<div class="post-text" itemprop="text">
<p>In this code:</p>
<pre><code>c=loop.create_connection(lambda: SocketClient(loop),
                              '192.168.0.219', 6773)
# [...]
def some_rpc(with_data):
    c.send('test')
    return json.dumps({'status': 'OK'})
</code></pre>
<p><code>create_connection</code> <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_connection" rel="nofollow noreferrer">is a coroutine function</a>, so <code>c</code> contains a coroutine object. Such object does have a <code>send</code> method, but one that is entirely unrelated to sending things over the network. After calling <code>create_connection</code>, you probably want to get the resulting transport with something like:</p>
<pre><code>transport, ignore = loop.run_until_complete(c)
</code></pre>
<p>and then use <a href="https://docs.python.org/3/library/asyncio-protocol.html#asyncio.WriteTransport.write" rel="nofollow noreferrer"><code>transport.write()</code></a>, not <code>c.send()</code>.</p>
</div>
