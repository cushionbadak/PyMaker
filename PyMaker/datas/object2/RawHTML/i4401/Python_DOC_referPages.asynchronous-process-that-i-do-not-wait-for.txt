<div class="post-text" itemprop="text">
<p>There's many questions on the topic but apparently none with my exact use-case.</p>
<p>I'm running a long loop where each iteration takes a lot of time. I want to at the end of each loop plot (using <code>matplotlib</code>) the current progress. The basic setup is</p>
<pre><code>import matplotlib.pyplot as plt

def plotStuff(data)
    plt.figure()
    plt.plot(data)
    plt.savefig('test.pdf')

def main():

    for iteration in range(1000):
        data = doStuff(oldData)
        if convergence(data, oldData):
             break
        plotStuff(data)
        oldData = data

if __name__ == '__main__':
    main()
</code></pre>
<p>However, the plotting routine takes a lot of time. My initial solution was to </p>
<pre><code>import threading
</code></pre>
<p>and change the plotting part to </p>
<pre><code>    plottingThread = threading.Thread(target=plotStuff, args=data)
    plottingThread.start()
</code></pre>
<p>However, it appears that <code>matplotlib</code> is not thread save. My newest idea was then to </p>
<pre><code>import multiprocessing
</code></pre>
<p>and </p>
<pre><code>def main():
    pool = multiprocessing.Pool(processes=1)
    for iteration in range(1000):
        data = doStuff(oldData)
        if convergence(data, oldData):
             break
        res = pool.apply_async(plotStuff, args=(data,))
        oldData = data
</code></pre>
<p>However, it appears that this will only schedule the function call, and not actually execute it. Execution happens via <code>pool.close(); pool.join()</code> or <code>res.get()</code>. However, <code>pool.join()</code> and <code>res.get()</code> do block the main process until the pools are done.</p>
<p>I believe my questoin is this: How can I asynchronously call <code>plotStuff(data)</code> without having to <em>ever</em> wait for the result? </p>
<p>Additionally, I'd be happy if there's a way of controlling the jobs in the pool. Say, I only want to have at max <code>10</code> jobs in the pool, and the plotting is too slow -- would there be a way of deleting the oldest jobs such that we have a chance of catching up with the ``outer process''?</p>
</div>
<div class="post-text" itemprop="text">
<p>Regarding the first question, your assumptions are wrong. The actual computation happens immediately after you call <code>apply_async</code>. The <a href="https://docs.python.org/3/library/multiprocessing.html?highlight=process#multiprocessing.pool.AsyncResult" rel="nofollow noreferrer"><code>AsyncResult</code></a> object the method returns can be used to retrieve the computation results. It will block until they are ready but you can ignore it if you want.</p>
<p>Keep in mind that if you don't collect the <code>AsyncResult</code>, errors triggered in <code>plotStuff</code> will go unnoticed. If you still want to report errors, you can set a callback function when calling <a href="https://docs.python.org/3/library/multiprocessing.html?highlight=process#multiprocessing.pool.Pool.apply_async" rel="nofollow noreferrer"><code>apply_async</code></a> and print the error message there.</p>
<p>For the second part of the question I'd kindly ask you to better elaborate as it's not really clear what you want to achieve.</p>
</div>
