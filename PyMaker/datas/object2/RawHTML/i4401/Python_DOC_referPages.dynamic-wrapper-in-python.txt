<div class="post-text" itemprop="text">
<p>I'm looking to create a dynamic wrapper class that exposes the API calls from a provided object using data in the object.</p>
<p>Statically it looks like this:</p>
<pre><code> class Concrete:
     def __init__(self, data):
       self.data = data

     def print_data(self):
         print(self.data)


 class Wrapper:
     '''
     One day this will wrap a variety of objects. But today
     it can only handle Concrete objects.
     '''
     def wrap_it(self, concrete):
         self.cco = concrete  # concreteobject=cco

     def print_data(self):
         self.cco.print_data()


 cco = Concrete(5)
 wcco = Wrapper()
 wcco.wrap_it(cco)
 wcco.print_data()
</code></pre>
<p>Produces</p>
<pre><code> 5
</code></pre>
<p>I'd like to figure out how to do the same thing but make
<code>wrap_it</code> dynamic. It should search the concrete object
find the functions, and create functions of the same name
that call the same function in the concrete object.</p>
<p>I imagine that the solution involves <code>inspect.signature</code> or
at least some use of <code>*args</code> and <code>**kwargs</code>, but I've not seen
an example on how to put all this together.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow noreferrer">dir()</a> function to get the attributes of the given object, check if they are callable and assign them to your wrapper, like this:</p>
<pre><code> class Wrapper:
     def wrap_it(self, objToWrap):
         for attr in dir(objToWrap):
             if not attr.startswith('__') and callable(getattr(objToWrap, attr)):
                 exec('self.%s = objToWrap.%s' % (attr, attr))
</code></pre>
<p>And now, for testing.</p>
<pre><code>&gt;&gt;&gt; cco = Concrete(5)
&gt;&gt;&gt; wcco = Wrapper()
&gt;&gt;&gt; wcco.wrap_it(cco)
&gt;&gt;&gt; wcco.print_data()
5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a> magic method to hook getting undefined attributes, and forward them to the concrete object:</p>
<pre><code>class DynamicWrapper():
    def wrap_it(self, concrete):
        self.cco = concrete

    def __getattr__(self, k):
        def wrapper(*args, **kwargs):
            print(f'DynamicWrapper calling {k} with args {args} {kwargs}')
            return getattr(self.cco, k)(*args, **kwargs)

        if hasattr(self.cco, k):
            return wrapper
        else:
            raise AttributeError(f'No such field/method: {k}')

cco = Concrete(5)
dwcco = DynamicWrapper()
dwcco.wrap_it(cco)
dwcco.print_data()
</code></pre>
</div>
<span class="comment-copy">What's the point of cloning the functions from one object to another? You might as well use the original object directly instead of the wrapper. Could you come up with an example that explains why you want to do this? The solution might vary depending on what exactly you're doing.</span>
<span class="comment-copy">There are design needs to do this.</span>
<span class="comment-copy">That doesn't even begin to answer my question. Like I said, the details might be important.</span>
<span class="comment-copy">I really can't go into the details on it, other than to say that the wrapping solution above is what Is needed.</span>
<span class="comment-copy">Note that this just creates <b>aliases</b> to original methods, and not wrapper methods. This may make perfectly sense or not, depending of what the OP intention is.</span>
<span class="comment-copy">I think the alias approach matches my original need as it is the same as calling the function in the wrappedObject, right?</span>
<span class="comment-copy">And today I learned about 'exec'.  Thanks</span>
<span class="comment-copy">Does it work with special method names?</span>
<span class="comment-copy">For special method names you probably have to implement <code>__getattribute__</code> instead of <code>__getattr__</code> which is a bit trickier to get to work correcrtly, because that will shadow existing attributes (such as <code>wrap_it</code>) so you have to provide a special case for that, and also, <code>self.cco</code> would generate an infinite recursion error, so you have to change that with <code>object.__getattribute__(self, 'cco')</code>. In short, you must know what you are doing very well if you chose to go this way.</span>
<span class="comment-copy">Python3 doc says: "In addition to bypassing any instance attributes in the interest of correctness, implicit special method lookup generally also bypasses the __getattribute__() method even of the objectâ€™s metaclass". It hasn't changed since Python2.</span>
