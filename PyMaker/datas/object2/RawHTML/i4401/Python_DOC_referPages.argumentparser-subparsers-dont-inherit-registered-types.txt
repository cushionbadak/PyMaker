<div class="post-text" itemprop="text">
<p>We can add our own types to a parser's registry, for example:</p>
<pre><code>from argparse import ArgumentParser
from distutils.util import strtobool

parser = ArgumentParser('flats')
parser.register('type', 'boolean', strtobool)
parser.add_argument('--conveyor-belt', type='boolean')
</code></pre>
<p>This works so far, i.e. <code>args = parser.parse_args(['--conveyor-belt', 'on'])</code>   and then <code>args.conveyor_belt == True</code>.  But when trying to add subparser(s):</p>
<pre><code>subparsers = parser.add_subparsers()
subparser = subparsers.add_parser('slaughterhouse')
subparser.add_argument('--rotating-knives', type='boolean')  # crash
</code></pre>
<p>We get error here: <code>ValueError 'boolean' is not callable</code>.  </p>
<p>I want all subparsers to automatically inherit the types already registered by parent.  Possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>I demonstrated the use of <code>register</code> here, several years ago.</p>
<p><a href="https://stackoverflow.com/questions/15008758/parsing-boolean-values-with-argparse/19233287#19233287">Parsing boolean values with argparse</a></p>
<p>It isn't a hidden feature (i.e. no '_') but also not documented.  </p>
<p>Each parser has a <code>registry</code> that matches strings with classes and functions.  If <code>action='store_true'</code>, the parser looks up 'store_true' in the <code>registry</code> and finds the corresponding <code>Action</code> subclass.  </p>
<pre><code>print(parser._registries)
</code></pre>
<p><code>type</code> strings are also looked up, though as default only 'None' is registered.  Other common type values such as <code>int</code> and <code>float</code> are Python functions, and don't need to be registered.</p>
<p>Subparsers are new parsers, using the main parser class.  I don't think they use any of its <code>__init__</code> parameters, and certainly they don't use any attributes that might have been changed after creation.</p>
<p>It might be possible to define a <code>ArgumentParser</code> subclass that adds these items to the registry.</p>
<p>Some relevant parts of the <code>argparse.py</code> code:</p>
<pre><code>def add_subparsers(self, **kwargs):

        # add the parser class to the arguments if it's not present
        kwargs.setdefault('parser_class', type(self))
        ...
        # create the parsers action and add it to the positionals list
        parsers_class = self._pop_action_class(kwargs, 'parsers')
        action = parsers_class(option_strings=[], **kwargs)
        ....

class _SubParsersAction(Action):
    def __init__(self,
                 option_strings,
                 prog,
                 parser_class,
                 dest=SUPPRESS,
                 help=None,
                 metavar=None):
        ...
        self._parser_class = parser_class
    def add_parser(self, name, **kwargs):
       ...
        parser = self._parser_class(**kwargs)
</code></pre>
<p>So the class of the main parser is recorded with the <code>subparsers</code> <code>Action</code> object., and that is used when creating the subparser.  But parameters like <code>description</code>, and <code>help_formatter</code> are taken from the <code>add_parser</code> command, not inherited.  There was a bug/issue asking for inheritance of the <code>formatter_class</code>, but no action.</p>
<hr/>
<p>From your code:</p>
<pre><code>In [22]: parser._registries['type']
Out[22]: 
{None: &lt;function argparse.ArgumentParser.__init__.&lt;locals&gt;.identity&gt;,
 'boolean': &lt;function distutils.util.strtobool&gt;}
</code></pre>
<p>and</p>
<pre><code>In [24]: subparser._registries['type']
Out[24]: {None: &lt;function argparse.ArgumentParser.__init__.&lt;locals&gt;.identity&gt;}
In [25]: subparser._registries['type'].update(parser._registries['type'])
In [27]: subparser.add_argument('--rotating-knives', type='boolean')  # crash
Out[27]: _StoreAction(option_strings=['--rotating-knives'], dest='rotating_knives', nargs=None, const=None, default=None, type='boolean', choices=None, help=None, metavar=None)
</code></pre>
<p>or instead of <code>update</code>, simply share the dictionary:</p>
<pre><code>subparser._registries = parser._registries
</code></pre>
<p><code>argparse</code> does a lot of attribute sharing.  For example, the <code>_actions</code> list is shared between <code>parser</code> and all of its <code>action_groups</code>.</p>
<p>So if I were to add this to <code>argparse</code>, or my own version, I'd probably modify the <code>_SubParsersAction</code> class rather than the <code>ArgumentParser</code> class.   Either that, or just define a helper function:</p>
<pre><code>   def new_parser(subparsers, *args, **kwargs):
       # parser - take from global
       sp = subparsers.add_parser(*args, **kwargs)
       sp._registries = parser._registries
       sp.help.formatter_class = parser.formatter_class
       etc
</code></pre>
<p>As best I can tell, <code>subparsers</code> does not have any reference to the main parser.  That is, <code>subparsers</code> is in the <code>parser._actions</code> list, but there's no link in the other direction.</p>
<h2>Changing subparsers Action class</h2>
<p><code>parser._defaults</code> is another attribute that isn't passed from main parser to subparsers.  It is set with <code>set_defaults</code>, which is documented:</p>
<p><a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.set_defaults" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.set_defaults</a></p>
<p>Setting a different value in the subparsers is documented as a way of linking a function to the subparser:</p>
<p><a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_subparsers" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_subparsers</a></p>
<p>Judging from questions here about subparsers, it is clear that the feature is quite useful.  But it is also a bit tricky to use, and not to everyone's liking.  </p>
<p>One of the last patches that the original author, Steven J. Bethard, wrote had to do with passing the <code>Namespace</code> between main parser and subparsers.</p>
<p><a href="https://bugs.python.org/issue9351" rel="nofollow noreferrer">argparse set_defaults on subcommands should override top level set_defaults</a></p>
<p>But that wasn't to everyone's liking.</p>
<p><a href="https://bugs.python.org/issue27859" rel="nofollow noreferrer">argparse - subparsers does not retain namespace</a></p>
<p>In light of the current question, it interesting that I suggest using the <code>register</code> to use a customized <code>_SubParsersAction</code>.</p>
<blockquote>
<p>It uses a custom Action class (like your test case).  It subclasses ._SubParsersAction, and replaces the 9351 namespace use with the original one.  I use the registry to change the class that parser.add_subparsers() uses.</p>
</blockquote>
<pre><code>p.register('action', 'parsers', MyParserAction)
</code></pre>
<p>That's required because as the <code>add_subparsers</code> quote (above) shows, <code>argparse</code> uses the registry to determine what subclass to use.</p>
<p>One might argue that this use of <code>parser.register</code> needs to be documented.  But I don't see how it can be done without adding confusion to users who don't need the feature.</p>
</div>
<span class="comment-copy">Umm, I can't find any documentation about the <code>register</code> function in <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser" rel="nofollow noreferrer">the argparse docs</a>. Are you sure you're not working with implementation details here?</span>
<span class="comment-copy">Also, the <a href="https://docs.python.org/3/library/argparse.html#type" rel="nofollow noreferrer"><code>type</code> argument docs</a> state that you may pass "any callable that takes a single string argument", but it never says that you can pass a string like <code>'boolean'</code> there.</span>
<span class="comment-copy">I assume <code>ArgumentParser.register</code> is public interface and <code>ArgumentParser._registry_get</code> is non-public, because of the usual Python conventions.  Undocumented != implementation detail.  Happy to be convinced otherwise here, though.</span>
<span class="comment-copy">I demonstrated the use of <code>register</code> here (in 2013): <a href="https://stackoverflow.com/questions/15008758/parsing-boolean-values-with-argparse/19233287#19233287">Parsing boolean values with argparse</a></span>
<span class="comment-copy">@hpaulj  I know you are very familiar with argparse.  Why do you think this thing is undocumented?  Non-public API, or documentation bug?</span>
