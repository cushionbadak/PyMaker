<div class="post-text" itemprop="text">
<p>Suppose I have a function, which has a large section of code repeated in various places within the function, I can do the following:</p>
<pre><code>def foo():
    def bar():
        # do some stuff

    bar()
    # do some other stuff
    bar()
</code></pre>
<p>I can ‘read’ the variables that are in the scope of <code>foo</code> whilst inside <code>bar</code>, furthermore if I need to edit them, I can do this:</p>
<pre><code>def foo():
    # stuff involving var1 and var2
    def bar():
        nonlocal var1, var2
        # do some stuff

    bar()
    # do some other stuff
    bar()
</code></pre>
<p><strong>The Problem</strong></p>
<p>Now suppose I have several functions, <code>foo_1</code>, <code>foo_2</code>, <code>foo_3</code>… etc, all of which have the same lines of code from <code>bar</code> repeated in them. It would be monotonous (not to mention a nightmare every time I wanted to change <code>bar</code>) to define <code>bar</code> inside each <code>foo_i</code>, however doing the following does not work, since it appears <code>nonlocal</code> works on the scope in which a function is defined, not in which it is called:</p>
<pre><code>def bar():
    nonlocal var1, var2  # SyntaxError: no binding for nonlocal 'var1' found
    # do some stuff

def foo_1():
    # stuff involving var1 and var2
    bar()
    # do some other stuff
    bar()
</code></pre>
<p><strong>A potential solution</strong></p>
<p>One way round this problem it to pass in all of the variables that you need to change, and then return them afterwards. Something like this:</p>
<pre><code>def bar(var1, var2):
    # do some stuff
    return var1, var2

def foo_1():
    # stuff involving var1 and var2
    var1, var2 = bar(var1, var2)
    # do some other stuff
    var1, var2 = bar(var1, var2)
</code></pre>
<p><strong>My Question</strong></p>
<p>The solution above has a few problems:</p>
<ul>
<li>It is <strong>considerably</strong> more verbose than simply <code>bar()</code> (especially when there are more variables)</li>
<li>It isn't actually that much of an improvement on defining <code>bar</code> inside every <code>foo_i</code> since suppose a variable I previously just accessed within <code>bar</code> I now decide to edit. Not only do I need to change the function, but I need to change everywhere it is called (since now I must return an extra variable).</li>
</ul>
<p>Is there a better way of achieving the above?</p>
<p>(This feels like the sort of problem that aught to have an answer, so I apologise if it’s a repeated question. I haven’t been able to find anything as yet though.)</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>[...] it appears nonlocal works on the scope in which a function is defined, not in which it is called [...].</p>
</blockquote>
<p>You are correct. <code>nonlocal</code> only applies to the namespace in which said function is defined. From the documentation for <a href="https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement" rel="nofollow noreferrer"><code>nonlocal</code></a>:</p>
<blockquote>
<p>The nonlocal statement <strong>causes the listed identifiers to refer to previously bound variables in the nearest enclosing scope</strong> excluding globals. </p>
</blockquote>
<p><sub>(emphasis mine)</sub></p>
<p>As @Aran mentioned, a potential solution to avoid unnecessary verbosity is to wrap the variables you want to pass into certain functions in a class. <code>namedtuple</code> would be a attractive choice since you don't need a full-fledge class, but as has been stated, it is immutable. You can use a <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer"><code>types.SimpleNamespace</code></a> object instead, as they are also lightweight:</p>
<pre><code>from types import SimpleNamespace


def bar(n):
    n.a = 3, n.b = 4


def foo():
    n = SimpleNamespace(a=1, b=2)
    bar(n)
    print(n.a, n.b) # 3 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can declare those variables as <code>global</code> before modifying them inside each function, but they need to be declared before any function that uses them, also keep in mind that this will modify the variables for the scopes of ANY function in which they are declared as global:</p>
<pre><code>var1 = var2 = None
def bar():
    global var1, var2
    # do some stuff

def foo_1():
    # stuff involving var1 and var2
    bar()
    # do some other stuff
    bar()
</code></pre>
</div>
<span class="comment-copy">Short answer: Make a class that encapsulates all of those values. That reduces the number of parameters you have to pass to 1.</span>
<span class="comment-copy">(To ensure I have understood your correctly) Do you mean something similar to a namedTuple??</span>
<span class="comment-copy">No, something mutable.</span>
<span class="comment-copy">ah, yes. Good point. Thanks :)</span>
<span class="comment-copy">This sounds like an object that has two attributes. It calls methods that mutate its attributes (or returns new instances with updated attributes). What, specifically, are you trying to do?</span>
<span class="comment-copy">It would probably make sense to write a custom class for these variables. If they're always passed between functions together, that would imply that they should actually be a class. (And not a <code>NameSpace</code> thingy that's essentially just a thin wrapper that makes a dict look like a class.)</span>
<span class="comment-copy">That would make sense @Aran-Fey. However, it seems to me that using a class just as a namespace is clunky. And yes, <code>NameSpace</code> is a then wrapper around a <code>dict</code>, but being able to use the <code>.</code> operator rather than the <code>[]</code> operator (IMO) makes for more readable code.</span>
<span class="comment-copy">Yes, that's true. However, it could make sense to implement these <code>foo_1</code>, <code>foo_2</code> etc functions as methods of that class. It's impossible to say without knowing what exactly the OP is doing though. Just throwing it out there as a suggestion.</span>
<span class="comment-copy">Hmm, good point @Aran-Fey. I'll update if the OP clarifies anything.</span>
<span class="comment-copy">Thankyou both for your help :) I'm just trying to refactor a few (quite long) functions, to make them less repetitive and more maintainable. Accessing all of the variables of each function through a class/dict/object will make the code quite a lot more verbose (which I was trying to avoid) although it does address well the issue of maintainability every place <code>bar</code> is called.</span>
