<div class="post-text" itemprop="text">
<p><strong>Input:</strong> A list of lists of various positions.</p>
<pre><code>[['61097', '12204947'],
 ['61097', '239293'],
 ['61794', '37020977'],
 ['61794', '63243'],
 ['63243', '5380636']]
</code></pre>
<p><strong>Output:</strong> A sorted list that contains the count of unique numbers in a list.</p>
<pre><code>[4, 3, 3, 3, 3]
</code></pre>
<p>The idea is fairly simple, I have a list of lists where each list contains a variable number of positions (in our example there is only 2 in each list, but lists of up to 10 exist). I want to loop through each list and if there exists ANY other list that contains the same number then that list gets appended to the original list.</p>
<p><strong>Example:</strong> Taking the input data from above and using the following code:</p>
<pre><code>def gen_haplotype_blocks(df):
    counts = []
    for i in range(len(df)):
        my_list = [item for item in df if any(x in item for x in df[i])]
        my_list = list(itertools.chain.from_iterable(my_list))
        uniq_counts = len(set(my_list))
        counts.append(uniq_counts)
        clear_output()
        display('Currently Running ' +str(i))
    return sorted(counts, reverse=True)
</code></pre>
<p>I get the output that is expected. In this case when I loop through the first list <code>['61097', '12204947']</code> I find that my second list <code>['61097', '239293']</code> both contain <code>'61097'</code> so these who lists get concatenated together and form <code>['61097', '12204947', '61097', '239293']</code>. This is done for every single list outputting the following:</p>
<pre><code>['61097', '12204947', '61097', '239293']
['61097', '12204947', '61097', '239293']
['61794', '37020977', '61794', '63243']
['61794', '37020977', '61794', '63243', '63243', '5380636']
['61794', '63243', '63243', '5380636']
</code></pre>
<p>Once this list is complete, I then count the number of unique values in each list, append that to another list, then sort the final list and return that.</p>
<p>So in the case of <code>['61097', '12204947', '61097', '239293']</code>, we have two '61097', one '12204947' and one '239293' which equals to 3 unique numbers.</p>
<p>While my code works, it is VERY slow. Running for nearly two hours and still only on line ~44k.</p>
<p>I am looking for a way to speed up this function considerably. Preferably without changing the original data structure. I am very new to python.</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Too <strong>considerably</strong> improve the speed of your program, especially for larger data set. The key is to <strong>use a hash table, or a dictionary in Python's term, to store different numbers as the key, and the lines each unique number exist as value.</strong> Then in the second pass, merge the lists for each line based on the dictionary and count unique elements. </p>
<pre><code>def gen_haplotype_blocks(input):
    unique_numbers = {}

    for i, numbers in enumerate(input):
        for number in numbers:
            if number in unique_numbers:
                unique_numbers[number].append(i)
            else:
                unique_numbers[number] = [i]

    output = [[] for _ in range(len(input))]

    for i, numbers in enumerate(input):
        for number in numbers:
            for line in unique_numbers[number]:
                output[i] += input[line]

    counts = [len(set(x)) for x in output]
    return sorted(counts, reverse=True)
</code></pre>
<p>In theory, the time complexity of your algorithm is O(N*N), N as the size of the input list. Because you need to compare each list with all other lists. But in this approach the complexity is O(N), which should be considerably faster for a larger data set. And the trade-off is extra space complexity.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure how much you expect by saying <em>"considerably"</em>, but converting your inner <code>list</code>s to <code>set</code>s from the beginning should speed up things. The following works approximately 2.5x faster in my testing:</p>
<pre><code>def gen_haplotype_blocks_improved(df):
    df_set = [set(d) for d in df]
    counts = []
    for d1 in df_set:
        row = d1
        for d2 in df_set:
            if d1.intersection(d2) and d1 != d2:
                row = row.union(d2)
        counts.append(len(row))
    return sorted(counts, reverse=True)  
</code></pre>
</div>
<span class="comment-copy">Just a remark: in python you do not (usually) need to do <code>for i in range(len(thing))</code>. Most <code>things</code> support <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">iteration protocol</a> so you can just do <code>for i in thing</code>.</span>
<span class="comment-copy">Are you sure <code>[4, 3, 3, 3, 3]</code> is correct? I don't see any number appear 4 times.</span>
<span class="comment-copy">@chrisz for the first line <code>['61097', '12204947']</code> we go through all the other lines and find that only the second line <code>['61097', '239293']</code> contain at least one number that are the same between each other (the 61097). We concat these two lists together to get <code>['61097', '12204947', '61097', '239293']</code>, and when you count the number of unique numbers in those it is 3. We do the same for the second line and the unique numbers is also 3. For the third line our concated list is <code>['61794', '37020977', '61794', '63243']</code> because lines 3 and 4 have at least one number that is in both lists.</span>
<span class="comment-copy">@Nathan when you do line 4 you end up concating lists 4, 3 and 5 (becaue 4 has 61794 which is in list 3 and 63243 which is in list 5) to get <code>['61794', '37020977', '61794', '63243', '63243', '5380636']</code>. The unique numebrs are 61794, 370..., 63243, and 5380636. That is 4 numbers.</span>
<span class="comment-copy">@jjj good to know, thanks!</span>
<span class="comment-copy">This is in fact faster than both OP's and my method but the results are incorrect for some reason. It produces the same result for the sample list in the question but fails for others (try duplicating one of the tuples, for example).</span>
<span class="comment-copy">@Selcuk, good catch! I was trying to avoid merging the lists in my previous answer and it didn't work. I have updated the code and this one works fine for me.</span>
