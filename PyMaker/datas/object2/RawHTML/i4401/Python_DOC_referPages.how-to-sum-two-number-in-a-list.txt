<div class="post-text" itemprop="text">
<p><strong>what is the solution of this by  python 3 ?</strong> </p>
<p>****Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.<strong>``</strong></p>
<pre><code>Example:
Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1]. 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use <code>itertools.combinations</code> which combines the elements of your list into non-repeated couples, and check if the sum matches. If it does, print the positions of the terms:</p>
<pre><code>import itertools

lst = [2, 7, 11, 15]
for t in itertools.combinations(lst,2):
    if sum(t)==9:
        print([lst.index(a) for a in t])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This question has 2 parts:</p>
<ol>
<li>Retrieving the 2 items in a list which equate to the target </li>
<li><p>Retrieving their index value</p>
<p>def get_index_for_target(nums, target):</p>
<pre><code>for x in nums:
    for y in nums:
        if x + y == target:
            return (nums.index(x), nums.index(y))
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>For each entry in the list, check whether there's any other numbers in the list after that number that add up to the target. Since a+b = target is equivalent to b = target - a, you can just take each element, look at all the numbers after that element, and check whether they are target - element. If so, return the indices.</p>
<pre><code>for index,num in  enumerate(nums):
    if target-num in nums[index+1:]:
        return(index, nums.index(target-num))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This function iterates through all the numbers in the list and finds the sum with other numbers. If the sum is equal to the target, it returns the indices</p>
<pre><code>def indices_sum(nums,target):
    for i in range(len(nums)):
        for j in range(i+1,len(nums)):
            if nums[i]+nums[j] == target: return(i,j)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The main problem with solutions testing all possible couples (with imbricated loops or <code>itertools.combinations</code>) is that that are O(n^2), as you basically test all possible combinations of two elements among n (there are n*(n-1)/2 such combinations) until you find a valid one.</p>
<p>When n is large, you will need a more efficient algorithm. One possibility is to first sort the list (this is O(n * log(n))), finding the solution can then be done directly in O(n), which gives you a solution in O(n * log(n)).</p>
<hr/>
<p>We sort the list first, then add the first (smallest) and last (greatest) values. If the sum is too large, we can remove the largest value. If it's too small, we remove the smallest one, until we reach the exact sum.</p>
<p>We can use a <a href="https://docs.python.org/3/library/collections.html#deque-objects" rel="nofollow noreferrer">collection.deque</a> to efficiently remove values at any end of the list.</p>
<p>In order to retrieve the indices, we keep them besides the values in tuples.</p>
<pre><code>from collections import deque


def find_target(values, target):

    dq = deque(sorted([(val, idx) for idx, val in enumerate(values)]))

    while True:
        if len(dq) &lt; 2:
            raise ValueError('No match found')

        s =  dq[0][0] + dq[-1][0]

        if s &gt; target:
            dq.pop()
        elif s &lt; target:
            dq.popleft()  
        else:
            break
    return dq[0], dq[-1]



values = [23, 5, 55, 11, 2, 12, 26, 16]
target = 27

sol = find_target(values, target)

print(sol)
# ((11, 3), (16, 7))
# 11 + 16 == 27, indices 3 and 7

print(sol[0][1], sol[1][1])
# 3 7
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can use to pointers, at the beginning and at the end of the list to check each index by the sum of the two numbers, looping once.</p>
<pre><code>def sumOfTwo(array, target):
    i = 0
    j = len(array) - 1
    while i &lt; j:
      add = array[i] + array[j]
      if add == target:
        return True
      elif add &lt; target:
        i += 1
      else:
        j -= 1
    return False 

input -&gt; [1, 2, 3, 4] -&gt; target: 6

 i-&gt;    &lt;-j
[1][2][3][4]  if i + j = target return True 
              if i + j &lt; target increase i
              else decrease j
</code></pre>
<p><strong><em>Note:</em></strong> In a edge case, a guard of check before the loop, in case: target is a negative value, list is empty, target is null.</p>
</div>
<span class="comment-copy">use combinations to combine elements together and find the sum</span>
<span class="comment-copy">Agreed. @Jean-Fran√ßoisFabre Python only knows to do what you tell it to do. I'm unaware of such a combination search unless you define it.</span>
<span class="comment-copy">Welcome to StackOverflow! Please consider reading this documentation: <a href="https://meta.stackoverflow.com/q/334822">How do I ask and answer homework questions?</a></span>
<span class="comment-copy">@Michael: <code>itertools.combinations</code> taken 2 at a time without replacement.</span>
<span class="comment-copy">Thank you @Prune. I'll just put that in ye ol tool belt.  :-)</span>
<span class="comment-copy">why you used  itertools.combinations(lst,2) ?</span>
<span class="comment-copy">to generate non-repeating couples, like asked.</span>
<span class="comment-copy">While this code snippet may solve the question, <a href="http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers">including an explanation</a> really helps to improve the quality of your post. Remember that you are answering the question for readers in the future, and those people might not know the reasons for your code suggestion.</span>
