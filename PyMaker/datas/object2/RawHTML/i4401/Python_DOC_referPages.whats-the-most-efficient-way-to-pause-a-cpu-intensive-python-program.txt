<div class="post-text" itemprop="text">
<p>I made a neural network (which has unfortunately grown in complexity and become rather CPU intensive) which analyzes screenshots in real-time. </p>
<p>I wish to pause it when I press the letter 'a' and un-pause it when the letter 'a' is pressed again. What is the most efficient way to pause it (without breaking the loop altogether)? </p>
<p>It uses Python OpenCV library, but I don't use cv2.imshow, hence I can't use cv2.Waitkey. I'm running this on Windows 10. Could you please provide example code to your answer? Here's a bit of the code:</p>
<pre><code>import cv2
import mss
from PIL import Image
import numpy as np

#Creates an endless loop for high-speed image acquisition...
while (True):
    with mss.mss() as sct:
        # Get raw pixels from the screen
        sct_img = sct.grab(sct.monitors[1])

        # Create the Image
        img = Image.frombytes('RGB', sct_img.size, sct_img.bgra, 'raw', 'BGRX')

        #The rest of the neural network goes here...

        #PAUSE statement... 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>sigwait</code> from the <a href="https://docs.python.org/3/library/signal.html#signal.sigwait" rel="nofollow noreferrer"><code>signal</code> package</a> in the Python standard library. <code>sigwait</code> won't work on Windows.</p>
<h1>Edit</h1>
<p>You can do what you want in a platform independent way by using the <a href="https://docs.python.org/3.6/library/threading.html#condition-objects" rel="nofollow noreferrer"><code>threading</code> library</a>. Here's a short example program (needs the <code>py-getch</code> package if you're running on Linux or Mac):</p>
<pre><code>import os
from threading import Thread, Event

if os.name=='nt':
    from msvcrt import getch
elif os.name=='posix':
    from getch import getch
else:
    raise OSError

isRunning = True

def count(event):
    i = 0
    while isRunning:
        event.wait(1)

        if event.isSet() and isRunning:
            event.clear()
            print('Pausing count at %d' % i)
            event.wait()
            print('resuming count')
            event.clear()

        i += 1

def listener(event):
    # in Python, need to mark globals if writing to them
    global isRunning

    while isRunning:
        c = getch()
        if c=='a':
            event.set()
        if c=='e':
            event.set()
            isRunning = False

def main():
    pauseEvent = Event()
    pauseEvent.clear()

    listenerThread = Thread(target=listener, args=(pauseEvent,))

    listenerThread.start()
    count(pauseEvent)

if __name__=='__main__':
    main()
</code></pre>
<p>The above program will run two threads. The main thread will run the <code>count</code> function, which adds 1 to a count every second. The other thread runs the <code>listener</code> function, which will wait for user input. If type <code>a</code>, the <code>listener</code> thread will tell the <code>count</code> thread to pause and print out the current count. You can type <code>a</code> again to resume the count, or you can type <code>e</code> to quit.</p>
</div>
<span class="comment-copy">I should have specified that I was using Windows earlier. The help file for 'sigwait' states that it is only available on Unix.</span>
<span class="comment-copy">@MonkeyBot2020 You can implement your own (limited) custom signal handling by using the threading library in Python. I've added an example to my answer</span>
