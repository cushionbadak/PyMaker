<div class="post-text" itemprop="text">
<p>Given a pattern <code>[1,1,0,1,1]</code>, and a binary list of length 100, <code>[0,1,1,0,0,...,0,1]</code>. I want to count the number of occurences of this pattern in this list. Is there a simple way to do this without the need to track the each item at every index with a variable? </p>
<p>Note something like this, <code>[...,1, 1, 0, 1, 1, 1, 1, 0, 1, 1,...,0]</code> can occur but this should be counted as 2 occurrences. </p>
</div>
<div class="post-text" itemprop="text">
<p>Convert your list to string using join. Then do:</p>
<pre><code>text.count(pattern)
</code></pre>
<p>If you need to count overlapping matches then you will have to use regex matching or define your own function.</p>
<p><strong>Edit</strong>
Here is the full code:</p>
<pre><code>def overlapping_occurences(string, sub):
    count = start = 0
    while True:
        start = string.find(sub, start) + 1
        if start &gt; 0:
            count+=1
        else:
            return count

given_list = [1, 1, 0, 1, 1, 1, 1, 0, 1, 1]
pattern = [1,1,0,1,1]

text = ''.join(str(x) for x in given_list)
print(text)
pattern = ''.join(str(x) for x in pattern)
print(pattern)
print(text.count(pattern)) #for no overlapping
print(overlapping_occurences(text, pattern))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>l1 = [1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0]
l1str = str(l1).replace(" ", "").replace("[", "").replace("]", "")

l3 = [1, 1, 0, 1, 1]
l3str = str(l3).replace(" ", "").replace("[", "").replace("]", "")


l1str = l1str.replace(l3str, "foo")
foo = l1str.count("foo")
print(foo)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think a simple regex would suffice:</p>
<pre><code>def find(sample_list):
    list_1 = [1,1,0,1,1]
    str_1 = str(list_1)[1:-1]
    print len(re.findall(str_1, str(sample_list)))
</code></pre>
<p>Hope this solves your problem.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import Counter

a = [1,1,0,1,1]
b = [1,1,0,1,1,1,1,0,1,1]

lst = list()
for i in range(len(b)-len(a)+1):
    lst.append(tuple(b[i:i+len(a)]))

c = Counter(lst)
print c[tuple(a)]
</code></pre>
<p>output</p>
<pre><code>2
</code></pre>
<p>the loop can be written in one line like, for more "clean" but less understood code </p>
<pre><code>lst = [tuple(b[i:i+len(a)]) for i in range(len(b)-len(a)+1)]
</code></pre>
<p>NOTE, I'm using tuple cause they are immutable objects and can be hashed </p>
<p>you can also use the hash functionality and create your own hash method like multiple each var with 10 raised to his position e.g </p>
<pre><code>[1,0,1] = 1 * 1 + 0 * 10 + 1 * 100 = 101
</code></pre>
<p>that way you can make a one pass on the list and check if it contains the pattern by simply check <code>if sub_list == 101</code></p>
</div>
<div class="post-text" itemprop="text">
<p>you can always use the naive way : 
for loop on slices of the list (as in the slice that starts at i-th index and ends at i+[length of pattern]).</p>
<p>and you can improve it - notice that if you found an occurence in index i' you can skip i+1 and i+2 and check from i+3 and onwards (meaning - you can check if there is a sub-pattern that will ease your search ) 
it costs O(n*m)</p>
<p>you can use backwards convolution (called pattern matching algorithem)
this costs O(n*log(n)) which is better</p>
</div>
<div class="post-text" itemprop="text">
<p>You can divide the lookup list into chucks of size of the pattern you are looking. You can achieve this using simple recipe involving <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a> to yield a sliding window iterator </p>
<pre><code>&gt;&gt;&gt; from itertools import islice

&gt;&gt;&gt; p = [1,1,0,1,1]
&gt;&gt;&gt; l = [0,1,1,0,0,0,1,1,0,1,1,1,0,0,1]
&gt;&gt;&gt; [tuple(islice(l,k,len(p)+k)) for k in range(len(l)-len(p)+1)]
</code></pre>
<p>This will give you output like:</p>
<pre><code>&gt;&gt;&gt; [(0, 1, 1, 0, 0), (1, 1, 0, 0, 0), (1, 0, 0, 0, 1), (0, 0, 0, 1, 1), (0, 0, 1, 1, 0), (0, 1, 1, 0, 1), (1, 1, 0, 1, 1), (1, 0, 1, 1, 1), (0, 1, 1, 1, 0), (1, 1, 1, 0, 0), (1, 1, 0, 0, 1)]
</code></pre>
<p>Now you can use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> to count the occurrence of each sublist in sequence like</p>
<pre><code> &gt;&gt;&gt; from collections import Counter
 &gt;&gt;&gt; c = Counter([tuple(islice(l,k,len(p)+k)) for k in range(len(l)-len(p)+1)])
 &gt;&gt;&gt; c 
 &gt;&gt;&gt; Counter({(0, 1, 1, 0, 1): 1, (1, 1, 1, 0, 0): 1, (0, 0, 1, 1, 0): 1, (0, 1, 1, 1, 0): 1, (1, 1, 0, 0, 0): 1, (0, 0, 0, 1, 1): 1, (1, 1, 0, 1, 1): 1, (0, 1, 1, 0, 0): 1, (1, 0, 1, 1, 1): 1, (1, 1, 0, 0, 1): 1, (1, 0, 0, 0, 1): 1})
</code></pre>
<p>To fetch frequency of your desired sequence use</p>
<pre><code> &gt;&gt;&gt; c.get(tuple(p),0)
 &gt;&gt;&gt; 1
</code></pre>
<p>Note I have used <code>tuple</code> everywhere as <code>dict</code> keys since <code>list</code> is not a hashable type in python so cannot be used as <code>dict</code> keys.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can solve it using following two steps:</p>
<ul>
<li>Combine all elements of the list in a single string</li>
<li><p>Use python count function to match the pattern in the string</p>
<pre><code>a_new = ''.join(map(str,a))

pattern = ''.join(map(str,pattern))

a_new.count(pattern)
</code></pre></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can try range approach :</p>
<pre><code>pattern_data=[1,1,0,1,1]
data=[1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1]

count=0
for i in range(0,len(data),1):
    if data[i:i+len(pattern_data)]==pattern_data:
        print(i,data[i:i+len(pattern_data)])
        j+=1

print(count)
</code></pre>
<p>output:</p>
<pre><code>0 [1, 1, 0, 1, 1]
15 [1, 1, 0, 1, 1]
20 [1, 1, 0, 1, 1]
35 [1, 1, 0, 1, 1]
40 [1, 1, 0, 1, 1]
52 [1, 1, 0, 1, 1]
55 [1, 1, 0, 1, 1]
60 [1, 1, 0, 1, 1]
75 [1, 1, 0, 1, 1]
80 [1, 1, 0, 1, 1]
95 [1, 1, 0, 1, 1]
11
</code></pre>
</div>
<span class="comment-copy">I believe you need to visit each item in the list at least once, to check whether it is the same as your starting item in the pattern or not. That is, at least you'll have to make n-l+1 visits where "n" is the number of elements of the list and "l" is the length of your pattern.</span>
<span class="comment-copy">You can convert both lists into strings and use regular expressions or find ...</span>
<span class="comment-copy"><a href="https://stackoverflow.com/q/2970520/2284418">stackoverflow.com/q/2970520/2284418</a>  maybe could help you.</span>
<span class="comment-copy">He can have a look at this post: <a href="https://stackoverflow.com/questions/4664850/find-all-occurrences-of-a-substring-in-python" title="find all occurrences of a substring in python">stackoverflow.com/questions/4664850/…</a>, or <a href="https://stackoverflow.com/questions/3873361/finding-multiple-occurrences-of-a-string-within-a-string-in-python" title="finding multiple occurrences of a string within a string in python">stackoverflow.com/questions/3873361/…</a> but without converting to strings I see no simple method other than iterating.</span>
