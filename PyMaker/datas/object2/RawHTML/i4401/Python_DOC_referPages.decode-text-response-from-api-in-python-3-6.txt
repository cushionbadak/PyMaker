<div class="post-text" itemprop="text">
<p>I am trying to extract data from mailchimp export api, which returns responses based on the following specifications:</p>
<pre><code>    Returns:
</code></pre>
<p>Parameter -     text    </p>
<p>Description:
a plain text dump of JSON objects. The first row is a header row. Each additional row returned is an individual JSON object. Rows are delimited using a newline (\n) marker, so implementations can read in a single line at a time, handle it, and move on.</p>
<p>To get the data I am using:</p>
<pre><code>response = requests.get(urldetails).text
</code></pre>
<p>If I use .json() it errors out with a JSON decode error. The output of the above is something along the lines of:</p>
<p>{data..}
{data...}</p>
<p>I am unsure whether each dict is on a separate row, however I am under the impression it's actually just one continuous string as many of my attempts to decode it ended up with an error 'str' object cannot be...etc. . I don't see the '\n' separators anywhere when I am using the .text method. </p>
<p>What's the best way of going about and make each dict a separate item in a list or a row in a dataframe (which I can unpack later).</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>You can get all the data from the <code>MailChimp export api</code> using a simple approach. Please note that I am using <code>f-strings</code>, only available in Python 3.6+.</p>
<pre><code>import requests
import json


apikey = '&lt;your-api-key&gt;'
id = "&lt;list-id&gt;"

URL = f"https://us10.api.mailchimp.com/export/1.0/campaignSubscriberActivity/?apikey={apikey}&amp;id={id}"

json_data = [json.loads(s) for s in requests.get(URL).text.strip().split("\n")]
print(json_data[0]['&lt;some-subscriber-email&gt;'][0]['action'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Provided that the text response isn't insanely badly formed json, you can use the <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer"><code>json</code> library</a>. In particular, the loads() function.</p>
<pre><code>import json
json_response = json.loads(response)
</code></pre>
<p><code>loads()</code> loads JSON into a python dict from a string. </p>
<p><strong>EDIT:</strong>
The Mailchimp API states that each JSON object is separated by a newline character. We can create a list of dicts with the following code:</p>
<pre><code># get response from GET request and load as a string
import json
json_resp = [json.loads(line) for line in response.split('\n')]
</code></pre>
</div>
<span class="comment-copy">What is the endpoint you are querying? <code>https://&lt;dc&gt;.api.mailchimp.com/3.0/lists/</code>?</span>
<span class="comment-copy">Its the export API https://&lt;dc&gt;.api.mailchimp.com/export/1.0/campaignSubscriberActivity/ : <a href="https://developer.mailchimp.com/documentation/mailchimp/guides/how-to-use-the-export-api/" rel="nofollow noreferrer">developer.mailchimp.com/documentation/mailchimp/guides/â€¦</a></span>
<span class="comment-copy">Apparently splitlines() didn't work for him - why would stripping the string before splitting it make it function any different</span>
<span class="comment-copy">Because the response has extra spaces that cause a <code>JSONDecodeError</code> if you do <code>json.loads</code> on a string with an extra space.</span>
<span class="comment-copy">Ah right - I'm unable to test the api else I would've. Thanks!</span>
<span class="comment-copy">Thanks! - I tagged it as the correct answer, although I need to use a slightly different approach because I need everything in a neat dataframe (which looks like a challenge at the moment..). However, the '.text.strip().split("\n")' approach works!</span>
<span class="comment-copy">I had tried this, receiving the following error: 'TypeError: the JSON object must be str, bytes or bytearray, not 'Response''. On the other hand if I use the .text version: json.loads(response.text), I get a different error: json.decoder.JSONDecodeError: Extra data: line 2 column 1 (char 113)</span>
<span class="comment-copy">@DBa this is assuming the code on the question - <code>response = requests.get(urldetails).text</code> - has already been performed and therefore should already be a string if following the posted code.</span>
<span class="comment-copy">Also, do you have a sample of what is returned? Or a URL I can test with?</span>
<span class="comment-copy">Yes, sorry, realized afterwards, edited my answer to cover both with and without .text errors.</span>
<span class="comment-copy">@DBa some sample of sorts would <i>really</i> help me help you</span>
