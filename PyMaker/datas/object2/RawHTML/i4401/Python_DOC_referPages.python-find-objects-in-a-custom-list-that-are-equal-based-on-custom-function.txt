<div class="post-text" itemprop="text">
<p>Here is my code :</p>
<pre><code>&gt;&gt;&gt; class MyClass() :
...      def __init__( self, item ) :
...              self.a = item["a"]
...              self.b = item["b"]
...      def __eq__(self, other ) :
...              return self.a == other.a and self.b == other.b
...      def myEqualityFunc(self,other) :
...              return self.b == other.b
...      def __str__(self) :
...              return str( self.__dict__ )
...
&gt;&gt;&gt; t1 = MyClass({"a" : ["X1"] , "b" : [1,2] })
&gt;&gt;&gt; t2 = MyClass({"a" : ["X2"] , "b" : [1,2] })
&gt;&gt;&gt; t3 = MyClass({"a" : ["Y1"] , "b" : [3] })
&gt;&gt;&gt;
&gt;&gt;&gt; l = [t1,t3,t2 ]
&gt;&gt;&gt; for l_ in l :
...     print l_
...
{'a': ['X1'], 'b': [1, 2]}
{'a': ['Y1'], 'b': [3]}
{'a': ['X2'], 'b': [1, 2]}
</code></pre>
<p>What I am trying to do is find the objects in my list that are equal based on <code>myEqualityFunc</code> -&gt; in my example these will be t1 and t2 since they have the same <code>b</code> attribute.</p>
<p>I know that <code>a</code> is unique.</p>
<p>Is there a more pythonic way than that :</p>
<pre><code>for outer_l in l:
    for inner_l in l :
            if outer_l.myEqualityFunc( inner_l ) and outer_l != inner_l :
               # remove inner_l from l since found and keep it in anotehr data structure.
</code></pre>
<p>Ultimate goal is to end up with something like this but right now I am doing it in more than one steps :</p>
<pre><code>&gt;&gt;&gt; for r in result :
...     print r
...
{'a': ['X1' , 'X2'], 'b': [1, 2]}
{'a': ['Y1'], 'b': [3]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, definitely check what <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools library</a> does. </p>
<p>Second, you can use <code>itertools.combinations</code> in this case.</p>
<pre><code>import itertools
map(your_func_to_do_stuff_with_pairs, itertools.combinations(l, 2))
</code></pre>
<p>Here <code>your_func_to_do_stuff_with_pairs</code> looks like</p>
<pre><code>def your_func_to_do_stuff_with_pairs(pair):
    # do sth with pair[0] and pair[1]
    if pair[0].myEqualityFunc( pair[1]) and pair[0] != pair[1] :
          # what happens when if is satisfied
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>find objects in a custom list that are equal based on custom function</p>
</blockquote>
<p>This is exactly what <code>groupby</code> was made for</p>
<pre><code>t1 = MyClass({"a" : ["X1"] , "b" : [1,2] })                                     
t2 = MyClass({"a" : ["X2"] , "b" : [1,2] })                                     
t3 = MyClass({"a" : ["Y1"] , "b" : [3] })                                       

l = [t1,t3,t2]                                                                  

data = sorted(l, key = lambda t: t.b)                                           
for k, g in itertools.groupby(data, lambda t: t.b):                             
    print("key =", k)                                                           
    for t in g: print(t) 
</code></pre>
<p>Output: </p>
<pre><code>key = [1, 2]
{'a': ['X1'], 'b': [1, 2]}
{'a': ['X2'], 'b': [1, 2]}
key = [3]
{'a': ['Y1'], 'b': [3]}
</code></pre>
</div>
<span class="comment-copy">double list comprehension which filters?</span>
<span class="comment-copy">much cleaner answer than mine. I didn't know about groupby (outside pandas), so good</span>
