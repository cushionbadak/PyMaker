<div class="post-text" itemprop="text">
<p>I would like to create a function that returns a function of the product of a list of functions. The list of functions should be of variable length and the functions should have different parameters.</p>
<p>E.g.:</p>
<pre><code>def f(a, b, **kwargs):
    return a + b

def g(c, d, **kwargs):
    return c + d

def product_function(function_list, **kwargs):
    ...
    &lt;create function that returns product function of functions in 
     function_list&gt;
    ...
    return &lt;productfunction&gt;
</code></pre>
<p>In the example above this would be something like:</p>
<pre><code>my_function = product_function([f,g])
</code></pre>
<p>This should return a function that can be used <em>as if it was defined as:</em></p>
<pre><code>def my_function(a, b, c, d):
    return f(a, b) * g(c, d)
</code></pre>
<p>I would like to use this for iterating over a list of combinations of factors and optimising parameters for these combinations to select the most predictive one in a data science project.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with some help from the introspection utilities in the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> module.</p>
<p>Specifically, I used <a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow noreferrer"><code>inspect.signature</code></a> to find each function's positional and keyword arguments, and <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature.bind_partial" rel="nofollow noreferrer"><code>Signature.bind_partial</code></a> to prevent clashes between positional and keyword arguments. The following is a generic implementation of a function that combines other functions:</p>
<pre><code>import inspect

def generic_operator_function(operator_function, default_value,
                              function_list, **kwargs):
    POSITIONALS = {inspect.Parameter.POSITIONAL_ONLY,
                   inspect.Parameter.POSITIONAL_OR_KEYWORD}
    KEYWORDS = {inspect.Parameter.POSITIONAL_OR_KEYWORD,
                inspect.Parameter.KEYWORD_ONLY}

    # if no functions were given, return the default value
    if not function_list:
        return lambda: default_value

    # for each function in the list, find out how many positional
    # arguments it accepts. Also find out which keyword arguments
    # it accepts.
    arg_maps = []
    kwarg_names = []
    for func in function_list:
        sig = inspect.signature(func)
        params = sig.parameters.values()

        # count the positional arguments and map them to
        # parameter names
        bound_args = sig.bind_partial(**kwargs).arguments
        arg_map = [param.name for param in params if param.kind in POSITIONALS
                                                  and param.name not in bound_args]
        arg_maps.append(arg_map)

        # find the names of all keyword arguments
        if any(param.kind == inspect.Parameter.VAR_KEYWORD for param in params):
            kwnames = True
        else:
            kwnames = {param.name for param in params if param.kind in KEYWORDS}
        kwarg_names.append(kwnames)

    # return a function that iterates through the function_list and
    # multiplies all results
    def combined_func(*args, **inner_kwargs):
        value = default_value

        i = 0
        for func, arg_map, kwnames in zip(function_list, arg_maps, kwarg_names):
            # if the function takes **kwargs, pass all kwargs. Otherwise, pass
            # only those that it supports.
            kw_arguments = kwargs.copy()
            kw_arguments.update(inner_kwargs)
            if kwnames is not True:
                kw_arguments = {k: v for k, v in kw_arguments.items() if k in kwnames}

            # take the next batch of arguments, but only those that aren't already
            # provided as keyword arguments
            arg_map = [arg for arg in arg_map if arg not in kw_arguments]
            numparams = len(arg_map)
            arguments = args[i:i+numparams]
            kw_arguments.update({arg: value for arg, value in zip(arg_map, arguments)})

            # call the function
            retval = func(**kw_arguments)
            value = operator_function(value, retval)

            i += numparams

        return value

    return combined_func
</code></pre>
<p>With this, you can easily define a bunch of functions similar to your <code>product_function</code>:</p>
<pre><code>import operator

def product_function(*args, **kwargs):
    return generic_operator_function(operator.mul, 1, *args, **kwargs)

def sum_function(*args, **kwargs):
    return generic_operator_function(operator.add, 0, *args, **kwargs)

def append_function(*args, **kwargs):
    return generic_operator_function(lambda x, y: x+[y], [], *args, **kwargs)
</code></pre>
<pre><code>&gt;&gt;&gt; my_function = product_function([f,g])
&gt;&gt;&gt; my_function(1,2, 3,4)
21
&gt;&gt;&gt; sum_function([f,g])(1,2, 3,4)
10
&gt;&gt;&gt; append_function([f,g])(1,2, 3,4)
[3, 7]
</code></pre>
<p>And it correctly passes on only those keyword arguments that each function supports:</p>
<pre><code>&gt;&gt;&gt; p = product_function([f,g], a=1, c=2)
&gt;&gt;&gt; p(3, 4)
24
</code></pre>
</div>
<span class="comment-copy">How should kwargs be handled? If you don't need them, don't add them in.</span>
<span class="comment-copy">I assume the kwargs should be passed to each function in <code>function_list</code>?</span>
<span class="comment-copy">@abccd  I had added the **kwargs because I thought all parameters would be entered into all functions. Apparently I should not have added **kwargs at all.</span>
<span class="comment-copy">@Aran-Fey No not necessarily, only the function to which the parameters are relevant</span>
<span class="comment-copy">Just a guess, but it might be because you didn't explain how the <code>**kwargs</code> should be handled, or because you didn't post your own attempt at writing <code>product_function</code>.</span>
<span class="comment-copy">Super! Thanks a lot!</span>
<span class="comment-copy">Thanks for the update. Would it be possible to give arguments of <code>f</code> and <code>g</code> default values and only fill in some arguments, like: <code>product_function(a=1, c=1)</code></span>
<span class="comment-copy">@Frits Updated. See the example at the very bottom.</span>
<span class="comment-copy">I wrote my follow up question wrongly, I wanted to ask how to implement it such that <code>p=product_function([f,g])</code> and then call <code>p(a=1, c=2)</code></span>
<span class="comment-copy">@Frits But then where do the values for <code>b</code> and <code>d</code> come from? Do the <code>f</code> and <code>g</code> functions have default values for those parameters?</span>
