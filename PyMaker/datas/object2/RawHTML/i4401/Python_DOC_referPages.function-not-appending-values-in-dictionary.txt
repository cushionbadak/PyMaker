<div class="post-text" itemprop="text">
<p>I have the following text file (as we can't be attached files here I have uploaded to Pastebin)</p>
<pre><code>https://pastebin.com/zicShFFm
</code></pre>
<p>I am reading this text file using the function provided below, scrapping data (using regex), the function works perfectly.
The only problem is if the movie comes twice in the file it doesn't append values. It replaces it.</p>
<p>For example:</p>
<p>A Quiet Place (2018) is running in "Studio Movie Grill - Downey" and "AMC Norwalk 20"; while processing the text file it will insert movie details of the first movie theater but when it read same movies details of second movie theater it will remove the old entry and update with new one.</p>
<p>Here is the function:</p>
<pre><code>movie_details=[]
movie_name=[]
final_dict={}

def textScrapper(theater,filepath):
    pattern=r'\w.+(?=\([0-9]{4})'
    with open(filepath,'r') as f:
    def regex_approach():
        sub_details=[]
        for line in f:
        logging.info(line)
        if re.search(pattern,line):
            movie_name.append(re.search(pattern,line).group())
            if sub_details:
                 logging.info(sub_details)
                 movie_details.append(sub_details)
            sub_details=[]
        else:
            sub_details.append(line.strip())       
        movie_details.append(sub_details)
    regex_approach()
    final_dict=dict(zip(movie_name,unique))
    return final_dict

theater='abc'
results=textScrapper('abc',filepath)
print(results)
</code></pre>
<p>Any help will be appreciated!   </p>
</div>
<div class="post-text" itemprop="text">
<p>A dict can only have a single value for each key. Every time you try to assign a new value to an existing key, it just replaces the old value. Even if you do it within the constructor. For example:</p>
<pre><code>&gt;&gt;&gt; keys = [1, 2, 3, 1]
&gt;&gt;&gt; values = ['a', 'b', 'c', 'd']
&gt;&gt;&gt; dict(zip(keys, values))
{1: 'd', 2: 'b', 3: 'c'}
</code></pre>
<p>The <code>(1, 'd')</code> replaced the <code>(1, 'a')</code>. And exactly the same thing is happening in your code if there are two movies with the same name when you do this:</p>
<pre><code>final_dict=dict(zip(movie_name,unique))
</code></pre>
<hr/>
<p>Something that maps a single key to one or more values, instead of just one value, is often called a "multidict". In Python, this is usually implemented as a plain old dict whose values are either sets or lists of the actual values.<sup>1</sup></p>
<p>In your case, the actual values are lists, which are mutable, and therefore can't be put into a set. If you don't actually need them to be mutable, you might be better off using tuples instead, but let's assume you do need specifically lists.</p>
<p>You can write it like this:</p>
<pre><code>final_dict = {}
for name, detail in zip(movie_name, unique):
    final_dict.setdefault(name, list()).append(detail)
</code></pre>
<p>Or, alternatively:</p>
<pre><code>final_dict = collections.defaultdict(list)
for name, detail in zip(movie_name, unique):
    final_dict[name].append(unique)
</code></pre>
<p>The difference between the two is in what happens if you later try to look up a name that doesn't existâ€”a normal dict built with <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>setdefault</code></a> will raise a <code>KeyError</code>, while a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> will give you an empty <code>set</code>. So, whichever one of those two outcomes you want, pick the respective implementation. (Occasionally, you really don't care either way. In that case, <code>defaultdict</code> is generally a bit faster, and equally easy to understand.)</p>
<p>And now, <code>final_dict['A Quiet Place (2018)']</code> will be a set of all of the theaters where it's playing, which you can easily loop over and print out, or whatever else you wanted to do.</p>
<hr/>
<p><sub>1. A real multidict type should probably have some way to iterate key-value pairs with repeated keys, instead of key-collection-of-value pairs, similar to the way <code>Counter</code> can be used for a multiset. There are various libraries on PyPI that provide this, but all with slightly different APIs, and some also make <code>d[key]</code> return the first value and require a special method to get all values for <code>key</code>. Many of them are embedded in various client-side or server-side web frameworks, because web forms are a common use case where it's uncommon but not illegal to have multiple values for the same key.</sub></p>
</div>
<span class="comment-copy">So what would you like it to do? I assume you are aware that a dictionary cannot have repeated keys?</span>
<span class="comment-copy">@jpp - yes, but values are not repeating, movie details are different and unique. In logic somewhere its not appending. It should append</span>
<span class="comment-copy">What you probably want here is a "multidict": something that maps each key to 1 or more values, instead of to just 1 value. In Python, this is usually implemented as a <code>dict</code> with either <code>set</code>s or <code>list</code>s for values via the <code>setdefault</code> method, or a <code>defaultdict(set)</code> or <code>defaultdict(list)</code>.</span>
<span class="comment-copy">(I think your indentation is off, no?)</span>
<span class="comment-copy">@BruceWayne indentation fixed</span>
<span class="comment-copy">On both approaches getting error: final_dict[name].add(unique) TypeError: unhashable type: 'list'</span>
<span class="comment-copy">@spider22 Yeah, you can't put lists in a set, because lists are mutable. If you specifically need these to be lists, I can change it to use a list of lists instead of a set of lists. But if you don't need them to be lists, you might want to use a set of tuples instead.</span>
<span class="comment-copy">@abamert I don't have any preference, I need to do a lot of values replace later in my code, so whatever makes that easy you can change to that.</span>
<span class="comment-copy">@spider22 If you're going to be changing the values later, then you probably do want them to be mutable (otherwise you have to <code>remove</code> the old value and re-<code>add</code> a changed value), so I've edited it to use a list of lists for each value.</span>
<span class="comment-copy">@spider22 The second one works when I try it on reasonable sample data. If it doesn't work for you, either there's something weird with your data, or with the way you implemented it, and nobody can help you if you don't give us both of those (possibly in a new question). As for mutable dicts, I don't really know what you're asking, but that sounds like a whole new question; if you can't figure out how to do things like <code>final_dict[name][1] = 'spam'</code> or whatever, get as far as you can, and then post a new question with a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
