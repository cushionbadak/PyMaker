<div class="post-text" itemprop="text">
<p>Input will be :</p>
<pre><code>A=['5', '5', '262.1', 0, 0.0, ['5', '5', '262.1', 0, 0.0], ['5', '5', '262.1', 0, 0.0]]
</code></pre>
<p>Result would be :</p>
<pre><code>B=['15','15','786.3','0','0.0']
</code></pre>
<p>The goal is given <code>[x1...xN, [y1...yN], [z1...zN]]</code> to return a list where the values are <code>[x1 + y1 + z1, ..., xN + yN + zN]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can group your data by element type:</p>
<pre><code>import itertools
A=['5', '5', '262.1', 0, 0.0, ['5', '5', '262.1', 0, 0.0], ['5', '5', '262.1', 0, 0.0]]
new_a = itertools.chain.from_iterable([[list(b)] if not a else list(b) for a, b in itertools.groupby(A, key=lambda x:isinstance(x, list))])
final_result = [str(round(sum(i), 1)) for i in zip(*[map(float, i) for i in new_a])]
</code></pre>
<p>Output:</p>
<pre><code>['15.0', '15.0', '786.3', '0.0', '0.0']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Per user comment:</p>
<pre><code># original input
A = ['5', '5', '262.1', 0, 0.0, ['5', '5', '262.1', 0, 0.0], ['5', '5', '262.1', 0, 0.0]]
# build a list of lists containing the non-list elements from 'A'
# i.e. it gets '5', '5', '262.1', 0, 0.0
N = [[float(item) for item in A if not isinstance(item, list)]]
# build a list of lists containing the list elements from 'A'
# i.e. it gets both ['5', '5', '262.1', 0, 0.0]
L = [list(map(float, item)) for item in A if isinstance(item, list)]
# at this point...
# N = [['5', '5', '262.1', 0, 0.0]]
# L = [['5', '5', '262.1', 0, 0.0], ['5', '5', '262.1', 0, 0.0]]
# N + L = [['5', '5', '262.1', 0, 0.0], ['5', '5', '262.1', 0, 0.0], ['5', '5', '262.1', 0, 0.0]]
# zip() iterates over each internal iterable simulatenously preforming 'sum()'
F = [sum(item) for item in zip(*(N + L))]
</code></pre>
<p>So the inline comments can be helpful, but a quick breakdown and links may do you some good:</p>
<ul>
<li><a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer">isinstance</a> checks if the element in <code>A</code> is a <code>list</code> object or not (since you have lists within lists)</li>
<li><a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer">map</a> does what its name implies, it "maps" a function (<code>float</code>) to each list element within <code>A</code></li>
<li><a href="https://docs.python.org/3/library/functions.html#func-list" rel="nofollow noreferrer">list</a> is used to convert the result from <code>map()</code> to a <code>list</code> object that shows with the <code>[ ]</code></li>
<li><a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip</a> simultaenously iterates over multiple iterables so we can call <code>sum()</code> on the iterator</li>
<li><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a> is a fast way to make a <code>list</code>; this is the <code>[i for i in x]</code> syntax</li>
</ul>
</div>
<span class="comment-copy">what is your question?</span>
<span class="comment-copy">Can you post some of your code?</span>
<span class="comment-copy">also explain the output makes no sense</span>
<span class="comment-copy">It's possible that this could happen if they did <code>append()</code> when they should have done <code>extend()</code>.</span>
<span class="comment-copy">Also, I think a more interesting question is how you ended up with this weird structure. It's probably better to fix this upstream, rather than doing some gymnastics at this point.</span>
<span class="comment-copy">dude.....<code>new_a</code> is literally unreadable......</span>
<span class="comment-copy">ok, let me rephrase, it's not Pythonic or conducive to newbies stumbling upon this question, and I really wouldn't consider it readable either tbh</span>
<span class="comment-copy">If this is readable, I need new glasses. Smart glasses, with automatic translation from code to english. Even <i>knowing</i> what it's supposed to do it took me 5 minutes of intense staring to figure out what's going on.</span>
<span class="comment-copy"><code>itertools.chain(*[...])</code> is a <b>total</b> anti-pattern. Use a flat-nested list comprehension instead, which is both a bit more readable and executes much faster.</span>
<span class="comment-copy">...like so, with some slightly-improved variable names and removing an unnecessary <code>list()</code> casting -- <code>[seq for is_list, group in itertools.groupby(A, key=lambda val: isinstance(val, list)) for seq in (group if is_list else [list(group)])]</code></span>
<span class="comment-copy">@Aran-Fey Missed my 2nd bracket pair on N. Fixed.</span>
<span class="comment-copy">@Aran-Fey Not sure what you fixed but I was adding comments when you did I suppose.</span>
<span class="comment-copy">Have my upvote for readable code with comments. You're in a completely different league than the other answer.</span>
