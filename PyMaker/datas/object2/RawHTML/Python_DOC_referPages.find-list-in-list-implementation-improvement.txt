<div class="post-text" itemprop="text">
<p>This is a generalization of the "string contains substring" problem to (more) arbitrary types.</p>
<p>Given an sequence (such as a list or tuple), what's the best way of determining whether another sequence is inside it?   As a bonus, it should return the index of the element where the subsequence starts:</p>
<p>Example usage (Sequence in Sequence):</p>
<pre><code>&gt;&gt;&gt; seq_in_seq([5,6],  [4,'a',3,5,6])
3
&gt;&gt;&gt; seq_in_seq([5,7],  [4,'a',3,5,6])
-1 # or None, or whatever
</code></pre>
<p>So far, I just rely on brute force and it seems slow, ugly, and clumsy.</p>
</div>
<div class="post-text" itemprop="text">
<p>I second the Knuth-Morris-Pratt algorithm. By the way, your problem (and the KMP solution) is exactly recipe 5.13 in <a href="https://rads.stackoverflow.com/amzn/click/com/0596007973" rel="nofollow noreferrer">Python Cookbook</a> 2nd edition. You can find the related code at <a href="http://code.activestate.com/recipes/117214/" rel="noreferrer">http://code.activestate.com/recipes/117214/</a></p>
<p>It finds <em>all</em> the correct subsequences in a given sequence, and should be used as an iterator:</p>
<pre><code>&gt;&gt;&gt; for s in KnuthMorrisPratt([4,'a',3,5,6], [5,6]): print s
3
&gt;&gt;&gt; for s in KnuthMorrisPratt([4,'a',3,5,6], [5,7]): print s
(nothing)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a brute-force approach <code>O(n*m)</code> (similar to <a href="https://stackoverflow.com/questions/425604/best-way-to-determine-if-a-sequence-is-in-another-sequence-in-python#425764">@mcella's answer</a>). It might be faster than the Knuth-Morris-Pratt algorithm implementation in pure Python <code>O(n+m)</code> (see <a href="https://stackoverflow.com/questions/425604/best-way-to-determine-if-a-sequence-is-in-another-sequence-in-python#425838">@Gregg Lind answer</a>) for <em>small</em> input sequences.</p>
<pre><code>#!/usr/bin/env python
def index(subseq, seq):
    """Return an index of `subseq`uence in the `seq`uence.

    Or `-1` if `subseq` is not a subsequence of the `seq`.

    The time complexity of the algorithm is O(n*m), where

        n, m = len(seq), len(subseq)

    &gt;&gt;&gt; index([1,2], range(5))
    1
    &gt;&gt;&gt; index(range(1, 6), range(5))
    -1
    &gt;&gt;&gt; index(range(5), range(5))
    0
    &gt;&gt;&gt; index([1,2], [0, 1, 0, 1, 2])
    3
    """
    i, n, m = -1, len(seq), len(subseq)
    try:
        while True:
            i = seq.index(subseq[0], i + 1, n - m + 1)
            if subseq == seq[i:i + m]:
               return i
    except ValueError:
        return -1

if __name__ == '__main__':
    import doctest; doctest.testmod()
</code></pre>
<p>I wonder how large is the <em>small</em> in this case?</p>
</div>
<div class="post-text" itemprop="text">
<p>Same thing as string matching sir...<a href="http://www.ics.uci.edu/~eppstein/161/960227.html" rel="nofollow noreferrer">Knuth-Morris-Pratt string matching</a></p>
</div>
<div class="post-text" itemprop="text">
<p>A simple approach: Convert to strings and rely on string matching.</p>
<p>Example using lists of strings:</p>
<pre><code> &gt;&gt;&gt; f = ["foo", "bar", "baz"]
 &gt;&gt;&gt; g = ["foo", "bar"]
 &gt;&gt;&gt; ff = str(f).strip("[]")
 &gt;&gt;&gt; gg = str(g).strip("[]")
 &gt;&gt;&gt; gg in ff
 True
</code></pre>
<p>Example using tuples of strings:</p>
<pre><code>&gt;&gt;&gt; x = ("foo", "bar", "baz")
&gt;&gt;&gt; y = ("bar", "baz")
&gt;&gt;&gt; xx = str(x).strip("()")
&gt;&gt;&gt; yy = str(y).strip("()")
&gt;&gt;&gt; yy in xx
True
</code></pre>
<p>Example using lists of numbers:</p>
<pre><code>&gt;&gt;&gt; f = [1 , 2, 3, 4, 5, 6, 7]
&gt;&gt;&gt; g = [4, 5, 6]
&gt;&gt;&gt; ff = str(f).strip("[]")
&gt;&gt;&gt; gg = str(g).strip("[]")
&gt;&gt;&gt; gg in ff
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; def seq_in_seq(subseq, seq):
...     while subseq[0] in seq:
...         index = seq.index(subseq[0])
...         if subseq == seq[index:index + len(subseq)]:
...             return index
...         else:
...             seq = seq[index + 1:]
...     else:
...         return -1
... 
&gt;&gt;&gt; seq_in_seq([5,6], [4,'a',3,5,6])
3
&gt;&gt;&gt; seq_in_seq([5,7], [4,'a',3,5,6])
-1
</code></pre>
<p>Sorry I'm not an algorithm expert, it's just the fastest thing my mind can think about at the moment, at least I think it looks nice (to me) and I had fun coding it. ;-)</p>
<p>Most probably it's the same thing your brute force approach is doing.</p>
</div>
<div class="post-text" itemprop="text">
<p>Brute force may be fine for small patterns.</p>
<p>For larger ones, look at the <a href="http://en.wikipedia.org/wiki/Aho-Corasick_algorithm" rel="nofollow noreferrer">Aho-Corasick algorithm</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another KMP implementation:</p>
<pre><code>from itertools import tee

def seq_in_seq(seq1,seq2):
    '''
    Return the index where seq1 appears in seq2, or -1 if 
    seq1 is not in seq2, using the Knuth-Morris-Pratt algorithm

    based heavily on code by Neale Pickett &lt;neale@woozle.org&gt;
    found at:  woozle.org/~neale/src/python/kmp.py

    &gt;&gt;&gt; seq_in_seq(range(3),range(5))
    0
    &gt;&gt;&gt; seq_in_seq(range(3)[-1:],range(5))
    2
    &gt;&gt;&gt;seq_in_seq(range(6),range(5))
    -1
    '''
    def compute_prefix_function(p):
        m = len(p)
        pi = [0] * m
        k = 0
        for q in xrange(1, m):
            while k &gt; 0 and p[k] != p[q]:
                k = pi[k - 1]
            if p[k] == p[q]:
                k = k + 1
            pi[q] = k
        return pi

    t,p = list(tee(seq2)[0]), list(tee(seq1)[0])
    m,n = len(p),len(t)
    pi = compute_prefix_function(p)
    q = 0
    for i in range(n):
        while q &gt; 0 and p[q] != t[i]:
            q = pi[q - 1]
        if p[q] == t[i]:
            q = q + 1
        if q == m:
            return i - m + 1
    return -1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm a bit late to the party, but here's something simple using strings:</p>
<pre><code>&gt;&gt;&gt; def seq_in_seq(sub, full):
...     f = ''.join([repr(d) for d in full]).replace("'", "")
...     s = ''.join([repr(d) for d in sub]).replace("'", "")
...     #return f.find(s) #&lt;-- not reliable for finding indices in all cases
...     return s in f
...
&gt;&gt;&gt; seq_in_seq([5,6], [4,'a',3,5,6])
True
&gt;&gt;&gt; seq_in_seq([5,7], [4,'a',3,5,6])
False
&gt;&gt;&gt; seq_in_seq([4,'abc',33], [4,'abc',33,5,6])
True
</code></pre>
<p><br/>
As noted by <strong>Ilya V. Schurov</strong>, the <strong>find</strong> method in this case will not return the correct indices with multi-character strings or multi-digit numbers.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach, using sets:</p>
<pre><code>set([5,6])== set([5,6])&amp;set([4,'a',3,5,6])
True
</code></pre>
</div>
<span class="comment-copy">Note that the KMP implementation given on code.activestate was demostrably slower by 30-500 times for some (perhaps unrepresentative input). Benchmarking to see if dumb built-in methods outperform seems to be a good idea!</span>
<span class="comment-copy">KMP is known to be about twice as slow as the naive algorithm in practice. Hence, for most purposes itâ€™s <i>completely</i> inappropriate, despite its good asymptotic worst-case runtime.</span>
<span class="comment-copy">I like it! For quick &amp; dirty stuff, anyway. Generally:  <code>def is_in(seq1, seq2):     return str(list(seq1))[1:-1] in str(list(seq2))[1:-1]</code>  Not a good way to find the index of the match, I guess.</span>
<span class="comment-copy">It is nice an clean, but brute-forcy --&gt;  O(mn)</span>
<span class="comment-copy">Aho-Corasick would be great.  I'm specifically looking for python, or pythonish solutions... so if there were an implementation, that would be great.  I'll poke around.</span>
<span class="comment-copy">The <code>tee</code> calls don't seem to be good for anything since the other element in tee's output 2-tuple is ignored. <code>seq1</code> and <code>seq2</code> are each copied to two new generators, one of which gets instantiated into a list, and the other of which gets ignored.</span>
<span class="comment-copy">This solution is not reliable in case elements of sequences have non-unique lenghs: it become not obvious how to translate index returned to index in initial sequences. Note also that backtick for <code>`d`</code> syntax is deprecated as for Python 3 and discouraged.</span>
<span class="comment-copy">example of non reliability even with all same sizes : sub='ab', full='aa','bb'</span>
<span class="comment-copy">Merely finds out whether the set is a subset of the sequence. Not whether it's actually in that order in the sequence. <code>set([5,6])== set([5,6])&amp;set([4,'a',5,4,6])</code> returns <code>True</code></span>
<span class="comment-copy">that could be a first, fast test however : check that all elements are in the full list.</span>
