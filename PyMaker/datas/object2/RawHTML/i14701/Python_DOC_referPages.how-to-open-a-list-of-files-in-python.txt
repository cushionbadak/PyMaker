<div class="post-text" itemprop="text">
<p>I'm reading  data file (text), and generating a number of reports, each one is written to a different output file (also text).  I'm opening them the long way:</p>
<p><code>fP = open('file1','w')</code></p>
<p><code>invP = open('inventory','w')</code></p>
<p><code>orderP = open('orders','w')</code></p>
<p>... and so on, with a corresponding group of close() lines at the end.</p>
<p>If I could open them with a for loop, using a list of fP names and file names, I could guarantee closing the same files.</p>
<p>I tried using a dictionary of <code>fp:filename</code>, but that [obviously] didn't work, because either the fP variable is undefined, or a string 'fP' isn't a good file object name.</p>
<p>Since these are output files, I probably don't need to check for open errors - if I can't open one or more, I can't go on anyway.</p>
<p>Is there any way to open a group of files (not more than 10 or so) from a list of names, in a loop?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can use a list comprehension:</p>
<pre><code>filenames = ['file1.txt', 'file2.txt', 'file3.txt'...]
filedata = {filename: open(filename, 'w') for filename in filenames}
</code></pre>
<p>Now, all of the opened instances are saved in <code>filedata</code>, assigned to the name of the file.</p>
<p>To close them:</p>
<pre><code>for file in filedata.values():
    file.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Good news! Python 3.3 brings in a standard safe way to do this: </p>
<h2><a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow noreferrer">contextlib.ExitStack</a></h2>
<p>From the docs:</p>
<blockquote>
<p>Each instance maintains a stack of registered callbacks that are called in reverse order when the instance is closed.<br/>
  (...)<br/>
  Since registered callbacks are invoked in the reverse order of registration, <strong>this ends up behaving as if multiple nested <code>with</code> statements had been used</strong> with the registered set of callbacks.</p>
</blockquote>
<p>Here's an example how to use it:</p>
<pre><code>from contextlib import ExitStack

with ExitStack() as stack:
    files = [
        stack.enter_context(open(filename))
        for filename in filenames
    ]
    # ... use files ...
</code></pre>
<p>When the code leaves the <code>with</code> statement, all files that have already been opened will be closed.</p>
<p>This way you also know that if 2 files get opened and then third file fails to open, the two already-opened files will be closed correctly. Also if an exception is raised anytime inside the <code>with</code> block, you'll see correct cleanup.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you are saying there are many data files.Instead of entering filenames manually into a list.You can get the filenames into a list with this.</p>
<pre><code>from os import listdir
from os.path import isfile, join
files_in_dir = [ f for f in listdir('/home/cam/Desktop') if isfile(join('/home/cam/Desktop',f)) ]
</code></pre>
<p>Now you can </p>
<pre><code>for file in files_in_dir:
    with open(file, 'w') as f:
        f.do_something
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://effbot.org/zone/python-with-statement.htm" rel="nofollow"><code>with</code> keyword</a> to guarantee that opened files (and other similar resources, known as "context managers") are closed:</p>
<pre><code>with open(file_path, 'w') as output_file:
    output_file.write('whatever')
</code></pre>
<p>Upon exiting the <code>with</code> block, the file will be properly closed -- even if an exception occurs.</p>
<p>You could easily loop over a list of paths to the desired files:</p>
<pre><code>files = ['fp1.txt', 'inventory', 'orders']
for file in files:
    with open(file, 'w') as current_file:
        current_file.do_some_stuff()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can open as many files as you want and keep them in a list to close them later:</p>
<pre><code>fds = [open(path, 'w') for path in paths]

# ... do stuff with files

# close files
for fd in fds:
    fd.close()
</code></pre>
<p>Or you could use a dictionary for better readability:</p>
<pre><code># map each file name to a file descriptor
files = {path: open(path, 'w') for path in paths}

# use file descriptors through the mapping
files['inventory'].write("Something")

# close files
for path in files:
    files[path].close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Both answers above are good if you know or define ahead of time the list of files you will want to create. But, in case you want a more generic solution, you can build that list just in time, use your OS to create empty files on disk (this is done different ways depending on the OS you are), then create the list of files interactively this way:</p>
<pre><code>import os
working_folder = input("Enter full path for the working folder/directory: ")
os.chdir(working_folder)
filenames_list = os.listdir()

#you can filter too, if you need so:
#filenames_list = [filename for filename in os.listdir() if '.txt' in filename]

#then you can do as Reut Sharabani and A.J. suggest above and make a list of file descriptors
file_descriptors = [open(filename, 'w') for filename in filenames_list]
#or a dictionary as Reut Sharabani suggests (I liked that one Reut :)

#do whatever you need to do with all those files already opened for writing

#then close the files
for fd in file_descriptors:
   fd.close()
</code></pre>
<p>It is ok to use "with"; as some suggest, if you work with only one file at the time (from start to finish), but if you want to work with all the files at the same time, it is better a list or dictionary of file descriptors.</p>
</div>
<span class="comment-copy">I had the right idea: a dictionary, but I didn't think that the file pointer object could be of the form <code>filedata[filename]</code> - which isn't really a symbol like <code>filepointer</code>.</span>
<span class="comment-copy">This approach also needs a <code>try/finally</code> around everything, to make sure you close the open files if there's an exception or early exit somewhere.</span>
