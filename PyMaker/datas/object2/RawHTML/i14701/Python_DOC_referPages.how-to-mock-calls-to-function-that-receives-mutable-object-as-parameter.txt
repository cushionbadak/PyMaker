<div class="post-text" itemprop="text">
<p>Consider example:</p>
<pre><code>def func_b(a):
    print a

def func_a():
    a = [-1]
    for i in xrange(0, 2):
        a[0] = i
        func_b(a)
</code></pre>
<p>And test function that tries to test func_a and mocks func_b:</p>
<pre><code>import mock
from mock import call

def test_a():
    from dataTransform.test import func_a
    with mock.patch('dataTransform.test.func_b', autospec=True) as func_b_mock:
        func_a()
        func_b_mock.assert_has_calls([call(0), call(1)])
</code></pre>
<p>After func_a has executed I try to test if func_a made correct calls to func_b, but since in for loop I am mutating list in the end I get:</p>
<pre><code>AssertionError: Calls not found.
Expected: [call(0), call(1)]
Actual: [call([1]), call([1])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following works (the importing <code>mock</code> from <code>unittest</code> is a Python 3 thing, and <code>module</code> is where <code>func_a</code> and <code>func_b</code> are):</p>
<pre><code>import mock
from mock import call
import copy

class ModifiedMagicMock(mock.MagicMock):
    def _mock_call(_mock_self, *args, **kwargs):
        return super(ModifiedMagicMock, _mock_self)._mock_call(*copy.deepcopy(args), **copy.deepcopy(kwargs))
</code></pre>
<p>This inherits from <code>MagicMock</code>, and redefines the call behaviour to deepcopy the arguments and keyword arguments.</p>
<pre><code>def test_a():
    from module import func_a
    with mock.patch('module.func_b', new_callable=ModifiedMagicMock) as func_b_mock:
        func_a()
        func_b_mock.assert_has_calls([call([0]), call([1])])
</code></pre>
<p>You can pass the new class into <code>patch</code> using the <code>new_callable</code> parameter, however it cannot co-exist with <code>autospec</code>. Note that your function calls <code>func_b</code> with a list, so <code>call(0), call(1)</code> has to be changed to <code>call([0]), call([1])</code>. When run by calling <code>test_a</code>, this does nothing (passes).</p>
<p>Now we cannot use both <code>new_callable</code> and <code>autospec</code> because <code>new_callable</code> is a generic factory but in our case is just a <code>MagicMock</code> override. But <a href="https://docs.python.org/3/library/unittest.mock.html#autospeccing" rel="nofollow">Autospeccing</a> is a very cool <code>mock</code>'s feature, we don't want lose it.</p>
<p>What we need is replace <code>MagicMock</code> by <code>ModifiedMagicMock</code> just for our test: we want avoid to change <code>MagicMock</code> behavior for all tests... could be dangerous. We already have a tool to do it and it is <code>patch</code>, used with the <code>new</code> argument to replace the destination.</p>
<p>In this case we use decorators to avoid too much indentation and make it more readable: </p>
<pre><code>@mock.patch('module.func_b', autospec=True)
@mock.patch("mock.MagicMock", new=ModifiedMagicMock)
def test_a(func_b_mock):
    from module import func_a
    func_a()
    func_b_mock.assert_has_calls([call([0]), call([1])])
</code></pre>
<p>Or:</p>
<pre><code>@mock.patch("mock.MagicMock", new=ModifiedMagicMock)
def test_a():
    with mock.patch('module.func_b') as func_b_mock:
        from module import func_a
        func_a()
        func_b_mock.assert_has_calls([call([0]), call([1])])
</code></pre>
</div>
<span class="comment-copy">Your mock of <code>func_b()</code> will need to make copies or otherwise untouchable representations of the argument it gets.  Then you can later check these copies for their values.</span>
<span class="comment-copy">Thanks! One thing to mention that in python 2.7 call to parent function would look like:          return super(ModifiedMagicMock, _mock_self)._mock_call(*copy.deepcopy(args), **kwargs)</span>
<span class="comment-copy">Sorry, I forget it... And I wrote an answer about that some months agoâ˜º.</span>
<span class="comment-copy">I know a way to solve this leak. If you are agree I can edit your answer again, otherwise I can file a new answer to cover it. I hate to lose autospec feature.</span>
<span class="comment-copy">@matsjoyce Can I use decorators instead of with statements... it is more redable.</span>
<span class="comment-copy">@Micheled'Amico Thanks. For some reason (mocking being clever), it only worked when I reversed the order of the decorators. I added a half <code>with</code> half decorator version, just in case the implementation of mocking changes.</span>
