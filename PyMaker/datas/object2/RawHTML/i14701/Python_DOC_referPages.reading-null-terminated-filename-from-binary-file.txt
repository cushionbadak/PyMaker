<div class="post-text" itemprop="text">
<p>In C, I could read an "at most 16 characters" filename which is null-terminated, simply by reading it into a small buffer:</p>
<pre><code>FILE *fp = fopen("file.bin", "rb");
char filename[16];
fread(filename, 1, 16, fp);
</code></pre>
<p>But in my Python approach, I have resorted to actually stripping away the null characters and converting it to ASCII even though the characters might not actually be ASCII only, because it seems <code>open()</code> doesn't accept <code>b''</code> strings, which might have been the result if I used <code>decode("utf-8")</code> in my code instead.</p>
<pre><code>def read_filename(f):
    return f.read(16).rstrip(b"\0").decode("ascii")
</code></pre>
<p>Is there a more "standard" way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You have binary data with embedded ASCII data, so your method is correct. </p>
<p>Python strings are not C strings. That the data is NULL-terminated makes no difference in Python and the standard library has no methods to read such data, strip the NULL bytes and decode the data like you've done.</p>
<p>The <a href="https://docs.python.org/3/library/struct.html" rel="nofollow"><code>struct</code> module</a> does support <em>writing</em> null-terminated strings (<code>16s</code> in a <code>struct.pack()</code> call will pad the output string with nulls to make up the required length) but on reading the nulls are left in place.</p>
</div>
