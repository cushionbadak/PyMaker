<div class="post-text" itemprop="text">
<p>I'd like to combine (zip?) two python lists of tuples, but matching on a key.</p>
<p>e.g. I'd like to create a function that takes two input lists and produces an output like this:</p>
<pre><code>lst1 = [(0, 1.1), (1, 1.2), (2, 1.3),           (5, 2.5)]
lst2 = [          (1, 4.5), (2, 3.4), (4, 2.3), (5, 3.2)]

desiredOutput = [(1, 1.2, 4.5), (2, 1.3, 3.4), (5, 2.5, 3.2)]
</code></pre>
<p>I could do it very messily and manually with loops, but I figure there must be some <code>itertools</code> / zipping functions that will greatly simplify this.</p>
<p>I'm sure the answer is out there and obvious, I just don't have the right termonology to search for it.</p>
<p>==</p>
<p>(( For what it's worth, here's my naive solution.  I'm hoping to find something neater / more pythonic:</p>
<pre><code>def key_zipper(lst1, lst2):    
    dict1 = dict(lst1)
    dict2 = dict(lst2)

    intersectKeys = [k for k in dict1.keys() if k in dict2.keys()]

    output = []

    for key in intersectKeys:
        output.append((key, dict1[key], dict2[key]))

    return output
</code></pre>
<p>Thanks ))</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; [(i, a, b) for i, a in lst1 for j, b in lst2 if i==j]
[(1, 1.2, 4.5), (2, 1.3, 3.4), (5, 2.5, 3.2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Still a bit messy, but works:</p>
<pre><code>def combine(lst1, lst2):
  d2 = dict(lst2)
  return [(k, v, d2[k]) for (k, v) in lst1 if k in d2]
</code></pre>
<p><strong>Update</strong>:</p>
<p>If I'd actually use this in production code, I'd refactor a little bit:</p>
<pre><code>def dict_intersection(d1, d2):
    return [(k,v,d2[k]) for (k,v) in d1.items() if k in d2]
</code></pre>
<p>and then In your case, I'd call</p>
<pre><code>lst1 = [(0, 1.1), (1, 1.2), (2, 1.3), (5, 2.5)]
lst2 = [(1, 4.5), (2, 3.4), (4, 2.3), (5, 3.2)]
common = dict_intersection(dict(lst1), dict(lst2))
</code></pre>
<p>@Vincent's answer is a good variation, too.</p>
</div>
<div class="post-text" itemprop="text">
<p>Convert the second list to a dictionary then you can check if the key is present without iterating the entire second list:</p>
<pre><code>def func(lst1,lst2):
    d2 = dict(lst2)
    return [(k,a,d2[k]) for (k,a) in lst1 if d2.has_key(k) ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A solution using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a> and <a href="https://docs.python.org/3/library/heapq.html#heapq.merge" rel="nofollow"><code>heapq.merge</code></a>:</p>
<pre><code>from itertools import groupby
from heapq import merge
from operator import itemgetter

def key_zipper(*lst):
    for k, v in groupby(merge(*lst), itemgetter(0)):
        yield (k,) + tuple(map(itemgetter(1), v))

lst1 = [(0, 1.1), (1, 1.2), (2, 1.3),           (5, 2.5)]
lst2 = [          (1, 4.5), (2, 3.4), (4, 2.3), (5, 3.2)]
print(list(key_zipper(lst1, lst2)))
# [(0, 1.1), (1, 1.2, 4.5), (2, 1.3, 3.4), (4, 2.3), (5, 2.5, 3.2)]
</code></pre>
<p><code>merge</code> and <code>groupby</code> both need their input to be sorted. If you list are not always sorted, then you'd need to make sure to do so:</p>
<pre><code>def key_zipper(*lst):
    for k, v in groupby(merge(*map(sorted, lst)), itemgetter(0)):
        yield (k,) + tuple(map(itemgetter(1), v))
</code></pre>
<p>This has the advantage that it works with an arbitrary number of input lists, and has a better runtime for large lists.</p>
<p>Note that here I've written it as a generator yielding tuples instead of a function returning a list of tuples, but converting that into a list is trivial.</p>
</div>
<span class="comment-copy">Do the sub elements in the output need to be tuples? It would be much easier with lists.</span>
<span class="comment-copy">@DanielRoseman if you can do this with lists, I could certainly work with that.</span>
<span class="comment-copy">I wasn't aware of the list comprehension with multiple <code>for</code>s - I think I like it</span>
<span class="comment-copy">@jlb83 For the sake of efficiency, it's best to avoid nested <code>for</code> loops, when practical; and as the other answers here show in this case it <i>is</i> possible to avoid them. An n length loop in an m length loop is O(n*m); the non-nested algorithms are O(n+m). Obviously there are big savings even for modest values of n &amp; m.</span>
<span class="comment-copy">Thanks - this is a much more concise version of my effort (which I've just posted in the question)</span>
<span class="comment-copy">That's better than my answer from a complexity point of view, because of the dictionary lookup <code>if k in d2</code>. Also you can use <code>[(k, v, d2[k]) for k, v in d1.items() if k in d2]</code> to save a lookup.</span>
<span class="comment-copy">You also don't need d1 at all.</span>
