<div class="post-text" itemprop="text">
<p>The objective is to do calculations on a single <code>iter</code> in <em>parallel</em> using <strong><code>builtin</code></strong> <code>sum &amp; map</code> functions <strong>concurrently</strong>.  Maybe using (something like) <code>itertools</code> instead of classic <code>for loops</code> to analyze (LARGE) data that arrives via an <code>iterator</code>...</p>
<p>In one simple <em>example</em> case I want to calculate <code>ilen, sum_x &amp; sum_x_sq</code>:</p>
<pre><code>ilen,sum_x,sum_x_sq=iterlen(iter),sum(iter),sum(map(lambda x:x*x, iter))
</code></pre>
<p>But without converting the <em>(large)</em> <code>iter</code> to a <code>list</code> (as with <code>iter=list(iter)</code>)</p>
<p>n.b. Do this using <code>sum &amp; map</code> and without <code>for loops</code>, maybe using the <code>itertools</code> and/or <code>threading</code> modules? </p>
<pre><code>def example_large_data(n=100000000, mean=0, std_dev=1):
  for i in range(n): yield random.gauss(mean,std_dev)
</code></pre>
<p>-- edit --</p>
<p>Being VERY specific: I was taking a good look at <code>itertools</code> hoping that there was a dual function like <code>map</code> that could do it. For example: <code>len_x,sum_x,sum_x_sq=itertools.iterfork(iter_x,iterlen,sum,sum_sq)</code></p>
<p>If I was to be very very specific:  I am looking for just one answer, python source code for the "<code>iterfork</code>" procedure.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.tee</code> to turn your single iterator into three iterators which you can pass to your three functions.</p>
<pre><code>iter0, iter1, iter2 = itertools.tee(input_iter, 3)
ilen, sum_x, sum_x_sq = count(iter0),sum(iter1),sum(map(lambda x:x*x, iter2))
</code></pre>
<p>That <em>will</em> work, but the builtin function <code>sum</code> (and <code>map</code> in Python 2) is not implemented in a way that supports parallel iteration. The first function you call will consume its iterator completely, then the second one will consume the second iterator, then the third function will consume the third iterator. Since <code>tee</code> has to store the values seen by one of its output iterators but not all of the others, this is essentially the same as creating a list from the iterator and passing it to each function.</p>
<p>Now, if you use generator functions that consume only a single value from their input for each value they output, you might be able to make parallel iteration work using <code>zip</code>. In Python 3, <code>map</code> and <code>zip</code> are both generators. The question is how to make <code>sum</code> into a generator.</p>
<p>I think you can get pretty much what you want by using <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow"><code>itertools.accumulate</code></a> (which was added in Python 3.2). It is a generator that yields a running sum of its input. Here's how you could make it work for your problem (I'm assuming your <code>count</code> function was supposed to be an iterator-friendly version of <code>len</code>):</p>
<pre><code>iter0, iter1, iter2 = itertools.tee(input_iter, 3)

len_gen = itertools.accumulate(map(lambda x: 1, iter0))
sum_gen = itertools.accumulate(iter1)
sum_sq_gen = itertools.accumulate(map(lambda x: x*x, iter2))

parallel_gen = zip(len_gen, sum_gen, sum_sq_gen)  # zip is a generator in Python 3

for ilen, sum_x, sum_x_sq in parallel_gen:
    pass    # the generators do all the work, so there's nothing for us to do here

# ilen_x, sum_x, sum_x_sq have the right values here!
</code></pre>
<p>If you're using Python 2, rather than 3, you'll have to write your own <code>accumulate</code> generator function (there's a pure Python implementation in the docs I linked above), and use <code>itertools.imap</code> and <code>itertools.izip</code> rather than the builtin <code>map</code> and <code>zip</code> functions.</p>
</div>
<span class="comment-copy">Closely related: <a href="http://stackoverflow.com/questions/21945732/consuming-two-iterators-in-parallel" title="consuming two iterators in parallel">stackoverflow.com/questions/21945732/â€¦</a></span>
<span class="comment-copy">What's the importance of using the built-in <code>sum</code> and <code>map</code>? Any solution is going to involve either enough runtime overhead that using those builtins has little performance impact, or enough C extension code that rewriting <code>sum</code> and <code>map</code> would be trivial in comparison.</span>
<span class="comment-copy">Agreed: Maybe it can only be done in threads, but I'm hoping not and there is some pythonic feature I have overlooked.  I was taking a good look at <code>itertools</code> hoping that there was a dual function like <code>map</code> that could do it.  For example: <code>len_x,sum_x,sum_x_sq=itertools.iterfork(iter_x,count,sum,sum_sq)</code> ... this issue has come up often enough that I feel like I need a pattern.</span>
<span class="comment-copy">Last I checked, threading is the only option that doesn't force you to rewrite the routines that consume the iterator. I tried to come up with a way to do it with coroutines, but Python's coroutines just aren't powerful enough. On the bright side, if you control the source code for the functions that need to consume the iterator, the amount of rewriting is quite minor, and you can keep the old API.</span>
<span class="comment-copy">Being VERY specific, I am looking for just one answer, python code for an "iterfork" procedure.</span>
<span class="comment-copy">This is a very good hint... I'll give it a spin.  ThanX</span>
