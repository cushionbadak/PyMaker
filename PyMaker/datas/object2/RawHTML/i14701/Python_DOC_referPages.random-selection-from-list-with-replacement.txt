<div class="post-text" itemprop="text">
<p>I have a list of lists, like so:</p>
<pre><code>a = [[1,2],[2,3]]
</code></pre>
<p>I want to create a random list <strong>with replacement</strong> of a given size from <code>a</code>. The <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html" rel="nofollow noreferrer"><code>numpy.random.choice()</code></a> method only accepts 1D arrays. I can write my own function to do this, but is there already an optimized way?</p>
<p><em>Expected output</em>:</p>
<pre><code>[[1,2],[1,2],[2,3],[2,3]] 
// the size (4 here) has to be a parameter passed to the function
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply call <a href="https://docs.python.org/3/library/random.html#random.choice" rel="noreferrer">the standard library's <code>random.choice()</code></a> repeatedly. No need for <code>numpy</code>.</p>
<pre><code>&gt;&gt;&gt; list_of_lists = [[1, 2], [2, 3]]
&gt;&gt;&gt; sample_size = 4
&gt;&gt;&gt; [random.choice(list_of_lists) for _ in range(sample_size)]
[[1, 2], [2, 3], [1, 2], [1, 2]]
</code></pre>
<p>This is an alternative to <a href="https://docs.python.org/3/library/random.html#random.sample" rel="noreferrer"><code>random.sample()</code></a> that works without replacement and lets you choose a “sample” larger than the size of the original population.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using numpy:</p>
<pre><code>size = 4
a = np.array([[1,2],[2,3]])
b = np.random.randint(len(a), size = size)
a[b,:]

Out[93]:
array([[2, 3],
       [2, 3],
       [2, 3],
       [1, 2]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.6, you can directly use <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices</code></a>.</p>
<pre><code>random.choices(list_of_lists, k=sample_size)
## [[1, 2], [3, 4], [3, 4], [1, 2]]
</code></pre>
<p>A rough benchmark suggests this seems to be more performant on varying sample sizes than the list comprehension approach. </p>
<pre><code>&gt;&gt;&gt; list_of_lists = [[1, 2], [3, 4]]
&gt;&gt;&gt; sample_size = 4

&gt;&gt;&gt; %timeit [random.choice(list_of_lists) for _ in range(sample_size)]
<b>4.49 µs ± 20.9 ns per loop</b> (mean ± std. dev. of 7 runs, 100000 loops each)

&gt;&gt;&gt; %timeit random.choices(list_of_lists, k=sample_size)
<b>1.99 µs ± 14.1 ns per loop</b> (mean ± std. dev. of 7 runs, 100000 loops each)

&gt;&gt;&gt; list_of_lists *= 100
&gt;&gt;&gt; sample_size *= 1000

&gt;&gt;&gt; %timeit [random.choice(list_of_lists) for _ in range(sample_size)]
<b>3.54 ms ± 28.7 µs per loop</b> (mean ± std. dev. of 7 runs, 100 loops each)

&gt;&gt;&gt; %timeit random.choices(list_of_lists, k=sample_size)
<b>927 µs ± 1.39 µs per loop</b> (mean ± std. dev. of 7 runs, 1000 loops each)</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> library implements <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.random_combination_with_replacement" rel="nofollow noreferrer"><code>more_itertools.random_combination_with_replacement</code></a>:</p>
<pre><code>import more_itertools as mit

list_of_lists = [[1, 2], [2, 3]]
sample_size = 4
list(mit.random_combination_with_replacement(list_of_lists, sample_size))
# [[1, 2], [1, 2], [2, 3], [2, 3]]
</code></pre>
</div>
<span class="comment-copy">Can you give an example of your expected output?</span>
<span class="comment-copy">Do you want a list of sublists, or a list of integers? If the latter, are the lists guaranteed to contain lists of integers, or is it possible that they may be nested deeper and shallower than two levels?</span>
<span class="comment-copy">@BrendanLong: I just added the expected output</span>
<span class="comment-copy">@BlacklightShining: I want a list of sublists</span>
