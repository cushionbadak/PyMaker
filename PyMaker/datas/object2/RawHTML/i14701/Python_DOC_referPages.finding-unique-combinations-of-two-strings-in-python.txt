<div class="post-text" itemprop="text">
<p>I have two strings:</p>
<pre><code>StringA: ['K', 'T', 'T', 'T', 'K', 'K', 'G', 'T', 'T', 'T', 'T', 'K', 'K']

StringB: ['T', 'K', 'G', 'G', 'K', 'T', 'T', 'K', 'G', 'G', 'K', 'K', 'T']
</code></pre>
<p>And I want to test for how many unique combinations of letters there are. The strings are ordered, so I only want to match <code>StringA</code> position 1 with <code>StringB</code> position 1, <code>StringA</code> position 2 with <code>StringB</code> position 2, etc. So the pairs in the strings above are <code>(KT), (TK), (TG), (TG), (KK), (KT), (GT), (TK), (TG), (TG), (TK), (KK), (KT)</code>.</p>
<p>And there are 5 unique combinations: <code>(KT), (TK), (TG), (GT), (KK)</code></p>
<p>I have used the following code to produce the strings from two .csv files.</p>
<pre><code>import sys
import csv

pairlist = open(sys.argv[1], 'r')
snp_file = open(sys.argv[2], 'r')

pair = csv.reader(pairlist, delimiter=',')
snps = csv.reader(snp_file, delimiter=',')

output = open(sys.argv[1]+"_FGT_Result", 'w')

snp1 = []
snp2 = []

firstpair = pair.next()

locusa = firstpair[0]
locusb = firstpair[1]

f = snps
        #search = snp.readlines()
for i, row in enumerate(f):
    if locusa in row:
        hita = row
        #print hita
        snp1.append(hita[2])
    if locusb in row:
        hitb = row
        #print hitb
        snp2.append(hitb[2])

print snp1
print snp2

pairlist.close()
snp_file.close()
output.close()
</code></pre>
<p>But I cannot figure out how to do the comparison. I have tried to convert the strings to sets, as I read in another thread, that this is required, but I am not sure why, and I cannot get it to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use <code>zip</code> and <code>set</code> to combine the two lists of strings and get unique combinations. I used a list comprehension to return combined strings:</p>
<pre><code>&gt;&gt;&gt; unique = [''.join(x)  for x in set(list(zip(StringA, StringB)))]
&gt;&gt;&gt; unique
['TG', 'GT', 'KT', 'TK', 'KK']
</code></pre>
<p>Alternatively, if you simply want them in a <code>set</code> you can remove the list comprehension:</p>
<pre><code>&gt;&gt;&gt; unique = set(zip(StringA, StringB))
&gt;&gt;&gt; unique
{('T', 'K'), ('T', 'G'), ('K', 'K'), ('K', 'T'), ('G', 'T')}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>snp1 = ['K', 'T', 'T', 'T', 'K', 'K', 'G', 'T', 'T', 'T', 'T', 'K', 'K']
snp2 = ['T', 'K', 'G', 'G', 'K', 'T', 'T', 'K', 'G', 'G', 'K', 'K', 'T']
combinations = []
for a,b in zip(snp1, snp2):
    combinations.append(a+b)         

print list(set(combinations))
</code></pre>
<p>output:<br/></p>
<pre><code>['KK', 'TG', 'GT', 'TK', 'KT']
</code></pre>
<p>Or a simple one liner would do:</p>
<pre><code>list(set([a+b for a,b in zip(snp1, snp2)]))
</code></pre>
<p>output:<br/></p>
<pre><code>['KK', 'TG', 'GT', 'TK', 'KT']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use use <code>zip</code> function and <code>set</code> to create the expected list :</p>
<pre><code>&gt;&gt;&gt; z=set(zip(a,b))
&gt;&gt;&gt; z
set([('T', 'G'), ('K', 'T'), ('T', 'K'), ('G', 'T'), ('K', 'K')])
</code></pre>
<p>then use <code>chain</code> and <code>combinations</code> functions from <a href="https://docs.python.org/2/library/itertools.html#module-itertools" rel="nofollow"><code>itertools</code></a> module for create the combinations  :</p>
<pre><code>&gt;&gt;&gt; a=['K', 'T', 'T', 'T', 'K', 'K', 'G', 'T', 'T', 'T', 'T', 'K', 'K']
&gt;&gt;&gt; b=['T', 'K', 'G', 'G', 'K', 'T', 'T', 'K', 'G', 'G', 'K', 'K', 'T']
&gt;&gt;&gt; from itertools import combinations,chain
&gt;&gt;&gt; z=[''.join(k) for k in set(zip(a,b))]
&gt;&gt;&gt; z
['TG', 'KT', 'TK', 'GT', 'KK']
&gt;&gt;&gt; list(chain.from_iterable(combinations(z, r) for r in range(len(z)+1)))
[(), ('TG',), ('KT',), ('TK',), ('GT',), ('KK',), ('TG', 'KT'), ('TG', 'TK'), ('TG', 'GT'), ('TG', 'KK'), ('KT', 'TK'), ('KT', 'GT'), ('KT', 'KK'), ('TK', 'GT'), ('TK', 'KK'), ('GT', 'KK'), ('TG', 'KT', 'TK'), ('TG', 'KT', 'GT'), ('TG', 'KT', 'KK'), ('TG', 'TK', 'GT'), ('TG', 'TK', 'KK'), ('TG', 'GT', 'KK'), ('KT', 'TK', 'GT'), ('KT', 'TK', 'KK'), ('KT', 'GT', 'KK'), ('TK', 'GT', 'KK'), ('TG', 'KT', 'TK', 'GT'), ('TG', 'KT', 'TK', 'KK'), ('TG', 'KT', 'GT', 'KK'), ('TG', 'TK', 'GT', 'KK'), ('KT', 'TK', 'GT', 'KK'), ('TG', 'KT', 'TK', 'GT', 'KK')]
</code></pre>
</div>
<span class="comment-copy">Look at the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip</a> function. That's half of what you need to do.</span>
