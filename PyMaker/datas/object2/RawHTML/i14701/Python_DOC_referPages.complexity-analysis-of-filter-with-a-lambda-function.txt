<div class="post-text" itemprop="text">
<p>Given two lists, <code>list1</code> and <code>list2</code></p>
<pre><code>list3 = filter(lambda x: x in list1,list2)
</code></pre>
<p>This returns the intersection of the two lists.</p>
<p>How can I find the complexity of this algorithm? I have found out that the time complexity of <code>x in list1</code> is <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow"><strong>O(n)</strong></a> where n is number of elements in the list, but how about the <code>filter</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code does <code>O(len(list1) * len(list2))</code> comparison operations for elements.</p>
<ul>
<li><p>Your lambda function is executed <code>O(len(list2))</code> times, once per each element filtered. <a href="https://docs.python.org/3/library/functions.html#filter" rel="noreferrer">See documentation for <code>filter</code> in Python 3</a> (<a href="https://docs.python.org/3/library/functions.html#filter" rel="noreferrer">Python 2</a>):</p>
<blockquote>
<p><code>filter(function, iterable)</code></p>
<p>Construct an <code>iterator</code> from <strong>those elements of <code>iterable</code> for which function returns true</strong>. <code>iterable</code> may be either a sequence, a container which supports iteration, or an iterator</p>
</blockquote>
<p>(emphasis mine)</p>
<p>Clearly the function is called at least 1 time for each (distinct) element in iterable - knowing when not to need call it would mean also solving <a href="http://en.wikipedia.org/wiki/Halting_problem" rel="noreferrer">the Halting problem in general case</a>, which not even the Python core developers are yet to solve ;-). In practice in CPython 3 the <a href="https://hg.python.org/cpython/file/eca51493c770/Python/bltinmodule.c#l380" rel="noreferrer"><code>filter</code> builtin</a> creates an iterator which when <a href="https://hg.python.org/cpython/file/eca51493c770/Python/bltinmodule.c#l428" rel="noreferrer">advanced</a>, executes the function once for each element (distinct or not) in the iteration order.</p></li>
<li><p>The <a href="https://wiki.python.org/moin/TimeComplexity" rel="noreferrer"><code>x in list1</code></a> does <code>O(len(list1))</code> comparisons in average and worst case, as documented.</p></li>
</ul>
<hr/>
<p>To speed it up, use a <code>set</code>; also you do not need a lambda function at all (use <code>__contains__</code> magic method)</p>
<pre><code>list3 = filter(set(list1).__contains__, list2)
</code></pre>
<p>This builds a <code>set</code> of the <code>list1</code> once in <code>O(len(list1))</code> time and runs the filter against it with <code>O(len(list2))</code> average complexity for <code>O(len(list1) + len(list2))</code></p>
<hr/>
<p>If the ordering of elements of <code>list2</code> <em>does not matter</em> then you can also do</p>
<pre><code>set(list1).intersection(list2)
</code></pre>
<p>which should have lower constants than doing the <code>filter</code> above; and for really fast code, you should order the lists so that the <em>smaller</em> is turned into a set (since both intersection and set building have documented average complexity of <code>O(n)</code>, but set building most probably will have larger constants due to resizing the <code>set</code>, thus it will make sense to build the set from the smaller to decrease the weight of these constants):</p>
<pre><code>smaller, larger = sorted([list1, list2], key=len)
result = set(smaller).intersection(larger)
</code></pre>
<hr/>
<p>Notice that Python 2 and 3 differ from each other. <code>filter</code> in Python 3 returns a generator, and the actual running time depends on the number of elements consumed from the resulting generator, whereas in Python 2 a list will be generated upfront, which might be more costly if you need only the first values.</p>
</div>
<div class="post-text" itemprop="text">
<p>The complexity could be <code>O(nm)</code> where <code>n</code> is the size of <code>list1</code> and <code>m</code> is the size of <code>list2</code>. However this analysis although plausible depends on the underlying python implementation of intersection (which might use sorting so the complexity could be <code>O(logn+logm)</code> or sth)</p>
<p>In order to experimentaly test this and verify the result, use this:</p>
<ol>
<li>generate variious test lists with varying items and sizes (including duplicates)</li>
<li>test the function with the test lists and <a href="https://stackoverflow.com/questions/5998245/get-current-time-in-milliseconds-in-python">measure the time taken</a></li>
<li>plot the results of time vs list sizes to verify the (exprimental) complexity</li>
</ol>
</div>
<span class="comment-copy">Do you know how to analyze computational complexity in general? If not, go learn to do that. If you do, what specific difficulties are you having with this exercise?</span>
<span class="comment-copy">How do you know the <code>filter</code> function's time complexity? Didn't manage to find it here: <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a></span>
<span class="comment-copy">@Controll: We know how it works - it iterates through the list, calling the given function on every element of the list to decide whether to keep that element in the new list - and that's enough to compute its complexity.</span>
<span class="comment-copy">Of course not. But that is how it works, the function is executed once per each element consumed from the argument.</span>
<span class="comment-copy">Is there any way to verify that this is the correct complexity analysis, some library which does that ?</span>
<span class="comment-copy">use <code>timeit.timeit</code> with different random inputs.</span>
<span class="comment-copy">It was stated that the two are <code>list</code>s, there is no doubt how it works. I posted an answer already, yours just adds to confusion</span>
<span class="comment-copy">@NikosM.: can I remind you of the code of conduct here (see the <a href="https://stackoverflow.com/help/behavior">help center</a>). Telling someone to get lost is <b>not</b> acceptable behaviour.</span>
<span class="comment-copy">The filter does not run in any other time than exactly <code>n</code> with n elements consumed; even if <code>list</code> <i>could</i> theoretically support fast membership tests in some alternative implementations of Python (it does not do in any that I know of), an alternative implementation could  <i>not</i> make <code>filter</code> to run in logarithmic time, so the <code>log m</code> could not happen.</span>
<span class="comment-copy">@AnttiHaapala, as the answer mentions, it involves testing the intersection functionbality. Of course filter will run for every elemtn in a list (already mentioned). The rst talk about the intersection functionality. Hope it is clear to everyone who can read. As far as implementations go, i do not know and i presume neither do you know the internals of python and all its used algorithms in every version. Even in this case the experimental test should manifext this and certainly clear any confusions</span>
<span class="comment-copy">All that you'll get in future is people downvoting <i>without</i> leaving feedback as they don't want to be drawn into discussions with you, if you continue to respond like you have. That's not going to help you improve those posts or learn from any mistakes you might make.</span>
