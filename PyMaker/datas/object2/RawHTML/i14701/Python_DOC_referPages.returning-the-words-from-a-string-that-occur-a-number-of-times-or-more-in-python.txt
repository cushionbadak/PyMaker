<div class="post-text" itemprop="text">
<p>I'm trying to write a function, <code>f(x, n)</code>, from scratch, that returns the words that occur an <code>n</code> number of times or more in a sorted list. </p>
<p>For example:</p>
<pre><code>f("the apple the banana the apple", 2)
&gt;&gt;&gt; ['apple', 'the']
</code></pre>
<p>since <code>the</code> and <code>apple</code> are the only words that occur two or more times</p>
<p>another example:</p>
<pre><code>f("the kid jumped off the roof", 1)
&gt;&gt;&gt; ['jumped', 'kid', 'off', 'roof', the']
</code></pre>
<p>What I've tried so far with no luck:</p>
<pre><code>def f(x, n):
   words = list(x.split())
   a= ""
   for word in words:
     if len(word) &gt;= n:
       a += word
         return(list(word))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This would iterate over the  items  present inside the  list generated after splitting and add the each item to the dictionary and it's count as <code>1</code> if the item is not exists already in that dictiornary. If the item is already exists, it would increase it's corresponding value by <code>1</code>. word acts like a key and the count acts like a value.</p>
<pre><code>def f(x, n):
    words = x.split()
    d = {}
    for word in words:
        if word in d:
            d[word] += 1
        else:
            d[word] = 1     
    print [i for i,j in d.items() if d[i] &gt;= n]        

f("the apple the banana the apple", 2)
</code></pre>
<p>Output:</p>
<pre><code>['the', 'apple']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem in the function you provide is that you're actually checking the <a href="https://docs.python.org/3/library/functions.html#len" rel="nofollow">length</a> of each word (by doing <code>if len(word)...</code>) instead of checking is frequency in the string. </p>
<p>You could simply use <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a> and a <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow"><code>list comprehension</code></a> like that:</p>
<pre><code>from collections import Counter

def f(string, n):
    count = Counter(string.split()).items()
    return [i for (i, j) in count if j &gt;= n]

print(f("the apple the banana the apple", 2))
</code></pre>
<p>Output:</p>
<pre><code>['apple', 'the']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>This is a working solution</strong>
<br/>Since you mentioned 'from scratch', I will write this code without importing any modules. <br/>
<strong><br/>Logic:</strong>
<br/>1.  Iterate through the list of words (only once) <strong>{O(n) complexity}</strong> and keep count of the number of occurrences using a dictionary. A dictionary is ideal because you can't have duplicates <br/>
<br/>2. Iterate through the dictionary once <strong>{O(n) complexity}</strong> and check to see if the value is greater than N -&gt; If so, append it to the list that will be returned (if not already in the list).</p>
<pre><code>  def N_duplicates(string, freq): #Get's input string and Frequency
    word_count={} #Dictionary is used to store word frequencies. 
    ret_lst=[] #returning list
    lst=string.split();

    for word in lst:
        if (word not in word_count):
            word_count[word]=1
        else:
            word_count[word]=word_count[word]+1;

    for item in word_count.keys():
        if (word_count[item]&gt;=freq):
            if (item not in ret_lst):
                ret_lst.append(item)

    return ret_lst;


print(N_duplicates("the kid jumped off the roof",1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3.4/library/collections.html#collections.Counter" rel="nofollow" title="Counter">Counter</a> is your friend on this one. Try something like this:</p>
<pre><code>from collections import Counter

def f(x, n):
   words = x.split()
   c = Counter(words)
   return [word for word, v in c.items() if v &gt;= n]
</code></pre>
<p>And then:</p>
<pre><code>&gt;&gt;&gt; print(f("the kid jumped off the roof", 1))
['the', 'kid', 'off', 'roof', 'jumped']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use string's <a href="https://docs.python.org/2/library/string.html#string.count" rel="nofollow">count</a> and <a href="https://docs.python.org/2/library/functions.html#func-set" rel="nofollow">set</a> built-in functions to achieve this:</p>
<pre><code>&gt;&gt;&gt; def f(x, n):
...     return sorted(set(s for s in x.split() if x.count(s) &gt;= n))
... 
&gt;&gt;&gt; s1 = "the apple the banana the apple"
&gt;&gt;&gt; s2 = "the kid jumped off the roof"
&gt;&gt;&gt; f(s1, 2)
['apple', 'the']
&gt;&gt;&gt; f(s2, 1)
['jumped', 'kid', 'off', 'roof', 'the']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I do like the Answers supplied here, but i was tempted to test the result difference between the <code>Counter()</code> and the <code>list()</code> variant, so i implemented both functions so they return a sorted array with the word and the number of counts combined so i can compare results better:</p>
<pre><code>from collections import Counter
# this is the Counter version returned sorted
def f(x,n): return sorted(["%s:%s" % (w,c) for w,c in Counter(x.split()).most_common() if c &gt;= n])
# this is the list version returned sorted
def g(x, n): return sorted(list(set("%s:%s" % (s, x.count(s)) for s in x.split() if x.count(s) &gt;= n)))
</code></pre>
<p>Now i fed both function with 500 Words of <a href="http://www.loremipsum.de" rel="nofollow">Lorem Ipsum</a> text. And i was astonished, that there actually where differences.</p>
<p>A bug, that both versions have in common, is that they don't take into considerations punctuation. So if i have <code>Apple</code> in the text, it is not the same word as <code>Apple,</code> or <code>Apple.</code> or <code>Apple!</code>, and so on. Where you could easily replace/remove all punctuation before counting words.</p>
<p>Also <code>Apple</code> is not the same as <code>apple</code> which could be as intended, but if not you would also have to <code>.lower()</code> the string.</p>
<p>But the biggest difference is the counting itself. Here actually the <code>list()</code> version fails, because it counts words, if they appear within another word it seams. So function <code>f()</code> counted <code>at</code> 8 times, which was correct, but function <code>g()</code> showed 38 counts - so obviously <code>x.count(s)</code> returns not only words, but also sub matches. too bad, that makes the <code>list()</code> version fail.</p>
<p>Trying this with an awkward sentence gave following result:</p>
<pre><code>&gt;&gt;&gt; print f("This test so nice, is like ice! Test... likely;",1)
['Test...:1', 'This:1', 'ice!:1', 'is:1', 'like:1', 'likely;:1', 'nice,:1', 'so:1', 'test:1']

&gt;&gt;&gt; print g("This test so nice, is like ice! Test... likely;",1)
['Test...:1', 'This:1', 'ice!:1', 'is:2', 'like:2', 'likely;:1', 'nice,:1', 'so:1', 'test:1']
</code></pre>
<p>Here you can see the behavior, and that the <code>list()</code> version actually counts <em>is</em> and <em>like</em> twice, because they are contained in <em>This</em> and <em>likely</em>.</p>
<p>So the winner is:</p>
<pre><code>from collections import Counter
# this is the Counter version but result returned sorted
def f(x,n): return sorted([w for w,c in Counter(x.split()).most_common() if c &gt;= n])
</code></pre>
<p>Now this still does not take into consideration upper/lower case and punctuation. If you want a result, as i would expect it, you could add the <code>string</code> module to give you the expected result:</p>
<pre><code>from collections import Counter
import string
# return correct result lowercase without punctuation and sorted
def f(x,n): return sorted([w for w,c in Counter(x.translate(None, string.punctuation).lower().split()).most_common() if c &gt;= n])
</code></pre>
<p>The <code>.translate(None, string.punctuation).lower()</code> does all the magic here and the result is:</p>
<pre><code>&gt;&gt;&gt; print f("This test so nice, is like ice! Test... likely;",1)
['ice', 'is', 'like', 'likely', 'nice', 'so', 'test', 'this']
</code></pre>
<p>Guys, i love one liner function :) But if python beginners are asking here, we should not so much pay attention to our preferences, but rather towards a code that gives a good insight into python and why things behave like they do, so regards to the chosen answer, readable for beginners!</p>
</div>
<span class="comment-copy">Can you use imported module functions or data objects for this? BTW, you haven't sorted your word list.</span>
<span class="comment-copy">I'd prefer a code from scratch as I'm still learning the basics of pythons. And thanks for that, I'll try fixing that up.</span>
<span class="comment-copy">Python is <i>all about</i> importing the right modules. Knowing the library is 95% of the work.</span>
<span class="comment-copy">Awesome! thank you! Just one more thing, how would I sort  it in this case? Do i use .sorted() or .sort()?</span>
<span class="comment-copy">sort will do an in-place sort where sorted will return a list after sorting. like <code>print sorted([i for i,j in d.items() if d[i] &gt;= n])</code></span>
<span class="comment-copy">Oh! I'll keep that in mind. Thanks again</span>
<span class="comment-copy">@AvinashRaj i love one-liners, but for a python beginner i appreciate your code being much more explanatory than the other samples. I did not test your function in my answer, because you posted later but you might consider removing punctuation and converting to lowercase as i explained in my answer</span>
<span class="comment-copy">I'm trying to make a function that would work for any string, similar to the examples I had.</span>
<span class="comment-copy">@Roger Please check my edit</span>
