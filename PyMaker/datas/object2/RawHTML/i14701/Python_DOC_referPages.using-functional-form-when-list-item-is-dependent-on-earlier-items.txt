<div class="post-text" itemprop="text">
<p>I have list of tuples which each tuple has length of element. I use following code to calculate offset of element depending on lengths of earlier elements.</p>
<pre><code>import pprint
recordInfo = [(3,), (4,), (1,), (2,)]  # List of lengths
# Calculate and add offsets
recordSize = 0
for index, info in enumerate(recordInfo):
    recordInfo[index] = info + ( recordSize, )  # Replace with new tuple with offset
    recordSize += info[0]  # Calculate next offset
pprint.pprint(recordInfo)
</code></pre>
<p>Output is </p>
<pre><code>[(3, 0), (4, 3), (1, 7), (2, 8)]
</code></pre>
<p>Is there a way to do the loop in functional form, like list comprehension? I cannot figure out how to avoid temporary variable <code>recordSize</code>, which makes it impossible?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not pretty, and it's not efficient, but here is a list comprehension that does what you requested:</p>
<pre><code>&gt;&gt;&gt; recordInfo = [(3,), (4,), (1,), (2,)]
&gt;&gt;&gt; [info + (sum(_info[0] for _info in recordInfo[:i]),)
         for i,info in enumerate(recordInfo)]
[(3, 0), (4, 3), (1, 7), (2, 8)]
</code></pre>
<p>It works by recalculating the offset up to the current item at each iteration, hence it's inefficient.</p>
<p>It works on both Python 2 &amp; 3.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; recordInfo = [3, 4, 1, 2]

&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; reduce(lambda x, y: x + [(y, sum(x[-1]))], recordInfo, [(0, 0)])[1:]
[(3, 0), (4, 3), (1, 7), (2, 8)]

&gt;&gt;&gt; from itertools import accumulate
&gt;&gt;&gt; list(zip(recordInfo, [0] + list(accumulate(recordInfo))))
[(3, 0), (4, 3), (1, 7), (2, 8)]
</code></pre>
<p>If you have tuples:</p>
<pre><code>&gt;&gt;&gt; recordInfo = [(3, 'a'), (4, 'b'), (1, 'c'), (2, 'd')]

&gt;&gt;&gt; reduce(lambda x, y: x + [y + (x[-1][0] + x[-1][-1], )], recordInfo, [(0, )])[1:]
[(3, 'a', 0), (4, 'b', 3), (1, 'c', 7), (2, 'd', 8)]

&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; [x + (c,) for x, c in zip(recordInfo, accumulate(map(itemgetter(0), [(0,)] + recordInfo)))]
[(3, 'a', 0), (4, 'b', 3), (1, 'c', 7), (2, 'd', 8)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Probably not what you meant by functional but hey, always fun.</p>
<pre><code>def increment_record(records, size=0):
     if not records:
         return []
     return [(records[0], size)] + increment_record(records[1:], size=size+records[0])
</code></pre>
<p>But yeah, I don't think this is really a pattern python allows a person to address in a manner without local state (unless of course you use a high level function like the aforementioned itertools.aggregate that just conceals the state). Of course, if you really needed to you could just define some sort of counting object (or use a closure).</p>
<pre><code>class Tallier(object):
     def __init__(self, val):
          self._val = val

     def tally(self, new_val):
          old_val = self._val
          self._val += new_val
          return old_val

[(val, tallier.tally(val)) for val in values]
</code></pre>
</div>
<span class="comment-copy">Are you on Python 2 or 3? Python 3 has <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate</code></a>, which perfectly solves your problem.</span>
<span class="comment-copy">@user2357112 Python 3.</span>
<span class="comment-copy">That is pretty nice actually. I hadn't thought of using <code>sum</code>.</span>
<span class="comment-copy">Does these work with tuples? In my real code tuples in <code>recordInfo</code> actually have more data before operation.</span>
<span class="comment-copy">Do you want to keep the original data and just append the accumulated value then?</span>
<span class="comment-copy">Kind of, yes. In original data each tuple has 3 fields, and after operation there is 4 fields in each tuple. I just removed 2 unrelated fields to keep my question simple.</span>
<span class="comment-copy">Edited my answer; but it’s getting quite messy now… :/</span>
<span class="comment-copy">Yes, not really what I meant. I want to avoid recursion.</span>
