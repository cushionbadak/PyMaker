<div class="post-text" itemprop="text">
<p>I have following Directory structure,</p>
<pre><code>F:\TestData
</code></pre>
<p>and TestData contains 20 folders with name <code>node1, node2,..., node20</code>
and each node folder contains file with names <code>log.10.X</code> </p>
<p>I need to access each log file from all node folders, For which I have writen code, but it is saying, <code>File not found - log.*</code></p>
<p>CODE:</p>
<pre><code>directory = "F:\TestData"
p = subprocess.Popen(["find", "./" + directory, "-name", "log.*"], stdout=subprocess.PIPE)
output, err = p.communicate()
foutput = output.split("\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python, unlike POSIX shells, does not automatically do globbing (interpreting <code>*</code> and the like as wildcards related to files in the relevant directory) in strings. It does, however, provide <a href="https://docs.python.org/3/library/glob.html" rel="nofollow">a <code>glob</code> module</a> for that purpose. You can use this to get a list of matching filenames:</p>
<pre><code>import glob

filenames = glob.glob(r'F:\TestData\node*\log.*')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just use python to get a list of files in the directory</p>
<pre><code>import os
directory = "F:\TestData\"
file_list = os.listdir(directory)
log_list = filter(lambda x: x.startswith("log"), file_list)
</code></pre>
<p>oh, you have to code to iterate sub directory. 
First <code>os.listdir()</code>in the parent directory ,and iterate the sub directory to get the files</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's glob module may be an option.</p>
<pre><code>import glob
directory = 'F:\TestData'
logcontents = [open(f,'r').read() for f in glob.glob(directory + '\node*\log.*')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You also use <code>walk</code>, like this:</p>
<pre><code>import os
directory = "F:\TestData"
for i in os.walk(directory):
    # i like this:
    # ('F:\\TestData', ['node1', 'node2', 'node3'], [])
    # ('F:\\TestData\\node1', [], ['log.1.txt'])
    # ('F:\\TestData\\node2', [], ['log.2.txt'])
    print i
    if i[2] != []:
        # TODO: use the path to finish other
        # If dictory noden have some log file, you should use i[2][n].
        # So, if you only need log.n.txt, you only use i[2][n].
        print os.path.join(i[0], i[2][0])
</code></pre>
</div>
<span class="comment-copy">It is showing small problem, it is giving correct paths but with extra backslash. Like I am getting F:\\TestData\\node1\\log.10.17.0.0 instead of F:\CRLOG1\node1\log.10.17.0.0</span>
<span class="comment-copy">If you are getting the <code>repr()</code>esentation of the strings (including using the interpreter without <code>print</code>), they will be surrounded in quotes and backslashes will be escaped (with another backslash).</span>
<span class="comment-copy">i did print <code>myrepr.repr(filenames)</code> it is showing same result. Is this what you were saying or did I understood it wrong? Sorry</span>
<span class="comment-copy">Noâ€”_don't_ print the representation. The representation of a string is what you would type into the interpreter to get the string, enclosing quotes, escape sequences and all. Just print the filename itself (e.g. <code>print filenames[0]</code>). Note that the representation and the string version of lists are the same, so <code>print filenames</code> and <code>print repr(filenames)</code> will also show the strings with enclosing quotes and escape sequences.</span>
<span class="comment-copy">ohh ok, Thanks!</span>
<span class="comment-copy">Double backslashes or a single forward slash!</span>
<span class="comment-copy">I would use <a href="https://www.python.org/dev/peps/pep-3132/#specification" rel="nofollow noreferrer">iterable unpacking</a> for the return value of <code>os.walk()</code>. Also, remember to filter out directories whose names do not begin with <code>'node'</code>.</span>
