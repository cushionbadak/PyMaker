<div class="post-text" itemprop="text">
<p>I have a dictionary in some code which maps a key to a word, the key is the result of an <code>md5</code> hash.  I have code that essentially wants to get the <code>key</code> for a <code>word</code>, and when it doesn't already exist, add it to the dictionary</p>
<p>Here was my first implementation:</p>
<pre><code>key = int(hashlib.md5(word).hexdigest(), 16)
if key in self.id_to_word.keys():
    assert word == self.id_to_word[key]
else:
    self.id_to_word[key] = word
return key
</code></pre>
<p>After profiling my code I found this to be EXTREMELY slow.  So then I tried this, which is functionally equivalent</p>
<pre><code>key = int(hashlib.md5(word).hexdigest(), 16)

try:
    assert word == self.id_to_word[key]
    return key
except KeyError:
    self.id_to_word[key] = word
</code></pre>
<p>This turned out to be incredibly faster.  While I'm certainly happy about the performance improvement, I was wondering if someone could explain to me why.  Is it bad practice to check for something in a <code>keys()</code> function from a dictionary like that?  Is it generating copies of that every time (wasting a lot of computation)?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>id_to_word.keys()</code> creates a new list, which is linearly searched, which is much slower than a hash lookup. Remove the <code>.keys()</code>.</p>
<p>The fastest way would be:</p>
<pre><code>key = int(hashlib.md5(word).hexdigest(), 16)
assert word == self.id_to_word.setdefault(key, word)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>key in some_dict</code> is much faster than <code>key in some_dict.keys()</code> </p>
<p>Dict Lookup <code>key in some_dict</code> is <code>O(1)</code> complexity so its very fast</p>
<p>that said its still (very marginally)slower in the case where the key is in the dict than just <code>try/except</code></p>
<p>the real answer is there is no real measurable difference between these 2 methods and do whatever feels right to you</p>
</div>
<div class="post-text" itemprop="text">
<p>This is to be expected (in python2). The <code>keys()</code> method returns a <strong>list</strong> of keys. So using the <code>in</code> operator on the list takes linear time. </p>
<p>Trying to access the item is constant time, which is much faster.</p>
<p>Note: you can simply use <code>key in dictionary</code> instead of the <code>try: ...except:</code>.</p>
<hr/>
<p>Note that dictionaries have a <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow"><code>setdefault</code></a> method that already does what you want. Moreover if you do that operation a lot of time you should consider using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a> instead of a plain dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Elaborating on my comments above:</p>
<pre><code>In [4]: d = {k:k for k in xrange(1000)}
In [5]: %timeit 50 in d
10000000 loops, best of 3: 68.6 ns per loop

In [6]: %timeit 50 in d.keys()
100000 loops, best of 3: 6.35 Âµs per loop
</code></pre>
<p>as you can see, using d.keys() is about 100 times slower.</p>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned <code>setdefault()</code> solves your problem without an <code>if</code> or <code>try</code> block.<br/>
But "Easier to Ask for Forgiveness than Permission" [EAFP] and duck-typing is a common idiom in Python, compared to the more defensive "Look Before You Leap" [LBYL] idiom common in other languages, e.g. Java, C++.</p>
<p>Jeff Knuth has an interesting blog post on it <a href="http://www.jeffknupp.com/blog/2013/02/06/write-cleaner-python-use-exceptions/" rel="nofollow">Write Clean Python: Use Exceptions</a></p>
</div>
<span class="comment-copy">can just do <code>key in some_dict</code>, don't have to use <code>.keys()</code></span>
<span class="comment-copy">Could you add the actual time results?</span>
<span class="comment-copy">.keys() creates a list of all the keys, and the <code>in</code> statement searches all those keys, an O(N) operation. <code>key in dict</code> is O(1) operation</span>
<span class="comment-copy">This discussion doesn't work for you: <a href="http://stackoverflow.com/q/1835756/349420">stackoverflow.com/q/1835756/349420</a> ?</span>
<span class="comment-copy">The only issue with this is that <code>assert</code> should not be used in production code.  <code>python -O</code> (the optimize flag) will remove an assert from code.  At that time, your code breaks.</span>
