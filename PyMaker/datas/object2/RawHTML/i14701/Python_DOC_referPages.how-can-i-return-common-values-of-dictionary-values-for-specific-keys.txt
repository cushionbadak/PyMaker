<div class="post-text" itemprop="text">
<p>I have a dictionary, which contains:</p>
<pre><code>{'Key': ['File1', 'File2']}
</code></pre>
<p>where <code>key</code> corresponds to a word and <code>files</code> are the set of files that contain that word.</p>
<p>Suppose I have a dictionary:</p>
<pre><code>{'banana': ['file1.txt', 'file2.txt', 'file3.txt'],
 'apple': ['file2.txt', 'file3.txt']}
</code></pre>
<p>and my query is <code>banana apple</code>. How do I compare values in such a way that I return only <code>file2.txt</code> and <code>file3.txt</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Iterate over the keys in the query and aggregate the result in a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow"><code>set</code></a>:</p>
<pre><code>data = {'banana' : ['file1.txt', 'file2.txt', 'file3.txt'],
        'apple' : ['file2.txt', 'file3.txt']}
query = "banana apple"

result = None
for key in (k for k in query.split() if k in data):
    if result is None:
        result = set(data[key])
    else:
        result &amp;= set(data[key])    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/2/library/stdtypes.html#set.intersection" rel="nofollow"><code>set.intersection</code></a> to create the common elements, like this</p>
<pre><code>&gt;&gt;&gt; d = {'banana': ['file1.txt', 'file2.txt', 'file3.txt'],
...      'apple': ['file2.txt', 'file3.txt']}
&gt;&gt;&gt; words = 'banana apple'
&gt;&gt;&gt; set.intersection(*(set(d[word]) for word in words.split() if word in d))
{'file2.txt', 'file3.txt'}
</code></pre>
<p>Here, we are creating a generator expression, which gets all the files corresponding to the word and converts that to a set. We then <a href="https://docs.python.org/2/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow">unpack</a> the genereator expression over the <code>set.intersection</code> function, which finds the set intersection of all the sets.</p>
<p><strong>Edit:</strong> If your values of the dictionary are really sets, as you mentioned in the question</p>
<blockquote>
<p>and files are the <strong>set</strong> of files that contain that word</p>
</blockquote>
<p>then, the solution can be even faster, since we don't have convert the lists to sets.  You can simply skip that and do</p>
<pre><code>&gt;&gt;&gt; set.intersection(*(d[word] for word in words.split() if word in d))
{'file2.txt', 'file3.txt'}
</code></pre>
<p><strong>Important Edit</strong></p>
<p>What if the dictionary had only <code>banana</code> and <code>apple</code> is not there and the input is <code>banana apple</code>? If you wanted to return an empty set in that case, then you just have to slightly modify the generator expression, like this</p>
<pre><code>&gt;&gt;&gt; set.intersection(*(set(d.get(word, set())) for word in words.split()))
{'file2.txt', 'file3.txt'}
</code></pre>
<p>Here, we use <code>dict.get</code> method to return a default value if the key is not found in the dictionary. So, if <code>apple</code> is not there in the dictionary, then we return an empty set which makes the result an empty set (because when you intersect any set with an empty set, the result will be an empty set).</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simple way, by constructing a mirror or reverse map of the given <code>dict</code>. The keys in this reverse dictionary, that have all the items in <code>query</code>, as their corresponding values would be what we want.</p>
<pre><code>d1 = {'banana': ['file1.txt', 'file2.txt', 'file3.txt'],
 'apple': ['file2.txt', 'file3.txt']}

d2 = {}
query = 'banana apple'
for (k, lst) in d1.items():
    for l in lst:
      d2.setdefault(l, []).append(k)
print filter(lambda y: all([x in d2[y] for x in query.split()]), d2.keys())
</code></pre>
</div>
<span class="comment-copy">Please explain <i>why</i> this query is supposed to give this result. Why is  <code>file1.txt</code> not in the result?</span>
<span class="comment-copy">@Tichodroma I want to display only the documents which contain both apple and banana, since file1.txt does not contain 'apple' it shouldn't be included in results</span>
<span class="comment-copy">What if the dictionary had only <code>banana</code> and <code>apple</code> is not there and the input is <code>banana apple</code>? What should be the result?</span>
<span class="comment-copy">Additionally, if the lists only serve to track which files contain the word, consider skipping the conversion to set step and just keep them in memory as a set. A set is in some way equivalent to a dictionary that has no values attached to the keys: it can only tell you if the (hashable) item is in there or not; you can add and remove items from sets; lookup is in amortized constant time (means it's fast no matter the size of the set) and there are some operations you can perform on sets, such as intersections: <code>set.intersection(s1, s2)</code>. When mixing a dict with a set, the dict ...</span>
<span class="comment-copy">... degrades nicely as a set of its keys. Example: <code>d=dict(a=1, b=2); s=set(['a', 'c']); s.intersection(d) -&gt; 'a'</code></span>
