<div class="post-text" itemprop="text">
<p>Is there a one-line expression for:</p>
<pre><code>for thing in generator:
    yield thing
</code></pre>
<p>I tried <code>yield generator</code> to no avail.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.3+, you can use <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="noreferrer"><code>yield from</code></a>. For example,</p>
<pre><code>&gt;&gt;&gt; def get_squares():
...     yield from (num ** 2 for num in range(10))
... 
&gt;&gt;&gt; list(get_squares())
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>It can actually be used with any iterable. For example,</p>
<pre><code>&gt;&gt;&gt; def get_numbers():
...     yield from range(10)
... 
&gt;&gt;&gt; list(get_numbers())
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; def get_squares():
...     yield from [num ** 2 for num in range(10)]
... 
&gt;&gt;&gt; list(get_squares())
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<hr/>
<p>Unfortunately, Python 2.7 has no equivalent construct :'(</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a list comprehension to get all of the elements out of a generator (assuming the generator ends):</p>
<pre><code>[x for x in generator]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a simple one-liner valid in Python 2.5+ as requested ;-):</p>
<pre><code>for thing in generator: yield thing
</code></pre>
</div>
<span class="comment-copy">Answer is <b>No</b> then.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/17581332/converting-yield-from-statement-to-python-2-7-code" title="converting yield from statement to python 2 7 code">stackoverflow.com/questions/17581332/â€¦</a> is related</span>
<span class="comment-copy">Would those who downvoted this question care to clarify? The question is perfectly clear, and if it is duplicate, you should've linked to the original.</span>
<span class="comment-copy">I don't think the helper function does exactly the same in Py2.7 as what <code>yield from</code> does in Py3.3. Calling this function just returns another generator object, so it is pretty similar to the built-in <code>iter</code>. If you call your <code>yield_from()</code> from within a function, this function will not automatically become a generator function, as will happen with <code>yield from</code>. As far as I <a href="https://www.python.org/dev/peps/pep-0380/#motivation" rel="nofollow noreferrer">understand</a>,  in Py2.7, you need to write the explicit for-loop as shown by the OP.</span>
<span class="comment-copy">@BasSwinckels Yup, the helper function is not the same. But, you can delegate the generator to that function and it would make the code simpler, no?</span>
<span class="comment-copy">No, I think the helper function is useless, since it does not yield from the calling function. As shown in the PEP, this <code>for i in generator: yield i</code> can not be factored out into a separate function. You just rewrote <code>iter</code> ... :)</span>
<span class="comment-copy">would this negate some of the lazy properties of generators, i.e. convert its output to a list?</span>
<span class="comment-copy">Absolutely.  By converting to a list you are allocating all of the memory necessary to warehouse the data "generated" by the generator.  Also, if the generator does not complete the above statement will never terminate.</span>
<span class="comment-copy">heavy cost for one-lining it....</span>
<span class="comment-copy">No, that's the heavy cost of converting a generator into a memory representation.  I would suggest considering <i>why</i> you're converting from a generator to a list; in most instances you don't want to force the generator to evaluate until necessary.</span>
<span class="comment-copy">you da real mvp</span>
