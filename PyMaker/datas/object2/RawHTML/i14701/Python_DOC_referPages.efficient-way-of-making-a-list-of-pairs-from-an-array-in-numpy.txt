<div class="post-text" itemprop="text">
<p>I have a <code>numpy</code> array <code>x</code> (with <code>(n,4)</code> shape) of integers like:</p>
<pre><code>[[0 1 2 3],
[1 2 7 9],
[2 1 5 2],
...]
</code></pre>
<p>I want to transform the array into an array of pairs:</p>
<pre><code>[0,1]
[0,2]
[0,3]
[1,2]
...
</code></pre>
<p>so first element makes a pair with other elements in the same sub-array. I have already a <code>for-loop</code> solution:</p>
<pre><code>y=np.array([[x[j,0],x[j,i]] for i in range(1,4) for j in range(0,n)],dtype=int)
</code></pre>
<p>but since looping over numpy array is not efficient, I tried <code>slicing</code> as the solution. I can do the slicing for every column as:</p>
<pre><code>y[1]=np.array([x[:,0],x[:,1]]).T
# [[0,1],[1,2],[2,1],...] 
</code></pre>
<p>I can repeat this for all columns. My questions are:</p>
<ol>
<li>How can I append <code>y[2]</code> to <code>y[1]</code>,... such that the shape is <code>(N,2)</code>?</li>
<li>If number of columns is not small (in this example <code>4</code>), how can I find <code>y[i]</code> elegantly?</li>
<li>What are the alternative ways to achieve the final array? </li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The cleanest way of doing this I can think of would be:</p>
<pre><code>&gt;&gt;&gt; x = np.arange(12).reshape(3, 4)
&gt;&gt;&gt; x
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
&gt;&gt;&gt; n = x.shape[1] - 1
&gt;&gt;&gt; y = np.repeat(x, (n,)+(1,)*n, axis=1)
&gt;&gt;&gt; y
array([[ 0,  0,  0,  1,  2,  3],
       [ 4,  4,  4,  5,  6,  7],
       [ 8,  8,  8,  9, 10, 11]])
&gt;&gt;&gt; y.reshape(-1, 2, n).transpose(0, 2, 1).reshape(-1, 2)
array([[ 0,  1],
       [ 0,  2],
       [ 0,  3],
       [ 4,  5],
       [ 4,  6],
       [ 4,  7],
       [ 8,  9],
       [ 8, 10],
       [ 8, 11]])
</code></pre>
<p>This will make two copies of the data, so it will not be the most efficient method. That would probably be something like:</p>
<pre><code>&gt;&gt;&gt; y = np.empty((x.shape[0], n, 2), dtype=x.dtype)
&gt;&gt;&gt; y[..., 0] = x[:, 0, None]
&gt;&gt;&gt; y[..., 1] = x[:, 1:]
&gt;&gt;&gt; y.shape = (-1, 2)
&gt;&gt;&gt; y
array([[ 0,  1],
       [ 0,  2],
       [ 0,  3],
       [ 4,  5],
       [ 4,  6],
       [ 4,  7],
       [ 8,  9],
       [ 8, 10],
       [ 8, 11]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Like <code>Jaimie</code>, I first tried a <code>repeat</code> of the 1st column followed by reshaping, but then decided it was simpler to make 2 intermediary arrays, and <code>hstack</code> them:</p>
<pre><code>x=np.array([[0,1,2,3],[1,2,7,9],[2,1,5,2]])
m,n=x.shape
x1=x[:,0].repeat(n-1)[:,None]
x2=x[:,1:].reshape(-1,1)
np.hstack([x1,x2])
</code></pre>
<p>producing</p>
<pre><code>array([[0, 1],
       [0, 2],
       [0, 3],
       [1, 2],
       [1, 7],
       [1, 9],
       [2, 1],
       [2, 5],
       [2, 2]])
</code></pre>
<p>There probably are other ways of doing this sort of rearrangement.  The result will copy the original data in one way or other.  My guess is that as long as you are using compiled functions like <code>reshape</code> and <code>repeat</code>, the time differences won't be significant.  </p>
</div>
<div class="post-text" itemprop="text">
<p>Suppose the <code>numpy</code> array is</p>
<pre><code>arr = np.array([[0, 1, 2, 3],
                [1, 2, 7, 9],
                [2, 1, 5, 2]])
</code></pre>
<p>You can get the array of pairs as</p>
<pre><code>import itertools
m, n = arr.shape
new_arr = np.array([x for i in range(m) 
                    for x in itertools.product(a[i, 0 : 1], a[i, 1 : n])])
</code></pre>
<p>The output would be</p>
<pre><code>array([[0, 1],
       [0, 2],
       [0, 3],
       [1, 2],
       [1, 7],
       [1, 9],
       [2, 1],
       [2, 5],
       [2, 2]])
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations()</code></a> may be useful here.</span>
<span class="comment-copy">@BlacklightShining: Not really. The pattern needed isn't actually combinations, though it might look that way at first due to poor choice of example data, and for NumPy, you want to avoid <code>itertools</code> about as much as you want to avoid loops and comprehensions.</span>
<span class="comment-copy">itertools is rarely the best answer to a numpy question...</span>
