<div class="post-text" itemprop="text">
<p>The built-in <code>int</code> takes two parameters:</p>
<pre><code>&gt;&gt;&gt; print(int.__doc__)
int(x=0) -&gt; integer
int(x, base=10) -&gt; integer

Convert a number or string to an integer, or return 0 if no arguments
...
</code></pre>
<p>However, (in CPython 3.4.0) <code>inspect.signature</code> shows 0:</p>
<pre><code>&gt;&gt;&gt; len(inspect.signature(int).parameters)
0
</code></pre>
<p>in contrast with a user-defined function:</p>
<pre><code>&gt;&gt;&gt; def my_int(x, base=10):
...     return int(x, base)
... 
&gt;&gt;&gt; len(inspect.signature(my_int).parameters)
2
</code></pre>
<p>The <a href="https://docs.python.org/3/library/inspect.html#inspect.signature">docs for <code>inspect.signature</code></a> do say:</p>
<blockquote>
<p>Some callables may not be introspectable in certain implementations of Python. For example, in CPython, some built-in functions defined in C provide no metadata about their arguments.</p>
</blockquote>
<p>But they also say:</p>
<blockquote>
<p>Raises ValueError if no signature can be provided, and TypeError if that type of object is not supported.</p>
</blockquote>
<p>So I am surprised that I did not get a <code>ValueError</code> and instead got what appears to be an incorrect signature.</p>
<p>Is there a way to reliably (and programmatically) determine when it is not possible to get the parameters for a callable with <code>inspect</code>? That is, if I am given something like <code>int</code>, is there a way to distinguish between "this thing does not have any parameters" and "it is not possible to determine what parameters this thing has"?</p>
</div>
<div class="post-text" itemprop="text">
<p>There's an open bug report for this:  <a href="http://bugs.python.org/issue23934" rel="nofollow">http://bugs.python.org/issue23934</a></p>
<p>The problem is that if the obj passed to <code>signature()</code> is a 'type', and it doesn't have a user defined <strong>init</strong> or <strong>new</strong>, it just gives up and returns the signature for <code>object</code>, which has 0 parameters.</p>
<p>If the obj is in the builtins module, and it's a 'type', but not an Exception, there's a pretty good chance it's not going to work with <code>signature()</code>.  </p>
<p>I came up with this workaround to find the problem objs... It's not particularly elegant, but it may be useful to you:</p>
<pre><code>def count_params():
    output = {}
    for funcname in dir(builtins):
        f = getattr( builtins,funcname)
        if isinstance(f, type):
            try:
                paramcount = len(inspect.signature(f).parameters)
                output[funcname] = paramcount
            except:
                pass
                #print("%s is a %s" % (funcname, type(f)))
    return output
</code></pre>
<p>Output:</p>
<pre><code>{'__loader__': 0,
 'bool': 0,
 'bytes': 0,
 'complex': 0,
 'enumerate': 0,
 'filter': 0,
 'float': 0,
 'frozenset': 0,
 'int': 0,
 'map': 0,
 'memoryview': 0,
 'object': 0,
 'range': 0,
 'reversed': 0,
 'slice': 0,
 'str': 0,
 'tuple': 0,
 'zip': 0}
</code></pre>
</div>
<span class="comment-copy">Maybe this will help: <a href="http://stackoverflow.com/questions/25847035/what-are-signature-and-text-signature-used-for-in-python-3-4">What are <code>__signature__</code> and <code>__text_signature__</code> used for in Python 3.4</a></span>
<span class="comment-copy">Thanks for the bug link.  There's also the issue of subclasses of these types. For example, <code>inspect.signature</code> incorrectly returns an empty signature for any subclass of <code>int</code> that does not define its own <code>__init__</code>. (If the subclass defines its own <code>__init__</code> then the correct signature is returned.) @user1941126's (deleted) answer actually suggests a pretty good augmentation to your answer: if the callable has 0 parameters and is a type, then check the signature of <code>__init__</code>. If <code>__init__</code> has more than 1 parameter then something fishy is going on.</span>
