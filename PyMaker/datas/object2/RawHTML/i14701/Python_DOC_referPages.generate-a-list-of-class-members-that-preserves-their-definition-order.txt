<div class="post-text" itemprop="text">
<p>I am trying to automatically create some SQL tables from the definition of some Python classes, I tried using <code>dir()</code> but since it returns a Python Dictionary, it's not ordered so the definition order of the class members is lost.</p>
<p>Reading on the internet I found the following <a href="https://docs.python.org/3/reference/datamodel.html#metaclass-example" rel="nofollow">here</a></p>
<pre><code>class OrderedClass(type):

     @classmethod
     def __prepare__(metacls, name, bases, **kwds):
        return collections.OrderedDict()

     def __new__(cls, name, bases, namespace, **kwds):
        result = type.__new__(cls, name, bases, dict(namespace))
        result.members = tuple(namespace)
        return result

class A(metaclass=OrderedClass):
    def one(self): pass
    def two(self): pass
    def three(self): pass
    def four(self): pass

&gt;&gt;&gt; A.members
('__module__', 'one', 'two', 'three', 'four')
</code></pre>
<p>I successfuly implemented a copy of it, and it appears to be doing what it should except that it's only saving the <code>methods</code> in the <code>members</code> variable, and I need to have also the <strong><code>class</code> member variables</strong>.</p>
<p><strong>Question</strong>:</p>
<p>How could I get a list of the member variables preserving their definition order?, I don't care about class methods, and I am actually ignoring them.</p>
<p><strong>Note</strong>: The reason why the order is important is because the tables will have constraints that reference some of the table columns, and they must go after defining the column, but they are appearing before.</p>
<p><strong>Edit</strong>: This is a sample class in my real program</p>
<pre><code>class SQLTable(type):
    @classmethod
    def __prepare__(metacls, name, bases, **kwds):
        return OrderedDict()

    def __new__(cls, name, bases, namespace, **kwds):
        result = type.__new__(cls, name, bases, dict(namespace))
        result.members = tuple(namespace)
        return result

class AreaFisicoAmbiental(metaclass = SQLTable):
    def __init__(self, persona, datos):
        # edificacion
        self.persona = persona
        self.tipoEdificacion = datos[0]
        self.tipoDeParedes = datos[1]
        self.detallesTipoDeParedes = datos[2]
        self.tipoDeTecho = datos[3]
        self.detallesTipoDeTecho = datos[4]
        self.tipoDePiso = datos[5]
        self.detallesTipoDePiso = datos[6]
        # ambientes
        self.problemaDeInfraestructura = datos[7]
        self.detallesProblemaDeInfraestructura = datos[9]
        self.condicionDeTenencia = datos[10]
        self.detallesCondicionDeTenencia = datos[11]
        self.sala = toBool(datos[12])
        self.comedor = toBool(datos[13])
        self.baño = toBool(datos[14])
        self.porche = toBool(datos[15])
        self.patio = toBool(datos[16])
        self.lavandero = toBool(datos[17])
        self.habitaciones = toInt(datos[19])
        # servicios básicos
        self.aguasServidas = toBool(datos[21])
        self.aguaPotable = toBool(datos[22])
        self.luz = toBool(datos[23])
        self.gas = datos[24]
        self.internet = toBool(datos[25])
</code></pre>
<p>Doing</p>
<pre><code>print(AreaFisicoAmbiental.members)
</code></pre>
<p>Outputs:
</p>
<pre class="lang-none prettyprint-override"><code>('__module__', '__qualname__', '__init__')
</code></pre>
<p>Variable names are in spanish because their names will be used as the table column names, and also as the labels for a web application that will be generated from the database structure.</p>
<p>I know that Django does something like this, but I already have my database inspector which does the opposite thing, so know I need a Django like functionality to use my generator.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Updated</strong></p>
<p>As I commented, I think you're probably confusing instance attributes with class attributes and really want to keep track of the latter. Instance attributes are dynamic and can be added, changed, or removed at any time, so trying to do this with a metaclass like shown in your question won't work (and different instances may have a different group of them defined).</p>
<p>You may be able to keep track of their creation and deletion by overloading a couple of the class's special methods, namely <code>__setattr__()</code> and <code>__delattr__()</code> and storing their effects in a private data member which is an <a href="http://code.activestate.com/recipes/576694" rel="nofollow"><code>OrderedSet</code></a>. Do so will keep track of what they are and preserve the order in which they were created.</p>
<p>Both of these methods will need to be careful not to operate upon the private data member itself.</p>
<p>That said, here's something illustrating such an implementation:</p>
<pre><code># -*- coding: iso-8859-1 -*-
# from http://code.activestate.com/recipes/576694
from orderedset import OrderedSet

class AreaFisicoAmbiental(object):
    def __init__(self, persona, datos):
        self._members = OrderedSet()
        self.persona = persona
        self.tipoEdificacion = datos[0]
        self.tipoDeParedes = datos[1]

    def __setattr__(self, name, value):
        object.__setattr__(self, name, value)
        if name != '_members':
            self._members.add(name)

    def __delattr__(self, name):
        if name != '_members':
            object.__delattr__(self, name)
            self._members.discard(name)

    def methodA(self, value1, value2):  # add some members
        self.attribute1 = value1
        self.attribute2 = value2

    def methodB(self):
        del self.attribute1  # remove a member

if __name__ == '__main__':
    a = AreaFisicoAmbiental('Martineau', ['de albañilería', 'vinilo'])
    a.methodA('attribute1 will be deleted', 'but this one will be retained')
    a.methodB()  # deletes a.attribute1
    a.attribute3 = 42  # add an attribute outside the class

    print('current members of "a":')
    for name in a._members:
        print('  {}'.format(name))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>current members of "a":
  persona
  tipoEdificacion
  tipoDeParedes
  attribute2
  attribute3
</code></pre>
<p>A final note: It <em>would</em> be possible to create a metaclass that added these two methods automatically to client classes, which would make it easier to modify existing classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe, <a href="https://docs.python.org/3/library/enum.html" rel="nofollow">python enum</a> would be enough for the task. Indeed it supports stable order.</p>
<p>The basic implementation of <em>DDL</em> would look like this:</p>
<pre><code>from enum import Enum
class Table1(Enum):
    nombre = ''
    edad = 0
    sexo = True
    ...
</code></pre>
<p>then later you could do:</p>
<pre><code>for prop in Table1:
    print(prop)
</code></pre>
<p>this gives you</p>
<pre><code>Table1.nombre
Table1.edad
Table1.sexo
</code></pre>
<p>if you need to construct a proper table definition you could use Table1.&lt;field&gt;.value:</p>
<pre><code>&gt;&gt;&gt; print(type(Table1.nombre.value))
&lt;class 'str'&gt;
&gt;&gt;&gt; print(type(Table1.edad.value))
&lt;class 'int'&gt;
</code></pre>
<p>and so on. Using this technique you could even link some tables to others thus constructing a complete definition of a whole set of tables and their relationships.</p>
<p>As for data objects (e.g. a row in a table, or a row of a query results), here I think you don't any own ordering, you just need to maintain a link to a corresponding table class (from which the order can be restored, however I don't think it's such a requested option). So these classes could look like this:</p>
<pre><code>class Table1Row(object):
    _table = Table1
    __slots__ = tuple(k.name for k Table1)
    ...
</code></pre>
<p>or simply</p>
<pre><code>class ASpecificQueryResults(object):
   __slots__ = (Table1.nombre.name, Table2.empresa.name,...)
</code></pre>
<p>probably you need a factory which would build row classes based on the query results and/or table definitions.</p>
<p><strong>Edit</strong> probably the idea with <code>__slots__</code> in *Row classes requires some more polish but this heavily depends on your actual needs.</p>
<p>P.S. Perhaps 'Table1.sexo' also should be an enum in our complicated times ;)</p>
</div>
<span class="comment-copy">Have you thought about using Django for this? Or at least looking at how it's model code works? It does exactly this.</span>
<span class="comment-copy"><code>class A</code> doesn't define any member variables. Try adding a <code>member_var = 42</code> to its definition. Regardless, it sounds like what you really want is a copy of an instance's data members.</span>
<span class="comment-copy">@martineau my classes do define member variables, I will post one of them.</span>
<span class="comment-copy">Since that's what your question is all about, by all means, do so.</span>
<span class="comment-copy">All those items defined with <code>self.xxx = whatever</code> are instance attributes and don't exist at class definition time.</span>
<span class="comment-copy">That would be a class with a specific number of instances, in order, not a class whose instances' attributes are in a specific order.</span>
<span class="comment-copy">well, as I understand @¡harob needs this to implement a sort of ORM. In this case only one instance of a class matters (which corresponds to an SQL table), and even not an instance, but rather a class with some class-level properties. So I still think that something like a enum-based class would be enough for his initial problem</span>
<span class="comment-copy">@user3159253 Maybe your idea is not bad, but it lacks explanation, how would you use <i>python enum</i> to implement that, even a simple example?</span>
<span class="comment-copy">@user3159253 You did a great job, let me take a look and see if it fits my needs, I need to finish this project right now.</span>
<span class="comment-copy">At the PS: indeed. My Spanish is terribly rusty, but if <i>sexo</i> means <i>sex</i> (and <i>gender</i> is a different word), it should also be renamed. At least take two minutes and <a href="https://en.wikipedia.org/wiki/Gender_identity" rel="nofollow noreferrer">skim relevant Wikipedia articles</a>. You might even learn something.</span>
