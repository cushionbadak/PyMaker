<div class="post-text" itemprop="text">
<p>I have a list of 256 functions as dicts, each with 4 pairs as in: </p>
<blockquote>
<p>[{'a':'b', 'b':'c', 'c':'c', 'd':'a'}, ... ]</p>
</blockquote>
<p>and would like to do the following...</p>
<ol>
<li>Apply function to each element in the domain from 1 to four times. For example for element 1 in the domain, 'a': </li>
</ol>
<blockquote>
<p>[f[a], f[f[a]], ..., f[f[f[f[a]]]] ]</p>
</blockquote>
<p>This produces the following for the example dict/function in 1. </p>
<pre><code>['b','c','c','c'] #for element a 
['c','c','c','c'] #for element b 
... etc.          #for element c
                  #for element d 
</code></pre>
<ol start="3">
<li><p>view the matrix/list of lists as columns. </p>
<p>4.Then, I wish to count the number of elements 'a' in col1, 2, 3 and 4. 
and do this for each domain element. I am hoping to produce something of the form: </p></li>
</ol>
<blockquote>
<p>[ [num a's in col 1, num of as in col 2, ...],
             [num b's in col 1, num of b's in col 2, ...], etc ]</p>
</blockquote>
<p>for every single of the 256 function/dict elements.
the final output <strong><em>should</em></strong> be something like: </p>
<pre><code>[ [[0,1,1,0], 
   [2,1,1,0], 
   [0,0,0,0], 
   [2,2,2,4]], .... 256 of these] 
</code></pre>
<p>Here is the current code and the current output: </p>
<pre><code>domain = ['a','b','c','d']
allf = [{'a':'a','b':'c','c':'d', 'd':'d'}, {'a':'b', 'b':'c', 'c':'d', 'd':'a'}]


def dictfunky():
    global dictfuncts
    dictfuncts = []
    for item in allf:
        di = dict(item)
        dictfuncts.append(di)
    print(dictfuncts)


def functmatnoz():
    global matlist
    matlist = []
    global elems
    for f in dictfuncts:
        elems = []
        for element in domain:
            forward = [f[element], f[f[element]], f[f[f[element]]], f[f[f[f[element]]]]]
            forward.reverse()
            back = forward
            elems.append(back)
        matlist.append(elems)
    print(matlist)



def sigma():
    global sigmamat
    sigmamat = []
    for element in domain:
        sig = []
        for column in matlist:
            size = column.count(element)
            sig.append(size)
        sigmamat.append(sig)
    print(sigmamat)

dictfunky()
functmatnoz()
sigma()
</code></pre>
<p>the first bit of output from the above is as follows, the main problem is of course the resultant string of 0's instead of my desired list of lists counting occurrences: </p>
<p>Out: </p>
<pre><code> &gt;&gt;&gt; dictfunky()
[{'b': 'c', 'd': 'd', 'c': 'd', 'a': 'a'}, {'b': 'c', 'd': 'a', 'c': 'd', 'a': 'b'}]

&gt;&gt;&gt; functmatnoz()
[[['a', 'a', 'a', 'a'], ['d', 'd', 'd', 'c'], ['d', 'd', 'd', 'd'], ['d', 'd', 'd', 'd']], [['a', 'd', 'c', 'b'], ['b', 'a', 'd', 'c'], ['c', 'b', 'a', 'd'], ['d', 'c', 'b', 'a']]]

&gt;&gt;&gt; sigma()
[[0, 0], [0, 0], [0, 0], [0, 0]]
&gt;&gt;&gt; 
</code></pre>
<p>desired out: </p>
<pre><code>sigma()

[
  [[4,0,0,0], # num of a's in each col for funct 1
   [0,0,0,0], # num of b's in each col for funct 1 
   [0,1,0,0], # num of c's in .... 
   [0,3,4,4]] , 

  [[1,1,1,1], # num of a's in each col for funct 2 
   [1,1,1,1], # num of b's in each col for funct 2 
   [1,1,1,1], # etc. 
   [1,1,1,1]]
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This seems to do what you want. I also got rid of the global variable references in the functions and made them just return a result (<a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad" rel="nofollow">global variables are bad</a>). The only significant logic change was to the <code>sigma()</code> function.</p>
<pre><code>domain = ['a','b','c','d']
allf = [{'a':'a','b':'c','c':'d', 'd':'d'}, {'a':'b', 'b':'c', 'c':'d', 'd':'a'}]

def dictfunky():
    dictfuncts = []
    for item in allf:
        di = dict(item)
        dictfuncts.append(di)
    return dictfuncts

def functmatnoz():
    matlist = []
    for f in dictfuncts:
        elems = []
        for element in domain:
            forward = [f[element], f[f[element]], f[f[f[element]]], f[f[f[f[element]]]]]
            forward.reverse()
            back = forward
            elems.append(back)
        matlist.append(elems)
    return matlist

def sigma():
    sigmamat = []
    for mat in matlist:
        col = []
        for element in domain:
            num_elem = []
            for results in mat:
                count = results.count(element)
                num_elem.append(count)
            col.append(num_elem)
        sigmamat.append(col)
    return sigmamat

dictfuncts = dictfunky()
matlist = functmatnoz()
sigmamat = sigma()

print('dictfuncts: {}'.format(dictfuncts))
print('   matlist: {}'.format(matlist))
print('  sigmamat: {}'.format(sigmamat))
</code></pre>
<p>Output (line-breaks added for readability):</p>
<pre class="lang-none prettyprint-override"><code>dictfuncts: [{'c': 'd', 'b': 'c', 'a': 'a', 'd': 'd'},
             {'c': 'd', 'b': 'c', 'a': 'b', 'd': 'a'}]
   matlist: [[['a', 'a', 'a', 'a'], ['d', 'd', 'd', 'c'], 
              ['d', 'd', 'd', 'd'], ['d', 'd', 'd', 'd']],
             [['a', 'd', 'c', 'b'], ['b', 'a', 'd', 'c'], 
              ['c', 'b', 'a', 'd'], ['d', 'c', 'b', 'a']]]
  sigmamat: [[[4, 0, 0, 0],
              [0, 0, 0, 0],
              [0, 1, 0, 0],
              [0, 3, 4, 4]],
             [[1, 1, 1, 1],
              [1, 1, 1, 1],
              [1, 1, 1, 1],
              [1, 1, 1, 1]]]
</code></pre>
<p><strong>Update</strong></p>
<p>The following optimized version, which uses nested <a href="https://docs.python.org/3/tutorial/datastructures.html?highlight=list%20comprehension#list-comprehensions" rel="nofollow">list comprehensions</a>, produces exactly the same results with a lot less code, and so might also be of interest to you. It also eliminates the remaining references to global variables in each of the functions by passing the those needed as additional arguments to them. </p>
<pre><code>domain = ['a','b','c','d']
allf = [{'a':'a','b':'c','c':'d', 'd':'d'}, {'a':'b', 'b':'c', 'c':'d', 'd':'a'}]

def dictfunky(allf):
    return [dict(item) for item in allf]

def functmatnoz(dictfuncts, domain):
    return [[[f[f[f[f[element]]]],
                 f[f[f[element]]],
                    f[f[element]],
                       f[element]] for element in domain]
                                        for f in dictfuncts]

def sigma(matlist, domain):
    return [[[[results.count(element) for results in mat]
                                        for element in domain]]
                                            for mat in matlist]

dictfuncts = dictfunky(allf)
matlist = functmatnoz(dictfuncts, domain)
sigmamat = sigma(matlist, domain)

print('dictfuncts: {}'.format(dictfuncts))
print('   matlist: {}'.format(matlist))
print('  sigmamat: {}'.format(sigmamat))
</code></pre>
</div>
<span class="comment-copy">Please provide a <a href="http://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>. Also in Python what you're calling "256 functions as dicts" are simply 256 dicts or mappings, and <code>f[a]</code> is not calling a function, it's applying a mapping <code>f</code> to the value <code>a</code> (or looking up its value in the <code>f</code> dictionary).</span>
<span class="comment-copy">@martineau Hope the edit helps.</span>
<span class="comment-copy">Yes, that looks like it will help a lot.</span>
<span class="comment-copy">This is great, many thanks.</span>
