<div class="post-text" itemprop="text">
<p>How can I conditionally call the orignal method in a mock?</p>
<p>In this example I only want to fake a return value if <code>bar=='x'</code>. Otherwise I want to call the original method.</p>
<pre><code>def mocked_some_method(bar):
    if bar=='x':
        return 'fake'
    return some_how_call_original_method(bar)

with mock.patch('mylib.foo.some_method', mocked_some_method):
    do_some_stuff()
</code></pre>
<p>I know that it is a bit strange. If I want to fake <code>mylib.foo.some_method</code> in side <code>do_some_stuff()</code> it should be condition-less. All (not some) calls to <code>some_method</code> should be mocked.</p>
<p>In my case it is an integration test, not a s tiny unittest and <code>mylib.foo.some_method</code> is a kind of dispatcher which gets used very often. And in one case I need to fake the result.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need just replace behavior without care of mock's calls assert function you can use <code>new</code> argument; otherwise you can use <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect"><code>side_effect</code></a> that take a callable. </p>
<p>I guess that <code>some_method</code> is a object method (instead of a <code>staticmethod</code>) so you need a reference its object to call it. Your wrapper should declare as first argument the object and your patch use <code>autospec=True</code> to use the correct signature for <code>side_effect</code> case.</p>
<p>Final trick is save the original method reference and use it to make the call.</p>
<pre><code>orig = mylib.foo.some_method
def mocked_some_method(self, bar):
    if bar=='x':
        return 'fake'
    return orig(self, bar)

#Just replace:
with mock.patch('mylib.foo.some_method', new=mocked_some_method):
    do_some_stuff()

#Replace by mock
with mock.patch('mylib.foo.some_method', side_effect=mocked_some_method, autospec=True) as mock_some_method:
    do_some_stuff()
    assert mock_some_method.called
</code></pre>
</div>
<span class="comment-copy">What do you mean with "static" here: "I guess that some_method is not static ..."?</span>
<span class="comment-copy">You are right. mock as wrapper is not best practice. I updated the question to reflect this.</span>
<span class="comment-copy">@guettli From your question I can just guess that <code>some_method</code> is not <code>@staticmethod</code> but an object method.... I'll change my answer by remove the side note but it should already fit your requirements.</span>
