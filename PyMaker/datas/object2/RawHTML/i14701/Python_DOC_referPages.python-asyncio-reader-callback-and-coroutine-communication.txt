<div class="post-text" itemprop="text">
<p>I am trying to implement a simple idea of passing a data from stdin to a coroutine:</p>
<pre><code>import asyncio
import sys

event = asyncio.Event()

def handle_stdin():
    data = sys.stdin.readline()
    event.data = data  # NOTE: data assigned to the event object
    event.set()

@asyncio.coroutine
def tick():
    while 1:
        print('Tick')
        yield from asyncio.sleep(1)

        if event.is_set():
            data = event.data  # NOTE: data read from the event object
            print('Data received: {}'.format(data))
            event.clear()

def main(): 
    loop = asyncio.get_event_loop()
    loop.add_reader(sys.stdin, handle_stdin)
    loop.run_until_complete(tick())    

if __name__ == '__main__':
    main()
</code></pre>
<p>This code works fine, however a simplified version of it with a variable instead of an <code>Event</code> object works too:</p>
<pre><code>data = None

def handle_stdin():
    global data
    data = sys.stdin.readline()

@asyncio.coroutine
def tick():
    while 1:
        print('Tick')
        yield from asyncio.sleep(1)

        global data
        if data is not None:
            print('Data received: {}'.format(data))
            data = None
</code></pre>
<p>My questions are: is the approach with <code>Event</code> correct? Or is there a better way with another asyncio objects to handle this kind of problem? 
Then, if the approach with <code>Event</code> is fine, is using a variable is fine as well? </p>
<p>Thank you. </p>
</div>
<div class="post-text" itemprop="text">
<p>I think <a href="https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue" rel="nofollow noreferrer"><code>asyncio.Queue</code></a> is much better suited for this kind of producer/consumer relationship:</p>
<pre><code>import asyncio
import sys

queue = asyncio.Queue()

def handle_stdin():
    data = sys.stdin.readline()
    # Queue.put is a coroutine, so you can't call it directly.
    asyncio.async(queue.put(data)) 
    # Alternatively, Queue.put_nowait() is not a coroutine, so it can be called directly.
    # queue.put_nowait(data)

async def tick():
    while 1:
        data = await queue.get()
        print('Data received: {}'.format(data))

def main(): 
    loop = asyncio.get_event_loop()
    loop.add_reader(sys.stdin, handle_stdin)
    loop.run_until_complete(tick())    

if __name__ == '__main__':
    main()
</code></pre>
<p>There's less logic involved than with an <code>Event</code>, which you need to make sure you set/unset properly, and there's no need for a <code>sleep</code>, wakeup, check, go back to sleep, loop, like with the global variable. So the the <code>Queue</code> approach is simpler, smaller, and blocks the event loop less than your other possible solutions. The other solutions are technically <em>correct</em>, in that they will function properly (as long as you don't introduce any <code>yield from</code> calls inside if <code>if event.is_set()</code> and <code>if data is not None:</code> blocks). They're just a bit clunky.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to wait for an event, you should probably be using <a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event.wait" rel="nofollow"><code>Event.wait</code></a> instead of polling <code>is_set</code>.</p>
<pre><code>@asyncio.coroutine
def tick():
    while True:
        yield from event.wait()
        print('Data received: {}'.format(event.data))
        event.clear()
</code></pre>
</div>
<span class="comment-copy">Thank you very much @dano, <code>queue</code> approach looks indeed better than the <code>"event"</code> one.</span>
<span class="comment-copy">True, in fact even a simple <code>yield from event.wait()</code> without a loop should be sufficient.</span>
