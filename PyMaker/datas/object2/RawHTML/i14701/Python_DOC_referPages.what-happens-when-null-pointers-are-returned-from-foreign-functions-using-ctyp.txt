<div class="post-text" itemprop="text">
<p>When wrapping C functions with ctypes what happens when a method returns a NULL pointer to a struct mapped to a python class derived from ctypes.Structure?  Also what happens when valid pointers passed to a method are set to NULL values?  The following test will help us find out:</p>
<pre><code>//python_ctypes_test.c
#include &lt;stdlib.h&gt;

struct test_struct {
    int a;
    int b;
    int c;
    int d;
} typedef test_struct;

test_struct* get_test_struct(const int valid) {
    test_struct* newStruct = 0;
    if (valid &gt; 0) {
        newStruct = malloc(sizeof *newStruct);
        newStruct-&gt;a = 1;
        newStruct-&gt;b = 2;
        newStruct-&gt;c = 3;
        newStruct-&gt;d = 4;
    }
    return newStruct;
}

void get_two_floats(const int valid, float* float1, float* float2) {
    if (valid &gt; 0) {
        *float1 = 1.1f;
        *float2 = 2.2f;
    } else {
        float1 = 0;
        float2 = 0;
    }
}
</code></pre>
<hr/>
<pre><code>#python_ctypes_test.py
import ctypes
import ctypes.util

dll = ctypes.CDLL('libpython_ctypes_test.so')

class _test_struct(ctypes.Structure):
    _fields_ = [("a", ctypes.c_int),
                ("b", ctypes.c_int),
                ("c", ctypes.c_int),
                ("d", ctypes.c_int)]

    def wrap(self, something):
        self.a,self.b,self.c,self.d = something

    def unwrap(self):
        part1 = self.a,self.b
        part2 = self.c,self.d
        return part1, part2

dll.get_test_struct.restype = ctypes.POINTER(_test_struct)
dll.get_test_struct.argtypes = [ctypes.c_int]
def py_get_test_struct(valid):
    return dll.get_test_struct(valid).contents.unwrap()

def py_get_test_struct_safe(valid):
    testStructPtr = dll.get_test_struct(valid)
    if testStructPtr: 
        return testStructPtr.contents.unwrap()
    else:
        return None

dll.get_two_floats.restype = None
dll.get_two_floats.argtypes = [ctypes.c_int, 
        ctypes.POINTER(ctypes.c_float), ctypes.POINTER(ctypes.c_float)]
def py_get_two_floats(valid):
    float1_value = ctypes.c_float(0)
    float1 = ctypes.pointer(float1_value)
    float2_value = ctypes.c_float(0)
    float2 = ctypes.pointer(float2_value)

    dll.get_two_floats(valid, float1, float2)

    return float1_value.value, float2_value.value

print py_get_two_floats(True)
print py_get_two_floats(False)
print py_get_test_struct_safe(True)
print py_get_test_struct_safe(False)
print py_get_test_struct(True)
print py_get_test_struct(False)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As it turns out, the developer need not be concerned about the address of pointer that has been passed to a function changing.</p>
<pre><code>print py_get_two_floats(True)
  (1.100000023841858, 2.200000047683716)

print py_get_two_floats(False)
  (0.0, 0.0)
</code></pre>
<p>In the second case the values remain unchanged from their initialized state.  This is generally true.  Had <code>float1_value</code> and <code>float2_value</code> been initialized to 10 and 20.  Those values would have been remained unchanged as well.</p>
<p>As @eryksun points out:</p>
<blockquote>
<p>float1 and float2 are local variables that contain the address of the
  two floats. You can set the value to 0, or any other address, but
  that's just changing a local variable. That's not the same as
  dereferencing the pointer (e.g. *float1) to access the floating point
  value at the address.</p>
</blockquote>
<p>In the case of return values things are handled differently.  The object returned evaluates to true (non-null) or false (null).</p>
<pre><code>print py_get_test_struct_safe(True)
  ((1, 2), (3, 4))

print py_get_test_struct_safe(False)
  None
</code></pre>
<p>Attempting to access a NULL pointer results in a ValueError exception.</p>
<pre><code>print py_get_test_struct(True)
  ((1, 2), (3, 4))

print py_get_test_struct(False)
Traceback (most recent call last):
  File "python_ctypes.py", line 52, in &lt;module&gt;
    print py_get_test_struct(False)
  File "python_ctypes.py", line 24, in py_get_test_struct
    return dll.get_test_struct(valid).contents.unwrap()
ValueError: NULL pointer access
</code></pre>
</div>
<span class="comment-copy">Download source code: <a href="https://github.com/trukvl/python_ctypes_test" rel="nofollow noreferrer">github.com/trukvl/python_ctypes_test</a></span>
<span class="comment-copy">Do you think something is missing from the <a href="https://docs.python.org/3/library/ctypes.html#pointers" rel="nofollow noreferrer">ctypes pointers tutorial</a>? It discusses their boolean value and demonstrates the <code>ValueError</code>.</span>
<span class="comment-copy">I suppose I would like to see a section discussing how ctypes handles NULL pointers returned from C functions and pointers passed by reference that are changed to NULL pointers by the C function.  It is not clear to me the these points are addressed directly.</span>
<span class="comment-copy">It does discuss <code>NULL</code> pointers; it doesn't matter how they're created. The C function returns an integer value in a register (e.g. <code>rax</code> in x64), and ctypes creates a pointer instance from that value, which could be 0. For the 2nd question, you aren't passing pointers by reference. You're passing them by value.</span>
<span class="comment-copy">Instead of creating a pointer instance, generally you'd just use <code>float1 = ctypes.c_float()</code> and pass a reference as <code>ctypes.byref(float1)</code>. That's passing a reference to the float value, but the address itself is passed by value, either on the stack or in a register (e.g. register <code>rcx</code> in x64).</span>
<span class="comment-copy">Is this supposed to be a lesson in basic C programming? (1) <code>float1</code> is a local variable in <code>get_two_floats</code>, so of course setting it to 0 has no effect in the context of the caller. (2) As to accessing a <code>NULL</code> pointer, you could simply use <code>ctypes.POINTER(_test_struct)().contents</code> to demonstrate the <code>ValueError</code>.</span>
<span class="comment-copy">I shared this example because I was debugging code that uses pyGLFW (a wrapper around the GLFW C library). I had questions about what the python would return if the C code returned null in the two cases I demonstrated. Since I couldn't find a good example that answered this question, I decided to post it.</span>
<span class="comment-copy"><code>float1</code> and <code>float2</code> are local variables that contain the address of the two floats. You can set the value to 0, or any other address, but that's just changing a local variable. That's not the same as dereferencing the pointer (e.g. <code>*float1</code>) to access the floating point value at the address.</span>
<span class="comment-copy">Thanks, I see my mistake now.  You are correct, <code>float1</code> and <code>float2</code> will never be NULL after the C call.  I misread the API I was testing.  I will revise my answer to reflect this.</span>
