<div class="post-text" itemprop="text">
<p>I wanted to understand a bit more about <code>iterators</code>, so please correct me if I'm wrong.</p>
<p>An iterator is an object which has a pointer to the next object and is read as a buffer or stream (i.e. a linked list). They're particularly efficient cause all they do is tell you what is next by references instead of using indexing.</p>
<p>However I still don't understand why is the following behavior happening:</p>
<pre><code>In [1]: iter = (i for i in range(5))

In [2]: for _ in iter:
   ....:     print _
   ....:     
0
1
2
3
4

In [3]: for _ in iter:
   ....:     print _
   ....:     

In [4]: 
</code></pre>
<p>After a first loop through the iterator (<code>In [2]</code>) it's as if it was consumed and left empty, so the second loop (<code>In [3]</code>) prints nothing. </p>
<p>However I never assigned a new value to the <code>iter</code> variable.</p>
<p>What is really happening under the hood of the <code>for</code> loop?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your suspicion is correct: the iterator has been consumed. </p>
<p>In actuality, your iterator is a <a href="https://wiki.python.org/moin/Generators" rel="noreferrer">generator</a>, which is an object which has the ability to be iterated through <em>only once.</em></p>
<pre><code>type((i for i in range(5))) # says it's type generator 

def another_generator():
    yield 1 # the yield expression makes it a generator, not a function

type(another_generator()) # also a generator
</code></pre>
<p>The reason they are efficient has nothing to do with telling you what is next "by reference." They are efficient because they only generate the next item upon request; all of the items are not generated at once. In fact, you can have an infinite generator:</p>
<pre><code>def my_gen():
    while True:
        yield 1 # again: yield means it is a generator, not a function

for _ in my_gen(): print(_) # hit ctl+c to stop this infinite loop!
</code></pre>
<p>Some other corrections to help improve your understanding: </p>
<ul>
<li>The generator is not a pointer, and does not behave like a pointer as you might be familiar with in other languages.</li>
<li>One of the differences from other languages: as said above, each result of the generator is generated on the fly. The next result is not produced until it is requested.</li>
<li>The keyword combination <code>for</code> <code>in</code> accepts an iterable object as its second argument. </li>
<li>The iterable object can be a generator, as in your example case, but it can also be any other iterable object, such as a <code>list</code>, or <code>dict</code>, or a <code>str</code> object (string), or a user-defined type that provides the required functionality. </li>
<li>The <a href="https://docs.python.org/3/library/functions.html#iter" rel="noreferrer"><code>iter</code> function</a> is applied to  the object to get an iterator (by the way: don't use <code>iter</code> as a variable name in Python, as you have done - it is one of the keywords). Actually, to be more precise, the object's <a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" rel="noreferrer"><code>__iter__</code> method</a> is called (which is, for the most part, all the <code>iter</code> function does anyway; <code>__iter__</code> is one of Python's so-called "magic methods").</li>
<li>If the call to <code>__iter__</code> is successful, the function <a href="https://docs.python.org/3/library/functions.html#next" rel="noreferrer"><code>next()</code></a> is applied to the iterable object over and over again, in a loop, and the first variable supplied to <code>for</code> <code>in</code> is assigned to the result of the <code>next()</code> function. (Remember: the iterable object could be a generator, or a container object's iterator, or any other iterable object.) Actually, to be more precise: it calls the iterator object's <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="noreferrer"><code>__next__</code></a> method, which is another "magic method". </li>
<li>The <code>for</code> loop ends when <code>next()</code> raises the <a href="https://docs.python.org/3/library/exceptions.html#StopIteration" rel="noreferrer"><code>StopIteration</code></a> exception (which usually happens when the iterable does not have another object to yield when <code>next()</code> is called).</li>
</ul>
<p>You can "manually" implement a <code>for</code> loop in python this way (probably not perfect, but close enough):</p>
<pre><code>try:
    temp = iterable.__iter__()
except AttributeError():
    raise TypeError("'{}' object is not iterable".format(type(iterable).__name__))
else:
    while True:
        try:
            _ = temp.__next__()
        except StopIteration:
            break
        except AttributeError:
            raise TypeError("iter() returned non-iterator of type '{}'".format(type(temp).__name__))
        # this is the "body" of the for loop
        continue
</code></pre>
<p>There is pretty much no difference between the above and your example code. </p>
<p>Actually, the more interesting part of a <code>for</code> loop is not the <code>for</code>, but the <code>in</code>. Using <code>in</code> by itself produces a different effect than <code>for</code> <code>in</code>, but it is very useful to understand what <code>in</code> does with its arguments, since <code>for</code> <code>in</code> implements very similar behavior. </p>
<ul>
<li><p>When used by itself, the <code>in</code> keyword first calls the object's <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="noreferrer"><code>__contains__</code> method</a>, which is yet another "magic method" (note that this step is skipped when using <code>for</code> <code>in</code>). Using <code>in</code> by itself on a container, you can do things like this:</p>
<pre><code>1 in [1, 2, 3] # True
'He' in 'Hello' # True
3 in range(10) # True
'eH' in 'Hello'[::-1] # True
</code></pre></li>
<li><p>If the iterable object is NOT a container (i.e. it doesn't have a <code>__contains__</code> method), <code>in</code> next tries to call the object's <code>__iter__</code> method. As was said previously: the <code>__iter__</code> method returns what is known in Python as an <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="noreferrer">iterator</a>. Basically, an iterator is an object that you can use the built-in generic function <a href="https://docs.python.org/3/library/functions.html#next" rel="noreferrer"><code>next()</code></a> on<sup>1</sup>. A generator is just one type of iterator. </p></li>
<li>If the call to <code>__iter__</code> is successful, the <code>in</code> keyword applies the function <a href="https://docs.python.org/3/library/functions.html#next" rel="noreferrer"><code>next()</code></a> to the iterable object over and over again. (Remember: the iterable object could be a generator, or a container object's iterator, or any other iterable object.) Actually, to be more precise: it calls the iterator object's <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="noreferrer"><code>__next__</code></a> method). </li>
<li>If the object doesn't have a <code>__iter__</code> method to return an iterator, <code>in</code> then falls back on the old-style iteration protocol using the object's <code>__getitem__</code> method<sup>2</sup>. </li>
<li>If all of the above attempts fail, you'll get a <a href="https://docs.python.org/3/library/exceptions.html#TypeError" rel="noreferrer"><code>TypeError</code> exception</a>.</li>
</ul>
<p>If you wish to create your own object type to iterate over (i.e, you can use <code>for</code> <code>in</code>, or just <code>in</code>, on it), it's useful to know about the <code>yield</code> keyword, which is used in <a href="https://docs.python.org/3/glossary.html#term-generator" rel="noreferrer">generators</a> (as mentioned above). </p>
<pre><code>class MyIterable():
    def __iter__(self):
        yield 1

m = MyIterable()
for _ in m: print(_) # 1
1 in m # True    
</code></pre>
<p>The presence of <code>yield</code> turns a function or method into a generator instead of a regular function/method. You don't need the <code>__next__</code> method if you use a generator (it brings <code>__next__</code> along with it automatically). </p>
<p>If you wish to create your own container object type (i.e, you can use <code>in</code> on it by itself, but NOT <code>for</code> <code>in</code>), you just need the <code>__contains__</code> method. </p>
<pre><code>class MyUselessContainer():
    def __contains__(self, obj):
        return True

m = MyUselessContainer()
1 in m # True
'Foo' in m # True
TypeError in m # True
None in m # True
</code></pre>
<hr/>
<p><sup>1</sup> Note that, to be an iterator, an object must implement <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="noreferrer">the iterator protocol</a>. This only means that both the <code>__next__</code> and <code>__iter__</code> methods must be <em>correctly</em> implemented (generators come with this functionality "for free", so you don't need to worry about it when using them). Also note that the <code>___next__</code> method <a href="https://docs.python.org/2/library/stdtypes.html#iterator.next" rel="noreferrer">is actually <code>next</code> (no underscores) in Python 2</a>. </p>
<p><sup>2</sup> See <a href="https://stackoverflow.com/a/7542261/208880">this answer</a>  for the different ways to create iterable classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>For loop basically calls the <code>next</code> method of an object that is applied to (<code>__next__</code> in Python 3).</p>
<p>You can simulate this simply by doing:</p>
<pre><code>iter = (i for i in range(5))

print(next(iter))
print(next(iter))  
print(next(iter))  
print(next(iter))  
print(next(iter)) 

# this prints 1 2 3 4 
</code></pre>
<p>At this point there is no next element in the input object. So doing this:</p>
<pre><code>print(next(iter))  
</code></pre>
<p>Will result in <code>StopIteration</code> exception thrown. At this point <code>for</code> will stop. And iterator can be <a href="https://stackoverflow.com/a/5262255/248823">any object</a> which will respond to the <code>next()</code> function and throws the exception when there are no more elements. It does not have to be any pointer or reference (there are no such things in python anyway in C/C++ sense), linked list, etc. </p>
</div>
<div class="post-text" itemprop="text">
<p>There is an iterator protocol in python that defines how the <code>for</code> statement will behave with lists and dicts, and other things that can be looped over.</p>
<p>It's in the python docs <a href="https://docs.python.org/2/library/stdtypes.html" rel="nofollow">here</a> and <a href="https://docs.python.org/3/library/stdtypes.html" rel="nofollow">here</a>.</p>
<p>The way the iterator protocol works typically is in the form of a python generator.  We <code>yield</code> a value as long as we have a value until we reach the end and then we raise <code>StopIteration</code></p>
<p>So let's write our own iterator:</p>
<pre><code>def my_iter():
    yield 1
    yield 2
    yield 3
    raise StopIteration()

for i in my_iter():
    print i
</code></pre>
<p>The result is:</p>
<pre><code>1
2
3
</code></pre>
<p>A couple of things to note about that.  The my_iter is a function.  my_iter() returns an iterator. </p>
<p>If I had written using iterator like this instead:</p>
<pre><code>j = my_iter()    #j is the iterator that my_iter() returns
for i in j:
    print i  #this loop runs until the iterator is exhausted

for i in j:
    print i  #the iterator is exhausted so we never reach this line
</code></pre>
<p>And the result is the same as above.  The iter is exhausted by the time we enter the second for loop.</p>
<p>But that's rather simplistic what about something more complicated?  Perhaps maybe in a loop why not?</p>
<pre><code>def capital_iter(name):
    for x in name:
        yield x.upper()
    raise StopIteration()

for y in capital_iter('bobert'):
    print y
</code></pre>
<p>And when it runs, we use the iterator on the string type (which is built into <strong>iter</strong>).  This in turn, allows us run a for loop on it, and yield the results until we are done. </p>
<pre><code>B
O
B
E
R
T
</code></pre>
<p>So now this begs the question, so what happens between yields in the iterator?  </p>
<pre><code>j = capital_iter("bobert")
print i.next()
print i.next()
print i.next()

print("Hey there!")

print i.next()
print i.next()
print i.next()

print i.next()  #Raises StopIteration
</code></pre>
<p>The answer is the function is paused at the yield waiting for the next call to next().</p>
<pre><code>B
O
B
Hey There!
E
R
T
Traceback (most recent call last):
  File "", line 13, in 
    StopIteration
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some additional details about the behaviour of <code>iter()</code> with <code>__getitem__</code> classes that lack their own <code>__iter__</code> method.</p>
<hr/>
<p>Before <code>__iter__</code> there was <code>__getitem__</code>.  If the <code>__getitem__</code> works with <code>int</code>s from <code>0</code> - <code>len(obj)-1</code>, then <code>iter()</code> supports these objects.  It will construct a new iterator that repeatedly calls <code>__getitem__</code> with <code>0</code>, <code>1</code>, <code>2</code>, <code>...</code> until it gets an <code>IndexError</code>, which it converts to a <code>StopIteration</code>.</p>
<p>See <a href="https://stackoverflow.com/a/7542261/208880">this answer</a> for more details of the different ways to create an iterator.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Excerpt from <a href="http://anandology.com/python-practice-book/iterators.html" rel="nofollow">the Python Practice book</a>:</strong></p>
<hr/>
<h1><strong>5. Iterators &amp; Generators</strong></h1>
<h2><strong>5.1. Iterators</strong></h2>
<p>We use for statement for looping over a list.</p>
<pre><code>&gt;&gt;&gt; for i in [1, 2, 3, 4]:
...     print i,
...
1
2
3
4
</code></pre>
<p>If we use it with a string, it loops over its characters.</p>
<pre><code>&gt;&gt;&gt; for c in "python":
...     print c
...
p
y
t
h
o
n
</code></pre>
<p>If we use it with a dictionary, it loops over its keys.</p>
<pre><code>&gt;&gt;&gt; for k in {"x": 1, "y": 2}:
...     print k
...
y
x
</code></pre>
<p>If we use it with a file, it loops over lines of the file.</p>
<pre><code>&gt;&gt;&gt; for line in open("a.txt"):
...     print line,
...
first line
second line
</code></pre>
<p>So there are many types of objects which can be used with a for loop. These are called iterable objects.</p>
<p>There are many functions which consume these iterables.</p>
<pre><code>&gt;&gt;&gt; ",".join(["a", "b", "c"])
'a,b,c'
&gt;&gt;&gt; ",".join({"x": 1, "y": 2})
'y,x'
&gt;&gt;&gt; list("python")
['p', 'y', 't', 'h', 'o', 'n']
&gt;&gt;&gt; list({"x": 1, "y": 2})
['y', 'x']
</code></pre>
<h2><strong>5.1.1. The Iteration Protocol</strong></h2>
<p>The built-in function iter takes an iterable object and returns an iterator.</p>
<pre><code>    &gt;&gt;&gt; x = iter([1, 2, 3])
&gt;&gt;&gt; x
&lt;listiterator object at 0x1004ca850&gt;
&gt;&gt;&gt; x.next()
1
&gt;&gt;&gt; x.next()
2
&gt;&gt;&gt; x.next()
3
&gt;&gt;&gt; x.next()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
</code></pre>
<h2><strong>StopIteration</strong></h2>
<p>Each time we call the next method on the iterator gives us the next element. If there are no more elements, it raises a StopIteration.</p>
<p>Iterators are implemented as classes. Here is an iterator that works like built-in xrange function.</p>
<pre><code>class yrange:
    def __init__(self, n):
        self.i = 0
        self.n = n

    def __iter__(self):
        return self

    def next(self):
        if self.i &lt; self.n:
            i = self.i
            self.i += 1
            return i
        else:
            raise StopIteration()
</code></pre>
<p>The <strong>iter</strong> method is what makes an object iterable. Behind the scenes, the iter function calls <strong>iter</strong> method on the given object.</p>
<p>The return value of <strong>iter</strong> is an iterator. It should have a next method and raise StopIteration when there are no more elements.</p>
<p>Lets try it out:</p>
<pre><code>&gt;&gt;&gt; y = yrange(3)
&gt;&gt;&gt; y.next()
0
&gt;&gt;&gt; y.next()
1
&gt;&gt;&gt; y.next()
2
&gt;&gt;&gt; y.next()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 14, in next
</code></pre>
<h2><strong>StopIteration</strong></h2>
<p>Many built-in functions accept iterators as arguments.</p>
<pre><code>&gt;&gt;&gt; list(yrange(5))
[0, 1, 2, 3, 4]
&gt;&gt;&gt; sum(yrange(5))
10
</code></pre>
<p>In the above case, both the iterable and iterator are the same object. Notice that the <strong>iter</strong> method returned self. It need not be the case always.</p>
<pre><code>class zrange:
    def __init__(self, n):
        self.n = n

    def __iter__(self):
        return zrange_iter(self.n)

class zrange_iter:
    def __init__(self, n):
        self.i = 0
        self.n = n

    def __iter__(self):
        # Iterators are iterables too.
        # Adding this functions to make them so.
        return self

    def next(self):
        if self.i &lt; self.n:
            i = self.i
            self.i += 1
            return i
        else:
            raise StopIteration()
</code></pre>
<p>If both iteratable and iterator are the same object, it is consumed in a single iteration.</p>
<pre><code>&gt;&gt;&gt; y = yrange(5)
&gt;&gt;&gt; list(y)
[0, 1, 2, 3, 4]
&gt;&gt;&gt; list(y)
[]
&gt;&gt;&gt; z = zrange(5)
&gt;&gt;&gt; list(z)
[0, 1, 2, 3, 4]
&gt;&gt;&gt; list(z)
[0, 1, 2, 3, 4]
</code></pre>
<h2><strong>5.2. Generators</strong></h2>
<p>Generators simplifies creation of iterators. A generator is a function that produces a sequence of results instead of a single value.</p>
<pre><code>def yrange(n):
   i = 0
    while i &lt; n:
        yield i
        i += 1
</code></pre>
<p>Each time the yield statement is executed the function generates a new value.</p>
<pre><code>&gt;&gt;&gt; y = yrange(3)
&gt;&gt;&gt; y
&lt;generator object yrange at 0x401f30&gt;
&gt;&gt;&gt; y.next()
0
&gt;&gt;&gt; y.next()
1
&gt;&gt;&gt; y.next()
2
&gt;&gt;&gt; y.next()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
</code></pre>
<h2><strong>StopIteration</strong></h2>
<p>So a generator is also an iterator. You don’t have to worry about the iterator protocol.</p>
<p>The word “generator” is confusingly used to mean both the function that generates and what it generates. In this chapter, I’ll use the word “generator” to mean the generated object and “generator function” to mean the function that generates it.</p>
<p>Can you think about how it is working internally?</p>
<p>When a generator function is called, it returns a generator object without even beginning execution of the function. When next method is called for the first time, the function starts executing until it reaches yield statement. The yielded value is returned by the next call.</p>
<p>The following example demonstrates the interplay between yield and call to next method on generator object.</p>
<pre><code>&gt;&gt;&gt; def foo():
...     print "begin"
...     for i in range(3):
...         print "before yield", i
...         yield i
...         print "after yield", i
...     print "end"
...
&gt;&gt;&gt; f = foo()
&gt;&gt;&gt; f.next()
begin
before yield 0
0
&gt;&gt;&gt; f.next()
after yield 0
before yield 1
1
&gt;&gt;&gt; f.next()
after yield 1
before yield 2
2
&gt;&gt;&gt; f.next()
after yield 2
end
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
</code></pre>
<p><strong>StopIteration</strong></p>
<p>Lets see an example:</p>
<pre><code>def integers():
    """Infinite sequence of integers."""
    i = 1
    while True:
        yield i
        i = i + 1

def squares():
    for i in integers():
        yield i * i

def take(n, seq):
    """Returns first n values from the given sequence."""
    seq = iter(seq)
    result = []
    try:
        for i in range(n):
            result.append(seq.next())
    except StopIteration:
        pass
    return result

print take(5, squares()) # prints [1, 4, 9, 16, 25]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Concept 1</strong></p>
<blockquote>
<p>All generators are iterators but all iterators are not generator</p>
</blockquote>
<p><strong>Concept 2</strong></p>
<blockquote>
<p>An iterator is an object with a next (Python 2) or <strong>next</strong> (Python 3)
  method.</p>
</blockquote>
<p><strong>Concept 3</strong></p>
<blockquote>
<p>Quoting from wiki
  <a href="https://wiki.python.org/moin/Generators" rel="nofollow">Generators</a> Generators
  functions allow you to declare a function that behaves like an
  iterator, i.e. it can be used in a for loop.</p>
</blockquote>
<p>In your case</p>
<pre><code>&gt;&gt;&gt; it = (i for i in range(5))
&gt;&gt;&gt; type(it)
&lt;type 'generator'&gt;
&gt;&gt;&gt; callable(getattr(it, 'iter', None))
False
&gt;&gt;&gt; callable(getattr(it, 'next', None))
True
</code></pre>
</div>
<span class="comment-copy">More info on that <a href="https://wiki.python.org/moin/Generators" rel="nofollow noreferrer">here</a> and <a href="https://docs.python.org/3.4/reference/expressions.html" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">@Matteo: Marcin is correct. And yes, you're thinking of it as a pointer, but isn't a pointer. Your code - the stuff in the parentheses - it a generator comprehension. Once the generator raises <code>StopIteration</code>, it's done. No, <code>0,1,2,3,4</code> is not stored anywhere. <code>range(5)</code> produces the values one at a time. It doesn't produce them all at once. Each time <code>next()</code> is called, the generator generates the next value. Look up some information about functional programming, such as in Haskel, where this idea is normal, vs languages like Java and c++.</span>
<span class="comment-copy">your "manual" loop is sus.  you simply assign to <code>iterable.__next__</code> (which may or may not exist for an iterable!)  and never call it</span>
<span class="comment-copy">it would be more correct to create a <code>temp = iter(iterable)</code> and then call <code>next(temp)</code> in the try block.  a <code>listiterator</code>, for example, has no <code>__next__</code> method</span>
<span class="comment-copy">This answer conflates the <code>in</code> operator as used in code like <code>1 in [1, 2, 3]</code> with the keyword's usage in <code>for</code> loops. The <code>in</code> operator simply calls the <a href="https://docs.python.org/2.7/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer"><code>__contains__</code> method</a>, falling back to iterating over the object if the method does not exist.</span>
<span class="comment-copy">It is not necessary to explicitly raise a <code>StopIteration</code>.  Generator functions will do this anyway with that line omitted</span>
<span class="comment-copy">Much of this answer is irrelevant to the question.</span>
