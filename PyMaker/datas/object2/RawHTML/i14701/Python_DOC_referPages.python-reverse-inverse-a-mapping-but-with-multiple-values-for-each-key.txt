<div class="post-text" itemprop="text">
<p>This is really a variation on this question, but not a duplicate:</p>
<p><a href="https://stackoverflow.com/q/483666/992834">Python reverse / invert a mapping</a></p>
<p>Given a dictionary like so:</p>
<p><code>mydict= { 'a': ['b', 'c'], 'd': ['e', 'f'] }</code></p>
<p>How can one invert this dict to get:</p>
<p><code>inv_mydict = { 'b':'a', 'c':'a', 'e':'d', 'f':'d' }</code></p>
<p>Note that values span uniquely under each key.</p>
<p><strong>Note</strong>: I previously had syntax <code>map = ...</code> and <code>dict = ...</code> Reminder not to use <code>map</code> and <code>dict</code> as they are built-in functions, see excellent comments and answers below :)</p>
</div>
<div class="post-text" itemprop="text">
<h3>TL;DR</h3>
<p>Use dictionary comprehension, like this</p>
<pre><code>&gt;&gt;&gt; my_map = { 'a': ['b', 'c'], 'd': ['e', 'f'] }
&gt;&gt;&gt; {value: key for key in my_map for value in my_map[key]}
{'c': 'a', 'f': 'd', 'b': 'a', 'e': 'd'}
</code></pre>
<hr/>
<p>The above seen dictionary comprehension is functionally equivalent to the following looping structure which populates an empty dictionary</p>
<pre><code>&gt;&gt;&gt; inv_map = {}
&gt;&gt;&gt; for key in my_map:
...     for value in my_map[key]:
...         inv_map[value] = key
... 
&gt;&gt;&gt; inv_map
{'c': 'a', 'f': 'd', 'b': 'a', 'e': 'd'}
</code></pre>
<p><strong>Note:</strong> Using <code>map</code> shadows the built-in <a href="https://docs.python.org/3/library/functions.html#map" rel="noreferrer"><code>map</code></a> function. So, don't use that as a variable name unless you know what you are doing.</p>
<hr/>
<p><strong>Other similar ways to do the same</strong></p>
<p><strong>Python 3.x</strong></p>
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#dict.items" rel="noreferrer"><code>dict.items</code></a>, like this</p>
<pre><code>&gt;&gt;&gt; {value: key for key, values in my_map.items() for value in values}
{'c': 'a', 'f': 'd', 'b': 'a', 'e': 'd'}
</code></pre>
<p>We use <code>items()</code> method here, which would create a view object from the dictionary which would give key value pairs on iteration. So we just iterate over it and construct a new dictionary with the inverse mapping.</p>
<p><strong>Python 2.x</strong></p>
<p>You can use <a href="https://docs.python.org/2/library/stdtypes.html#dict.iteritems" rel="noreferrer"><code>dict.iteritems</code></a> like this</p>
<pre><code>&gt;&gt;&gt; {value: key for key, values in my_map.iteritems() for value in values}
{'c': 'a', 'b': 'a', 'e': 'd', 'f': 'd'}
</code></pre>
<p>We don't prefer <code>items()</code> method in 2.x, because it will return a list of key-value pairs. We don't want to construct a list just to iterate and construct a new dictionary. That is why we prefer <code>iteritems()</code>, which returns an iterator object which gives a key value pair on iteration.</p>
<p><strong>Note:</strong> The actual equivalent of Python 3.x's <code>items</code> would be Python 2.x's <a href="https://docs.python.org/2/library/stdtypes.html#dict.viewitems" rel="noreferrer"><code>viewitems</code></a> method, which returns a view object. Read more about the view object in the official documentation, <a href="https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects" rel="noreferrer">here</a>.</p>
<hr/>
<h2><code>iter*</code> vs <code>view*</code> methods in Python 2.x</h2>
<p>The main difference between <code>iter*</code> functions and <code>view*</code> functions in Python 2.x is that, the view objects reflect the current state of the dictionary. For example,</p>
<pre><code>&gt;&gt;&gt; d = {1: 2}
&gt;&gt;&gt; iter_items = d.iteritems()
&gt;&gt;&gt; view_items = d.viewitems()
</code></pre>
<p>now we add a new element to the dictionary</p>
<pre><code>&gt;&gt;&gt; d[2] = 3
</code></pre>
<p>If you try to check if <code>(2, 3)</code> (key-value pair) is in the <code>iter_items</code>, it will throw an error</p>
<pre><code>&gt;&gt;&gt; (2, 3) in iter_items
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
RuntimeError: dictionary changed size during iteration
</code></pre>
<p>but view object will reflect the current state of the dictionary. So, it will work fine</p>
<pre><code>&gt;&gt;&gt; (2, 3) in view_items
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>mp = { 'a': ['b', 'c'], 'd': ['e', 'f'] }

pm={}
for x in mp.iterkeys():
    for d in mp[x]:
        pm[d]=x

print pm
</code></pre>
<p>Output:</p>
<blockquote>
<p>{'c': 'a', 'b': 'a', 'e': 'd', 'f': 'd'}</p>
</blockquote>
<p><em>Note:</em> a dictionary is an <em>unordored</em> data structure, so the result may not be ordered as you want it to be. </p>
</div>
<span class="comment-copy"><code>map</code> is a keyword, don't use as a dictionary name.</span>
<span class="comment-copy">I changed to wording to dict as a result</span>
<span class="comment-copy">@KevinLee, <code>dict</code> is a keyword too :-))</span>
<span class="comment-copy">@ForceBru thanks I'm not thinking Python enough.</span>
<span class="comment-copy">Thanks for the unordered reminder, I ended up using the library <code>natsort</code> to sort my dictionary.</span>
