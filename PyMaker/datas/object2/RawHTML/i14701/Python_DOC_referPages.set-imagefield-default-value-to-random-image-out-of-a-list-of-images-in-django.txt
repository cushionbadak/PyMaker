<div class="post-text" itemprop="text">
<p>I have some images inside the static directory and want to create a model that has a ImageField. I want to set the default field to any one of those  images. I have tried using this - </p>
<pre><code>def randomImage():
    return ImageFile('media/blog/image/' + str(random.randrange(1, 15, 1)) + '.jpg')

# ----------------------- Model for each post in the blog-------------------
class Post(models.Model):
    heading = models.CharField(max_length=150)
    author = models.ForeignKey(User)
    postBody = models.TextField()
    postDate = models.DateTimeField('posting date')
    postImage = models.ImageField(upload_to='media/blog/image/'+str(int(time.time())), default=randomImage)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here I'm taking some assumptions,<br/>
1. Your <strong><em>default images</em></strong> are inside the <strong><code>static</code></strong> directory<br/>
2. Inside the <strong><code>static</code></strong> directory, <strong><em>all files are images</em></strong>
<br/><br/></p>
<h2>What is the <strong><em>major trick</em></strong> here ?<br/></h2>
<p>Django needs a <strong>valid file path</strong> only to create or update a <strong><em>file entry</em></strong> (image is also a file). So, what we're doing here is, list out all the <strong><em>files</em></strong> (assuming those are only images) and picking up one entry randomly using <a href="https://docs.python.org/3/library/random.html#random.choice" rel="nofollow noreferrer"><strong><code>random.choice()</code></strong></a> and retun an <strong><em>absoulute path</em></strong> (something like <code>static/my_img.jpg</code>) to the <strong><code>default</code></strong> argument
<br/><br/></p>
<pre><code>import time
from random import choice
from os.path import join as path_join
from os import listdir
from os.path import isfile


<b>def random_img():
    dir_path = 'static'
    files = [content for content in listdir(dir_path) if isfile(path_join(dir_path, content))]
    return path_join(dir_path, choice(files))</b>


class Post(models.Model):
    # other fields
    postImage = models.ImageField(
        upload_to='media/blog/image/' + str(int(time.time())),
        <b>default=random_img</b>)</code></pre>
<p><br/><br/></p>
<h2>UPDATE-1</h2>
<p>I've created a minimal example in <strong>Django 2.1.1</strong> which can be found in follwing git repo<br/>
Repopsitory link -&gt; <a href="https://bitbucket.org/jerinpetergeorge/django2x/src/master/" rel="nofollow noreferrer">django2X</a><br/>
1. clone the repository,create a virtual env and install the dependencies (provided a <code>requirements.txt</code> file)<br/>
2.create a new superuser or use mine (username -&gt; <code>admin</code>, pass-&gt; <code>jerin123@</code>)<br/>
3.run the server and login to django admin : (<a href="https://i.stack.imgur.com/ysJtM.png" rel="nofollow noreferrer">screenshot-1</a>)<br/>
4. Create a new <code>Post</code> instance (again and again)
<br/><br/>
That's it
<br/><br/></p>
<h2>UPDATE-2</h2>
<p>I've made few changes in my <em>minimal example</em>, which are<br/>
1. Created a simple object creation (here, the <strong><code>Post</code></strong> model object) <strong><em>while every django startup</em></strong> (checkout <code>sample/app.py</code>)<br/>
2. Added <strong><code>MEDIA_ROOT</code></strong> and <strong><code>MEDIA_URL</code></strong> to the <code>settings.py</code> file
<br/><br/>
Now, start your project (it will create 3 objects per every startup) and go to <a href="http://127.0.0.1:8000/admin/sample/post/" rel="nofollow noreferrer">http://127.0.0.1:8000/admin/sample/post/</a>.<br/> Then open any instance and click on the image link (<a href="https://i.stack.imgur.com/xdMnA.png" rel="nofollow noreferrer">screenshot-2</a>) and it will open the image (<a href="https://i.stack.imgur.com/EAhbr.jpg" rel="nofollow noreferrer">screenshot-3</a>)</p>
</div>
<div class="post-text" itemprop="text">
<p>My solution is to <strong>override the model save method</strong> and check <strong>if the model is being created for the first time and also check if the postImage image field is empty</strong>. If so <strong>populate the postImage field with contents of a Radom image</strong>. Django will handle the rest</p>
<p>If we use the path of the Radom image directly in our model we will end up like serving some of the post model files from the media folder and some other from the static directory which is not recommended. Instead, we feed the image file content to the postImage field and Django will save the image to media folder and thus we can serve all our model images from media folder itself. Wola</p>
<p>Code</p>
<p>The following code is tested in <strong>Python 3.6</strong>
Please add the code to your <strong>models.py</strong></p>
<pre><code>from pathlib import Path
from random import randint
import time
from django.core.files import File
from django.db import models

allowed_image_extensions = ['.jpg', '.png', '.jpeg']


def get_file_extension(file_path):
    return Path(file_path).suffix


def get_files_in_directory(directory, absolute_path=False):
    from os import listdir
    from os.path import isfile
    only_files = [f for f in listdir(directory) if isfile("{}/{}".format(directory, f))]

    if not absolute_path:
        return only_files

    else:
        return ["{}/{}".format(directory, file_) for file_ in only_files]


def get_random_image_from_directory(directory_path, image_extension=None):
    files_in_directory_path = get_files_in_directory(directory_path, absolute_path=True)

    if image_extension:
        allowed_file_types = [image_extension]
    else:
        allowed_file_types = allowed_image_extensions

    # filter out files of type other than required file types
    filtered_files_list = [_file for _file in files_in_directory_path if
                       get_file_extension(_file).lower() in allowed_file_types]

   random_index = randint(0, len(filtered_files_list) - 1)
   random_file_path = filtered_files_list[random_index]
   random_file_content = File(open(random_file_path, 'rb'))

   return random_file_content


def get_post_image_path(instance, filename):
    path_first_component = 'posts'
    ext = get_file_extension(filename)
    current_time_stamp = int(time.time())
    file_name = '{}/posts_{}_{}{}'.format(path_first_component, instance.id, current_time_stamp, ext)
    full_path = path_first_component + file_name
    return full_path

class Post(models.Model):
    heading = models.CharField(max_length=150)
    author = models.ForeignKey(User)
    postBody = models.TextField()
    postDate = models.DateTimeField('posting date')
    postImage = models.ImageField(blank=True, null=True, upload_to=get_post_image_path)

    # override model save method
    def save(self, *args, **kwargs):

        # check model is new and postImage is empty
        if self.pk is None and not self.postImage:
            random_image = get_random_image_from_directory(settings.STATIC_ROOT)
            self.postImage = random_image
            random_image.close()


    super(Post, self).save(*args, **kwargs)
</code></pre>
<p>Also no need to set ‘/media’ in upload_to path. Django will read media path from settings variable</p>
<p>The best practice is to move those set of default images out of static directory to another folder probably another folder with name resources or any another meaningful name since the static directory contents will change frequently as the project grows</p>
</div>
<span class="comment-copy">This is related: <a href="http://stackoverflow.com/questions/1276887/default-image-for-imagefield-in-djangos-orm" title="default image for imagefield in djangos orm">stackoverflow.com/questions/1276887/…</a></span>
<span class="comment-copy">@abidibo No the above link doesn't tells anything about using random image path generating function. What I want is to use a function that returns a random image path and then to set it as the image for that record.</span>
<span class="comment-copy">I'm putting a bounty on this as this question has no answer, and the linked answer is completely unrelated.</span>
<span class="comment-copy">@Routhinator I've added one answer, Try it :)</span>
<span class="comment-copy">@JPG Taking a look, will award bounty once I confirm it works well. :)</span>
<span class="comment-copy">Looks like this won't work. Django executes the random function when django.start() is called, which is before static is collected. It gets a default response I added for if the files do not exist, and then it uses that response for the default setting statically. It does not call the function on model.save(), rendering the function useless.</span>
<span class="comment-copy">Maybe I spoke too soon. It works for new users being registered after application start, but not for the users being save from the initial import on startup.. Trying to track down why.</span>
<span class="comment-copy">What you mean by <b><i>initial import</i></b>. I don't get that point</span>
<span class="comment-copy">I'm migrating an exisiting site into Django. After I run staticfile collection and migrations in my startup.py script, I run a custom management command called "installlegacy" which checks to see if users and data have been imported. This uses a legacy db connection to grab the user objects from the old DB, and then maps their properties to the new user model, and then calls user.save() - For some reason during this process, the function fails to find any images, even though staticfiles have already been collected.</span>
<span class="comment-copy">in order to give you a complete picture, I've created snippets of the startup script, import process, modified version of your example and the models.py for the members. The random_img() function is set on the default for the background image: <a href="https://gitlab.routh.io/users/Routhinator/snippets" rel="nofollow noreferrer">gitlab.routh.io/users/Routhinator/snippets</a></span>
<span class="comment-copy">Will test this, I think it has promise in that this will force the random image to actually be called on save. I think what happens with @JPG 's method is it's called once per execution when the model is loaded by django, so my import only executes it once, before staticfiles are collected, and then uses the failure result for every user. Whereas this will be forcibly called on each call to save, and will work all the time.</span>
<span class="comment-copy">Ah, this code is not immune to <code>django.core.exceptions.SuspiciousFileOperation: The joined path (/usr/src/app/static/images/avatars/wolf_avatar1.jpg) is located outside of the base path component (/usr/src/app/media)</code></span>
<span class="comment-copy">Managed to get it to work with a small change: .<code>self.postImage.save(                 str(self.postDate) + get_file_extension(random_image.name), random_image, save=True)</code></span>
<span class="comment-copy">Bounty awarded. This seems to be the most robust solution that works on every model save. Please update your answer with the small modification that was needed.</span>
<span class="comment-copy">Two more small modifications. On this line you are creating a list of lists, which causes the extension filter to filter everything out, even if valid. It should be <code>allowed_file_types = allowed_image_extensions</code> (no [] around the var), and the absolute path is needed, so in model save we should actually call it with the django settings.STATIC_ROOT var: <code>get_random_image_from_directory(settings.STATIC_ROOT)</code></span>
