<div class="post-text" itemprop="text">
<p>I found some Python code that claims checking primality based on <a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem" rel="nofollow noreferrer">Fermat's little theorem</a>:</p>
<pre><code>def CheckIfProbablyPrime(x):
    return (2 &lt;&lt; x - 2) % x == 1
</code></pre>
<p>My questions:</p>
<ol>
<li>How does it work?</li>
<li>What's its relation to Fermat's little theorem?</li>
<li>How accurate is this method? </li>
<li>If it's not accurate, what's the advantage of using it?</li>
</ol>
<p>I found it <a href="https://stackoverflow.com/questions/12421969/finding-all-divisors-of-a-number-optimization">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<h1>1. How does it work?</h1>
<p><a href="http://en.wikipedia.org/wiki/Fermat%27s_little_theorem" rel="nofollow noreferrer">Fermat's little theorem</a> says that if a number <em>x</em> is prime, then for any integer <em>a</em>:</p>
<p><img alt="Fermat's Little Theorem Part 1" src="https://i.stack.imgur.com/v6q5h.gif"/></p>
<p>If we divide both sides by <em>a</em>, then we can re-write the equation as follows:</p>
<p><img alt="Fermat's Little Theorem Part 2" src="https://i.stack.imgur.com/65Rpn.gif"/></p>
<p>I'm going to punt on proving <em>how</em> this works (your first question) because there are many good proofs (better than I can provide) on <a href="http://en.wikipedia.org/wiki/Proofs_of_Fermat%27s_little_theorem" rel="nofollow noreferrer">this wiki page</a> and under some Google searches.</p>
<h1>2. Relation between code and theorem</h1>
<p>So, the function you posted checks if <code>(2 &lt;&lt; x - 2) % x == 1</code>.</p>
<p>First off, <code>(2 &lt;&lt; x-2)</code> is the same thing as writing <code>2**(x-1)</code>, or in math-form:</p>
<p><img alt="2**(x-1)" src="https://i.stack.imgur.com/uH09u.gif"/></p>
<p>That's because <code>&lt;&lt;</code> is the <a href="http://en.wikipedia.org/wiki/Logical_shift" rel="nofollow noreferrer">logical left-shift operator</a>, which is explained better <a href="https://stackoverflow.com/questions/141525/absolute-beginners-guide-to-bit-shifting">here</a>. The relation between bit-shifting and multiplying by powers of 2 is specific to the way that numbers are represented on computers (in binary), but it all boils down to</p>
<p><img alt="2 &lt;&lt; (x-1) == 2**(x)" src="https://i.stack.imgur.com/srjHQ.gif"/></p>
<p>I can subtract 1 from the exponent on both sides, which gives</p>
<p><img alt="2 &lt;&lt; (x-2) == 2**(x-1)" src="https://i.stack.imgur.com/81v1l.gif"/></p>
<hr/>
<p>Now, we know from above that <em>for any number a</em>,</p>
<p><img alt="a**(x-1) == 1 (mod x)" src="https://i.stack.imgur.com/pgQu0.gif"/></p>
<p>Let's say then that <em>a = 2</em>. That gives us</p>
<p><img alt="2**(x-1) == 1 (mod x)" src="https://i.stack.imgur.com/udUx2.gif"/></p>
<p>Well heck, that's the same as <code>2 &lt;&lt; (x-2)</code>! So then we can write:</p>
<p><img alt="Almost final relation" src="https://i.stack.imgur.com/Z1qMC.gif"/></p>
<p>Which leads to the final relation:</p>
<p><img alt="Final Relation" src="https://i.stack.imgur.com/CmHpj.gif"/></p>
<hr/>
<p>Now, the math version of mod looks kind of odd, but we can write the equivalent code as follows:</p>
<p><code>(2 &lt;&lt; x - 2) % x == 1</code></p>
<p>And that's the relation.</p>
<h1>3. Accuracy of method</h1>
<p>So, I think "accuracy" is a bad term here, because Fermat's little theorem is definitely true for all prime numbers. However, that does <em>not</em> mean that it's true or false for all numbers -- which is to say, if I have some number <em>i</em>, and I'm not sure if <em>i</em> is prime, using Fermat's Little Relation will only tell me if it is definitely NOT prime. If Fermat's Little Relation is true, then <em>i</em> could not be prime. These kinds of numbers are called <a href="http://en.wikipedia.org/wiki/Pseudoprime" rel="nofollow noreferrer">pseudoprime numbers</a>, or more specifically in this case <a href="http://en.wikipedia.org/wiki/Fermat_pseudoprime" rel="nofollow noreferrer">Fermat Pseudoprime</a> numbers. </p>
<p>If this sort of thing sounds interesting, take a look at the <a href="http://en.wikipedia.org/wiki/Carmichael_number" rel="nofollow noreferrer">Carmichael numbers</a> AKA the Absolute Fermat Pseudoprimes, which pass the Fermat test in any base but are not prime. In our case we run into numbers which pass in base 2, but Fermat's little theorem might not hold for these numbers in other bases -- the Carmichael numbers pass the test for all bases coprime to <code>x</code>.</p>
<p>On the wiki page of the Carmichael there is a discussion of their distribution over the range of natural numbers -- they appear exponentially with the size of the range over which you're looking, though the exponent is less than 1 (about 1/3). So, if you're searching for primes over a big range, you're going to run into exponentially more Carmichael numbers, which are effectively false positives for this method <code>CheckIfProbablyPrime</code>. That might be okay, depending on your input and how much you care about running into false positives.</p>
<h1>4. Why is this useful?</h1>
<p>In short, it's an optimization.</p>
<p>The main reason to use something like this is to speed up a search for prime numbers. That's because actually checking if a number is prime is expensive -- i.e. more than O(1) running time. Doable, but still more expensive than O(1) time. So, if we can avoid doing that actual check for some numbers, we'll be able to devote more time to checking actual candidates. Since Fermat's little relation will only say yes if a number is possibly prime (it will never say no if the number is prime), and it can be checked in O(1) time, we can toss it into an <code>is_prime</code> loop to ignore a fair amount of numbers. So, we can speed things up.</p>
<p>There are many primality checks like this one, you can find some coded prime checkers <a href="http://en.wikipedia.org/wiki/Primality_test" rel="nofollow noreferrer">here</a></p>
<hr/>
<h1>Final Note</h1>
<p>One of the confusing things about this optimization is that it uses the bit shift operator <code>&lt;&lt;</code> instead of the exponentiation operator <code>**</code>. This is because bit shifting is one of the fastest operations that your computer can do, while exponentiation is slower by some amount. It is <a href="https://stackoverflow.com/questions/6357038/is-multiplication-and-division-using-shift-operators-in-c-actually-faster">not always the best optimization</a> in many cases, because most modern languages know how to replace things we write with more optimized operations. But, that's my venture as to <em>why</em> the authors of this code used the bit shift instead of <code>2**(x-1)</code>.</p>
<hr/>
<p>Edit: As MarkDickinson notes, taking the exponent of a number and then modding it explicitly is not the best way to do it. This is a thing called <a href="http://en.wikipedia.org/wiki/Modular_exponentiation" rel="nofollow noreferrer">modular exponentiation</a>, and there exist algorithms which can do it faster than the way we've written it. Python's builtin <a href="https://docs.python.org/3/library/functions.html#pow" rel="nofollow noreferrer"><code>pow</code></a> actually implements one of these algorithms, and takes an optional third argument to mod by. So we can write a final version of this function:</p>
<pre><code>def CheckIfProbablyPrime(x):
    return pow(2, x-1, x) == 1
</code></pre>
<p>Which is not only more readable but also <em>faster</em> than the confusing bit-shift crap. <a href="https://www.google.com/search?q=premature+optimization+is+the+root+of+all+evil" rel="nofollow noreferrer">You know what they say.</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I believe, the code in your example is incorrect because binary left shift operator is not equivalent to power of a number, which is used in Fermat's little theorem. With base of two, binary left shift would be equal to power of x + 1, which is NOT used in a version of Fermat's little format.</p>
<p>Instead, use ** for power of integer in Python.</p>
<pre><code>def CheckIfProbablyPrime(x):
    return (2 ** x - 2) % x == 0
</code></pre>
<p>" p − a is an integer multiple of p " therefore for primes, following theorem, result of 2 in power of x - 2 divided by x will leave a leftover of 0 (modulo '%' checks for number left over after division.</p>
<p>For x - 1 version,</p>
<pre><code>def CheckIfProbablyPrime(a, x):
   return (a ** (x-1) - 1) % x == 0
</code></pre>
<p>both variations should result as true for prime numbers, because they're representing the Fermat's little theorem in Python</p>
</div>
<span class="comment-copy">This is a pretty direct implementation of the theorem, using <code>a == 2</code>. It uses a bit shift operator to do <code>2**x</code>, read up on the operator <a href="https://wiki.python.org/moin/BitwiseOperators" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">I couldn't understand most of it, but does this help?: <a href="http://math.stackexchange.com/questions/659529/prime-number-test-and-fermats-little-theorem" title="prime number test and fermats little theorem">math.stackexchange.com/questions/659529/…</a></span>
<span class="comment-copy">@Marius ok, so he did it to gain performance. still why using 2 ? isn't it working for any prime? no difference?</span>
<span class="comment-copy">@jakekimds thanks, that was a great and short explanation for how the theorem works.</span>
<span class="comment-copy">@bigOTHER I believe 341, 561, 645 and 2 doesn't work to name a few.</span>
<span class="comment-copy">you said , the function  is to tell if a number is "definitely  Not a prime" . Could you explain, why 341, 561, 645 and 2 return False?</span>
<span class="comment-copy">Nice answer.  It's also worth noting that <code>pow(2, x-1, x)</code> is going to be <i>much</i> more (time and space) efficient than <code>(2 &lt;&lt; x - 2) % x</code> for large <code>x</code>.</span>
<span class="comment-copy">@bigOTHER: If the test returns <code>False</code>, then the input is definitely not an odd prime.  If it returns <code>True</code>, the test is inconclusive: it may or may not be a prime.  Not surprisingly, <code>2</code> is a special case here, but the other numbers you ask about (341, 561, 645) are all composite.</span>
<span class="comment-copy">Bit shifting is not my specialty, but if <code>x</code> is large, is computing <code>(2 &lt;&lt; x-2)%x</code> computationally better?  That's a huge number of bits that you're trying to find the modulus of, would it be better to go with traditional trial division?</span>
<span class="comment-copy">@Dan: Good answer, but your definition of Carmichael numbers is incorrect. A base-2 pseudoprime is a composite which this test claims is prime. A Carmichael number is a composite which a test to <i>any</i> base claims is prime.</span>
<span class="comment-copy">I think you misinterpreted <code>2 &lt;&lt; x - 2</code>. Subtraction takes precedence in the order of operations, so this is <code>2 &lt;&lt;(x-2)</code> not <code>(2&lt;&lt;x)-2</code>.  <code>2&lt;&lt;(x-2)</code> is the same as <code>1&lt;&lt;(x-1)</code> or <code>2**(x-1)</code>.</span>
<span class="comment-copy">actually yes, thanks for pointing out</span>
