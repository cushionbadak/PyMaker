<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/986006/how-do-i-pass-a-variable-by-reference">How do I pass a variable by reference?</a>
<span class="question-originals-answer-count">
                    24 answers
                </span>
</li>
</ul>
</div>
<p>So basically i've observed that in python3 if i do something like</p>
<pre><code>a = 5
def addFive(x):
    x+=5
    return x
print(addFive(a),a)
</code></pre>
<p>The output will be "10 5" since a is not changed by the function.
However the same does not happen for lists:</p>
<pre><code>a = [1,2,3]

def b(x):
    z = x
    z.append(10)

b(a)
print(a)
</code></pre>
<p>When i run the function it changes the actual list. </p>
<p>Now to my Question: Why does this happen, where can i read up more about this(Honestly have no idea how to word my google search) and how can i avoid this. Please feel free to redirect me to other articles as this could be a common problem but I honestly couldn't find anything similar. </p>
<p>Thanks in advance :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3.2/library/copy.html" rel="nofollow"><code>copy</code></a> module.</p>
<pre><code>import copy

a = [1,2,3]

def b(x):
    z = copy.deepcopy(x)
    z.append(10)
    return z

b(a)
print(a)
</code></pre>
<p>This prints</p>
<pre><code>[1, 2, 3, 10]
[1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Each element in a Python <code>list</code> is a location in memory, so when you modify an element, you're actually modifying that reference in memory. So if you're familiar with C++, passing a list into a function in Python, is similar in concept to passing by reference.</p>
</div>
<span class="comment-copy">Read the paragraph on mutable vs. immutable values for your Python version: <a href="https://docs.python.org/2/reference/datamodel.html#objects-values-and-types" rel="nofollow noreferrer">Python 2 Data Model</a> or <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="nofollow noreferrer">Python 3 Data Model</a>.</span>
<span class="comment-copy">@Shashank you should link to the <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="nofollow noreferrer">Python 3</a> doc on same.</span>
<span class="comment-copy">Also <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">this FAQ</a>.</span>
<span class="comment-copy"><code>z = x[:]</code> will do it</span>
<span class="comment-copy">This is not an answer to the question. Also why was this upvoted? It recommends the use of copy.deepcopy when that it might not even be what the OP was looking for. We only need a shallow copy in this case and that can be done with x[:] or list(x).</span>
<span class="comment-copy">it answers "how can i avoid this," but yeah, doesn't answer the other questions.  it's a partial answer.  i'll expand it.</span>
<span class="comment-copy">true, only a shallow copy is needed if the contents of the list are ints.  but if a solution is desired when the contents of the list can be anything, <code>deepcopy</code> is the way to go.</span>
<span class="comment-copy">Bad explanation of what's going on, since in C++ I could do <code>int&amp; x</code> and that's impossible to do in Python. It's actually because <code>list</code> is mutable. Everything in Python is pass by assignment, and the <code>=</code> operator is actually assigning pointers, not values. Read the linked duplicate.</span>
<span class="comment-copy">i see your point. I was trying to suggest that how he's passing a list as an argument, is similar in concept to how one would pass params into a function by reference in C++.</span>
<span class="comment-copy">But this has less to do with passing-references-by-value than it has to do with mutability vs immutability. <code>list.append</code> is a mutation of an object, <code>__add__</code> method returns a brand new object because ints are immutable. I like the direction you're taking with this answer but it can be improved.</span>
<span class="comment-copy">You learn something new everyday around here :)</span>
