<div class="post-text" itemprop="text">
<p>With <a href="https://docs.python.org/3/library/abc.html" rel="nofollow">abstract base classes</a>, Python provides a way to know the behavior of objects without actually trying it out. In the standard library, we have some ABCs defined for containers in <a href="https://docs.python.org/3/library/collections.abc.html#module-collections.abc" rel="nofollow">collections.abc</a>. For example, one can test that an argument is iterable:</p>
<pre><code>from collections.abc import Iterable
def function(argument):
    if not isinstance(argument, Iterable):
        raise TypeError('argument must be iterable.')
    # do stuff with the argument
</code></pre>
<p>I was hoping that there would be one such ABC for deciding whether instances of a class can be compared but couldn't find one. Testing for the existence of <code>__lt__</code> methods is not sufficient. For example, dictionaries cannot be compared but <code>__lt__</code> is still defined (same with <code>object</code> actually).</p>
<pre><code>&gt;&gt;&gt; d1, d2 = {}, {}
&gt;&gt;&gt; d1 &lt; d2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: dict() &lt; dict()
&gt;&gt;&gt; hasattr(d1, '__lt__')
True
</code></pre>
<p>So my question is: is there a simple way to do it without doing the comparisons themselves and catching the <code>TypeError</code>?</p>
<p>My use case is similar to a sorted container: I'd like to raise an exception when I insert the first element and not to wait for a second element. I thought about comparing the element with itself, but is there a better approach:</p>
<pre><code>def insert(self, element):
    try:
        element &lt; element
    except TypeError as e:
        raise TypeError('element must be comparable.')
    # do stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, there is no such ABC, because an ABC <em>only dictates what attributes are there</em>. ABCs cannot test for the nature of the implementation (or even if those attributes are actually methods).</p>
<p>The presence of comparison methods (<code>__lt__</code>, <code>__gt__</code>, <code>__le__</code>, <code>__ge__</code> and <code>__eq__</code>) does <em>not</em> dictate that the class is going to be comparable with everything else. <em>Usually</em> you can only compare objects of the same type or class of types; numbers with numbers for example.</p>
<p>As such, <em>most</em> types<sup>*</sup> implement the comparison methods but return the <code>NotImplemented</code> sentinel object when comparing with other incompatible types. Returning <code>NotImplemented</code> signals to Python to give the right-hand value a say in the matter too. If <code>a.__lt__(b)</code> returns <code>NotImplemented</code> then <code>b.__gt__(a)</code> is tested too.</p>
<p>The base <code>object</code> provides default implementations for the methods, returning <code>NotImplemented</code>:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     pass
... 
&gt;&gt;&gt; Foo() &lt; Foo()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: Foo() &lt; Foo()
&gt;&gt;&gt; Foo().__lt__
&lt;method-wrapper '__lt__' of Foo object at 0x10f1cf860&gt;
&gt;&gt;&gt; Foo().__lt__(Foo())
NotImplemented
</code></pre>
<p>which is exactly what <code>dict.__lt__</code> does:</p>
<pre><code>&gt;&gt;&gt; {}.__lt__({})
NotImplemented
</code></pre>
<p>Numbers, however, only return <code>NotImplemented</code> when the other type is not comparable:</p>
<pre><code>&gt;&gt;&gt; (1).__lt__(2)
True
&gt;&gt;&gt; (1).__lt__('2')
NotImplemented
&gt;&gt;&gt; 1 &lt; 2
True
&gt;&gt;&gt; 1 &lt; '2'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: int() &lt; str()
</code></pre>
<p>As such, your <em>best</em> choice is to simply catch the <code>TypeError</code> thrown when values are not comparable.</p>
<hr/>
<p><sup>*</sup> I am not aware of any types in the Python 3 standard library that do not implement the comparison methods at this time.</p>
</div>
<span class="comment-copy">ABCs do not only state what attributes are there. That's all they can <i>enforce</i>, but since they are opt-in (need to inherit from it or explicitly register with it), most ABCs can and do define a contract. It is more than reasonable to assume, when <code>isinstance(x, abc.Sized)</code>, that <code>x.__len__</code> is a method returning a non-negative integer. It isn't checked programmatically, of course, but with Python being as dynamic as it is, nothing can really be checked.</span>
<span class="comment-copy">@delnan: sure, that is the intention of ABCs. But since the contract for the comparison methods is to return <code>NotImplemented</code> when passed an object type that is incompatible, you cannot test for implementation of that contract to that extent using ABCs.</span>
<span class="comment-copy">@Anonymous: Please don't add that function; calling all comparison methods can lead to side effects as a custom class could do <i>anything</i> when their special methods are called, including altering their own state.</span>
<span class="comment-copy">True, the double dispatch makes it more complicated. I'm mostly objecting to the general statements "only dictates what attributes are there" and "(or even if those attributes are actually methods)".</span>
<span class="comment-copy">Thanks for the detailed answer. Do you know if there are many cases of objects that can be compared with other types, besides numbers?</span>
