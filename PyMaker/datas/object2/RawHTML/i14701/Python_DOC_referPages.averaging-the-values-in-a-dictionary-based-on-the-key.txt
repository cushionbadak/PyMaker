<div class="post-text" itemprop="text">
<p>I am new to Python and I have a set of values like the following:</p>
<pre><code>(3, '655')
(3, '645')
(3, '641')
(4, '602')
(4, '674')
(4, '620')
</code></pre>
<p>This is generated from a CSV file with the following code (python 2.6):</p>
<pre><code>import csv
import time

with open('file.csv', 'rb') as csvfile:
    reader = csv.reader(csvfile)
    for row in reader:
        date = time.strptime(row[3], "%a %b %d %H:%M:%S %Z %Y")
        data = date, row[5]

        month = data[0][1]
        avg = data[1]
        monthAvg = month, avg
        print monthAvg
</code></pre>
<p>What I would like to do is get an average of the values based on the keys:</p>
<pre><code>(3, 647)
(4, 632)
</code></pre>
<p>My initial thought was to create a new dictionary.  </p>
<pre><code>loop through the original dictionary
    if the key does not exist
        add the key and value to the new dictionary
    else
        sum the value to the existing value in the new dictionary
</code></pre>
<p>I'd also have to keep a count of the number of keys so I could produce the average.  Seems like a lot of work though - I wasn't sure if there was a more elegant way to accomplish this.</p>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a> to create a dictionary with unique keys and lists of values:</p>
<pre><code>&gt;&gt;&gt; l=[(3, '655'),(3, '645'),(3, '641'),(4, '602'),(4, '674'),(4, '620')]
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d=defaultdict(list)
&gt;&gt;&gt; 
&gt;&gt;&gt; for i,j in l:
...    d[i].append(int(j))
... 
&gt;&gt;&gt; d
defaultdict(&lt;type 'list'&gt;, {3: [655, 645, 641], 4: [602, 674, 620]})
</code></pre>
<p>Then use a list comprehension to create the expected pairs:</p>
<pre><code>&gt;&gt;&gt; [(i,sum(j)/len(j)) for i,j in d.items()]
[(3, 647), (4, 632)]
</code></pre>
<p>And within your code you can do:</p>
<pre><code>with open('file.csv', 'rb') as csvfile:
    reader = csv.reader(csvfile)
    for row in reader:
        date = time.strptime(row[3], "%a %b %d %H:%M:%S %Z %Y")
        data = date, row[5]

        month = data[0][1]
        avg = data[1]
        d[month].append(int(avg))

     print [(i,sum(j)/len(j)) for i,j in d.items()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>pandas</code>, it is designed specifically to do these sorts of things, meaning you can express them in only a small amount of code (what you want to do is a one-liner).  Further, it will be much, much faster than any of the other approaches when given a lot of values.</p>
<pre><code>import pandas as pd

a=[(3, '655'),
   (3, '645'),
   (3, '641'),
   (4, '602'),
   (4, '674'),
   (4, '620')]

res = pd.DataFrame(a).astype('float').groupby(0).mean()
print(res)
</code></pre>
<p>Gives:</p>
<pre><code>     1
0     
3  647
4  632
</code></pre>
<p>Here is a multi-line version, showing what happens:</p>
<pre><code>df = pd.DataFrame(a)  # construct a structure containing data
df = df.astype('float')  # convert data to float values
grp = df.groupby(0)  # group the values by the value in the first column
df = grp.mean()  # take the mean of each group
</code></pre>
<p>Further, if you want to use a <code>csv</code> file, it is even easier since you don't need to parse the <code>csv</code> file yourself (I use made-up names for the columns I don't know):</p>
<pre><code>import pandas as pd
df = pd.read_csv('file.csv', columns=['col0', 'col1', 'col2', 'date', 'col4', 'data'], index=False, header=None)
df['month'] = pd.DatetimeIndex(df['date']).month
df = df.loc[:,('month', 'data')].groupby('month').mean()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a dictionary comprehension, where <code>items</code> in the list of tuple pairs:</p>
<pre><code>data = {i:[int(b) for a, b in items if a == i] for i in set(a for a, b in items)}
data = {a:int(float(sum(b))/float(len(b))) for a, b in data.items()} # averages
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools,csv
from dateutil.parser import parse as dparse

def make_tuples(fname='file.csv'):
    with open(fname, 'rb') as csvfile:
        rows = list(csv.reader(csvfile))
        for month,data in itertools.groupby(rows,lambda x:dparse(x[3]).strftime("%b")):
             data = zip(*data)
             yield (month,sum(data[5])/float(len(data[5])))

print dict(make_tuples('some_csv.csv'))
</code></pre>
<p>is one way to do it ...</p>
</div>
<span class="comment-copy"><code>dictionary of values</code> - How? Dictionaries don't allow duplicate keys. Please show the actual datastructure used.</span>
<span class="comment-copy">Dictionary is probably the wrong term...as I said I am new to Python.  I will post the code I used to generate the data.</span>
<span class="comment-copy">A dictionary (or <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer"><code>dict</code></a>) is a standard datatype in Python, which like @thefourtheye says doesn't allow duplicate keys.  In general, a dictionary is a mapping, where what you're starting with is just a group of datapoints.  @Kasra's suggestion of using a <code>dict</code> mapping your keys to <i>lists</i> of values (effectively a <a href="http://en.wikipedia.org/wiki/Multimap" rel="nofollow noreferrer">Multimap</a>) gets around the no-duplicate-keys problem.</span>
<span class="comment-copy">The first comprehension will iterate over the whole dataset for every unique key, which is O(n^2) runtime.</span>
<span class="comment-copy">@dimo414 Runtime isn't a big deal for me, as the slow performance is unnoticeable in modern computers. I don't know anything about time complexity anyway, I'm only 16.</span>
<span class="comment-copy">"the slow performance is unnoticeable in modern computers" famous last words.</span>
