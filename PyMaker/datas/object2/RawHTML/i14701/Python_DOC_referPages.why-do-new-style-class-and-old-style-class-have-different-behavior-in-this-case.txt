<div class="post-text" itemprop="text">
<p>I found something interesting, here is a snippet of code:</p>
<pre><code>class A(object):
    def __init__(self):
        print "A init"

    def __del__(self):
        print "A del"

class B(object):
    a = A()
</code></pre>
<p>If I run this code, I will get:</p>
<pre><code>A init
</code></pre>
<p>But if I change <code>class B(object)</code> to <code>class B()</code>, I will get:</p>
<pre><code>A init
A del
</code></pre>
<p>I found a note in the <a href="https://docs.python.org/2/reference/datamodel.html#object.__del__" rel="nofollow">__del__ doc</a>: </p>
<blockquote>
<p>It is not guaranteed that <strong>del</strong>() methods are called for objects
  that still exist when the interpreter exits.</p>
</blockquote>
<p>Then, I guess it's because that <code>B.a</code> is still referenced(referenced by class <code>B</code>) when the interpreter exists.</p>
<p>So, I added a <code>del B</code> before the interpreter exists manually, and then I found <code>a.__del__()</code> was called.</p>
<p>Now, I am a little confused about that. Why is <code>a.__del__()</code> called when using old style class? Why do new and old style classes have different behavior?</p>
<p>I found a similar question <a href="http://bytes.com/topic/python/answers/467672-__del__-not-called" rel="nofollow">here</a>, but I think the answers are not clear enough.</p>
</div>
<div class="post-text" itemprop="text">
<p>TL;DR: this is an <a href="http://bugs.python.org/issue1545463" rel="nofollow">old issue</a> in CPython, that was finally fixed in <a href="https://docs.python.org/3/whatsnew/3.4.html#pep-442-safe-object-finalization" rel="nofollow">CPython 3.4</a>. Objects kept live by reference cycles that are referred to by module globals are not properly finalized on interpreter exit in CPython versions prior to 3.4. New-style classes have implicit cycles in their <code>type</code> instances; old-style classes (of type <code>classobj</code>) do not have implicit reference cycles.</p>
<p>Even though fixed in this case, the CPython 3.4 documentation still recommends to not depend on <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__del__" rel="nofollow"><code>__del__</code></a> being called on interpreter exit - consider yourself warned.</p>
<hr/>
<p>New style classes have reference cycles in themselves: most notably</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     pass
&gt;&gt;&gt; A.__mro__[0] is A
True
</code></pre>
<p>This means that they cannot be deleted instantly*, but only when the garbage collector is run. Since a reference to them is being held by the main module, they will stay in memory until the interpreter shutdown. At the end, during the module clean-up, all the module global names in the main are set to point to <code>None</code>, and whichever objects had their reference counts decreased to zero (your old-style class for example) were also deleted. However, the new-style classes, having reference cycles, would not be released/finalized by this.</p>
<p>The cyclic garbage collector would not be run at the interpreter exit (which is allowed by the <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__del__" rel="nofollow">CPython documentation</a>:</p>
<blockquote>
<p>It is not guaranteed that <code>__del__()</code> methods are called for objects that still exist when the interpreter exits.</p>
</blockquote>
<hr/>
<p>Now, old-style classes in Python 2 do not have implicit cycles. When the CPython module cleanup/shutdown code sets the global variables to <code>None</code>, the only remaining reference to class <code>B</code> is dropped; then <code>B</code> is deleted, and the last reference to <code>a</code> is dropped, and <code>a</code> too is finalized.</p>
<hr/>
<p>To demonstrate the fact that the new-style classes have cycles and require a GC sweep, whereas the old-style classes do not, you can try the following program in CPython 2 (CPython 3 does not have old-style classes any more):</p>
<pre><code>import gc
class A(object):
    def __init__(self):
        print("A init")

    def __del__(self):
        print("A del")

class B(object):
    a = A()

del B
print("About to execute gc.collect()")
gc.collect()
</code></pre>
<p>With <code>B</code> as new-style class as above, the output is</p>
<pre><code>A init
About to execute gc.collect()
A del
</code></pre>
<p>With <code>B</code> as old-style class (<code>class B:</code>), the output is</p>
<pre><code>A init
A del
About to execute gc.collect()
</code></pre>
<p>That is, the new-style class was deleted only after <code>gc.collect()</code> even though the last outside reference to it was dropped already; but the old-style class was deleted instantly.</p>
<hr/>
<p>Much of this is already <a href="http://bugs.python.org/issue1545463" rel="nofollow">fixed</a> in <a href="https://docs.python.org/3.4/whatsnew/3.4.html#pep-442-safe-object-finalization" rel="nofollow">Python 3.4</a>: thanks to <a href="https://www.python.org/dev/peps/pep-0442/" rel="nofollow">PEP 442</a>, which included the <a href="http://bugs.python.org/issue812369" rel="nofollow"><em>module shutdown procedure based on GC code</em></a>. Now even on interpreter exit the module globals are finalized using the ordinary garbage collection. If you run your program under Python 3.4, the program will print</p>
<pre><code>A init
A del
</code></pre>
<p>Whereas with Python &lt;=3.3 it will print</p>
<pre><code>A init
</code></pre>
<p><em>(<strong>Do note</strong> that other implementations still might or might not execute <code>__del__</code> at this moment, regardless of the version of them being above, at, or below, 3.4)</em></p>
</div>
<span class="comment-copy">Does <a href="http://stackoverflow.com/questions/14323734/python-destructors-in-new-and-old-style-classes" title="python destructors in new and old style classes">stackoverflow.com/questions/14323734/â€¦</a> answer your question?</span>
<span class="comment-copy">Interesting! Reproduced, and hash randomisation doesn't affect it. I suspect there may still a reference to the new-style class present when the module is torn down.</span>
<span class="comment-copy">@MJeffryes: the module is cleared when the interpreter exits. So running here means running this code as a script. It is the interpreter exit that tears down the module (setting all references in it to None) and thus triggering the <code>A.__del__</code> call as the instance is cleared too.</span>
<span class="comment-copy">@figs No answer for the difference between new/old style class either</span>
<span class="comment-copy">@WKPlus: the issue is the same; mgilson is right though, it may be interesting there is a difference but that difference is an implementation detail.</span>
