<div class="post-text" itemprop="text">
<pre><code>    #!/usr/bin/env python3

import binascii


var=binascii.a2b_qp("hello")
key=binascii.a2b_qp("supersecretkey")[:len(var)]

print(binascii.b2a_qp(var))
print(binascii.b2a_qp(key))


#here i want to do an XOR operation on the bytes in var and key and place them in 'encryption': encryption=var XOR key

print(binascii.b2a_qp(encrypted))
</code></pre>
<p>If someone could enlighten me on how I could accomplish this I would be very happy. Very new to the whole data-type conversions so yeah...reading through the python wiki is not as clear as I would like :(.</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like what you need to do is XOR each of the characters in the message with the corresponding character in the key. However, to do that you need a bit of interconversion using <code>ord</code> and <code>chr</code>, because you can only xor numbers, not strings:</p>
<pre><code>&gt;&gt;&gt; encrypted = [ chr(ord(a) ^ ord(b)) for (a,b) in zip(var, key) ] 
&gt;&gt;&gt; encrypted
['\x1b', '\x10', '\x1c', '\t', '\x1d']

&gt;&gt;&gt; decrypted = [ chr(ord(a) ^ ord(b)) for (a,b) in zip(encrypted, key) ]
&gt;&gt;&gt; decrypted
['h', 'e', 'l', 'l', 'o']

&gt;&gt;&gt; "".join(decrypted)
'hello'
</code></pre>
<p>Note that <code>binascii.a2b_qp("hello")</code> just converts a string to another string (though possibly with different encoding).</p>
<p>Your approach, and my code above, will only work if the key is at least as long as the message. However, you can easily repeat the key if required using <code>itertools.cycle</code>:</p>
<pre><code>&gt;&gt;&gt; from itertools import cycle
&gt;&gt;&gt; var="hello"
&gt;&gt;&gt; key="xy"

&gt;&gt;&gt; encrypted = [ chr(ord(a) ^ ord(b)) for (a,b) in zip(var, cycle(key)) ]
&gt;&gt;&gt; encrypted
['\x10', '\x1c', '\x14', '\x15', '\x17']

&gt;&gt;&gt; decrypted = [ chr(ord(a) ^ ord(b)) for (a,b) in zip(encrypted, cycle(key)) ]
&gt;&gt;&gt; "".join(decrypted)
'hello'
</code></pre>
<p>To address the issue of unicode/multi-byte characters (raised in the comments below), one can convert the string (and key) to bytes, zip these together, then perform the XOR, something like:</p>
<pre><code>&gt;&gt;&gt; var=u"hello\u2764"
&gt;&gt;&gt; var
'hello❤'

&gt;&gt;&gt; encrypted = [ a ^ b for (a,b) in zip(bytes(var, 'utf-8'),cycle(bytes(key, 'utf-8'))) ]
&gt;&gt;&gt; encrypted
[27, 16, 28, 9, 29, 145, 248, 199]

&gt;&gt;&gt; decrypted = [ a ^ b for (a,b) in zip(bytes(encrypted), cycle(bytes(key, 'utf-8'))) ]
&gt;&gt;&gt; decrypted
[104, 101, 108, 108, 111, 226, 157, 164]

&gt;&gt;&gt; bytes(decrypted)
b'hello\xe2\x9d\xa4'

&gt;&gt;&gt; bytes(decrypted).decode()
'hello❤'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Comparison of two python3 solutions</h2>
<p>The first one is based on <a href="https://docs.python.org/3/library/functions.html#zip" rel="noreferrer">zip</a>:</p>
<pre><code>def encrypt1(var, key):
    return bytes(a ^ b for a, b in zip(var, key))
</code></pre>
<p>The second one uses <a href="https://docs.python.org/3/library/stdtypes.html#int.from_bytes" rel="noreferrer">int.from_bytes</a> and <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="noreferrer">int.to_bytes</a>:</p>
<pre><code>def encrypt2(var, key):
    key = key[:len(var)]
    int_var = int.from_bytes(var, sys.byteorder)
    int_key = int.from_bytes(key, sys.byteorder)
    int_enc = int_var ^ int_key
    return int_enc.to_bytes(len(var), sys.byteorder)
</code></pre>
<p>Simple tests:</p>
<pre><code>assert encrypt1(b'hello', b'supersecretkey') == b'\x1b\x10\x1c\t\x1d'
assert encrypt2(b'hello', b'supersecretkey') == b'\x1b\x10\x1c\t\x1d'
</code></pre>
<p>Performance tests with <code>var</code> and <code>key</code> being 1000 bytes long:</p>
<pre><code>$ python3 -m timeit \
  -s "import test_xor;a=b'abcdefghij'*100;b=b'0123456789'*100" \
  "test_xor.encrypt1(a, b)"
10000 loops, best of 3: 100 usec per loop

$ python3 -m timeit \
  -s "import test_xor;a=b'abcdefghij'*100;b=b'0123456789'*100" \
  "test_xor.encrypt2(a, b)"
100000 loops, best of 3: 5.1 usec per loop
</code></pre>
<p>The integer approach seems to be significantly faster.</p>
</div>
<span class="comment-copy">do you mean xoring the var string against the key string? Mind you they They have different lengths. In python the xor operator is ^</span>
<span class="comment-copy">So my use of [:len(var)] to cut the key to the same size as the the var string will not work?  I thought each character is converted in to a single byte where a=97=01100001 for example.  When I use encrypted = var ^ key I get "TypeError: unsupported operand type(s) for ^: 'bytes' and 'bytes'"</span>
<span class="comment-copy">Thanks!  I see I need to just re-do my code really ha.</span>
<span class="comment-copy">This solution fails to account for the length of the <code>var</code> and <code>key</code>. If <code>var</code> is longer than <code>key</code> it will shop off the extra character.</span>
<span class="comment-copy">@mbecker True, though that's what the OP asked for. I will update my answer with a solution to this issue.</span>
<span class="comment-copy">Updated using <code>itertools.cycle</code></span>
<span class="comment-copy">IMO this just underlines how tricky p2 can be for byte operations...the only quick fix I see for this is to double-check that the input is a str not a unicode e.g. <code>if not isinstance(var, str) or not isinstance(key, str)</code></span>
<span class="comment-copy">One might simply use <code>int.from_bytes(bytes_object, endianness)</code> to convert a bytes object to an integer directly (and in a saner way).</span>
<span class="comment-copy">@boramalper Thanks, see my edit.</span>
<span class="comment-copy">What's the performance of this solution though?</span>
<span class="comment-copy">@Czechnology The integer approach seems to be significantly faster. See my edit.</span>
<span class="comment-copy">This faster version is a neat discovery. Thanks!</span>
