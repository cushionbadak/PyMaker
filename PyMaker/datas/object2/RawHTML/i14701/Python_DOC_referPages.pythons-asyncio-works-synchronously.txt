<div class="post-text" itemprop="text">
<p>I'm trying to leverage Python's new asyncio library to send asynchronous HTTP requests. I want to wait a few miliseconds (the <code>timeout</code> variable) before sending each request - but of course - send them all asynchronously and, not wait for a response after each request sent.</p>
<p>I'm doing something like the following:</p>
<pre><code>@asyncio.coroutine
def handle_line(self, line, destination):
    print("Inside! line {} destination {}".format(line, destination))
    response = yield from aiohttp.request('POST', destination, data=line,
                               headers=tester.headers)
    print(response.status)
    return (yield from response.read())

@asyncio.coroutine
def send_data(self, filename, timeout):
    destination='foo'
    logging.log(logging.DEBUG, 'sending_data')
    with open(filename) as log_file:
        for line in log_file:
            try:
                json_event = json.loads(line)
            except ValueError as e:
                print("Error parsing json event")
            time.sleep(timeout)
            yield from asyncio.async(self.handle_line(json.dumps(json_event), destination))


loop=asyncio.get_event_loop().run_until_complete(send_data('foo.txt', 1))
</code></pre>
<p>The output that I am getting (by printing the 200 responses) looks like this code is running synchronously. What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of issues here:</p>
<ol>
<li><p>You should use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.sleep"><code>asyncio.sleep</code></a>, not <code>time.sleep</code>, because the latter will block the event loop. </p></li>
<li><p>You shouldn't be using <code>yield from</code> after the <code>asyncio.async(self.handle_line(...))</code> call, because that will make the script block until the <code>self.handle_line</code> coroutine is complete, which means you don't end up doing anything concurrently; you process each line, wait for the processing to complete, then move on to the next line. Instead, you should run all the <code>asyncio.async</code> calls without waiting, save the <code>Task</code> objects returned to a list, and then use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait"><code>asyncio.wait</code></a> to wait for them all to complete once you've started them all. </p></li>
</ol>
<p>Putting that all together:</p>
<pre><code>@asyncio.coroutine
def handle_line(self, line, destination):
    print("Inside! line {} destination {}".format(line, destination))
    response = yield from aiohttp.request('POST', destination, data=line,
                               headers=tester.headers)
    print(response.status)
    return (yield from response.read())

@asyncio.coroutine
def send_data(self, filename, timeout):
    destination='foo'
    logging.log(logging.DEBUG, 'sending_data')
    tasks = []
    with open(filename) as log_file:
        for line in log_file:
            try:
                json_event = json.loads(line)
            except ValueError as e:
                print("Error parsing json event")
            yield from asyncio.sleep(timeout)
            tasks.append(asyncio.async(
                 self.handle_line(json.dumps(json_event), destination))
    yield from asyncio.wait(tasks)


asyncio.get_event_loop().run_until_complete(send_data('foo.txt', 1))
</code></pre>
</div>
<span class="comment-copy">hmm... thank you. but I am not sure it's exactly what I want though. the yield from asyncio.sleep will wait a timeout before appending the task to the tasks list. the yield from asyncio.wait will send all the requests concurrently. I want them to be sent one after one with the timeout interval between each request. that code will not wait between each request. it will send them all at once.</span>
<span class="comment-copy">@OhadBasan  The <code>yield from asyncio.sleep(timeout)</code> line will make the code wait <code>timeout</code> seconds between <i>starting</i> each task, not just between appending it to the task list. The task actually gets added to the event loop and starts is soon as you call <code>asyncio.async(task())</code>. You don't need to actually <code>yield from</code> the task for it to start execution.</span>
<span class="comment-copy">@OhadBasan It helps to think of <code>yield from</code> not as <i>starting</i> a coroutine, but rather as <i>waiting</i> for its completion.</span>
