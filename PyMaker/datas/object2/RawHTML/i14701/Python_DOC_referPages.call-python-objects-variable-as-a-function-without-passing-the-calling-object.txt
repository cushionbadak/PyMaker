<div class="post-text" itemprop="text">
<p>I have a structure something like this:</p>
<pre><code>def foobar():
    print('FOOBAR!')

class SampleClass:
    foo = foobar
    def printfunc(self):
        self.foo()
</code></pre>
<p>This doesn't work because the original foobar function can't handle <code>self</code> being passed to it -- it wasn't part of any class or object to begin with. Python won't let me add the <code>@staticmethod</code> decorator either.</p>
<p>I have no control over the definition of <code>foobar</code>, and I may have to override the value of <code>foo</code> in subclasses. </p>
<p>How can I call foo, without passing the object calling it?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/glossary.html#term-decorator" rel="nofollow">Decorators are plain functions</a>, you should be able to call <code>staticmethod(foobar)</code> explicitly in the class definition</p>
<pre><code>class SampleClass:
    foo = staticmethod(foobar)
    def printfunc(self):
        self.foo() # Prints 'FOOBAR!'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The approach from user2357112's comment seems to work, too:</p>
<pre><code>def foobar():
        print('FOOBAR!')

def foobaz():
        print('FooBAZ!')

class SampleClass:
        def foo(self):
                foobar()

        def printfunc(self):
                self.foo()

class DerivedClass(SampleClass):
        def foo(self):
                foobaz()

sample = SampleClass()
sample.printfunc() # FOOBAR!

derived = DerivedClass()
derived.printfunc() # FooBAZ!
</code></pre>
<p>If return values shall make it through, you need <code>return</code> statements on all levels, though:</p>
<pre><code>def foobar():
        print('FOOBAR!')
        return 'foo'

def foobaz():
        print('FooBAZ!')
        return 'baz'

class SampleClass:
        def foo(self):
                return foobar()

        def printfunc(self):
                return self.foo()

class DerivedClass(SampleClass):
        def foo(self):
                return foobaz()

sample = SampleClass()
s = sample.printfunc() # FOOBAR!
print(s) # foo

derived = DerivedClass()
d = derived.printfunc() # FooBAZ!
print(d) # baz
</code></pre>
</div>
<span class="comment-copy">I'm a bit confused. Why not define the <code>foobar</code> function inside your <code>SampleClass</code>?</span>
<span class="comment-copy">Why not just <code>def foo(self): foobar()</code>?</span>
<span class="comment-copy">@Huey Because in this specific case, it's <i>not</i> something I can define. It's an external method, and will be overridden with another external method in a subclass.</span>
<span class="comment-copy">Try to use <code>classmethod</code>.</span>
<span class="comment-copy">It's not simply enough to run the function with a second function, I think. I had to greatly prune the example I gave to its simplest components, but there are some <code>yield</code> statements floating around in there too -- not sure how this would effect them.</span>
<span class="comment-copy">Well, while it's appreciated (and expected) that you boil examples down to their relevant parts, make sure that everything that <i>is</i> relevant (to you/to your problem or question) is still included. <a href="https://en.wikiquote.org/wiki/Albert_Einstein" rel="nofollow noreferrer">Einstein's razor</a> is as important as Occam's.</span>
<span class="comment-copy">@Z̷͙̗̻͖̣̹͉̫̬̪̖̤͆ͤ̓ͫͭ̀̐͜͞ͅͅαлγo: It should work just fine. <code>foobar</code> is a generator function, and <code>foo</code> won't be, but <code>foo</code> should return the generator iterator returned by <code>foobar</code> as if <code>foo</code> were a generator function itself.</span>
<span class="comment-copy">@user2357112 Didn't know that, thanks.</span>
