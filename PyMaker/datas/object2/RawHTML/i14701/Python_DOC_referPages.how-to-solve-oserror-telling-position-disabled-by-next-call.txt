<div class="post-text" itemprop="text">
<p>I am creating a file editing system and would like to make a line based tell() function instead of a byte based one. This function would be used inside of a "with loop" with the open(file) call. This function is part of a class that has:</p>
<pre><code>self.f = open(self.file, 'a+')
# self.file is a string that has the filename in it
</code></pre>
<p>The following is the original function
(It also has a char setting if you wanted line and byte return):</p>
<pre><code>def tell(self, char=False):
    t, lc = self.f.tell(), 0
    self.f.seek(0)
    for line in self.f:
        if t &gt;= len(line):
            t -= len(line)
            lc += 1
        else:
            break
    if char:
        return lc, t
    return lc
</code></pre>
<p>The problem I'm having with this is that this returns an OSError and it has to do with how the system is iterating over the file but I don't understand the issue. Thanks to anyone who can help.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have an older version of Python 3, and I'm on Linux instead of a Mac, but I was able to recreate something very close to your error:</p>
<pre class="lang-none prettyprint-override"><code>IOError: telling position disabled by next() call
</code></pre>
<p>An <em>IO</em> error, not an <em>OS</em> error, but otherwise the same.  Bizarrely enough, I couldn't cause it using your <code>open('a+', ...)</code>, but only when opening the file in read mode: <code>open('r+', ...)</code>.</p>
<p>Further muddling things is that the error comes from <code>_io.TextIOWrapper</code>, a class that <em>appears</em> to be defined in Python's <code>_pyio.py</code> file...  I stress "appears", because:</p>
<ol>
<li><p>The <code>TextIOWrapper</code> in that file has attributes like <code>_telling</code> that I can't access on the whatever-it-is object calling itself <code>_io.TextIOWrapper</code>.</p></li>
<li><p>The <code>TextIOWrapper</code> class in <code>_pyio.py</code> doesn't make any distinction between readable, writable, or random-access files.  Either both should work, or both should raise the same <code>IOError</code>.</p></li>
</ol>
<p>Regardless, the <code>TextIOWrapper</code> class as described in the <code>_pyio.py</code> file <strong>disables the <code>tell</code> method while the iteration is in progress</strong>.  This seems to be what you're running into (comments are mine):</p>
<pre class="lang-python3 prettyprint-override"><code>def __next__(self):
    # Disable the tell method.
    self._telling = False
    line = self.readline()
    if not line:
        # We've reached the end of the file...
        self._snapshot = None
        # ...so restore _telling to whatever it was.
        self._telling = self._seekable
        raise StopIteration
    return line
</code></pre>
<p>In your <code>tell</code> method, you almost always <code>break</code> out of the iteration before it reaches the end of the file, leaving <code>_telling</code> disabled (<code>False</code>):</p>
<p>One other way to reset <code>_telling</code> is the <code>flush</code> method, but it also failed if called while the iteration was in progress:</p>
<pre class="lang-none prettyprint-override"><code>IOError: can't reconstruct logical file position
</code></pre>
<p>The way around this, at least on my system, is to <strong>call <code>seek(0)</code></strong> on the <code>TextIOWrapper</code>, which restores everything to a known state (and successfully calls <code>flush</code> in the bargain):</p>
<pre class="lang-python3 prettyprint-override"><code>def tell(self, char=False):
    t, lc = self.f.tell(), 0
    self.f.seek(0)
    for line in self.f:
        if t &gt;= len(line):
            t -= len(line)
            lc += 1
        else:
            break
    # Reset the file iterator, or later calls to f.tell will
    # raise an IOError or OSError:
    f.seek(0)
    if char:
        return lc, t
    return lc
</code></pre>
<p>If that's not the solution for your system, it might at least tell you where to start looking.</p>
<p>PS:  You should consider <em>always</em> returning both the line number and the character offset.  Functions that can return completely different types are hard to deal with --- it's a lot easier for the caller to just throw away the value her or she doesn't need.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know if this was the original error but you can get the same error if you try to call f.tell() inside of a line-by-line iteration of a file like so:</p>
<pre><code>with open(path, "r+") as f:
  for line in f:
    f.tell() #OSError
</code></pre>
<p>which can be easily substituted by the following:</p>
<pre><code>with open(path, mode) as f:
  line = f.readline()
  while line:
    f.tell() #returns the location of the next line
    line = f.readline()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just a quick workaround for this issue:</p>
<p>As you are iterating over the file from the beginning anyways, just keep track of where you are with a dedicated variable:</p>
<pre><code>file_pos = 0
with open('file.txt', 'rb') as f:
    for line in f:
        # process line
        file_pos += len(line)
</code></pre>
<p>Now <code>file_pos</code> will always be, what <code>file.tell()</code> would <em>tell</em> you. Note that this only works for ASCII files as tell and seek work with byte positions. Working on a line-basis it's easy though to convert strings from byte to unicode-strings. </p>
</div>
<span class="comment-copy">Hard to answer without seeing the rest of your class.  (I couldn't reproduce it on Linux using only functions.)  You might want to read up on <a href="https://docs.python.org/3/library/exceptions.html#OSError" rel="nofollow noreferrer"><code>OSError</code>'s attributes</a>, which can give you (and us) some additional information.  My first question would be, since this is an <i>OS</i> error:  What's your operating system?  Also (possibly related): Why / how are you <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">opening the file in append mode</a> and then <code>seek</code>ing around inside it?</span>
<span class="comment-copy">I'm opening it in append mode because, it is assumed that the file is non-existant before the instance is created. (as you know, I'm sure, 'a' mode creates the file if it doesn't exist yet). I wanted to be able to save space in the code to have a check if the file existed.     My operating system is Mac OS X Yosemite, but I don't think it has to do with Apple.</span>
<span class="comment-copy">Thanks so much for your help! What seems to be my problem is that i can't call the (built-in) tell() method during a file iteration (line by line). I found a way around this and your answer really helped. Thanks again!</span>
<span class="comment-copy">@BrandonGomes: would you mind sharing your solution with me?</span>
<span class="comment-copy">sorry @marscher I don't have this code anymore. It's from an old computer. I think the answer was to store some meta-data about the file iterator. You could always rewrite the <b>next</b> function.</span>
