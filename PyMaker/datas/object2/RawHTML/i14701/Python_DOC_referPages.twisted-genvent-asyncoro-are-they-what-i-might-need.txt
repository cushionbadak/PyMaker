<div class="post-text" itemprop="text">
<p>Learning Python and trying to do something ambitious (perhaps too much).</p>
<p>The application (console, that runs silently like a server), needs to talk to 2 serial ports, needs to deal with timers, needs to push information on Redis KV-store, write logs, and interact with bunch of other similar applications using unix IPC (or socket comm.)</p>
<p>The easier way (to my mind) to think of such an application is to work with threads and event queues. However due to what I understand as GIL enforced limitation with threading, it is not quite an option with Python (unless, I misunderstood things). The alternative way, what I understood - is to work with asynchronous I/O framework, green-threads, coroutines etc.</p>
<p>Are <a href="https://twistedmatrix.com/trac/" rel="nofollow">twisted</a>, <a href="http://www.gevent.org/" rel="nofollow">gevent</a> and <a href="https://pypi.python.org/pypi/asyncoro/3.1" rel="nofollow">asyncoro</a> really alternatives in Python for asynchronous event-driven programming that I intend to write ? </p>
<p>Since learning twisted seems to be such a big investment (in terms of time/effort), I was wondering if gevent and asyncoro could be easier and better alternative ? From the bit of superficial document reading done so far, asyncoro seems to be simplest, with very limited amount of new learning, and Twisted is other extreme, with gevent being somewhere in the middle -- but then I am not sure, if they are really comparable.</p>
<p>Here's an example of what the application would do if were multi-threaded:</p>
<ul>
<li>Thread:1 - Monitor health of serial port, periodically i.e. with a timer. Say check every 2 minutes if last state was healthy. If last state was unhealthy then check every 30 seconds for first 5 mins, then every minute for next 10 mins... like in exponential backoff. Note that there are multiple such serial ports. </li>
<li>Thread:2 - Monitor state of application-level sessions that come-and-go from time to time, over the serial ports, and the communication that happens over it. Redis is (planned) to be used to write to distributed KV-store s.t. other instances of application (running on same or other servers), can coordinate certain other actions.</li>
<li>Thread:3 - Performs some other housekeeping tasks.</li>
</ul>
<p>All of the threads need to do logging, all the threads use timers (&amp; other events) to do certain things. Timers are used for periodic execution of some logic and as timeouts to guard certain actions (blocking or non-blocking).</p>
<p>My experience with Python is extremely limited, but I have experience writing similar programs in C/C++ and Java. Using Python for this, to learn.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use any of the libraries you've mentioned here to implement the application you've described.  You can also use traditional threads.  The GIL prevents you from achieving hardware-level parallelism in the execution of Python byte code operations (as distinct from, say, native code being invoked from your Python program).  It does not prevent you from performing parallel I/O operations - which is what it sounds like your application is primarily concerned with.</p>
<p>There isn't enough detail in your question to provide a recommendation of one of these tools over another (and if there were enough detail, the question would probably be enormous and the effort to answer it correctly would probably discourage anyone on SO from doing so).  It's typically safe to say that the threading approach is probably the worst, though (for a variety of reasons I won't even attempt to expain here; they're documented well enough on the internet at large).</p>
</div>
<span class="comment-copy">You should also take <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a>/<a href="https://trollius.readthedocs.org/en/latest/index.html" rel="nofollow noreferrer">trollius</a> into account (asyncio is python3, trollius a python2 backport).</span>
<span class="comment-copy">Thanks for pointing to 'trollius', wasn't aware of a asyncio backport available in python2. Indeed, I had come across asyncio for Python3.</span>
<span class="comment-copy">what is "asyncoro"? Your question should have more links in it.</span>
<span class="comment-copy">Thanks Jean-Paul. GIL effectively renders multiple-cores/processors from being used, and instead only one core is used, while the operating system does perform preemptive multitasking using single processor, which is sub-optimal (compared to all the other cores that could've been used). The Python threads do map to OS threads, which are stack-based, and thus close to the cost/efficiency of process level context-switching. Is this a correct understanding ?</span>
<span class="comment-copy">Also, one concern (or question) that remains about the 3 being alternatives is that, apart from Twisted, the other 2 do not seem to support (though there is no strong evidence of being prohibited) serial i/o (pyserial or any alternative). The part that I remain unsure of is, if there is anything in gevent or asyncoro or say even trollius, that prevent me from using pyserial in the same application.</span>
<span class="comment-copy">Will read/research more on threads on Python and why it is such a terrible idea, but I get the warning.</span>
