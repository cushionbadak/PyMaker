<div class="post-text" itemprop="text">
<p>I'm fairly new to Python, and am creating a program that tracks RFID badges used by the students in my school district.  In my program I have a class named <code>Badge</code> that creates a badge object with six public named variables (RFID, studentID, status, dateActivated, dateDeactivated, reason).  I then have a class named <code>BadgeTable</code> that holds badges.</p>
<p>What I want to do is see if a specific RFID or studentID exists in any of the badges.  I know I can do this with loops, but that can take a while (I'm reading in about 450 CSV files, each of which contains 2000 to 14000 badges, and adding a badge to BadgeTable only if it hasn't already been added).  </p>
<blockquote>
<p>Edit: to expand on the above, all badge data for the last three years has been manually entered into a spreadsheet that has logic to identify duplicate RFID or studentID numbers, then exported each day as a CSV file for the badge reader software.  For the first year of our bus badge program each day's CSV file only contained active badges; we naively assumed that if we stopped sending inactive badges they would be rejected by the badge reader.  When we discovered we were wrong, we started including the inactive badges we knew about in the CSV files (we added a suffix to the studentID for each inactive badge to keep them unique), so from then on each days's CSV file was a superset of the previous day's file.  However, there are a not insignificant number inactive/lost badges not in the current CSV file, so the above process was meant to be a way use the old CSV files to a) get as complete a list as possible of badges we've issued, and b) eliminate misspellings in the student names associated with each badge.</p>
</blockquote>
<p>I'd like to be able to say something like:</p>
<pre><code>studentBadges = BadgeTable()
# 
# Bunch of code to load badges into studentBadges 
#
if RFID not in studentBadges[:].RFID:
    studentBadges.add_badge(RFID, studentID, 'A', fileDate, None, None)
</code></pre>
<p>What I want that to do is see if the variable RFID matches the RFID field in any of the badges in studentBadges.  I've tried that, and <code>studentBadges[:][1]</code>, but both fail (both with <code>'BadgeTable' object is not subscriptable</code>)</p>
<p>My current workaround is to actually store a separate list in the BadgeTable class named <code>RFIDList</code>, and when each badge gets added to <code>BadgeTable</code> I also add it's RFID value to <code>RFIDList</code>.  As long as I never sort either <code>RFIDList</code> or the list of badges itself I can do things like:</p>
<pre><code>def delete_badge(self, RFID):
    """Delete an individual badge from BadgeTable """
    if RFID in self.RFIDList:
        idx = self.RFIDList.index(RFID)
        del self.RFIDList[idx]
        del self.BadgeTable[idx]
</code></pre>
<p>Is there a more elegant, more Pythonic way to test for the existence of a value in a compound object in Python 3, one that doesn't involve keeping parallel lists in the class?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not quite sure why you need <code>BadgeTable</code> to be a class rather than just having <code>studentBadges</code> be a <a href="https://docs.python.org/3.3/library/collections.html" rel="nofollow">collection</a> of <code>Badge</code>s. Does it do something additional to just hold the data?</p>
<p>In any case, it makes sense to look at what collections python has to offer beyond lists. It seems you care about uniqueness of <code>Badge</code>s, but not about their order. Lists (similar to "arrays" in other programming languages) are all about order. <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow">Sets</a> and <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow">dictionaries</a> ("associative arrays" or "hash maps" in other languages) are unordered, but help you with uniqueness:</p>
<ul>
<li>Sets contain each object at most once</li>
<li>Dictionaries contain each key object at most once. Each key points to a value object. (Several keys might point to the same value.)</li>
</ul>
<p>So you could have two dictionaries, one mapping RFIDs to <code>Badge</code>s and one mapping studentIDs to <code>Badge</code>s. A lookup in these would be much quicker than in lists.</p>
<p>But even better might be to just have the <code>Badge</code>s in a single set. Trying to add a <code>Badge</code> a second time would do nothing. Holding a (mathematical) set of unique objects is exactly what a (python) set does.</p>
<p>But when are two objects the "same"? Instances of user-defined classes like <code>Badge</code> are <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow">hashable</a> by default, but compare unequal except with themselves. So each <code>Badge</code> you freshly create from read-in data would be considered different from all others, even if some share its <code>RFID</code> or <code>studentID</code>. Thus, override methods <code>__hash__()</code> and <code>__eq__()</code> in <code>Badge</code>, so that <code>Badge</code> compare equal iff their <code>RFID</code>s match.</p>
<h3>Nota bene: Equality consistence</h3>
<p>Equality should be transitive. (I.e. if <code>a == b</code> and <code>b == c</code>, then also <code>a == c</code>.) Thus you could make <code>Badge</code>s compare equal if both, their <code>RFID</code>s <strong>and</strong> their <code>studientID</code>s match, but you should not make them equal already if any, their <code>RFID</code>s <strong>or</strong> their <code>studientID</code>s match. (It'd be impossible to find a meaningful <code>__hash__()</code> implementation consistent with the latter, anyway.)</p>
<p>Though I guess if a student has been given several badges (with different RFIDs) in his or her school career your program might want to know about more than just the first badge, anyway.</p>
<h2>6'300'000 badges</h2>
<p>Looking at the amounts of data you're handling here, are you sure you want to (and can) hold it all in memory? If not, using python to access the data base management system of your choice would probably be the way to go. Relational databases also support the set operation semantics you'd want to rely on.</p>
</div>
<span class="comment-copy">Implement <code>__contains__</code> on your <code>BadgeTable</code> class.</span>
<span class="comment-copy">Very nice answer.</span>
<span class="comment-copy">Thank you: it sounds like a dictionary is the best way for me to proceed.  To answer the questions you posed: BadgeTable has methods for adding, activating, deactivating, and removing badges. I made BadgeTable a class as opposed to just making it a collection because this situation seemed similar to the blackjack program I did in a Python class last year, where we were required to have a class for the cards, and another one for the hand that held the cards. As for the number of badges, we've only issued about 15,000 since we started (see my edit above for the reason why).</span>
