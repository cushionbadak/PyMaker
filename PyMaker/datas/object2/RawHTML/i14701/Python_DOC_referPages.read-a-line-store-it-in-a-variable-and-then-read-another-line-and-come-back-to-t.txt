<div class="post-text" itemprop="text">
<p>This is a tricky question and I've read a lot of posts about it, but I haven't been able to make it work.</p>
<p>I have a big file. I need to read it line by line, and once I reach a line of the form <code>"Total is: (any decimal number)"</code>, take this string and to save the number in a variable. If the number is bigger than 40.0, then I need to find the fourth line above the <code>Total</code> line (for example, if the <code>Total</code> line was line 39, this line would be line 35). This line will be in the format <code>"(number).(space)(substring)"</code>. Finally, I need to parse this substring out and do further processing on it.</p>
<p>This is an example of what an input file might look like:</p>
<pre class="lang-none prettyprint-override"><code>many lines that we don't care about
many lines that we don't care about
...
1. Hi45
People: bla bla bla bla bla bla
whitespace
bla bla bla bla bla
Total is: (*here there will be a decimal number*)
bla bla
white space
...
more lines we don't care about
and then more lines and then
again we get
2. How144
People: bla bla bla bla bla bla
whitespace
bla bla bla bla bla
Total is: (*here there will be a decimal number*)
bla bla
white space
</code></pre>
<p>I have tried many things, including using the <code>re.search()</code> method to capture what I need from each line I need to focus on.</p>
<p>Here is my code which I modified from another stackoverflow Q &amp; A:</p>
<pre class="lang-py prettyprint-override"><code>import re
import linecache
number = ""
higher_line = ""
found_line = ""

with open("filename_with_many_lines.txt") as aFile:
    for num, line in enumerate(aFile, 1):
        searchObj = re.search(r'(\bTotal\b)(\s)(\w+)(\:)(\s)(\d+.\d+)', line)
        if searchObj:
            print "this is on line", line
            print "this is the line number:", num
            var1 = searchObj.group(6)
            print var1
            if float(var1) &gt; 40.0:
                number = num
                higher_line = number - 4
                print number
                print higher_line

                found_line = linecache.getline("filename_with_many_lines.txt", higher_line)
                print "found the", found_line
</code></pre>
<p>The expected output would be:</p>
<pre class="lang-none prettyprint-override"><code>this is on line Total is: 45.5
this is the line number: 14857
14857
14853
found the 1. Hi145
this is on line Total is: 62.1
this is the line number: 14985
14985
14981
found the 2.How144
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This stores the line which starts with  a number and a dot into a variable called <code>prevline</code>. We print the <code>prevline</code> only if  <code>re.search</code> returns a match object.</p>
<pre><code>import re
with open("file") as aFile:
    prevline = ""
    for num, line in enumerate(aFile,1):
        m = re.match(r'\d+\.\s*.*', line)                                # stores the match object of the line which starts with a number and a dot
        if m:                                              
            prevline += re.match(r'\d+\.\s*(.*)', line).group()         # If there is any match found then this would append the whole line to the variable prevline. You could also write this line as prevline += m.group()

        searchObj = re.search(r'(\bTotal\b\s+\w+:\s+(\d+\.\d+))', line)  # Search for the line which contains the string Total plus a word plus a colon and a float number
        if searchObj:                                                   # if there is any
            score = float(searchObj.group(2))                           # then the float number is assigned to the variable called score
            if score &gt; 40.0:                                            # Do all the below operations only if the float number we fetched was greater than 40.0
                print "this is the line number: ", num
                print "this is the line", searchObj.group(1)
                print num
                print num-4
                print "found the", prevline
                prevline = ""
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>this is on line Total is: 45.5
this is the line number:  8
8
4
found the 1. Hi45
this is on line Total is: 62.1
this is the line number:  20
20
16
found the 2. How144
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the line you need is always four lines above the <code>Total is:</code> line, you could keep the previous lines in a bounded <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow"><code>deque</code></a>.</p>
<pre><code>from collections import deque

with open(filename, 'r') as file:
    previous_lines = deque(maxlen=4)
    for line in file:
        if line.startswith('Total is: '):
            try:
                higher_line = previous_lines[-4]
                # store higher_line, do calculations, whatever
                break  # if you only want to do this once; else let it keep going
            except IndexError:
                # we don't have four previous lines yet
                # I've elected to simply skip this total line in that case
                pass
        previous_lines.append(line)
</code></pre>
<p>A bounded <code>deque</code> (one with a maximum length) will discard an item from the opposite side if adding a new item would cause it to exceed its maximum length. In this case, we're appending strings to the right side of the <code>deque</code>, so once the length of the <code>deque</code> reaches <code>4</code>, each new string we append to the right side will cause it to discard one string from the left side. Thus, at the beginning of the <code>for</code> loop, the <code>deque</code> will contain the four lines prior to the current line, with the oldest line at the far left (index <code>0</code>).</p>
<p>In fact, <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow">the documentation on <code>collections.deque</code></a> mentions use cases very similar to ours:</p>
<blockquote>
<p>Bounded length deques provide functionality similar to the <code>tail</code> filter in Unix. They are also useful for tracking transactions and other pools of data where only the most recent activity is of interest.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I suggested an edit to Blacklight Shining's post that built on its <code>deque</code> solution, but it was rejected with the suggestion that it instead be made into an answer.  Below, I show how Blacklight's solution does solve your problem, if you were to just stare at it for a moment.</p>
<pre><code>with open(filename, 'r') as file:
    # Clear: we don't care about checking the first 4 lines for totals.
    # Instead, we just store them for later.
    previousLines = []
    previousLines.append(file.readline())
    previousLines.append(file.readline())
    previousLines.append(file.readline())
    previousLines.append(file.readline())

    # The earliest we should expect a total is at line 5.
    for lineNum, line in enumerate(file, 5):
        if line.startswith('Total is: '):
            prevLine = previousLines[0]
            high_num = prevLine.split()[1] # A
            score = float(line.strip("Total_is: ").strip("\n").strip()) # B

            if score &gt; 40.0:
                # That's all! We've now got everything we need.
                # Display results as shown in example code.
                print "this is the line number : ", lineNum
                print "this is the line ", line.strip('\n')
                print lineNum
                print (lineNum - 4)
                print "found the ", prevLine

        # Critical - remove old line &amp; push current line onto deque.
        previousLines = previousLines[1:] + [line]
</code></pre>
<p>I don't take advantage of <code>deque</code>, but my code accomplishes the same thing imperatively.  I don't think it's necessarily a better answer than either of the others; I'm posting it to show how the problem you're trying to solve can be addressed with a very simple algorithm and simple tools. (Compare Avinash's clever 17 line solution with my dumbed-down 18 line solution.)</p>
<p>This simplified approach won't make you look like a wizard to anyone reading your code, but it also won't accidentally match on anything in the intervening lines.  If you're dead set on hitting your lines with a regex, then just modify lines A and B.  The general solution still works.</p>
<p>The point is, <em>an easy way to remember what was on the line 4 lines back is to just store the last four lines in memory.</em></p>
</div>
<span class="comment-copy">provide an example along with the expected output.</span>
<span class="comment-copy">What if the number is not greater than 40?</span>
<span class="comment-copy">"One of my attempts was partially successful as it gave me all the lines that are "Total is" but it is not getting them all."  It's getting them all, but it's not getting them all?  Can you be more specific about how it's breaking down?</span>
<span class="comment-copy">By the way, calling <code>close()</code> on a file is not necessary if it was opened in the header of a <code>with</code> statement.</span>
<span class="comment-copy">Hi thank you. It works, but not quite, because it is also printing the scores that are smaller than 40.0. I understand that the float(searchObj.group(2)) is allowing it to capture the decimal number because I tried adding 1.0 to it and the addition worked. But I don't understand why it is also printing the lines that have score smaller than 40. Thank you</span>
<span class="comment-copy">@HR123r You said that the “higher line” that you needed along with the current line would be four lines before the current line. This answer uses the most recent line that matches a regex—an entirely different condition. If that is what you want, consider editing your question.</span>
<span class="comment-copy">@BlacklightShining yep it uses the most recent line. I assumed that each block has exactly one <code>number.</code> and <code>Total is:</code> lines. So it won't create any problems.</span>
<span class="comment-copy">@HR123r just put the condition <code>if float(searchObj.group(2)) &gt; 40.0</code> at the top.</span>
<span class="comment-copy">@HR123r - That issue could be avoided entirely if you 1. can assume your file is correctly formatted and 2. don't depend on a regex to capture your text when you don't need to.  It seems likely that this file as generated by a computer (just by number of lines.)  Use the <code>deque</code> solution, with <code>higherline.split()[1]</code> to get the first number and <code>line.strip('Total is: ').strip('\n')</code> to get the second.</span>
<span class="comment-copy">Upvoted.  I <i>like</i> this solution, but it could be slightly more explicit in explaining the idea behind the it, which can be implemented with just a few more lines without the new data structure.</span>
<span class="comment-copy">@HR123r think about how you would operate on the line to get that decimal! Could you slice the string? Could you split it on something? Worst case scenario, could you apply a regex?</span>
<span class="comment-copy">@Ben I wouldn't consider <code>deque</code> to be a <i>new</i> data structure; it's in the standard library. What are you suggesting?</span>
<span class="comment-copy">@BlacklightShining - I agree that it's totally fair play, and that this is a valid solution to the problem.  I just mean that, if a future reader couldn't conclude that they could just keep track of four lines at a time, then they probably wouldn't know what <code>deque</code> is to begin with.  Hence, the answer might benefit from a touch of exposition.  Fair?  EDIT:  Awesome. :D</span>
<span class="comment-copy">@AvinashRaj The question I saw here was “if I'm iterating over a file, how do I get at the line 4 before the current one?” The issue of parsing values out of a line is separate and should be a new question (though I'm sure it's been answered here already).</span>
<span class="comment-copy">+1 for the explanation. I do believe that a <code>list</code> is a less appropriate container here—the last line is rather inelegant, and each append (including that one) takes O(n) time—though to be fair, with only four items, it hardly matters. By the way, the first four lines of the function could be replaced with a comprehension (<code>previous_lines = [file.readline() for _ in range(3)]</code>). And thanks for pointing out an important flaw in my answer.</span>
<span class="comment-copy">@BlacklightShining - Thanks!  I agree - <code>deque</code> is more appropriate in practice.  I tried just adding the output to your solution, but the edit was rejected on the grounds that it changed the functionality of your answer.  Hence, I figured I would instead show the most fundamental idea behind the solution instead of copying your code and making a mostly redundant answer.  (My feelings are pretty much the same for your suggested comprehension.  It's concise, but I'm trying to be as unclever as possible.)</span>
<span class="comment-copy">Ah—looking back in my notification queue, I see <a href="https://stackoverflow.com/review/suggested-edits/7642123">that suggested edit</a>. I can also understand the reason for its rejection—while it certainly was not “deliberately destructive,” nor did it “deface the post” (?!), it <i>did</i> substantially change my code, making it reflect the question more. In the spirit of giving the asker a tool with which to do the job, I intended to simply demonstrate how a <code>deque</code> could be used in this context, and leave the task of fitting it to the specific case as an excercise for the reader.</span>
