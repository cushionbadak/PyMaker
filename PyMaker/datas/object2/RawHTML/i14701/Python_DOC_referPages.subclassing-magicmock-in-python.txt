<div class="post-text" itemprop="text">
<p>I have a class that I need to patch, which works similar to this</p>
<pre><code>class Foo(object):
    def __init__(self, query):
        self._query = query

    def do_stuff(self):
        # do stuff with self._query
</code></pre>
<p>How would I set up a mocking class for Foo such that</p>
<pre><code>foo = MockFoo(query)
foo.do_stuff()
</code></pre>
<p>returns a mock result, but still taking into account the data passed in for <code>query</code>. I thought of subclassing <code>MagicMock</code> like this</p>
<pre><code>class MockFoo(MagicMock):
    def __init__(self, query, *args, **kwargs):
        super(MagicMock, self).__init__(*args, **kwargs)
        self._query

    def do_stuff(self):
        mock_result = self._query * 10
        return MagicMock(return_value=mock_result)
</code></pre>
<p>but I can't quite figure out how to apply <code>patch</code> to use <code>MockFoo</code> instead of <code>MagicMock</code> in the actual TestCase. I need to be able to write a test similar to this.</p>
<pre><code>with patch('x.Foo') as mock_foo:
    # run test code
    self.assertTrue(mock_foo.called)
    self.assertEqual(mock_foo.wait.return_value, 20)
</code></pre>
<p>I know I can just use plain <code>MagicMock</code> with <code>autospec=True</code> or something and override the return values for each of the methods, but it would be nice to have a mock class which I can just use to replace the production class in one go. The key bit being, having to access the member variable <code>self._query</code> in the mock methods, while having it initialized in the constructor (just like the production class). </p>
</div>
<div class="post-text" itemprop="text">
<p>About you base question the answer is use <code>new_callable</code> parameter in <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow"><code>patch</code></a>: </p>
<pre><code>with patch('x.Foo', new_callable=MockFoo) as mock_foo:
    # run test code
    self.assertTrue(mock_foo.called)
    self.assertEqual(mock_foo.wait.return_value, 20)
</code></pre>
<p>If you need to add some argument to <code>MockFoo</code> init call consider that every argument not used in <code>patch</code> will be passet to the mock constructor (<code>MockFoo</code> in your case).</p>
<p>If you need to a wrapper of your production class maybe you are looking in the wrong place: mock is not wrapper.</p>
<p>When you mock something you don't really want to know how your mock do the work but just how your code use it and how you code react to mocked objects answers.</p>
</div>
<span class="comment-copy">I don't think that works because on some level you need to distinguish between real methods / properties and mocked methods / properties. Things like "called" and "return_value" are part of the mock so it's not feasible to add these to a modified instance of the production class. I think it's better to do as you said by mocking what you need and possibly add some helper code to do so.</span>
