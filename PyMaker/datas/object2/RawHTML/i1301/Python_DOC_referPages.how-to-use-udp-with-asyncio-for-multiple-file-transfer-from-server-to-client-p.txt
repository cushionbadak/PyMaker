<div class="post-text" itemprop="text">
<p>I want to transfer data (multiple images of size &gt; 3 MB) from server to client. Since I want to test the packet loss with no re-transmission, I don't want to use stream (TCP). </p>
<p>I went through this <a href="https://docs.python.org/3/library/asyncio-protocol.html#udp-echo-server" rel="nofollow noreferrer">example</a>. My approach is that, the server reads chunk of data using <code>f.read(1024)</code>and send to the client using <code>transport.sendto(data + seq_num)</code>. Reading and sending will continue in a loop until end of file.
 The client will  receive through <code>datagram_received(self, data, addr):</code>.Since I send sequence number (<em>seq_num</em>) along the data, I can control the lost segment and the order. My problem is on receiving and writing the data on the client side. How do I store data sent from server at different time on the client side with some condition with  <code>datagram_received (self, data, addr)</code> function?</p>
<p>Is there a feature that used to receive data from sock into the buf buffer?  e.g for stream (TCP) <code>data = await loop.sock_recv(tcp_sock, buf)</code>. I appreciate your help.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a feature that used to receive data from sock into the buf buffer? e.g for stream (TCP) <code>data = await loop.sock_recv(tcp_sock, buf)</code>.</p>
</blockquote>
<p>As pointed out in the comment, datagrams can't provide a true streaming interface because UDP does not guarantee delivery order. If I understand the question correctly, you would like an <em>awaitable</em> interface to the event of the delivery of the next UDP packet, as the interface provided by default is purely callback-based.</p>
<p>Fortunately it is quite easy to convert a callback-based interface to an awaitable one - <code>asyncio</code> typically uses <code>Future</code> for that purpose, where the coroutine awaits the future, and the callback invokes <code>set_result()</code> to pass some data to the awaiting coroutine - see <code>on_con_lost</code> in the <a href="https://docs.python.org/3/library/asyncio-protocol.html#udp-echo-client" rel="nofollow noreferrer">sample UDP client</a> from the docs.</p>
<p>A good stream-like API always supports some form of buffering, which can be provided by a limited-capacity queue:</p>
<pre class="lang-py prettyprint-override"><code>class Client:
    def __init__(self):
        self._received = asyncio.Queue(10)
        ...

    async def read_packet(self):
        return await self._received.get()

    def datagram_received(self, data, addr):
        try:
            self._received.put_nowait((data, addr))
        except asyncio.QueueFull:
            log.error(f"dropped packet size {len(data)} from {addr}")
</code></pre>
<p>The limited-size queue allows processing of data to temporarily be slower than the rate at which data arrives, while preventing a memory leak in case the situation continues. After the queue is filled up, the packets are dropped. (With a TCP/IP-backed stream we would slow down reading to provide <em>backpressure</em> - well explained in <a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/" rel="nofollow noreferrer">this article</a>, but with UDP there is no choice but to drop.)</p>
</div>
<span class="comment-copy">If I understand your question correctly, you hope to find a way to assemble your original data in order? If so - well, thatâ€™s what TCP IP is for. If you chose (for whatever good reason) to not use that, you will have to implement this yourself.</span>
<span class="comment-copy">Thanks for for the good explanation. yes, I was looking 'awaitable interface to the event of the delivery of the next UDP packet'. I now get a better understanding from your code snippet. Since observing packet drop is my main goal, I am sticking to UDP.  Can I also set a timeout and stop listing the incoming data from the client?</span>
<span class="comment-copy">@ewalel You can use <code>asyncio.wait_for</code> to implement timeout anywhere in asyncio, e.g. instead of awaiting <code>self.read_packet()</code>, you await <code>asyncio.wait_for(duration, self.read_packet())</code>. You can also flag another future when the packets drop, so you can even await <i>that</i>, and so on. Top stop listening for incoming data, I guess you'd just call <code>transport.close()</code>.</span>
