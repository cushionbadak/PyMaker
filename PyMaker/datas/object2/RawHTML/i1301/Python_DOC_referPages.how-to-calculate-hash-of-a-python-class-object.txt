<div class="post-text" itemprop="text">
<p>In python3, I have a class. Like below:</p>
<pre><code>class Foo:
    def __init__(self):
        self.x = 3
    def fcn(self, val):
        self.x += val
</code></pre>
<p>Then I instantiate objects of that class, like so:</p>
<pre><code>new_obj = Foo()
new_obj2 = Foo()
</code></pre>
<p>Now when I hash these objects, I get <em>different hash values</em>. I need them to return the same hash, as they are the same objects (in theory). </p>
<p>Any idea how I can do this?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Foo:
    def __init__(self):
        self.x = 3
    def fcn(self, val):
        self.x += val
    def __hash__(self):
        return hash(self.x)
</code></pre>
<p>This will calculate the hash using <code>self.x</code>; That means the hash will be the same when <code>self.x</code> is the same. You can return anything from <code>__hash__</code>, but to prevent consistency bugs you should return the same hash if the objects compare equal. More about that <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">in the docs</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>They are <em>not</em> the same object.  The expression <code>Foo()</code> invokes the class constructor, <code>Foo.__init__</code>, which returns a <em>new, unique</em> instance of the object on each call.  Your two calls return two independent objects, residing in different memory locations, each containing its own, private instance of the <code>x</code> attribute.</p>
<p>You might want to read up on Python class and instance theory.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thank you to all who answered. You're right that instantiating a new instance of the same class object is not <em>actually</em> the same, as it occupies a different place in memory. What I ended up doing is similar to what @nosklo suggested.</p>
<p>I created a 'get_hashables' function that returned a dictionary with all the properties of the class that would constitute a unique class object, like so:</p>
<pre><code>def get_hashables(self):
    return {'data': self.data, 'result': self.result}
</code></pre>
<p>Then my main method would take these 'hashable' variables, and hash them to produce the hash itself.</p>
</div>
<span class="comment-copy">You are free to implement <code>__hash__</code> if you'd like. However I question your intent, as <i>"they are the same objects"</i> is not true in most definitions that come to mind. Perhaps you believe the objects should be <i>equal</i> to each other?</span>
<span class="comment-copy">They are not, not in theory and not in practice.</span>
<span class="comment-copy">See my answer as to these being the same object.  That said, what characteristics do you expect your <code>hash</code> function to exhibit?  What are the <code>Foo</code> properties that you want to embody in that function?  To put it another way, if you find that <code>hash(a) == hash(b)</code>, what do you want to have guaranteed about the objects <code>a</code> and <code>b</code>?</span>
<span class="comment-copy">@Prune: Considering hash collisions, it may be more useful to instead determine what <code>hash(a) != hash(b)</code> should guarantee about <code>a</code> and <code>b</code>.</span>
<span class="comment-copy">@user2357112: I realize that -- but I hope that the equality issue will focus OP on what is desired.</span>
