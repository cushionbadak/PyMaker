<div class="post-text" itemprop="text">
<p>I'm trying to create a frozen dataclass but I'm having issues with setting a value from <code>__post_init__</code>. Is there a way to set a field value based on values from an <code>init param</code> in a <code>dataclass</code> when using the <code>frozen=True</code> setting? </p>
<pre><code>RANKS = '2,3,4,5,6,7,8,9,10,J,Q,K,A'.split(',')
SUITS = 'H,D,C,S'.split(',')


@dataclass(order=True, frozen=True)
class Card:
    rank: str = field(compare=False)
    suit: str = field(compare=False)
    value: int = field(init=False)
    def __post_init__(self):
        self.value = RANKS.index(self.rank) + 1
    def __add__(self, other):
        if isinstance(other, Card):
            return self.value + other.value
        return self.value + other
    def __str__(self):
        return f'{self.rank} of {self.suit}'
</code></pre>
<p>and this is the trace </p>
<pre><code> File "C:/Users/user/.PyCharm2018.3/config/scratches/scratch_5.py", line 17, in __post_init__
    self.value = RANKS.index(self.rank) + 1
  File "&lt;string&gt;", line 3, in __setattr__
dataclasses.FrozenInstanceError: cannot assign to field 'value'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/dataclasses.html#frozen-instances" rel="nofollow noreferrer">the same thing the generated <code>__init__</code> method does</a>: <code>object.__setattr__</code>.</p>
<pre><code>def __post_init__(self):
    object.__setattr__(self, 'value', RANKS.index(self.rank) + 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/3/library/dataclasses.html#frozen-instances" rel="nofollow noreferrer">PyDocs</a>, you can't create truly immutable objects.</p>
<p>"...dataclasses will add <strong>setattr</strong>() and <strong>delattr</strong>() methods to the class. These methods will raise a FrozenInstanceError when invoked." </p>
<p>To answer your question, you cannot set values after creation using a frozen dataclass.</p>
<p>Frozen is designed to create a read only object. Not sure why you are trying to as you didn't specify a use-case.</p>
<p>Below is something that you can do, that I believe accomplishes what you are looking to do.</p>
<pre class="lang-py prettyprint-override"><code>
    #!/usr/bin/env python3.7
    """Card Dataclass: Jerod Gawne, 2019.01.09 &lt;https://github.com/jerodg&gt;"""
    from dataclasses import dataclass, field

    RANKS = '2,3,4,5,6,7,8,9,10,J,Q,K,A'.split(',')
    SUITS = 'H,D,C,S'.split(',')


    @dataclass(order=True)
    class Card:
        """Card"""
        rank: str = field(compare=False)
        suit: str = field(compare=False)
        value: int = field(init=False)

        def __post_init__(self):
            self.value = RANKS.index(self.rank) + 1

        def __add__(self, other):
            if isinstance(other, Card):
                return self.value + other.value
            return self.value + other

        def __str__(self):
            return f'{self.rank} of {self.suit}'


    if __name__ == '__main__':
        c = Card(rank='J', suit='H')
        print(c.value)


</code></pre>
<blockquote>
<p>Result: 10</p>
</blockquote>
</div>
<span class="comment-copy">This works. However, it does seem that the <code>dataclass</code> generated <code>__setattr__</code> should know to not raise <code>FrozenInstanceError</code> when being called from <code>__post_init__</code> on a name that has <code>init=False</code>. Using <code>object.__setattr__</code> like this is ugly / tedious.</span>
