<div class="post-text" itemprop="text">
<p>This is the code:</p>
<pre><code>import asyncio
import aiohttp
loop = asyncio.get_event_loop()
session = aiohttp.ClientSession(loop=loop)
data = {'file': open('test_img.jpg', 'rb')}

async def start():
        async with session.post("http://localhost", data=data) as response:
            text = await response.text()
            print(text)

loop.run_until_complete(asyncio.gather(*[start() for i in range(20)]))
</code></pre>
<p>I get an error:</p>
<pre><code>ValueError: read of closed file
</code></pre>
<p>However if I move the <code>open()</code> call to inside the start() function, it works. But I don't want to open the file multiple times.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <code>open(...)</code> returns a <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" rel="nofollow noreferrer">file object</a>, and you're passing the same file object to all <code>start()</code> coroutines you are creating at top-level. The coroutine instance that happens to be scheduled first will transfer the file object to <code>session.post()</code> as part of the <code>data</code> parameter, and <code>session.post()</code> will read the file to the end and close the file object. The next <code>start()</code> coroutine will try to read from the now-closed object which will raise the exception.</p>
<p>To fix the issue without opening the file multiple times, you need to make sure to actually <em>read</em> the data as a bytes object:</p>
<pre><code>data = {'file': open('test_img.jpg', 'rb').read()}
</code></pre>
<p>This will pass the same bytes object to all coroutines, which should work as intended.</p>
</div>
<span class="comment-copy">Hi, I'm curious if my answer helped resolve your issue?</span>
<span class="comment-copy">Yes, though I'm still wondering why the same code is working with <code>requests</code>. using the <code>files=</code> argument</span>
<span class="comment-copy">Good question. Does it actually <i>work</i> (correctly), or does it just not raise an exception? Perhaps <code>requests</code> reads the file through to the end, but doesn't close it, so all requests other than the first one work with zero-length data.</span>
