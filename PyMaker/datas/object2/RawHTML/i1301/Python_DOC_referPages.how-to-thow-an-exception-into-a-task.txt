<div class="post-text" itemprop="text">
<p><code>asyncio.Task</code> only provides a method for throwing an empty <code>CancelledError</code> into the task. However, sometimes it might be desirable to have different types of interrupt. For example, similar to SIGINT, SIGTERM and SIGKILL, multiple levels of cancellation may allow a task to do a better cleanup.</p>
<p><code>asyncio.Task</code> itself can be easily modified to provide such functionality. The question is, how to do it in a more elegant and efficient way?</p>
</div>
<div class="post-text" itemprop="text">
<p>I asyncio was providing such functionality long time ago, but it was cut.</p>
<p>Now in documentation you can <a href="https://docs.python.org/3/library/asyncio-task.html#task-object" rel="nofollow noreferrer">read</a>:</p>
<blockquote>
<p>asyncio.Task inherits from Future all of its APIs except
  Future.set_result() and Future.set_exception().</p>
</blockquote>
<p>And in asyncio <a href="https://github.com/python/cpython/blob/master/Lib/asyncio/tasks.py#L164" rel="nofollow noreferrer">source code</a> you can see:</p>
<pre><code>def set_exception(self, exception):
    raise RuntimeError('Task does not support set_exception operation')
</code></pre>
<p>You can read discussion behind this decision in relevant <a href="https://github.com/python/cpython/pull/4923" rel="nofollow noreferrer">PR</a> and <a href="https://bugs.python.org/issue32363" rel="nofollow noreferrer">issue</a>.</p>
<p>From how I understand stuff supporting <code>set_result</code>/<code>set_exception</code> spawns too many ways to shoot yourself in the foot, for example see <a href="https://groups.google.com/forum/#!msg/python-tulip/-EcYtJXDvSo/mES8xjj0BAAJ" rel="nofollow noreferrer">this</a> discussion.</p>
</div>
<span class="comment-copy">I think that was something different. <code>set_exception</code> and <code>cancel</code> represent different direction of information flow. <code>set_exception</code> is for the producer to notify the consumer, while <code>cancel</code> is exactly the inverse. Throwing an exception into the task is some form of a consumer notifying the producer , so the proper way would be <code>cancel(reason=some_exception)</code>, instead of reusing <code>set_exception</code>. Either way, even when <code>set_exception</code> didn't raise a <code>RuntimeError</code>, it had no affect on wrapped coroutine.</span>
