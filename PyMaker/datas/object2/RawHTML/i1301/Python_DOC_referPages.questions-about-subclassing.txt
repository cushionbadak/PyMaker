<div class="post-text" itemprop="text">
<p>I've read all morning about subclassing and still have a few questions. Suppose we have the class Car below:</p>
<pre><code>class Car():
    doors=4
    color='red'
    def __init__(self,gas,miles):
        self.gas=gas
        self.miles=miles
    @property #responsible for handing back the value of the variable gas
    def gas(self):
        return self._gas
    @gas.setter #responsible for setting the value of the variable gas
    def gas(self,x):
        if x&lt;0:
            raise ValueError('Gas cannot be negative')
        self._gas=x
</code></pre>
<p>The class is instantiated with default values for doors and color. We also check that the value of gas is not negative using decorators. This all makes sense to me. However, suppose we create a subclass ElectricCar:</p>
<pre><code>class ElectricCar(Car):
    def __init__(self,battery_charge,miles):
        self.battery_charge=battery_charge
        super().__init__(miles)
</code></pre>
<p>This does not work. A few questions:</p>
<ol>
<li>If we use <code>super().__init__</code>, do we inherit <strong>all</strong> attributes from the parent class?</li>
<li>In this case, the ElectricCar does not need a value for gas; do we need to inherit this attribute from Car?</li>
<li>When we use <code>super().__init__</code> do we need to reference all of attributes of the parent class constructor? In the case of ElectricCar, do we need to write:  <code>super().__init__(gas, miles)</code> ?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>To answer your questions:</p>
<p>By subclassing <code>Car</code> with <code>ElectricCar</code>, you create a new class called "ElectricCar" that contains all the attributes, properties and functions of the Car class in addition to whatever you add onto <code>ElectricCar</code>. An ElectricCar is a Car and something more. By calling <code>super().__init__</code> you are calling the constructor (the <code>__init__</code> function) on the class's parent class, <code>Car</code> in this case. You get an error because this function expects two arguments: <code>gas</code> and <code>miles</code>, but you only provide one. When calling any method, you <em>must</em> provide <em>all</em> required arguments for that method.</p>
<p>In your case, your <code>ElectricCar</code> doesn't need <code>gas</code> because it represents an electric car. However, you have no option in Python to say, "I want to inherit this from <code>Car</code> but not that". Therefore, you have an issue with your architecture because you assume that the base case for a car is a gasoline car. Therefore, you should remove the <code>gas</code> attribute from <code>Car</code> and create a <code>GasolineCar</code> class that encapsulates that information. </p>
</div>
<div class="post-text" itemprop="text">
<p>Let's come up with a really simple example:</p>
<pre><code>class Foo:
    ca1="a class attribute in Foo"
    def __init__(self, dv1, dv2="a default value"):
        self.ia="an instance attribute in Foo"
        self.dv1=dv1
        self.dv2=dv2

class Bar(Foo):
    ca2="a class attribute in Bar"
    def __init__(self, dv="new default from Bar"):
        self.ia="an instance attribute in Bar"
        super().__init__("from Bar 1", dv)
</code></pre>
<p>Any instance of <code>Bar</code> will inherit from <code>Foo</code> all attributes <em>other than</em> those specifically added or overwritten. </p>
<p>To demonstrate, you can use the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">inspect module</a> to show the attributes of each instance. (I am filtering out the internal methods and attributes to only focus on user attributes):</p>
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; [a for a in inspect.getmembers(Foo("positional argument"), lambda at: not(inspect.isroutine(at))) if not(a[0].startswith('__'))]
[('ca1', 'a class attribute in Foo'), 
 ('dv1', 'positional argument'), 
 ('dv2', 'a default value'), 
 ('ia', 'an instance attribute in Foo')]  # I added the new lines...
</code></pre>
<p>You can see the class and instance variables in an instance of <code>Foo</code> here.</p>
<p>Now look at an instance of <code>Bar</code>:</p>
<pre><code>&gt;&gt;&gt; [a for a in inspect.getmembers(Bar(), lambda at: not(inspect.isroutine(at))) if not(a[0].startswith('__'))]
[('ca1', 'a class attribute in Foo'), 
 ('ca2', 'a class attribute in Bar'), 
 ('dv1', 'from Bar 1'), 
 ('dv2', 'new default from Bar'), 
 ('ia', 'an instance attribute in Foo')]
</code></pre>
<p>If you remove <code>super</code> from the <code>__init__</code> in <code>Bar</code> then the <code>__init__</code> in <code>Foo</code> never gets called. The result is visible and implicit code related to <code>__init__</code> in <code>Foo</code> (like the assignment of instance values) is not done:</p>
<pre><code>class Bar(Foo):
    ca2="a class attribute in Bar"
    def __init__(self, dv="new default from Bar"):
        self.ia="an instance attribute in Bar"
</code></pre>
<p>The difference is that the instance attributes in <code>Foo</code> will not be added as attributes to an instance of <code>Bar</code> (as well as any other specific additions that are made to an instance of <code>Foo</code>):</p>
<pre><code>&gt;&gt;&gt; [a for a in inspect.getmembers(Bar(), lambda at: not(inspect.isroutine(at))) if not(a[0].startswith('__'))]
[('ca1', 'a class attribute in Foo'), 
 ('ca2', 'a class attribute in Bar'), 
 ('ia', 'an instance attribute in Bar')] # note Foo's     
                                         # instance attributes are missing
</code></pre>
</div>
<span class="comment-copy">Look at the difference between a class attribute vs an instance attribute vs a default value.</span>
<span class="comment-copy">You inherit any attributes that belong to the <i>class</i>. This includes methods which may set instance attributes, like init, unless it is overridden. And yes, when you call <code>super().__init__</code> you must pass it the correct arguments. All inheritance is, essentially, is that the base class is checked during method resolution. So when you do <code>myobject.some_attribute</code>, first the instance namespace is checked for <code>some_attribute</code>, then the class namespace, and then all the class namespaces in the method resolution order.</span>
<span class="comment-copy">That inheritance seems wrong. The <code>Car</code> class should define stuff like maximum speed, acceleration, distance traveled per unit of "fuel" (without restricting what you mean by "fuel"). Then you'd have <code>GasolineCar(Car)</code> and <code>ElectricCar(Car)</code> or something like that.</span>
<span class="comment-copy">Or, if the asker wants a more terse answer, I think this is the heart of the matter:  "An ElectricCar is a Car and something more. By calling super().__init__ you are calling the constructor (the <b>init</b> function) on the class's parent class, Car in this case. You get an error because this function expects two arguments: gas and miles, but you only provide one. When calling any method, you must provide all required arguments for that method."</span>
