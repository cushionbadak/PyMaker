<div class="post-text" itemprop="text">
<p>In my program I create an un-ending amount of class instances. the amount depends on how long the program is running. However I don't need the instances at all after a certain code being run. How could i remove them completely from memory?</p>
<p>Simple example code:</p>
<pre><code>class Player:
    def __init__(self, color):
        self.color = color

for n in range(1000):
    p = Player('black')
</code></pre>
<p>Would <code>del p</code> in this case completely remove that instance?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python will remove them from memory for you when they are no longer referred to. If you have <code>Player</code> instances that refer to other <code>Player</code> instances (ex: <code>p.teammates = [list of Players]</code>) you could end up with circular references that may prevent them from being garbage collected. In this case you should consider the <a href="https://docs.python.org/3/library/weakref.html" rel="nofollow noreferrer"><code>weakref</code></a> module.</p>
<p>for example:</p>
<pre><code>&gt;&gt;&gt;sam = Player('blue')
&gt;&gt;&gt;rob = Player('green')
&gt;&gt;&gt;sam.team = [sam, rob]
&gt;&gt;&gt;rob.team = [sam, rob]
&gt;&gt;&gt; #sam and rob may not be deleted because they contain 
&gt;&gt;&gt; #references to eachother so the reference count cannot reach 0
&gt;&gt;&gt;del sam #del is a way to manually dereference an object in an interactive prompt. Otherwise the interpreter cannot know you won't use it again unlike when the entire code is known at the beginning.
&gt;&gt;&gt;print(rob.team[0].color) #this prints 'blue' proving that sam hasn't been deleted yet
blue
</code></pre>
<p>so how do we fix it?</p>
<pre><code>&gt;&gt;&gt;sam = Player('blue')
&gt;&gt;&gt;rob = Player('green')
&gt;&gt;&gt;sam.team = [weakref.ref(sam), weakref.ref(rob)]
&gt;&gt;&gt;rob.team = [weakref.ref(sam), weakref.ref(rob)]
&gt;&gt;&gt; #now sam and rob can be deleted, but we've changed the contents of `p.team` a bit:
&gt;&gt;&gt; #if they both still exist:
&gt;&gt;&gt;rob.team[0]() is sam #calling a `ref` object returns the object it refers to if it still exists
True
&gt;&gt;&gt;del sam
&gt;&gt;&gt;rob.team[0]() #calling a `ref` object that has been deleted returns `None`
None
&gt;&gt;&gt;rob.team[0]().color #sam no longer exists so we can't get his color
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'color'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this instance, <code>del p</code> would only remove the <em>reference</em> to the <code>Player</code> object, so that it can later be picked up by the garbage collector. </p>
<p>However, this also happens when it goes out-of-scope.</p>
<p>In most everyday Python, there is no need to use explicit <code>del</code> statements.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no way in Python to delete an instance. Instead you can delete references to the instance, and once they are all gone, the object is reclaimed.</p>
</div>
<span class="comment-copy">Objects that have no references to them will be collected by the garbage collector</span>
<span class="comment-copy">what if I use an attribute of an instance as parameter for creating another instance? Would this cause the circular references you're talking about? i.e.                              <code>b = Player(p.color)</code></span>
<span class="comment-copy">@BasVelden <code>p.color</code> will refer to a string object you created when you created <code>p</code>. If multiple <code>Player</code> instances refer to the same string, that string will not be deleted until all <code>Player</code> instances referring to it are deleted. while this concept is carried across datatypes (if color was a list instead, only one list would exist in memory, with multiple references to it), Strings in particular have a special additional mechanism called <a href="https://en.wikipedia.org/wiki/String_interning" rel="nofollow noreferrer">string interning</a> to help reduce memory usage and copying.</span>
