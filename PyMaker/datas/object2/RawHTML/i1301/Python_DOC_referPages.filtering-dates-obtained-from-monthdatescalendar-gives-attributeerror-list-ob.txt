<div class="post-text" itemprop="text">
<p><strong>Scenario:</strong> I am trying to pass all days of a month to a list, in which I could iterate and use functions on the days, such as weekday().</p>
<p><strong>Issue:</strong> So far, I was able to use Calendar to pass dates or days into a list. In both cases, when I try to read the dates and output only the wanted weekday, I get the error:</p>
<pre><code>AttributeError: 'list' object has no attribute 'weekday'
</code></pre>
<p><strong>What I did so far (with the help from other posts here on SO):</strong></p>
<p>This here works fine, but I need it to be more dynamic</p>
<pre><code>import calendar
cal = calendar.Calendar()
cal.monthdatescalendar(2019, 1)[0][1]
cal.monthdatescalendar(2019, 1)[0][1].weekday()
r = [foo for foo in cal.monthdatescalendar(2019, 1)]
</code></pre>
<p><strong>So I tried:</strong></p>
<pre><code>r = [foo for foo in calendar.monthcalendar(2019, 1)]
list(r)
</code></pre>
<p><strong>and</strong> </p>
<pre><code>r = [foo for foo in cal.monthdatescalendar(2019, 1)]
list(r)
</code></pre>
<p><strong>All of these work fine, but when I try to iterate, like:</strong></p>
<pre><code>r = [foo for foo in cal.monthdatescalendar(2019, 1)]
if r[1].weekday() == 1:
    list(r)
</code></pre>
<p><strong>or</strong></p>
<pre><code>r = [foo for foo in cal.monthdatescalendar(2019, 1) if foo[1].weekday() == 1]
list(r)
</code></pre>
<p>I get the previously mentioned error.</p>
<p><strong>Question:</strong> Any Idea on how to do this properly / more efficiently?</p>
<p><strong>Final objective:</strong> Is to create a function that takes as input month, year, week and weekday, and returns me a datetime object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Probably something like this</p>
<pre><code>import calendar

cal = calendar.Calendar(firstweekday=0) # firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.
for my_date in cal.itermonthdates(year=2019, month=1):
    print('{}. Weekday is {}'.format(my_date.strftime('%A, %Y-%m-%d'), my_date.weekday()))
</code></pre>
<p>or if you want to use monthdatescalendar, in which case you will gate list of list, i.e. list ot weeks and each week is also a list</p>
<pre><code>import calendar

cal = calendar.Calendar(firstweekday=0) # firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.
for week in cal.monthdatescalendar(year=2019, month=1):
    for my_date in week:
        print('{}. Weekday is {}'.format(my_date.strftime('%A, %Y-%m-%d'), my_date.weekday()))
</code></pre>
<p>Note that it will expose full weeks, e.g. in this case it will start with 31 Dec 2018.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <a href="https://docs.python.org/3/library/calendar.html#calendar.Calendar.monthdatescalendar" rel="nofollow noreferrer"><code>monthdatescalendar</code></a> returns a nested list:</p>
<pre><code>&gt;&gt;&gt; import calendar
&gt;&gt;&gt; cal = calendar.Calendar()
&gt;&gt;&gt; cal.monthdatescalendar(2019, 1)
[[datetime.date(2018, 12, 31),
  datetime.date(2019, 1, 1),
  datetime.date(2019, 1, 2),
  datetime.date(2019, 1, 3),
  datetime.date(2019, 1, 4),
  datetime.date(2019, 1, 5),
  datetime.date(2019, 1, 6)],
 [datetime.date(2019, 1, 7),
  datetime.date(2019, 1, 8),
  datetime.date(2019, 1, 9),
  datetime.date(2019, 1, 10),
  ...
</code></pre>
<p>So, if you want to keep the same structure, in order to retrieve only second days of the week, you could do the following:</p>
<pre><code>&gt;&gt;&gt; filtered_month = [[day for day in week if day.weekday() == 1]
                      for week in cal.monthdatescalendar(2019, 1)]
&gt;&gt;&gt; filtered_month
[[datetime.date(2019, 1, 1)],
 [datetime.date(2019, 1, 8)],
 [datetime.date(2019, 1, 15)],
 [datetime.date(2019, 1, 22)],
 [datetime.date(2019, 1, 29)]]
</code></pre>
<p>Another option is to use <a href="https://docs.python.org/3/library/calendar.html#calendar.Calendar.itermonthdates" rel="nofollow noreferrer"><code>itermonthdates</code></a> but the list will be flat:</p>
<pre><code>&gt;&gt;&gt; [day for day in cal.itermonthdates(2019, 1) if day.weekday() == 1]
[datetime.date(2019, 1, 1),
 datetime.date(2019, 1, 8),
 datetime.date(2019, 1, 15),
 datetime.date(2019, 1, 22),
 datetime.date(2019, 1, 29)]
</code></pre>
<p>Also, note that you can specify the first day of the calendar when creating a <a href="https://docs.python.org/3/library/calendar.html#calendar.Calendar" rel="nofollow noreferrer"><code>Calendar</code></a> object. Then to obtain the first days of the week, you just have to take the first elements of the lists:</p>
<pre><code>&gt;&gt;&gt; cal = calendar.Calendar(calendar.TUESDAY)
&gt;&gt;&gt; [week[0] for week in cal.monthdatescalendar(2019, 1)]
[datetime.date(2019, 1, 1),
 datetime.date(2019, 1, 8),
 datetime.date(2019, 1, 15),
 datetime.date(2019, 1, 22),
 datetime.date(2019, 1, 29)]
</code></pre>
<p><strong>P.S.:</strong><br/>
As a side note, I think it's better to compare days explicitly like this:</p>
<pre><code>if day.weekday() == calendar.TUESDAY:
    ...
</code></pre>
<p>instead of</p>
<pre><code>if day.weekday() == 1:
    ...
</code></pre>
<p>Because <a href="https://www.python.org/dev/peps/pep-0020/#id3" rel="nofollow noreferrer"><em>Explicit is better than implicit</em></a>.</p>
</div>
<span class="comment-copy">Maybe I don't understand something but what's the point of this line: <code>r = [foo for foo in cal.monthdatescalendar(2019, 1)]</code> if you could just write <code>r = cal.monthdatescalendar(2019, 1)</code>?</span>
<span class="comment-copy">@Georgy I was trying to create something I can iterate later with a condition. That line, without the "if" statement, was just a test. The main objective is in: r = [foo for foo in cal.monthdatescalendar(2019, 1) if foo[1].weekday() == 1]</span>
<span class="comment-copy">Thanks, itermonthdates allows me to use the weekday() attribute. Many thanks.</span>
<span class="comment-copy">Thanks for the answer. Actually the last part is very interesting because it could account for the problem of dates from other months bleeding into the list. Problem is, I want to keep the code flexible, so if I set the weekday start with ((calendar.TUESDAY)) I would run into the problem if I input other months or years directly.</span>
