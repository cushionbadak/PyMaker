<div class="post-text" itemprop="text">
<p>I have a Base class with a public <code>fn</code> in it. I want to make all classes in the hierarchy system callable, and their <code>__call__</code>  actually translate their work to <code>fn</code>, the semantic is similar to <code>Class.__call__ = fn</code>. The following codes show how i currently implement.</p>
<pre><code>class Base:
    def fn(self, *input):
        # ...

    __call__ = fn

class Derived(Base):
    def fn(self, input):
        # ...

    __call__ = fn
</code></pre>
<p>i know there is a kind of design that only define a <code>__call__</code> in the Base class, and in <code>__call__</code>'s function body, to translate its work to <code>fn</code>, each Derived class implement its own <code>fn</code>. The semantic is like "inherit a public interface and implement from Base, and in this public interface, each Derived class define its own version of implementation".</p>
<p>However, some of the <code>fn</code> have different parameter list, not always the same as the Base one, like the case that i show above. The above code can work, but i guess there must be better solutions, without the repeat definition in all classes of the hierarchy system.</p>
<p>So is there anyway to specific the <code>__call__</code> only one time in the Base class, but make it available for all Derived class?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're using a Python version &gt;= 3.6, you could write an <a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__" rel="nofollow noreferrer"><code>__init_subclass__</code></a> method of the <code>Base</code> class that assigns the <code>__call__</code> attribute of the child class to be equal to its <code>fn</code> attribute:</p>
<pre><code>class Base:
    def fn(self, *args):
        return args
    __call__ = fn
    def __init_subclass__(cls):
        cls.__call__ = cls.fn

class Derived(Base):
    def fn(self, arg):
        print("In derived")
        return arg


Base()(1, 2, 3)
# (1, 2, 3)

Derived()(1)
# In derived
# 1
</code></pre>
<p>If you're using an older version of Python, you can accomplish a similar effect with a metaclass.</p>
<pre><code>class BaseMeta(type):
    def __init__(cls, *args, **kwargs):
        super().__init__(*args, **kwargs)
        cls.__call__ = cls.fn

class Base(metaclass=BaseMeta):
    def fn(self, *args):
        return args

class Derived(Base):
    def fn(self, arg):
        print("In derived")
        return arg
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the example you provided there is no need to use <code>__call__</code>. There is already a perfectly good mechanism, since python will call the class constructor. So simply <code>def __init__(self, *args):</code> and have that code call <code>fn</code> as appropriate.</p>
<p>You mention different parameter lists, without describing how to distinguish them. If it is a simple criterion, like <code>len(args)</code>, then what you have suffices. If it is more complex, you might want to put <code>**kwargs</code> in the signature, and have each method pick out just the keyword arguments that it recognizes.</p>
</div>
<span class="comment-copy">Maybe i did not explain my question clearly. The example i provided above simplify the real situation. The point is, i want semantic like  <code>__call__ == fn</code> in the whole hierarchy system, without the repeat definition in all classes(no matter definition in the class definition or a instance attribute setting in the <code>__init__</code>, the above code can work, but i guess there must be some better solutions in python world?</span>
