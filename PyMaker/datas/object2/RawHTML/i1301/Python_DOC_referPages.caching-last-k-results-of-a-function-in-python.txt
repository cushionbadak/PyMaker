<div class="post-text" itemprop="text">
<p>I want to write a function that accepts a single-argument function f, and an integer k, and returns a function that behaves the same as f except it caches the last k results of f.</p>
<p>For instance, if memoize is the function we're after, and let mem_f = memoize(f, 2), then:</p>
<pre><code>    mem_f(arg1) -&gt; f(arg1) is computed and cached  
    mem_f(arg1) -&gt; f(arg1) is returned from cache  
    mem_f(arg2) -&gt; f(arg2) is computed and cached  
    mem_f(arg3) -&gt; f(arg3) is computed and cached, and f(arg1) is evicted
</code></pre>
<p>What I have done is:</p>
<pre><code>def memoize(f,k):
    cache = dict()

    def mem_f(*args):
        if args in cache:
            return cache[args]
        result = f(*args)
        cache[args]= result
        return result 
    return mem_f
</code></pre>
<p>This function returns the result from cache and if it is not in cache, it is computed and cached. However, I am not clear <strong>how to cache only last k results of f?</strong> I am newbie, any help would be appreciated.   </p>
</div>
<div class="post-text" itemprop="text">
<p>You could just use <a href="https://docs.python.org/3/library/functools.html" rel="noreferrer"><code>functools.lru_cache</code></a> to do the caching. I accepts a <code>maxsize</code> parameter to control how much it caches:</p>
<pre><code>from functools import lru_cache

@lru_cache(maxsize=2)
def test(n):
    print("calling function")
    return n * 2

print(test(2))
print(test(2))
print(test(3))
print(test(3))
print(test(4))
print(test(4))
print(test(2))
</code></pre>
<p>results:</p>
<blockquote>
<p>calling function<br/>
  4<br/>
  4<br/>
  calling function<br/>
  6<br/>
  6<br/>
  calling function<br/>
  8<br/>
  8<br/>
  calling function<br/>
  4  </p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Expanding on the excellent suggestion of Mark Meyer, here's what the solution looks like using <code>lru_cache</code> and the terminology of your question:</p>
<pre><code>from functools import lru_cache


def memoize(f, k):
    mem_f = lru_cache(maxsize=k)(f)
    return mem_f


def multiply(a, b):
    print("Called with {}, {}".format(a, b))
    return a * b


def main():
    memo_multiply = memoize(multiply, 2)
    print("Answer: {}".format(memo_multiply(3, 4)))
    print("Answer: {}".format(memo_multiply(3, 4)))
    print("Answer: {}".format(memo_multiply(3, 7)))
    print("Answer: {}".format(memo_multiply(3, 8)))


if __name__ == "__main__":
    main()
</code></pre>
<p>Result:</p>
<pre><code>Called with 3, 4
Answer: 12
Answer: 12
Called with 3, 7
Answer: 21
Called with 3, 8
Answer: 24
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Solution</h1>
<p>You can fix the code you have by using <code>OrderedDict</code> like this:</p>
<pre><code>from collections import OrderedDict

def memoize(f, k):
    cache = OrderedDict()

    def mem_f(*args):
        if args in cache:
            return cache[args]
        result = f(*args)
        if len(cache) &gt;= k:
            cache.popitem(last=False)
        cache[args]= result
        return result 
    return mem_f,cache
</code></pre>
<h1>Testing it out</h1>
<pre><code>def mysum(a, b):
    return a + b

mysum_cached,cache = memoize(mysum, 10)
for i in range(100)
    mysum_cached(i, i)

print(cache)
</code></pre>
<p>Output:</p>
<pre><code>OrderedDict([((90, 90), 180), ((91, 91), 182), ((92, 92), 184), ((93, 93), 186), ((94, 94), 188), ((95, 95), 190), ((96, 96), 192), ((97, 97), 194), ((98, 98), 196), ((99, 99), 198)])
</code></pre>
<p>This version of <code>memoize</code> will likely work well for your own code. However, for production code (ie code that other people have to rely on), you should probably use the standard library function (<code>functools.lru_cache</code>) that Mark Meyer suggests.</p>
</div>
<span class="comment-copy">This would need an additional data structure to keep the keys(=parameters) called at last. One such structure could be a <code>collections.deque</code>.</span>
