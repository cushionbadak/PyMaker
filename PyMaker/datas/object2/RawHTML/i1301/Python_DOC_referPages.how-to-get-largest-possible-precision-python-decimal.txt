<div class="post-text" itemprop="text">
<p>I'm using the <a href="https://docs.python.org/2/library/decimal.html" rel="nofollow noreferrer">Decimal</a> class for operations that requires precision.</p>
<p>I would like to use 'largest possible' precision. With this, I mean as precise as the system on which the program runs can handle.</p>
<p>To set a certain precision it's simple:</p>
<pre><code>import decimal
decimal.getcontext().prec = 123 #123 decimal precision
</code></pre>
<p>I tried to figure out the maximum precision the 'Decimal' class can compute:</p>
<pre><code>print(decimal.MAX_PREC)
&gt;&gt; 999999999999999999
</code></pre>
<p>So I tried to set the precision to the maximum precision (knowing it probably won't work..):</p>
<pre><code>decimal.getcontext().prec = decimal.MAX_PREC
</code></pre>
<p>But, of course, this throws a <strong>Memory Error</strong> (on division)</p>
<p>So my question is: How do I figure out the maximum precision the current system can handle?</p>
<p>Extra info:</p>
<pre><code>import sys
print(sys.maxsize)
&gt;&gt; 9223372036854775807
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Trying to do this is a mistake. Throwing more precision at a problem is a tempting trap for newcomers to floating-point, but it's not that useful, especially to this extreme.</p>
<p>Your operations wouldn't actually require the "largest possible" precision even if that was a well-defined notion. Either they require <em>exact</em> arithmetic, in which case <code>decimal.Decimal</code> is the wrong tool entirely and you should look into something like <code>fractions.Fraction</code> or symbolic computation, or they don't require that much precision, and you should determine how much precision you <em>actually need</em> and use that.</p>
<p>If you still want to throw all the precision you can at your problem, then how much precision that actually is will depend on what kind of math you're doing, and how many absurdly precise numbers you're attempting to store in memory at once. This can be determined by analyzing your program and the memory requirements of <code>Decimal</code> objects, or you can instead take the precision as a parameter and binary search for the largest precision that doesn't cause a crash.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd like to suggest a function that allows you to estimate your maximum precision for a given operation in a brute force way:</p>
<pre><code>def find_optimum(a,b, max_iter):
    for i in range(max_iter):
        print(i)
        c = int((a+b)/2)
        decimal.getcontext().prec = c
        try:
            dummy = decimal.Decimal(1)/decimal.Decimal(7) #your operation
            a = c
            print("no fail")
        except MemoryError:
            print("fail")
            dummy = 1
            b = c
        print(c)
        del dummy
</code></pre>
<p>This is just halving intervals one step at a time and looks if an error occurs. Calling with <code>max_iter=10</code> and <code>a=int(1e9), b=int(1e11)</code> gives:</p>
<pre><code>&gt;&gt;&gt; find_optimum(int(1e9), int(1e11), 10)
0
fail
50500000000
1
no fail
25750000000
2
no fail
38125000000
3
no fail
44312500000
4
fail
47406250000
5
fail
45859375000
6
no fail
45085937500
7
no fail
45472656250
8
no fail
45666015625
9
no fail
45762695312
</code></pre>
<p>This may give a rough idea of what you are dealing with. This took approx half an hour on i5-3470 and 16GB RAM so you really only would use it for testing purposes. </p>
<p>I don't think, that there is an actual exact way of getting the maximum precision for your operation, as you'd have to have exact knowledge of the dependency of your memory usage on memory consumption. I hope this helps you at least a bit and I would really like to know, what you need that kind of precision for.</p>
<p><strong>EDIT</strong> I feel like this really needs to be added, since I read your comments under the top rated post here. Using arbitrarily high precision in this manner is not the way, that people calculate constants. You would program something, that utilizes disk space in a smart way (for example calcutating a bunch of digits in RAM and writing this bunch to a text file), but never only use RAM/swap only, because this will always limit your results. With modern algorithms to calculate pi, you don't need infinite RAM, you just put another 4TB hard drive in the machine and let it write the next digits. So far for mathematical constants.</p>
<p>Now for physical constants: They are not precise. They rely on measurement. I'm not quite sure atm (will edit) but I think the <em>most exact</em> physical constant has an error of 10**(-8). Throwing more precision at it, doesn't make it more exact, you just calculate more wrong numbers.</p>
<p>As an experiment though, this was a fun idea, which is why I even posted the answer in the first place.</p>
</div>
<div class="post-text" itemprop="text">
<p>The maximum precision of the Decimal class is a function of the memory on the device, so there's no good way to set it for the general case. Basically, you're allocating all of the memory on the machine to one variable to get the maximum precision.</p>
<p>If the mathematical operation supports it, long integers will give you unlimited precision. However, you are limited to whole numbers.</p>
<p>Addition, subtraction, multiplication, and simple exponents can be performed exactly with long integers.</p>
<p>Prior to Python 3, the built-in <code>long</code> data type would perform arbitrary precision calculations.
<a href="https://docs.python.org/2/library/functions.html#long" rel="nofollow noreferrer">https://docs.python.org/2/library/functions.html#long</a></p>
<p>In Python &gt;=3, the <code>int</code> data type now represents long integers.
<a href="https://docs.python.org/3/library/functions.html#int" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#int</a></p>
<p>One example of a 64-bit integer math is implementation is bitcoind, where transactions calculations require exact values. However,  the precision of Bitcoin transactions is limited to 1 "Satoshi"; each Bitcoin is defined as 10^8 (integer) Satoshi.</p>
<p>The Decimal class works similarly under the hood. A Decimal precision of 10^-8 is similar to the Bitcoin-Satoshi paradigm.</p>
</div>
<div class="post-text" itemprop="text">
<p>From your reply above:</p>
<blockquote>
<p>What if I just wanted to find more digits in pi than already found? what if I wanted to test the irrationality of e or mill's constant.</p>
</blockquote>
<p>I get it. I really do. My <a href="https://stackoverflow.com/questions/16369616/multiprecision-python-library-that-plays-well-with-boostmultiprecision-or-othe">one SO question</a>, several years old, is about arbitrary-precision floating point libraries for Python. If those are the types of numerical representations you want to generate, be prepared for the deep dive. Decimal/FP arithmetic is <a href="https://docs.python.org/3.7/tutorial/floatingpoint.html" rel="nofollow noreferrer">notoriously tricky</a> in Computer Science. </p>
<blockquote>
<p>Some programmers, when confronted with a problem, think “I know, I’ll use floating point arithmetic.” Now they have 1.999999999997 problems. – <a href="https://henrikwarne.com/2017/09/16/more-good-programming-quotes-part-2/" rel="nofollow noreferrer">@tomscott</a></p>
</blockquote>
<p>I think when others have said it's a "mistake" or "it depends" to wonder what the max precision is for a Python Decimal type on a given platform, they're taking your question more literally than I'm guessing it was intended. You asked about the Python Decimal type, but if you're interested in FP arithmetic for educational purposes -- "to find more digits in pi" -- you're going to need more powerful, more flexible tools than <a href="https://docs.python.org/3.7/library/decimal.html?highlight=decimal#module-decimal" rel="nofollow noreferrer">Decimal</a> or <a href="https://docs.python.org/3.7/library/functions.html#float" rel="nofollow noreferrer">float</a>. These built-in Python types don't even come <em>close</em>. Those are good enough for NASA maybe, but they have limits... in fact, the very limits you are asking about.</p>
<p>That's what multiple-precision (or <a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic" rel="nofollow noreferrer">arbitrary-precision</a>) floating point libraries are for: arbitrarily-precise representations. Want to compute <em>pi</em> for the next 20 years? Python's Decimal type won't even get you through the <em>day</em>.</p>
<p>The fact is, multi-precision binary FP arithmetic is still kinda fringe science. For Python, you'll need to install the <a href="https://www.mpfr.org/" rel="nofollow noreferrer">GNU MPFR</a> library on your Linux box, then you can use the Python library <a href="https://pypi.org/project/gmpy2/" rel="nofollow noreferrer">gmpy2</a> to dive as deep as you like. </p>
<p>Then, the question isn't, "What's the max precision my program can use?"</p>
<p>It's, "How do I write my program so that it'll run until the electricity goes out?"</p>
<p>And that's a whole other problem, but at least it's restricted by your algorithm, not the hardware it runs on.</p>
</div>
<span class="comment-copy">Your system might have memory available for a few objects with precision X but not for many. So there is not a single answer—the maximum precision you can use before running out of memory depends on the calculations you are going to do.</span>
<span class="comment-copy">I tried doing what you did and it doesn't throw any Memory Error and changes the precision. What is your python version? Also, you might want to look at <a href="https://stackoverflow.com/questions/28081091/what-is-the-largest-number-the-decimal-class-can-handle">this answer</a></span>
<span class="comment-copy">@RickM. I'm using python 3.6.5 (64bit), have you tried doing a division or something with a infinite non-repeating decimal?</span>
<span class="comment-copy">@Eli Sure, there you can expect MemoryError but that doesn't mean that the precision isn't set (as Eric Postpischii says). As your question is now, you should add Memory Error on division to make things clearer.</span>
<span class="comment-copy">@RickM. I've edited the question, but the question doesn't change much, as just want a way to go as precise as it can get...</span>
<span class="comment-copy">This is absolutely the correct answer. You need a surprisingly small number of bits to calculate things like the exact distance to Alpha Centauri in millimeters (only about 20 decimal digits, only slightly outside the range of a normal 64-bit integer). I think it's probably safe to say that in any real-world application, your measurement error is going to exceed any numeric error caused by a lack of <code>Decimal</code> precision.</span>
<span class="comment-copy">@user2357112, It's not a mistake, it's education. Of course I don't need infinite precision, but what if I discovered a new constant? and would like to release an application that uses precision 'infinitly'. What if I just wanted to find more digits in pi than already found? what if I wanted to test the irrationality of e  or mill's constant. What if I could make a program that just goes as precise as possible untill it can't due to memory or whatnot.. NASA only uses 15 digits of pi because it's accurate enough, and yet people still try to get more, here I am trying to make that possible.</span>
<span class="comment-copy">@Eli: Throwing the maximum possible precision at the problem doesn't actually help with any of the stuff you've listed. For example, the state of the art in computing pi doesn't involve just throwing precision at an arbitrary-precision floating point implementation; it looks like <a href="http://www.numberworld.org/y-cruncher/algorithms.html" rel="nofollow noreferrer">this</a>, and it manages precision based on what a computation actually needs. (Also, it knows how to use disk space intelligently instead of being limited to memory or OS-level swap.)</span>
<span class="comment-copy">As for rationality testing, no amount of precision will let you test the irrationality of e or Mill's constant through direct computation (and I don't think we know how to compute Mill's constant for sure anyway).</span>
<span class="comment-copy">Trying to push the limits of high-precision computing is a worthy goal, but it doesn't work like this.</span>
<span class="comment-copy">That's exactly what I could do, calculate X-amount of digits and flush it to hard drive, doesn't even have to be a text file, binary will do fine as well. But the thing is RAM is faster than HDD. So figuring next digits and writing it is more tedious than calculating millions of digits and flushing those to a file.  But I'm glad this question is getting some attention.</span>
<span class="comment-copy">If you are using your RAM as a buffer, before writing to a disk, that's okay</span>
