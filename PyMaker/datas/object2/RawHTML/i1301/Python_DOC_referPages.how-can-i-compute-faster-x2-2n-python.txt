<div class="post-text" itemprop="text">
<pre><code>x = 2**1000000
n = 2**100000000
</code></pre>
<p><code>(x**2-2)%n</code> is too slow. I found pow() but I can't use it because I can't subtract 2. <code>(pow(x, 2)-2)%n</code> and <code>(x*x-2)%n</code> are also slow. When I tested <code>(x*x-2)</code> it was fast but when I added the modulo operator it was slow. Is there a way to compute <code>(x**2-2)%n</code> faster?</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you running this in the interpreter? I did some testing and the main slowdown seemed to come from the interpreter trying to display the result.</p>
<p>If you assign the expression to a variable, the interpreter won't try to display the result, and it will be very quick:</p>
<pre><code>x = 2**1000000
n = 2**100000000
result = (x**2-2)%n
</code></pre>
<p><strong>Addendum:</strong></p>
<p>I was also originally thinking along the same lines as MikeW's answer, and if you wanted <em>every</em> part of the code to be fast, you could take advantage of Python's internal base 2 representation of integers and use bitwise left shifts:</p>
<pre><code>x = 1 &lt;&lt; 1000000
n = 1 &lt;&lt; 100000000
</code></pre>
<p>This comes with the caveat that this only works because <code>x</code> and <code>n</code> are powers of 2, and you have to be more careful to avoid making an off-by-one error. <a href="https://stackoverflow.com/a/141873/8117067">This answer</a> is a good explanation of how bitshifts basically work, but Python is bit different than other languages like C, C++, or Java because Python integers are <a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex" rel="noreferrer">unlimited precision</a>, so you can never left shift a bit completely away like you could in other languages.</p>
</div>
<div class="post-text" itemprop="text">
<p>Some module rules :</p>
<p>1) (a+b)mod(n)  = amod(n)+bmod(N)</p>
<p>2) (a.b)mod(n)  = amod(n).bmod(n)</p>
<p>So you can transform your equation into :</p>
<p>(x**2-2)%n ==&gt; (x.x - 2)%n ==&gt; (x%n).(x%n) - (2%n) </p>
<p>If n is always greater than 2, (2%n) is 2 itself.</p>
<p>solving (x%n) : </p>
<p>If x and n are always in 2**value ; if x &gt; n then (x%n)= 0 is the answer and if x &lt; n (x%n)=x  </p>
<p>So the answer is either 0-(2%n) or x**2-(2%n) </p>
</div>
<div class="post-text" itemprop="text">
<p>If x is always a power of 2, and n is always a power of 2, then you can you can compute it easily and quickly using bit operations on a byte array, which you can then reconstitute into a "number".</p>
<p>If 2^N is (binary) 1 followed by N zeroes, then (2^N)^2 is (binary) 1 followed by 2N zeros.</p>
<pre><code>2^3 squared is b'1000000'
</code></pre>
<p>If you have a number 2^K (binary 1 followed by K zeroes), then 2^K - 2 will be K-1 1s (ones) followed by a zero.</p>
<pre><code>eg 2^4 is 16 =  b'10000', 2^4 - 2 is b'1110'
</code></pre>
<p>If you require "% 2^M" then in binary, you just select the last (lower) M bits, and disregard the rest .</p>
<pre><code>9999 is       b'10011100001111'
9999 % 2^8 is       b'00001111'
</code></pre>
<p>'</p>
<p>Hence combining the parts, if x=2^A and n=2^B, then</p>
<p>(x^2 - 2 ) % n</p>
<p>will be: (last B bits of) (binary) (2*A - 1 '1's followed by a '0')</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to compute (x ** y - z) % n<br/>
it will be equivalent to ((x ** y) % n - z) % n</p>
<p>Python pow function includes as optional parameter a modulo, as it is very often used and can be computed in an optimized way. So you should use:</p>
<pre><code>(pow(x, y, n) - z) % n
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>OP says in comment : <em>it's slow because I assign x to the answer and I repeat the process</em>. </p>
<p>I try this :</p>
<pre><code>x = 2**(1000*1000)
n = 2**(100*1000*1000)

import time
t0=time.time()
for i in range(6):
    x = (x*x-2)%n   
    t1=time.time()
    print(i,t1-t0)
    t0=t1

print(x&lt;n)

"""    
0 0.0
1 0.4962291717529297
2 0.5937404632568359
3 1.9043104648590088
4 5.708504915237427
5 16.74528479576111  
True   
"""
</code></pre>
<p>It shows that in this problem, it's just slow because <code>x</code> grows, doubling the number of digit at each loop :   </p>
<pre><code>In [5]: %timeit  u=x%n
149 ns ± 6.42 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>
<p>the <code>%n</code> takes absolutely no time if <code>x&lt;n</code>.</p>
</div>
<span class="comment-copy">could you maybe simplify it based on <a href="https://en.wikipedia.org/w/index.php?title=Modular_arithmetic&amp;action=edit&amp;section=3" rel="nofollow noreferrer">modulo properties</a>? A quick look (and intuition) reveals that you do not need the <code>-2</code> for example.</span>
<span class="comment-copy">I don't know the modulo properties. Can you send a link?</span>
<span class="comment-copy">For a large value of x.</span>
<span class="comment-copy">What is your criterion of "too slow" ? Do you have some numbers for an existing test run, and a figure that you would like to achieve ?</span>
<span class="comment-copy">1) (a+b)mod(n)  = amod(n)+bmod(N) 2) (a.b)mod(n)  = amod(n).bmod(n)</span>
<span class="comment-copy">Is x = 1 &lt;&lt; 1000000 equal to x = 2**1000000?</span>
<span class="comment-copy">@JohnnyP. Yes, you can test it yourself: <code>2**100000000 == 1 &lt;&lt; 100000000</code></span>
<span class="comment-copy">Can % work in binary numbers?</span>
<span class="comment-copy">@JohnnyP. Internally, <i>all</i> numbers are binary to Python. As demonstrated by the above comparison, the numbers are identical. The only difference is that using a bitshift is faster than individually doing each multiplication by 2 (I'll add a link explaining binary in a second)</span>
<span class="comment-copy">It runs very fast.</span>
<span class="comment-copy">These rules are incorrect, at least as written here. For example (3+4) mod 5 = 2, while (3 mod 5) + (4 mod 5) = 7. You need to replace "=" with "≡". Or, equivalently, add one more "mod(n)" at the end.</span>
<span class="comment-copy">How can I do it?</span>
<span class="comment-copy">You don't need a "byte array" to do this—that's essentially what Python's built-in <code>int</code> type is already. Just use shift operators on <code>int</code> values. See the <b>Edit</b> in @Graham's answer.</span>
<span class="comment-copy">it is not faster.</span>
