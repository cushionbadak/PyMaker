<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2835206/python-regular-expressions-how-to-extract-longest-of-overlapping-groups">python regular expressions, how to extract longest of overlapping groups</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>For some reason I need to generate the regular expression from some arbitrary list by using alternations.</p>
<p>Let's say the user can input <code>"cat"</code>, <code>"dog"</code> and <code>"!@[]"</code>, it will generate <code>"cat|dog|!@\\{\\}"</code>.</p>
<p>The problem is that, can I make the re to match the longest term when several of the inputs contain common prefix?</p>
<p>For example:</p>
<p><code>"god"</code>, <code>"godspeed"</code>, <code>"godzilla"</code> will generate <code>"god|godspeed|godzilla"</code></p>
<p>I want it to match the longest term if there are several matches. That is to match <code>"godspeed"</code> rather than <code>"god"</code> if I use <code>re.finditer()</code> to match the string <code>"godspeeding"</code></p>
<p><em>I have tried in Python 3.7.1 and it seems it reports matches according to the order in the regular expression.</em> If this is always true, I can just sort the input (wrt length) before converting them to regular expression.</p>
<p><strong>However, I cannot find any documentation about this behavior and not sure if this will be unchanged in the future.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>As the target string is scanned, REs separated by '|' are tried from left to right. When one pattern completely matches, that branch is accepted.</p>
</blockquote>
<p>This is specified behavior and will most likely not be changed in the future. You should be alright sorting wrt the lenghts and performing the regex match afterwards.</p>
<p>Does this answer your question?</p>
</div>
<span class="comment-copy">Sort them by length in descending order. Also, if you need to match whole words use word boundaries, <code>\b(god|godspeed|godzilla)\b</code>. Combining these two things is usually sufficient.</span>
<span class="comment-copy">This is how regular expressions work. It only consumes characters to make a match, it doesn't know anything about the <i>ideal</i> match per your specifications. Once a match is made, it's happy. Since it is endemic to the system itself, it doesn't surprise me if Python's documentation of its regexp implementation doesn't include notes about it.</span>
<span class="comment-copy">@AdamSmith This is how <i>some</i> (well, I suppose 'most' at this point) regular expression engines works.. it is not a requirement that a regular expression engine is <i>greedy</i>. See <a href="https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines" rel="nofollow noreferrer">en.wikipedia.org/wiki/Comparison_of_regular_expression_engines</a> - "Note that many older, pre-POSIX engines were non-greedy and didn't have greedy quantifiers at all.". Also, there is no universal requirement that an alternation only evaluations one branch, or that it selects branch based on order: <i>this logic belongs to to a specific regular expression impl./contract</i>, in this specific case it's Python.</span>
<span class="comment-copy">It seems like a legitimate question, and definitely shows prior research. I focused the title and drew out the stated/observed information to avoid re-information about the same.. programming is about <i>guarantees</i> (and a little bit of finger crossing when such is informal).</span>
<span class="comment-copy">@user2864740 Yes this was my concern too because since the quantifiers are greedy, the alternations should be greedy too. But it seems that it all depends on the implementations. Thanks a lot :-)</span>
<span class="comment-copy">Would you explain the downvote? This seems to be a legitimate answer to me. If not pls explain what's wrong with it. Thanks ;-)</span>
<span class="comment-copy">Thanks for you answer! I overlook this part and your solution definitely answers my question. PS. I did not downvote you :-p</span>
<span class="comment-copy">Alright, glad I could help ;-)</span>
