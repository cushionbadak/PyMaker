<div class="post-text" itemprop="text">
<p>Consider the following Python code:</p>
<pre><code>b = [1,2,3,4,5,6,7]
a = iter(b)
for x in a :
    if (x % 2) == 0 :
        print(next(a))
</code></pre>
<p>Which will print 3, 5, and 7. Is the use of <code>next</code> on the variable being iterated on a reliable construct (you may assume that a StopIteration exception is not a concern or will be handled), or does the modification of the iterator being looped over inside the loop constitute a violation of some principle?</p>
</div>
<div class="post-text" itemprop="text">
<p>There's nothing <em>wrong</em> here protocol-wise or in theory that would stop you from writing such code. An exhausted iterator <code>it</code> will throw <code>StopIteration</code> on every subsequent call to <code>it.__next__</code>, so the <code>for</code> loop technically won't mind if you exhaust the iterator with a <code>next</code>/<code>__next__</code> call in the loop body.</p>
<p>I advise against writing such code because the program will be very hard to reason about. If the scenario gets a little more complex than what you are showing here, at least I would have to go through some inputs with pen and paper and work out what's happening.</p>
<p>In fact, your code snippet possibly does not even behave like you think it behaves, assuming you want to print every number that is preceded by an even number.</p>
<pre><code>&gt;&gt;&gt; b = [1, 2, 4, 7, 8]                                              
&gt;&gt;&gt; a = iter(b)                                                      
&gt;&gt;&gt; for x in a: 
...:    if x%2 == 0: 
...:        print(next(a, 'stop'))                                   
4
stop
</code></pre>
<p>Why is <code>7</code> skipped although it's preceded by the even number <code>4</code>?</p>
<pre><code>&gt;&gt;&gt;&gt; a = iter(b)                                                      
&gt;&gt;&gt;&gt; for x in a: 
...:     print('for loop assigned x={}'.format(x)) 
...:     if x%2 == 0: 
...:         nxt = next(a, 'stop') 
...:         print('if popped nxt={} from iterator'.format(nxt)) 
...:         print(nxt)
...:                                               
for loop assigned x=1
for loop assigned x=2
if popped nxt=4 from iterator
4
for loop assigned x=7
for loop assigned x=8
if popped nxt=stop from iterator
stop
</code></pre>
<p>Turns out <code>x = 4</code> is never assigned by the <code>for</code> loop because the explicit <code>next</code> call popped that element from the iterator before the <code>for</code> loop had a chance to look at the iterator again.</p>
<p>That's something I'd hate to work out the details of when reading code.</p>
<hr/>
<p>If you want to iterate over an iterable (including iterators) in "<code>(element, next_element)</code>" pairs, use the <code>pairwise</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer">recipe</a> from the <code>itertools</code> documentation.</p>
<pre><code>from itertools import tee                                         

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..." 
    a, b = tee(iterable) 
    next(b, None) 
    return zip(a, b) 
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; b = [1,2,3,4,5,6,7]                                               
&gt;&gt;&gt; a = iter(b)                                                       
&gt;&gt;&gt;                                                                   
&gt;&gt;&gt; for x, nxt in pairwise(a): # pairwise(b) also works 
...:    print(x, nxt)                                                                      
1 2
2 3
3 4
4 5
5 6
6 7
</code></pre>
<p>In general, <code>itertools</code> together with its recipes provides many powerful abstractions for writing readable iteration-related code. Even more useful helpers can be found in the <a href="https://pypi.org/project/more-itertools/" rel="noreferrer"><code>more_itertools</code></a> module, including an implementation of <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.pairwise" rel="noreferrer"><code>pairwise</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends what you mean by 'safe', as others have commented, it is okay, but you can imagine some contrived situations that might catch you out, for example consider this code snippet:</p>
<pre><code>b = [1,2,3,4,5,6,7]
a = iter(b)
def yield_stuff():
    for item in a:
        print(item)
        print(next(a))
    yield 1

list(yield_stuff())
</code></pre>
<p>On Python &lt;= 3.6 it runs and outputs:</p>
<pre><code>1
2
3
4
5
6
7
</code></pre>
<p>But on Python 3.7 it raises <code>RuntimeError: generator raised StopIteration</code>. Of course this is expected if you read <a href="https://www.python.org/dev/peps/pep-0479/" rel="nofollow noreferrer">PEP 479</a> and if you're thinking about handling <code>StopIteration</code> anyway you might never encounter it, but I guess the use cases for calling <code>next()</code> inside a <code>for</code> loop are rare and there are normally clearer ways of re-factoring the code.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you modify you code to see what happens to iterator <code>a</code>:</p>
<pre><code>b = [1,2,3,4,5,6,7]
a = iter(b)

for x in a :
    print 'x', x
    if (x % 2) == 0 :
        print 'a', next(a)
</code></pre>
<p>You will see the printout:</p>
<pre><code>x 1
x 2
a 3
x 4
a 5
x 6
a 7
</code></pre>
<p>It means that when you are doing <code>next(a)</code> you are moving forward your iterator. If you need (or will need in the future) to do something else with iterator <em>a</em>, you will have problems. For complete safety use various recipes from <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow noreferrer">itertools</a> module. For example:</p>
<pre><code>from itertools import tee, izip

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return izip(a, b) 

b = [1,2,3,4,5,6,7]
a = iter(b)
c = pairwise(a)

for x, next_x in c:
    if x % 2 == 0:
        print next_x
</code></pre>
<p>Not that here you have full control in any place of the cycle either on current iterator element, or next one.</p>
</div>
<span class="comment-copy">A question to ponder: what happens if you skip the <code>if</code> condition and always call <code>next(a)</code>?</span>
<span class="comment-copy">That's fine as long as you know what you're getting into.</span>
<span class="comment-copy">Ok, but worth commenting if others are going to be using/reading the code.</span>
<span class="comment-copy">Other than academic interest, I fail to understand why one would write code like this?</span>
<span class="comment-copy">@copper.hat You can see here - <a href="https://stackoverflow.com/questions/53762253/using-a-python-script-which-reads-a-77gb-file-into-memory-to-scan-for-keywords" title="using a python script which reads a 77gb file into memory to scan for keywords">stackoverflow.com/questions/53762253/…</a> - for the motivating example. The aim is to find a line in a file too large to read into memory and process the next line. The <code>pairwise</code> recipe in timgeb's answer is a clearer way to do this.</span>
<span class="comment-copy">The example above is, of course, a toy, you can see the motivating example here: <a href="https://stackoverflow.com/questions/53762253/using-a-python-script-which-reads-a-77gb-file-into-memory-to-scan-for-keywords" title="using a python script which reads a 77gb file into memory to scan for keywords">stackoverflow.com/questions/53762253/…</a> where the asker wants to search for a particular sequence in one line and print the next.</span>
<span class="comment-copy">@JackAidley Usually, in cases like these, I believe the pattern to <code>zip</code> the list with itself, offset by one is interesting. For instance, you could do : <code>for previous, current in zip(my_list, my_list[1:]):</code>. This prevents you from doing fancy tricks with <code>next</code>, and is quite readable and elegant.</span>
<span class="comment-copy">@VincentSavard This doesn't work when reading lines from a file, however.</span>
<span class="comment-copy">@JackAidley Why wouldn't it work? You can read the first two lines to create the first element, then it's just a matter of reading the file line by line.</span>
<span class="comment-copy">@VincentSavard I think Jack means that you cannot slice the iterator over lines you get from opening a file. <code>pairwise</code> from the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> docs</a> handles that.</span>
<span class="comment-copy">Nice catch on a subtle difference between versions.</span>
