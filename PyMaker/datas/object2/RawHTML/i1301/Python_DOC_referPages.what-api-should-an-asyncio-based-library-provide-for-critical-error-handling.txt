<div class="post-text" itemprop="text">
<p>I'm writing a library using <code>asyncio</code>. Under some circumstances it detects a ciritical error and cannot continue. It is not a bug, the problem has an external cause.</p>
<p>A regular library code would raise an exception. The program will terminate by default, but the caller also has a chance to catch the exception and perform a cleanup or some kind of reset. That is what I want, but unfortunately exceptions do not work that way in asyncio. More about that: 
<a href="https://docs.python.org/3/library/asyncio-dev.html#detect-never-retrieved-exceptions" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio-dev.html#detect-never-retrieved-exceptions</a></p>
<p>What is a reasonable way to notify the async library user about the problem? Probably some callback activated when the error occurs. The user may do necessary cleanup and then exit in the callback.</p>
<p>But what should be the default action? Cancel the current task? Stop the entire event loop? Calling <code>sys.exit</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>In general, there should be no need for error-specific callbacks. Asyncio fully supports propagating exceptions across <code>await</code> boundaries inside coroutines, as well as across calls like <code>run_until_complete</code> where sync and async code meet. When someone awaits your coroutine, you can just raise an exception in the usual way.</p>
<p>One pitfall is with the coroutines that run as "background tasks". When such coroutines fail, potentially rendering the library unusable, no one will get notified automatically. This is a known deficiency in asyncio (see <a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/" rel="nofollow noreferrer">here</a> for a detailed discussion), which is currently <a href="https://twitter.com/1st1/status/1028032168327565312" rel="nofollow noreferrer">being addressed</a>. In the meantime, you can achieve equivalent functionality with code like this:</p>
<pre><code>class Library:
    async def work_forever(self):
        loop = asyncio.get_event_loop()
        self._exit_future = loop.create_future()
        await self._exit_future

    async def stop_working(self):
        self._cleanup()
        self._exit_future.set_result(None)

    async def _failed(self):
        self._cleanup()
        self._exit_future.set_exception(YourExceptionType())

    def _cleanup(self):
        # cancel the worker tasks
        ...
</code></pre>
<p><code>work_forever</code> is analogous to <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Server.serve_forever" rel="nofollow noreferrer"><code>serve_forever</code></a>, a call that can be awaited by a <code>main()</code> coroutine, or even directly passed to <code>asyncio.run()</code>. In this design the library may detect an erroneous state and propagate the exception, or the main program (presumably through a separately spawned coroutine) can request it to exit cleanly.</p>
</div>
<span class="comment-copy">There is no need for specific callbacks, exceptions <i>are</i> propagated through each <code>await</code> and through entry points such as <code>run_until_complete</code>. The poster from the other question had a specific problem where the program wouldn't exit because he was using <code>run_in_executor</code>, and the program was waiting for the worker thread to finish before exiting. If you try to raise an exception from a coroutine you are actually awaiting, you'll notice that the exception is propagated just fine.</span>
<span class="comment-copy">@user4815162342 Sorry for providing a link to a different problem. I have changed the link. There is no single entry point. The library reacts to events in an asynchronous and possible complex way including setting timers, making calls to external functions and making decisions (finite state machine transitions) based on the returned value. If an exception is raised in some external function, the internal state becomes very probably incorrect. When it happens, the user should decide if he/she wants to exit the progam asap or to attempt a shutdown event or some kind of reset and recovery.</span>
<span class="comment-copy">@user4815162342 thank you for useful information. I find the proposed coroutine like server_forever a good idea. If you copy your comments to an answer, I will accept it.</span>
