<div class="post-text" itemprop="text">
<p>So I'm trying to improve this script, which returns a bool if an adjacent item is equal.</p>
<pre><code>from typing import List, Dict, TextIO, Tuple
def adjacent_match(L: List[str]) -&gt; bool:
"""Return True iff two adjacent items in L are equal.

&gt;&gt;&gt; adjacent_match(['A', 'B', 'B'])
True
&gt;&gt;&gt; adjacent_match(['A', 'B', 'A'])
False
"""

result = False

for index in range(len(L)):
    if len(L) == 0:
        return result
    elif index == 0:
        result = L[index] == L[index + 1]
    elif 0 &lt; index &lt; (len(L) - 1):
        result = (L[index] == L[index + 1] or L[index] == L[index - 1])
    elif index == (len(L) - 1):
        result = L[index] == L[index - 1]
    if result == True:
        return result

return result
</code></pre>
<p>So I feel like this script can be improved using a <code>while</code> loop, but hasn't work for me, my goal is to make it shorter without using modules, any advice?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just run through each element in the input array (using an index), but the last one to avoid an IndexError, and compare it with the next element:</p>
<pre class="lang-python prettyprint-override"><code>def adjacent_match(arr):
    for i in range(len(arr) - 1):
      if arr[i] == arr[i + 1]:
        return True
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> (which is in-built, you don't need to import) to check adjacency condition:</p>
<pre><code>def adjacent_match(L):
    for x, y in zip(L, L[1:]):
        if x == y:
            return True
    return False
</code></pre>
<p><strong>Sample runs</strong>:</p>
<pre><code>&gt;&gt;&gt; adjacent_match(['A', 'B', 'B'])
True
&gt;&gt;&gt; adjacent_match(['A', 'B', 'A'])
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>enumerate()</code> to iterate through the items in the list and also keep track of the item's position in the list.</p>
<p>For each item in the second and subsequent position, compare it to the previous item.</p>
<pre><code>def adjacent_match(L):
    for position, item in enumerate(L):
        if position == 0:
            continue
        if item == L[position-1]:
            return True

    return False
</code></pre>
</div>
<span class="comment-copy">sounds like a "Here you go - this code does what it does - rewrite it using a while" - homework ..</span>
<span class="comment-copy">@PatrickArtner it was homework and the code worked, but I'm asking because the length of the code bugs me, and I think a <code>while</code> loop might work better</span>
<span class="comment-copy">Would you mind pointing out where in my script I can get IndexError?</span>
<span class="comment-copy">@S.. just change len(arr) - 1 by len(arr) and you will get an IndexError (unless arr is an empty array, in that case the for loop will never execute). If you array has size 3 then the last element is at index 2, but the last iteration will try to access the array at index 3 (arr[i + 1])</span>
<span class="comment-copy">Do you think a <code>while</code> loop works too?</span>
<span class="comment-copy">when using one built in , use two: <code>return any(x==y for x,y in zip(L, L[1:]) )</code></span>
<span class="comment-copy">Would a while loop work better?</span>
