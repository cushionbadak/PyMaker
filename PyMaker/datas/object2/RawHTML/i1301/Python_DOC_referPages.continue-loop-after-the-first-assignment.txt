<div class="post-text" itemprop="text">
<p>How do I access the index itself for a list like the following?</p>
<pre><code>ints = [8, 23, 45, 12, 78]
</code></pre>
<p>When I loop through it using a <code>for</code> loop, how do I access the loop index, from 1 to 5 in this case?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using an additional state variable, such as an index variable (which you would normally use in languages such as C or PHP), is considered non-pythonic.</p>
<p>The better option is to use the built-in function <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="noreferrer" title="enumerate"><code>enumerate()</code></a>, available in both Python 2 and 3:</p>
<pre><code>for idx, val in enumerate(ints):
    print(idx, val)
</code></pre>
<p>Check out <a href="https://www.python.org/dev/peps/pep-0279/" rel="noreferrer" title="PEP 279">PEP 279</a> for more.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>Using a for loop, how do I access the loop index, from 1 to 5 in this case?</h1>
</blockquote>
<p>Use <code>enumerate</code> to get the index with the element as you iterate:</p>
<pre><code>for index, item in enumerate(items):
    print(index, item)
</code></pre>
<p>And note that Python's indexes start at zero, so you would get 0 to 4 with the above. If you want the count, 1 to 5, do this:</p>
<pre><code>for count, item in enumerate(items, start=1):
    print(count, item)
</code></pre>
<h1>Unidiomatic control flow</h1>
<p>What you are asking for is the Pythonic equivalent of the following, which is the algorithm most programmers of lower-level languages would use:</p>
<blockquote>
<pre><code>index = 0            # Python's indexing starts at zero
for item in items:   # Python's for loops are a "for each" loop 
    print(index, item)
    index += 1
</code></pre>
</blockquote>
<p>Or in languages that do not have a for-each loop:</p>
<blockquote>
<pre><code>index = 0
while index &lt; len(items):
    print(index, items[index])
    index += 1
</code></pre>
</blockquote>
<p>or sometimes more commonly (but unidiomatically) found in Python:</p>
<blockquote>
<pre><code>for index in range(len(items)):
    print(index, items[index])
</code></pre>
</blockquote>
<h1>Use the Enumerate Function</h1>
<p>Python's <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="noreferrer"><code>enumerate</code> function</a> reduces the visual clutter by hiding the accounting for the indexes, and encapsulating the iterable into another iterable (an <code>enumerate</code> object) that yields a two-item tuple of the index and the item that the original iterable would provide. That looks like this:</p>
<pre><code>for index, item in enumerate(items, start=0):   # default is zero
    print(index, item)
</code></pre>
<p>This code sample is fairly well the <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#index-item-2-enumerate" rel="noreferrer">canonical</a> example of the difference between code that is idiomatic of Python and code that is not. Idiomatic code is sophisticated (but not complicated) Python, written in the way that it was intended to be used. Idiomatic code is expected by the designers of the language, which means that usually this code is not just more readable, but also more efficient.</p>
<h2>Getting a count</h2>
<p>Even if you don't need indexes as you go, but you need a count of the iterations (sometimes desirable) you can start with <code>1</code> and the final number will be your count.</p>
<pre><code>for count, item in enumerate(items, start=1):   # default is zero
    print(item)

print('there were {0} items printed'.format(count))
</code></pre>
<p>The count seems to be more what you intend to ask for (as opposed to index) when you said you wanted from 1 to 5.</p>
<hr/>
<h2>Breaking it down - a step by step explanation</h2>
<p>To break these examples down, say we have a list of items that we want to iterate over with an index:</p>
<pre><code>items = ['a', 'b', 'c', 'd', 'e']
</code></pre>
<p>Now we pass this iterable to enumerate, creating an enumerate object:</p>
<pre><code>enumerate_object = enumerate(items) # the enumerate object
</code></pre>
<p>We can pull the first item out of this iterable that we would get in a loop with the <code>next</code> function:</p>
<pre><code>iteration = next(enumerate_object) # first iteration from enumerate
print(iteration)
</code></pre>
<p>And we see we get a tuple of <code>0</code>, the first index, and <code>'a'</code>, the first item:</p>
<pre><code>(0, 'a')
</code></pre>
<p>we can use what is referred to as "<a href="https://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences" rel="noreferrer">sequence unpacking</a>" to extract the elements from this two-tuple:</p>
<pre><code>index, item = iteration
#   0,  'a' = (0, 'a') # essentially this.
</code></pre>
<p>and when we inspect <code>index</code>, we find it refers to the first index, 0, and <code>item</code> refers to the first item, <code>'a'</code>.</p>
<pre><code>&gt;&gt;&gt; print(index)
0
&gt;&gt;&gt; print(item)
a
</code></pre>
<h1>Conclusion</h1>
<ul>
<li>Python indexes start at zero</li>
<li>To get these indexes from an iterable as you iterate over it, use the enumerate function</li>
<li>Using enumerate in the idiomatic way (along with tuple unpacking) creates code that is more readable and maintainable:</li>
</ul>
<p>So do this:</p>
<pre><code>for index, item in enumerate(items, start=0):   # Python indexes start at zero
    print(index, item)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's pretty simple to start it from <code>1</code> other than <code>0</code>:</p>
<pre><code>for index, item in enumerate(iterable, start=1):
   print index, item
</code></pre>
<h2>Note</h2>
<p>Important hint, though a little misleading since <code>index</code> will be a <code>tuple</code> <code>(idx, item)</code> here.
Good to go.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>for i in range(len(ints)):
   print i, ints[i]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As is the norm in Python there are several ways to do this. In all examples assume: <code>lst = [1, 2, 3, 4, 5]</code></p>
<h2>1. Using enumerate (<em>considered most idiomatic</em>)</h2>
<pre><code>for index, element in enumerate(lst):
    # do the things that need doing here
</code></pre>
<p>This is also the safest option in my opinion because the chance of going into infinite recursion has been eliminated. Both the item and its index are held in variables and there is no need to write any further code
to access the item.</p>
<h2>2. Creating a variable to hold the index (<em>using <code>for</code></em>)</h2>
<pre><code>for index in range(len(lst)):   # or xrange
    # you will have to write extra code to get the element
</code></pre>
<h2>3. Creating a variable to hold the index (<em>using <code>while</code></em>)</h2>
<pre><code>index = 0
while index &lt; len(lst):
    # you will have to write extra code to get the element
    index += 1  # escape infinite recursion
</code></pre>
<h2>4. There is always another way</h2>
<p>As explained before, there are other ways to do this that have not been explained here and they may even apply more in other situations. <em>e.g</em> using <code>itertools.chain</code> with for. It handles nested loops better than the other examples.</p>
</div>
<div class="post-text" itemprop="text">
<p>Old fashioned way:</p>
<pre><code>for ix in range(len(ints)):
    print ints[ix]
</code></pre>
<p>List comprehension:</p>
<pre><code>[ (ix, ints[ix]) for ix in range(len(ints))]

&gt;&gt;&gt; ints
[1, 2, 3, 4, 5]
&gt;&gt;&gt; for ix in range(len(ints)): print ints[ix]
... 
1
2
3
4
5
&gt;&gt;&gt; [ (ix, ints[ix]) for ix in range(len(ints))]
[(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]
&gt;&gt;&gt; lc = [ (ix, ints[ix]) for ix in range(len(ints))]
&gt;&gt;&gt; for tup in lc:
...     print tup
... 
(0, 1)
(1, 2)
(2, 3)
(3, 4)
(4, 5)
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The fastest way to access indexes of list within loop in <strong>Python 2.7</strong> is to use the <a href="https://docs.python.org/2/library/functions.html#range" rel="noreferrer">range method</a> for small lists and <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="noreferrer">enumerate method</a> for medium and huge size lists.</p>
<p>Please see <strong>different approaches</strong> which can be used to iterate over list and access index value and <strong>their performance metrics</strong> (which I suppose would be useful for you) in code samples below:</p>
<pre><code>from timeit import timeit

# Using range
def range_loop(iterable):
    for i in range(len(iterable)):
        1 + iterable[i]

# Using xrange
def xrange_loop(iterable):
    for i in xrange(len(iterable)):
        1 + iterable[i]

# Using enumerate
def enumerate_loop(iterable):
    for i, val in enumerate(iterable):
        1 + val

# Manual indexing
def manual_indexing_loop(iterable):
    index = 0
    for item in iterable:
        1 + item
        index += 1
</code></pre>
<p>See performance metrics for each method below:</p>
<pre><code>from timeit import timeit

def measure(l, number=10000):
print "Measure speed for list with %d items" % len(l)
print "xrange: ", timeit(lambda :xrange_loop(l), number=number)
print "range: ", timeit(lambda :range_loop(l), number=number)
print "enumerate: ", timeit(lambda :enumerate_loop(l), number=number)
print "manual_indexing: ", timeit(lambda :manual_indexing_loop(l), number=number)

measure(range(1000))
# Measure speed for list with 1000 items
# xrange:  0.758321046829
# range:  0.701184988022
# enumerate:  0.724966049194
# manual_indexing:  0.894635915756

measure(range(10000))
# Measure speed for list with 100000 items
# xrange:  81.4756360054
# range:  75.0172479153
# enumerate:  74.687623024
# manual_indexing:  91.6308541298

measure(range(10000000), number=100)
# Measure speed for list with 10000000 items
# xrange:  82.267786026
# range:  84.0493988991
# enumerate:  78.0344707966
# manual_indexing:  95.0491430759
</code></pre>
<p>As the result, using <code>range</code> method is the fastest one up to list with 1000 items. For list with size &gt; 10 000 items <code>enumerate</code> is the winner.</p>
<p>Adding some useful links below:</p>
<ul>
<li><p><em><a href="https://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x">What is the difference between range and xrange functions in Python 2.X?</a></em></p></li>
<li><p><em><a href="https://stackoverflow.com/questions/4852944/what-is-faster-for-loop-using-enumerate-or-for-loop-using-xrange-in-python">What is faster for loop using enumerate or for loop using xrange in Python?</a></em></p></li>
<li><p><em><a href="https://stackoverflow.com/questions/11990105/rangelenlist-or-enumeratelist">range(len(list)) or enumerate(list)?</a></em></p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I don't know if the following is pythonic or not, but it uses the Python function <code>enumerate</code> and prints the index and the value.</p>
<pre><code>int_list = [8, 23, 45, 12, 78]
for index, value in enumerate(int_list):
   print(index, value)
</code></pre>
<p>Output:</p>
<pre><code>0 8
1 23
2 45
3 12
4 78
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>ints = [9, 23, 45, 12, 78]
ints.extend([1,2,3,4,5,6,7,8])
for idx, val in enumerate(ints):
    print(idx,val)
</code></pre>
<p>This way you can extend a list. Extend means you can add multiple values at a time.</p>
<p>To append this list you have to write the code given below:</p>
<pre><code>ints = [9, 23, 45, 12, 78]
ints.append([1])
for idx, val in enumerate(ints):
    print(idx,val)
</code></pre>
<p>This way you can add a single value at a time. If you write <code>ints.append([1])</code> so this will create a sub list for this element.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, the indexes will be from 0 to 4. Programming languages start counting from 0; don't forget that or you will come across an index out of bounds exception. All you need in the for loop is a variable counting from 0 to 4 like so:</p>
<pre><code>for x in range(0, 5):
</code></pre>
<p>Keep in mind that I wrote 0 to 5 because the loop stops one number before the max. :)</p>
<p>To get the value of an index use</p>
<pre><code>list[index]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to this discussion: <a href="http://bytes.com/topic/python/answers/464012-objects-list-index">http://bytes.com/topic/python/answers/464012-objects-list-index</a></p>
<p>Loop counter iteration</p>
<p>The current idiom for looping over the indices makes use of the built-in 'range' function:</p>
<pre><code>for i in range(len(sequence)):
    # work with index i
</code></pre>
<p>Looping over both elements and indices can be achieved either by the old idiom or by using the new 'zip' built-in function[2]:</p>
<pre><code>for i in range(len(sequence)):
    e = sequence[i]
    # work with index i and element e
</code></pre>
<p>or</p>
<pre><code>for i, e in zip(range(len(sequence)), sequence):
    # work with index i and element e
</code></pre>
<p>via <a href="http://www.python.org/dev/peps/pep-0212/">http://www.python.org/dev/peps/pep-0212/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it with this code:</p>
<pre><code>ints = [8, 23, 45, 12, 78]
index = 0

for value in (ints):
    index +=1
    print index, value
</code></pre>
<p>Use this code if you need to reset the index value at the end of the loop:</p>
<pre><code>ints = [8, 23, 45, 12, 78]
index = 0

for value in (ints):
    index +=1
    print index, value
    if index &gt;= len(ints)-1:
        index = 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Best solution for this problem is use <strong>enumerate</strong> in-build python function. <br/>
<strong>enumerate</strong> return <strong>tuple</strong> <br/>
first value is <strong>index</strong> <br/>
second value is <strong>element</strong> of array at that index</p>
<pre><code>In [1]: ints = [8, 23, 45, 12, 78]

In [2]: for idx, val in enumerate(ints):
   ...:         print(idx, val)
   ...:     
(0, 8)
(1, 23)
(2, 45)
(3, 12)
(4, 78)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If there is no duplicate value in the list:</p>
<pre><code>for i in ints:
    indx = ints.index(i)
    print(i,indx)
</code></pre>
<p>Otherwise use <code>enumerate</code>. </p>
<pre><code>for counter, value in enumerate(ints):
    print(counter, value)
</code></pre>
<p>OR use below:</p>
<pre><code>for counter in range(len(ints)):
    print(counter, ints[counter])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Here's what you get when you're accessing index in <code>for</code> loops:</h1>
<blockquote>
<p><strong><code>for i in enumerate(items): print(i)</code></strong></p>
</blockquote>
<p><a href="https://i.stack.imgur.com/2Vke5.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/2Vke5.png"/></a></p>
<blockquote>
<p><strong><code>for i, val in enumerate(items): print(i, val)</code></strong></p>
</blockquote>
<p><a href="https://i.stack.imgur.com/BeRBP.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/BeRBP.png"/></a></p>
<blockquote>
<p><strong><code>for i, val in enumerate(items): print(i)</code></strong></p>
</blockquote>
<p><a href="https://i.stack.imgur.com/b1gka.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/b1gka.png"/></a></p>
<p>Hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also try this:</p>
<pre><code>data = ['itemA.ABC', 'itemB.defg', 'itemC.drug', 'itemD.ashok']
x = []
for (i, item) in enumerate(data):
      a = (i, str(item).split('.'))
      x.append(a)
for index, value in x:
     print(index, value)
</code></pre>
<p>The output is </p>
<pre><code>0 ['itemA', 'ABC']
1 ['itemB', 'defg']
2 ['itemC', 'drug']
3 ['itemD', 'ashok']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In you question, you write <em>"how do I access the loop index, from 1 to 5 in this case?"</em></p>
<p>However, the index for a list, runs from zero.  So, then we need to known if what you actually want is the index and item for each item in a list, or whether you really want numbers starting from 1.  Fortunately, in python it is easy to do either or both.</p>
<p>First, to clarify, the enumerate function, iteratively returns the index and corresponding item for each item in a list.</p>
<pre><code>alist = [ 1, 2, 3, 4, 5 ]

for n,a in enumerate(alist):
    print( "%d %d"%(n,a) )
</code></pre>
<p>The output for the above is then,</p>
<pre><code>0 1
1 2
2 3
3 4
4 5
</code></pre>
<p>Notice that the index runs from 0.  This kind of indexing is common among modern programming languages including python and c.</p>
<p>If you want your loop to span a part of the list, you can use the standard python syntax for a part of the list. For example, to loop from the second item in a list up to but not including the last item, you could use</p>
<pre><code>for n,a in enumerate(alist[1:-1]):
    print( "%d %d"%(n,a) )
</code></pre>
<p>Note that once again, the output index runs from 0,</p>
<pre><code>0 2
1 3
2 4
</code></pre>
<p>That brings us to the start=n switch for enumerate().  This simply offsets the index, you can equivalently simply add a number to the index inside the loop.</p>
<pre><code>for n,a in enumerate(alist,start=1):
    print( "%d %d"%(n,a) )
</code></pre>
<p>for which the output is</p>
<pre><code>1 1
2 2
3 3
4 4
5 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I were to iterate nums = [1,2,3,4,5]
I would do</p>
<pre><code>for i, num in enumerate(nums, start = 1):
    print(i, num)
</code></pre>
<p>Or get the length as l = len(nums)</p>
<pre><code>for i in range(1, l + 1):
    print(i, nums[i])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>index</code> method</p>
<pre><code>ints = [8, 23, 45, 12, 78]
inds = [ints.index(i) for i in ints]
</code></pre>
<p><strong>EDIT</strong>
Highlighted in the comment that this method doesn’t work if there are duplicates in <code>ints</code>, the method below should work for any values in <code>ints</code>:</p>
<pre><code>ints = [8, 8, 8, 23, 45, 12, 78]
inds = [tup[0] for tup in enumerate(ints)]
</code></pre>
<p>Or alternatively</p>
<pre><code>ints = [8, 8, 8, 23, 45, 12, 78]
inds = [tup for tup in enumerate(ints)]
</code></pre>
<p>if you want to get both the index and the value in <code>ints</code> as a list of tuples.</p>
<p>It uses the method of <code>enumerate</code> in the selected answer to this question, but with list comprehension, making it faster with less code.</p>
</div>
<div class="post-text" itemprop="text">
<p>To print tuple of (index, value) in list comprehension using a <code>for</code> loop:</p>
<pre><code>ints = [8, 23, 45, 12, 78]
print [(i,ints[i]) for i in range(len(ints))]
</code></pre>
<p>Output:</p>
<pre><code>[(0, 8), (1, 23), (2, 45), (3, 12), (4, 78)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It can also be done by using the <code>index()</code> method </p>
<pre><code>for i in ints:
   print(ints.index(i), i) 
</code></pre>
<p>Here the indexing starts from 0. But in case you need to start it from 1 just add 1 to the <code>index()</code> method as follows</p>
<pre><code>for i in int:
   print(int.index(i) + 1, i)    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You've received a number of answers explaining <code>enumerate</code>, but if you only need the index for accessing matching entries in two lists, there's another way that's cleaner and simpler in Python 3: <code>zip</code>.</p>
<p>For example, if you're using the index to pull out corresponding names for the numbers in your list, you could do it like this:</p>
<pre><code>ints = [8, 23, 45, 12, 78]
names = ["John", "Sue", "Johannes", "Patel", "Ian"]
for int, name = zip(ints, names):
    print("{} - {}".format(name, int)
</code></pre>
<p>That would produce</p>
<pre><code>8 - John
23 - Sue
45 - Johannes
12 - Patel
78 - Ian
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This serves the purpose well enough:</p>
<pre><code>list1 = [10, 'sumit', 43.21, 'kumar', '43', 'test', 3]
for x in list1:
    print('index:', list1.index(x), 'value:', x)
</code></pre>
</div>
<span class="comment-copy">Note that indexes in python start from 0, so the indexes for your example list are 0 to 4 not 1 to 5</span>
<span class="comment-copy">As Aaron points out below, use start=1 if you want to get 1-5 instead of 0-4.</span>
<span class="comment-copy">Hi Peter this one only returns 1 value for me. When I print both idx and val it is only looping through once - any ideas why?</span>
<span class="comment-copy">The question was about list indexes; since they start from 0 there is little point in starting from other number since the indexes would be wrong (yes, the OP said it wrong in the question as well). Otherwise, calling the variable that is tuple of <code>index, item</code> just <code>index</code> is very misleading, as you noted. Just use <code>for index, item in enumerate(ints)</code>.</span>
<span class="comment-copy">Better is to enclose index inside parenthesis pairs as (index), it will work on both the Python versions 2 and 3.</span>
<span class="comment-copy">@AnttiHaapala The reason, I presume, is that the question's expected output starts at index 1 instead 0</span>
<span class="comment-copy">That should probably be <code>xrange</code> for pre-3.0.</span>
<span class="comment-copy">No, unless the speed is needed one shouldn't optimize.</span>
<span class="comment-copy">One shouldn't <i>prematurely</i> optimize, though I agree in this case, due to having the same code work in 2.x and 3.x.</span>
<span class="comment-copy">Use enumerate instead</span>
<span class="comment-copy">For Python 2.3 above, use enumerate built-in function since it is more Pythonic.</span>
<span class="comment-copy">In point 2, access with <code>.index()</code> has a linear complexity, which means that your loop's complexity is now quadratic. Moreover, it doesn't work when your list contains several equal elements, since it always returns the index of the first one.</span>
<span class="comment-copy">@Charitoo I'm removing point 2 because it really should never be used</span>
<span class="comment-copy">can you have multiple enumerate at the same time? Say I want I and J to be indices such that J &gt; I, etc.? I suppose 3 would be better for that</span>
<span class="comment-copy">This is <b>not</b> wrong and is used in C/C++ and others. It's considered as non-pythonic, but can also be used in python. Like simple solutions that break it down to the source :+</span>
<span class="comment-copy">Where does it say it's wrong?</span>
<span class="comment-copy">Some python <i>extremists</i> would say, don't do this. But I said it only to indicate that there is more than one possible way</span>
<span class="comment-copy">"readability counts"  The speed difference in the small &lt;1000 range is insignificant.  It is 3% slower on an already small time metric.</span>
<span class="comment-copy">This won't work for iterating through generators. Just use enumerate().</span>
<span class="comment-copy">Nowadays, the current idiom is enumerate, not the range call.</span>
<span class="comment-copy">Note that the first option should not be used, since it only works correctly only when each item in the sequence is unique.</span>
<span class="comment-copy">Second example is incorrect.  range() in this context returns a single int, so the <code>for i, num</code> part will fail.  Secondly, you cannot access <code>nums[i]</code> if your range is from 1 to len+1.  the second line would fail anyway because <code>i</code> would be out of range.  The correct use of range in this case would be <code>for i in range(len(nums)):   print(nums[i])</code></span>
<span class="comment-copy">I think second is wrong. It should be <code>for i in range(1, len(nums), 1) : print (i, nums[i])</code></span>
<span class="comment-copy">Thanks for the correction. I fixed it.</span>
<span class="comment-copy">your solution works with: <code>ints = [8, 8, 8, 8, 8]</code> ?</span>
<span class="comment-copy">This is a duplicate of the <a href="https://stackoverflow.com/a/49999727/3479456">answer</a> by Sumit Kumar. Also, as stated there in a comment, this won't work if the list has duplicate elements</span>
<span class="comment-copy">You're making an assumption and thus answering a question that wasn't asked</span>
<span class="comment-copy">This will break down if there are repeated elements in the list as <code>index()</code> will search for the first occurrence of <code>x</code>, not mentioning the O( <b><i>n^2</i></b> ) time required to look up each element.</span>
<span class="comment-copy">your solution works with: list1 = [8, 8, 8, 8, 8] ?</span>
<span class="comment-copy">totally agreed that it won't work for duplicate elements in the list. afterall I'm also learning python.</span>
