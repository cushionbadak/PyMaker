<div class="post-text" itemprop="text">
<p>This is the relevant part of the code that I am having issues with. The player.x and player.y are getting "AttributeError: type object 'player' has no attribute 'x'" errors in the debug console. I have a seperate class called "player" and I want to get its x and y coordinate while it is moving around so that the enemy can move toward it. This is the player class beginning part that is also relevant:</p>
<pre><code>class player(object):
    def __init__(self, x, y, sprintMultiplier, fps):
        self.x = x
        self.y = y
        self.vel = 1/fps * 150


class enemy(object):
    def __init__(self, fps, difficulty):
      pass

    def draw(self, window):
        self.moveTowardsPlayer()
        window.blit(self.downStanding, (self.x, self.y))

    def moveTowardsPlayer(self):
        dx, dy = self.x - player.x, self.y - player.y
        dist = math.hypot(dx, dy)
        dx, dy = dx/dist, dy/dist
        self.x += dx * self.vel
        self.y += dy * self.vel
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Error in your code</strong></p>
<ul>
<li>You are declaring the x and y variables of the class player as private instance variables whereas in the enemy class you are accessing those x and y values as global variables.</li>
</ul>
<p><strong>So the work around the problem is.</strong></p>
<blockquote>
<p>You either declare the x and y values as global variables as below 
  and access those x and y variables as global ones in the constructor
  as given below.</p>
</blockquote>
<pre><code>class player(object):
     x = 0
     y = 0
     def __init__(self, x, y, sprintMultiplier, fps):
       player.x = x
       player.y = y
       self.vel = 1/fps * 150
</code></pre>
<blockquote>
<p>or Pass a player instance to the method moveTowardsPlayer() within the
  enemy class if you don't want to keep the x and y variables (of player
  class) as global/class variables. Code is given below.</p>
</blockquote>
<pre><code>def moveTowardsPlayer(self, player1):
    dx, dy = self.x - player1.x, self.y - player1.y
    dist = math.hypot(dx, dy)
    dx, dy = dx/dist, dy/dist
    self.x += dx * self.vel
    self.y += dy * self.vel
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on the code provided, it looks like you're mixing up a <em>class</em> with an <em>object</em> (instance) of that class.</p>
<p><code>player</code> here is a class, of which you <em>could</em> create objects. The <code>player</code> class itself has no <a href="https://docs.python.org/3/tutorial/classes.html#class-objects" rel="nofollow noreferrer">class attributes</a> (i.e., variables that are shared by <em>all</em> members of the class); it only has <em>instance</em> attributes (variables unique to individual instances of the class). So the expected use is that you create one or more instances (maybe global to your program) and operate on those.</p>
<p>Thus, I think what you need is threefold:</p>
<ol>
<li>To create a <code>player</code> object like so: <code>the_player = player(starting_x, starting_y, multiplier, starting_fps)</code></li>
<li><p>Add a parameter for that <code>player</code> to your <code>enemy</code>'s initializer, like so:</p>
<pre><code>class enemy(object):
    def __init__(self, player_to_track, fps, difficulty):
        self.player_to_track = player_to_track
</code></pre></li>
<li>Pass <code>the_player</code> to the <code>enemy</code> object you create.</li>
</ol>
<p>(For what it's worth, many people adhere to a convention of making class names capitalized, and instances lowercase. This helps make it the distinction obvious when reading the codeâ€”you get something like <code>my_player = Player( . . . )</code>, and if you ever write <code>Player.foo</code>, it helps call out that you're talking about a <em>class</em> attribute, not a member variable.)</p>
</div>
<span class="comment-copy">Silly argument, but may it be because of the ident of the <b>init</b> in the player class, it looks like it needs one more push :)  It's the person below me, with the right answer, always have your ClassNames camelcased, you are referencing the class not the instance in the movetowards def.</span>
<span class="comment-copy">The <code>class player</code> doesn't have <code>x</code> or <code>y</code> attribute. Only instances of the class have.</span>
<span class="comment-copy">Show us the full error message, and also show us how you create a player instance.</span>
<span class="comment-copy">Just a sidenote: Once you're familiar with trigonometry, check out vectors as well, since they'll make your life easier. Here's a short <a href="https://stackoverflow.com/a/52740357/6220679">example</a> with an object that moves towards the mouse.</span>
<span class="comment-copy">I have tried to add what you suggested, however I get an error stating that player1 is not defined. I have a main.py file where my mainloop is and where I use my Player class from character.py. I renamed all the parts where I had "player" to "player1" and changed the name of the class to "Player" instead of it all being lower case. Is there something obvious that I am missing out?</span>
<span class="comment-copy">Use that player class object to pass into the method moveTowardsPlayer() ex. if you created the player as player1 = player(4, 5, 10, 20), then you can call the method as moveTowardsPlayer(player1)</span>
<span class="comment-copy">If you are using the individual files for each classes then make sure that you import each files properly where you use them.</span>
<span class="comment-copy">Thanks! Adding the (player1) in the brackets worked, however the enemy only moves towards that coordinate where the player spawns, and then doesn't follow him around. How would I update the coordinates of the player so that the enemy follows it?</span>
<span class="comment-copy">You can use the coordinates of the player to set the respective coordinates of the enemy in each move. You need to review the algorithm how the enemy is supposed to move towards player based on its velocity and power values.</span>
