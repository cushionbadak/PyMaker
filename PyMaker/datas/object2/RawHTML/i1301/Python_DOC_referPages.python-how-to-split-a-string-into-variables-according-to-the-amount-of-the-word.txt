<div class="post-text" itemprop="text">
<p>I have a string like:</p>
<pre><code>text = The Black Cat is running 
</code></pre>
<p>and I want to split the text into words and create a variable for each word without setting it manually.
some thing like this:</p>
<pre><code>one="The"
two="black"
three="Cat"
four="is"
five="running"
</code></pre>
<p>but if there is a different string with more or fewer words it will create an amount of variables according to the amount of words; for example, if there are seven words it will create seven variables.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can have a dictionary and create the variables on the fly for each value in <code>text</code>:</p>
<p>So, you don't have to worry about larger strings. It will create <code>n</code> number of variables depending upon its length.</p>
<pre><code>In [2355]: d = {}
In [2357]: for c,i in enumerate(text.split()):
      ...:     d['var{}'.format(c)] = i
      ...:     
      ...:     

In [2358]: d
Out[2358]: 
{'var0': 'The',
 'var1': 'Black',
 'var2': 'Cat',
 'var3': 'is',
 'var4': 'running'}
</code></pre>
<p>Then, you can access the dictionary like below:</p>
<pre><code>In [2362]: for key in d.keys():
      ...:     print(key,d[key])
      ...:     
('var4', 'running')
('var1', 'Black')
('var0', 'The')
('var3', 'is')
('var2', 'Cat')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just unpack the values, for example:</p>
<pre><code>text = "The Black Cat is running"

one, two, three, four, five, *_ = l = text.split()

for n in l:
  print(n)
</code></pre>
<p>Notice the usage of <code>*_</code> in case the resulting split has more words than desired. In case it has less it will always fail.</p>
<p>Here you have the <a href="https://repl.it/repls/CoarseArtisticTests" rel="nofollow noreferrer">live example</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The best way to deal this problem would be to use <code>list</code> of <code>dict</code> instead. But for some reasons, if you want to create variables as you mentioned then this might help</p>
<pre><code>text = "The Black Cat is running "
text=text.strip().split(" ")

for i,j in enumerate(text,1):
    locals()['var'+str(i)]=j # create variable as var1='The' and so on in local scope
</code></pre>
<p>Trying accessing the variables</p>
<pre><code>print(var1,var2,var3,var4,var5)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>('The', 'Black', 'Cat', 'is', 'running')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I read this as two different questions.</p>
<h2>1. Split each word in the string into a separate variable</h2>
<p>You can do this very simply with the <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow noreferrer"><code>.split()</code></a> method for strings. As answered above</p>
<pre><code>text = "The Black Cat is running"
one, two, three, four, five, *_ = l = text.split()
</code></pre>
<h2>2. Count the letters of each word</h2>
<p>One way that you could approach this is to first sort the words by the number of letters they have, and then second to assign them to proper variables. For instance</p>
<pre><code>def count_letters_in_each_word(text):
    word_counts = {len(word): word for word in text.split(' ')}
    max_length = max(word_counts.keys())
    return [word_counts.get(cnt) for cnt in range(1, max_length+1)]

text = 'The Black cat is flopping around'
one, two, three, four, five, six, seven, eight = count_letters_in_each_word(text)
print(one)
&gt; None
print(five)
&gt; "Black"
print(seven)
&gt; None
print(eight)
&gt; "flopping"

# or, if you only want short words
one, two, *_ = count_letters_in_each_word(text)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>suppose we have this string</p>
<pre><code>str = "The Black Cat is running"
</code></pre>
<p>then we need to split it to get all array elements of the string as:</p>
<pre><code>str_arr = str.split(" ") 

str_arr = ['The', 'Black', 'Cat', 'is', 'running']
</code></pre>
<p>To persist the dynamic variable's value, we can use Hash:</p>
<pre><code> mydict = {}
</code></pre>
<p>And then we need to iterate the array and assign the element to the unique variable as below:</p>
<pre><code>for index in range(len(str_arr)):
  mydict["var_%d" %index] = str_arr[index]
  print "var_%d : " %index + str_arr[index]
</code></pre>
<p>which will give the output as:</p>
<pre><code>var_0 : The

var_1 : Black

var_2 : Cat

var_3 : is

var_4 : running
</code></pre>
<p>And to print Hash, we can write:</p>
<pre><code>print mydict
{'var_0': 'The', 'var_1': 'Black', 'var_2': 'Cat', 'var_3': 'is', 'var_4': 'running'}
</code></pre>
<p>Hope, this will provide some hint to write to your next logic..</p>
</div>
<span class="comment-copy">Why not just split on ' ' to create a list? Is there a reason you want these as individual variables, and not a list?</span>
<span class="comment-copy">@someone If the answer helped, please accept it. This lets the community know that you are not looking for anymore answers.</span>
<span class="comment-copy">This will fail over as <code>cnt</code> is not defined in the <code>range</code> condition</span>
<span class="comment-copy">Fixed that typo, thanks!</span>
<span class="comment-copy">Still, why would you count the letters if it is not required? I dont see second section of the answer of any use. No where OP mentioned to get the length. OP just gave an example of naming of variables and it can be anything,e.g, x,y,z and so on</span>
<span class="comment-copy">Do you think <code>var_0</code> will be persisted after the <code>for</code> loop? If not, then how does it solve the problem?</span>
<span class="comment-copy">@mad_ : yes definately var_0 won't be accessible. I was just showing to store the dynamic value into dynamic variable. To make it accessible: we can define mydict = {} and then in the loop we can wrtie == mydict["var_%d" %index] = str_arr[index]</span>
