<div class="post-text" itemprop="text">
<p>There is a simple class where I want to store some functions statically in a dictionary using different ways:</p>
<pre><code>import os, sys
class ClassTest():
    testFunc = {}
    def registerClassFunc(self,funcName):
        ClassTest.testFunc[funcName] = eval(funcName)
    @classmethod
    def registerClassFuncOnClass(cls,funcName):
        cls.testFunc[funcName] = eval(funcName)
    @staticmethod
    def registerClassFuncFromStatic(funcName):
        ClassTest.testFunc[funcName] = eval(funcName)
</code></pre>
<p>Some example methods:</p>
<pre><code>def user_func():
    print("I run therefore I am self-consistent")
def user_func2():
    print("I am read therefore I am interpreted")
def user_func3():
    print("I am registered through a meta function therefore I am not recognized")
def user_func4():
    print("I am registered through an instance function therefore I am not recognized")
def user_func5():
    print("I am registered through a static function therefore I am not recognized")
</code></pre>
<p>And a little test:</p>
<pre><code>if __name__ == "__main__":
    a = ClassTest()
    a.testFunc["user_func"] = user_func
    a.testFunc["user_func"]()
    a.testFunc["user_func2"] = eval("user_func2")
    a.testFunc["user_func2"]()

    ClassTest.testFunc["user_func"] = user_func
    ClassTest.testFunc["user_func"]()
    ClassTest.testFunc["user_func2"] = eval("user_func2")
    ClassTest.testFunc["user_func2"]()

    a.registerClassFunc("user_func5")  # does not work on import
    a.testFunc["user_func5"]()
    ClassTest.registerClassFuncFromStatic("user_func3") # does not work on import
    ClassTest.testFunc["user_func3"]()
    ClassTest.registerClassFuncOnClass("user_func4") # does not work on import
    ClassTest.testFunc["user_func4"]()
</code></pre>
<p>All this works <strong>provided</strong> all these elements are in the same file. As soon as the functionality is split up in 2 files and a main file:</p>
<pre><code>from ClassTest import ClassTest
from UserFunctions import user_func,user_func2, user_func3, user_func4, user_func5
if __name__ == "__main__":
    a = ClassTest()
    a.testFunc["user_func"] = user_func
    ...
</code></pre>
<p>Only the first two keep working (setting the function directly), the others - using a function to do the same thing - give a <code>NameError</code> on all the <code>eval</code> calls. For instance: <code>NameError: name 'user_func5' is not defined</code>.</p>
<p>What is the logic here for the loss of scope when using the methods versus directly setting the functions? And can I get it to work using imports from other packages so I can place any function in the class with a method rather than directly?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://repl.it/@telamonian/ClassTestrefactoroutevalrefactorininspecthacks" rel="nofollow noreferrer">There's a live version of fix #1 from this answer online that you can try out for yourself</a></p>
<h1>The problem</h1>
<p>You're right that the reason this doesn't work is due to scoping issues. You can figure out what's going on by scrutinizing the <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer">docs for <code>eval</code></a>:</p>
<blockquote>
<p>eval(expression, globals=None, locals=None)</p>
<p>...If both dictionaries [ie globals and locals] are omitted, the expression is executed in the environment where eval() is called.</p>
</blockquote>
<p>Thus, it is reasonable to assume that the issue you're having is down to the contents of <code>globals</code> and <code>locals</code> in the context (ie within the definition (and possibly separate module) of <code>ClassTest</code>) in which <code>eval</code> is getting called. Since the context in which <code>eval</code> is getting called is not, in general, the context in which you have defined and/or imported <code>user_func, user_func2....</code>, these functions are undefined as far as <code>eval</code> is concerned. This line of thinking is backed up by the <a href="https://docs.python.org/3/library/functions.html#globals" rel="nofollow noreferrer">docs for <code>globals</code></a>:</p>
<blockquote>
<p>globals()</p>
<p>...This is always the dictionary of the current module (inside a function or method, this is the module where it is defined, not the module from which it is called).</p>
</blockquote>
<h1>The fix</h1>
<p>You have a few different options for how you can go about fixing this code. All of them are going to involve passing <code>locals</code> from the context in which you call, eg, <code>ClassTest.registerClassFunc</code> to the context in which that method is defined. Additionally, you should take the opportunity to factor out the use of <code>eval</code> from your code (its use is considered bad practice, it's a <a href="https://stackoverflow.com/a/37081082/425458">massive security hole</a>, yadda yadda yadda). Given that <code>locals</code> is the dict of a scope in which <code>user_func</code> is defined, you can always just do:</p>
<pre><code>locals['user_func'] 
</code></pre>
<p>instead of: </p>
<pre><code>eval('user_func')
</code></pre>
<h2>fix #1</h2>
<p><a href="https://repl.it/@telamonian/ClassTestrefactoroutevalrefactorininspecthacks" rel="nofollow noreferrer">Link to live version of this fix</a></p>
<p>This'll be the easiest fix to implement, since it only requires a few tweaks to the definitions of the methods of <code>ClassTest</code> (and no changes to any method signatures). It relies on the fact that it is possible to use the <code>inspect</code> package within a function to directly grab the <code>locals</code> of the calling context:</p>
<pre><code>import inspect

def dictsGet(s, *ds):
    for d in ds:
        if s in d:
            return d[s]
    # if s is not found in any of the dicts d, treat it as an undefined symbol
    raise NameError("name %s is not defined" % s)

class ClassTest():
    testFunc = {}
    def registerClassFunc(self, funcName):
        _frame = inspect.currentframe()
        try:
            _locals = _frame.f_back.f_locals
        finally:
            del _frame

        ClassTest.testFunc[funcName] = dictsGet(funcName, _locals, locals(), globals())

    @classmethod
    def registerClassFuncOnClass(cls, funcName):
        _frame = inspect.currentframe()
        try:
            _locals = _frame.f_back.f_locals
        finally:
            del _frame

        cls.testFunc[funcName] = dictsGet(funcName, _locals, locals(), globals())

    @staticmethod
    def registerClassFuncFromStatic(funcName):
        _frame = inspect.currentframe()
        try:
            _locals = _frame.f_back.f_locals
        finally:
            del _frame

        ClassTest.testFunc[funcName] = dictsGet(funcName, _locals, locals(), globals())
</code></pre>
<p>If you use the above given definition of <code>ClassTest</code>, the import test you cooked up will now function as expected.</p>
<h3>Pros</h3>
<ul>
<li><p>Provides exactly the originally intended functionality.</p></li>
<li><p>Involves no changes to function signatures.</p></li>
</ul>
<h3>Cons</h3>
<ul>
<li><p>Calling <code>inspect.currentframe()</code> can cause a dip in performance, so you may not be able to use this fix if you're planning on calling the methods of <code>ClassTest</code> a million times a second.</p></li>
<li><p><code>inspect.currentframe()</code> is only guaranteed to work on CPython. <a href="https://stackoverflow.com/questions/9938980/inspect-currentframe-may-not-work-under-some-implementations">Mileage may vary when running this code with other implementations of Python</a>.</p></li>
</ul>
<h2>fix #2</h2>
<p>Fix #2 is basically the same as fix #1, except that in this version you explicitly pass <code>locals</code> into the methods of <code>ClassTest</code> at the point of call. For example, under this fix the definition of <code>ClassTest.registerClassFunc</code> would be:</p>
<pre><code>def registerClassFunc(self, funcName, _locals):
        ClassTest.testFunc[funcName] = dictsGet(funcName, _locals, locals(), globals())
</code></pre>
<p>and you would call it in your code like this:</p>
<pre><code>a = ClassTest()
a.registerClassFunc("user_func5", locals())
</code></pre>
<h3>Pros</h3>
<ul>
<li>Doesn't rely on <code>inspect.currentframe()</code>, and so is probably more performant/portable than fix #1.</li>
</ul>
<h3>Cons</h3>
<ul>
<li><p>You have to modify method signatures, so you'll also have to change any existing code that uses those methods.</p></li>
<li><p>You'll have to add the <code>locals()</code> boilerplate to every invocation of every <code>ClassTest</code> method from here on.</p></li>
</ul>
</div>
<span class="comment-copy">Thanks for making it so clear</span>
