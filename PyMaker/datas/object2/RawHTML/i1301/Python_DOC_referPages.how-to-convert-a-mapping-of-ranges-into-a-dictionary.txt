<div class="post-text" itemprop="text">
<p>How can this be converted into a dictionary?</p>
<pre><code>if grade&gt;=96.5:return 5.83
elif grade&gt;=92.5:return 5.5
elif grade&gt;=89.5:return 5.16
elif grade&gt;=86.5:return 4.83
elif grade&gt;=82.5:return 4.5
elif grade&gt;=79.5:return 4.16
elif grade&gt;=76.5:return 3.83
elif grade&gt;=72.5:return 3.5
elif grade&gt;=69.5:return 3.16
elif grade&gt;=68.5:return 2.83
elif grade&gt;=64.5:return 2.5
else:return 0
</code></pre>
<p>I know how to make basic dictionaries, however, I am not sure whether it would look something like this:</p>
<pre><code>grade_checker = {
    grade&gt;96.5:5.83
}
</code></pre>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>The short answer is that you should <strong>not</strong> convert this to a dictionary. This is best suited as a function, and it appears you are just missing your function definition, as I see you are using <code>return</code> in your code. Dictionaries are constructed from key-value pairs, and since your conditions involve <code>&gt;=</code> evaluations, a dictionary is not appropriate. See the function implementation below:</p>
<pre><code>def grade_checker(grade):

    if grade&gt;=96.5: return 5.83
    elif grade&gt;=92.5: return 5.5
    elif grade&gt;=89.5: return 5.16
    elif grade&gt;=86.5: return 4.83
    elif grade&gt;=82.5: return 4.5
    elif grade&gt;=79.5: return 4.16
    elif grade&gt;=76.5: return 3.83
    elif grade&gt;=72.5: return 3.5
    elif grade&gt;=69.5: return 3.16
    elif grade&gt;=68.5: return 2.83
    elif grade&gt;=64.5: return 2.5
    else: return 0

grade_checker(75)
grade_checker(62)
grade_checker(94)
</code></pre>
<p>Returns:</p>
<pre><code>3.5
0
5.5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without a dict, you could solve the problem like this: </p>
<pre><code>import numpy as np
GRADES = np.array(
    [[96.5 , 92.5 , 89.5 , 86.5 , 82.5 , 79.5 , 76.5 , 72.5 , 69.5 , 68.5 , 64.5 ],
     [ 5.83,  5.5 ,  5.16,  4.83,  4.5 ,  4.16,  3.83,  3.5 ,  3.16, 2.83,  2.5 ]])
def get_grade(grade):
    try:
        return GRADES[1][grade &gt; [GRADES[0]][0]
    except:
        return 0
</code></pre>
<p>This is preferable over a dictionary because builtin dictionaries make a guarantee of orderedness (i.e., that they will iterate in the order that keys/values were inserted) only for &gt;= Python 3.6. Being able to run code over more Python versions is preferable to depending on a specific version detail.</p>
</div>
<div class="post-text" itemprop="text">
<p>You <em>can</em> use a dictionary for holding the grading information, but it does not really provide any benefit as you can not use the fast dictionary lookup with those ranges. Instead, I'd suggest using a sorted list of <code>(points, grade)</code> pairs and then using <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code></a> to binary-search the matching score in O(logn).</p>
<pre><code>&gt;&gt;&gt; import bisect
&gt;&gt;&gt; grade_ranges = [(0, 0), (64.5, 2.5), (68.5, 2.83), (69.5, 3.16), 
...                 (72.5, 3.5), (76.5, 3.83), (79.5, 4.16), (82.5, 4.5), 
...                 (86.5, 4.83), (89.5, 5.16), (92.5, 5.5), (96.5, 5.83)]
...
&gt;&gt;&gt; points, grade = zip(*grade_ranges)
&gt;&gt;&gt; grade[bisect.bisect(points, 96.5)-1]
5.83
&gt;&gt;&gt; grade[bisect.bisect(points, 73)-1]
3.5
&gt;&gt;&gt; grade[bisect.bisect(points, 30)-1]
0
</code></pre>
<p>Unzipping the <code>grade_ranges</code> to <code>points</code> and <code>scores</code> is optional here, but IMHO it's a bit cleaner that way. If you don't unzip, you will have to pass a tuple to <code>bisect</code>, e.g. <code>bisect(grade_ranges, (55,))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Dicts are especially useful if you want to store key-value pairs and want to be able to retrieve an arbitrary entry really fast. As the other answers show, you only need to go through the sequence of elements and use the value of the first one that matches. So the most straight forward (and probably most efficient) strategy is to use a sequence data type. Here's how that looks like in code:</p>
<pre><code>pairs = (
    (96.5, 5.83),
    (92.5, 5.5),
    (89.5, 5.16),
    (86.5, 4.83),
    (82.5, 4.5),
    (79.5, 4.16),
    (76.5, 3.83),
    (72.5, 3.5),
    (69.5, 3.16),
    (68.5, 2.83),
    (64.5, 2.5),
)

def get_grade(g):
    for grade, value in pairs:
            if g &gt;= grade:
                return value
    return 0
</code></pre>
<p>Dicts are great, but if you don't need their powers, use something simpler.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another option is to use <a href="https://github.com/albertmenglongli/range-key-dict" rel="nofollow noreferrer">range-key-dict</a>:</p>
<pre><code>from range_key_dict import RangeKeyDict

range_key_dict = RangeKeyDict({
    (96.5, 100): 5.83,
    (92.5, 96.5): 5.5,
    (89.5, 92.5): 5.16,
    (86.5, 89.5): 4.83,
    (82.5, 86.5): 4.5,
    (79.5, 82.5): 4.16,
    (76.5, 79.5): 3.83,
    (72.5, 76.5): 3.5,
    (69.5, 72.5): 3.16,
    (68.5, 69.5): 2.83,
    (64.5, 68.5): 2.5,
    (0, 64.5): 0
})

assert range_key_dict[96.5] == 5.83
assert range_key_dict[96.4] == 5.5
assert range_key_dict[96.49] == 5.5
</code></pre>
<p>You can install this Python package with <code>pip install range-key-dict</code>. </p>
<p>You would also need to examine the source code for the complexity, since this won't maintain O(1) hashing like regular dictionaries. </p>
<p>It might be easier and efficient to just use regular if statements. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you can use a 3rd party library, you can use Pandas via <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.cut.html" rel="nofollow noreferrer"><code>pd.cut</code></a>. This will be especially efficient if you have a large number of input grades to categorise.</p>
<pre><code>import pandas as pd

grade_checker = {96.5: 5.83,
                 ...,
                 64.5: 2.5}

keys, values = zip(*sorted(grade_checker.items()))
keys += (float('inf'),)  # need to add upper boundary for pd.cut input

grade = 65.5
res = pd.cut([grade], keys, labels=values).astype(float)[0]  # 2.5
</code></pre>
<p>See related: <a href="https://stackoverflow.com/questions/49382207/how-to-map-numeric-data-into-categories-bins-in-pandas-dataframe">How to map numeric data into categories / bins in Pandas dataframe</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This would be one way, if you really need to use a dictionary; taking dictionary keys as the condition checking values and dictionary values as the values to be returned.</p>
<pre><code>grade_checker = {
    96.5: 5.83,
    92.5: 5.5,
    89.5: 5.16,
    86.5: 4.83,
    82.5: 4.5,
    79.5: 4.16,
    76.5: 3.83,
    72.5: 3.5,
    69.5: 3.16,
    68.5: 2.83,
    64.5: 2.5
}

def check_grade(grade):
    for k in grade_checker:
        if grade &gt;= k:
            return grade_checker[k]
    return 0
</code></pre>
<p><strong>Check</strong>:</p>
<pre><code>&gt;&gt;&gt; check_grade(45.5)
0
&gt;&gt;&gt; check_grade(65.5)
2.5
&gt;&gt;&gt; check_grade(95)
5.5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are using Python before 3.6, you can use <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> (including Python 2.7), otherwise <code>dict</code> objects are natively insertion-sorted (<a href="https://stackoverflow.com/a/39980744/4541045">see here for more</a>)!</p>
<p>With that, you can simply iterate over your <code>dict</code> and return the first range match.</p>
<pre><code># python 3.6+
grade_table = {
    96.5: 5.83,
    ...
    64.5: 2.5,
}

# pre-3.6
from collections import OrderedDict
grade_table = OrderedDict((  # this is a tuple of tuples
    (96.5, 5.83),
    ...
    (64.5, 2.5),
))

def fn(student_grade):
    for grade, value in grade_table.iteritems():
        if student_grade &gt;= grade:
            return value

    return 0  # default
</code></pre>
<p>Note if you expect your table to change, it probably makes sense to test if your dict is in descending order or always accept an iterable of iterables and then sort 'em (I use a tuple of tuples above, but anything of the same form should work and be easy to sort) Otherwise it will return incorrect results.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not possible to convert this logic into a dictionary. Dictionaries are key value pairs, so there's no way you can do the "greater than" check just by way of a lookup.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not a maths person but thought that interpolation might, maybe, work for this? </p>
<pre><code>    from numpy import interp

    ak = [k for k in gc.keys()]
    av = [v for v in gc.values()]

    # np.interp needs values from lowest to highest
    ak.reverse()
    av.reverse()

    interp(79, ak, av)
    &gt;&gt;&gt; 4.105

    interp(96, ak, av)
    &gt;&gt;&gt; 5.78875

    interp(64, ak, av)
    &gt;&gt;&gt; 2.5
</code></pre>
<p>You'd need to pad-up to 100 and pad-down because it is <em>interpolation</em> so your data points of interest need to be <em>within</em> sample'able scope.</p>
</div>
<span class="comment-copy">Not sure why you would want a dictionary here, a function is still best suited for this.</span>
<span class="comment-copy">This is not valid python syntax, return should only be used inside of functions. If this is a part of a function, you should include all of your code.</span>
<span class="comment-copy">What version of Python are you using?</span>
<span class="comment-copy">I agree that dicts aren't the right way to go here, but writing a function like you did seems very verbose and repetitive. Grade-Value pairs should be stored in a sequence and the function should loop over these pairs until it finds the first match.</span>
<span class="comment-copy">Completely agree with you, just wanted to provide the OP with a solution w/ minimal changes to their original code (seeing as they are likely a beginner).</span>
<span class="comment-copy">Are the end points inclusive, exclusive, or does it depend on the internal dictionary order?</span>
<span class="comment-copy">@cpburnz The end points are exclusive, just like the <code>range()</code> function.</span>
<span class="comment-copy">Only works with newer versions of Python respecting insertion-order. For other versions, you could just use a list of tuples instead of a dict, or iterate the reverse-sorted keys, or use a <code>collections.OrderedDict</code>.</span>
<span class="comment-copy">there is a way but it will still be ugly. you could for example do <code>d = {(0, 10): 0}</code> and then do <code>next(v for k, v in d.items() if value in range(*k))</code></span>
<span class="comment-copy">the dictionary really just becomes a sequence of key-value pairs in that case, in which case you could store it as a sequence of objects which encapsulates the lower bound, upper bound and the mapped outcome. I actually think that's less secure because you'd need to prove that the bounds don't overlap - with the original if, then, else sequence overlapping bounds are impossible.</span>
