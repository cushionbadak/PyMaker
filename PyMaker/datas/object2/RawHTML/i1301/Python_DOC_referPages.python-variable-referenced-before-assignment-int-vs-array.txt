<div class="post-text" itemprop="text">
<p>When I compile this snippet with func1 I get an error about referencing output before assignment, which seems reasonable to me:</p>
<pre><code>def func1():
    output += 1

output = 0
func1()
print(output)    
</code></pre>
<p>But when I compile this snippet with func2 I don't get an error, which seems unreasonable to me.</p>
<pre><code>def func2():
    output.append(1)

output = []
func2()
print(output)
</code></pre>
<p>Thoughts? Thanks in advance and sorry if this is a duplicate. I didn't didn't see this particular question addressed in similarly titled posts when researching.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem here is in how Python binds <em>names</em> to <em>variables</em>.</p>
<p>Any time you write an assignment in a function (something like <code>a = b</code> or <code>a += b</code>), Python will bind that name <strong>locally</strong> for the <strong>entire</strong> function scope.  This means that any variables with that name declared outside the function are <strong>ignored</strong>.</p>
<p>For example:</p>
<pre><code>a = 1 # This variable is ignored.
def foo():
    print(a) # "a" hasn't been defined yet!
    a = 2 # This causes "a" to bind to a local variable.
</code></pre>
<p>This will produce an <code>UnboundLocalError</code> at the print statement because Python sees that <code>a</code> is assigned to later in the function, and binds it locally, ignoring the variable you defined outside the function.  Since <code>a</code> is only defined <em>after</em> the print statement, you get an error.</p>
<p>This can be very confusing because removing the <code>a += 2</code> line will cause the print statement to work as expected!</p>
<p>The solution is to explicitly tell Python <strong>not</strong> to bind the name locally.  This can be done with the <code>global</code> and <code>nonlocal</code> keywords, e.g.:</p>
<pre><code>a = 1
def foo():
    nonlocal a # or: global a
    print(a)
    a += 2
</code></pre>
<p><code>global</code> tells Python to bind the name in the module's global scope, while <code>nonlocal</code> (introduced in Python 3) tells Python to bind to the <strong>enclosing</strong> scope (for example, if you define a function inside a function).</p>
<p>There's a nice explanation of this (with examples) in the <a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow noreferrer">documentation</a> :-)</p>
<hr/>
<p>Once we understand these rules, we can see that your first example fails because you're trying to increment a variable that doesn't yet exist.  <code>output += 1</code> is equivalent to <code>output = output + 1</code>, which triggers local name binding.</p>
<p>On the other hand, your second example doesn't trigger the error because you're not assigning to <code>output</code> (you're <em>mutating</em> it instead), so it will bind to the global variable that you defined.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, global variables when called in functions don't work all the same. </p>
<p>The data types (on a high level) in Python can be categorised into "mutable" and "immutable".</p>
<ul>
<li>If you have have mutable datatypes like <code>list</code> then they can be both : accessed <strong>and</strong> modified in the function without referring them with a <code>global</code> keyword.</li>
</ul>
<p>Eg:</p>
<pre><code>l = []
def foo():
    l.append(1) #works

foo()
print(l) # prints [1], so foo() changed the global list l.
</code></pre>
<ul>
<li>But if you have immutable types like <code>int</code> or <code>str</code> then they can be accessed <strong>but not</strong> modified.</li>
</ul>
<p>Eg: </p>
<pre><code>someString = "abcdef"

def foo():
    print(someString[2]) # prints "c"
    someString += "l"    # error as someString cannot be modified unless you include it in the function foo() with the global keyword as shown below.
</code></pre>
<ul>
<li>But to modify a global variable of immutable types like <code>str</code> you have to include it first with the <code>global</code> keyword then you're free to use it like any local variable. </li>
</ul>
<p>Eg:</p>
<pre><code>someString = "abcdef"

def foo():
    global someString    # This now includes someString in foo() scope and is allowed to be modified.

    print(someString[2]) # prints "c"

    someString += "l"    # works as expected

    print(someString) # prints "abcdefl"
</code></pre>
<ul>
<li>Thanks to <a href="https://stackoverflow.com/users/235698/mark-tolonen">Mark Tolonen</a> for this valuable point.  At the end, you cannot reassign a global variable without the global keyword, irrespective of whether the variable is mutable or immutable. </li>
</ul>
<p>Eg:</p>
<pre><code>someInt  = 1
someStr  = "abc"
someList = [1,2,3]

def foo():
    someInt  += 3     # error, local variable referenced before assignment.
    someStr  += "def" # error, local variable referenced before assignment.
    someList += [4]   # error,  local variable referenced before assignment. Note that this is **not** the same as doing someList.append(4).
</code></pre>
<p>To make the above work, include them in the function via <code>global</code> keyword and use them as required.</p>
</div>
<span class="comment-copy">Try to make the variable output global. Otherwise, the function cannot access it</span>
<span class="comment-copy">Terminology nitpick...you can't <i>modify</i> an immutable variable.  You can't <i>reassign</i> a name in the global namespace in a local function without the global keyword, regardless if it is mutable or immutable.</span>
<span class="comment-copy">@MarkTolonen Thank you for pointing that out. Added the changes in the edit.</span>
<span class="comment-copy">I'm afraid this has nothing to do with mutability/immutability.  The problem is really about how Python binds names in function scope.</span>
