<div class="post-text" itemprop="text">
<p>I am trying to iterate a number of times over an iterable.  Howver, the issue is that once the iterable is consumed  it no longer can yield. Which means, after my first iteration I no longer can use the iterable.<br/>
In my case, I have an excel file of 10 000 lines, <strong>I am creating a textfilereader to avoid importing all my data into memory</strong>. I am fixing a number of iterations which will be used to execute the same opeartions over the lines of the excel file. Because of the fading nature of the iterable, I can't use the operations after the second iteration. So, I tried to create a global iteraton loop where I define the iterable each time: <strong>Is there a better way to get around this issue</strong></p>
<p><em>The main reason of using an iterable in my case is to avoid loading data in memory .</em></p>
<blockquote>
<p>Code causing issue</p>
</blockquote>
<pre><code>### read file through an iterable
df_test = pd.read_csv('filet_to_read.csv',sep=';',quotechar='"', escapechar='\\', iterator=True, chunksize=15, encoding='utf-8',converters={'Ident':str})
### iterations
iterations=5
for iter in range(iterations):
    for chunk in df_test:
          ##Do_operations
    print('end of itertaion :',iter)

### After first iteration, no more operations are possible because iterable is consumed
</code></pre>
<blockquote>
<p>My solution</p>
</blockquote>
<pre><code>iterations=5
    for i in range(iterations):
        df_test = pd.read_csv('filet_to_read.csv',sep=';',quotechar='"', escapechar='\\', iterator=True, chunksize=15, encoding='utf-8',converters={'Ident':str})
        for chunk in df_test:
              ##Do_operations
        print('end of itertaion :',iter)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer">tee</a>, from the documentation:</p>
<blockquote>
<p>Return n independent iterators from a single iterable.</p>
</blockquote>
<p><strong>Example</strong></p>
<pre><code>from itertools import tee


it = range(5)

for i in tee(it, 5):
    print(list(i))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had an issue very similar to yours. I needed to iterate over a database table many times without keeping it in memory. The above solution didnt satisfy my problem as my code required passing the iterator many times and to many functions at different levels. I came up with a solution that I believe it to be more elegant and general than tee and wanted to share it here.</p>
<p>This "looper" class will allow you to iterate over any iterator multiple times simply by regenerating the iterator once the internal iterator has raised StopIteration. The outer looper class does raise the StopIteration exception before regenerating. Meaning it will have similar iterator behavior to a list or tuple when n=None.</p>
<pre><code>class looper:
    def __init__(self, gen_iter_func,n=None):
        self.gen_iter_func = gen_iter_func
        self.n = n

    def __iter__(self):
        self.iterable = self.gen_iter_func()
        return self

    def __next__(self):
        if (self.n is not None and self.n &lt;= 0):
            raise StopIteration
        try:
            return next(self.iterable)
        except:
            if self.n is not None:
                self.n -= 1
            raise StopIteration
</code></pre>
<p>Example using range:</p>
<pre><code>def gen_iter():
    return iter(range(5))

loop = looper(gen_iter,n=3)
for i in range(5):
    print('-------{}-------'.format(i))
    for x in loop:
        print(x)
</code></pre>
<p>Output:</p>
<pre><code>-------0-------
0
1
2
3
4
-------1-------
0
1
2
3
4
-------2-------
0
1
2
3
4
-------3-------
-------4-------
</code></pre>
</div>
<span class="comment-copy">Use the <code>csv</code> module and <code>seek()</code> the start of the file at the end? (I actually don't know if seek is a method on the csvreader object, I'll have to look it up)</span>
<span class="comment-copy">Although this is a different example, the code shows how you can seek to the start of the file <a href="https://docs.python.org/2/library/csv.html#csv.Sniffer" rel="nofollow noreferrer">docs.python.org/2/library/csv.html#csv.Sniffer</a></span>
<span class="comment-copy">Yup, just remember to leave <code>it</code> alone once you've tee'd it.</span>
<span class="comment-copy">@mouni93 the documentation linked to says: "Once tee() has made a split, the original iterable should not be used anywhere else; otherwise, the iterable could get advanced without the tee objects being informed."</span>
