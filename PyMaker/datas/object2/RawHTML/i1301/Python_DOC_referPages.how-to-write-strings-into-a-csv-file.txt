<div class="post-text" itemprop="text">
<p>I am trying to create a csv file with a single column of file paths. I need a second column filled with ones.</p>
<p>The result I want to get is as follows;</p>
<pre><code>./1/a_1.csv, 1
./1/a_2.csv, 1
./1/a_3.csv, 1
</code></pre>
<p>The code I tried is this;</p>
<pre><code>import numpy as np

data=np.chararray((650,2), itemsize=20)

for i in range(1, 650):
    data[0][0]="./1/a_" + str(i) + ".csv"

np.savetxt("C:\\a.csv", data, delimiter = ",")
</code></pre>
<p>However, it doesn't seem to work. Could you help?</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need Numpy for this. Just do something like</p>
<pre><code>with open('a.csv', 'w') as outf:
    for i in range(650):
        print('./1/a_%s.csv, 1' % (i + 1), file=outf)
</code></pre>
<p>and you're golden.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't care about how the file is created (as long as it works), go for AKX's solution.</p>
<p>If you want to do it with Numpy, you need to get your dtype straight. <code>np.savetxt</code> has a default formatter which has trouble understanding the array you gave it.</p>
<p>This is how I managed to get your desired output:</p>
<pre><code>data = np.empty((650,2),dtype="S20") # empty array of the correct datatype 

data[:,1] = '1' # set column 1 to '1' (as you noted)

for i in range(650):
    data[i][0] = "./1/a_" + str(i) + ".csv" # put your filenames into first column

np.savetxt(r"C:\a.csv", data, delimiter = ",", fmt="%s") # save it using %s formatter
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In each iteration of your loop, you only ever write to <code>data[0][0]</code>. You need to alter your loop to change the array position you're setting as you loop over the range.</p>
</div>
<div class="post-text" itemprop="text">
<p>In csv file the delimiter is ";" not ",".</p>
<pre><code>import numpy as np

data=np.chararray((650,2), itemsize=20)

for i in range(1, 650):
    data[0][0]="./1/a_" + str(i) + ".csv"

np.savetxt("C:\\a.csv", data, delimiter = ";")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use Dataframes from the Pandas library. A similar approach to chitown88's answer, but more compact.</p>
<pre><code>import pandas as pd

# create a list with paths to files named from 1 to 256
file_paths = ["./1/a_{}.csv".format(i) for i in range(1,257)]

# add the list to a Pandas Dataframe, the column name can be omitted
df = pd.DataFrame(data=file_paths, columns=['Paths'])

# add a column of 1's to the DataFrame
df['1'] = 1

# write the DataFrame without the indices and column names to a csv file using a specific separation character  
df.to_csv('C:\\a.csv', sep=',', index=False, header=False)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I personally like to store all my data into a dataframe and then at he very end, save it to a csv file, as opposed to writing after each iteration.</p>
<p>so I initialize a blank dataframe called <code>results</code></p>
<p>then iterates through your range, creating your file_path string. Then I create that 1 row with the current file_name string and your 2nd column. That gets appended to the results dataframe, then moves on to the next item in your list/range. Continues that process until it's done, then saves the final results dataframe to file</p>
<pre><code>import pandas as pd

# initialize an empty dataframe 
results = pd.DataFrame()

# iterates each element in the range list to form a row that is appended to the results dataframe
for i in range(1, 650):
    file_path="./1/a_" + str(i) + ".csv"
    temp_df = pd.DataFrame([[file_path, 1]], columns = ['file_path', 'col_2'])
    results = results.append(temp_df.reset_index(drop = True))

# after iterating through all the elements, saves completed results dataframe to file
results.to_csv("a.csv", index=False))
</code></pre>
</div>
<span class="comment-copy">What do you mean with "doesn't seem to work"? What happens? Do you get an error? If so, please post the error too, and the traceback, if any.</span>
<span class="comment-copy">"TypeError: Mismatch between array dtype ('|S20') and format specifier ('%.18e,%.18e')". I was getting this error but the solution you have posted works so thank you very much for this!</span>
<span class="comment-copy">Please accept the answer that worked for you. :)</span>
<span class="comment-copy">Interesting use of print. Is there any difference between your method and <code>with open('a.csv', 'w') as myfile:</code> <code>myfile.write('./1/a_%s.csv, 1')</code>?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#print" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#print</a> explains the <code>file</code> parameter.  It says the <code>file</code> object must a have <code>write</code> method.  So in effect they are the same (for string output).</span>
<span class="comment-copy"><code>print()</code> adds the newline by default, too; I didn't want to clutter the original code with the extra ` \n `</span>
<span class="comment-copy">The default delimiter is <code>","</code> because that's the most common one used and what ,many people think the "C" is <a href="https://en.wikipedia.org/wiki/Comma-separated_values" rel="nofollow noreferrer">"CSV"</a> stands for. However there is no standard, and <code>";"</code> is fine, as are many other characters.</span>
<span class="comment-copy">Can you please provide some information on what this code does/how it works? Code-only answers often don't shine as well as ones that are accompanied by explanations.</span>
