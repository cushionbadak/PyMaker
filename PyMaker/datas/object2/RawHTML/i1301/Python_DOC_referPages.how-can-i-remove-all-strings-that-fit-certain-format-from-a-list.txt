<div class="post-text" itemprop="text">
<p>Question: 
Say I have a list <code>a = ['abd', ' the dog', '4:45 AM', '1234 total', 'etc...','6:31 PM', '2:36']</code></p>
<p>How can I go about removing elements such as <code>4:45 AM</code> and <code>6:31 PM</code> and '2:36'? i.e, how can I remove elements of the form <code>number:number|number</code> and those with AM/PM on the end?</p>
<p>To be honest, I havent tried much, as I am not sure really where to even begin, other than something like:</p>
<pre><code>[x for x in a if x != something]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use regular expression <code>\d+(?::\d+)?$</code> and filter using it.</p>
<p>See demo.</p>
<p><a href="https://regex101.com/r/HoGZYh/1" rel="noreferrer">https://regex101.com/r/HoGZYh/1</a></p>
<pre><code>import re
a = ['abd', ' the dog', '4:45', '1234 total', '123', '6:31']
print [i for i in a if not re.match(r"\d+(?::\d+)?$", i)]
</code></pre>
<p>Output: <code>['abd', ' the dog', '1234 total']</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Consider using the built-in <a href="https://docs.python.org/2/library/functions.html#filter" rel="nofollow noreferrer"><code>filter</code></a> function with a compiled regex.</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; no_times = re.compile(r'^(?!\d\d?:\d\d(\s*[AP]M)?$).*$')
&gt;&gt;&gt; a = ['abd', ' the dog', '4:45 AM', '1234 total', 'etc...','6:31 PM', '2:36']

&gt;&gt;&gt; filter(no_times.match, a)
['abd', ' the dog', '1234 total', 'etc...']
</code></pre>
<p>A lambda can also be used for the first argument if, for example, you wanted to avoid compiling a regex, though it is messier.</p>
<pre><code>&gt;&gt;&gt; filter(lambda s: not re.match(r'^\d\d?:\d\d(\s*[AP]M)?$', s), a)
['abd', ' the dog', '1234 total', 'etc...']
</code></pre>
<p>Note that in Python 3, <code>filter</code> returns an iterable object instead of a list.</p>
<hr/>
<p>The regular expression here works by accepting all strings <em>except</em> <code>\d\d?:\d\d(\s*[AP]M)?$</code>. This means all strings except for ones matching <code>HH:MM</code>, optionally ending in some whitespace followed by AM or PM.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this code in pure Python.
Firstly it checks the last two chars, if the last two chars equals to 'am' or 'pm', element should be removed from list.
Secondly it checks each element if it contains ':', if ':' is found in the element, then it checks the characters before and after ':'. If characters before and after ':' are digits, the element is removed from list. The idea supports number|number:number and number:number|number.</p>
<pre><code>def removeElements(a):
    removed_elements = []
    L = len(a)
    for i in range(L):
        element = a[i]
        if 'am' == element[-2:].lower() or 'pm' ==element[-2:].lower() :
            removed_elements.append(element)
        if ':' in element:
            part1 = element.split(':')
            part2 = element.split(':')
            if part1[-1].isdigit() and part2[0].isdigit():
                removed_elements.append(element)
    output =  []
    for element in a:
        if not(element in removed_elements):
            output.append(element)
    return output

a = ['abd', ' the dog', '4:45 AM', '1234 total', 'etc...','6:31 PM', '2:36']
output = removeElements(a)
print output

</code></pre>
<p>output for this example is :
['abd', ' the dog', '1234 total', 'etc...']</p>
</div>
<div class="post-text" itemprop="text">
<p>The regular expression <code>\d:\d\d$</code> matches a single digit, then a <code>:</code>, followed by two digits.</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; a = ['abd', ' the dog', '4:45', '1234 total', 'etc...', '6:31']
&gt;&gt;&gt; regex = re.compile('\d:\d\d$')
&gt;&gt;&gt; [s for s in a if regex.match(s)]
['4:45', '6:31']
&gt;&gt;&gt; [s for s in a if not regex.match(s)]
['abd', ' the dog', '1234 total', 'etc...']
</code></pre>
<p><code>\d+:\d+$</code> would match any number <code>n &gt;= 1</code> of digits  on each side of the <code>:</code>. I suggest you play around with it. The documentation is <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">here</a>.</p>
<p>Detail: <code>$</code> specifies the end of the string, and <code>re.match</code> starts looking at the start of the string.</p>
</div>
<div class="post-text" itemprop="text">
<p>A regex is the easy answer.</p>
<p>Here is an alternative with pure Python:</p>
<pre><code>&gt;&gt;&gt; a = ['abd', ' the dog', '4:45', '1234 total', 'etc...','6:31', '1234']
&gt;&gt;&gt; [s for s in a if not all(e.isdigit() for e in s.split(':'))]
['abd', ' the dog', '1234 total', 'etc...']
</code></pre>
<p>Note that there is a side effect of <code>'1234'.split(':')</code> that serves to filter all digits as well.</p>
<hr/>
<p>If there is a possibility of <code>'1:2:3'</code> type numbers:</p>
<pre><code>&gt;&gt;&gt; a = ['abd', ' the dog', '4:45', '1234 total', 'etc...','6:31', '1234', '1:2:3']
&gt;&gt;&gt; [s for s in a if len(s.split(':'))&lt;=2 and not all(e.isdigit() for e in s.split(':'))]
['abd', ' the dog', '1234 total', 'etc...']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need regex, try using:</p>
<pre><code>&gt;&gt;&gt; a = ['abd', ' the dog', '4:45 AM', '1234 total', 'etc...','6:31 PM', '2:36']
&gt;&gt;&gt; [i for i in a if ':' not in i and not i[-2:] in ['AM','PM']]
['abd', ' the dog', '1234 total', 'etc...']
&gt;&gt;&gt; 
</code></pre>
<p>Or use a much easier solution with regex:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; a = ['abd', ' the dog', '4:45 AM', '1234 total', 'etc...','6:31 PM', '2:36']
&gt;&gt;&gt; [i for i in a if not re.search('\d+:\d+',i)]
['abd', ' the dog', '1234 total', 'etc...']
&gt;&gt;&gt; 
</code></pre>
<p>Or a version of non-regex that's also much easier:</p>
<pre><code>&gt;&gt;&gt; a = ['abd', ' the dog', '4:45 AM', '1234 total', 'etc...','6:31 PM', '2:36']
&gt;&gt;&gt; [i for i in a if ':' not in i]
['abd', ' the dog', '1234 total', 'etc...']
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check this implementation.</p>
<pre><code>import re

a = ['abd', ' the dog', '4:45 AM', '1234 total', 'etc...','6:31 PM', '2:36']
regex = re.compile(r'^[0-2]{0,1}[0-9]\:[0-5][0-9]\s{0,1}([AP][M]){0,1}')

a  = [x for x in a if not regex.match(x)]
print(a)
</code></pre>
<p><strong>OUTPUT</strong></p>
<pre><code>['abd', ' the dog', '1234 total', 'etc...']
</code></pre>
</div>
<span class="comment-copy">Have you looked into regular expressions?</span>
<span class="comment-copy"><code>^(\d+:\d+|\d+)$</code> is your regex</span>
<span class="comment-copy">What if the string looks like a time but is not a valid time? e.g. <code>133:89 PM</code></span>
<span class="comment-copy">question, what if it was number|number:number|number, like 12:18?</span>
<span class="comment-copy">nvm it handles that too. thank you!</span>
<span class="comment-copy">@cjg123 look here... try all ur inputs <a href="https://regex101.com/r/HoGZYh/2" rel="nofollow noreferrer">regex101.com/r/HoGZYh/2</a></span>
<span class="comment-copy">@cjg123 what didn't work</span>
<span class="comment-copy">@vks that helped me too! thanks!</span>
<span class="comment-copy">What might be a reason to avoid compiling a regex?</span>
<span class="comment-copy">The only thing I can think of is possibly avoiding creating another variable name, so probably not the best reason. At least in the cpython implementation, <code>match()</code> compiles and caches the pattern anyway.</span>
<span class="comment-copy">yes, but <code>1:1:1</code> also matches.</span>
<span class="comment-copy"><code>[s for s in a if len(s.split(':'))&lt;=2 and not all(e.isdigit() for e in s.split(':'))]</code> fixes that...</span>
<span class="comment-copy">yes, but that's really horrible and slow compared to regex. I had thought of <code>[x for x in a if not x.replace(":","").isdigit()]</code> too but has loopholes</span>
<span class="comment-copy">In what respect is the use of module <code>re</code> not pure Python?</span>
<span class="comment-copy">@cjg123 i added much much better solutions, with <code>re.match</code> very short, and an even shorter one with a list comprehension.</span>
