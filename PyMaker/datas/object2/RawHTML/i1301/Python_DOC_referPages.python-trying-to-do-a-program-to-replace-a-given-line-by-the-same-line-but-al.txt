<div class="post-text" itemprop="text">
<p>Trying to do a college exercise where I'm supposed to replace a given line in a file, by the same line but written in all caps. The problem is we can only write in the same file, and in that exact line, we can't write in the rest of the file.</p>
<p>This is the code I have so far, but I can't figure out how to go to the line I want</p>
<pre><code>def upper(n):
    count=0
    with open("upper.txt", "r+") as file:
        lines = file.readlines()
        file.seek(0)
        for line in file.readlines():
            if count == n:
                pos = file.tell()
                line1 = str(line.upper())

            count += 1
        file.seek(pos)
        file.write(line1)       
</code></pre>
<p>Help appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem lies in that your <code>readlines</code> <em>already</em> has read the entire file, and so the position of the "file cursor" is always at the end of the file. In theory, a simple fix should be:</p>
<ol>
<li>Initialize <code>pos</code> to 0.</li>
<li>Read a single line.</li>
<li>If the current line counter indicates this is the one you want, set the position to <code>pos</code> again, update that line, and exit.</li>
<li>Update <code>pos</code> to point to the end of <em>this</em> line (so it points to the start of the <em>next</em> line).</li>
<li>Loop until satisfied.</li>
</ol>
<p>In code, that would be this:</p>
<pre><code>def upper(n):
    count=0
    with open("text.txt", "r+") as file:
        pos = 0
        for line in file.readlines():
            if count == n:
                line1 = line.upper()
                break

            pos = file.tell()
            count += 1
        file.seek(pos)
        file.write(line1)

upper(5)
</code></pre>
<p><strong>However!</strong> There is a snag. File operations are heavily buffered, and the <code>for</code> loop on <code>readlines</code> does <em>not</em> read one line at a time. Instead, for efficiency, it reads as much as possible, but it only "returns" the next line to your program. On a next run through your loop, it simply checks if it already had read enough of your text file to return the following line, and if not, it fills its internal buffer again. So, even while <code>tell()</code> will correctly be updated to the <em>external</em> file position – the value you see –, it does <em>not</em> reflect the "cursor" position of what you are processing at the time.</p>
<p>One way to circumvent this is to physically mimic what <code>readlines</code> does: read a single byte at a time, determine whether you have read an entire line (then this byte would be <code>\n</code>), and update your position and status based on this.</p>
<p>However, a more proper way of updating a file is to read it into memory in its entirety, change it, and write it back to disk. Changing part of an existing file with <code>"r+"</code> is usually recommended to use binary mode (where the position of each byte is known beforehand); admittedly, in theory your method should have worked as well, but as you see the file buffering defeats this.</p>
<p>Reading, changing, and writing the file entirely is as simple as this:</p>
<pre><code>def better_upper(n):
    count=0
    with open("text.txt", "r") as file:
        lines = file.readlines()
    lines[n] = lines[n].upper()
    with open("text.txt", "w") as file:
        file.writelines(lines)

better_upper(5)
</code></pre>
<p>(Where the only caveat is that it always overwrites the original file. That is: if something unexpected goes wrong, it will probably erase <code>text.txt</code>. If you want a belt-and-suspenders approach, write to a new file, then check if it got written correctly. If it did, delete the old file and rename the new one. Left as an exercise to the reader.)</p>
</div>
<span class="comment-copy">The <code>pos</code> that <code>ftell</code> returns is the one <i>after</i> your line already has been read. Does that help?</span>
<span class="comment-copy">Read about <a href="https://docs.python.org/3/library/io.html#io.IOBase.readlines" rel="nofollow noreferrer">readlines</a> and rethink your approach.</span>
<span class="comment-copy"><code>lines[5] = lines[5].upper()</code> , you can use <code>n</code> insted of <code>5</code></span>
<span class="comment-copy">Couldn't we use <code>for line in file:</code> instead of <code>for line in file.readlines():</code> and iterate line by line ? With that way, I think we can follow the cursor.</span>
