<div class="post-text" itemprop="text">
<p>I feel bad for asking such a simple question but I'm really confused as to why this example does not work as expected. I expect that the following assert would fail with a value of 70 but the test passes with a value of 30.</p>
<p>The following is in a pip package called calc:</p>
<pre><code>calc/__init__.py
from .calculator import *


calc/calculator.py
def get_value_1():
    return 10


def get_value_2():
    return 20


def addition():
    return get_value_1() + get_value_2()


test/simple.test
import calc
@mock.patch('calc.get_value_1', return_value=50)
def test1(mock_data):
    value = calc.addition()
    assert value == 30

Test output:
plugins: cov-2.6.0, nbval-0.9.1
collected 1 item                                                                                                                                             

test/simple_test.py::test6 PASSED

================= 1 passed in 0.21 seconds ===================
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answer of @JulienChein is pretty good, and I will just add some example based on you snippet.</p>
<p>I create a similar environment to your.</p>
<pre><code>.
├── calculator.py
├── __init__.py
└── test
    ├── __init__.py
    └── test_calc.py
</code></pre>
<p><strong>calculator.py</strong></p>
<pre><code>def get_value_1():
    return 10

def get_value_2():
    return 20

def addition():
    return get_value_1() + get_value_2()
</code></pre>
<p><strong>__init__.py</strong></p>
<pre><code>from .calculator import *
</code></pre>
<p><strong>test/test_calc.py</strong></p>
<pre><code>from unittest.mock import patch
from .. import addition

# Here get_value_1, is mocked from calc.__inti__.py
@patch('calc.get_value_1', return_value=50)
def test1(mock_data):
    value = addition()
    assert value == 30  # This assert is False

# Here get_value_1, is mocked from calc.calculator.py
@patch('calc.calculator.get_value_1', return_value=50)
def test2(mock_data):
    value = addition()
    assert value == 70  # This assert is True
</code></pre>
<p>The point is that <code>addition</code> uses methods from <strong>calc.calculator.py</strong>, that's why you need to mock the method from this file.</p>
</div>
<div class="post-text" itemprop="text">
<p>Make sure you are patching the correct target. Specifically, follow the 'Where to Patch' section here: <a href="https://docs.python.org/3/library/unittest.mock.html#id5" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#id5</a></p>
<p>From your posted files, it seems possible that some names are mixed up ('calc' or 'calculator', for example). Make sure to read through the <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer">docs</a>, especially:</p>
<blockquote>
<p>target should be a string in the form 'package.module.ClassName'. The target is imported and the specified object replaced with the new object, so the target must be importable from the environment you are calling patch() from. </p>
</blockquote>
<p>Patching, if you are just starting to do it, can be pretty confusing / maddening. Maybe add an <code>import pdb; pdb.set_trace()</code> (debugger) in the test. This would pause the test at this statement. You can then check what <code>get_value_1</code> gives you. If it's of type <code>MagicMock</code> or some such, then the patch succeeded. If it's not, then you failed to patch the correct thing and should change the target path. Hope this helps!</p>
<p>Also: are you sure <code>@mock.patch('calc.get_value_1', return_value=50)</code> would work? I would try <code>mock.patch('calc.get_value_1')</code> then add <code>mock_data.return_value = 50</code> inside the test function. I haven't seen your way before and a brief digging of the source code didn't show me it would work (didn't show me it wouldn't work either!) - worth trying.</p>
</div>
<span class="comment-copy">The addition function returns <code>get_value_1() + get_value_2()</code> which is equivalent to 10 + 20 = 30. So if you call the <code>addition</code> function, you should get 30. Though you patched <code>calc.get_value_1</code>, by the time you have loaded <code>calc</code>, it already has been defined so that it returns 30.</span>
<span class="comment-copy">Yes, but I change the return value of what the get_value_1 should be. So, instead of returning 10, it now returns 50, which would cause the return value of 70 instead of 30.</span>
<span class="comment-copy">Updated comment</span>
<span class="comment-copy">I dont know, <code>patch</code> should just replace the object with the patched object, see <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html#patch</a> - OP I think the culprit is the namespace you are patching</span>
<span class="comment-copy">As a guess, you're patching <code>calc.get_value_1</code> when you should be patching <code>calc.calc.get_value_1</code>. It's impossible to tell for sure, though, since what you've posted displays indicators that it doesn't quite match anything you actually ran.</span>
<span class="comment-copy">thank you so much for your response, I understand what I did wrong. I got my higher level examples working now!</span>
<span class="comment-copy">Your right about the snippets that I put in, I the calc.py file is suppose to be calculator.py but that was just a mistype and what was not actually in the code. As for not patching the correct thing, there is not to many other things to really patch in this example, but I will give the pdb.set_trace() a try. Thanks for the help.</span>
