<div class="post-text" itemprop="text">
<p>I am trying to find two numbers in a list which are divisible by each other. I have managed to do this by placing two for loops that loop over the same list to compare numbers until a pair is found.</p>
<h2>My Question:</h2>
<p>Is it possible to easily compress this code to one or two lines using a conditional statement? </p>
<pre><code>def FindDivisible(j):
    for i in j:
        for m in j:
            if int(i) % int(m) == 0 and int(i) != int(m):
                return([int(i),int(m)])
</code></pre>
<p><em>I do understand that this would not be very pythonic at all. I do however want to know if it is possible and what would be a good way for going about this.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>This one-liner will get all divisible combinations of the elements in iterable <code>j</code>:</p>
<pre><code>[([int(i),int(m)]) for m in j for i in j if int(i) % int(m) == 0 and int(i) != int(m)]
</code></pre>
<p>The above is just your code translated into a <em>list comprehension</em>.  One difference is that this will find all combinations while your original looping code will return just the first successful combination.  If you want to exit after the first combination, then the explicit looping is the right choice.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; j=range(2,5)
&gt;&gt;&gt; [([int(i),int(m)]) for m in j for i in j if int(i) % int(m) == 0 and int(i) != int(m)]
[[4, 2]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>You can probably use <strong>itertools.product</strong></p>
</blockquote>
<p><a href="http://docs.python.org/library/itertools.html#itertools.product" rel="nofollow noreferrer">http://docs.python.org/library/itertools.html#itertools.product</a></p>
<p>Example as</p>
<pre><code>for var1, var2 in itertools.product(xrange(min1, max1, step1), xrange(min2, max2, step2)):
    # stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>let use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">itertool combinaison</a>  and filter</p>
<p>in 2 lines :</p>
<pre><code>from itertools import combinations
alist =[(x,y) if  (x%y==0 or y%x==0 and x!=y ) else None for x,y in combinations(l, 2)]
L = list(filter(None, alist))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>itertools.product</code>. Note that it is simpler to map <code>int</code> over the original input list once, rather than constantly converting individual elements.</p>
<pre><code>from itertools import product
def find_divisible(j):
    return [(i, m) for (i, m) in product(map(int, j), repeat=2) 
             if i % m == 0 and i != m]
</code></pre>
</div>
<span class="comment-copy">I think you want list comprehension. With comprehension you could this in a line or two</span>
<span class="comment-copy">Your code is not properly indented. That aside, your current solution only returns the first pair of numbers that are found. For example, if the input were <code>j = [2, 4, 5, 6, 7, 8]</code>, your code would return <code>[4, 2]</code>. Is this what you want? What about the other pairs?</span>
<span class="comment-copy">List comprehension won't solve this... To OP: why would you want to compress this into "one or two lines"? Less code is not better code. Readable code is better code, and bar poorly named variables, this code is readable.</span>
<span class="comment-copy">Looks like a homework not well planned. Give it some more effort.</span>
<span class="comment-copy">@andyhasit, I think you are underestimating list comprehension</span>
<span class="comment-copy">The OP specified UNTIL a pair is found, this returns all. Of course you could slice the first one off. Still not sure why the OP is asking for this in first place as list comprehension makes it muddy as.</span>
<span class="comment-copy">@andyhasit I find the list comprehension clearer but I understand that, based on each individual's prior experience, others may view it differently.    Also, you are right about the list comprehension approach finding all pairs, not just the first.  That is stated in the answer.</span>
<span class="comment-copy">This is quite cool! I like this alot, even though it returns every combination. I might use this and just have other functions use only the information they need! Thanks!</span>
