<div class="post-text" itemprop="text">
<p><strong>[EDIT: The requirements changed, the structure of the input is now different!]</strong>
<strong>Please see the changes below.</strong></p>
<p>So I have to create a new list, containing dictionaries, out of a dictionary that contains lists.</p>
<p>To clarify, I have the following dictionary as input:</p>
<pre><code>{
    "data_source": "serial_number",
    "parameters": ["param_1", "param_2", "param_3"],
    "data_array": [
        {
            "time": "time_stamp_1",
            "values": [val_1, val_2, val_3]
        },
        {
            "time": "time_stamp_2",
            "values": [val_4, val_5, val_6]
        },
        {
            "time": "time_stamp_3",
            "values": [val_7, val_8, val_9]
        },
        {
            "time": "time_stamp_4",
            "values": [val_10, val_11, val_12]
        },
        {
            "time": "time_stamp_5",
            "values": [val_13, val_14, val_15]
        },
        {
            "time": "time_stamp_6",
            "values": [val_16, val_17, val_18]
        }
    ]
}
</code></pre>
<p>The number of items on each <strong>parameters</strong>, and <strong>values</strong> will always correspond. If there are 100 parameters, there will be 100 values, and 1 <strong>time stamp</strong> for each pair of <strong>parameter, value</strong></p>
<p>That said, out of that input, I need to output <strong>n</strong> dictionaries that look like this:</p>
<pre><code>[
    {
        "serial": "#serial_number", // type str
        "parameter": "param_1", // type str
        "time": "time_stamp_1", // type str
        "parameter_value": val_1 //type int
        }
    },
    {
        "serial": "#serial_number", // type str
        "parameter": "param_2", // type str
        "time": "time_stamp_1", // type str
        "parameter_value": val_2 //type int
        }
    },
    {
        "serial": "#serial_number", // type str
        "parameter": "param_3", // type str
        "time": "time_stamp_1", // type str
        "parameter_value": val_3 //type int
        }
    },
... // repeat "n" times for each item on the above lists
]
</code></pre>
<p>So that if I get 100 items in the (first example) <strong>parameters, values</strong> lists, I will then have a list of 100 dictionaries with corresponding values.</p>
<p>To clarify, there will be <strong>n</strong> parameters in a list, and <strong>x</strong> sets of <strong>time_stamp</strong>: <strong>n</strong>_values</p>
<p>This is what I have so far:</p>
<pre><code>dataDict = dict(request.data)
parameters = dataDict["parameters"]
data_array = dataDict["data_array"]
final_data = []

for param, data in zip(parameters, data_array):
    parameter = Parameter.objects.get_or_create(parameter_name=param, parameter_position="None")[0]
    new_data = {
        "sensor": sensor.id,
        "parameter": parameter.id,
        "parameter_value": data,
        # "time": time
        }

    pprint.pprint(new_data)

    final_data.append(new_data)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python has a great function called <a href="https://docs.python.org/3.4/library/functions.html#zip" rel="nofollow noreferrer">zip</a> that is perfect for this.</p>
<p>EDIT: After re-reading your question you are already using zip! When iterating through the zipped values you just need to build up a <code>list</code> of each <code>dict</code> and use the final output however you need.</p>
<pre><code>input = {
    "data_source": "serial_number",
    "parameters": ["param_1", "param_2", "param_3"],
    "data_array": [
        {
            "time": "time_stamp_1",
            "values": [1, 2, 3]
        },
        {
            "time": "time_stamp_2",
            "values": [4, 5, 6]
        },
        {
            "time": "time_stamp_3",
            "values": [7, 8, 9]
        },
        {
            "time": "time_stamp_4",
            "values": [10, 11, 12]
        },
        {
            "time": "time_stamp_5",
            "values": [13, 14, 15]
        },
        {
            "time": "time_stamp_6",
            "values": [16, 17, 18]
        }
    ]
}

output = []
for data in input['data_array']:
    zipped = zip(input['parameters'], data['values'])
    for parameter, value in zipped:
        output.append({
            "serial": input['data_source'],
            "parameter": parameter,
            "time": data['time'],
            "parameter_value": value
        })
print output
</code></pre>
<p>Output:</p>
<pre><code>[
  {
    'parameter_value': 1,
    'serial': 'serial_number',
    'parameter': 'param_1',
    'time': 'time_stamp_1'
  },
  ...
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming your data in the form:</p>
<pre><code>my_dict = {"datasource": "#serial_number", 
           "parameters": ["param1", "param2", "param3"], 
           "data_array": {"time": ["time1", "time2", "time3"], 
                          "values": [1, 2, 3]
                         }
          }
</code></pre>
<p>You can use a list-comprehension to create your list of dictionaries like so:</p>
<pre><code>serial = my_dict["datasource"]
my_list = [{"serial": serial,
            "parameter": my_dict["parameters"][i], 
            "time": time, 
            "parameter_value": my_dict["data_array"]["values"][i] 
           } for i, time in enumerate(my_dict["data_array"]["time"])]
</code></pre>
<p>Which does produce the required result.</p>
<pre><code>[{'serial': '#serial_number', 'parameter': 'param1', 'time': 'time1', 'parameter_value': 1}, 
 {'serial': '#serial_number', 'parameter': 'param2', 'time': 'time2', 'parameter_value': 2}, 
 {'serial': '#serial_number', 'parameter': 'param3', 'time': 'time3', 'parameter_value': 3}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So your loop body looks broadly ok, it's a nice use of <code>zip</code>. The main issue is that each time round the loop, you're creating a new <code>new_data</code> dict, and updating <code>request.data</code> with it. It sounds like what you actually want to do is build up a list of those new_dicts, and then after the loop completes, add that list to your request data.</p>
<p>So the structure would be more like:</p>
<pre><code>samples = []

for param, time, value in zip(parameters, time_stamps, values):
    new_data = {
        "sensor": dataDict["source"],
        "parameter": param,
        "parameter_value": value,
        "time": time
    } # Note you don't need the extra () around the dict here

    # You don't need this at all - new_data will only have the 4 keys you defined above as it's a brand new dict
    # Clean the lists I don't need
    # removeKeys = ('parameters', 'data_array', 'datasource')
    # for k in removeKeys:
    #    new_data.pop(k, None)

    samples.append(new_data)

# You'll need to work out how the request data needs to be sent back
request.data['???'] = samples
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe this will do what you want:</p>
<p>Though I think you might be better of using <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuple</a> for each element that <code>create_result</code> generates.</p>
<pre><code>input_data = {
    "datasource": "#serial_number",
    "parameters": ["param1", "param2", "param3"],
    "data_array": {
        "time": ["time1", "time2", "time3"],
        "values": [1, 2, 3]
    }
}

def create_result(input_data):
    serial_number = input_data['datasource']
    for param, time, value in zip(
            input_data['parameters'],
            input_data['data_array']['time'],
            input_data['data_array']['values']
    ):
        yield dict(serial=serial_number,
                    parameter=param,
                    time=time,
                    parameter_value=value)

result = list(create_result(input_data))

from pprint import pprint

pprint(result)
</code></pre>
<hr/>
<pre><code>[{'parameter': 'param1',
  'parameter_value': 1,
  'serial': '#serial_number',
  'time': 'time1'},
 {'parameter': 'param2',
  'parameter_value': 2,
  'serial': '#serial_number',
  'time': 'time2'},
 {'parameter': 'param3',
  'parameter_value': 3,
  'serial': '#serial_number',
  'time': 'time3'}]
</code></pre>
<p>Using <code>namedtuple</code> :</p>
<pre><code>from collections import namedtuple

Record = namedtuple('Record', ['serial', 'parameter', 'time', 'parameter_value'])

def create_result(input_data):
    serial_number = input_data['datasource']
    for param, time, value in zip(
            input_data['parameters'],
            input_data['data_array']['time'],
            input_data['data_array']['values']
    ):  # &lt;- he's sad I put him on a new line
        yield Record(serial=serial_number,
                    parameter=param,
                    time=time,
                    parameter_value=value)

result = list(create_result(input_data))

from pprint import pprint

pprint(result)
</code></pre>
<hr/>
<pre><code>[Record(serial='#serial_number', parameter='param1', time='time1', parameter_value=1),
 Record(serial='#serial_number', parameter='param2', time='time2', parameter_value=2),
 Record(serial='#serial_number', parameter='param3', time='time3', parameter_value=3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def get_values(new_tuple):
    created = dict(zip(["parameter","time","parameter_value"], new_tuple))
    created.update({"serial":data["datasource"]})
    return created

new_values = zip(data["parameters"],data["data_array"]["time"],
                      data["data_array"]["values"])

list_value = [get_values(new) for new in new_values]

print(list_value)
&gt;&gt;&gt;

[{'parameter': 'param1',
  'parameter_value': 'value1',
  'serial': '#serial_number',
  'time': 'time1'},
 {'parameter': 'param2',
  'parameter_value': 'value2',
  'serial': '#serial_number',
  'time': 'time2'},
 {'parameter': 'param3',
  'parameter_value': 'value3',
  'serial': '#serial_number',
  'time': 'time3'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = {
    "datasource": "#serial_number",
    "parameters": ["param1", "param2", "param3"],
    "data_array": {
        "time": ["time1", "time2", "time3"],
        "values": ["value1", "value2", "value3"]
    }
}
param, time, value = a["parameters"], a["data_array"]["time"], a["data_array"]["values"]
print param, time, value
arrayOfDicts = []
index = 0
while index &lt; len(param):
    arrayOfDicts.append({"serial":a["datasource"], "parameter": param[index], "time": time[index], "value": value[index]})
    index += 1
print arrayOfDicts
</code></pre>
</div>
<span class="comment-copy">I dislike that the question changed after many answers had been posted. Invalidating them.</span>
<span class="comment-copy">The very first (accepted) answer does still apply though, and the change isn't that big to figure out from the other answers.</span>
<span class="comment-copy">The requirements just changed as we realised we could save a lot of data being transferred by using only 1 time_stamp for each parameter:value pair. Could you take a look? I think it complicated things a lot more now.</span>
<span class="comment-copy">I've just updated the answer. With your updated structure you just needed to loop over <code>data_array</code> to get the <code>time</code>, and still use <code>zip</code> for the other items.</span>
<span class="comment-copy">Thank you, that worked perfectly.</span>
<span class="comment-copy">Its a good answer, but the readability might be a challenge if you need to debug it.</span>
<span class="comment-copy">I did this and it worked nicely, but now I'm getting "AttributeError: Can't set attribute" when I try to do request.data = samples (I named if final_data).  Not sure what's going there now, when I print(final_data) it looks exactly like a list of dicts that request.data can handle.</span>
<span class="comment-copy">Assuming you're using <code>requests</code> or similar to send the data to some other HTTP endpoint, you need o understnad how HTTP data is sent. <code>request.data</code> would generally refer to the GET or POST parameters in the request, which usually look like a dictionary (in that they're key/value pairs). Since you seem to want to send a list rather than a dict, you'll first need to understand what format the endpoint you're sending the data to actually needs the data</span>
<span class="comment-copy">It migiht be worth asking a new question, focussing on specifically this issue, and providing more detail on what/where you're POSTINg and as much info as you have on your comment 'This is for a POST request in which the input data needs to be shaped first'.</span>
<span class="comment-copy">Fixed it for Django. The request.data for the Django serializers can either be a dict, or a list of dicts. But since apparently name tuples are immutable, I couldn't just do request.data = new_data. So instead I just serialized as "serializer = DataCreateSerializer(data=final_data, many=True)" so I sent in data=new_data to my serializer instead of data=data.</span>
<span class="comment-copy">The requirement just changed. We realized we could save a lot of data if we only used one time stamp.  I've updated the questions, could you take a look? I don't think I can use zip anymore.</span>
<span class="comment-copy">The use of the <code>while</code> loop seems excessive when you know how many items are in <code>a</code></span>
