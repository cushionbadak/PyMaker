<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1747817/create-a-dictionary-with-list-comprehension-in-python">Create a dictionary with list comprehension in Python</a>
<span class="question-originals-answer-count">
                    11 answers
                </span>
</li>
</ul>
</div>
<p>I am looking for a short and compact one-liner to initialize a dictionary from a list in Python. Is there an equivalent to the two constructs below?</p>
<pre><code>dic = {}
for elt in list:
  dic[elt.hash] = elt
</code></pre>
<p>.</p>
<pre><code>dic2 = {}
defaultValue = 0
for elt in list:
  dic2[elt] = defaultValue
</code></pre>
<p>I've see the use of <code>Counter</code> for the second case, but it is a very narrow case, and I'm looking for a generic syntax.</p>
</div>
<div class="post-text" itemprop="text">
<p>Summary of three pythonic solutions to instantiating dictionaries. Having a "one-line" solution should never be the most important consideration.</p>
<p><strong>1. Keys and default value defined in advance.</strong></p>
<p>Instead of setting a default value for every key, use <a href="https://docs.python.org/3.6/library/stdtypes.html#dict.fromkeys" rel="nofollow noreferrer"><code>dict.fromkeys</code></a>. Also, do not name variables the same as classes, e.g. use <code>lst</code> instead.</p>
<pre><code>dic2 = dict.fromkeys(lst, 0)
</code></pre>
<p><strong>2. Default value defined in advance, but not keys.</strong></p>
<p>Alternatively, if you will be adding more keys in the future, consider using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>, which is a subclass of <code>dict</code>:</p>
<pre><code>from collections import defaultdict
dic2 = defaultdict(int)
dic2['newkey']  # returns 0 even not explicitly set
</code></pre>
<p><strong>3. Keys and values related by a function.</strong></p>
<p>For building a dictionary where keys and values are linked via a function, use a dictionary comprehension, as <a href="https://stackoverflow.com/a/48609760/9209546">described in detail by @OmerB</a>, e.g.</p>
<pre><code>{k: f(k) for k in lst}  # value function of given keys
{f(v): v for v in lst}  # key function of given values
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, dictionary comprehension is one-line, is that what you mean?</p>
<pre><code>&gt;&gt; MyList = ['apple', 'banana', 'pear']
&gt;&gt; {hash(element): element for element in MyList}

{-8723846192743330971: 'pear',
 -6060554681585566095: 'banana',
 -4133088065282473265: 'apple'}
</code></pre>
<p>Also - I'm suspecting that using the element's hash as the key is not what you're looking for:</p>
<ul>
<li>If your elements are immutable (e.g. strings), you could use the elements themselves as keys. </li>
<li>If they're not immutable, you can use the element's location in the list.</li>
</ul>
<p>For the latter, to make sure you insert each value only once to the dict, clear duplicates from the list before iterating over it:</p>
<pre><code>&gt;&gt; MyList = ['apple', 'apple', 'banana', 'banana', 'pear']
&gt;&gt; {idx: value for (idx,value) in enumerate(set(MyList))}
{0: 'banana', 1: 'pear', 2: 'apple'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple one liner statement for case-01 using <code>dict</code> constructor, <code>map</code> and <code>zip</code>:</p>
<pre><code>&gt;&gt;&gt; l = ['a','b','c']
&gt;&gt;&gt; dict(zip(map(hash,l),l))
&gt;&gt;&gt; {12416037344: 'a', 12672038114: 'c', 12544037731: 'b'}
</code></pre>
<p>For second situation:</p>
<pre><code>&gt;&gt;&gt; l = ['a','b','c']
&gt;&gt;&gt; default_value = 10
&gt;&gt;&gt; dict((zip(l,[default_value]*len(l))))
&gt;&gt;&gt; {'a': 10, 'c': 10, 'b': 10}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Those two constructs can be built using <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">dictionary comprehensions</a> like:</p>
<h3>Code:</h3>
<pre><code>dic_comp = {getattr(elt, 'hash'): elt for elt in test_data}
dic2_comp = {elt: defaultValue for elt in test_data}
</code></pre>
<h3>Test Code:</h3>
<pre><code>class TestObj(object):
    def __init__(self, hash_value):
        self.hash = hash_value

test_data = [TestObj(i) for i in range(5)]

dic = {}
for elt in test_data:
    dic[elt.hash] = elt

dic_comp = {getattr(elt, 'hash'): elt for elt in test_data}
assert dic == dic_comp

dic2 = {}
defaultValue = 0
for elt in test_data:
    dic2[elt] = defaultValue

dic2_comp = {elt: defaultValue for elt in test_data}
assert dic2 == dic2_comp
</code></pre>
</div>
<span class="comment-copy">the second example isn't optimally built via dictionary comprehension. <code>dict.fromkeys</code> or <code>collections.defaultdict</code> is more suitable here.</span>
<span class="comment-copy">@PPC, did one of the below answers help? if so, feel free to accept one (tick on left) so other users can see an accepted solution.</span>
