<div class="post-text" itemprop="text">
<p>Let's say I have the following pseudo-code. Does importing <code>bla</code> in both files refer to 2 instances of <code>Bla</code> or do they refer to the same instance? In other words, can I connect and disconnect a single connection in different files like this in Python?</p>
<p><strong>bla.py</strong></p>
<pre><code>import socket
class Bla:
  connect(self):
    self.connection = socket.socket(...)
  disconnect(self):
    self.connection.close()
bla = Bla()
</code></pre>
<p><strong>hello.py</strong></p>
<pre><code>from bla import bla
bla.connect()
</code></pre>
<p><strong>world.py</strong></p>
<pre><code>from bla import bla
bla.disconnect()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, both in <code>hello</code> and in <code>world</code>, <code>bla</code> references the same instance.</p>
<p>Modules are <em>singletons</em>, and there is just one copy of their namespace. The top level statements (everything outside of functions and generators) is executed just once, when your module is imported the first time.</p>
<p>Modules are managed in the <a href="https://docs.python.org/library/sys.html#sys.modules" rel="nofollow noreferrer"><code>sys.modules</code> mapping</a>. Importing first ensures the module is loaded and present in <code>sys.modules</code>, after which names are bound in the importing namespace. Essentially, <code>from bla import bla</code> does the same thing as the <code>bla = sys.modules['bla'].bla</code> assignment statement would. So <em>loading</em> your module into memory takes place just once, your <code>bla = Bla()</code> is executed just once, and all further imports will access that one reference to the instance.</p>
<p>From the <a href="https://docs.python.org/3/reference/simple_stmts.html#import" rel="nofollow noreferrer"><code>import</code> statement documentation</a>:</p>
<blockquote>
<p>The basic import statement (no <code>from</code> clause) is executed in two steps:</p>
<ol>
<li>find a module, <strong>loading and initializing it if necessary</strong></li>
<li>define a name or names in the local namespace for the scope where the <code>import</code> statement occurs.</li>
</ol>
<p><em>[...]</em></p>
<p>The <code>from</code> form uses a slightly more complex process:</p>
<ol>
<li>find the module specified in the from clause, <strong>loading and initializing it if necessary;</strong></li>
<li>for each of the identifiers specified in the <code>import</code> clauses:
  
  <ol>
<li>check if the imported module has an attribute by that name</li>
<li>if not, attempt to import a submodule with that name and then check the imported module again for that attribute</li>
<li>if the attribute is not found, <code>ImportError</code> is raised.</li>
<li>otherwise, a reference to that value is stored in the local namespace, using the name in the <code>as</code> clause if it is present, otherwise using the attribute name</li>
</ol></li>
</ol>
</blockquote>
<p>(Bold emphasis mine).</p>
</div>
<span class="comment-copy">That would be <code>from bla import bla</code>, lower case. Your module file is <code>bla.py</code>, not <code>Bla.py</code>.</span>
<span class="comment-copy">Just a caveat: if you import the same module from two distinct qualified path you can end up with two distinct modules instance, each with it's own distinct <code>bla</code> object.</span>
<span class="comment-copy">@brunodesthuilliers: you'd have to use a different name for the module, the <code>sys.modules</code> namespace does not support duplicates. That can still happen when <code>bla.py</code> is used as the main script, <i>and</i> there is a <code>import bla</code> statement somewhere, you then get <code>sys.modules['__main__']</code> and <code>sys.modules['bla']</code>.</span>
<span class="comment-copy">I've also seen this on django projects where the project root is itself a package, so if you have both the project root's parent path and the project root path in your <code>sys.path</code> and have one import from the project root (<code>from myproject.someapp import something</code> and another without the project root (<code>from someapp import something</code>) you end up with two distinct modules - which is what I meant by "distinct qualified path" (and I assume what you mean by "different names").</span>
