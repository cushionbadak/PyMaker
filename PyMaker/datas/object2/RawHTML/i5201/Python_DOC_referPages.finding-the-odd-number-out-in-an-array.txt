<div class="post-text" itemprop="text">
<p>I am trying to solve a problem where I'm given an array, such as [0, 0, 1, 1, 2, 2, 6, 6, 9, 10, 10] where all numbers are duplicated twice, excluding one number, and I need to return the number that is not duplicated.</p>
<p>I am trying to do it like this:</p>
<pre><code>def findNumber(self, nums):

    if (len(nums) == 1):
        return nums[0]

    nums_copy = nums[:]

    for i in nums:
        nums_copy.remove(i)

        if i not in nums:
            return i
        else:
            nums_copy.remove(i)
</code></pre>
<p>However when it reaches the else statement, there is the following error:</p>
<blockquote>
<p>ValueError: list.remove(x): x not in list</p>
</blockquote>
<p>This is occurring when <code>i</code> is in <code>nums_copy</code>, so I do not understand why this error occurs in this situation?</p>
</div>
<div class="post-text" itemprop="text">
<p>You already <code>nums_copy.remove(i)</code> so you can't <code>nums_copy.remove(i)</code> again</p>
<p>You could do:</p>
<pre><code>a = [0, 0, 1, 1, 2, 2, 6, 6, 9, 10, 10]

def get_single_instance(array):
  d = {}

  for item in a:
    if item not in d:
      d[item] = 1
    else:
      d[item] += 1

  print d

  for k, v in d.iteritems():
    if v == 1:
      return k

print get_single_instance(a)
</code></pre>
<p>Result: 9</p>
</div>
<div class="post-text" itemprop="text">
<p>An easier (and more efficient) way of doing this than your initial approach is with a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> object:</p>
<pre><code> from collections import Counter

 singlet = Counter(nums).most_common()[-1][0]
</code></pre>
<p>The <code>Counter</code> object will create a dictionary-like object with the keys being the values in your list and the values being the number of times they appear. The <code>most_common</code> method will return a list of tuples of <code>(value, count)</code> sorted by count in decreasing order.</p>
<p>If you don't know how many singlets there will be, you can get a list of them with:</p>
<pre><code>[k for k, v in Counter(nums).items() if v == 1]
</code></pre>
<hr/>
<p><strong>Complexity:</strong></p>
<p>I said my top solution was more efficient because your original implementation iterates through your list and for each item calls both <code>remove</code> and <code>in</code> which is going to get you to something like O(n<sup>2</sup>) complexity. In the Counter implementation the construction of the <code>Counter</code> object only does a single pass through the entire list. <s>There is probably a sort going on when <code>most_common</code> is called so I'm guessing the complexity is about O(n log n).</s> @Stefan Pochman has corrected me on this: Python uses the <a href="https://en.wikipedia.org/wiki/Timsort" rel="nofollow noreferrer">Timsort</a> algorithm which will be very efficient in a case like this (if all but one of the numbers appear twice, the list is effectively almost completely sorted already) so its complexity will about about O(n).</p>
</div>
<div class="post-text" itemprop="text">
<p>The best algorithm is to use XOR to find the odd number.</p>
<pre><code>def find_number(nums):
    s = 0 
    for n in nums:
        s ^= n 
    return s 


a = [0, 0, 1, 1, 2, 2, 6, 6, 9, 10, 10] 
print(find_number(a))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this list comprehension. It goes through each element and checks if it is duplicated, and if it isn't, it lets it stay in the new list. It then gets the zeroth element of the new list:</p>
<pre><code>a=[0, 0, 1, 1, 2, 2, 6, 6, 9, 10, 10]
[e for e in a if a.count(e)==1][0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the array is sorted, we can find the answer in <code>O(log n)</code> time and <code>O(1)</code> extra space. Consider that repeated number pairs start on odd or even indexes depending on where the single element is:</p>
<pre><code>              0  1  2  3  4  5  6  7  8  9   10
             [0, 0, 1, 1, 2, 2, 6, 6, 9, 10, 10]
even indexes: x     x     x     x
odd indexes:                             x

search:                      ^  (0 + 11) / 2 = 5
                         [2, 2] pair starting on even index
                                so the singleton must be ahead

                                      ^  (6 + 11) / 2 = 8
                                     [9] singleton found in two steps!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a very long method of doing things.  As suggested you could use <code>nums_copy.remove(i)</code> or you could implement this is a much simpler manner using <a href="https://stackoverflow.com/questions/2600191/how-to-count-the-occurrences-of-a-list-item"><code>count()</code></a>:</p>
<pre><code>def findNumber(self, nums):

    for i in nums:

        val = nums.count(i)

        if val == 1:
            return i
</code></pre>
<p>This will return the single number.  This method is fine as long as you do not have multiple values, if so it will return only the last one. You could otherwise return a list which would store multiple values like so:</p>
<pre><code>def findNumber(self, nums):
    values = []
    for i in nums:

        val = nums.count(i)

        if val == 1:
            values.append(i)

    return values
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming a sorted iterable (otherwise sort it), here is the first occurrence of a non-duplicate pair:</p>
<pre><code>import more_itertools as mit


iterable = [0, 0, 1, 1, 2, 2, 6, 6, 9, 10, 10] 
next(x for x, y in mit.windowed(iterable, n=2, step=2) if x != y)
# 9
</code></pre>
<p>An alternative way to create non-overlapping pairs:</p>
<pre><code>next(x for x, y in mit.sliced(iterable, 2) if x != y)
# 9
</code></pre>
<p><a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> is a third-party library, <code>&gt; pip install more_itertools</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>For anyone working with NumPy, this should be competitive in speed with other answers here:</p>
<pre><code>&gt;&gt;&gt; def get_single_instance_np(arr: np.ndarray):
...     return np.asscalar(arr[np.bincount(arr) == 1])

&gt;&gt;&gt; print(get_single_instance(a))
9
</code></pre>
<p>This just returns elements for which their count equals 1.</p>
</div>
<span class="comment-copy">Lots of weird things happen when you modify a list you're iterating on. Don't do that.</span>
<span class="comment-copy">@MosesKoledoye That's why he's modifying <code>nums_copy</code> instead of <code>nums</code></span>
<span class="comment-copy">@Barmar Oversight, but their membership check is done on the original list, not the copy, so still defeats the purpose of them copying the list anyway.</span>
<span class="comment-copy">So I guess it should be <code>if i not in nums_copy:</code></span>
<span class="comment-copy">Does Python have XOR? If so:use it!</span>
<span class="comment-copy">Would this be O(n) in terms of efficiency?</span>
<span class="comment-copy">@Shannon yes, worst case O(n)</span>
<span class="comment-copy">@MosesKoledoye My reading of the  problem as stated by the OP was that all numbers would be duplicated except for one of which there would be a single instance.</span>
<span class="comment-copy">Ok, fair enough +1</span>
<span class="comment-copy">This gives an error as well "TypeError: 'method' object is not subscriptable". Also, sorry, could you explain what a singlet means? (my English is not great, and I tried searching online)</span>
<span class="comment-copy">I think it would be good if you said how efficient it is.</span>
<span class="comment-copy">Let us <a href="http://chat.stackoverflow.com/rooms/164717/discussion-between-turn-and-stefan-pochmann">continue this discussion in chat</a>.</span>
<span class="comment-copy">Not a good use-case for a list comprehension, and <code>.count</code> will give you polynomial performance in the worst case</span>
<span class="comment-copy">It will, but for small numbers, it is a short option that requires no libraries</span>
<span class="comment-copy">@juanpa.arrivillaga You say "polynomial performance" like that's a bad thing... O(n) is polynomial as well, and optimal.</span>
<span class="comment-copy">@ᴡʜᴀᴄᴋᴀᴍᴀᴅᴏᴏᴅʟᴇ3000 A quick test on my side shows that your solution is faster than my Counter one by about a second or two for lists less than about 20. For longer lists your solution quickly blows up. That's because your complexity is O(n^2) and the Counter is O(n) (creating the dict object happens once and is cheap).</span>
<span class="comment-copy">Thanks for the evaluation and explanation.</span>
<span class="comment-copy">This will work but it is worth noting that it is computationally costly.</span>
