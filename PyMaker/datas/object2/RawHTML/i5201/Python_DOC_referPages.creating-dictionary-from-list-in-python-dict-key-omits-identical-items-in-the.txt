<div class="post-text" itemprop="text">
<p>While creating a dictionary from the list, the keys of the dictionary neglects the identical items in the List and stores the last item as the key.</p>
<p>For example in this:</p>
<pre><code>lst1 = [["Apple",20.00,"Swiss"],
    ["Banana",5.00,"Brazil"],
    ["Strawberry",25.00,"Swiss"],
    ["Pear",12.00,"Greece"],
    ["Mango",3.00,"Peru"],
    ["Avacado",7.00,"Peru"]]

my_dict = {val[2]:val[:2] for val in lst1}

print (my_dict)
</code></pre>
<p>Prints this </p>
<pre><code>{'Swiss': ['Strawberry', 25.0], 'Brazil': ['Banana', 5.0], 'Greece': ['Pear', 12.0], 'Peru': ['Avacado', 7.0]}
</code></pre>
<p>As far as I understand it does so because the keys can't be identical, then why doesn't it group the values of identical keys in to one list. Like this </p>
<pre><code>{
    'Swiss': [["Apple",20.00],['Strawberry', 25.0]],
    'Brazil': ['Banana', 5.0],
    'Greece': ['Pear', 12.0],
    'Peru': [["Mango",3.00],['Avacado', 7.0]]
}
</code></pre>
<p>Is there any way I could do this in pure Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't use a dictionary comprehension for this, that can't know about preceding keys already being present.</p>
<p>You'll have to use a straight-up loop. Add <strong>all</strong> values to a list, not just the repeating ones. Don't mix structures here, that'll only create more headaches later on. If you don't you'll have to detect if you have a nested list or a flat list with one fruit and price later on.</p>
<p>You can use a regular dictionary:</p>
<pre><code>my_dict = {}
for fruit, price, origin in lst1:
    my_dict.setdefault(origin, []).append([fruit, price])
</code></pre>
<p>The <code>dict.setdefault()</code> call adds an empty list to the dictionary if the key (the first argument) is missing. It then returns the value for the given key (which could be an already existing list or the new empty list). The line then call <code>list.append()</code> to add the fruit and price.</p>
<p>Or you can use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict()</code> object</a> to create the empty lists when a key is missing:</p>
<pre><code>from collections import defaultdict

my_dict = defaultdict(list)
for fruit, price, origin in lst1:
    my_dict[origin].append([fruit, price])
</code></pre>
<p>Code using a <code>defaultdict</code> is a little more concise, but the downside is that this object will now continue to produce empty lists for missing keys, even when you perhaps didn't intend to due to a bug in your code.</p>
<p>Both produce the desired result:</p>
<pre><code>&gt;&gt;&gt; my_dict = {}
&gt;&gt;&gt; for fruit, price, origin in lst1:
...     my_dict.setdefault(origin, []).append([fruit, price])
...
&gt;&gt;&gt; my_dict
{'Swiss': [['Apple', 20.0], ['Strawberry', 25.0]], 'Brazil': [['Banana', 5.0]], 'Greece': [['Pear', 12.0]], 'Peru': [['Mango', 3.0], ['Avacado', 7.0]]}
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; my_dict = defaultdict(list)
&gt;&gt;&gt; for fruit, price, origin in lst1:
...     my_dict[origin].append([fruit, price])
...
&gt;&gt;&gt; my_dict
defaultdict(&lt;class 'list'&gt;, {'Swiss': [['Apple', 20.0], ['Strawberry', 25.0]], 'Brazil': [['Banana', 5.0]], 'Greece': [['Pear', 12.0]], 'Peru': [['Mango', 3.0], ['Avacado', 7.0]]})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Those kind of "accumulation" problems cannot be done simply with list comprehensions (or with ugly side effects which impair readability).</p>
<p>You want <code>collections.defaultdict(list)</code> to create a list of couples as values, and country as key:</p>
<pre><code>lst1 = [["Apple",20.00,"Swiss"],
    ["Banana",5.00,"Brazil"],
    ["Strawberry",25.00,"Swiss"],
    ["Pear",12.00,"Greece"],
    ["Mango",3.00,"Peru"],
    ["Avacado",7.00,"Peru"]]

result = collections.defaultdict(list)

for fruit,price,country in lst1:
    result[country].append([fruit,price])

print(dict(result))  # convert to dict for a cleaner representation when printing
</code></pre>
<p>result:</p>
<pre><code>{'Swiss': [['Apple', 20.0], ['Strawberry', 25.0]], 'Brazil': [['Banana', 5.0]], 'Greece': [['Pear', 12.0]], 'Peru': [['Mango', 3.0], ['Avacado', 7.0]]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As far as I am aware, this can't be done in a <code>comprehension</code>, but you can use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>setdefault</code></a> to make every 2nd element of each list in <code>lst1</code> a <code>key</code> in a <code>dictionary</code> which you can then immediately <code>append</code> the slice up to it (as you were doing). The neatness of <code>setdefault</code> is that we can <em>append</em> to a <code>key</code> if it is already there, or create that <code>key</code> and <em>then append</em> if it is not. Both actions being done without an <code>if-statement</code>.</p>
<pre><code>d = {}
for l in lst1:
    d.setdefault(l[2], []).append(l[:2])
</code></pre>
<p>giving:</p>
<pre><code>{'Brazil': [['Banana', 5.0]],
 'Greece': [['Pear', 12.0]],
 'Swiss': [['Apple', 20.0], ['Strawberry', 25.0]],
 'Peru': [['Mango', 3.0], ['Avacado', 7.0]]}
</code></pre>
</div>
<span class="comment-copy">Your output is incorrect, use <code>.append(l[:2])</code>.</span>
<span class="comment-copy">@MartijnPieters My bad! I just mimicked the slicing that was used in the question. Strange though, as using the <code>[:1]</code> slicing (as the OP did), doesn't yield the output they claim :/</span>
<span class="comment-copy">They just corrected their question, as I was about to point this out in a comment. :-)</span>
<span class="comment-copy">@JoeIddon Sorry, didnt notice while pasting it.</span>
<span class="comment-copy">@Raja No problem, please remember to accept someone's answer for future visitor</span>
