<div class="post-text" itemprop="text">
<p>When referencing global variables, one can see that functions and classes handle this differently. The first is fine and the second causes an error:</p>
<pre><code>x = 10
class Foo():
    x = x + 1
a = foo()
</code></pre>
<p>Vs:</p>
<pre><code>x = 10
def faa():
    x = x + 1
faa()
</code></pre>
<p>In the  <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">Python execution model</a>, this is described as:</p>
<blockquote>
<p>A class definition is an executable statement that may use and define
  names. These references follow the normal rules for name resolution
  with an exception that unbound local variables are looked up in the
  global namespace.</p>
</blockquote>
<p>But why? </p>
<p>The only other hint I have come across is <a href="https://docs.python.org/2.7/reference/compound_stmts.html#class-definitions" rel="nofollow noreferrer">this bit</a>:</p>
<blockquote>
<p>The class’s suite is then executed in a new execution frame (see
  section Naming and binding), using a newly created local namespace and
  the original global namespace. (Usually, the suite contains only
  function definitions.) When the class’s suite finishes execution, its
  execution frame is discarded but its local namespace is saved. <a href="https://stackoverflow.com/questions/13905741/accessing-class-variables-from-a-list-comprehension-in-the-class-definition#13913933">4</a> A
  class object is then created using the inheritance list for the base
  classes and the saved local namespace for the attribute dictionary.</p>
</blockquote>
<p>Which still offers no explanation why this should have the consequence that unbound locals are looked up in the global namespace. </p>
<p>Both links are from <a href="https://stackoverflow.com/questions/13905741/accessing-class-variables-from-a-list-comprehension-in-the-class-definition#13913933">this answer</a> which does not adress the why in more details though. </p>
</div>
<div class="post-text" itemprop="text">
<p>As explained in <a href="https://docs.python.org/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" rel="nofollow noreferrer">Python FAQ - Why am I getting an UnboundLocalError?</a></p>
<blockquote>
<p><em>... because when you make an assignment to a variable in a scope, that variable becomes local to that scope and shadows any similarly named variable in the outer scope. Since the last statement in foo assigns a new value to x, the compiler recognizes it as a local variable.</em></p>
</blockquote>
<p>Consequently when earlier attempting to access the uninitialized local variable an error results.</p>
<p>This explains why this:</p>
<pre><code>x = 10
def foo():
    x = x+1  # raises UnboundLocalError
foo()
</code></pre>
<p>raises an Exception, but not this:</p>
<pre><code>x = 10
def faa():
    y = x+1  # x stays in global scope, since it is not assigned in local
faa()
</code></pre>
<hr/>
<p>For the <code>class foo()</code> it's the same, since python allows assignments of attributes to objects to any given time. The class-code assigns <code>x</code> as new attribute of the object <code>a</code>.</p>
<pre><code>x = 10
class foo():
    x = x+1  # scope of x: class
a = foo()  # x = 10; a.x = foo.x = 11
</code></pre>
<p>is the same as:</p>
<pre><code>x = 10
class foo():
    def __init__(self):
        self.x = x+1  # scope of x: instance
a = foo()  # x = 10; a.x = 11
</code></pre>
<p>where obviously <code>self.x</code> is assigned instead of <code>x</code>, therefore also staying in global scope. (see also <a href="http://blog.lerner.co.il/python-attributes/" rel="nofollow noreferrer">here</a>)</p>
</div>
<span class="comment-copy">I would not think so, at least my question in not answered there. That question relates to public and private and is broadly formulated at that.</span>
<span class="comment-copy">If you have any suggestions on how to clarify muy question I would be glab about them though.</span>
<span class="comment-copy">See <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">here</a>: " A class definition is an executable statement that may use and define names. These references follow the normal rules for name resolution with an exception that unbound local variables are looked up in the global namespace." and some more information at <a href="https://stackoverflow.com/questions/291978/short-description-of-the-scoping-rules" title="short description of the scoping rules">stackoverflow.com/questions/291978/…</a> (Python3 answer here: <a href="https://stackoverflow.com/a/23471004/92092">stackoverflow.com/a/23471004/92092</a>)</span>
<span class="comment-copy">@pindakaas in particular, look at <a href="https://stackoverflow.com/a/23471004/5014455">this</a> answer instead of the accepted one for an understanding of the special nature of class body scope in Python's scoping rules.</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/13905741/accessing-class-variables-from-a-list-comprehension-in-the-class-definition">this question</a> about another suprising aspect of class body scope, which goes into a lot of details. One takeaway from that superb answer: "Because the scope is repurposed as the attributes on a class object, allowing it to be used as a scope as well leads to undefined behaviour... Python has to treat a class scope differently as it is very different from a function scope."</span>
<span class="comment-copy">Sorry but this just restates what I already know. also you may want to look at foo.x this is a variable local to foo that shadows the global variable x. So no a.x is not assigned to the local space of a. a looks it up in foo.</span>
<span class="comment-copy">python is indeed assigning a.x as 11! Therefore no <code>local x</code> is used, since the target is the lokal space of the class, therefore again python is looking in global space for the unknown value. In your function you are assigning x as <code>local</code> when assigning a value to it, since you dont use any keywords, resulting in python using it in in local space instead of shadowing it from global. The function would work if you would assing <code>x+1</code> to a different var. Thanks for the quick downvote btw.</span>
<span class="comment-copy">was not me. But again look at a.__dict__ you will see there is no x in there a looks it up in foo.x.</span>
<span class="comment-copy">thats interesting, <code>print(a.x)</code> shows me 11, while <code>a.__dict__</code> is showns as empty (tested in python2.7 and 3.6)</span>
<span class="comment-copy"><a href="http://blog.lerner.co.il/python-attributes/" rel="nofollow noreferrer">blog.lerner.co.il/python-attributes</a> this post is quite good about this</span>
