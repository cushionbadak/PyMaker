<div class="post-text" itemprop="text">
<p>Need help for a task. I should to sum even numbers not equal to each other, for example I have a list of ints like <code>[1, 3, 2, 2, 4]</code> the output should be <code>6</code>, and if a list all numbers are the same it should sum only 2 numbers, for instance <code>[2, 2, 2, 2]</code> it should print out <code>4</code> but I don't understand how to check the equality of the numbers in a loop:</p>
<pre><code>a = [int(x) for x in input().split()]

for i in a:
        if i % 2 == 0:
            summ += i
        elif i == i:
            continue
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are many methods , Here are two methods :</p>
<p>First one , using dict , dict key can't be same so just assign the value as keys in dict and it will be unique :</p>
<pre><code>output={j:i for i,j in enumerate(data) if j%2==0}
</code></pre>
<p>And then just boolean condition :</p>
<pre><code>print([sum(output),sum(list(map(lambda x:x+x,output)))][len(output)==1])
</code></pre>
<p>How does this condition work?</p>
<p>booleans are a subclass of int , so [len(output)==1] produce a integer value but ['false','true'] takes it as index value.</p>
<p>output:</p>
<pre><code>6
</code></pre>
<p>If same values as you said then you want two number sum in this condition:</p>
<pre><code>data=[2,2,2,2]
</code></pre>
<p>output:</p>
<pre><code>4 
</code></pre>
<p>Second one using the set:</p>
<pre><code>data=[4,4,4,4]

def even_(data):
    sum_data=[]
    for i in data:
        if i%2==0:
            sum_data.append(i)
    if len(set(sum_data)) == 1:
        return list(map(lambda x: x + x, set(sum_data)))[0]
    else:
        return sum(set(sum_data))

print(even_(data))
</code></pre>
<p>output:</p>
<pre><code>6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't use a loop to check for duplicates. Instead, <a href="https://docs.python.org/3.5/library/functions.html#sum" rel="nofollow noreferrer"><code>sum</code></a> the numbers after putting them into a <a href="https://docs.python.org/3.5/library/functions.html#func-set" rel="nofollow noreferrer"><code>set</code></a>.</p>
<pre><code>&gt;&gt;&gt; lst = [1, 3, 2, 2, 4]
&gt;&gt;&gt; sum(x for x in set(lst) if x % 2 == 0)
6
</code></pre>
<p>If you only want to filter out consecutive equal numbers, you could "collapse" those ranges with <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>&gt;&gt;&gt; lst = [1, 3, 2, 2, 4, 2]
&gt;&gt;&gt; sum(k for k, g in itertools.groupby(lst) if k % 2 == 0)
8  # last 2 after 4 is counted
</code></pre>
<hr/>
<blockquote>
<p>and if a list all numbers are the same it should sum only 2 numbers</p>
</blockquote>
<p>I still believe this to be a misunderstanding of the task or a mistake in the given example, but if this is <em>really</em> the desired behaviour, you can, again, convert the list to a set and see if the set has only one element, and in this case take the sum times two.</p>
<pre><code>&gt;&gt;&gt; lst = [2, 2, 2, 2]
&gt;&gt;&gt; sum(x for x in set(lst) if x % 2 == 0) * (2 if len(set(lst)) == 1 else 1)
4
&gt;&gt;&gt; lst = [1, 3, 2, 2, 4]
&gt;&gt;&gt; sum(x for x in set(lst) if x % 2 == 0) * (2 if len(set(lst)) == 1 else 1)
6
</code></pre>
<p>The first part of this expression is the same as above, and the second part is a ternary that returns the factor 1 or 2 depending on the size of the set.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have missed this part of your question:</p>
<blockquote>
<p>if a list all numbers are the same it should sum only 2 numbers, for
  instance [2, 2, 2, 2] it should print out 4</p>
</blockquote>
<p>To do that you can simply add an if else structure such as:</p>
<pre><code>if len(set(a))==1 and not a[0]%2:
    print(a[0]*2)
else: 
    pass
    #any approach below
</code></pre>
<p>Try to use amazint Python data structures =) </p>
<p>In my example I have created a set of numbers so that we can sum up only unique values.</p>
<pre><code>a = [int(x) for x in input().split()]
print(sum({num for num in a if not num%2}))
</code></pre>
<p>Also hidden conversion to bool is used in <code>if not num%2</code> </p>
<p>In addition you cat use more clear solution. Little bit improved version of your answer:</p>
<pre><code>a = [int(x) for x in input().split()]
summ=0
filt_set = set()
for num in a:
    if not num%2 and num not in filt_set:
        filt_set.add(num)
        summ+=num
print(summ)
</code></pre>
<p>It uses set as more effective data structure then a list when we talk about searching an element. Also it sums elements at the same time with adding them to the set.</p>
<p>During the discussion in comments I realized that you may need a code to sum up only non-duplicated numbers, not unique ones. I suggest to use functional Python features:</p>
<pre><code>from collections import Counter

summ = sum(map(lambda x: x[0]
        ,filter(lambda x:x[1]==1 
                ,Counter(a).items())))

print(summ)
</code></pre>
<p>So that here for <code>a = [1, 3, 2, 2, 4]</code> we will get 1+3+4 = 8.</p>
<p>Also you can achieve it in a more traditional way:</p>
<pre><code>elt_set = set() # a set to keep info about elements
res_set = set() # a set that we will sum up

for e in a:
# if the element happens for the first time, add it to the res_set
if e not in elt_set:
    res_set.add(e)
else if e in res_set:
# if it has been already seen before, remove it from the res_set
    res_set.remove(e)
elt_set.add(e)

print(sum(res_set))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What I would do is :</p>
<pre><code>lst = [1, 3, 2, 2, 4]

exists = []
total = 0
for nb in lst:
    # if nb is even AND has not been used yet...
    if nb % 2 == 0 and nb not in exists:
        total += nb
        # check the nb as used.
        exists.append(nb)
</code></pre>
</div>
<span class="comment-copy">This code also doesn't work with a list with the same numbers.</span>
<span class="comment-copy">@Bootuz I didn't see that second case, fixed it, Now check.</span>
<span class="comment-copy">yep, that's what I needed! thank you!</span>
<span class="comment-copy">I'm inclined to -1 just for use of "boolean indexing" instead of using a ternary <code>... if ... else ...</code>. And why do you use a dict instead of the much-simpler set, and why <code>map</code> each <code>x</code> to <code>x+x</code> instead of just multiplying the sum with 2?</span>
<span class="comment-copy">it won't work if I'll have a list with numbers all equal like <code>[2, 2, 2]</code></span>
<span class="comment-copy">@Bootuz Why not? What's the expected sum then?</span>
<span class="comment-copy">the expected sum is 4</span>
<span class="comment-copy">@Bootuz That does not make any sense. I'd assume that there is a mistake in the assignment. You might ask your advisor or whomever you got that task from. Or do <i>you</i> have any explanation <i>why</i> it should give 4 in this case?</span>
<span class="comment-copy">@Bootuz Well, whatever, see my edit.</span>
<span class="comment-copy">it doesn't work if a list contains all numbers equal to each other, for example [2, 2, 2, 2] your code prints out 2, but by the condition of the task it should be 4.</span>
<span class="comment-copy">@Bootuz it should be equal to 2 if you need to sum up unique numbers or 0 if you need to sum numbers that have no duplicates in a series. How can you obtain 4?</span>
<span class="comment-copy">Nice idea, using <code>Counter</code>, but IMHO would be more readable using a comprehension instead of <code>map</code> and <code>filter</code>: <code>sum(x for x, c in Counter(a).items() if c == 1)</code></span>
<span class="comment-copy">Agree. I also like comprehensions more then functional tools =) I will work as well.</span>
