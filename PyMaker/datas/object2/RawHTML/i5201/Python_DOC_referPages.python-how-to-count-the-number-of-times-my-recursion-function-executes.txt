<div class="post-text" itemprop="text">
<p>Suppose I have a binary search tree <code>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]</code></p>
<p>If I run the following function, I want to know how many times the recursion function executes(in the following example, it is 31)</p>
<pre><code>def loopBST(root):
    if not root:
        return
    loopBST(root.left)
    loopBST(root.right)
</code></pre>
<p>I can get this by create a global variable</p>
<pre><code>global ind 
ind = 0
def loopBST(root):
    global ind
    ind += 1
    if not root:
        return
    loopBST(root.left)
    loopBST(root.right)
loopBST(bsttree)
</code></pre>
<p>The variable <code>ind</code> will be 31.</p>
<p>The question is, how can I make this <code>ind</code>inside the <code>dfs</code> function rather than creating the global variable?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a parameter.</p>
<pre><code>def loopBST(root, times=0):
    times += 1
    if not root:
        return times
    times = loopBST(root.left, times=times)
    times = loopBST(root.right, times=times)
    return times
loopBST(bsttree)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could <em>return</em> the number of executions:</p>
<pre><code>def loopBST(root):
    if not root:
        return 1
    return 1 + loopBST(root.left) + loopBST(root.right)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to rewrite your recursive function, you could also decorate it in a function that counts it using a counter of some sort. Example of an implementation:</p>
<p><strong>UPDATE:</strong> I've changed the answer, but the old answer is kept at the end of the answer <strong>//UPDATE</strong></p>
<p>Assume here that you have some recursion functions in some_module.py:</p>
<pre><code># From some_module.py
def factorial(x):
    return factorial(x-1)*x if x &gt; 1 else 1

def cumsum(x):
    return cumsum(x-1) + x if x &gt; 1 else 1

def loopBST(root):
    # ... your code
</code></pre>
<p>And you want to apply the decorator to count how many recursions ran. Here, the code is performed inside <code>some_function()</code> to show that you don't have to keep the count variable(s) in the global scope. (See comments) (Also, the recursive functions are still in global space)</p>
<pre><code># Main file:
from functools import wraps, partial
from collections import defaultdict
# import the two recursion functions from some_module.py
from some_module import cumsum, factorial, loopBST


def some_function():
    global factorial, cumsum, loopBST

    def counting_recursion(fn, counter):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            counter[fn.__name__] += 1
            return fn(*args, **kwargs)
        return wrapper

    counters = defaultdict(int)

    my_deco = partial(counting_recursion, counter=counters)
    factorial = my_deco(factorial)
    cumsum = my_deco(cumsum)
    loopBST = my_deco(loopBST)

    print(factorial(3))
    # 6
    print(cumsum(5))
    # 15

    factorial_count = counters[factorial.__name__]
    cumsum_count = counters[cumsum.__name__]
    loopBST_count = counters[loopBST.__name__]  # Equals 0: were not called in my example

    print('The "{}" function ran {} times'.format(factorial.__name__, factorial_count))
    print('The "{}" function ran {} times'.format(cumsum.__name__, cumsum_count))
    # The "factorial" function ran 3 times
    # The "cumsum" function ran 5 times
</code></pre>
<p>A few modifications/variations:</p>
<p>Instead of using <code>my_deco = partial(counting_recursion, counter=counters)</code>, the recursive functions could be decorated directly:</p>
<pre><code>cumsum = counting_recursion(cumsum, counter=counters)
factorial = counting_recursion(factorial, counter=counters)
loopBST = counting_recursion(loopBST, counter=counters)
</code></pre>
<p>Instead of using <code>fn.__name__</code> to identify the called function, the <code>counting_recursion</code>-function could be rewritten as:</p>
<pre><code>def counting_recursion(fn, counter):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        counter[wrapper] += 1
        return fn(*args, **kwargs)
    return wrapper
</code></pre>
<p>Then, to read the number from the <code>counters</code> dictionary:</p>
<pre><code>factorial_count = counters[factorial]
cumsum_count = counters[cumsum]
loopBST_count = counters[loopBST]
</code></pre>
<p>If you want to read more about wrapping functions, check out <a href="https://stackoverflow.com/a/25827070/1144382">https://stackoverflow.com/a/25827070/1144382</a> and the docs on <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer">wraps</a></p>
<p><strong>OLD EXAMPLE:</strong></p>
<pre><code>from functools import wraps, partial

class Counter:
    def __init__(self, start_count=0):
        self._counter = start_count

    def __repr__(self):
        return str(self._counter)

    def count(self):
        self._counter += 1

counter = Counter()

def counting_recursion(fn, counter):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        counter.count()
        return fn(*args, **kwargs)
    return wrapper

my_deco = partial(counting_recursion, counter=counter)

@my_deco
def factorial(x):
    return factorial(x-1)*x if x &gt; 1 else 1

print(factorial(3))
# 6

print('The {} function ran {} times'.format(factorial.__name__, counter))
# The factorial function ran 3 times
</code></pre>
<p>To implement this in your case, just make some counter and decorate your function:</p>
<pre><code>@my_deco
def loopBST(root):
    # ...

print(counter._counter)
# prints number of counts
</code></pre>
<p>Of course, you don't have to make a <code>Counter</code>-class to call <code>counter.count()</code> on, you could also have a dictionary of counters, e.g. <code>counts[loopBST] += 1</code> or just an array with a single element <code>count_list[0] += 1</code>. (<em>see the code example at top of this answer</em>) (The entire point is to "hide" the value in a reference that is not rewritten when the variable is reassigned, which is why just an integer count <code>count += 1</code> won't work.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you can try with instance of a class, this way it probably is cleaner than having keyword argument. Not to mention that you can store additional data in instance.</p>
<p>This is a Python 2.7 class.</p>
<pre><code>class LoopBST(object):

    def __init__(self):
        self.ind = 0

    def __call__(self, root):
        self.ind += 1

        if not root:
            return

        self(root.left)
        self(root.right)

loopBST = LoopBST()

loopBST(bstree)

print loopBST.ind
</code></pre>
</div>
<span class="comment-copy">Can you please use codeblock formatting? Do four spaces of indentation for every line you have code and it will look a lot cleaner.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/1301735/counting-python-method-calls-within-another-method">Counting python method calls within another method</a></span>
<span class="comment-copy"><a href="https://wiki.python.org/moin/PythonDecoratorLibrary#Counting_function_calls" rel="nofollow noreferrer">Counting function calls</a></span>
<span class="comment-copy">No problem! I missed something too; I forgot to return <code>times</code> at the end of the function. Edited.</span>
<span class="comment-copy">Oh, good, so I was somewhat right after all :-P. I wish they had provided usable testing data instead of an unclear list, then none of this would've happened...</span>
<span class="comment-copy">Thanks Stefan. I see you from leetcode. In fact this question is from the question I am practicing in leetcode. I know I can solve this by put the dfs inside a <code>class</code> and set up a <code>global count variable</code> inside the <code>class</code> to finish this job.   I am wondering if there is any way I can put that count variable as a parameter of the <code>dfs</code> function. Can I do this in the recursion fuction? I can create a <code>dfs</code> parameter  called <code>temp</code> list and append a value to that <code>temp</code> list once there is a recursion run.</span>
<span class="comment-copy">Which question is it there? I don't think leetcode ever asked to count function calls...</span>
<span class="comment-copy">for example, q230. to return kth smallest of bst. You have fancy way to solve it. I try to start from stupid way: goes to the left lowest leaf, and then goes up, if I goes up k(my i==k), I will get the answer. My stupid code is like <code>def kthsmall2(root, k):     if not root:         return     def dfs(node, i, k):         i += 1         if not node:             return         dfs(node.left, i, k)         if i == k:             return node.val         dfs(node.right, i, k)         return i     print dfs(root, 0, k)</code></span>
<span class="comment-copy">I like this solution with decorator. It might be a good idea to modify the decorator so that we can avoid the global variable for the empty dictionary and may be importing the partial function</span>
<span class="comment-copy">I see, thanks for follow up, I will update my answer when I get back to my computer.</span>
<span class="comment-copy">I've updated the ansswer</span>
<span class="comment-copy">Encapsuling such simple task like this inside a class doesn't seem to be a very pythonic way.</span>
