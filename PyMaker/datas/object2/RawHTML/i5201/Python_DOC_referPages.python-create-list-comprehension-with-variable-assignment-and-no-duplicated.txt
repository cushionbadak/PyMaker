<div class="post-text" itemprop="text">
<p>I'm looping over a function in my script which returns list of lists, for example in the first iteration I'm getting the following list of lists:</p>
<pre><code>list1 = [['Farm05', 'Red Hat Enterprise Linux, Standard', 1], ['Farm05', 'Red Hat Enterprise Linux, Standard', 1], ['Farm05', 'Red Hat Enterprise Linux, Standard', 1], ['Farm05', 'Red Hat Enterprise Linux, Premium', 1], ['Farm05', 'Red Hat nterprise Linux,Premium', 1]]
</code></pre>
<p>What I want to get is a list with distinct items, and summary of numbers for each subscriptions, i.e for standard list = 1+1 =2  for premium list 1+1=2</p>
<pre><code>list2 = ['Farm05','Red Hat Enterprise Linux, Standard',2]
list3 = ['Farm05','Red Hat Enterprise Linux, Premium',2]
</code></pre>
<p>I have tried this approach, but it's not removing the duplicates and it doesn't look clean. How can I achieve it with list comprehentions?</p>
<pre><code>new_list = []
    for i in Farm:
        farm = i[0]
        subscription = i[1]
        count = i[2]
        count += count
        if farm not in list1 or subscription not in list1 or count  not in list1:
            new_list.extend(farm,subscription,count)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you need is <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code> from <code>itertools</code></a>. And here is how you can use it:</p>
<pre><code>from itertools import groupby    

res = [[*i, sum(k[-1] for k in g)] for i, g in groupby(list1, key=lambda x: x[:-1])]
</code></pre>
<p>which for the example input you provided<sup>1</sup> prints:</p>
<pre><code>[['Farm05', 'Red Hat Enterprise Linux, Standard', 3], ['Farm05', 'Red Hat Enterprise Linux, Premium', 2]]
</code></pre>
<hr/>
<p><sup>1</sup><em>The input had to be corrected; it contained typos.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>Using a list comprehension to all you need probably won't make it very readable.</p>
<p>A cleaner way to do it would be:</p>
<pre><code>from collections import defaultdict

list1 = [['Farm05', 'Red Hat Enterprise Linux, Standard', 1], 
         ['Farm05', 'Red Hat Enterprise Linux, Standard', 1], 
         ['Farm05', 'Red Hat Enterprise Linux, Standard', 1], 
         ['Farm05', 'Red Hat Enterprise Linux, Premium', 1], 
         ['Farm05', 'Red Hat Enterprise Linux, Premium', 1]]

# We create a dict whose keys will be (farm, subscription) tuples, 
# and whose default values will be 0
summary = defaultdict(int)

for elt in list1:
    farm, sub, count = elt
    summary[(farm, sub)] += count

print(summary)
#   defaultdict(&lt;class 'int'&gt;, {('Farm05', 'Red Hat Enterprise Linux, Standard'): 3, 
# ('Farm05', 'Red Hat Enterprise Linux, Premium'): 2})


print(summary[('Farm05', 'Red Hat Enterprise Linux, Standard')])
# 3
</code></pre>
<p>If you really want a list in the format of your question:</p>
<pre><code>out = [[key[0], key[1], total] for  key, total in summary.items()]
print(out)
# [['Farm05', 'Red Hat Enterprise Linux, Standard', 3], 
# ['Farm05', 'Red Hat Enterprise Linux, Premium', 2]]
</code></pre>
<p>It would be even nicer with a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collections.Counter</a>:</p>
<pre><code>from collections import Counter

counts = Counter()
for elt in list1:
    farm, sub, count = elt
    counts.update({(farm, sub): count})

print(counts)
# Counter({('Farm05', 'Red Hat Enterprise Linux, Standard'): 3, ('Farm05', 'Red Hat Enterprise Linux, Premium'): 2})

print(counts.most_common(1))
# [(('Farm05', 'Red Hat Enterprise Linux, Standard'), 3)]

# and you can get the output in the format of the question just as before, with:
out = [[key[0], key[1], total] for  key, total in counts.items()]
print(out)
# [['Farm05', 'Red Hat Enterprise Linux, Standard', 3], ['Farm05', 'Red Hat Enterprise Linux, Premium', 2]]      
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here a way to do this with a dictionairy:</p>
<pre><code>list1 = [['Farm05', 'Red Hat Enterprise Linux, Standard', 1], ['Farm05', 'Red Hat Enterprise Linux, Standard', 1], ['Farm05', 'Red Hat Enterprise Linux, Standard', 1], ['Farm05', 'Red Hat Enterprise Linux, Premium', 1], ['Farm05', 'Red Hat nterprise Linux,Premium', 1]]
result = {}

for e in list1:
    index = ', '.join([e[0].strip(), e[1].strip()])
    if index in result:
        result[index] = result[index] + e[2]
    else:
        result[index] = e[2]

# do something with the result
for i, v  in enumerate(result):
    print(i, v, result[v])
</code></pre>
<p>output:</p>
<pre><code>0 Farm05, Red Hat Enterprise Linux, Standard 3
1 Farm05, Red Hat Enterprise Linux, Premium 1
2 Farm05, Red Hat nterprise Linux,Premium 1
</code></pre>
<p>NOTE: the input <code>list1</code> is likely to contain two typo's in the OP's original question, this is why the output is showing like this. The typo's are likely in the last element "<code>['Farm05', 'Red Hat nterprise Linux,Premium', 1]</code>"</p>
<ul>
<li>First Typo is likely to be "nterprise" and should be "Enterprise"</li>
<li>Second Typo is likely the missing space after the comma </li>
</ul>
<p>You should either write code to 'catch' typo's on the input, or fix the input</p>
</div>
<span class="comment-copy">You mean it is same for all but the last items?</span>
<span class="comment-copy">you seem to have 3 <i>standard</i> subscriptions</span>
<span class="comment-copy">besides 3 standard subscriptions you have on 1 "Enterprise"... the other is "nterprise"</span>
<span class="comment-copy">I like the <code>groupby</code> idea, though it would fail if the identical (farm, subscription) aren't grouped in the original data - which maybe is the case, the OP didn't tell us. Also, the <code>*i</code> syntax as used here is only valid from Python 3.5 on. The alternative for older versions would be <code>i[0], i[1]</code>.</span>
