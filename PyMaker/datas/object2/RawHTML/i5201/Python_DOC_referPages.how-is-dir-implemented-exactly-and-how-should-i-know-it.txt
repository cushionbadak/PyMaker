<div class="post-text" itemprop="text">
<p>So I'm trying to know the details of <code>dir()</code> function. First I looked at the implementation of it:
<a href="https://github.com/python/cpython/blob/e76daebc0c8afa3981a4c5a8b54537f756e805de/Objects/object.c#L1450-L1477" rel="nofollow noreferrer">https://github.com/python/cpython/blob/e76daebc0c8afa3981a4c5a8b54537f756e805de/Objects/object.c#L1450-L1477</a></p>
<pre class="lang-c prettyprint-override"><code>/* Helper for PyObject_Dir: object introspection. */
static PyObject *
_dir_object(PyObject *obj)
{
    PyObject *result, *sorted;
    PyObject *dirfunc = _PyObject_LookupSpecial(obj, &amp;PyId___dir__);

    assert(obj);
    if (dirfunc == NULL) {
        if (!PyErr_Occurred())
            PyErr_SetString(PyExc_TypeError, "object does not provide __dir__");
        return NULL;
    }
    /* use __dir__ */
    result = _PyObject_CallNoArg(dirfunc);
    Py_DECREF(dirfunc);
    if (result == NULL)
        return NULL;
    /* return sorted(result) */
    sorted = PySequence_List(result);
    Py_DECREF(result);
    if (sorted == NULL)
        return NULL;
    if (PyList_Sort(sorted)) {
        Py_DECREF(sorted);
        return NULL;
    }
    return sorted;
}
</code></pre>
<p>And found that the <code>_dir_object</code> function doesn't do any work itself, but invokes the <code>__dir__</code> method of the introspected object. </p>
<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; def test(): pass
&gt;&gt;&gt; test.__dir__
&lt;built-in method __dir__ of function object at 0x10ee57ae8&gt;
</code></pre>
<p>So how to know the implementation of it?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__dir__</code> is a <em>special method</em>, so looked up on the type, at least in Python 3:</p>
<pre><code>&gt;&gt;&gt; type(test)
&lt;class 'function'&gt;
&gt;&gt;&gt; '__dir__' in dir(type(test))
True
&gt;&gt;&gt; type(test).__dir__
&lt;method '__dir__' of 'object' objects&gt;
&gt;&gt;&gt; dir(test) == sorted(type(test).__dir__(test))
True
</code></pre>
<p>See the <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer"><em>Special method lookup</em> section</a> of the datamodel:</p>
<blockquote>
<p>For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary.</p>
</blockquote>
<p>This is exactly what the <code>_PyObject_LookupSpecial()</code> function does, see <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c#L1409-L1438" rel="nofollow noreferrer">the <code>typeobject.c</code> source code</a>:</p>
<pre class="lang-c prettyprint-override"><code>res = _PyType_LookupId(Py_TYPE(self), attrid);
</code></pre>
<p>The <code>Py_TYPE()</code> call there is the important part, <code>__dir__</code> is looked up on the <em>type</em>.</p>
<p>The <code>__dir__</code> method is implemented on the <code>object</code> type and inherited by the function type, so the implementation is in the <a href="https://github.com/python/cpython/blob/v3.6.4/Objects/typeobject.c#L4469-L4514" rel="nofollow noreferrer"><code>object_dir()</code> function</a>.</p>
<p>For Python 2, the <a href="https://github.com/python/cpython/blob/v2.7.14/Objects/object.c#L1908-L1961" rel="nofollow noreferrer"><code>dir()</code> implementation is more elaborate</a>, and actually also delegates to other functions! For function objects, it delegates to the <a href="https://github.com/python/cpython/blob/v2.7.14/Objects/object.c#L1852-L1906" rel="nofollow noreferrer"><code>_generic_dir()</code> function</a>. This function consults the <code>__dict__</code> of the type:</p>
<pre class="lang-c prettyprint-override"><code>/* Merge in attrs reachable from its class. */
itsclass = PyObject_GetAttrString(obj, "__class__");
if (itsclass == NULL)
    /* XXX(tomer): Perhaps fall back to obj-&gt;ob_type if no
                   __class__ exists? */
    PyErr_Clear();
else {
    if (merge_class_dict(dict, itsclass) != 0)
        goto error;
}
</code></pre>
<p>where <a href="https://github.com/python/cpython/blob/v2.7.14/Objects/object.c#L1680-L1737" rel="nofollow noreferrer"><code>merge_class_dict()</code></a> recursively incorporates the class hierarchy attributes into the final result.</p>
</div>
<div class="post-text" itemprop="text">
<p>The code you're looking at is from a recent Python version, but you're testing on an old version.</p>
<p>In the new version, an implementation <code>__dir__</code> is automatically provided on all types.</p>
<p>In the old version, objects do not have <code>__dir__</code> unless it is manually provided. The implementation then takes this into account in <code>_dir_object</code>. This is from Python 2.7: </p>
<pre><code>if (dirfunc == NULL) {
    /* use default implementation */
    if (PyModule_Check(obj))
        result = _specialized_dir_module(obj);
    else if (PyType_Check(obj) || PyClass_Check(obj))
        result = _specialized_dir_type(obj);
    else
        result = _generic_dir(obj);
}
</code></pre>
<p>For the implementation of <code>object.__dir__</code> in Python 3, see <a href="https://github.com/python/cpython/blob/07ca9afaa8768b44baf816b4998d209ed3e0088f/Objects/typeobject.c#L4653" rel="nofollow noreferrer"><code>object___dir___impl</code></a> in Objects/typeobject.c.</p>
</div>
<span class="comment-copy">On Python 3.6 I do get <code>__dir__</code> among the members listed. I guess you're testing on an older version which didn't always have it defined. You should test on a version matching the code you're examining.</span>
<span class="comment-copy">@interjay: right, in Python 2, the <code>__getattribute__</code> method for functions doesn't consider the type when looking up attributes directly on the function object.</span>
<span class="comment-copy">You appear to be using Python 2 to test, but are looking at the Python 3 source code. Know that they differ materially!</span>
<span class="comment-copy"><code>test.__dir__</code> should work even if <code>__dir__</code> is defined on the type. I think OP is testing on an old Python version.</span>
<span class="comment-copy">What wouldn't work is that if you define <code>__dir__</code> on a specific instance, it wouldn't be called by <code>dir</code>. But <code>test.__dir__</code> should work in any case because it looks up in the type after trying the instance..</span>
<span class="comment-copy">I think @MartijnPieters has misunderstood @interjay. I think the implication is that <code>assert hasattr(type(obj), "__dir__")</code> implies <code>assert hasattr(obj, "__dir__")</code>. And is refering to the attribute error that OP has mentioned.</span>
<span class="comment-copy">@Dunes: Right, yes, in Python 3.6 <code>test.__dir__</code> works because it is found on <code>type(test)</code>.</span>
<span class="comment-copy">It seems like OP is running 2.7 or earlier where even <code>type(test).__dir__</code> results in an attribute error.</span>
<span class="comment-copy">Old vs new meaning 2.x vs 3.x?</span>
<span class="comment-copy">@Piinthesky I don't know if the new mechanism was added in 3.0 or later, but it seems likely that it's a 3.0 change.</span>
