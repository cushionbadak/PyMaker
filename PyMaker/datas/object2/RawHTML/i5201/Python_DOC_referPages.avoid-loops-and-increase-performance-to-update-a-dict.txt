<div class="post-text" itemprop="text">
<p>I have a dict of the form:</p>
<blockquote>
<p>dict1[element1] : reference1</p>
<p>dict1[element2] : reference2</p>
<p>dict1[element3] : reference2</p>
</blockquote>
<p>There a some elements have the same reference (like <code>element2</code> and <code>element3</code> have).
I need to convert this into a dict with the following form:</p>
<blockquote>
<p>dict2[reference1] : [element1]</p>
<p>dict2[reference2] : [element2,element3]</p>
</blockquote>
<p>To get this I wrote:</p>
<pre><code>dict2=dict()
for key in dict1:
    UpdateDict(dict2,dict1[key],key)

def UpdateDict(Dict,Key,Entry):
    Keys = list(Dict.keys())
    if Key in Keys:
        Dict[Key].append(Entry)
        return
    else:
        Item = list()
        Item.append(Entry)
        Dict[Key] = Item
    return
</code></pre>
<p>This works fine until <code>dict1</code> is not very large, but if <code>dict1</code> is large (some 1000 keys) it takes hours to get the result.</p>
<p>Is there a faster way to do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>This:</p>
<pre><code>Keys = list(Dict.keys())
if Key in Keys:
    ...
</code></pre>
<p>is probably the main culprit. It turns a O(1) lookup (<code>if Key in Dict:</code>) into a O(n) one. This plus the overhead of the one-function-call per key is certainly suboptimal indeed.</p>
<p>A much simpler solution is to use a <code>collections.defaultdict</code>:</p>
<pre><code>from collections import defaultdict

def revindex(dic):
    rev = defaultdict(list)
    # nb for py2.7 use `iteritems()` instead
    for k, v in dic.items():
        rev[v].append(k)
    return rev


dict2 = revindex(dict1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> instead of a vanilla dict to avoid those membership checks and you can remove the function calls which adds a non trivial overhead with repeated calls:</p>
<pre><code>from collections import defaultdict

dct2 = defaultdict(list)
for k in dct1:
   dct2[dct1[k]].append(k)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <code>defaultdict</code> or just <code>dict.setdefault</code>:</p>
<pre><code>dict2 = {}
for key, value in dict1.items():
    dict2.setdefault(value, []).append(key)
</code></pre>
<p>A function seems unnecessary for such a simple call.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of defaultdicts that were already mentioned, you could also create the dict with the setdefault method, like so:</p>
<pre><code>def transform(some_dict):
    new_dict = {}
    for k, v in some_dict.items():
        new_dict.setdefault(v, []).append(k)
    return new_dict
</code></pre>
<p>There is no need for the if statement you made. In my benchmark, this is around 2 times faster than your method. The method of Moses Koledoye beats those (on my machine) for some reason, which is in turn beaten by bruno desthuilliers' method. 
For the dictionary</p>
<pre><code>dict1 = dict([(str(x),x%10) for x in range(0,100000)])
</code></pre>
<p>I get (transform_0 being your method with together with the for loop, transform_d Moses' and transform_d2 being Bruno's methods) as average over 200 calls:</p>
<blockquote>
<p>benchmark for "transform_0": 133.516 ms</p>
<p>benchmark for "transform": 50.696 ms</p>
<p>benchmark for "transform_d": 43.967 ms</p>
<p>benchmark for "transform_d2": 38.408 ms </p>
</blockquote>
</div>
<span class="comment-copy">Only answer to correctly identify and explain the actual performance issue instead of just providing shorter/simpler code.</span>
<span class="comment-copy">@tobias_k true, its a nice answer. Considering the OP tagged python 3x I would change that iteritems to items though. +1</span>
<span class="comment-copy">@Banana fixed, thx - I did miss the py3 tag.</span>
<span class="comment-copy">I have not benchmarked it but using <code>dict.items()</code> (or <code>dict.iteritems()</code> in py2) might be a bit faster by avoiding the <code>__getitem_</code> calls.</span>
<span class="comment-copy">@brunodesthuilliers added a small test in my answer for a generic dict of size 100000. For that dict at least you are right</span>
<span class="comment-copy">what did you use for the benchmark ? <code>timeit</code> ?</span>
<span class="comment-copy">@brunodesthuilliers self written snippet using time.clock(), far from optimal, but good for a first hint</span>
<span class="comment-copy"><code>timeit</code> would have saved you some time - no self-written snippet required ;)</span>
<span class="comment-copy">@brunodesthuilliers probably true, at the time I wrote that I wasn't aware of timeit though :P</span>
