<div class="post-text" itemprop="text">
<p>Edit: My first attempt at asking this might be a bit unfocused/poorly worded here's a better explanation of what I'm trying to do:</p>
<p><strong>I'm trying to modify the default behavior of the print function for the entire environment python is running in without having to modify each file that's being run.</strong></p>
<p>I'm attempting to decorate the print function (I know there are many ways to do this such as overriding it but that's not really the question I'm asking) so I can have it print out some debugging information and force it to always flush. I did that like so:</p>
<pre><code>def modify_print(func):
    # I made this so that output always gets flushed as it won't by default
    # within the environment I'm using, I also wanted it to print out some
    # debugging information, doesn't really matter much in the context of this
    # question
    def modified_print(*args,**kwargs):
        return func(f"some debug prefix: ",flush=True,*args,**kwargs)
    return modified_print

print = modify_print(print)
print("Hello world") # Prints "some debug prefix Hello World"
</code></pre>
<p>However what I'm trying to do is modify this behavior throughout my entire application. I know I can manually decorate/override/import the print function in each file however I'm wondering if there is some way I can globally configure my python environment to decorate this function everywhere. The only way I can think to do this would be to edit the python source code and build the modified version.</p>
<p>EDIT:
Here's the behavior I wanted implemented, thank you Match for your help.
It prints out the line number and filename everywhere you call a print function within your python environment. This means you don't have to import or override anything manually in all of your files.</p>
<p><a href="https://gist.github.com/MichaelScript/444cbe5b74dce2c01a151d60b714ac3a" rel="nofollow noreferrer">https://gist.github.com/MichaelScript/444cbe5b74dce2c01a151d60b714ac3a</a></p>
<pre><code>import site
import os
import pathlib
# Big thanks to Match on StackOverflow for helping me with this
# see https://stackoverflow.com/a/48713998/5614280

# This is some cool hackery to overwrite the default functionality of
# the builtin print function within your entire python environment
# to display the file name and the line number as well as always flush 
# the output. It works by creating a custom user script and placing it 
# within the user's sitepackages file and then overwriting the builtin.

# You can disable this behavior by running python with the '-s' flag.


# We could probably swap this out by reading the text from a python file
# which would make it easier to maintain larger modifications to builtins
# or a set of files to make this more portable or to modify the behavior
# of more builtins for debugging purposes.
customize_script = """
from inspect import getframeinfo,stack
def debug_printer(func):
    # I made this so that output always gets flushed as it won't by default
    # within the environment I'm running it in. Also it will print the
    # file name and line number of where the print occurs
    def debug_print(*args,**kwargs):
        frame = getframeinfo(stack()[1][0])
        return func(f"{frame.filename} : {frame.lineno} ", flush=True,*args,**kwargs)
    return debug_print

__builtins__['print'] = debug_printer(print)
"""

# Creating the user site dir if it doesn't already exist and writing our
# custom behavior modifications
pathlib.Path(site.USER_SITE).mkdir(parents=True, exist_ok=True)
custom_file = os.path.join(site.USER_SITE,"usercustomize.py")
with open(custom_file,'w+') as f:
    f.write(customize_script)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>usercustomize</code> script from the <a href="https://docs.python.org/3/library/site.html" rel="nofollow noreferrer"><code>site</code></a> module to achieve something like this.</p>
<p>First, find out where your user site-packages directory is:</p>
<pre><code>python3 -c "import site; print(site.USER_SITE)"
</code></pre>
<blockquote>
<p>/home/foo/.local/lib/python3.6/site-packages</p>
</blockquote>
<p>Next, in that directory, create a script called <code>usercustomize.py</code> - this script will now be run first whenever python is run.</p>
<p>One* way to replace <code>print</code> is to override the <code>__builtins__</code> dict and replace it with a new method - something like:</p>
<pre><code>from functools import partial
old_print = __builtins__['print']

__builtins__['print'] = partial(old_print, "Debug prefix: ", flush=True)
</code></pre>
<p>Drop this into the <code>usercustomize.py</code> script and you should see all python scripts from then on being overridden. You can temporarily disable calling this script by calling <code>python</code>  with the <code>-s</code> flag.</p>
<p>*(Not sure if this is the correct way of doing this - there may be a better way - but the main point is that you can use <code>usercustomize</code> to deliver whatever method you choose).</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no real reason to define a decorator here, because you are only intending to apply it to a single, predetermined function. Just define your modified <code>print</code> function directly, wrapping it around <code>__builtins__.print</code> to avoid recursion.</p>
<pre><code>def print(*args, **kwargs):
    __builtins.__print(f"some debug prefix: ", flush=True, *args, **kwargs)

print("Hello world") # Prints "some debug prefix Hello World"
</code></pre>
<p>You can use <code>functools.partial</code> to simplify this.</p>
<pre><code>import functools
print = functools.partial(__builtins.__print, f"some debug prefix: ", flush=True)
</code></pre>
</div>
<span class="comment-copy">Just use the above code as a wrapper - i.e after redefining <code>print</code> then go on to <code>import</code> and run your <code>real</code> app.</span>
<span class="comment-copy">Yeah, however the print function isn't overridden in each file without manually importing or overriding it in each individual file. In other words: modifying the default behavior of the print function for the entire environment python is running in.</span>
<span class="comment-copy">Hey thanks a lot! I'm really happy with your solution. I updated my question with the script I wrote which will do that automatically and print some debugging information, hope you can find it useful too!</span>
<span class="comment-copy">Yeah, I realize you can do that. My question is more about how to globally modify that print function so I don't have to import/do that that in every file.</span>
