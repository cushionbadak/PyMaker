<div class="post-text" itemprop="text">
<p>I am working on a problem which requires me to independently change the value of a dictionary in python.</p>
<p>The code is like below</p>
<pre><code>g = 1 # a variable 
for j in lst1:
    dictionary = fo_1(j) # a function to update the dictinary
    for key in dictionary: # need to proccess in parallel 
        dictionary[key] = fo_2(dictionary[key], key, j, g)
</code></pre>
<p>As you can see, each time when the <code>fo_2</code> is called, we only access one value by <code>key</code> and modify it in <code>dictionary</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your question isn't entirely clear to me.</p>
<h3>Possible Interpretations</h3>
<ul>
<li>Is it safe to concurrently modify a python dictionary?</li>
<li>How does one write multithreaded code in Python?</li>
</ul>
<p>First, if you're using CPython then due to the <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">GIL</a> this is technically safe. In other interpreters, your results may vary.</p>
<p>Second, in an interpreter without a GIL, <a href="https://stackoverflow.com/questions/6953351/thread-safety-in-pythons-dictionary">assuming a threadsafe dictionary implementation</a>, this is still very error prone. If fo_1(j) is doing something to the key <code>j</code> in the dictionary <em>while you are also iterating over all keys in the dictionary</em>, then you might or might not make it to key <code>j</code> before it has been modified. In other words, in the general case what you propose is going to result in non-deterministic behavior, which is <strong>A Bad Thing</strong>.</p>
<p>If your specific use case has constraints that can somehow guarantee that this won't result in a race condition, and if you are using an interpreter without a GIL (ie other than CPython), and if that interpreter provides a threadsafe implementation of dictionary, only then you might reasonably ask how to go about writing such multithreaded code.</p>
<h3>Edit</h3>
<p>I apologize in advance if what I wrote below seems overly blunt, but I honestly don't think you are ready to be pursuing concurrent programming just yet.</p>
<p>Your particular task in this case does not appear well suited to concurrent code, because all stages of your code try to modify the same collection of data. Concurrent execution is much better suited to tasks where you have a single read-only data structure, and want to accomplish multiple <em>independent</em> tasks based on that data. I should also note that you generally don't want to introduce the added complexity of concurrent code unless achieving the desired level of performance requires it.</p>
<blockquote>
<p>I am using Cpython.</p>
</blockquote>
<p>It seems you have a fundamental misunderstanding - multithreaded code in CPython <em>does not execute concurrently</em>. Instead, the threads <em>take turns</em> executing their (separate) instruction streams. From the docs, "<a href="https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock" rel="nofollow noreferrer">Therefore, the rule exists that only the thread that has acquired the GIL may operate on Python objects or call Python/C API functions.</a>" Also see <a href="https://stackoverflow.com/a/1294430/9175160">this SO answer for an explanation.</a></p>
<p>To achieve actual concurrent execution of native Python code in CPython requires multiple Python processes (ie multiprocess), not just multiple threads. How to do that is beyond the scope of this answer at this point.</p>
<blockquote>
<p>I think it is still doable since the inner loop starts after we finish the outer loop.</p>
</blockquote>
<p>This is incorrect, given the code you provided in your question. In your provided code, the inner loop will execute fully (ie from start to end) once during each iteration of the outer loop. First <code>fo_1(j)</code> is called, and completes. Then the inner loop begins, calling <code>fo_2(...)</code> for each key, and completes. Then the outer loop advances to the next item, and this pattern repeats.</p>
<blockquote>
<p>The fo_1 might delete the old key or create a new key to the dictionary. The fo_2 only modifies the value, and does nothing to key. I think it is still doable since the inner loop starts after we finish the outer loop. I only need to finish the inner loop in parallel.</p>
</blockquote>
<p>There's... a number of problems with your apparent understanding here. Most obviously, if you were to achieve actual concurrent execution, what do you expect to happen when:</p>
<ul>
<li>An invocation of <code>fo_2(...)</code> tries to modify the value of a key that's (in the mean time) been deleted by <code>fo_1(j)</code>?</li>
<li>Two (concurrent) invocations of <code>fo_2(...)</code> attempt to modify the same value?</li>
<li>One invocation of <code>fo_2(...)</code> reads a value to make a decision, while that same value is simultaneously being changed by a different invocation of <code>fo_2(...)</code>?</li>
</ul>
<p>To be blunt, you do not seem to fully understand the many implications of parallel code, in particular that execution order is <em>undefined</em>. This has <strong>huge</strong> consequences.</p>
<blockquote>
<p>The fo_1 might delete the old key or create a new key to the dictionary. The fo_2 only modifies the value, and does nothing to key.</p>
</blockquote>
<p>This statement indicates a lack of understanding of this data structure. A Python dictionary is an <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">associative array</a>, a typical implementation of which is the <a href="https://en.wikipedia.org/wiki/Hash_table" rel="nofollow noreferrer">hash table</a>. These consist of a number of <code>key -&gt; value</code> mappings. So to restate your first sentence, the call <code>fo_1(j)</code> might either add or delete a <code>key -&gt; value</code> mapping from the table. Now, if you try to modify the value of a <code>key -&gt; value</code> mapping that has been (concurrently) deleted, what happens? This will depend on the semantics of the code you wrote, but typically a key that doesn't already exist will be inserted. In other words, <code>fo_2(...)</code> might well end up adding deleted keys back into the dictionary, depending on how exactly you implement it.</p>
</div>
<span class="comment-copy"><code>Can you give me the solutions...?</code> . stackoverflow isn't meant for asking others to write code for you.  If you post your code and ask a specific question about it, people will help.</span>
<span class="comment-copy">I am using Cpython. The <code>fo_1</code> might delete the old key or create a new key to the <code>dictionary</code>. The <code>fo_2</code> only modifies the value, and does nothing to <code>key</code>. I think it is still doable since the inner loop starts after we finish the outer loop. I only need to finish the inner loop in parallel.</span>
<span class="comment-copy">@Wedoso I've edited to reflect your comment.</span>
