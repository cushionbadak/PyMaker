<div class="post-text" itemprop="text">
<p>given a list and exclusions elements, is it possible to ignore calculation of combinations that contains these elements ?</p>
<h1>Example 1</h1>
<p>Given <code>l = [1, 2, 3, 4, 5]</code>, I want to calculate all combinations of <code>size 4</code> and excluding combinations that contains <code>(1, 3)</code> before even calculated. </p>
<p>The results would be :</p>
<pre><code>    All results:            Wanted results:

    [1, 2, 3, 4]            [1, 2, 4, 5]
    [1, 2, 3, 5]            [2, 3, 4, 5]
    [1, 2, 4, 5]
    [1, 3, 4, 5]
    [2, 3, 4, 5]
</code></pre>
<p>All combinations that contained <strong>1 and 3</strong> have been removed.</p>
<h1>Example 2</h1>
<p>suggested by @Eric Duminil</p>
<p>the result for <code>l = [1, 2, 3, 4, 5, 6]</code>, <code>size 4</code> and </p>
<ul>
<li>excluding <code>(1, 2, 3)</code> in second column</li>
<li><p>excluding <code>(1, 2)</code> in third column</p>
<pre><code>All results:        Wanted results 1            Wanted results 2
                    (Excluding [1, 2, 3]):      (Excluding [1, 2])

[1, 2, 3, 4]        [1, 2, 4, 5]                [1, 3, 4, 5]
[1, 2, 3, 5]        [1, 2, 4, 6]                [1, 3, 4, 6]
[1, 2, 3, 6]        [1, 2, 5, 6]                [1, 3, 5, 6]
[1, 2, 4, 5]        [1, 3, 4, 5]                [1, 4, 5, 6]
[1, 2, 4, 6]        [1, 3, 4, 6]                [2, 3, 4, 5]
[1, 2, 5, 6]        [1, 3, 5, 6]                [2, 3, 4, 6]
[1, 3, 4, 5]        [1, 4, 5, 6]                [2, 3, 5, 6]
[1, 3, 4, 6]        [2, 3, 4, 5]                [2, 4, 5, 6]
[1, 3, 5, 6]        [2, 3, 4, 6]                [3, 4, 5, 6]
[1, 4, 5, 6]        [2, 3, 5, 6]                                
[2, 3, 4, 5]        [2, 4, 5, 6]                                
[2, 3, 4, 6]        [3, 4, 5, 6]                                
[2, 3, 5, 6]           
[2, 4, 5, 6]           
[3, 4, 5, 6]        
</code></pre></li>
</ul>
<p>All combinations that contained <strong>1 and 2 and 3</strong> have been removed from wanted results 1</p>
<p>All combinations that contained <strong>1 and 2</strong> have been removed from wanted results 2</p>
<p>I have a much bigger combinations to compute but it takes a lot of time and I want to reduce this time using these exclusions.</p>
<h1>Tried solutions</h1>
<p>With method 1, the combinations are still calculated</p>
<p>With method 2, I tried to modify the <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">combinations function</a> but I could not find a proper way to ignore my exclusion list before calculated.</p>
<pre><code>            Method 1                    |               Method 2
                                        |               
def main():                             |   def combinations(iterable, r):
    l = list(range(1, 6))               |       pool = tuple(iterable)
    comb = combinations(l, 4)           |       n = len(pool)
                                        |       if r &gt; n:
    for i in comb:                      |           return
        if set([1, 3]).issubset(i):     |       indices = list(range(r))
            continue                    |       yield tuple(pool[i] for i in indices)
        else                            |       while True:
            process()                   |           for i in reversed(range(r)):
                                        |               if indices[i] != i + n - r:
                                        |                   break
                                        |               else:
                                        |                   return
                                        |           indices[i] += 1
                                        |           for j in range(i+1, r):
                                        |               indices[j] = indices[j-1] + 1
                                        |           yield tuple(pool[i] for i in indices)
</code></pre>
<h1>EDIT:</h1>
<p>First of all, thank you all for your help, I forgot to give more details about constraints.</p>
<ul>
<li><p>The order of the ouputs is not relevant, from example, if result is <code>[1, 2, 4, 5] [2, 3, 4, 5]</code> or <code>[2, 3, 4, 5] [1, 2, 4, 5]</code>, it is not important.</p></li>
<li><p>The elements of the combinations should be (if possible) sorted, <code>[1, 2, 4, 5] [2, 3, 4, 5]</code> and not <code>[2, 1, 5, 4] [3, 2, 4, 5]</code> but it is not important since the combinations could be sorted after.</p></li>
<li><p>The exclusions list is a list of all items that <strong>should not appear</strong> in the combinations <strong>together</strong>. e.g If my exclusion list is <code>(1, 2, 3)</code>, all combinations that contains <strong>1 and 2 and 3</strong> should not be calculated. However, combinations with <strong>1 and 2 and not 3</strong> are allowed. In that case, if I exclude combinations that contains <code>(1, 2)</code> and <code>(1, 2, 3)</code> it is completely useless since all combinations that will be filtered by <code>(1, 2, 3)</code> are already filtered by <code>(1, 2)</code></p></li>
<li><p><strong>Multiple exclude lists</strong> must be possible because I use multiple constraints on my combinations.</p></li>
</ul>
<h1>Tested answers</h1>
<p>@tobias_k
This solution considers the exclusion list <code>(1, 2, 3)</code> as OR exclusion meaning <code>(1, 2), (2, 3) and (1, 3)</code> will be excluded if I understood well, this is useful in a case but not in my current problem, I modified the question to give more details, sorry for confusion. In your answer, I can't use only lists <code>(1, 2)</code> and <code>(1, 3)</code> as exclusion as you specified it. However the big advantage of this solution is to permit multiple exclusions.</p>
<p>@Kasramvd and @mikuszefski
Your solution is really close to what I want, if it does include multiple exclusion lists, it would be the answer.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>(As it turned out that my <a href="https://stackoverflow.com/a/48619647/1639625">previous answer</a> does not really satisfy the constraints of the question, here's another one. I'm posting this as a separate answer, as the approach is vastly different and the original answer may still help others.)</p>
<p>You can implement this recursively, each time before recursing to add another element to the combinations checking whether that would violate one of the exclude-sets. This does not generate and invalid combinations, and it works with overlapping exclude-sets (like <code>(1,3), (1,5)</code>), and exclude-sets with more than two elements (like <code>(2,4,5)</code>, allowing any combinations except all of them together).</p>
<pre><code>def comb_with_excludes(lst, n, excludes, i=0, taken=()):
    if n == 0:
        yield taken  # no more needed
    elif i &lt;= len(lst) - n:
        t2 = taken + (lst[i],)  # add current element
        if not any(e.issubset(t2) for e in excludes):
            yield from comb_with_excludes(lst, n-1, excludes, i+1, t2)
        if i &lt; len(lst) - n:  # skip current element
            yield from comb_with_excludes(lst, n, excludes, i+1, taken)
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; excludes = [{1, 3}, {1, 5}, {2, 4, 5}]
&gt;&gt;&gt; list(comb_with_excludes(lst, 4, excludes))
[[1, 2, 4, 6], [2, 3, 4, 6], [2, 3, 5, 6], [3, 4, 5, 6]]
</code></pre>
<hr/>
<p>Well, I did time it now, and it turns out this is considerably slower than naively using <code>itertools.combination</code> in a generator expression with a filter, much like you already do:</p>
<pre><code>def comb_naive(lst, r, excludes):
    return (comb for comb in itertools.combinations(lst, r)
                 if not any(e.issubset(comb) for e in excludes))
</code></pre>
<p>Calculating the combinations in Python is just slower than using the library (which is probably implemented in C) and filtering the results afterwards. Depending on the amount of combinations that can be excluded, this <em>might</em> be faster in some cases, but to be honest, I have my doubts.</p>
<p>You could get better results if you can use <code>itertools.combinations</code> for subproblems, as in <a href="https://stackoverflow.com/a/48625806/1639625">Kasramvd's answer</a>, but for multiple, non-disjunct exclude sets that's more difficult. One way might be to separate the elements in the list into two sets: Those that have constraints, and those that don't. Then, use <code>itertoolc.combinations</code> for both, but check the constraints only for the combinations of those elements where they matter. You still have to check and filter the results, but only a part of them. (One caveat, though: The results are not generated in order, and the order of the elements within the yielded combinations is somewhat messed up, too.) </p>
<pre><code>def comb_with_excludes2(lst, n, excludes):
    wout_const = [x for x in lst if not any(x in e for e in excludes)]
    with_const = [x for x in lst if     any(x in e for e in excludes)]
    k_min, k_max = max(0, n - len(wout_const)), min(n, len(with_const))
    return (c1 + c2 for k in range(k_min, k_max)
                    for c1 in itertools.combinations(with_const, k)
                    if not any(e.issubset(c1) for e in excludes)
                    for c2 in itertools.combinations(wout_const, n - k))
</code></pre>
<p>This is already much better then the recursive pure-Python solution, but still not as good as the "naive" approach for the above example:</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; excludes = [{1, 3}, {1, 5}, {2, 4, 5}]
&gt;&gt;&gt; %timeit list(comb_with_excludes(lst, 4, excludes))
10000 loops, best of 3: 42.3 µs per loop
&gt;&gt;&gt; %timeit list(comb_with_excludes2(lst, 4, excludes))
10000 loops, best of 3: 22.6 µs per loop
&gt;&gt;&gt; %timeit list(comb_naive(lst, 4, excludes))
10000 loops, best of 3: 16.4 µs per loop
</code></pre>
<p>However, the results depend very much on the input. For a larger list, with constraints only applying to a few of those elements, this approach is in fact faster then the naive one:</p>
<pre><code>&gt;&gt;&gt; lst = list(range(20))
&gt;&gt;&gt; %timeit list(comb_with_excludes(lst, 4, excludes))
10 loops, best of 3: 15.1 ms per loop
&gt;&gt;&gt; %timeit list(comb_with_excludes2(lst, 4, excludes))
1000 loops, best of 3: 558 µs per loop
&gt;&gt;&gt; %timeit list(comb_naive(lst, 4, excludes))
100 loops, best of 3: 5.9 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>(Turns out this does not do exactly what OP wants. Still leaving this here as it might help others.)</p>
<hr/>
<p>To include mutually exclusive elements, you could wrap those in lists within the list, get the <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>combinations</code></a> of those, and  then the <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>product</code></a> of the combinations of sub-lists:</p>
<pre><code>&gt;&gt;&gt; from itertools import combinations, product
&gt;&gt;&gt; l = [[1, 3], [2], [4], [5]]
&gt;&gt;&gt; [c for c in combinations(l, 4)]
[([1, 3], [2], [4], [5])]
&gt;&gt;&gt; [p for c in combinations(l, 4) for p in product(*c)]
[(1, 2, 4, 5), (3, 2, 4, 5)]
</code></pre>
<p>A more complex example:</p>
<pre><code>&gt;&gt;&gt; l = [[1, 3], [2, 4, 5], [6], [7]]
&gt;&gt;&gt; [c for c in combinations(l, 3)]
[([1, 3], [2, 4, 5], [6]),
 ([1, 3], [2, 4, 5], [7]),
 ([1, 3], [6], [7]),
 ([2, 4, 5], [6], [7])]
&gt;&gt;&gt; [p for c in combinations(l, 3) for p in product(*c)]
[(1, 2, 6),
 (1, 4, 6),
 ... 13 more ...
 (4, 6, 7),
 (5, 6, 7)]
</code></pre>
<p>This does not generate any "junk" combinations to be filtered out afterwards. However, it assumes that you want at most one element from each "exclusive" group, e.g. in the second example, it not only prevents combinations with <code>2,4,5</code>, but also those with <code>2,4</code>, <code>4,5</code>, or <code>2,5</code>. Also, it is not possible (or at least not easy) to have exclusively one of <code>1,3</code>, and <code>1,5</code>, but allow for <code>3,5</code>. (It might be possible to extend it to those cases, but I'm not yet sure if and how.)</p>
<hr/>
<p>You can wrap this in a function, deriving the slightly different input format from your (presumed) format and returning an accordant generator expression. Here, <code>lst</code> is the list of elements, <code>r</code> the number of items per combinations, and <code>exclude_groups</code> a list of groups of mutually-exclusive elements:</p>
<pre><code>from itertools import combinations, product

def comb_with_excludes(lst, r, exclude_groups):
    ex_set = {e for es in exclude_groups for e in es}
    tmp = exclude_groups + [[x] for x in lst if x not in ex_set]
    return (p for c in combinations(tmp, r) for p in product(*c))

lst = [1, 2, 3, 4, 5, 6, 7]
excludes = [[1, 3], [2, 4, 5]]
for x in comb_with_excludes(lst, 3, excludes):
    print(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From an algorithmic perspective you can separate the excluded and the reset of the valid items and calculate the combinations of each set separately and just concatenate the result based on the desire length. This approach will entirely refuse of including all the excluded items at once in combination but will omit the actual order.</p>
<pre><code>from itertools import combinations

def comb_with_exclude(iterable, comb_num, excludes):
    iterable = tuple(iterable)
    ex_len = len(excludes)
    n = len(iterable)

    if comb_num &lt; ex_len or comb_num &gt; n:
        yield from combinations(iterable, comb_num)

    else:
        rest = [i for i in iterable if not i in excludes]
        ex_comb_rang = range(0, ex_len)
        rest_comb_range = range(comb_num, comb_num - ex_len, -1)
        # sum of these pairs is equal to the comb_num
        pairs = zip(ex_comb_rang, rest_comb_range)

        for i, j in pairs:
            for p in combinations(excludes, i):
                for k in combinations(rest, j):
                    yield k + p
       """
       Note that instead of those nested loops you could wrap the combinations within a product function like following:
       for p, k in product(combinations(excludes, i), combinations(rest, j)):
            yield k + p
       """
</code></pre>
<p>Demo:</p>
<pre><code>l = [1, 2, 3, 4, 5, 6, 7, 8]
ex = [2, 5, 6]
print(list(comb_with_exclude(l, 6, ex)))

[(1, 3, 4, 7, 8, 2), (1, 3, 4, 7, 8, 5), (1, 3, 4, 7, 8, 6), (1, 3, 4, 7, 2, 5), (1, 3, 4, 8, 2, 5), (1, 3, 7, 8, 2, 5), (1, 4, 7, 8, 2, 5), (3, 4, 7, 8, 2, 5), (1, 3, 4, 7, 2, 6), (1, 3, 4, 8, 2, 6), (1, 3, 7, 8, 2, 6), (1, 4, 7, 8, 2, 6), (3, 4, 7, 8, 2, 6), (1, 3, 4, 7, 5, 6), (1, 3, 4, 8, 5, 6), (1, 3, 7, 8, 5, 6), (1, 4, 7, 8, 5, 6), (3, 4, 7, 8, 5, 6)]

l = [1, 2, 3, 4, 5]
ex = [1, 3]
print(list(comb_with_exclude(l, 4, ex)))

[(2, 4, 5, 1), (2, 4, 5, 3)]
</code></pre>
<p>Benckmark with other answers:</p>
<p>Results: this approach is faster that the others</p>
<pre><code># this answer
In [169]: %timeit list(comb_with_exclude(lst, 3, excludes[0]))
100000 loops, best of 3: 6.47 µs per loop

# tobias_k
In [158]: %timeit list(comb_with_excludes(lst, 3, excludes))
100000 loops, best of 3: 13.1 µs per loop

# Vikas Damodar
In [166]: %timeit list(combinations_exc(lst, 3))
10000 loops, best of 3: 148 µs per loop

# mikuszefski
In [168]: %timeit list(sub_without(lst, 3, excludes[0]))
100000 loops, best of 3: 12.52 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have made an attempt to edit combinations according to your requirements :</p>
<pre><code>def combinations(iterable, r):
   # combinations('ABCD', 2) --&gt; AB AC AD BC BD CD
   # combinations(range(4), 3) --&gt; 012 013 023 123
   pool = tuple(iterable)
   n = len(pool)
   if r &gt; n:
      return
   indices = list(range(r))
   # yield tuple(pool[i] for i in indices)
   while True:
       for i in reversed(range(r)):
           if indices[i] != i + n - r:
               break
    else:
        return
    indices[i] += 1
    for j in range(i+1, r):
        indices[j] = indices[j-1] + 1
    # print(tuple(pool[i] for i in indices ), "hai")
    if 1 in tuple(pool[i] for i in indices ) and 3  in tuple(pool[i] for i in indices ):
        pass
    else:
        yield tuple(pool[i] for i in indices)


d = combinations(list(range(1, 6)),4)
for i in d:
   print(i)
</code></pre>
<p>It will return something like this :</p>
<blockquote>
<p>(1, 2, 4, 5)
  (2, 3, 4, 5)</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I did the exclusion during the combination using the following code to save the second loop time. you just need to pass the indices of the excluded elements as a set. </p>
<p><strong>update</strong>: <a href="https://pyfiddle.io/fiddle/d170614c-ddcb-407c-a960-90c6f6ca38f8/?i=true" rel="nofollow noreferrer">working fiddle</a></p>
<pre><code>from itertools import permutations

def combinations(iterable, r, combIndeciesExclusions=set()):
    pool = tuple(iterable)
    n = len(pool)
    for indices in permutations(range(n), r):
        if ( len(combIndeciesExclusions)==0 or not combIndeciesExclusions.issubset(indices)) and sorted(indices) == list(indices):
            yield tuple(pool[i] for i in indices)


l = list(range(1, 6))
comb = combinations(l, 4, set([0,2]))
print list(comb)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I guess my answer is similar to some others here, but this was what I fiddled together in parallel</p>
<pre><code>from itertools import combinations, product

"""
with help from
https://stackoverflow.com/questions/374626/how-can-i-find-all-the-subsets-of-a-set-with-exactly-n-elements
https://stackoverflow.com/questions/32438350/python-merging-two-lists-with-all-possible-permutations
https://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python
"""
def sub_without( S, m, forbidden ):
    out = []
    allowed = [ s for s in S if s not in forbidden ]
    N = len( allowed )
    for k in range( len( forbidden ) ):
        addon = [ list( x ) for x in combinations( forbidden, k) ]
        if N + k &gt;= m:
            base = [ list( x ) for x in combinations( allowed, m - k ) ]
            leveltotal = [ [ item for sublist in x for item in sublist ] for x in product( base, addon ) ]
            out += leveltotal
    return out

val = sub_without( range(6), 4, [ 1, 3, 5 ] )

for x in val:
    print sorted(x)

&gt;&gt;
[0, 1, 2, 4]
[0, 2, 3, 4]
[0, 2, 4, 5]
[0, 1, 2, 3]
[0, 1, 2, 5]
[0, 2, 3, 5]
[0, 1, 3, 4]
[0, 1, 4, 5]
[0, 3, 4, 5]
[1, 2, 3, 4]
[1, 2, 4, 5]
[2, 3, 4, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Algorithmically you have to calculate the combination of the items within your list that are not among the excluded ones then add the respective combinations of the excluded items to the combination of the rest of items. This approach of course requires a lot of checking and need to keep track of the indexes which even if you do it in python it won't give you a notable difference in performance (known as drawbacks of <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem" rel="nofollow noreferrer">Constraint satisfaction problem</a>). (rather than just calculating them using <code>combination</code> and filtering the unwanted items out).</p>
<p>Therefor, I think this is the best way to go in most of the cases:</p>
<pre><code>In [77]: from itertools import combinations, filterfalse

In [78]: list(filterfalse({1, 3}.issubset, combinations(l, 4)))
Out[78]: [(1, 2, 4, 5), (2, 3, 4, 5)]
</code></pre>
</div>
<span class="comment-copy">Do you need output elements to be ordered the same way you describe in question?</span>
<span class="comment-copy">Can you add a bit more about the exclusiveness-constraints? If you have a set of three exclusive numbers, would that mean that you can only have one of those three, or can you have two? And can you have constraints like "only of of 1 and 3, and only one of 1 and 5, but 3 and 5 is okay"?</span>
<span class="comment-copy">What should be the result for <code>l = [1, 2, 3, 4, 5, 6]</code>, <code>size 4</code> and excluding <code>(1, 2, 3)</code>?</span>
<span class="comment-copy">Thank you for your answer, this was exactly what I was looking for ! Your previous answer is also interesting and I may use it too for another problem ! Thanks again !</span>
<span class="comment-copy">After testing this solution appears to be much more slower than calculating all combinations :/ do you have an idea why ? <a href="https://pyfiddle.io/fiddle/a1f2b4f3-16d5-47b5-8bee-4984b3502931/?i=true" rel="nofollow noreferrer">pyfiddle.io/fiddle/a1f2b4f3-16d5-47b5-8bee-4984b3502931/?i=true</a></span>
<span class="comment-copy">@SyedElec Well, I guess <code>itertools.combinations</code> is just too efficient (probably implemented in C and all that), so when re-creating it in pure Python it will always be much slower. Depending on the number of combinations to exclude this might still be faster in some cases, but in general, you might indeed be better of just using a generator expression with <code>itertools.combinations</code> and a filter...</span>
<span class="comment-copy">This solution is not even changing the question itself but also is not efficient at all. Checkout my answer for a more Pythonic version of this approach.</span>
<span class="comment-copy">@Kasramvd Could you explain, please? In which sense is it not efficient? As I said, it doe snot generate any "junk" to be filtered, but maybe it's still slower due to overhead? I did not time it. Also, what do you mean with "not even changing the question"? Did you mean "not only changing the question", and if so, in which sense? Just by slightly changing the input format?</span>
<span class="comment-copy">Yes, changing the input format makes it another question. The whole point of the question is to how deal with such inputs. Regarding the performance you're using a nested loop and using both <code>products</code> and <code>combinations</code>. Just imagine how this approach will  perform if the number of excludes and lists are larger. Also using list object in combinations is not memory efficient as well (due to immutability and lack of cashing etc.).</span>
<span class="comment-copy">@Kasramvd Ehrm... yes, it has nested loops, but it still generates <i>exactly</i> the combinations OP wants (provided I correctly guessed what those unclear exclude-lists are about exactly, see my comments). And of course the list comprehension can trivially be changed to a generator if that's the problem. And the input can be transformed beforehand.</span>
<span class="comment-copy">@Kasramvd I think OP's problem is not really well-defined with just one example, that's why I asked for clarification. My answer does, however, provide an efficient solution for that exact problem (see my edit for transforming the input) and for what I assume to be the "general" case.</span>
<span class="comment-copy">Nice. But not really comparable, as the functions calculate slightly different things. That does not mean that either is wrong, just that OP's question is not entirely clear. Also, you forgot to consume the generator in the first <code>%timeit</code> ;-) (sorry)</span>
<span class="comment-copy">@tobias_k Yes just fixed ;)). They all attempt to return same result but regarding your approach that accepts multiple exclude I just passed one to it.</span>
<span class="comment-copy">It's not just multiple exclude sets: In the case of <code>[2,4,5]</code>, I allow for only one of the three numbers, whereas you allow for two of them, as long as it's not all three. For <code>[1,3]</code>, both should yield the same, though. But as I said, we don't really know which one it should be.</span>
<span class="comment-copy">true, but that is the example <b>1</b> in the question, which still calculates all combinations.</span>
<span class="comment-copy">i know it's not a good way, But if he want to go forward with the first solution I gave him a suggestion, may be a temporary solution.</span>
<span class="comment-copy">I don't see where the suggestion is. This the OPs code with an added overhead of creating a list.</span>
<span class="comment-copy">@hiroprotagonist  I have made an attempt to do in the way OP asked, asking better suggestions from your side</span>
<span class="comment-copy">@Matthias I have made an edit , I'am not sure about its a good way or not .</span>
<span class="comment-copy">you solution is not working, e.g <code>combinations([1, 2, 3], 2, set([1, 2]))</code>, thanks anyway</span>
<span class="comment-copy">@SyedElec what are you talking about? your query gives this result <code>[(1, 2), (1, 3)]</code> which is correct. the exclusion of index 1 and index 2 means that you don't want to have the values 2 and 3 all together in the same combination. note that you are setting indexes not values. this gives you exactly the result you wanted.</span>
<span class="comment-copy">It might be simpler, then, to accept sets of elements and convert those to sets of indices internally. Also, this is still calculating all the combinations and only then checking whether they are valid. Much worse, in fact: It generates all the permutations, then checks whether those are combinations (of which there are much fewer), and <i>then</i> checks whether they are valid.</span>
<span class="comment-copy">@SyedElec in fact this method is from the same place you got your implementation, check out the next block of alternative implementation <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.combinations</a> I have only tweaked the filtration process to exclude the set of indices passed. you can do benchmarking and it won't make a big difference.</span>
<span class="comment-copy">@CME64 sorry I did not read your answer correctly, I was in the same process of testing all answers and I did not read you were taking indices instead of values, the code in python3 doc is not really optimized for my problem.</span>
<span class="comment-copy">@tobias_k I just decided to remove that solution. Check the update.</span>
<span class="comment-copy">Well, now it's basically what OP is already doing, just in one line and without re-creating the set in each iteration. (Not saying that that's bad, though; entirely depends on the amount of "junk" in the actual, larger data sets.)</span>
<span class="comment-copy">@downvoter Can you explain the reason of your down vote?</span>
<span class="comment-copy">It wasn't my downvote, but if I'd have to guess, it might be for the claim about "no notable difference", which depends entirely on the total amount of combinations and the proportion of those that wouldn't have to be generated.</span>
<span class="comment-copy">@tobias_k I knew it wasn't you. But no! it's not that simple. As I mentioned <b>in python</b> if you can do this in a lower abstracted language it will give you a notable difference but in python in order to satisfy those conditions yo have to keep track of the indices of the items, remove the excluded onces and do a lot of other manipulations that will take a lot of time. This is known as drawback of <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem" rel="nofollow noreferrer">Constraint satisfaction problem</a>.</span>
