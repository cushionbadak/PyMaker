<div class="post-text" itemprop="text">
<p>I have a list that looks something like this:</p>
<pre><code>[u'https://www.microsoft.com']
[u'https://www.microsoft.com']
[u'https://products.office.com/en-us/home']
[u'https://www.microsoft.com/en-us/windows/']
[u'https://www.microsoft.com/surface/en-us']
[u'https://www.xbox.com/en-us']
</code></pre>
<p>I want to clean up the output a bit, sort the values, remove duplicate entries, and so on. But in it's current format, instead of operating on each values as an entire individual element, it's operating on individual characters (i.e. just a string of individual letters). What I get back is just nonsensical diced up strings of text.</p>
<p>So basically, I want to consolidate all the sublists into a single list, on a single line, in the following (regular) format:  </p>
<pre><code>['https://www.microsoft.com', 'https://www.microsoft.com', 'https://products.office.com/en-us/home', 'https://www.microsoft.com/en-us/windows/', 'https://www.microsoft.com/surface/en-us', 'https://www.xbox.com/en-us']
</code></pre>
<hr/>
<p>I'm new to Python, so there's a chance I've missed something (or used incorrect terminology at some point), but this (and the placement of the square brackets) is why I assumed this to be considered a list (and/or multiple sublists); if I substitute <code>print(links)</code> with <code>print(type(links))</code>, I get the following output:</p>
<pre><code>&lt;type 'list'&gt;
&lt;type 'list'&gt;
&lt;type 'list'&gt;
&lt;type 'list'&gt;
&lt;type 'list'&gt;
&lt;type 'list'&gt;
</code></pre>
<hr/>
<p>The original piece of code where <code>links</code> is defined, looks something like this:  </p>
<pre><code>class LinkParser(HTMLParser):
  def handle_starttag(self, tag, attrs):
    links = []
    if tag == 'a':
      for attr in attrs:
        if attr[0] == 'href':
          links.append(attr[1])
          print(links)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Looks like you have a list of list in my_list. If so</p>
<pre><code>l = [['https://www.microsoft.com'],
['https://www.microsoft.com'],
['https://products.office.com/en-us/home'],
['https://www.microsoft.com/en-us/windows/'],
['https://www.microsoft.com/surface/en-us'],
['https://www.xbox.com/en-us']]

res = []
for i in l:
    if i[0] not in res:
        res.append(i[0])
print(res)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>['https://www.microsoft.com', 'https://products.office.com/en-us/home', 'https://www.microsoft.com/en-us/windows/', 'https://www.microsoft.com/surface/en-us', 'https://www.xbox.com/en-us']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>toolz.concat</code> is surprisingly efficient (as a lazy function) and elegant for this kind of task.</p>
<pre><code>from toolz import concat

lst = [['https://www.microsoft.com'],
['https://www.microsoft.com'],
['https://products.office.com/en-us/home'],
['https://www.microsoft.com/en-us/windows/'],
['https://www.microsoft.com/surface/en-us'],
['https://www.xbox.com/en-us']]

list(concat(lst))  # for a sorted list, replace list with sorted

# ['https://www.microsoft.com',
#  'https://www.microsoft.com',
#  'https://products.office.com/en-us/home',
#  'https://www.microsoft.com/en-us/windows/',
#  'https://www.microsoft.com/surface/en-us',
#  'https://www.xbox.com/en-us']
</code></pre>
<p>Or, if you want a set:</p>
<pre><code>set(concat(lst))

# {'https://products.office.com/en-us/home',
#  'https://www.microsoft.com',
#  'https://www.microsoft.com/en-us/windows/',
#  'https://www.microsoft.com/surface/en-us',
#  'https://www.xbox.com/en-us'}
</code></pre>
<p>If you don't have <code>toolz</code>, you can use the below instead. <code>toolz</code> often provides easy access for some common hard-to-find functions hidden in other libraries.</p>
<pre><code>import itertools
itertools.chain.from_iterable(...)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>data = [['https://www.microsoft.com'],
['https://www.microsoft.com'],
['https://products.office.com/en-us/home'],
['https://www.microsoft.com/en-us/windows/'],
['https://www.microsoft.com/surface/en-us'],
['https://www.xbox.com/en-us']]

from itertools import chain

new_list = list(dict.fromkeys(chain.from_iterable(data)))

print(new_list)
&gt;&gt;&gt;
['https://www.microsoft.com',
 'https://products.office.com/en-us/home',
 'https://www.microsoft.com/en-us/windows/',
 'https://www.microsoft.com/surface/en-us',
 'https://www.xbox.com/en-us']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you not have a single list, but 6 lists with one element. if you want to collect
all that into one item without duplicates i suggest you use a
<a href="https://docs.python.org/3/library/stdtypes.html?highlight=set#set" rel="nofollow noreferrer"><code>set</code></a>:</p>
<pre><code>class MyHTMLParser(HTMLParser):
    def handle_starttag(self, tag, attrs):
        my_set = set()
        if tag == 'a':
            for attrs in attrs:
                if attrs[0] == 'href' and '.' in attrs[1]:
                    my_set.add(attrs[1])
        print(sorted(my_set))
</code></pre>
<p>...i was not able to test that; you may have to tweak it a litte.</p>
</div>
<div class="post-text" itemprop="text">
<p>Okay, I figured it out:</p>
<ol>
<li><p>The object/list in question (i.e. <strong><code>links</code></strong>), needs to be initialized outside the scope of the function and/or class in which it's defined (i.e. the block of code where items are appended to it). It can come before, or after; as long as long as it's interpreted first.  </p></li>
<li><p>The same applies to calling the <strong><code>print()</code></strong> statement (regarding scope), but it should be interpreted last (after calling the function and/or class that sets it up).  </p></li>
</ol>
<hr/>
<p><strong>For example:</strong></p>
<h2>Input:</h2>
<pre><code>class LinkParser(HTMLParser):
  def handle_starttag(self, tag, attrs):
    if tag == 'a':
      for attr in attrs:
        if attr[0] == 'href':
          links.append(attr[1])

links = []
LinkParser().feed(html)
print(links)
</code></pre>
<h2>Output:</h2>
<p><pre><code>[u'<a href="https://www.microsoft.com" rel="nofollow noreferrer">https://www.microsoft.com</a>', u'<a href="https://www.microsoft.com" rel="nofollow noreferrer">https://www.microsoft.com</a>', u'<a href="https://products.office.com/en-us/home" rel="nofollow noreferrer">https://products.office.com/en-us/home</a>', u'<a href="https://www.microsoft.com/en-us/windows/" rel="nofollow noreferrer">https://www.microsoft.com/en-us/windows/</a>', u'<a href="https://www.microsoft.com/surface/en-us" rel="nofollow noreferrer">https://www.microsoft.com/surface/en-us</a>', u'<a href="https://www.xbox.com/en-us" rel="nofollow noreferrer">https://www.xbox.com/en-us</a>']</code></pre></p></div>
<span class="comment-copy">the output of <code>print(my_list)</code> does not look like a list...</span>
<span class="comment-copy">Could you give the output of <code>type(my_list)</code> ?</span>
<span class="comment-copy">You probably want list(set([el[0] for el in my_list])).</span>
<span class="comment-copy">@hiroprotagonist Because of the newlines?</span>
<span class="comment-copy">newlines, no commas, missing brackets around the outer list.</span>
<span class="comment-copy"><code>toolz</code> is not in the standard python library. you might want to add a link to the library and how to install it.</span>
<span class="comment-copy">@hiroprotagonist, updated with <code>itertools</code> alternative. <code>toolz</code> often just provides syntax sugar, or shortcuts to commonly used tools.</span>
<span class="comment-copy">nothing against <code>tools</code>. i just thought the answer would be more complete if you added some information about the library.</span>
<span class="comment-copy">I haven't used <code>toolz</code> but I tried the <code>set</code> and <code>itertools</code> techniques that you mentioned.</span>
<span class="comment-copy">Same problem. The output looks like several lines of this: <code>['.', '/', ':', 'c', 'f', 'h', 'i', 'm', 'o', 'p', 'r', 's', 't', 'w']</code></span>
<span class="comment-copy">really? because: <code>my_set = set(); my_set.add('hello')</code> gives <code>{'hello'}</code>...</span>
<span class="comment-copy">That was using <code>.update</code>. With <code>.add</code>, the output looks identical to how it is in the question. My brain hurts.</span>
<span class="comment-copy">do you use all of that in yet another loop?</span>
<span class="comment-copy">Nope. No more loops. I even tried omitting the current <code>for</code> loop, which I thought would work, but there was no output.</span>
