<div class="post-text" itemprop="text">
<p>I transform an empty list called <code>UNVISITED</code> into a heap, such that:</p>
<pre><code>UNVISITED = []
heapq.heappush(UNVISITED, (a.f, a))
</code></pre>
<p>The object <code>a</code> that I push, which is instantiated from a class, has the following fields:</p>
<pre><code>class UNVISITEDNode():
    def __init__(self, value1, value2 , value3, value4, value5):
            self.q = value1
            self.h = value2
            self.g = value3
            self.f = value4
            self.p = value5
</code></pre>
<p>Throughout my algorithm, I keep modifying any <code>valueX</code> from the object already in the heap whenever is needed like:</p>
<pre><code>for i in range(len(UNVISITED)):
        UNVISITED[i][1].q = newvalue1
        UNVISITED[i][1].h = newvalue2
        UNVISITED[i][1].g = newvalue3
        UNVISITED[i][1].f = newvalue4
        UNVISITED[i][1].p = newvalue5
</code></pre>
<p>Because (or so I think, please correct me if I am wrong) modifying the value <code>f</code> like I am doing now does not change the value that affects the sorting of the heap, I directly try to modify <code>UNVISITED[i][0]</code> (which is the above <code>a.f</code> passed as a second part of the second argument when creating the heap).</p>
<p>[THE PROBLEM] -&gt; Then I am told that this value does not admit modification:</p>
<pre><code>UNVISITED[i][0] = newvalue4

*Traceback (most recent call last):
  File "/home/daniel/pycharm-2017.3.3/helpers/pydev/
_pydevd_bundle/pydevd_exec.py", line 3, in Exec
        exec exp in global_vars, local_vars
      File "&lt;input&gt;", line 1, in &lt;module&gt;
    TypeError: 'tuple' object does not support item assignment
</code></pre>
<p><strong>I really need to modify the value <code>f</code> of the object <code>a</code>, which has to affect the sorting of the heap every time is needed and you cannot do this through <code>UNVISITED[i][1].f = newvalue4</code>  (apparently)</strong>. Is there any way to do this or any workaround?</p>
<h2><strong>EDIT (WORKAROUND PERFORMED)</strong></h2>
<p>Eventually I have defined a simple manual heap as <code>heap = []</code>and <code>heap.append()</code> the objects to it.
You can use <code>heap.pop()</code> to pop the first element in the heap, and <code>heap.sort(key=lambda x: x.f, reverse=True)</code> to sort it based on the values of the attributes.
Like this you get closer to the behavior of <code>heapq</code> and you are able to modify the elements in the heap for which that heap is sorted.
It is important to say that this is significantly slower than using <code>heapq</code>.</p>
<p>Nonetheless, I am marking @Raymong Hettinger 's answer as the good one because of the detail of other possible workarounds.</p>
<p>Also, @Davis Yoshida has made a valid point in that maybe a <em>heap</em> as it is defined might not be the best way to store the data.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Invalidate and Reinsert</h2>
<p>The usual solution is to mark the object as invalid and to reinsert a new value.  When popping off values, just ignore the invalid entries.</p>
<p>This technique is very efficient as long as there are not a large number of invalidated entries.  The invalidation step runs in <a href="https://en.wikipedia.org/wiki/Time_complexity#Constant_time" rel="nofollow noreferrer">constant time</a> and the subsequent pops run in <a href="https://en.wikipedia.org/wiki/Time_complexity#Logarithmic_time" rel="nofollow noreferrer">logarithmic time</a>.</p>
<h2>Reheapify</h2>
<p>After adjusting one or more values, run the <a href="https://docs.python.org/3/library/heapq.html#heapq.heapify" rel="nofollow noreferrer"><em>heapify()</em></a> function to restore the heap invariant.</p>
<p>This uses a public function that is guaranteed to run in <a href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time" rel="nofollow noreferrer">linear time</a>.</p>
<h2>Direct Heap Adjustment</h2>
<p>Another way is to locate the object in the heap's list, using <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow noreferrer"><em>list.index()</em></a>.  After changing the value, run the internal <em>_siftup()</em> or <em>_siftdown()</em> functions depending on whether the value is being increased or decreased.</p>
<p>Increasing case:</p>
<pre><code>&gt;&gt;&gt; from heapq import _siftup, _siftdown, heapify, heappop

&gt;&gt;&gt; data = [10, 5, 18, 2, 37, 3, 8, 7, 19, 1]
&gt;&gt;&gt; heapify(data)
&gt;&gt;&gt; old, new = 8, 22              # increase the 8 to 22
&gt;&gt;&gt; i = data.index(old)
&gt;&gt;&gt; data[i] = new
&gt;&gt;&gt; _siftup(data, i)
&gt;&gt;&gt; [heappop(data) for i in range(len(data))]
[1, 2, 3, 5, 7, 10, 18, 19, 22, 37]
</code></pre>
<p>Decreasing case:</p>
<pre><code>&gt;&gt;&gt; data = [10, 5, 18, 2, 37, 3, 8, 7, 19, 1]
&gt;&gt;&gt; heapify(data)
&gt;&gt;&gt; old, new = 8, 4              # decrease the 8 to 4
&gt;&gt;&gt; i = data.index(old)
&gt;&gt;&gt; data[i] = new
&gt;&gt;&gt; _siftdown(data, 0, i)
&gt;&gt;&gt; [heappop(data) for i in range(len(data))]
[1, 2, 3, 4, 5, 7, 10, 18, 19, 37]
</code></pre>
<p>This technique uses linear time list indexing and a <a href="https://en.wikipedia.org/wiki/Time_complexity#Logarithmic_time" rel="nofollow noreferrer">logarithmic time</a> heap update.  It is likely to use fewer comparisons than the reheapifying technique, but this isn't entirely satisfying because it uses non-public functions.</p>
<h2>Resorting</h2>
<p>Lastly, you can resort the data:</p>
<pre><code>&gt;&gt;&gt; data.sort()
</code></pre>
<p>This technique likely makes more comparisons than reheapifying or direct heap adjustment.  The reason it works is that "if the data is sorted, then it is already a heap".</p>
<p>The running time can be <code>O(n log n)</code> in the worst case; however, the <em>sort</em>
 implementation applies the <a href="https://en.wikipedia.org/wiki/Timsort" rel="nofollow noreferrer">Timsort</a> algorithm which can be very efficient with partially sorted inputs.</p>
</div>
<div class="post-text" itemprop="text">
<p>Even if this code ran, I believe it would not do what you are intending.
Specifically, if you did</p>
<pre><code>tup = (a.f, a) # a.f = 7
</code></pre>
<p>then could execute</p>
<pre><code>tup[0] = 3
</code></pre>
<p>You would have <code>tup</code> set to <code>(3, a)</code>, but <code>a.f</code> would still be 7.</p>
<p>One thing you could do would allow direct comparisons by adding an <code>__lt__</code> (less than) method to your <code>UNVISITEDNode</code> class like so:</p>
<pre><code>class UNVISITEDNode:
   ...
   def __lt__(self, other):
       return self.f &lt; other.f
</code></pre>
<p>Then, instead of putting tuples into the heapq, just directly put the node objects in.</p>
<p>However, if you modify objects that are not at the root of the heap, you are no longer guaranteed that the heap is valid so you will need to reheapfiy <code>UNVISITED</code>.</p>
</div>
<span class="comment-copy">There is probably a bug elsewhere in your code, where you inadvertently assigned a tuple to <code>UNVISITED[i][0]</code> rather than just <code>UNVISITED[i]</code>.</span>
<span class="comment-copy">@chepner i am doing that on purpose so the heap is sorted given that value in <code>UNVISITED[i][0]</code>. You can see this in the first lines of this post. Afaik that is a way to define it if you also want to pop additional things.</span>
<span class="comment-copy">Is there a way to do this inside the <i>heapq</i> architecture so the pop automatically pops the following value in the heap? Or do I have to find the way to mark this externally and interpret that the pop is not valid?</span>
<span class="comment-copy">@thepirate16 The issue is a heap isn't really an architecture.  Instead, is just a semi-ordered arrangement of the data.   So, you left with solutions that need to modify the ordering or that invalidate the data.</span>
<span class="comment-copy">A question about this answer has been asked <a href="https://stackoverflow.com/q/55373969/1720199">here</a>, my <a href="https://stackoverflow.com/a/55539362/1720199">answer</a> may give some additional information on how <code>_siftup</code> compares to <code>.sort()</code> and <code>heapify()</code> in practice. From what I've observed, <code>heapify</code> is always faster, even for correcting a single invariant violation.</span>
<span class="comment-copy">This is interesting. Nevertheless then I have to directly discard a heap.</span>
<span class="comment-copy">You have a for loop running over the whole of the heap modifying every value, so you will use O(n log n) operations regardless of how you reheapify. You might as well run the entire for loop and reheapify.</span>
<span class="comment-copy">Another point is that if you intend to iterate over all the data, it is likely not best to store it as a heap.</span>
