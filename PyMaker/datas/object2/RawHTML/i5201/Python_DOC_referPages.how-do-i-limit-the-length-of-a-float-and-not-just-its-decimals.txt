<div class="post-text" itemprop="text">
<p>I'm working on a script that needs to output numbers in a precision determined by length and not just decimal places. Let's say I want a max of 7 decimals but whole numbers above 7 digits are ok although they can't have decimals if the total amount of digits is 7 or higher.</p>
<p>So the rules are:</p>
<pre><code>- If a float has more than 7 digits of whole numbers, it loses it's decimals
- If a float has less than 7 digits of whole numbers, it gets a length of 7 total digits including decimals
- If a floats has no digits of whole numbers, it keeps 7 decimals
</code></pre>
<p>For example:</p>
<pre><code>a = 10000.02
b = 1.000002
c = 100000000000
</code></pre>
<p>are all correct.</p>
<p>How do I handle numbers (all <code>float</code>) in this format?   </p>
<p>For example:</p>
<pre><code>d = 892432589.54680
e = 382.39810758264057251
f = 452545871.1643548
g = 10254.968743541742
h = 165783438364325.126
</code></pre>
<p>I was thinking about something along the lines of:</p>
<pre><code>length_of_number = len(str(x))
    if length_of_number &gt; 7:
        x.round(0)
    else:
        x.round(7 - length_of_number)
</code></pre>
<p>but then I get in trouble with situations like  </p>
<pre><code>x= 0.5313231568943218748
</code></pre>
<p>because the whole <code>float</code> is longer than 7 digits.</p>
<p>What to do?</p>
<p>Edit for asked examples:</p>
<pre><code>12345678 is ok
1234567.1 is ok (but 1234567.12 not)
1.12345678 would become 1.123456
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't really get what you want, but perhaps this can help you?</p>
<pre><code>round(num_here, 7)
</code></pre>
<p>From the documentation:</p>
<blockquote>
<p>Return number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None, it returns the nearest integer to its input.</p>
<p>For the built-in types supporting <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer"><code>round()</code></a> , values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice (so, for example, both <code>round(0.5)</code> and <code>round(-0.5)</code> are 0, and <code>round(1.5)</code> is 2). Any integer value is valid for ndigits (positive, zero, or negative). The return value is an integer if called with one argument, otherwise of the same type as number.</p>
<p>For a general Python object number, <code>round(number, ndigits)</code> delegates to <code>number.__round__(ndigits)</code>.</p>
<blockquote>
<p><strong>Note:</strong> The behavior of <code>round()</code> for floats can be surprising: for example, <code>round(2.675, 2)</code> gives <code>2.67</code> instead of the expected <code>2.68</code>. This is not a bug: it's a result of the fact that most decimal fractions can't be represented exactly as a float. See <a href="https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues" rel="nofollow noreferrer">Floating Point Arithmetic: Issues and Limitations for more information</a>.</p>
</blockquote>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I think what you are asking can be solved in how you determine your length and also by finding if there is a decimal in your string or not.  For instance if you said</p>
<pre><code>&gt;&gt;&gt;a = 1325.6326
&gt;&gt;&gt;len(str(a).split(".")[0])
4
</code></pre>
<p>This will give you the length of all your numbers to the left of the decimal place.</p>
<pre><code>&gt;&gt;&gt;b = '.' in str(a)
&gt;&gt;&gt;print(b)
True
</code></pre>
<p>And this will tell you if there is a decimal place in your number.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def truncate(n):
    s = str(n)
    is_decimal = '.' in s
    if len(s) &lt;= 7 + is_decimal:
        return s
    if not is_decimal:
        return s
    fore, aft = s.split('.', 1)
    if len(fore) &gt;= 7:
        return fore
    if n &lt; 1:
        return '{:.7f}'.format(n)
    return f'{{:.{7-len(fore)}f}}'.format(n)
</code></pre>
<p>Here's one version, using string formatting to truncate the decimals.  It turns out that string formatting actually rounds, instead of dropping characters, so string slicing may work better for you</p>
<pre><code>def truncate(n):
    s = str(n)
    is_decimal = '.' in s
    if len(s) &lt;= 7 + is_decimal:
        return s
    if not is_decimal:
        return s
    fore, aft = s.split('.', 1)
    if len(fore) &gt;= 7:
        return fore
    if n &lt; 1:
        return '.' + aft[:7]
    return '{}.{}'.format(fore, aft[:7-len(fore)])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I change your code slightly and turned it into a function to make it easier to test.</p>
<pre><code>num = [892432589.54680,
  382.39810758264057251,
  452545871.1643548,
  10254.968743541742,
  165783438364325.126,
  0.5313231568943218748]

def trunc_num(x):
  num_int = int(x)
  length_of_number = len(str(num_int))
  if length_of_number &gt;= 7:
    return num_int
  else:
    return round(x, 7 - length_of_number)

for n in num:
  print(trunc_num(n))
</code></pre>
<p>By changing the number into an <code>int</code> the decimals are dropped and we can check the length of the number with out the decimal in the way. If the <code>int</code> is greater than 7 digits we just return the <code>int</code> else we round the number as you were trying before.</p>
<p>Output</p>
<pre><code>892432589
382.3981
452545871
10254.97
165783438364325
0.531323
</code></pre>
<p>If you need to account for negative numbers than you can just add <code>lstrip</code> after converting it to a string.</p>
<pre><code>length_of_number = len(str(num_int).lstrip('-'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a super simple version using string slicing:</p>
<pre><code>def seven(x):
    ret = lambda x: float(x) if '.' in str(x) else int(x)
    return ret(str(x)[:max(str(x).find('.'), 8 + ('-' in str(x)))].strip('.'))
</code></pre>
<h1>Output:</h1>
<pre><code>&lt;class 'int'&gt;           892432590
&lt;class 'int'&gt;          -892432590
&lt;class 'float'&gt;          382.3981
&lt;class 'float'&gt;         -382.3981
&lt;class 'int'&gt;           452545871
&lt;class 'int'&gt;          -452545871
&lt;class 'float'&gt;          10254.97
&lt;class 'float'&gt;         -10254.97
&lt;class 'int'&gt;     165783438364325
&lt;class 'int'&gt;    -165783438364325
&lt;class 'float'&gt;          0.531323
&lt;class 'float'&gt;         -0.531323
</code></pre>
<p>An alternative using <code>str.format()</code>:</p>
<pre><code>def seven(x):
    ret = lambda x: float(x) if '.' in x else int(x)
    return ret('{:.{cutoff}f}'.format(x, cutoff=7 - min(str(x).find('.') - ('-' in str(x)), 7)))
</code></pre>
</div>
<span class="comment-copy">You can't use commas like that in numeric literals.  <a href="https://www.python.org/dev/peps/pep-0515/" rel="nofollow noreferrer">Instead, as of Python 3.6, you can use underscores <code>_</code> to group digits in numeric literals</a></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/8885663/how-to-format-a-floating-number-to-fixed-width-in-python">How to format a floating number to fixed width in Python</a></span>
<span class="comment-copy">@patrick Oh sorry, I probably did that to make it more readable for humans. Forgetting that it's not how I handle the actual numbers in the script. I'll edit for clarity.</span>
<span class="comment-copy">@supersam654 I don't want my decimals to have a fixed width, I want to have a maximum amount of decimals determined by the length of the float.</span>
<span class="comment-copy">I'm having a problem understanding the expected results. Could you provide your expected outputs for <code>12345678</code>, <code>1234567.1</code>, and <code>1.12345678</code>, please?</span>
