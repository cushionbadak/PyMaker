<div class="post-text" itemprop="text">
<p>I'm trying to figure out if it's possible to create categories using custom filters.</p>
<p>I am building an e-commerce app and I have set up my category model using mptt. I am importing a csv that creates my top level categories which works fine. The problem is I will need to have sub-categories that are more specific e.g Men's Clothing(Top Level) &gt; Jeans.</p>
<p>The csv has several fields that contains info relating to each product e.g description: "stone wash bootcut jeans". I would ideally like to check these fields for keywords and add each product to the correct categories. Is it possible to set up categories this way or is there an alternative solution?</p>
<p>I am a django newbie so any help is appreciated.</p>
<p><strong>models.py</strong></p>
<pre><code>from django.db import models
from mptt.models import MPTTModel, TreeForeignKey

class Category(MPTTModel):
    name = models.CharField(max_length=50, unique=True)
    parent = TreeForeignKey('self', null=True, blank=True, related_name='children', db_index=True, on_delete=models.CASCADE)
    slug = models.SlugField()

    class MPTTMeta:
        order_insertion_by = ['name']

    class Meta:
        unique_together = (('parent', 'slug',))
        verbose_name_plural = 'categories'

    def get_slug_list(self):
        try:
            ancestors = self.get_ancestors(include_self=True)
        except:
            ancestors = []
        else:
            ancestors = [ i.slug for i in ancestors]
        slugs = []
        for i in range(len(ancestors)):
            slugs.append('/'.join(ancestors[:i+1]))
        return slugs


    def __str__(self):
        return self.name

class Brands(models.Model):
    brand_name = models.CharField(max_length=500, default='')

    def __str__(self):
        return self.brand_name


class Product(models.Model):
    aw_deep_link = models.CharField(max_length=500, default='')
    description = models.CharField(max_length=500, default='')
    product_name = models.CharField(max_length=500, default='')
    aw_image_url = models.CharField(max_length=500, default='')
    search_price = models.DecimalField(max_digits=6, decimal_places=2, null=True)
    merchant_name = models.CharField(max_length=500, default='')
    display_price = models.CharField(max_length=500, default='')
    brand_name = TreeForeignKey('Brands', on_delete=models.CASCADE)
    colour = models.CharField(max_length=500, default='')
    rrp_price = models.DecimalField(max_digits=6, decimal_places=2, null=True)
    category = TreeForeignKey('Category',null=True,blank=True, on_delete=models.CASCADE)
    slug = models.SlugField(default='')

    def __str__(self):
        return self.product_name
</code></pre>
<p><strong>importCSV.py</strong></p>
<pre><code>import re
from products.models import Category, Brands
from django.core.management.base import BaseCommand


class Command(BaseCommand):
    help = "Load some sample data into the db"

    def add_arguments(self, parser):
        parser.add_argument('--file', dest='file', help='File to load')

    def handle(self, **options):
        from products.models import Product

        if options['file']:
            print("Importing " + options['file'])

            with open(options['file']) as f:
                linecount = 0
                next(f)
                for line in f:
                    linecount += 1
                    fields = line.split(',')
                    category = Category.objects.get_or_create(name=fields[10])
                    brand_name = Brands.objects.get_or_create(brand_name=fields[7])

                    data = {
                            'aw_deep_link':  fields[0],
                            'description': fields[1],
                            'product_name': fields[2],
                            'aw_image_url':  fields[3],
                            'search_price':  fields[4],
                            'merchant_name': fields[5],
                            'display_price':  fields[6],
                            'brand_name':  brand_name[0],
                            'colour' :  fields[8],
                            'rrp_price' :  fields[9],
                            'category' :  category[0],

                    }

                    product = Product(**data)
                    product.save()

                print("Added {0} products".format(linecount))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So you have</p>
<ul>
<li>Manually predefined subcategories that may comprise more than one keyword</li>
<li>Several text fields for each Product where it is assured that any of the keywords appears at least once</li>
</ul>
<p>From this setup I would at first try to generalize the "search term" for each subcategroy, maybe by a regex, depending on the complexity of conditions that you need to identify a subcategory. Most probably a list of synonyms is already sufficient. Add such a field to your <code>Category</code> model (here a regex solution):</p>
<pre><code>class Category(models.Model):
    regex = models.CharField(max_length=100, blank=True)  # only needed for subcategories (top level from csv)
    ...
</code></pre>
<p>For your example where <code>trainers</code> and <code>runners</code> would be equivalent (to my English knowledge these are plural words here, so <strong>not</strong> equivalent to <code>trainer</code> or <code>runner</code> appearing anywhere), this would by (as a regex) <code>r'trainers|runners'</code></p>
<p>This is the part you need define manually - I don't envy your for the tedious work involved ;)</p>
<p>Afterwards, your import loop would need some changes around here:</p>
<pre><code>def handle(self, **options):
    from products.models import Product, Category
    all_categories = list(Category.objects.all())
    # converted to list to evaluate Queryset and don't query again in the loop below
</code></pre>
<p>and here</p>
<pre><code>                data = ...
                for textfield in ('description', 'product_name'):
                    # I suppose these are the two relevant fields to scan?
                    subcat = None
                    for cat in all_categories:
                        if re.search(cat.regex, data[textfield]) is not None:
                            if cat.is_leaf_node():
                                # only consider nodes that have no children
                                subcat = cat
                                break
                    if subcat is not None:
                        break
                # subcat is now the first matching subcategory
                if subcat is not None:
                    data['category'] = subcat


                product = Product(**data)
</code></pre>
<p>Complete</p>
<pre><code>import re
from products.models import Category, Brands
from django.core.management.base import BaseCommand


class Command(BaseCommand):
    help = "Load some sample data into the db"

    def add_arguments(self, parser):
        parser.add_argument('--file', dest='file', help='File to load')

    def handle(self, **options):
        from products.models import Product, Category
        all_categories = list(Category.objects.all())

        if options['file']:
            print("Importing " + options['file'])

            with open(options['file']) as f:
                linecount = 0
                next(f)
                for line in f:
                    linecount += 1
                    fields = line.split(',')
                    category = Category.objects.get_or_create(name=fields[10])
                    brand_name = Brands.objects.get_or_create(brand_name=fields[7])

                    data = {
                            'aw_deep_link':  fields[0],
                            'description': fields[1],
                            'product_name': fields[2],
                            'aw_image_url':  fields[3],
                            'search_price':  fields[4],
                            'merchant_name': fields[5],
                            'display_price':  fields[6],
                            'brand_name':  brand_name[0],
                            'colour' :  fields[8],
                            'rrp_price' :  fields[9],
                            'category' :  category[0],

                    }

                    for textfield in ('description', 'product_name'):
                        # I suppose these are the two relevant fields to scan?
                        subcat = None
                        for cat in all_categories:
                            if re.search(cat.regex, data[textfield]) is not None:
                                if cat.is_leaf_node():
                                    # only consider nodes that have no children
                                    subcat = cat
                                    break
                        if subcat is not None:
                            break
                    # subcat is now the first matching subcategory
                    if subcat is not None:
                        data['category'] = subcat

                    product = Product(**data)
                    product.save()

                print("Added {0} products".format(linecount))
</code></pre>
</div>
<span class="comment-copy">So you don't know your subcategories in advance but want an intelligent algorithm that reads the text and understands its meaning well enough to be able to decide which of the words would make up a good subcategory? That sounds like "Natural Language Processing", a task for machine learning. It would probably be easier to take the time and define your categories manually. Of course you could do a simple word count across all your text fields. This may help <i>you</i> to identify what's relevant.</span>
<span class="comment-copy">I would have pre-defined categories and sub-categories. The top level would be created by the csv and all sub-categories would be created manually. I'm trying to figure out how I can import the csv and have each product assigned to the correct sub-category @ascripter</span>
<span class="comment-copy">Can you assume exactly one sub-category keyword will always be present? Or can it be zero? Can it be more than one?</span>
<span class="comment-copy">There would be a minimum of one keyword and there may be variations of the word e.g trainers/runners. So if a keyword was mentioned in any of the data fields, it would assign the product to the correct category e.g Men’s Footwear &gt; Trainers. @ascripter</span>
<span class="comment-copy">Thanks, really appreciate the help, that's exactly what I'm looking for. I'm just slightly confused on how or where I create the regex. I understand it may be something like this - Trainers = r'trainers|runners' for each subcategory but I'm unsure how I implement it @ascripter</span>
<span class="comment-copy">OK, then I misunderstood your previous comment stating <i>I would have pre-defined categories and sub-categories</i>. You could add them via the django admin for example. Or write them in a csv and import from there.</span>
<span class="comment-copy">Sorry, I think I'm explaining this badly. I do have pre-defined categories and sub-categories (which have been created manually via admin). I'm just unsure how regex in models work. With the example of trainers being the sub-category and trainers/runners being the keywords, how and where would I write that? @ascripter</span>
<span class="comment-copy">For the admin, it is just a simple textfield (or <code>CharField</code>). You have to add that field to your model. A regex pattern is just a string. Maybe have a look <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">here</a>. This string is then used in the line with <code>re.search(cat.regex, ...)</code> as a regex pattern. If the pattern matches somewhere in the text you analyse, <code>re.search</code> will return a MatchObject, otherwise <code>None</code>. Does this make it clearer?</span>
<span class="comment-copy">Yes, it works perfectly. Thanks for your help and patience. I understand  what I have to do, now for the tedious work.</span>
