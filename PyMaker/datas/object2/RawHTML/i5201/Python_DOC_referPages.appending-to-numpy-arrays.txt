<div class="post-text" itemprop="text">
<p>I'm trying to construct a numpy array, and then append integers and another array to it.
I tried doing this:</p>
<pre><code>xyz_list = frag_str.split()
nums = numpy.array([])
coords = numpy.array([])
for i in range(int(len(xyz_list)/4)):
    numpy.append(nums, xyz_list[i*4])
    numpy.append(coords, xyz_list[i*4+1:(i+1)*4])
print(atoms)
print(coords)
</code></pre>
<p>Printing out the output only gives my empty arrays. Why is that?
In addition, how can I rewrite <code>coords</code> in a way that allows me to have 2D arrays like this: <code>array[[0,0,0],[0,0,1],[0,0,-1]]</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>numpy.append</code>, unlike python's <code>list.append</code>, does not perform operations in place. Therefore, you need to assign the result back to a variable, as below.</p>
<pre><code>import numpy

xyz_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
nums = numpy.array([])
coords = numpy.array([])

for i in range(int(len(xyz_list)/4)):
    nums = numpy.append(nums, xyz_list[i*4])
    coords = numpy.append(coords, xyz_list[i*4+1:(i+1)*4])

print(nums)    # [ 1.  5.  9.]
print(coords)  # [  2.   3.   4.   6.   7.   8.  10.  11.  12.]
</code></pre>
<p>You can reshape <code>coords</code> as follows:</p>
<pre><code>coords = coords.reshape(3, 3)

# array([[  2.,   3.,   4.],
#        [  6.,   7.,   8.],
#        [ 10.,  11.,  12.]])
</code></pre>
<p><strong>More details on <code>numpy.append</code> behaviour</strong></p>
<p><a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.append.html" rel="nofollow noreferrer">Documentation</a>:</p>
<blockquote>
<p>Returns: A copy of arr with values appended to axis. Note that
  append does not occur in-place: a new array is allocated and filled.</p>
</blockquote>
<p>If you know the shape of your <code>numpy</code> array output beforehand, it is efficient to instantiate via <code>np.zeros(n)</code> and fill it with results later.</p>
<p>Another option: if your calculations make heavy use of inserting elements <em>to the left</em> of an array, consider using <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a> from the standard library.</p>
</div>
<div class="post-text" itemprop="text">
<p>As stated above, <code>numpy.append</code> does not append items in place, but the reason why is important. You must store the returned array from <code>numpy.append</code> to the original variable, or else your code will not work. That being said, you should likely rethink your logic.</p>
<p>Numpy uses C-style arrays internally, which are arrays in contiguous memory without leading or trailing unused elements. In order to append an item to an array, Numpy must allocate a buffer of the array size + 1, copy all the data over, and add the appended element.</p>
<p>In pseudo-C code, this comes to the following:</p>
<pre><code>int* numpy_append(int* arr, size_t size, int element)
{
    int* new_arr = malloc(sizeof(int) * (size+1);
    mempcy(new_arr, arr, sizeof(int) * size);
    new_arr[size] = element;
    return new_arr;
}
</code></pre>
<p>This is extremely inefficient, since a new array must be allocated each time (memory allocation is slow), all the elements must be copied over, and the new element added to the end of the new array.</p>
<p>In comparison, Python lists reserve extra elements beyond the size of the container, until the size is the same as the capacity of the list, and grow exponentially. This is much more efficient for insertions at the end of the container than reallocating the entire buffer each time.</p>
<p>You should use Python lists and <code>list.append</code>, and then convert the new list to a NumPy array. Or, if performance is truly critical, use a C++-extension using <code>std::vector</code> rather than <code>numpy.append</code> in all scenarios. Re-write your code, or it will be glacial.</p>
<p><strong>Edit</strong> </p>
<p>Also,as pointed out in the comments, if you know the size of a Numpy array before hand, pre-allocating it with <code>np.zeros(n)</code> is efficient, as is using a custom wrapper around a NumPy array</p>
<pre><code>class extendable_array:
    def __init__(self, size=0, dtype=np.int):
        self.arr = np.array(dtype=dtype)
        self.size = size

    def grow(self):
        '''Double the array'''

        arr = self.arr
        self.arr = np.zeros(min(arr.size * 2, 1), dtype=arr.dtype)
        self.arr[:arr.size] = arr

    def append(self, value):
        '''Append a value to the array'''

        if self.arr.size == self.size:
            self.grow()

        self.arr[self.size] = value
        self.size += 1.

    # add more methods here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>np.append</code> is not a list clone.  It is a clumsy wrapper to <code>np.concatenate</code>.  It is better to learn to use that correctly.</p>
<pre><code>xyz_list = frag_str.split()
nums = []
coords = []
for i in range(int(len(xyz_list)/4)):
    nums.append(xyz_list[i*4])
    coords.append(xyz_list[i*4+1:(i+1)*4])
nums = np.concatenate(nums)
coords = np.concatenate(coords)
</code></pre>
<p>List append is faster, and easier to initialize.  <code>np.concatenate</code> works fine with a list of arrays.  <code>np.append</code> uses <code>concatenate</code>, but only accepts two inputs.  <code>np.array</code> is needed if the list contains numbers or strings.</p>
<hr/>
<p>You don't give an example of <code>frag_str</code>.  But the name and the use of <code>split</code> suggests it is a string.  I don't think anything else has a <code>split</code> method.</p>
<pre><code>In [74]: alist = 'one two three four five six seven eight'.split()
</code></pre>
<p>That's a list of strings.  Using your indexing I can construct 2 lists:</p>
<pre><code>In [76]: [alist[i*4] for i in range(2)]
Out[76]: ['one', 'five']

In [77]: [alist[i*4+1:(i+1)*4] for i in range(2)]
Out[77]: [['two', 'three', 'four'], ['six', 'seven', 'eight']]
</code></pre>
<p>And I can make arrays from each of those lists:</p>
<pre><code>In [78]: np.array(Out[76])
Out[78]: array(['one', 'five'], dtype='&lt;U4')
In [79]: np.array(Out[77])
Out[79]: 
array([['two', 'three', 'four'],
       ['six', 'seven', 'eight']], dtype='&lt;U5')
</code></pre>
<p>In the first case the array is 1d, in the second, 2d.</p>
<p>It the string contains digits, we can make an integer array by specifying <code>dtype</code>.</p>
<pre><code>In [80]: alist = '1 2 3 4 5 6 7 8'.split()
In [81]: np.array([alist[i*4] for i in range(2)])
Out[81]: array(['1', '5'], dtype='&lt;U1')
In [82]: np.array([alist[i*4] for i in range(2)], dtype=int)
Out[82]: array([1, 5])
</code></pre>
</div>
<span class="comment-copy">Looks like <code>frag_str</code> is a string, which you are splitting into a list on whitespace.  I don't see where you are getting integers.</span>
<span class="comment-copy">Note, if you are only appending to "the right", i.e. <code>.append</code>, then a <code>list</code> is a better substitute. <code>deque</code> is optimized for appending from both sides.</span>
<span class="comment-copy">I would add: if you know the size of your resulting <code>numpy</code> array, then instantiating an empty array, e.g. <code>np.zeros(n)</code>, beforehand and filling it is efficient.</span>
<span class="comment-copy">@jp_data_analysis Edited, also added a custom wrapper to create an extendable array with a growth factor of 2.</span>
