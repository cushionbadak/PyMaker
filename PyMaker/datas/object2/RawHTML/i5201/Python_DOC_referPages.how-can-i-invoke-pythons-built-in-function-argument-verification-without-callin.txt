<div class="post-text" itemprop="text">
<p>Python obviously has a way to verify whether a function call has valid arguments (correct number of positional arguments, correct keyword arguments, etc). The following is a basic example of what I mean:</p>
<pre><code>def test_func(x, y, z=None):
    print(x, y, z)

test_func(2)  # Raises a "missing positional argument" TypeError
test_func(1, 2, 3, a=5)  # Raises an "unexpected keyword argument" TypeError
</code></pre>
<p>Is there a way that I can use this argument verification, without actually calling the function?</p>
<p>I'm basically trying to write a decorator that does some preprocessing steps based on the function arguments before calling the wrapped function itself, such as:</p>
<pre><code>def preprocess(func):
    def wrapper(*args, **kwargs):
        # Verify *args and **kwargs are valid for the original function.
        # I want the exact behavior of calling func() in the case of bad arguments,
        # but without actually calling func() if the arguments are ok.

        preprocess_stuff(*args, **kwargs)
        func(*args, **kwargs)
    return wrapper
</code></pre>
<p>I want my <code>wrapper</code> function to verify that the arguments would be valid if used on the wrapped function before doing any preprocessing work.</p>
<p>I would like to take advantage of the checks Python already does every time you call a function and the various exceptions it will raise. I just do not want to <em>actually</em> call the function, because the function may not be idempotent. Writing my own checks and exceptions feels like reinventing the wheel.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't invoke the actual built-in argument verification for a function without calling the function, but you can use something pretty close.</p>
<p>The <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> module has a function <a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow noreferrer"><code>signature()</code></a>, which returns a <a href="https://docs.python.org/3.5/library/inspect.html#inspect.Signature" rel="nofollow noreferrer"><code>Signature</code></a> object representing the argument signature of the function passed to it. That <code>Signature</code> object has a <a href="https://docs.python.org/3.5/library/inspect.html#inspect.Signature.bind" rel="nofollow noreferrer"><code>bind()</code></a> method which attempts to create a <a href="https://docs.python.org/3.5/library/inspect.html#inspect.BoundArguments" rel="nofollow noreferrer"><code>BoundArguments</code></a> object using the arguments passed to it. If those arguments don't match the signature, a <code>TypeError</code> is raised.</p>
<p>While this mostly behaves like the built-in argument binding logic, it has a few differences. For example, it can't always determine the signature of functions written in C, and its interaction with decorators will depend on whether they use <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps</code></a> (or something else that sets the <code>__wrapped__</code> attribute). That said, since the real argument binding logic is inaccessible, <code>inspect.signature</code> is the best alternative.</p>
<p>We can use all this to create your decorator:</p>
<pre><code>import functools
import inspect

def preprocess(func):
    sig = inspect.signature(func)
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        try:
            sig.bind(*args, **kwargs)
        except TypeError:
            pass  # bad arguments; skip preprocessing
        else:
            print("Preprocessing: args=%r, kwargs=%r" % (args, kwargs))
            # ... etc.
        return func(*args, **kwargs)
    return wrapper
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code>@preprocess
def test_func(x, y, z=None):
    print(x, y, z)
</code></pre>
<p> </p>
<pre><code>&gt;&gt;&gt; test_func(2)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 10, in wrapper
TypeError: test_func() missing 1 required positional argument: 'y'
</code></pre>
<p> </p>
<pre><code>&gt;&gt;&gt; test_func(1, 2, 3, a=5)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 10, in wrapper
TypeError: test_func() got an unexpected keyword argument 'a'
</code></pre>
<p> </p>
<pre><code>&gt;&gt;&gt; test_func(1, 2)
Preprocessing: args=(1, 2), kwargs={}
1 2 None
</code></pre>
<p>Note that, if bad arguments are supplied, you <strong>do</strong> in fact want to call the function, because you "want the exact behavior of calling func() in the case of bad arguments" (to quote your comment), and the only way of getting the exact behaviour of calling an arbitrary function (even if that behaviour is to immediately fail) is to actually call it. What you <strong>don't</strong> want to do in such cases is the preprocessing, which the decorator above achieves for you.</p>
</div>
<span class="comment-copy">Very elegant! Looks like I can even use <code>bind().arguments</code> to get at specific named arguments even if I do not know whether they were passed as positional or keywork arguments. As a small bonus question: Is there a name for this kind of argument validity (where the args may or may not be logically valid, but satisfy the function interface)? Lexically valid? Syntactically valid?</span>
<span class="comment-copy">@ChristopherSheaf I don't know of a specific term, so I guess you get to choose your own. Interfactual validity, perhaps?</span>
