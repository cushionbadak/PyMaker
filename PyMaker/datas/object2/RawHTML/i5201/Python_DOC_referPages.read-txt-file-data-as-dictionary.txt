<div class="post-text" itemprop="text">
<p>I am new to python. I have a txt file which contains input data for a 3D model:</p>
<pre><code>...
# comments
rfk = [1e-5, 1e-7, 1e-1]
rsig = [0.0005]
# comments
lengths = [[13,13,1.6],[13,13,1.6],[13,13,1.6]]
...
</code></pre>
<p>I guess the best way to extract the data for further processing is to save them into dictionaries - like this:</p>
<pre><code>data1 = {rfk:[1e-5, 1e-7, 1e-1], rsig:[0.0005], lengths:[[13,13,1.6],[13,13,1.6],[13,13,1.6]]}
</code></pre>
<p>I now struggle a little bit with reading the file and saving the data (by ignoring the comments) like in my example as dictionaries. My approach for reading the data from the file was like this:</p>
<pre><code>for line in open("myfile.txt"):
    li=line.strip()
    if not li.startswith("#"):        
        # what to do here?
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a> to evaluate the right hand side into Python objects</p>
<pre><code>from ast import literal_eval

with open('myfile.txt') as file:
    d = {}
    for line in file:
        line = line.strip()
        if not line.startswith('#'):
            key, value = map(str.strip, line.split('='))
            d[key] = literal_eval(value)
</code></pre>
<p>For your example data, <code>d</code> is then</p>
<pre><code>{'rfk': [1e-05, 1e-07, 0.1], 'rsig': [0.0005], 'lengths': [[13, 13, 1.6], [13, 13, 1.6], [13, 13, 1.6]]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the string method <code>partition</code>* to seperate your data to key and value for your dictionary, <br/>
The string method <code>strip</code> to clean up your key's string from leading and tailing spaces
<br/>
And then the built-in function <code>eval</code> to extract the pythonic object from the value's string, as such:</p>
<pre><code>with open('myfile.txt') as file:
    d = {}
    for line in file:
        line = line.strip()
        if not line.startswith('#'):
            key, _ ,value = line.partition('=')
            d[key.strip()] = eval(value)
</code></pre>
<p>*<code>partition</code> splits your string in the first occurance of your delimiter 
(which is '=' in this case)<br/>
and returns a <code>list</code> of [leading string, delimiter, following string]</p>
</div>
<div class="post-text" itemprop="text">
<p>You can treat the at as json and add a few safety checks:</p>
<pre><code>import json

data = {}
with open('thefile.txt') as fobj:
    for raw_line in fobj:
        line = raw_line.strip()
        if line and not line.startswith('#'):
            try:
                key, values = line.split('=', 1)
            except ValueError:
                print('skipping invalid line:')
                print(line)
            try:
                data[key.strip()] = json.loads(values)
            except json.JSONDecodeError
                print('skipping invalid line (no JSON):')
                print(line)
</code></pre>
<p>for your example <code>data</code> contains:</p>
<pre><code>{'lengths': [[13, 13, 1.6], [13, 13, 1.6], [13, 13, 1.6]],
 'rfk': [1e-05, 1e-07, 0.1],
 'rsig': [0.0005]}
</code></pre>
</div>
<span class="comment-copy">Your text file's contents looks like a kind of config file; modules for handling such things might be useful here.</span>
<span class="comment-copy">Patrick, thanks for your feedback! However, I get the ValueError:  "not enough values to unpack (expected 2, got 1)".  What does that mean? Might this be problem with my input data?</span>
<span class="comment-copy">Some line of your input data does not start with a hash <code>#</code> and does not contain an equals sign <code>=</code>.</span>
