<div class="post-text" itemprop="text">
<p>I'm following a basic tutorial on logging in Python, <a href="https://docs.python.org/3/howto/logging.html#a-simple-example" rel="nofollow noreferrer">https://docs.python.org/3/howto/logging.html#a-simple-example</a>, and following the steps in an iPython console. As described there, the default level of the root logger is <code>WARNING</code>:</p>
<pre><code>In [1]: import logging

In [2]: logging.warning('Watch out!')
WARNING:root:Watch out!

In [3]: logging.info('I told you so')
</code></pre>
<p>I'd like to explicitly set the level of the root logger to <code>INFO</code>. I tried doing it using <code>name='root'</code>, but this has no apparent effect:</p>
<pre><code>In [4]: logging.getLogger('root').setLevel(logging.INFO)

In [5]: logging.info('I told you so')
</code></pre>
<p>I am able to set the level of the root logger if I call <code>logging.getLogger()</code> without arguments:</p>
<pre><code>In [6]: logging.getLogger().setLevel(logging.INFO)

In [7]: logging.info('I told you so')
INFO:root:I told you so
</code></pre>
<p>I'm curious, though, why this didn't work the first time? It would seem that this should work since its <code>name</code> attribute is 'root':</p>
<pre><code>In [12]: root_logger = logging.getLogger()

In [14]: root_logger.name
Out[14]: 'root'
</code></pre>
<p>In short, if I didn't want to rely on the default, what name would I pass to <code>logging.getLogger()</code> in order to get the root logger?</p>
</div>
<div class="post-text" itemprop="text">
<p>The root logger's name is <code>root</code>, but you can't access the root logger by name.</p>
<p>Inspecting <a href="https://bugs.python.org/file4410/logging.py" rel="nofollow noreferrer">logging.py</a> reveals this:</p>
<pre><code>def __init__(self, root):
    """
    Initialize the manager with the root node of the logger hierarchy.
    """
    self.root = root
    self.disable = 0
    self.emittedNoHandlerWarning = 0
    self.loggerDict = {}
</code></pre>
<p><code>root</code> is stored separately from <code>loggerDict</code>, which is where all named loggers go.</p>
<pre><code>def getLogger(name=None):
    """
    Return a logger with the specified name, creating it if necessary.
    If no name is specified, return the root logger.
    """
    if name:
        return Logger.manager.getLogger(name)
    else:
        return root
</code></pre>
<p>You can follow the <code>manager.getLogger</code> internal function and find it cannot find <code>root</code>:</p>
<pre><code>def getLogger(self, name):
        """
        Get a logger with the specified name (channel name), creating it
        if it doesn't yet exist. If a PlaceHolder existed for the specified
        name [i.e. the logger didn't exist but a child of it did], replace
        it with the created logger and fix up the parent/child references
        which pointed to the placeholder to now point to the logger.
        """
        rv = None
        _acquireLock()
        try:
            if self.loggerDict.has_key(name):
                rv = self.loggerDict[name]
                if isinstance(rv, PlaceHolder):
                    ph = rv
                    rv = _loggerClass(name)
                    rv.manager = self
                    self.loggerDict[name] = rv
                    self._fixupChildren(ph, rv)
                    self._fixupParents(rv)
            else:
                rv = _loggerClass(name)
                rv.manager = self
                self.loggerDict[name] = rv
                self._fixupParents(rv)
        finally:
            _releaseLock()
        return rv
</code></pre>
</div>
<span class="comment-copy">The root logger has a <code>name</code> attribute, but it's not stored in the dictionary with other loggers you define and thus isn't accessible by name via <code>getLogger()</code></span>
