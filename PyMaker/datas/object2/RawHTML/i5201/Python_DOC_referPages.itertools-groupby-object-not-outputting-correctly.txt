<div class="post-text" itemprop="text">
<p>I was trying to use itertools.groupby to help me group a list of integers by positive or negative property, for example:</p>
<p>input </p>
<pre><code>[1,2,3, -1,-2,-3, 1,2,3, -1,-2,-3] 
</code></pre>
<p>will return </p>
<pre><code>[[1,2,3],[-1,-2,-3],[1,2,3],[-1,-2,-3]]
</code></pre>
<p>However if I:</p>
<pre><code>import itertools

nums = [1,2,3, -1,-2,-3, 1,2,3, -1,-2,-3]
group_list = list(itertools.groupby(nums, key=lambda x: x&gt;=0))
print(group_list)
for k, v in group_list:
    print(list(v))
&gt;&gt;&gt;
[]
[-3]
[]
[]
</code></pre>
<p>But if I don't <code>list()</code> the groupby object, it will work fine:</p>
<pre><code>nums = [1,2,3, -1,-2,-3, 1,2,3, -1,-2,-3]
group_list = itertools.groupby(nums, key=lambda x: x&gt;=0)
for k, v in group_list:
    print(list(v))
&gt;&gt;&gt;
[1, 2, 3]
[-1, -2, -3]
[1, 2, 3]
[-1, -2, -3]
</code></pre>
<p>What I don't understand is, a groupby object is a iterator composed by a pair of key and <code>_grouper</code> object, a call of <code>list()</code> of a groupby object should not consume the <code>_grouper</code> object?</p>
<p>And even if it did consume, how did I get <code>[-3]</code> from the second element?</p>
</div>
<div class="post-text" itemprop="text">
<p>Per <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">the docs</a>, it is explicitly noted that advancing the <code>groupby</code> object renders the previous group unusable (in practice, empty):</p>
<blockquote>
<p>The returned group is itself an iterator that shares the underlying iterable with <code>groupby()</code>. Because the source is shared, when the <code>groupby()</code> object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list.</p>
</blockquote>
<p>Basically, instead of <code>list</code>-ifying directly with the <code>list</code> constructor, you'd need a listcomp that converts from group iterators to <code>list</code>s before advancing the <code>groupby</code> object, replacing:</p>
<pre><code>group_list = list(itertools.groupby(nums, key=lambda x: x&gt;=0))
</code></pre>
<p>with:</p>
<pre><code>group_list = [(k, list(g)) for k, g in itertools.groupby(nums, key=lambda x: x&gt;=0)]
</code></pre>
<p>The design of most <code>itertools</code> module types is intended to avoid storing data implicitly, because they're intended to be used with potentially huge inputs. If all the groupers stored copies of all the data from the input (and the <code>groupby</code> object had to be sure to retroactively populate them), it would get ugly, and potentially blow memory by accident. By forcing you to make storing the values explicit, you don't accidentally store unbounded amounts of data unintentionally, per the Zen of Python:</p>
<blockquote>
<p>Explicit is better than implicit.</p>
</blockquote>
</div>
<span class="comment-copy">Just use a list comprehension: <code>groups = [list(g) for _, g in groupby(nums, lambda n: n &gt;= 0)]</code>.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/773/how-do-i-use-pythons-itertools-groupby" title="how do i use pythons itertools groupby">stackoverflow.com/questions/773/â€¦</a></span>
<span class="comment-copy">@ChristianDean Hey there, it's you again! I understand how should I do it right, but I don't understand why that call on <code>list()</code> make things wrong.</span>
<span class="comment-copy">@Code_Control_jxie0755 Yep, I patrol the site quite frequently :-). Were you still confused after reading the answer posted below? If so, by what?</span>
<span class="comment-copy">@ChristianDean after reading that additional paragraph, now I understand!</span>
<span class="comment-copy">I understand, the second code snippet is the way you suggested to replace with. But I still don't quite get what you quote from the docs, and don't understand where that <code>[-3]</code> comes from</span>
<span class="comment-copy">@Code_Control_jxie0755: Every time you pull a new <code>key</code>/<code>group</code> pair from a <code>groupby</code> (advancing the <code>groupby</code> iterator), any existing <code>group</code>s are effectively emptied. <code>groupby</code> is super lazy; it's only keeping one copy of the underlying iterator and advancing it on demand, either once per iteration of the group, or skipping all remaining members of the group (if the <code>groupby</code> object itself is advanced). There is no separate state.</span>
<span class="comment-copy">@Code_Control_jxie0755: The <code>[-3]</code> is an implementation quirk; when you run out the groupby, it's left in a state handling a negative group. The first negative group object you read from doesn't really know it's invalid, so it pulls the final value in the cache and says "hey, this is totally part of my group" and yields it. It probably shouldn't, so this is a minor bug in the implementation (don't rely on it), but it's not really that important; using a group iterator after advancing past it is the closest thing Python has to undefined behavior, so behaving weirdly isn't really unexpected.</span>
<span class="comment-copy">@Code_Control_jxie0755: Cool. If you want a clearer demonstration of where the <code>-3</code> is coming from, change <code>nums</code> to <code>nums = [1,2,3,-1,-2,-3,4,5,6,-4,-5,-6]</code>, then do <code>[(k, list(g)) for k, g in list(itertools.groupby(nums, key=lambda x: x&gt;=0))]</code>. You'll notice the second group isn't producing <code>-3</code> now, it's producing <code>-6</code> (the last member of the fourth group). Like I said, it's essentially undefined behavior and an implementation quirk.</span>
<span class="comment-copy">@Code_Control_jxie0755: Yeah. The first group that is advanced with a <code>key</code> value that matches <code>-6</code> happens to be pulling the <code>-6</code> that got cached inside the <code>groupby</code> object (it needs to cache up to one value when a group ends so the data isn't lost for the next group; it should have cleared it when the iterator was exhausted, but looks like the implementation didn't do so explicitly, and it just hung around). The second group looks for all the negative values, finds the one in the cache, yields it and clears the cache, and doesn't realize its "real" group had long since expired.</span>
