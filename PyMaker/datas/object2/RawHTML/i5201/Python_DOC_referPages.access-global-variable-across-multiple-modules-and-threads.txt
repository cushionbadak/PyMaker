<div class="post-text" itemprop="text">
<p>I have two python scripts which import each other and access a variable defined in the first script. But changes made to this variable are not seen in the other module.</p>
<p>Code with which the behavior can be reproduced:</p>
<p>File <code>a.py</code></p>
<pre><code>import time
import b

X = {}

def set():
    global X
    X[time.time()] = 1

def get():
    global X
    return X

if __name__ == '__main__':
    b.monitor()
    while True:
        time.sleep(1)
        set()
</code></pre>
<p>File <code>b.py</code>:</p>
<pre><code>import threading
import time

from a import get

def f():
    while True:
        time.sleep(1)
        print get(), 'in b'

def monitor():
    t = threading.Thread(target=f)
    t.setDaemon(True)
    t.start()
</code></pre>
<p>Run the program with <code>python a.py</code>. The result is:</p>
<pre><code>{} in b
{} in b
{} in b
...
</code></pre>
<p>Expected output:</p>
<pre><code>{"1518106774": 1} in b
{"1518106774": 1, "1518106775": 1} in b
{"1518106774": 1, "1518106775": 1, "1518106776": 1} in b
... // etc
</code></pre>
<p>... where the keys are <code>time.time()</code> strings.</p>
<p>I thought the global variable <code>X</code> should be able to be referenced wherever we want to. So why is <code>X</code> not updated in <code>b.f</code> even though the call to <code>set</code> is adding these keys to it?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that two instances of the variable X are created in such a set-up: one in <code>a.py</code> and another in <code>b.py</code>. The problem also occurs in this example that reduces it to the essence -- it is not related to creating threads:</p>
<h2>Problem in most simple form</h2>
<p>File <code>a.py</code>:</p>
<pre><code>X = "original value"
import b
if __name__ == '__main__':
    b.monitor()
    print ('A', X)
</code></pre>
<p>File <code>b.py</code>:</p>
<pre><code>import a
def monitor():
    print ('B', a.X)
    a.X = "new value"
    print ('B', a.X)
</code></pre>
<p>When running <code>a.py</code> the output is:</p>
<blockquote>
<p>B original value<br/>
  B new value<br/>
  A original value</p>
</blockquote>
<p>If the same <code>X</code> were accessed, then the last line of the output would have read:</p>
<blockquote>
<p>A new value</p>
</blockquote>
<h3>Explanation</h3>
<p>This happens because <code>import</code> creates new instances of all global names therein. It will do this only upon the first time <code>import a</code> is encountered, and it really is the first time here. The module created by <em>execution</em> of <code>a.py</code> is named <code>__main__</code>, not <code>a</code>. Since this name is different from <code>a</code>, <code>import a</code> will really import the module, and not just reference the already loaded <code>__main__</code> module. See also the <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="nofollow noreferrer">Python documentation</a> for a description of how module names are resolved.</p>
<p>As a consequence the names in these two modules are distinct; <code>import a</code> does not make the <code>__main__</code> names accessible to the other module.</p>
<h3>Solution</h3>
<p>A quick solution is to replace the <code>import a</code> statement in <code>b.py</code> with an <code>import __main__</code> statement, and use <code>__main__.X</code> as the qualified name you want to access in <code>b.py</code>. But this is not regarded the <a href="https://stackoverflow.com/a/24023850/5459839">advised way to proceed</a>.</p>
<p>A more robust way is to ensure the global variables are not defined in the executed script, but in an imported module -- one that is imported by <em>both</em> <code>a.py</code> and <code>b.py</code>. The second <code>import</code> will make the names available that were defined when the first <code>import</code> was parsed:</p>
<p>File <code>common.py</code>:</p>
<pre><code>X = "original value"
</code></pre>
<p>File <code>a.py</code>:</p>
<pre><code>import common
import b
if __name__ == '__main__':
    b.monitor()
    print ('A', common.X)
</code></pre>
<p>File <code>b.py</code>:</p>
<pre><code>import common
def monitor():
    print ('B', common.X)
    common.X = "new value"
    print ('B', common.X)
</code></pre>
<p>Now the output is:</p>
<blockquote>
<p>B original value<br/>
  B new value<br/>
  A new value</p>
</blockquote>
<h2>Solution applied to your code</h2>
<p>File <code>common.py</code>:</p>
<pre><code>import time
X = {}
def set():
    global X
    X[time.time()] = 1

def get():
    global X
    return X
</code></pre>
<p>File <code>a.py</code>:</p>
<pre><code>import common
import time
import b

if __name__ == '__main__':
    b.monitor()
    while True:
        time.sleep(1)
        common.set()
</code></pre>
<p>File <code>b.py</code>:</p>
<pre><code>import common
import threading
import time

def f():
    while True:
        time.sleep(1)
        print common.get(), 'in b'

def monitor():
    t = threading.Thread(target=f)
    t.setDaemon(True)
    t.start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>a.py</h1>
<pre><code>import time
import b

X = {}


def set():
    # global X
    X[time.time()] = 1


def get():
    global X
    return X


if __name__ == '__main__':
    b.monitor()
    while True:
        time.sleep(1)
</code></pre>
<h1>b.py</h1>
<pre><code>import threading
import time
import a


def f():
    while True:
        time.sleep(1)
        a.set()
        print a.get(), 'in b'


def monitor():
    t = threading.Thread(target=f)
    t.setDaemon(True)
    t.start()
</code></pre>
<h1>and finally here's your answer:</h1>
<pre><code>{1518083438.771415: 1} in b
{1518083438.771415: 1, 1518083439.772717: 1} in b
{1518083440.773916: 1, 1518083438.771415: 1, 1518083439.772717: 1} in b
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the answer lies in the fact that python does not truly allow global variables. A scope of a global is typically only in the same module. So when another module imports a module with globals, the namespace is copied and a variable is created with same original value. An imported Python module will not have direct access to the globals in the module which imports it, nor vice versa. </p>
<p>You may want to read the section 1.2.5 &amp; 1.15.6 from  Norman Matloff's <a href="http://heather.cs.ucdavis.edu/~matloff/Python/PLN/FastLanePython.pdf" rel="nofollow noreferrer">Quick and Painless Python PDF Tutorial</a></p>
</div>
<span class="comment-copy">Also <code>get()</code> never gets called. And if you want to change dictionary <code>X</code> in <code>set()</code> you have to have <code>global X</code> in it.</span>
<span class="comment-copy">i ran the code as one file. I got the output as u expected except the first time [{} in b {1518081548.076467: 1, 1518081549.077585: 1} in b {1518081548.076467: 1, 1518081549.077585: 1, 1518081550.078685: 1} in b {1518081548.076467: 1, 1518081549.077585: 1, 1518081550.078685: 1, 1518081551.079762: 1} in b {1518081552.080953: 1, 1518081548.076467: 1, 1518081549.077585: 1, 1518081550.078685: 1, 1518081551.079762: 1} in b]</span>
<span class="comment-copy">@shiva Put them into two files</span>
<span class="comment-copy">Very helpful. But in term of the executed script part, by which you said it doesn't apply to the rules, where can I find any document or proof on that?</span>
<span class="comment-copy">See update in the "Explanation" and "Solution" paragraphs.</span>
<span class="comment-copy">Obviously this is not what I want. You just made the code correct, but didn't explain why the original version was wrong.</span>
<span class="comment-copy">The most mysterious part of my original code is that, I was modifying the variable in a.py and reading it in b.py. However the sharing global variable was not correct.</span>
<span class="comment-copy">because in f() of b.py has while loop which will never exit until we stop it and u mentioned set() in while loop which is below b.monitor() in a.py and it'll never go in to the while loop which is in a.py</span>
<span class="comment-copy">while loop in f() of b.py will never terminate and it'll get blocked there itself and will never go to while loop of a.py. That's why it shown X= {} every time.</span>
