<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/typing.html" rel="noreferrer"><code>typing</code></a> module provides a base class for generic type hints: The <a href="https://docs.python.org/3/library/typing.html#typing.Generic" rel="noreferrer"><code>typing.Generic</code></a> class.</p>
<p>Subclasses of <code>Generic</code> accept type arguments in square brackets, for example:</p>
<pre><code>list_of_ints = typing.List[int]
str_to_bool_dict = typing.Dict[str, bool]
</code></pre>
<hr/>
<p>My question is, how can I access these type arguments?</p>
<p>That is, given <code>str_to_bool_dict</code> as input, how can I get <code>str</code> and <code>bool</code> as output?</p>
<p>Basically I'm looking for a function such that</p>
<pre><code>&gt;&gt;&gt; magic_function(str_to_bool_dict)
(&lt;class 'str'&gt;, &lt;class 'bool'&gt;)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Possibility 1</h2>
<p>As of Python 3.6. there is a public <code>__args__</code> and (<code>__parameters__</code>) field.
For instance:</p>
<pre><code>print( typing.List[int].__args__ )
</code></pre>
<p>This contains the generic parameters (i.e. <code>int</code>), whilst <code>__parameters__</code> contains the generic itself (i.e. <code>~T</code>). </p>
<h2>Possibility 2</h2>
<p>Use <a href="https://github.com/ilevkivskyi/typing_inspect" rel="noreferrer">typing_inspect.getargs</a></p>
<h2>Which to use</h2>
<p><code>typing</code> follows <a href="https://www.python.org/dev/peps/pep-0008/" rel="noreferrer">PEP8</a>. Both PEP8 and <code>typing</code> are coauthored by Guido van Rossum. A double leading and trailing underscore is defined in  as: <em>"“magic” objects or attributes that live in <strong>user-controlled namespaces</strong>"</em>.</p>
<p>The dunders are also commented in-line; from the official repository for <a href="https://github.com/python/typing" rel="noreferrer">typing</a> we
can see:
* <em>"<code>__args__</code> is a tuple of all arguments used in subscripting, e.g., <code>Dict[T, int].__args__ == (T, int)</code>".</em></p>
<p>However, the <a href="https://github.com/python/typing/issues/480" rel="noreferrer">authors also note</a>:
* <em>"The typing module has provisional status, so it is not covered by the high standards of backward compatibility (although we try to keep it as much as possible), this is especially true for (yet undocumented) dunder attributes like <code>__union_params__</code>. If you want to work with typing types in runtime context, then you may be interested in the <code>typing_inspect</code> project (part of which may end up in typing later)."</em></p>
<p>I general, whatever you do with <code>typing</code> will need to be kept up-to-date for the time being. If you need forward compatible changes, I'd recommend writing your own annotation classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems that this inner method will do the trick</p>
<pre><code>typing.List[int]._subs_tree()
</code></pre>
<p>which returns the tuple:</p>
<pre><code>(typing.List, &lt;class 'int'&gt;)
</code></pre>
<p>But this a private API, probably there is a better answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I know, there is no happy answer here.</p>
<p>What comes to mind is the <code>__args__</code> undocumented attribute which stores this information:</p>
<pre><code>list_of_ints.__args__
&gt;&gt;&gt;(&lt;class 'int'&gt;,)

str_to_bool_dict.__args__
&gt;&gt;&gt;(&lt;class 'str'&gt;, &lt;class 'bool'&gt;)
</code></pre>
<p>but there is no mention of it in the documentation of the <code>typing</code> module.</p>
<p>It is worth noting that it was <a href="https://github.com/python/typing/issues/335" rel="nofollow noreferrer">very close to be mentioned</a> in the documentation though:</p>
<blockquote>
<p>Probably we should also discuss whether we need to document all keyword arguments for <code>GenericMeta.__new__</code>. There are <code>tvars</code>, <code>args</code>, <code>origin</code>, <code>extra</code>, and <code>orig_bases</code>. I think we could say something about first three (they correspond to <code>__parameters__</code>, <code>__args__</code>, and <code>__origin__</code> and these are used by most things in typing).</p>
</blockquote>
<p>But <a href="https://github.com/python/typing/pull/340" rel="nofollow noreferrer">it did not quite make it</a>:</p>
<blockquote>
<p>I added <code>GenericMeta</code> to <code>__all__</code> and added docstrings to <code>GenericMeta</code> and <code>GenericMeta.__new__</code> following the discussion in the issue.
  I decided not to describe <code>__origin__</code> and friends in docstrings. Instead, I just added a comment at the place where they are first used.</p>
</blockquote>
<p>From there, you still have three non-mutually exclusive options:</p>
<ul>
<li><p>wait for the <code>typing</code> module to reach full maturity and hope these features will be documented soon</p></li>
<li><p>join the <a href="https://mail.python.org/mailman/listinfo/python-ideas" rel="nofollow noreferrer">Python ideas mailing list</a> and see if enough support can be gathered to make these internals public / part of the API</p></li>
<li><p>work in the meantime with the undocumented internals, making a gamble that there won't be changes to these or that the changes will be minor.</p></li>
</ul>
<p>Note that the third point can hardly be avoided as even the <a href="https://docs.python.org/3.6/library/typing.html" rel="nofollow noreferrer">API can be subject to changes</a>:</p>
<blockquote>
<p>The typing module has been included in the standard library on a provisional basis. New features might be added and <strong>API may change even between minor releases if deemed necessary by the core developers</strong>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Use the <code>.__args__</code> on your constructs. So the magic function you need is something like --</p>
<pre><code>get_type_args = lambda genrc_type: getattr(genrc_type, '__args__')
</code></pre>
<hr/>
<blockquote>
<p>My question is, how can I access these type arguments?</p>
</blockquote>
<p>In situations like these -- how do I access ...</p>
<p>Use Python's powerful introspection features.</p>
<p>Even as a non-pro programmer I know I am trying to inspect stuff and <code>dir</code> is a function which is like IDE in terminal. So after</p>
<pre><code>&gt;&gt;&gt; import typing
&gt;&gt;&gt; str_to_bool_dict = typing.Dict[str, bool]
</code></pre>
<p>I want to see if there's anything that does the magic you want so</p>
<pre><code>&gt;&gt;&gt; methods = dir(str_to_bool_dict)
&gt;&gt;&gt; methods
['__abstractmethods__', '__args__', .....]
</code></pre>
<p>I see too much info, to see if I am correct I verify</p>
<pre><code>&gt;&gt;&gt; len(methods)
53
&gt;&gt;&gt; len(dir(dict))
39
</code></pre>
<p>Now let us find the methods which were designed specifically for generic types</p>
<pre><code>&gt;&gt;&gt; set(methods).difference(set(dir(dict)))
{'__slots__', '__parameters__', '_abc_negative_cache_version', '__extra__',
'_abc_cache', '__args__', '_abc_negative_cache', '__origin__',
'__abstractmethods__', '__module__', '__next_in_mro__', '_abc_registry',
'__dict__', '__weakref__'}
</code></pre>
<p>among these, <code>__parameters__</code>, <code>__extra__</code>, <code>__args__</code> and <code>__origin__</code> sound helpful. <code>__extra__</code> and <code>__origin__</code> won't work without self so we are left with <code>__parameters__</code> and <code>__args__</code>.</p>
<pre><code>&gt;&gt;&gt; str_to_bool_dict.__args__
(&lt;class 'str'&gt;, &lt;class 'bool'&gt;)
</code></pre>
<p>Hence the answer.</p>
<hr/>
<p>Introspection allows <code>py.test</code>'s <code>assert</code> statements to make JUnit derived testing frameworks look obsolete. Even languages like JavaScript / Elm / Clojure don't have a straight-forward thingy like <code>dir</code> of Python. Python's naming convention allows you to discover the language without actually reading (grokking in some cases such as these) the documentations.</p>
<p>So hunt using introspection and read documentation/mailing-lists to confirm your findings.</p>
<p>P.S. To OP -- this method also answers your question <a href="https://stackoverflow.com/questions/49171189/">What's the correct way to check if an object is a typing.Generic?</a> use discovery if you can't commit to mailing list or are a busy developer - that's the way to do it in python.</p>
</div>
<span class="comment-copy">I'm not sure why this question is being downvoted. I'd appreciate some feedback - Is there something I should improve?</span>
<span class="comment-copy">Not sure why downvoted, but here's some speculation: 1. bounty text has unnecessary snark  2. revenge? there exist good answers which got negged (i.e. "stop being such a princess and just use the <code>__args__</code>") 3. seems kind of XY-ish in the first place (you didn't really offer any background or use-case for accessing the inner types)</span>
<span class="comment-copy">How do you know that this is public? If you have any sources, please cite them.</span>
<span class="comment-copy">"How do you know that this is public " - because <code>__xxx__</code> is always public and, unlike <code>_xxx</code> and <code>__xxx</code> has never suggested otherwise. I presume you mean "How do you know that this is documented". I've updated my answer with documentation.</span>
<span class="comment-copy">Indeed, it's unclear if that's an implementation detail or not. Relying on this to work seems a little risky.</span>
<span class="comment-copy">Totally agree, I dig up this just now and the internals are very complex (there is some recursion happening in _subs_tree() for reaching to this result).</span>
<span class="comment-copy">Should point out that the <code>typing</code> module is still under active (and code-breaking) development. If you want this feature to stick around, I'd recommend submitting a use case rather than not using it: <a href="https://github.com/python/typing/issues" rel="nofollow noreferrer">github.com/python/typing/issues</a> .</span>
<span class="comment-copy">Does not work with Python 3.7.</span>
<span class="comment-copy">I'd suggest rephrasing your answer to put more focus on "The <code>__args__</code> attribute does what you want". At the moment your answer is talking mostly about the documentation and discussion of all these internal attributes, and you only mention <code>__args__</code> in passing. Even just a single line of code showing the output of <code>str_to_bool_dict.__args__</code> would go a long way in making your answer better.</span>
<span class="comment-copy">Thanks for the suggestion, I have updated the answer.</span>
<span class="comment-copy">I'm aware I can fire up an interactive session and dissect the internals of the typing module. The point of the question is that <i>I don't want to do that</i>. I specifically asked what the <i>official, documented</i> solution is.</span>
<span class="comment-copy">Earlier answers already showed about <code>__args__</code> attribute. This answer just seems to add unnecessary waffle on top of that.</span>
