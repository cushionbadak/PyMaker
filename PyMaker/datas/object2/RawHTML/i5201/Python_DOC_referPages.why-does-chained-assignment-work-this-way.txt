<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/32127908/python-assignment-operator-precedence-a-b-ab-5">Python Assignment Operator Precedence - (a, b) = a[b] = {}, 5</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I found the assignment <code>a = a[1:] = [2]</code> in an article.  I tried it in python3 and python2; it all works, but I don't understand <em>how</em> it works.  <code>=</code> here is not like in C; C processes <code>=</code> by right to left.  How does python process the <code>=</code> operator?</p>
</div>
<div class="post-text" itemprop="text">
<p>Per <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="noreferrer">the language docs on assignment</a>:</p>
<blockquote>
<p>An assignment statement evaluates the expression list (remember that this can be a single expression or a comma-separated list, the latter yielding a tuple) and assigns the single resulting object to each of the target lists, from left to right.</p>
</blockquote>
<p>In this case, <code>a = a[1:] = [2]</code> has an expression list <code>[2]</code>, and two "target lists", <code>a</code> and <code>a[1:]</code>, where <code>a</code> is the left-most "target list".</p>
<p>You can see how this behaves by looking at the disassembly:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis('a = a[1:] = [2]')
  1           0 LOAD_CONST               0 (2)
              2 BUILD_LIST               1
              4 DUP_TOP
              6 STORE_NAME               0 (a)
              8 LOAD_NAME                0 (a)
             10 LOAD_CONST               1 (1)
             12 LOAD_CONST               2 (None)
             14 BUILD_SLICE              2
             16 STORE_SUBSCR
             18 LOAD_CONST               2 (None)
             20 RETURN_VALUE
</code></pre>
<p>(The last two lines of the disassembly can be ignored, <code>dis</code> is making a function wrapper to disassemble the string)</p>
<p>The important part to note is that when you do <code>x = y = some_val</code>, <code>some_val</code> is loaded on the stack (in this case by the <code>LOAD_CONST</code> and <code>BUILD_LIST</code>), then the stack entry is duplicated and assigned, from left to right, to the targets given.</p>
<p>So when you do:</p>
<pre><code>a = a[1:] = [2]
</code></pre>
<p>it makes two references to a brand new <code>list</code> containing <code>2</code>, and the first action is a <code>STORE</code> one of these references to <code>a</code>. Next, it stores the second reference to <code>a[1:]</code>, but since the slice assignment mutates <code>a</code> itself, it has to load <code>a</code> again, which gets the <code>list</code> just stored. Luckily, <code>list</code> is resilient against self-slice-assignment, or we'd have issues (it would be forever reading the value it just added to add to the end until we ran out of memory and crashed); as is, it behaves as a copy of <code>[2]</code> was assigned to replace any and all elements from index one onwards.</p>
<p>The end result is equivalent to if you'd done:</p>
<pre><code>_ = [2]
a = _
a[1:] = _
</code></pre>
<p>but it avoids the use of the <code>_</code> name.</p>
<p>To be clear, the disassembly annotated:</p>
<p>Make list <code>[2]</code>:</p>
<pre><code>  1           0 LOAD_CONST               0 (2)
              2 BUILD_LIST               1
</code></pre>
<p>Make a copy of the reference to <code>[2]</code>:</p>
<pre><code>              4 DUP_TOP
</code></pre>
<p>Perform store to <code>a</code>:</p>
<pre><code>              6 STORE_NAME               0 (a)
</code></pre>
<p>Perform store to <code>a[1:]</code>:</p>
<pre><code>              8 LOAD_NAME                0 (a)
             10 LOAD_CONST               1 (1)
             12 LOAD_CONST               2 (None)
             14 BUILD_SLICE              2
             16 STORE_SUBSCR
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The way I understand such assignments is that this is equivalent to</p>
<pre><code>temp = [2]
a = temp
a[1:] = temp
</code></pre>
<p>The resulting value of <code>[2, 2]</code> is consistent with this interpretation.</p>
</div>
<span class="comment-copy">I reopened this question because it is a much more complex case than the typical <code>x = y = some_func()</code> case addressed in <a href="https://stackoverflow.com/q/7601823/364696">How do chained assignments work?</a></span>
<span class="comment-copy">It can be left to right because assignment is a type of statement in Python and not an expression like in C. It doesn’t have an associativity since <code>a = b = … = x</code> is all parsed together.</span>
<span class="comment-copy">The question is only related to the non-complex part though (left-to-right). OP states they understand how it works. I am not strongly against reopening though.</span>
