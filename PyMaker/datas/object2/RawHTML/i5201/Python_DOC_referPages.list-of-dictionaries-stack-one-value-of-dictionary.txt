<div class="post-text" itemprop="text">
<p>I have trouble in adding one value of dictionary when conditions met, For example I have this list of dictionaries:</p>
<pre><code>[{'plu': 1, 'price': 150, 'quantity': 2, 'stock': 5},
 {'plu': 2, 'price': 150, 'quantity': 7, 'stock': 10},
 {'plu': 1, 'price': 150, 'quantity': 6, 'stock': 5},
 {'plu': 1, 'price': 200, 'quantity': 4, 'stock': 5},
 {'plu': 2, 'price': 150, 'quantity': 3, 'stock': 10}
]
</code></pre>
<p>Then output should look like this:</p>
<pre><code>[{'plu': 1, 'price': 150, 'quantity': 8, 'stock': 5},
 {'plu': 1, 'price': 200, 'quantity': 4, 'stock': 5},
 {'plu': 2, 'price': 150, 'quantity': 10, 'stock': 10}
]
</code></pre>
<p>Quantity should be added only if plu and price are the same, it should ignore key:values other than that (ex. stock). What is the most efficient way to do that?</p>
<p>@edit
I tried:</p>
<pre><code>import itertools as it
keyfunc = lambda x: x['plu']

groups = it.groupby(sorted(new_data, key=keyfunc), keyfunc)
x = [{'plu': k, 'quantity': sum(x['quantity'] for x in g)} for k, g in groups]
</code></pre>
<p>But it works only on plu and then I get only quantity value when making html table in django, other are empty</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to sort/<code>groupby</code> the combined key, not just one key. Easiest/most efficient way to do this <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer">is with <code>operator.itemgetter</code></a>. To preserve an arbitrary <code>stock</code> value, you'll need to use the group twice, so you'll need to convert it to a sequence:</p>
<pre><code>from operator import itemgetter

keyfunc = itemgetter('plu', 'price')

# Unpack key and listify g so it can be reused
groups = ((plu, price, list(g)) 
          for (plu, price), g in it.groupby(sorted(new_data, key=keyfunc), keyfunc))
x = [{'plu': plu, 'price': price, 'stock': g[0]['stock'],
      'quantity': sum(x['quantity'] for x in g)}
     for plu, price, g in groups]
</code></pre>
<p>Alternatively, if <code>stock</code> is guaranteed to be the same for each unique <code>plu</code>/<code>price</code> pair, you can include it in the <code>key</code> to simplify matters, so you don't need to listify the groups:</p>
<pre><code>keyfunc = itemgetter('plu', 'price', 'stock')
groups = it.groupby(sorted(new_data, key=keyfunc), keyfunc)
x = [{'plu': plu, 'price': price, 'stock': stock,
      'quantity': sum(x['quantity'] for x in g)
     for (plu, price, stock), g in groups]
</code></pre>
<p>Optionally, you could create <code>getquantity = itemgetter('quantity')</code> at top level (like the <code>keyfunc</code>) and change <code>sum(x['quantity'] for x in g)</code> to <code>sum(map(getquantity, g))</code> which pushes work to the C layer in CPython, and can be faster if your groups are large.</p>
<p>The other approach is to avoid sorting entirely <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">using <code>collections.Counter</code></a> (<a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">or <code>collections.defaultdict(int)</code></a>, though <code>Counter</code> makes the intent more clear here):</p>
<pre><code>from collections import Counter

grouped = Counter()
for plu, price, stock, quantity in map(itemgetter('plu', 'price', 'stock', 'quantity'), new_data):
    grouped[plu, price, stock] += quantity
</code></pre>
<p>then convert back to your preferred form with:</p>
<pre><code>x = [{'plu': plu, 'price': price, 'stock': stock, 'quantity': quantity}
     for (plu, price, stock), quantity in grouped.items()]
</code></pre>
<p>This should be faster for large inputs, since it replaces <code>O(n log n)</code> sorting work with <code>O(n)</code> <code>dict</code> operations (which are roughly <code>O(1)</code> cost).</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://pandas.pydata.org/pandas-docs/stable/index.html#module-pandas" rel="nofollow noreferrer"><code>pandas</code></a> will make this a trivial problem:</p>
<pre><code>import pandas as pd    

data = [{'plu': 1, 'price': 150, 'quantity': 2, 'stock': 5},
        {'plu': 2, 'price': 150, 'quantity': 7, 'stock': 10},
        {'plu': 1, 'price': 150, 'quantity': 6, 'stock': 5},
        {'plu': 1, 'price': 200, 'quantity': 4, 'stock': 5},
        {'plu': 2, 'price': 150, 'quantity': 3, 'stock': 10}]

df = pd.DataFrame.from_records(data)

#    df
#
#       plu  price  quantity  stock
#    0    1    150         2      5
#    1    2    150         7     10
#    2    1    150         6      5
#    3    1    200         4      5
#    4    2    150         3     10

new_df = df.groupby(['plu','price','stock'], as_index=False).sum()
new_df = new_df[['plu','price','quantity','stock']]  # Optional: reorder the columns

#    new_df
#
#       plu  price  quantity  stock
#    0    1    150         8      5
#    1    1    200         4      5
#    2    2    150        10     10
</code></pre>
<p>And finally, if you want to, port it back to <code>dict</code> (though I would argue <code>pandas</code> give you a lot more functionality to handle the data elements):</p>
<pre><code>new_data = df2.to_dict(orient='records')

#    new_data
#
#    [{'plu': 1, 'price': 150, 'quantity': 8, 'stock': 5},
#     {'plu': 1, 'price': 200, 'quantity': 4, 'stock': 5},
#     {'plu': 2, 'price': 150, 'quantity': 10, 'stock': 10}]
</code></pre>
</div>
<span class="comment-copy">"What is the most efficient way to do that?" is only a reasonable question if you got it to work in the first place at all. Please show what you have tried.</span>
<span class="comment-copy">Furthermore, a list fo dictionaries is probably not the best data-structure for this.</span>
<span class="comment-copy">I added what I tried in question</span>
<span class="comment-copy">"It only works on plu" because that's what you told it to do: <code>keyfunc = lambda x: x['plu']</code>. First of all, this needs to be sorted to work correctly, and second, you need to sort and groupby <i>both</i> plu and price</span>
<span class="comment-copy">Stock is always same for each plu, should be just ignored, but added to the end result</span>
<span class="comment-copy">It works like a charm, thanks!</span>
<span class="comment-copy">Worked for me too, but I must learn more about pandas to understand how it works.</span>
<span class="comment-copy">It's a powerful data analysis tool, this barely scratches the surface of what it can do.  For large sets of data and data structure manipulation it's very handy.  The other answer is great as well to learn different functionalities.</span>
