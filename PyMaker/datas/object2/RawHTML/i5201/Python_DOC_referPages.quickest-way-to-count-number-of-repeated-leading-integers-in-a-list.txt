<div class="post-text" itemprop="text">
<p>example of list being looked at (list will always be sorted). Size of list is 4^12. 
[1,1,1,1, ...... , 1,1,4]</p>
<p>At the moment I have a for loop that iterates through the list with a counter until it finds the first non 1 and then breaks and returns the counter. This is quicker than using the count function since the list is already sorted. I am now implementing binary search and I was wondering if anyone can think of a better way to count the number of leading ones in a ordered list. </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer">Bisect</a> is built in and seems comparably fast to binary sort;</p>
<pre><code>import bisect
import time

import itertools

test = [1] * 100000000
test[len(test) - 1] = 4

start = time.time()
print(bisect.bisect_right(test,1))
print(time.time() - start)

start = time.time()
runs = [len(list(b)) for a, b in itertools.groupby(test)][0]
print(runs)
print(time.time() - start)

start = time.time()
length= len(test)-test[::-1].index(1)
print(length)
print(time.time() - start)


# Bisect
99999999
3.719329833984375e-05

# GroupBy
99999999
1.2406058311462402

# Length
99999999
0.3920767307281494
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby</code>:</p>
<pre><code>import itertools
s = [1,1,1,1,1,1,4]
runs = [len(list(b)) for a, b in itertools.groupby(s)][0]
</code></pre>
<p>Output:</p>
<pre><code>6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you only want to find the count of the first value then you can use this:</p>
<pre><code>a = [1,1,1,...,1,4]
first_value = a[0]
length= len(a)-a[::-1].index(first_value) #get index starting from the end
</code></pre>
</div>
<span class="comment-copy">Do you know the len of your list ? -- nevermind, I wanted to make a special implementation of binary search. But you would have needed the length of your current list. But if you don't have it at the beginning, you won't go faster than iterating once through your list, and counting the elements that interests you, and stop when you know you won't find any as you have a sorted list.</span>
<span class="comment-copy">I know the length of the list.</span>
<span class="comment-copy">This is a nice one, it's super fast! Although you should change the number of elements to 4^12 and maybe randomize the number of 1's to get a better timing on your approach.</span>
