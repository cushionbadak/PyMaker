<div class="post-text" itemprop="text">
<p>I'm trying to understand how to write a decorator which checks the main_val attribute for every method, especially when the position of the main_val attribute could change, or even have a default. Separately, is there a more pythonic way to apply this condition?</p>
<p>I wrote an example below to visually describe the problem, hoping someone with more experience can shed light.</p>
<p>For each method below, main_val should be the only attribute my decorator should be checking. I'm not sure how force the decorator to always check main_val, unless it's passed as a key=value attribute or refers to hardcoded the position in *args.</p>
<pre><code>class TestCase:
    def __init__(self):
        self.allowable_list = [1,2,3,4,5]

    def decorator_check(func):
        # I want to apply condition to "main_val" attribute of any method this decorator is applied to
        def wrapper(self, val, *args, **kwargs):
            if val not in self.allowable_list:
                raise AttributeError("value {} not in allowable list {}".format(val, self.allowable_list))
        return func(self, val, *args, **kwargs)
    return wrapper

    @decorator_check
    def calc(self, main_val, val_num_two, val_num_three):
        print("(calc) - main_val: {} val_num_two: {} val_num_three: {}".format(main_val, val_num_two, val_num_three))
        return main_val * val_num_two * val_num_three

    @decorator_check
    def calc_two(self, another_val, main_val,  val_num_two):
        print("(calc_two) - another_val: {} main_val: {} val_num_two: {}".format(another_val, main_val, val_num_two))
        return another_val * main_val * val_num_two

    @decorator_check
    def calc_three(self, another_val, val_num_two, main_val=3):
        print("(calc_two) - another_val: {} main_val: {} val_num_two: {}".format(another_val, main_val, val_num_two))
        return another_val * val_num_two * main_val

test_obj = TestCase()
</code></pre>
<hr/>
<pre><code>test_obj.calc(100, 2 ,3)
</code></pre>
<p>Returns error as expected</p>
<pre><code>test_obj.calc_two(2, 5, 3)
</code></pre>
<p>Returns (calc_two) - another_val: 2 main_val: 5 val_num_two: 3</p>
<pre><code>test_obj.calc_three(2,5,100)
</code></pre>
<p>Returns (calc_two) - another_val: 2 val_num_two: 5 main_val: 100</p>
<p>What are some ways to approach this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object" rel="nofollow noreferrer"><code>inspect.signature</code></a> to determine the signature, bind arguments, apply defaults, and figure out the final value of <code>main_val</code>:</p>
<pre><code>import functools
import inspect

def main_val_decorator(f):
    f_sig = inspect.signature(f)
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        bound = f_sig.bind(*args, **kwargs)
        bound.apply_defaults()
        main_val = bound.arguments['main_val']

        do_whatever_with(main_val)
        return f(*args, **kwargs)
    return wrapper
</code></pre>
<p>This does more work than you need, because it determines bindings for all the other arguments too, but it's a lot more convenient than performing the introspection manually.</p>
</div>
<span class="comment-copy">It's unrelated to your main question, but <code>AttributeError</code> is certainly not the right exception to be raised in the situation you're using it in. That error suggests that an attribute lookup <code>obj.attr</code> failed because <code>attr</code> doesn't exist. I think you should probably use <code>ValueError</code> instead, as that's normally raised when you pass an argument of the wrong value to a function or method. Since your decorator is checking the value you were passed against a list of allowed values, that seems most appropriate.</span>
<span class="comment-copy">Thanks @Blckknght !  I just looked up the definition and didn't realize that was the case.</span>
<span class="comment-copy">This is a little overkill - but useful nevertheless. Hoping maybe there is a more straightforward solution</span>
<span class="comment-copy">I suspect this is about as easy as it gets if you want to handle a value that could be anywhere in the method signature. For a narrower situation (if the argument is keyword-only, for instance), you could come up with your own custom solution that might be simpler, but this is probably the only good general solution.</span>
<span class="comment-copy">Thanks folks - there's one thing i don't quite follow, what's the point of functools.wraps in this context? Doesn't seem necessary</span>
