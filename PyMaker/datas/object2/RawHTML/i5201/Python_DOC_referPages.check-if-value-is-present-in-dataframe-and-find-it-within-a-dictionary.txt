<div class="post-text" itemprop="text">
<p>Assuming a dataframe</p>
<pre><code>Market | Status | Team |
-------|--------|------|
Chicago|   1    | Tom  |
Chicago|   1    | Tom  |
SF Bay |   3    | Julia|
SF Bay |   1    | Julia|
SF Bay |   1    | Julia|
</code></pre>
<p>And a dictionary</p>
<pre><code>Team = {"Tom": "tom@email.com", "Julia": "Julia@email.com", "Carol": "carol@email.com"}
</code></pre>
<p>I want to get each team members specific dataframe, convert it to HTML and email it to them. I can get the dataframes individually that I need and then <code>df.to_html()</code> it. In the case above, <code>Carol</code> is in the dictionary, but not within the dataframe, so I don't want her to receive an email. </p>
<p>I've tried</p>
<pre><code>for i in Team:
    df[df['Team'].str.contains(i)]
    Mail = df[df['Team'].isin([i])]
    ...
    #send an email
</code></pre>
<p>But this would then send an email with a blank dataframe to <code>Carol</code>. How can I iterate through easily and get only those names that are present from my dictionary and then utilize the dictionary email value to send an email?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>map</code>, convert the <code>Team</code> column to a column of email addresses, and then use a <code>groupby</code> to get each team member's <code>DataFrame</code> separately, using a dictionary comprehension. </p>
<pre><code>df['Team'] = df['Team'].map(Team)
df

    Market  Status             Team
0  Chicago       1    tom@email.com
1  Chicago       1    tom@email.com
2   SF Bay       3  Julia@email.com
3   SF Bay       1  Julia@email.com
4   SF Bay       1  Julia@email.com
</code></pre>
<p></p>
<pre><code>df_dict = {i : g for i, g in df.groupby('Team')}

df_dict.keys()
dict_keys(['Julia@email.com', 'tom@email.com'])  # look ma, no Carol
</code></pre>
<p>Note that <a href="https://stackoverflow.com/a/42012366/4909087"><code>map</code> scales better than <code>replace</code></a>. After this, you can iterate over each key-value pair, and dispatch:</p>
<pre><code>for email, df in df_dict.items():
    data = df.to_html()
    ... # dispatch `data` to `email`
</code></pre>
<p>For more info on how to dispatch email through python using the SMTP protocol, refer to the <a href="https://docs.python.org/3/library/email.examples.html" rel="nofollow noreferrer"><code>email</code></a> module in the standard library.</p>
<hr/>
<p>If you want to keep the <code>Name</code> column, you can combine the <code>groupby</code> and <code>map</code> step together, and simplify your solution:</p>
<pre><code>df_dict = {i : g for i, g in df.groupby(df.Team.map(Team))}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>replace</code> :-) </p>
<pre><code>df.Team.replace(d,inplace=True)
df
Out[176]: 
    Market  Status             Team
0  Chicago       1    tom@email.com
1  Chicago       1    tom@email.com
2    SFBay       3  Julia@email.com
3    SFBay       1  Julia@email.com
4    SFBay       1  Julia@email.com
</code></pre>
</div>
<span class="comment-copy">This works perfectly! Is there any way to maintain their names so I can place them inside the email?</span>
<span class="comment-copy">@ATCH_torn Of course! It's even simpler, in fact. I've edited my answer.</span>
<span class="comment-copy">That works great! One last question. Can I then take the name and append it to the dictionary? Ideally I'd like to have <code>name: email, df</code> all in one fell swoop.</span>
<span class="comment-copy">@ATCH_torn Well, you could do so. The key is the name and the value is a list/tuple. You could choose to create a new dict by iterating over <code>df_dict</code>. For each value, <code>df.Team.unique()</code> gives you the name. Good luck!</span>
