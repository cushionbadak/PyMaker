<div class="post-text" itemprop="text">
<p>Practicing with decorators, found this behavior strange:</p>
<pre><code>def test_decorator(cls, *args, **kwargs):
    print (args, kwargs)
    def build(*args, **kwargs):
        print (args, kwargs)
        return cls(*args, **kwargs)
    return build

@test_decorator
class Test:
    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs

t = Test(1, 2, 3, val = 4)
print (t.args, t.kwargs)

# output
# () { }
# (1, 2, 3) {'val' = 4}
# (1, 2, 3) {'val' = 4}
</code></pre>
<p>Why does the first <code>print</code> in the decorator show empty containers? Further, if I defined <code>build()</code> as:</p>
<pre><code>def build():
    return cls(*args, **kwargs)
</code></pre>
<p>I know it will fail because of <a href="https://docs.python.org/3/tutorial/classes.html#scopes-and-namespaces-example" rel="nofollow noreferrer">nested function scoping</a>. I'm just not sure why they somehow don't exists before the call to <code>build</code> and suddenly return to scope.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have two different callables here:</p>
<ul>
<li><code>test_decorator()</code></li>
<li>the wrapper returned by <code>test_decorator()</code>, <code>build()</code>.</li>
</ul>
<p>You are confusing the two. </p>
<p>The first is called with <em>only the class</em>, because</p>
<pre><code>@test_decorator
class Test:
    # ...
</code></pre>
<p>is really just</p>
<pre><code>class Test:
    # ...
Test = test_decorator(Test)
</code></pre>
<p>That call is only passed <em>one argument</em>, the class being decorated, which is assigned to the <code>cls</code> name. The <code>args</code> and <code>kwargs</code> arguments to that call remain empty.</p>
<p>When you then call <code>Test(...)</code>, you are really calling <code>build(...)</code>. That call is passed arguments that are captured by the local <code>args</code> and <code>kwargs</code> objects, and passed to <code>cls(...)</code> (which references the original class object). Those arguments are not lost, they clearly are being passed on to the <code>__init__</code> method and the instance attributes by the same names are correctly set.</p>
<p>To distinguish the different catch-all parameters, start with giving them different names and augment your <code>print()</code> output:</p>
<pre><code>def test_decorator(cls, *decorator_args, **decorator_kwargs):
    print('Decorator called with ({!r}, *{!r}, **{!r})'.format(
        cls, decorator_args, decorator_kwargs))
    def build(*build_args, **build_kwargs):
        print('build() wrapper called with (*{!r}, **{!r})'.format(
            build_args, build_kwargs))
        print('The decorator was originally called with ({!r}, *{!r}, **{!r})'.format(
            cls, decorator_args, decorator_kwargs))
        return cls(*build_args, **build_kwargs)
    return build
</code></pre>
<p>Now the output becomes:</p>
<pre><code>&gt;&gt;&gt; @test_decorator
... class Test:
...     def __init__(self, *args, **kwargs):
...         self.args = args
...         self.kwargs = kwargs
...
Decorator called with (&lt;class '__main__.Test'&gt;, *(), **{})
&gt;&gt;&gt; t = Test(1, 2, 3, val = 4)
build() wrapper called with (*(1, 2, 3), **{'val': 4})
The decorator was originally called with (&lt;class '__main__.Test'&gt;, *(), **{})
&gt;&gt;&gt; t.args, t.kwargs
((1, 2, 3), {'val': 4})
</code></pre>
<p>Note that the <em>Decorator called with ...</em> output was produced when the <code>class</code> statement was executed, while the <code>t = Test(...)</code> call triggered the <em>build() wrapper called ...</em> output.</p>
</div>
<span class="comment-copy">They're <i>arguments</i> to build, the only thing passed to <code>test_decorator</code> is <code>cls</code>. It's not clear what you think has disappeared.</span>
<span class="comment-copy">So does the class passed to the decorator retain its arguments?</span>
<span class="comment-copy">@pstatix: yes, it does. You already saw this in your own output.</span>
<span class="comment-copy">Very nice write-up; from this I suppose the convention is that each decorator has a single responsibility, meaning it should only have a single wrapper function inside?</span>
<span class="comment-copy">@pstatix: not necessarily. A decorator is a very simple contract: The <code>@&lt;something&gt;</code> syntax above a function or class is called and the function or class is passed in. <b>Whatever</b> the decorator returns is assigned to the original name. You have a huge amount of flexibility beyond that contract.</span>
<span class="comment-copy">@pstatix: the decorator could just return the original object. That's how many web frameworks (like Django and Flask) use decorators to register functions to handle requests: they update a registry with information and return the original function, otherwise untouched.</span>
