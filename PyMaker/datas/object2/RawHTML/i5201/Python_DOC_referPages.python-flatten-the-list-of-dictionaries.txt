<div class="post-text" itemprop="text">
<p>List of dictionaries:</p>
<pre><code>data = [{
         'a':{'l':'Apple',
                'b':'Milk',
                'd':'Meatball'},
         'b':{'favourite':'coke',
              'dislike':'juice'}
         },
         {
         'a':{'l':'Apple1',
                'b':'Milk1',
                'd':'Meatball2'},
         'b':{'favourite':'coke2',
              'dislike':'juice3'}
         }, ...
]
</code></pre>
<p>I need to join all nested dictionaries to reach at the expected output:</p>
<pre><code> [{'d': 'Meatball', 'b': 'Milk', 'l': 'Apple', 'dislike': 'juice', 'favourite': 'coke'},
  {'d': 'Meatball2', 'b': 'Milk1', 'l': 'Apple1', 'dislike': 'juice3', 'favourite': 'coke2'}]
</code></pre>
<p>I try nested list comprehension, but cannot join dict together:</p>
<pre><code>L = [y for x in data for y in x.values()]
print (L)

[{'d': 'Meatball', 'b': 'Milk', 'l': 'Apple'}, 
 {'dislike': 'juice', 'favourite': 'coke'}, 
{'d': 'Meatball2', 'b': 'Milk1', 'l': 'Apple1'}, 
 {'dislike': 'juice3', 'favourite': 'coke2'}]
</code></pre>
<p>I am looking for the fastest solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do the following, using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain
# timeit: ~3.40
&gt;&gt;&gt; [dict(chain(*map(dict.items, d.values()))) for d in data]
[{'l': 'Apple', 
  'b': 'Milk', 
  'd': 'Meatball', 
  'favourite': 'coke', 
  'dislike': 'juice'}, 
 {'l': 'Apple1', 
  'b': 'Milk1', 
  'dislike': 'juice3', 
  'favourite': 'coke2', 
  'd': 'Meatball2'}]
</code></pre>
<p>The usage of <code>chain</code>, <code>map</code>, <code>*</code> make this expression a shorthand for the following doubly nested comprehension which actually performs better on my system (Python 3.5.2) and isn't that much longer:</p>
<pre><code># timeit: ~2.04
[{k: v for x in d.values() for k, v in x.items()} for d in data]
# Or, not using items, but lookup by key
# timeit: ~1.67
[{k: x[k] for x in d.values() for k in x} for d in data]
</code></pre>
<h3>Note:</h3>
<p><a href="https://stackoverflow.com/users/5238915/roadrunner">RoadRunner's</a> loop-and-update approach outperforms both these one-liners at <code>timeit: ~1.37</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with 2 nested loops, and <a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="noreferrer"><code>dict.update()</code></a> to add inner dictionaries to a temporary dictionary and add it at the end:</p>
<pre><code>L = []
for d in data:
    temp = {}
    for key in d:
        temp.update(d[key])

    L.append(temp)

# timeit ~1.4
print(L)
</code></pre>
<p>Which Outputs:</p>
<pre><code>[{'l': 'Apple', 'b': 'Milk', 'd': 'Meatball', 'favourite': 'coke', 'dislike': 'juice'}, {'l': 'Apple1', 'b': 'Milk1', 'd': 'Meatball2', 'favourite': 'coke2', 'dislike': 'juice3'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="noreferrer"><code>functools.reduce</code></a> along with a simple list comprehension to flatten out the list the of dicts</p>
<pre><code>&gt;&gt;&gt; from functools import reduce 

&gt;&gt;&gt; data = [{'b': {'dislike': 'juice', 'favourite': 'coke'}, 'a': {'l': 'Apple', 'b': 'Milk', 'd': 'Meatball'}}, {'b': {'dislike': 'juice3', 'favourite': 'coke2'}, 'a': {'l': 'Apple1', 'b': 'Milk1', 'd': 'Meatball2'}}]
&gt;&gt;&gt; [reduce(lambda x,y: {**x,**y},d.values()) for d in data]
&gt;&gt;&gt; [{'dislike': 'juice', 'l': 'Apple', 'd': 'Meatball', 'b': 'Milk', 'favourite': 'coke'}, {'dislike': 'juice3', 'l': 'Apple1', 'd': 'Meatball2', 'b': 'Milk1', 'favourite': 'coke2'}]
</code></pre>
<p>Time benchmark is as follows:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; setup = """
      from functools import reduce
      data = [{'b': {'dislike': 'juice', 'favourite': 'coke'}, 'a': {'l': 'Apple', 'b': 'Milk', 'd': 'Meatball'}}, {'b': {'dislike': 'juice3', 'favourite': 'coke2'}, 'a': {'l': 'Apple1', 'b': 'Milk1', 'd': 'Meatball2'}}]
  """
&gt;&gt;&gt; min(timeit.Timer("[reduce(lambda x,y: {**x,**y},d.values()) for d in data]",setup=setup).repeat(3,1000000))
&gt;&gt;&gt; 1.525032774952706
</code></pre>
<p>Time benchmark of other answers on my machine</p>
<pre><code>&gt;&gt;&gt; setup = """
        data = [{'b': {'dislike': 'juice', 'favourite': 'coke'}, 'a': {'l': 'Apple', 'b': 'Milk', 'd': 'Meatball'}}, {'b': {'dislike': 'juice3', 'favourite': 'coke2'}, 'a': {'l': 'Apple1', 'b': 'Milk1', 'd': 'Meatball2'}}]
    """
&gt;&gt;&gt; min(timeit.Timer("[{k: v for x in d.values() for k, v in x.items()} for d in data]",setup=setup).repeat(3,1000000))
&gt;&gt;&gt; 2.2488374650129117

&gt;&gt;&gt; min(timeit.Timer("[{k: x[k] for x in d.values() for k in x} for d in data]",setup=setup).repeat(3,1000000))
&gt;&gt;&gt; 1.8990078769857064

&gt;&gt;&gt; code = """
      L = []
      for d in data:
          temp = {}
          for key in d:
              temp.update(d[key])

          L.append(temp)
    """

&gt;&gt;&gt; min(timeit.Timer(code,setup=setup).repeat(3,1000000))
&gt;&gt;&gt; 1.4258553800173104

&gt;&gt;&gt; setup = """
      from itertools import chain
      data = [{'b': {'dislike': 'juice', 'favourite': 'coke'}, 'a': {'l': 'Apple', 'b': 'Milk', 'd': 'Meatball'}}, {'b': {'dislike': 'juice3', 'favourite': 'coke2'}, 'a': {'l': 'Apple1', 'b': 'Milk1', 'd': 'Meatball2'}}]
    """
&gt;&gt;&gt; min(timeit.Timer("[dict(chain(*map(dict.items, d.values()))) for d in data]",setup=setup).repeat(3,1000000))
&gt;&gt;&gt; 3.774383604992181
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have nested dictionaries with only 'a' and 'b' keys, then I suggest the following solution I find fast and very easy to understand (for readability purpose):  </p>
<pre><code>L = [x['a'] for x in data]
b = [x['b'] for x in data]

for i in range(len(L)):
    L[i].update(b[i])

# timeit ~1.4

print(L)
</code></pre>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/38987/how-to-merge-two-dictionaries-in-a-single-expression">how-to-merge-two-dictionaries-in-a-single-expression</a> would be helpful.</span>
<span class="comment-copy">I like your fair behaviour because add timing of another solution which is better, so no reaccepting ;) Thank you.</span>
<span class="comment-copy">@jezrael Thx, nah, no need to hide that fact. It is interesting to compare these 3 stylistically so different approaches and to see that the straightforward loop beats the comprehension and particularly the kitchen sink of built-ins and itertools :)</span>
<span class="comment-copy">A more readable alternative to <code>dict(chain(*map(...</code>  is <code>[ChainMap(*d.values()) for d in data]</code>. It's slower than the other methods, though.</span>
