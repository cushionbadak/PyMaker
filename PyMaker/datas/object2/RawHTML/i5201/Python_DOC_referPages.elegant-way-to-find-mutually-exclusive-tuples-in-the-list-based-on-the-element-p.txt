<div class="post-text" itemprop="text">
<p>I want to subtract the two following tuples from each other to get the desired result (also included below). Note that the subtraction is based on only the a of the (a, b).</p>
<pre><code># the two tuples
first = [(('the',), 431), (('and',), 367)]
second = [(('the',), 100), (('hello',), 100)]

# the desired result
first = [(('and',), 367)]
second = [(('hello',), 100)]
</code></pre>
<p>I tried <code>map(operation.sub, first, second)</code>, didn't work. Tried <code>b = map(sub, first, second)</code>, didn't work. Says <strong>unsupported operand type(s) for -: 'tuple' and 'tuple</strong>.</p>
<p>Thanks for your help and time in advance.</p>
<p><strong>Edit</strong>: A solution that would help me most would include creating an intersection of the two tuples and subtracting that from each of the tuples.</p>
<p>Edit: I want to subtract based on common items. Hope that clarifies it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe follow is what you wantï¼š</p>
<pre><code># the two tuples
first = [(('the',), 431), (('and',), 367)]
second = [(('the',), 100), (('hello',), 100)]

first_keys = set(_[0][0] for _ in first)
second_keys = set(_[0][0] for _ in second)

first = [_ for _ in first if _[0][0] not in second_keys]
second = [_ for _ in second if _[0][0] not in first_keys]
</code></pre>
<hr/>
<pre><code>multi = [
    [(('the',), 431), (('and',), 367)],
    [(('the',), 100), (('hello',), 100)]
]

def get_key(x):
    return x[0][0]

def occur_counts(set_x):
    cnt = {}
    for x in set_x:
        cnt[get_key(x)] = cnt.get(get_key(x), 0) + 1
    return cnt


def do_one(single, total_cnt):
    single_cnt = occur_counts(single)
    return [_ for _ in single if single_cnt[get_key(_)] == total_cnt[get_key(_)]]


total_cnt = occur_counts(sum(multi, []))

answer = [do_one(_, total_cnt) for _ in multi]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is what you are looking for - </p>
<pre><code># the two tuples
first = [(('the',), 431), (('and',), 367)]
second = [(('the',), 100), (('hello',), 100)]

interim1 = {i[0][0]:i[1] for i in first}

interim2 = {i[0][0]:i[1] for i in second}

op1 = [ ((item,),interim1[item]) for item in interim1 if item not in interim2]
op2 = [ ((item,),interim2[item]) for item in interim2 if item not in interim1]
print(op1)
print(op2)
</code></pre>
<p><strong>Intersection (Edit)</strong></p>
<pre><code>intersection = [ ((item,),interim1[item]) for item in interim1 if item in interim2]
print(intersection)
</code></pre>
<p><strong>Union (Extra)</strong></p>
<pre><code>union = set().union(*[ op1, op2, intersection])
print(union)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[(('the',), 431)]
[(('and',), 367)]
[(('hello',), 100)]
{(('hello',), 100), (('and',), 367), (('the',), 431)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#func-set" rel="nofollow noreferrer"><strong><code>set</code></strong></a> with below <em>list comprehension</em> to get the desired result as:</p>
<pre><code>&gt;&gt;&gt; first = [(('the',), 431), (('and',), 367)]
&gt;&gt;&gt; second = [(('the',), 100), (('hello',), 100)]

&gt;&gt;&gt; [t for t in first+second if t[0] in set(f[0] for f in first) ^ (set(s[0] for s in second))]
[(('and',), 367), (('hello',), 100)]
</code></pre>
<hr/>
<p><strong>Explanation:</strong></p>
<p>Here, I am using set to get the non-common words in the two list by performing <a href="https://en.wikipedia.org/wiki/Exclusive_or" rel="nofollow noreferrer"><em>XOR (also know as Exclusive OR)</em></a> on two sets. For example:</p>
<pre><code>&gt;&gt;&gt; first_words = set(f[0] for f in first)
&gt;&gt;&gt; second_words = set(s[0] for s in second)

&gt;&gt;&gt; first_words ^ second_words
set([('hello',), ('and',)])
</code></pre>
<p>Then I am iterating on both the list within <em>list comprehension</em> and checking whether they are present in above set of <em>non-common</em> words tuples. If they are present, then we are keeping it as the part of new list as:</p>
<pre><code>&gt;&gt;&gt; result = [t for t in first+second if t[0] in first_words ^ second_words]
# where `result` will hold value `[(('and',), 367), (('hello',), 100)]`

## If your resultant lists contains only two variable, 
## then you may assign them directly to individual variable as:
#     f, s = [t for t in first+second if t[0] in first_words ^ second_words]

## where `f` first required tuple will hold
# &gt;&gt;&gt; f
# (('and',), 367)

## and `s` second required tuple will hold
# &gt;&gt;&gt; s
# (('hello',), 100)
</code></pre>
</div>
<span class="comment-copy">the desired result is unclear</span>
<span class="comment-copy">your desire is unclear; to get your result literally, you can use: <code>first = first[1]</code> or <code>first = list(first[1])</code></span>
<span class="comment-copy">I tried this, but it gave me the same two sets/tuples back.</span>
<span class="comment-copy">use 'first = [_ for _ in first if <i>[0][0] not in second_keys]' instead of first = [</i> for _ in first if _[0][0] not in second] . sorry for my  carelessness</span>
<span class="comment-copy">Works, great, thanks. can you tell me how I go about automating this for more than 2 tuples? I could do it by hand for each two, but would be good to automate it.</span>
<span class="comment-copy">How do you take the intersection of more than two sets/tuples/lists?</span>
<span class="comment-copy">Thanks. The more detailed version doesn't work for me, as it gives me this error: 'too many values to unpack' for this line f, s = [t for t in first+second if t[0] in first_words ^ second_words]. The first code you wrote works fine, but gives me the same result both ways around.</span>
<span class="comment-copy">Are you using different list then the one mentioned in the example? The error you are seeing in because <code>f, s = &lt;my code</code> assumes two values in the returned tuple assigns the values to <code>f</code> and <code>s</code>. Check the edit.</span>
<span class="comment-copy">No, there are numerous value pairs of this kind: ('hello'), 100 in the tuples.</span>
<span class="comment-copy">check the updated version.. it will contain the list of tuples as <code>result</code>. You may access them with <code>result[0]</code>, <code>result[1]</code>, .... so on</span>
<span class="comment-copy">Works well now, thank you. Any idea how I can select multiple answers to my question? All three provided different, but valid answers.</span>
