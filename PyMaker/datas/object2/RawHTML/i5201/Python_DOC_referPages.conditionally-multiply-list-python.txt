<div class="post-text" itemprop="text">
<p>I have to multiply a list (a) with one of two other lists (b and c), but conditional on if the value in (a) is positive or negative.</p>
<p>I do have a working solution, but it is quite slow and I would like to speed it up significantly.
I believe <a href="https://stackoverflow.com/questions/26738551/conditionally-multiply-a-vector-by-another-r">this</a> code in R is what I need, but don't know of a similar approach in Python. </p>
<p><strong>EDIT:</strong></p>
<p>I have applied Moinuddin Quadri's method:</p>
<pre><code>amount = [0,1,0,0,-1,0,1,-1,1]
data1 = [10,11,12,13,14,15,16,15,14]
data2 = [3,1,2,3,4,5,6,5,4]

flow2 = [(i*j if i &gt; 0 else i*k) for i, j, k  in zip(amount, data1, data2)]
</code></pre>
<p>100000 loops, best of 3: 2.35 µs per loop</p>
<p>Whereas my own attempt:</p>
<pre><code>amount = [0,1,0,0,-1,0,1,-1,1]
data1 = [10,11,12,13,14,15,16,15,14]
data2 = [3,1,2,3,4,5,6,5,4]

flow = [0]*len(data1)

for i in range(len(data1)):
    if amount[i] &gt; 0:
        flow[i] = amount[i]*data1[i]
    else:
        flow[i] = amount[i]*data2[i]
</code></pre>
<p>100000 loops, best of 3: 2.97 µs per loop.</p>
<p>So it is a slight improvement, but not huge. I have to iteratively perform this task, many times and need significant improvement...</p>
</div>
<div class="post-text" itemprop="text">
<p>Better way to achieve this is using <em>list comprehension</em> (having conditional check) with <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><strong><code>zip</code></strong></a> as:</p>
<pre><code>&gt;&gt;&gt; a = [1, -3, 2, -5, 5, 6, -8]
&gt;&gt;&gt; b = [1, 3, 5, 7, 9, 11, 13]
&gt;&gt;&gt; c = [2, 4, 6, 8, 10, 13, 14]

&gt;&gt;&gt; [(i*j if i &gt; 0 else i*k) for i, j, k  in zip(a, b, c)]
[1, -12, 10, -40, 45, 66, -112]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure how much of an improvement this will be, but you can shorten your original approach to:</p>
<pre><code>amount = [0,1,0,0,-1,0,1,-1,1]
data1 = [10,11,12,13,14,15,16,15,14]
data2 = [3,1,2,3,4,5,6,5,4]

flow = []    
for idx,num in enumerate(amount):
    flow.append( num *data1[idx] if num &gt; 0  else num * data2[idx])
</code></pre>
</div>
<span class="comment-copy">can you post some of your code so we can test it out?</span>
<span class="comment-copy">If an extra library is okay, I would suggest to use numpy for this. Then simple matrix multiplication would do the trick (using a binary selector matrix for the conditional). This makes sense if you intend to continue to perform mathematical operations</span>
<span class="comment-copy">btw your <code>elif amount[i] &lt;= 0:</code> can just be <code>else:</code> (may improve performance slightly if <code>amount</code> has lots of &lt;=0 value)</span>
<span class="comment-copy">In the question you link to, the positive and negative lists' lengths add to the length of the original list, whereas your proposed solution seems to have to both the positive and negative lists be equally long as the original list. Which is it you want to achieve?</span>
<span class="comment-copy">@marcman but wouldn't making the matrix every time waste the time you save on the multiplication? Amount changes every iteration, data1 and data2 stay the same.</span>
<span class="comment-copy">Thanks! I have tried it, have a look at my update. Small improvement, but not huge!</span>
<span class="comment-copy">Marking it as the right answer, even though it is just a small improvement. thanks! I'll try using vectors and matrices, as @marcman proposed.</span>
<span class="comment-copy">@Alex the problem statement you are having is very trivial, and your change is also having just single iteration. Among all the solutions I know for achieving this, this is the most efficient. I also tried with coupe of more solution, they were equivalent to this but this is more elegant.</span>
<span class="comment-copy">Looks like it takes as much time as my attempt: 100000 loops, best of 3: 2.94 µs per loop, but thanks!</span>
