<div class="post-text" itemprop="text">
<p>I want to create a for loop that will alternate upper and lowercase letters in a provided string (given as user input). 
My general idea is to make a for loop starting at 0 and ending at the length of the string, with a step size of 2. 
This is what I have so far (x is the string variable).</p>
<pre><code>for a in range (0,len(x),2):
    x=x[0:a] + x[a].upper + x[a+1::]
    print("Alternate Lowercase Letters:", a)
</code></pre>
<p>When I use this, I get an error message that says </p>
<blockquote>
<p>"TypeError: must be str, not builtin_function_or_method"</p>
</blockquote>
<p>Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned earlier, the cause of that error is that you have <code>x[a].upper</code> instead of <code>x[a].upper()</code>. So Python thinks you want to concatenate that method with the <code>x[0:a]</code> and <code>x[a+1::]</code> strings, and that doesn't make sense.</p>
<p>However, there are better ways to do this task. You can use a list comprehension to perform the case-changing and then use the <code>.join</code> method to convert the list contents into a string. Here are two variations.</p>
<p>We can use <code>enumerate</code> to get the character index while we iterate over the characters in the input string. If the index is odd, we make the char lower-case, otherwise we make it upper-case.</p>
<pre><code>def alt_case(s):
    return ''.join([u.lower() if i % 2 else u.upper() for i, u in enumerate(s)])
</code></pre>
<p>Alternatively, we can use slicing to separate the odd &amp; even chars, and then use zip to put them back together after performing the case transformations.</p>
<pre><code>def alt_case(s):
    hi = s[::2].upper()
    lo = s[1::2].lower()
    return ''.join([u+v for u, v in zip(hi, lo)])
</code></pre>
<p>Here's code that tests those functions.</p>
<pre><code>s = 'This is a test'
print(alt_case(s))
</code></pre>
<p><strong>output</strong></p>
<pre><code>ThIs iS A TeSt
</code></pre>
<hr/>
<p>FWIW, here's a cryptic variant of the first version:</p>
<pre><code>def alt_case(s):
    return ''.join([(str.upper, str.lower)[i%2](u) for i, u in enumerate(s)])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem, as pault mentioned, is that you use <code>.upper</code> rather than <code>.upper()</code>. The former gives you a function reference, and the latter gives you the return value of the function. </p>
<p>Another thing to consider, if the string <code>x</code> is long, is to cast it to a list and reassign values rather than reconstructing the whole string every iteration. If <code>x</code> is a short string, it doesn't really matter as there will be no perceivable runtime difference, but if it is rather long, there would certainly be a significant difference in runtime since this method is O(x) while your current method is O(x<sup>2</sup>).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <code>generater-comprehension</code> with <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer"><code>str.join</code></a>. I believe that this is the most efficient solution:</p>
<pre><code>def alternate(s):
    return ''.join(c.upper() if i &amp; 1 else c.lower() for i, c in enumerate(s))
</code></pre>
<p>and a test shows it works:</p>
<pre><code>&gt;&gt;&gt; alternate('testing')
'tEsTiNg'
</code></pre>
</div>
<span class="comment-copy">Two things that jump out- 1) you need parentheses for a function call (<code>.upper()</code>) and 2) you're printing <code>a</code> when you should be printing <code>x</code>. Change it to <code>x=x[0:a] + x[a].upper() + x[a+1::]</code> and <code>print("....", x)</code> and you should be good.</span>
<span class="comment-copy">Oh, that makes more sense. Thank you!</span>
<span class="comment-copy">That's one problem. The other problem is that OP is printing <code>a</code> (the index variable) and not <code>x</code> (the string).</span>
<span class="comment-copy">True, though I wasn't sure if that was on purpose, just for debugging, etc.</span>
<span class="comment-copy">Alternatively <code>if i%2 == 0</code>, which may be easier than bitwise operations for beginners to understand.</span>
<span class="comment-copy"><code>''.join((str.upper if i%2 else str.lower)(c) for i,c in enumerate(text))</code> :)</span>
<span class="comment-copy">@DYZ I like it.</span>
