<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/750136/how-is-returning-the-output-of-a-function-different-from-printing-it">How is returning the output of a function different from printing it?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>So I'm working my way through Wentworth et al <a href="http://openbookproject.net/thinkcs/python/english3e/" rel="nofollow noreferrer"><em>How to Think Like a Computer Scientist</em></a> a Python 3 guidebook to try and teach myself more about programming. While it's a fantastic resource, it has very little to say about style and "best practice" for writing in Python 3. </p>
<p>I'm working through one of practice questions in the chapter on conditionals that asks me to write a function that returns a string 'grade' when an int or float 'mark' is inputted. </p>
<p>My direct question here is about the repetition in the conditionals in the function and the value the function returns. Is it possible to use a loop instead somehow to make it more concise instead of just writing <code>elif</code> statements over and over? Also, the main <code>grade</code> function is returning a null <code>None</code> value; How I can make this function "fruitful" and not print <code>None</code> when it's called? </p>
<p>Here's what I've written:</p>
<pre><code>def grade(mark):
    grds = ['First','Upper Second','Second','Third','F1 Supp.','F2','F3']

    if mark &gt;= 75.0:
        print("Your grade is",grds[0])
    elif mark &lt; 75.0 and mark &gt;= 70.0:
        print("Your grade is",grds[1])
    elif mark &lt; 70.0 and mark &gt;= 60.0:
        print("Your grade is",grds[2])
    elif mark &lt; 60.0 and mark &gt;= 50.0:
        print("Your grade is",grds[3])
    elif mark &lt; 50.0 and mark &gt;= 45.0:
        print("Your grade is",grds[4])
    elif mark &lt; 45.0 and mark &gt;= 40.0:
        print("Your grade is",grds[5])
    elif mark &lt; 40.0: 
        print("Your grade is",grds[6])

def finalmark():
    mark = float(input("Enter your mark"))
    fnlmark = grade(mark)
    return fnlmark

print(finalmark())    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rather than using <code>print()</code> in the <code>grade()</code> function, <em>return</em> your result and have the caller print the resulting mark. The <code>grade()</code> function should only be used to return a grade:</p>
<pre><code>def grade(mark):
    grds = ['First','Upper Second','Second','Third','F1 Supp.','F2','F3']

    if mark &gt;= 75.0:
        return grds[0]
    # .. etc

def finalmark():
    mark = float(input("Enter your mark"))
    fnlmark = grade(mark)
    print("Your grade is", fnlmark)

finalmark()
</code></pre>
<p>Note that <code>finalmark()</code> is responsible for printing now; that's the best place for it, as that same function also is responsible for printing the question on the screen and taking user input. Like your version, <code>finalmark()</code> returns <code>None</code> (because that's the default), and I removed the <code>print()</code> from around the <code>finalmark()</code> call to avoid printing that return value. There's no point in printing it, <code>finalmark()</code> will never return anything other than <code>None</code>.</p>
<p>You can also remove half of your tests; only the <em>first matching</em> <code>if</code> or <code>elif</code> branch is picked, the rest are skipped. So you can remove tests for what a previous branch already covered:</p>
<pre><code>def grade(mark):
    grds = ['First','Upper Second','Second','Third','F1 Supp.','F2','F3']

    if mark &gt;= 75.0:
        return grds[0]
    elif mark &gt;= 70.0:
        return grds[1]
    elif mark &gt;= 60.0:
        return grds[2]
    elif mark &gt;= 50.0:
        return grds[3]
    elif mark &gt;= 45.0:
        return grds[4]
    elif mark &gt;= 40.0:
        return grds[5]
    else:
        return grds[6]
</code></pre>
<p>If the first <code>if mark &gt;= 75.0:</code> test did not match, then there is no need to test for <code>mark &lt; 75.0</code> anymore, because <em>we have tested for the inverse</em>. Testing for <code>mark &gt;= 70.0</code> is enough for the next grade. If that fails to match, we know the mark is definitely smaller than 70, so the next test only needs to test if it is larger than <code>60.0</code>, etc.</p>
<p>Now a pattern emerges that you could build a loop on. You test for a <em>lower bound</em>, and if it matches, you know which index to return. Build a separate list to store the lower bounds:</p>
<pre><code>def grade(mark):
    grds = ['First','Upper Second','Second','Third','F1 Supp.','F2','F3']
    bounds = [75.0, 70.0, 60.0, 50.0, 45.0, 40.0]

    for grade, bound in zip(grds, bounds):
        if mark &gt;= bound:
            return grade

    # there is no lower bound for F3; if the loop didn't find a match,
    # we end up here and can assume the lowest grade.
    return grds[6]
</code></pre>
<p>I used the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code> function</a> here to pair up the grade names and the bounds, pairwise. You could also have used the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate()</code> function</a> to generate an index along with each grade name, or a <code>for index in range(len(grds)):</code> loop, but I find <code>zip()</code> to work cleaner here.</p>
<p>Next, we can start being clever with the algorithm. The above still tests <em>each grade, from high to low, one by one</em>. That can take up to N steps, for N grades. That's a <em>linear algorithm</em>, it takes as many steps as there are inputs.</p>
<p>But the grades are <em>sorted</em>, so we could use bisection here; jump to the middle and see if the mark is lower or higher than the current bound. Then pick either half, and test again, until you find a best match. Bisection takes at most Log(N) steps. Python has a <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer">very fast implementation included</a>; it assumes values in <em>increasing</em> order, so reverse the grades and boundaries:</p>
<pre><code>import bisect

def grade(mark):
    grds = ['F3', 'F2', 'F1 Supp.', 'Third', 'Second', 'Upper Second', 'First']
    bounds = [40.0, 45.0, 50.0, 60.0, 70.0, 75.0]
    return grds[bisect.bisect_right(bounds, mark)]    
</code></pre>
<p><code>bisect.bisect_right()</code> bisects into <code>bounds</code> to find the 'insertion point' for <code>mark</code>, which will be <em>to the right</em> of the same value in the list. So <code>35.0</code> would be inserted at <code>0</code>, <code>50.0</code> at <code>3</code> (as it is equal <em>or higher</em>), <code>74.0</code> at <code>5</code> and anything at <code>75.0</code> or higher at <code>6</code>. And those happen to be the exact indices for the matching grades.</p>
</div>
<div class="post-text" itemprop="text">
<p>Two very simple things:</p>
<ul>
<li><p>You <em>never</em> return anything.  By default, Python is going to return <code>None</code>.  You can fix this by adding a return statement in addition to or in lieu of your print statement.</p>
<pre><code>def grade(mark):
    grds = ['First','Upper Second','Second','Third','F1 Supp.','F2','F3']

    if mark &gt;= 75.0:
        print("Your grade is",grds[0])
        return grds[0]
    elif 75.0 &gt; mark &gt;= 70.0:
        print("Your grade is",grds[1])
        return grds[1]
</code></pre></li>
<li><p>You can simplify your expression.  Python accepts ranges of expressions analogous to mathematical ranges (e.g. 0 &lt;= x &lt;= 100 is valid Python).  You can see an example of that above; I leave cleaning it up and making it more readable as an exercise for the reader.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Below are two pythonic solutions. As a learning problem, there are a few interesting bits to understand: dictionaries with tuple keys, iterating dictionary items, generator expressions, class inheritance.</p>
<p>This isn't the <em>only</em> way to structure your code. Another way is to set a sequence of boundary scores, as in <a href="https://stackoverflow.com/a/48653351/9209546">@MartijnPeter's answer</a>. However, these are <em>readable</em> and reasonably performant solutions.</p>
<p>In both instances note the importance of the <code>return</code> statement, which is missing in your code. By default, Python returns <code>None</code>.</p>
<p><strong>Functional</strong></p>
<pre><code>def grade(mark):

    grds = {(75, 100.1): 'First',
            (70, 75): 'Upper Second',
            (60, 70): 'Second',
            (50, 60): 'Third',
            (45, 50): 'F1 Supp.',
            (40, 45): 'F2',
            (0, 40): 'F3'}

    return next(v for k, v in grds.items() if k[0] &lt;= mark &lt; k[1])
</code></pre>
<p><strong>Object-oriented</strong></p>
<p>The beauty of python is it marries, to some degree, object-oriented and functional programming. Consider the below solution. Efficiency will be similar to the above, but it introduces a construct, subclass <code>dict_range</code> inheriting from <code>dict</code>, which can be reused easily in other scenarios.</p>
<pre><code>class dict_range(dict):
    def __getitem__(self, value):
        return next(self.get(k) for k in self.keys() if k[0] &lt;= value &lt; k[1])

def grade(mark):

    grds = dict_range({(75, 100.1): 'First',
                       (70, 75): 'Upper Second',
                       (60, 70): 'Second',
                       (50, 60): 'Third',
                       (45, 50): 'F1 Supp.',
                       (40, 45): 'F2',
                       (0, 40): 'F3'})

    return grds[mark]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First : why does your function return None ?</p>
<p>Because you actually use print, which echoes the text to the user. What you want to use instead is return, which will leave the function and basically say "that's what I have calculated".</p>
<p>As there is no value returned, python automatically returns None. If you were in a stricter language, you would probably have an error.</p>
<p>Therefore, you should do this :</p>
<pre><code>return "Your grade is " + grds[0]
</code></pre>
<p>Second : how to improve your code ?</p>
<p>The first thing to see is that if the first condition is valid (<code>mark &gt;= 75.0</code>) then, in all the elifs, mark can't be more (or equal) to 75, which mean that you can, in this case, get rid of every lower than condition in every elif.</p>
<p>Third : how to improve your code (2) ?</p>
<p>Now, as I have told you, return leaves the function. So you can use this to remove the elifs as such : </p>
<pre><code>def grade(mark):
    grds = ['First','Upper Second','Second','Third','F1 Supp.','F2','F3']

    if mark &gt;= 75.0:
        return ("Your grade is " + grds[0])
    if mark &gt;= 70.0:
        return ("Your grade is " + grds[1])
    if mark &gt;= 60.0:
        return ("Your grade is " + grds[2])
    if mark &gt;= 50.0:
        return ("Your grade is " + grds[3])
    if mark &gt;= 45.0:
        return ("Your grade is " + grds[4])
    if mark &gt;= 40.0:
        return ("Your grade is " + grds[5])
    return ("Your grade is " + grds[6])
</code></pre>
<p>The issue now is that you have the same code repeated a lot of times. This mean that you can break it into a loop. I would recommend using an array of bounds as such :</p>
<pre><code>def grade(mark):
    grds = ['First','Upper Second','Second','Third','F1 Supp.','F2','F3']
    bounds = [75.0, 70.0, 60.0, 50.0, 45.0, 40.0]
    for i in range(len(bounds)):
        if mark &gt;= bounds[i]:
            return ("Your grade is " + grds[i])
    return ("Your grade is " + grds[-1])
</code></pre>
<p>I hope I have explained this clearly, if you have any questions, just ask them below.</p>
</div>
<div class="post-text" itemprop="text">
<p>Slightly different approach to Makoto. Again, just for a snippet.</p>
<pre><code>if mark &gt;= 75: 
    # limit the religion here by just saving an index
    idx = 0
# you don't need to check its below 75, as that was confirmed by above failing
elif mark &gt;= 70:
    idx = 0
# now consolidate the repetitions here.
return grds[idx]
</code></pre>
</div>
<span class="comment-copy">.... you're getting <code>None</code> because your <code>grade</code> function <i>always returns <code>None</code></i></span>
<span class="comment-copy">Slight correction - <code>bisect_right</code> should be used here, because if a mark is exactly equal to the lower bound for a grade, that is just enough to still be rewarded the higher of the two candidate grades, e.g. <code>grade(75.0)</code> should return <code>'First'</code></span>
<span class="comment-copy">@plamut: ah, indeed, I had my logic backwards based on the earlier tests, not applying the inversion correctly.</span>
<span class="comment-copy">The binary search seems overkill. I'm not even convinced it's faster here, since it's more complicated and the list is tiny. And it doesn't even provide a better complexity class, since your function builds the entire lists every time it's called so your function takes O(N) anyway. Maybe better use tuples instead so they get pre-compiled. It's definitely <i>nice code</i>, though, so I'd say that's the real advantage here.</span>
<span class="comment-copy">... or do it like the documentation does in <a href="https://docs.python.org/3/library/bisect.html#other-examples" rel="nofollow noreferrer">its example of exactly this</a>, using default arguments.</span>
