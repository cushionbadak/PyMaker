<div class="post-text" itemprop="text">
<p>Total noob, seriously and angrily struggling with Python...</p>
<p>What I'm trying to do SHOULD be simple:</p>
<ol>
<li>Make a button.</li>
<li>Connect that button go a function.</li>
<li>Click button --&gt; run function.</li>
</ol>
<p>The problem comes when we have to use CLASS (which, no matter how much I read, study - or even pay to take classes continues to make zero sense to me)...</p>
<p>I've tried every concieveable combination of putting this little convert() function IN the class, of adding self.convert or root.convert - and NONE of it works. And, I am clueless why - or what to try next.</p>
<p>Here's the code:</p>
<pre><code>from tkinter import *
from tkinter.ttk import Frame, Button, Style


def convert():
    print("clicked")
    kg = entry_kg.get()
    print(kg)



class Example(Frame):

    def __init__(self):
        super().__init__()

    self.initUI()    # initiate the GUI
    # -------------------------------


    def initUI(self):

        self.master.title("Weight Converter")
        self.pack(fill=BOTH, expand=True)
        # -------------------------------------

        frame_kg = Frame(self)   # frame for Kilograms
        frame_kg.pack(fill=X)

        lbl_kg = Label(frame_kg, text="Kilograms", width=16)
        lbl_kg.pack(side=LEFT, padx=5, pady=5)

        entry_kg = Entry(frame_kg)
        entry_kg.pack(fill=X, padx=(5, 30), expand=True)
        # ------------------------------------------------

        frame_btn = Frame(self)    # frame for buttons
        frame_btn.pack(fill=BOTH, expand=True, padx=20, pady=5)

        btn_convert=Button(frame_btn, text="Convert", command=convert)
        btn_convert.pack(side=LEFT, padx=5, pady=5)

        # -------------------------------------------

def main():

    root = Tk()
    root.geometry("300x200+300+200")
    app = Example()
    root.mainloop()


if __name__ == '__main__':
    main()
</code></pre>
<p>What am I doing wrong?</p>
<p>How to do it right?</p>
<p>The seemingly arbitrary and useless over-complication of a simple task is seriously maddening...</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want your functions to be designed outside of the class, but want to call it from a button defined in the class, the solution is to create a method in your class which takes the input values and then passes them to the external function. </p>
<p>This is called <em>decoupling</em>. Your function is <em>decoupled</em> from the implementation of the UI, and it means that you are free to completely change the implementation of the UI without changing the function, and vice versa. It also means that you can reuse the same function in many different programs without modification. </p>
<p>The overall structure of your code should look something like this:</p>
<pre><code># this is the external function, which could be in the same
# file or imported from some other module
def convert(kg):
    pounds = kg * 2.2046
    return pounds

class Example(...):
    def initUI(self):
        ...
        self.entry_kg = Entry(...)
        btn_convert=Button(..., command=self.do_convert)
        ...

    def do_convert(self):
        kg = float(self.entry_kg.get())
        result = convert(kg)
        print("%d kg = %d lb" % (kg, result))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>entry_kg</code> is not <em>known</em> anywhere outside the scope of <code>initUI</code> method. That is why. You could convert it from a method variable to instance attribute to be within reach for class methods by replacing:</p>
<pre><code>entry_kg = Entry(frame_kg)
entry_kg.pack(fill=X, padx=(5, 30), expand=True)
</code></pre>
<p>with:</p>
<pre><code>self.entry_kg = Entry(frame_kg)
self.entry_kg.pack(fill=X, padx=(5, 30), expand=True)
</code></pre>
<hr/>
<p><strong>Only <em>then</em></strong>:</p>
<p>You can mention it in a class method like:</p>
<pre><code>...
kg = self.entry_kg.get()
</code></pre>
<p>That way you if you make your <code>convert</code> a method under <code>Example</code> again:</p>
<pre><code>def initUI(self):
...
def convert(self):           # is defined under the same scope as initUI
    print("clicked")
    kg = self.entry_kg.get() # notice that it now refers to self.e...
    print(kg)
</code></pre>
<p>also don't forget to replace command option as well:</p>
<pre><code>btn_convert=Button(..., command=self.convert)
</code></pre>
<hr/>
<p><strong>Or only <em>then</em>:</strong></p>
<p>When outside the class scope, by using dot notation on the object that the class creates:</p>
<pre><code>def main():

    root = Tk()
    root.geometry("300x200+300+200")
    app = Example()
    kg = app.entry_kg.get() # This would return an empty string, but it would still be valid
    root.mainloop()
</code></pre>
<p>to be used with global methods, such as the current state of <code>convert</code> you need to make <code>app</code> (the object it is an attribute of) global, or pass it explicitly to the method.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a modified version of your code that works. The changes have been indicated with ALL CAPS line comments. I obviously misunderstood your question (which does say you could figure out how to make the <code>convert()</code> function part of the class. However, you mentioned you wanted the opposite of that, so I'm modified the code here accordingly.</p>
<p>Essentially the problem boils down to the <code>convert()</code> function needing to access a <code>tkinter.Entry</code> widget that's created somewhere else—inside your <code>Example</code> class in this case.</p>
<p>One way of doing that would be to save the widget in a global variable and access it through the variable name assigned to it. Many folks do that because it's easiest to thing to do, but as you should know, global variables are considered a bad practice and are generally something to be avoided.</p>
<p>There's a common way to avoid needing one with <code>tkinter</code>, which is sometimes called "<a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/extra-args.html" rel="nofollow noreferrer">the extra arguments trick</a>". To use it all you need to do is create a short anonymous function with an argument that has a default value defined—which in this case will be the <code>Entry</code> widget you want passed to the now "wrapped" <code>convert()</code> function. This can be done using what's called a <a href="https://docs.python.org/3/reference/expressions.html#lambda" rel="nofollow noreferrer"><code>lambda expression</code></a>. The revised code below and the comments in it show and describe how to do this:</p>
<pre><code>from tkinter import *
from tkinter.ttk import Frame, Button, Style


def convert(entry_widget):  # ADDED WIDGET ARGUMENT
    """ Some function outside class. """
    print("clicked")
    kg = entry_widget.get()  # REFERENCE ENTRY WIDGET PASSED AS ARGUMENT
    print(kg)


class Example(Frame):
    def __init__(self):
        super().__init__()

        self.initUI()    # initiate the GUI

    def initUI(self):
        self.master.title("Weight Converter")
        self.pack(fill=BOTH, expand=True)

        frame_kg = Frame(self)   # frame for Kilograms
        frame_kg.pack(fill=X)

        lbl_kg = Label(frame_kg, text="Kilograms", width=16)
        lbl_kg.pack(side=LEFT, padx=5, pady=5)

        entry_kg = Entry(frame_kg)
        entry_kg.pack(fill=X, padx=(5, 30), expand=True)

        frame_btn = Frame(self)    # frame for buttons
        frame_btn.pack(fill=BOTH, expand=True, padx=20, pady=5)

        btn_convert=Button(frame_btn, text="Convert",
                        # DEFINE ANONYMOUS FUNCTION WITH DEFAULT ARGUMENT SO IT'S
                        # AUTOMATICALLY PASSED TO THE TARGET FUNCTION.
                        command=lambda entry_obj=entry_kg: convert(entry_obj))
        btn_convert.pack(side=LEFT, padx=5, pady=5)


def main():
    root = Tk()
    root.geometry("300x200+300+200")
    app = Example()
    root.mainloop()

if __name__ == '__main__':
    main()
</code></pre>
</div>
<span class="comment-copy">Please fix the indentation of the code.</span>
<span class="comment-copy">TkInter is an old interface, kept around for backward compatibility and for those who really need a self contained executable.  Modern code would use a web framework like Flask and serve a simple HTML page.  Of course that would mean learning Flask and HTML.</span>
<span class="comment-copy">Welcome to <a href="https://stackoverflow.com">Stack Overflow</a>. Please try to provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> as opposed to your current code. You'll both understand more which parts of your code does what, and improve the quality of the question to motivate better answers.</span>
<span class="comment-copy">@verisimilidude I don't see how this helps the OP exactly.</span>
<span class="comment-copy">Sorry to Bryan Oakley for the ugly code.  I pasted, expecting the editor to retain the indenting.   And, seriously?  This editor not only can't maintain existing indents, but can't take tabs, either? Seriously? We have to sit and hit the spacebar?  To versimilidude (great name): Thanks very much for your comment. I'm <i>clueless</i> - I was taking a class on Udemy that said to use tkinter. Now, I'm doubly pissed-off that I've been tearing hair over this. Grateful, however for your pointing me toward Flask. Guess that's the next google...</span>
<span class="comment-copy">There's no way to format a comment here?</span>
<span class="comment-copy">@JohnBailey There is but it is a bit messy. Do you see help link under Add Comment button? It explains a bit.</span>
<span class="comment-copy">Thank you for patience.  &lt;br/&gt; I've got to learn a whole new editor just to comment?&lt;br/&gt;   And, that still doesn't work. NO LINE BREAKS TO BE HAD HERE</span>
<span class="comment-copy">@JohnBailey Well, you don't <i>have</i> to format your comments. But yeah, the rules here do apply in posts but not vice-versa.</span>
<span class="comment-copy">Thank you again. I got the first version to work, but that locks me into putting the function IN the class - which is not the way I wanted to organize it. I wanted a class for the tkinter interface and a different place for the functions.</span>
<span class="comment-copy">@Nae: Obviously I missed a comment on one line and have fixed it.</span>
<span class="comment-copy">@Nae: Sorry for assuming it was you.</span>
<span class="comment-copy">thank you for your help. Much appreciated. I wanted to keep the functions OUTside the class of the interface, but alas, that seems impossible...</span>
<span class="comment-copy">John: Obviously I misunderstood what you desired. See updated answer.</span>
<span class="comment-copy">thank you VERY MUCH for that update. The people here are so fantastic!   And, boy have I got questions, now.   You added the entry_widget argument to the def convert() function.   If you don't mind my asking, why do we pass the widget object rather than the value contained in it?</span>
