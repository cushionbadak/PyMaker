<div class="post-text" itemprop="text">
<p>Last month I made a scraper for <a href="https://www.dizionario-latino.com/" rel="nofollow noreferrer">this</a> Latin dictionary. It finally finished executing (that website gave me response times of 6 to 8 seconds per page). To bad I find out that a good chunk of my data is severely compromised...<br/>
eg. commandūcor ----&gt; command\xc5\xabcor || commandūcāris ----&gt; command\xc5\xabc\xc4\x81ris</p>
<p>I made the stupid mistake of using the str() function on the raw data I got from requests. Just like this:</p>
<pre><code>import requests

r = requests.get("https://www.dizionario-latino.com/dizionario-latino-
flessione.php?lemma=COMMANDUCOR100", verify = False)

out = str(r.content)

with open("test.html", 'w') as file:
    file.write(out)
</code></pre>
<p>I'd really appreciate it if anyone could help me restore the broken text.
Thank you in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>r.content</code> returns <code>bytes</code>. (In contrast, <a href="http://www.python-requests.org/en/latest/user/quickstart/#response-content" rel="nofollow noreferrer"><code>r.text</code> returns a <code>str</code></a>. The <code>requests</code> module attempts to guess the correct decoding based on HTTP headers and decodes the bytes using that encoding for you. In the future maybe that is what you would want to use instead).</p>
<p>If <code>r.content</code> contained <code>bytes</code> such as <code>b'command\xc5\xabcor'</code>, then
<code>str(r.content)</code> returns a <code>str</code> which begins with the characters <code>b'</code> and ends with a literal <code>'</code>. </p>
<pre><code>In [45]: str(b'command\xc5\xabcor')
Out[45]: "b'command\\xc5\\xabcor'"
</code></pre>
<p>You can use <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer"><code>ast.literal_eval</code></a> to recover the bytes:</p>
<pre><code>In [46]: ast.literal_eval(str(b'command\xc5\xabcor'))
Out[46]: b'command\xc5\xabcor'
</code></pre>
<p>You could then decode these <code>bytes</code> to a <code>str</code>. The URL you posted declares the content is UTF-8 encoded:</p>
<pre><code>&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
</code></pre>
<p>Assuming all the data you downloaded uses the same encoding, you could recover the content as a str by calling the <code>bytes.decode('utf-8')</code> method:</p>
<pre><code>In [47]: ast.literal_eval(str(b'command\xc5\xabcor')).decode('utf-8')
Out[47]: 'commandūcor'
</code></pre>
<hr/>
<pre><code>import ast
import requests

r = requests.get("https://www.dizionario-latino.com/dizionario-latino-flessione.php?lemma=COMMANDUCOR100", verify = False)

out = str(r.content)

with open("test.html", 'w') as file:
    file.write(out)

with open("test.html", 'r') as f_in, open("test-fixed.html", 'w') as f_out:
    broken_text = f_in.read()  
    content = ast.literal_eval(broken_text)
    assert content == r.content
    text = content.decode('utf-8')
    f_out.write(text)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just <a href="https://docs.python.org/3.6/library/stdtypes.html#bytes.decode" rel="nofollow noreferrer"><code>.decode</code></a> them using <code>utf-8</code> (the default). You can read more about character encodings in Python's <a href="https://docs.python.org/3.6/howto/unicode.html" rel="nofollow noreferrer">Unicode howto</a>.</p>
<pre><code>b'command\xc5\xabcor'.decode()  # 'commandūcor'
b'command\xc5\xabc\xc4\x81ris'.decode()  # 'commandūcāris'
</code></pre>
</div>
<span class="comment-copy">Are you sure it is "broken"</span>
<span class="comment-copy">It is not broken, these are probably just binary strings.</span>
<span class="comment-copy">@ᴡʜᴀᴄᴋᴀᴍᴀᴅᴏᴏᴅʟᴇ3000 Well I can't seem to figure out how to restore it to it's previous state</span>
<span class="comment-copy">Try printing it. And what was its previous state?</span>
<span class="comment-copy">For example it prints: command\xc5\xabcor</span>
<span class="comment-copy">Perfect this works, just had to write in binary.</span>
<span class="comment-copy">Thank you, That works! How would I implement this? If I say b = "command\xc5\xabcor" print(b.encode().decode()) I get "commandÅ«cor" as an output which is incorrect</span>
<span class="comment-copy">@AlexP. Interesting... You're wanting to treat a string as though it were bytes. I don't know. You might want to ask this in a new question for more visibility.</span>
<span class="comment-copy">Why do you <code>endcode().decode()</code>? That would be a round-trip but apparently you should specify the correct encoding explicitly to avoid getting mojibake.</span>
