<div class="post-text" itemprop="text">
<p>I have an audio file, <code>Sample.flac</code>. The title and length can be read with <code>ffprobe</code> to result in the output being sent to STDERR.</p>
<p>I want to run <code>ffprobe</code> through subprocess, and have done so successfully. I then retrieve the output (piped to <code>subprocess.PIPE</code>) with <code>*.communicate()[1].decode()</code> as indicated that I should by the Python docs.</p>
<p><code>communicate()</code> returns a tuple, <code>(stdout, stderr)</code>, with the output from the <code>Popen()</code> object. The proper index for <code>stderr</code> is then accessed and decoded from a byte string into a Python 3 UTF-8 string.</p>
<p>This decoded output is then parsed with a multiline regex pattern matching the format of the <code>ffprobe</code> metadata output. The match groups are then placed appropriately into a dictionary, with each first group converted to lowercase, and used as the key for the second group (value).</p>
<p><a href="https://regex101.com/r/PVHwPJ/1" rel="nofollow noreferrer">Here is an example of the output and the working regex.</a></p>
<p>The data can be accessed through the dictionary keys as expected. But upon concatenating the values together (all are strings), the output appears mangled.</p>
<p>This is the output I would expect:</p>
<pre><code>Believer (Kaskade Remix) 190
</code></pre>
<p>Instead, this is what I get:</p>
<pre><code> 190ever (Kaskade Remix)
</code></pre>
<p>I don't understand why the strings appear to "overlap" each other and result in a mangled form. Can anyone explain this and what I have done wrong?</p>
<p>Below is the complete code that was run to produce the results above. It is a reduced section of my full project.</p>
<pre><code>#! /usr/bin/env python3
# -*- coding: utf-8 -*-

import os

from re import findall, MULTILINE
from subprocess import Popen, PIPE


def media_metadata(file_path):
    """Use FFPROBE to get information about a media file."""
    stderr = Popen(("ffprobe", file_path), shell=True, stderr=PIPE).communicate()[1].decode()

    metadata = {}

    for match in findall(r"(\w+)\s+:\s(.+)$", stderr, MULTILINE):
        metadata[match[0].lower()] = match[1]

    return metadata


if __name__ == "__main__":
    meta = media_metadata("C:/Users/spike/Music/Sample.flac")
    print(meta["title"], meta["length"])
    # The above and below have the same result in the console
    # print(meta["title"] + " " + meta["length"])
    # print("{title} {length}".format(meta))
</code></pre>
<p>Can anyone explain this unpredictable output?</p>
<p>I have asked this question <a href="https://stackoverflow.com/questions/48672124/mangled-output-when-printing-strings-from-ffprobe-stderr">here</a> earlier, however I dont think it was very clear. In the <a href="https://gist.githubusercontent.com/anonymous/cbd9af38013339fd13daaa4096e1657f/raw/cca381ac6c5216a0d29194ac0c648ec39aba98a6/1_output.txt" rel="nofollow noreferrer">raw output</a> when this is run on multiple files, you can see that towards the end the strings start becoming as unpredictable as not even printing part of the <code>title</code> value at all.</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Reproduce:</strong></p>
<pre><code>print('Believer (Kaskade Remix)\r 190')
</code></pre>
<p><strong>Output:</strong></p>
<pre><code> 190ever (Kaskade Remix)
</code></pre>
<p><strong>Issue:</strong></p>
<p>End-Of-Line is <code>\r\n</code>. re <code>$</code> matches <code>\n</code>. <code>\r</code> remains in the matching group.</p>
<p><strong>Fix:</strong></p>
<p>Insert <code>\r</code> before <code>$</code> in your re pattern. i.e. <code>(\w+)\s+:\s(.+)\r$</code></p>
<p>Or use <code>universal_newlines=True</code> as a Popen argument and remove <code>.decode()</code>
as the output will be text with <code>\n</code> instead of <code>\r\n</code>.</p>
<p>Or <code>stderr = stderr.replace('\r', '')</code> before re processing. </p>
<p><strong>Alternative:</strong></p>
<p>ffprobe can output a <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">json</a> string. Use <code>json</code> module which <a href="https://docs.python.org/3/library/json.html#json.loads" rel="nofollow noreferrer">loads</a> the string
and returns a dictionary.</p>
<p>i.e. command</p>
<pre><code>['ffprobe', '-show_format', '-of', 'json', file_path]
</code></pre>
<p>The json string will be the stdout stream.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are catching up the "\r" symbol. At printing, cursor is returned to the beginning of the string, so the next print and overwrites the first part. Stripping whitespaces (will also remove trailing "\r") should solve the problem:</p>
<pre><code>metadata[match[0].lower()] = match[1].strip()
</code></pre>
</div>
<span class="comment-copy">Accepted as the answer because it is the most thorough, however both are correct. Thank you.</span>
<span class="comment-copy">But why would this affect concatenation as shown in the second commented print statement?</span>
<span class="comment-copy">both look the same to me (<code>print(meta["title"], meta["length"])</code>). What is the difference?</span>
<span class="comment-copy">One uses explicit concatenation, and the other I assume internally uses <code>" ".join(args)</code>?</span>
<span class="comment-copy">I see two exactly identical expressions. I might be looking at a wrong expression(s), so can you give a specific example?</span>
<span class="comment-copy">Ahah, I didn't catch that. I fixed it and added another example, even though this has been solved. Thanks.</span>
