<div class="post-text" itemprop="text">
<p>I decided to try and get into the multiprocessor module to help speed up my program. To figure it out, I tried using some of the code examples on the official python documentation on multiprocessing.</p>
<h1>First attempt: <a href="https://docs.python.org/3/library/multiprocessing.html#introduction" rel="nofollow noreferrer" title="introduction code">Introduction</a></h1>
<pre><code>&gt;&gt;&gt; from multiprocessing import Pool
&gt;&gt;&gt;
&gt;&gt;&gt; def f(x):
...     return x*x
...
&gt;&gt;&gt; if __name__ == '__main__':
...     with Pool(5) as p:
...         print(p.map(f, [1, 2, 3]))
...
Process SpawnPoolWorker-3:
Process SpawnPoolWorker-2:
Traceback (most recent call last):
  File "C:\Program Files\Python36\lib\multiprocessing\process.py", line 258, in _bootstrap
    self.run()
  File "C:\Program Files\Python36\lib\multiprocessing\process.py", line 93, in run
    self._target(*self._args, **self._kwargs)
  File "C:\Program Files\Python36\lib\multiprocessing\pool.py", line 108, in worker
    task = get()
  File "C:\Program Files\Python36\lib\multiprocessing\queues.py", line 337, in get
    return _ForkingPickler.loads(res)
AttributeError: Can't get attribute 'f' on &lt;module '__main__' (built-in)&gt;
Traceback (most recent call last):
  File "C:\Program Files\Python36\lib\multiprocessing\process.py", line 258, in _bootstrap
    self.run()
  File "C:\Program Files\Python36\lib\multiprocessing\process.py", line 93, in run
    self._target(*self._args, **self._kwargs)
  File "C:\Program Files\Python36\lib\multiprocessing\pool.py", line 108, in worker
    task = get()
  File "C:\Program Files\Python36\lib\multiprocessing\queues.py", line 337, in get
    return _ForkingPickler.loads(res)
AttributeError: Can't get attribute 'f' on &lt;module '__main__' (built-in)&gt;
Process SpawnPoolWorker-4:
Traceback (most recent call last):
  File "C:\Program Files\Python36\lib\multiprocessing\process.py", line 258, in _bootstrap
    self.run()
  File "C:\Program Files\Python36\lib\multiprocessing\process.py", line 93, in run
    self._target(*self._args, **self._kwargs)
  File "C:\Program Files\Python36\lib\multiprocessing\pool.py", line 108, in worker
    task = get()
  File "C:\Program Files\Python36\lib\multiprocessing\queues.py", line 337, in get
    return _ForkingPickler.loads(res)
AttributeError: Can't get attribute 'f' on &lt;module '__main__' (built-in)&gt;
</code></pre>
<p>Here I assume that the pool function is broken; maybe there is a typo somewhere in the lastest version. So I try some of the more specific code.</p>
<h1>Second attempt: <a href="https://docs.python.org/3/library/multiprocessing.html#the-process-class" rel="nofollow noreferrer">Process class code block 2</a></h1>
<pre><code>&gt;&gt;&gt; from multiprocessing import Process
&gt;&gt;&gt; import os
&gt;&gt;&gt;
&gt;&gt;&gt; def info(title):
...     print(title)
...     print('module name:', __name__)
...     print('parent process:', os.getppid())
...     print('process id:', os.getpid())
...
&gt;&gt;&gt; def f(name):
...     info('function f')
...     print('hello', name)
...
&gt;&gt;&gt; if __name__ == '__main__':
...     info('main line')
...     p = Process(target=f, args=('bob',))
...     p.start()
...     p.join()
...
main line
module name: __main__
parent process: 43824
process id: 54888
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
  File "C:\Program Files\Python36\lib\multiprocessing\spawn.py", line 105, in spawn_main
    exitcode = _main(fd)
  File "C:\Program Files\Python36\lib\multiprocessing\spawn.py", line 115, in _main
    self = reduction.pickle.load(from_parent)
AttributeError: Can't get attribute 'f' on &lt;module '__main__' (built-in)&gt;
</code></pre>
<p>At this point I know the underlying error is with the Process function of multiprocessing. However, I think that the extended code might have broken something, so I try the simple code.</p>
<h1>Third Attempt <a href="https://docs.python.org/3/library/multiprocessing.html#the-process-class" rel="nofollow noreferrer">Process class code block 1</a></h1>
<pre><code>&gt;&gt;&gt; from multiprocessing import Process
&gt;&gt;&gt;
&gt;&gt;&gt; def f(name):
...     print('hello', name)
...
&gt;&gt;&gt; if __name__ == '__main__':
...     p = Process(target=f, args=('bob',))
...     p.start()
...     p.join()
...
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
  File "C:\Program Files\Python36\lib\multiprocessing\spawn.py", line 105, in spawn_main
    exitcode = _main(fd)
  File "C:\Program Files\Python36\lib\multiprocessing\spawn.py", line 115, in _main
    self = reduction.pickle.load(from_parent)
AttributeError: Can't get attribute 'f' on &lt;module '__main__' (built-in)&gt;
</code></pre>
<p>At this point I was desperate. I think that maybe the argument was messing with the Process class.</p>
<h1>Final attempt: self-generated code</h1>
<pre><code>&gt;&gt;&gt; from multiprocessing import Process
&gt;&gt;&gt;
&gt;&gt;&gt; def f():
...     print('hello')
...
&gt;&gt;&gt; if __name__ == '__main__':
...     p = Process(target=f)
...     p.start()
...     p.join()
...
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
  File "C:\Program Files\Python36\lib\multiprocessing\spawn.py", line 105, in spawn_main
    exitcode = _main(fd)
  File "C:\Program Files\Python36\lib\multiprocessing\spawn.py", line 115, in _main
    self = reduction.pickle.load(from_parent)
AttributeError: Can't get attribute 'f' on &lt;module '__main__' (built-in)&gt;
</code></pre>
<p>Now I am totally confused because I do not know why the error is occuring. Could someone help me figure out why I am getting this error every time?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're in interactive mode. That basically doesn't work with <code>multiprocessing</code>, because the workers have to import <code>__main__</code> and get something that mostly resembles the main process's <code>__main__</code>. This is one of the many ways in which the <code>multiprocessing</code> API is horribly confusing.</p>
<p>Put your code in a script and run the script.</p>
</div>
<div class="post-text" itemprop="text">
<p>When <code>multiprocessing</code> is invoked on windows, it uses the <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer"><code>spawn</code></a> strategy for creating new processes.</p>
<blockquote>
<p>The parent process starts a fresh python interpreter process.</p>
</blockquote>
<p>The <em>rough</em> strategy taken here for function objects that are "pickled" across processes is:</p>
<ol>
<li>Record the module of the function before creating a new process (in this case <code>f.__module__</code> =&gt; <code>__main__</code>)</li>
<li>Encode that to some representation</li>
<li>In the newly spawned process, initialize the main module (for interactive execution this is an empty module)</li>
<li>"unpickle" the arguments, for functions this means:

<ol>
<li>import their module</li>
<li>access their function name from that module (where you're getting your <code>AttributeError</code>)</li>
</ol></li>
</ol>
<p>In your case this looks roughly like this:</p>
<ol>
<li>Record <code>('__main__', 'f')</code></li>
<li>encode that</li>
<li>spawn a new process, initialize an empty <code>__main__</code> module</li>
<li>unpickle (recover <code>__main__</code> and <code>f</code>)

<ol>
<li><code>import __main__ as mod</code></li>
<li><code>obj = getattr(mod, 'f')</code> (boom!)</li>
</ol></li>
</ol>
<p>For more details about the specific pickling / unpickling, check out the <a href="https://github.com/python/cpython/blob/bd73e72b4a9f019be514954b1d40e64dc3a5e81c/Lib/multiprocessing/reduction.py#L198-L223" rel="nofollow noreferrer"><code>ForkingPickler</code></a></p>
<p>Here's an excerpt:</p>
<pre><code>#
# Try making some callable types picklable
#

def _reduce_method(m):
    if m.__self__ is None:
        return getattr, (m.__class__, m.__func__.__name__)
    else:
        return getattr, (m.__self__, m.__func__.__name__)
class _C:
    def f(self):
        pass
register(type(_C().f), _reduce_method)


def _reduce_method_descriptor(m):
    return getattr, (m.__objclass__, m.__name__)
register(type(list.append), _reduce_method_descriptor)
register(type(int.__add__), _reduce_method_descriptor)
</code></pre>
<p>The fix is to put your code into an actual module such that when that is re-initialized on the other side it can import it.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/45719956/python-multiprocessing-attributeerror-cant-get-attribute-abc">python multiprocessing: AttributeError: Can't get attribute "abc"</a></span>
<span class="comment-copy">the sample code works fine on unixlike platforms -- the OP's issue is a windows-specific quirk</span>
<span class="comment-copy">thank you. once i put it into a script file it worked perfectly</span>
