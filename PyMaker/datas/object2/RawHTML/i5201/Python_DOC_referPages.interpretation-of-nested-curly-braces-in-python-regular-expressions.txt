<div class="post-text" itemprop="text">
<p>I ran across this regular expression in a Kaggle kernel and can't figure out what it does:</p>
<pre><code>import re
def substitute_repeats_fixed_len(text, nchars, ntimes=3):
    return re.sub(r"(\S{{{}}})(\1{{{},}})".format(nchars, ntimes-1), 
                  r"\1", text)
</code></pre>
<p>I've been experimenting with it but find it surprisingly difficult to interpret.</p>
<p>"Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it". - Brian Kernighan</p>
</div>
<div class="post-text" itemprop="text">
<p>This is three operators in one, format, regexp match, and regexp replace.to understand it easily, write it as:</p>
<pre><code>import re
def substitute_repeats_fixed_len(text, nchars, ntimes=3):
    regexp = r"(\S{{{}}})(\1{{{},}})".format(nchars, ntimes-1)
    print "regexp:", regexp
    match = re.search(regexp, text)
    print "match groups:", match.groups()
    return re.sub(regexp, r"\1", text)
</code></pre>
<p>(this assumes python2; add () around print args if you are on python3)
Now let's try it:</p>
<pre><code>&gt;&gt;&gt; substitute_repeats_fixed_len("XYabcdabcdabcdZ", 4)
regexp: (\S{4})(\1{2,})
match groups: ('abcd', 'abcdabcd')
'XYabcdZ'
</code></pre>
<p>Our regexp has two groups (each in <code>()</code>): first one is "any non-whitespace character, repeated four times. We can see it matched <code>'abcd'</code>. The second group contains back reference: match <code>'\1'</code> (whatever group 1 matched), repeated twice. We see it matched <code>'abcdabcd'</code></p>
<p>Together, this matches <code>abcdabcdabcd</code>, and this is replaced again with <code>'\1'</code> , which is <code>'abcd'</code> as we saw before.</p>
<p>You could ask: but how did group 1 knew to match <code>abcd</code> and not, say, <code>XYab</code>? This is regexp magic for you. The regexp engine will try different matches until it finds the one which can match entire string.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="nofollow noreferrer">That's a <code>str.format</code> thing, not a regex thing.</a></span>
<span class="comment-copy">From <a href="https://docs.python.org/3/library/string.html#formatstrings" rel="nofollow noreferrer">the docs</a>: <code>Format strings contain “replacement fields” surrounded by curly braces {}. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: {{ and }}.</code></span>
<span class="comment-copy">O.k., thanks for pointing that out. Maybe some of the curly braces are intended to be literals, but even if that is so, I still haven't cracked the code. The name of the subroutine suggests that the substitution is supposed to remove repeating strings, and I'm wondering if the nested braces don't somehow allow a flexible definition of the number of repetitions of the pattern that is removed. But that's just a guess. This regular expression is too clever and no code comments are provided to explain what it does.</span>
<span class="comment-copy">Have you tried just printing the string or the resulting regex object?</span>
<span class="comment-copy">Very good suggestion. Thanks for taking time. Do you understand it? What, for instance, is the role of the first of the two \1 conversion characters? The backslash syntax usually shows up in the replacement part of a substitution, but here we find it in the search pattern.</span>
<span class="comment-copy">For example, following your suggestion, I tried this: <code>fmt = r"(\S{{{}}})(\1{{{},}})"</code> which yields <code>'(\\S{1})(\\1{2,})'</code>. That does indeed start to look more like a parseable regular expression. But I still don't understand his use of \1 in the second pair of parentheses.</span>
<span class="comment-copy">greately expanded an answer, should be more clear now.</span>
