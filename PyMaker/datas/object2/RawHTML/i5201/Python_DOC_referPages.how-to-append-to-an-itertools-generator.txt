<div class="post-text" itemprop="text">
<p>Is there a simple way to append an integer to each item in an itertools iterator? If I use <code>itertools.product</code>, I do not receive the expected output. For example: </p>
<pre><code>&gt;&gt;&gt; for i in itertools.product(itertools.combinations(np.arange(4),2),(4,)): 
...   print(i) 
...    
((0, 1), 4)
((0, 2), 4)
((0, 3), 4)
((1, 2), 4)
((1, 3), 4)
((2, 3), 4)
</code></pre>
<p>But I would expect (and I want) is </p>
<pre><code>&gt;&gt;&gt; for i in itertools.product(itertools.combinations(np.arange(4),2),(4,)): 
...   print(i) 
...    
(0, 1, 4)
(0, 2, 4)
(0, 3, 4)
(1, 2, 4)
(1, 3, 4)
(2, 3, 4)
</code></pre>
<p>I know that I can "flatten" the output, but I would rather construct the iterator to produce tuples, not tuples of tuples. </p>
<p>I have many different iterators floating around, and I want to keep the code the same for <code>product</code>s of itertool iterators and plain itertool iterators</p>
</div>
<div class="post-text" itemprop="text">
<p>These two alternatives each produce an iterator. In the first case, the iterator is created by a <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression" rel="nofollow noreferrer">generator expression</a>. In the second, the iterator is created by the use of a <a href="https://docs.python.org/3/reference/expressions.html#yield-expressions" rel="nofollow noreferrer">generator function</a>.</p>
<pre><code>In [9]: for i in (tup + (4,) for tup in itertools.combinations(np.arange(4),2)):
   ...:     print(i)
   ...:     
(0, 1, 4)
(0, 2, 4)
(0, 3, 4)
(1, 2, 4)
(1, 3, 4)
(2, 3, 4)

In [10]: 
</code></pre>
<p>A generator function might be more readable at the call site, especially if the function name describes its behavior.</p>
<pre><code>import itertools
import numpy as np

def adder(it, addend):
    for x in it:
        yield x + addend

for i in adder(itertools.combinations(np.arange(4),2), (4,)):
    print(i)
</code></pre>
</div>
<span class="comment-copy">This might be too simplistic, but what about doing <code>x = list(i); x.append(4)</code> then printing <code>tuple(x)</code> ?</span>
<span class="comment-copy">I have many different iterators floating around, and I want to keep the code the same for <code>product</code>s of itertool iterators and plain itertool iterators.</span>
<span class="comment-copy">You could use <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a>: <code>for i in map(lambda x: x + (4,), combinations(range(4), 2)): print(i)</code>.</span>
<span class="comment-copy">Yes, <code>(tup + (4,) for tup in itertools.combinations(np.arange(4),2))</code> does produce a generator! Thank you</span>
<span class="comment-copy">Also see the perhaps more readable alternative I've posted.</span>
