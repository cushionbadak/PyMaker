<div class="post-text" itemprop="text">
<p>I have a Python script that is to be placed on a remote vendor server, which then will be run, importing a module (that isn't available to me locally).</p>
<pre><code>from onlyonremoteserver.remoteaccessonly import CustomRemoteClass


sensor = CustomRemoteClass()
    sensor.add_channel(channel_name="Status",unit="Count",value=status,is_limit_mode=True,limit_max_error=1.5,limit_max_warning=0.5)
    sensor.add_channel(channel_name="Number Of Data Nodes",unit="Count",value=output['number_of_data_nodes'])
    sensor.add_channel(channel_name="Number of Nodes",unit="Count",value=output['number_of_nodes'])
</code></pre>
<p>How am I able to mock a class I don't have access to? Is it possible to stub the known class name, add_channel func (and its params)</p>
<p>I was also thinking is this even the write approach, maybe I just write different running cases, and skip this section entirely if executing remotely. </p>
</div>
<div class="post-text" itemprop="text">
<p>Try to patch your module. Have you seen <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch</a>?</p>
</div>
<div class="post-text" itemprop="text">
<p>YES! <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer" title="unittest">unittest has mocking built in</a>.  </p>
<p>Using unit tests to develop your code is the way to go.<br/>
If you make your code do case statements or try/catch blocks to see if you're in the test environment vs deployment, you're going to get slammed by your customer.  Or, hopefully you will.  So, use their API to create a mocked class, and unittest will allow you utilize that mocked class without having to put those awful try/catch blocks in your import statements.</p>
</div>
