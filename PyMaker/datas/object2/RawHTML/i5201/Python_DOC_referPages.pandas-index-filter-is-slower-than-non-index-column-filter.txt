<div class="post-text" itemprop="text">
<p>I timed two Pandas queries with the hope of achieving much higher speeds with a index. However, the opposite happened. Can someone explain why that is? or whether something I am doing is wrong? My understanding was, a Pandas index works as a hash table and look ups would happen in constant time. As far as row filtering is concerned, I believe it is a sequential filtering where each time a filter is applied, all the rows in the data frame is scanned.</p>
<p>The data set has about 8 million rows and 7 columns. I am trying to filter by a combination of string values in a column in which the data is not unique.</p>
<pre><code>In [1]: import pandas as pd

In [2]: df = pd.read_csv("/path/to/file", header=None, sep='\t', usecols=[0,1,2,3,5,6,7], names=['A', 'B', 'C', 'D', 'E', 'F', 'G'])

In [3]: %timeit -n10 df[df['B'].isin(['S1', 'S2'])]
10 loops, best of 3: 145 ms per loop

In [4]: df.dtypes
Out[4]: 
A       object
B      object
C      int64
D      int64
E      float64
F      float64
G     object
dtype: object

In [5]: df.shape
Out[5]: (8468828, 7)
</code></pre>
<p>After indexing:</p>
<pre><code>In [4]: df2 = pd.read_csv("/path/to/file", header=None, sep='\t', usecols=[0,1,2,3,5,6,7], names=['A', 'B', 'C', 'D', 'E', 'F', 'G'])

In [5]: df2.set_index('B', inplace=True)

In [6]: %timeit -n10 df2.loc[['S1', 'S2']]
10 loops, best of 3: 302 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>.loc</code> is implemented in Python so it's slow.</p>
<p>The first way does two things:</p>
<ol>
<li>Compute <code>.isin</code>. Here's <a href="https://github.com/pandas-dev/pandas/blob/461221dd58d7fa7fcc247a7eec0e409309e82394/pandas/core/algorithms.py#L411" rel="nofollow noreferrer">a link to the path</a> that your code is taking. It relies on the <code>hashtable</code> module which is written in cython (and runs at near <code>c</code> speeds).</li>
<li>Once you've computed a mask, applying it is mostly done with <code>numpy</code> which again means <code>c</code> speeds.</li>
</ol>
<p>The moral of the story is that sticking in <code>c</code>/<code>cython</code> land is faster than operating in <code>Python</code> land.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/16629125/9209546">@HYRY's explanation</a> on how indices are treated in <code>pandas</code> is informative:</p>
<blockquote>
<p>When index is unique, pandas use a hashtable to map key to value O(1).
  When index is non-unique and sorted, pandas use binary search O(log <em>N</em>),
  when index is random ordered pandas need to check all the keys in the
  index O(<em>N</em>).</p>
</blockquote>
</div>
<span class="comment-copy">Does <code>df['B']</code> have repeated values, or are they unique?</span>
<span class="comment-copy">They are not unique. Updated the question.</span>
<span class="comment-copy">Hi Thanks. I am finding it hard to understand why Pandas indexes exist if they are less efficient than the numpy/cython based column filtering. Is there some other way to get better performance using indexes?</span>
<span class="comment-copy">Because they are super convenient. Check out <a href="https://pandas.pydata.org/pandas-docs/stable/indexing.html" rel="nofollow noreferrer">the docs on indexing</a> to get a feel for what you can do with an <code>Index</code>. Secondly, better performance is always machine/dataset specific. I'd recommend profiling your code and then go after bottlenecks. There are line profilers (e.g. <a href="https://github.com/rkern/line_profiler" rel="nofollow noreferrer">kernprof</a>) and function profilers (e.g. Python's <a href="https://docs.python.org/3/library/profile.html#module-profile" rel="nofollow noreferrer">profile module</a>) that make this pretty straightforward.</span>
<span class="comment-copy">Thanks. I checked with a sorted index as well. In fact, it was slower than the unsorted one. I was also shooting for a O(log N) speed. But, repeatedly got better results with a sequential column filtration (I think as @Alex pointed out, due to the cython speeds)</span>
