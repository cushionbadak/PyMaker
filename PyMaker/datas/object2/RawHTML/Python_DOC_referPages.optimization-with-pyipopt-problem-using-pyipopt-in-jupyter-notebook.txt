<div class="post-text" itemprop="text">
<p>I am going to make a script that optimizes the position of tidal turbines in a stream. To do this i will find the position that maximise the drag on the turbine. </p>
<p>I am planning to use ipopt to do this optimization of the position. I am currently learning how to use ipopt and this is where I am now facing problems. </p>
<p>I am using jupyter notebook the problem I am facing is that when calling nlp.solve(obj_poss) then,</p>
<p>1.) The solve() function does not print out information about whats happening inside as it is supposed to happend see: <a href="https://www.coin-or.org/Ipopt/documentation/node36.html" rel="nofollow noreferrer">https://www.coin-or.org/Ipopt/documentation/node36.html</a></p>
<p>2.) When there are errors in the arguments sent to solve() it does not print out why there is an error. Example try change low_var to low_var = np.array([0.5, 0.5 , 0.5, 0.5]).</p>
<p>Explanation to the code: The code tries to minimize the function eval_Psum. Under the constraint of the function eval_g_func.</p>
<pre><code>from dolfin import * # Only here to give pyipopt the correct petsc_comm_world
import numpy as np
import pyipopt
import sympy
from pdb import set_trace



def eval_Psum(pos_vec):
    # This function takes in a vector with possitions and calculates the square sum of its
    # coordinates. the vector is aranged as [x1, y1, x2, y2,...]
    sq_sum = 0
    for i in range(len(pos_vec)):
        sq_sum = sq_sum + pos_vec[i]**2
    return sq_sum

def eval_dPsum(pos_vec):
    return np.array([2*pos_vec[0], 2*pos_vec[1], 2*pos_vec[2], 2*pos_vec[3]])

def eval_g_func(pos):
    num_obj = 2
    x = list(sympy.symbols("x0:%d" % num_obj))
    y = list(sympy.symbols("y0:%d" % num_obj))


    g, z = [], []
    for i in range(num_obj):
        z.append(x[i])
        z.append(y[i])
        for j in range(i+1, num_obj):
            xi, yi = x[i], y[i]
            xj, yj = x[j], y[j]
            int_radius = 10**-5
            # FIXME: Max_int_radius should change with each cable radius
            g.append(int_radius**2 - (xi - xj)**2 - (yi - yj)**2)


    g = sympy.Matrix(g)
    z = sympy.Matrix(z)
    print("symbolic g ", g)

    eval_g = g.subs([(z[i], pos[i]) for i in range(2*num_obj)]) 
    return np.array(eval_g).astype(float)



def eval_jac_g_func(pos, flag):
    if flag:
        nvar = len(pos)
        nobj = int(nvar/2)
        ncon = int(nobj + nobj*(nobj-1)/2)
        rows = []
        for i in range(ncon):
            rows += [i]*nvar
        cols = list(range(nvar))*ncon
        return (np.array(rows), np.array(cols))
    else:

        num_obj = 2
        x = list(sympy.symbols("x0:%d" % num_obj))
        y = list(sympy.symbols("y0:%d" % num_obj))

        g, z = [], []
        for i in range(num_obj):
            z.append(x[i])
            z.append(y[i])
            for j in range(i+1,num_obj):
                xi, yi = x[i], y[i]
                xj, yj = x[j], y[j]
                int_radius = 10**-5
                # FIXME: Max_int_radius should change with each cable radius
                g.append(int_radius**2 - (xi - xj)**2 - (yi - yj)**2)


        g = sympy.Matrix(g)
        z = sympy.Matrix(z)


        jac_g = g.jacobian(z) # Create jacobian of the constraints
        print("symbolic jac_g ", jac_g)

        eval_jac_g = jac_g.subs([(z[i], pos[i]) for i in range(2*num_obj)]) 
        eval_jac_g = np.array(eval_jac_g).astype(float)
        return eval_jac_g





obj_poss = np.array([0.9, 0.9, 0.8, 0.8])
print(eval_jac_g_func(obj_poss, False ) )


nvar = 4 # number of variables x1 x2 x3 x4
low_var = np.array([0, 0,0, 0]) # lower constraint on variables
#low_var = np.array([0.5, 0.5, 0.5, 0.5]) # Uncheck this to see what happends
up_var = np.array([1, 1, 1, 1]) # upper constraint on variables
ncon = 1 # Later we add constraints that turbines cannot overlap # number of constraining equations = 1 namely g 
gl =  - np.inf*np.ones(ncon, dtype=float) # lower constraint value on the constraint function g
gu = np.zeros(ncon, dtype=float) # upper constraint value on the constraint function g
num_non_zero_j = 0 # Number of non zero terms in jacobian
num_non_zero_H = 0 # Number of non zero terms in Hessian


nlp = pyipopt.create(nvar,      # Number of controls
                                  low_var,  # Lower bounds for Control
                                  up_var,   # Upper bounds for Control
                                  ncon,      # Number of constraints
                                  gl,  # Lower bounds for contraints
                                  gu,   # Upper bounds for contraints
                                  nvar*ncon, # Number of nonzeros in cons. Jac
                                  0,         # Number of nonzeros in cons. Hes
                                  lambda x: eval_Psum(x),  # Objective eval
                                  lambda x: eval_dPsum(x), # Obj. grad eval
                                  eval_g_func,    # Constraint evaluation
                                  eval_jac_g_func # Constraint Jacobian evaluation

                         )

obj_poss = np.array([0.9, 0.9, 0.8, 0.8])
nlp.int_option("print_level",12)


solution = nlp.solve(obj_poss)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Tried a quick replication, but can't find the right pyipopt for my environment. If they're using logger to output messages, you may need to initialize a logger at "DEBUG" level to get everything written to the Jupyter console, like:</p>
<pre><code>import logging
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
</code></pre>
</div>
