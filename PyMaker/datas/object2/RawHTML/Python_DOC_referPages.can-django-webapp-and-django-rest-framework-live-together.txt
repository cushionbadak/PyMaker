<div class="post-text" itemprop="text">
<p>I have a Django WebApp to administrate certain things of my business. It's currently using Django 1.5.5, but I just migrated the code to Django 1.11. </p>
<p>The thing is that we are developing another apps using other technologies, and due to all my information is in the Django app, I decided to add Django Rest Framework to my existing Django Webapp. All ok so far, beautiful, API with Token access... happy...</p>
<p>But, then I realized that on PROD env, I've ALLOWED_HOST setting. :(. I added that line in my devbox, and the happiness end. </p>
<p>I tried adding CORS support using django-cors-headers, but, so far, I've not successful. </p>
<p>So, to avoid wasting time, I want to ask to people that knows more than me about it, if the Django App and the DRF API can live together, without removing the ALLOWED_HOST setting or setting it as ALLOWED_HOSTS = ['*'].</p>
<p>Thanks in advance! </p>
<p><strong>UPDATE</strong></p>
<p>My settings.py file looks like this:</p>
<pre><code># Django settings for dojosite project.
# -*- coding:  utf-8 -*-
import os
import datetime

DEBUG = True

ALLOWED_HOSTS = ['www.myapp.com']

...

MIDDLEWARE_CLASSES = (
    'corsheaders.middleware.CorsMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.locale.LocaleMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware'
)



TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [(os.path.join(ROOT_PATH, 'templates'),)],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.static',
                'django.template.context_processors.tz',
                'django.contrib.messages.context_processors.messages',
                'django.template.context_processors.media',
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.template.context_processors.i18n',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    'django.contrib.admin',
    'django.contrib.humanize',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'rest_framework',
    'rest_framework.authtoken',
    'corsheaders',
    'myapp',
)

...

SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'

REST_FRAMEWORK = {
    # Use Django's standard `django.contrib.auth` permissions,
    # or allow read-only access for unauthenticated users.
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.DjangoModelPermissions',
    ]
}


# JWT settings
JWT_AUTH = {
    'JWT_ENCODE_HANDLER':
    'rest_framework_jwt.utils.jwt_encode_handler',

    'JWT_DECODE_HANDLER':
    'rest_framework_jwt.utils.jwt_decode_handler',

    'JWT_PAYLOAD_HANDLER':
    'rest_framework_jwt.utils.jwt_payload_handler',

    'JWT_PAYLOAD_GET_USER_ID_HANDLER':
    'rest_framework_jwt.utils.jwt_get_user_id_from_payload_handler',

    'JWT_RESPONSE_PAYLOAD_HANDLER':
    'rest_framework_jwt.utils.jwt_response_payload_handler',

    'JWT_SECRET_KEY': SECRET_KEY,
    'JWT_GET_USER_SECRET_KEY': None,
    'JWT_PUBLIC_KEY': None,
    'JWT_PRIVATE_KEY': None,
    'JWT_ALGORITHM': 'HS256',
    'JWT_VERIFY': True,
    'JWT_VERIFY_EXPIRATION': True,
    'JWT_LEEWAY': 0,
    'JWT_EXPIRATION_DELTA': datetime.timedelta(seconds=300),
    'JWT_AUDIENCE': None,
    'JWT_ISSUER': None,

    'JWT_ALLOW_REFRESH': False,
    'JWT_REFRESH_EXPIRATION_DELTA': datetime.timedelta(days=7),

    'JWT_AUTH_HEADER_PREFIX': 'Bearer',
    'JWT_AUTH_COOKIE': None,
}

CORS_ORIGIN_ALLOW_ALL = True
CORS_ALLOW_CREDENTIALS = False
</code></pre>
<p>That configuration is causing that ALLOWED_HOSTS is applied to the WebApp urls and also to the API URLs.</p>
<p><strong>UPDATE 2</strong></p>
<p>Something I didn't say, is that I want that API public. I mean, let's suppose that I didn't know which hosts will invoke my API. So, what I want to do is:</p>
<p><strong>WebApp:</strong> should be just called from known hosts (ALLOWED_HOSTS should be applied)</p>
<p><strong>API:</strong> can be called from unknown hosts (ALLOWED_HOSTS control should not be applied here).</p>
<p>Is this possible? How can I achieve this?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes you can use Django Rest Framework with your Django webapp with no problem at all. Moving to cors part you should first install <code>pip install django-cors-headers
</code> then add corsheaders to installed apps </p>
<pre><code>INSTALLED_APPS = (
    ...
    'corsheaders',
    ...
)
</code></pre>
<p>Add middleware properly in <code>settings.py</code></p>
<pre><code>MIDDLEWARE = [  # Or MIDDLEWARE_CLASSES on Django &lt; 1.10
    ...
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    ... ]
</code></pre>
<p>lastly you should do in <code>settings.py</code> as you are allowing every host</p>
<p><code>CORS_ORIGIN_ALLOW_ALL = True</code></p>
<p>else make the whitelist</p>
<pre><code>CORS_ORIGIN_WHITELIST = (
    'hostname.example.com',
    'localhost:8000',
    '127.0.0.1:9000'
)
</code></pre>
</div>
<span class="comment-copy">Hello @Yugandhar Chaudhari ,  I just have my project set in that way. I tried to access the webapp, localhost:8000, and I got the appropriate error. The thing is that using POSTMAN to hit my login endpoint, I'l also getting the 400 error, with the same message: <b>Invalid HTTP_HOST header: 'localhost:8000'. You may need to add u'localhost' to ALLOWED_HOSTS.</b></span>
<span class="comment-copy">Not getting the issue here... if you're running the server on localhost (or if you're running the server with a public hostname BUT also having stuff access it via localhost (because e.g. you have internal requests), you'll need to add localhost to ALLOWED_HOSTS like it says)</span>
<span class="comment-copy">Thanks @Foon ... please check my <b>UPDATE 2</b>. Probably, I'm trying to do something that is not possible to do</span>
<span class="comment-copy">I <i>think</i> you're misunderstanding what allowed_hosts does.  It controls the allowed hostname for the HTTP request, not which hosts are allowed to act as clients making requests to the API.  I think you are correct (minus running your web app and API on different applications and throwing a reverse proxy in front of them to make it looks like the same server) that you can't configure Django so requests to /api don't use the ALLOWED_HOSTS check , but I also don't think this is what you want</span>
<span class="comment-copy">Hey @Foon... let me explain what's the real use case, and probably you'll understand what I'm trying to do. As I said, my WebApp controls certain stuffs of my business. All the data is there. What we are doing now, is a new app, that will run in a machine (standalone app) that needs to consume the information I'm handling with my Django App to generate some courses certificates. Is for that reason, that I decided to include DRF in my project. The IP from my API can be consume won't be known all the time.</span>
