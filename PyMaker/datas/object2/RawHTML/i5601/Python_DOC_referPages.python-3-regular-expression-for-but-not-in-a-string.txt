<div class="post-text" itemprop="text">
<p>I need to match one of the following anywhere in a string:</p>
<pre><code>${aa:bb[99]}
${aa:bb}
${aa}
</code></pre>
<p>but not:</p>
<pre><code>$${aa:bb[99]}
$${aa:bb}
$${aa}
</code></pre>
<p>my python 3 regex is:</p>
<pre><code>pattern = **r"[^\$|/^]**\$\{(?P&lt;section&gt;[a-zA-Z]+?\:)?(?P&lt;key&gt;[a-zA-Z]+?)(?P&lt;value&gt;\[[0-9]+\])?\}"
</code></pre>
<p>What I'm looking for, is the proper way to say not $ or beginning of a string. The block <code>r"[^\$|/^]"</code> will properly detect all cases but will fail if my string starts at the first character.</p>
<p>I trie, without success: </p>
<pre><code>r"[^\$|\b]... 
r"[^\$|\B]...
r"[^\$]...
r"[^\$|^] 
</code></pre>
<p>Any suggestion?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a negative lookbehind:</p>
<pre><code>(?&lt;!\$)
</code></pre>
<p>and then follow it by the thing you actually want to match. This will ensure that the thing you actually want to match is not preceded by a <code>$</code> (i.e. not preceded by a match for <code>\$</code>):</p>
<pre><code>(?&lt;!\$)\$\{(?P&lt;section&gt;[a-zA-Z]+?\:)?(?P&lt;key&gt;[a-zA-Z]+?)(?P&lt;value&gt;\[[0-9]+\])?\}
     ^  ^
     |  |
     |  +--- The dollar sign you actually want to match
     |
     +--- The possible second preceding dollar sign you want to exclude
</code></pre>
<blockquote>
<p><code>(?&lt;!...)</code></p>
<p>Matches if the current position in the string is not preceded
  by a match for <code>...</code>. This is called a negative lookbehind assertion.
  Similar to positive lookbehind assertions, the contained pattern must
  only match strings of some fixed length and shouldnâ€™t contain group
  references. Patterns which start with negative lookbehind assertions
  may match at the beginning of the string being searched.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/re.html" rel="noreferrer">https://docs.python.org/3/library/re.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a negative lookbehind <code>(?&lt;!\$)</code> to say "not preceded by <code>$</code>":</p>
<pre><code>(?&lt;!\$)\${[^}]*}
</code></pre>
<p>I have simplified the part between the brackets a bit to focus on the "one and only one <code>$</code> part".</p>
<p>Here is a <a href="https://regex101.com/r/ohMGEC/1" rel="nofollow noreferrer">regex101 link</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thank you Amber for the ideas. I followed the same train of thought you suggest using negative look ahead. I tried them all with  <a href="https://regex101.com/r/G2n0cO/1/" rel="nofollow noreferrer">https://regex101.com/r/G2n0cO/1/</a>. The only one that succeed almost perfectly is:</p>
<pre><code>(?:^|[^\$])\${(?:(?P&lt;section&gt;[a-zA-Z0-9\-_]+?)\:)??(?P&lt;key&gt;[a-zA-Z0-9\-_]+?)(?:\[(?P&lt;index&gt;[0-9]+?)\])??\}
</code></pre>
<p>I still had to add a check to remove the last non-dollar character. at the end of the sample below. For history I kept a few of the iterations I made since I posted this question:</p>
<pre><code>    # keep tokens ${[section:][key][\[index\]]}and skip false ones 
    # pattern = r"\$\{((?P&lt;section&gt;.+?)\:)?(?P&lt;key&gt;.+?)(\[(?P&lt;index&gt;\d+?)\])+?\}" 
    # pattern = r'\$\{((?P&lt;section&gt;\S+?)\:)??(?P&lt;key&gt;\S+?)(\[(?P&lt;index&gt;\d+?)\])?\}'
    # pattern = r'\$\{((?P&lt;section&gt;[a-zA-Z0-9\-_]+?)\:)??(?P&lt;key&gt;[a-zA-Z0-9\-_]+?)(\[(?P&lt;index&gt;[0-9]+?)\])??\}'
    pattern = r'(?:^|[^\$])\${(?:(?P&lt;section&gt;[a-zA-Z0-9\-_]+?)\:)??(?P&lt;key&gt;[a-zA-Z0-9\-_]+?)(?:\[(?P&lt;index&gt;[0-9]+?)\])??\}'

    analyser = re.compile(pattern)
    mo = analyser.search(value, 0)
    log.debug(f'got match object: {mo}')
    while not mo is None:
        log.debug(f'in while loop, level={level}')

        if level &gt; MAX_LEVEL:
            raise RecursionError(f"to many recursive call to _substiture_text() while processing '{value}'.")
        else:
            level +=1

        start = mo.start()
        end   = mo.end()
        # re also captured the first non $ sign symbol
        if value[start] != '$': 
            start += 1
</code></pre>
</div>
<span class="comment-copy">Why not explicitly say you expect one dollar sign, as in <code>\${1}</code>?</span>
<span class="comment-copy">@RishatMuhametshin: because that does not work.</span>
<span class="comment-copy"><code>(?&lt;!\$)\$\{(?P&lt;section&gt;[a-z]+)(?::(?P&lt;key&gt;[a-z]+))?(?P&lt;value&gt;\[\d+\])?\}</code></span>
<span class="comment-copy">@RishatMuhametshin you do realize that <code>\${1}</code> is <b>exactly the same</b> as <code>\$</code> right?</span>
<span class="comment-copy">I actually like this answer better than mine because it explains what the negative lookbehind does clearly. For a new user, this can be at least as important as having a working example. +1</span>
