<div class="post-text" itemprop="text">
<p>I am trying to create a simple monitoring system that periodically checks things and logs them. Here is a cutdown example of the logic I am attempting to use but I keep getting a <code>RuntimeWarning: coroutine 'foo' was never awaited</code> error. </p>
<p>How should I reschedule an async method from itself? </p>
<p>Code in test.py:</p>
<pre><code>import asyncio
from datetime import datetime

async def collect_data():
    await asyncio.sleep(1)
    return {"some_data": 1,}

async def foo(loop):
    results = await collect_data()
    # Log the results
    print("{}: {}".format(datetime.now(), results))
    # schedule to run again in X seconds
    loop.call_later(5, foo, loop)

if __name__ == '__main__':

    loop = asyncio.get_event_loop()
    loop.create_task(foo(loop))
    loop.run_forever()
    loop.close()
</code></pre>
<p>Error:</p>
<pre><code>pi@raspberrypi [0] $ python test.py 
2018-01-03 01:59:22.924871: {'some_data': 1}
/usr/lib/python3.5/asyncio/events.py:126: RuntimeWarning: coroutine 'foo' was never awaited
  self._callback(*self._args)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>call_later</code> <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.call_later" rel="nofollow noreferrer">accepts</a> a plain sync callback (a function defined with <code>def</code>). A coroutine function (<code>async def</code>) should be awaited to be executed.</p>
<hr/>
<p>The cool thing about <code>asyncio</code> is that it imitates imperative plain synchronous code in many ways. How would you solve this task for a plain function? I guess just sleep some time and recursively call function again. Do the same (almost - we should use synchronous sleep) with <code>asyncio</code> also:</p>
<pre><code>import asyncio
from datetime import datetime


async def collect_data():
    await asyncio.sleep(1)
    return {"some_data": 1,}


async def foo(loop):
    results = await collect_data()

    # Log the results
    print("{}: {}".format(datetime.now(), results))

    # Schedule to run again in X seconds
    await asyncio.sleep(5)
    return (await foo(loop))


if __name__ ==  '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(foo(loop))
    finally:
        loop.run_until_complete(loop.shutdown_asyncgens())  # Python 3.6 only
        loop.close()
</code></pre>
<p>If you sometime would need to run <code>foo</code> in the background alongside with other coroutines you <a href="https://stackoverflow.com/a/37345564/1113207">can create a task</a>. There is also shown a way to cancel task execution.</p>
<p><strong>Update:</strong></p>
<p>As Andrew pointed out, a plain loop is even better:</p>
<pre><code>async def foo(loop):
    while True:
        results = await collect_data()

        # Log the results
        print("{}: {}".format(datetime.now(), results))

        # Wait before next iteration:
        await asyncio.sleep(5)
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/37512182/how-can-i-periodically-execute-a-function-with-asyncio">How can I periodically execute a function with asyncio?</a></span>
<span class="comment-copy">A loop instead of recursive call is even better.</span>
