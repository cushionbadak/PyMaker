<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/19686533/how-to-zip-two-differently-sized-lists">How to zip two differently sized lists?</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<p>If I have two iterables of different lengths, how can I most cleanly pair them, re-using values from the shorter one until all values from the longer are consumed?</p>
<p>For example, given two lists</p>
<pre><code>l1 = ['a', 'b', 'c']
l2 = ['x', 'y']
</code></pre>
<p>It would be desirable to have a function <code>fn()</code> resulting in pairs: </p>
<pre><code>&gt;&gt;&gt; fn(l1, l2)
[('a', 'x'), ('b', 'y'), ('c', 'x')]
</code></pre>
<p>I found I could write a function to perform this as such</p>
<pre><code>def fn(l1, l2):
    if len(l1) &gt; len(l2):
        return [(v, l2[i % len(l2)]) for i, v in enumerate(l1)]
    return [(l1[i % len(l1)], v) for i, v in enumerate(l2)]

&gt;&gt;&gt; fn(l1, l2)
[('a', 'x'), ('b', 'y'), ('c', 'x')]
&gt;&gt;&gt; l2 = ['x', 'y', 'z', 'w']
&gt;&gt;&gt; fn(l1,l2)
[('a', 'x'), ('b', 'y'), ('c', 'z'), ('a', 'w')]
</code></pre>
<p>However, I'm greedy and was curious <strong>what other methods exist?</strong> so that I may select the most obvious and elegant and be wary of others.</p>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a> as suggested in many similar questions is very close to my desired use case as it has a <code>fillvalue</code> argument which will pad the longer pairs. However, this only takes a single value, instead of wrapping back to the first value in the shorter list.</p>
<p>As a note: in my use case one list will always be much shorter than the other and this may allow a short-cut, but a generic solution would be exciting too!</p>
</div>
<div class="post-text" itemprop="text">
<p>You may use <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle()</code></a> with <a href="https://docs.python.org/3.3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> to get the desired behavior. </p>
<p>As the <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><strong><code>itertools.cycle()</code></strong></a> document says, it:</p>
<blockquote>
<p>Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. </p>
</blockquote>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; l1 = ['a', 'b', 'c']
&gt;&gt;&gt; l2 = ['x', 'y']

&gt;&gt;&gt; from itertools import cycle
&gt;&gt;&gt; zip(l1, cycle(l2))
[('a', 'x'), ('b', 'y'), ('c', 'x')]
</code></pre>
<p>Since in your case, length of <code>l1</code> and <code>l2</code> could vary, your generic <code>fn()</code> should be like:</p>
<pre><code>from itertools import cycle

def fn(l1, l2):
    return zip(l1, cycle(l2)) if len(l1) &gt; len(l2) else zip(cycle(l1), l2)
</code></pre>
<p>Sample Run:</p>
<pre><code>&gt;&gt;&gt; l1 = ['a', 'b', 'c']
&gt;&gt;&gt; l2 = ['x', 'y']

# when second parameter is shorter 
&gt;&gt;&gt; fn(l1, l2)
[('a', 'x'), ('b', 'y'), ('c', 'x')]

# when first parameter is shorter
&gt;&gt;&gt; fn(l2, l1)
[('x', 'a'), ('y', 'b'), ('x', 'c')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're not sure which one is the shortest, <code>next</code> <code>it.cycle</code> the longest <code>len</code> of the two lists:</p>
<pre><code>def fn(l1, l2):
    return (next(zip(itertools.cycle(l1), itertoools.cycle(l2))) for _ in range(max((len(l1), len(l2)))))

&gt;&gt;&gt; list(fn(l1, l2))

[('a', 'x'), ('a', 'x'), ('a', 'x')]
</code></pre>
<p><code>itertools.cycle</code> will repeat the list infinitely. Then, <code>zip</code> the two infinite lists together to get the cycle that you want, but repeated infinitely. So now, we need to trim it to the right size. <code>max((len(l1), len(l2)))</code> will find the longest length of the two lists, then <code>next</code> the infinite iterable until you get to the right length. Note that this returns a generator, so to get the output you want use <code>list</code> to eat the function.</p>
</div>
<span class="comment-copy">just added <code>[*zip(A*(len(B)//len(A) + 1), B*(len(A)//len(B) + 1))]</code> to <a href="https://stackoverflow.com/questions/19686533/how-to-zip-two-differently-sized-lists">how-to-zip-two-differently-sized-lists</a></span>
<span class="comment-copy">@rassar I was on my way to write that :)</span>
