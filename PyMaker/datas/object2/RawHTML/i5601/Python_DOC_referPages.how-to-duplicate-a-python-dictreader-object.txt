<div class="post-text" itemprop="text">
<p>I'm currently trying to modify a <code>DictReader</code> object to strip all the spaces for every cell in the csv. I have this function:</p>
<pre><code>def read_the_csv(input_file):
    csv_reader = csv.DictReader(input_file)
    for row in csv_reader:
        for key, value in row.items():
            value.strip()

    return csv_reader
</code></pre>
<p>However, the issue with this function is that the reader that is returned has already been iterated through, so I can't re-iterate through it (as I would be able to if I just called <code>csv.DictReader(input_file)</code>. I want to be able to create a new object that is exactly like the <code>DictReader</code> (i.e., has the fieldnames attribute too), but with all fields stripped of white space. Any tips on how I can accomplish this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Two things: firstly, the reader is a lazy iterator object which is exhausted after one full run (meaning it will be empty once you return it at the end of your function!), so you  have to either collect the modified rows in a list and return that list in the end or make the <a href="https://wiki.python.org/moin/Generators" rel="nofollow noreferrer">function a generator</a> producing the modified rows. Secondly, <a href="https://docs.python.org/3/library/stdtypes.html#str.strip" rel="nofollow noreferrer"><code>str.strip()</code></a> does not modify strings in-place (strings are immutable), but returns a new stripped string, so you have to rebind that new value to the old key:</p>
<pre><code>def read_the_csv(input_file):
    csv_reader = csv.DictReader(input_file)
    for row in csv_reader:
        for key, value in row.items():
            row[key] = value.strip()  # reassign
        yield row
</code></pre>
<p>Now you can use that generator function like you did the <code>DictReader</code>:</p>
<pre><code>reader = read_the_csv(input_file)
for row in reader:
    # process data which is already stripped
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I prefer using inheritance, make a subclass of DictReader as follows:</p>
<pre><code>from csv import DictReader
from collections import OrderedDict


class MyDictReader(DictReader):
    def __next__(self):
        return OrderedDict({k: v.strip()
                            for k, v in super().__next__().items()})
</code></pre>
<p>Usage, just as DictReader:</p>
<pre><code>with open('../data/risk_level_model_5.csv') as input_file:
    for row in MyDictReader(input_file):
        print(row)
</code></pre>
</div>
<span class="comment-copy">Thanks, this is very helpful. The one issue with this approach is I lose the "fieldnames" property of the csv_reader when I use the generator function like this. When I try to access <code>reader.fieldnames</code>, I get the error <code>AttributeError: 'generator' object has no attribute 'fieldnames'</code></span>
<span class="comment-copy">That will not just not strip any tabs, newline or other non-<code>' '</code> whitespace, but it will also remove any spaces from inside the column values which is surely not the desired bahaviour.</span>
<span class="comment-copy">I just show the basic idea, U can do whatever you want to modify the value. Already changed the method to strip() if you mind.</span>
<span class="comment-copy">Also, an <code>OrderedDict</code> is pointless if it is created by passing its constructor an unordered common <code>dict</code>. You should rather pass it a list of pairs (tuples).</span>
<span class="comment-copy">Sorry, cannot agree with you at this point, I checked the result of the super().__next__(), it's an OrderedDict, and I just make some modification on it, trying to make minimum changes to the base class.</span>
<span class="comment-copy">Of course, it is an <code>OrderedDict</code>, but if its order is not guaranteed to be the same as in the original row, its purpose is defeated. In Python3, normal dicts maintain insertion order, but that should not be relied upon as it is more of a implementational side effect. The dict comprehension you use can already scramble the order, so why not pass a list (generator) of tuples. Then, this is a nice approach!</span>
