<div class="post-text" itemprop="text">
<p>Can someone please explain the groupby operation and the lambda function being used on <a href="https://stackoverflow.com/questions/15646148/fast-method-in-python-to-split-a-large-text-file-using-number-of-lines-as-input">this</a> SO post? </p>
<p><code>key=lambda k, line=count(): next(line) // chunk</code></p>
<pre><code>import tempfile
from itertools import groupby, count

temp_dir = tempfile.mkdtemp()

def tempfile_split(filename, temp_dir, chunk=4000000):
    with open(filename, 'r') as datafile:

    # The itertools.groupby() function takes a sequence and a key function,
    # and returns an iterator that generates pairs.

    # Each pair contains the result of key_function(each item) and
    # another iterator containing all the items that shared that key result.

        groups = groupby(datafile, key=lambda k, line=count(): next(line) // chunk)
        for k, group in groups:

            print(key, list(group))

            output_name = os.path.normpath(os.path.join(temp_dir + os.sep, "tempfile_%s.tmp" % k))
            for line in group:
                with open(output_name, 'a') as outfile:
                    outfile.write(line)
</code></pre>
<p><strong>Edit:</strong> It took me a while to wrap my head around the lambda function used with groupby. I don't think I understood either of them very well. </p>
<p>Martijn explained it really well, however I have a follow up question. Why is <code>line=count()</code> passed as an argument to the lambda function every time? I tried assigning the variable <code>line</code> to <code>count()</code> just once, outside the function.</p>
<pre><code>    line = count()
    groups = groupby(datafile, key=lambda k, line: next(line) // chunk)
</code></pre>
<p>and it resulted in <code>TypeError: &lt;lambda&gt;() missing 1 required positional argument: 'line'</code></p>
<p>Also, calling <code>next</code> on <code>count()</code> directly within the lambda expression, resulted in all the lines in the input file getting bunched together i.e a single key was generated by the <code>groupby</code> function.</p>
<pre><code>groups = groupby(datafile, key=lambda k: next(count()) // chunk)
</code></pre>
<p>I'm learning Python on my own, so any help or pointers to reference materials /PyCon talks are much appreciated. Anything really!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>itertools.count()</code> is an infinite iterator of increasing integer numbers.</p>
<p>The <code>lambda</code> stores an instance as a keyword argument, so every time the lambda is called the local variable <code>line</code> references that object. <code>next()</code> advances an iterator, retrieving the next value:</p>
<pre><code>&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; line = count()
&gt;&gt;&gt; next(line)
0
&gt;&gt;&gt; next(line)
1
&gt;&gt;&gt; next(line)
2
&gt;&gt;&gt; next(line)
3
</code></pre>
<p>So <code>next(line)</code> retrieves the next count in the sequence, and divides that value by <code>chunk</code> (taking only the integer portion of the division). The <code>k</code> argument is ignored.</p>
<p>Because integer division is used, the result of the <code>lambda</code> is going to be <code>chunk</code> repeats of an increasing integer; if <code>chunk</code> is 3, then you get <code>0</code> three times, then <code>1</code> three times, then <code>2</code> three times, etc:</p>
<pre><code>&gt;&gt;&gt; chunk = 3
&gt;&gt;&gt; l = lambda k, line=count(): next(line) // chunk
&gt;&gt;&gt; [l('ignored') for _ in range(10)]
[0, 0, 0, 1, 1, 1, 2, 2, 2, 3]
&gt;&gt;&gt; chunk = 4
&gt;&gt;&gt; l = lambda k, line=count(): next(line) // chunk
&gt;&gt;&gt; [l('ignored') for _ in range(10)]
[0, 0, 0, 0, 1, 1, 1, 1, 2, 2]
</code></pre>
<p>It is this resulting value that <code>groupby()</code> groups the <code>datafile</code> iterable by, producing groups of <code>chunk</code> lines.</p>
<p>When looping over the <code>groupby()</code> results with <code>for k, group in groups:</code>, <code>k</code> is the number that the <code>lambda</code> produced and the results are grouped by; the <code>for</code> loop in the code ignores this. <code>group</code> is an iterable of lines from <code>datafile</code>, and will always contain <code>chunk</code> lines.</p>
</div>
<div class="post-text" itemprop="text">
<p>In response to the updated OP...</p>
<p>The <code>itertools.groupby</code> iterator offers ways to group items together, giving more control when a key function is defined.  See more on <a href="https://stackoverflow.com/a/45873519/4531270">how <code>itertools.groupby()</code> works</a>.</p>
<p>The <code>lambda</code> function, is a functional, shorthand way of writing a regular function.  For example:</p>
<pre><code>&gt;&gt;&gt; keyfunc = lambda k, line=count(): next(line)
</code></pre>
<p>Is equivalent to this regular function:</p>
<pre><code>&gt;&gt;&gt; def keyfunc(k, line=count()):
...     return next(line) // chunk
</code></pre>
<p><em>Keywords</em>: iterator, functional programming, anonymous functions</p>
<hr/>
<p><strong>Details</strong></p>
<blockquote>
<p>Why is <code>line=count()</code> passed as an argument to the lambda function every time?</p>
</blockquote>
<p>The reason is the same for normal functions.  The <code>line</code> parameter by itself is a <em>positional argument</em>.  When a value is assigned, it becomes a default <em>keyword argument</em>.  See more on <a href="https://stackoverflow.com/questions/9450656/positional-argument-v-s-keyword-argument">positional vs. keyword arguments</a>.</p>
<p>You can still define <code>line=count()</code> outside the function by assigning the result to a keyword argument:</p>
<pre><code>&gt;&gt;&gt; chunk = 3
&gt;&gt;&gt; line=count()
&gt;&gt;&gt; keyfunc = lambda k, line=line: next(line) // chunk       # make `line` a keyword arg
&gt;&gt;&gt; [keyfunc("") for _ in range(10)]
[0, 0, 0, 1, 1, 1, 2, 2, 2, 3]
&gt;&gt;&gt; [keyfunc("") for _ in range(10)]
[3, 3, 4, 4, 4, 5, 5, 5, 6, 6]                               # note `count()` continues
</code></pre>
<blockquote>
<p>... calling next on <code>count()</code> directly within the lambda expression, resulted in all the lines in the input file getting bunched together i.e a single key was generated by the <code>groupby</code> function ...</p>
</blockquote>
<p>Try the following experiment with <code>count()</code>:</p>
<pre><code>&gt;&gt;&gt; numbers = count()
&gt;&gt;&gt; next(numbers)
0
&gt;&gt;&gt; next(numbers)
1
&gt;&gt;&gt; next(numbers)
2
</code></pre>
<p>As expected, you will notice <code>next()</code> is yielding the next item from the <code>count()</code> iterator.  (A similar function is called iterating an iterator with a <code>for</code> loop).  What is unique here is that generators do not reset - <code>next()</code> simply gives the next item in the line (as seen in the former example).  </p>
<p>@Martijn Pieters pointed out <code>next(line) // chunk</code> computes a floored integer that is used by <code>groupby</code> to identify each line (bunching similar lines with similar ids together), which is also expected.  See the references for more on how <code>groupby</code> works.</p>
<p><em>References</em> </p>
<ul>
<li><a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer">Docs for <code>itertools.count</code></a></li>
<li><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">Docs for <code>itertools.groupby()</code></a></li>
<li>Beazley, D. and Jones, B.  "7.7 Capturing Variables in Anonymous Functions," Python Cookbook, 3rd ed. O'Reilly. 2013.</li>
</ul>
</div>
<span class="comment-copy">Thank You. Appreciate your help!</span>
<span class="comment-copy">Thank you so much for the clarification!</span>
