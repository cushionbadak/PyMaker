<div class="post-text" itemprop="text">
<p>A left rotation operation on an array of size  shifts each of the array's elements  1 unit to the left. For example, if 2 left rotations are performed on array [1,2,3,4,5] , then the array would become [3,4,5,1,2].</p>
<p>Given an array of  integers and a number, , perform  left rotations on the array. Then print the updated array as a single line of space-separated integers.</p>
<p>Sample Input: 
5, 4<br/>
1 2 3 4 5
Sample Output: 5 1 2 3 4
My output is: 2 2 3 4 1</p>
<pre><code>#!/bin/python3

    import sys

    def leftRotation(a, d):
        #Main Logic here
        length=len(a)
        for j in range(0,d):
            for i in range(0,length):
                temp=a[0]
                a[i]=a[i+1]
                a[length-1]=temp
                return a
            return a
        return a



    if __name__ == "__main__":
        n, d = input().strip().split(' ')
        n, d = [int(n), int(d)]
        a = list(map(int, input().strip().split(' ')))
        result = leftRotation(a, d)
        print (" ".join(map(str, result)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>1) Return will halt execution of the code, so the code will only loop once before returning.</p>
<p>2) These lines contain the error in logic:</p>
<pre><code>temp=a[0]
a[i]=a[i+1]
a[length-1]=temp
</code></pre>
<p>To do a left rotation we insert the last value in the first position. Your problem is that you are assigning <code>temp = a[0]</code> inside the loop, rather than outside. You are also reassigning the last value inside the loop.</p>
<p>All of the errors fixed:</p>
<pre><code>def leftRotation(a, d):
    #Main Logic here
    length=len(a)
    for j in range(0,d):
        temp=a[0]
        for i in range(0,length - 1):
            a[i]=a[i+1]
        a[length-1]=temp
    return a
</code></pre>
<p>gives you the correct answer.</p>
<p>(P.S. There is a much easier way to left-rotate using standard <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer">list</a> methods: <code>a.append(a.pop(0))</code>.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Rassar already covered what are the problems with the code, I just want to add nicer solution using <code>list</code> methods mentioned in the answer:</p>
<pre><code>def left_rotation(l, offset):
    offset %= len(l)
    return l[offset:] + l[:offset]

result = left_rotation([1, 2, 3, 4, 5], 12)
print(" ".join(str(item) for item in result))  # 3 4 5 1 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>SInce others have pointed out the issues in your code, you could also try this solution using <a href="https://docs.python.org/2/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a>:</p>
<pre><code>from collections import deque

def left_rotation(lst, n):
    queue = deque(lst)

    removed = [queue.popleft() for i in range(n)]

    return list(queue) + removed

print(" ".join(map(str, left_rotation([1,2,3,4,5], 2))))
</code></pre>
<p>Which Outputs:</p>
<pre><code>3 4 5 1 2
</code></pre>
<p><strong>Note:</strong> <code>popleft()</code> is <code>O(1)</code> here, which is more efficient that <code>pop(0)</code>, which is <code>O(n)</code> instead. </p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>First of all your program is not running for whole(0,d), its ending in first iteration and left rotation is not completed so your 1st and 2nd element have same values</p>
<pre><code>def leftRotation(a, d):   
    #Main Logic here   
    length=len(a)   

    for j in range(0,d):   
        temp=a[0]
        for i in range(0,length):  
        a[i]=a[i+1]   # a[i](i == 0) &amp; a[i+1](i == 1) will have same values
        a[length-1]=temp
        return a    #Because your  program is ending here
</code></pre></li>
<li><p>Even if your code runs for whole iteration you will get <code>IndexError</code> since 
you are running loop (0, length), when your i = length-1 =&gt; i+1 = length &amp; in a list we only index "zero" to "length-1" in a list</p></li>
</ol>
<p>Now after fixing both the issues, this might work:-</p>
<pre><code>def leftRotation(a, d):
    #Main Logic here
    length=len(a)
    for j in range(0,d):
        temp=a[0]
        for i in range(0,length-1):  
            a[i]=a[i+1]

        a[length-1]=temp

    return a
</code></pre>
<p>A much better answer using list slicing:-.   </p>
<pre><code>function rotate_list(a,d):   
     return a[d:] + a[d:]
</code></pre>
</div>
<span class="comment-copy">what errors/output are you getting?</span>
<span class="comment-copy">I need to make sure you are really trying to understand the problem, not just getting a quick fix.</span>
<span class="comment-copy">Why do you have three <code>return</code> statements?</span>
<span class="comment-copy">I suggest that you take a step back and get a piece of paper and pencil. Then describe <b>in words</b> the steps that you need to take to solve this problem. Don't worry overly much about the python syntax. Just work on clarifying in your mind what you need to do.</span>
<span class="comment-copy">I'm voting to close this question as off-topic because I think the OP is violating the terms from <a href="https://app.codility.com/terms-of-service-for-programmers/" rel="nofollow noreferrer">app.codility.com/terms-of-service-for-programmers</a> - he is supposed to solve the problem on his own and must not disclose the test content outside the site.</span>
<span class="comment-copy">Congratulations, this is a O(1) solution, but I suspect OP is cheating a test from <a href="https://app.codility.com/programmers/" rel="nofollow noreferrer">app.codility.com/programmers</a></span>
<span class="comment-copy">@PauloScardine Isn't slicing <code>O(k)</code> for a list? Where <code>k</code> is the length of the slice. I feel that <code>O(k)</code> and <code>O(1)</code> are different here, unless <code>k=1</code>.</span>
<span class="comment-copy">Bureaucrat Conrad, you are technically correct, the best kind of correct. But big-O notation is fuzzy on purpose: this algorithm is <code>O(n)</code> where <code>n</code> is <code>len(l)</code> but we are more interested in <code>O(n)</code> where <code>n</code> is <code>offset</code> and for all practical purposes we can approximate it to 1 in this case`.</span>
<span class="comment-copy">Your indentation is wrong on the last return statement.</span>
<span class="comment-copy">@rassar corrected, thanks</span>
<span class="comment-copy">This may be correct but is very efficient. There is a solution that is O(1).</span>
<span class="comment-copy">@paulo scardine are you talking about negative list slicing Mr. Scardine?</span>
<span class="comment-copy">He was thinking <code>a[d:] + a[:d]</code></span>
