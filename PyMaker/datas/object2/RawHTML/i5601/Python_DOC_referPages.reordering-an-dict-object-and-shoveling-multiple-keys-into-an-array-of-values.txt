<div class="post-text" itemprop="text">
<p>This is my Ruby code. I want to convert this function to a Python 3 equivalent.   </p>
<pre><code>files = {
  'Input.txt' =&gt; 'Randy',
  'Code.py' =&gt; 'Stan',
  'Output.txt' =&gt; 'Randy'
}    

def group_by_owners(files)
  files.each_with_object({}) { |(key, value), new_hash| (new_hash[value] ||= []) &lt;&lt; key }
end

puts group_by_owners(files)
</code></pre>
<p>The Ruby result looks like this:</p>
<pre><code>{"Randy" =&gt; ["Input.txt", "Output.txt"], "Stan" =&gt; ["Code.py"]}
</code></pre>
<p>Python would be:</p>
<pre><code>{"Randy": ["Input.txt", "Output.txt"], "Stan": ["Code.py"]}
</code></pre>
<p>Here is what I have tried: </p>
<pre><code>def group_by_owners(files):
  new_dict = dict(zip(files.values(), (files.keys())))
  print(new_dict)
</code></pre>
<p>Then I was trying to append the keys to an array.</p>
<pre><code>def group_by_owners(files):
  keys_array = []
  new_dict = dict(zip(files.values(), keys_array.append((files.keys()))))
</code></pre>
<p>but I don't think that will work inside of a zip method. </p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, your mentioned data structure is known as dictionary (<a href="https://docs.python.org/3/library/functions.html#func-dict" rel="nofollow noreferrer"><strong><code>dict</code></strong></a> in terms of code) and is syntactically represented as:</p>
<pre><code>files = {
   'Input.txt': 'Randy',
   'Code.py': 'Stan',
   'Output.txt': 'Randy'
}
</code></pre>
<p>In order to swap the key and values of your <code>dict</code>, you may use <a href="https://docs.python.org/dev/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><strong><code>collections.defaultdict</code></strong></a> as:</p>
<pre><code>from collections import defaultdict

swapped_dict = defaultdict(list)

for key, value in files.items():
    swapped_dict[value].append(key) 
</code></pre>
<p>where <code>swapped_dict</code> is a <code>dict</code> object holding the value:</p>
<pre><code>{
    'Randy': ['Output.txt', 'Input.txt'],
    'Stan': ['Code.py']
}
</code></pre>
<p><strong>Note:</strong> Ruby maintains the order, but in Python version &lt; 3.6, the <code>dict</code> objects are unordered in nature. However, <a href="https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6">from Python version &gt;= 3.6, <code>dict</code> objects are now ordered in nature</a>.</p>
<p>For Python versions &lt; 3.6, we have <a href="https://docs.python.org/dev/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><strong><code>collections.OrderedDict</code></strong></a> which maintains the order in which keys are inserted. Here's an example to show the swapping of key/value pairs:</p>
<pre><code>from collections import OrderedDict

# for maintaining the order, your initial list 
# should also be of the type `OrderedDict`
old_dict = OrderedDict([('Input.txt', 'Randy'), ('Code.py', 'Stan'), ('Output.txt', 'Randy')])

for k, v in old_dict.items():
    new_dict.setdefault(v, []).append(k)
    # You may use `setdefault` on normal dictionaries too
</code></pre>
<p>which will return <code>dict</code> object as: </p>
<pre><code>&gt;&gt;&gt; new_dict
OrderedDict([('Randy', ['Input.txt', 'Output.txt']), ('Stan', ['Code.py'])])
</code></pre>
<p>It is just represented like this, you can access <code>new_dict</code> like a normal dictionary object.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def group_by_owners(files: dict): -&gt; dict
    res = {v: [] for v in files.values() }
    for k, v in files.items():
        res[v].append(k)
    return res
</code></pre>
<p><strong>Note:</strong> in Python dicts are unordered (until 3.7 version).</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a dictionary version of <code>files</code> in Python:</p>
<pre><code>files = {'Input.txt': 'Randy',
         'Code.py': 'Stan',
         'Output.txt' : 'Randy'}
</code></pre>
<p><code>files.items()</code> returns:</p>
<p><code>dict_items([('Input.txt', 'Randy'), ('Code.py', 'Stan'), ('Output.txt', 'Randy')])</code></p>
<pre><code>def group_by_owners(files):    
    result = dict() # empty dict

    for k, v in files.items(): 
        if v in result:
            result[v].append(k) # Append to list value if the key is in result
        else:
            result[v] = [k]  # Add key: value        

    return result


print(group_by_owners(files))
# {'Randy': ['Input.txt', 'Output.txt'], 'Stan': ['Code.py']}
</code></pre>
</div>
<span class="comment-copy">So what have you tried? This isn't a code translation service. And that output isn't Python.</span>
<span class="comment-copy">Isn't the result more like <code>{"Randy": ["Input.txt", "Output.txt"], "Stan": ["Code.py"]}</code> ?</span>
<span class="comment-copy">There is still no Python code in your question, so... <i>what</i> is what you have tried?</span>
<span class="comment-copy">Come on, you've had over a year to update to Python 3.6 :-P</span>
<span class="comment-copy">@StefanPochmann Still I mostly work on Python 2.7, and sometime on 3.4.5 due to old official projects (we haven't migrated them yet). After reading your comment, I explored a bit and updated the answer. Thanks! :)</span>
<span class="comment-copy">In Ruby insertion order is maintained.</span>
<span class="comment-copy">@steenslag added an example of ordered dictionaries too</span>
<span class="comment-copy">@MoinuddinQuadri Thanks for the detailed explanation!!</span>
<span class="comment-copy">Dicts will be ordered as of two weeks ago: <a href="https://mail.python.org/pipermail/python-dev/2017-December/151283.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-dev/2017-December/151283.html</a> This will become part of the Python 3.7 spec, and all conforming implementations of Python 3.7 must implement it.</span>
<span class="comment-copy">@JÃ¶rgWMittag thank you. Updated.</span>
