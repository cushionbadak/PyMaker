<div class="post-text" itemprop="text">
<p>How do I express the type of a <code>Dict</code> which has two keys that take two different types of values? For example:</p>
<pre><code>a = {'1': [], '2': {})
</code></pre>
<p>The following is just to give you an idea of what I am looking for.</p>
<blockquote>
<p>Dict[(str, List), (str, Set)]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The feature you are asking about is called <strong>"Heterogeneous dictionaries"</strong> where you need to define specific types of values for the specific keys. The issue is being discussed at <a href="https://github.com/python/typing/issues/28" rel="nofollow noreferrer">Type for heterogeneous dictionaries with string keys</a> and <em>is not yet implemented</em> and is still open. The current idea is to use so-called <code>TypedDict</code> which would allow a syntax like:</p>
<pre><code>class HeterogeneousDictionary(TypedDict):
    x: List
    y: Set
</code></pre>
<p>Note that <a href="http://mypy.readthedocs.io/en/latest/introduction.html" rel="nofollow noreferrer"><code>mypy</code> project</a> has this type already available through the "mypy extensions" (marked as experimental) - <a href="http://mypy.readthedocs.io/en/latest/kinds_of_types.html#typeddict" rel="nofollow noreferrer"><code>TypedDict</code></a>:</p>
<pre><code>from mypy_extensions import TypedDict

HeterogeneousDictionary = TypedDict('HeterogeneousDictionary', {'1': List, '2': Set})
</code></pre>
<hr/>
<p>At the very least though, we can ask for values to be either <code>List</code> or <code>Set</code> using <a href="https://docs.python.org/3/library/typing.html#typing.Union" rel="nofollow noreferrer"><code>Union</code></a>:</p>
<pre><code>from typing import Dict, List, Set, Union

def f(a: Dict[str, Union[List, Set]]):
    pass
</code></pre>
<p>This is, of course, not ideal as we lose a lot of information about what keys need to have values of which types.</p>
</div>
<span class="comment-copy">This is not support in [most] statically typed language either. Consider a Union (eg. "Record" or "Tuple") to decompose the types.</span>
<span class="comment-copy">So, I guess the answer is you cannot?</span>
<span class="comment-copy">@Nijan okay, edited the answer, check it out, thanks.</span>
<span class="comment-copy">That was very insightful, thanks.</span>
<span class="comment-copy">I tried to edit the answer to make the syntax <code>Union(List, Set)</code> to <code>Union[List, Set]</code> but could not do it because it needs to be at least 6 characters. Using parenthesis gives me this error <code>Traceback (most recent call last):   File "main.py", line 3, in &lt;module&gt;     def f(a: Dict[str, Union(List, Set)]):   File "/usr/lib64/python3.6/typing.py", line 189, in __call__     raise TypeError("Cannot instantiate %r" % type(self)) TypeError: Cannot instantiate typing.Union</code></span>
<span class="comment-copy">@openrijal I fixed it</span>
