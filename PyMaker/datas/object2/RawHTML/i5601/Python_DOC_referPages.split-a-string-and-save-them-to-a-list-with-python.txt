<div class="post-text" itemprop="text">
<p>I have a string that I inserted a space into it in all different positions and saved them to a list. Now this list of strings with space in them, I want to split those strings and put the output in one list, when am doing this, it happens that am having multiple list inside:</p>
<p>This is the code am working on:</p>
<pre><code>var ='sans'
res = [var[:i]+' '+var[i:] for i in range(len(var))]
// The previous line: AM adding a space to see maybe that would generate other words
cor = [res[i].split() for i in range (len(res))]
</code></pre>
<p>And this is the output am getting:</p>
<pre><code>&gt;&gt;&gt; cor
[['sans'], ['s', 'ans'], ['sa', 'ns'], ['san', 's']]
</code></pre>
<p>What am expecting:</p>
<pre><code>&gt;&gt;&gt; cor
    ['sans', 's', 'ans', 'sa', 'ns', 'san', 's']
</code></pre>
<p>Am new to python, I don't know what am missing. </p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>An alternative approach:</p>
<pre><code>cor = " ".join(res).split()
</code></pre>
<p>Output:</p>
<pre><code>['sans', 's', 'ans', 'sa', 'ns', 'san', 's']
</code></pre>
<p><strong>Explanation</strong></p>
<p><code>" ".join(res)</code> will join the individual strings in <code>res</code> with a space in between them. Then calling <code>.split()</code> will split this string on whitespace back into a list.</p>
<p><strong>EDIT</strong>: A second approach that doesn't involve the intermediate variable <code>res</code>, although this one isn't quite as easy on the eyes:</p>
<pre><code>cor = [var[:i/2+1] if i%2==1 else var[i/2:] for i in range(2*len(var)-1)]
</code></pre>
<p>Basically you flip between building substrings from the front and the back.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, your</p>
<pre><code>[res[i].split() for i in range (len(res))]
</code></pre>
<p>is a complicated unpythonic way to do the same as this:</p>
<pre><code>[r.split() for r in res]
</code></pre>
<p>Now... the problem is that you treat <code>r.split()</code> as your end result. You should instead use it as a source to treat it further:</p>
<pre><code>[s for r in res for s in r.split()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have a list </p>
<pre><code>cor = [['sans'], ['s', 'ans'], ['sa', 'ns'], ['san', 's']]
</code></pre>
<p>And you want to flatten it, you can use the following:</p>
<pre><code>flat = [x for y in cor for x in y]
</code></pre>
<p>The output will be:</p>
<pre><code>['sans', 's', 'ans', 'sa', 'ns', 'san', 's']
</code></pre>
<p>You can also make that directly with the <code>res</code> variable:</p>
<pre><code>cor = [x for y in [res[i].split() for i in range (len(res))] for x in y]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You coud always use <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map()</code></a> to split each string in <code>res</code>:</p>
<pre><code>list(map(str.split, res))
</code></pre>
<p>Which gives:</p>
<pre><code>[['sans'], ['s', 'ans'], ['sa', 'ns'], ['san', 's']]
</code></pre>
<p>Then you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a> to flatten the list:</p>
<pre><code>list(chain.from_iterable(map(str.split, res)))
</code></pre>
<p>Which Outputs:</p>
<pre><code>['sans', 's', 'ans', 'sa', 'ns', 'san', 's']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do something like this in one line without importing any module :</p>
<pre><code>var ='sans'

final=[]
list(map(lambda x:list(map(lambda y:final.append(y),x)),[(var[i:]+' '+var[:i]).split() for i in range(0,len(var))]))
print(final)
</code></pre>
<p>output:</p>
<pre><code>['sans', 'ans', 's', 'ns', 'sa', 's', 'san']
</code></pre>
</div>
<span class="comment-copy">@roganjosh Compared to <i>yours</i> maybe :-P</span>
<span class="comment-copy">@StefanPochmann haha, oh come on, this is gonna have to come down to a <code>timeit</code> because this answer beats even a list comp IMO in simplicity :P</span>
<span class="comment-copy">@StefanPochmann's answer is likely the best (he's got my upvote) but double list comprehensions can be difficult to understand for someone thats "new to python."</span>
<span class="comment-copy">@roganjosh But it's much <i>faster</i> than ours.</span>
<span class="comment-copy">@roganjosh Yeah you made a big error there. I'm not spelled with "ph" :-). Also, there's no timing code, it's just the solutions.</span>
<span class="comment-copy">This approach seems to be quite fast also, as seen <a href="https://ideone.com/zozhMt" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">@RoadRunner With <code>var ='sans' * 1000</code> and <code>n = 40</code> it looks better: <a href="https://ideone.com/6dC8Rb" rel="nofollow noreferrer">ideone.com/6dC8Rb</a>. But interestingly, Dekel's is even faster then. That didn't seem right, so I tested them locally independently (also with Python 3.5) and mine was faster there. Then I moved mine to the end and lo and behold, it became the fastest: <a href="https://ideone.com/yYXRrn" rel="nofollow noreferrer">ideone.com/yYXRrn</a>. Then I moved <i>yours</i> to the end and <i>it</i> became almost the fastest: <a href="https://ideone.com/sN5Gnn" rel="nofollow noreferrer">ideone.com/sN5Gnn</a>. I guess I'll have to stop benchmarking on ideone. Seems like later tests benefit from earlier tests increasing the process priority or so.</span>
<span class="comment-copy">Would be better to not build that <code>cor</code> in the first place.</span>
<span class="comment-copy">@StefanPochmann you are right, added an example for that as well</span>
<span class="comment-copy">Nah, that's not what I meant. You're still building that list (even in the exact same bad way).</span>
