<div class="post-text" itemprop="text">
<p>this is perhaps a very simple question</p>
<p>I have a list that looks like this:</p>
<pre><code>a=[0,1,1,2,3,2,1,2,0,3,4,1,1,1,1,0,0,0,0,4,5,1,1,1,3,2,0,2,1,1,3,4,1]
</code></pre>
<p>I am struggling to find a simple python code that replaces when <strong><em>n</em></strong> or less consecutive <strong>1s</strong> are found to 0s and creates a new list with the new values</p>
<p>So if</p>
<pre><code>n = 2
</code></pre>
<p>b = [0,<strong>0,0</strong>,2,3,2,<strong>0</strong>,2,0,3,4,1,1,1,1,0,0,0,0,4,5,1,1,1,3,2,0,2,<strong>0,0</strong>,3,4,<strong>0</strong>]</p>
<p>if</p>
<p>n = 3</p>
<p>b = [0,<strong>0,0</strong>,2,3,2,<strong>0</strong>,2,0,3,4,1,1,1,1,0,0,0,0,4,5,<strong>0,0,0</strong>,3,2,0,2,<strong>0,0</strong>,3,4,<strong>0</strong>] </p>
<p>I have highlighted the new replaces values in each example</p>
</div>
<div class="post-text" itemprop="text">
<p>"One"-liner, using some <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a>:</p>
<pre><code>from itertools import groupby, chain

a=[0,1,1,2,3,2,1,2,0,3,4,1,1,1,1,0,0,0,0,4,5,1,1,1,3,2,0,2,1,1,3,4,1]

list(
    chain.from_iterable(
        ([0] * len(lst) if x == 1 and len(lst) &lt;= n else lst 
         for x, lst in ((k, list(g)) for k, g in groupby(a)))
    )
)
# [0,0,0,2,3,2,0,2,0,3,4,1,1,1,1,0,0,0, 0,4,5,1,1,1,3,2,0,2,0,0,3,4,0]
</code></pre>
<p><code>groupby</code> groups the initial list into groups of identical objects. Its output is an iterator of pairs <code>(k, g)</code> where <code>k</code> is the element that is the grouping key and <code>g</code> is an iterator producing the actual elements in the group.</p>
<p>Since you cannot call <code>len</code> on an iterator, this listifies the groups and chains the resulting lists except lists of <code>1</code> of the appropriate lengthes. Those are replaced by lists of <code>0</code> of the same length.</p>
<p>In single steps (using intermediate lists instead of generators):</p>
<pre><code>grouped_lists_by_key = [k, list(g)) for k, g in groupby(a)]
# [(0, [0]), (1, [1, 1]), ...]

grouped_lists = [[0] * len(lst) if x == 1 and len(lst) &lt;= n else lst for x, lst in grouped]
# [[0], [0, 0], [2], [3], ...]

flattened = chain.from_iterable(grouped_lists)
# [0, 0, 0, 2, 3, ...]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>import itertools
a=[0,1,1,2,3,2,1,2,0,3,4,1,1,1,1,0,0,0,0,4,5,1,1,1,3,2,0,2,1,1,3,4,1]
n = 3
new_list = list(itertools.chain(*[[0]*len(b) if a == 1 and len(b) &lt;= n else b for a, b in [(c, list(d)) for c, d in itertools.groupby(a)]]))
</code></pre>
<p>Output:</p>
<pre><code>[0, 0, 0, 2, 3, 2, 0, 2, 0, 3, 4, 1, 1, 1, 1, 0, 0, 0, 0, 4, 5, 0, 0, 0, 3, 2, 0, 2, 0, 0, 3, 4, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Non-oneliner using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code></a>:</p>
<pre><code>a = [0,1,1,2,3,2,1,2,0,3,4,1,1,1,1,0,0,0,0,4,5,1,1,1,3,2,0,2,1,1,3,4,1]
n = 2
b = []
for k, g in groupby(a):
    l = list(g)
    if k == 1 and len(l) &lt;= n:
        b.extend([0]*len(l))
    else:
        b.extend(l)
print(b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>def replacer(array, n):
    i, consec = 0, 0
    while i &lt; len(array):
        if array[i] == 1:
            consec += 1
        else:
            if consec &gt;= n:
                for x in range(i-consec, i):
                    array[x] = 0
            consec = 0
        i += 1
    return array
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Longer than others, but arguably straightforward:</p>
<pre><code>a = [0,1,1,2,3,2,1,2,0,3,4,1,1,1,1,0,0,0,0,4,5,1,1,1,3,2,0,2,1,1,3,4,1]

def suppress_consecutive_generator(consecutive=2, toreplace=1, replacement=0):
    def gen(l):
        length = len(l)
        i = 0
        while i &lt; length:
            if l[i] != toreplace:
                yield l[i]
                i += 1
                continue
            j = i
            count = 0
            while j &lt; length:
                if l[j] != toreplace:
                    break
                count += 1
                j += 1
            i += count
            if count &lt;= consecutive:
                for _ in range(count):
                    yield replacement
            else:
                for _ in range(count):
                    yield toreplace
    return gen

print(list(suppress_consecutive_generator()(a)))
</code></pre>
</div>
<span class="comment-copy">That's great! Many thanks! Could you please explain a bit?</span>
<span class="comment-copy">I added some explanations.</span>
