<div class="post-text" itemprop="text">
<p>I'm trying to compare two dates. This code works:</p>
<pre><code>import datetime

todays_date = datetime.date.today()

date1 = datetime.date(2006, 3, 15)
date2 = datetime.date(2009, 4, 30)

print(date1 != date2)
print(date1 == 0)
</code></pre>
<p>It produces:</p>
<pre><code>True
False
</code></pre>
<p>Those code does not work and I don't know why:</p>
<pre><code>import datetime

todays_date = datetime.date.today()

date1 = datetime.date(2006, 3, 15)
date2 = datetime.date(2009, 4, 30)

print(date1 != date2)
print(date1 &gt;= 0)
</code></pre>
<p>It produces this error:</p>
<pre><code>File 'datetime.py', Line 363: AttributeError: 'int' object has no attribute '__name__'
</code></pre>
<p>Note that all I changed was <code>==</code> to <code>&gt;=</code>, why does equality comparison results in <code>True</code> or <code>False</code>, while greater than comparaison results in an error?</p>
<p>I would appreciate any help!</p>
</div>
<div class="post-text" itemprop="text">
<h1>TL;DR</h1>
<p><em>It's because of how the comparison methods are defined.</em></p>
<hr/>
<h3>Reason why `==` is comparable while `&gt;=` isn't between `time` objects and type `int`:</h3>
<p>Here's a copy of the <a href="https://github.com/python/cpython/blob/master/Lib/datetime.py" rel="noreferrer">source code</a> for the <code>time</code> object:</p>
<pre><code>def __eq__(self, other):
    if isinstance(other, time):
        return self._cmp(other, allow_mixed=True) == 0
    else:
        return False

def __ge__(self, other):
    if isinstance(other, time):
        return self._cmp(other) &gt;= 0
    else:
        _cmperror(self, other)
</code></pre>
<p><code>__eq__</code> returns <code>False</code> when it's not another <code>time</code> instance, while <code>__ge__</code> calls <code>_cmperror</code>, which is defined as followed:</p>
<pre><code>def _cmperror(x, y):
    raise TypeError("can't compare '%s' to '%s'" % (
                    type(x).__name__, type(y).__name__))
</code></pre>
<hr/>
<h1>Very Important Edit</h1>
<p>Although this answer already got some positive scores, but I have miss read your question, you used <code>date</code> objects, not <code>time</code> objects.</p>
<h3>Reason why `==` is comparable while `&gt;=` isn't between `date` objects and type `int`:</h3>
<p>First of all, <code>date</code> objects, unlike <code>time</code> objects, they are implemented the same for <code>__eq__</code> and <code>__ge__</code>. Both of them actually returns <code>NotImplemented</code>, therefore there's nothing special about the <code>date</code> object's methods:</p>
<pre><code>def __eq__(self, other):
    if isinstance(other, date):
        return self._cmp(other) == 0
    return NotImplemented

def __ge__(self, other):
    if isinstance(other, date):
        return self._cmp(other) &gt;= 0
    return NotImplemented
</code></pre>
<p>What is different, however, is <code>int</code>'s <code>__eq__</code> comparison's to the other methods. <code>int</code> returns <code>False</code> when an object has a none-comparable type for <code>__eq__</code> and <code>NotImplemented</code> for <code>__ge__</code>.</p>
<p>The <code>NotImplemented</code> returned by <code>date</code> will result in a fallback on <code>int</code>'s methods. Since <code>int</code> is always equality comparable, <code>date == 0</code> does not result in an error.</p>
<p>Here is an example:</p>
<pre><code>class LikeDate:
    def __eq__(self, other):
         if isinstance(other, LikeDate):
             return True
         else:
              return NotImplemented

    def __ge__(self, other):
         if isinstance(other, LikeDate):
             return True
         else:
              return NotImplemented

class LikeInt:
    def __eq__(self, other):
         if isinstance(other, LikeInt):
             return True
         else:
             return False

    def __ge__(self, other):
         if isinstance(other, LikeInt):
             return True
         else:
              return NotImplemented

a = LikeDate()
b = LikeInt()
print(a == b) # False
print(a == 0) # False, because int provides an __eq__ method that returns False
print(a &gt;= 0) # Error, because nether LikeDate nor int provides a definite comparison for __ge__
print(a &gt;= b) # Error, because neither objects provide a comparable __ge__
</code></pre>
<p><a href="https://ideone.com/BEJxdW" rel="noreferrer">You can run this example here.</a></p>
<hr/>
<p>If you do not know what <code>return NotImplemented</code> is, here's a short explanation and a quote from the <a href="https://docs.python.org/3/library/constants.html?highlight=notim#NotImplemented" rel="noreferrer">doc</a>:</p>
<blockquote>
<p>When a binary [ ( <code>__eq__</code>, <code>__ge__</code> ...) ] (or in-place) method returns <code>NotImplemented</code> the
  interpreter will try the reflected operation on the other type (or
  some other fallback, depending on the operator). If all attempts
  return <code>NotImplemented</code>, the interpreter will raise an appropriate
  exception. Incorrectly returning NotImplemented will result in a
  misleading error message or the <code>NotImplemented</code> value being returned to
  Python code.</p>
</blockquote>
<p>When <code>NotImplemented</code> is returned from a binary method, it refers that the binary method isn't able to compare itself with the targets' type. The result of the binary method will depend on the other objects' binary method. If both object returns <code>NotImplemented</code> an error is raised.</p>
</div>
<div class="post-text" itemprop="text">
<p>As others have already pointed out, you cannot use <code>date1 &gt;= 0</code> because both do not have the same type.</p>
<p><code>date1 == 0</code> works because you are checking if two objects are equal to each other. If their types are different, the answer is automatically no and thus you get <code>False</code> back.</p>
<p>However, when using <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, you check whether or not something is greater or smaller than something else. If you use two objects with different types that cannot be trivially converted to one another, then it is not defined what 'greater than' or 'smaller than' means. So, in your case, <code>date1</code> is of type <code>datetime.date</code>, while <code>0</code> is of type <code>int</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to compare <code>date1</code> with 0.</p>
<p>That would not work since <code>date1</code> is a <code>datetime.date</code> (See how you define it initially). So basically you are comparing a <code>date</code> with an <code>int</code>.</p>
<p>You can compare only similar types.</p>
</div>
<span class="comment-copy">What "date" would <code>0</code> be? The types have to be comparable.</span>
<span class="comment-copy">But then why does <code>date1 == 0</code> work?</span>
<span class="comment-copy">@JohnGordon Huh. That's interesting. The behavior is <a href="https://docs.python.org/2/library/datetime.html#date-objects" rel="nofollow noreferrer">documented</a>, but there's no justification for it. That does seem very strange and inconsistent.</span>
<span class="comment-copy">Equality comparison is a different thing. <code>1 == '1'</code> also works but <code>1 &gt; '1'</code> doesn't. (Also <code>1 == []</code>, <code>x == {}</code> and many others. I wouldn't call this inconsistent.)</span>
<span class="comment-copy">@ayhan all of these work for me (all return False, though). Is that a Python 2 - 3 thing?</span>
<span class="comment-copy">@FatihAkici Yes, in Python 2 everything was <a href="https://stackoverflow.com/a/3270689/2285236">comparable</a>.</span>
