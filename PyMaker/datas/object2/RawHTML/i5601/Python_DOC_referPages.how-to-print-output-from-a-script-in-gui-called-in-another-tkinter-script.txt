<div class="post-text" itemprop="text">
<p>I have tried using several different similar solutions that I have found online, but none seem to quite do what I am aiming for.  </p>
<p>I want to call an external script (helloworld.py) into my tkinter gui.  I want this called script (helloworld.py) to execute all the functions that are contained in it upon a button press in the gui and print the resulting outputs into the gui, not the console.  I have found some solutions which will print the output to the console, but I am unable to get it to display in the gui.  Any solutions that I have found that print to the gui do not work when I try to get the output to come from a called external script.  </p>
<p>I appreciate any help.  I am definitely a novice, so I apologize for what is probably a basic question and the inability to connect the dots for myself on similar questions asked on here.  Below is one of the versions of code that I am currently working with.  Thank you in advance for your help!</p>
<pre><code>import Tkinter
import sys
import subprocess
sys.path.append('/users/cmbp')

def callback():
    import os
    print subprocess.call('python /users/cmbp/p4e/helloworld.py', 
shell=True)
    lbl = Tkinter.Label(master)
    lbl.pack()

master = Tkinter.Tk()
master.geometry('200x90')
master.title('Input Test')

Btn1 = Tkinter.Button(master, text="Input", command=callback)
Btn1.pack()

master.mainloop()
</code></pre>
<p><strong><em>EDIT</em></strong></p>
<p>I also started having some success with trying to import the called script as a module.  The problem with this is I can only get one function to print out from the called script even though there are multiple functions that I want to try and call (I just want the entire called script to print out all the results of its functions).</p>
<p>Here is an example of a script that I want to call helloworld.py:</p>
<pre><code>def cooz():
    return ('hello worldz!')

def tooz():
    return ("here is another line")

def main():
    return cooz()
    return tooz()
</code></pre>
<p>And here is an example of the tkinter gui script that is trying to import helloworld.py:</p>
<pre><code>import Tkinter as tk
import helloworld

def printSomething():
    y = helloworld.main()
    label = tk.Label(root, text= str(y))
    label.pack()


root = tk.Tk()
root.geometry('500x200')
root.title('Input Test')

button = tk.Button(root, text="Print Me", command=printSomething)
button.pack()

root.mainloop()
</code></pre>
<p>This results in only the first function printing ('hello worldz!').  Any thoughts on why it only will return one line and not the entire helloworld.py script?  </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>subprocess.check_output()</code> to get output and assign to <code>Label</code></p>
<p>You can also <code>import</code> script and execute function from script. </p>
<pre><code>import test
test.function()
</code></pre>
<p>But first you will have to redirect <code>sys.stdout</code> using class with <code>write()</code> and then it will catch all printed text.</p>
<p>You can redirect <code>sys.stdout</code> to variable (see <code>StdoutRedirector</code>) and then you can edit it (ie. strip <code>\n</code> at the end) or you can redirect directly to <code>Label</code> (see <code>StdoutRedirectorLabel</code>)</p>
<pre><code>import Tkinter as tk

# -----

import subprocess

def callback1():
    cmd = 'python test.py'

    # it will execute script which runs only `function1`
    output = subprocess.check_output(cmd, shell=True)

    lbl['text'] = output.strip()

# -----

class StdoutRedirector(object):

    def __init__(self):
        # clear before get all values
        self.result = ''

    def write(self, text):
        # have to use += because one `print()` executes `sys.stdout` many times
        self.result += text

def callback2():

    import test

    # keep original `sys.stdout
    old_stdout = sys.stdout

    # redirect to class which has `self.result`
    sys.stdout = StdoutRedirector()

    # it will execute only `function2`
    test.function2()

    # assign result to label (after removing ending "\n")
    lbl['text'] = sys.stdout.result.strip()

    # set back original `sys.stdout
    sys.stdout = old_stdout

# -----

import sys

class StdoutRedirectorLabel(object):

    def __init__(self, widget):
        self.widget = widget
        # clear at start because it will use +=
        self.widget['text'] = ''

    def write(self, text):
        # have to use += because one `print()` executes `sys.stdout` many times
        self.widget['text'] += text

def callback3():

    import test

    # keep original `sys.stdout
    old_stdout = sys.stdout

    # redirect to class which will add text to `lbl`
    sys.stdout = StdoutRedirectorLabel(lbl)

    # it will execute only `function3` and assign result to Label (with ending "\n")
    test.function3()

    # set back original `sys.stdout
    sys.stdout = old_stdout

# --- main ---

master = tk.Tk()
master.geometry('200x200')

lbl = tk.Label(master, text='')
lbl.pack()

btn1 = tk.Button(master, text="subprocess", command=callback1)
btn1.pack()

btn2 = tk.Button(master, text="StdoutRedirector", command=callback2)
btn2.pack()

btn3 = tk.Button(master, text="StdoutRedirectorLabel", command=callback3)
btn3.pack()

master.mainloop()
</code></pre>
<p>test.py</p>
<pre><code>def function1():
    print('function 1')

def function2():
    print('function 2')

def function3():
    print('function 3')

if __name__ == '__main__':
    function1() 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In a method when a line with <code>return ...</code> is run, nothing else will be seen that comes after that line, as in your 2nd line of <code>return ...</code> is effectively useless as <code>return  cooz()</code> is run <em>unconditionally</em>. You could simply replace your <code>main</code> with:</p>
<pre><code>def main():
    return cooz(), tooz()
</code></pre>
<p>and accordingly your <code>printSomething</code>:</p>
<pre><code>x, y = helloworld.main()
</code></pre>
<hr/>
<h1>Returning <em>all</em> methods/functions from a script without explicitly passing method names:</h1>
<p>Well, I <a href="https://stackoverflow.com/questions/48038526/how-to-print-output-from-a-script-in-gui-called-in-another-tkinter-script#comment83047812_48038526">stand corrected</a>, based on <a href="https://stackoverflow.com/a/5136686/7032856">this answer</a> you can do it fairly simply. For calling <em>all</em> methods or functions <a href="https://stackoverflow.com/a/1796247/7032856">this answer</a> helped a lot.</p>
<p>Let's say there's a script named <code>hello_world.py</code>:</p>
<pre><code>def hello_world():
    print("Hello World!")
    print("this is the 2nd line of this method")

def multiplication(*args):
    mult = 1
    for arg in args:
        mult *= arg

    return mult

def some_other_method():
    print("some other method")
    print(multiplication(2, 3, 5, 7))
</code></pre>
<p>is in the <em>same</em> directory as GUI script below:</p>
<pre><code>import tkinter as tk    # required for the GUI
import subprocess       # required for redirecting stdout to GUI
import sys, inspect     # required for all methods and functions redirection
import hello_world      # the script file that is redirected

def redirect(module, method):
    '''Redirects stdout from the method or function in module as a string.'''
    proc = subprocess.Popen(["python", "-c",
        "import " + module.__name__ + ";" + module.__name__ + "." + method + "()"],
                                                                stdout=subprocess.PIPE)
    out = proc.communicate()[0]
    return out.decode('unicode_escape')

def redirect_module(module):
    '''Retruns all stdout from all methods or functions in module as a string.'''
    # to filter out non-method, and non-function attributes
    all_mtds_or_funcs = inspect.getmembers(sys.modules[module.__name__], 
                                                inspect.isfunction or inspect.ismethod)
    red_str_buffer = ""
    for method in all_mtds_or_funcs:
        red_str_buffer += redirect(module, method[0]) + "\n---\n"

    return red_str_buffer

def put_in_txt(module):
    '''Puts the redirected string in a text.'''
    txt.insert('1.0', redirect_module(module))

root = tk.Tk()
txt = tk.Text(root)
btn = tk.Button(root, text="Redirect")
btn['command'] = lambda module=hello_world : put_in_txt(module)

txt.pack()
btn.pack()

root.mainloop()
</code></pre>
<p>which returns console output of <em>all</em> methods and functions in <code>hello_world.py</code> as a string. Based on <a href="https://stackoverflow.com/questions/48038526/how-to-print-output-from-a-script-in-gui-called-in-another-tkinter-script/48039105#comment83048813_48039105">this suggestion</a> it then puts that string in a <a href="http://effbot.org/tkinterbook/text.htm" rel="nofollow noreferrer">Text</a> field.</p>
</div>
<span class="comment-copy">Interesting. Can you search SO for <code>freopen</code>? That's a C function but I think it would be applicable for you as well.</span>
<span class="comment-copy">I don't think this is a simple question at all. You need a complete wrapper that detects print statements and converts them to GUI widgets, and that's still not guaranteed to work with every function.</span>
<span class="comment-copy">@Nae: capturing <i>all</i> output that prints to <code>stdout</code> is a standard operation in consoles, IDEs, and other software. So no need to detect singular "print statements". I wouldn't know where to start for Python, hence my suggestion.</span>
<span class="comment-copy">There's a script named <code>errorwindow.py</code> in my <a href="https://stackoverflow.com/a/18091356/355230">answer</a> to another question which shows how to redirect output sent to <code>stdout</code> and <code>stderr</code> to a <code>tkinter</code> window. What it does is very similar to what you want to do (and it doesn't require—and isn't specific to—using the <code>easygui</code> module).</span>
<span class="comment-copy"><code>subprocess</code> has other functions to get output - ie. <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer">check_output()</a></span>
<span class="comment-copy">Above codes are for python3, it may be slightly different in python 2.</span>
<span class="comment-copy">Knock me over with a feather duster. Works like a charm: <a href="https://imgur.com/27GAoek" rel="nofollow noreferrer">imgur.com/27GAoek</a> (I added a scrolling text field, just for funsies).</span>
<span class="comment-copy">@usr2564301 Scrolling text suits better I think.</span>
<span class="comment-copy">I can edit my changes into your answer if you want. (OTOH As I am a starter with Python, it's a bit of copypasta from elsewhere. So perhaps you already know how to do this :)</span>
<span class="comment-copy">@usr2564301 Improved the code allow more flexibility with redirection, which is now returned as a string. Which should make putting on the widget of choice easier. Thanks for the suggestion.</span>
