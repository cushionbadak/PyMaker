<div class="post-text" itemprop="text">
<p>I have loaded a black and white image as a numpy array. The array shape is equal to the pixels in the image. I want to extract certain ranges of pixel values, for instance, </p>
<pre><code>numpy_array_to_slice[160:300,28:43] 
</code></pre>
<p>etc etc, but I don't want to hardcode the index numbers. Rather, I want to load the index values from a list of values. For instance, I have a list of index values like:</p>
<pre><code>listofindexvalues = [['160:300,28:43'],['160:300,40:55'],['160:300,28:43']] 
</code></pre>
<p>So effectively I want something like:</p>
<pre><code>numpy_array_to_slice[listofindexvalues[0]]
</code></pre>
<p>which would take the place of:</p>
<pre><code>numpy_array_to_slice['160:300,28:43']
</code></pre>
<p>I've tried a variety of things which haven't worked like:</p>
<pre><code>first,second = str(index_list[19]).replace('[','').replace(']','').replace('\'','').split(':')  ##for just one side of an index value, such as 28:59
</code></pre>
<p>and trying to pass that like so:</p>
<pre><code>numpy_array_to_slice[int(first)+':'+int(second]
</code></pre>
<p>but that doesn't work because I can't concatenate those values. Is there any way to accomplish this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Slicing is <em>syntax</em>, not a string. See the <a href="https://docs.python.org/3/reference/expressions.html#slicings" rel="nofollow noreferrer"><em>Slicings</em> expressions reference documentation</a>:</p>
<blockquote>
<p>The semantics for a slicing are as follows. The primary is indexed (using the same <code>__getitem__()</code> method as normal subscription) with a key that is constructed from the slice list, as follows. <strong>If the slice list contains at least one comma, the key is a tuple containing the conversion of the slice items</strong>; otherwise, the conversion of the lone slice item is the key. The conversion of a slice item that is an expression is that expression. <strong>The conversion of a proper slice is a <code>slice</code> object (see section <a href="https://docs.python.org/3/reference/datamodel.html#types" rel="nofollow noreferrer">The standard type hierarchy</a>) whose <code>start</code>, <code>stop</code> and <code>step</code> attributes are the values of the expressions given as lower bound, upper bound and stride, respectively, substituting <code>None</code> for missing expressions.</strong></p>
</blockquote>
<p>Bold emphasis mine.</p>
<p>You can bypass this conversion (from slice syntax to <code>slice()</code> objects) by creating <code>slice()</code> objects directly; you can put them in tuples if need be.</p>
<p>So</p>
<pre><code>numpy_array_to_slice[160:300,28:43]
</code></pre>
<p>is equivalent to</p>
<pre><code>box = slice(160, 300), slice(28, 43)
numpy_array_to_slice[box]
</code></pre>
<p>I've omitted the <code>step</code> argument; it defaults to <code>None</code> when omitted.</p>
<p>Extending this to your list would be:</p>
<pre><code>listofindexvalues = [
    (slice(160, 300), slice(28, 43)),
    (slice(160, 300), slice(40, 55)),
    (slice(160, 300), slice(28, 43))
]

for box in listofindexvalues:
    sliced_array = numpy_array_to_slice[box]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should use a list of <code>slice</code> instances (or tuples thereof), not strings.</p>
<p>Here's an example.</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; 
&gt;&gt;&gt; listofindexvalues = [(slice(1, 6), slice(3, 4))]
&gt;&gt;&gt; a = np.arange(100).reshape(10,10)
&gt;&gt;&gt; a[listofindexvalues[0]]
array([[13],
       [23],
       [33],
       [43],
       [53]])
</code></pre>
<p><code>a[listofindexvalues[0]]</code> is equivalent to <code>a[1:6, 3:4]</code> in this case.</p>
<pre><code>&gt;&gt;&gt; a[1:6, 3:4]
array([[13],
       [23],
       [33],
       [43],
       [53]])
</code></pre>
</div>
<span class="comment-copy">Even if I read the documentation I'm not sure i would have understood it that easily. Thanks again, that's perfect!</span>
<span class="comment-copy">Awesome, thanks!</span>
