<div class="post-text" itemprop="text">
<p>I have the following line in a Python script that runs a separate Python script from within the original script:</p>
<pre><code>subprocess.Popen("'/MyExternalPythonScript.py' " + theArgumentToPassToPythonScript, shell=True).communicate()
</code></pre>
<p>Using the above line, any <code>print()</code> statements found in the separate Python file do appear in the console of the main Python script.</p>
<p>However, these statements are <strong>not</strong> reflected in the .txt file log that the script writes to.</p>
<p>Does anyone know how to fix this, so that the .txt file exactly reflects the true console text of the main Python script?</p>
<hr/>
<p>This is <a href="https://stackoverflow.com/a/616672">the method</a> I am using to save the console as a .txt file, in real time:</p>
<pre><code>import sys
class Logger(object):
    def __init__(self):
        self.terminal = sys.stdout
        self.log = open("/ScriptLog.txt", "w", 0)
    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)


sys.stdout = Logger()
</code></pre>
<p>I am not necessarily attached to this method. I am interested in any method that will achieve what I've detailed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Keep in mind that <code>subprocess</code> spawns a new process, and doesn't really communicate with the parent process (they're pretty much independent entities). Despite its name, the <a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow noreferrer"><code>communicate</code></a> method is just a way of sending/receiving data from the parent process to the child process (simulate that the user input something on the terminal, for instance)</p>
<p>In order to know where to write the output, subprocess uses numbers (file identifiers or file numbers). When subprocess spawns a process, the child process only knows that the standard output is the file identified in the O.S. as <code>7</code> (to say a number) but that's pretty much it. The subprocess will independently query the operative system with something like <em>"Hey! What is file number 7? Give it to me, I have something to write in it."</em> (understanding what a C <a href="https://www.geeksforgeeks.org/fork-system-call/" rel="nofollow noreferrer"><code>fork</code></a> does is quite helpful here)</p>
<p>Basically, the spawned subprocess doesn't <em>understand</em> your <code>Logger</code> class. It just knows it has to write its stuff to a file: a file which is uniquely identified within the O.S with a number and that unless otherwise specified, that number corresponds with the file descriptor of the standard output (but as explained in the case #2 below, you can change it if you want)</p>
<p>So you have several "solutions"... </p>
<ol>
<li><p>Clone (<a href="https://en.wikipedia.org/wiki/Tee_(command)" rel="nofollow noreferrer">tee</a>) stdout to a file, so when something is written to stdout, the operative system ALSO writes it to your file (this is really not Python-related... it's OS related):</p>
<pre><code>import os
import tempfile
import subprocess

file_log = os.path.join(tempfile.gettempdir(), 'foo.txt')
p = subprocess.Popen("python ./run_something.py | tee %s" % file_log, shell=True)
p.wait()
</code></pre></li>
<li><p>Choose whether to write to terminal <strong>OR</strong> to the file using the <code>fileno()</code> function of each. For instance, to write <em>only</em> to the file:</p>
<pre><code>import os
import tempfile
import subprocess

file_log = os.path.join(tempfile.gettempdir(), 'foo.txt')
with open(file_log, 'w') as f:
    p = subprocess.Popen("python ./run_something.py", shell=True, stdout=f.fileno())
    p.wait()
</code></pre></li>
<li><p>What I personally find "safer" (I don't feel confortable overwriting <code>sys.stdout</code>): Just let the command run and store its output into a variable and pick it up later (in the parent process):</p>
<pre><code>import os
import tempfile
import subprocess

p = subprocess.Popen("python ./run_something.py", shell=True, stdout=subprocess.PIPE)
p.wait()
contents = p.stdout.read()
# Whatever the output of Subprocess was is now stored in 'contents'
# Let's write it to file:
file_log = os.path.join(tempfile.gettempdir(), 'foo.txt')
with open(file_log, 'w') as f:
    f.write(contents)
</code></pre>
<p>This way, you can also do a <code>print(contents)</code> somewhere in your code to output whatever the subprocess "said" to the terminal.</p></li>
</ol>
<p>For example purposes, the script "./run_something.py" is just this:</p>
<pre><code>print("Foo1")
print("Foo2")
print("Foo3")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do you really need <code>subprocess.Popen</code>'s <code>communicate()</code> method? It looks like you just want the output. That's what <code>subprocess.check_output()</code> is for.</p>
<p>If you use that, you can use the built-in <a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer">logging</a> module for "tee"-ing the output stream to multiple destinations.</p>
<pre><code>import logging
import subprocess
import sys

EXTERNAL_SCRIPT_PATH = '/path/to/talker.py'
LOG_FILE_PATH = '/path/to/debug.log'

logger = logging.getLogger('')
logger.setLevel(logging.INFO)

# Log to screen
console_logger = logging.StreamHandler(sys.stdout)
logger.addHandler(console_logger)

# Log to file
file_logger = logging.FileHandler(LOG_FILE_PATH)
logger.addHandler(file_logger)

# Driver script output
logger.info('Calling external script')

# External script output
logger.info(
    subprocess.check_output(EXTERNAL_SCRIPT_PATH, shell=True)
)

# More driver script output
logger.info('Finished calling external script')
</code></pre>
<p>As always, be careful with <code>shell=True</code>. If you can write the call as <code>subprocess.check_output(['/path/to/script.py', 'arg1', 'arg2'])</code>, do so!</p>
</div>
<span class="comment-copy">You can <code>self.log.flush()</code> after every write. Essentially Python will wait to write to the file until it has enough data in the buffer, or the file handle is closed (for instance when the application stops).</span>
<span class="comment-copy">I just tried inserting <code>self.log.flush()</code> after <code>self.log.write(message)</code>. Doing this did not change anything. The .txt file still does not contain the <code>print</code> text from the external script.</span>
<span class="comment-copy">Hold on, this script is rather dangerous. Furthermore your program nowhere prints the argument at all. So I guess this is only the shell itself that prints the argument.</span>
<span class="comment-copy">In <code>write</code>, open the file an write to it instead of using reference to an open file as an instance attribute.  Dues that work.</span>
<span class="comment-copy">Sorry, I don't quite know how to implement this</span>
<span class="comment-copy">I ended up going with Solution #3. It works great. I can simply <code>print(contents)</code>, and the .txt log then reflects the <code>contents</code>. I appreciate the detailed answer.</span>
<span class="comment-copy">Sure... And yeah, to me it was very important to understand that <i>processes</i> (threads are something different) basically can only communicate with each other through files (in one shape or another, but in the end, files, after all) It's like having two completely separate "things" that both use a common file to "talk" (call it queue, call it buffer... same idea): process-1 writes to a file and process-2 reads from it, and many other variations, but the files are pretty much the only thing that can "link" processes together</span>
