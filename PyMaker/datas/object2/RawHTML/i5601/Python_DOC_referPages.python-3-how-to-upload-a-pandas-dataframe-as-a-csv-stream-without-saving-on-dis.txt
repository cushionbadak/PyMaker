<div class="post-text" itemprop="text">
<p>I want to upload a pandas dataframe to a server as csv file without saving it on the disc. Is there a way to create a more or less "fake csv" file which pretends to be a real file?</p>
<p>Here is some example code:
First I get my data from a sql query and storing it as a dataframe.
In the upload_ga_data function I want to have something with this logic</p>
<pre><code> media = MediaFileUpload('df',
                      mimetype='application/octet-stream',
                      resumable=False)
</code></pre>
<p>Full example:</p>
<pre><code>from __future__ import print_function
from apiclient.discovery import build
from oauth2client.service_account import ServiceAccountCredentials
from googleapiclient.errors import HttpError
from apiclient.http import MediaFileUpload
import pymysql
import pandas as pd
con = x

ga_query = """
    SELECT XXXXX
    """

df = pd.read_sql_query(ga_query,con)

df.to_csv('ga_export.csv', sep=',', encoding='utf-8', index = False)

def upload_ga_data():
    try:
        media = MediaFileUpload('ga_export.csv',
                          mimetype='application/octet-stream',
                          resumable=False)
        daily_upload = service.management().uploads().uploadData(
                accountId=accountId,
                webPropertyId=webPropertyId,
                customDataSourceId=customDataSourceId,
                media_body=media).execute()
        print ("Upload was successfull")
    except TypeError as error:
      # Handle errors in constructing a query.
      print ('There was an error in constructing your query : %s' % error)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The required behavior is possible using <a href="https://docs.python.org/3/library/io.html" rel="nofollow noreferrer">stream</a>:</p>
<blockquote>
<p>to create a more or less "fake csv" file which pretends to be a real file</p>
</blockquote>
<p>Python makes <em>File Descriptor</em> (with <code>open</code>) and <em>Stream</em> (with <code>io.StringIO</code>) behave similarly. Then anywhere you can use a file descriptor can also use a String Stream.</p>
<blockquote>
<p>The easiest way to create a text stream is with open(), optionally
  specifying an encoding:</p>
<pre><code>f = open("myfile.txt", "r", encoding="utf-8")
</code></pre>
<p>In-memory text streams are also available as StringIO objects:</p>
<pre><code>f = io.StringIO("some initial text data")
</code></pre>
<p>The text stream API is described in detail in the documentation of
  TextIOBase.</p>
</blockquote>
<p>In Pandas you can do it with any <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_csv.html" rel="nofollow noreferrer">function</a> having <code>path_or_buf</code> argument in its <a href="https://en.wikipedia.org/wiki/Type_signature" rel="nofollow noreferrer">signature</a>, such as <code>to_csv</code>:</p>
<blockquote>
<p><code>DataFrame.to_csv(</code><strong><code>path_or_buf</code></strong><code>=None, sep=', ', na_rep='', float_format=None, columns=None, header=True, index=True, index_label=None, mode='w', encoding=None, compression=None, quoting=None, quotechar='"', line_terminator='\n', chunksize=None, tupleize_cols=None, date_format=None, doublequote=True, escapechar=None, decimal='.')</code></p>
</blockquote>
<p>Following code exports a dummy DataFrame in CSV format into a String Stream (not physical file, in-memory octet-stream):</p>
<pre><code>import io
import pandas as pd

df = pd.DataFrame(list(range(10)))

stream = io.StringIO()
df.to_csv(stream, sep=";")
</code></pre>
<p>When you want to get access to the stream content, just issue:</p>
<pre><code>&gt;&gt;&gt; stream.getvalue()
';0\n0;0\n1;1\n2;2\n3;3\n4;4\n5;5\n6;6\n7;7\n8;8\n9;9\n'
</code></pre>
<p>It returns the content without having the need to use a real file.</p>
</div>
