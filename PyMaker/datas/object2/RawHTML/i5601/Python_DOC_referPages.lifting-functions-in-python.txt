<div class="post-text" itemprop="text">
<p>Say you have a function <code>f:integers -&gt; integers</code>, one should be able to lift this function to act on sets of integers. </p>
<p>I.e. <code>f:sets of integers -&gt; sets of integers</code>, by <code>f({a,b,...}) = {f(a),f(b),...}</code></p>
<p>How can one do this succinctly in python? That is, not involving iterables (loops), potentially something more native and order-independent.</p>
<p>I would expect <code>f({a,b,...})</code> to be the syntax, but it's not. Maybe something like <code>act(f,{a,b,...})</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python 2.7.10</strong></p>
<p>What you described is mapping; it does involve loops in the background, but it achieves your succinctness. Here's an example.</p>
<pre><code>l = [1,2,3]   

#f returns n^2
def f(n):
    return n*n

l = map(f, l) #[1,4,9]
</code></pre>
<p><code>map</code> applies the function <code>f</code> to every element of <code>l</code>.</p>
<p><code>map</code> also works on sets; however, map returns back a list of values e.g. <code>f({x1,x2,x3}) = [f(x1),f(x2),f(x3)]</code>, in an arbitrary order. You can turn the returned list back into a set by wrapping it as a <code>set</code>. </p>
<p><strong>Python 3.6</strong></p>
<p>In Python 3.6, <code>map</code> returns back a map object, and you will need to convert it to your desired typed. This example shows the map object converted to a list. </p>
<pre><code>l = [1,2,3]
def f(n):
    return n*n
l = list(map(f, l)) #[1,4,9]
</code></pre>
<p>Alternatively, you can reduce the amount of code further using lambda functions, making it more succinct. </p>
<pre><code>l = [1,2,3]
l = map(lambda x:x*x, l)
</code></pre>
<p>Where the lambda expression has the functionality <code>f</code> but used only there and non-existent afterwards. </p>
</div>
<div class="post-text" itemprop="text">
<p>The tools you want are <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer">map</a>, and in <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a>.</p>
<p>For example, to apply <code>f</code> on a collection <code>c</code> of elements, you can use</p>
<pre><code>map(f, c)
</code></pre>
<p>Note that the application is lazy in Python 3, and eager in Python 2.7. Alternatively, you can also use a lazy comprehension:</p>
<pre><code>g(f(x) for x in c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can pass multiple arguments as well , like this:</p>
<pre><code>def square(*args) :
    l = []
    for i in args:
        l.append(i**2)
    return l
</code></pre>
<p>It'll return like:</p>
<pre><code>&gt;&gt;&gt;&gt; square(1,2,3,4)
&gt;&gt;&gt;&gt; [1,2,9,16]
&gt;&gt;&gt;&gt; square(1)
&gt;&gt;&gt;&gt; [1]
&gt;&gt;&gt;&gt; square(1,6)
&gt;&gt;&gt;&gt; [1,36]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python currying is not a native feature but you can emulate it using <code>functools.partial</code>. For instance, you can use <code>partial</code> to lift a function <code>f: A -&gt; B</code> to a function <code>f': [A] -&gt; [B]</code>.</p>
<pre><code>from functools import partial
def f(...):
    ...

# lift f
f_lifted = partial(map, f)
</code></pre>
</div>
<span class="comment-copy">you mean set comprehension? <code>print({f(x) for x in {1,2,3}})</code> or <code>set(map(f,{1,2,3}))</code></span>
<span class="comment-copy">note that sets are unordered so order of the result may not match order of the input.</span>
<span class="comment-copy">There's no way to do this without involving iteration. Sure, you can <code>map</code> it but, that's iteration too. You're probably after <code>map</code>, though.</span>
<span class="comment-copy">Sweet, Jean's answer is what I was looking for.   &gt;There's no way to do with without involving iteration   So I might be naive, but if one were able to compute on a GPU, would this "map" function still be iterable, or would the computations be done in parallel?</span>
<span class="comment-copy">you need <code>multiprocessing.map</code> then</span>
<span class="comment-copy">Note that the behavior you display is Python 2 only, you need to wrap it in <code>list</code>.</span>
<span class="comment-copy">@JimFasarakisHilliard Good call! Let me update it my answer to show the 3.6 behavior.</span>
<span class="comment-copy">the issue with sets is undefined ordering. there's no way to associate inputs &amp; outputs.</span>
