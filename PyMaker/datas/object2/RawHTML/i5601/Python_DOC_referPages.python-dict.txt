<div class="post-text" itemprop="text">
<p>The attribute <code>__dict__</code> is supposed to contain user defined attributes. But if we print the <code>__dict__</code> of an empty class, I would also get: </p>
<pre><code>__module__
__dict__ 
__weakref__
__doc__
</code></pre>
<p>Which are prepopulated by Python in the <code>__dict__</code> attribute accordingly to the class object type.</p>
<p>Now, <code>__base__</code> and <code>__class__</code> are also Python defined attributes of a class object type, but not included in <code>__dict__</code>.</p>
<p>Is there any rule that specifies which dunder attribute is included in an object <code>__dict__</code> and which are not?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>The attribute <code>__dict__</code> is supposed to contain user defined attributes.</p>
</blockquote>
<p>No, the <code>__dict__</code> contains the <em>dynamic attributes</em> of an object. Those are not the only attributes an object can have however, the <em>type</em> of the object is usually also consulted to find attributes.</p>
<p>For example, the methods on a class can be found as attributes on an instance too. Many such attributes are <a href="https://docs.python.org/3/howto/descriptor.html" rel="noreferrer">descriptor objects</a> and are <em>bound</em> to the object when looked up. This is the job of the <code>__getattribute__</code> method all classes inherit from <code>object</code>; attributes on an object are resolved via <code>type(object).__getattribute__(attribute_name)</code>, at which point the descriptors on the type as well as attributes directly set on the object (in the <code>__dict__</code> mapping) are considered.</p>
<p>The <code>__bases__</code> attribute of a class is provided by the class metatype, which is <code>type()</code> by default; it is a descriptor:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     pass
...
&gt;&gt;&gt; Foo.__bases__
(&lt;class 'object'&gt;,)
&gt;&gt;&gt; type.__dict__['__bases__']
&lt;attribute '__bases__' of 'type' objects&gt;
&gt;&gt;&gt; type.__dict__['__bases__'].__get__(Foo, type)
(&lt;class 'object'&gt;,)
</code></pre>
<p><code>__dict__</code> just happens to be a place to store attributes that can have any valid string name. For classes that includes several standard attributes set when the class is created (<code>__module__</code> and <code>__doc__</code>), and others that are there as descriptors for instances of a class (<code>__dict__</code> and <code>__weakref__</code>). The latter must be added to the <em>class</em>, because a class itself also has those attributes, taken from <code>type</code>, again as descriptors.</p>
<p>So why is <code>__bases__</code> a descriptor, but <code>__doc__</code> is not? You can't set <code>__bases__</code> to just anything, so the descriptor setter checks for specific conditions and is an opportunity to rebuild internal caches. The Python core developers use descriptors to restrict what can be set, or when setting a value requires additional work (like validation and updating internal structures).</p>
</div>
<span class="comment-copy">Thank you very much @Martijn for your answer. It was very helpful.</span>
<span class="comment-copy"><a href="https://ideone.com/Qv2EHe" rel="nofollow noreferrer"><code>__bases__</code> is writeable</a> (at least, for the same classes where <code>__doc__</code> is writeable). It's a descriptor because setting it requires extra handling that wouldn't have fit well in <code>type.__setattr__</code>, and because it's more convenient (and more efficient) for the implementation to store the underlying data in a dedicated slot in the class's memory layout instead of putting it in the associated dict.</span>
<span class="comment-copy">@user2357112: yes, of course, updated the wording.</span>
