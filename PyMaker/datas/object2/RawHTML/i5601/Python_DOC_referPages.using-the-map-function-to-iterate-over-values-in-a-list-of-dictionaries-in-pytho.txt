<div class="post-text" itemprop="text">
<p>I've been trying to process data stored in a list of dictionaries, and store it in another list of tuples. For example say i have the following data:</p>
<pre><code>triangles= [{"name": "triangle1", "base":3, "height":4}, 
            {"name": "triangle2", "base":5, "height":12}, 
            {"name": "triangle3", "base":8, "height":15}
           ]
</code></pre>
<p>And I want to run all the data through the following function which i cannot change:</p>
<pre><code>def hypotenuse(base, height):
    hyp_sq=base**2+height**2

    return hyp_sq**(1.0/2.0)
</code></pre>
<p>Ideally, after computing all the data, I want to sort the triangles based on their hypotenuse length and I want to return a list of tuples in the following format:</p>
<pre><code>hypotenuse_results=[("triangle1", 5), ("triangle2", 13), ("triangle3", 17)]
</code></pre>
<p>I know I have to use the map() function in conjunction with sorted() but I have no idea how to pass only the values corresponding to "base" and "height" keys. </p>
<p>If someone could point me in the right direction, it would be greatly appreciated.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>You need do modify you hypotenuse function, for some like this:</p>
<pre><code>def hypotenuse(triangle):
    hyp_sq=triangle["base"]**2 + triangle["height"]**2
    return (triangle["name"], hyp_sq**(1.0/2.0))
</code></pre>
<p>map will returns a generator of tuples, when, each tuple is (name, hyp), so, just sort using the second element of tuple:</p>
<pre><code>sorted(map(hypotenuse, triangles), key=lambda x: x[1])
</code></pre>
<p>UPDATE:</p>
<p>Cause you can't change hypotenuse function, you can just use list comprehension:</p>
<pre><code>sorted([(t['name'], hypotenuse(t['base'], t['height'])) for t in triangles], key=lambda x: x[1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Around 1993, Python got lambda, reduce(), filter() and map(), courtesy of a Lisp hacker who missed them and submitted working patches. These Lisp-flavored constructs are considered a little alien in Python specially after the introduction of list comprehensions in 2000. So no, you don't need map, you can use list comprehensions or generator expressions.</p>
<p>You can let your <code>hypotenuse</code> function take extra arguments and ignore them:</p>
<pre><code>def hypotenuse(base, height, **kwargs):
    hyp_sq=base**2+height**2
    return hyp_sq**(1.0/2.0)
</code></pre>
<p>Then you can use a list comprehension:</p>
<pre><code>hypotenuse_results = [(t['name'], hypotenuse(**t)) for t in triangles]
hypotenuse_results.sort(key=lambda pair: pair[1])
</code></pre>
<p>This should perform well enough even for large <code>len(triangles)</code>. The generator expression version is:</p>
<pre><code>unsorted_results = ((t['name'], hypotenuse(**t)) for t in triangles)
hypotenuse_results = sorted(unsorted_results, key=lambda pair: pair[1])
</code></pre>
<p>Profiling both solutions and posting here would be a great exercise.</p>
<blockquote>
<p>thanks. is there a way to this without modifying the hypotenuse function? â€“ canecse</p>
</blockquote>
<p>Sure! Just call it with both arguments:</p>
<pre><code>hypotenuse_results = [(t['name'], hypotenuse(t['base'], t['height'])) for t in triangles]
hypotenuse_results.sort(key=lambda pair: pair[1])
</code></pre>
<p>Note that the accepted solution is allocating an actual list and trowing it away so you may want to use a generator expression instead of a list comprehension if you are concerned about memory footprint (specially useful if <code>len(triangles)</code> is big but always a good habit):</p>
<pre><code>hypotenuse_results = sorted(
    ((t['name'], hypotenuse(t['base'], t['height'])) for t in triangles), 
    key=lambda x: x[1]
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since your <code>hypotenuse</code> function works fine here, you can construct a comprehension to create your list of tuples:</p>
<pre><code>from operator import itemgetter

result = sorted(((x['name'], hypotenuse(x['base'], x['height'])) for x in triangles), key = itemgetter(1))

print(result)
</code></pre>
<p>Which gives:</p>
<pre><code>[('triangle1', 5), ('triangle2', 13), ('triangle3', 17)]
</code></pre>
<p>or if you really wanted to use <code>map()</code>, you could try this:</p>
<pre><code>result = sorted(map(lambda x: (x['name'], hypotenuse(x['base'], x['height'])), triangles), key = itemgetter(1))
</code></pre>
<p><strong>Note:</strong> You can use <code>lambda x: x[1]</code> instead of <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter(1)</code></a>. It's just a matter of preference here. If your interested, you can read <a href="https://stackoverflow.com/questions/17243620/operator-itemgetter-or-lambda/17243726">this</a> to see the performance between the two, and their respective pros and cons. </p>
<p><strong>UPDATE:</strong></p>
<p>@Paulo Scardine pointed out in the comments that if <code>triangle</code> gets bigger in the future, using a generator expression within <code>sorted()</code> is more efficient. This is because the list comprehension creates a list on the spot, but <code>sorted()</code> removes this list anyways in the process, so its a waste to pass in a list when its not needed. This isn't a problem for the second example, since <code>map()</code> already returns a generator. I updated the above code to account for these recommendations. </p>
</div>
<span class="comment-copy">Do you <i>have</i> to use <code>map()</code>?  Or you just think you need to?</span>
<span class="comment-copy">I thought I needed to. Map lets you run a function over a list right?</span>
<span class="comment-copy">This solves the problem. But what if i couldn't modify the function hypotenuse as the function in the actual problem given to me is imported through a library.</span>
<span class="comment-copy">@canecse if you can't change the function, you can't use map in this case, cause original hypotenuse function just return a value without triangle name, so, map generator returns a list of hypo values, but, you need a list of tuples.</span>
<span class="comment-copy">You could create another function, can be a lambda, and call hypotenuse and create a tuple like you want, like this: <code>sorted(map(lambda t: (t['name'], hypotenuse(t['base'], t['height'])), triangles), key=lambda x: x[1])</code></span>
<span class="comment-copy">thanks. is there a way to this without modifying the hypotenuse function?</span>
<span class="comment-copy">Sure! Call it like <code>hypotenuse(t['base'], t['height'])</code>.</span>
<span class="comment-copy">@canecse Just change <code>hypotenuse(**t)</code> to <code>hypotenuse(t["base"],t["height"])</code> but if you can't edit the function then that is the sort of information you should put in the question</span>
<span class="comment-copy"><code>sorted([(t['name'], hypotenuse(t['base'], t['height'])) for t in triangles], key=lambda t: t[1])</code></span>
<span class="comment-copy">@NickA. true I forgot mentioning that. thanks.</span>
<span class="comment-copy">@NickA Look <a href="https://stackoverflow.com/questions/17243620/operator-itemgetter-or-lambda/17243726">here</a>, it's performance is slightly better. Shouldn't make a difference here, I'm just used to using it.</span>
<span class="comment-copy">Also, <code>itemgetter(1)</code> is imho slightly easier to understand then <code>lambda x: x[1]</code>, same as its cousin <code>attrgetter(name)</code></span>
<span class="comment-copy">@mata I couldn't agree more. It's also more flexible in my opinion. One instance where I've found a big difference is getting a number of elements at once: <code>itemgetter(2,4,6)</code> vs <code>lambda x: (x[2], x[4], x[6])</code>. I prefer the first way by far.</span>
<span class="comment-copy">Good answer. For small <code>len(triangles)</code> it does not matter but for larger inputs a generator expression is better (since the list comprehension is allocating an actual list that <code>sorted</code> is throwing away).</span>
<span class="comment-copy">@NickA You have a point there. Ill remove the cast then.</span>
