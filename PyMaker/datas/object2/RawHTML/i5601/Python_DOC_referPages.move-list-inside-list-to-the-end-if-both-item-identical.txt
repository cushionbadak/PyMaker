<div class="post-text" itemprop="text">
<p>I have the following list of paired values :</p>
<pre><code>a = [['A', 'B'], ['A', 'C'], ['D', 'D'], ['C', 'D']]
</code></pre>
<p>This list can contain one or more remarkable pairs that are made of the same item:</p>
<p><code>['D', 'D']</code></p>
<p>I'd like to move those pairs to the end of the list to obtain :</p>
<pre><code>a = [['A', 'B'], ['A', 'C'], ['C', 'D'], ['D', 'D']]
</code></pre>
<p>I can't figure it out, but I believe I'm not too far:</p>
<pre><code>a.append(a.pop(x) for x in range(len(a)) if a[x][0] == a[x][1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Straight-forward <a href="https://docs.python.org/3/howto/sorting.html#sorting-basics" rel="noreferrer">sorting</a>:</p>
<pre><code>a = [['A', 'B'], ['A', 'C'], ['D', 'D'], ['C', 'D']]
a = sorted(a, key=lambda x: x[0] == x[1])
# [['A', 'B'], ['A', 'C'], ['C', 'D'], ['D', 'D']]
</code></pre>
<p>This simple <a href="https://docs.python.org/3/howto/sorting.html#key-functions" rel="noreferrer">key function</a> works because <code>False</code> is sorted before <code>True</code> while mapping all pairs to only two keys maintains <a href="https://docs.python.org/3/howto/sorting.html#sort-stability-and-complex-sorts" rel="noreferrer">stability</a>. The downside to this approach is that sorting is <code>O(N_logN)</code>. For a linear solution without unecessary list concatenations, you could use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain</code></a> with appropriate generators:</p>
<pre><code>from itertools import chain
a = list(chain((p for p in a if p[0] != p[1]), (p for p in a if p[0] == p[1])))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use list comprehensions:</p>
<pre><code>a = [pair for pair in a if pair[0] != pair[1]] + [pair for pair in a if pair[0] == pair[1]]
</code></pre>
<p>Note that a more efficient solution would be</p>
<pre><code>identical = []
not_identical = []
for pair in a:
    if pair[0] == pair[1]:
        identical.append(pair)
    else:
        not_identical.append(pair)
a = not_identical + identical
</code></pre>
<p>It is more efficient, as here you iterate <code>a</code> only once, whereas in the list comprehensions solution, you iterate <code>a</code> twice. Still, both solutions take <code>O(n)</code> time complexity and <code>O(n)</code> space complexity, which are better (and more natural for this problem), than a sorting solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want your original solution to work, you can do something simple like this instead:</p>
<pre><code>a = [['A', 'B'], ['A', 'C'], ['D', 'D'], ['C', 'D']]

for i, pair in enumerate(a):
    if pair[0] == pair[1]:
        a.append(a.pop(i))

print(a)
# [['A', 'B'], ['A', 'C'], ['C', 'D'], ['D', 'D']]
</code></pre>
<p>This however is <code>O(N^2)</code>, because of <code>pop(i)</code> in the for loop, which is <code>O(N)</code> itself. <code>pop()</code> is only <code>O(1)</code> if you pop from the end of a list.</p>
<p>You could also group using a dictionary by the length of lists sets, which is <code>O(N)</code> if you avoid sorting at the end and just use <code>min()</code> and <code>max()</code>, both of which are <code>O(N)</code> operations. </p>
<p>Here is an example:</p>
<pre><code>from collections import defaultdict

a = [['A', 'B'], ['A', 'C'], ['D', 'D'], ['C', 'D']]

d = defaultdict(list)
for sublst in a:
    key = len(set(sublst))
    d[key].append(sublst)

result = result = d[max(d)] + d[min(d)]

print(result)
# [['A', 'B'], ['A', 'C'], ['C', 'D'], ['D', 'D']]
</code></pre>
<p>Of course, as shown by @schwobaseggl, you can also accept the <code>O(NlogN)</code> approach of sorting:</p>
<pre><code>sorted(a, key = lambda x: -len(set(x)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just collect all the duplicates in a list and at last extend the list :</p>
<pre><code>a = [['A', 'B'], ['A', 'C'], ['D', 'D'], ['C', 'D']]

no_dub=[]
dub=[]
for i in a:
    if i[0]==i[1]:
        dub.append(i)
    else:
        no_dub.append(i)

no_dub.extend(dub)
print(no_dub)
</code></pre>
<p>output:</p>
<pre><code>[['A', 'B'], ['A', 'C'], ['C', 'D'], ['D', 'D']]
</code></pre>
</div>
<span class="comment-copy"><code>a = [pair for pair in a if pair[0] != pair[1]] + [pair for pair in a if pair[0] == pair[1]]</code></span>
<span class="comment-copy">Note that sorting takes <code>O(nlogn)</code> while my solution below takes <code>O(n)</code>. A very creative solution though</span>
<span class="comment-copy">@SomethingSomething True.</span>
<span class="comment-copy">@SomethingSomething Can you please demonstrate that it's only O(nlogn)? I'm trying to but so far failed. When I sort random floats I do observe O(nlogn) behavior but when I sort random bools I observe O(n) behavior.</span>
<span class="comment-copy">@StefanPochmann I don't know what sorting algorithms are used there. In the general case, when there is no restriction on the type and the range of the input, a sorting cannot take less than <code>O(nlogn)</code> time complexity. That is what I meant. Maybe Python checks the type of the input and uses <code>O(n)</code> algorithms that can run under certain conditions.</span>
<span class="comment-copy">Ok I think I now know why. Maybe I'll write a question+answer about it, but I'd first need to fully read what Timsort does in order to be sure...</span>
<span class="comment-copy">I doubt that the second will be more efficient. While it is true that you are only iterating the list once instead of twice, but the highly optimized comprehension should make more than up for that.</span>
<span class="comment-copy">@schwobaseggl agreed. I wonder why this answer does not get upvotes. Maybe people who ask such a basic question feel bad when they see Python's list comprehensions (else they would probably not ask the question)</span>
<span class="comment-copy">Despite its higher time complexity, I guess mine is simpler and more concise and performance won't be an issue even for very long lists (as log(n) doesn't grow that fast). Add to that that list concatenation is <code>O(M+N)</code> which is unnecessary and that users tend to trust rep without proper checking ;)</span>
<span class="comment-copy">I generally agree with you. <code>O(N+M)</code> is <code>O(n)</code> here, since if the first list is <code>O(n)</code> then <code>M+N = n</code>. Anyway, as you say, whereas <code>n</code> is sane, a sorting is totally fine. Liked your answer</span>
