<div class="post-text" itemprop="text">
<p>If I have the following architecture...</p>
<p><strong>Please note the edits below. It occurred to me (after some recent refactoring) that there are actually three classes in three different files. Sorry that the file/class names are getting ridiculous. I assure you those are not the real names. :)</strong></p>
<pre><code>main_class.py

class MainClass(object):
    def do_some_stuff(self):
        dependent_class = DependentClass()



dependent_class.py

class DependentClass(object):
    def __init__():
        dependent_dependent_class = DependentDependentClass()
        dependent_dependent_class.do_dependent_stuff()



dependent_dependent_class.py

class DependentDependentClass(object):
    def do_dependent_stuff(self):
        print "I'm gonna do production stuff that I want to mock"
        print "Like access a database or interact with a remote server"

class MockDependentDependentClass(object):
    def do_dependent_stuff(self):
        print "Respond as if the production stuff was all successful."
</code></pre>
<p>and I want to call <code>main_class.do_some_stuff</code> during testing but, during its execution, I want instances of <code>DependentDependentClass</code> replaced with <code>MockDependentDependentClass</code> how can I do that pythonically using best practices.</p>
<p>Currently, the best thing I could come up with is to conditionally instantiate one class or the other based on the presence/value of an environment variable. It certainly works but is pretty dirty.</p>
<p>I spent some time reading about the unittest.mock and mock.patch functions and they seem like they might be able to help but each description that I could wrap my head around seemed to be a little different than my actual use case.</p>
<p>The key is that I don't want to define mock return values or attributes but that I want the namespace changed, globally, I guess, such that when my application thinks it is instantiating DependentClass it is actually instantiating MockDependentClass.</p>
<p>The fact that I can't find any examples of anyone doing exactly this means one of two things:</p>
<ol>
<li>It's because I'm doing it in a very dumb/naive way.</li>
<li>I'm doing something so genius no else has ever encountered it.</li>
</ol>
<p>... I assume it's number 1...</p>
<p>Full disclosure, unit testing is not something with which I am skilled. It's an effort that my internal tools development team is trying to catch up to step our game up a bit. It's possible that I'm not thinking about testing correctly.</p>
<p>Any thoughts would be most welcome. Thank you, in advance!</p>
<p><strong>SOLUTION!!!</strong></p>
<p>Thanks to @de1 for the help. Given my <em>clever</em> architecture shown above the following accomplishes what I want.</p>
<p><strong>The following code is located in <code>main_class.py</code></strong></p>
<pre><code>import dependent_class
from dependent_dependent_class import MockDependentDependentClass

with patch.object(dependent_class, "DependentDependentClass", MockDependentDependentClass):
    main_class = MainClass()
    main_class.do_some_stuff()
</code></pre>
<p>The code seems to (and hell if I know how it's doing this) manipulate the namespace within the module <code>dependent_class</code> so that, while inside the <code>with</code> block (that's a context manager for anyone who is hung up on that part) anything referring to the class object <code>DependentDependentClass</code> will actually be referencing <code>MockDependentDependentClass</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">mock module</a> does indeed seem to be a good fit in this case. You can specify the mock (your mock) to use when calling the various <code>patch</code> methods.</p>
<p>If you are importing only the class rather than the module you can patch the imported DependentDependentClass in DependentClass:</p>
<pre><code>import .DependentClass as dependent_class
from .DependentDependentClass import MockDependentDependentClass

with patch.object(dependent_class, 'DependentDependentClass', MockDependentDependentClass):
  # do something while class is patched
</code></pre>
<p>Alternatively:</p>
<pre><code>with patch('yourmodule.DependentClass.DependentDependentClass', MockDependentDependentClass):
  # do something while class is patched
</code></pre>
<p>or the following will only work if you are accessing the class via a module or import it after it is being patched:</p>
<pre><code>with patch('yourmodule.DependentDependentClass.DependentDependentClass', MockDependentDependentClass):
  # do something while class is patched
</code></pre>
<p>Just bare in mind what object is being patched, when.</p>
<p>Note: you might find it less confusing naming your files in lower case, slightly different to the embedded class(es).</p>
<p>Note 2: If you need to mock a dependency of a dependency of the module under test then it might suggest that you are not testing at the right level.</p>
</div>
<span class="comment-copy">Hmmm. Neither one seems to accomplish it for me. In the second example I assume that <code>dependent</code> as used in the <code>with</code> statement was supposed to be <code>dependent_class</code>?</span>
<span class="comment-copy">Yes, that's fixed. Not sure why it wouldn't work. It basically replaced <code>DependentClass</code> within the <code>DependentClass</code> module (for the duration of the context).</span>
<span class="comment-copy">My check consists of simple print statements in the <code>__init__()</code> methods of each class. One prints "REAL" the other prints "MOCK." With both approaches you showed I get "REAL."</span>
<span class="comment-copy">Are you sure you are instantiating <code>DependentClass</code> and in this case <code>MainClass</code> within the with statement?</span>
<span class="comment-copy">I am instantiating <code>MainClass</code> inside the with statement. <code>DependentClass</code> is being instantiated within <code>MainClass</code>'s <code>__init__()</code> in a different file. I think that the problem might be that the namespace change does not carry over to the other file. Maybe the example wasn't clear. Each mention of <code>something.py</code> was an indication of a separate source file.</span>
