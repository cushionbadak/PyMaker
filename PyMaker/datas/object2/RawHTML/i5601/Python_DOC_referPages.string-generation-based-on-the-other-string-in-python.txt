<div class="post-text" itemprop="text">
<p>I want to create a simple string generator and here is how it will work</p>
<ol>
<li>I declare a <code>pattern_string =  "abcdefghijklmnopqrstuvwxyz"</code></li>
<li>My starting string lets say <code>starting_string = "qywtx"</code></li>
<li>Now I want to generate strings as follows: </li>
<li>Check the last character in my <code>starting_string</code>against the pattern string.</li>
<li><p>Last character is <code>x</code>. We find this character in the find it in the <code>pattern_string</code>: </p>
<p>abcdefghijklmnopqrstuvw <strong>x</strong> yz</p>
<p>and see that next character is <code>y</code> so I want output <code>qywty</code>.
...</p></li>
</ol>
<p>However, when I reach the z, I want my string to increment second last character and set the last character to the first character of the <code>starting_pattern</code> so it will be <code>qywra</code> and so on...</p>
<p>Now questions:</p>
<ul>
<li><p>Can I use REGEX to achieve that?</p></li>
<li><p>Are there any libraries out there that already handle such generation?</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The following will generate the next string according to your description.</p>
<pre><code>def next(s, pat):
  l = len(s)
  for i in range(len(s) - 1, -1, -1):  # find the first non-'z' from the back
    if s[i] != pat[-1]:  # if you find it
      # leave everything before i as is, increment at i, reset rest to all 'a's
      return s[:i] + pat[pat.index(s[i]) + 1] + (l - i - 1) * pat[0]
  else:  # this is only reached for s == 'zzzzz'
    return (l + 1) * pat[0]  # and generates 'aaaaaa'  (just my assumption)

&gt;&gt;&gt; import string
&gt;&gt;&gt; pattern = string.ascii_lowercase  # 'abcde...xyz'
&gt;&gt;&gt; s = 'qywtx'
&gt;&gt;&gt; s = next(s, pattern)  # 'qywty'
&gt;&gt;&gt; s = next(s, pattern)  # 'qywtz'
&gt;&gt;&gt; s = next(s, pattern)  # 'qywua'
&gt;&gt;&gt; s = next(s, pattern)  # 'qywub'
</code></pre>
<p>For multiple <code>'z'</code> in the end:</p>
<pre><code>&gt;&gt;&gt; s = 'foozz'
&gt;&gt;&gt; s = next(s, lower)  # 'fopaa'
</code></pre>
<p>For all 'z', start over with 'a' of incremented length:</p>
<pre><code>&gt;&gt;&gt; s = 'zzz'
&gt;&gt;&gt; s = next(s, lower)  # 'aaaa'
</code></pre>
<p>To my knowledge there is no library function to do that. One that comes close is <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; list(map(''.join, product('abc', repeat=3)))
['aaa', 'aab', 'aac', 'aba', 'abb', 'abc', 'aca', 'acb', 'acc', 'baa', 
 'bab', 'bac', 'bba', 'bbb', 'bbc', 'bca', 'bcb', 'bcc', 'caa', 'cab',
 'cac', 'cba', 'cbb', 'cbc', 'cca', 'ccb', 'ccc']
</code></pre>
<p>But that doesn't not work with an arbitrary start string. This behaviour could be mimicked by combining it with <code>itertools.dropwhile</code> but that has the serious overhead of skipping all the combinations before the start string (which in the case of an alphabet of 26 and a start string towards the end pretty much renders that approach useless):</p>
<pre><code>&gt;&gt;&gt; list(dropwhile(lambda s: s != 'bba', map(''.join, product('abc', repeat=3))))
['bba', 'bbb', 'bbc', 'bca', 'bcb', 'bcc', 'caa', 'cab', 'cac', 'cba', 'cbb', 'cbc', 'cca', 'ccb', 'ccc']
</code></pre>
</div>
<span class="comment-copy">Shouldn't the order you describe be: <code>'qywtx' -&gt; 'qywty' -&gt; 'qywtz' -&gt; 'qywua'</code>?</span>
<span class="comment-copy">Hey @schwobaseggl you are right, I made a typo in my post thank you!</span>
