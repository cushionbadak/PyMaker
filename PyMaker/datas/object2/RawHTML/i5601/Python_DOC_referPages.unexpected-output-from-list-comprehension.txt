<div class="post-text" itemprop="text">
<p>I have an input list as follows:</p>
<pre><code>test_list = ['a', ('abc', 'd'), ['efgh', 'i'], 'jkl']
</code></pre>
<p>which I need to flatten, so getting rid of the tuple and list as respective second and third element of <code>test_list</code></p>
<p>Expected output:</p>
<pre><code>['a', 'abc', 'd', 'efgh', 'i', 'jkl']
</code></pre>
<p>I have a problem finding the correct list comprehension for this.
I have tried the following 2 examples:</p>
<pre><code>result = [xs if type(xs) is str else x for xs in test_list for x in xs]
print('result', result) 
# this outputs:
# ['a', 'abc', 'd', 'efgh', 'i', 'jkl', 'jkl', 'jkl']

result = [x if ((type(xs) is list) or (type(xs) is tuple)) else xs for xs in test_list for x in xs]
print('result',result)
#this also outputs:
# ['a', 'abc', 'd', 'efgh', 'i', 'jkl', 'jkl', 'jkl']  
</code></pre>
<p>as you can see, it does "flatten" the list, but it repeats the last element based on the number of characters in the last element. Example if the last element of the <code>test_list</code> is <code>'jklm'</code> then the in the <code>result</code> the last element is repeated 4 times.</p>
<p>I would like to know if there is a list comprehension which flatten my input list to the expected output without repeating the last element.</p>
</div>
<div class="post-text" itemprop="text">
<p>The following nested comprehension will work:</p>
<pre><code>[x for sub in test_list for x in (sub if isinstance(sub, (list, tuple)) else [sub])]
</code></pre>
<p>This uses <code>isinstance</code> which should preferred over <code>type(...)</code> and can be given multiple types. If any top level element is not a list or tuple, it is wrapped in a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try:</p>
<pre><code>test_list = ['a', ('abc', 'd'), ['efgh', 'i'], 'jkl']
result = [x for xs in test_list for x in (xs if isinstance(xs, (tuple, list)) else [xs])]
</code></pre>
<p>But I wouldn't use this, I would just write a for loop</p>
</div>
<div class="post-text" itemprop="text">
<p>You could always convert all single elements in <code>test_list</code> to lists:</p>
<pre><code>&gt;&gt;&gt; test_list = ['a', ('abc', 'd'), ['efgh', 'i'], 'jkl']
&gt;&gt;&gt; convert_to_lists = [[x] if not isinstance(x, (list, tuple)) else x for x in test_list]
&gt;&gt;&gt; convert_to_lists
[['a'], ('abc', 'd'), ['efgh', 'i'], ['jkl']]
</code></pre>
<p>Then just flatten this with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain_from_iterable</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; list(chain.from_iterable(convert_to_lists))
['a', 'abc', 'd', 'efgh', 'i', 'jkl']
</code></pre>
<p>or all in one line:</p>
<pre><code>list(chain.from_iterable([x] if not isinstance(x, (list, tuple)) else x for x in test_list))
</code></pre>
</div>
<span class="comment-copy">It doesn't just repeat the last element; it repeats <i>any</i> top-level element that is more than one letter long.</span>
<span class="comment-copy">What if the data is arbitrary nested?</span>
<span class="comment-copy">@JohnGordon thanks, I just noticed that too.</span>
<span class="comment-copy">@WillemVanOnsem not sure what you mean presisely, but data is not more than 1 level deep, e.g. the elements of test_list are either string, list_of_strings or tuple_of_strings. But tuples and lists can occur at any place in the test_list.</span>
<span class="comment-copy">@EdwinvanMierlo: for instance <code>[1, [2, [3,[4]],4,5], 6]</code>.</span>
<span class="comment-copy">I know I can do this in a for loop, and have done so, but I was looking for a comprehension. Could you elaborate why you would not use a list comprehension in this case ?</span>
<span class="comment-copy">@EdwinVanMierlo because it is clunky and inelegant. It's using a trick that won't be obvious if I read this a month later. It is long, and hard to read, IMO</span>
