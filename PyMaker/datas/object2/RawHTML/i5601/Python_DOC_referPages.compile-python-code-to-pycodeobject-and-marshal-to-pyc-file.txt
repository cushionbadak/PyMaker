<div class="post-text" itemprop="text">
<p>I try to compile python code to PyCodeObject and marshal to pyc file.
But when I import my pyc file, it fails and the traceback is "ValueError: bad marshal data (unknown type code)"
Here is my code</p>
<pre><code>import struct
import marshal
import time
import imp 
import sys 

def dump(co, filename):
    magic = imp.get_magic()
    time_string = struct.pack('L', int(time.time()))
    f = open("merge.pyc", "wb")
    f.write(magic)
    f.write(time_string)
    marshal.dump(dco, f)
    f.close()

demo = open("demo.py").read()
dco = compile(demo, "demo.py", "exec")
dump(dco, "dco.pyc")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I guess the <code>ValueError</code> raised is because of the mismatched type of timestamp. You should make sure the <code>fmt</code> parameter (<code>L</code> used, which standard size is 4 bytes) in <code>struct.pack</code> has the same length with your python executable.</p>
<p><strike>Since the value of timestamp do not effect on the final result, making the type suitable is enough here. Try to use <code>Q</code> instead of <code>L</code> to ensure 8 bytes if you are using 64bit version of CPython.</strike></p>
<p>=== UPDATED BEGIN ===</p>
<p>Sorry, I made a serious mistake in the previous description. </p>
<p><code>L</code> without any prefix, means <a href="https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment" rel="nofollow noreferrer">native</a>, and the size and byte order is the same to the machine’s native format and byte order (In 64bit CPython, it would be 8 bytes). However the timestamp written to <code>pyc</code> file is always be 4 bytes (little endian) in both Python 2 and 3. </p>
<p>If the used is Python2, we should use <code>&lt;L</code> instead of <code>L</code>, which has standard size, 4 bytes.</p>
<p>If the used is Python3, in additional to <code>timestamp</code>, we should add another 4 bytes field, <code>source size</code>, as the following code shown (<em>importlib/_bootstrap_external.py, Python3.6.4</em>)</p>
<pre><code>def _code_to_bytecode(code, mtime=0, source_size=0):
    """Compile a code object into bytecode for writing out to a byte-compiled
    file."""
    data = bytearray(MAGIC_NUMBER)
    data.extend(_w_long(mtime))
    data.extend(_w_long(source_size))
    data.extend(marshal.dumps(code))
    return data
</code></pre>
<p>At last, you could refer to <code>pkgutil.read_code()</code>, which is the reverse order of writing code.</p>
<p>=== UPDATED END ===</p>
<p>By the way, there are some defects in your code: Have not use the <code>co</code> and <code>filename</code> parameters in <code>dump</code> function</p>
</div>
<span class="comment-copy">In face, I just findout the problem one minute before. I use 64 bit python so I can change the "L" to "I" to ensure the byte of this part is 4. Any way thank you !</span>
<span class="comment-copy">By the way, which version of Python you used, 2 or 3?</span>
<span class="comment-copy">Sorry, I can't understand that why  the result of struct.calcsize('L') is 8  while struct.calcsize('&lt;L') is 4 in 64 bit python. Would you help me?</span>
<span class="comment-copy">I use 64 bit python 2.7.13</span>
<span class="comment-copy">According to the document of <code>struct</code> <a href="https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment" rel="nofollow noreferrer">docs.python.org/3/library/…</a>, <code>L</code> without any prefix, means native, which the size depends on the host system used, could either be 4 or 8. But <code>&gt;L</code> and <code>&lt;L</code> are different, their size are the standard size, 4 bytes.</span>
