<div class="post-text" itemprop="text">
<p>So I was trying to make a program that brute forces passwords. </p>
<p>Firstly, I made a program for a password of length 1:</p>
<pre><code>password = input('What is your password?\n')
chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

def brute_force():
    for char in chars:
        if char == password:
            return char

print(brute_force())
</code></pre>
<p>Then I edited it for a password of length 2:</p>
<pre><code>def brute_force():
    guess = [None, None]
    for char in chars:
        guess[0] = char
        for char2 in chars:
            guess[1] = char2
            if ''.join(guess) == password:
                return ''.join(guess)
</code></pre>
<p>Finally I did the same for a password of length 3:</p>
<pre><code>def brute_force():
    guess = [None, None, None]
    for char in chars:
        guess[0] = char
        for char2 in chars:
            guess[1] = char2
            for char3 in chars:
                guess[2] = char3
                if ''.join(guess) == password:
                    return ''.join(guess)
</code></pre>
<p>How could I generalize this for a variable called length which contains the integer value of the lenght of the password?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the following <em>recursive</em> function:</p>
<pre><code>def brute_force(string, length, goal):
    if not length:
        if string == goal:
            return string
        return False
    for c in chars:
         s = brute_force(string + c, length - 1, goal)
         if s:
             return s
    return False
</code></pre>
<p>which you can call with syntax like:</p>
<pre><code>&gt;&gt;&gt; brute_force('', 3, 'bob')
'bob'
&gt;&gt;&gt; brute_force('', 2, 'yo')
'yo'
</code></pre>
<hr/>
<p><strong>Why does this work?</strong></p>
<p>We always call each function with the three variables: <code>string</code>, <code>length</code> and <code>goal</code>. The variable <code>string</code> holds the current guess up to this point, so in the first example, <code>string</code> will be everything up to <code>bob</code> such as <code>ab</code>, <code>bo</code> etc.</p>
<p>The next variable <code>length</code> holds how many characters there are to go till the <code>string</code> is the right length.</p>
<p>The next variable <code>goal</code> is the correct password which we just pass through and is compare against.</p>
<p>In the main body of the function, we need to first check the case where <code>length</code> is <code>0</code> (done by checking <code>not length</code> as <code>0</code> evaluates to <code>False</code>). This is the case when we already have a string that is the length of the goal and we just want to check whether it is correct.</p>
<p>If it matches, then we return the string, otherwise we return <code>False</code>. We return either the solution or <code>False</code> to indicate to the function which called us (the call above in the stack) that we found the right password (or not).</p>
<p>We have now finished the case where <code>length = 0</code> and now need to handle the other cases.</p>
<p>In these cases, the aim is to take the string that we have been called with and loop through <em>all</em> of the characters in <code>chars</code>, each time calling the <code>brute_force</code> function (recursive) with the result of the concatenation of the string we were called with and that character (<code>c</code>). </p>
<p>This will create a tree like affect where <strong>every</strong> string up to the original <code>length</code> is checked.</p>
<p>We also need to know what to do with the <code>length</code> and <code>goal</code> variables when calling the next function.</p>
<p>Well, to handle these, we just need to think what the next function needs to know. It already has the <code>string</code> (as this was the result of concatenating the next character in the <code>chars</code> string) and the <code>length</code> is just going to be one less as we just added one to the <code>string</code> through the concatenation and the <code>goal</code> is clearly going to be the same - we are still searching for the same password.</p>
<p>Now that we have called this function, it will run through subtracting one from the length at each of the subsequent calls it makes until it eventually reaches the case where <code>length == 0</code>. And we are at the easy case again and already know what to do!</p>
<p>So, after calling it, the function will return one of two things, either <code>False</code> indicating that the last node did not find the password (so this would occur in the case where something like <code>ab</code> reached the end in our search for <code>bob</code> so returned <code>False</code> after no solution was found), or, the call could return the <em>actual</em> solution.</p>
<p>Handling these cases is simple, if we got the actual solution, we just want to return that up the chain and if we got a fail (<code>False</code>), we just want to return <code>False</code> And that will indicate to the node above us that we did not succeed and tell it to continue its search.</p>
<p>So now, we just need to know how to call the function. We just need to send in an empty <code>string</code> and a target <code>length</code> and <code>goal</code> value and let the recursion take place.</p>
<hr/>
<p>Note one last thing is that if you wanted this to be even neater, you could modify the function definition to:</p>
<pre><code>def brute_force(length, goal, string=''):
    ...
</code></pre>
<p>and change the recursive call within. This way, you could call the function with something just like: <code>brute_force(3, 'bob')</code> and wouldn't need to specify what <code>string</code> should start at. This is just something that you can add in if you want, but isn't necessary for the function to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the answer that shows you how this works, I'd like to draw attention to the fact that the standard library has a function for just this, in the shape of <code>itertools.product</code>â€”not <code>itertools.permutations</code> because that does not allow repetitions and therefore would only generate guesses with all unique characters:</p>
<pre><code>from itertools import product

def brute_force():
    for length in range(min_length, max_length + 1):
        for p in product(chars, repeat=length):
            guess = ''.join(p)
            if guess == password:
                return guess
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one solution:</p>
<pre><code>password = input('What is your password? ')
chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

def brute_force(length, check_callback, guess = ""):
    if check_callback(guess):
        return guess
    elif len(guess) == length: #Reached maximum length and didn't find the password
        return None
    for char in chars:
        retval = brute_force(length, check_callback, guess = guess + char)
        if retval is not None:
            return retval
    return None #Couldn't find anything

print(brute_force(len(password), lambda guess: (guess == password))) #len(password) =&gt; cheating just for this example
</code></pre>
<p><code>length</code> is the maximum guess length the function will go up to. <code>check_callback</code> should take a guess and return a truthy value if it worked. The function returns the first successful guess, or <code>None</code> if it couldn't find anything.</p>
<p>I will admit I forgot about the guess length and was reminded by <a href="https://stackoverflow.com/a/47953095">@Joe Iddon's answer</a>.</p>
<hr/>
<p>Now, that function checks for a correct answer even if the guess isn't the right length yet, which is wasteful in some circumstances. Here's a function that doesn't do that:</p>
<pre><code>def brute_force(length, check_callback, guess = ""):
    if len(guess) == length: #Reached maximum length
        return (guess if check_callback(guess) else None)
    for char in chars:
        retval = brute_force(length, check_callback, guess = guess + char)
        if retval is not None:
            return retval
    return None #Couldn't find anything
print(brute_force(len(password), lambda guess: guess == password)) #len(password) =&gt; cheating just for this example
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>password = input('What is your password?\n')
chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

answer = ''
for i in range(len(password)):
    for char in chars:
        if char==password[i]:
            answer += char

print(answer)
</code></pre>
<p>Instead of using nested loops it guesses each character in turn.</p>
</div>
<span class="comment-copy">Use <a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="nofollow noreferrer">recursion</a></span>
<span class="comment-copy">Have you thought about using <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">itertools.product</a>?</span>
<span class="comment-copy">Exactly what I meant, for completeness I would define chars within the function and you are good.</span>
<span class="comment-copy">Could you explain a bit more please? (I am new to recursive functions) Thanks.</span>
<span class="comment-copy">@MilanTom Ended up writing a fairly long explanation! Hope it makes sense now</span>
<span class="comment-copy">Presented like this, the function is almost useless and very inefficient. If you have the <code>goal</code>, all you'd need is to check that it has the correct length and that every character is <code>in chars</code>.</span>
<span class="comment-copy">@EricDuminil Well obviously! If they are asked to input their password, there is no need for any algorithm! Clearly if this were to be used in a real circumstance, the check would not simply be <code>== goal</code>, it would probably be another function of sorts that goes and does some hashing / encryption etc.</span>
<span class="comment-copy">Functional one-liner: <code>return next(filter(password.__eq__, map(''.join, itertools.chain.from_iterable(map(functools.partial(itertools.permutations, chars), range(min_length, max_length+1))))), None)</code></span>
<span class="comment-copy">You need <code>itertools.product</code>; permutations don't include duplicate characters.</span>
<span class="comment-copy">@JiK Ugh, you're right...</span>
<span class="comment-copy">@MilanTom Please note this answer has changed.</span>
<span class="comment-copy">Upvote for <code>check_callback</code>, which could be a hash calculation for example.</span>
<span class="comment-copy">This is ok but in application, you will only know if you got the password correct when you submit the whole password - even one character wrong will mean the password will be rejected.</span>
