<div class="post-text" itemprop="text">
<p>I have the following dictionary,</p>
<pre><code>&gt;&gt;&gt; names
{1: ('c1', 1), 2: ('c2', 2), 3: ('c1', 3), 4: ('c2', 4)}
</code></pre>
<p>What is the best way to eliminate keys with duplicate entries based on the first entry in the value i.e 1 and 3 are duplicates because of 'c1' and 2 and 4 are duplicates because of 'c2'?</p>
<p>I would like the final output to be something like this</p>
<pre><code>&gt;&gt;&gt; uniqueNames
{1: ('c1', 1), 2: ('c2', 2) }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Similar to how you would eliminate duplicates in a regular list while keeping the list's order. </p>
<p>The only real difference here is that dictionaries have no order, which means that iteration order through <code>names.items</code> is arbitrary so you will keep an arbitrary key-value pair with a unique first item for the value-tuple.</p>
<pre><code>&gt;&gt;&gt; names = {1: ('c1', 1), 2: ('c2', 2), 3: ('c1', 3), 4: ('c2', 4)}
&gt;&gt;&gt; 
&gt;&gt;&gt; seen = set()
&gt;&gt;&gt; unique_names = {}
&gt;&gt;&gt; 
&gt;&gt;&gt; for k, (v0, v1) in names.items():
...     if v0 not in seen:
...         unique_names[k] = (v0, v1)
...         seen.add(v0)
... 
&gt;&gt;&gt; unique_names
{1: ('c1', 1), 2: ('c2', 2)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is the cryptic one-liner such questions tend to elicit:</p>
<pre><code>unique_names = dict({i[1][0]: i for i in names.items()}.values())
</code></pre>
<p>If you want to guarantee to keep the smallest key:</p>
<pre><code>unique_names = dict({i[1][0]: i for i in sorted(names.items(), reverse=True)}.values())
</code></pre>
<p>Collects the old items as values to the keys to be uniquified and builds a new dict from the items that remain as values in said dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try: </p>
<pre><code>ulist = []      # unique-list
outdict = {}    # dict for output
for i in names.items():         # i will be as: (1, ('c1', 1))
    if i[1][0] not in ulist:
        ulist.append(i[1][0])   # add unique item to unique-list
        outdict[i[0]] = i[1]    # add entry to output dict
print(outdict)
</code></pre>
<p>Output:</p>
<pre><code>{1: ('c1', 1), 2: ('c2', 2)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could solve it like this:</p>
<pre><code>names = {1: ('c1', 1), 2: ('c2', 2), 3: ('c1', 3), 4: ('c2', 4)}

values_set = set()
unique_names = {}
for key, value in names.items():
    if value[0] not in values_set:
        values_set.add(value[0])
        unique_names[key] = value

print(unique_names)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do a set of first tuple values and then knowing what values are unique you can pop keys from the dict.</p>
<pre><code>&gt;&gt;&gt; temp = {1: ('a', '1'), 2: ('b', '2'), 3: ('a', '3'), 4: ('b', '4')}
&gt;&gt;&gt; uniques = set()
&gt;&gt;&gt; uniquedict = {}
&gt;&gt;&gt; for key, value in temp.iteritems():
...     if value[0] not in uniques:
...         uniques.update(value[0])
...         uniquedict[key]=value
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; uniquedict
{1: ('a', '1'), 2: ('b', '2')}
</code></pre>
<p>edit: this is for python 2.7, @mrCarnivore answer is for python 3</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3.6/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> to group what you want, and only take the first value:</p>
<pre><code>from collections import defaultdict

d = {1: ('c1', 1), 2: ('c2', 2), 3: ('c1', 3), 4: ('c2', 4)}

groups = defaultdict(list)
for num1, (entry, num2) in d.items():
    groups[entry].append((num1, num2))
# defaultdict(&lt;class 'list'&gt;, {'c1': [(1, 1), (3, 3)], 'c2': [(2, 2), (4, 4)]})

result = {v[0][0]:(k, v[0][1]) for k, v in groups.items()}

print(result)
# {1: ('c1', 1), 2: ('c2', 2)}
</code></pre>
<p>Or even with <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>grouped = [list(g) for _, g in groupby(sorted(d.items(), key = lambda x: x[1][0]), key = lambda x: x[1][0])]
# [[(1, ('c1', 1)), (3, ('c1', 3))], [(2, ('c2', 2)), (4, ('c2', 4))]]

result = {k: v for (k, v) in [x[0] for x in grouped]}

print(result)
# {1: ('c1', 1), 2: ('c2', 2)}
</code></pre>
</div>
<span class="comment-copy">Please show us what you have tried!</span>
<span class="comment-copy">How do you determine whether to keep <code>1</code> or <code>3</code>? There is no inherent order.</span>
<span class="comment-copy">You should use an OrderedDict if the order matters to you. That way only the first occurrence of the value will remain.</span>
<span class="comment-copy">Ok, that's clever and cool. Would take me a while staring down what's happening, though.</span>
<span class="comment-copy">@timgeb I agree, if in doubt (or at work) I'd always go with your explicit version. But I like how this wraps all those logical steps concisely.</span>
