<div class="post-text" itemprop="text">
<p>I was given this school project, which goal is to take a picture, apply the RLE method in order to compress it in a binary file (.txt), and save some space. And after struglling with it for 3 days now I'm having troubles.</p>
<pre><code>def lecture_fichier_compresse():
    f2=open("data2.txt",'rb') #open a binary file in reading mod.
    im3=zeros((962,800,3),dtype="uint8") #create picture which size is 962*800 where every pixels are coded on 3 bytes.
    d=0#pixel counter
    i=0#lign indexation
    j=0#column indexation
    b=ord(f2.read(1))# the informations are read a first time
    a=ord(f2.read(1))
    rouge=ord(f2.read(1))
    vert=ord(f2.read(1))
    bleu=ord(f2.read(1))
    while i!=im3.shape[0]: #as long as it doesn't reach the final lign
        if d&lt;=(a+b*255):
            im3[i,j,0] = rouge
            im3[i,j,1] = vert
            im3[i,j,2] = bleu
            d+=1
            j+=1
            if j==im3.shape[1]:
                j=0
                i+=1
        else: #resets pixel counter and starts reading next informations
            d=0
            b=ord(f2.read(1))
            a=ord(f2.read(1))
            rouge=ord(f2.read(1))
            vert=ord(f2.read(1))
            bleu=ord(f2.read(1))       
    f2.close()
    imsave("Copie_compresse.bmp",im3)
    return im3

imshow(lecture_fichier_compresse());show()
</code></pre>
<p>When I execute the pgrm, it gives me this error written in the tittle. Which is something I feel like impossible to correct, since it is writting itself in hex.</p>
<p>Here's further information :
A pixel is not coded here using bytes, like we usually do on format such as .bmp.
Here RLE will search for identic pixel on a same lign, and count how many times it encounters it, by comparing 3 levels colors. Finally it stores in two additional bytes than the RGB ones : a and b.
a is for the number of pixels.
b is the number of 255 stacks of pixels. (Since I'm coding data into 8bits and that pictures are usually larger than 255*255 size) </p>
</div>
<div class="post-text" itemprop="text">
<p>Your file is too short, your ran out of data. <code>file.read(..)</code> returns an empty string when the EOF is found. Perhaps your remaining bytes should just be left at 0?</p>
<p>You are reading your data extremely inefficiently. Use the <a href="https://docs.python.org/2/library/struct.html" rel="nofollow noreferrer"><code>struct</code> module</a> to unpack your data into integers, and create a single long numpy array of (R, G, B) triplets, then <em>reshape</em> the data to form your image matrix:</p>
<pre><code>import numpy as np
import struct

def lecture_fichier_compresse():
    width, height = 800, 962
    with open("data2.txt", 'rb') as rle_data:
        image = np.zeros((width * height, 3), dtype="uint8")
        pos = 0
        # decompress RLE data; 2 byte counter followed by 3 RGB bytes
        # read until the file is done
        for data in iter(lambda: rle_data.read(5), ''):
            if len(data) &lt; 5:
                # not enough data to store another RLE RGB chunk
                break
            count, r, g, b = struct.unpack('&gt;HBBB', data)
            image[pos:pos + count, :] = [[r, g, b]] * count
            pos += count
    # reshape continuous stream into an image matrix
    image = image.reshape((height, width, 3))
    imsave("Copie_compresse.bmp",im3)
    return image
</code></pre>
<p>That said, using your sample file data I can't seem to construct a coherent image. Decompression produces data for 695046 pixels, which doesn't make for a coherent rectangular image (the highest short dimension that numbers factors into is 66, so extremely elongated). Even allowing for missing data at the end I can't seem to find any aspect ratio that produces a coherent image. The conclusion is that your input data is incomplete or incorrect.</p>
</div>
<span class="comment-copy">The error indicates that one of your <code>f2.read(1)</code> calls returned an empty string; that happens when you have reached the end of the file.</span>
<span class="comment-copy">Well in that case, how can I prevent it ?</span>
<span class="comment-copy">Without the actual file input data, hard to say. Your file doesn't contain as much info as you expect it to contain.</span>
<span class="comment-copy">Moreover, i'd like to share the file data2 to show everybody how it gets stuck. Does anyone knows a site where I could store that binary file?</span>
<span class="comment-copy">You really want to study the <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer"><code>struct</code> module</a>, and avoid so many individual byte reads and <code>ord()</code> calls. Reading an integer from 2 bytes is trivial with that module.</span>
<span class="comment-copy">Thank you, however this is too advanced for me.</span>
<span class="comment-copy">@Oni_chan: it does the <i>exact same work</i>, only more efficient, and taking into account that the file doesn't contain enough data.</span>
<span class="comment-copy">But yeah now that you say that, the file is indeed too short. I just need a way to make it stop reading the moment it hits the last package of data</span>
<span class="comment-copy">@Oni_chan: the image dimensions are clearly wrong, the image rows don't line up.</span>
<span class="comment-copy">Well its dimensions are 962*800 vertically then horizontaly</span>
