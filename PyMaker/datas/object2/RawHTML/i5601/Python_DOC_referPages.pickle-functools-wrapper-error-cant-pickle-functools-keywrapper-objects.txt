<div class="post-text" itemprop="text">
<p>I am trying to pickle a SortedListWithKey for which I am using cmp_to_key() from functools to convert a comparison function to a key function. 
However, the cmp_to_key() seems to make my object unpickable and I get the following error: TypeError: can't pickle functools.KeyWrapper objects</p>
<p>How can I fix it? This is a code sample to reproduce the error:</p>
<pre><code>import pickle
from functools import cmp_to_key
from sortedcontainers import SortedListWithKey

def order_fun(a, b):
    if abs(a[0]-b[0]) &lt; 1e-8:
        return 0
    elif a[0]-b[0] &gt; 0:
        return 1
    else:
        return -1

pickle.loads(pickle.dumps(SortedListWithKey([[1,2], [3,4]], key=cmp_to_key(order_fun))))
</code></pre>
<p>Thanks!</p>
<p>Note: The pickling works fine without using the cmp_to_key() function, but I need it since my function is not a key function.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem seems to be that <a href="https://docs.python.org/3/library/functools.html#functools.cmp_to_key" rel="nofollow noreferrer">cmp_tp_key</a> is <a href="https://bugs.python.org/issue11707" rel="nofollow noreferrer">now written in C</a>, and the class it returns is neither pickleable nor subclassable. However, the original pure python version is <a href="https://github.com/python/cpython/blob/3.6/Lib/functools.py#L211" rel="nofollow noreferrer">still maintained in the source</a>, and is very simple. When this is used with your example, it works correctly. Of course, the obvious downside is that the pure python version is slower - but <a href="https://bugs.python.org/issue11707#msg132969" rel="nofollow noreferrer">the difference is not huge</a>.</p>
<p>Here is a working version of your example:</p>
<pre><code>import pickle
from sortedcontainers import SortedListWithKey

def order_fun(a, b):
    if abs(a[0]-b[0]) &lt; 1e-8:
        return 0
    elif a[0]-b[0] &gt; 0:
        return 1
    else:
        return -1

class KeyFunc(object):
    __slots__ = ['obj']
    def __init__(self, obj):
        self.obj = obj
    def __lt__(self, other):
        return order_fun(self.obj, other.obj) &lt; 0
    def __gt__(self, other):
        return order_fun(self.obj, other.obj) &gt; 0
    def __eq__(self, other):
        return order_fun(self.obj, other.obj) == 0
    def __le__(self, other):
        return order_fun(self.obj, other.obj) &lt;= 0
    def __ge__(self, other):
        return order_fun(self.obj, other.obj) &gt;= 0
    __hash__ = None

sl = SortedListWithKey([[1,2], [3,4]], key=KeyFunc)

print(sl)

print(pickle.loads(pickle.dumps(sl)))
</code></pre>
<p>Output:</p>
<pre><code>SortedListWithKey([[1, 2], [3, 4]], key=&lt;class '__main__.KeyFunc'&gt;)
SortedListWithKey([[1, 2], [3, 4]], key=&lt;class '__main__.KeyFunc'&gt;)
</code></pre>
</div>
<span class="comment-copy">can generators be pickled? maybe try: <code>list(SortedListWithKey(...))</code> ? see: <a href="https://stackoverflow.com/questions/7180212/why-cant-generators-be-pickled#7180424" title="why cant generators be pickled%237180424">stackoverflow.com/questions/7180212/â€¦</a> by using the <code>key</code> kwarg i think it turns it into a generator?</span>
<span class="comment-copy">A very old question, not every objects can be pickled. Try converting to some basic objects.</span>
<span class="comment-copy">You can't pickle a function (of any kind). There's an module named <a href="https://pypi.python.org/pypi/dill/0.2.7.1" rel="nofollow noreferrer"><code>dill</code></a> that ought to be able to do it, though.</span>
