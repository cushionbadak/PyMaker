<div class="post-text" itemprop="text">
<p>I know I can implement in the base class some function to <strong>raise when subclass fails to override some method</strong>.</p>
<pre><code>def some_method( self ):
  raise NotImplementedError
</code></pre>
<p>But how can I do the opposite, i.e. <strong>raise only when the subclass does override this method</strong>?</p>
<p>Thanks!</p>
<p>Edit: I'm trying to prevent people from overriding <strong>getitem</strong>/<strong>getattr</strong> so the namespace clash doesn't apply here.</p>
<p>Edit: I already tried to check if the subclass method is base class method. This worked under CPython, but not PyPy. Is there any all-around solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>One way of solving this problem is to use a meta-class and then check during creation, if the method is part of the <code>body</code> and raise a <code>typeError</code></p>
<pre><code>class BaseMeta(type):
    def __new__(cls, name, bases, body):
        if 'bar' in body:
            raise TypeError("bad user class")
        return super().__new__(cls, name, bases, body)


class Base(metaclass=BaseMeta):
    def bar(self):
        return None


class Derived(object):
    def bar(self):
        return 'bar'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can check whether the method is the same method object as the superclass:</p>
<pre><code>def is_base_impl(obj):
    return obj.__getattr__ is BaseClass.__getattr__
</code></pre>
<p>Of course, this only detects unintentional overriding; if a subclass were determined to do this they could just monkey-patch <code>BaseClass</code> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>At <code>__init__()</code> time you could use <a href="https://docs.python.org/3/library/inspect.html#inspect.getmembers" rel="nofollow noreferrer">inspect.getmembers()</a> to learn details about some_method(). Then you could choose to test the method's behavior or report on it as needed.</p>
</div>
<span class="comment-copy">What are you trying to prevent? Should you possibly just be using the double-underscore convention instead?</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/30543615/python-avoiding-implementation-method-name-clashes-in-subclass">Python avoiding implementation method name clashes in subclass</a></span>
<span class="comment-copy">I'm trying to prevent overriding <code>__getitem__ / __getattr__</code></span>
<span class="comment-copy">Why? What's wrong with a subclass implementing those?</span>
<span class="comment-copy">In the base class I already override them to implement some magic and they are not meant to be overriden by subclasses.</span>
<span class="comment-copy">This is what I had, worked with CPython, but not PyPy ... But anyways thanks for the help!</span>
<span class="comment-copy">In the presence of a JIT all bets are off. You should have put that relevant information in your question in the first place: both that you had tried this and what platform you are using.</span>
<span class="comment-copy">Honestly, you should not have accepted this answer if it didn't actually answer your question.</span>
<span class="comment-copy">Can't believe this is what you want... So you think those guys who don't know how to use your lib correctly are smart enough to use this function to check if they are doing wrongly? IMHO, you just need to believe them or writing a well-formatted document.</span>
<span class="comment-copy">Thanks for the suggestion. Already updated the question. I thought it was just because I was doing the wrong thing and there might be Pythonic all-around solution.</span>
