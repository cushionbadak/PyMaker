<div class="post-text" itemprop="text">
<p>I have a list:</p>
<pre><code>day_list = [1,2,3,4,5,6]
</code></pre>
<p>I want to write a function which will take any number (<code>no</code>) from this list and return the next and previous element.</p>
<p>So, for example, if I pass <strong>2</strong>, I should get <code>[1,3]</code> (<em>1 being the previous and 3 the next elements</em>).</p>
<p>But there is a catch: </p>
<p><em>If <code>no = 1</code> the previous element should be 6 and similarly for <code>no = 6</code> next should be 1</em></p>
<p>I would like something like:</p>
<pre><code>def getPrevNext(no):
    ....
    ....
    return [prev,next]

result = getPrevNext(2)  # result should be [1,3]
result2 = getPrevNext(5)  # result2 should be [4,5]
result3 = getPrevNext(1)  # result3 should be [6,2]
result4 = getPrevNext(6)  # result3 should be [5,1]
</code></pre>
<p>I tried:</p>
<pre><code>def dummy(no):
        if no == 1:
            prev_no = 6
            next_no = 2
        elif no == 6:
            prev_no = 5
            next_no = 1
        else:
            prev_no = no - 1
            next_no = no + 1
        return [prev_no,next_no]
</code></pre>
<p>But this seems like a very naive and basic approach.. Is there a better way to do this?</p>
<p>FYI <strong>List of days not required, that was just for understanding the total no.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/48074653/4909087">@juanpa.arrivillaga's answer</a> covers the specifics of this question quite well (which is a question on how to use modulo arithmetic).  However, in the general case of accessing the previous and next elements of <em>any</em> list, this is how I'd do it - </p>
<pre><code>def getPrevNext(l, no):
    i = l.index(no)
    return [l[i - 1], l[(i + 1) % len(l)]]
</code></pre>
<p></p>
<pre><code>days = list(range(1, 7))

getPrevNext(days, 2)
[1, 3]

getPrevNext(days, 1)
[6, 2]

getPrevNext(days, 6)
[5, 1]
</code></pre>
<p>The first expression <code>l[i - 1]</code> takes advantage python's ability to access elements using negative indices. The second expression, <code>l[(i + 1) % len(l)]</code>, is a common circular list access idiom. </p>
<p>To return a tuple instead of a list, drop the enclosing square brackets in the <code>return</code> statement - </p>
<pre><code>def getPrevNextAsTuple(l, no):
    i = l.index(no)
    return l[i - 1], l[(i + 1) % len(l)]
</code></pre>
<hr/>
<p>Note that this does not handle the possibility of <code>no</code> not being in the list. In that case, you'd use something like exception handling to catch any <code>ValueError</code>s raised - </p>
<pre><code>def getPrevNext(l, no):
    try:
        i = l.index(no)
    except ValueError:
        return None

    return l[i - 1], l[(i + 1) % len(l)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are working with "days" encoded 1-6, use the following:</p>
<pre><code>&gt;&gt;&gt; def prev_next_day(day):
...     day -= 1
...     prev = ((day - 1) % 6) + 1
...     next_ = ((day + 1) % 6) + 1
...     return [prev, next_]
...
&gt;&gt;&gt; prev_next_day(2)
[1, 3]
&gt;&gt;&gt; prev_next_day(5)
[4, 6]
&gt;&gt;&gt; prev_next_day(1)
[6, 2]
&gt;&gt;&gt; prev_next_day(6)
[5, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just use <code>slicing</code> (and optionally, for elegance, <em>mod</em>) like so:</p>
<pre><code>day_list = [1,2,3,4,5,6]

def get_prev_next(my_list, no):
  try:
    pointer = my_list.index(no)
  except ValueError:
    return []
  else:
    return [my_list[pointer-1], my_list[(pointer+1) % len(my_list)]]
</code></pre>
<hr/>
<p><strong>Examples:</strong></p>
<pre><code># first element
print(get_prev_next(day_list, 1))   # -&gt; [6, 2]

# last element
print(get_prev_next(day_list, 6))   # -&gt; [5, 1]

# any other
print(get_prev_next(day_list, 3))   # -&gt; [2, 4]

# non-existent element
print(get_prev_next(day_list, 98))  # -&gt; []    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would say the following works:</p>
<pre><code>def getPrevNext(no):
    day_list = [1, 2, 3, 4, 5, 6]
    return([day_list[(no-2) % 6], day_list[(no) % 6]])
</code></pre>
<p>Depending on whether or not you also only accept <code>1 &lt;= no &lt;= 6</code>, you could add a condition to this function like so:</p>
<pre><code>def getPrevNext(no):
    day_list = [1, 2, 3, 4, 5, 6]
    return([day_list[(no-2) % 6], day_list[(no) % 6]] if 1 &lt;= no &lt;= 6 else 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def getem(lst,element):
index=lst.index(element)
try:
    if index!=0 and index!=(len(lst)-1):
        return [lst[index-1],lst[index+1]]
    else:
        if index==0:
            return [lst[len(lst)-1],lst[index+1]]
        else:
            return [lst[index-1],lst[0]]
except Exception as e:
print("element does not exists")
</code></pre>
<p>try this function or you can use circular linked-list in this function i have mimicked that behaviour</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you sure you need a list of days?</p>
<pre><code>def f(n):
    assert 0&lt;n&lt;7, "numbers should be between 1 and 6"
    return n-1 if n!=1 else 6, n+1 if n!=6 else 1
f(1)
#result (6, 2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the <code>trick</code> you mentioned is famous as circular linked list. Please correct me if I'm wrong about it.</p>
<pre><code>day_list = [1,2,3,4,5,6] 
def get_prev_next(elem):
    if elem not in day_list:
       return False     # element not found
    index = day_list.index(elem)
    return day_list[i - 1], l[(i + 1) % len(day_list)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the <em>previous</em>, you can take advantage of the fact that when indexing a list, negative indexes mean "<em>negative starting on the last element</em>". It helps me thinking about the <code>[-1]</code> as "overflowing", which means going to the first element (index <code>0</code>) and start counting from the last element.</p>
<p>For the <em>next</em>, you can use the <a href="https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations" rel="nofollow noreferrer">modulo (%)</a> operator, to make sure you keep your indexes between <code>0</code> and <code>len(days_list)</code>. This is only critical in the case the index of the number you want to calculate the next is the last element of the list (index <code>5</code>, value <code>6</code> in the <code>day_list</code>). Just adding <code>+1</code> to the index <code>5</code> would put you in <code>6</code>, which is not a valid <strong><code>index</code></strong>. But then you get the module of <code>6 % 6</code> and "becomes" <code>0</code>.</p>
<pre><code>day_list = [1, 2, 3, 4, 5, 6]


def find(thing):
    position = day_list.index(thing)
    prev_pos = day_list[position - 1]
    next_pos = day_list[(position + 1) % len(day_list)]
    return prev_pos, next_pos


if __name__ == "__main__":
    for i in range(1, 7):
        print("prev_next %s: %s" % (i, find(i)))
</code></pre>
<p>Outputs:</p>
<pre><code>prev_next 1: (6, 2)
prev_next 2: (1, 3)
prev_next 3: (2, 4)
prev_next 4: (3, 5)
prev_next 5: (4, 6)
prev_next 6: (5, 1)
</code></pre>
</div>
<span class="comment-copy">Why is 6 the next for 6?</span>
<span class="comment-copy">You never accessed <code>day_list</code> in <code>dummy()</code>.</span>
<span class="comment-copy">@timgeb it is a typo , because in code next item after 6 is 1.</span>
<span class="comment-copy">@timgeb the next for 6 is 1</span>
<span class="comment-copy">You should create a round list data structure.</span>
<span class="comment-copy">you mean <code>len(l)</code> on the <code>return</code> line.</span>
<span class="comment-copy">@Ev.Kounis Thanks, copy paste error :)</span>
<span class="comment-copy">And you are returning a tuple. Sorry for the nitpicking, it is meant in a good way. I am actually a fan :)</span>
<span class="comment-copy">@Ev.Kounis Nitpick accepted :)</span>
<span class="comment-copy">Finding <code>prev</code> doesn't need a %6, because of negative access.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ no slicing going on... original problem description was misleading, this is a problem about previous and next <i>days</i> encoded 1-6, not of a general list.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ Yes, the min day = 1 and max =6, it will not be a general list, you can remove the list parameter from your function</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ nah, there's no list. Essentially the question is how to do modular arithmetic...</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ well, the title is highly misleading. <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">Classic XY-problem</a>.</span>
<span class="comment-copy">List of days not required, that was just for understanding the total no.s</span>
<span class="comment-copy">Then please verify if my code fulfill your requirements.</span>
<span class="comment-copy">Yes it works, i dont know who gave -minus rating!</span>
<span class="comment-copy">It's ok. In any case, so far you have 3 answers. Look what works best for you, or maybe combine the answers ;)</span>
