<div class="post-text" itemprop="text">
<p>I am writing a webapp with a Tornado backend and, of course, javascript and jquery on the frontend, so I am using the builtin json module in the standard library to serialize objects for the frontend. I had started writing a custom JSONEncoder for my classes, but then it occurred to me that I could simply write a very simple, generic object encoder:</p>
<pre><code>class ObjectEncoder(json.JSONEncoder):
    def default(self, obj):
        return vars(obj)
</code></pre>
<p>It seems to be working nicely, so I wondered why this is not included in the module, and if this technique has drawbacks. I didn't experiment if it works nicely with check_circular, but I have no reason to believe it doesn't.</p>
<p>Any comments on my doubts? Otherwise, I suppose this technique may be useful to somebody, since I didn't find it with a search (admittedly, a quick one).</p>
<p>EDIT: here's an example, as simple as it gets, to show the behaviour of the json module:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; class Foo:
...   def __init__(self):
...     self.bar = 'bar'
... 
&gt;&gt;&gt; foo = Foo()
&gt;&gt;&gt; json.dumps(foo)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.5/json/__init__.py", line 230, in dumps
    return _default_encoder.encode(obj)
  File "/usr/lib/python3.5/json/encoder.py", line 198, in encode
    chunks = self.iterencode(o, _one_shot=True)
  File "/usr/lib/python3.5/json/encoder.py", line 256, in iterencode
    return _iterencode(o, 0)
  File "/usr/lib/python3.5/json/encoder.py", line 179, in default
    raise TypeError(repr(o) + " is not JSON serializable")
TypeError: &lt;__main__.Foo object at 0x7f14660236d8&gt; is not JSON serializable
&gt;&gt;&gt; class ObjectEncoder(json.JSONEncoder):
...     def default(self, obj):
...         return vars(obj)
... 
&gt;&gt;&gt; json.dumps(foo, cls=ObjectEncoder)
'{"bar": "bar"}'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>vars(obj)</code> is syntactic sugar for <code>obj.__dict__</code>, so it doesn't work on any object without <code>__dict__</code>. This includes stuff like:</p>
<ol>
<li>User-defined objects where every level in the class hierarchy defined <code>__slots__</code> (without a <code>__dict__</code> slot) to reduce memory usage</li>
<li>Objects of built-in types that don't opt-in to a <code>tp_dict</code> slot</li>
</ol>
<p>Worse, there are in-between cases, where some attributes are set on the <code>__dict__</code>, while others aren't (e.g. a class hierarchy where <code>__slots__</code> was used for some levels, but other levels didn't use <code>__slots__</code> and relied on the implicit <code>__dict__</code>). In cases like that, you wouldn't get an error to let you know something had gone wrong, you'd just serialize the <code>__dict__</code> part of the object state and silently ignore the rest.</p>
<p>You'd have similar problems if the interface uses <code>@property</code>s; they're used like attributes, but they're not on the instance <code>__dict__</code>, so you'd either lose the information completely (if there is no hidden underlying attribute), or serialize the "wrong" value (the internal name, rather than the API name exposed as an <code>@property</code>).</p>
<p>In short, lots of things can go subtly wrong by trying to guess at the correct behavior like this, which is why The Zen of Python (type <code>import this</code> in an interactive terminal to see it) includes stuff like:</p>
<blockquote>
<p>Errors should never pass silently.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>In the face of ambiguity, refuse the temptation to guess.</p>
</blockquote>
<p>Beyond these errors, there's also the general problem of reversability. A general <em>encoder</em> of this form is definitionally incapable of being handled by a general <em>decoder</em> (because you lose all the type information). Offering an easy way to lose important information is... suboptimal.</p>
</div>
<span class="comment-copy">What's wrong with <code>json.dumps(obj)</code> ?</span>
<span class="comment-copy">It raises <code>TypeError: &lt;... instance at ...&gt; is not JSON serializable</code>. This seems to be by design, since it is explicitly stated in <a href="https://docs.python.org/3/library/json.html#py-to-json-table" rel="nofollow noreferrer">the documentation</a>, I would just like to understand why it is so, and if there are complication which I do not see.</span>
<span class="comment-copy">Post the full error stacktrace please</span>
<span class="comment-copy">I really don't see the point, anyway, here's a full example:</span>
<span class="comment-copy">(added to the main post, it was too long for comments)</span>
<span class="comment-copy">I am sure I had thanked you, but my comment was lost :(  Well, at least I had accepted your answer...</span>
<span class="comment-copy">In fact, I had come back here to note that I had hit the first problem with my aproach: I needed a <code>set</code> in on of my classes, and <i>that</i> hasn't got a <code>__dict__</code>, so I had to change approach: I use the <code>vars()</code> approach for a list of predefined user classes, and custom code for other classes like <code>set</code>.</span>
