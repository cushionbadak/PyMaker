<div class="post-text" itemprop="text">
<p>I was reading this: <a href="https://stackoverflow.com/questions/1319338/combining-two-lists-and-removing-duplicates-without-removing-duplicates-in-orig">Combining two lists and removing duplicates, without removing duplicates in original list</a> but my need goes beyond. I have at least 30 lists and I need the union without duplicates of all the lists. Right now my first try was just to use + to just append all the member in one great list and then use set to remove duplicates, but I'm not sure if this is the best solution:</p>
<p><strong>Edit - Adding samples:</strong></p>
<pre><code>list_a = ['abc','bcd','dcb']
list_b = ['abc','xyz','ASD']
list_c = ['AZD','bxd','qwe']
big_list = list_a + list_b + list_c
print list(set(big_list)) # Prints ['abc', 'qwe', 'bcd', 'xyz', 'dcb', 'ASD', 'bxd']
</code></pre>
<p>My real question is if this the best way to go with this combination?</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand correctly what you are trying to do, you can use the <code>set.update</code> method with an arbitrary number of iterable arguments.</p>
<pre><code>&gt;&gt;&gt; lists = [[1,2,3], [3,4,5], [5,6,7]]
&gt;&gt;&gt; result = set()
&gt;&gt;&gt; result.update(*lists)
&gt;&gt;&gt; 
&gt;&gt;&gt; result
{1, 2, 3, 4, 5, 6, 7}
</code></pre>
<p>edit: with your sample data:</p>
<pre><code>&gt;&gt;&gt; list_a = ['abc','bcd','dcb']
&gt;&gt;&gt; list_b = ['abc','xyz','ASD']
&gt;&gt;&gt; list_c = ['AZD','bxd','qwe']
&gt;&gt;&gt; 
&gt;&gt;&gt; result = set()
&gt;&gt;&gt; result.update(list_a, list_b, list_c)
&gt;&gt;&gt; result
{'ASD', 'xyz', 'qwe', 'bxd', 'AZD', 'bcd', 'dcb', 'abc'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>set.union(set1, set2, set3, ..)</code>.</p>
<pre><code>&gt;&gt;&gt; l1 = [1,2,3]
&gt;&gt;&gt; l2 = [2,3,4]
&gt;&gt;&gt; l3 = [3,4,5]
&gt;&gt;&gt; set.union(*[set(x) for x in (l1, l2, l3)])
{1, 2, 3, 4, 5}
</code></pre>
<p>More compact (works for both Py2 and Py3, Thanks @Lynn!): </p>
<pre><code>&gt;&gt;&gt; set.union(*map(set, (l1, l2, l3)))
set([1, 2, 3, 4, 5])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One approach using <code>set.union</code> has <a href="https://stackoverflow.com/a/48063424/4573247">already been mentioned</a>, although applied onto each list after first mapping the lists to <code>set</code> instances.</p>
<p>As an alternative, the explicit <code>set</code> mapping can be omitted, as <code>set.union</code>, much like <code>set.update</code> (the latter approach covered in <a href="https://stackoverflow.com/a/48063418/4573247">the accepted answer</a>) also takes arbitrary number of iterable arguments, allowing directly invoking <code>set.union</code> over an empty set and the provided lists.</p>
<pre><code>&gt;&gt;&gt; list_a = ['abc','bcd','dcb']
&gt;&gt;&gt; list_b = ['abc','xyz','ASD']
&gt;&gt;&gt; list_c = ['AZD','bxd','qwe']

&gt;&gt;&gt; result = set().union(list_a, list_b, list_c)
&gt;&gt;&gt; result
{'ASD', 'xyz', 'qwe', 'bxd', 'AZD', 'bcd', 'dcb', 'abc'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you could do is create a function that accepts any number of lists, flattens them and returns the union:</p>
<pre><code>from itertools import chain

def union_lists(*iterables):
    union = []
    lookup = set()

    flattened = chain.from_iterable(iterables)

    for item in flattened:
        if item not in lookup:
            lookup.add(item)
            union.append(item)

    return union
</code></pre>
<p>The benefit of the above function is that it preserves the order of the list items as they are inserted, unlike a <code>set()</code>, which is unordered. It however uses a <code>set()</code> for checking if items have been added, which is <code>O(1)</code>, but inserts them into a list instead, since lists are ordered. </p>
<p>It also flattens the list with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a>, which is <code>O(n)</code>. </p>
<p>Then you can simply run this function on as many lists as you want:</p>
<pre><code>&gt;&gt;&gt; list_a = ['abc','bcd','dcb']
&gt;&gt;&gt; list_b = ['abc','xyz','ASD']
&gt;&gt;&gt; list_c = ['AZD','bxd','qwe']
&gt;&gt;&gt; print(union_lists(list_a, list_b, list_c))
['abc', 'bcd', 'dcb', 'xyz', 'ASD', 'AZD', 'bxd', 'qwe']
&gt;&gt;&gt; list_d = ['bcd', 'AGF', 'def']
&gt;&gt;&gt; print(union_lists(list_a, list_b, list_c, list_d))
['abc', 'bcd', 'dcb', 'xyz', 'ASD', 'AZD', 'bxd', 'qwe', 'AGF', 'def']
</code></pre>
</div>
<span class="comment-copy">Please add an example to your question. Preferably with three lists, not thirty.</span>
<span class="comment-copy">Just perform the "union two lists" operation 29 times?</span>
<span class="comment-copy">This works perfectly, the only thing I add to this was to use <code>print(list(result))</code> because only having <code>print(result)</code> give me <code>set(['abc', 'qwe', 'bcd', 'xyz', 'dcb', 'ASD', 'bxd'])</code> on screen.</span>
<span class="comment-copy">Both of your snippets actually work for both Python 2 and 3. Your second snippet is missing a <code>)</code>.</span>
<span class="comment-copy">Fixed! Thanks for pointing out. :-)</span>
