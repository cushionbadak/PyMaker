<div class="post-text" itemprop="text">
<p>For exmaple:</p>
<pre><code>class person():
    def __init__(self):
        self.a1 = 0
        self.a2 = 0
        self.a3 = 0

    def method_a1(self):
        self.a1 = self.a1 * 2
        print(self.a1)

    def method_a2(self):
        self.a2 = self.a2 * 2
        print(self.a2)

    def method_a3(self):
        self.a3 = self.a3 * 2
        print(self.a3)
</code></pre>
<p>The three methods are similar, so I want to build a function to generate these methods, like this:</p>
<pre><code>class person():
    def __init__(self):
        self.a1 = 0
        self.a2 = 0
        self.a3 = 0

   def method(p):
       p = p * 2
       print(p)

   method(self.a1)
   method(self.a2)
   method(self.a3)
</code></pre>
<p>I do not know how to write it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do sth along the following lines:</p>
<pre><code>def _helper(attr):
    def method(self):
        val = getattr(self, attr) * 2
        setattr(self, attr, val)
        print(val)
    return method

class person():
    # ...
    method_a1 = _helper('a1')
    method_a2 = _helper('a2')
    method_a3 = _helper('a3')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could assign them straight in the <code>__init__</code>, and use some generic function that retrieves the attributes via string with <code>getattr()</code> and <code>setattr()</code>, and returns the function to call:</p>
<pre><code>class person():
    def __init__(self):
        self.a1 = 0
        self.a2 = 0
        self.a3 = 0

        self.method_a1 = self._generic_update('a1')
        self.method_a2 = self._generic_update('a2')
        self.method_a3 = self._generic_update('a3')

    def _generic_update(self, attribute):
        def update():
            value = getattr(self, attribute)
            setattr(self, attribute, value * 2)
            print(getattr(self, attribute)
        return update
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is a loooot of weird stuff you can do with Python.</p>
<p>One that comes to mind is using <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer">getattr</a> (to fetch an attribute from a string representing its name) and <a href="https://docs.python.org/3/library/functions.html#setattr" rel="nofollow noreferrer">setattr</a> (to write an attribute using its name)</p>
<p>Check this out:</p>
<pre><code>class Person(object):
    def __init__(self):
        self.a1 = 0
        self.a2 = 1
        self.a3 = 2

    def method(self, attr_name):
        new_value = getattr(self, attr_name) * 2
        setattr(self, attr_name, new_value)
        print(getattr(self, attr_name))


if __name__ == "__main__":
    pers = Person()
    pers.method('a1')
    pers.method('a2')
    pers.method('a3')
</code></pre>
<p>Outputs:</p>
<pre><code>0
2
4
</code></pre>
<p>However: You should also consider readability: Sometimes writing a bit more can make other people who read your code understand it much better. Abusing things like this can make the code very confusing very fast.</p>
</div>
<span class="comment-copy">Feel this is the best way presented. Actually makes class methods (which actually have <code>self</code>) instead of attributes that are empty functions.</span>
<span class="comment-copy">Yup, the effect is the same for most purposes, but you are creating the function objects only once for the class (class method is maybe not the right term as it is already used for sth else) and not for each instance. It is also a little more elegant if you don't have to hook into the <code>__init__</code>.</span>
<span class="comment-copy">I like this one better than my answer <b>:-D</b> (particularly because of the assignment to <code>method_a1</code>, <code>method_a2</code>)...</span>
<span class="comment-copy">Though you are correct, any case where you've got to start pulling out <code>getattr</code> and <code>setattr</code>, things are going to start getting confusing. Use as last resort.</span>
