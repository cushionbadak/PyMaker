<div class="post-text" itemprop="text">
<p>So one issue I discovered with python is that it is not very user-friendly to create nested loops each with their own indexes. </p>
<p>How would I write the Python-equivalent of this Java code:</p>
<pre><code>for(int i = 0; i &lt; array.length-2; i++){
    for(int j = i+1; j &lt; array.length-1; j++){ 
       for(int k = j+1; k &lt; array.length; k++){
</code></pre>
<p>Notice how I reference the counter value of the predecessor's for each nested loop. I tried using:</p>
<p><code>for idx, val in enumerate(nums[:-2]):</code></p>
<p>but it seems like <code>idx</code> will always start at 0 rather than start at the predecessor's index value. Is there a better solution besides maintaining separate counter variables?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's very simple to do that using <code>range</code> or <code>xrange</code>. Here's how you do it.</p>
<p>Java version:</p>
<pre><code>for(int i = 0; i &lt; array.length-2; i++) {
    for(int j = i+1; j &lt; array.length-1; j++) { 
        for(int k = j+1; k &lt; array.length; k++) {
</code></pre>
<p>Python version:</p>
<pre><code>for i in xrange(0,len(arr)-2):
    for j in xrange(i+1, len(arr)-1):
       for k in xrange(j+1, len(arr)):
</code></pre>
<p>I hope that helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">[Python 3]: <strong>enumerate</strong>(<em>iterable, start=0</em>)</a> (<strong>emphasis</strong> is mine):</p>
<blockquote>
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="nofollow noreferrer">__next__()</a> method of the iterator returned by <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate()</a> returns a tuple containing a count (from <em>start</em> which <strong>defaults to 0</strong>) and the values obtained from iterating over <em>iterable</em>.</p>
</blockquote>
<p>Example:</p>
<pre class="lang-py prettyprint-override"><code>num = [0, 2, 4, 6, 8]
start = 2
for idx, val in enumerate(num[start:], start=start):
    print("Index: {}, Element: {}".format(idx, val))
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre class="lang-py prettyprint-override"><code>Index: 2, Element: 4
Index: 3, Element: 6
Index: 4, Element: 8
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>It's simple.</p>
<pre><code>for i in range(0,len(array)-2):
    for j in range(i+1,len(array)-1):
        for k in range(j+1,len(array)):
            print k
        print j
    print i
</code></pre>
</div>
<span class="comment-copy">I smell an XY problem here. What are you trying to solve? Often there are no 1-1 mappings between different languages (there is here), and there may even be a better pythonic way of solving the same problem that Java does not offer.</span>
<span class="comment-copy">For reference, it isn't hard at all. <code>for i in range(len(arr) - 2): for j in range(i + 1, len(arr) - 1): for k in range(j + 1, len(arr)): ...</code> using the nested loops with <code>range</code> would be the obvious way of doing it.</span>
<span class="comment-copy">this might be related: <a href="https://stackoverflow.com/questions/41521725/iterating-over-multiple-indices-with-i-j-k-in-a-pythonic-way" title="iterating over multiple indices with i j k in a pythonic way">stackoverflow.com/questions/41521725/â€¦</a></span>
<span class="comment-copy">The goal is just to iterate through an array and do something with each triplet. Looks like instead of using an enhanced for-loop which references the current element directly, I just use the index values to reference the element from the array (ie array[i] vs val)</span>
<span class="comment-copy">I would go for this version since if I'm not mistaken, enumerate returns an iterator, which is faster to iterate through than a list (returned by range). :)</span>
<span class="comment-copy">@IMCoins: In <i>Py3</i> <code>range</code> also returns an iterator (behavior that in <i>Py2</i> is available via <code>xrange</code>). I don't think that iterators are faster than lists (iterator values are produced on the fly, while list is already there), the great advantage is memory consumption.</span>
