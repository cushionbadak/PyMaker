<div class="post-text" itemprop="text">
<p>I'm working on a simple dictionary attack script where it checks every english lowercase word hashed against the ciphertext, and my first version worked well. It looked like this:</p>
<pre><code>import hashlib
import random


def dict_attack(pwds):
    f = open('Dictionary.txt', 'r')
    words = f.readlines()
    f.close()
    cracked = []
    for pwd in pwds:
        for w in words:
            word = w.strip('\n')
            word = word.strip(' ')
            hashed = hashlib.md5(word.encode())
            if hashed.hexdigest() == pwd:
                print("[+] Found {} as {}, updating...".format(pwd, word))
                cracked.append(word)
                break
    print("[-] {}/{} passwords found!".format(len(cracked), len(pwds)))
    return cracked

def main():
    # To generate new ciphertext
    f = open('Dictionary.txt', 'r')
    words = f.readlines()
    f.close()
    for b in range(0, 10):
        passwords.append(random.choice(words))
        passwords[b] = passwords[b].strip('\n')
        passwords[b] = passwords[b].strip(' ')
    hashed_passwords = []
    for p in passwords:
        hashed_passwords.append(hashlib.md5(p.encode()).hexdigest())
    #print(hashed_passwords)
    print(dict_attack(hashed_passwords))

main()
</code></pre>
<p>as you can see, the function dict_attack only used the md5 hash. In my next version of this script I planned to cycle through each algorithm in the hashlib.algorithms_guaranteed library, and encrypt each word in the dictionary with each algorithm and check against the ciphertext. That code looked like this:</p>
<pre><code>import hashlib


arguments = [[hashlib.md5('hello'.encode())]]
f = open('Dictionary.txt', 'r')
words = f.readlines()
f.close()
# Remember to strip the \n's
cracked = {}
for ciphertext in arguments[0]:
    for word in words:
        for alg in hashlib.algorithms_guaranteed:
            exec("hashed = hashlib.{}(word.encode())".format(alg))
            if hashed.hexdigest() == ciphertext:
                cracked[ciphertext] = [word, alg]
                print("[+] Found {} as {} with {} algorithm!".format(ciphertext, word, alg))
                break
print(cracked)
</code></pre>
<p>However, when I ran my code, it threw this error:</p>
<pre><code> TypeError: Required argument 'length' (pos 1) not found
</code></pre>
<p>Why is this happening, and how can I fix it?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>hashlib</code> contains some hash functions that have dynamic length outputs. Specifically, <code>shake_128</code> and <code>shake_256</code>.</p>
<pre><code>import hashlib


arguments = [[hashlib.md5('hello'.encode())]]
f = open('Dictionary.txt', 'r')
words = f.readlines()
f.close()
# Remember to strip the \n's
cracked = {}

for ciphertext in arguments[0]:
    digest = ciphertext.digest()
    for word in words:
        for alg in hashlib.algorithms_guaranteed:
            if alg.startswith('shake_'):
                continue
            hashed = getattr(hashlib, alg)(word.encode())
            if hashed.digest() == digest:
                cracked[ciphertext] = [word, alg]
                print("[+] Found {} as {} with {} algorithm!".format(ciphertext, word, alg))
                break

print(cracked)
</code></pre>
</div>
<span class="comment-copy">Have you looked at what algorithm you're on at the time and then seen what arguments it takes? As a side note - you're doing a lot of repeated work in your first example which isn't wonderfully efficient...</span>
<span class="comment-copy"><code>shake_256</code> algorithm <code>hexdigest</code> needs a length parameter according to <a href="https://docs.python.org/3/library/hashlib.html#shake-variable-length-digests" rel="nofollow noreferrer">docs</a>.</span>
<span class="comment-copy">@JonClements yeah, my first one wasn't really good. It was more of a coder script than a programmer script which is one of the reasons I made a v2.</span>
<span class="comment-copy">@YakupTürkan I'll try that, brb</span>
<span class="comment-copy">@YakupTürkan Fixed!! Thanks</span>
