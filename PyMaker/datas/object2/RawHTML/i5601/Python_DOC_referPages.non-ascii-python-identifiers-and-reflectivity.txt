<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/34097193/identifier-normalization-why-is-the-micro-sign-converted-into-the-greek-letter">Identifier normalization: Why is the micro sign converted into the Greek letter mu?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I have learnt from <a href="https://www.python.org/dev/peps/pep-3131/" rel="nofollow noreferrer">PEP 3131</a> that non-ASCII identifiers were supported in Python, though it's not considered best practice.</p>
<p>However, I get this strange behaviour, where my <code>𝜏</code> identifier (U+1D70F) seems to be automatically converted to <code>τ</code> (U+03C4).</p>
<pre><code>class Base(object):
    def __init__(self):
        self.𝜏 = 5 # defined with U+1D70F

a = Base()
print(a.𝜏)     # 5             # (U+1D70F)
print(a.τ)     # 5 as well     # (U+03C4) ? another way to access it?
d = a.__dict__ # {'τ':  5}     # (U+03C4) ? seems converted
print(d['τ'])  # 5             # (U+03C4) ? consistent with the conversion
print(d['𝜏'])  # KeyError: '𝜏' # (U+1D70F) ?! unexpected!
</code></pre>
<p>Is that expected behaviour? Why does this silent conversion occur? Does it have anything to see with <a href="https://en.wikipedia.org/wiki/Unicode_equivalence" rel="nofollow noreferrer">NFKC</a> normalization? I thought this was only for canonically ordering Unicode character <em>sequences</em>...</p>
</div>
<div class="post-text" itemprop="text">
<p>Per <a href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers" rel="noreferrer">the documentation on identifiers</a>:</p>
<blockquote>
<p>All identifiers are converted into the normal form NFKC while parsing;
  comparison of identifiers is based on NFKC.</p>
</blockquote>
<p>You can see that U+03C4 is the appropriate result using <a href="https://docs.python.org/3/library/unicodedata.html" rel="noreferrer"><code>unicodedata</code></a>:</p>
<pre><code>&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; unicodedata.normalize('NFKC', '𝜏')
'τ'
</code></pre>
<p>However, this conversion <em>doesn't</em> apply to string literals, like the one you're using as a dictionary key, hence it's looking for the unconverted character in a dictionary that <em>only contains the converted character</em>.</p>
<pre><code>self.𝜏 = 5  # implicitly converted to "self.τ = 5"
a.𝜏  # implicitly converted to "a.τ"
d['𝜏']  # not converted
</code></pre>
<p>You can see similar problems with e.g. string literals used with <code>getattr</code>:</p>
<pre><code>&gt;&gt;&gt; getattr(a, '𝜏')
Traceback (most recent call last):
  File "python", line 1, in &lt;module&gt;
AttributeError: 'Base' object has no attribute '𝜏'
&gt;&gt;&gt; getattr(a, unicodedata.normalize('NFKD', '𝜏'))
5
</code></pre>
</div>
<span class="comment-copy">Does <a href="https://www.python.org/dev/peps/pep-0263/" rel="nofollow noreferrer">defining an encoding</a> make a difference? 03C4 is definitely the decomposition of 1D70F, and it looks from <a href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers" rel="nofollow noreferrer">the reference</a> like some normalization happens.</span>
<span class="comment-copy">Your theory seems to be correct. Seems that python interpreter normalises your unicode variable already when assigning it. If you put <code>print(dir(a))</code> after <code>a</code> has been assigned, you can see there is no trace of  U+1D70F character in the class.  Your second print statement would then work for the same reason (gets normalised), while your dictionary access fails as dictionaries can take anything as keywords and there would be no reason to normalise or do anything else to them as it is a string in parentheses.</span>
<span class="comment-copy">@jonrsharpe Nope, defining <code># -*- coding: utf-8 -*-</code> makes no difference. Maybe NFKC is responsible.. but I thought canonisation was just about <i>reordering</i>, not changing the actual character.. 8)</span>
<span class="comment-copy">@Hannu I guess you're right as well.. but it leads to a quite unexpected behaviour when it comes to indexing <code>__dict__</code>, don't you find?</span>
<span class="comment-copy">Not at all. As the answer explains, there is no automatic normalisation of string literals, and It would be completely inappropriate to do so anyway.</span>
<span class="comment-copy">Well, that's interesting. Cheers :) I'll keep thinking that it's a weird behaviour anyway. If <code>𝜏</code> was the only character I could access on my keyboard, I couldn't use python reflective <code>__dict__</code> or <code>getattr</code> features like anybody else.. Should I file this as a bug to python?</span>
<span class="comment-copy">@iago-lito I'm not sure they'd consider it a bug, given that this is the documented behaviour. It certainly surprised me, though! And it makes dynamic attribute access (see the <code>getattr</code> example) a little more complex than initially expected. I guess this is why ASCII identifiers are still recommended; no more <code>from math import pi as π</code> for me!</span>
<span class="comment-copy">I'll inform them anyway :) What's the best place to do so?</span>
<span class="comment-copy">@iago-lito anything like that should go through <a href="https://bugs.python.org/" rel="nofollow noreferrer">bugs.python.org</a>; have a look around, there may be a similar issue logged already.</span>
<span class="comment-copy">Great. <a href="https://bugs.python.org/issue32483" rel="nofollow noreferrer">Here</a> it is. Thanks again :)</span>
