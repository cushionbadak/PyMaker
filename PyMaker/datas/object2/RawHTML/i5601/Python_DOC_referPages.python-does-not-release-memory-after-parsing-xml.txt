<div class="post-text" itemprop="text">
<p>I'm using lxml to parse some pretty big xml files (around ~15MB each). 
while I'm conceptually doing is the following:</p>
<pre><code>import lxml.etree as ET
def process_xmls():
    for xml_file in xml_files:
        tree=ET.parse(xml_file)
        etc. etc. 
</code></pre>
<p>Now, I'm calling the function, and I see the memory is increasing and increasing, which is reasonable. 
The problem is, that also after the function ends - the memory stays high, and Python does not release it!
Why is that, and is there any workaround? </p>
</div>
<div class="post-text" itemprop="text">
<p>It may be that lxml called malloc(), which called sbrk(). And then virtual memory never gets any smaller.</p>
<p>But that's not the end of the world. The ps VSZ may never shrink, but under memory pressure from other processes RSS should shrink with pageouts. Depending on the activity pattern of your app, which you never described, those "cold" pages may never be referenced again, so your long-lived python process winds up with a small memory footprint despite the large VSZ.</p>
<p>If your app can run for 24 hours, sometimes reading 15 MiB files, with stable memory numbers, then it's not leaking. The first file read will inflate the memory figures, but as long as subsequent file reads won't lead to monotonically increasing memory consumption you should be in good shape.</p>
<p>If you're very upset about the footprint, consider telling your long-lived app to use <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">multiprocessing</a> to fork off short-lived parser processes. They will call sbrk(), sbrk(), sbrk(), then exit(), and all resources will be immediately reclaimed.</p>
</div>
<span class="comment-copy">Usually because there are cyclic references in memory, or because something out of the function holds a reference to some elements. In the former case, you can use <code>import gc; gc.collect()</code>.</span>
<span class="comment-copy">@WillemVanOnsem - thank you for your answer. I tried to explicitly garbage-collect, and it didn't help :(</span>
<span class="comment-copy">then probably you have set (not per se explicitly) a variable outside of the function scope to hold data.</span>
<span class="comment-copy">@WillemVanOnsem I didn't... that's the problem :(</span>
<span class="comment-copy">How exactly do you monitor memory consumption? Try a memory profiler (e.g. <a href="https://pypi.python.org/pypi/memory_profiler" rel="nofollow noreferrer">pypi.python.org/pypi/memory_profiler</a>) to check where the physical memory goes. Also, someone suggested recently that functions need to terminate with a <code>return</code> in order to enable garbage collection. Don't know if it's true though.</span>
