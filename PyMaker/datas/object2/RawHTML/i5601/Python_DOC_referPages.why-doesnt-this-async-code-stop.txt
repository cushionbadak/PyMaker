<div class="post-text" itemprop="text">
<p>The following code snippet has two coroutines each for server and client. The client coroutine has a logic to break the <code>while</code> loop after 10 seconds and server should stop after 15 seconds.</p>
<p>When I run the script this doesn't stop, ideally, it should stop after 15 seconds but this is not happening.</p>
<pre><code>import asyncio
import time
import zmq
import zmq.asyncio

zmq.asyncio.install()

ctx = zmq.asyncio.Context()


server_socket = ctx.socket(zmq.REP)
client_socket = ctx.socket(zmq.REQ)

server_socket.bind("tcp://127.0.0.1:8899")
client_socket.connect("tcp://127.0.0.1:8899")

t0 = time.time()


@asyncio.coroutine
def server_coroutine():

    while True:
        msg = yield from server_socket.recv_string()
        print(msg)
        msg = "Server:: {}".format(msg)
        yield from server_socket.send_string(msg)
        t1 = time.time()
        elapsed_time = t1 - t0
        # print('elapsed time is {}'.format(elapsed_time))
        if elapsed_time &gt; 15:
            print("Breaking Server loop")
            break

@asyncio.coroutine
def client_coroutine():
    counter = 0
    while True:
        yield from asyncio.sleep(2)
        msg = 'Message: {}'.format(counter)
        yield from client_socket.send_string(msg)
        res = yield from client_socket.recv_string()
        print(res)
        t1 = time.time()
        elapsed_time = t1 - t0
        print('elapsed time is {}'.format(elapsed_time))
        if elapsed_time &gt; 10:
            print("Breaking Client loop")
            break
        counter += 1


if __name__ == '__main__':

    loop = asyncio.get_event_loop()

    loop.run_until_complete(asyncio.gather(
        asyncio.ensure_future(server_coroutine()),
        asyncio.ensure_future(client_coroutine())
    ))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you run code you will see something like this:</p>
<pre><code>Server:: Message: 4
elapsed time is 10.022311687469482
Breaking Client loop
</code></pre>
<p>ok, <code>client_coroutine</code> finished successfully, but what state of <code>server_coroutine</code> at this moment? It stuck at this line <code>msg = yield from server_socket.recv_string()</code> waiting for possibility to recive string from <code>server_socket</code>, but it won't happen since there's already no client to send it! And since your event loop runs until both coroutines done it would run forever.</p>
<p>Here's the simplest fix:</p>
<pre><code>@asyncio.coroutine
def server_coroutine():
    while True:
        msg = yield from server_socket.recv_string()
        if msg == 'CLOSE':  # LOOK HERE 1
            break
        print(msg)
        msg = "Server:: {}".format(msg)
        yield from server_socket.send_string(msg)
        t1 = time.time()
        elapsed_time = t1 - t0
        # print('elapsed time is {}'.format(elapsed_time))
        if elapsed_time &gt; 15:
            print("Breaking Server loop")
            break

@asyncio.coroutine
def client_coroutine():
    counter = 0
    while True:
        yield from asyncio.sleep(2)
        msg = 'Message: {}'.format(counter)
        yield from client_socket.send_string(msg)
        res = yield from client_socket.recv_string()
        print(res)
        t1 = time.time()
        elapsed_time = t1 - t0
        print('elapsed time is {}'.format(elapsed_time))
        if elapsed_time &gt; 10:
            print("Breaking Client loop")
            yield from client_socket.send_string('CLOSE')  # LOOK HERE 2
            break
        counter += 1
</code></pre>
<p>Note, this fix is only to demonstrate issue and one possible way to solve it. </p>
<p>In real life I think you would want to do something different: probably, set timeouts to you coroutines to guarantee they won't stuck forever if client/server stops responding.</p>
</div>
<span class="comment-copy">Thanks, Mikhail is there a way for a large application with many coroutine, where event-loop is waiting/ stuck?</span>
<span class="comment-copy">@bruce_wayne you should always have timeouts for your operations. In asyncio it's not a big problem: timeouted task can be <a href="https://stackoverflow.com/a/43810272/1113207">cancelled with standard mechanism</a>. Most convenient way to achieve it is to use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for" rel="nofollow noreferrer">asyncio.wait_for</a> coroutine or nice third-party <a href="https://pypi.python.org/pypi/async_timeout" rel="nofollow noreferrer">async-timeout</a> context manager (you can place multiple operations inside it).</span>
