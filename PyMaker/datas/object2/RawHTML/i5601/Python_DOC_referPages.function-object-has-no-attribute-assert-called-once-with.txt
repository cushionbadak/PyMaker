<div class="post-text" itemprop="text">
<p>I'm trying to run the following test using pytest and pytest_mock</p>
<pre><code>def rm(filename):
    helper(filename, 5)

def helper(filename):
    pass

def test_unix_fs(mocker):
    mocker.patch('module.helper')
    rm('file')
    helper.assert_called_once_with('file', 5)
</code></pre>
<p>But I get exception <code>AttributeError: 'function' object has no attribute 'assert_called_once_with'</code></p>
<p>What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can not perform a <code>.assert_called_once_with</code> function on a <em>vanilla</em> function: you first need to wrap it with the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.create_autospec" rel="nofollow noreferrer"><strong><code>mock.create_autospec</code></strong></a> decorator. So for instance:</p>
<pre><code><b>import unittest.mock as mock</b>

def rm(filename):
    helper(filename, 5)

def helper(filename):
    pass

<b>helper = mock.create_autospec(helper)</b>

def test_unix_fs(mocker):
    mocker.patch('module.helper')
    rm('file')
    helper.assert_called_once_with('file', 5)</code></pre>
<p>Or more elegantly:</p>
<pre><code>import unittest.mock as mock

def rm(filename):
    helper(filename, 5)

<b>@mock.create_autospec</b>
def helper(filename):
    pass

def test_unix_fs(mocker):
    mocker.patch('module.helper')
    rm('file')
    helper.assert_called_once_with('file', 5)</code></pre>
<p>Note that the assertion will fail, since you call it only with <code>'file'</code>. So a valid test would be:</p>
<pre><code>import unittest.mock as mock

def rm(filename):
    helper(filename, 5)

@mock.create_autospec
def helper(filename):
    pass

def test_unix_fs(mocker):
    mocker.patch('module.helper')
    rm('file')
    helper.<b>assert_called_once_with('file')</b></code></pre>
<p><strong>EDIT</strong>: In case the function is defined in some module, you can wrap it in a decorator locally. For example:</p>
<pre><code>import unittest.mock as mock
<b>from some_module import some_function</b>

<b>some_function = mock.create_autospec(some_function)</b>

def test_unix_fs(mocker):
    some_function('file')
    some_function.assert_called_once_with('file')</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In <strong>oriented object</strong> case:</p>
<pre><code>class Foo:
    def rm(self, filename):
        self.helper(filename, 5)

    def helper(self, filename, number):
        pass

def test_unix_fs(mocker):
    mocker.patch.object(Foo, 'helper')
    foo = Foo()
    foo.rm('file')
    helper.assert_called_once_with('file', 5)
</code></pre>
</div>
<span class="comment-copy">I wish SO had favourite answers and stars so I could click it &amp; remember.</span>
<span class="comment-copy">Problem here is that <code>helper</code> function may be defined in another module. I think that is not good idea add test stuff like <code>@mock.create_autospec</code> in application code.</span>
<span class="comment-copy">@Overflow012: you do not have to do that. You can fetch the function from the module, and add a decorator over it locally.</span>
