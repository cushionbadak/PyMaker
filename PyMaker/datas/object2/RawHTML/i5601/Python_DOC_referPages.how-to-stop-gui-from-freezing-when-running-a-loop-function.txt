<div class="post-text" itemprop="text">
<p>I am trying to add threading to a Python 3.63 Tkinter program where a function will run but the GUI will still be responsive, including if the user wants to close the program while the function is running.</p>
<p>In the example below I have tried to run a simple printing to console function on a separate thread to the GUI mainloop so the user could click the X in the top right to close the program while the loop is running if they so wish.</p>
<p>The error I am getting is:</p>
<p><code>TypeError: start() takes 1 positional argument but 2 were given</code></p>
<pre><code>try:
    import tkinter as tk
    import queue as queue
except:
    import Tkinter as tk
    import Queue as queue
import threading

def center(toplevel,desired_width=None,desired_height=None):
    toplevel.update_idletasks()
    w, h = toplevel.winfo_screenwidth() - 20, toplevel.winfo_screenheight() - 100
    if desired_width and desired_height:
        size = (desired_width,desired_height)
    else:
        size = tuple(int(Q) for Q in toplevel.geometry().split("+")[0].split("x"))
    toplevel.geometry("%dx%d+%d+%d" % (size + (w/2 - size[0]/2, h/2 - size[1]/2)))

class ThreadedTask(threading.Thread):
    def __init__(self,queue):
        threading.Thread.__init__(self)
        self.queue = queue
    def run(self,func):
        func()

class app(tk.Tk):
    def __init__(self):
        tk.Tk.__init__(self)
        center(self,desired_width=500,desired_height=400)
        self.queue = queue.Queue()
        self.run_func_button = tk.Button(self,
                                         text="Run Function",
                                         font=("Calibri",20,"bold"),
                                         command=self.run_func)
        self.run_func_button.pack()

    def run_func(self):
        ThreadedTask(self.queue).start(self.count_to_1500)

    def count_to_1500(self):
        for i in range(1500):
            print (i)

app_start = app()
app_start.mainloop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See doc <a href="https://docs.python.org/3/library/threading.html#threading.Thread.start" rel="nofollow noreferrer">threading</a> - start() doesn't use arguments but you use <code>.start(self.count_to_1500)</code> - and this gives your error. </p>
<p>You could use </p>
<pre><code>Thread(target=self.count_to_1500).start()
</code></pre>
<p>or </p>
<pre><code>Thread(target=self.count_to_1500, args=(self.queue,)).start()
</code></pre>
<p>if you define </p>
<pre><code>def count_to_1500(self, queue):
</code></pre>
<hr/>
<p><strong>EDIT:</strong> working example with thread which put in quoue and method which get data from queue.</p>
<pre><code>try:
    import tkinter as tk
    import queue as queue
except:
    import Tkinter as tk
    import Queue as queue
import threading
import time

def center(toplevel,desired_width=None,desired_height=None):
    toplevel.update_idletasks()
    w, h = toplevel.winfo_screenwidth() - 20, toplevel.winfo_screenheight() - 100
    if desired_width and desired_height:
        size = (desired_width,desired_height)
    else:
        size = tuple(int(Q) for Q in toplevel.geometry().split("+")[0].split("x"))
    toplevel.geometry("%dx%d+%d+%d" % (size + (w/2 - size[0]/2, h/2 - size[1]/2)))

class app(tk.Tk):
    def __init__(self):
        tk.Tk.__init__(self)
        center(self,desired_width=500,desired_height=400)
        self.queue = queue.Queue()
        self.run_func_button = tk.Button(self,
                                         text="Run Function",
                                         font=("Calibri",20,"bold"),
                                         command=self.run_func)
        self.run_func_button.pack()

    def run_func(self):
        threading.Thread(target=self.count_to_1500).start()
        threading.Thread(target=self.count_to_1500_with_queue, args=(self.queue,)).start()
        self.check_queue()

    def count_to_1500(self):
        for i in range(10):
            print('1:', i)
            time.sleep(0.2)

    def count_to_1500_with_queue(self, queue):
        for i in range(10):
            print('put:', i)
            queue.put(i)
            time.sleep(1)
        queue.put('last')

    def check_queue(self):
        print("check queue")
        data = None
        if not self.queue.empty():
            data = self.queue.get()
            print('get:', data)
        if data != 'last':
            self.after(200, self.check_queue)

app_start = app()
app_start.mainloop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thread.start takes no parameters:  <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">https://docs.python.org/3/library/threading.html</a></p>
<p>The correct way to use a Thread is:</p>
<pre><code># Will call func(*args, **kwargs)
t = threading.Thread(target=func, args=(), kwargs={})
t.start()

t.join()
</code></pre>
<p>The join is important. Without it you will have many zombie threads in your app, which will also prevent your app from shutting down cleanly.</p>
<p>Another pattern is to use a daemon thread, which processes a queue. daemon threads are automatically killed when the program exits.</p>
<pre><code>def worker(q):
    while True:
      try:
        f = q.get()
        q.task_done()
        if f is None: return
        f()
      except Exception:
        import traceback
        traceback.print_exc()

q = Queue.Queue()    
t = threading.Thread(target=worker, args=(q,))
t.daemon=True
t.start()


# f is a no-arg function to be executed
q.put(f) 


# Call at shutdown
q.join()
</code></pre>
<p>To run several tasks at the same time, start many threads.</p>
<p>Yet another method, use multiprocessing.pool.ThreadPool</p>
<pre><code>from multiprocessing.pool import ThreadPool

# Create at startup
pool = ThreadPool(8)

# For each treaded task
pool.apply_async(func, args, kwds) 

# Call at shutdown
pool.close()
pool.join()
</code></pre>
<p>... which works, more or less, as the above.</p>
<p>I recommend reading:</p>
<p><a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing-programming" rel="nofollow noreferrer">https://docs.python.org/2/library/multiprocessing.html#multiprocessing-programming</a></p>
</div>
<span class="comment-copy">Please include the error that you are getting as part of your question.</span>
<span class="comment-copy">don't put code in one line with <code>if/else</code> - it makes code less readable.</span>
<span class="comment-copy">show complete error message.</span>
<span class="comment-copy">see doc <a href="https://docs.python.org/3/library/threading.html#threading.Thread.start" rel="nofollow noreferrer">threading</a> - <code>start()</code> doesn't use arguments but you use <code>.start(self.count_to_1500)</code> - and this gives your error. Can't you use <code>Thread(target=self.count_to_1500, args=(self.queue,)</code> ?</span>
<span class="comment-copy">For clarity in <code>ThreadedTask(self.queue).start(self.count_to_1500)</code>  the<code>start</code> method is being passed <i>two</i> arguments, <code>ThreadedTask(self.queue)</code> and <code>self.count_to_1500)</code>. But apparently <code>start</code> needs only <i>one</i> argument.</span>
<span class="comment-copy">I added example with queue</span>
<span class="comment-copy">Without a Thread.join this will generate many zombie threads and also prevent the program from shutting down correctly.</span>
<span class="comment-copy">@user48956 in this example <code>join()</code> is not needed. It will terminate all threads.</span>
<span class="comment-copy">Well.... that depends. If you  CTRL-C to interrupt main, and then CTRL-C again before the threads exit, then you're left with zombies and a non-exiting program.</span>
<span class="comment-copy">... if you t.daemon=True, your program exits immediately at the first CTRL-C</span>
