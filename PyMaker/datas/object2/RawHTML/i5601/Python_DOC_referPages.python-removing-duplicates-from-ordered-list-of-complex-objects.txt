<div class="post-text" itemprop="text">
<p>I have list of several milions of dictionaries produced from json in form like this:</p>
<pre><code>{
  "_id":XXX,
  "some_other":"fields",
  ...
}
</code></pre>
<p>List needs to be safe-sorted by <code>_id</code> key however there are disctionaries with duplicated <code>_id</code>. There's really few duplicates comparing to size of list (around 10-100 at most). I want to take only first (or last, doesn't matter as long as it's deterministic) dictionary for each duplicated <code>_id</code>. In JavaScript I'd use following:</p>
<pre><code>list.sort((a,b)=&gt;a._id&gt;b._id?1:(a._id&lt;b._id?-1:0))
    .filter((ent,i,arr)=&gt;i==0||ent!=arr[i-1])
</code></pre>
<p>However I guess python variant of filter doesn't allow accessing index of item? Is there any similarly short way to accomplish such thing in Python? I found <code>sorted(...)</code> function that allows me to sort this list the way I want, however I still don't know how to filter out following duplicates (without obvious, brute for loop).</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a dictionary to remove duplicates (this will always keep the last occurrence for each _id):</p>
<pre><code>d = {i['_id']: i for i in your_list}
</code></pre>
<p>Then sort its values by _id:</p>
<pre><code>list(sorted(d.values(), key=lambda i: i['_id']))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An idiomatic way, in python, would be:</p>
<pre><code>import itertools
import operator

get_id = operator.itemgetter('_id') #factory function: lambda x:x['_id']
grouped = itertools.groupby(sorted(json_data, key=get_id), get_id)

result = [next(g) for k,g in grouped]
</code></pre>
<p>Note, the built-in python <code>sorted</code> is an stable-sort, using an adaptive merge-sort called timsort.  </p>
<p><code>itertools</code> is a very useful module, implementing various lazy-iterators efficiently. <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> is a grouping iterator:</p>
<pre><code># [k for k, g in groupby('AAAABBBCCDAABBB')] --&gt; A B C D A B
# [list(g) for k, g in groupby('AAAABBBCCD')] --&gt; AAAA BBB CC D                 
</code></pre>
<p>You can create a transliteration of your javascript, using python anonymous functions and a ternary operator (in Python, a "conditional expression"). Note, Python's <code>sorted</code> function doesn't use a comparator function, it uses a <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer">key-based function</a>:</p>
<blockquote>
<p>key specifies a function of one argument that is used to extract a
  comparison key from each list element: <code>key=str.lower</code>. The default
  value is <code>None</code> (compare the elements directly).</p>
</blockquote>
<p>In Python 2, a <code>cmp</code> argument that works similarly to the Javascript version still is available (e.g. a function that returns -1, 1, or 0)</p>
<p><code>cmp</code> was deprecated and finally removed in Python 3 in favor of <code>key</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>sorted</code>, <code>filter</code>, and <code>map</code>:</p>
<pre><code>d = [
    {
        "_id": 3,
        "some_other": "a"
    },
    {
      "_id": 1,
      "some_other": "b"
    },
    {
        "_id": 2,
        "some_other": "c"
    },
    {
        "_id": 2,
        "some_other": "d"
    }
]

sorted_d = sorted(d, key=lambda x: x['_id'])
map(
    lambda y: y[1],
    filter(
        lambda x: True if x[0]==0 else sorted_d[x[0]]["_id"] != sorted_d[x[0]-1]["_id"],
        enumerate(sorted_d)
    )
)
</code></pre>
<p>Output:</p>
<pre><code>[{'_id': 1, 'some_other': 'b'},
 {'_id': 2, 'some_other': 'c'},
 {'_id': 3, 'some_other': 'a'}]
</code></pre>
</div>
<span class="comment-copy">have you looked at <code>sorted</code> and <code>filter</code>? Python has <code>map</code>, <code>filter</code>, and <code>reduce</code> constructs, and you could write an equivalent expression with Python's (a bit unwieldy) anonymous function syntax, using <code>lambda args: &lt;expression with args&gt;</code>... Although, for filtering/mapping, frequently list-comprehensions (and related constructs, e.g. <code>dict</code> comprehensions, <code>set</code> comprehensions, or even generator expressions) are considered more idiomatic.</span>
