<div class="post-text" itemprop="text">
<p>I'm going through Problem 3 of the MIT lead python course, and I have an admittedly long drawn out script that feels like it's getting close. I need to print the longest substring of s in which the letters occur in alphabetical order. I'm able to pull out any characters that are in alphabetical order with regards to the character next to it. What I need to see is:</p>
<p>Input : <code>'aezcbobobegghakl'</code></p>
<p>needed output: <code>'beggh'</code></p>
<p>my output: <code>['a', 'e', 'b', 'b', 'b', 'e', 'g', 'g', 'a', 'k']</code></p>
<p>My code: </p>
<pre><code>s = 'aezcbobobegghakl'

a = 'abcdefghijklmnopqrstuvwxyz'

len_a = len(a)
len_s = len(s)

number_list = []
letter_list = []

for i in range(len(s)):
    n = 0
    letter = s[i+n]
    if letter in a:
        number_list.append(a.index(letter))
        n += 1

print(number_list)

for i in number_list:
    letter_list.append(a[i])

print(letter_list)

index_list = []
for i in range(len(letter_list)):
    index_list.append(i)

print(index_list)

first_check = []

for i in range(len(letter_list)-1):
    while number_list[i] &lt;= number_list[i+1]:
        print(letter_list[i])
        first_check.append(letter_list[i])
        break

print(first_check)
</code></pre>
<p>I know after looking that there are much shorter and completely different ways to solve the problem, but for the sake of my understanding, is it even possible to finish this code to get the output I'm looking for? Or is this just a lost cause rabbit hole I've dug?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would build a generator to output all the runs of characters such that <code>l[i] &gt;= l[i-1]</code>.  Then find the longest of those runs.  Something like</p>
<pre><code>def runs(l):
    it = iter(l)
    try:
        run = [next(it)]
    except StopIteration:
        return
    for i in it:
        if i &gt;= run[-1]:
            run.append(i)
        else:
            yield run
            run = [i]
    yield run

def longest_increasing(l):
    return ''.join(max(runs(l), key=len))
</code></pre>
<p>Edit: Notes on your code</p>
<pre><code>for i in range(len(s)):
    n = 0
    letter = s[i+n]
    if letter in a:
        number_list.append(a.index(letter))
        n += 1
</code></pre>
<p>is getting the "number value" for each letter.  You can use the <code>ord</code> function to simplify this</p>
<pre><code>number_list = [ord(c) - 97 for c in s if c.islower()]
</code></pre>
<p>You never use <code>index_list</code>, and you never should.  Look into the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> function.</p>
<pre><code>first_check = []

for i in range(len(letter_list)-1):
    while number_list[i] &lt;= number_list[i+1]:
        print(letter_list[i])
        first_check.append(letter_list[i])
        break
</code></pre>
<p>this part doesn't make a ton of sense.  You <code>break</code> out of the <code>while</code> loop every time, so it's basically an <code>if</code>. You have no way of keeping track of more than one run. You have no mechanism here for comparing runs of characters against one another. I think you might be trying to do something like </p>
<pre><code>max_run = []
for i in range(len(letter_list)-1):
    run = []
    for j in range(i, len(letter_list)):
        run.append(letter_list[j])
        if letter_list[j] &gt; letter_list[j+1]:
            break
    if len(run) &gt; len(max_run):
        max_run = run
</code></pre>
<p>(Disclaimer: I'm pretty sure the above is off by one but it should be illustrative).  The above can be improved in a lot of ways.  Note that it loops over the last character as many as <code>len(s)</code> times, making it a <code>n**2</code> solution.  Also, I'm not sure why you need <code>number_list</code>, as strings can be compared directly. </p>
</div>
<div class="post-text" itemprop="text">
<p>What about a simple recursive approach :</p>
<pre><code>data = 'ezcbobobegghakl'
words=list(data)

string_s=list(map(chr,range(97,123)))

final_=[]
def ok(list_1,list_2):

    if not list_1:
        return 0
    else:
        first = list_1[0]
        chunks = list_2[list_2.index(first):]

        track = []

        for j, i in enumerate(list_1):

            if i in chunks:
                track.append(i)
                chunks=list_2[list_2.index(i):]

            else:
                final_.append(track)
                return ok(list_1[j:],list_2)
            final_.append(track)



print(ok(words,string_s))
print(max(final_,key=lambda x:len(x)))
</code></pre>
<p>output:</p>
<pre><code>['b', 'e', 'g', 'g', 'h']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can find a list of all substrings of the input string, and then find all the strings that are sorted alphabetically. To determine of a letter is sorted alphabetically, sorted the original string by position in the alphabet, and then see if the final string equals the original string:</p>
<pre><code>from string import ascii_lowercase as l
s = 'aezcbobobegghakl'
substrings = set(filter(lambda x:x, [s[i:b] for i in range(len(s)) for b in range(len(s))]))
final_substring = max([i for i in substrings if i == ''.join(sorted(list(i), key=lambda x:l.index(x)))], key=len)
</code></pre>
<p>Output:</p>
<pre><code>'beggh'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is one way of getting the job done:</p>
<pre><code>s = 'aezcbobobegghakl'
l = list(s)
run = []
allrun = []
element = 'a'

for e in l:
    if e &gt;= element:
        run.append(e)
        element = e
    else:
        allrun.append(run)
        run = [e]
        element = e

lengths = [len(e) for e in allrun]
result = ''.join(allrun[lengths.index(max(lengths))])
</code></pre>
<p>"run" is basically an uninterrupted run; it keeps growing as you add elements bigger than what is previously seen ("b" is bigger than "a", just string comparison), and resets else. </p>
<p>"allrun" contains all "run"s, which looks like this:</p>
<pre><code>[['a', 'e', 'z'], ['c'], ['b', 'o'], ['b', 'o'], ['b', 'e', 'g', 'g', 'h']]
</code></pre>
<p>"result" finally picks the longest "run" in "allrun", and merges it into one string.</p>
<hr/>
<p>Regarding your code:</p>
<p>It is very very inefficient, I would not proceed with it. I would adopt one of the posted solutions. </p>
<p>Your number_list can be written as [a.index(_) for _ in s], one liner.</p>
<p>Your letter_list is actually just list(s), and you are using a loop for that! </p>
<p>Your index_list, what does it even do? It is equivalent to range(len(letter_list)), so what are you aiming with the append in the loop? </p>
<p>Finally, the way you write loops reminds me of matlab. You can just iterate on the elements of a list, no need to iterate on index and fetch the corresponding element in list.</p>
</div>
<span class="comment-copy">I've seen this solution around, but my particular question was, going with the flow of logic on the code I gave, is it possible to finish it out to get the desired result? I know it can be better, I'm just trying to understand how to get mine to work.</span>
<span class="comment-copy">Thank you for the thorough explanation! Much appreciated.</span>
