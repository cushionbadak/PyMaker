<div class="post-text" itemprop="text">
<p>"All slice operations return a new list containing the requested elements"
This is from the python tutorials.</p>
<p>But if this is the case then why does this piece of code behave this way: </p>
<pre><code>&gt;&gt;&gt; a = [11, 3, 1999]
&gt;&gt;&gt; a[:] = [9, 78]
&gt;&gt;&gt; a
    [9, 78]
</code></pre>
<p>1) if slicing returned a new list then why does the binding that I have done to the new one affect the original one. What does this suggest?</p>
<p>But then I have also observed this:</p>
<pre><code>&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; b[:].append(5)
&gt;&gt;&gt; b
[4, 5, 6]
&gt;&gt;&gt; print(b)
[4, 5, 6]
</code></pre>
<p>2) This shows that indeed a new list is returned. What is really happening when      we slice a list?</p>
<p>Please point out my ignorance. Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are confusing <em>expressions</em> with <em>assignment</em>. Getting values (reading) is handled differently from setting values (writing).</p>
<p>Assignment (setting) re-uses syntax to specify a target. In an assignment like <code>a[:] = ...</code>, <code>a[:]</code> is a target to which the assignment takes place. Using <code>a[:]</code> in an expression produces a new list.</p>
<p>In other words: you have two different language statements, that are deliberately using the same syntax. They are still distinct however.</p>
<p>See the <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow noreferrer"><em>Assignment statements</em> reference documentation</a>:</p>
<blockquote>
<pre><code>assignment_stmt ::=  (target_list "=")+ (starred_expression | yield_expression)
target_list     ::=  target ("," target)* [","]
target          ::=  identifier
                     | "(" [target_list] ")"
                     | "[" [target_list] "]"
                     | attributeref
                     | subscription
                     | slicing
                     | "*" target
</code></pre>
<p>[...]</p>
<ul>
<li>If the target is a slicing: The primary expression in the reference is evaluated. It should yield a mutable sequence object (such as a list). The assigned object should be a sequence object of the same type. Next, the lower and upper bound expressions are evaluated, insofar they are present; defaults are zero and the sequence’s length. The bounds should evaluate to integers. If either bound is negative, the sequence’s length is added to it. The resulting bounds are clipped to lie between zero and the sequence’s length, inclusive. <strong>Finally, the sequence object is asked to replace the slice with the items of the assigned sequence. The length of the slice may be different from the length of the assigned sequence, thus changing the length of the target sequence, if the target sequence allows it.</strong></li>
</ul>
</blockquote>
<p>(Bold emphasis mine).</p>
<p>Compare this with the <a href="https://docs.python.org/3/reference/expressions.html#slicings" rel="nofollow noreferrer"><em>Slicings</em> section</a> in the expressions reference documentation; slicing in an expression produces a <a href="https://docs.python.org/3/reference/datamodel.html#types" rel="nofollow noreferrer"><code>slice()</code> object</a>, which the <code>list.__getitem__</code> method interprets as a request for a new list object with the matching indices copied over. Other object types can choose to interpret a slice object differently.</p>
<p>Note that there is a <em>third</em> operation, the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-del-statement" rel="nofollow noreferrer"><code>del</code> statement</a> to <em>delete</em> references, including slices. Deletion takes the same <code>target_list</code> syntax and asks to <em>remove</em> the indices indicated by a slice.</p>
<p>These three operations are, under the hood, implemented by the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>object.__getitem__()</code></a> (reading), <a href="https://docs.python.org/3/reference/datamodel.html#object.__setitem__" rel="nofollow noreferrer"><code>object.__setitem__()</code></a> (writing) and <a href="https://docs.python.org/3/reference/datamodel.html#object.__delitem__" rel="nofollow noreferrer"><code>object.__delitem__()</code></a> (deleting) hook methods; the <code>key</code> argument to each of these operations is a <code>slice()</code> object, but only <code>__getitem__</code> is expected to return anything.</p>
</div>
<span class="comment-copy">Assignment to a <i>target</i> is not the same thing as using slicing in an expression.</span>
<span class="comment-copy">for <code>a[:] = [9, 78]</code>, you're effectively doing <code>a = [9, 78]</code>... for <code>b[:].append(5)</code>, your return value is being trashed</span>
<span class="comment-copy">@taesu: no, you are not. You are replacing the <i>elements in <code>a</code></i>. Your alternative <i>creates a new list</i>. The difference matters when you have more than one reference to that list object.</span>
<span class="comment-copy">What I am asking is if slicing was returning a new list, then the assignment I did would not have affected the original list. Right?</span>
<span class="comment-copy">Wait are you saying that although we are doing the same slicing operation in both contexts, but we get different results since the contexts are different @Martijn Pieters♦</span>
<span class="comment-copy">@Allen: yes, assignment does something different. <i>Setting</i> (writing) is not the same thing as <i>getting</i> (reading).</span>
<span class="comment-copy">Thanks a lot @Martijn Pieters♦ . Now I understand. By the way who said Python is 'SIMPLE' :-)</span>
<span class="comment-copy">@Allen: how much experience do you have with other languages? Really, Python is <i>clear and consistent</i>.</span>
<span class="comment-copy">Well I am currently taking cs50x from edx. That says about my experience. What I meant by not being simple is that in C, operators have a fixed meaning no matter the context. Python is indeed simple to learn I agree with you, but when we go into things like this it seems not too simple, it becomes hard to figure it out. @Martijn Pieters♦</span>
