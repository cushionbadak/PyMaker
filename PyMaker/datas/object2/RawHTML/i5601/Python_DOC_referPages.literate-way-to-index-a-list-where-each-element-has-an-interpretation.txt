<div class="post-text" itemprop="text">
<p>Tl;dr is bold-faced text.</p>
<p>I'm working with an image dataset that comes with boolean "one-hot" image annotations (Celeba to be specific). The annotations encode facial features like <em>bald</em>, <em>male</em>, <em>young</em>. Now <strong>I want to make a custom one-hot list</strong> (to test my GAN model). I want to provide a <strong>literate interface</strong>. I.e., rather than specifying <code>features[12]=True</code> knowing that <code>12</code> - counting from zero - corresponds to the <em>male</em> feature, I want something like <code>features[male]=True</code> or <code>features.male=True</code>.</p>
<p>Suppose the header of my <code>.txt</code> file is</p>
<pre><code>Arched_Eyebrows Attractive Bags_Under_Eyes Bald Bangs Chubby Male Wearing_Necktie Young
</code></pre>
<p>and I want to codify <em>Young</em>, <em>Bald</em>, and <em>Chubby</em>. <strong>The expected output is</strong></p>
<pre><code>[ 0.  0.  0.  1.  0.  1.  0.  0.  1.]
</code></pre>
<p>since <em>Bald</em> is the fourth entry of the header, <em>Chubby</em> is the sixth, and so on. <strong>What is the clearest way to do this without expecting a user to know <em>Bald</em> is the fourth entry, etc.?</strong> </p>
<p>I'm looking for a Pythonic way, not <em>necessarily</em> the fastest way.</p>
<h1>Ideal Features</h1>
<p>In rough order of importance:</p>
<ol>
<li>A way to accomplish my stated goal that is already standard in the Python community will take precedence.</li>
<li>A user/programmer should not need to count to an attribute in the <code>.txt</code> header. This is the point of what I'm trying to design.</li>
<li>A user should not be expected to have non-standard libraries like <code>aenum</code>.</li>
<li>A user/programmer should not need to reference the <code>.txt</code> header for attribute names/available attributes. One example: if a user wants to specify the gender attribute but does not know whether to use <code>male</code> or <code>female</code>, it should be easy to find out.</li>
<li>A user/programmer should be able to find out the available attributes via documentation (ideally generated by Sphinx api-doc). That is, the point 4 should be possible reading as little code as possible. Attribute exposure with <code>dir()</code> sufficiently satisfies this point.</li>
<li>The programmer should find the indexing tool natural. Specifically, zero-indexing should be preferred over subtracting from one-indexing.</li>
<li>Between two otherwise completely identical solutions, one with better performance would win.</li>
</ol>
<h1>Examples:</h1>
<p>I'm going to compare and contrast the ways that immediately came to my mind. <strong>All examples use:</strong></p>
<pre><code>import numpy as np
header = ("Arched_Eyebrows Attractive Bags_Under_Eyes "
          "Bald Bangs Chubby Male Wearing_Necktie Young")
NUM_CLASSES = len(header.split())  # 9
</code></pre>
<h2>1: Dict Comprehension</h2>
<p>Obviously we could use a dictionary to accomplish this:</p>
<pre><code>binary_label = np.zeros([NUM_CLASSES])
classes = {head: idx for (idx, head) in enumerate(header.split())}
binary_label[[classes["Young"], classes["Bald"], classes["Chubby"]]] = True
print(binary_label)
</code></pre>
<p>For what it's worth, this has the fewest lines of code and is the only one that doesn't rely on a standard library over builtins. As for negatives, it isn't exactly self-documenting. To see the available options, you must <code>print(classes.keys())</code> - it's not exposed with <code>dir()</code>. This borders on not satisfying feature 5 because it requires a user to know <code>classes</code> is a dict to exposure features AFAIK.</p>
<h2>2: Enum:</h2>
<p>Since I'm learning C++ right now, <code>Enum</code> is the first thing that came to mind:</p>
<pre><code>import enum
binary_label = np.zeros([NUM_CLASSES])
Classes = enum.IntEnum("Classes", header)
features = [Classes.Young, Classes.Bald, Classes.Chubby]
zero_idx_feats = [feat-1 for feat in features]
binary_label[zero_idx_feats] = True
print(binary_label)
</code></pre>
<p>This gives dot notation and the image options are exposed with <code>dir(Classes)</code>. However, <code>enum</code> uses one-indexing by default (the reason is <a href="https://docs.python.org/3/library/enum.html#functional-api" rel="nofollow noreferrer">documented</a>). The work-around makes me feel like <code>enum</code> is not the Pythonic way to do this, and entirely fails to satisfy feature 6.</p>
<h2>3: Named Tuple</h2>
<p>Here's another one out of the standard Python library:</p>
<pre><code>import collections
binary_label = np.zeros([NUM_CLASSES])
clss = collections.namedtuple(
    "Classes", header)._make(range(NUM_CLASSES))
binary_label[[clss.Young, clss.Bald, clss.Chubby]] = True
print(binary_label)
</code></pre>
<p>Using <code>namedtuple</code>, we again get dot notation and self-documentation with <code>dir(clss)</code>. But, the <code>namedtuple</code> class is heavier than <code>enum</code>. By this I mean, <code>namedtuple</code> has functionality I do not need. This solution appears to be a leader among my examples, but I do not know if it satisfies feature 1 or if an alternative could "win" via feature 7.</p>
<h2>4: Custom Enum</h2>
<p>I could really break my back:</p>
<pre><code>binary_label = np.zeros([NUM_CLASSES])
class Classes(enum.IntEnum):
    Arched_Eyebrows = 0
    Attractive = 1
    Bags_Under_Eyes = 2
    Bald = 3
    Bangs = 4
    Chubby = 5
    Male = 6
    Wearing_Necktie = 7
    Young = 8
binary_label[
    [Classes.Young, Classes.Bald, Classes.Chubby]] = True
print(binary_label)
</code></pre>
<p>This has all the advantages of Ex. 2. But, it comes with obvious the obvious drawbacks. I have to write out <em>all the features</em> (there's <em>40</em> in the real dataset) just to zero-index! Sure, this is how to make an enum in C++ (AFAIK), but it shouldn't be necessary in Python. This is a slight failure on feature 6.</p>
<h1>Summary</h1>
<p>There are many ways to accomplish literate zero-indexing in Python. <strong>Would you provide a code snippet of how you would accomplish what I'm after and tell me why your way is right?</strong> </p>
<p>(edit:) <strong>Or explain why one of my examples is the right tool for the job?</strong></p>
<hr/>
<h1>Status Update:</h1>
<p>I'm not ready to accept an answer yet in case anyone wants to address the following feedback/update, or any new solution appears. Maybe another 24 hours? All the responses have been helpful, so I upvoted everyone's so far. You may want to look over this <a href="https://github.com/flauted/SO-literate-index" rel="nofollow noreferrer">repo</a> I'm using to test solutions. <strong>Feel free to tell me if my following remarks are (in)accurate or unfair:</strong></p>
<h3>zero-enum:</h3>
<p>Oddly, Sphinx documents this incorrectly (one-indexed in docs), but it does document it! I suppose that "issue" doesn't fail any ideal feature.</p>
<h3>dotdict:</h3>
<p>I feel that <code>Map</code> is overkill, but <code>dotdict</code> is acceptable. Thanks to both answerers that got this solution working with <code>dir()</code>. However, it doesn't appear that it "works seamlessly" with Sphinx.</p>
<h3>Numpy record:</h3>
<p>As written, this solution takes significantly longer than the other solutions. It comes in at 10x slower than a <code>namedtuple</code> (fastest behind pure dict) and 7x slower than standard <code>IntEnum</code> (slowest behind numpy record). That's not drastic at current scale, <em>nor a priority</em>, but a quick Google search indicates <code>np.in1d</code> is in fact slow. Let's stick with</p>
<pre><code>_label = np.zeros([NUM_CLASSES])
_label[[header_rec[key].item() for key in ["Young", "Bald", "Chubby"]]] = True
</code></pre>
<p>unless I've implemented something wrong in the linked repo. This brings the execution speed into a range that compares with the other solutions. Again, no Sphinx.</p>
<h3>namedtuple (and rassar's critiques)</h3>
<p>I'm not convinced of your <code>enum</code> critique. It seems to me that you believe I'm approaching the problem wrong. It's fine to call me out on that, but I don't see how using the <code>namedtuple</code> is fundamentally different from "Enum [which] will provide separate values for each constant." Have I misunderstood you?</p>
<p>Regardless, <code>namedtuple</code> appears in Sphinx (correctly numbered, for what it's worth). On the Ideal Features list, this chalks up identically to zero-enum <strong>and</strong> profiles ahead of zero-enum.</p>
<h2>Accepted Rationale</h2>
<p>I accepted the zero-enum answer because the answer gave me the best challenger for <code>namedtuple</code>. <strong>By my standards, <code>namedtuple</code> is marginally the best solution.</strong> But salparadise wrote the answer that helped me feel confident in that assessment. Thanks to all who answered.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about a factory function to create a <strong>zero</strong> indexed <code>IntEnum</code> since that is the object that suits your needs, and <code>Enum</code> provides flexibility in construction:</p>
<pre><code>from enum import IntEnum

def zero_indexed_enum(name, items):
    # splits on space, so it won't take any iterable. Easy to change depending on need.
    return IntEnum(name, ((item, value) for value, item in enumerate(items.split())))
</code></pre>
<p>Then:</p>
<pre><code>In [43]: header = ("Arched_Eyebrows Attractive Bags_Under_Eyes "
    ...:           "Bald Bangs Chubby Male Wearing_Necktie Young")
In [44]: Classes = zero_indexed_enum('Classes', header)

In [45]: list(Classes)
Out[45]:
[&lt;Classes.Arched_Eyebrows: 0&gt;,
 &lt;Classes.Attractive: 1&gt;,
 &lt;Classes.Bags_Under_Eyes: 2&gt;,
 &lt;Classes.Bald: 3&gt;,
 &lt;Classes.Bangs: 4&gt;,
 &lt;Classes.Chubby: 5&gt;,
 &lt;Classes.Male: 6&gt;,
 &lt;Classes.Wearing_Necktie: 7&gt;,
 &lt;Classes.Young: 8&gt;]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a custom class which I like to call as <code>DotMap</code> or as mentioned here is this SO discussion as <code>Map</code>: </p>
<ul>
<li><a href="https://stackoverflow.com/a/32107024/2598661">https://stackoverflow.com/a/32107024/2598661</a> (<code>Map</code>, longer complete version)</li>
<li><a href="https://stackoverflow.com/a/23689767/2598661">https://stackoverflow.com/a/23689767/2598661</a> (<code>dotdict</code>, shorter lighter version)</li>
</ul>
<p>About <code>Map</code>:</p>
<ul>
<li>It has the features of a dictionary since the input to a Map/DotMap is a dict. You can access attributes using <code>features['male']</code>.</li>
<li>Additionally you can access the attributes using dot i.e. <code>features.male</code> and the attributes will be exposed when you do <code>dir(features)</code>.</li>
<li>It is only as heavy as it needs to be in order to enable the dot functionality.</li>
<li>Unlike <code>namedtuple</code> you don't need to pre-define it and you can add and remove keys willy nilly.</li>
<li>The <code>Map</code> function described in the SO question is not Python3 compatible because it uses <code>iteritems()</code>. Just replace it with <code>items()</code> instead.</li>
</ul>
<p>About <code>dotdict</code>:</p>
<ul>
<li><code>dotdict</code> provides the same advantages of <code>Map</code> with the exception that it does not override the <code>dir()</code> method therefore you will not be able to obtain the attributes for documentation. @SigmaPiEpsilon has provided a fix for this <a href="https://stackoverflow.com/a/48001538/2598661">here</a>.</li>
<li>It uses the <code>dict.get</code> method instead of <code>dict.__getitem__</code> therefore it will return <code>None</code> instead of throwing <code>KeyError</code> when you are access attributes that don't exist.</li>
<li>It does not recursively apply <code>dotdict-iness</code> to nested dicts therefore you won't be able to use <code>features.foo.bar</code>.</li>
</ul>
<p>Here's the updated version of <code>dotdict</code> which solves the first two issues:</p>
<pre><code>class dotdict(dict):
    __getattr__ = dict.__getitem__  # __getitem__ instead of get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__
    def __dir__(self):              # by @SigmaPiEpsilon for documentation
        return self.keys()
</code></pre>
<h3>Update</h3>
<p><code>Map</code> and <code>dotdict</code> don't have the same behavior as pointed out by @SigmaPiEpsilon so I added separate descriptions for both.</p>
</div>
<div class="post-text" itemprop="text">
<p>Of your examples, 3 is the most pythonic answer to your question.</p>
<p>1, as you said, does not even answer your question, since the names are not explicit. </p>
<p>2 uses enums, which though being in the standard library are not pythonic and generally not used in these scenarios in Python.
(Edit): In this case you only really need two different constants - the target values and the other ones. An Enum will provide separate values for each constant, which is not what the goal of your program is and seems to be a roundabout way of approaching the problem.</p>
<p>4 is just not maintainable if a client wants to add options, and even as it is it's painstaking work.</p>
<p>3 uses well-known classes from the standard library in a readable and succinct way. Also, it does not have any drawbacks, as it is perfectly explicit. Being too "heavy" doesn't matter if you don't care about performance, and anyway the lag will be unnoticeable with your input size.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your requirements if I understand correctly can be divided into two parts:</p>
<ol>
<li><p>Access the position of header elements in the <code>.txt</code> by name in the most pythonic way possible and with minimum external dependencies</p></li>
<li><p>Enable dot access to the data structure containing the names of the headers to be able to call <code>dir()</code> and setup easy interface with Sphinx</p></li>
</ol>
<h2>Pure Python Way (no external dependencies)</h2>
<p>The most pythonic way to solve the problem is of course the method using dictionaries (dictionaries are at the heart of python). Searching a dictionary through key is also much faster than other methods. The only problem is this prevents dot access. Another answer mentions the <a href="https://stackoverflow.com/a/32107024/2116081">Map</a> and <a href="https://stackoverflow.com/a/23689767/2116081">dotdict</a> as alternatives. <code>dotdict</code> is simpler but it only enable dot access, it will not help in the documentation aspect with <code>dir()</code> since <code>dir()</code> calls the <code>__dir__()</code> method which is not overridden in these cases. Hence it will only return the attributes of Python <code>dict</code> and not the header names. See below:</p>
<pre><code>&gt;&gt;&gt; class dotdict(dict):
...     __getattr__ = dict.get
...     __setattr__ = dict.__setitem__
...     __delattr__ = dict.__delitem__
... 
&gt;&gt;&gt; somedict = {'a' : 1, 'b': 2, 'c' : 3}                                                                                                          
&gt;&gt;&gt; somedotdict = dotdict(somedict)
&gt;&gt;&gt; somedotdict.a
1
&gt;&gt;&gt; 'a' in dir(somedotdict)
False
</code></pre>
<p>There are two options to get around this problem.</p>
<p><strong>Option 1</strong>: Override the <code>__dir__()</code> method like below. But this will only work when you call <code>dir()</code> on the instances of the class. To make the changes apply for the class itself you have to create a metaclass for the class. See <a href="https://stackoverflow.com/questions/46120462/how-to-override-the-dir-method-for-a-class">here</a></p>
<pre><code>#add this to dotdict
def __dir__(self):
    return self.keys()

&gt;&gt;&gt; somedotdictdir = dotdictdir(somedict)
&gt;&gt;&gt; somedotdictdir.a
1
&gt;&gt;&gt; dir(somedotdictdir)
['a', 'b', 'c']
</code></pre>
<p><strong>Option 2</strong>: A second option which makes it much closer to user-defined object with attributes is to update the <code>__dict__</code> attribute of the created object. This is what <a href="https://stackoverflow.com/a/32107024/2116081">Map</a> also uses. A normal python <code>dict</code> does not have this attribute. If you add this then you can call <code>dir()</code> to get attributes/keys and also all the additional methods/attributes of python <code>dict</code>. If you just want the stored attribute and values you can use <code>vars(somedotdictdir)</code> which is also useful for documentation.</p>
<pre><code>class dotdictdir(dict):

    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self.__dict__.update({k : v for k,v in self.items()})
    def __setitem__(self, key, value):
        dict.__setitem__(self, key, value)
        self.__dict__.update({key : value})
    __getattr__ = dict.get #replace with dict.__getitem__ if want raise error on missing key access
    __setattr__ = __setitem__
    __delattr__ = dict.__delitem__

&gt;&gt;&gt; somedotdictdir = dotdictdir(somedict)
&gt;&gt;&gt; somedotdictdir
{'a': 3, 'c': 6, 'b': 4}
&gt;&gt;&gt; vars(somedotdictdir)
{'a': 3, 'c': 6, 'b': 4}
&gt;&gt;&gt; 'a' in dir(somedotdictdir)
True
</code></pre>
<h2>Numpy way</h2>
<p>Another option will be to use a numpy <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.recarray.html" rel="nofollow noreferrer"><code>record</code></a> array which allows dot access. I noticed in your code you are already using numpy. In this case too <code>__dir__()</code> has to be overrridden to get the attributes. This may result in faster operations (not tested) for data with lots of other numeric values. </p>
<pre><code>&gt;&gt;&gt; headers = "Arched_Eyebrows Attractive Bags_Under_Eyes Bald Bangs Chubby Male Wearing_Necktie Young".split()
&gt;&gt;&gt; header_rec = np.array([tuple(range(len(headers)))], dtype = zip(headers, [int]*len(headers)))
&gt;&gt;&gt; header_rec.dtype.names                                                                                                                           
('Arched_Eyebrows', 'Attractive', 'Bags_Under_Eyes', 'Bald', 'Bangs', 'Chubby', 'Male', 'Wearing_Necktie', 'Young')
&gt;&gt;&gt; np.in1d(header_rec.item(), [header_rec[key].item() for key in ["Young", "Bald", "Chubby"]]).astype(int)
array([0, 0, 0, 1, 0, 1, 0, 0, 1])
</code></pre>
<p>In Python 3, you will need to use <code>dtype=list(zip(headers, [int]*len(headers)))</code> since <code>zip</code> became its own object.</p>
</div>
<span class="comment-copy">The only drawback you gave for <code>namedtuple</code> is that it's "too heavy". You didn't make it sound like it was missing features you need, nor that the extra features would <i>actively get in the way</i>. So to me, this is the clear and obvious winner. I don't think there is anything more Pythonic than taking a well-known, well-understood standard library feature which meets all your requirements and just using it.</span>
<span class="comment-copy">Of your examples, 3 is the most pythonic - 1 is not explicit, 4 is too explicit, and generally enums are not pythonic for things like this, especially with the indexing difference. 3 is more readable, uses well-known stdlib, and has no real drawbacks.</span>
<span class="comment-copy">@JohnY See the edit. Your comment would serve as an answer to how I intended the question.</span>
<span class="comment-copy">@rassar See my comment to JohnY above.</span>
<span class="comment-copy">This seems to be an incomplete/too subjective question. In each of the cases you present disparate and sometimes conflicting arguments. For the dictionary example you mention preference for built-ins over standard library. Then you mention need to use <code>dir()</code>. For namedtuple you mention being too heavy. If you can clearly state what the goal of the program is from the programmer (you) and the user point of view, i.e. how the program is meant to be used, why the user has to use <code>dir()</code> and not <code>classes.keys()</code> then it will be easier to answer. Maybe a list of required features too?</span>
<span class="comment-copy">Defining an entire new class might be overkill for this question.</span>
<span class="comment-copy">@rassar OP seemed ok with it since method-4 in the question is a custom class. And the second link i.e. <code>shorter lighter version</code> is pretty small anyway.</span>
<span class="comment-copy">+1 for a creative response and discussing advantages! I agree that the "shorter lighter version" could be appropriate.</span>
<span class="comment-copy">These methods are not sufficient on their own as none of these classes override <code>__dir__()</code> which is what is called by <code>dir()</code>. Using <code>dir()</code> on these instances will only give the attributes of python <code>dict</code>. The primary need for dot access as I understood was to facilitate easy documentation through sphinx by <code>dir()</code>. See my answer below.</span>
<span class="comment-copy">I agree with your assessment and I appreciate additional feedback on my examples. I'm curious: Why do you say <code>enums</code> are not Pythonic? Could you maybe include a short, good use for enums if they're not for enumerating lists? I understand this is an additional question, but it would support your argument for <code>namedtuple</code>.</span>
<span class="comment-copy">Good question, updated.</span>
<span class="comment-copy">I hope you don't mind, I updated my answer using your suggestion for completeness. Thanks for pointing it out.</span>
<span class="comment-copy">In your numpy solution, Python 3 requires <code>list(zip(...))</code>. I made an edit for you.</span>
<span class="comment-copy">Thanks for the edit.</span>
<span class="comment-copy">@Nitred No problem and you're welcome.</span>
<span class="comment-copy">@DylanF I added a second way to enable accessing the keys/attributes both through <code>dir()</code> and <code>vars()</code>.</span>
