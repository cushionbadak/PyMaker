<div class="post-text" itemprop="text">
<p>This is what I have in mind because I find myself typing the name twice whenever I want to inspect the value of a variable:</p>
<pre><code>a = 1
my_print(a)  # "a: 1"
</code></pre>
<p>Is this possible in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are in control of the calling function, you can hack this to work reasonably well like:</p>
<h3>Code:</h3>
<pre><code>import inspect

def print_name_and_value(var):
    lines = inspect.stack()[1][4]
    var_name = ''.join(lines).strip().split('(')[-1].split(')')[0]
    print("%s: %d" % (var_name, var))

a = 5
print_name_and_value(a)
</code></pre>
<h3>Results:</h3>
<pre><code>a: 5
</code></pre>
<h3>How does this work?</h3>
<p>The <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">inspect</a> module can be used to inspect the caller, and get the line of code used by the caller.  With a bit of string hacking the variable name (assuming it is a simple variable and not a more complex expression) can be gathered from the source code.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would say "no", and any other magic doable is just... too much magic.</p>
<p><strong>However</strong> there's something you can do, and that's looking at the stack trace using the <a href="https://docs.python.org/2/library/inspect.html" rel="nofollow noreferrer">inspect module</a>.</p>
<pre><code>import inspect


def my_print(thingy):
    # print("id(thingy)=%s" % id(thingy))
    previous_frame = inspect.currentframe().f_back
    # print("locals: %s" % previous_frame.f_locals)
    for variable_name, variable_value in previous_frame.f_locals.items():
        if id(variable_value) == id(thingy):
            return("%s: %s" % (variable_name, variable_value))

    # print("globals: %s" % previous_frame.f_globals)
    for variable_name, variable_value in previous_frame.f_globals.items():
        if id(variable_value) == id(thingy):
            return("%s: %s" % (variable_name, variable_value))


if __name__ == '__main__':
    a = 1
    print("Test %s" % my_print(a))  # "a: 1"
    list_thingy = [1, 2, 3]
    print("Test %s" % my_print(list_thingy))

    def and_within_function():
        d = {1: "a"}
        print("Test %s" % my_print(d))

    and_within_function()
</code></pre>
<p>But this is not reliable and <strong>I'd use it more as a curiosity</strong>, since there are plenty of "special cases". For instance: the first 255 integers (I think) in Python occupy a specific memory address so, if you have two variables that are <code>=1</code> I don't think you're gonna really be guaranteed which one is it.</p>
</div>
<span class="comment-copy">No it's not possible, if you need this functionality use a <code>dict</code>. Just consider how <code>my_print()</code> is defined, e.g. <code>def my_print(arg1): ...</code> how could it possibly know that it was called <code>a</code> in the calling context.</span>
<span class="comment-copy">For anyone interested, <code>inspect.stack()[1]</code> is a frame object which has a <code>__getitem__</code> method. Its first 5 items are 'frame', 'filename', 'lineno', 'function' and 'code_context'.</span>
