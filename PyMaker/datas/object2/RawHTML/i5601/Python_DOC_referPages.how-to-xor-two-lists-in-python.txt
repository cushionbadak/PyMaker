<div class="post-text" itemprop="text">
<p>I've got two lists, for example:</p>
<pre><code>a = ['hello','world']
b = ['hello','world','im','steve']
</code></pre>
<p>If I want to create a third list that only contains elements NOT in both:</p>
<pre><code>c = ['im','steve']
</code></pre>
<p>How do I do this if the order of the elements IS important? I know I can use sets but they keep throwing out the order of my lists. I could use <code>' '.join(list)</code> to convert them to strings but not sure how to do this operation in that format either.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can concatenate the lists and use list comprehension:</p>
<pre><code>a = ['hello','world']
b = ['hello','world','im','steve']
final_vals = [i for i in a+b if i not in a or i not in b]
</code></pre>
<p>Output:</p>
<pre><code>['im', 'steve']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>Option 1: set method (recommended)</em></p>
<p>Sets have a <a href="https://www.programiz.com/python-programming/methods/set/symmetric_difference" rel="nofollow noreferrer"><code>symmetric_difference</code></a> method that exclusively return elements from either <code>a</code> or <code>b</code>.  Order can be preserved with a list comprehension for a concatenated list <code>a + b</code>.</p>
<pre><code>comp = set(a).symmetric_difference(b)
[x for x in a + b if x in comp]
# ['im', 'steve']
</code></pre>
<hr/>
<p><em>Option 2: <code>pathlib</code> method</em></p>
<p>For reference, another way to diff two lists might be with <a href="https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.relative_to" rel="nofollow noreferrer"><code>pathlib.Path.relative_to</code></a> method:  </p>
<pre><code>import pathlib


p = pathlib.Path(*b)
r = p.relative_to(*a)
list(r.parts)
# ['im', 'steve']
</code></pre>
<p>Note: <code>b</code> is the longer list.  This option is potentially less efficient than a simple list comprehension. </p>
</div>
<div class="post-text" itemprop="text">
<p>Add two lists together and minus the intersection part if it shows in the new list. Order is preserved.</p>
<pre><code>c = a + b
for v in set(a).intersection(set(b)):
    while v in c:
        c.remove(v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = ['hello','world']
b = ['hello','world','im','steve']
a = set(a)
b = set(b)
print(a.symmetric_difference(b))
</code></pre>
<p>This code print elements that are only in one of the tables.</p>
<p>Look here:
<a href="https://learnpython.org/en/Sets" rel="nofollow noreferrer">https://learnpython.org/en/Sets</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could also just create a function that <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer">filters</a> elements from <code>l1</code> that don't exist in <code>l2</code>, and call it twice with the arguments flipped:</p>
<pre><code>a = ['hello','world', 'foo']
b = ['hello','world','im','steve']

def difference(l1, l2):
    return list(filter(lambda x: x not in l2, l1))

print(difference(a, b) + difference(b, a))
# ['foo', 'im', 'steve']
</code></pre>
<p>If you don't wish to use <code>filter()</code>, a simple list comprehension like this also works:</p>
<pre><code>[item for item in l1 if item not in l2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The question is not very clear, indeed, and probably you're good with @Ajax1234 's <a href="https://stackoverflow.com/a/47985302/289011">answer</a>, but here's another "take" on it.</p>
<p>If you wanna compare positions (kind of what a bit-wise XOR would do) you can do something like getting the shortest list, iterate checking position by position with the longest list (check the same position in the longest list matches the word in the shortest list) and then add the remainder (the "<em>unwalked</em>" part of the longest list). Something like the following:</p>
<pre><code>a = ['hello', 'world']
b = ['hello', 'world', 'im', 'steve']

min_list = a if len(a) &lt; len(b) else b
max_list = b if len(b) &gt; len(a) else a

results = []
for i, item in enumerate(min_list):
    # Iterate through the shortest list to avoid IndexError(s)
    if min_list[i] != max_list[i]:
        results.append(min_list[i])
        results.append(max_list[i])
results.extend(max_list[i + 1:])
print(results)
# Prints: ['im', 'steve']
</code></pre>
<p>However, then you have the problem of what to do if the same positions don't match. I mean... What to do in that case? In the code above, I just added both entries to the <code>results</code> list, which means for the following inputs:</p>
<pre><code>a = ['hello', 'foo']
b = ['hello', 'world', 'im', 'steve']
</code></pre>
<p>would output:</p>
<pre><code>&gt;&gt;&gt; ['foo', 'world', 'im', 'steve']
</code></pre>
<p>(notice both <code>foo</code> from list <code>a</code> and <code>world</code> from list <code>b</code> have been added)</p>
</div>
<div class="post-text" itemprop="text">
<p>Using standard <code>for</code> loop to check for items not in one or the other list (may be more understandable than list comprehension):</p>
<pre><code>a = ['hello','world', 'foo']
b = ['hello','world','im','steve']
c = a+b
ans = []
for i in c:
    if i not in a or i not in b:
        ans.append(i)
print(ans)
</code></pre>
<p>Output:</p>
<pre><code>['foo', 'im', 'steve']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I recommend, using <code>^</code> operator with sets, like <code>set(a) ^ set(b)</code>, Example (demo):</p>
<pre><code>&gt;&gt;&gt; a = ['hello','world']
&gt;&gt;&gt; b = ['hello','world','im','steve']
&gt;&gt;&gt; set(a) ^ set(b)
{'steve', 'im'}
&gt;&gt;&gt; sorted(set(a) ^ set(b),key=max([a,b],key=len).index)
['im', 'steve']
&gt;&gt;&gt; 
</code></pre>
<blockquote>
<p><a href="https://docs.python.org/2/library/stdtypes.html#frozenset.symmetric_difference" rel="nofollow noreferrer">https://docs.python.org/2/library/stdtypes.html#frozenset.symmetric_difference</a></p>
</blockquote>
</div>
<span class="comment-copy">If order <i>is</i> important, what do you do when <code>a</code> is, e.g., <code>['hello', 'the', 'world']</code> or <code>['world', 'hello']</code>? What if it's <code>['world', 'hello', 'world']</code>? What if it contains <code>'steve'</code> somewhere, does it matter where?</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/16312730/comparing-two-lists-and-only-printing-the-differences-xoring-two-lists">Comparing two lists and only printing the differences? (XORing two lists)</a></span>
<span class="comment-copy">you have to precompute <code>set(a).symmetric_difference(b)</code> or this will be slow.</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre confirmed.  Updated post.  Thank you.</span>
<span class="comment-copy">From the question: "How do I do this if the order of the elements IS important?"</span>
<span class="comment-copy">Will edit now to fit it. Can you remove downvote?  @viraptor</span>
<span class="comment-copy">This ignores repetitions though. For example <code>a=[1, 1, 2, 3] ; b=[1, 2]</code> would return <code>c=[3, 1]</code></span>
<span class="comment-copy">Don't worry so much about downvotes. If you have a new good answer, you can always delete the wrong one. (there's even a <a href="https://stackoverflow.com/help/badges/38/peer-pressure">badge</a> for it) On the other hand, if the answer is not correct, it's good to mark it as such by voting.</span>
<span class="comment-copy">@Tai, downvotes are inevitable on this site, even if you make a good answers. Best thing to do is to edit your answer until its correct, and hope for the best. Don't take them too seriously.</span>
<span class="comment-copy">Sets do not maintain order.</span>
<span class="comment-copy">if you use <code>zip</code> you don't need all that of checking the size of the list, also you can use <code>max</code> to select the longest list, or <code>sorted</code> to both at once</span>
<span class="comment-copy">where does "foo" come from in your output?</span>
<span class="comment-copy">I have added my lists above.</span>
