<div class="post-text" itemprop="text">
<p>Sorry the topic's title is vague, I find it hard to explain.</p>
<p>I have a dictionary in which each value is a list of items. I wish to remove the duplicated items, so that each item will appear minimum times (preferable once) in the lists.</p>
<p>Consider the dictionary:</p>
<pre><code>example_dictionary = {"weapon1":[1,2,3],"weapon2":[2,3],"weapon3":[2,3]}
</code></pre>
<p>'weapon2' and 'weapon3' have the same values, so it should result in:</p>
<pre><code>result_dictionary = {"weapon1":[1],"weapon2":[3],"weapon3":[2]}
</code></pre>
<p>since I don't mind the order, it can also result in:</p>
<pre><code>result_dictionary = {"weapon1":[1],"weapon2":[2],"weapon3":[3]}
</code></pre>
<p>But when "there's no choice" it should leave the value. Consider this new dictionary:</p>
<pre><code>example_dictionary = {"weapon1":[1,2,3],"weapon2":[2,3],"weapon3":[2,3],"weapon4":[3]}
</code></pre>
<p>now, since it cannot assign either '2' or '3' only once without leaving a key empty, a possible output would be:</p>
<pre><code>result_dictionary = {"weapon1":[1],"weapon2":[3],"weapon3":[2],"weapon4":[3]}
</code></pre>
<p>I can relax the problem to only the first part and manage, though I prefer a solution to the two parts together</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>#!/usr/bin/env python3

example_dictionary = {"weapon1":[1,2,3],"weapon2":[2,3],"weapon3":[2,3]}

result = {}
used_values = []

def extract_semi_unique_value(my_list):
    for val in my_list:
        if val not in used_values:
            used_values.append(val)
            return val
    return my_list[0]

for key, value in example_dictionary.items():
    semi_unique_value = extract_semi_unique_value(value)
    result[key] = [semi_unique_value]

print(result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is probably not the most efficient solution possible. Because it involves iteration over all possible combinations, then it'll run quite slow for large targets.</p>
<p>It makes use of <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product()</code></a> to get all possible combinations. Then in it, tries to find the combination with the most unique numbers (by testing the length of a set).</p>
<pre><code>from itertools import product
def dedup(weapons):
    # get the keys and values ordered so we can join them back
    #  up again at the end
    keys, vals = zip(*weapons.items())

    # because sets remove all duplicates, whichever combo has
    #  the longest set is the most unique
    best = max(product(*vals), key=lambda combo: len(set(combo)))

    # combine the keys and whatever we found was the best combo
    return {k: [v] for k, v in zip(keys, best)}
</code></pre>
<p>From the examples:</p>
<pre><code>dedup({"weapon1":[1,2,3],"weapon2":[2,3],"weapon3":[2,3]})
#: {'weapon1': 1, 'weapon2': 2, 'weapon3': 3}
dedup({"weapon1":[1,2,3],"weapon2":[2,3],"weapon3":[2,3],"weapon4":[3]})
#: {'weapon1': 1, 'weapon2': 2, 'weapon3': 2, 'weapon4': 3}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this could help</p>
<pre><code>import itertools
res = {'weapon1': [1, 2, 3], 'weapon2': [2, 3], 'weapon3': [2, 3]}
r = [[x] for x in list(set(list(itertools.chain.from_iterable(res.values()))))]
r2 = [x for x in res.keys()]
r3 = list(itertools.product(r2,r))
r4 = dict([r3[x] for x in range(0,len(r3)) if not x%4])
</code></pre>
</div>
<span class="comment-copy">Can you explain why weapon1 have [1] in result ? and weapon2 and weapon3 will get values from first weapon1 [1,2,3] ?</span>
<span class="comment-copy">@AyodhyankitPaul weapon1 is the only one who has [1] in his list, that's why it has [1]. weapon2 and weapon3 both has [2,3], so each get an individual number, one of them gets [2] and the other [3]</span>
<span class="comment-copy">This doesn't work for cases like <code>{'weaponA': [1, 2], 'weaponB': [1]}</code>.</span>
<span class="comment-copy">Total uniqueness was not a constraint. That case will give [1] and [1] which is acceptable if I understand the question correctly.</span>
<span class="comment-copy">I rather get [1] and [2] if possible without complicating it too much since the size of the input may be large</span>
