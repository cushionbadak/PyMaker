<div class="post-text" itemprop="text">
<p>How to best write a Python function (<code>check_list</code>) to efficiently test if an element (<code>x</code>) occurs at least <code>n</code> times in a list (<code>l</code>)?</p>
<p>My first thought was:</p>
<pre><code>def check_list(l, x, n):
    return l.count(x) &gt;= n
</code></pre>
<p>But this doesn't short-circuit once <code>x</code> has been found <code>n</code> times and is always O(n).</p>
<p>A simple approach that does short-circuit would be:</p>
<pre><code>def check_list(l, x, n):
    count = 0
    for item in l:
        if item == x:
            count += 1
            if count == n:
                return True
    return False
</code></pre>
<p>I also have a more compact short-circuiting solution with a generator:</p>
<pre><code>def check_list(l, x, n):
    gen = (1 for item in l if item == x)
    return all(next(gen,0) for i in range(n))
</code></pre>
<p>Are there other good solutions? What is the best efficient approach?</p>
<p>Thank you</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of incurring extra overhead with the setup of a <code>range</code> object and using <code>all</code> which has to test the <em>truthiness</em> of each item, you could use <a href="https://docs.python.org/2/library/itertools.html#itertools.islice"><code>itertools.islice</code></a> to advance the generator <code>n</code> steps ahead, and then return the <em>next</em> item in the slice if the slice exists or a default <code>False</code> if not:</p>
<pre><code>from itertools import islice

def check_list(lst, x, n):
    gen = (True for i in lst if i==x)
    return next(islice(gen, n-1, None), False)
</code></pre>
<p>Note that like <code>list.count</code>, <code>itertools.islice</code> also runs at C speed. And this has the extra advantage of handling iterables that are not lists.</p>
<hr/>
<p>Some timing:</p>
<pre><code>In [1]: from itertools import islice

In [2]: from random import randrange

In [3]: lst = [randrange(1,10) for i in range(100000)]

In [5]: %%timeit # using list.index
   ....: check_list(lst, 5, 1000)
   ....:
1000 loops, best of 3: 736 µs per loop

In [7]: %%timeit # islice
   ....: check_list(lst, 5, 1000)
   ....:
1000 loops, best of 3: 662 µs per loop

In [9]: %%timeit # using list.index
   ....: check_list(lst, 5, 10000)
   ....:
100 loops, best of 3: 7.6 ms per loop

In [11]: %%timeit # islice
   ....: check_list(lst, 5, 10000)
   ....:
100 loops, best of 3: 6.7 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the second argument of <code>index</code> to find the subsequent indices of occurrences:</p>
<pre><code>def check_list(l, x, n):
    i = 0
    try:
        for _ in range(n):
            i = l.index(x, i)+1
        return True
    except ValueError:
        return False

print( check_list([1,3,2,3,4,0,8,3,7,3,1,1,0], 3, 4) )
</code></pre>
<h3>About <code>index</code> arguments</h3>
<p>The official documentation does not mention in its <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer">Python Tutuorial, section 5</a> the method's second or third argument, but you can find it in the more comprehensive <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow noreferrer">Python Standard Library, section 4.6</a>:</p>
<blockquote>
<p><code>s.index(x[, i[, j]])</code>    index of the first occurrence of <em>x</em> in <em>s</em> (at or after index <em>i</em> and before index <em>j</em>) <sup>(8)</sup></p>
<p><sup>(8)</sup> <code>index</code> raises <code>ValueError</code> when <em>x</em> is not found in <em>s</em>. When supported, the additional arguments to the index method allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using <code>s[i:j].index(x)</code>, only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice.</p>
</blockquote>
<h3>Performance Comparison</h3>
<p>In comparing this <code>list.index</code> method with the <code>islice(gen)</code> method, the most important factor is the distance between the occurrences to be found. Once that distance is on average 13 or more, the <code>list.index</code> has a better performance. For lower distances, the fastest method also depends on the number of occurrences to find. The more occurrences to find, the sooner the <code>islice(gen)</code> method outperforms <code>list.index</code> in terms of average distance: this gain fades out when the number of occurrences becomes really large. </p>
<p>The following graph draws the (approximate) border line, at which both methods perform equally well (the X-axis is logarithmic):</p>
<p><a href="https://i.stack.imgur.com/36PZO.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/36PZO.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Ultimately short circuiting is the way to go if you expect a significant number of cases will lead to early termination. Let's explore the possibilities:</p>
<p>Take the case of the <code>list.index</code> method versus the <code>list.count</code> method (these were the two fastest according to my testing, although ymmv)</p>
<p>For <code>list.index</code> if the list contains n or more of x and the method is called n times. Whilst within the list.index method, execution is very fast, allowing for much faster iteration than the custom generator. If the occurances of x are far enough apart, a large speedup will be seen from the lower level execution of <code>index</code>. If instances of x are close together (shorter list / more common x's), much more of the time will be spent executing the slower python code that mediates the rest of the function (looping over <code>n</code> and incrementing <code>i</code>)</p>
<p>The benefit of <code>list.count</code> is that it does all of the heavy lifting outside of slow python execution. It is a much easier function to analyse, as it is simply a case of O(n) time complexity. By spending almost none of the time in the python interpreter however it is almost gaurenteed to be faster for short lists. </p>
<p>Summary of selection criteria:</p>
<ul>
<li>shorter lists favor <code>list.count</code></li>
<li>lists of any length that don't have a high probability to short circuit favor <code>list.count</code></li>
<li>lists that are long and likely to short circuit favor <code>list.index</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I would recommend using <code>Counter</code> from the <code>collections</code> module. </p>
<pre><code>from collections import Counter

%%time
[k for k,v in Counter(np.random.randint(0,10000,10000000)).items() if v&gt;1100]

#Output:
    Wall time: 2.83 s
    [1848, 1996, 2461, 4481, 4522, 5844, 7362, 7892, 9671, 9705]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This shows another way of doing it.</p>
<ol>
<li>Sort the list.</li>
<li>Find the index of the first occurrence of the item.</li>
<li>Increase the index by one less than the number of times the item must occur. (n - 1)</li>
<li><p>Find if the element at that index is the same as the item you want to find.</p>
<pre><code>def check_list(l, x, n):
    _l = sorted(l)
    try:
        index_1 = _l.index(x)
        return _l[index_1 + n - 1] == x
    except IndexError:
        return False
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Another possibility might be:</p>
<pre><code>def check_list(l, x, n):
    return sum([1 for i in l if i == x]) &gt;= n
</code></pre>
</div>
<span class="comment-copy">You can't come up with better than O(n) technique because you need to scan the whole list for checking. Without that you can't reach to a conclusion. If you have a sorted list, then scenario is different.</span>
<span class="comment-copy"><code>list.count</code> is going to be faster in the majority of cases. It doesn't short-circuit, but (in CPython) it's implemented in C which could easily make up for that. The primary alternative is calling <code>index</code> in a loop, which short-circuits but requires multiple calls.</span>
<span class="comment-copy">@Veedrac Good point about the C implementation, but I guess it depends on how large the list is and how early it can short-circuit. What do you mean with the <code>index</code> approach?</span>
<span class="comment-copy">@Chris_Rands I was referring to trincot's approach.</span>
<span class="comment-copy">Your bounty reason states that it hasn't received much attention, I see 2 good answers so far. Don't you think it would be a good idea to elaborate on what "attention" means here?</span>
<span class="comment-copy">Thanks, this is a neat modification to my solution</span>
<span class="comment-copy">@MosesKoledoye Whoops, I misread</span>
<span class="comment-copy">This has the advantage of working over arbitrary iterators, but if you are know you are working on a list its about twice as slow as a <code>list.index</code></span>
<span class="comment-copy">@donkopotamus That isn't quite true. I added some timing</span>
<span class="comment-copy">@MosesKoledoye My test timings were with: <code>lst = [random.randrange(0, 100) for i in range(10000)]</code> and had <code>%timeit check_list_index(lst, 0, 45)</code> =&gt; 64.8 µs and <code>%timeit check_list_iter(lst, 0, 45)</code> =&gt; 127 µs.  Investigating further, <code>islice</code> faster than <code>index</code> when the implicit gap between occurrences is smaller (as implied by using randoms in range [1, 10) ).  Once the gap gets bigger <code>index</code> wins ... eg if you bump your <code>10</code> to <code>20</code> and then <code>50</code> and then <code>100</code> you'll see index pull ahead.   If you make it smaller (eg change <code>10</code> to <code>5</code> or <code>3</code>) then the iterator wins.  Horses for courses</span>
<span class="comment-copy">Thanks I was not aware that <code>list.index</code> takes a 2nd argument, it is not listed in the docs <a href="https://docs.python.org/3.6/tutorial/datastructures.html" rel="nofollow noreferrer">docs.python.org/3.6/tutorial/datastructures.html</a></span>
<span class="comment-copy">The more comprehensive documentation is in the library reference. I added a section on this in my answer.</span>
<span class="comment-copy">I actually submitted this as a documentation bug <a href="https://bugs.python.org/issue28587" rel="nofollow noreferrer">bugs.python.org/issue28587</a></span>
<span class="comment-copy">You shouldn't; the tutorial is not designed to be comprehensive. Quoted from <a href="https://docs.python.org/3.6/tutorial/index.html" rel="nofollow noreferrer">the Tutorial</a>: <i>"This tutorial does not attempt to be comprehensive and cover every single feature..."</i>.</span>
<span class="comment-copy">The bug issue has been closed and the documentation on <code>list.index</code> has now been updated (for Python 3.6) <a href="https://docs.python.org/3.6/tutorial/datastructures.html" rel="nofollow noreferrer">docs.python.org/3.6/tutorial/datastructures.html</a></span>
<span class="comment-copy">You included generator solutions in your benchmark? Can you include the code/timings here?</span>
<span class="comment-copy">@Chris_Rands the generator was just yours from the original question.. The only code I wrote was timing and testing. I then varied the length and range of <code>l</code> (random list of ints) and varied <code>n</code> to get different probabilities of short circuiting, and lengths between instances of <code>x</code></span>
<span class="comment-copy">@Chris_Rands searching for the next instance of <code>x</code> will always be O(n) unless the list is sorted (O(log n!) so slower anyway). therefore short circuit if statistics tell you it's worth it, and spend as little time in the python interpreter as possible</span>
<span class="comment-copy">It might be better to include Moses's generator solution (unless that's what you meant); he's already included a benchmark + donkopotamus's comment</span>
<span class="comment-copy">@Chris_Rands I could not reproduce any meaningful difference between the two. Nor could I make them faster than the <code>list.index</code> method. I could make them faster than the <code>list.count</code> method if the list length was long and the probability to terminate early was high, however that situation favored <code>list.index</code> as well.</span>
<span class="comment-copy">I don't think this answers my question</span>
<span class="comment-copy">Sorting the list is likely O(n log n), then <code>list.index</code> is O(n), so by the end of  2. this is clearly not a good approach</span>
<span class="comment-copy">Your language is a bit hard to understand. Care to clarify @Chris_Rands</span>
<span class="comment-copy">For more, read about time complexity <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a></span>
<span class="comment-copy">I'm afraid I think this can only be worse than the alternatives. It does not short-circuit and it dose not benefit from C implementation in CPython.</span>
