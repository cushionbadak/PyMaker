<div class="post-text" itemprop="text">
<p>I'm trying to communicate with a serial port as defined in a specification.</p>
<pre><code>ser = serial.Serial("/dev/ttyUSB0", baudrate="115200")  

frame = bytearray([
    0x00, 0x00, #frame control (2 bytes)
    0x00, 0x00, #machine id (2 bytes)
    0x07, # number of bytes in data field
    0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, #data field itself 
    0x00, 0x0A #checksum
])

ser.write(frame)
ser.close()
</code></pre>
<p>The code executes without error, and I am monitoring the same port in a separate script/process. The device is supposed to return a frame when it receives a successful one.</p>
<p>In this example, I have manually calculated the checksum, which is defined as:</p>
<p><strong>Two-byte checksum, MSB first, computed over the whole frame reanging from FSN.msb...DATA[dsize]. The checksum is calculated by a simple 16-bit unsigned addition of bytes</strong></p>
<p>So in this case, adding everything up in the frame, apart from the checksum would equal 10, as shown by doing sum(frame) without it added. With it added, the sum is 20.</p>
<p>The device on the other end possibly has a fault, so this is a difficult environment to work in, but it would great if anyone could vet my approach so far?</p>
<p>Is generating a checksum literally that simple, or does it require something else?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes it is that simple - 
you will normally fill in your frame, and append the checksum in another stage - like in:</p>
<pre><code>In [73]: frame = bytearray([
    ...:     0x00, 0x00, #frame control (2 bytes)
    ...:     0x00, 0x00, #machine id (2 bytes)
    ...:     0x07, # number of bytes in data field
    ...:     0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, #data field itself 
    ...:     ])


In [75]: checksum = sum(frame)

In [76]: frame.extend((checksum // 256, checksum % 256))

In [80]: print (", ".join("\\x%02X" % v for v in frame))
\x00, \x00, \x00, \x00, \x07, \x01, \x01, \x01, \x00, \x00, \x00, \x00, \x00, \x0A
</code></pre>
<p>Now, note  a detail: I added the 2 bytes of the checksum in the "natual order" - which is "MSB" (most significant byte) first. As is in your spec. That should work - if not you likely hae some formatting error in one of the other fields.</p>
</div>
<span class="comment-copy">What exactly is the question ? The checksum role is to have a reasonable guarantee that the real data has not been altered. So a simple addition of all bytes can serve that role, even if it is not reliable. Usually checksum is an hash of the payload, that is may more reliable but more requires more calculation.</span>
<span class="comment-copy">Even better solution since Python 3.2: <code>frame.extend(sum(frame).to_bytes(2, 'big'))</code> <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#int.to_bytes</a></span>
<span class="comment-copy">Thanks for this, really useful. When I print the array I get this bytearray(b'\x00\x00\x00\x00\x07\x01\x01\x01\x00\x00\x00\x00\x00\n')  Why the n on the end?</span>
<span class="comment-copy">Ah, I can see that it's because print is converting the bytes directly into characters or something similar to that? And the .join is a way of printing them as hex. Still be interesting to know the exact reason that some of the bytes look ok, and that random n is in there?</span>
<span class="comment-copy">All ytes are ok. It isjust that the default representation of bytes and bytearrays in Python chooses to print the byte as its ASCII representation, if there is one. The <code>\n</code> is the ASCII "new line"  character, and its numeric value is 10 (decimal). With the print statement I wrote above, I explicitly print all bytes in teh sequence as a 2 digit hex number.</span>
<span class="comment-copy">Ah cool, I knew that 10 = newline, but the slightly odd thing was that it includes a backslash, hence it seemed almost as if it was just an n on it's own!</span>
