<div class="post-text" itemprop="text">
<p>I want to implement class <code>Fraction</code> so that when I pass non-integer, exception is raised and object is NOT created. The following code raises an exception but in can create a quirky fraction <code>'hello, world'/0</code></p>
<pre><code>class Fraction:
    def __init__(self, num, den):
        try:
            num = int(num)
            den = int(den)
        except ValueError:
            print('Passed argument not convertible to int')
        self.num = num
        self.den = den
</code></pre>
<p>The question is, how do I elegantly catch non-integer inputs and 0 denominators?</p>
<p><strong>Update</strong>
Totally forgot that I need to raise an exception, not just make <code>except</code> clause. Here's how code looks now</p>
<pre><code>class Fraction:
    def __init__(self, num, den):
        if not (isinstance(num, int) and isinstance(den, int)):
            raise TypeError('Got non-int argument')
        if den == 0:
            raise ValueError('Got 0 denominator')
        self.num = num
        self.den = den 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the <code>except</code> block just <code>raise</code> the original exception.
To check for zero denominator, just do:</p>
<pre><code>if den == 0:
    raise ValueError("boom")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could have a factory method that creates your object:</p>
<pre><code>class Fraction:
    def __init__(self, num, den):
        self.num = num
        self.den = den

def new_fraction(num, den):
    try:
        num = int(num)
        den = int(den)
        return Fraction(num, int)
    except ValueError:
        print('Passed argument not convertible to int')
</code></pre>
<p>Then when you want a new Fraction call the factory method:</p>
<pre><code>my_fraction = new_fraction(1,5)
</code></pre>
<p>You'll then need to test if my_fraction is None:</p>
<pre><code>if my_fraction is not None:
    # Do stuff
else:
    # my_fraction is not an instance of Fraction, so do something else
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Somewhere in your code you'll call</p>
<pre><code>my_fraction = Fraction(num, den)
</code></pre>
<p>Why don't you change it to:</p>
<pre><code>if type(num) is int and type(den) is int:
  my_fraction = Fraction(num, den)
else:
  print('Passed argument not convertible to int')
</code></pre>
<p>This way the object is never created. You could also add exceptions if you wanted.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to print or log an error message and raise an exception, just add <a href="https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement" rel="nofollow noreferrer"><code>raise</code></a> to your existing except suite - it will raise the most recent exception.  Use a descriptor to reject a denominator of zero. <code>NonZero</code> adapted from <a href="http://nbviewer.jupyter.org/urls/gist.github.com/ChrisBeaumont/5758381/raw/descriptor_writeup.ipynb#Descriptors-(Finally)" rel="nofollow noreferrer">Python Descripters Demystified</a></p>
<pre><code>import weakref

class NonZero(object):
    """A descriptor that forbids zero values"""
    def __init__(self, default):
        self.default = default
        self.data = weakref.WeakKeyDictionary()

    def __get__(self, instance, owner):
        # we get here when someone calls x.d, and d is a NonNegative instance
        # instance = x
        # owner = type(x)
        return self.data.get(instance, self.default)

    def __set__(self, instance, value):
        # we get here when someone calls x.d = val, and d is a NonNegative instance
        # instance = x
        # value = val
        if value == 0:
            raise ValueError("Denominator can not be zero")
        self.data[instance] = value


class Fraction:

    den = NonZero(1)

    def __init__(self, num, den):
        try:
            num = int(num)
            den = int(den)
        except ValueError as e:
            print('Passed argument not convertible to int')
            raise
        self.num = num
        self.den = den
</code></pre>
<hr/>
<p>For posterity, my first solution used assert to reject a zero value for the denominator, hence the comment by @PM2Ring. I debated with myself on using it. It's docs state : <code>Assert statements are a convenient way to insert debugging assertions into a program</code> - and down at the bottom of <a href="https://wiki.python.org/moin/UsingAssertionsEffectively" rel="nofollow noreferrer">UsingAssertionsEffectively</a> : <code>Assertions should *not* be used to test for failure cases that can occur because of bad user input</code> - so my bad. The descriptor is the way to go.  (But assert sure was convenient). </p>
</div>
<span class="comment-copy">After you catch the issue, what do you expect to happen? Should the object still be created, or be aborted?</span>
<span class="comment-copy">Why not add checks like   <code>if type(num)!=int :</code>  ?</span>
<span class="comment-copy">I think it would be better to check your num and den, before you try instantiate Fraction. It seems as a better design this way, as you have more control what to do.</span>
<span class="comment-copy">@metatoaster If exception is raised, I want the object to be aborted.</span>
<span class="comment-copy">@Sweeney Todd I know, but tasks says to do it with exception and I'm curious to try it this way</span>
<span class="comment-copy">It's an excersice, so the point is to implement class <code>Fraction</code> yourself.</span>
<span class="comment-copy">No problem, you can instead raise an error as you've now added to your question. Note that you normally wouldn't want to use isinstance(num, int). You want to check if it acts like an int, not if it is an int - custom classes that are "int-like" should not raise a value-error.</span>
<span class="comment-copy">Please don't use <code>assert</code> like that. <code>assert</code> should be used for catching logic errors in your code, not for catching bad data. Instead, you should do something like <code>raise ValueError('Zero denominator')</code>.</span>
<span class="comment-copy">@PM2Ring - see edit.</span>
<span class="comment-copy">Thanks for getting rid of that inappropriate <code>assert</code> statement. OTOH, I think your NonZero is overkill for this. I don't see the point of <code>den = NonZero(1)</code>: that creates a class attribute (in contrast to an instance attribute) that isn't used by the rest of your code.</span>
<span class="comment-copy">BTW, you should take a look at Basil's follow-on question: <a href="http://stackoverflow.com/questions/40355818/comparing-custom-fractions">Comparing custom Fractions</a>.</span>
<span class="comment-copy">@PM2Ring - the extra complexity of the descriptor was one reason I opted for the assert (however misguided that was).  ... The class attribute <code>den</code> is used with <code>self.den = den</code> in this example.  <a href="http://nbviewer.jupyter.org/urls/gist.github.com/ChrisBeaumont/5758381/raw/descriptor_writeup.ipynb#How-NonNegative-works" rel="nofollow noreferrer">How The Descriptor Works</a>. This descriptor idea was kinda weird for me at first but a like it - I have found numerous similar implementations.</span>
