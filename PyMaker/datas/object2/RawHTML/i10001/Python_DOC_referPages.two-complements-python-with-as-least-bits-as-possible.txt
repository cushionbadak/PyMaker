<div class="post-text" itemprop="text">
<p>I am trying to output the binary representation of an negative number with the least bytes available each time.</p>
<p>Example:</p>
<pre><code>-3 -&gt; 101
-10 -&gt; 10110
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a way to do this using the <code>.bit_length</code> method of Python 3 integers. It also uses the string <code>.format</code> method to do the integer to binary string conversion. This function returns a string starting with '0' for non-negative numbers so that they can be distinguished from negative numbers.</p>
<pre><code>def twos_complement(n):
    m = n + 1 if n &lt; 0 else n
    bitlen = 1 + m.bit_length()
    mask = (1 &lt;&lt; bitlen) - 1
    return '{0:0{1}b}'.format(n &amp; mask, bitlen)

for i in (-10, -3, 0, 3, 10):
    print('{:3}: {}'.format(i, twos_complement(i)))

print('- ' * 30)

for i in range(-15, 16):
    print(i, twos_complement(i))    
</code></pre>
<p><strong>output</strong></p>
<pre><code>-10: 10110
 -3: 101
  0: 0
  3: 011
 10: 01010
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
-15 10001
-14 10010
-13 10011
-12 10100
-11 10101
-10 10110
-9 10111
-8 1000
-7 1001
-6 1010
-5 1011
-4 100
-3 101
-2 10
-1 1
0 0
1 01
2 010
3 011
4 0100
5 0101
6 0110
7 0111
8 01000
9 01001
10 01010
11 01011
12 01100
13 01101
14 01110
15 01111
</code></pre>
<hr/>
<h3>How it works</h3>
<p>Python uses a modified form of two's complement to represent integers. Python integers have no size limit, so negative integers behave as if they have an <em>infinite</em> number of leading 1 bits, as explained in the <a href="https://wiki.python.org/moin/BitwiseOperators" rel="nofollow noreferrer">Python Wiki article on Bitwise Operators</a>.</p>
<p>The <code>int.bit_length</code> method tells us the minimum number of bits required to represent a number, we want one more bit than that so that all our non-negative numbers will start with 0 and all the negative numbers start with a 1. We need to modify that slightly to ensure that numbers of the form <code>-2**n</code> will only get a single leading one bit, we do that by adding 1 to all the negative numbers when calculating the bit length. </p>
<p>To select the bits we want we need a bit mask of the appropriate length. If the bit length is 4, we want a mask of 1111 = <code>2**4 - 1</code>; we _could calculate it by using exponentiation, but it's more efficient to use bit shifting: <code>(1 &lt;&lt; bitlen) - 1</code>. We then do the bitwise AND operation <code>n &amp; mask</code> to select the bits we want. Fortunately, Python gives us a non-negative number when we perform such masking operations. :)</p>
<p>Finally we convert the resulting integer to a string using the <code>.format</code> method. We use a nested format specification so we can dynamically specify the correct length of the output string. In </p>
<pre><code>'{0:0{1}b}'.format(n &amp; mask, bitlen) 
</code></pre>
<p>the first 0 of the format spec says that we're converting the value of the 0 arg in the argument list (<code>n &amp; mask</code>), the <code>:0{1}b</code> says to convert it to binary, padded with leading zeroes if necessary, using the value of the 1 arg in the argument list (<code>bitlen</code>) as the total string length.</p>
<p>You can read about nested format specs in the <a href="https://docs.python.org/3/library/string.html#format-string-syntax" rel="nofollow noreferrer">Format String Syntax</a> section of the docs:</p>
<blockquote>
<p>A <em>format_spec</em> field can also include nested replacement fields
  within it. These nested replacement fields may contain a field name,
  conversion flag and format specification, but deeper nesting is not
  allowed. The replacement fields within the <em>format_spec</em> are
  substituted before the <em>format_spec</em> string is interpreted. This
  allows the formatting of a value to be dynamically specified.</p>
</blockquote>
</div>
<span class="comment-copy">Can you show said try?</span>
<span class="comment-copy">And your question is? Write this code for me? Give me a library that does this? Both of these are off topic, sorry. Show your research and what you tried to solve the task.</span>
<span class="comment-copy">How is <code>-3</code> <code>101</code>? <code>bin(-3) == '-0b11'</code></span>
<span class="comment-copy">What do you want to output if the input is positive? Do you want 5 to return '0101'? I assume so, otherwise you won't be able to distinguish positive numbers from negative ones.</span>
<span class="comment-copy">@LutzHorn <a href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="nofollow noreferrer">Two's complement</a></span>
<span class="comment-copy">can you explain me a little bit the logic of the code? thanks it seems to work</span>
<span class="comment-copy">update: the code doesn't seem to work for -2,-8</span>
<span class="comment-copy">should -8 just be 1000?</span>
<span class="comment-copy">Thank you!!! this worked.can you explain a little bit</span>
<span class="comment-copy">@ΣΤΑΥΡΟΣΑΒΡΑΜΙΔΗΣ Sorry about the delay, but hopefully what I've written makes sense. :)</span>
