<div class="post-text" itemprop="text">
<p>I have created a SSL socket (server side) and place the socket into a select() queue.  The select() properly returns when the socket "is ready" to read.</p>
<p>I then recv(1024) bytes.  Under some circumstances this will get all the data, in others it may not.  </p>
<p>However, if there is still data in the socket buffer (because I didn't recv() it all), and I pass that same socket into select() again, it will <strong>not</strong> be returned as being "ready" to read even though I know there is data there.</p>
<p>I suppose my question is really to confirm what "ready to be read" really means from select()'s perspective and what the best way to handle this would be.  Continuing to recv() until EWOULDBLOCK seems sort of hack-ish given that I'm using select().</p>
<p>Am I thinking about this incorrectly?  I realize I could use a larger recv buffer, but there is always the possibility that there would be more to read than recv can pull -- so what is the "right" way to handle this coming out of a select()?</p>
<p>Thanks in advance.</p>
<p>EDIT:  As noted in the comments, I neglected to mention that this is an SSL server and apparently select() behaves differently when using wrapped sockets.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>select</code> cares only about the readiness of a socket from the view of the OS kernel. That is checking if a socket is ready for <code>recv</code> with select only checks if there are data in the socket buffer. But with SSL it is different since user space buffering is involved.</p>
<p>Even if you read only a few bytes from a SSL socket it needs to read the full SSL record which contains the encrypted data, decrypt the full record and then it can return the few bytes you've requested. The rest of the data will be buffered in user space for the next read. But, the full SSL record is removed from the OS socket buffer which means that <code>select</code> might not show you that there are still data available. </p>
<p>There are two ways to work around this. One way is to use the <a href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.pending" rel="noreferrer">pending</a> method to find out of there are still data buffered in user space. The other is to always <code>recv</code> in huge chunks so that no data will be buffered in user space. Since the maximum size of a SSL record is 16k and each <code>recv</code> handles only a single SSL record (implementation detail in openssl <a href="https://www.openssl.org/docs/man1.1.0/ssl/SSL_read.html" rel="noreferrer">SSL_read</a>) it would work to always call <code>recv</code> with a size of at least 16384.</p>
</div>
<span class="comment-copy">Take a look at this <a href="http://stackoverflow.com/questions/7749341/very-basic-python-client-socket-example" title="very basic python client socket example">stackoverflow.com/questions/7749341/â€¦</a>  and the example server code. You should use listen() and accept() to your server side socket, making the socket available for subsequent calls.</span>
<span class="comment-copy">@Hannu, my case is well after the listen()/accept() phase.  The question you pointed me to doesn't have any of the elements of my issue.  Thanks anyway.</span>
<span class="comment-copy"><a href="https://pymotw.com/2/select/" rel="nofollow noreferrer">pymotw.com/2/select</a>  does this explain it more thoroughly?  Basically "readable" means different things if you are talking about your master socket you are listening to, or a socket created by accept()ing a connection to your master socket.  In the latter case, it means there is data to be read, in the first case it means there is a pending connection you should or could accept().</span>
<span class="comment-copy">@Hannu - yes, but if you read my OP, there is still "data to be read" because I left it there, yet select() is not returning the socket as being ready to read.  That is the entire point of my question which, unless I'm missing something, is not addressed in the links you've provided.</span>
<span class="comment-copy">It might have helped if you included into your question that this is a SSL socket. Maybe add it now.</span>
