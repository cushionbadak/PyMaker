<div class="post-text" itemprop="text">
<p>I'm learning how parsers work by creating a simple recursive descent parser. However I'm having a problem defining my grammar to be LL(1). I want to be able to parse the following two statements:</p>
<pre><code>a = 1
a + 1
</code></pre>
<p>To do this I've created the following grammar rules:</p>
<pre><code>statement:  assignent | expression
assignment: NAME EQUALS expression
expression: term [(PLUS|MINUS) term]
term:       NAME | NUMBER
</code></pre>
<p>However, this leads to ambiguity when using a LL(1) parser as when a NAME token is encountered in the <code>statement</code> rule, it doesn't know whether it is an <code>assignment</code> or an <code>expression</code> without a look-ahead.</p>
<p>Python's grammar is LL(1) so I know this is possible to do but I can't figure out how to do it. I've looked at Python's grammar rules found here (<a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow">https://docs.python.org/3/reference/grammar.html</a>) but I'm still not sure how they implement this.</p>
<p>Any help would be greatly appreciated :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Just treat <kbd>=</kbd> as an operator with very low precedence. However (unless you want a language like C where <kbd>=</kbd> really is an operator with very low precedence), you need to exclude it from internal (e.g. parenthetic) expressions.</p>
<p>If you had only multiplication and addition, you could use:</p>
<pre><code>expression: factor ['+' factor]
factor:     term ['*' term]
term:       ID | NUMBER | '(' expression ')'
</code></pre>
<p>That is a guide for operator precedence: <kbd><em></em></kbd> has higher precedence because the arguments to <kbd>+</kbd> can include <kbd></kbd></p></div>
<span class="comment-copy">LL(1) doesn't mean no look-ahead, it means you have a one-token look-ahead (that's where the 1 comes from). When you find a NAME token, look for the next token, it will be an EQUALS, PLUS or MINUS token, then you know which rule to follow based on this information.</span>
<span class="comment-copy">Correct me if I'm wrong but I thought the single look-ahead would be the NAME token?</span>
<span class="comment-copy">It's been some time since I've learned compilers and my terminology may be wrong, but I think NAME is the current token (the one yielded by the lexer) and EQUALS/PLUS would be the first look-ahead token (the one you "peek" but don't actually pop).</span>
<span class="comment-copy">Thanks for clarifying :)</span>
<span class="comment-copy">I'm currently working through the book Language Implementation Patterns which describes LL(1) parsers by saying "it only needs to look at the current input symbol to make parsing decisions", which disagrees with your comment.</span>
