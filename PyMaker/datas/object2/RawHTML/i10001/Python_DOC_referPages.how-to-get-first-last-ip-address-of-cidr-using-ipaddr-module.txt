<div class="post-text" itemprop="text">
<p>The brute force approach:</p>
<pre><code>from ipaddr import IPv4Network
n = IPv4Network('10.10.128.0/17')
all = list(n.iterhosts()) # will give me all hosts in network
first,last = all[0],all[-1] # first and last IP
</code></pre>
<p>I was wondering how I would get the first and last IP address from a CIDR without having to iterate over a potentially very large list to get the first and last element?</p>
<p>I want this so I can then generate a random ip address in this range using something like this:</p>
<pre><code>socket.inet_ntoa(struct.pack('&gt;I', random.randint(int(first),int(last))))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe try netaddr instead, in particular the indexing section. </p>
<p><a href="https://pythonhosted.org/netaddr/tutorial_01.html#indexing" rel="nofollow noreferrer">https://pythonhosted.org/netaddr/tutorial_01.html#indexing</a></p>
<pre><code>from netaddr import *
import pprint

ip = IPNetwork('10.10.128.0/17')

print "ip.cidr = %s" % ip.cidr
print "ip.first.ip = %s" % ip[0]
print "ip.last.ip = %s" % ip[-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From Python 3.3, you can use the <a href="https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Network" rel="nofollow noreferrer"><code>ipaddress</code> module</a></p>
<p>You could use it like this:</p>
<pre><code>import ipaddress

n = ipaddress.IPv4Network('10.10.128.0/17')
first, last = n[0], n[-1]
</code></pre>
<p><code>__getitem__</code> is implemented, so it won't generate any large lists.</p>
<p><a href="https://github.com/python/cpython/blob/3.6/Lib/ipaddress.py#L634" rel="nofollow noreferrer">https://github.com/python/cpython/blob/3.6/Lib/ipaddress.py#L634</a></p>
</div>
<span class="comment-copy">Oops...looks like ipaddr module supports this method as well! I should have tried that. I used ipaddr over netaddr as I found the former had more reliable operations for checking overlapping CIDRs.</span>
