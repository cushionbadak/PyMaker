<div class="post-text" itemprop="text">
<p>I am having trouble mocking a function that accepts **kwargs.  The scenario is I have ClassA (which in my specific case is something I didnt write) and it has a function with **kwargs. ClassB which has an instance of ClassA, and calls the **kwargs function.  I want to test ClassB by mocking the call to Class A's function.</p>
<p>Here is what I have tried so far, and in both of my attempts I ended up with a TypeError.  Is there any way to do this? Should I rethink another aspect of this?</p>
<pre><code>import unittest


#a class i have no control over. Has a function accepting **kwargs
class ClassA(object):

    def classFunctionAcceptingKwargs(self, **kwargs):
        return kwargs["a"] + kwargs["b"]

# a mock of the above class
class Mock_ClassA(object):

    def __init__(self):
        self.mockclassFunctionAcceptingKwargs = lambda **kwargs: None

    def classFunctionAcceptingKwargs(self, **kwargs):
        #FAILS: TypeError: mockFunctionAcceptingKwargs() takes exactly 0 arguments (1 given)
        return self.mockclassFunctionAcceptingKwargs(kwargs)
        #ALSO FAILS: TypeError: mockFunctionAcceptingKwargs() argument after ** must be a mapping, not set
        #return self.mockclassFunctionAcceptingKwargs(**{kwargs["a"] + kwargs["b"]})

#class B calls the class A kwargs but exposes a function with a dict
class ClassB(object):
    def __init__(self, classA):
        self.classA = classA

    def doSomething(self, dict):
        return self.classA.classFunctionAcceptingKwargs(**dict)

class TestClassA(unittest.TestCase):

    def runTest(self):
        a = ClassA()
        result = a.classFunctionAcceptingKwargs(**{"a":1, "b": 2})
        self.assertEqual(result, 3)

class TestClassB(unittest.TestCase):

    def runTest(self):

        mock = Mock_ClassA()
        def mockFunctionAcceptingKwargs(**kwargs):
            self.assertEqual(kwargs["a"], 1)
            self.assertEqual(kwargs["b"], 2)

        mock.mockclassFunctionAcceptingKwargs = mockFunctionAcceptingKwargs
        b = ClassB(mock)
        b.doSomething({"a": 1, "b": 2})
</code></pre>
<p>Stack trace: </p>
<pre><code>Test Name:  TestClassB
Test Outcome:   Failed
Result StandardError:   
======================================================================
ERROR: runTest (module1.TestClassB)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\test\module1.py", line 49, in runTest
    b.doSomething({"a": 1, "b": 2})
  File "C:\test\module1.py", line 28, in doSomething
    return self.classA.classFunctionAcceptingKwargs(**dict)
  File "C:\test\module1.py", line 18, in classFunctionAcceptingKwargs
    return self.mockclassFunctionAcceptingKwargs(kwargs)
TypeError: mockFunctionAcceptingKwargs() takes exactly 0 arguments (1 given)
----------------------------------------------------------------------
Ran 1 test in 12.873s
FAILED (errors=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure why you are calling another function. But if you <em>must</em> have an instance attribute <code>mockclassFunctionAcceptingKwargs</code> function, then just pass on the <code>kwargs</code> dictionary with <code>**kwargs</code>:</p>
<pre><code>class Mock_ClassA(object):
    # ...
    def classFunctionAcceptingKwargs(self, **kwargs):
        return self.mockclassFunctionAcceptingKwargs(**kwargs)
</code></pre>
<p>You don't need to call that lambda at all if all you need is for <code>classFunctionAcceptingKwargs</code> to exist:</p>
<pre><code>class Mock_ClassA(object):
    def __init__(self, mock_result):
        self.mock_result = mock_result
    def classFunctionAcceptingKwargs(self, **kwargs):
        self.called_with = kwargs
        return self.mock_result
</code></pre>
<p>then just pass in the mocked return value, whatever you need to be passed back to <code>ClassB</code> for the test, and afterwards you can check that the right value was passed in too:</p>
<pre><code>mock = Mock_ClassA(3)  # to return 3 back to the caller
b = ClassB(mock)
b.doSomething({"a": 1, "b": 2})
self.assertEqual(mock.called_with, {'a': 1, 'b': 2})
</code></pre>
<p>You may want to use the <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>unittest.mock</code> library</a> to build a mock object to pass in (available in Python 3, and a <a href="https://pypi.python.org/pypi/mock" rel="nofollow noreferrer">backport</a> for Python 2 can be installed). It'll let you create a mocked <code>ClassA</code> and then use the API to test if the mock was used in the expected manner:</p>
<pre><code>try:
    # Python 3
    from unittest import mock
except ImportError:
    # Python 2, backport
    import mock

class TestClassB(unittest.TestCase):
    def runTest(self):
        mockA = mock.Mock(spec=ClassA)  # only accept attributes ClassA also has
        mockA.classFunctionAcceptingKwargs.return_value = 3  # or whatever else you want it to return
        b = ClassB(mockA)
        b.doSomething({"a": 1, "b": 2})
        mockA.classFunctionAcceptingKwargs.assert_called_once_with(a=1, b=2)
</code></pre>
<p>Demo with <code>unittest.mock</code> as the mocking layer:</p>
<pre><code>&gt;&gt;&gt; from unittest import mock
&gt;&gt;&gt; class ClassA(object):
...     def classFunctionAcceptingKwargs(self, **kwargs):
...         return kwargs["a"] + kwargs["b"]
...
&gt;&gt;&gt; class ClassB(object):
...     def __init__(self, classA):
...         self.classA = classA
...     def doSomething(self, dict):
...         return self.classA.classFunctionAcceptingKwargs(**dict)
...
&gt;&gt;&gt; mockA = mock.Mock(spec=ClassA)
&gt;&gt;&gt; mockA.classFunctionAcceptingKwargs.return_value = 3
&gt;&gt;&gt; b = ClassB(mockA)
&gt;&gt;&gt; b.doSomething({"a": 1, "b": 2})
3
&gt;&gt;&gt; mockA.classFunctionAcceptingKwargs.assert_called_once_with(a=1, b=2)  # passes, no exception raised
&gt;&gt;&gt; mockA.mock_calls
[call.classFunctionAcceptingKwargs(a=1, b=2)]
</code></pre>
</div>
