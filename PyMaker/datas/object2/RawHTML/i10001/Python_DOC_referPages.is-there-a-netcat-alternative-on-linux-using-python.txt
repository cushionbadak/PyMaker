<div class="post-text" itemprop="text">
<p>netcat is not available in our Linux prod environment for security reasons.
I'm trying to write/read short text messages into a port for logging.
Write to port on worker nodes read on logger node.
netcat would do the job
Is there a way to do the same on Linux using Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>i made you a script, save this, chmod it and make it executable. And run it. This should work for you. Ping me if you have questions.</p>
<pre><code>#!/usr/bin/python

import socket



def writer(sock):
    file=open("log.txt","w")      #you can specify a path for the file here, or a different file name
    while(1):
        try:
            output=sock.recv(500)
            file.write(output)
        except:
            file.close()

try:
    x=socket.socket()
    x.bind(("127.0.0.1",1339))    # Enter IP address and port according to your needs ( replace 127.0.0.1 and 1339 )
    x.listen(2)                   # This will accept upto two connections, change the number if you like
    sock,b=x.accept()
    writer(sock)
except:
    print("bye")
    exit()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thank you for replies.
I ended up writing my own scripts.</p>
<ol>
<li>I start <a href="https://github.com/alexbuz/PyCopy/blob/master/netcat_reader.py" rel="nofollow">netcat_reader.py</a> on logger node. </li>
<li>I start 2 <a href="https://github.com/alexbuz/PyCopy/blob/master/netcat_writer.py" rel="nofollow">netcat_writer.py</a> shells on the same or different worker nodes:</li>
</ol>
<blockquote>
<pre><code>python netcat_writer.py writer1&amp; 

python netcat_writer.py writer2&amp;
</code></pre>
</blockquote>
<ol start="3">
<li>Result is combined log of messages from 2 reporting scripts (netcat_writer.py) accumulated on logging server:</li>
</ol>
<blockquote>
<pre><code>Receiving...
timed out 1
timed out 2
timed out 1
timed out 2
timed out 1
timed out 2
timed out 1
Got connection from ('10.20.102.39', 17992)
Got connection from ('10.20.102.39', 17994)
client:one --0--
client:two --0--
client:one --1--
client:one --2--
client:one --3--
client:one --4--
client:one --5--
client:two --1--
client:one --6--
client:two --2--
client:one --7--
client:two --3--
client:one --8--
client:two --4--
client:one --9--
client:two --5--
client:two --6--
client:two --7--
client:two --8--
client:two --9--
</code></pre>
</blockquote>
<p>netcat_reader.py (run it in loggerhost123):</p>
<pre><code>import socket   
import sys
e=sys.exit
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
s.setblocking(False)
s.settimeout(2)
#
host = socket.gethostname()
port = 12346                 
s.bind((host, port))       
s.listen(5)               
c1=c2=t1=t2=None
print "Receiving..."
while True:
        try: 
            if not c1:
                c1, addr1 = s.accept()
                print 'Got connection from', addr1  
            if t1:
                print t1.decode('utf-8')
            if c1:
                t1 = c1.recv(1024)
        except socket.error, er:
            err = er.args[0]
            print err   ,1

        try: 
            if not c2:
                c2, addr2 = s.accept()
                print 'Got connection from', addr2
            if t2:
                print t2.decode('utf-8')
            if c2:
                t2 = c2.recv(1024)
        except socket.error, er:
            err = er.args[0]
            print err,2             
c1.close()
c2.close()      
s.shutdown(socket.SHUT_WR)  
s.close()
print "Done Receiving"
e(0)
</code></pre>
<p>netcat_writer.py (run it on reporting nodes)</p>
<pre><code>import socket 
import sys, time
e=sys.exit
assert len(sys.argv)==2, 'Client name is not set'
client_name= sys.argv[1]
class NetcatWriter:
    def __init__(self, port,client_name):
        print '__init__'
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.host = 'loggerhost123' 
        self.port = port 
        self.client_name=client_name
        self.s.connect((self.host, self.port))  
    def __enter__(self):
        print '__enter__'
        return self     
    def write(self,i):      
        print 'Sending..',
        l = 'client:%s --%d--'  % (self.client_name,i)
        while (l):
          print '.',
          self.s.send(l)
          l=None
        #f.close()
        print "Done Sending"
        #
    def __exit__(self, exc_type, exc_value, traceback): 
        self.s.shutdown(socket.SHUT_WR)
        self.s.close

netcat= NetcatWriter(12346,client_name)
if 1:
    for i in range(10):
        netcat.write(i) 
        time.sleep(0.1)
e(0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I use this at work for some situations where i need to get a message from a network node. hopefully it will help you. you will need to adapt this to your needs. i wont do all the work for you but I will give you the right direction.</p>
<pre><code>!#/usr/bin/env python
import socket

def netcat_alternative(ip, port):
    req = socket.create_connection((ip, port)).recv(1024)
    print(req) #alternatively you can log this value
    req.close()

# main goes here
def main():
    """
    main logic flow
    """
    string_ip = '127.0.0.1'
    int_port = 80
    netcat_alternative(string_ip, int_port)


if __name__ == "__main__":
    main()
</code></pre>
</div>
<span class="comment-copy">Use the <a href="https://docs.python.org/3/library/socket.html" rel="nofollow noreferrer"><code>socket</code></a> module.</span>
<span class="comment-copy">What kind of "security reasons"? Netcat isn't a privileged application, it can't do anything you can't do yourself with Python, Perl, PHP, Ruby, C, etc.</span>
<span class="comment-copy">See the code here : <a href="http://stackoverflow.com/questions/1908878/netcat-implementation-in-python" title="netcat implementation in python">stackoverflow.com/questions/1908878/â€¦</a></span>
<span class="comment-copy">@Barmar It was only my guess. I tried to execute it. it was not there. Why would you remove it other than security reasons.</span>
<span class="comment-copy">They may not have removed it, just not installed it in the first place.</span>
