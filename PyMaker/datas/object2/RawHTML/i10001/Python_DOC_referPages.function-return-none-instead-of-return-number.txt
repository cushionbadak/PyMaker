<div class="post-text" itemprop="text">
<p>I create a function that compare with x and y variable. Inside the function has a lots of nested elif to compare the x and y then return integer. The problem is right now, when it runs at the certain elif statement, it didn't execute the statement although the statement is correct.</p>
<pre><code>def convertTo(self, x, y):
    if( x == 0 &amp; y == 0):
        return 0
    if( x == 0 &amp; y == 1):
        return 1
    if( x == 0 &amp; y == 2):
        return 2
    if( x == 0 &amp; y == 3):
        return 3
    if( x == 1 &amp; y == 0): 
        return 4 # Didn't return this line even though x = 1 and y = 0
    else
        return None

def main():
    self.convertTo(0,0)
    self.convertTo(0,1)
    self.convertTo(0,2)
    self.convertTo(0,3)
    self.convertTo(1,0) # return None? Why?
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're performing a chained equality comparison which is not doing what you think it does. The bitwise <code>&amp;</code> is performed first as it has a higher priority than <code>==</code>. </p>
<p>Replace:</p>
<pre><code>x == 1 &amp; y == 0
# 1 == 1 &amp; 0 == 0
# 1 == 0 == 0  False!
</code></pre>
<p>With:</p>
<pre><code>x == 1 and y == 0
</code></pre>
<hr/>
<p>See: <a href="https://docs.python.org/2/reference/expressions.html#operator-precedence">Operator precedence</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, "&amp;" and "and" do two different things.  "and" is what you should be using, "&amp;" is a binary operator.</p>
<p>if
a = 0011 1100</p>
<p>and</p>
<p>b = 0000 1101</p>
<p>then</p>
<p>a&amp;b = 0000 1100</p>
<p>See <a href="http://www.tutorialspoint.com/python/python_basic_operators.htm" rel="nofollow">http://www.tutorialspoint.com/python/python_basic_operators.htm</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You should use and instead of &amp;, as &amp; is a bitwise and.</p>
<p>Chaining multiple conditions in Python is generally done with an if-elif-else statement like below:</p>
<pre><code>if a and b:
   # a and b both was true
elif a and not b:
   # a was true, but b wasn't
else:
   # none of the conditions matched
</code></pre>
<p>In your code, if it wasn't for the return statement in each if, and the fact that you are checking the same two variables, it would be possible for two if statements to evaluate to true.</p>
<pre><code>if a:
   # this will run if a was true
if b:
   # regardless of a this will run if b was true
else:
   # regardless of a this will only run if b was false
</code></pre>
<p>Also, take a look at this: <a href="https://docs.python.org/3/tutorial/controlflow.html" rel="nofollow">https://docs.python.org/3/tutorial/controlflow.html</a></p>
</div>
<span class="comment-copy">Have you tried <code>and</code> instead of <code>&amp;</code>?</span>
<span class="comment-copy">@tobias_k Operator precedence is different.</span>
<span class="comment-copy">Short circuit? maybe? Just a question... Anyways, how do we know what's returned? The code doesn't output anything</span>
<span class="comment-copy">Note that your <code>if/else</code> structure is odd. It should be a series of <code>if/elif/else</code>. But you could also just drop the <code>else: return None</code> entirely, as that's the default anyway.</span>
<span class="comment-copy">I think the order of operations executes the bitwise operator before the comparision</span>
<span class="comment-copy">This, basically it's parsed as <code>x == (1 &amp; y) == 0</code>.</span>
<span class="comment-copy">AKA PEMDAS for adults!</span>
<span class="comment-copy">But that by itself isn't the entire explanation.</span>
<span class="comment-copy">But that does not explain why it fails in this case, after all <code>True &amp; True</code> would still be true. The critical point is indeed operator precedence.</span>
