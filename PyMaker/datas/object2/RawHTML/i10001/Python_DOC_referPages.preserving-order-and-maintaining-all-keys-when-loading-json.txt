<div class="post-text" itemprop="text">
<p>Using the approach described <a href="https://stackoverflow.com/a/6921760/1389110">here</a>, I pass <code>OrderedDict</code> as <code>object_pairs_hook</code> when loading a nested JSON file, to preserve order.</p>
<p>Order is preserved, and this is fine for <em>most</em> of the JSON object. But there are parts of the JSON (at the lowest level of nesting), which look like:</p>
<p><code>"In Content" : {
    "Sulvo" : "abc.com_336x280_he-inlinecontentmobile",
    "Sulvo" : "abc.com_336x280_he-inlinecontentmobile_level2",
    "Sulvo" : "abc.com_336x280_he-inlinecontentmobile_level3",
    "Adsense" : ""
  },</code></p>
<p>And when processed, only one of these identical keys gets preserved:</p>
<p><code>OrderedDict([(u'Sulvo', u'homeepiphany.com_336x280_he-inlinecontentmobile_level3'),
(u'Adsense', u'')])),</code></p>
<p>I know that we can have a dictionary which has multiple items of the same key name with a <code>defaultdict</code>. The following doesn't work though, and even it it did, I presume we would gain the keys but lose the order, so we'd be no better off:</p>
<p><code>j = json.load(open('he.json'), object_pairs_hook=defaultdict)</code></p>
<p>Is it possible to maintain order <em>AND</em> preserve all keys in one go?</p>
<p>Python 2.7.12</p>
</div>
<div class="post-text" itemprop="text">
<p>If you look at the <a href="https://docs.python.org/3/library/json.html#json.load" rel="nofollow">docs for <code>json.load</code></a>, they outline what the <code>object_pairs_hook</code> parameter does:</p>
<blockquote>
<p><code>object_pairs_hook</code> is an optional function that will be called with the result of any object literal decoded with an ordered list of pairs. The return value of <code>object_pairs_hook</code> will be used instead of the <code>dict</code>.</p>
</blockquote>
<p>All you need to do is write a function that, given a list of <code>(key, value)</code> pairs, constructs your object.</p>
<p>One approach would be to do nothing and just pass the items list straight through without constructing a dictionary:</p>
<pre><code>def handle_mapping(items):
    return items
</code></pre>
<p>Then, your JSON is parsed like so:</p>
<pre><code>[(u'In Content',
  [(u'Sulvo', u'abc.com_336x280_he-inlinecontentmobile'),
   (u'Sulvo', u'abc.com_336x280_he-inlinecontentmobile_level2'),
   (u'Sulvo', u'abc.com_336x280_he-inlinecontentmobile_level3'),
   (u'Adsense', u'')])]
</code></pre>
<p>If you do want to merge the values of duplicate keys into a list, you can use <code>OrderedDict</code>:</p>
<pre><code>def handle_mapping(items):
    d = OrderedDict()
    duplicate_keys = set()

    for key, value in items:
        # So [('k', 'v')] becomes {'k': 'v'}
        if key not in d:
            d[key] = value
        else:
            # So [('k', 'v1'), ('k', 'v2')] becomes {'k': ['v1', 'v2']}
            if key not in duplicate_keys:
                duplicate_keys.add(key)
                d[key] = [d[key]]

            d[key].append(value)

    return d
</code></pre>
<p>Then, you'd object would be parsed as:</p>
<pre><code>OrderedDict([(u'In Content',
              OrderedDict([(u'Sulvo',
                            [u'abc.com_336x280_he-inlinecontentmobile',
                             u'abc.com_336x280_he-inlinecontentmobile_level2',
                             u'abc.com_336x280_he-inlinecontentmobile_level3']),
                           (u'Adsense', u'')]))])
</code></pre>
</div>
<span class="comment-copy">That's one hell of an answer. I got as far as the <code>handle_mapping()</code> suggestion. It was surprising to me that passing just the json file to <code>json.load()</code> - i.e. not specifying an <code>object_pairs_hook</code> -  also resulted in loss of items, whereas passing the dummy function resulted in them being preserved. Will try your full solution tomorrow. Thanks.</span>
<span class="comment-copy">@Pyderman: In Python, <code>dict([('a', 1), ('a', 1)]) == {'a': 1} == {'a': 1, 'a': 1}</code>, since having duplicate keys in a dictionary doesn't make sense (what would <code>d['a']</code> do?). JavaScript (the J in <b>J</b>SON) does the same thing. You have to tell Python to use something other than a dictionary to hold your elements if your JSON is weird like yours.</span>
