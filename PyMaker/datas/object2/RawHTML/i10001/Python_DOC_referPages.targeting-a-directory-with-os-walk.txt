<div class="post-text" itemprop="text">
<p>Due to a large and convoluted directory structure, my script is searching too many directories:</p>
<pre class="lang-none prettyprint-override"><code>root--
     |
     --Project A--
                  |
                  -- Irrelevant
                  -- Irrelevant
                  -- TARGET
     |
     --Project B--
                  |
                  -- Irrelevant
                  -- TARGET
                  -- Irrelevant
     |
     -- Irrelevant  --
                       |
                       --- Irrelevant
</code></pre>
<p>The TARGET directory is the only one I need to traverse and it has a consistent name in each project (we'll just call it Target here).</p>
<p>I looked at this question:</p>
<p><a href="https://stackoverflow.com/questions/19859840/excluding-directories-in-os-walk">Excluding directories in os.walk</a></p>
<p>but instead of excluding, I need to include the "target" directory which isn't at the "root" level, but one level down.</p>
<p>I've tried something to the like of:</p>
<pre><code>def walker(path):
    for dirpath, dirnames, filenames in os.walk(path):
        dirnames[:] = set(['TARGET'])
</code></pre>
<p>But this one effects the root directory (thereby ignoring all the directories it needs to traverse, Project A, Project B...)</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue with your code is that you are <em>always</em> modifying the <code>dirnames</code> list, but this means that even at the root level all the subdirectories are removed and hence the recursive calls do not end up visiting the various <code>Project X</code> directories.</p>
<p>What you want is to purge other directories <em>only</em> when the <code>TARGET</code> one is present:</p>
<pre><code>if 'TARGET' in dirnames:
    dirnames[:] = ['TARGET']
</code></pre>
<p>This will allow the <code>os.walk</code> call to visit the <code>Project X</code> directories, but will prevent it from going inside the <code>Irrelevant</code> ones.</p>
</div>
<div class="post-text" itemprop="text">
<p>For a whitelisting scenario like this, I'd suggest using <a href="https://docs.python.org/3/library/glob.html#glob.iglob" rel="nofollow noreferrer"><code>glob.iglob</code></a> to get the directories by a pattern. It's a generator, so you'll get each result as fast as it finds them (Note: At time of writing, it's still implemented with <code>os.listdir</code> under the hood, not <code>os.scandir</code>, so it's only half a generator; each directory is scanned eagerly, but it only scans the next directory once it's finished yielding values from the current directory). For example, in this case:</p>
<pre><code>from future_builtins import filter  # Only on Py2 to get generator based filter

import os.path
import glob

from operator import methodcaller

try:
    from os import scandir       # Built-in on 3.5 and above
except ImportError:
    from scandir import scandir  # PyPI package on 3.4 and below

# If on 3.4+, use glob.escape for safety; before then, if path might contain glob
# special characters and you don't want them processed you need to escape manually
globpat = os.path.join(glob.escape(path), '*', 'TARGET')

# Find paths matching the pattern, filtering out non-directories as we go:
for targetdir in filter(os.path.isdir, glob.iglob(globpat)):
    # targetdir is the qualified name of a single directory matching the pattern,
    # so if you want to process the files in that directory, you can follow up with:
    for fileentry in filter(methodcaller('is_file'), scandir(targetdir)):
        # fileentry is a DirEntry with attributes for .name, .path, etc.
</code></pre>
<p>See the docs on <a href="https://docs.python.org/3/library/os.html#os.scandir" rel="nofollow noreferrer"><code>os.scandir</code></a> for more advanced usage, or you can just make the inner loop a call to <code>os.walk</code> to preserve most of your original code as is.</p>
<p>If you really must use <code>os.walk</code>, you can just be more targeted in how you prune <code>dirs</code>. Since you specified all <code>TARGET</code> directories should be only one level down, this is actually pretty easy. <code>os.walk</code> walks top down by default, which means the first set of results will be the root directory (which you don't want to prune solely to <code>TARGET</code> entries). So you can do:</p>
<pre><code>import fnmatch

for i, (dirpath, dirs, files) in enumerate(os.walk(path)):
    if i == 0:
        # Top level dir, prune non-Project dirs
        dirs[:] = fnmatch.filter(dirs, 'Project *')
    elif os.path.samefile(os.path.dirname(dirpath), path):
        # Second level dir, prune non-TARGET dirs
        dirs[:] = fnmatch.filter(dirs, 'TARGET')
    else:
        # Do whatever handling you'd normally do for files and directories
        # located under path/Project */TARGET/
</code></pre>
</div>
<span class="comment-copy">Try: <code>if 'TARGET' in dirnames: dirnames[:] = ['TARGET']</code>...</span>
<span class="comment-copy">what about using <code>glob.glob</code> to first get a list of "target" subdirs then using <code>os.listdir</code> or <code>os.walk</code> on the results ?</span>
<span class="comment-copy">@CAB That means that <code>walk</code> won't get past the root directory.</span>
<span class="comment-copy">@CAB You probably meant <code>else dirnames</code>. Otherwise you end the recursion, and since the root directory does not contain <code>TARGET</code> you end up doing nothing.</span>
<span class="comment-copy">You could just consume the first value.  <code>o=os.walk(path)</code> <code>_=next(o)</code> then your code</span>
<span class="comment-copy">Seems like this would do nothing if the initial path is <code>/root</code> because it contains no subdirectory named <code>TARGET</code>.</span>
<span class="comment-copy">@martineau Yes, that is correct. By <i>not</i> removing the directory names it <i>does</i> recursive into the other directories, which is the point of the answer.</span>
<span class="comment-copy">Ah, right...now I get it. Good answer.</span>
<span class="comment-copy">Am I mistaken or this fails if the directories might be nested more than one level? And if this doesn't fails then that means that it will still list the contents of the <code>Irrelevant</code> directories, and for each path inside them it will check that it does not verify the pattern, but still it will have to waste that time.</span>
<span class="comment-copy">@Bakuriu: If they might be nested more than one level, make <code>globpat = os.path.join(glob.escape(path), '**', 'TARGET')</code> and make the <code>iglob</code> call <code>glob.iglob(globpat, recursive=True)</code> and it will descend indefinitely. The OP seemed to want it exactly one level down though, so deep recursion shouldn't be needed. You can also tweak the wildcards to avoid <code>Irrelevant</code> directories for that single level case, e.g. replacing the <code>'*'</code> component with <code>'Project [AB]'</code> for very targeted selection, or <code>'Project *'</code> for any directory with a <code>Project </code> prefix.</span>
<span class="comment-copy">Yes, but my point is that if you use <code>**</code> your answer becomes inefficient. <code>iglob</code> cannot know that <i>nothing</i> below <code>Irrelevant</code> matters, yet it will still have to check all those contents (which, if <code>Irrelevant</code> contains millions of files or nested subdirectories will take significant time).</span>
<span class="comment-copy">@Bakuriu: Sure. But then, the OP doesn't need <code>**</code>. Sure, for very fine grained filters with deep recursive searches in large trees, globbing is simple but slow. But for the OP's case, it should be fine. I did add a more involved fully filtering <code>os.walk</code> solution for completeness that filters the top level and second level specially so it only fully processes trees under <code>Project */TARGET</code>. But if <code>TARGET</code> can be at any depth, it's not saving you work, you're still looking through everything under <code>Project */</code> looking for <code>TARGET</code> directories.</span>
<span class="comment-copy">@Bakuriu: While it's not relevant to the single level check here, I did notice one reason you'd want to avoid <code>glob</code>: It follows symlinks, and can't be told not to do so. You might want this, but it's comparatively rare, and risks problems (cyclic references, or just references out to a huge directory you don't want to search). <code>os.walk</code> can follow symlinks, but doesn't by default.</span>
