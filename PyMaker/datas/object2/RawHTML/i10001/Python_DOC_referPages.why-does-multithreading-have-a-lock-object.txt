<div class="post-text" itemprop="text">
<p>My understanding is that <a href="https://docs.python.org/3/library/threading.html" rel="nofollow">threading</a> allows in reality to have only <strong>one</strong> thread active at a time, continously switching between threads. This is useful when having IO-bound operations where the worload is effectively offloaded somewhere else (an PI, a database, ...).</p>
<p>If so, <strong>why is there a need for a <a href="https://docs.python.org/3/library/threading.html#lock-objects" rel="nofollow">Lock()</a> object?</strong> There is no risk that a variable is accessed by two threads simultaneously (as it can be the case in multiprocessing) so I fail to see a real usage for locks in this context.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, locks secure whole areas, think of updating a file:</p>
<pre><code>with lock:
    with open("some_file", "r+") as f:
        do_something(f)
</code></pre>
<p>Even single operations like</p>
<pre><code>a['b'] += 1
</code></pre>
<p>might lead to multiple operations (read value of <code>a['b']</code>, increment, write to <code>a['b']</code>), and need to be secured by a lock:</p>
<pre><code>with lock:
    a['b'] += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>There is no risk that a variable is accessed by two threads simultaneously</em></p>
<p>It depends on the scheduler used to implement multithreading. Context switches may occur on any interrupt no matter what the current thread does. Therefore a thread accessing a variable may be interrupted on a clock interrupt and another thread accessing the same variable may be activated.</p>
</div>
<span class="comment-copy">Isn't the limitation of one thread only true for the CPython implementation? And the standard library has to be implemented by all potential Python interpreters? (e.g.: in Jython you would need the <code>Lock</code> object as it has "true" multithreading)</span>
<span class="comment-copy">actually there is risk that a variable is accessed by two threads.</span>
<span class="comment-copy">As with any processor, Pythons Virtual Machine has some atomic operations, but most Python statements are not atomic. Therefore locks.</span>
<span class="comment-copy">The problems with concurrency come when you have to complete more than one operation atomically (which means: practically always). Keep in mind that even <code>a += 1</code> is more than one byte code: <code>LOAD_FAST a</code>, <code>LOAD_CONST 1</code>, <code>INPLACE_ADD</code>, <code>STORE_FAST a</code>. So there are <i>3</i> places where these instructions could be halted before they are completed!</span>
<span class="comment-copy">Thank you. I use locks for file access and my question was more about the in-memory data (variables). Your example of non-atomicity is very clear.</span>
