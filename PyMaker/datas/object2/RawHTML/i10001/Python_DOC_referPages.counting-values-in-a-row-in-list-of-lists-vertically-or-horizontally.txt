<div class="post-text" itemprop="text">
<p>I'm writing a function that counts the number of occurrences of a specific value of a list of lists <strong>in a row</strong> whether horizontal or vertical. Then it just needs to return the value of how many times it occurred. Here's an example</p>
<pre><code>lst=[['.','.','.','e'],
     ['A','A','.','e'],
     ['.','.','.','e'],
     ['.','X','X','X'],
     ['.','.','.','.'],
     ['.','.','.','e']]
</code></pre>
<p>For this list of lists, the function should return 3 for e as it appears 3 times in a row, 2 for A, and 3 for X. Thank you for your time</p>
<p>My code so far:</p>
<pre><code>def length_of_row(symbol,lot):
    count = 0
    for sublist in lot:
        for x in sublist:
            if x == symbol:
                count += 1
                continue
            else:
                continue
                return count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try the following if you don't mind changing things a little bit:</p>
<pre><code>from functools import reduce
from itertools import takewhile


def length_of_row(symbol, lot):
    if symbol not in reduce(lambda x,y: x+y, lot):
        return 0
    elif symbol in lot[0]:
        good_lot =  map(lambda y: y.count(symbol),takewhile(lambda x: symbol in x, lot))
        return sum(good_lot)
    else:
        return length_of_row(symbol, lot[1:])
</code></pre>
<p>This uses a combination of recursion and one of python's powerful <a href="https://docs.python.org/3/library/itertools.html#module-itertools" rel="nofollow"><code>itertools</code></a> methods (<a href="https://docs.python.org/3/library/itertools.html#itertools.takewhile" rel="nofollow"><code>takewhile</code></a>). The idea is to count the number of symbols until you hit a list that does not contain that symbol. Also, it tries to make sure that it only counts the occurrences of the symbol if said symbol is in the list of lists.</p>
<p>Using it:</p>
<pre><code>lst = [['.', '.', '.', 'e'],
 ['A', 'A', '.', 'e'],
 ['.', '.', '.', 'e'],
 ['.', 'X', 'X', 'X'],
 ['.', '.', '.', '.'],
 ['.', '.', '.', 'e']]

print(length_of_row('e', lst))
print(length_of_row('X', lst))
print(length_of_row('A', lst))
print(length_of_row('f', lst))

#3
#3
#2
#0
</code></pre>
<p>As you can see, if the symbol does not exist it returns <code>0</code>.</p>
<h3>Edit:</h3>
<p>If you don't wish to import the <code>takewhile</code> function from <code>itertools</code>, you can use the approximate definition provided in the documentation. But just keep in mind that it is not as optimized as the <code>itertools</code> method:</p>
<pre><code>def takewhile(predicate, iterable):
    for x in iterable:
        if predicate(x):
            yield x
        else:
            break
</code></pre>
<p>Also, <code>reduce</code> should be available to you directly if you are using <code>python2</code>. However, you can define a function to reduce a list of lists into one list as follows:</p>
<pre><code>def reduce_l_of_l(lst_of_lst):
    out_lst = []
    for lst in lst_of_lst:
        out_lst += lst
    return out_lst
</code></pre>
<p>Instead of using <code>reduce</code>, just replace it with <code>reduce_l_of_l</code> after it's been defined.</p>
<p>I hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is actually quite a messy problem to solve with basic principles, and will be especially hard if you've just started learning programming. Here's a concise but more advanced solution:</p>
<pre><code>result = {}
for grid in [lst, zip(*lst)]:
    for row in grid:
        for key, group in itertools.groupby(row):
            result[key] = max(len(list(group)), result.get(key, 0))
</code></pre>
<p>Then <code>result</code> is:</p>
<pre><code>{'A': 2, 'X': 3, 'e': 3, '.': 4}
</code></pre>
</div>
<span class="comment-copy">Where in your code are you testing whether symbols are the same?</span>
<span class="comment-copy">I don't think you understand what <code>continue</code> does. There's no way to reach <code>return count</code> here.</span>
<span class="comment-copy">Your code doesn't even check whether an element in the array is the symbol that was passed to the function. All it's doing is counting the number of truthy values.</span>
<span class="comment-copy">The indentation of <code>return count</code> is almost certainly wrong, it's probably meant to be outside the loop.</span>
<span class="comment-copy">@Barmar specific list of lists like the one I included above 'lst' are input into the function and then it tests how many times 'symbol' (which can be any character) appears in a row whether vertical or horizontal. For that particular one it tests for A and should return 2 and also tests for C which it should return 0 since there are no C's in that list of lists</span>
<span class="comment-copy">Thank you so much I chose this as best answer as it returns in the correct way. Is this still possible without importing modules? I should have made it clear in my original question but part of the challenge of this is not importing tools (not sure why it says that as it just makes things more difficult)</span>
<span class="comment-copy">I found the definition for reduce online and added it to my program and now it works thanks a lot you've been a huge help</span>
<span class="comment-copy">I am glad this was useful.</span>
<span class="comment-copy">Thank you for answering. Can this be done without importing modules and instead returning just the specific value of the character that is being tested? If you don't want to write the code but maybe explain how it could be done without importing thatd be helpful. For example have result equal just 2, 3, 3, or 4 depending on if it is testing for A, X, e, or '.' .</span>
