<div class="post-text" itemprop="text">
<p>Say I have a variable <code>x</code>, which is of an unknown data type. I also have some random function <code>foo</code>. Now I want to do something along the following lines:</p>
<p>If <code>x</code> is a type that can be unpacked using **, such as a dictionary, call <code>foo(**x)</code>. Else, if <code>x</code> is a type that can be unpacked using *, such as a tuple, call <code>foo(*x)</code>. Else, just call <code>foo(x)</code>.</p>
<p>Is there an easy way to check whether a type can be unpacked via either ** or *? </p>
<p>What I am currently doing is checking the type of x and executing something like:</p>
<pre><code>if type(x) == 'dict':
    foo(**x)
elif type(x) in ['tuple','list', ...]:
    foo(*x)
else:
    foo(x)
</code></pre>
<p>But the problem is that I don't know the complete list of data types that can actually be unpacked and I'm also not sure if user defined data types can have a method that allows them to be unpacked.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>try</code>:</p>
<pre><code>try:
    foo(**x)
except:
    try:
        foo(*x)
    except:
        foo(x)
</code></pre>
<p>Its kind of crude, and doesn't distinguish <em>why</em> the exception occurred (which might be mitigated by checking the type of exception), but eliminates the need to try and enumerate which types can be called which way.    </p>
</div>
<div class="post-text" itemprop="text">
<p>Let's check the errors we receive when doing it badly:</p>
<pre><code>&gt;&gt;&gt; x = 1
&gt;&gt;&gt; f(*x)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: f() argument after * must be a sequence, not int
&gt;&gt;&gt; f(**x)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: f() argument after ** must be a mapping, not int
</code></pre>
<p>Great: so we need a sequence type for <code>*</code> and a mappping type for <code>**</code>. The rest is fairly straightforward: the <a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range" rel="nofollow noreferrer">Python 3 docs</a> state:</p>
<blockquote>
<p>There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections.</p>
</blockquote>
<p>The fail-safe way to check if a var is a sequence type is:</p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; all(isinstance(x, collections.Sequence) for x in [[], (), 'foo', b'bar', range(3)])
True
</code></pre>
<p>(see <a href="https://stackoverflow.com/questions/2937114/python-check-if-an-object-is-a-sequence">Python: check if an object is a sequence</a> for more info)</p>
<p>The mapping type, according to the <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer">docs</a>, is a <code>dict</code>:</p>
<blockquote>
<p>There is currently only one standard mapping type, the dictionary.</p>
</blockquote>
<p>You can check this in the same way, using <code>isinstance</code>, which will even take care of derived classes:</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; all(isinstance(x, dict) for x in [{}, OrderedDict(), Counter()])
True
</code></pre>
<p>So you could do as follows:</p>
<pre><code>import collections
if isinstance(x, dict):
    foo(**x)
elif isinstance(x, collections.Sequence):
    foo(*x)
else:
    foo(x)
</code></pre>
</div>
<span class="comment-copy">Indeed, <code>except TypeError</code> is the minimal restriction you should put on that; though that still doesn't tell you whether <code>**</code> raised the exception or something within <code>foo</code>.</span>
<span class="comment-copy">Cute answer, but what if foo(x) fails too? might Make another try for it ? Since x is unknown right ?</span>
<span class="comment-copy">Hence the disclaimer after the code.</span>
<span class="comment-copy">This is close to what I'm looking for, but it doesn't seem to work for sets. For example <code>isinstance(set([1,2,3]),collections.Sequence)</code> is false. However, <code>'{},{}'.format(*set([1,2,3]))</code> unpacks to <code>'1,2'</code> just fine. I'm not sure if there are any other exceptions, but there's at least this one.</span>
<span class="comment-copy">set([1,2,3]) unpacks to 1,2 is fine?</span>
<span class="comment-copy">@K.Mao Hmm...you're right, but note that this doesn't really make a lot of sense since <code>set</code>'s are not ordered. I'm checking up on this now</span>
<span class="comment-copy">I did a bit of digging around. Maybe <code>collections.Iterable</code> could work? You can unpack sets and dictionaries using * (though dictionaries should probably be unpacked using **). And <code>all(isinstance(x,collections.Iterable) for x in [set(),[],(),{},'foo',b'bar',range(3)])</code> evaluates to true, whereas <code>collections.Sequence</code> fails on sets and dictionaries. However, I do agree that it doesn't make very much sense to unpack sets or dictionaries using *, considering they are not ordered. But for some reason you can do it in Python.</span>
<span class="comment-copy">You're right: for a <code>dict</code> it will iterate through keys. I would advise using <code>Sequence</code> because those will give you <i>predictable, ordered</i> behavior.</span>
