<div class="post-text" itemprop="text">
<pre><code>class Ordered:
    def __init__(self,aset):
        self.aset = aset
    def __iter__(self):
        for v in sorted(self.aset): # iterate over list of values returned by sorted
            yield v
</code></pre>
<p>the function takes a set and return a list</p>
<p>the set is always </p>
<p>s = {1, 2, 4, 8, 16}</p>
<p>for example:</p>
<pre><code>s = {1, 2, 4, 8, 16}
i = iter(Ordered(s))
print(next(i))
print(next(i))
s.remove(8)
print(next(i))
s.add(32)
print(next(i))
print(next(i))

it should prints 1 2 4 16 32
</code></pre>
<p>But when my function takes</p>
<pre><code>[next(i), next(i), s.remove(8), next(i), next(i), s.add(32), next(i)]
</code></pre>
<p>it should print</p>
<pre><code>[1, 2, None, 4, 16, None, 32]
</code></pre>
<p>But instead, it prints:</p>
<pre><code>[1, 2, None, 4, 8, None, 16]
</code></pre>
<p>can someone tell me how to fix it? thanks</p>
<p>I posted the error I got below to help to understand:</p>
<pre><code>39 *Error: Failed [next(i), next(i), s.remove(8), next(i), next(i), s.add(32), next(i)] == [1, 2, None, 4, 16, None, 32]
      evaluated: [1, 2, None, 4, 8, None, 16] == [1, 2, None, 4, 16, None, 32]
42 *Error: [next(i), next(i), next(i), s.add(3), next(i), s.add(10), s.add(32), next(i), next(i), next(i)] raised exception; unevaluated: [1, 2, 4, None, 8, None, None, 10, 16, 32]
46 *Error: Failed [next(i), s.remove(2), s.remove(4), s.remove(8), next(i)] == [1, None, None, None, 16]
      evaluated: [1, None, None, None, 2] == [1, None, None, None, 16]
49 *Error: Failed [next(i), s.remove(2), next(i), s.remove(4), s.remove(8), next(i)] == [1, None, 4, None, None, 16]
      evaluated: [1, None, 2, None, None, 4] == [1, None, 4, None, None, 16]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/2/library/functions.html#sorted" rel="nofollow"><code>sorted()</code></a> function sorts the argument and returns a list.  Modifying the input set will not affect the sorted list.</p>
<p>If you want the iterator to reflect changes to the original set, the iterator will need to check the state of the set at each iteration and respond appropriately.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you use <code>sorted</code>, you create a sorted list from the set. That list has no connection to the original set it was created from, and will not reflect any changes to that set. You will have to keep track of changes yourself, while iterating the elements in sorted order.</p>
<p>Keeping track of removed elements is simple: Just check whether the current element is still in the original set. Keeping track of new elements is a bit more complex. You could use the <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow"><code>heapq</code></a> module and create a <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" rel="nofollow">heap</a> from the set, instead of a sorted list, then you can add new elements to that heap while iterating it. To find new elements, create a copy of the original set and compare the two in each iteration. Also, according to your test cases, you will have to check whether the current element is smaller than the previous, and skip it in this case.</p>
<pre><code>import heapq

class Ordered:

    def __init__(self,aset):
        self.aset = aset

    def __iter__(self):
        # memorize original elements
        known = set(self.aset)
        last = None

        # create heap
        heap = list(self.aset)
        heapq.heapify(heap)

        # yield from heap
        while heap:
            v = heapq.heappop(heap)
            if (v in self.aset and  # not removed
                    (last is None or last &lt; v)): # not smaller than last
                yield v
            last = v

            # in case of new elements, update the heap
            diff = self.aset - known
            if diff:
                for x in self.aset - known:
                    heapq.heappush(heap, x)
                known = set(self.aset)
</code></pre>
<p>This works for all your test cases (re-initialization of <code>s</code> and <code>i</code> not shown):</p>
<pre><code>&gt;&gt;&gt; s = {1, 2, 4, 8, 16}
&gt;&gt;&gt; i = iter(Ordered(s))
&gt;&gt;&gt; [next(i), next(i), s.remove(8), next(i), next(i), s.add(32), next(i)]
[1, 2, None, 4, 16, None, 32]
&gt;&gt;&gt; [next(i), next(i), next(i), s.add(3), next(i), s.add(10), s.add(32), next(i), next(i), next(i)]
[1, 2, 4, None, 8, None, None, 10, 16, 32])
&gt;&gt;&gt; [next(i), s.remove(2), s.remove(4), s.remove(8), next(i)]
[1, None, None, None, 16]
&gt;&gt;&gt; [next(i), s.remove(2), next(i), s.remove(4), s.remove(8), next(i)]
[1, None, 4, None, None, 16]
</code></pre>
</div>
<span class="comment-copy">The iterator isn't valid anymore after you remove something.</span>
<span class="comment-copy">but how can I fix it?</span>
<span class="comment-copy">can anyone help me to fix it ?</span>
