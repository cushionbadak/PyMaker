<div class="post-text" itemprop="text">
<p>I have a list and I want to find the element that has the lowest count of '*'. </p>
<pre><code>mylist = ['12*3','12345**6','11234']
</code></pre>
<p>So the answer in this little test is '11234'</p>
<p>This works but is slow (I'm working with massive genomic data:</p>
<pre><code>sorted(mylist, key = lambda x: x.count('*'))[0]
</code></pre>
<p>This is less eloquent but works:</p>
<pre><code>values = map(lambda x: x.count('*'), mylist)
print mylist[values.index(min(values))]
</code></pre>
<p>Is there a better way?
I was trying to do a schwartzian transformation but can't figure it out.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#min" rel="nofollow noreferrer"><code>min</code></a> with <code>key</code> parameter:</p>
<pre><code>&gt;&gt;&gt; mylist = ['12*3','12345**6','11234']
&gt;&gt;&gt; min(mylist, key=lambda x: x.count('*'))
'11234'
</code></pre>
<p><code>key</code> is a function that is called on each item on the iterable to specify the ordering the same way as in <code>sorted</code>.</p>
<p>Above approach will result to <strong>O(n)</strong> time complexity where as sorting is <strong>O(n log n)</strong>.</p>
<p><strong>Update:</strong> If your strings are really long then you could count the occurrences of <code>*</code> in a loop and reject the string as soon as count is the same as current minimum. You could also terminate the search if string with 0 occurrences is found:</p>
<pre><code>def find(l):
    min_item = None
    min_val = float('inf')

    for x in l:
        current = 0
        for c in x:
            current += (c == '*')
            if current &gt;= min_val:
                break
        else:
            # Found new minimum, update
            min_item = x
            min_val = current

        # Can't get lower than 0
        if min_val == 0:
            break

    return min_item

print(find(['12*3','11234', '12345**6', '1'])) # '11234'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may further improve the performance by creating the separate function for <code>key</code> instead of <code>lambda</code> as <em>lambda functions</em> are slow. For example as:</p>
<pre><code>def get_asterisk_count(my_string):
    return my_string.count('*')

mylist = ['12*3','12345**6','11234']
min(mylist, key=get_asterisk_count)
</code></pre>
<p>Below are the <code>timeit</code> stats:</p>
<ul>
<li><p>Using <code>lambda</code> function: 1.25 usec</p>
<pre><code>mquadri$ python -m "timeit" -s "mylist = ['12*3','12345**6','11234']" "min(mylist, key=lambda x: x.count('*'))"
1000000 loops, best of 3: 1.25 usec per loop
</code></pre></li>
<li><p>Using separate function: 1.19 usec</p>
<pre><code>mquadri$ python -m "timeit" -s "mylist = ['12*3','12345**6','11234']" "def get_asterisk_count(my_string): return my_string.count('*')" "min(mylist, key=get_asterisk_count)"
1000000 loops, best of 3: 1.19 usec per loop
</code></pre></li>
</ul>
</div>
<span class="comment-copy">I think the differences in your timings are not appreciable. Certainly not enough to support the claim that "lambda functions are slow", or--more generously--<i>slower</i>. When I run the same snippets multiple times, sometimes the named function comes out ahead, sometimes the <code>lambda</code> comes out ahead. This leads me to believe the differences are purely noise and/or some confounding factor. AFAIK, in CPython, there is no real difference in the implementation of <code>lambda</code> and <code>def</code> functions. I don't see any reason why the execution of a <code>lambda</code> would be slower than the equivalent named function.</span>
