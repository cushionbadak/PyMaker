<div class="post-text" itemprop="text">
<p>I've been building this program to make a decision based off a sum of numbers in a given list.  When I sum the numbers in a given function that also tests ceratin required logic it gives the correct answer, but the if statement that tests the value doesn't work properly, or will execute the wrong if statement:</p>
<pre><code>import random
from decimal import Decimal
from decimal import getcontext


def language_equate(sentence_parsing):
    both = ["and", ",", "then", "next"]
    ignore = ["don't", "not"]
    travel = ["move", "go", "travel"]
    dial = ["rotate", "turn", "spin", "twist"]
    lever_positive = ["push", "back"]
    lever_negative = ["pull", "forward"]
    north = ["north", "up", "forward"]
    east = ["east", "right"]
    west = ["west", "left"]
    south = ["south", "down", "backward"]
    modded_sentence = []
    getcontext().prec = 20
    for i, word in enumerate(sentence_parsing):
        if word.lower() in both:
            modded_sentence.append(Decimal(99))
        elif word.lower() in ignore:
            modded_sentence.append(Decimal(-20))
        elif word.lower() in travel:
            modded_sentence.append(Decimal(1))
        elif word.lower() in dial:
            modded_sentence.append(Decimal(1/3))
        elif word.lower() in lever_positive:
            modded_sentence.append(Decimal(1/5))
        elif word.lower() in lever_negative:
            modded_sentence.append(Decimal(1/7))
        elif word.lower() in north:
            modded_sentence.append(Decimal(1/11))
        elif word.lower() in east:
            modded_sentence.append(Decimal(1/13))
        elif word.lower() in west:
            modded_sentence.append(Decimal(1/17))
        elif word.lower() in south:
            modded_sentence.append(Decimal(1/19))
    return modded_sentence


def language_evaluate(sentence_parsing):
    modded_sentence = language_equate(sentence_parsing)
    a = sum(modded_sentence)
    return a


def entrance(dial, lever, win, current_room, EPSILON):
    print("You are in the entrance.")
    print("Go north to try the closed door")
    print("Go east to the kitchen")
    print("Go west to the pantry")
    print("Go south to exit")
    print("What would you like to do?")
    sentence_parsing = input().split(" ")
    go = language_evaluate(sentence_parsing)
    # Exclusive Disjunction Answer Bank
    answer_bank = ["Y", "y", "Yes", "yes", "YES"]
    if abs(go - Decimal(1/11)) &lt;= EPSILON or abs(go - Decimal(12/11)) &lt;= EPSILON: # separate statements
        if dial == "red" and lever == "backward":
            win = True
            current_room = ""
        else:
            print("Sorry the door remains locked")
    elif abs(go - Decimal(1/13)) &lt;= EPSILON or abs(go - Decimal(14/13)) &lt;= EPSILON:
        current_room = "kitchen"
    elif Decimal(1/17) or Decimal(18/17):
        current_room = "pantry"
    elif abs(go - Decimal(1/19)) &lt;= EPSILON or (go - Decimal(20/19)) &lt;= EPSILON:
        print("Are You sure you want to quit? [Y/N]")
        give_up = input()
        if give_up in answer_bank:
            print("Ok, maybe next time")
            raise SystemExit
    else:
        print("Sorry I don't understand that")
    return win, current_room


def kitchen(lever, lever_position, current_room, EPSILON):
    print("You are in the kitchen.")
    print("Go north to move the lever the %s position" % lever)
    print("Go west to the entrance")
    print("What would you like to do?")
    sentence_parsing = input().split(" ")
    go = language_evaluate(sentence_parsing)
    print(go)
    if abs(go - 16/55) &lt;= EPSILON or abs(go - 71/55) &lt;= EPSILON or abs(go - 1/5) &lt;= EPSILON:
        lever = lever_position[1]
    elif abs(go - 18/77) &lt;= EPSILON or abs(go - 95/77) &lt;= EPSILON or abs(go - 1/7) &lt;= EPSILON:
        lever = lever_position[0]
    elif abs(go - 1/17) &lt;= EPSILON or abs(18/17) &lt;= EPSILON:
        print("test works")
        current_room = "entrance"
    else:
        print("Sorry I don't understand that")
    return lever, current_room


def pantry(dial, current_room, EPSILON):
    print("You are in the pantry.")
    print("South of you is a three coloured dial, with the color %s glowing" % dial)
    print("Go east to the entrance")
    print("Go south to turn the dial")
    print("What would you like to do?")
    sentence_parsing = input().split(" ")
    go = language_evaluate(sentence_parsing)
    print(int(go))
    if abs(go - 1/19) &lt;= EPSILON or abs(go - 20/19) &lt;= EPSILON or abs(go - 22/57) &lt;= EPSILON or abs(go - 79/57) &lt;= EPSILON or abs(go - 1/3) &lt;= EPSILON:
        dial += 1
        if dial == 3:
            dial = 0
    elif abs(go - 1/13) &lt;= EPSILON or abs(14/13) &lt;= EPSILON:
        current_room = "entrance"
    else:
        print("Sorry I don't understand that")
    return dial, current_room


def main():
    EPSILON = Decimal(0.00000000001)
    current_room = "entrance"
    dial_color = ["green", "blue", "red"]
    dial = dial_color[random.randrange(3)]
    lever_position = ["forward", "backward"]
    lever = lever_position[random.randrange(2)]
    win = False
    while win is False:
        while current_room is "entrance":
            entrance(dial, lever, win, current_room, EPSILON)
            win, current_room = entrance(dial, lever, win, current_room, EPSILON)
        while current_room is "kitchen":
            kitchen(lever, lever_position, current_room, EPSILON)
            lever, current_room = kitchen(lever, lever_position, current_room, EPSILON)
        while current_room is "pantry":
            pantry(dial, current_room, EPSILON)
            dial, current_room = pantry(dial, current_room, EPSILON)
main()
</code></pre>
<p>From start if you go south 3 times you will get an error, 2 times you will end up east in the pantry, and 1 time wont do anything??? I'm very very lost
The program at this point will be followed by three more similar elif statements, however the first time you give input will be ignored, and the second time it will perform the wrong action except for the one including the prime fraction of 1/11;  side note all other elifs use increasing prime fractions{1/11, 1/13, 1/17, 1/19}.  I have very little experience programing(3-ish months) and am just learning python as my first language.  Any help would be greatly appretiated</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a bunch of errors in your code. Lets see the ones the cause the issue you describe when you enter <code>"south"</code> as your input three times.</p>
<p>The <code>entrance</code> function has one test that's seriously broken: </p>
<pre><code>elif Decimal(1/17) or Decimal(18/17):
</code></pre>
<p>That's always going to be true, so if you reach that condition (by not going north or east, which are tested for earlier), you always end up going to the pantry.</p>
<p>The <code>pantry</code> function has a similar issue, where you're not converting some of your fractions to <code>Decimal</code> before subtracting from the value you get from the parsing code. This causes the exception you see.</p>
<p>The reason you have the <code>entry</code> twice is that your <code>main</code> function always calls the current room's function twice (on two consecutive lines). The choice made the first time is ignored.</p>
<p>There are probably more errors in other parts of the code that I looked at yet.</p>
<p>You're making your task much more difficult than it needs to be by using fractions for the values you parse your input text into. A much better approach would be to use integer powers of two, and use bitwise-or (<code>|</code>) to combine them. For instance, if the word <code>move</code> parsed to <code>1</code> (<code>2**0</code>) and <code>south</code> parsed to <code>16</code> (<code>2**4</code>), your test for <code>south</code> or <code>move south</code> could be <code>if go == 16 or go == 17</code> (with no type conversions or epsilon needed). If you don't care about extra words, you could use bitwise-and (<code>&amp;</code>) to just test for one term: <code>if go &amp; 16</code>.</p>
<p>You might also consider using an <code>Enum</code> if you're using a version of Python that includes the <code>enum</code> module (it was added in Python 3.4).</p>
</div>
<div class="post-text" itemprop="text">
<p>This are the issues with your program:</p>
<ol>
<li><p>You use <a href="https://docs.python.org/3/reference/expressions.html#is" rel="nofollow noreferrer"><code>is</code></a> for equally testing when you should use <a href="https://docs.python.org/3/library/stdtypes.html?#comparisons" rel="nofollow noreferrer"><code>==</code></a>, for example in here</p>
<pre><code>while current_room is "entrance":
</code></pre>
<p>the <code>is</code> operator tell you if the to object have the same place in memory not if they have the same value, usually they may be the same for immutable object like strings but you can't count on that, for example</p>
<pre><code>&gt;&gt;&gt; "asfdvfgbgdf" is "".join("asfdvfgbgdf")
False
&gt;&gt;&gt; 
</code></pre>
<p>while using <code>==</code> give the correct answer</p>
<pre><code>&gt;&gt;&gt; "asfdvfgbgdf" == "".join("asfdvfgbgdf")
True
&gt;&gt;&gt; 
</code></pre>
<p>change all the <code>is</code> for <code>==</code></p></li>
<li><p>You don't need to compare Boolean values or any other value against <code>True</code> or <code>False</code>. In python, when a object is used in and <a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="nofollow noreferrer">Boolean context</a> that object behave as True or False</p>
<blockquote>
<p>values are interpreted as false: <code>False</code>, <code>None</code>, numeric zero of all types, and empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets). All other values are interpreted as true. User-defined objects can customize their truth value by providing a <code>__bool__()</code> method.</p>
</blockquote>
<p>so this for instance</p>
<pre><code>while win is False:
</code></pre>
<p>change it to </p>
<pre><code>while not win:
</code></pre></li>
<li><p>In your <code>main</code> function you call your other functions twice which cause that the first time the result to be ignored as you do nothing with it</p>
<p>like in here</p>
<pre><code>entrance(...)
win, current_room = entrance(...)
</code></pre>
<p>the same with <code>kitchen</code> and <code>pantry</code>. Remove the first call of each one to solve that issue.</p></li>
<li><p>In the pantry function, here</p>
<pre><code>elif abs(go - 1/13) &lt;= EPSILON or abs(14/13) &lt;= EPSILON:
</code></pre>
<p>perhaps you mean?</p>
<pre><code>elif abs(go - 1/13) &lt;= EPSILON or abs(go - 14/13) &lt;= EPSILON:
</code></pre>
<p>the same with the <code>kitchen</code> in the third <code>elif</code></p></li>
<li><p>in the <code>entrance</code> in the second <code>elif</code> </p>
<pre><code>elif Decimal(1/17) or Decimal(18/17):
</code></pre>
<p>what is this suppose to mean? by point 2, that is always true as none of those number is zero, so if fail the other check, this always will pass</p></li>
<li><p>In <code>language_equate</code> in the for-loop</p>
<pre><code>for i, word in enumerate(sentence_parsing):
</code></pre>
<p>you never use the <code>i</code>, so there is no reason to use enumerate, so change it to</p>
<pre><code>for word in sentence_parsing:
</code></pre>
<p>also you repeat the <code>word.lower()</code> too many times, you should try to <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="nofollow noreferrer">avoid repeat instructions</a> that always give the same result because is a waste of time, instead make a new variable or reuse the one you have con the result of that method for instance</p>
<pre><code>for word in sentence_parsing:
    word = word.lower()
    if word in both:
        ...
    elif word in ignore:
        ...
    ...
</code></pre>
<p>you can also call the <code>lower</code> as soon as you get the input like </p>
<pre><code>input().lower()
</code></pre>
<p>or as you split it then </p>
<pre><code>input().lower().split()
</code></pre></li>
<li><p>Finally as you may have notice Decimal and floats don't like each other very much as I said in my previous comment, choose one or the other and stick with it all the way. </p>
<p>Or as <strong>Blckknght</strong> suggest, change instead to use <a href="https://en.wikipedia.org/wiki/Mask_(computing)" rel="nofollow noreferrer">Bit Mask</a>, or <a href="https://docs.python.org/3/library/enum.html?" rel="nofollow noreferrer">enumeration</a> </p></li>
</ol>
</div>
<span class="comment-copy">Don't define <code>sum</code> like that because it will run recursively and not work at all how you want it to.</span>
<span class="comment-copy">Adding to @EliSadoff comment, your sum function is recursive (calling itself) on an infinite loop, most likely the execution is not reaching the if statement</span>
<span class="comment-copy">sorry marked it down wrong the function wasn't supposed to be named as the built in sum() function, either way It doesn't work</span>
<span class="comment-copy">I can't understand what you're saying at all. Please try to explain more clearly and if possible include a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">we can't test your sample code, what is <code>user_statement</code>? your print should be <code>print("yeah, it works")</code> and yours <code>summation</code> function is no more that a alias for the built-in <code>sum</code> use that instead or if you want to change the name of <code>sum</code> you can do <code>summation=sum</code></span>
<span class="comment-copy">Thank you very much for the feed back, I am really new to programing and was kind of getting stuck on this one; I will never refuse help from someone who clearly knows much more than I do.  PS it works fine now with those changes and some logical implementation to count accidental duplicates, double negatives and other types of things. :)</span>
