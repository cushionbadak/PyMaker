<div class="post-text" itemprop="text">
<p>I'm working on a python assignment for a class, and we are required to use the random generator to roll through the assignment(instead of going through the option recursively). </p>
<p>It's a classic problem with a simple answer, but the random selection has to find it by chance. I can't figure out why the output is repeating the same pattern as the functions look solid. Is there an issue that causes the same movement of entities?</p>
<p>EDIT: It outputs infinitely as posted repeating those blocks, but it should stop when all elements are in the 'west' list.</p>
<p>Assignment:
With the Farmer, Wolf, Goat, Cabbage, the Farmer must move all entities to the west side of a river. 
The Wolf, Goat, and Cabbage Cannot stay alone on one side.
The Wolf will eat the Goat, and the Goat will eat they Cabbage if they are alone on one side (east or west).
These restraints are mirrored by the forbidden[] list, and must be checked each time elements change sides of the river.</p>
<p>Code:</p>
<pre><code>import random

# The following comments and some changes in the code were provided by Mr. Alexey Pogodin.
# Code has been changed to follow these guidelines.
# All style recommendations below are based on PEP 8 (Style Guide for Python Code)
# http://www.python.org/dev/peps/pep-0008/
# Python module names should be all-lowercase.
# Global variable names should be lowercase, with words separated by underscores as necessary to improve readability.
# Always surround these binary operators with a single space on either side: assignment, augmented assignment,
# comparisons, Booleans
# whitespace after comma is required

east = ['C', 'F', 'G', 'W']
west = []
forbidden = [['C', 'G', 'W'],['C', 'G'],['G', 'W']]

#Complete the following function so it Prints the objects at East and then the objects at West==========================
def print_contains(east, west):
    print(east)
    print(west)

    return

#Go west: Complete this function according to the instructions on HW4
def go_west(east, west):
    west.append('F')
    east.remove('F')

    isForbidden = 1

    while isForbidden == 1:
        curr = random.choice(east)
        west.append(curr)
        east.remove(curr)

        if (all(x in east for x in forbidden[0]) or
                all(x in east for x in forbidden[1]) or
                all(x in east for x in forbidden[2])):
            isForbidden = 1
            east.append(curr)
            west.remove(curr)
        else:
            isForbidden = 0
            break


    print_contains(east, west)
    print('-------------------------------------\n')
    return east, west




#Go East: Complete this function according to the instructions on HW4   
def go_east(east, west):
    east.append('F')
    west.remove('F')

    isForbidden = 1

    while isForbidden == 1:
        curr = random.choice(west)
        east.append(curr)
        west.remove(curr)

        if (all(x in west for x in forbidden[0]) or
                all(x in west for x in forbidden[1]) or
                all(x in west for x in forbidden[2])):
            isForbidden = 1
            west.append(curr)
            east.remove(curr)
        else:
            isForbidden = 0
            break


    print_contains(east, west)
    print('-------------------------------------\n')    
    return east, west


# Solution: This function returns True if all objects are on the West side otherwise returns False (One line of code)    
def solution():
    if not east:
        return True
    else:
        return False



#DO not change anything in the following lines. Your job is to complete the functions above.
# Main

print_contains(east, west)
print('-------------------------------------')

condition = True
while condition:
    east, west = go_west(east,west)
    if not solution():
        east, west = go_east(east,west)
    else:
        condition = False
</code></pre>
<p>Output:</p>
<pre><code>['C', 'W', 'F', 'G']
[]
-------------------------------------

['W', 'C']
['F', 'G']
-------------------------------------

['W', 'C', 'F', 'G']
[]
-------------------------------------

['W', 'C']
['F', 'G']
-------------------------------------

['W', 'C', 'F', 'G']
[]
-------------------------------------

['W', 'C']
['F', 'G']
-------------------------------------

['W', 'C', 'F', 'G']
[]
-------------------------------------
etc...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you go east, you <em>always</em> ship an item with the farmer. 
After the first journey (going west), there is only one item on the west shore. Thus, the <em>only</em> choice to pick to accompany the farmer going east, is whatever you just shipped west. 
So you'll always end up with the same items on the east shore that were there initially: you simply shipped a random item back and forth between the river sides.</p>
<p>One solution would be insert an empty item to ship. It that gets picked randomly, the farmer will just row across on his own. Which is what you want in some cases for the puzzle to be solvable.</p>
</div>
<span class="comment-copy">What are the <code>for</code> loops related to the forbidden list supposed to be doing?</span>
<span class="comment-copy">@Rodolfo I edited to explain the assignment.</span>
<span class="comment-copy">Your code is really not pythonic at all, which makes it a bit confusing to understand. Python supports booleans, so instead of <code>0</code> and <code>1</code>, use <code>False</code> and <code>True</code>. Besides, <code>1</code> has a boolean value of <code>True</code>, so do not write <code>while isForbidden == 1</code>, but just <code>while isForbidden</code> (unless, of course, you want to implement different states, but your code does not). Besides, I have been programming in Python for (only) two years, but never came across the <code>all</code> method. I don't think you need it.</span>
<span class="comment-copy">@Rightleg I know, but this is the way the teacher wanted it done. the all method is to test against the forbidden list, but if there's a better way then that's fine.</span>
<span class="comment-copy">I would recommend using the python debugger <code>pdb</code> since this is more of a logical problem. <a href="https://docs.python.org/3/library/pdb.html" rel="nofollow noreferrer">docs.python.org/3/library/pdb.html</a></span>
