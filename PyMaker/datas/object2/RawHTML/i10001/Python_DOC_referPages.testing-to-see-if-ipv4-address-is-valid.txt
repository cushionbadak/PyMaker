<div class="post-text" itemprop="text">
<p>I want to return a boolean depending if the address given is a correct IPv4 address or not. I am having an issue with the all() built in in python. I have looked up the documentation on it and it seems straight forward. That being said I can't get it to work for my expression. If you could explain how it works layman's terms and how I could correct my code, that would be great.</p>
<pre><code>def IPv4_address(address):

    lst_split_address = address.split(".")
    slice_split_address = [int(num) for num in lst_split_address[1:]]

    if address.count(".") != 3:
        return False
    elif address == "":
        return False
    else:
        if all(slice_split_address) &gt;= slice_split_address[0]:
            return True
        else:
            return False


print IPv4_address("10.20.30.40")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As said in the documentation of <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow"><code>all</code></a>, it checks if every element in a list evaluates to <code>True</code> (basically <code>bool(e)</code> is <code>True</code>) or it is empty.</p>
<p>Now you have a list of integers in <code>slice_split_address</code> and so it'll check if every element of that list evaluates to <code>True</code> if you just call it like you do and any number other than 0 will evaluate to <code>True</code>, but an IP like <code>127.0.0.1</code> is actually valid.</p>
<p>So what you need is actually a list which contains <code>True</code> if the corresponding number is between 0 and 255 (inclusive):</p>
<pre><code>is_valid = [0 &lt;= e &lt;= 255 for e in slice_split_address]
</code></pre>
<p>If you call then <code>all(is_valid)</code> it returns if every item in <code>slice_split_address</code> is between 0 and 255. Usually it'll be combined into something like <code>all(0 &lt;= e &lt;= 255 for e in slice_split_address)</code>.</p>
<p>Now there is still one issue in your implementation because <code>slice_split_address</code> doesn't actually contain the first number of the IP address, so you might include it. Or do you actually want the first number to be lower or equal to the other three numbers?</p>
<p>Also your check <code>all(…) &gt;= …</code> doesn't make sense as <code>all()</code> only returns <code>True</code> or <code>False</code> so comparing it with an integer doesn't really make sense.</p>
<p>Note that <code>all(is_valid)</code> will also return <code>True</code> to IP addresses like <code>0.0.0.0</code> so might need to adjust the range I used.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using Python3, there is a built-in <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow"><code>ipaddress</code></a> module that you can use.</p>
<p>As for what is wrong with your code, I don't believe that the all() function does what you think it does. all() expects an iterable of Booleans, and returns <code>True</code> if every one of those Booleans is <code>True</code>.</p>
<p>To get that to work how you expected, you probably want something like</p>
<pre><code>all(addr_piece &gt;= slice_split_address[0] for addr_piece in slice_split_address)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't reinvent the wheel (unless you're happy to maintain the wheel).  You can use a regex to validate ipv4 addresses.  The following pattern is <a href="https://github.com/django/django/blob/f734e2d4b2fc4391a4d097b80357724815c1d414/django/core/validators.py#L83" rel="nofollow">taken from Django</a>:</p>
<pre><code>r'(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)(?:\.(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}'
</code></pre>
<p>If you are working already in the context of a Django project, you may prefer to just import their validator and use it directly:</p>
<pre><code>from django.core.validators import validate_ipv4_address
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As others have said, there are better ways to do this. And your algorithm doesn't actually validate IPv4 addresses. But here's a repaired version of your code.</p>
<pre><code>def IPv4_address(address):
    if address.count(".") != 3:
        return False
    elif address == "":
        return False
    else:
        lst_split_address = address.split(".")
        slice_split_address = [int(num) for num in lst_split_address[1:]]
        head = slice_split_address[0]
        return all(u &gt;= head for u in slice_split_address)

print IPv4_address("10.20.30.40")
</code></pre>
<p><strong>output</strong></p>
<pre><code>True
</code></pre>
<p>I've moved the <code>lst_split_address</code> stuff into the <code>else</code> block because there's no need to do it if the if / elif parts return False. </p>
<pre><code>all(u &gt;= head for u in slice_split_address)
</code></pre>
<p>uses a simple generator expression to check that all items in <code>slice_split_address</code> are &gt;= the head item.</p>
</div>
<span class="comment-copy">Thanks this has really helped me out. Sorry it has taken so long to respond, been busy. Wondering what the requirements are for an IPv4 address? do the numbers have to be consecutively bigger, with the exception of the first number? Having a hard time finding the exact requirements.</span>
<span class="comment-copy">There are special IP addresses, but they aren't “invalid”. And there is no requirement that the number need to bigger than the previous. For example <code>192.168.0.254</code> or <code>192.168.178.1</code> are a perfectly valid IPs.</span>
<span class="comment-copy">And with python2 can use <a href="https://pypi.python.org/pypi/IPy/" rel="nofollow noreferrer">IPy</a></span>
