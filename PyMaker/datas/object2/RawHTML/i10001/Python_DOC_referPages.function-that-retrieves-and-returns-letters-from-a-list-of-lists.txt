<div class="post-text" itemprop="text">
<p>I'm writing a function that needs to go through a list of lists, collect all letters uppercase or lowercase and then return a list with 1 of each letter that it found in order. If the letter appears multiple times in the list of lists the function only has to report the first time it sees the letter.</p>
<p>For example, if the list of lists was [['.', 'M', 'M', 'N', 'N'],['.', '.', '.',    '.', 'g'], ['B', 'B', 'B', '.','g']] then the function output should return ["M","N","g","B"].</p>
<p>The code I have so far seems like it could work but it doesn't seem to be working. Any help is appreciated </p>
<pre><code>def get_symbols(lot):

    symbols = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

    newlot = []

    for i in lot:
        if i == symbols:
            newlot.append(symbols)
            return newlot
        else:
            return None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are a few things wrong with your code. You are using <code>return</code> in the wrong place, looping only over the outer list (not over the items in the sublists) and you were appending <code>symbols</code> to <code>newlot</code> instead of the matched item.</p>
<pre><code>def get_symbols(lot):

    symbols = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' # You should define this OUTSIDE of the function

    newlot = []

    for i in lot: # You are iterating over the outer list only here
        if i == symbols: # == does not check if an item is in a list, use `in` here
            newlot.append(symbols) # You are appending symbols which is the alphabet
            return newlot # This will cause your function to exit as soon as the first iteration is over
        else:
            return None # No need for this
</code></pre>
<p>You can use a double <code>for</code> loop and use <code>in</code> to check if the character is in <code>symbols</code> and isn't already in <code>newlot</code>:</p>
<pre><code>l = [['.', 'M', 'M', 'N', 'N'],['.', '.', '.', '.', 'g'], ['B', 'B', 'B', '.','g']]
symbols = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

def get_symbols(lot):

    newlot = []

    for sublist in lot:
        for i in sublist:

            if i in symbols and i not in newlot:
                newlot.append(i)

    return newlot
</code></pre>
<p>This is the output for your list:</p>
<pre><code>&gt;&gt;&gt; get_symbols(l)
['M', 'N', 'g', 'B']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To build on your existing code:</p>
<pre><code>import string

def get_symbols(lot):
    symbols = string.ascii_lowercase + string.ascii_uppercase
    newlot = []

    for sublot in lot:
        for x in sublot:
            if x in symbols and x not in newlot:
                newlot.append(x)

    return newlot

print get_symbols([['.', 'M', 'M', 'N', 'N'],['.', '.', '.', '.', 'g'], ['B', 'B', 'B', '.','g']])
</code></pre>
<p>Using <code>string</code> gets us the letters a little more neatly. We then loop over each list provided (each <code>sublot</code> of the <code>lot</code>), and then for each element (<code>x</code>), we check if it is both in our list of all letters and <strong>not</strong> in our list of found letters. If this is the case, we add it to our output.</p>
</div>
<div class="post-text" itemprop="text">
<p>this also can be done by using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow">chain</a>, <a href="https://docs.python.org/3/library/collections.html#ordereddict-objects" rel="nofollow">OrderedDict</a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.isalpha" rel="nofollow">isalpha</a> as follow</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; data = [['.', 'M', 'M', 'N', 'N'],['.', '.', '.', '.', 'g'], ['B', 'B', 'B', '.','g']]
&gt;&gt;&gt; temp = OrderedDict.fromkeys(chain.from_iterable(data))
&gt;&gt;&gt; [x for x in temp if x.isalpha()]
['M', 'N', 'g', 'B']
&gt;&gt;&gt; 
</code></pre>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow">chain.from_iterable</a> will serve the same purpose as if you concatenate all the sublist in one </p>
<p>As the order is relevant, <code>OrderedDict</code> will server the same purpose as an <code>set</code> by removing duplicates with the added bonus of preserving the order of the first instance of the object added. The <a href="https://docs.python.org/3/library/stdtypes.html#dict.fromkeys" rel="nofollow"><code>fromkeys</code></a> class-method will create a dictionary with the given keys and same value, which by default is <code>None</code>, and as we don't care about it, for our purpose is a orderer set</p>
<p>Finally the <a href="https://docs.python.org/3/library/stdtypes.html#str.isalpha" rel="nofollow">isalpha</a> will tell you if the string is a letter or not</p>
<p>you can also take a look at the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">unique_everseen</a> recipe, because itertools is your best friend I recommend to put all those recipes in a file that is always at hand, they always are helpful </p>
</div>
<span class="comment-copy">Python 3 or Python 2?</span>
<span class="comment-copy">@Rob Using Python 3</span>
<span class="comment-copy">Thank you the other answers were also good but this seems like the simplest way to accomplish this</span>
