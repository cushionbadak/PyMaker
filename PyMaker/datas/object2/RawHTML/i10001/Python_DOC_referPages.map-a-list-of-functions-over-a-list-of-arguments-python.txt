<div class="post-text" itemprop="text">
<p>I have a list of functions:  listFunc=[g1, g2, g3].  This list is generated with the code below:  </p>
<pre><code>def g(y): 
    def f(x):
        return x+y;
    return f; 
listFunc=list(map(g, [1, 2, 3])); 
</code></pre>
<p>Now, I have a list of arguments ListArg = [4, 5, 6];</p>
<p>How could I get a result list of <code>[g1(4), g1(5), g1(6), g2(4), g2(5), g2(6), g3(4), g3(5), g3(6)]</code> using <code>map</code> only?      </p>
<p>I thought about using the following code:</p>
<pre><code>map(lambda x:x(y), listFunc, ListArg)
</code></pre>
<p>But it only gives a result of <code>[g1(4), g2(5), g3(6)]</code>. </p>
<p>Thanks,</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a perfect use-case for a list comprehension with two for-clauses:</p>
<pre><code>&gt;&gt;&gt; def g1(x): return 1*x
... 
&gt;&gt;&gt; def g2(x): return 2*x
... 
&gt;&gt;&gt; def g3(x): return 3*x
... 
&gt;&gt;&gt; funcs = [g1,g2,g3]
&gt;&gt;&gt; args = [4,5,6]
&gt;&gt;&gt; [f(a) for f in funcs for a in args]
[4, 5, 6, 8, 10, 12, 12, 15, 18]
&gt;&gt;&gt; 
</code></pre>
<p>This is eminently readable and eminently functional - list comprehensions were borrowed from Haskell.</p>
<p>If you feel some deep need to use map, then you will have to approach it like this:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list(map(lambda f,a : f(a), *zip(*itertools.product(funcs,args))))
[4, 5, 6, 8, 10, 12, 12, 15, 18]
</code></pre>
<p>Which is eminently <em>unreadable</em> and likely slower. List comprehensions win here.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use <code>map()</code>, you could do:</p>
<pre><code>&gt;&gt;&gt; [k for item in map(lambda x: [g(x) for g in listFunc], ListArg) for k in item]
[5, 6, 7, 6, 7, 8, 7, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't quite do this with <em>just</em> <code>map</code>, but you can nest one call in another, and use <code>sum</code> to flatten the result.</p>
<pre><code>&gt;&gt;&gt; sum(map(lambda x : map(lambda f: f(x), ListArg),listFunc), [])
[5, 6, 7, 6, 7, 8, 7, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow">itertools.product</a> helps</p>
<pre><code>def g(y): 
    def f(x):
        return x+y
    return f
funcs = map(g, [1, 2, 3])
args = [4,5,6]
p = itertools.product(funcs, args)
r = [f(arg) for f, arg in p]
</code></pre>
<hr/>
<p>The only alternative to the list comprehension I could come up with is:</p>
<pre><code>def foo(args):
    f, a = args
    return f(a)
r = list(map(foo, p)) # using p from above
</code></pre>
</div>
<span class="comment-copy">For future reference, what you want is called the "Cartesian Product". For some (non-python) discussion see <a href="http://phrogz.net/lazy-cartesian-product" rel="nofollow noreferrer">phrogz.net/lazy-cartesian-product</a></span>
<span class="comment-copy">Somehow, I kept reading into the question that the OP knew about list comprehensions, but wanted to use <code>map</code> anyway.</span>
<span class="comment-copy">Your <code>listFunc</code> and <code>ListArg</code> are swapped. Your code computes <code>g1(4), g2(4), ...</code> when <code>g1(4), g1(5), ...</code> was originally desired. :-)</span>
<span class="comment-copy">+1 because I love this answer. However, your maps are backward; the desired output is g1(4), g1(5), g1(6), g2(4), g2(5), ..., but your code executes g1(4), g2(4), g3(4), g1(5), g2(5), ...</span>
<span class="comment-copy">Ah, tricky because <code>+</code> is commutative :) Just needed to swap the two lists.</span>
<span class="comment-copy">Never mind, i somehow saw something that wasn't there. I'm going to delete my comments for clarity. You may wish to do the same.</span>
