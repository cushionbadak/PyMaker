<div class="post-text" itemprop="text">
<p>I am writing tests for some legacy code that is littered with catch-all constructs like</p>
<pre><code>try:
    do_something()
    do_something_else()

    for x in some_huge_list():
        do_more_things()

except Exception:
    pass
</code></pre>
<p>and I want to tell whether an exception was thrown inside the try block.</p>
<p>I want to avoid introducing changes into the codebase just to support a few tests and I don't want to make the <code>except</code> cases more specific for fear of unintentionally introducing regressions. </p>
<p>Is there a way of extracting information about exceptions that were raised and subsequently handled from the runtime? Or some function with a similar API to <code>eval</code>/<code>exec</code>/<code>apply</code>/<code>call</code> that either records information on every raised exception, lets the user supply an exception handler that gets run first, or lets the user register a callback that gets run on events like an exception being raised or caught.</p>
<p>If there isn't a way to detect whether an exception was thrown without getting under the (C)Python runtime in a really nasty way, what are some good strategies for testing code with catch-all exceptions inside the units you're testing?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your only realistic option is to instrument the <code>except</code> handlers.</p>
<p>Python does record exception information, which is retrievable with <a href="https://docs.python.org/3/library/sys.html#sys.exc_info" rel="nofollow noreferrer"><code>sys.exc_info()</code></a>, but this information is <em>cleared</em> when a function exits (Python 2) or the <code>try</code> statement is done (Python 3).</p>
</div>
<div class="post-text" itemprop="text">
<p>A good strategy would be testing observable behaviour. Since exceptions were explicitly excluded from the observable behaviour I do not think you should be testing whether an exception was raised or not.</p>
</div>
<span class="comment-copy">Why not just print something inside the <code>except</code> block?</span>
<span class="comment-copy">Do you care if an exception was thrown and handled inside <code>do_something()</code>?</span>
<span class="comment-copy"><code>except Exception as e: print(e)</code></span>
<span class="comment-copy">You generally can't after the fact, because <i>once a function exits</i> (Python 2) or the <code>try..except</code> block is done (Python 3) all traces of exceptions are cleared.</span>
<span class="comment-copy">One semi-solution I've been toying with is adding a whole bunch of <code>def foo_exception_hook(*args, **kwargs): pass</code> functions, calling them as <code>foo_exception_hook(e)</code> inside the exception handler, and then targeting them with <code>mock.patch</code> in the body of my test code so I can extract the exception object with the <code>call_with_args</code> method on magic mocks. I borrowed this concept from emacs. I don't like it.</span>
<span class="comment-copy">The claim that this is the only option sounds incorrect to me.  I think it would be possible by [ab]using the <a href="https://docs.python.org/3/library/sys.html#sys.settrace" rel="nofollow noreferrer">system trace function</a>.</span>
<span class="comment-copy">@wim: then by all means try to do that, but that is going to be <i>painfully</i> slow. I don't consider that a practical option.</span>
<span class="comment-copy">@wim: and does that make this answer so unhelpful as to be worthy of downvoting?</span>
<span class="comment-copy">Right, I never said that it was a good idea.  Just possible.  Coverage uses this to see which lines are visited, for example.</span>
<span class="comment-copy">@wim: sure, and coverage uses a C extension to keep that manageable (the slowdown is still easily measurable though).</span>
