<div class="post-text" itemprop="text">
<p>So, I searched for how to initialize a list in python with a number of cells.</p>
<p>I found this syntax</p>
<p><code>l = [T] * n</code></p>
<p>ok, but I got massively gotcha-ed by this and looked for the cause of the bug this was creating for over an hour. The instances of <code>T</code> are somehow linked, as if the cells had a reference to a single instance of <code>T</code>!</p>
<p>But this is only true for <em>some</em> types. See:</p>
<pre><code>l1 = [int] * 10

print l1[0]
print l1[1]

l1[0] = 12

print l1[0]
print l1[1]


l2 = [Counter()] * 10

for key, value in l2[0].items():
    print key, value

for key, value in l2[1].items():
    print key, value

l2[0]["a"] +=1

for key, value in l2[0].items():
    print key, value

for key, value in l2[1].items():
    print key, value
</code></pre>
<p>output:</p>
<pre><code>&lt;type 'int'&gt;
&lt;type 'int'&gt;
12
&lt;type 'int'&gt;
a 1
a 1
</code></pre>
<p>As a side question: Why is this so inconsistent and why does the duplicate design exist the first place?</p>
<p>So, how can I do the initialization with a number of <code>T</code>s without this weird duplicate behavior?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a list comprehension:</p>
<pre><code>l = [f() for _ in range(n)]
</code></pre>
<p>It's a common gotcha with mutable types:</p>
<pre><code>&gt;&gt;&gt; l = [[]] * 2
&gt;&gt;&gt; l[0].append(4)
&gt;&gt;&gt; l
[[4], [4]]

&gt;&gt;&gt; l = [5] * 2
&gt;&gt;&gt; l[0] += 1
&gt;&gt;&gt; l
[6, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the first case, you put the abstraction of the type <strong>int</strong> into each list element.  Then you changed <em>one</em> of those locations.</p>
<p>In the second case, you put a reference to a Counter into each list element.  Then you changed the Counter, not an individual list element.  You didn't touch any of the references, merely the object to which they point.</p>
<p>In the second case, try doing the <em>same</em> thing you did in the first:</p>
<pre><code>l2 = [Counter()] * 10

for key, value in l2[0].items():
    print key, value

for key, value in l2[1].items():
    print key, value

l2[0] = 12
</code></pre>
<p>Does this un-confuse you?</p>
</div>
<span class="comment-copy">thanks, what is the design idea behind this behavior though?</span>
<span class="comment-copy">@lotolmencre mutable types don't need to copied when passed around, just a reference to them is enough, and they can be modified too. (It's a little more complicated than that, but you can read more about that <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">here</a>).</span>
