<div class="post-text" itemprop="text">
<p>I have been trying to figure out a way to yield an int value from a generator but the scripting engine is throwing errors at me.</p>
<pre><code>def inorderTraversal(self, node):
        if(node.left):
            for n in self.inorderTraversal(node.left):
                yield n[0]
        yield node.data[0]
        if(node.right):
            for n in self.inorderTraversal(node.right):
                yield n[0] 
</code></pre>
<p>The error is: </p>
<blockquote>
<p>File "ac.py", line 142, in inorderTraversal<br/>
      yield n[0] TypeError: 'int' object is not subscriptable</p>
</blockquote>
<p>where </p>
<p><code>n = {10,"X"}</code>. I tried to search it but no solution I know of caters to my needs.</p>
</div>
<div class="post-text" itemprop="text">
<p>if your <code>yield node.data[0]</code> is correct, then when you do <code>yield n[0]</code> in the recursive case is like you are doing <code>yield node.data[0][0]</code> in that branch. So change it to <code>yield n</code> instead because the recursive case already give you what you need, you only need to pass it along. </p>
<p>Furthermore, when designing a tree you usually do it in a way that <code>.data</code> store, well, the data that the user of your tree want to store in it and don't worry about what that is or how it looks, so you usually do <code>yield node.data</code>. </p>
<p>Also as you are in python 3, you can use the <a href="https://docs.python.org/3/reference/expressions.html#yieldexpr" rel="nofollow noreferrer"><code>yield from</code></a> that is a shortcut for that kind of for-loop.</p>
<p>with those in mind your code should look like this </p>
<pre><code>def inorderTraversal(self, node):
    if node.left:
        yield from self.inorderTraversal(node.left)
    yield node.data
    if node.right:
        yield from self.inorderTraversal(node.right)
</code></pre>
<hr/>
<p>as you have not provided with a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> of your problem I can only guess, so</p>
<p>Lets see a example tree code like this</p>
<pre><code>class Node:
    def __init__(self, data, left=None, right=None):
        self.data  = data
        self.left  = left
        self.right = right
</code></pre>
<p>with that lets build a sample tree like the one in <a href="https://en.wikipedia.org/wiki/Tree_traversal" rel="nofollow noreferrer">wikipedia</a></p>
<p><a href="https://en.wikipedia.org/wiki/Tree_traversal" rel="nofollow noreferrer"><img alt="sample tree" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Sorted_binary_tree_inorder.svg/336px-Sorted_binary_tree_inorder.svg.png"/></a></p>
<pre><code>test1 = Node(6,
             Node(2,
                  Node(1),
                  Node(4,
                       Node(3),
                       Node(5)
                       )
                  ),
             Node(7,
                  None,
                  Node(9,
                       Node(8)
                       )
                  )
             )
</code></pre>
<p>lets do it again with your data structure of [int,str] </p>
<pre><code>test2 = Node([6,"F"],
            Node([2,"B"],
                 Node([1,"A"]),
                 Node([4,"D"],
                      Node([3,"C"]),
                      Node([5,"E"])
                      )
                 ),
            Node([7,"G"],
                 None,
                 Node([9,"I"],
                      Node([8,"H"])
                      )
                 )
            )
</code></pre>
<p>now the fun part, the inorder function, first yours</p>
<pre><code>def inorderBad(node):
    if node.left:
        for n in inorderBad(node.left):
            yield n[0]
    yield node.data[0]
    if node.right:
        for n in inorderBad(node.right):
            yield n[0]
</code></pre>
<p>lets test it with <code>test2</code></p>
<pre><code>&gt;&gt;&gt; list(inorderBad(test2))
Traceback (most recent call last):
  File "&lt;pyshell#0&gt;", line 1, in &lt;module&gt;
    list(inorderBad(test2))
  File "C:\Users\David\Documents\Python Scripts\stackoverflow_test.py", line 26, in inorderBad
    for n in inorderBad(node.left):
  File "C:\Users\David\Documents\Python Scripts\stackoverflow_test.py", line 27, in inorderBad
    yield n[0]
TypeError: 'int' object is not subscriptable
&gt;&gt;&gt; 
</code></pre>
<p>look familiar? the error as I said is the recursive case of <code>n[0]</code> when you reach the bottom Node (A in this case) it yield data[0] (1 in this case), in the Node above (B) it get this value and try to yield it again only this time try to yield the first value of it and fail in that regard as the error said</p>
<p>Now lets fix it</p>
<pre><code>def inorder2(node):
    if node.left:
        for n in inorder2(node.left):
            yield n
    yield node.data[0]
    if node.right:
        for n in inorder2(node.right):
            yield n         
</code></pre>
<p>and test it </p>
<pre><code>&gt;&gt;&gt; list(inorder2(test2))
[1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; 
</code></pre>
<p>work as expected, lets try with the other one </p>
<pre><code>&gt;&gt;&gt; list(inorder2(test1))
Traceback (most recent call last):
  File "&lt;pyshell#6&gt;", line 1, in &lt;module&gt;
    list(inorder2(test1))
  File "C:\Users\David\Documents\Python Scripts\stackoverflow_test.py", line 35, in inorder2
    for n in inorder2(node.left):
  File "C:\Users\David\Documents\Python Scripts\stackoverflow_test.py", line 35, in inorder2
    for n in inorder2(node.left):
  File "C:\Users\David\Documents\Python Scripts\stackoverflow_test.py", line 37, in inorder2
    yield node.data[0]
TypeError: 'int' object is not subscriptable
&gt;&gt;&gt; 
</code></pre>
<p>naturally it fail because inorder2 is not general enough, also in your current implementation, what if you want the string instead? have you think on that?, in general those concern should not be of relevance to this particular function, it should only provide all the data <em>inorder</em> </p>
<p>so the general inorder and adding the <code>yield from</code> is</p>
<pre><code>def inorder(node):
    if node.left:
        yield from inorder(node.left)
    yield node.data
    if node.right:
        yield from inorder(node.right)
</code></pre>
<p>test</p>
<pre><code>&gt;&gt;&gt; list(inorder(test2))
[[1, 'A'], [2, 'B'], [3, 'C'], [4, 'D'], [5, 'E'], [6, 'F'], [7, 'G'], [8, 'H'], [9, 'I']]
&gt;&gt;&gt; list(inorder(test1))
[1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to replace <code>yield n[0]</code> with <code>yield n</code>. You are already yielding the (integer) value of the node, so no need to index it further.</p>
<p><strong>Edit</strong>: Explanation added.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>n = {10,"X"}

print(n[0]) 
</code></pre>
<p>Yields</p>
<pre><code>TypeError: 'set' object does not support indexing
</code></pre>
<p>Not the exact error, but I'm testing this on an Android IDE, so that doesn't entirely surprise me. </p>
<p>The answer then is that you're trying to subscript a set, but what does that mean? Sets are unordered, so there is no "0th" element of the set. If you want random access, you'll need to switch to a list. </p>
<p>Or, if you're looking for just a simple temporary container, tuples are indexable. </p>
<p>If <code>n</code> is node data, you could so just create a <code>Node</code> class then access the field directly instead of indexing. </p>
</div>
<span class="comment-copy">Do you want to return the nodes or their values? It looks like <code>yield node.data[0]</code> is returning a value, while the two for-loops access the return value as if it's a node instead of a value.</span>
<span class="comment-copy">Are you 100% sure that's what <code>n</code> is equal? Or are you guessing? Put a print line in to be sure.</span>
<span class="comment-copy">Are you sure of your type <code>n</code>, it's saying its just an <code>int</code> (probably from the recursive yield) and you have described a <code>set</code>, which isn't subscriptable. You are mixing recursing with generators, if you really want to do that then take a look at <code>yield from ...</code> you can replace <code>for n in self.inorderTraversal(node.left): yield n</code> with <code>yield from self.inorderTraversal(node.left)</code></span>
<span class="comment-copy">You may want to read <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a> and <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">I need only the integer keys from the nodes. The data stored at each node is currently in form [<b>int</b>,"string"].  I doubt how <code>yield n[0]</code> would become recursive as I am also printing <code>n[0]</code> just before yield statement and the print output is exactly what I need.  I also swapped <code>yield from</code> in place of <code>yield</code> but nothing changed.</span>
<span class="comment-copy">@Akt  I made a update, compare those with your code I try to find the difference, if you are still stuck, then update your question with the change you try that still don't work, or put an actual working code and the an example so we can test it...</span>
<span class="comment-copy">Yes, I emulated this solution and the function is now running without any error. Now I get it, because of recursion <code>yield n.data[0]</code> was trying to subscript the int at data[0]. Thank u for your time</span>
<span class="comment-copy">While I understand you don't have the reputation to comment, this isn't an answer.</span>
<span class="comment-copy">@Carcigenicate it <i>is</i> an answer, just not of the most helpful kind :-).</span>
<span class="comment-copy">@JimFasarakis-Hilliard He's telling the OP to try something, not telling them definitely what the problem is. I guess by some vast stretch it could be considered one, but only very thinly.</span>
<span class="comment-copy">@Carcigenicate yup it is considered one, albeit, a bad one. That's why I down voted.</span>
<span class="comment-copy">@Carcigenicate I have no way of testing the correctness of my answer without the full code, so my initial answer was a suggestion. I edited it to be more affirmative and explained of what I think the problem is.</span>
<span class="comment-copy">I also tried using n = [10, 'X'] and then printed <b>n[0]</b>, the print statement works as expected. Its only the <code>yield n[0]</code> that fails.</span>
