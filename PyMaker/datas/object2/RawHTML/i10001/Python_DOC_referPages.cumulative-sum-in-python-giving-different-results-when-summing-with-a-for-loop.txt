<div class="post-text" itemprop="text">
<p>Ok let's try this again.  I have 1 set of data.  I want to make 2 copies, and then sort the copies in descending order based on different columns.  Then I want to get the cumulative sum of the respective columns.  When I run the following code I get different results for the two instances I call on print (setA[x][2]).</p>
<pre><code>set = [[2,2,0],[1,3,0],[3,1,0]]

def getkey_setA (item):
    return item[0]
setA = sorted(set, key=getkey_setA, reverse=True)

def getkey_setB (item):
    return item[1]
setB = sorted(set, key=getkey_setB, reverse=True)

setA[0][2] = setA[0][0]
setB[0][2] = setB[0][1]

for x in range(1, 3):
    setA[x][2] = setA[x-1][2] + setA[x][0]
    print(setA[x][2])

for x in range(1, 3):
    setB[x][2] = setB[x-1][2] + setB[x][1]

for x in range(1, 3):
    print (setA[x][2])
</code></pre>
<p>This produces:</p>
<pre><code>5
6
8
6
</code></pre>
<p>but I expected it to produce</p>
<pre><code>5
6
5
6
</code></pre>
<p>instead.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>sorted()</code> creates a <em>shallow</em> copy of the sequence being sorted. This means that your <em>nested</em> lists are not copied, they are merely referenced:</p>
<pre><code>&gt;&gt;&gt; set = [[2,2,0],[1,3,0],[3,1,0]]
&gt;&gt;&gt; setA = sorted(set, key=getkey_setA, reverse=True)
&gt;&gt;&gt; setB = sorted(set, key=getkey_setB, reverse=True)
&gt;&gt;&gt; setA[0] is set[2]
True
&gt;&gt;&gt; setB[2] is set[2]
True
&gt;&gt;&gt; setA[0] is setB[2]
True
</code></pre>
<p>So the last element in <code>set</code> is <em>exactly the same object</em> as <code>setA[0]</code> and <code>setB[2]</code>. Making changes to any one of those references is reflected in the others:</p>
<pre><code>&gt;&gt;&gt; setA[0][2]
0
&gt;&gt;&gt; setA[0][2] = 42
&gt;&gt;&gt; setB[2]
[3, 1, 42]
&gt;&gt;&gt; set[2]
[3, 1, 42]
</code></pre>
<p>This is why the <code>set</code> object (from which you produced your sorted <code>setA</code> and <code>setB</code> lists) is <em>also</em> changed after running your code:</p>
<pre><code>&gt;&gt;&gt; set
[[2, 2, 8], [1, 3, 6], [3, 1, 9]]
</code></pre>
<p>You need to create a proper copy of the nested lists; you could use the <a href="https://docs.python.org/2/library/copy.html#copy.deepcopy" rel="nofollow noreferrer"><code>copy.deepcopy()</code> function</a> to create a recursive copy of the list objects, or you could use a generator expression when sorting:</p>
<pre><code>setA = sorted((subl[:] for subl in set), key=getkey_setA, reverse=True)
setB = sorted((subl[:] for subl in set), key=getkey_setB, reverse=True)
</code></pre>
<p>This shallowly copies the nested lists; this is fine because those nested lists only contain immutable objects themselves.</p>
</div>
<span class="comment-copy">It <i>sounds</i> as if you have <i>shared references</i> to lists (perhaps you <a href="http://stackoverflow.com/questions/2612802/how-to-clone-or-copy-a-list">didn't copy your lists</a>)? Without an <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> we can't help, however.</span>
<span class="comment-copy">Gotcha.  Please see above edited example.</span>
<span class="comment-copy">And what is the output that produces, and what was the expected output?</span>
<span class="comment-copy">It produces: 5 6 8 6.  I expected 5 6 5 6.</span>
<span class="comment-copy">Ok thank you, I get it.  Could I also 1) sort the data for setA, 2) record my results in the output file, 3) sort the data for set B, 4) record my results in the output file.  This way I avoid having multiple copies of set, which in my real life problem has millions of entries.</span>
<span class="comment-copy">@Jellybeard: Perhaps you want to use <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate()</code></a> to produce the accumulated data instead? That'd avoid using the 3rd element as a variable and lets you keep sharing the ordering. Or better yet, use the <code>pandas</code> project to do the sorting and accumulation for you, it is likely far more efficient at this task.</span>
