<div class="post-text" itemprop="text">
<p>I have the following class definition:</p>
<pre><code>class Codes():
    def __new__(self, inp):
        self.data = np.zeros((50,50))
        self.capacity = 50
        self.size = 6
        self.data[:self.size,:self.size] = inp
        self.x = 0
        self.y = 0

        return self

    def __setitem__(self,coords,value):
        x = coords[0]
        y = coords[1]
        if max(x,y) &gt;= self.capacity:
            self.capacity *= 2
            newdata = np.zeroes((self.capacity,))
            newdata[:self.size,:self.size] = self.data
            self.data = newdata

        self.data.__setitem__(coords,value)

        if max(x,y) &gt;= self.size:
            print("expanding")
            self.size = max(x,y)
        print ("Debug")
    def __getitem__(self,coords):
        x = coords[0]
        y = coords[1]
        return self.data[x,y]
</code></pre>
<p>The get and set methods don't seem to be being called. I'm initialising with:</p>
<pre><code>inp = np.array([[20151125,18749137,1728984,30943339,10071777,33511524],
               [31916031,21629792,16929656,7726640,15514188,4041754],
               [16080970,8057251,1601130,7981243,11661866,16474243],
               [24592653,32451966,21345942,9380097,10600672,31527494],
               [77061,17552253,28094349,6899651,9250759,31663883],
               [33071741,6796745,25397450,24659492,1534922,27995004]])
a = Codes(inp)
</code></pre>
<p>If I try to then execute <code>print(a[1,1])</code>, I get the error:</p>
<pre><code>Traceback (most recent call last):
  File "C:/Users/cotont/Dropbox/Advent of Code/Advent of Code 25-1.py", line 55, in &lt;module&gt;
    print(a[1,1])
TypeError: 'type' object is not subscriptable
</code></pre>
<p>If I try to execute <code>a[49,49] = 1</code>, I get:</p>
<pre><code>Traceback (most recent call last):
  File "C:/Users/cotont/Dropbox/Advent of Code/Advent of Code 25-1.py", line 55, in &lt;module&gt;
    a[49,49] = 1
TypeError: 'type' object does not support item assignment
</code></pre>
<p>Why are my custom methods not being called, and how do I fix it?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are misunderstanding what <code>__new__</code> does or accidentally used it where you should have used <code>__init__</code>. You are returning the <code>Codes</code> object <em>itself</em> by returning <code>self</code>:</p>
<pre><code>def __new__(self, inp):
    # ...
    return self
</code></pre>
<p><code>__new__</code> is called as a static method on the class and is expected to produce a new instance <em>in the method</em>.</p>
<p>Because you returned the type object (the class), <code>__getitem__</code> and <code>__setitem__</code> are looked up on <code>type</code> (the default metaclass) (see <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow"><em>Special method lookup</em></a>), which fails.</p>
<p>You probably wanted to use <code>__init__</code> there instead; <code>__init__</code> is called on an already-created instance:</p>
<pre><code>class Codes():
    def __init__(self, inp):
        self.data = np.zeros((50,50))
        self.capacity = 50
        self.size = 6
        self.data[:self.size,:self.size] = inp
        self.x = 0
        self.y = 0
</code></pre>
<p><code>__init__</code> doesn't need to return anything (and what it returns is ignored anyway), so you can drop the <code>return self</code> line altogether.</p>
<p>If you feel you <em>must</em> use <code>__new__</code> (perhaps because you are subclassing an immutable type), then at the very least create an instance with <code>super().__new__()</code>:</p>
<pre><code>class Codes():
    def __new__(cls, inp):
        instance = super(Codes, cls).__new__(cls)
        instance.data = np.zeros((50,50))
        instance.capacity = 50
        instance.size = 6
        instance.data[:self.instance,:instance.size] = inp
        instance.x = 0
        instance.y = 0
        return instance
</code></pre>
<p>but using <code>__init__</code> instead is just simpler.</p>
</div>
<div class="post-text" itemprop="text">
<p>Add</p>
<pre><code>import numpy as np
</code></pre>
<p>Rename </p>
<pre><code>__new__(self, inp):
    ....
</code></pre>
<p>to</p>
<pre><code>__init__(self, inp):
    ....
</code></pre>
<p>and remove line</p>
<pre><code>return self
</code></pre>
</div>
<span class="comment-copy">Is that not what I'm supposed to do? The <code>Codes</code> object is the thing that has those custom get and set methods</span>
<span class="comment-copy">@TamCoton: you want to return an instance, not the type itself. Because your class is not immutable, you don't need to control how an empty instance is created, you just want to initialise a new instance. Use <code>__init__</code>.</span>
<span class="comment-copy">Ah, that worked perfectly. Thanks!  The use of <code>__new__</code> was because I started out subclassing <code>np.ndarray</code>, before realising I didn't need to.</span>
