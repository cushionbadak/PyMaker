<div class="post-text" itemprop="text">
<p>I am trying to build a program which allows the user to browse to a folder which contains python modules. Once the folder has been selected it will list all python files within that folder as well as all the classes and methods for each module. My question is, are there any way I can do this without opening each file and parsing for "def" or "class"? I noticed that there's a function called mro which returns the attribute of a class but that requires me to have access to that class through an import. So is there any way I can get the same result? Thank you in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what I came up with using the AST module, it has exactly what I was looking for.</p>
<pre><code>def fillClassList(file):
    classList = []
    className = None
    mehotdName = None
    fileName = "C:\Transcriber\Framework\ctetest\RegressionTest\GeneralTest\\" + file
    fileObject = open(fileName,"r")
    text = fileObject.read()
    p = ast.parse(text)
    node = ast.NodeVisitor()
    for node in ast.walk(p):
        if isinstance(node, ast.FunctionDef) or isinstance(node, ast.ClassDef):
            if isinstance(node, ast.ClassDef):
                className = node.name
            else:
                methodName = node.name
            if className != None and methodName != None:
                subList = (methodName , className)
                classList.append(subList)
    return classList
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Most of Python's implementation (parser included) is available in the stdlib, so by carefully reading the <a href="https://docs.python.org/2.7/library/importlib.html" rel="nofollow noreferrer">modules index</a> you should find what you need. The first modules / packages that come to mind are <a href="https://docs.python.org/2.7/library/importlib.html" rel="nofollow noreferrer">importlib</a>, <a href="https://docs.python.org/2/library/inspect.html" rel="nofollow noreferrer">inspect</a> and <a href="https://docs.python.org/2/library/ast.html" rel="nofollow noreferrer">ast</a> but there surely other modules of interest.</p>
</div>
<div class="post-text" itemprop="text">
<p>I had to replace a lot of code in one of my modules, here is my way of getting classes and methods:</p>
<pre><code>def listClass(file):

    with open(file,"r") as f:
        p = ast.parse(f.read())

    # get all classes from the given python file.
    classes = [c for c in ast.walk(p) if isinstance(c,ast.ClassDef)]

    out = dict()
    for x in classes:
        out[x.name] = [fun.name for fun in ast.walk(x) if isinstance(fun,ast.FunctionDef)]

    return out
</code></pre>
<p>Sample <a href="https://docs.python.org/3/library/pprint.html" rel="nofollow noreferrer">pprint</a> output:</p>
<pre><code>{'Alert': ['__init__',
           'fg',
           'fg',
           'bg',
           'bg',
           'paintEvent',
           'drawBG',
           'drawAlert'],
 'AlertMouse': ['__init__', 'paintEvent', 'mouseMoveEvent'],
 'AlertPopup': ['__init__', 'mousePressEvent', 'keyPressEvent', 'systemInfo']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks, useful example for this first time ast user. Code above with the  import, printed output, and without the 1 spelling error ;-)</p>
<pre><code>import ast

classList = []
className = None
methodName = None
fileName = "C:\\fullPathToAPythonFile.py"
fileObject = open(fileName ,"r")
text = fileObject.read()
p = ast.parse(text)
node = ast.NodeVisitor()
for node in ast.walk(p):
    if isinstance(node, ast.FunctionDef) or isinstance(node, ast.ClassDef):
        if isinstance(node, ast.ClassDef):
            className = node.name
        else:
            methodName = node.name
        if className != None and methodName != None:
            subList = (methodName , className)
            classList.append(subList)
            print("class: " + className + ", method: " + methodName)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to know the contents of the file, there's no way around looking into the file :)  </p>
<p>Your choice comes down to whether you want to parse out the content-of-interest yourself, or if you want to let Python load the file and then ask it about what it found. </p>
<p>For a very simple Python file like testme.py below you can do something like this (warning: not for those with weak stomachs): </p>
<p>testme.py: </p>
<pre><code>class Foo (object):
    pass

def bar():
    pass 
</code></pre>
<p>analyze.py:</p>
<pre><code>import os.path

files = ['testme.py']
for f in files: 
    print f
    modname = os.path.splitext(f)[0]
    exec('import ' + modname)
    mod = eval(modname)
    for symbol in dir(mod):
        if symbol.startswith('__'):
            continue
        print '   ', symbol, type(eval(modname + '.' + symbol))
</code></pre>
<p>Output:</p>
<pre><code>testme.py
   Foo &lt;type 'type'&gt;
   bar &lt;type 'function'&gt;
</code></pre>
<p>However, that's going to start to get pretty grotty when you expand it to deal with nested packages and modules and broken code and blah blah blah.  Might be easier just to <code>grep</code> for <code>class</code> and/or <code>def</code> and go from there.</p>
<p>Have fun with it!  I :heart: metaprogramming</p>
</div>
<span class="comment-copy">You could put <code>__init__.py</code> files in the folders and then load them as modules. See here: <a href="https://docs.python.org/2/tutorial/modules.html#packages" rel="nofollow noreferrer">docs.python.org/2/tutorial/modules.html#packages</a></span>
<span class="comment-copy">@Ted please post this code in your post (you can edit it) - in a comment it's just unreadable.</span>
<span class="comment-copy">my bad, I posted it but I needed to wait 5 minutes to change it and I sort of forgot about it :P But I already did below</span>
<span class="comment-copy">Python has better (and <b>much</b> safer) solutions than "exec" and "eval" - if you care about your system's security, that is...</span>
<span class="comment-copy">I did say it was not for those with weak stomachs :)</span>
<span class="comment-copy">You mean "it's not for those with a brain" ?</span>
<span class="comment-copy">"How do I light my birthday candles?" "Oh, that's easy, just set yourself on fire and hold your burning hand to the cake. Warning: not for those with weak stomachs." Seriously, that is not an informative warning, and when there are so much better solutions, you shouldn't be suggesting <code>exec</code> or <code>eval</code> at all.</span>
<span class="comment-copy">(<code>import</code>ing arbitrary files is also dangerous, and it deserves a warning of its own. It's not quite so trivial to replace the <code>import</code> with safer alternatives, though.)</span>
