<div class="post-text" itemprop="text">
<p>I have a list of items they <em>may or may not</em> be arbitrarily nested. I would like to replace one of the lists' elements. Either way (nested or not), I have the element's index location stored in another list. </p>
<p>Here's a nested list example where I would like to replace <code>'xyz'</code> with something else, say <code>123</code>. I have the location of <code>'xyz'</code> stored in <code>loc</code>:</p>
<pre><code>find='xyz'
replace=123
nested=[['abc',1],['xyz',2]] 
print(loc) # [1,0]
</code></pre>
<p>Using <code>loc</code> how can I substitute <code>'xyz'</code> for <code>123</code>?</p>
<p>Here is an unnested example where I would like to do the same substitution:</p>
<pre><code>unnested=['abc','xyz']
print(loc) # [1]
</code></pre>
<p>If <code>loc</code> only has one element then you can simply do:</p>
<pre><code>*nest,element=loc
if not nest: 
    unnested[element]=replace
else: pass # need help with this part
</code></pre>
<p>Is there something flexible enough to handle both cases? </p>
</div>
<div class="post-text" itemprop="text">
<p>This does the same as the other answer, just walks the path in a functional fashion:</p>
<pre><code>reduce(getitem, loc[:-1], nested)[loc[-1]] = replace
</code></pre>
<p>In Python 3 you'll need to import <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow"><code>reduce</code></a> from <code>functools</code>. And <a href="https://docs.python.org/3/library/operator.html#operator.getitem" rel="nofollow"><code>getitem</code></a> is from the <code>operator</code> module. If you just have lists, you could use <code>list.__getitem__</code> instead.</p>
<p>Explanation: <code>reduce</code> starts with <code>nested</code> and replaces it with <code>getitem(thecurrentvalue, i)</code> for each value <code>i</code> in <code>loc[:-1]</code>. So for example if <code>loc</code> is <code>[2, 4, 1, 3]</code> then you get <code>getitem(getitem(getitem(nested, 2), 4), 1)</code>. Which is the same as <code>nested[2][4][1]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>ok so given <code>loc = [0,1]</code> you would want to preform the operation:</p>
<pre><code>thing[0][1] = replace
</code></pre>
<p>or given <code>loc = [1]</code> you would preform</p>
<pre><code>thing[1] = replace
</code></pre>
<p>or if we had overly complicated data and <code>loc = [0,1,2,3,4,5,6,7]</code> you would want:</p>
<pre><code>thing[0][1][2][3][4][5][6][7] = replace
</code></pre>
<p>In any case we first need to look up each layer before the last element which we can do in a for loop like this:</p>
<pre><code>*nest,element=[0,1,2,3,4,5,6,7]
layer = thing #start with the original object
for i in nest:
    layer = layer[i] #get an element from this layer
#now layer == thing[0][1][2][3][4][5][6]
layer[element] = replace
</code></pre>
<p>This also works when there is only one item in <code>loc</code> since in that case the for loop is iterating over an empty sequence so there is no need to treat that case seperately</p>
</div>
<div class="post-text" itemprop="text">
<p>if you just have lists that has tuple or single element, we can  first detect if a list has tuples and apply lambda function to replace elements as desired.</p>
<p>If the list has different types of tuples, we will need to add additional logic to recognize that.</p>
<pre><code>find='xyz'
replace=123
mylist1=[('abc',1),('xyz',2)] # nests could be tuples or lists
mylist2=['abc','xyz']
replace_this = '123'

for mylist in mylist1,mylist2:

    for x in mylist:
        if (x[0],x[1]) in mylist:            
            modified = map(lambda (x, y): (x,y) if x!=find else  (replace_this,y) ,mylist)
            break
        else:            
            modified = map(lambda x: x if x!=find else  replace_this ,mylist)
            break

    print "modified list=", modified
</code></pre>
<p><strong>output:</strong> </p>
<pre><code>Python 2.7.9 (default, Dec 10 2014, 12:24:55) [MSC v.1500 32 bit (Intel)] on win32
Type "copyright", "credits" or "license()" for more information.
&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt; 
modified list= [('abc', 1), ('123', 2)]
modified list= ['abc', '123']
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">that isn't a nested list, it is a list of tuples.  Tuples are immutable so you can't just replace the element directly in the first case.</span>
<span class="comment-copy">You're right this is a list of tuples, I was trying to show a simple structure to convey the issue. Showing more nests would only add to the length of <code>loc</code>. I will edit this to make it a list of lists.</span>
<span class="comment-copy">this only works if every level is a list, if some layers have tuples / other constructs this won't work.  Probably not an issue but the question was originally posted using tuples so might be relevant for OP's use case.</span>
<span class="comment-copy">@TadhgMcDonald-Jensen Well I'm answering the question as it is. And the title did say just "list" already before the edit. Yours wouldn't work for that original, either, like you said it's even somewhat impossible. Anyway, I added a more general version and it looks nicer. Thanks :-)</span>
<span class="comment-copy">@StefanPochmann do you mind adding some explanation for how this works?</span>
<span class="comment-copy">@LMc Hmm, I thought I did, saying it does the same as the other answer. Is it still unclear after reading <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>reduce</code>'s documentation</a>?</span>
<span class="comment-copy">@LMc Oh well, I added some more.</span>
<span class="comment-copy">A note: The OP hasn't specified the Python version (the <code>print</code> having only one argument would be equivalent on both, not to mention <code>__future__</code> can make it a function on Py2). <code>*nest,element=[0,1,2,3,4,5,6,7]</code> is only legal in Py3, not Py2. On Py2, with a source list named <code>foo</code>, you could do either: <code>nest = foo[:]</code>, <code>element = nest.pop()</code> or <code>nest, element = foo[:-1], foo[-1]</code>.</span>
<span class="comment-copy">Since the op used that notation in their question I assumed it is valid in the version of python they are using ;)</span>
<span class="comment-copy">Oops. Missed that. Carry on sir! :-)</span>
