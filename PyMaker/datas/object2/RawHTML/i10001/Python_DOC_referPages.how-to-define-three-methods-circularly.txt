<div class="post-text" itemprop="text">
<p>I have an abstract class with three methods that are is a sense equivalent - they could all be defined in terms of each other using some expensive conversion functions. I want to be able to write a derived class which would only need to override one of the methods and automatically get the other two. Example</p>
<pre><code>class FooBarBaz(object):
    def foo(self, x):
        return foo_from_bar(self.bar(x))
        # OR return foo_from_baz(self.baz(x))

    def bar(self, x):
        return bar_from_foo(self.foo(x))
        # OR return bar_from_baz(self.baz(x))

    def baz(self, x):
        return baz_from_bar(self.bar(x))
        # OR return baz_from_foo(self.foo(x))

class Derived1(FooBarBaz):
    def bar(self, x):
        return 5
        # at this point foo = foo_from_bar(5) and
        # baz = baz_from_bar(5), which is what I wanted

class Derived2(FooBarBaz):
    def foo(self, x):
        return 6
        # at this point bar = bar_from_foo(6) and
        # baz = baz_from_bar(bar_from_foo(6)),
        # which is not ideal, but still works

class Derived3(FooBarBaz):
    def baz(self, x):
        return 7
        # at this point foo and bar remain defined
        # in terms of each other, which is a PROBLEM
</code></pre>
<p>I know I could explicitly tell each derived class which conversions to use. I want to know if there is a way for the parent class to figure this out on its own, without modifying the children.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could resort to metaprogramming techniques like writing a metaclass that fills in the remaining methods automatically, or use introspection to look at the classes in <code>type(self).mro()</code> in turn to find out which methods have been overridden.  However, these options firmly fall into the "too much magic" category for me, so I'd go with something simpler.</p>
<p>Simply split each method up into two:  One generic one, and the actual implementation.  Derived classes override the actual implementation:</p>
<pre><code>class FooBarBaz(object):

    def foo_impl(self, x):
        raise NotImplementedError

    def foo(self, x):
        try:
            return self.foo_impl(x)
        except NotImplementedError:
            try:
                return foo_from_bar(self.bar_impl(x))
            except NotImplementedError:
                return foo_from_baz(self.baz_impl(x))

    # Similarly fo bar and baz

class Dervied(FooBarBaz):

    def bar_impl(self, x):
        return 5
</code></pre>
<p>The common logic can also be factored out in a decorator:</p>
<pre><code>def first_implemented(func):
    @functools.wraps
    def wrapper(*args, **kwargs):
        for f in func(*args, **kwargs):
            try:
                return f()
            except NotImplementedError:
                pass
        raise NotImplementedError
    return wrapper

class FooBarBaz(object):

    def foo_impl(self, x):
        raise NotImplementedError

    @first_implemented
    def foo(self, x):
        yield lambda: self.foo_impl(x)
        yield lambda: foo_from_bar(self.bar_impl(x))
        yield lambda: foo_from_baz(self.baz_impl(x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suggest to define the conversions in a clean circle, such that redefining one method will break that circle. That is:</p>
<pre><code>class FooBarBaz(object):
    def foo(self, x):
        return foo_from_baz(self.baz(x))

    def bar(self, x):
        return bar_from_foo(self.foo(x))

    def baz(self, x):
        return baz_from_bar(self.bar(x))
</code></pre>
<p><strong>Edited simultaneously with comment on the same issue being raised:</strong>
That should work, but of course, sometimes you'll need to convert twice. To avoid that, you could implement some kind of lazy evaluation, i.e. the functions first generate an object that knows how to evaluate itself, but first when you ask it for its value, the operation is performed. That way, the chain of conversion can be simplified before evaluation, if it is expensive.</p>
</div>
<div class="post-text" itemprop="text">
<p>A decorator could also do the trick. Something along these lines:</p>
<pre><code>def define_missing(cls):
    has_at_least_one = False
    if hasattr(cls, 'foo'):
        if not hasattr(cls, 'bar'):
            cls.bar = lambda self, x: bar_from_foo(self.foo(x))
        if not hasattr(cls, 'baz'):
            cls.baz = lambda self, x: baz_from_foo(self.foo(x))
        has_at_least_one = True
    if hasattr(cls, 'bar'):
        if not hasattr(cls, 'foo'):
            cls.foo = lambda self, x: foo_from_bar(self.bar(x))
        if not hasattr(cls, 'baz'):
            cls.baz = lambda self, x: baz_from_bar(self.bar(x))
        has_at_least_one = True
    if hasattr(cls, 'baz'):
        if not hasattr(cls, 'bar'):
            cls.foo = lambda self, x: foo_from_baz(self.baz(x))
        if not hasattr(cls, 'baz'):
            cls.bar = lambda self, x: bar_from_baz(self.baz(x))
        has_at_least_one = True
    if not has_at_least_one:
        raise TypeError("Class needs to implement at least one of the methods foo, bar, and baz.")
    return cls
</code></pre>
<p>Then use it like so:</p>
<pre><code>@define_missing
class Derived1(FooBarBaz):
    def bar(self, x):
        return 5
</code></pre>
<p>This is inspired by the <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow noreferrer"><code>functools.total_ordering</code></a> decorator.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am actually duplicating <a href="https://stackoverflow.com/a/40419393/6394138">Dr. V's answer</a>. I am posting my answer to justify the effort that I spent writing the code:</p>
<pre><code>#!/usr/bin/env python
def foo_from_bar(x):
    return 'foo_from_bar(%s)' % x

def bar_from_baz(x):
    return 'bar_from_baz(%s)' % x

def baz_from_foo(x):
    return 'baz_from_foo(%s)' % x

class FooBarBaz(object):
    def foo(self, x):
        return foo_from_bar(self.bar(x))

    def bar(self, x):
        return bar_from_baz(self.baz(x))

    def baz(self, x):
        return baz_from_foo(self.foo(x))

class Derived1(FooBarBaz):
    def bar(self, x):
        return 5

class Derived2(FooBarBaz):
    def foo(self, x):
        return 6

class Derived3(FooBarBaz):
    def baz(self, x):
        return 7

d1 = Derived1()
d2 = Derived2()
d3 = Derived3()

def check(expr):
    print expr, '-&gt;', eval(expr)

for i,d in enumerate([d1, d2, d3]):
    print '--- d = Derived%d() ----' % (i+1)
    check('d.foo(0)')
    check('d.bar(0)')
    check('d.baz(0)')
</code></pre>
<p>Output:</p>
<pre><code>--- d = Derived1() ----
d.foo(0) -&gt; foo_from_bar(5)
d.bar(0) -&gt; 5
d.baz(0) -&gt; baz_from_foo(foo_from_bar(5))
--- d = Derived2() ----
d.foo(0) -&gt; 6
d.bar(0) -&gt; bar_from_baz(baz_from_foo(6))
d.baz(0) -&gt; baz_from_foo(6)
--- d = Derived3() ----
d.foo(0) -&gt; foo_from_bar(bar_from_baz(7))
d.bar(0) -&gt; bar_from_baz(7)
d.baz(0) -&gt; 7
</code></pre>
</div>
<span class="comment-copy">As you see in the answers below, the decision on which approach to use is based on how expensive the conversions are, and also whether you really have only three alternatives or maybe 20. The latter in combination with avoiding multiple conversions when necessary would yield a nice exercise :-D.</span>
<span class="comment-copy">I went for a slightly more magical solution (who doesn't like magic?), but your idea is clever.</span>
<span class="comment-copy">@KarolisJuodelÄ— Magic tends to bite you (or someone else) when trying to extend or refactor the code in the future.  Mark my words.</span>
<span class="comment-copy">I expanded on how to implement the decorator I mentioned.</span>
<span class="comment-copy">The OP stated that the conversion functions are expensive, so this solution isn't optimal since it requires two conversion functions where one would be enough.</span>
<span class="comment-copy">This is a bit inconsistent and doesn't work as written.  You are using <code>foo_from_bar</code> as a function converting a method to a different method.  That's neither how the OP introduced <code>foo_from_bar</code>, nor what the <code>total_ordering</code> decorator does.  Your assignments should be <code>cls.foo = lambda self, x: foo_from_bar(self.bar(x))</code> instead to make this approach work.</span>
<span class="comment-copy">@Sven: True. My intention was to provide a hint of how such an implementation could be done, but I should have mentioned that those functions needed to be redefined. I have edited the answer to use <code>foo_from_bar</code> etc. the way you suggested. It should now be consistent with how OP used them.</span>
