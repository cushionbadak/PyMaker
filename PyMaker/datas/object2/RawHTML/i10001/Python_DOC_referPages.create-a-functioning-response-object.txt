<div class="post-text" itemprop="text">
<p>For testing purposes I'm trying to create a Response() object in python but it proves harder then it sounds.</p>
<p>i tried this:</p>
<pre><code>from requests.models import Response

the_response = Response()
the_response.code = "expired"
the_response.error_type = "expired"
the_response.status_code = 400
</code></pre>
<p>but when I attempted <code>the_response.json()</code> i got an error because the function tries to get <code>len(self.content)</code> and <code>a.content</code> is null.
So I set <code>a._content = "{}"</code> but then I get an encoding error, so I have to change <code>a.encoding</code>, but then it fails to decode the content....
this goes on and on. Is there a simple way to create a Response object that's functional and has an arbitrary status_code and content?</p>
</div>
<div class="post-text" itemprop="text">
<p>That because the <code>_content</code> attribute  on the <code>Response</code> objects (on python3) has to be bytes and not unicodes.</p>
<p>Here is how to do it:</p>
<pre><code>from requests.models import Response

the_response = Response()
the_response.code = "expired"
the_response.error_type = "expired"
the_response.status_code = 400
the_response._content = b'{ "key" : "a" }'

print(the_response.json())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Create a <a href="https://docs.python.org/3/library/unittest.mock.html" rel="noreferrer"><code>mock</code></a> object, rather than trying to build a real one:</p>
<pre><code>from unittest.mock import Mock

from requests.models import Response

the_response = Mock(spec=Response)

the_response.json.return_value = {}
the_response.status_code = 400
</code></pre>
<p>Providing a <code>spec</code> ensures that the mock will complain if you try to access methods and attributes a real <code>Response</code> doesn't have.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use the <a href="https://github.com/getsentry/responses" rel="nofollow noreferrer"><code>responses</code></a> library to do it for you:</p>
<pre><code>import responses

@responses.activate
def test_my_api():
    responses.add(responses.GET, 'http://whatever.org',
                  json={}, status=400)

    ...
</code></pre>
<p>This has the advantage that it intercepts a real request, rather than having to inject a response somewhere.</p>
</div>
<span class="comment-copy">Have you considered using something like <a href="https://github.com/getsentry/responses" rel="nofollow noreferrer"><code>responses</code></a>? Alternatively, create a <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>mock</code></a> rather than trying to recreate the real object</span>
<span class="comment-copy">This will work, but breaks if <code>requests</code> changes the implementation of <code>Response</code>; the leading underscore indicates an internal detail that shouldn't be relied upon. That said, it hasn't changed for a while (and such a change may also affect how <code>responses</code> does its thing, unless it mocks the public interface too).</span>
<span class="comment-copy">100% agreed, but as for OP question - this is the right solution. Also upvoted your mock solution(much better than 3th party lib), but again the OP asked for specific use case and wanted to know why his code is not working.</span>
