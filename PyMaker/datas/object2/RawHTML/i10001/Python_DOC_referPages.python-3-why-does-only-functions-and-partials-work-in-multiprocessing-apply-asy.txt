<div class="post-text" itemprop="text">
<p>I was trying to use use some closures in my multiprocessing code and it kept failing for no reason. So I did a little test:</p>
<pre><code>#!/usr/bin/env python3

import functools
from multiprocessing import Pool 

def processing_function(unprocessed_data):
    return unprocessed_data

def callback_function(processed_data):
    print("FUNCTION: " + str(processed_data))

def create_processing_closure(initial_data):
    def processing_function(unprocessed_data):
        return initial_data + unprocessed_data
    return processing_function

def create_callback_closure():
    def callback(processed_data):
        print("CLOSURE: " + str(processed_data))
    return callback

def create_processing_lambda(initial_data):
    return lambda unprocessed_data: initial_data + unprocessed_data

def create_callback_lambda():
    return lambda processed_data: print("LAMBDA: " + str(processed_data))

def processing_partial(unprocessed_data1, unprocessed_data2):
    return (unprocessed_data1 + unprocessed_data2)

def callback_partial(initial_data, processed_data):
    print("PARTIAL: " + str(processed_data))

pool = Pool(processes=1)

print("Testing if they work normally...")

f1 = processing_function
f2 = callback_function

f2(f1(1))

f3 = create_processing_closure(1)
f4 = create_callback_closure()

f4(f3(1))

f5 = create_processing_lambda(1)
f6 = create_callback_lambda()

f6(f5(1))

f7 = functools.partial(processing_partial, 1)
f8 = functools.partial(callback_partial, 1)

f8(f7(1))

# bonus round!
x = 1
f9 = lambda unprocessed_data: unprocessed_data + x
f10 = lambda processed_data: print("GLOBAL LAMBDA: " + str(processed_data))

f10(f9(1))

print("Testing if they work in apply_async...")

# works
pool.apply_async(f1, args=(1,), callback=f2)
# doesn't work
pool.apply_async(f3, args=(1,), callback=f4)
# doesn't work
pool.apply_async(f5, args=(1,), callback=f6)
# works
pool.apply_async(f7, args=(1,), callback=f8)
# doesn't work
pool.apply_async(f9, args=(1,), callback=f10)

pool.close()
pool.join()
</code></pre>
<p>The results are:</p>
<pre><code>&gt; ./apply_async.py
Testing if they work normally...
FUNCTION: 1
CLOSURE: 2
LAMBDA: 2
PARTIAL: 2
GLOBAL LAMBDA: 2
Testing if they work in apply_async...
FUNCTION: 1
PARTIAL: 2
</code></pre>
<p>Can anyone explain this weird behavior?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because those objects can't be transferred to another process; pickling of callables only ever stores the module and name, not the object itself.</p>
<p>The <code>partial</code> only works because it shares the underlying function object, which here is another global.</p>
<p>See the <a href="https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled" rel="nofollow"><em>What can be pickled and unpickled</em> section</a> of the <code>pickle</code> module documentation:</p>
<blockquote>
<ul>
<li>functions defined at the top level of a module (using <code>def</code>, not <code>lambda</code>)</li>
<li>built-in functions defined at the top level of a module</li>
</ul>
<p>[...]</p>
<p>Note that functions (built-in and user-defined) are pickled by “fully qualified” name reference, not by value. [2] This means that only the function name is pickled, along with the name of the module the function is defined in. Neither the function’s code, nor any of its function attributes are pickled. Thus the defining module must be importable in the unpickling environment, and the module must contain the named object, otherwise an exception will be raised. [3]</p>
</blockquote>
<p>Do note the <a href="https://docs.python.org/3/library/multiprocessing.html#programming-guidelines" rel="nofollow"><code>multiprocessing</code> <em>Programming guidelines</em></a>:</p>
<blockquote>
<p><em>Picklability</em></p>
<p>Ensure that the arguments to the methods of proxies are picklable.</p>
</blockquote>
<p>and</p>
<blockquote>
<p><em>Better to inherit than pickle/unpickle</em></p>
<p>When using the <em>spawn</em> or <em>forkserver</em> start methods many types from <code>multiprocessing</code> need to be picklable so that child processes can use them. However, one should generally avoid sending shared objects to other processes using pipes or queues. Instead you should arrange the program so that a process which needs access to a shared resource created elsewhere can inherit it from an ancestor process.</p>
</blockquote>
<p>If you try to pickle each of your callable objects directly, you can see that which can be pickled happen to coincide with what callables successfully were executed using multiprocessing:</p>
<pre><code>&gt;&gt;&gt; import pickle
&gt;&gt;&gt; f2(f1(1))
FUNCTION: 1
&gt;&gt;&gt; pickle.dumps([f1, f2]) is not None
True
&gt;&gt;&gt; f4(f3(1))
CLOSURE: 2
&gt;&gt;&gt; pickle.dumps([f3, f4]) is not None
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: Can't pickle local object 'create_processing_closure.&lt;locals&gt;.processing_function'
&gt;&gt;&gt; f6(f5(1))
LAMBDA: 2
&gt;&gt;&gt; pickle.dumps([f5, f6]) is not None
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: Can't pickle local object 'create_processing_lambda.&lt;locals&gt;.&lt;lambda&gt;'
&gt;&gt;&gt; f8(f7(1))
PARTIAL: 2
&gt;&gt;&gt; pickle.dumps([f7, f8]) is not None
True
&gt;&gt;&gt; f10(f9(1))
GLOBAL LAMBDA: 2
&gt;&gt;&gt; pickle.dumps([f9, f10]) is not None
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
_pickle.PicklingError: Can't pickle &lt;function &lt;lambda&gt; at 0x10994e8c8&gt;: attribute lookup &lt;lambda&gt; on __main__ failed
</code></pre>
</div>
<span class="comment-copy">FYI: partials don't work in np.vectorise, while lambdas do!</span>
<span class="comment-copy">On your last paragraph about inheriting vs pickling, are you saying to have the function passed into <code>apply_async</code> to inherit global variables like queues instead of explicitly passing the queue into the asynchronously applied function?</span>
<span class="comment-copy">Can you expand on why the partial works? The documentation indicates that its quite similar to just returning a closure.</span>
<span class="comment-copy">@CMCDragonkai: a closure stores the variables in a closure on a freshly-created function object (so not one you can re-create on the other side because the function object itself is fresh). A partial stores an instance with a pointer to a function object, which <i>here</i> is a global and thus re-creatable on the other side.</span>
<span class="comment-copy">@CMCDragonkai: I quoted the inherit paragraph only because it makes it explicit how data is passed between the master and worker processes; I didn't necessarily mean to imply that inheritance would be the work-around of choice here.</span>
