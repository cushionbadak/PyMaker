<div class="post-text" itemprop="text">
<p>In Python, is it possible for your class's <code>__rmul__</code> method to override another class's <code>__mul__</code> method, without making changes to the other class?</p>
<p>This question arises since I'm writing a class for a certain type of linear operator, and I want it to be able to multiply numpy arrays using the multiplication syntax. Here is a minimal example illustrating the issue:</p>
<pre><code>import numpy as np    

class AbstractMatrix(object):
    def __init__(self):
        self.data = np.array([[1, 2],[3, 4]])

    def __mul__(self, other):
        return np.dot(self.data, other)

    def __rmul__(self, other):
        return np.dot(other, self.data)
</code></pre>
<p>Left multiplication works fine:</p>
<pre><code>In[11]: A = AbstractMatrix()
In[12]: B = np.array([[4, 5],[6, 7]])
In[13]: A*B
Out[13]: 
array([[16, 19],
       [36, 43]])
</code></pre>
<p>But right multiplication defaults to <code>np.ndarray</code>'s version, which splits the array up and performs multiplication element-by-element (this not what is desired):</p>
<pre><code>In[14]: B*A
Out[14]: 
array([[array([[ 4,  8],
       [12, 16]]),
        array([[ 5, 10],
       [15, 20]])],
       [array([[ 6, 12],
       [18, 24]]),
        array([[ 7, 14],
       [21, 28]])]], dtype=object)
</code></pre>
<p>In this situation, how can I make it call my own class's <code>__rmul__</code> on the original (unsplit) array?</p>
<p>Answers addressing the specific case of numpy arrays are welcome but I am also interested in the general idea of overriding methods of another third party class that cannot be modified.</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way to make <code>NumPy</code> respect your <code>__rmul__</code> method is to set an <a href="https://docs.scipy.org/doc/numpy/reference/arrays.classes.html#numpy.class.__array_priority__" rel="nofollow noreferrer"><code>__array_priority__</code></a>:</p>
<pre><code>class AbstractMatrix(object):
    def __init__(self):
        self.data = np.array([[1, 2],[3, 4]])

    def __mul__(self, other):
        return np.dot(self.data, other)

    def __rmul__(self, other):
        return np.dot(other, self.data)

    __array_priority__ = 10000

A = AbstractMatrix()
B = np.array([[4, 5],[6, 7]])
</code></pre>
<p>This works like expected.</p>
<pre><code>&gt;&gt;&gt; B*A
array([[19, 28],
       [27, 40]])
</code></pre>
<p>The problem is that <code>NumPy</code> doesn't respect <a href="https://docs.python.org/3/reference/datamodel.html#object.__radd__" rel="nofollow noreferrer">Pythons "Numeric" Data model</a>. If a numpy array is the first argument and <code>numpy.ndarray.__mul__</code> isn't possible then it tries something like:</p>
<pre><code>result = np.empty(B.shape, dtype=object)
for idx, item in np.ndenumerate(B):
    result[idx] = A.__rmul__(item)
</code></pre>
<p>However if the second argument has an <code>__array_priority__</code> and it's higher than the one of the first argument only then it <strong>really</strong> uses:</p>
<pre><code>A.__rmul__(B)
</code></pre>
<hr/>
<p>However since Python 3.5 (<a href="https://www.python.org/dev/peps/pep-0465/" rel="nofollow noreferrer">PEP-465</a>) there is the <code>@</code> (<a href="https://docs.python.org/3/reference/datamodel.html#object.__matmul__" rel="nofollow noreferrer"><code>__matmul__</code></a>) operator that can utilize matrix multiplication:</p>
<pre><code>&gt;&gt;&gt; A = np.array([[1, 2],[3, 4]])
&gt;&gt;&gt; B = np.array([[4, 5],[6, 7]])
&gt;&gt;&gt; B @ A
array([[19, 28],
       [27, 40]])
</code></pre>
</div>
<span class="comment-copy">Why don't you use the <code>@</code> operator?</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/5182501/2823755">stackoverflow.com/a/5182501/2823755</a></span>
<span class="comment-copy">I believe that the only circumstance when <b>rXXX</b> methods get checked before the usual <b>XXX</b> methods are when the right-side object is a subclass of the left-side object.  I don't know enough about numpy internals to know whether they even can be subclassed.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html#object.__rmul__" rel="nofollow noreferrer">From the docs</a> - <code>These functions are only called if the left operand does not support the corresponding operation and the operands are of different types</code></span>
<span class="comment-copy">@FranciscoCouzo As someone doing numerical analysis, the @ operator looks amazing! What a great decision by the python community. I'm using Python 2.7.6, but this alone might get me to go to 3.x.</span>
