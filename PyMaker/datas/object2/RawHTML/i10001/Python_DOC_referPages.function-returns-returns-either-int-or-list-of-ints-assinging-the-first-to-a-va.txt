<div class="post-text" itemprop="text">
<p>Suppose we have </p>
<pre><code>def f_1():
    return (3, 4)

def f_2():
    return 2
</code></pre>
<p>The functions are given. It is not code that I can modify.
We know they return either an integer or a sequence of them.</p>
<p>I would like to assign the return to a variable, where the variable should take only the first of the integers if the return is a sequence of them.</p>
<p>Is there a build-in syntactic device in Python that allows me to do this?</p>
<pre><code>for function in [f_1, f_2]:
    ...
    x = function()[0] # Works for f_1, breaks for f_2
    y = function()    # Works for f_2, assigns (3, 4) for f_1 while 
                      #   we really would like only the 3 to be the 
                      #   assigned value
</code></pre>
<p><strong>Note:</strong> Assume that we don't know which of the functions return the sequence and which return just a number.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a build-in syntactic device</p>
</blockquote>
<p>No. The usual practice is to <a href="https://stackoverflow.com/a/11360880/6999902">ask</a> for <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">forgivness</a>:</p>
<pre><code>x = function()
try:
    x = x[0]
except TypeError:
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wouldnt go for try-except statement. To me it's an overkill.</p>
<p>More likely I would try to do something like:</p>
<pre><code>result = function()
# this can be changed to abc.Sequence for more general approach
if isinstance(result, (list, tuple)): 
    result = result[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Going in the other direction, wrap <code>f_2</code> in another function to ensure that the function called in the body of the loop <em>always</em> returns a sequence.</p>
<pre><code>for function in [f_1, lambda : (f_2(),)]:
    x = function()[0]
</code></pre>
<p>The additional overhead of another function call may make this approach undesirable.</p>
</div>
<span class="comment-copy">A <i>catch-all</i> except will probably not be forgiven</span>
<span class="comment-copy">True. Corrected that.</span>
<span class="comment-copy">This goes against the "better to ask for forgiveness than permission" style of Python though. Not saying I disagree with your answer, but it's probably considered unidiomatic.</span>
<span class="comment-copy">That would not be pythonic. See <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">docs.python.org/3/glossary.html#term-eafp</a></span>
<span class="comment-copy">Yes, I was just reading about it. The point is what if they would ever change the error type from TypeError to any other? you would need to change the source code to fix it. I would still stick to my answer but will remember that it's not pythonic. Thanks for the tip.</span>
<span class="comment-copy">It's highly unlikely that the <i>language</i> is going to change the exception raised by an attempt to index a type that doesn't support it. It's far more likely that any relevant change to the input will require you to change the list of instances you are checking against. Also, exception handling is more efficient when no error is raised than having to call <code>isinstance</code> on every result.</span>
<span class="comment-copy">Sorry, forgot to mention that I don't know which functions are returning the list and which return the number.</span>
<span class="comment-copy">@myfirsttime1 Just out of curiosity, how is it that you don't know the return of each function? Do they both return either? Does one only ever return a list and the other a number?</span>
<span class="comment-copy">The functions are input. I only know they can return one of those two cases, but don't know which one.</span>
<span class="comment-copy">But this is sort of what I think a solution should be. But I haven't found how to wrap the two cases such that the same type of wrapping works in both cases.</span>
<span class="comment-copy">I assume that not only <code>f_1</code> and <code>f_2</code> are beyond your control, but how your function receives them is as well. Your function <i>should</i> be able to dictate what callbacks it will accept, and it is the caller's responsibility to pass something like <code>lambda: (f_2(),)</code> instead.</span>
