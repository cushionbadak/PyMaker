<div class="post-text" itemprop="text">
<p>Given a list consisting of 1 to 50 integers in the range of -1000 to 1000, calculate the maximum product of one or any number of integers within the list given.</p>
<p>My approach:</p>
<pre><code>import itertools

def answer(xs):
    cur = 1
    dal = []
    for i in range(len(xs), 0, -1):
        for j in itertools.combinations(xs, i):
            for x in j:
                cur *= x
            dal.append(cur)
            cur = 1
    dal.sort(reverse=True)
    return str(dal[0])
</code></pre>
<p>The results timed out. I want to optimize the structure of the procedure to be as efficient as possible. </p>
</div>
<div class="post-text" itemprop="text">
<p>Going through all the combinations is a bad idea unless you have months for the calculation. If all numbers were positive, You would just multiply them all. If all were negative You would take even number of them. If You have to skip one, skip the biggest (-2 is bigger than -5). Adding zero to the mix returns always zero, which is worse than any of the previous cases. If there is no positive number and there are zero or one negative numbers, just take the biggest number You have. It can be zero or the only negative number You have. </p>
<pre><code>def answer(xs):    
    mult = 1
    valid = 0

    for i in xs:
        if i &gt; 0:
            mult *= i
            valid = 1

    negative = [i for i in xs if i&lt;0]
    negative.sort()

    if(len(negative) &amp; 1):
        del negative[-1]

    for i in negative:
            mult *= i
            valid = 1

    if valid==0:
        return max(xs)

    return mult
</code></pre>
<p>and here are some test cases:</p>
<pre><code>xs =  [0]
print(xs,"-&gt;",answer(xs)) #[0] -&gt; 0
xs =  [-1]
print(xs,"-&gt;",answer(xs)) #[-1] -&gt; -1
xs =  [0,-1]
print(xs,"-&gt;",answer(xs)) #[0, -1] -&gt; 0
xs =  [-2,-3]
print(xs,"-&gt;",answer(xs)) #[-2, -3] -&gt; 6
xs =  [-2,-3,-4]
print(xs,"-&gt;",answer(xs)) #[-2, -3, -4] -&gt; 12
xs =  [-2,-3,0]
print(xs,"-&gt;",answer(xs)) #[-2, -3, 0] -&gt; 6
xs =  [-2,3]
print(xs,"-&gt;",answer(xs)) #[-2, 3] -&gt; 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>maximum product can be achieved by multiplying all integers if count of negative is even else maximum product will be leaving the negative (closest to zero) and multiply all others. 
for n=1 print the number as it is.</p>
<p>EDITED :</p>
<pre><code>if len(mylist)==1:
    print mylist[0]
else:
    count=0
    for i in mylist:
        if i&lt;0:
            count+=1
    if count&gt;0:
        mylist.sort()
        if mylist[-1]==0:
            print "0"
        else:
            ans=1
            flag=1
            for i in xrange(len(mylist)):
                if mylist[i]&gt;0 and flag==1:
                    ans/=mylist[i-1]
                else:
                    ans*=mylist[i]
            if flag==1:
                ans/=mylist[-1]
            print ans
    else:
        ans=1
        for i in mylist:
            if i&gt;0:
                ans*=i
        print ans
</code></pre>
<p>and then return ans from your function.</p>
<p>this is a O(n) solution. </p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a two-phase algorithm for <strong>O(n)</strong> time complexity. First multiply all the positive numbers with each other and in case there are no positive numbers pick the largest one. With <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow"><code>reduce</code></a> this can be easily done with one line.</p>
<p>On the following step filter out all negative numbers. If there's more than one multiply them all together. In case the multiplication results to negative number (= there's odd amount of negative numbers) divide the result with maximum of the negative numbers. Then multiply the product you got in step one with product of step 2 for the final result. In case product of step 1 was non-positive number then product of step 2 is the result.</p>
<pre><code>from functools import reduce

nums = [3, -4, 5, -2, -3, 0, 1]
res = reduce(lambda x,y: x * y if x &gt; 0 and y &gt; 0 else max(x, y), nums)
negatives = [x for x in nums if x &lt; 0]
if len(negatives) &gt; 1:
    neg = reduce(lambda x,y: x * y, negatives)
    if neg &lt; 0:
        neg //= max(negatives)
    res = max(res, 1) * neg

print(res)
</code></pre>
<p>Output:</p>
<pre><code>180
</code></pre>
<p>If you're using Python 2 there's no need to import <code>reduce</code> since it's a built-in and instead of floordiv just use regular one.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be optimized in a few ways. First, instead of hosting everything in an array, have a variable <code>maximum</code> which is initialized to <code>xs[0]</code> and each product is checked against. Additionally, instead of doing the multiplication yourself, you can use mul from the <code>operator</code> module with reduce. Finally, I would use <code>xrange</code> as in Python 2 it does not create an array making it more efficient than <code>range</code> This would make your code look like this</p>
<pre><code>from itertools import combinations
from operator import mul    

def answer(xs):
    maximum = xs[0]
    one = 1 in xs
    filter(lambda a: a != 0 and a != 1, xs)
    if len(xs) == 0:
        if one:
            return 1
         else:
            return 0
    for i in xrange(len(xs), 0, -1):
        for j in combinations(xs, i):
            prod = reduce(mul, j, 1)
            if prod &gt; maximum:
                maximum = prod
    return str(maximum)
</code></pre>
<p>I left the return as <code>str(maximum)</code>, but you can return it as <code>maximum</code> which is an integer if you want.</p>
</div>
<span class="comment-copy">Stack Overflow specializes in not-working code. You might ask this on <a href="https://codereview.stackexchange.com">Code Review</a>.</span>
<span class="comment-copy">"one or any number" → So any number?</span>
<span class="comment-copy">count the number of negative elements as well. if they are even take all of them into account and multiply and if they are odd number of negative elements then leave the smallest and multiply everything else.</span>
<span class="comment-copy">i have made and tested it now...check if its working for all test cases for you. editing my ans above.</span>
<span class="comment-copy">now? i have a tendancy to forget some corner cases. sorry!</span>
<span class="comment-copy">I added my own answer, check the testcases there. You would get some surprises with Your code, I would not spoil them :-)</span>
<span class="comment-copy">looked at yours. got the mistakes. thanks :)</span>
<span class="comment-copy">I do not think going through all 1125899906842624 combinations is a good idea.</span>
<span class="comment-copy">@AntonínLejsek I just removed all <code>0</code>s and <code>1</code>s to increase efficiency.</span>
<span class="comment-copy">@Eli Sadoff Half an eternity is still an eternity ...</span>
