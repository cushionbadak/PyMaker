<div class="post-text" itemprop="text">
<p>I was reading about generator and iterators and the role of <code>__next__()</code> . </p>
<p><code>'__next__' in dir(mygen)</code>. is true</p>
<p><code>'__next__' in dir(mylist)</code>,  is false</p>
<p>As I looked deeper into it, </p>
<p><code>'__next__' in dir (mylist.__iter__())</code> is true</p>
<ol>
<li><p>why is<code>__next__</code> only available to list but only to <code>__iter__()</code> and <code>mygen</code> but not <code>mylist</code>. How does <code>__iter__()</code> call <code>__next__</code> when we are stepping thru the list using list-comprehension</p>
<p>Trying to manually step (+1) up the generator, I called <code>mygen.__next__()</code>. It doesn't exist. It only exist as <code>mygen.__next__</code>which is called method-wrapper.</p></li>
<li><p>what is a method-wrapper and what does it do? How is it applied here: in <code>mygen() and __iter__() ?</code></p></li>
<li><p>if <code>__next__</code> is what both generator and iterator provide (and their sole properties) then what is the difference between generator and iterator?*</p>
<p>Answer to 3: Solved, as noted by mod/editor:</p>
<p><a href="https://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators">Difference between Python's Generators and Iterators</a></p></li>
</ol>
<p>UPDATE: both generator and iterator have <code>__next__()</code>. My mistake. Looking at the logs, somehow <code>mygen.__next__()</code> test was giving me stopiteration exception error. But I wasn't able to duplicate that error again.</p>
<p>Thanks everyone for answering!</p>
</div>
<div class="post-text" itemprop="text">
<p>The special methods <code>__iter__</code> and <code>__next__</code> are part of the iterator protocol to create <a href="https://docs.python.org/3/library/stdtypes.html#typeiter" rel="noreferrer">iterator types</a>. For this purpose, you have to differentiate between two separate things: <strong>Iterables</strong> and <strong>iterators</strong>.</p>
<p><em>Iterables</em> are things that can be iterated, usually, these are some kind of container elements that contain items. Common examples are lists, tuples, or dictionaries.</p>
<p>In order to iterate an iterable, you use an <em>iterator</em>. An iterator is the object that helps you iterate through the container. For example, when iterating a list, the iterator essentially keeps track of which index you are currently at.</p>
<p>To get an iterator, the <code>__iter__</code> method is called on the iterable. This is like a factory method that returns a new iterator for this specific iterable. A type having a <code>__iter__</code> method defined, turns it into an iterable.</p>
<p>The iterator generally needs a single method, <code>__next__</code>, which returns the <em>next</em> item for the iteration. In addition, to make the protocol easier to use, every iterator should also be an iterable, returning itself in the <code>__iter__</code> method.</p>
<p>As a quick example, this would be a possible iterator implementation for a list:</p>
<pre><code>class ListIterator:
    def __init__ (self, lst):
        self.lst = lst
        self.idx = 0

    def __iter__ (self):
        return self

    def __next__ (self):
        try:
            item = self.lst[self.idx]
        except IndexError:
            raise StopIteration()
        self.idx += 1
        return item
</code></pre>
<p>The list implementation could then simply return <code>ListIterator(self)</code> from the <code>__iter__</code> method. Of course, the actual implementation for lists is done in C, so this looks a bit different. But the idea is the same.</p>
<p>Iterators are used invisibly in various places in Python. For example a <code>for</code> loop:</p>
<pre><code>for item in lst:
    print(item)
</code></pre>
<p>This is kind of the same to the following:</p>
<pre><code>lst_iterator = iter(lst) # this just calls `lst.__iter__()`
while True:
    try:
        item = next(lst_iterator) # lst_iterator.__next__()
    except StopIteration:
        break
    else:
        print(item)
</code></pre>
<p>So the for loop requests an iterator from the iterable object, and then calls <code>__next__</code> on that iterable until it hits the <code>StopIteration</code> exception. That this happens under the surface is also the reason why you would want iterators to implement the <code>__iter__</code> as well: Otherwise you could never loop over an iterator.</p>
<hr/>
<p>As for generators, what people usually refer to is actually a generator <em>function</em>, i.e. some function definition that has <code>yield</code> statements. Once you call that generator function, you get back a <em>generator</em>. A generator is esentially just an iterator, albeit a fancy one (since it does more than move through a container). As an iterator, it has a <code>__next__</code> method to “generate” the next element, and a <code>__iter__</code> method to return itself.</p>
<hr/>
<p>An example generator function would be the following:</p>
<pre><code>def exampleGenerator():
    yield 1
    print('After 1')
    yield 2
    print('After 2')
</code></pre>
<p>The function body containing a <code>yield</code> statement turns this into a generator function. That means that when you call <code>exampleGenerator()</code> you get back a <em>generator</em> object. Generator objects implement the iterator protocol, so we can call <code>__next__</code> on it (or use the the <code>next()</code> function as above):</p>
<pre><code>&gt;&gt;&gt; x = exampleGenerator()
&gt;&gt;&gt; next(x)
1
&gt;&gt;&gt; next(x)
After 1
2
&gt;&gt;&gt; next(x)
After 2
Traceback (most recent call last):
  File "&lt;pyshell#10&gt;", line 1, in &lt;module&gt;
    next(x)
StopIteration
</code></pre>
<p>Note that the first <code>next()</code> call did not print anything yet. This is the special thing about generators: They are lazy and only evaluate as much as necessary to get the next item from the iterable. Only with the second <code>next()</code> call, we get the first printed line from the function body. And we need another <code>next()</code> call to exhaust the iterable (since there’s not another value yielded).</p>
<p>But apart from that laziness, generators just act like iterables. You even get a <code>StopIteration</code> exception at the end, which allows generators (and generator functions) to be used as <code>for</code> loop sources and wherever “normal” iterables can be used.</p>
<p>The big benefit of generators and their laziness is the ability to generate stuff <em>on demand</em>. A nice analogy for this is endless scrolling on websites: You can scroll down item after after (calling <code>next()</code> on the generator), and every once in a while, the website will have to query a backend to retrieve more items for you to scroll through. Ideally, this happens without you noticing. And that’s exactly what a generator does. It even allows for things like this:</p>
<pre><code>def counter():
    x = 0
    while True:
        x += 1
        yield x
</code></pre>
<p>Non-lazy, this would be impossible to compute since this is an infinite loop. But lazily, as a generator, it’s possible to consume this iterative one item after an item. I originally wanted to spare you from implementing this generator as a fully custom iterator type, but in this case, this actually isn’t too difficult, so here it goes:</p>
<pre><code>class CounterGenerator:
    def __init__ (self):
        self.x = 0

    def __iter__ (self):
        return self

    def __next__ (self):
        self.x += 1
        return self.x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why is <code>__next__</code> only available to list but only to <code>__iter__()</code> and <code>mygen</code> but not <code>mylist</code>. How does <code>__iter__()</code> call <code>__next__</code> when we are stepping through the list using list-comprehension.</p>
</blockquote>
<p>Because lists have a separate object that is returned from <code>iter</code> to handle iteration, this objects <code>__iter__</code> is consecutively called. </p>
<p>So, for lists:</p>
<pre><code>iter(l) is l # False, returns &lt;list-iterator object at..&gt;
</code></pre>
<p>While, for generators:</p>
<pre><code>iter(g) is g # True, its the same object
</code></pre>
<p>In looping constructs, <code>iter</code> is first going to get called on the target object to be looped over. <code>iter</code> calls <code>__iter__</code> and an iterator is expected to be returned; its <code>__next__</code> is called until no more elements are available.</p>
<blockquote>
<p>What is a method-wrapper and what does it do? How is it applied here: in <code>mygen()</code> and <code>__iter__()</code>?</p>
</blockquote>
<p>A method wrapper is, if I'm not mistaken, a method implemented in <code>C</code>. Which is what both these <code>iter(list).__iter__</code> (<code>list</code> is an object implemented in <code>C</code>) and <code>gen.__iter__</code> (not sure here but generators are probably too) are.</p>
<blockquote>
<p>If <code>__next__</code> is what both generator and iterator provide (and their sole properties) then what is the difference between generator and iterator?</p>
</blockquote>
<p>A generator is an iterator, as is the iterator provided from <code>iter(l)</code>. It is an iterator since it provides a <code>__next__</code> method (which, usually, when used in a for loop it is capable of providing values until exhausted).</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__next__</code> and <code>__iter__</code> are method wrappers for when you do <code>next(some_gen)</code> or <code>iter(some_sequence)</code>. <code>next(some_gen)</code> is the same as <code>some_gen.__next__()</code></p>
<p>So if I do <code>mygen = iter(mylist)</code> then <code>mygen</code> is <code>mylist</code> implemented as a generator object and has a <code>__next__</code> method descriptor. Lists themselves do not have this method because they are not generators.</p>
<p>Generators are iterators. Check out <a href="https://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators">difference between generators and iterators</a></p>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators">Difference between Python's Generators and Iterators</a></span>
<span class="comment-copy">"Trying to manually step (+1) up the generator, I called <code>mygen.__next__()</code>. It doesn't exist." - yeah it does. If it looked like it didn't, you screwed up your test.</span>
<span class="comment-copy">You are right. <code>a=[1,2,3,4].__iter__() a.__next__()</code> yielded <code>Out[1] 1</code> obviously stepping up. But the other <code>mygen.__next__()</code> are failing like so: <code>StopIteration                              &lt;snip&gt; ---&gt; 14 mygen.__next__()  StopIteration: </code> I also overlooked this error and assumed that it was missing. But it wasn't. it was just stopIteration error. I still don't get why it would throw stopiteration exception when  <code>__next__()</code> haven't once called yet.</span>
<span class="comment-copy">Ok somehow, <code>mygen.__next__()</code> is now working. it was giving me <code>stopiteration exception</code> earlier. I am not able to duplicate it. Thanks for the tip.</span>
<span class="comment-copy">@theMobDog <code>__next__</code> will throw a StopIteration exception when the iterator reached its end. You would need to create a new iterator if you want to iterate the object again.</span>
<span class="comment-copy">This is the best answer. Most clear explaination on <code>iter, list, next</code>. still looking for information on method-wrapper. But I will take this answer as most complete.</span>
<span class="comment-copy">I’m not entirely sure what you are referring to with method wrapper.</span>
<span class="comment-copy">It's all cleared up now. It was giving me error when <code>__next__()</code> was called and I thought it didn't exist. (stop iteration error and wasn't able to duplicate it again)  I thought generator don't have <code>no __next__() but only __next__</code> .  And now, when I run it again it is working fine.</span>
<span class="comment-copy">Would you be willing to give an example for the generator case? I like your explanations. They speak to me.</span>
<span class="comment-copy">@MadPhysicist Thank you! Glad my answers are helpful to you :) I’ve added a bit more stuff on generators, but essentially it’s just the same thing.</span>
<span class="comment-copy">Thanks for detailed steps on <code>iter</code> calling <code>next</code>. Just to clarify, in a list comprehension <code>x for x in mylist</code> somewhere along there, <code>iter</code> object is returned and started calling <code>next</code>?</span>
<span class="comment-copy">Good explaination on between mygen and mylist. and <code>mygen=iter(mylist)</code> . Thanks.</span>
