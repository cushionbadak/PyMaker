<div class="post-text" itemprop="text">
<p>I have a script which must execute some shell commands. However if command takes too long to complete it must be forcibly killed. Consider the following code snippet:</p>
<pre><code>import asyncio, random

q = asyncio.Queue()

MAX_WAIT = 5

@asyncio.coroutine
def blocking_task(sec):
    print('This task will sleep {} sec.'.format(sec))
    create = asyncio.create_subprocess_shell(
       'sleep {s}; echo "Woke up after {s} sec." &gt;&gt; ./tst.log'.format(s=sec),
        stdout=asyncio.subprocess.PIPE)
    proc = yield from create
    yield from proc.wait()

@asyncio.coroutine
def produce():
    while True:
        q.put_nowait(random.randint(3,8))
        yield from asyncio.sleep(0.5 + random.random())

@asyncio.coroutine
def consume():
    while True:
        value = yield from q.get()
        try:
            yield from asyncio.wait_for(blocking_task(value), MAX_WAIT)
        except asyncio.TimeoutError:
            print('~/~ Job has been cancelled !!')
        else:
            print('=/= Job has been done :]')


loop = asyncio.get_event_loop()
asyncio.ensure_future(produce())
asyncio.ensure_future(consume())
loop.run_forever()
</code></pre>
<p>This code produce the following output:</p>
<pre><code>This task will sleep 4 sec.
=/= Job has been done :]
This task will sleep 8 sec.
~/~ Job has been cancelled !!
This task will sleep 5 sec.
~/~ Job has been cancelled !!
</code></pre>
<p>So it seems that it's working as expected, jobs are stopped if they take too long to finish. But if I check the log I can confirm that however time consuming tasks continued running and were not actually stopped / killed / aborted:</p>
<pre><code>Woke up after 4 sec.
Woke up after 8 sec.
Woke up after 5 sec.
</code></pre>
<p>I would expect there should be just one line in the log, as other processes must have been aborted before they had a chance to finish:</p>
<pre><code>Woke up after 4 sec.
</code></pre>
<p>Is there a way to achieve what I want?</p>
<p>I'm not even sure if I need <code>asyncio</code> here, perhaps <code>concurrent.futures</code> could be used too. Either way task is the same - terminate tasks, which are taking too much time to finish.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.asyncio.subprocess.Process.terminate" rel="nofollow">Process.terminate</a>:</p>
<pre><code>try:
    yield from proc.wait()
except asyncio.CancelledError:
    proc.terminate()
    raise
</code></pre>
<p>Or:</p>
<pre><code>try:
    yield from proc.wait()
finally:
    if proc.returncode is None:
        proc.terminate()
</code></pre>
<hr/>
<p>EDIT</p>
<blockquote>
<p>Why I didn't see asyncio.CancelledError raised in my code?</p>
</blockquote>
<p>When <code>asyncio.wait_for</code> (or anything else) cancels a task, it throws a <code>CancelledError</code> in the corresponding coroutine. This allows the coroutine to perform some clean up if necessary (using a context manager or a <code>try/finally</code> clause for instance). This error does not need to be logged since it is the normal behavior of a canceled task. But try to await a task after cancelling it and a <code>CancelledError</code> will be raised.</p>
</div>
<span class="comment-copy">That worked really beautifully, thank you! I just don't quite understand, why I didn't see <code>asyncio.CancelledError</code> raised in my code? The output was clean as shown, without any exceptions.</span>
<span class="comment-copy">@NarÅ«nasK See my edit.</span>
