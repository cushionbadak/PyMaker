<div class="post-text" itemprop="text">
<p>My problem is the following: I have a <code>multiprocessing.pool.ThreadPool</code> object with <code>worker_count</code> workers and a main <code>pqueue</code> from which I feed tasks to the pool. </p>
<p>The flow is as follows: There is a main loop that gets an item of <code>level</code> level from <code>pqueue</code> and submits it tot the pool using <code>apply_async</code>. When the item is processed, it generates items of <code>level + 1</code>. The problem is that the pool accepts all tasks and processes them in the order they were submitted. </p>
<p>More precisely, what is happening is that the <code>level 0</code> items are processed and each generates 100 <code>level 1</code> items that are retrieved immediately from <code>pqueue</code> and added to the pool, each <code>level 1</code> item produces 100 <code>level 2</code> items that are submitted to the pool, and so on, and the items are processed in an BFS manner. </p>
<p>I need to tell the pool to not accept more than <code>worker_count</code> items in order to give a chance of higher level to be retrieved from <code>pqueue</code> in order to process items in a DFS manner. </p>
<p>The current solution I came with is: for each submitted task, save the <code>AsyncResult</code> object in a <code>asyncres_list</code> list, and before retrieving items from <code>pqueue</code> I remove the items that were processed (if any), check if the length of the <code>asyncres_list</code> is lower than the number of threads in the pool every 0.5 seconds, and like that only <code>thread_number</code> items will be processed at the same time.</p>
<p>I am wondering if there is a cleaner way to achieve this behaviour and I can't seem to find in the documentation some parameters to limit the maximum number of tasks that can be submitted to a pool.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>ThreadPool</code> is a simple tool for a common task. If you want to manage the queue yourself, to get DFS behavior; you could implement the necessary functionality on top <code>threading</code> and <code>queue</code> modules directly.</p>
<p>To prevent scheduling the next root task until all tasks spawned by the current task are done ("DFS"-like order), you could <a href="https://docs.python.org/3/library/queue.html#queue.Queue.join" rel="nofollow">use <code>Queue.join()</code></a>:</p>
<pre><code>#!/usr/bin/env python3
import queue
import random
import threading
import time

def worker(q, multiplicity=5, maxlevel=3, lock=threading.Lock()):
    for task in iter(q.get, None):  # blocking get until None is received
        try:
            if len(task) &lt; maxlevel:
                for i in range(multiplicity):
                    q.put(task + str(i))  # schedule the next level
            time.sleep(random.random())  # emulate some work
            with lock:
                print(task)
        finally:
            q.task_done()

worker_count = 2
q = queue.LifoQueue()
threads = [threading.Thread(target=worker, args=[q], daemon=True)
           for _ in range(worker_count)]
for t in threads:
    t.start()

for task in "01234":  # populate the first level
    q.put(task)
    q.join()  # block until all spawned tasks are done
for _ in threads:  # signal workers to quit
    q.put(None)
for t in threads:  # wait until workers exit
    t.join()
</code></pre>
<p>The code example is derived from the example in <a href="https://docs.python.org/3/library/queue.html#queue.Queue.join" rel="nofollow">the <code>queue</code> module documentation</a>.</p>
<p>The task at each level spawns <code>multiplicity</code> direct child tasks that spawn their own subtasks until <code>maxlevel</code> is reached.</p>
<p><code>None</code> is used to signal the workers that they should quit. <code>t.join()</code> is used to wait until threads exit gracefully. If the main thread is interrupted for any reason then the daemon threads are killed unless there are other non-daemon threads (you might want to provide SIGINT hanlder, to signal the workers to exit gracefully on <code>Ctrl+C</code> instead of just dying).</p>
<p><code>queue.LifoQueue()</code> is used, to get "Last In First Out" order (it is approximate due to multiple threads).</p>
<p>The <code>maxsize</code> is not set because otherwise the workers may deadlock--you have to put the task somewhere anyway. <code>worker_count</code> background threads are running regardless of the task queue.</p>
</div>
<span class="comment-copy">Would probably help if you could post a <a href="http://stackoverflow.com/help/mcve">Minimal, Complete and Verifiable</a> example of the code you have. It is easier to process and answer a question like that.</span>
<span class="comment-copy">"change BFS to DFS" question seems different from "limit pool's task queue size"</span>
