<div class="post-text" itemprop="text">
<p>I'm building my own interpreter in C# using <a href="https://ruslanspivak.com/lsbasi-part7/" rel="nofollow">Ruslan Pavik's Guide</a>. I am at part 7 where we are creating an Abstract Syntax Tree. I was able to get by the first parts and was able to translate the Python code in the guide into C#. But in Part 7, it became entirely difficult for a guy with no Python experience.</p>
<p>I am having difficulty figuring out what the datatypes and the return types are, with Python being a dynamic programming language.</p>
<p>I am confused on this part:</p>
<pre><code> def visit(self, node):
    method_name = 'visit_' + type(node).__name__
    visitor = getattr(self, method_name, self.generic_visit)
    return visitor(node)
</code></pre>
<ol>
<li>I don't know the datatype for <code>visitor</code> but I think it's a string.</li>
<li><code>visitor</code> gets assigned <code>getattr</code> although I don't know what object it tries to get the attribute from.</li>
<li>I don't know what datatype does <code>node</code> have.</li>
</ol>
<p>Later on in the guide, he declares this class:</p>
<pre><code>class AST(object):
pass
</code></pre>
<p>But I know that in C# it's just a class with nothing inside the braces: <code>public class AST { }</code>.</p>
<p>The next class after <code>AST</code> is the <code>BinOp</code> that inherits <code>AST</code>:</p>
<pre><code>class BinOp(AST):
def __init__(self, left, op, right):
    self.left = left
    self.token = self.op = op
    self.right = right
</code></pre>
<p>Basically I'm really confused right now. But my main confusion is the <code>node</code> since I don't know what datatype it has. Since a lot of classes in the parser and interpreter use <code>node</code>, I really can't go forward in my interpreter without knowing what datatype it has.</p>
</div>
<div class="post-text" itemprop="text">
<p>Regarding your question about <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow"><code>getattr</code></a>: This is just a function which returns an attribute with a given name (in the 2nd parameter) of an object (in the 1st parameter) and with a fall back (in the 3rd parameter) if there is no attribute.</p>
<p>So in your case <code>getattr(self, method_name, self.generic_visit)</code> it tries to get an attribute with the name <code>method_name</code> from itself. And if it doesn't exist it uses <code>self.generic_visit</code>. Now if <code>method_name</code> is <code>"visit_BinOp"</code>, it'll try to get <code>self.visit_BinOp</code>, and if that doesn't exist it'll instead get <code>self.generic_visit</code>.</p>
<p>In the end, without running the code, it cannot be determined what it'll return or what type <code>visitor</code> is going to be. It could be anything in theory, but usually it is a method. But that is a difference from Python and C#, that the type of a variables in Python depends on what is assigned to it. You can do the following without an issue:</p>
<pre><code>i = 42
# i is now an int, but you can easily overwrite it with a string
i = "Hello World"
</code></pre>
<p>And the same is with <code>node</code>, in theory it can be anything, but if used correctly it'll be a subclass of <code>AST</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>node</code> is an instance of a subclass of <code>AST</code> here. <code>visitor</code> is a method on a subclass (which you are supposed to write yourself) of the <code>NodeVisitor</code> class. It is looked up <em>dynamically</em> because the passed in <code>node</code> is going to be any one of the possible subclasses of <code>AST</code>, and you are expected to implement specific <code>visit_</code> methods for specific nodes on your custom subclass. The fallback is to use the <code>self.generic_visit</code> method.</p>
<p><code>AST</code> is the base class for nodes. <code>BinOp</code> is a specific node class; the different classes are <a href="https://docs.python.org/3/library/ast.html#abstract-grammar" rel="nofollow noreferrer">documented in the <em>Abstract Grammar</em> section</a>; each camel-cased name is also an <code>AST</code> subclass.</p>
<p>By looking up methods dynamically by the name of the specific node, the developers avoided having to create specific concrete methods for every node type that the grammar defines.</p>
<p>To make this a little more concrete: say you are interested in specific <code>BinOp</code> operator nodes; perhaps because you want to analyse how <code>+</code> is used in a piece of code.</p>
<p>You can then implement a <code>NodeVisitor</code> subclass, and add a <code>visit_BinOp()</code> method on that subclass, and it'll be called automatically when you pass in a <em>tree</em> of nodes to <code>NodeVisitorSubclass().visit(toplevel_node)</code>; for any nodes for which there is no specific <code>visit_*</code> method present, the <code>NodeVisitor.generic_visit()</code> method will make sure the child nodes of the tree are visited (through the <code>iter_fields()</code> function).</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; class DemoVisitor(ast.NodeVisitor):
...     def visit_BinOp(self, binop_node):
...         if isinstance(binop_node.op, ast.Add):
...             print('Found addition of {} and {}'.format(
...                 ast.dump(binop_node.left), ast.dump(binop_node.right)))
...
&gt;&gt;&gt; tree = ast.parse('function(foo + bar)', '', 'eval')
&gt;&gt;&gt; ast.dump(tree)
"Expression(body=Call(func=Name(id='function', ctx=Load()), args=[BinOp(left=Name(id='foo', ctx=Load()), op=Add(), right=Name(id='bar', ctx=Load()))], keywords=[]))"
&gt;&gt;&gt; DemoVisitor().visit(tree)
Found addition of Name(id='foo', ctx=Load()) and Name(id='bar', ctx=Load())
</code></pre>
<p>In the above demo, the <code>NodeWalker.visit()</code> method found the <code>visit_BinOp</code> method and called it for us, but since there are no <code>visit_Expression</code> or <code>visit_Call</code>, etc. methods, those nodes were passed to the <code>NodeWalker.generic_visit()</code> method instead, which processes each field and calls <code>self.visit()</code> for any further nodes.</p>
</div>
<span class="comment-copy">What is your issue with inheriting an empty class? The <code>AST</code> class is basically just used as a “common basis name”.</span>
<span class="comment-copy">I am doing the same thing but in java and had the same problem with the same method. See the answer I was given, it should help - <a href="http://stackoverflow.com/questions/40601211/visitor-pattern-for-interpreter-invoking-method-based-on-instance-type/40601308#40601308" title="visitor pattern for interpreter invoking method based on instance type">stackoverflow.com/questions/40601211/…</a></span>
<span class="comment-copy">If <code>node</code> can be any type, how come the author of the guide was able to use <code>node.op.type</code> in the <code>visit_binOp</code>. I assume with this that a <code>node</code> contain the <code>op</code> operation token. Would <code>node</code> be a class then, or a subclass of <code>AST</code>?</span>
<span class="comment-copy">The author assumes that the correct type was given as a parameter, and if that wasn't the case Python would throw an error (e.g. if the <code>node</code> has no <code>op</code> attribute or the <code>node.op</code> has no <code>type</code> attribute).</span>
<span class="comment-copy">So a <code>node</code> won't be of type string right?</span>
<span class="comment-copy">I need to explicitly define what a <code>node</code> is in C# unlike in Python, thus I'm asking what data type is <code>node</code>.</span>
<span class="comment-copy">In that case it is actually <code>AST</code>. This is also why this class exists.</span>
<span class="comment-copy">What do you mean that I'm supposed to write <code>visitor</code> method myself? I don't see any code for that in the guide.</span>
<span class="comment-copy">@JeanoErmitaño: The <code>NodeVisitor</code> class is meant to be a baseclass for code that is analysing AST trees. It is a <i>framework class</i>, not something that is used directly without subclassing. So yes, you are supposed to write <code>visitor_*</code> functions yourself. You only need to use this if you are analysing Python code for some other task.</span>
<span class="comment-copy">@JeanoErmitaño: See <a href="https://github.com/pziegfeld/OpenMDAO-Framework/blob/master/openmdao.util/src/openmdao/util/dep.py#L87" rel="nofollow noreferrer">this example in a random Python project</a>; that project is interested in <code>import</code> and <code>class</code> statements and collects information about those.</span>
<span class="comment-copy">I was referring to the <code>visitor</code> in <code>visitor = getattr(self, method_name, self.generic_visit)</code> and <code>return visitor(node)</code>. How come this <code>visitor</code> gets assigned some attribute and then acts like a method accepting a <code>node</code>?</span>
<span class="comment-copy">@JeanoErmitaño: <code>getattr()</code> looks up attributes on the first argument, so <code>self</code> here. The attribute name is the string found in <code>method_name</code>, and if not found, <code>self.generic_visit</code> is returned. Methods are just attributes on the instance, so if <code>method_name</code> is set to <code>visit_BinOp</code>, then <code>self.visit_BinOp</code> is returned provided it exists. That's a method you can call.</span>
