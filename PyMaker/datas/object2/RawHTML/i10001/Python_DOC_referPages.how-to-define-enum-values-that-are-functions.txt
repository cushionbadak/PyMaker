<div class="post-text" itemprop="text">
<p>I have a situation where I need to enforce and give the user the option of one of a number of select functions, to be passed in as an argument to another function:</p>
<p>I really want to achieve something like the following:</p>
<pre><code>from enum import Enum

#Trivial Function 1
def functionA():
    pass

#Trivial Function 2
def functionB():
    pass

#This is not allowed (as far as i can tell the values should be integers)
#But pseudocode for what I am after
class AvailableFunctions(Enum):
    OptionA = functionA
    OptionB = functionB
</code></pre>
<p>So the following can be executed:</p>
<pre><code>def myUserFunction(theFunction = AvailableFunctions.OptionA):
   #Type Check
   assert isinstance(theFunction,AvailableFunctions) 

   #Execute the actual function held as value in the enum or equivalent
   return theFunction.value() 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your assumption is <strong>wrong</strong>. Values can be arbitrary, they are <strong>not</strong> limited to integers. From <a href="https://docs.python.org/3/library/enum.html#allowed-members-and-attributes-of-enumerations" rel="noreferrer">the documentation</a>:</p>
<blockquote>
<p>The examples above use integers for enumeration values. Using integers
  is short and handy (and provided by default by the Functional API),
  but not strictly enforced. In the vast majority of use-cases, one
  doesnâ€™t care what the actual value of an enumeration is. <strong>But if the
  value is important, enumerations can have arbitrary values.</strong></p>
</blockquote>
<p><em>However</em> the issue with functions is that they are considered to be method definitions instead of attributes!</p>
<pre><code>In [1]: from enum import Enum

In [2]: def f(self, *args):
   ...:     pass
   ...: 

In [3]: class MyEnum(Enum):
   ...:     a = f
   ...:     def b(self, *args):
   ...:         print(self, args)
   ...:         

In [4]: list(MyEnum)  # it has no values
Out[4]: []

In [5]: MyEnum.a
Out[5]: &lt;function __main__.f&gt;

In [6]: MyEnum.b
Out[6]: &lt;function __main__.MyEnum.b&gt;
</code></pre>
<p>You can work around this by using a wrapper class or just <code>functools.partial</code>:</p>
<pre><code>from functools import partial

class MyEnum(Enum):
    OptionA = partial(functionA)
    OptionB = partial(functionB)
</code></pre>
<p>Sample run:</p>
<pre><code>In [7]: from functools import partial

In [8]: class MyEnum2(Enum):
   ...:     a = partial(f)
   ...:     def b(self, *args):
   ...:         print(self, args)
   ...:         

In [9]: list(MyEnum2)
Out[9]: [&lt;MyEnum2.a: functools.partial(&lt;function f at 0x7f4130f9aae8&gt;)&gt;]

In [10]: MyEnum2.a
Out[10]: &lt;MyEnum2.a: functools.partial(&lt;function f at 0x7f4130f9aae8&gt;)&gt;
</code></pre>
<p>Or using a wrapper class:</p>
<pre><code>In [13]: class Wrapper:
    ...:     def __init__(self, f):
    ...:         self.f = f
    ...:     def __call__(self, *args, **kwargs):
    ...:         return self.f(*args, **kwargs)
    ...:     

In [14]: class MyEnum3(Enum):
    ...:     a = Wrapper(f)
    ...:     

In [15]: list(MyEnum3)
Out[15]: [&lt;MyEnum3.a: &lt;__main__.Wrapper object at 0x7f413075b358&gt;&gt;]
</code></pre>
<hr/>
<p>Also note that if you want you can define the <code>__call__</code> method in your enumeration class to make the values callable:</p>
<pre><code>In [1]: from enum import Enum

In [2]: from functools import partial

In [3]: def f(*args):
   ...:     print(args)
   ...:     

In [4]: class MyEnum(Enum):
   ...:     a = partial(f)
   ...:     def __call__(self, *args):
   ...:         self.value(*args)
   ...:         

In [5]: MyEnum.a(1,2,3)   # no need for MyEnum.a.value(1,2,3)
(1, 2, 3)
</code></pre>
</div>
<span class="comment-copy">Another option: put the functions in a dict, with the function name as the key.</span>
<span class="comment-copy">You discovered the edge case of enums... when python builds a class it adds the functional attributes as methods of the class. That's why they don't end up as values of the <code>Enum</code>. As I show in my answer it is easy to "fool" the interpreter into not making those as methods.</span>
<span class="comment-copy">Thanks very much for the detailed solution...</span>
