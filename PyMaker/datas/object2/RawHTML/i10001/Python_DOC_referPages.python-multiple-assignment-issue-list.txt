<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/34171348/tuple-unpacking-order-changes-values-assigned">Tuple unpacking order changes values assigned</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<pre><code>&gt;&gt;&gt; i = 1
&gt;&gt;&gt; A = [3,4,-1,1]
&gt;&gt;&gt; A[A[i] - 1], A[i]  =  A[i], A[A[i] - 1]
&gt;&gt;&gt; A
[3, 1, -1, 4]
&gt;&gt;&gt; A = [3,4,-1,1]
&gt;&gt;&gt; A[i], A[A[i] - 1] = A[A[i] - 1], A[i]
&gt;&gt;&gt; A
[4, 1, -1, 1]
</code></pre>
<p>I have question when I do assignment for multiple variables for a list.
Like the example above, the assignment</p>
<pre><code>A[A[i] - 1], A[i]  =  A[i], A[A[i] - 1]
</code></pre>
<p>is different from the assignment</p>
<pre><code>A[i], A[A[i] - 1] = A[A[i] - 1], A[i]
</code></pre>
<p>I am really confused the inside calculation order in Python. Why the results are different? What's the best way to do this kind of multiple assignment in one line?</p>
</div>
<div class="post-text" itemprop="text">
<p>Per <a href="https://docs.python.org/3/reference/expressions.html#evaluation-order" rel="nofollow noreferrer">the documentation</a>:</p>
<blockquote>
<p>Python evaluates expressions from left to right. Notice that while
  evaluating an assignment, the right-hand side is evaluated before the
  left-hand side.</p>
</blockquote>
<p>For more detail, see <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow noreferrer">this section</a>. There is a good example of a brain-teaser exploiting this behaviour <a href="https://stackoverflow.com/q/32127908/3001761">here</a>.</p>
<p>This means that the right-hand side of the <code>=</code> is evaluated first, left-to-right, then the assignment is made to the left-hand side, left-to-right. Necessarily, the brackets are evaluated inside-out. Breaking that down stepwise, here's the first example:</p>
<pre><code>i = 1
A = [3, 4, -1, 1]

A[A[i] - 1], A[i] = A[i], A[A[i] - 1]
                  = A[1], A[A[i] - 1]
                  = 4, A[A[i] - 1]
                  = 4, A[A[1] - 1]
                  = 4, A[4 - 1]
                  = 4, A[3]
                  = 4, 1
A[A[i] - 1], A[i] = 4, 1
A[A[1] - 1], A[i] = 4, 1
A[4 - 1], A[i] = 4, 1
A[3], A[i] = 4, 1  # A becomes [3, 4, -1, 4]
A[i] = 1
A[1] = 1  # A becomes [3, 1, -1, 4]
</code></pre>
<p>And here's the second:</p>
<pre><code>i = 1
A = [3, 4, -1, 1]

A[i], A[A[i] - 1] = A[A[i] - 1], A[i]
                  = A[A[1] - 1], A[i]
                  = A[4 - 1], A[i]
                  = A[3], A[i]
                  = 1, A[i]
                  = 1, A[1]
                  = 1, 4
A[i], A[A[i] - 1] = 1, 4
A[1], A[A[i] - 1] = 1, 4  # A becomes [3, 1, -1, 1]
A[A[1] - 1] = 4
A[1 - 1] = 4
A[0] = 4  # A becomes [4, 1, -1, 1]
</code></pre>
<p>The assignment to the left-hand target on the left-hand side alters the content of <code>A</code>, which changes the indexing in the right-hand target. The <code>4</code> is assigned to either <code>A[3]</code> or <code>A[0]</code>, depending on the value of <code>A[1]</code> (which changes from <code>4</code> to <code>1</code>) when the index is calculated.</p>
<p><em>"What's the best way to do this kind of multiple assignment in one line?"</em> - I'd do my very best to avoid it. I can't think of any situation where it would be necessary to assign to moving targets like this.</p>
</div>
<div class="post-text" itemprop="text">
<p>With how you're encouraged to do things like <code>a, b = b, a+b</code>, you might think that multiple assignments like this are supposed to always bypass problems with one assignment interfering with another. Particularly, it's natural to think that all expression evaluations happen before any assignments. Unfortunately, that's not how it works.</p>
<p>When you have a multiple assignment of the form</p>
<pre><code>expr_a[expr_b], expr_c[expr_d] = expr_e, expr_f
</code></pre>
<p>the order of events goes as follows:</p>
<ol>
<li>Evaluate the right-hand side, evaluating <code>expr_e</code> and <code>expr_f</code>.</li>
<li>Perform the first assignment, evaluating <code>expr_a</code> and <code>expr_b</code>.</li>
<li>Perform the third assignment, evaluating <code>expr_c</code> and <code>expr_d</code>. <strong>The first assignment has already happened when these expressions are evaluated.</strong></li>
</ol>
<p>That means that if assigning to <code>expr_a[expr_b]</code> changes the value of <code>expr_c</code> or <code>expr_d</code>, that will change what happens in the second assignment.</p>
<p>In your case, assigning to <code>A[i]</code> changes the value of <code>A[i] - 1</code> in the assignment target <code>A[A[i] - 1]</code>.</p>
<hr/>
<p>Don't use a multiple assignment in cases like this. Separate the assignments onto their own lines, and use temporary variables if necessary to remember values that get changed by assignments.</p>
</div>
<div class="post-text" itemprop="text">
<p>The sequence of operations works the same for any multiple assignment:</p>
<ol>
<li>Evaluate every expression on the RHS (right-hand side), left to right, placing each into a temporary variable.</li>
<li>Evaluate the expressions on the LHS (left), left to right.  For each of these, assign the corresponding temporary variable from the RHS.</li>
</ol>
<p>For your code, this expands to:</p>
<pre><code># A[A[i] - 1], A[i]  =  A[i], A[A[i] - 1]
A = [3,4,-1,1]
t1 = A[i]
t2 = A[A[i] - 1]
# t1 = 4, t2 = 1
A[A[i] - 1] = t1
A[i] = t2
print A
# Result: [3, 1, -1, 4]

# A[i], A[A[i] - 1] = A[A[i] - 1], A[i]
A = [3,4,-1,1]
t2 = A[A[i] - 1]
t1 = A[i]
# As before, t1 = 4, t2 = 1
A[i] = t2
# A[i] is now 1 !
A[A[i] - 1] = t1
print A
# Result: [4, 1, -1, 1]
</code></pre>
<p>The critical difference is when A[i] gets changed in each sequence.  IN the second example, when we evaluate <strong>A[A[i] - 1]</strong> in the final assignment, <strong>A[i]</strong> has already changed to 1.  Therefore, this last assignment puts 4 into location 0, rather than location 3.</p>
</div>
<span class="comment-copy">@Prune: None of the answers there discuss the kind of interference between assignments that shows up in this question.</span>
<span class="comment-copy">I just broke it down to the same logical sequence, and reproduced the user's problem.  In short, I <i>did</i> get the same interactions.</span>
<span class="comment-copy">@Prune: Are you seeing something in those answers that I'm not? None of them say anything about how assignments and evaluations are interleaved on the LHS, or how that can lead to assignments interfering with each other.</span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/q/32127908">Python Assignment Operator Precedence - (a, b) = a[b] = {}, 5</a></span>
<span class="comment-copy">@BhargavRao: Yeah, that's a much better dupe.</span>
<span class="comment-copy">If we could write A.swap(i,A[i]-1) then a one-liner would do... Maybe the reason why there is no such swap function is precisely this multiple assignment feature... like presumed at <a href="https://www.reddit.com/r/Python/comments/3eh5p3/why_isnt_there_a_listswapi_j_function_built_in_to/" rel="nofollow noreferrer">reddit.com/r/Python/comments/3eh5p3/…</a></span>
<span class="comment-copy">@aka.nice then <code>A[i] - 1</code> would be evaluated before the function was called, and be fixed on both sides of the assignment</span>
<span class="comment-copy">Yes, implicitely pushing A[i]-1 in a temp (or stack) is precisely what would make the expression work symmetrically A.swap(A[i]-1,i) would have the same effect</span>
