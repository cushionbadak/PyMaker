<div class="post-text" itemprop="text">
<p>I'm getting a <code>Can't set attribute</code> error when I'm using the <code>+=</code> operator on a read-only property that is of a type for which I've defined a <code>__iadd__()</code> method.</p>
<p>Simplified (but runnable) version of my code:</p>
<pre class="lang-py prettyprint-override"><code>class Emitter(list):
    def __iadd__(self, other):
        self.append( other )
        return self

class Widget:
    def __init__(self):
        self._on_mouseenter = Emitter()

    @property
    def on_mouseenter(self): return self._on_mouseenter


my_widget = Widget()
my_widget.on_mouseenter += lambda source: print("on_mouseenter!")
</code></pre>
<p>The last line produces the error. It goes away if I add the following line to the definition of <code>Widget</code>:</p>
<pre class="lang-py prettyprint-override"><code>@on_mouseenter.setter
def on_mouseenter(self, value): pass
</code></pre>
<p>(Runnable at <a href="https://repl.it/EONf/0" rel="nofollow noreferrer">https://repl.it/EONf/0</a>)</p>
<p>This behaviour seems strange on two accounts. First, I thought that Python passes objects by reference, so why should the property have to be readable? And second, how come that my dummy setter even works?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__iadd__</code> returns a replacement object to be rebound to the variable.  This of course requires a setter.</p>
<p>In this case it works because you're ignoring the set, but still leaving the original object in place, which you've changed in place.</p>
<p>This behavior is required because some objects are immutable, but in place add still works on them.</p>
<p><code>i += 5</code> takes the number i is bound to, adds 5 to it, and rebinds i to the NEW result number.  That is, it is exactly equivalent to <code>i = i + 5</code>, which has an assignment in it.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's caused by how Python's <a href="https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements" rel="nofollow noreferrer">augmented assignment operators</a> work. After calling the appropriate <a href="https://docs.python.org/3/glossary.html#term-special-method" rel="nofollow noreferrer">special method</a>, they assign the return value to the object at the left hand side of the operator.</p>
<blockquote>
<p>If <code>x</code> is an instance of a
  class with an <code>__iadd__()</code> method, <code>x += y</code> is equivalent to <code>x = x.__iadd__(y)</code>. Otherwise, <code>x.__add__(y)</code> and <code>y.__radd__(x)</code> are
  considered, as with the evaluation of <code>x + y</code>.</p>
</blockquote>
<p>Therefore</p>
<pre><code>my_widget.on_mouseenter += lambda source: print("on_mouseenter!")
</code></pre>
<p>is equivalent to</p>
<pre><code>my_widget.on_mouseenter = my_widget.on_mouseenter.__iadd__(lambda source: print("on_mouseenter!"))
</code></pre>
<p>and you need a setter to perform assignment. It doesn't have to do anything, though, because the <code>__iadd__</code> method is defined and modifies the list in-place.</p>
</div>
<span class="comment-copy">The answers explain the issue, however, you could just define <code>self.on_mouseenter = Emitter()</code> directly and avoid the property.</span>
<span class="comment-copy">Be careful with your terminology. While Python does pass around references to objects, "pass by reference" refers to something subtly different. What Python does doesn't really have a good standard name; some people call it "call by object", "call by sharing", or as the Java folks call it, "pass by value, but the value that gets passed is a reference".</span>
<span class="comment-copy">@BenHoyt: I wanted to make the property read-only so that user code can't overwrite it. Is that an antipattern in Python?</span>
<span class="comment-copy">Yeah, it's kind of an antipattern, but not necessarily. Usually Python goes more by the "we're all consenting adults here" principal. For example, Python doesn't really have private members, users can muck with things if they want (or need to).</span>
<span class="comment-copy">Thanks @BenHoyt, I'm gonna go back to a vanilla attribute then.</span>
<span class="comment-copy">Thanks @Max. Would you say that my solution is correct then?</span>
<span class="comment-copy">Not really: it should assign the value passed to it, or you may get some very surprising results if <code>__iadd__</code> doesn't return self.</span>
<span class="comment-copy">Using += to mean append is not particularly pythonic.  People will be used to working with lists by using .append(), not +=.</span>
<span class="comment-copy">Thanks @Max, that is good to know. I'm going to remove the Emitter class and save myself the trouble then.</span>
<span class="comment-copy">@Max Sorry for opening the topic again. What is then reason to implement augmented operators? For example in case x += 5, its equivalent x = x.__iadd__(5) so basically x = x + 5. Only reason to have two version is that x +=5 behaves differently than x = x + 5 and that doesn't have sense as well. So as I see it, the augmented operators are pointless.</span>
<span class="comment-copy">For further reading, see <a href="https://docs.python.org/3.5/faq/programming.html#faq-augmented-assignment-tuple-error" rel="nofollow noreferrer">this answer</a> in the Python FAQ.</span>
<span class="comment-copy">Thanks, that was indeed informative.</span>
<span class="comment-copy">@vaultah: I accepted Max' answer solely because it was a second or so faster. Thanks to both of you.</span>
