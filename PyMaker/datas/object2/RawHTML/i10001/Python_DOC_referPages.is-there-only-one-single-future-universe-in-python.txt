<div class="post-text" itemprop="text">
<p>As explained in another post(<a href="https://stackoverflow.com/a/7075121/2706606">https://stackoverflow.com/a/7075121/2706606</a>), in python you can import stuff from the future. </p>
<p>For example 2/4 evaluates to 0 (as it is an integer division). </p>
<pre><code>&gt;&gt;&gt;print 2/4
0
</code></pre>
<p>But if you import "division" from the future, it evaluates to 0.5</p>
<pre><code>&gt;&gt;&gt; from __future__ import division
&gt;&gt;&gt; print 2/4
0.5
</code></pre>
<p>What I understand from the linked post is that the parser parses the code differently when you use future imports.</p>
<p>And my question is, is there only one single, unique "future" environment where all this future imports are fetched from? </p>
<p>How do we guarantee that the future imports will be forward-compatible with future versions of the python compiler? </p>
<p>Is it possible that maybe in the "more distant future" 2/4 will evaluate to some other value?</p>
</div>
<div class="post-text" itemprop="text">
<p>The features from the future are not going to change meaning. It is guaranteed that <code>from __future__ import x</code> has one of three behaviors:</p>
<ol>
<li>On a version of Python before the future behavior was defined, an exception is thrown indicating the code is incompatible</li>
<li>On a version of Python before the behavior becomes the default, it enables the behavior</li>
<li>On a version of Python after the behavior becomes the default, the import is recognized, but ignored</li>
</ol>
<p>They will not reuse a name to mean something else later on (since that would violate the "recognized but ignored" rule for #3). If they decided to change, say, <code>division</code> again, they'd need to use a new name, e.g. to make it truncate towards zero division instead of floor division, they might make a <code>__future__</code> import named <code>truncating_division</code>. But they won't delete <code>division</code>, ever, as long as Python exists, nor will they change the meaning, <a href="https://docs.python.org/3/library/__future__.html" rel="nofollow noreferrer">per the <code>__future__</code> docs</a>:</p>
<blockquote>
<p>No feature description will ever be deleted from <code>__future__</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>If you look at the import <code>__future__</code> there is a list called <code>all_feature_names</code> that you can use to see what features are available for your python interpreter. </p>
<pre><code>import __future__
print(__future__.all_feature_names)
</code></pre>
<p>Which on my machine would return the following on Python 2.7.12.</p>
<pre><code>['nested_scopes', 'generators', 'division', 'absolute_import',
 'with_statement', 'print_function', 'unicode_literals']
</code></pre>
<p>And with Python 3.5.2.</p>
<pre><code>['nested_scopes', 'generators', 'division', 'absolute_import', 
 'with_statement', 'print_function', 'unicode_literals', 
 'barry_as_FLUFL', 'generator_stop']
</code></pre>
<p>There is however no guarantee that the Python interpreter you are running will have the same features available, the import may not even exist on some implementations, but assuming that the feature is available the implementation should remain the same, as long as it was implemented according to the <a href="https://www.python.org/dev/peps/" rel="nofollow noreferrer">PEP</a> (e.g. <a href="http://www.python.org/dev/peps/pep-0238" rel="nofollow noreferrer">PEP-0238</a>), which should be the case for most Python interpreters.</p>
</div>
<span class="comment-copy"><code>__future__</code> is use only in Python 2 which is almost dead. Nobody will need this in the future.</span>
<span class="comment-copy">Yes. The future environment is called Python 3.</span>
<span class="comment-copy">@furas: Absolutely not. It's used in Py3 for new things even now, for <code>generator_stop</code> (<a href="https://docs.python.org/3/library/__future__.html" rel="nofollow noreferrer">ref</a>). Once the future arrives though, the imports stop doing anything; they're recognized, but ignored (because the default syntax already includes them). If you import something that doesn't exist yet in your version of Python (e.g. <code>with_statement</code> being imported in 2.4), you'd get an exception that lets you know the code is incompatible with that old version of Python.</span>
<span class="comment-copy">For the record, <code>from __future__ import barry_as_FLUFL</code> is <a href="http://stackoverflow.com/a/4007310/364696">the best</a> <code>__future__</code> import. :-)</span>
<span class="comment-copy">@ShadowRanger how about <code>from __future__ import braces</code></span>
