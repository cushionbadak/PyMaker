<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/5466451/how-can-i-print-literal-curly-brace-characters-in-python-string-and-also-use-fo">How can I print literal curly-brace characters in python string and also use .format on it?</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
</ul>
</div>
<p>again :)</p>
<p>I found this bit of code </p>
<pre><code>col_width=[13,11]
header=['First Name','Last Name']

format_specs = ["{{:{}}}".format(col_width[i]) for i in range(len(col_width))]
lheader=[format_specs[i].format(self.__header[i]) for i in range(nb_columns)]
</code></pre>
<p>How Python evaluate this statement? Why we use three { when we have one element to format in every iteration?</p>
</div>
<div class="post-text" itemprop="text">
<p>when you do <code>{{}}</code>, python skips the replacement of <code>{}</code> and makes it the part of <code>string</code>. Below is the sample example to explain this:</p>
<pre><code>&gt;&gt;&gt; '{{}}'.format(3)  # with two '{{}}'
'{}'  # nothing added to the string, instead made inner `{}` as the part of string
&gt;&gt;&gt; '{{{}}}'.format(3)  # with three '{{{}}}'
'{3}'  # replaced third one with the number
</code></pre>
<p>Similarly, your expression is evaluating as:</p>
<pre><code>&gt;&gt;&gt; '{{:{}}}'.format(3)
'{:3}'  # during creation of "format_specs"
</code></pre>
<p>For details, refer: <a href="https://docs.python.org/3/library/string.html#format-string-syntax" rel="nofollow">Format String Syntax</a> document.</p>
</div>
<span class="comment-copy">Why are you tagging this with a Python 2 and a Python 3 tag? Which is it? does it even matter? Please don't use inappropriate tags.</span>
<span class="comment-copy">Read the <a href="https://docs.python.org/3/library/string.html#formatstrings" rel="nofollow noreferrer">docs</a>.</span>
<span class="comment-copy">Note: You could avoid the two pass solution here; Python can already format with a user provided width. The first outer bracket corresponds to the first positional argument, so your two pass code could be written as a single pass with: <code>lheader = ['{:{}}'.format(h, w) for h, w in zip(header, col_width)]</code> or even <code>lheader = list(map('{:{}}'.format, header, col_width))</code>. Since automatic numbering isn't 100% obvious here, you could use <code>'{0:{1}}'</code> as your format string, just to make it clear that the value is the first argument and the width is the second.</span>
