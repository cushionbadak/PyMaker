<div class="post-text" itemprop="text">
<p>What is right way to call async code in regular callback?
This code works, but looks not pretty. I do not like how respond called: it needs to pass caller address through all functions. How to set timeout to handler?</p>
<p>I placed questions in comments.</p>
<pre><code>import asyncio
import logging
logger = logging.getLogger('protocol')

async def echo(data):
    #external lib emulator
    data = b'&gt;'+data
    await asyncio.sleep(1)
    return data


class Protocol(asyncio.DatagramProtocol):
    def connection_made(self, transport):
        logger.debug('connection_made called')
        self.transport = transport

    def respond(self,task):
        logger.debug('respond called')
        # i want to get data in attrs, not task

        resp,caller = task.result()

        self.transport.sendto(resp, caller)


    async def handler(self,data, caller):
        logger.debug('handler called')

        # async needed for `await` and `async for` external library such motor, etc
        # do some awaits
        data = await echo(data)

        # simple echo
        return (data, caller)


    def datagram_received(self, data, addr):
        logger.debug('datagram_received called')

        # handler selected by data header
        handler = self.handler

        # how to do run async handler?
        loop = asyncio.get_event_loop()
        c = handler(data, addr) #coroutine

        f = asyncio.ensure_future(c,loop=loop) #attach coroutine to loop
        f.add_done_callback(self.respond)

        # How to get response here?

        # i cant loop.run_until_complete(...) because loop.run_forever() running

        #def wakeup():
        #    pass
        #loop.call_soon(wakeup)
        # without this call_soon future is not executed in first programm code, but works in test and after refactor


def main(HOST,PORT):

    loop = asyncio.get_event_loop()
    t = asyncio.Task(loop.create_datagram_endpoint(
        Protocol, local_addr=(HOST,PORT)))
    transport, server = loop.run_until_complete(t)

    sock = transport.get_extra_info('socket')
    # socket tuning here

    try:
        loop.run_forever()
    finally:
        transport.close()
        loop.close()

logging.basicConfig(level=logging.DEBUG)     
main('0.0.0.0',10012)
</code></pre>
<p>Use netcat to test <code>nc -u 127.0.0.1 10012</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You may use asyncio.Queue to put there tasks in one coroutine (handle) and <code>await</code> them in another (respond):</p>
<pre><code>class Protocol(asyncio.DatagramProtocol):

    def __init__(self):
        self.data_queue = asyncio.Queue(loop=asyncio.get_event_loop())
        asyncio.ensure_future(self.respond())

    def connection_made(self, transport):
        self.transport = transport

    def datagram_received(self, data, addr):
        asyncio.ensure_future(self.handler(data, addr), loop=asyncio.get_event_loop())

    async def respond(self):
        while True:
            resp, caller = await self.data_queue.get()
            self.transport.sendto(resp, caller)

    async def handler(self, data, caller):
        data = await echo(data)
        self.data_queue.put((data, caller))
</code></pre>
</div>
<span class="comment-copy">I think you are right: <code>asyncio.ensure_future</code> is the right way.</span>
<span class="comment-copy">@SergeyBelash how to get data from it inplace (without callback)?</span>
<span class="comment-copy"><code>ensure_future</code> runs only after <code>datagram_received</code> returns</span>
<span class="comment-copy">The lower level of asyncio is based on callbacks and asyncio doesn't provide coroutine-based objects for UDP. However, you can have a look at <a href="https://gist.github.com/vxgmichel/e47bff34b68adb3cf6bd4845c4bed448" rel="nofollow noreferrer">those high-level UDP endpoints for asyncio</a>, it might give you some insight on how to implement similar coroutine-based solutions.</span>
<span class="comment-copy">self.data_queue.get() locks loop?</span>
<span class="comment-copy">@eri no, this method is a <code>coroutine</code> <a href="https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue.get" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-queue.html#asyncio.Queue.get</a></span>
