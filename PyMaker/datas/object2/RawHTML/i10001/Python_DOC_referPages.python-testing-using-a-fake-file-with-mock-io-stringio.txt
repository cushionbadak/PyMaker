<div class="post-text" itemprop="text">
<p>I'm trying to test some code that operates on a file, and I can't seem to get my head around how to replace using a real file with <code>mock</code> and <code>io.StringIO</code>
My code is pretty much the following:</p>
<pre><code>class CheckConfig(object):
    def __init__(self, config):
        self.config = self._check_input_data(config)

    def _check_input_data(self, data):
        if isinstance(data, list):
            return self._parse(data)
        elif os.path.isfile(data):
            with open(data) as f:
                return self._parse(f.readlines())

    def _parse(self, data):
        return data
</code></pre>
<p>I have a class that can take either a list or a file, if it's a file it opens it and extracts the contents into a list, and then does what it needs to do to the resulting list. </p>
<p>I have a working test as follows:</p>
<pre><code>def test_CheckConfig_with_file():
    config = 'config.txt'
    expected = parsed_file_data
    actual = CheckConfig(config).config
    assert expected == actual
</code></pre>
<p>I want to replace the call to the filesystem. I have tried replacing the file with <code>io.StringIO</code> but I get a <code>TypeError</code> from <code>os.path.isfile()</code> as it's expecting either a string, bytes or int. I also tried mocking the <code>isfile</code> method like so:</p>
<pre><code>@mock.patch('mymodule.os.path')
def test_CheckConfig_with_file(mock_path):
    mock_path.isfile.return_value = True
    config = io.StringIO('data')
    expected = parsed_file_data
    actual = CheckConfig(config).config
    assert expected == actual
</code></pre>
<p>but I still get the same <code>TypeError</code> as the <code>_io.StringIO</code> type is causing the exception before <code>isfile</code> gets a chance to return something.</p>
<p>How can I get <code>os.path.isfile</code> to return True, when I pass it a fake file? Or is this a suggestion I should change my code?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just mock out both <code>os.path.isfile</code> <em>and</em> the <code>open()</code> call, and pass in a fake filename (you are not expected to pass in an open file, after all).</p>
<p>The mock library includes a utility for the latter: <a href="https://docs.python.org/3/library/unittest.mock.html#mock-open" rel="nofollow noreferrer"><code>mock_open()</code></a>:</p>
<pre><code>@mock.patch('os.path.isfile')
def test_CheckConfig_with_file(mock_isfile):
    mock_isfile.return_value = True
    config_data = mock.mock_open(read_data='data')
    with mock.patch('mymodule.open', config_data) as mock_open:
        expected = parsed_file_data
        actual = CheckConfig('mocked/filename').config
        assert expected == actual
</code></pre>
<p>This causes the <code>if isinstance(data, list):</code> test to be false (because <code>data</code> is a string instead), followed by the <code>elif os.path.isfile(data):</code> returning <code>True</code>, and the <code>open(data)</code> call to use your mocked data from the <code>mock_open()</code> result.</p>
<p>You can use the <code>mock_open</code> variable to assert that <code>open()</code> was called with the right data (<code>mock_open. assert_called_once_with('mocked/filename')</code> for example). </p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import os.path
&gt;&gt;&gt; from unittest import mock
&gt;&gt;&gt; class CheckConfig(object):
...     def __init__(self, config):
...         self.config = self._check_input_data(config)
...     def _check_input_data(self, data):
...         if isinstance(data, list):
...             return self._parse(data)
...         elif os.path.isfile(data):
...             with open(data) as f:
...                 return self._parse(f.readlines())
...     def _parse(self, data):
...         return data
...
&gt;&gt;&gt; with mock.patch('os.path.isfile') as mock_isfile:
...     mock_isfile.return_value = True
...     config_data = mock.mock_open(read_data='line1\nline2\n')
...     with mock.patch('__main__.open', config_data) as mock_open:
...         actual = CheckConfig('mocked/filename').config
...
&gt;&gt;&gt; actual
['line1\n', 'line2\n']
&gt;&gt;&gt; mock_open.mock_calls
[call('mocked/filename'),
 call().__enter__(),
 call().readlines(),
 call().__exit__(None, None, None)]
</code></pre>
</div>
<span class="comment-copy">Can you also paste the error log?</span>
<span class="comment-copy">Excellent, thankyou! This is exactly what I needed, and has helped me get a better grasp on mocking. Just out of interest, is there a reason you are using a context manager rather than a <code>@mock.patch</code> decorator. In previous tests I had been using the decorator, but here I couldn't find a way as I was using a <code>pytest.fixture</code> for the content of the <code>open</code> call, which wasn't available until inside the test function.</span>
<span class="comment-copy">for anyone stumbling on this answer. mock_open currently doesn't support iterables so if instead of f.readlines() you used yield you will have to work around the iteration. <a href="https://stackoverflow.com/questions/24779893/customizing-unittest-mock-mock-open-for-iteration" title="customizing unittest mock mock open for iteration">stackoverflow.com/questions/24779893/â€¦</a></span>
