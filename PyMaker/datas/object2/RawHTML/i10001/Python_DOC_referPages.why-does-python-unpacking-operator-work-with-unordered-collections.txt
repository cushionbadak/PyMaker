<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow">Python 3 tutorial</a> about the unpacking operator (<code>*</code>) generically speaks of a "list or tuple," while the error message for improper use says that a "sequence" is needed:</p>
<pre><code>Python 3.5.1 (v3.5.1:37a07cee5969, Dec  6 2015, 01:38:48) [MSC v.1900 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; def f(a, b):
...     return a / b
...
&gt;&gt;&gt; f(*1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: f() argument after * must be a sequence, not int
</code></pre>
<p>Python 3's <a href="https://docs.python.org/3/library/stdtypes.html" rel="nofollow">Built-in types</a> documentation lists the following sequence types:</p>
<ul>
<li>Sequence Types — <code>list</code>, <code>tuple</code>, <code>range</code></li>
<li>Text Sequence Type — <code>str</code></li>
<li>Binary Sequence Types — <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code></li>
</ul>
<p>Quick test:</p>
<pre><code>&gt;&gt;&gt; all(isinstance(x, collections.Sequence) for x in [[], (), range(1), '', b''])
True
</code></pre>
<p>Note that set types (like <code>set</code> and <code>frozenset</code>) and mapping types (<code>dict</code>) are <em>not</em> included here.</p>
<pre><code>&gt;&gt;&gt; any(isinstance(x, collections.Sequence) for x in [set(), {}])
False
</code></pre>
<hr/>
<p>My question: <strong>Why are all iterable types (including a <code>set</code> or <code>dict</code>) unpackable?</strong> They are not sequence types, as the <code>TypeError</code> above suggests they should be, and unordered behavior leads to undefined results when unpacking for positional args:</p>
<pre><code>&gt;&gt;&gt; def f(a, b):
...     return a / b
...
&gt;&gt;&gt; f(*{4, 2})
0.5
&gt;&gt;&gt; f(*{8, 2})
4.0
&gt;&gt;&gt; f(*{4:1, 2:1})
0.5
&gt;&gt;&gt; f(*{2:1, 8:1})
4.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The error message is most likely a little bug<sup>*</sup>. Anything that is an iterable is accepted during function calls; this is hidden inside the <a href="https://docs.python.org/3.6/reference/expressions.html#calls" rel="nofollow">section for Calls in the Python Reference Manual</a>:</p>
<blockquote>
<p>If the syntax <code>*expression</code> appears in the function call, expression <em>must evaluate to an iterable</em>. Elements from these iterables are treated as if they were additional positional arguments.</p>
</blockquote>
<p><sup>(Emphasis mine)</sup></p>
<p>*Which, as of <code>3.5.2</code> as @sytech pointed out, was fixed in <a href="http://bugs.python.org/issue4806" rel="nofollow"><code>Issue 4806</code></a> to correspond to the correct wording in the reference manual.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is no longer the case in (at least) Python 3.5.2 -- Probably was recognized as an issue and changed in a version later than what you're using. The message now more appropriately reads <strong><em>iterable</em></strong> instead of <em>sequence</em></p>
<p>See <a href="https://bugs.python.org/issue4806" rel="nofollow">https://bugs.python.org/issue4806</a></p>
<pre><code>&gt;&gt;&gt; def foo(*args):
...     print(*args)
...
&gt;&gt;&gt; foo(*1)
TypeError: foo() argument after * must be an iterable, not int
</code></pre>
</div>
<span class="comment-copy">Pretty sure only iterator methods are required for that. Unpacking predates abstract collection types.</span>
<span class="comment-copy">The error message in Python 3.5 is <code>TypeError: foo() argument after * must be an iterable, not int</code></span>
<span class="comment-copy">So, basically you ask <a href="http://stackoverflow.com/questions/15479928/why-is-the-order-in-dictionaries-and-sets-arbitrary">Why is the order in dictionaries and sets arbitrary?</a></span>
<span class="comment-copy">@ŁukaszRogalski No--my question is why unordered collections allow unpacking, given the error message and unexpected behavior with positional args. I understand that they are arbitrary.</span>
<span class="comment-copy">Dict and set are not a sequences, but they are iterables (they implement iterator protocol). Since they are implementing it, there is absolutely no reason for them not to be able to unpack. Integers are not iterables, why would you expect them to unpack successfully?</span>
<span class="comment-copy">A bug that, evidently, has been addressed. I'm on 3.5.2 and the message actually says <b><i>iterable</i></b> not <i>sequence</i></span>
<span class="comment-copy">@sytech Right, pointed that out, any luck finding that bug report yet?</span>
<span class="comment-copy"><a href="https://bugs.python.org/issue4806" rel="nofollow noreferrer">bugs.python.org/issue4806</a></span>
<span class="comment-copy">Interesting: I'm using v3.5.1:37a07cee5969</span>
<span class="comment-copy">I'm on 3.5.2 -- specifically v3.5.2:4def2a2901a5</span>
