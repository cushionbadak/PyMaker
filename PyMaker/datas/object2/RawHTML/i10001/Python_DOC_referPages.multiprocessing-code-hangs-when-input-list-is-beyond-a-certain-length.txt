<div class="post-text" itemprop="text">
<p>I'm been playing with the multiprocessing module to gain a better understanding from the implementation side. The code below does the following serial and then parallel way:</p>
<p>A set of random numbers are generated. Each number is used as a constant in an exponential function. The goal is to find, for each random number, a scalar needed such that the integral of the exponential function is 20.</p>
<p>The code below seems to work. However, once the value of <code>num</code> is set to 500, the code will just hang and I have no idea why. For what it's worth, this is on a Windows machine with everything running in Spyder.</p>
<pre><code>from scipy import optimize as op
from scipy.integrate import trapz as intg
import numpy as np
import multiprocessing as mp
import random
import timeit
import time

def to_solve(a=None, x=None, y=None):
    return intg(a*y, x)-20

def worker(lst, x,  out_q):
    ans = np.zeros(shape=(len(lst), 2))
    for i, a in enumerate(lst):
        y = func(a=a, x=x)
        ans[i,0] = a
        ans[i,1] = op.newton(func=to_solve,  x0=1,  args=(x, y))
    out_q.put(ans)

def func(a=None, x=None):
    return 1-np.exp(-a*x)

def main_p(nums):
    start = timeit.default_timer()
    x = np.linspace(0,100)
    procs = []
    out_q = mp.Queue()
    num_procs = 2
    step = int(len(nums)/num_procs)
    first = 0
    last  = 0
    for i in range(num_procs):
        first = last
        last = first+step
        if i == num_procs-1:
            out = nums[first:]
        else:
            out = nums[first:last]
        p = mp.Process(target=worker, args=(out, x, out_q))
        procs.append(p)
        p.start()        
    for p in procs:
        p.join()
    for i in range(len(procs)):
        if i == 0:
            results = out_q.get()
        else:
            results = np.vstack((results, out_q.get()))
    results = results[results[:,0].argsort()]
    print timeit.default_timer() - start
    return results

def main_s(nums):
    start = timeit.default_timer()
    results = np.zeros(shape=(len(nums),2))
    x = np.linspace(0,100)
    for i, a in enumerate(nums):
        results[i,0] = a
        y = func(a=a, x=x)
        results[i,1] = op.newton(func=to_solve,  x0=1,  args=(x,y))
    results = results[results[:,0].argsort()]
    print timeit.default_timer() - start    
    return results

if __name__ == '__main__':
    num  = 400
    nums = np.random.rand(1,num)
    nums = nums.tolist()[0]
    a = main_s(nums)
    b = main_p(nums)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The object you are putting on the Queue is too large. Th worker process will not terminate until the buffer feeding the Queue is empty, which in turn will not happen until the parent process reads from the queue, which will happen after the join(), which waits -&gt; Deadlock.</p>
<p>Here ist the description:
"<a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing-programming" rel="nofollow">An example which will deadlock is the following.</a>"
It follows that the problem goes away if you move the loop</p>
<pre><code>for p in procs:
    p.join()
</code></pre>
<p>after the <code>for i in range(len(procs)):</code> - loop.</p>
</div>
