<div class="post-text" itemprop="text">
<p>I have a dataframe like this.</p>
<pre><code>       Date       price     mid      std         top             btm
     ..............
    1999-07-21  8.6912  8.504580    0.084923    9.674425    8.334735
    1999-07-22  8.6978  8.508515    0.092034    8.692583    8.324447
    1999-07-23  8.8127  8.524605    0.118186    10.760976   8.288234
    1999-07-24  8.8779  8.688810    0.091124    8.871057    8.506563
     ..............
</code></pre>
<p>I want to create a new col called 'diff'.
If in a row ,'price' &gt;'top' then I want to fill 'diff' of this row with the Geometric mean return of price in this row and price in the n-5 previous row.(The 5-day Geometric mean).</p>
<p>For example, In row 1999-07-22,the price is greater than top, so I wanto fill 'diff' in this row with  Geometric mean of 07-22 and 07-17(notice the date may not be consecutive since holidays are excluded ). Only a small part of the rows meet the demand. So most of values in 'diff' will be missing values.</p>
<p>Could you please tell me how I can do this in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.diff.html" rel="nofollow noreferrer"><code>Series.diff</code></a> with <a href="http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.where.html" rel="nofollow noreferrer"><code>Series.where</code></a> for set <code>NaN</code>s:</p>
<pre><code>df['diff'] = df['price'].diff().where(df['price'] &gt; df['top'])
print (df)
             price       mid       std        top       btm    diff
Date                                                               
1999-07-21  8.6912  8.504580  0.084923   9.674425  8.334735     NaN
1999-07-22  8.6978  8.508515  0.092034   8.692583  8.324447  0.0066
1999-07-23  8.8127  8.524605  0.118186  10.760976  8.288234     NaN
1999-07-24  8.8779  8.688810  0.091124   8.871057  8.506563  0.0652
</code></pre>
<p>EDIT:</p>
<p>I believe you need:</p>
<pre><code>df['Date'] = pd.to_datetime(df['Date'])
df = df.set_index('Date')

from scipy.stats.mstats import gmean

df['gmean'] = (df['price'].rolling('5d')
                          .apply(gmean, raw=True)
                          .where(df['price'] &gt; df['top']))
print (df)
             price       mid       std        top       btm     gmean
Date                                                                 
1999-07-21  8.6912  8.504580  0.084923   9.674425  8.334735       NaN
1999-07-22  8.6978  8.508515  0.092034   8.692583  8.324447  8.694499
1999-07-23  8.8127  8.524605  0.118186  10.760976  8.288234       NaN
1999-07-24  8.8779  8.688810  0.091124   8.871057  8.506563  8.769546
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve that by taking the difference of <code>price</code> and <code>top</code> columns and then assign those values that are <code>&lt;= 0</code> a <code>NaN</code> or zero value:</p>
<pre><code>import pandas as pd
import numpy as np

df = pd.DataFrame(...)

df['diff'] = df['price'] - df['top']

df.loc[df['diff'] &lt;= 0, 'diff'] = np.NaN # or 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another solution:</p>
<pre><code>import pandas as pd
from functools import reduce

__name__ = 'RunScript'

ddict = {
    'Date':['1999-07-21','1999-07-22','1999-07-23','1999-07-24',],
    'price':[8.6912,8.6978,8.8127,8.8779],
    'mid':[8.504580,8.508515,8.524605,8.688810],
    'std':[0.084923,0.092034,0.118186,0.091124],
    'top':[9.674425,8.692583,10.760976,8.871057],
    'btm':[8.334735,8.324447,8.288234,8.506563],
    }


data = pd.DataFrame(ddict)


def geo_mean(iter):
    """
        Geometric mean function. Pass iterable
    """
    return reduce(lambda a, b: a * b, iter) ** (1.0 / len(iter))


def set_geo_mean(df):
    # Shift the price row down one period
    data['shifted price'] = data['price'].shift(periods=1)

    # Create a masked expression that evaluates price vs top
    masked_expression = df['price'] &gt; df['top']

    # Return rows from dataframe where masked expression is true
    masked_data = df[masked_expression]

    # Apply our function to the relevant rows
    df.loc[masked_expression, 'geo_mean'] = geo_mean([masked_data['price'], masked_data['shifted price']])

    # Drop the shifted price data column once complete
    df.drop('shifted price', axis=1, inplace=True)


if __name__ == 'RunScript':
    # Call function and pass dataframe argument.
    set_geo_mean(data)
</code></pre>
</div>
<span class="comment-copy">OK, so is possible add sample data for 10 rows with expected output? I think unnecessary columns should be removed from sample data.</span>
<span class="comment-copy">Sorry I just simplied the question just now but I find I should be more specific. Please see my question after editing.</span>
<span class="comment-copy">@JAKE - Not sure if understand your question, but if need geometric mean per 5 days use <code>rolling</code> with <code>gmean</code> check  solution.</span>
<span class="comment-copy">hey I think you are right</span>
<span class="comment-copy">Sorry I just simplied the question just now but I find I should be more specific. Please see my question after editing.</span>
