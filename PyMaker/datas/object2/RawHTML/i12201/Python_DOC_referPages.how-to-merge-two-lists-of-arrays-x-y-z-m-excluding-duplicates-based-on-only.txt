<div class="post-text" itemprop="text">
<p>I have two lists of the form</p>
<pre><code>list1 = list(zip(SGXm, SGYm, SGZm, Lm))
list2 = list(zip(SGXmm, SGYmm, SGZmm, Lmm))
</code></pre>
<p>I want to merge them, while excluding duplicate (x,y,z) entries, and ignoring differences in L.</p>
<pre><code>list1.extend(x for x in list2 if x not in list1)
</code></pre>
<p>Does the job only for my x,y,z, but I want to retain the Ls (of the first list when there is a choice).</p>
</div>
<div class="post-text" itemprop="text">
<p>You'll have to extract the triples you need for comparison.</p>
<pre><code>seen = set(item[:3] for item in list1)
list1.extend(item for item in list2 if item[:3] not in seen)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want sorted output (particularly if you already have sorted input) <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a> and <a href="https://docs.python.org/3/library/heapq.html#heapq.merge" rel="nofollow"><code>heapq.merge</code></a> combine nicely for this. If the inputs aren't already sorted, you'll need to do so. Either concatenate and sort all at once:</p>
<pre><code>from operator import itemgetter

commonkey = itemgetter(0, 1, 2)
combined = sorted(list1 + list2, key=commonkey)
</code></pre>
<p>or if they're already sorted, or you want to sort independently, you use <code>heapq.merge</code> and avoid making shallow copies of the inputs:</p>
<pre><code># Explicit sort calls only necessary if inputs not already sorted
list1.sort(key=commonkey)
list2.sort(key=commonkey)

# Combine already sorted inputs with heapq.merge, avoiding intermediate lists
combined = heapq.merge(list1, list2, key=commonkey)
</code></pre>
<p>Whichever approach you chose, you then follow it up with a simple comprehension over <code>groupby</code> to keep only one copy of each unique key by just getting the first entry in each unique group:</p>
<pre><code># Groups neighboring entries with the same key, and we keep only the first one
uniq = [next(g) for _, g in itertools.groupby(combined, key=commonkey)]
</code></pre>
</div>
<span class="comment-copy"><code>set</code>s are much more efficient for testing <code>in</code>, so would probably do this even if there wasn't a need for slicing.</span>
<span class="comment-copy"><code>list1.extend(item for item in list2[:3] if item[:3] not in seen)</code></span>
<span class="comment-copy">Slicing to extract the first three elements makes sense only to reduce each quadruple to the coordinates relevant to the check against dupes. There is no reason to consider only the first 3 quadruples from <code>list2</code> for the check, though. Please understand that your attempt to edit my answer accordingly was rejected for a reason.</span>
