<div class="post-text" itemprop="text">
<p>I have implemented a simple <a href="https://docs.python.org/3/library/http.server.html" rel="nofollow">HTTP server</a> and a client. The latter issues a PUT request using the <a href="http://docs.python-requests.org/en/master/api/" rel="nofollow">requests library</a>, sending some arbitrary JSON and then exits.</p>
<p>When I start the server, and then run the client, both the server and the client block. The server however appears to not have gone through the entire handler function yet.</p>
<p>This is what I get on server side:</p>
<pre><code>$ python3 server.py
PUT / HTTP/1.1
</code></pre>
<p>That is, after printing the request line, the content JSON string is not printed. At this point both client and server block for some reason.</p>
<p>Interestingly, when I trigger a <code>KeyboardInterrupt</code> to the client, the server proceeds:</p>
<pre><code>$ python3 server.py
PUT / HTTP/1.1
b'{"content": "Hello World"}'
127.0.0.1 - - [25/Feb/2016 11:52:54] "PUT / HTTP/1.1" 200 -
</code></pre>
<p>My questions:</p>
<ul>
<li>Why is it necessary to kill the client to let the server proceed?</li>
<li>Am I using any of these components the wrong way?</li>
<li>How can I make client and server to operate (nearly) instantaneously?</li>
</ul>
<hr/>
<p>This is the code of the HTTP server. It only handles PUT requests. It prints the request line and the content data and responds using the success code to the client:</p>
<pre><code>import http.server

class PrintPUTRequestHandler(http.server.BaseHTTPRequestHandler):
    def do_PUT(self):
        print(self.requestline)
        print(self.rfile.read())
        self.send_response(200)
        self.end_headers()

server_address = ('', 8000)
httpd = http.server.HTTPServer(server_address, PrintHTTPRequestHandler)
httpd.serve_forever()
</code></pre>
<p>This is the HTTP client. It is intended to connect to the server, write the request and return as soon as possible (but it doesn't):</p>
<pre><code>import requests

server_address = "http://127.1:8000"
data = '{"content": "Hello World"}'
requests.put(server_address, data, headers={"Content-type": "application/json"})
</code></pre>
<p>This is how I run it after the server has started (no output observable):</p>
<pre><code>python client.py
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The server blocks both itself and the client on this line:</p>
<pre><code>print(self.rfile.read())
</code></pre>
<p>That happens because you didn't specify the amount of data to be read so the server reads the input stream until it is closed. And in your case the input stream is closed once you kill the client.</p>
<p>Remember that the server doesn't know a priori when the streaming of data ends because you may want to send data chunk by chunk (for example when you send big files).</p>
<p>The size of request should be passed in <code>Content-Length</code> header so this is what you should do:</p>
<pre><code>length = int(self.headers['Content-Length'])
print(self.rfile.read(length))
</code></pre>
<p>That's assuming that the length is small enough to fit in your memory (and in your case it is).</p>
</div>
