<div class="post-text" itemprop="text">
<p>I have a Python code like this,</p>
<pre><code>pyg = 'ay'

original = raw_input('Enter a word:')

if len(original) &gt; 0 and original.isalpha():
    word = original.lower()
    first = word[0]
    new_word = word+first+pyg
    new_word[1:]
    print original
else:
    print 'empty'
</code></pre>
<p>The output of variable "new_word" should be "ythonpay", but now the new_word contains "pythonpay". Could anyone let me know what is the mistake i am doing here.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are not assigning the result of the slice <code>new_word[1:]</code> to anything. You could just do the slice on your previous line, e.g.:</p>
<pre><code>new_word = word[1:]+first+pyg
</code></pre>
<p>What version of python are you using, Python3 introduces a new unpacking syntax that makes this quite easy:</p>
<pre><code>first, *word = original.lower()
new_word = word+first+pyg
</code></pre>
<p>No need to slice because the <code>*</code> assignment already separated the string.</p>
</div>
<div class="post-text" itemprop="text">
<p>You say <code>new_word[1:]</code> but you aren't doing anything with it.  Change that to <code>new_word = new_word[1:]</code>.  <a href="https://docs.python.org/2.3/whatsnew/section-slices.html" rel="nofollow">Slicing</a> creates a copy of the list with whatever items you decide.  In your case it creates a list of all items except the first.  It does not change the original list, however, so you need to assign <code>new_word</code> to it.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is with the indexing and what you are printing.</p>
<p>In your code <code>new_word = word+first+pyg</code> returns the original word itself as the first part, you need it to include all of the string except the first letter. That you can achieve by using <code>word[1:]</code> i.e all characters after the first (or 0th) index of the string. </p>
<pre><code>pyg = 'ay'

original = raw_input('Enter a word:')

if len(original) &gt; 0 and original.isalpha():
    word = original.lower()
    first = word[0]
    # Here we take all the letters after the first letter.
    rest = word[1:]
    new_word = rest + first + pyg
    print new_word
else:
    print 'empty'
</code></pre>
<p>The above will output "ythonpay" for python.</p>
</div>
<span class="comment-copy">I did not know about that <code>*</code>.  Do you happen to know of somewhere I can learn more about that?</span>
<span class="comment-copy">Got it Sir, this solved the problem now i am getting 'ythonpay"</span>
<span class="comment-copy">All changes to the python language are detailed in PEPs (Python Enhancement Proposals). The <code>unpacking operator</code> is covered <a href="https://www.python.org/dev/peps/pep-3132/" rel="nofollow noreferrer">PEP 3132</a>. It is covered in the <a href="https://docs.python.org/3/reference/simple_stmts.html#grammar-token-assignment_stmt" rel="nofollow noreferrer">assignment statement</a> in the standard documentation but it just refers you to the above PEP. Argument unpacking has been in the language for a while, e.g. <code>func(*args)</code>.</span>
<span class="comment-copy">For example consider, I am giving python as my input which is the word here. So the variable first points to 'p' and my new_word should be set equal to the slice from the 1st index all the way to the end of new_word. So I am using [1:len(new_word)] to do this. So what might be my mistake here</span>
<span class="comment-copy"><code>new_word[1:]</code> returns a list of all items except the first.  It does not change the original list.  That is why you need to redefine <code>new_word</code> so that <i>it</i> will be all of the items except the first.</span>
