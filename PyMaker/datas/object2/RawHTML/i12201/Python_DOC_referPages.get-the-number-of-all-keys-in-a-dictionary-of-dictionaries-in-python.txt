<div class="post-text" itemprop="text">
<p>I have a dictionary of dictionaries in Python 2.7.</p>
<p>I need to quickly count the number of all keys, including the keys within each of the dictionaries.</p>
<p>So in this example I would need the number of all keys to be 6:</p>
<pre><code>dict_test = {'key2': {'key_in3': 'value', 'key_in4': 'value'}, 'key1': {'key_in2': 'value', 'key_in1': 'value'}}
</code></pre>
<p>I know I can iterate through each key with for loops, but I am looking for a quicker way to do this, since I will have thousands/millions of keys and doing this is just ineffective:</p>
<pre><code>count_the_keys = 0

for key in dict_test.keys():
    for key_inner in dict_test[key].keys():
       count_the_keys += 1

# something like this would be more effective
# of course .keys().keys() doesn't work
print len(dict_test.keys()) * len(dict_test.keys().keys())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Keeping it Simple</strong></p>
<p>If we know all the values are dictionaries, and do not wish to check that any of their values are also dictionaries, then it is as simple as:</p>
<pre><code>len(dict_test) + sum(len(v) for v in dict_test.itervalues())
</code></pre>
<p>Refining it a little, to actually check that the values are dictionaries before counting them:</p>
<pre><code>len(dict_test) + sum(len(v) for v in dict_test.itervalues() if isinstance(v, dict))
</code></pre>
<p>And finally, if you wish to do an arbitrary depth, something like the following:</p>
<pre><code>def sum_keys(d):
    return (0 if not isinstance(d, dict) 
            else len(d) + sum(sum_keys(v) for v in d.itervalues())

print sum_keys({'key2': {'key_in3': 'value', 'key_in4': 'value'}, 
                'key1': {'key_in2': 'value', 
                         'key_in1': dict(a=2)}})
# =&gt; 7
</code></pre>
<p>In this last case, we define a function that will be called recursively.  Given a value <code>d</code>, we return either:</p>
<ul>
<li><code>0</code> if that value is not a dictionary; or</li>
<li>the number of keys in the dictionary, plus the total of keys in all of our children.</li>
</ul>
<p><strong>Making it Faster</strong></p>
<p>The above is a succinct and easily understood approach.  We can get a little faster using a generator:</p>
<pre><code>def _counter(d):
    # how many keys do we have?
    yield len(d)

    # stream the key counts of our children
    for v in d.itervalues():
        if isinstance(v, dict):
            for x in _counter(v):
                yield x

def count_faster(d):
    return sum(_counter(d))
</code></pre>
<p>This gets us a bit more performance:</p>
<pre><code>In [1]: %timeit sum_keys(dict_test)
100000 loops, best of 3: 4.12 µs per loop

In [2]: %timeit count_faster(dict_test)
100000 loops, best of 3: 3.29 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about </p>
<pre><code>n = sum([len(v)+1 for k, v in dict_test.items()])
</code></pre>
<p>What you are doing is iterating over all keys k and values v. The values v are your subdictionaries. You get the length of those dictionaries and add one to include the key used to index the subdictionary.</p>
<p>Afterwards you sum over the list to get the complete number of keys.</p>
<p>EDIT:</p>
<p>To clarify, this snippet works only for dictionaries of dictionaries as asked. Not dictionaries of dictionaries of dictionaries...<br/>
So do not use it for nested example :)</p>
</div>
<div class="post-text" itemprop="text">
<p>As a more general way you can use a recursion function and generator expression:</p>
<pre><code>&gt;&gt;&gt; def count_keys(dict_test):
...     return sum(1+count_keys(v) if isinstance(v,dict) else 1 for _,v in dict_test.iteritems())
... 
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; dict_test = {'a': {'c': '2', 'b': '1', 'e': {'f': {1: {5: 'a'}}}, 'd': '3'}}
&gt;&gt;&gt; 
&gt;&gt;&gt; count(dict_test)
8
</code></pre>
<p><em>Note</em>: In python 3.X use <code>dict.items()</code> method instead of <code>iteritems()</code>.</p>
<p>A benchmark with accepted answer which shows that this function is faster than accepted answer:</p>
<pre><code>from timeit import timeit

s1 = """
def sum_keys(d):
    return 0 if not isinstance(d, dict) else len(d) + sum(sum_keys(v) for v in d.itervalues())

sum_keys(dict_test)
"""

s2 = """
def count_keys(dict_test):
    return sum(1+count_keys(v) if isinstance(v,dict) else 1 for _,v in dict_test.iteritems())

count_keys(dict_test)
   """

print '1st: ', timeit(stmt=s1,
                      number=1000000,
                      setup="dict_test = {'a': {'c': '2', 'b': '1', 'e': {'f': {1: {5: 'a'}}}, 'd': '3'}}")
print '2nd : ', timeit(stmt=s2,
                       number=1000000,
                       setup="dict_test = {'a': {'c': '2', 'b': '1', 'e': {'f': {1: {5: 'a'}}}, 'd': '3'}}")
</code></pre>
<p>result:</p>
<pre><code>1st:  4.65556812286
2nd :  4.09120802879
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a generator function and the <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator" rel="nofollow"><code>yield from</code></a> syntax new in Python 3.x. This will work for an arbitrary nested dictionary</p>
<pre><code>&gt;&gt;&gt; from collections import Mapping
&gt;&gt;&gt; def count_keys(mydict):
...     for key, value in mydict.items():
...         if isinstance(value, Mapping):
...             yield from count_keys(value)
...     yield len(mydict)
... 
&gt;&gt;&gt; dict_test = {'key2': {'key_in3': 'value', 'key_in4': 'value'}, 'key1': {'key_in2': 'value', 'key_in1': 'value'}}
&gt;&gt;&gt; sum(count_keys(dict_test))
6
</code></pre>
<p>In Python 2.x you need a to do this:</p>
<pre><code>&gt;&gt;&gt; def count_keys(mydict):
...     for key, value in mydict.items():
...         if isinstance(value, Mapping):
...             for item in count_keys(value):
...                 yield 1
...         yield 1
... 
&gt;&gt;&gt; sum(count_keys(dict_test))
6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Something like:</p>
<p><code>print len(dict_test) + sum(len(v) for v in dict_test.values())</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is the recursive function to find the nested dictionaries' total number of keys...</p>
<pre><code>s=0
def recurse(v):
   if type(v)==type({}):
     for k in v.keys():
      global s
      s+=1
      recurse(v[k])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try using pandas DataFrame for that:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; data = {'1': {'2': 'a', '3': 'b'}, '4': {'5': 'c', '6': 'd'}, '7': {'5': 'x'}}
&gt;&gt;&gt; df = pd.DataFrame(data)
&gt;&gt;&gt; print (df.count().sum() + len(df.columns))  # 8
</code></pre>
<p>The <code>pd.DataFrame(data)</code> line will convert your dictionary to a N x M matrix, where N is number of "parent" keys and M is the number of unique children keys:</p>
<pre><code>     1    4    7
2    a  NaN  NaN
3    b  NaN  NaN
5  NaN    c    x
6  NaN    d  NaN
</code></pre>
<p>For each [row, column] you have a value or NaN. You just need to count the non <code>NaN</code> values, which will give you the number of children keys and add <code>len(df.columns)</code>, which stands for the number of columns (i.e. parent keys).</p>
</div>
<div class="post-text" itemprop="text">
<p>recursive function:</p>
<pre><code>def count_keys(some_dict):
    count = 0
    for key in some_dict:
        if isinstance(some_dict[key], dict):
            count += count_keys(some_dict[key])
        count += 1
    return count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>len(dict) will return the number of keys in a dictionary, so, assuming you know how nested it is and that all the values are dictionaries:</p>
<pre><code>counter = len(outer_dict)
for v in outer_dict.values :
    counter += len(v)
</code></pre>
<p>You can wrap this in a list comprehension :</p>
<pre><code>counter = len(outer_dict)
counter += sum([len(inner_dict) for inner_dict in outer_dict.values])
</code></pre>
<p>which is probably the most pythonic. You can extend it as :</p>
<pre><code>counter = len(outer_dict)
counter += sum([len(inner_dict) if isinstance(inner_dict, dict) else 0 for inner_dict in outer_dict.values])
</code></pre>
<p>but I tend to think that this is fairly unreadable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this,</p>
<pre><code>l = len(dict_test)
for k in dict_test:
    l += len(dict_test[k])
</code></pre>
</div>
<span class="comment-copy">Although you don't ask for this, if you wanted the number of <i>distinct</i> keys then you could do something like <code>len(set(itertools.chain(dict_test, *dict_test.values())))</code></span>
<span class="comment-copy">Thanks, this is very helpful. Especially the performance bit.</span>
<span class="comment-copy">This doesn't count "parent" keys.</span>
<span class="comment-copy">which is why I add one to every length</span>
<span class="comment-copy">This is a dictionary of a dictionary of a dictionary. ivan_bilan asked for a dictionary of a dictionary...</span>
<span class="comment-copy">@MarounMaroun: ​​​​​​​​​​​​​​​Wait, OP didn't mention about <i>more nested examples</i>, right? OP's code will also fail if the dict is like this.</span>
<span class="comment-copy">@KevinGuan if that's the case, then this answer is correct.</span>
<span class="comment-copy">This also fails to: <code>dict_test = { "a": { "b": "1", "c": "2", "d": "3", "e": {"f": 1} }}</code></span>
<span class="comment-copy">@Idos Yep it's for a 2 level type.</span>
<span class="comment-copy">@Idos The OP only asked about a dictionary of dictionaries not an arbitrary nesting.</span>
<span class="comment-copy">@Idos Checkout the general answer.</span>
<span class="comment-copy">Great gig , +1 =]</span>
<span class="comment-copy">Doesn't work for more nested examples, try this - {1: {1: {1: {1: 2}}, 2: 3}, 2: {1: 2, 2: 3}}</span>
<span class="comment-copy">@AlokThakur should it? I mean it was not requested.</span>
<span class="comment-copy">it is printing 6 for the dictionary I mentioned above, are you getting different result ?</span>
<span class="comment-copy">@AlokThakur the question is about only one level deep, nothing is said about nesting. Read it.</span>
<span class="comment-copy">@AlokThakur I'm writing those comments because this answer 100% satisfies what OP was asking and your comments are irrelevant. If you have a question how to implement it for more levels, please ask it. I would say you need recursive calls.</span>
<span class="comment-copy">Wouldn't this be inefficient/memory intensive, as the OP said the dictionaries could have thousands/millions of entries?  I think the "empty" values (of which there would be a lot) may eat up a lot of wasted memory, but I am not completely sure how pandas stores those.</span>
<span class="comment-copy">@Matthew There sure would be one big matrix created. I am interested in the answer to this too.</span>
<span class="comment-copy">OP didn't mention anything about memory but the processing speed ;)</span>
