<div class="post-text" itemprop="text">
<p>I have the following data:</p>
<pre><code>names = ['foo','bar','baz', 'spam', 'ham', 'jam']

indices =[0,2,3,4]

size = 3
</code></pre>
<p>and want to create a list of the names which index is in <code>indices</code>. The list must have the size specified in the variable <code>size</code>.</p>
<p>I could not achieve it by doing this (wrong length):</p>
<pre><code>selected_names = []
selected_names = [names[i] for i in indices if len(selected_names) &lt;= size]
# Out[5]: ['foo', 'baz', 'spam', 'ham']
</code></pre>
<p>and I don't like this solution because declaring the empty list at the beginning is not elegant.</p>
<p>I can do this:</p>
<pre><code>selected_names = [names[i] for x,i in  enumerate(indices) if x &lt;= size]
</code></pre>
<p>but that's a bit unreadable and the list length is still wrong. </p>
<p>Is there a correct and more beautiful way to create that list? maybe something like this?</p>
<pre><code>#pseudo code
selected_names = [names[i] for i in indices if list_current_index &lt; size]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>enumerate</code> wouldn't even solve this since it would cause you to stop when you'd <em>pulled</em> <code>size</code> elements, not when you'd <em>kept</em> <code>size</code> elements. The only reason it seems to work is that you use a test for <code>&lt;= size</code> (which actually keeps <code>size + 1</code> elements), and your <code>indices</code> happens to be one element larger than <code>size</code>. If <code>indices</code> was larger, or <code>size</code> smaller, your test wouldn't work as intended.</p>
<p>If the goal is to keep <code>size</code> elements, without processing more elements than needed, then the simplest approach (assuming you don't mind slicing to create a small intermediate <code>list</code>, which is usually okay) is just:</p>
<pre><code>selected_names = [names[i] for i in indices[:size]]
</code></pre>
<p>If <code>indices</code> and <code>size</code> are huge, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow"><code>itertools.islice</code></a> with a generator expression to avoid the intermediate slice, using less memory, but somewhat more CPU:</p>
<pre><code>import itertools

selected_names = [names[i] for i in itertools.islice(indices, size)]
</code></pre>
<p>The fastest option I can find, avoiding any explicit looping at all, is using the <a href="https://docs.python.org/3/library/operator.html" rel="nofollow"><code>operator</code> module</a>, though it involves temporaries for argument passing, which is probably a bad idea if <code>size</code> is ever going to be huge (10s of thousands and up):</p>
<pre><code>import operator

selected_names = operator.itemgetter(*indices[:size])(names)
</code></pre>
<p>This creates an <code>itemgetter</code> callable that will look up the first <code>size</code> elements from <code>indices</code>, then immediately calls it on <code>names</code>, returning a <code>tuple</code> of all the values (wrap the <code>itemgetter</code> call in <code>list</code> if you need a mutable <code>list</code> result instead of a <code>tuple</code>). It also avoids all Python level loops in CPython; a loop still occurs at the C layer in CPython, but a loop at the C layer runs a lot faster than any loop at the Python layer. For simple <code>ipython</code> <code>%timeit</code> tests, the <code>operator.itemgetter</code> approach won, taking ~24% less time than slice + <code>list</code> comprehension (which in turn was about 9% faster than <code>islice</code> + <code>list</code> comprehension). For larger inputs (I just multiplied <code>indices</code> and <code>size</code> by 100), <code>operator.itemgetter</code> wins by a factor of 3x (slice still beats <code>islice</code>, but by a meaningless margin; the overhead in <code>islice</code> is mostly in setup, and doesn't increase meaningfully as the number of items sliced goes up).</p>
<p>All are equivalent to:</p>
<pre><code>selected_names = [names[i] for i in indices][:size]
</code></pre>
<p>except they don't populate the complete <code>list</code> first, then cut it down to <code>size</code>; they get enough entries and stop immediately.</p>
</div>
<span class="comment-copy">Perhaps you should use <code>enumerate()</code>. It's Pythonic.</span>
<span class="comment-copy">In your "I've achieved it by doing this code", your <code>if</code> condition did nothing. <code>selected_names</code> remains empty until the list comprehension finishes, so the check always says "Yup, the length of an empty list is <code>&lt;= size</code>." And of course, you say you want a final <code>list</code> with <code>size</code> elements, but testing <code>&lt;= size</code> would actually get you <code>size+1</code> elements.</span>
<span class="comment-copy">@ShadowRanger thx for letting me know. I'll remove the errors from the question.</span>
