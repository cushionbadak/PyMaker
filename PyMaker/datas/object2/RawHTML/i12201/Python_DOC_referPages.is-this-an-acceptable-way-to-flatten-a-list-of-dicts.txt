<div class="post-text" itemprop="text">
<p>I'm looking at a proper way to flatten something like this</p>
<pre><code>a = [{'name': 'Katie'}, {'name': 'Katie'}, {'name': 'jerry'}]
</code></pre>
<p>having</p>
<pre><code>d = {}
</code></pre>
<p>Using a double map like this:</p>
<pre><code>map(lambda x: d.update({x:d[x]+1}) if x in d else d.update({x:1}),map(lambda x: x["name"] ,a))
</code></pre>
<p>I get the result i want:</p>
<pre><code>&gt;&gt;&gt; d
{'jerry': 1, 'Katie': 2}
</code></pre>
<p>But I feel it could be done better..not with list comprehensions tho , I feel that's what we have map reduce.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't really like your solution because it is hard to read and has sideeffects.</p>
<p>For the sample data your provided, using a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>Counter</code></a> (which is a subclass of the built-in dictionary) is a better approach.</p>
<pre><code>&gt;&gt;&gt; Counter(d['name'] for d in a)
Counter({'Katie': 2, 'jerry': 1})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a Counter and keep it functional:</p>
<pre><code>In [46]: from collections import  Counter

In [47]: from operator import itemgetter

In [48]: Counter(map(itemgetter("name") ,a))
Out[48]: Counter({'Katie': 2, 'jerry': 1})
</code></pre>
<p>For python 2 you would use <code>itertools.imap</code> :</p>
<pre><code>Counter(itertools.imap(itemgetter("name") ,a))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this case <code>reduce()</code> would be more appropriate then <code>map()</code>:</p>
<pre><code>&gt;&gt;&gt; def count_names(d, x):
...     d[x['name']] = d.get(x['name'], 0) + 1
...     return d
...
&gt;&gt;&gt; reduce(count_names, a, {})
{'jerry': 1, 'Katie': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import defaultdict
val = defaultdict(int)
for names in a:
    val[names['name']] += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Again using Counter, but extracting the dictionary.</p>
<pre><code>&gt;&gt;&gt; dict(Counter([i['name'] for i in a]))
{'Katie': 2, 'jerry': 1}
</code></pre>
<p>Here's a more convoluted method using groupby:</p>
<pre><code>from itertools import groupby

&gt;&gt;&gt; dict((name, len(list(totals))) for name, totals in groupby([i["name"] for i in a]))
{'Katie': 2, 'jerry': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>for loop is your friend :)</p>
<pre><code>a = [{'name': 'Katie'}, {'name': 'Katie'}, {'name': 'jerry'}]
result = {}
for data in a:
    if data['name'] not in result:
         result[data['name']] = 0
    result[data['name']] += 1
print result
</code></pre>
</div>
<span class="comment-copy">can there be more than one key, or is it always 'name'?</span>
<span class="comment-copy">always name ... i just want to count duplicated names coming in that format... if you know what i mean</span>
<span class="comment-copy">has any of the answers solved your problem sufficiently?</span>
<span class="comment-copy">very elegant thank you very much!</span>
<span class="comment-copy">Also, one last q, when you mean side effects are you referring to violating the functional programming approach by modifying a variable (d in this case) outside the scope?</span>
<span class="comment-copy">@JeronimoGarcia, in python unless you are using what is in the container don't create one, i.e  don't  <code>my_list=[];[my_list.append(I + foo ) for i in blah]</code></span>
<span class="comment-copy">I meant that your lambda function returns <code>None</code> and that your call to <code>map</code> returns <code>[None, None, None]</code> but you never use either of that return values, but solely use the map for its sideeffect of updating the dictionary.</span>
<span class="comment-copy">Aren't comprehensions preferred to <code>map</code> - see BDFL's <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow noreferrer">opinion</a></span>
<span class="comment-copy">@AChampion, map is faster and widely used in python, the main argument from what I see in your link  is preparing a lambda which I rarely use, if I cannot use map without resorting to a lambda then I rarely do. I think <code>map(float, lst)</code> is as readable as <code>[float(s) for s in lst]</code>.</span>
<span class="comment-copy">I like this one too</span>
<span class="comment-copy">especially the default argument on get() which i didn't know it was possible!</span>
<span class="comment-copy">Basically the same as Counter, but more code</span>
<span class="comment-copy">why not <code>dict(Counter(i['name'] for i in a))</code> if you wanted a regular dict?</span>
<span class="comment-copy">I new there must have been a better way.  I'm surprised there isn't a <code>.to_dict()</code> method for Counter.</span>
<span class="comment-copy">@Alexander well, a Counter <i>is-a</i> dict, so I would not expect such a method.</span>
<span class="comment-copy">subclassed from a dict, yes.</span>
