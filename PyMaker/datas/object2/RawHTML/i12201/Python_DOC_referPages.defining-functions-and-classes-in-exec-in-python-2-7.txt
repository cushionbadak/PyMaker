<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/29979313/python-weird-nameerror-name-is-not-defined-in-an-exec-environment">Python: weird “NameError: name … is not defined” in an 'exec' environment</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>You can define both classes and functions in exec'd code without problems:</p>
<pre><code>my_func = """
    def test_func():
        print "Hi from test_func!"
    """
my_class = """
    class test_class:
        def __init__(self):
            self.a = "a"
    """

def call_func():
    exec(my_func)
    test_func()

def call_class():
    exec(my_class)
    a = test_class()

&gt;&gt;&gt; call_func()
Hi from test_func!

&gt;&gt;&gt; call_class()
a
</code></pre>
<p>However, defining both a class and a function that uses that class in exec'd code results in a <code>NameError</code>, because the class doesn't end up in the correct scope:</p>
<pre><code>my_class_fun = """
class test_class_2:
    def __init__(self):
        self.a = "a"

def test_func_2():
    a = test_class_2()
    print(a.a)
"""

def test_2():
    exec(my_class_fun)
    test_func_2()

&gt;&gt;&gt; test_2()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in test_2
  File "&lt;string&gt;", line 7, in test_func_2
NameError: global name 'test_class_2' is not defined
</code></pre>
<p>Passing <code>globals()</code> as the second argument to <code>exec</code> so that everything ends up in the global namespace fixes this problem.</p>
<p>My question is, why is that necessary? <code>test_class_2</code> and <code>test_func_2</code> seem like they should both be local to <code>test_2</code>, so why doesn't <code>test_func_2</code> have access to <code>test_class_2</code>?</p>
<p>EDIT:</p>
<p>Fundamentally, my question is why is <code>test_2()</code> above different from something like this code, which works fine:</p>
<pre><code>def test_func():
   class test_class:
     def __init__(self):
       self.a = "a"
   def test_func_inner():
     c = test_class()
     print(c.a)
   test_func_inner()

&gt;&gt;&gt; test_func()
a
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because your class (and function) not in global space</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; def test_2():
...     exec(my_class_fun)
...     global test_class_2
...     global test_func_2
...     test_func_2()
... 
&gt;&gt;&gt; test_2()
a
</code></pre>
</div>
<span class="comment-copy">The question I marked as duplicate uses slightly different exec-ed code, but I think the answer answers your question as well.  Please clarify your question if you think something remains unanswered.</span>
<span class="comment-copy">That question uses Python 3, whereas I'm using 2.7. I know that the exec function works very differently in 3 (i.e. it's an actual function, whereas in 2 it's a statement), but I don't know if that changes the answer. It's entirely possible that the underlying mechanism that they're both getting at is the same.</span>
<span class="comment-copy">The key point is that when globals and locals are different, "the code is executed as if it were embedded in a class definition", and that is [<a href="https://docs.python.org/3/library/functions.html#exec](unchanged)" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#exec](unchanged)</a> in Python 3.</span>
<span class="comment-copy">Right, but my question is why do they need to be? Why isn't it good enough for them to both be local to test_2?</span>
<span class="comment-copy">@seaotternerd because you run exec in local space of test_2 and test_func_2 don't know where get test_class_2, when we put test_class_2 in global space, then function test_func_2 know where get test_class_2</span>
