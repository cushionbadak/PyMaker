<div class="post-text" itemprop="text">
<p>I have a python code which uses multiprocessing Pool map. I am spawning multiple children from map, each of them reads a separate file, and I collect them in the end. My goal is to have a pandas dataframe in the end that is a concatenation of all the output from the children, with duplicates dropped. I use this dataframe to do more processing (the rest of the code seems unrelated to the question I ask here, so I am omitting that part for brevity). This code runs periodically at the end of the week with new input files to read every time. Sometimes there are errors in the files children read, like null values in integer columns, or missing files, etc.. If any of these errors occur, I want the main script to die, ideally as soon as possible. I do not know how to make this happen in the most efficient way.</p>
<p>I have tried, in turn:
1-Making the child die by a raising SystemExit(1) if it encounters an error. I couldn't make parent die.
2-Making child return an empty value or pandas dataframe in case of an error by try except blocks. I couldn't detect it properly in the parent.
3-Using map_async with callback functions instead of map. </p>
<p>The last one seems to work. However, I am not sure if this is the correct and most efficient way of doing this, as I do not use any output from the error callback function. Any comments and suggestions are appreciated.</p>
<p>Edit: </p>
<p>Sample input file: a.txt:</p>
<pre><code>shipmentId,processing_time_epoch
4001,1455408024132
4231,1455408024373
</code></pre>
<p>b.txt:</p>
<pre><code>shipmentId,processing_time_epoch
5001,1455408024132
4231,1455408024373
</code></pre>
<p>Desired final processing_time pandas dataframe: </p>
<pre><code>shipmentId,processing_time_epoch
4001,1455408024132
4231,1455408024373
5001,1455408024132
</code></pre>
<p>My code:</p>
<pre><code>import pandas as pd
import csv,glob,datetime,sys,pdb,subprocess,multiprocessing,io,os,shlex
from itertools import repeat

def myerrorcallback(x):
    print('There seems to be an error in the child. Parent: Please die.')
    return

def mycallback(x):
    print('Returned successfully.')
    return

def PrintException():
    exc_type, exc_obj, tb = sys.exc_info()
    f = tb.tb_frame
    lineno = tb.tb_lineno
    filename = f.f_code.co_filename
    print('EXCEPTION IN ({}, LINE {} ): {} ({})'.format(filename, lineno, exc_obj, exc_type))
    return

# ===================================================================
def Read_Processing_Times_v1(full_path_name):
    try:
        df = pd.read_csv(full_path_name,dtype={'shipmentId': pd.np.int64, 'processing_time_epoch': pd.np.int64}, usecols=['shipmentId','processing_time_epoch'])
        return df.drop_duplicates()
    except:
        print("exception in file "+full_path_name)
        PrintException()
        raise(SystemExit(1))

# ===================================================================
def Read_Processing_Times_v2(full_path_name):
    try:
        df = pd.read_csv(full_path_name,dtype={'shipmentId': pd.np.int64, 'processing_time_epoch': pd.np.int64}, usecols=['shipmentId','processing_time_epoch'])
        return df.drop_duplicates()
    except:
        print("exception in file "+full_path_name)
        PrintException()
    return pd.DataFrame()


# ===================================================================
def Read_Processing_Times_v3(full_path_name):
    df = pd.read_csv(full_path_name,dtype={'shipmentId': pd.np.int64,'processing_time_epoch': pd.np.int64}, usecols=['shipmentId','processing_time_epoch'])
    return df.drop_duplicates()

# ===========================================================================================================================
# Top-level
if __name__ == '__main__':

    mycols = ['shipmentId', 'processing_time_epoch']
    mydtypes = {'shipmentId': pd.np.int64, 'processing_time_epoch': pd.np.int64}

    # The following two files should not give an error:
    # files_to_read=["a.txt","b.txt"]

    # The following two files should give an error, as a2.txt does not exist:
    files_to_read=["a2.txt","b.txt"]

    # version 1: Works with the correct files. Does not work if one of the children has an error: the child dies, the parent does not and waits forever.
    # print("version 1")
    # pool = multiprocessing.Pool(15)
    # processing_times = pool.map(Read_Processing_Times_v1, files_to_read)
    # pool.close()
    # pool.join()
    # processing_times = pd.concat(processing_times,ignore_index=True).drop_duplicates()
    # print(processing_times)


    # version 2: Does not work. Don't know how to fix it. The idea is make child return something, and catch the error in the parent.
    # print("version 2")
    # pool = multiprocessing.Pool(15)
    # processing_times = pool.map(Read_Processing_Times_v2, files_to_read)
    # pool.close()
    # pool.join()
    # if(processing_times.count(pd.DataFrame()) &gt; 0):
    #     print("SLAM times are not read properly.")
    #     raise SystemExit(1)

    # version 3:
    print("version 3")
    pool = multiprocessing.Pool(15)
    processing_times = pool.map_async(Read_Processing_Times_v3, files_to_read,callback=mycallback,error_callback=myerrorcallback)
    pool.close()
    pool.join()
    processing_times = processing_times.get()
    processing_times = pd.concat(processing_times,ignore_index=True).drop_duplicates()


    print("success!")

    # Do more processing with processing_times after this line...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you could accomplish what you want by using the concurrent.futures module (<a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow">https://docs.python.org/3/library/concurrent.futures.html</a>).  Below is an example from the doc page that I modified to be closer to your problem.  In the example if <code>work_func</code> returns <code>False</code> that is considered an error and the program will terminate.</p>
<pre><code>import sys
import concurrent.futures
import random
import time


def work_func(input_val):
    """
    Do some work.  Here a False value would mean there is an error
    """
    time.sleep(0.5)
    return random.choice([True, True, True, True, False])


if __name__ == "__main__":
    # We can use a with statement to ensure processes are cleaned up promptly
    with concurrent.futures.ProcessPoolExecutor(max_workers=5) as executor:
        # Start the load operations and mark each future with its input value
        future_to_result = {executor.submit(work_func, val): val for val in range(30)}

        # iterate over the futures as they become available
        for future in concurrent.futures.as_completed(future_to_result):

            #  get the input value from the dict
            input_val = future_to_result[future]

            # now retrieve the result from the future
            try:
                data = future.result()
            except Exception as exc:
                print(input_val, data)
                print('Something exceptional happend')
            else:
                print(input_val, data)
                if not data:
                    print('Error - exiting')
                    sys.exit(1)
</code></pre>
<p>Sample output:</p>
<pre><code>0 True
1 True
2 True
3 False
Error - exiting
</code></pre>
</div>
<span class="comment-copy">By the way, my python version is 3.3.</span>
<span class="comment-copy">what you want to do exactly? please explain your expected output</span>
<span class="comment-copy">edited! Let me know if it is more clear now</span>
