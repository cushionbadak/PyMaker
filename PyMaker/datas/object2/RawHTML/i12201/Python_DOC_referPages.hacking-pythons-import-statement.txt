<div class="post-text" itemprop="text">
<p>I'm building a Python module for a fairly specific purpose. What I'd like to do with this is get more functionality behind <code>import</code>ing things from it. </p>
<p>I'd like to have a setup by which saying <code>from my_module import foo</code> would run a function and pass the string <code>"foo"</code>. This function would return the object that should be imported. </p>
<p>For example, maybe I want to make a cloud-based import system. I'd like to store community scripts in the cloud, and then download them when a user tries to import them. </p>
<p>Maybe I use the code <code>from cloud import test_module</code>. This would check a cache to decide whether <code>test_module</code> had been downloaded. If so, it would return that module. If not, it would download the module before importing it. </p>
<p>How can I accomplish something like this in Python, by which a dynamic range of submodules could be seamlessly <code>import</code>ed from the cloud? </p>
</div>
<div class="post-text" itemprop="text">
<p>Full featured support for what you ask probably requires a bunch of complicated code using <code>importlib</code> and hooking into various parts of the import machinery. However, a more limited solution can be implemented with just a single custom class that pretends to be a module.</p>
<p>When you import a module, Python first checks in the <code>sys.modules</code> dictionary to see if the module is a key. If so, it returns the value associated with the key. It does this regardless of what the value is, so you can put any kind of object in <code>sys.modules</code> and Python will treat it like a module. A module's code can even replace its own entry in <code>sys.modules</code>, and the replacement will be used even the first time it is <code>import</code>ed!</p>
<p>So, to implement your fancy module that downloads other modules on demand, replace the module itself with an instance of a custom class, and write that class a <code>__getattr__</code> or <code>__getattribute__</code> method that does the work you want.</p>
<p>Here's a trivial example module that returns a string for any attribute you look for in it. The string will always be the same as the requested attribute name. In your code, you'd want to do your fancy web-cache lookups and downloading, and then return the fetched module object instead of just returning a string.</p>
<pre><code>class FakeModule(object):
    def __getattribute__(self, name):
        return name

import sys
sys.modules[__name__] = FakeModule()
</code></pre>
<p>On my system I've saved that as <code>fakemodule.py</code>. Now if I do <code>from fakemodule import foo</code>, I get <code>foo</code> with the value <code>'foo'</code> in my local namespace.</p>
<p>Note that this only works for one level deep imports. If you do <code>from fakemodule.subpackage import name</code> it will not work because there's no <code>fakemodule.subpackage</code> entry in <code>sys.modules</code>.</p>
</div>
<span class="comment-copy">I'm sure there are ways to do this but I would ask that you don't. Go ahead and open a python terminal and run <code>import this</code>. What does the second line say? <code>Explicit is better than implicit.</code> This is vital to writing good Python. Having a module that does all sorts of weird things in the background without consulting the programmer first is not very Pythonic.</span>
<span class="comment-copy">Ok. Is it better, then, to write a function like <code>cloud.Import("test_module")</code> to replace the built-in import?</span>
<span class="comment-copy">The design pattern you describe here is a decorator. Import runs things in the imported module, but you always get the same know functionality</span>
<span class="comment-copy">If would be best to write custom finders and loaders, using the <code>importlib</code> module. <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer">docs.python.org/3/library/importlib.html</a></span>
<span class="comment-copy">The system you are describing has lots of problems. For one it won't work with out an internet connection, the script calling your library will now need elevated privileges to run since it will now be downloaded and writing things to disk (possibly to the surprise of the user); this could be an issue on a production server. A system like this complicates the standard import mechanism and don't really see any gains or advantages. Will this package reach out the network every time it's run? Even if I already DL'ed the package? How will you manage versioning?</span>
<span class="comment-copy">This is awesome, I had no idea I could do this. This is exactly what I need, thanks.</span>
