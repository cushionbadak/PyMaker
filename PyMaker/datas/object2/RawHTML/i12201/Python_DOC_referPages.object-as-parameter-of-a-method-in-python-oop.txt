<div class="post-text" itemprop="text">
<p>I'm trying to build a simple RPG game to learn more about classes in Python, but I'm struggling with the fight method. The idea is that after both player and monster are created, the method <code>fight</code> would have the parameter <code>enemy</code>, that is the monster the player is fighting.</p>
<p>Here is what I did in the <code>fight</code> (it's inside <code>Player</code>'s class) method:</p>
<pre><code>def fight(self, enemy):
        self.enemy = enemy
        d20 = Dice(20)
        if d20.roll() &gt;= enemy.armor_class:
            print("You hitted %s" % enemy.name)
            enemy.hp -= self._strength
            print("\n%s has %d hp left" % (enemy.name, enemy.hp))
        else:
            print("you missed")
</code></pre>
<p>Here is the call I'm doing right now (in the main file):</p>
<pre><code>player = Fighter()
goblin = Enemy("Goblin", 10, 10, 1, 5)

player.fight(goblin)
</code></pre>
<p>but, whenever I run it, I get the following error:</p>
<pre><code>TypeError: fight() takes 1 positional argument but 2 were given
</code></pre>
<p>Both classes(<code>Player</code> and <code>Enemy</code>) inherit from the <code>Character's</code> class, so what's the deal with this error? Do I need an <code>import</code> from enemy to solve this?</p>
<p><strong>EDIT1</strong> : Above the complete <code>Player</code> class:</p>
<pre><code>class Player(Character):
    def __init__(self, armor_class):
        super().__init__(input("Tell us your name, hero:\n&gt;"), 20, 10, {}, armor_class, 1)
        self.exp = 0
        self._strength = 0
        self._constitution = 0
        self._dexterity = 0
        self._intelligence = 0
        self._wisdom = 0
        self._charisma = 0

    def fight(self, enemy):
        self.enemy = enemy
        d20 = Dice(20)
        if d20.roll() &gt;= enemy.armor_class:
            print("You hitted %s" % enemy.name)
            enemy.hp -= self._strength
            print("\n%s has %d hp left" % (enemy.name, enemy.hp))
        else:
            print("you missed")

    def __str__(self):
        str_info = "\tName: [%s]\tLEVEL: %d\n\tHP: %2d\t\tMP: %2d\n" % (self.name, self.lvl, self.hp, self.mp)
        str_stats = "\t\tSTR: %2d\n\t\tCON: %2d\n\t\tDEX: %2d\n\t\tINT: %2d\n\t\tWIS: %2d\n\t\tCHA: %2d\n" % (
            self._strength, self._constitution, self._dexterity, self._intelligence, self._wisdom,
            self._charisma)
        return str_info + str_stats
</code></pre>
<p>The <code>Fighter</code> class:</p>
<pre><code>class Fighter(Player):
    """
    Fighter class, a strong warrior that uses meele attacks to face his opponents
    """

    def __init__(self):
        super().__init__(armor_class=10)
        self._strength += 2

    def fight(self):
        super().fight()

    def __str__(self):
        return super().__str__()
</code></pre>
<p>And my actual <code>Enemy</code> class:</p>
<pre><code>class Enemy(Character):
    def __init__(self, name, hp, mp, lvl, atk):
        super().__init__(name, hp, mp, {}, 10, lvl)
        self.atk = atk
</code></pre>
<p>My <code>main.py</code> is as follows</p>
<pre><code>from fighter import Fighter
from enemy import Enemy

player = Fighter()
goblin = Enemy("Goblin", 10, 10, 1, 5)

player.fight(goblin)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In <code>Fighter.fight</code> you are using <code>super().fight()</code> which instantiates a new <code>Player</code> object and calls <code>fight()</code> on this new instance. Use <code>self.fight()</code> to call the method on the instance of the Fighter.</p>
<p><s>Never use <code>super()</code> to access methods of the super class.</s> You are inheriting from that class so all methods from the super class are available in the scope of the subclass. 
<code>super()</code>'s purpose is to call the constructor of the super class (__init__()).</p>
<p>Edit: Methods from the superclass can in fact be accessed by using <code>super().method()</code>. The problem here is the wrong number of parameters to the fight() method. (See comments below)</p>
</div>
<span class="comment-copy">Please provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> that actually recreates the issue.</span>
<span class="comment-copy">Are you trying to return somthing from the _<i>init_</i> method of Enemy?</span>
<span class="comment-copy">No, please, take a look at the updated question.</span>
<span class="comment-copy">like <code>def fight(self):         self.fight()</code> ?</span>
<span class="comment-copy">no, either inside Fighter: <code>def fight(self, enemy): self.fight(enemy)</code> or just don't define the fight method inside the Fighter class.</span>
<span class="comment-copy">with the definition of <code>fight()</code> inside the Fighter class you are overriding the definition of <code>fight()</code> in the Player class. The <code>fight()</code> method in the Player class expects 1 parameter, the definition in the Fighter class expects 0 paramters. (excluding <code>self</code>). So you are overriding <code>fight(self, enemy)</code> with <code>fight(self)</code> and that is why the python interpreter tells you <code>fight() takes 1 positional argument but 2 were given</code></span>
<span class="comment-copy">Try to use the general programming paradigm DRY(Don't repeat yourself). Try to implement all functionality that is shared between Enemy and Fighter in the superclass (Character). What you are implying by implementing the <code>fight()</code> method in the Character class is that any Character is able to fight. If different subclasses 'fight' differently try to do most general behaviour in the implementation of the superclass. For example override the Character fight method in the Player class like so: <code>fight(self, enemy): self.fight(enemy); self.what_ever_a_player_instance_does_after_finishing_a_fight()</code></span>
<span class="comment-copy">Of course you can use <code>super</code> to call any method of the parent class. Have a look at the documentaion of <a href="https://docs.python.org/3/library/functions.html?highlight=super" rel="nofollow noreferrer">super</a>: "This is useful for accessing inherited methods that have been overridden in a class." What's wrong here is, that the method in the child class misses the parameters (and in fact you even don't need to redefine the method).</span>
