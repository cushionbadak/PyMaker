<div class="post-text" itemprop="text">
<p>I've made this list; each item is a string that contains commas (in some cases) and colon (always):</p>
<pre><code>dinner = [
    'cake,peas,cheese : No',
    'duck,broccoli,onions : Maybe',
    'motor oil : Definitely Not',
    'pizza : Damn Right',
    'ice cream : Maybe',
    'bologna : No',
    'potatoes,bacon,carrots,water: Yes',
    'rats,hats : Definitely Not',
    'seltzer : Yes',
    'sleeping,whining,spitting : No Way',
    'marmalade : No'
]
</code></pre>
<p>I would like to create a new list from the one above as follows:</p>
<pre><code>['cake : No',
 'peas : No',
 'cheese : No',
 'duck : Maybe',
 'broccoli : Maybe',
 'onions : Maybe',
 'motor oil : Definitely Not',
 'pizza : Damn Right',
 'ice cream : Maybe',
 'bologna : No',
 'potatoes : Yes',
 'bacon : Yes',
 'carrots : Yes',
 'water : Yes',
 'rats : Definitely Not',
 'hats : Definitely Not',
 'seltzer : Yes',
 'sleeping : No Way',
 'whining : No Way',
 'spitting : No Way',
 'marmalade : No']
</code></pre>
<p>But I'd like to know if/ how it's possible to do so in a line or two of efficient code employing primarily Python's higher order functions. I've been attempting it:</p>
<p><code>reduce(lambda x,y: x + y, (map(lambda x: x.split(':')[0].strip().split(','), dinner)))</code></p>
<p>...produces this:</p>
<pre><code>['cake',
 'peas',
 'cheese',
 'duck',
 'broccoli',
 'onions',
 'motor oil',
 'pizza',
 'ice cream',
 'bologna',
 'potatoes',
 'bacon',
 'carrots',
 'water',
 'rats',
 'hats',
 'seltzer',
 'sleeping',
 'whining',
 'spitting',
 'marmalade']
</code></pre>
<p>...but I'm struggling with appending the piece of each string after the colon back onto each item.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you really need it as a list of strings vs. a dictionary, which looks like a better data structure.</p>
<p>By simplify using comprehensions you can do this:</p>
<pre><code>&gt;&gt;&gt; [[x+':'+y for x in i.split(',')]
...  for i, y in map(lambda l: map(str.strip, l.split(':')), dinner)]
[['cake:No', 'peas:No', 'cheese:No'],
 ['duck:Maybe', 'broccoli:Maybe', 'onions:Maybe'],
 ['motor oil:Definitely Not'],
 ...
 ['marmalade:No']]
</code></pre>
<p>Now just <code>add</code> up the lists:</p>
<pre><code>&gt;&gt;&gt; from operator import add
&gt;&gt;&gt; reduce(add, ([x+':'+y for x in i.split(',')]
...              for i, y in map(lambda l: map(str.strip, l.split(':')), dinner)), [])
['cake:No',
 'peas:No',
 'cheese:No',
 'duck:Maybe',
 ...
 'marmalade:No']
</code></pre>
<p>Or just flatten the list:</p>
<pre><code>&gt;&gt;&gt; [a for i, y in map(lambda l: map(str.strip, l.split(':')), dinner) 
...  for a in (x+':'+y for x in i.split(','))]
['cake:No',
 'peas:No',
 'cheese:No',
 'duck:Maybe',
 ...
 'marmalade:No']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would create a dict using, <code>zip</code>, <code>map</code> and <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="noreferrer"><code>itertools.repeat</code></a>:</p>
<pre><code>from itertools import repeat


data = ({k.strip(): v.strip() for _k, _v in map(lambda x: x.split(":"), dinner)
     for k, v in zip(_k.split(","), repeat(_v))})

from pprint import pprint as pp

pp(data)
</code></pre>
<p>Output:</p>
<pre><code>{'bacon': 'Yes',
 'bologna': 'No',
 'broccoli': 'Maybe',
 'cake': 'No',
 'carrots': 'Yes',
 'cheese': 'No',
 'duck': 'Maybe',
 'hats': 'Definitely Not',
 'ice cream': 'Maybe',
 'marmalade': 'No',
 'motor oil': 'Definitely Not',
 'onions': 'Maybe',
 'peas': 'No',
 'pizza': 'Damn Right',
 'potatoes': 'Yes',
 'rats': 'Definitely Not',
 'seltzer': 'Yes',
 'sleeping': 'No Way',
 'spitting': 'No Way',
 'water': 'Yes',
 'whining': 'No Way'}
</code></pre>
<p>Or using the dict constructor:</p>
<pre><code>from itertools import repeat

data = dict(map(str.strip, t) for _k, _v in map(lambda x: x.split(":"), dinner)
            for t in zip(_k.split(","), repeat(_v)))

from pprint import pprint as pp

pp(data)
</code></pre>
<p>If you really want a list of strings, we can do something similar using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain</code></a> and joining the substrings:</p>
<pre><code>from itertools import repeat, chain

data = chain.from_iterable(map(":".join, zip(_k.split(","), repeat(_v))) 
                           for _k, _v in map(lambda x: x.split(":"), dinner))


from pprint import pprint as pp

pp(list(data))
</code></pre>
<p>Output:</p>
<pre><code>['cake: No',
 'peas: No',
 'cheese : No',
 'duck: Maybe',
 'broccoli: Maybe',
 'onions : Maybe',
 'motor oil : Definitely Not',
 'pizza : Damn Right',
 'ice cream : Maybe',
 'bologna : No',
 'potatoes: Yes',
 'bacon: Yes',
 'carrots: Yes',
 'water: Yes',
 'rats: Definitely Not',
 'hats : Definitely Not',
 'seltzer : Yes',
 'sleeping: No Way',
 'whining: No Way',
 'spitting : No Way',
 'marmalade : No']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This may work:</p>
<pre><code>def processList (aList):
    finalList = []
    for aListEntry in aList:
        aListEntry_entries = aListEntry.split(':')
        aListEntry_list = aListEntry_entries[0].split(',')
        for aListEntry_list_entry in aListEntry_list:
            finalList.append(aListEntry_list_entry.strip() + ' : ' + aListEntry_entries[1].strip())
    return finalList
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>List comprehensions are preferred in Python (check eg <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow">this</a>), due to better legibility (at least for some;).</p>
<p>The code demonstrates two types of list comprehension nesting, the first is basically chaining the operations, the other produces one list from two nested loops.</p>
<p>If you make your data more consistent by adding one space after the <code>carrots, water</code>, you can get rid of two <code>.strip()</code> calls;)</p>
<pre><code>dinner = [
    'cake,peas,cheese : No',
    'duck,broccoli,onions : Maybe',
    'motor oil : Definitely Not',
    'pizza : Damn Right',
    'ice cream : Maybe',
    'bologna : No',
    'potatoes,bacon,carrots,water : Yes',
    'rats,hats : Definitely Not',
    'seltzer : Yes',
    'sleeping,whining,spitting : No Way',
    'marmalade : No'
]

prefs = [(pref, items.split(',')) for items, pref in [it.split(" : ") for it in dinner]]
[" : ".join([item, pref]) for pref, items in prefs for item in items]
</code></pre>
</div>
<span class="comment-copy">Why are you concerned about the code length? This would be much less maintainable in the long term.</span>
<span class="comment-copy">@jpmc26 I understand where you're coming from and agree. This for me is more an exploratory exercise in understanding the capabilities of Python's hofs.</span>
<span class="comment-copy"><code>flatten</code> is built-in as <code>itertools.chain.from_iterable</code></span>
<span class="comment-copy">@AChampion thank you. Several people have posted great code that works well, but your response was more aligned with my goal.</span>
