<div class="post-text" itemprop="text">
<p>I am trying to write a function to  find integer with most divisor from a list, but i am getting the wrong output. This is how my function looks. </p>
<pre><code>def find_my_integer_divisor(mylist):
      def find_divisor(k):
            count =0
            for i in range (1,k+1):
                  if k%i==0:
                      count +=1
            return count 
     A=mylist[0]
     for x in mylist [0:]:
           A=find_divisor(x)
     return A
</code></pre>
<p>It returns the count of the last entry in mylist. I know I have to compare the value counts from each entry and returns the integer with the most count but don't know how to do it. </p>
</div>
<div class="post-text" itemprop="text">
<p>This should work:</p>
<pre><code>def find_divisor(k):
     count =0
     for i in range (1,k+1):
           if k%i==0:
               count +=1
     return count

def find_my_integer_divisor(mylist):
     return max(mylist, key=find_divisor)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of actually finding all the proper factors, we can much more efficiently calculate the number possible by doing a prime factorization.</p>
<p>For example,</p>
<pre><code>288 == 2**5 * 3**2
</code></pre>
<p>and the number of proper factors is</p>
<pre><code>  (5 + 1) * (2 + 1) - 1
    ^         ^       ^
number     number    omit one case:
of twos   of threes  5 2s and 2 3s == 288,
used in   used in    which is not a proper
factor,    factor    factor of itself
 0..5
(six possible
  values)
</code></pre>
<hr/>
<p>To do a prime factorization, we need to start by generating primes:</p>
<pre><code>def primes(known_primes=[7, 11, 13, 17, 19, 23, 29]):
    """
    Generate every prime number in ascending order
    """
    # 2, 3, 5 wheel
    yield from (2, 3, 5)
    yield from known_primes
    # The first time the generator runs, known_primes
    #   contains all primes such that  5 &lt; p &lt; 2 * 3 * 5
    # After each wheel cycle the list of known primes
    #   will be added to.
    # We need to figure out where to continue from,
    #   which is the next multiple of 30 higher than
    #   the last known_prime:
    base = 30 * (known_primes[-1] // 30 + 1)
    new_primes = []
    while True:
        # offs is chosen so  30*i + offs cannot be a multiple of 2, 3, or 5
        for offs in (1, 7, 11, 13, 17, 19, 23, 29):
            k = base + offs    # next prime candidate
            for p in known_primes:
                if not k % p:
                    # found a factor - not prime
                    break
                elif p*p &gt; k:
                    # no smaller prime factors - found a new prime
                    new_primes.append(k)
                    break
        if new_primes:
            yield from new_primes
            known_primes.extend(new_primes)
            new_primes = []
        base += 30
</code></pre>
<p>which can be tested like</p>
<pre><code>from itertools import islice
print(list(islice(primes(), 500)))
</code></pre>
<p>giving</p>
<pre><code>[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, ...
</code></pre>
<p>Now that we have primes, we can count the occurrences of each prime factor like so:</p>
<pre><code>def prime_factor_count(n):
    """
    Factorize n and yield (factor, count) for each distinct factor
    """
    if n &lt; 2:
        return
    else:
        for p in primes():
            count = 0
            while not n % p:
                count += 1
                n //= p
            if count:
                yield (p, count)
                if n == 1:
                    # number is fully factored
                    break
                elif p*p &gt; n:
                    # no smaller prime factors - remainder is prime
                    yield (n, 1)
                    break
</code></pre>
<p>which we can test like</p>
<pre><code>print(list(prime_factor_count(288)))    # =&gt; [(2, 5), (3, 2)]
</code></pre>
<p>which you should recognize from above, <code>288 == 2**5 * 3**2</code>. Now we can</p>
<pre><code>def num_proper_factors(n):
    total_factors = 1
    for factor, count in prime_factor_count(n):
        total_factors *= (count + 1)
    return total_factors - 1
</code></pre>
<p>which tests like</p>
<pre><code>print(num_proper_factors(288))     # =&gt; 17
</code></pre>
<p>and finally,</p>
<pre><code>def num_with_most_divisors(lst):
    return max(lst, key=num_proper_factors)
</code></pre>
<p>QED.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>short answer</strong>: use <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow"><code>max</code></a> with a key function like your's <code>find_divisor</code> as show by @rofls.</p>
<p><strong>Long answer</strong>: in each iteration you need to compare yours previous value with the current value in your list, if the current value have a bigger count of divisor change <code>A</code> otherwise don't, the problem in your code is that you don't do this check. You can do something like this </p>
<pre><code>def max_divisor_count(my_list):
    result = my_list[0]
    for n in my_list[1:]: # start in 1 because 0 is already in result
        if find_divisor(n) &gt; find_divisor(result):
            result = n
    return result 
</code></pre>
<p>and this is more or less the same that the <code>max</code> with key-function solution does. </p>
<p>Of course this can be improved a little more to avoid repeat calculations like this</p>
<pre><code>def max_divisor_count(my_list):
    result = my_list[0]
    div_count = find_divisor(result)
    for n in my_list[1:]: # start in position 1 because 0 is already in result
        if result != n:
            temp = find_divisor(n) 
            if temp &gt; div_count:
                result = n
                div_count = temp
    return result 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a generator expression alternative. Note I use <code>itertools.tee</code> to create 2 instances of the generator. The first is to calculate the max, the second to feed <code>enumerate</code>.</p>
<p>The below example also demonstrates how you can use a list comprehension to return <em>all</em> integers with the maximum number of divisors.</p>
<pre><code>from itertools import tee

lst = [1, 2, 3, 6, 8, 10, 14]

gen1, gen2 = tee(sum(k%i==0 for i in range(1, k+1)) for k in lst)
divmax = max(gen1)

[lst[i] for i, j in enumerate(gen2) if j == divmax]

# [6, 8, 10, 14]
</code></pre>
</div>
<span class="comment-copy">why dict? just use <code>find_divisor</code> as the key function</span>
<span class="comment-copy">Good call. I was thinking in case they wanted to return the count or something too... :) I'll update it to use your suggestion though, much cleaner</span>
