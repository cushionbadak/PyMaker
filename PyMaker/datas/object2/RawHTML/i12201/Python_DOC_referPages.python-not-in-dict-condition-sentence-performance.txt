<div class="post-text" itemprop="text">
<p>Does anybody know about what is better to use thinking about speed and resources? Link to some trusted sources would be much appreciated.</p>
<pre><code>if key not in dictionary.keys():
</code></pre>
<p>or</p>
<pre><code>if not dictionary.get(key):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, you'd do</p>
<pre><code>if key not in dictionary:
</code></pre>
<p>since dicts are iterated over by keys.</p>
<p>Secondly, the two statements are not equivalent - the second condition would be true if the corresponding values is falsy (<code>0</code>, <code>""</code>, <code>[]</code> etc.), not only if the key doesn't exist.</p>
<p>Lastly, the first method is definitely faster and more pythonic. Function/method calls are expensive. If you're unsure, <code>timeit</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In my experience, using <code>in</code> is faster than using <code>get</code>, although the speed of <code>get</code> can be improved by caching the <code>get</code> method so it doesn't have to be looked up each time. Here are some <code>timeit</code> tests:</p>
<pre><code>''' in vs get speed test

    Comparing the speed of cache retrieval / update using `get` vs using `in`

    http://stackoverflow.com/a/35451912/4014959

    Written by PM 2Ring 2015.12.01
    Updated for Python 3 2017.08.08
'''

from __future__ import print_function
from timeit import Timer
from random import randint
import dis

cache = {}

def get_cache(x):
    ''' retrieve / update cache using `get` '''
    res = cache.get(x)
    if res is None:
        res = cache[x] = x
    return res

def get_cache_defarg(x, get=cache.get):
    ''' retrieve / update cache using defarg `get` '''
    res = get(x)
    if res is None:
        res = cache[x] = x
    return res

def in_cache(x):
    ''' retrieve / update cache using `in` '''
    if x in cache:
        return cache[x]
    else:
        res = cache[x] = x
        return res

#slow to fast.
funcs = (
    get_cache, 
    get_cache_defarg,
    in_cache, 
)

def show_bytecode():
    for func in funcs:
        fname = func.__name__
        print('\n%s' % fname)
        dis.dis(func)

def time_test(reps, loops):
    ''' Print timing stats for all the functions '''
    for func in funcs:
        fname = func.__name__
        print('\n%s: %s' % (fname, func.__doc__))
        setup = 'from __main__ import data, ' + fname
        cmd = 'for v in data: %s(v)' % (fname,)
        times = []
        t = Timer(cmd, setup)
        for i in range(reps):
            r = 0
            for j in range(loops):
                r += t.timeit(1)
                cache.clear()
            times.append(r)
        times.sort()
        print(times)

datasize = 1024
maxdata = 32
data = [randint(1, maxdata) for i in range(datasize)]

#show_bytecode()
time_test(3, 500)
</code></pre>
<p><strong>typical output</strong> on my 2Ghz machine running Python 2.6.6:   </p>
<pre><code>get_cache:  retrieve / update cache using `get` 
[0.65624237060546875, 0.68499755859375, 0.76354193687438965]

get_cache_defarg:  retrieve / update cache using defarg `get` 
[0.54204297065734863, 0.55032730102539062, 0.56702113151550293]

in_cache:  retrieve / update cache using `in` 
[0.48754477500915527, 0.49125504493713379, 0.50087881088256836]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ok, I've tested it on python 3.4.3 and all three ways give the same result around 0.00001 second.</p>
<pre><code>import random
a = {}
for i in range(0, 1000000):
        a[str(random.random())] = random.random()
import time
t1 = time.time(); 1 in a.keys(); t2 = time.time(); print("Time=%s" % (t2 - t1))
t1 = time.time(); 1 in a; t2 = time.time(); print("Time=%s" % (t2 - t1))
t1 = time.time(); not a.get(1); t2 = time.time(); print("Time=%s" % (t2 - t1))
</code></pre>
</div>
<span class="comment-copy">Ok, 2nd is more pythonic but can't be used in situation when your dict can contain zeros, emptry strings or empty lists, right?</span>
<span class="comment-copy">The first is more pythonic (if all you're trying to do is determine whether a dict has a given key). The second part of your comment is correct. Of course, all this depends on what you're actually trying to do - even a <code>try/except</code> block might be the best way to achieve that.</span>
<span class="comment-copy">Hmm. In which situation <code>try/except</code> might be the best way?</span>
<span class="comment-copy">For example if you plan on doing something with the value for the key, and you're 99% sure that there will be such a key. In this case, it's <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">easier to ask forgiveness than permission</a>.</span>
<span class="comment-copy">This is not how you do performance testing. Use the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code> module</a>.</span>
<span class="comment-copy">Also, all your tests will always return False because there can never be a <code>a[1]</code>.</span>
<span class="comment-copy">use <code>xrange()</code> for iteration</span>
