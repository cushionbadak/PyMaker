<div class="post-text" itemprop="text">
<p>I have a set that contains small dictionaries saved as strings that looks like this:</p>
<pre><code>set(["{u'151H0': 28, u'151H1': 1}", "{u'151H0': 38, u'151H1': 1}", "{u'151H0': 36, u'151H1': 1}", "{u'151H0': 37, u'151H1': 1}"]) 
</code></pre>
<p>I can easily convert each item in the set from a string into a small dictionary using eval() but I am trying to figure out a good algorithm to note which keys in the set have more than one value. </p>
<p>For example, as seen above there are two keys '151H0' and '151H1'. The key '151H1' has only a value of 1 in each case. The key '151H0' has values 28, 38, 36, and 37. All I want to do is find an elegant way to read the set and return the key '151H0' because it has more than one associated value, and ignore the key '151H1' because it always has the same value. </p>
<p>As a bonus, I would like to get the average of the values as an integer for the returned key. In this case it would be 35. So my output could be a tuple such as: '151H0', 35</p>
<p>I am asking for help because the solutions that I have come up with so far involve more lines of code than I think should be necessary for this. </p>
</div>
<div class="post-text" itemprop="text">
<p>You'll need to convert to real <code>dict</code>s, and no, <code>eval</code> is not the way to go (it's a giant sign that reads "This code is insecure!"). <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow">Use <code>ast.literal_eval</code></a> for this, it works the same, except it only evaluates legal Python literals, so it can't be used to execute arbitrary code. In any event, the easy way to do this is to <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow">use <code>collections.defaultdict</code></a> to accumulate the values for each key so you know which ones have more than one unique value:</p>
<pre><code>import ast
from collections import defaultdict

partialdataset = ... your set goes here ...

# Accumulate values for each key
valuetracker = defaultdict(set)
for partialdict in map(ast.literal_eval, partialdataset):
    for k, v in partialdict.viewitems():  # Just .items() on Py3
        valuetracker[k].add(v)

# Keep only keys with more than one value (non-unique, because we used set)
# computing the average
nonuniquekeys = {k: round(sum(v) / float(len(v))) for k, v in valuetracker.viewitems() if len(v) &gt; 1}
</code></pre>
</div>
<span class="comment-copy">you should post your current solution</span>
<span class="comment-copy">My solution just gives me the average, but I haven't yet figured out how to isolate the key that has multiple values.. The ideas that I have in my head are messy..</span>
<span class="comment-copy">Nice answer, pointing out the dangers of using raw <code>eval</code></span>
<span class="comment-copy">@rofls: I will never object to people stealing use of <code>ast.literal_eval</code> from me. <code>eval</code> must die, and I welcome all aid. :-)</span>
<span class="comment-copy">Excellent! This gives me exactly what I need: <code>{u'151H0': 35.0}</code>. There are some concepts that I am not familiar with here, such as map(), ast, and viewitems().. Thanks!</span>
<span class="comment-copy">@ChrisNielsen: <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> is just shorthand for a list comprehension (Py2) or generator expression (Py3) that calls the function for every element in the input. It's not a good idea in the general case (usually slower than equivalent genexpr), unless the function is a built-in implemented in C (like <code>ast.literal_eval</code>). <code>.viewitems()</code> is like <code>.items()</code> except it doesn't create a <code>list</code> of key/value <code>tuple</code>s, it returns a view object that avoids the temporary list (in Py3, <code>.items()</code> behaves exactly like <code>.viewitems()</code> in 2.7).</span>
<span class="comment-copy">@ChrisNielsen: If you want the result to be a true <code>int</code>, just wrap the <code>round</code> call in <code>int</code>; in Py3, <code>round</code> called with a single argument automatically returns <code>int</code>, but in Py2, you need to explicitly cast the <code>float</code> result to <code>int</code>.</span>
