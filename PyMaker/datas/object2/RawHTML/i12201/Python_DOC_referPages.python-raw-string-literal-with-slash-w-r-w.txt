<div class="post-text" itemprop="text">
<p>With python 2.7.8 and 3.4 on my machine when I have a backslash-W inside a raw string literal it's not getting treated as raw. Is this  really the expected behaviour?</p>
<pre><code>import os
import sys
wspace = r'D:\Feb-19'
tile = '116o'
ex1 = os.path.join(wspace, r'Work_{}\scratch.gdb'.format(tile))
ex2 = os.path.join(wspace, r'\Work_{}\scratch.gdb'.format(tile))

print(sys.version)

print('''\n--- Expected ---
no-slash-W      D:\Feb-19Work_116o\scratch.gdb
yes-slash-W     D:\Feb-19\Work_116o\scratch.gdb
''')

print('''--- Actual Result ---
no-slash-W      {}
yes-slash-W     {}
'''.format(ex1, ex2))
</code></pre>
<p>Result I get from PyScripter and remote python interpreter. Note <code>9W</code> vs <code>9\W</code> and <code>D:\Feb</code> vs <code>D:\Work</code>.</p>
<pre><code>2.7.8 (default, Jun 30 2014, 16:03:49) [MSC v.1500 32 bit (Intel)]
--- Expected ---
no-slash-W      D:\Feb-19Work_116o\scratch.gdb
yes-slash-W     D:\Feb-19\Work_116o\scratch.gdb

--- Actual Result ---
no-slash-W      D:\Feb-19\Work_116o\scratch.gdb
yes-slash-W     D:\Work_116o\scratch.gdb
</code></pre>
<p>...and command shell Python 3:</p>
<pre><code>D:\&gt; python broken-raw-string-example.py
3.4.1 (v3.4.1:c0e311e010fc, May 18 2014, 10:45:13) [MSC v.1600 64 bit (AMD64)]

--- Expected ---
no-slash-W      D:\Feb-19Work_116o\scratch.gdb
yes-slash-W     D:\Feb-19\Work_116o\scratch.gdb

--- Actual Result ---
no-slash-W      D:\Feb-19\Work_116o\scratch.gdb
yes-slash-W     D:\Work_116o\scratch.gdb
</code></pre>
<p>Gist here if you want to stick a fork in it:
<a href="https://gist.github.com/maphew/9368fe16df751b016bbd" rel="nofollow">https://gist.github.com/maphew/9368fe16df751b016bbd</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It's not raw strings tripping you up here; you misunderstand <code>os.path.join</code>. <a href="https://docs.python.org/3/library/os.path.html#os.path.join" rel="nofollow"><code>os.path.join</code></a> is <em>supposed</em> to add a slash when the component doesn't start with one. And if a slash already exists, it's treated as the beginning of an absolute path, which discards the preceding components and begins again "from scratch" (except, on Windows, the drive letter). From the docs:</p>
<blockquote>
<p>If a component is an absolute path, all previous components are thrown away and joining continues from the absolute path component.</p>
<p>On Windows, the drive letter is not reset when an absolute path component (e.g., r'\foo') is encountered. If a component contains a drive letter, all previous components are thrown away and the drive letter is reset. Note that since there is a current directory for each drive, os.path.join("c:", "foo") represents a path relative to the current directory on drive C: (c:foo), not c:\foo.</p>
</blockquote>
<p>So it is expected and normal for:</p>
<pre><code>os.path.join('C:\a', 'b')
</code></pre>
<p>to produce the string <code>C:\a\b</code> on Windows (the repr of which would be <code>"C:\\a\\b"</code> due to the necessary escaping of the backslash), while:</p>
<pre><code>os.path.join('C:\a', '\\b')
</code></pre>
<p>the <code>'\\b'</code> means "starting a new absolute path from the current drive" and throws away the <code>\a</code> replacing it with <code>\b</code>. Similarly,</p>
<pre><code>os.path.join('C:\a', 'b', '\\c', 'd')
</code></pre>
<p>would, when it sees <code>'\\c'</code>, throw away <code>a</code>and <code>b</code> and build up the path from there, producing <code>C:\c\d</code>.</p>
</div>
<span class="comment-copy"><code>os.path.join()</code> normalizes paths also.  It sees the backslash as a path-joiner when it is there.  When it is <i>not</i> there, it puts one there.</span>
