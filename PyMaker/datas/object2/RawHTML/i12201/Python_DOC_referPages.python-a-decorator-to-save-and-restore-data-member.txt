<div class="post-text" itemprop="text">
<p>I'm looking for a python decorator to implement a 'save &amp; restore' feature. What I want is a decorator which save some data members of an object instance, execute a method which could change these data members, and restore the old state of the instance. Here is a minimal example:</p>
<pre><code>class toto:
    def __init__(self):
        self.myMember = []

    def update(self,var):
        self.myMember.append(var)

    def preserveMember(func):
        def dec(self):
            oldMember = self.myMember
            func(self)
            self.myMember = oldMember
            return
        return dec

    @preserveMember
    def doJob(self):
        self.update('haha!!')
        print "doJob: "+self.myMember.__repr__()


if __name__ == '__main__':
    tt = toto()

    tt.update('tutu1')
    tt.update('tutu2')

    print "Before Job: "+ tt.myMember.__repr__()
    tt.doJob()
    print "After Job: "+ tt.myMember.__repr__()
</code></pre>
<p>The output of this code is </p>
<pre><code>Before Job: ['tutu1', 'tutu2']
doJob: ['tutu1', 'tutu2', 'haha!!']
After Job: ['tutu1', 'tutu2', 'haha!!']
</code></pre>
<p>But what I want with the decorator <code>preserveMember</code> is</p>
<pre><code>Before Job: ['tutu1', 'tutu2']
doJob: ['tutu1', 'tutu2', 'haha!!']
After Job: ['tutu1', 'tutu2']
</code></pre>
<p>I feel like I'm lost with variable scope but I don't know where to look for such feature. Any idea would help, thanks! (one more information: I'm using Python 2.7)</p>
</div>
<div class="post-text" itemprop="text">
<p>Your decorator would work for a member that would be changed by overwriting. However, the member in question is a list and it is saved and restored by reference. This means that as the job mutates the list, it mutates the saved value as well because it's the very same (identical) list instance.</p>
<p>What you'd need to do if you're sure that the member is always a list is save and restore the old object but put a copy in its place for the job to mutate:</p>
<pre><code>def preserveMember(func):
    def dec(self):
        oldMember = self.myMember
        self.myMember = self.myMember[:]
        func(self)
        self.myMember = oldMember
    return dec
</code></pre>
<p>Update: In the general case, the <code>copy</code> module can be used to create a "deep copy" of the member:</p>
<pre><code>import copy

def preserveMember(func):
    def dec(self):
        oldMember = self.myMember
        self.myMember = copy.deepcopy(self.myMember)
        func(self)
        self.myMember = oldMember
    return dec
</code></pre>
<p>If custom objects are involved, they can implement how to <code>deepcopy</code> their instances. See <a href="https://docs.python.org/2.7/library/copy.html" rel="nofollow">the documentation of the <code>copy</code> module</a>.</p>
</div>
<span class="comment-copy">Better to user context manager. <a href="https://docs.python.org/3/library/contextlib.html" rel="nofollow noreferrer">docs.python.org/3/library/contextlib.html</a></span>
<span class="comment-copy">Good analysis! To keep the decorator agnostic about whether <code>myMember</code> is a indexable, one could use <a href="https://docs.python.org/2.7/library/copy.html#copy.deepcopy" rel="nofollow noreferrer"><code>deepcopy</code></a>.</span>
<span class="comment-copy">That's true, thank you for pointing it out.</span>
<span class="comment-copy">Thank you guys! I'm using this answer with deepcopy of das-g. Maybe you could update the answer to cover more user experiences. Thanks again!</span>
<span class="comment-copy">I'm updating it.</span>
