<div class="post-text" itemprop="text">
<p>I've created a linked list in Python, and it is singly linked.  This works perfectly fine, but I want to implement it so it's doubly linked, but I'm having trouble figuring out how to do it.</p>
<pre><code># node class
class node:
    def __init__(self):
        self.data = None # contains the data
        self.next = None # contains the reference to the next node

# linked list class
class linked_list:
    def __init__(self):
        self.cur_node = None

    def add_node(self, data):
        new_node = node() # create a new node
        new_node.data = data
        new_node.next = self.cur_node # link the new node to the 'previous' node.
        self.cur_node = new_node # set the current node to the new one.

    def list_print(self):
        node = self.cur_node # cant point to ll!
        while node:
            print(node.data)
            node = node.next
</code></pre>
<p>I know I need to add <code>self.previous</code> to the node class, and I think I need to add something to the <code>linked list</code> constructor and <code>add_node</code> function, but I'm not sure where to start.</p>
<p>I don't actually need to use this functionality in a program, I'm just trying to learn about how linked lists are implemented at a lower level.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not so much a coding problem as a conceptual problem. You need to figure out how you want your code to behave. Implementing the desired behavior is not (in this case) at all difficult.</p>
<p>Say we want these behaviors:</p>
<pre><code># construction
dlist = DoublyLinkedList()

# access to head and tail nodes
dlist.head  # should return the head node
dlist.tail  # should return the tail node

dlist.head.prev is None  # should be True
dlist.tail.next is None  # should be True 

# adding nodes at both ends
dlist.add_head()
dlist.add_tail()

# iteration in both directions
for node in dlist:
    # do something to the node
for node in reversed(dlist):
    # do something to the node
</code></pre>
<p>When you have written out the desired behavior like this, you'll also have got some test code ready.</p>
<p>Now let's start by modifying the <code>Node</code> class (<a href="https://www.python.org/dev/peps/pep-0008/#naming-conventions" rel="nofollow">you should use CamelCase for class names</a>):</p>
<pre><code>class Node:
    def __init__(self, data=None, prev=None, next=None):
        self.data = data
        self.prev = prev
        self.next = next

    def __repr__(self):
        return '&lt;{}, {}&gt;'.format(self.data, self.next)
</code></pre>
<p>We add <code>prev</code> since that's obviously needed. But we also improve on your original version by having <code>data</code> and <code>next</code> as parameters, so you can have these values set when a node is created. And <code>__repr__</code> is always nice to have, for debugging if not for anything else.</p>
<p>Now for the list itself. The key is, (a) instead of one <code>cur_node</code>, you need <em>two</em> handles on the list, which I've been calling <code>head</code> and <code>tail</code>, and (b) when adding nodes, the very first node is a special case where we have to make changes to both <code>head</code> and <code>tail</code>. </p>
<pre><code>class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def __repr__(self):
        return '&lt;DoublyLinkedList {}&gt;'.format(self.head)

    def add_head(self, data=None):
        if self.head is None:
            self.head = self.tail = Node(data)  # the very fist node
        else:
            new_head = Node(data=data, next=self.head)  # prev is None
            self.head.prev = self.head = new_head

    def add_tail(self, data=None):
        if self.tail is None:
            self.head = self.tail = Node(data)  # the very first node
        else:
            new_tail = Node(data=data, prev=self.tail)  # next is None
            self.tail.next = self.tail = new_tail

    # implements iteration from head to tail
    def __iter__(self):
        current = self.head
        while current is not None:
            yield current
            current= current.next

    # implements iteration from tail to head
    def __reversed__(self):
        current = self.tail
        while current  is not None:
            yield current
            current = current.prev
</code></pre>
<p>Let's test this</p>
<pre><code>&gt;&gt;&gt; dlist = DoublyLinkedList()
&gt;&gt;&gt; print(dlist)
&lt;DoublyLinkedList None&gt;
&gt;&gt;&gt; dlist.add_head(1)
&gt;&gt;&gt; dlist.add_tail(2)
&gt;&gt;&gt; dlist.add_tail(3)
&gt;&gt;&gt; dlist.add_head(0)
&gt;&gt;&gt; print(dlist)  # __repr__ is such a nice thing to have
&lt;DoublyLinkedList &lt;0, &lt;1, &lt;2, &lt;3, None&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt; print(dlist.head)
&lt;0, &lt;1, &lt;2, &lt;3, None&gt;&gt;&gt;&gt;
&gt;&gt;&gt; print(dlist.tail)
&lt;3, None&gt;
&gt;&gt;&gt; print(dlist.head.prev is None, dlist.tail.next is None)
True, True
&gt;&gt;&gt; print(dlist.tail.prev.next is dlist.tail)
True
&gt;&gt;&gt; [node.data for node in dlist]
[0, 1, 2, 3]
&gt;&gt;&gt; for node in reversed(dlist):
...     print(node.data, node)
3 &lt;3, None&gt;
2 &lt;2, &lt;3, None&gt;&gt;
1 &lt;1, &lt;2, &lt;3, None&gt;&gt;&gt;
0 &lt;0, &lt;1, &lt;2, &lt;3, None&gt;&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For a doubly linked list, you should have, each node should have a reference to the previous node.  This means that you will need to modify your add and remove methods to also assign this reference.</p>
</div>
<span class="comment-copy">Is there a reason you're not using <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a>?</span>
<span class="comment-copy">Yeah, I know I could implement this functionality easily, but I'm trying to learn how the underlying data structures work.</span>
<span class="comment-copy">At the moment your singly linked <code>add_node</code> is adding the node to the "start" of the list, not the "end" ... is that what you intended?</span>
<span class="comment-copy">I've been trying to find out how to add a node to the end (I figure if I can do that, I would probably be able to work out making it doubly linked.)</span>
