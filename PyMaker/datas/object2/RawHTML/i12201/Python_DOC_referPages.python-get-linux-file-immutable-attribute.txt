<div class="post-text" itemprop="text">
<p>I can use <code>os.stat(pathname)</code> to get pathname's perssmions, mtime, atime....
Howerver, I hava a file that has a '+i' attribute, you can see it by:
<code>lsattr  /tmp/test.py</code>
Is there a way to know if the pathname has the '+i' attribute by using python?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/34176464/why-os-chflags-doesnt-work-under-linux/36274086#36274086">This related SO post</a> about why <code>os.chflags</code> doesn't exist on Linux shows a way to work around the absence of <code>lsattr</code> in the <code>os</code> module using <code>fcntl</code>.  However, it relies on copying constant definitions from a header file (ext2fs/ext2_fs.h), so it's fragile.  A more permanent solution would require writing some C or something like Cython.</p>
<p>Meanwhile, PM 2Ring's answer works, though it should be modified to work with paths that contain the letter "i".  Perhaps someone with some reputation could comment or edit that answer (this is my first post)?</p>
<pre><code>import subprocess

def is_immutable(fname):
    p = subprocess.Popen(['lsattr', fname], bufsize=1, stdout=subprocess.PIPE)
    data, _ = p.communicate()
    #print(data)
    return 'i' in data

def is_immutable_safe(file_path):
    """Check if the immutable flag is set on a Linux file path

    Uses the lsattr command, and assumes that the immutable flag
    appears in the first 16 characters of its output.
    """
    return 'i' in subprocess.check_output(['lsattr', file_path])[:16]

# These assertions will pass if the immutable bit is not set on
# /etc/inittab on your system
assert is_immutable('/etc/inittab') is True
assert is_immutable_safe('/etc/inittab') is False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There doesn't appear to be an <code>os</code> module function to get these Linux file attributes, but you can use the <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer"><code>subprocess</code></a> module to call the <code>lsattr</code> command in Python.</p>
<p>The code below should work on Python 2 or 3, although it can be made more compact in recent Python versions.</p>
<p>FWIW, I have the <code>i</code> bit set on my fstab file because I got sick of it randomly getting wiped out.</p>
<pre><code>import subprocess

def is_immutable(fname):
    p = subprocess.Popen(['lsattr', fname], bufsize=1, stdout=subprocess.PIPE)
    data, _ = p.communicate()
    #print(data)
    return 'i' in data.split(None, 1)[0]

print(is_immutable("/etc/fstab"))
</code></pre>
<h3>Update</h3>
<p>The previous version of this code had </p>
<pre><code>return 'i' in data.split
</code></pre>
<p>However, that will <em>also</em> detect an 'i' if one is present in the file name! The new version <em>only</em> detects an 'i' in the attribute flags. Thanks, <a href="https://stackoverflow.com/users/2283382/sverasch">sverasch</a> for bring this to my attention.</p>
</div>
<span class="comment-copy"><a href="http://www.linuxquestions.org/questions/programming-9/python-checking-for-immutable-bit-4175457032/" rel="nofollow noreferrer">linuxquestions.org/questions/programming-9/â€¦</a></span>
<span class="comment-copy">statmode = os.stat("/tmp/test.py").st_modeF_IMMUTABLE(statmode) there is an error: AttributeError: 'posix.stat_result' object has no attribute 'st_modeF_IMMUTABLE'</span>
<span class="comment-copy">out of curiosity, what Distro/Kernel and filesystem are you using? Is <code>/tmp</code> a nfs share or something similar?</span>
<span class="comment-copy">centos6.7 ext4,pathname is local file</span>
<span class="comment-copy">Though it might be a messy way of doing it, one way would be to determine if it is immutable by changing the file in some inconsequential way in a try except block, then reverting the change if it is not immutable. It's definitely not the best way of doing it, though...</span>
<span class="comment-copy"><code>'i' in data</code> may not be a good idea, it's better to use re to match the result  <code>p = re.compile(r'-+i-+')</code></span>
<span class="comment-copy">@page: Why? On my machine, using <code>in</code> on the result string that <code>lsattr</code> sends to stdout is around 10 times faster than using <code>match</code> with your compiled pattern, and that's not counting the time to import <code>re</code> or compile the pattern; <code>search</code> is even slower, especially when the search fails. If I use a simplified regex <code>r'i'</code>, an <code>in</code> test is still faster than a regex <code>search</code>, even if I make the target string 1000 times longer.</span>
<span class="comment-copy">Thank you very much for your proposed these contrast</span>
<span class="comment-copy">@sverasch I hastily rejected your edit because I didn't realise why it was needed... until 5 seconds later. :) But I would've fixed it myself if you'd left me a comment...</span>
