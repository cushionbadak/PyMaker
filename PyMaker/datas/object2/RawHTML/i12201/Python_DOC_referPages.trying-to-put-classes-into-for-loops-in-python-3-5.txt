<div class="post-text" itemprop="text">
<p>I am trying to make a for loop, which iterates through a range, and makes classes. How could I do this? How could the classes be named?
Here is what I have and mean.</p>
<pre><code>for i in range(6):
    class Name(str(i)):     #I want the class name to be Name and then the number as a string. So the classes will be called 'Name1', Name2' etc
        pass
</code></pre>
<p>I'm making an RPG type game and I want a range of different monster types. I want to be able to generate classes for each monster type. I want each monster to be a level higher than the last so the health and other stats will be multiplied by the previous monster's stats</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer the question specifically, you would use the 3 argument form of <a href="https://docs.python.org/3.5/library/functions.html#type" rel="nofollow noreferrer">type</a> to create a <a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">metaclass</a>:</p>
<pre><code>&gt;&gt;&gt; classes=[type('Name'+str(i), (), {}) for i in range(6)]
&gt;&gt;&gt; classes
[&lt;class '__main__.Name0'&gt;, &lt;class '__main__.Name1'&gt;, &lt;class '__main__.Name2'&gt;, &lt;class '__main__.Name3'&gt;, &lt;class '__main__.Name4'&gt;, &lt;class '__main__.Name5'&gt;]
&gt;&gt;&gt; classes[0].__name__
'Name0'
</code></pre>
<p>The form <code>Bar=type('Bar', (), {})</code> is analogous to:</p>
<pre><code>class Foo:
    pass
</code></pre>
<p>Instantiating an instance would be:</p>
<pre><code>&gt;&gt;&gt; Bar=type('Bar', (), {})
&gt;&gt;&gt; Bar()
&lt;__main__.Bar object at 0x102c90fd0&gt;
</code></pre>
<p>vs</p>
<pre><code>&gt;&gt;&gt; class Foo:
...    pass
... 
&gt;&gt;&gt; Foo()
&lt;__main__.Foo instance at 0x102cde5f0&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to make brand new classes with names as if defined manually, you're usually stuck with <code>format</code>-ing and <code>eval</code>-ing strings. This is how Python implements <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow"><code>collections.namedtuple</code></a>; it's implemented in Python code using a template string that it fills in programmatically then <code>eval</code>s.</p>
<p>Take a look at <a href="https://hg.python.org/cpython/file/426ac89548b3/Lib/collections/__init__.py#l301" rel="nofollow">the <code>namedtuple</code> implementation</a> for an example of how you might do something like this.</p>
<p>You can also make classes programmatically using the three argument <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow"><code>type</code> constructor</a>, which lets you explicitly provide a name, bases and class dictionary, so making <code>Name#</code> six times with no special base classes or class attributes or member functions could be made and assigned to globals via:</p>
<pre><code>globals().update({name: type(name, (), {}) for name in  map('Name{}'.format, range(6))})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One you create a class, it's available like any other symbol. So try this:</p>
<pre><code>def make_class(name:str):
    class c:
        _classname = name
        pass

    return c
</code></pre>
<p>Now you have an object of type <code>class</code> (not really, but pretend), you can install it wherever you like:</p>
<pre><code>import sys
my_namespace = sys.modules[__name__].__dict__

for i in range(1,3):
    name = "my_class_name_{}".format(i)
    cls = make_class(name)
    my_namespace[name] = cls


obj1 = my_class_name_1()
print(type(obj1), obj1._classname)
obj2 = my_class_name_2()
print(type(obj2), obj2._classname)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The more pythonic way would be a list of monster objects accessed like <code>monsters[1]</code>. You can do it like this. </p>
<pre><code>monsters = []
for i in range(6):
    monsters.append(monster())
</code></pre>
<p>To do it your way you can see the other answers in the thread.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can generate classes in a loop, but it is the sign of a bad design, and always can be avoided.</p>
<p>This code generates classes and stores them in an array</p>
<pre><code>class Base():
  pass

classes = [Base]

for i in range(6):
  class Name(classes[-1]):
    pass
  classes.append(Name)

print(classes[0] != classes[-1]) # True
print(isinstance(classes[-1](), Base)) # True
</code></pre>
<p>It would be much better if all the monsters would be of the same type, and there would be some kind of "metaclass" for monster types. This means that you would have a dynamic structure which is language independent, can be changed even in runtime, and monster types can be loaded from resource files:</p>
<pre><code>class Monster:
  def __init__(self, mtype):
    self.mtype = mtype
    self.health = mtype.max_health
    # ...

class MonsterType:
  def __init__(self, mtype = None):
    self.parent_type = mtype
    self.max_health = 10 if mtype is None else mtype.max_health + 10
    # ...

mtypes = [MonsterType()]
for i in range(10):
    mtypes.append(MonsterType(mtypes[-1]))

monster = Monster(mtypes[3])

# monster.health == 40
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First things first: as other answers advised, be sure to think through this design decision. Creating classes in a loop is a possibly a red flag that your design is flawed. Moving on.</p>
<p>You can do this using metaclasses, or the <code>type</code> function. In fact, <code>type</code> is the default metaclass. It is the class of all built-in classes: </p>
<pre><code>&gt;&gt;&gt; print(type(int))
&lt;class 'type'&gt;
</code></pre>
<p>...it is the class of the basic <code>object</code> class:</p>
<pre><code>&gt;&gt;&gt; print(type(object))
&lt;class 'type'&gt;
</code></pre>
<p>...<code>type</code> is even its own class:</p>
<pre><code>&gt;&gt;&gt; print(type(type))
&lt;class 'type'&gt;
</code></pre>
<p>...and unless specified otherwise, all classes you create are themselves <code>type</code> objects: </p>
<pre><code>&gt;&gt;&gt; class MyClass:
        pass
&gt;&gt;&gt; print(type(MyClass))
&lt;class 'type'&gt;
</code></pre>
<p>All metaclasses - including <code>type</code> - can be used to create classes. When used this way, <code>type</code> takes 3 arguments: </p>
<ol>
<li>class name (a string)</li>
<li>a tuple containing the parent classes</li>
<li>a dictionary containing class attributes/members</li>
</ol>
<p>Probably the simplest way to accomplish your goal is to first create a dictionary to hold your classes:</p>
<pre><code>Name = {(i + 1): None for i in range(6)}
</code></pre>
<p>We will populate the dictionary values using the <code>type</code> metaclass:</p>
<pre><code>for num in Name:
    Name[num] = type(('Name' + str(i + 1)), (object,), {})
</code></pre>
<p>We can accomplish all of the above with this one-liner:</p>
<pre><code>Name = {(i + 1): type(('Name' + str(i + 1)), (object,), {}) for i in range(6)}
</code></pre>
<p>In the example above we are inheriting from <code>object</code> and providing no class members, but this can be adjusted as needed. </p>
<p>If you need more customization in your dynamically created classes, a good option is to use a base class with the starting functionality you require:</p>
<pre><code>class BaseMonster:
    def method1(self):
        # do stuff

Name = {(i + 1): type(('Name' + str(i + 1)), (BaseMonster,), {}) for i in range(6)}

n1 = Name[1]()
n1.method1()
</code></pre>
<p>Recall: <code>type</code> is the default metaclass. However, even more custimization can be accomplished by creating your own custom metaclass. You do this by inheriting a new class from <code>type</code>: </p>
<pre><code>class MetaMonster(type):
    def __new__(mclass, number, bases, dct):
        name = 'Name' + str(number + 1)
        return super().__new__(mclass, name, (BaseMonter,) + bases, dct)
</code></pre>
<p>And use it like this:</p>
<pre><code>Name = {(i + 1): MetaMonster(i, tuple(), {}) for i in range(6)}
n1 = Name[1]()
n1.method1()
</code></pre>
<p>Note that you no longer have to provide the <code>BaseMonster</code> argument, nor do you have to construct the string representing the class name; this is all taken care of in the <code>MetaMonster.__new__</code> method. </p>
</div>
<span class="comment-copy">You want to name the objects like that, or write code to generate classes for you to copy/paste or something?</span>
<span class="comment-copy">Basically, I'm making an RPG type game and I want a range of different monster types. I want to be able to generate classes for each monster type. I want each monster to be a level higher than the last so the health and other stats will be multiplied by the previous monster's stats.</span>
<span class="comment-copy">The base class of a class has to be a <i>reference</i> to a class, not a string containing its name.</span>
<span class="comment-copy">Also, this loop would simply overwrite the class defined in the previous iteration.</span>
<span class="comment-copy"><code>[type(str(i), (), {}) for i in range(6)] </code></span>
