<div class="post-text" itemprop="text">
<blockquote>
<p>Write a function that takes a string consisting of alphabetic
  characters as input argument and returns the most common character.
  Ignore white spaces i.e. Do not count any white space as a character.
  Note that capitalization does not matter here i.e. that a lower case
  character is equal to a upper case character. In case of a tie between
  certain characters return the last character that has the most count</p>
</blockquote>
<p><strong>This is the updated code</strong></p>
<pre><code>def most_common_character (input_str):
    input_str = input_str.lower()
    new_string = "".join(input_str.split())
    print(new_string)
    length = len(new_string)
    print(length)
    count = 1
    j = 0
    higher_count = 0
    return_character = ""
    for i in range(0, len(new_string)):
        character = new_string[i]
        while (length - 1):
            if (character == new_string[j + 1]):
                count += 1
            j += 1
            length -= 1    
            if (higher_count &lt; count):
                higher_count = count
    return (character)     

#Main Program
input_str = input("Enter a string: ")
result = most_common_character(input_str)
print(result)
</code></pre>
<p>The above is my code. I am getting an error of <code>string index out of bound</code> which I can't understand why. Also the code only checks the occurrence of first character I am confused about how to proceed to the next character and take the maximum count? </p>
<p><strong>The error i get when I run my code:</strong></p>
<pre><code>&gt; Your answer is NOT CORRECT Your code was tested with different inputs.
&gt; For example when your function is called as shown below:
&gt; 
&gt; most_common_character ('The cosmos is infinite')
&gt; 
&gt; ############# Your function returns ############# e The returned variable type is: type 'str'
&gt; 
&gt; ######### Correct return value should be ######## i The returned variable type is: type 'str'
&gt; 
&gt; ####### Output of student print statements ###### thecosmosisinfinite 19
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually your code is <em>almost</em> correct. You need to move <code>count</code>, <code>j</code>, <code>length</code> inside of your <code>for i in range(0, len(new_string))</code> because you need to start over on each iteration and also if <code>count</code> is greater than <code>higher_count</code>, you need to save that <code>charater</code> as <code>return_character</code> and return it instead of <code>character</code> which is always last char of your string because of <code>character = new_string[i]</code>.</p>
<p>I don't see why have you used <code>j+1</code> and <code>while length-1</code>. After correcting them, it now covers tie situations aswell.</p>
<pre><code>def most_common_character (input_str):
    input_str = input_str.lower()
    new_string = "".join(input_str.split())
    higher_count = 0
    return_character = ""

    for i in range(0, len(new_string)):
        count = 0
        length = len(new_string)
        j = 0
        character = new_string[i]
        while length &gt; 0:
            if (character == new_string[j]):
                count += 1
            j += 1
            length -= 1    
            if (higher_count &lt;= count):
                higher_count = count
                return_character = character
    return (return_character) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a regex patter to search for all characters.  <code>\w</code> matches any alphanumeric character and the underscore; this is equivalent to the set <code>[a-zA-Z0-9_]</code>.  The <code>+</code> after <code>[\w]</code> means to match one or more repetitions.</p>
<p>Finally, you use Counter to total them and <code>most_common(1)</code> to get the top value. See below for the case of a tie.</p>
<pre><code>from collections import Counter
import re

s = "Write a function that takes a string consisting of alphabetic characters as input argument and returns the most common character. Ignore white spaces i.e. Do not count any white space as a character. Note that capitalization does not matter here i.e. that a lower case character is equal to a upper case character. In case of a tie between certain characters return the last character that has the most count"

&gt;&gt;&gt; Counter(c.lower() for c in re.findall(r"\w", s)).most_common(1)
[('t', 46)]
</code></pre>
<p>In the case of a tie, it is a little more tricky.</p>
<pre><code>def top_character(some_string):
    joined_characters = [c for c in re.findall(r"\w+", some_string.lower())]
    d = Counter(joined_characters)
    top_characters = [c for c, n in d.most_common() if n == max(d.values())]
    if len(top_characters) == 1:
        return top_characters[0]
    reversed_characters = joined_characters[::-1]  
    for c in reversed_characters:
        if c in top_characters:
            return c

&gt;&gt;&gt; top_character(s)
't'

&gt;&gt;&gt; top_character('the the')
'e'
</code></pre>
<p>In the case of your code above and your sentence "The cosmos is infinite", you can see that 'i' occurs more frequently that 'e' (the output of your function):</p>
<pre><code>&gt;&gt;&gt; Counter(c.lower() for c in "".join(re.findall(r"[\w]+", 'The cosmos is infinite'))).most_common(3)
[('i', 4), ('s', 3), ('e', 2)]
</code></pre>
<p>You can see the issue in your code block:</p>
<pre><code>for i in range(0, len(new_string)):
    character = new_string[i]
    ...
return (character)     
</code></pre>
<p>You are iterating through a sentence and assign that letter to the variable character, which is never reassigned elsewhere.  The variable <code>character</code> will thus always return the last character in your string.</p>
</div>
<div class="post-text" itemprop="text">
<p>If we ignore the "tie" requirement; <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter()</code></a> works:</p>
<pre><code>from collections import Counter
from itertools import chain

def most_common_character(input_str):
    return Counter(chain(*input_str.casefold().split())).most_common(1)[0][0]
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; most_common_character('The cosmos is infinite')
'i'
&gt;&gt;&gt; most_common_character('ab' * 3)
'a'
</code></pre>
<p>To return the last character that has the most count, we could use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>collections.OrderedDict</code></a>:</p>
<pre><code>from collections import Counter, OrderedDict
from itertools import chain
from operator import itemgetter

class OrderedCounter(Counter, OrderedDict):
    pass

def most_common_character(input_str):
    counter = OrderedCounter(chain(*input_str.casefold().split()))
    return max(reversed(counter.items()), key=itemgetter(1))[0]
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; most_common_character('ab' * 3)
'b'
</code></pre>
<p>Note: this solution assumes that <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow"><code>max()</code></a> returns the first character that has the most count (and therefore there is a <a href="https://docs.python.org/3/library/functions.html#reversed" rel="nofollow"><code>reversed()</code> call</a>, to get the last one) and all characters are single Unicode codepoints. In general, you might want to use <code>\X</code> regular expression (supported by <a href="https://pypi.python.org/pypi/regex" rel="nofollow"><code>regex</code> module</a>), to extract <a href="http://unicode.org/glossary/#user_perceived_character" rel="nofollow">"user-perceived characters"</a> (<a href="http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries" rel="nofollow">eXtended grapheme cluster</a>) from the Unicode string.</p>
</div>
<span class="comment-copy">It's more easier with <code>Dictionary</code> I think</span>
<span class="comment-copy">I don't know how to use a dictionary. I am a beginner in python.</span>
<span class="comment-copy">please format your code: <a href="http://stackoverflow.com/posts/35594767/revisions">stackoverflow.com/posts/35594767/revisions</a></span>
<span class="comment-copy">If you got this question from the mooc or chuck severances course the answer is in the video.</span>
<span class="comment-copy">Yep, it is from MOOC.</span>
<span class="comment-copy">note: it is <code>O(n**2)</code> in time <code>O(1)</code> in space algorithm. It can be implemented in <code>O(n)</code> in time instead e.g., <a href="http://stackoverflow.com/a/35608206/4279">using <code>collections.Counter</code></a>.</span>
<span class="comment-copy">@J.F.Sebastian I was just trying to debug and fix(had so many free time) OPs code so didn't changed much. Thanks for the heads up though.</span>
<span class="comment-copy">1- <code>"".join(re.findall(r"[\w]+", s)))</code> is redundant. You could use <code>re.findall(r'\w', s)</code>. Note: <code>\w</code> matches more than <code>[a-zA-Z0-9_]</code> (the question has Python 3 tag). Though it is unnecessary: all non-whitespace characters are alphabetic here i.e., <code>''.join(s.split())</code> could be used instead. 2- Use <code>.casefold()</code> instead of <code>.lower()</code> for case-insensitive comparison of Unicode strings 3- In case of a tie, you could <a href="http://stackoverflow.com/a/35608206/4279">use <code>OrderedDict</code></a></span>
<span class="comment-copy">He is new one to Python , I think this code is compicated for him and dosen't help him.</span>
<span class="comment-copy">@Arman: it is not appropriate to downvote correct answers: 90+% visitors are from google. 2- If OP doesn't understand then OP can ask additional questions in the comment if something is unclear in the answer.</span>
<span class="comment-copy">as you see under question comments , I suggest him use dictionary , and he dont know wat dictionary is , and in this answer you suggest him complicated code , I'm surehe wont look at it , you may solve OP probelm not google visitors and it's not appreciated downvote descriptional answers because it's not return the full answer</span>
<span class="comment-copy">@Arman: you are wrong. 1- Answers should answer the question as stated. It is not a help site — It is Q/A site. There are other answers such as <a href="http://stackoverflow.com/a/35597313/4279">this O( n**2) solution that can help OP directly</a> 2- revenge-downvote is not appropriate. Vote on answers based on their content, not who is the author.</span>
<span class="comment-copy">It's not revenge , look at other answer , you comment under all of them and notice them they are wrong , and suggest an answer I'm not sure it's best , I upvoted the correct one and downvote other wrong and ugly one</span>
