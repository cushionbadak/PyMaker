<div class="post-text" itemprop="text">
<p>How can I write a mixin, which raises an Exception if the class which is using this specific mixin is not created properly. </p>
<p>If I do these checks and balances in the __init__ or __new__ methods of the mixin, Exception is raised when this  erroneous class tries to create an instance. Which is late, ideally the exception needs to be thrown when the compiler detects a wrong class. (Assuming, how to detect if a class is acceptable or not is a trivial matter)</p>
<p>To Illustrate the question </p>
<pre><code>class ASampleMixin:
    """
    A sample docstring
    """

    def a_method(self):
        raise NotImplementedError

    def class_rule(self):
        if something is wrong:
            return False
        return True 

    # more methods

class AClass(ASampleMixin, BaseClass):
    """
    This class should satisfy a condition specified in class_rule method of the mixin
    """
    # some methods
</code></pre>
<p>I am right now performing the check in the <strong>init</strong> method of mixin. Which raises an exception if rule returns False. Now this needs to be done at the time AClass is read by interpreter and not when I try to create an instance of AClass.</p>
<p>Is it possible even in dynamically typed languages like Python 3.5?</p>
</div>
<div class="post-text" itemprop="text">
<p>This sounds as if you want to create a custom metaclass that performs the check upon creation of the class object. See the <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow">documentation for metaclasses</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A metaclass example as reference:</p>
<pre><code>class CustomType(type):
    def __call__(cls, *args, **kwargs):
        if not CustomType.some_rule(kwargs.pop('some_attr', None)):
            raise Exception('Abort! Abort!')
        return super(CustomType, cls).__call__(*args, **kwargs)

    @staticmethod
    def some_rule(var):
        if type(var) is not str:
            return False
        return True


class A(object):
    __metaclass__ = CustomType


class B(A):
    pass

b = B(some_attr='f') # all is well
b = B() # raises 
</code></pre>
</div>
<span class="comment-copy">Thanks. Corrected it. Didnt focus on it and it just flowed out.</span>
<span class="comment-copy">Interesting... So basically adding this check and raising exception can be done in init of metaclass. Can the mixin and Aclass both derive from a different metaclass?</span>
<span class="comment-copy">@iankit If they do, the metaclass of the child is the <i>most derived metaclass</i> of the bases, which (from the documentation) is "selected from the explicitly specified metaclass (if any) and the metaclasses (i.e. type(cls)) of all specified base classes. The most derived metaclass is one which is a subtype of all of these candidate metaclasses. If none of the candidate metaclasses meets that criterion, then the class definition will fail with TypeError."</span>
<span class="comment-copy">This doesnt answer the question, in your code the exception is raised when instance is created from class. Which is an undesired outcome. I could have achieved this by default way itself.</span>
