<div class="post-text" itemprop="text">
<p>My Django project has hundreds of test in various modules across a number of apps. Recently we added a feature where an email gets sent (via sendgrid) on creation of a User object (using Django Signals).</p>
<p>The problem we ran into is that when running tests, many users are created either explicitly or as fixtures. This results in many hundreds of emails being sent on each test cycle, and because most of them are invalid we get hundreds of bounces. In addition to the costs involved, Sendgrid actually suspended our account briefly due to the odd behaviour.</p>
<p>Obviously I can mock the call on each test individually, however this would have to take place in hundreds of places, and we would have to remember to do it on all future tests we create.</p>
<p>Is there an easier way to globally mock a particular chunk of code for all tests (leaving it intact for when actually running of course)</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't use Django and maybe there is some idiomatic way to do it well in Django. </p>
<p>My approach to this kind of problem is to create my own <code>TestCase</code> class that extend from <code>unittest.TestCase</code> and override <code>setUpClass()</code>/<code>tearDownClass</code>/<code>setUp()</code>/<code>tearDown()</code> to set up the mock/patch that I need globally in my tests (or at least in a part of them).</p>
<p>Now every time I need it instead of importing <code>unittest.TestCase</code> module I'm importing <code>myunittest.TestCase</code></p>
<p>Example: <code>myunittest.py</code></p>
<pre><code>import unittest

class TestCase(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        super(TestCase, cls).setUpClass()
        # Init your class Mock/Patch

    @classmethod
    def tearDownClass(cls):
        # Remove Mocks or clean your singletons
        super(TestCase, cls).tearDownClass()

    def setUp(self):
        super(TestCase, self).setUp()
        # Init your obj Mock/Patch

    @classmethod
    def tearDown(self):
        # ... if you need it
        super(TestCase, self).tearDown()
</code></pre>
<p>And in your tests:</p>
<pre><code>from myunittest import TestCase

    class Test(TestCase):
        ... Your test
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Below are two methods to implement mocking.</p>
<p><strong>Method 1: With modifications to production code:</strong></p>
<p>You can create a pseudo-package and import it for testing instead of importing the original package. This check-based-import could be done at the beginning of every file. </p>
<p>For example:</p>
<pre><code>import os
    if 'TEST' in os.environ:
        import pseudoTime as time
    else:
        import time

print time.time
</code></pre>
<p><strong>Method 2: No modifications to production code:</strong></p>
<p>In your test program, you could import the utility package ( the package containing the email function described in the question) and overwrite the utility function. </p>
<p>For example:</p>
<p>Consider the following code:</p>
<pre><code>import time
def function():
    return time.time()
</code></pre>
<p>The test code could do the following:</p>
<pre><code>import code
import time

def helloWorld():
    return "Hello World"

print "Before changing ...", code.function()
oldTime = time.time # save
time.time = helloWorld
print "After changing ...", code.function()
time.time = oldTime # revert back
</code></pre>
<p>The output for above test was:</p>
<pre><code>Before changing ... 1456487043.76
After changing ... Hello World
</code></pre>
<p>Thus the test code can import the utility file, overwrite the function it provides and then run the tests on production code. </p>
<p>This method is superior as it does not change production code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Two ways that I have used in a big django project </p>
<p>Assuming a: <code>my_mock = patch("myapp.mymodule.MyClass.my_method")</code></p>
<p>1) You can add a mock inside a custom test runner class:</p>
<pre><code>from mock import patch
from django.test.runner import DiscoverRunner

class MyTestRunner(DiscoverRunner):
    @my_mock
    def run_tests(self, test_labels, **kwargs):
         return super(MyTestRunner, self).run_tests(test_labels, **kwargs)
</code></pre>
<p>2) You can add a mock on a custom base test class:</p>
<pre><code>from mock import patch
from django.test import TestCase

class MyTestCase(TestCase):

   def setUp(self):
      super(MyTestCase, self).setUp()
      my_mock.start()

   def tearDown(self):
      super(MyTestCase, self).tearDown()
      my_mock.stop()
</code></pre>
</div>
<span class="comment-copy">And put it at the head of every production code file? I hate IT!</span>
<span class="comment-copy">fair point. edited my answer to provide an additional method.</span>
<span class="comment-copy">Avoid globally monkey patching. Take a look to <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html#patch</a></span>
<span class="comment-copy">the example snippets are to illustrate the basic idea of mock testing.</span>
