<div class="post-text" itemprop="text">
<p>I am writing an LR(1) parser, and I've been basing my test grammar off of the C language. I've looked at the grammar for both C and Python:</p>
<p><a href="https://www.lysator.liu.se/c/ANSI-C-grammar-y.html" rel="nofollow">https://www.lysator.liu.se/c/ANSI-C-grammar-y.html</a>
<a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow">https://docs.python.org/3/reference/grammar.html</a></p>
<p>C seems to use the symbol CONSTANT for integer and floating point constants, and Python uses NUMBER.</p>
<p>What I'm wondering is why are these not separated into individual symbols such as INT and FLOAT so that they can later be put into separate nodes in the Abstract Syntax Tree?</p>
<p>Since we already know what type of number it is after the lexer has parsed it, why merge them into a generic 'NUMBER' and later try to figure out which one it is again?</p>
</div>
<div class="post-text" itemprop="text">
<p>Being able to handle <em>some</em> special cases earlier does not simplify things, since you still need the same code in a different place later. For example, consider the code <code>y + z</code>. Python doesn't know what that is, other than at run time it will invoke <code>y.__add__(z)</code>. The code to generate that isn't going away. That same code can take <code>3 + x</code> and just as easily generate <code>(3).__add__(z)</code>. So it doesn't really simplify anything to distinguish between <code>y + z</code> and <code>3 + z</code> during parsing. (The same logic holds if <code>y</code> is a float literal instead of an identifier.)</p>
<p>Now consider something like <code>3.0 + 5</code>. Separate code exists to replace this with <code>8.0</code> instead of <code>(3.0).__add__(5)</code> prior to byte-code compilation, because 1) it's simple to do and 2) it is demonstrably better than invoking a function at run time. However, this <em>still</em> isn't done by the parser. This is done by an optimizer that runs over the tree looking for things like <code>NUMBER + NUMBER</code>. Once that is found, the optimizer can determine if the <code>NUMBER</code>s are ints or floats, and produce the appropriate sum to include in the code. This is <em>simpler</em> than having to handle 4 different bits of parse tree <code>INT + FLOAT</code>, <code>FLOAT + INT</code>, <code>FLOAT + FLOAT</code>, and <code>INT + INT</code>.</p>
</div>
<span class="comment-copy">It only makes the grammar larger, and doesn't provide any real benefit.</span>
<span class="comment-copy">@n.m. How is <code>int x=2; double y=x/3.0;</code> handled? Clearly, it makes a difference whether the denominator is an integer or floating point constant. So something needs to keep track of the fact that the denominator was a floating point constant.</span>
<span class="comment-copy">@user3386109 Something does keep track of that. This "something" is just not the grammar, because it makes no sense to keep track of this in the grammar.</span>
<span class="comment-copy">@n.m. Ok, I was just thinking it would be easier to know what type of constant it is and just create the AST node without having to first parse the value string to figure out if it's an int or float.</span>
<span class="comment-copy">@SarathiJ.Hansen The parser doesn't need to know about the types at the grammar level. <code>expr ::= expr + expr</code> is the same rule regardless of types of the operands.The code generator knows about types but this information is not encoded in the grammar. It can be kept as semantic information in AST nodes, including literal nodes.</span>
