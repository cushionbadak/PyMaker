<div class="post-text" itemprop="text">
<p>I'm having trouble with the TYPES involved with this piece of code I wrote.  Ideally I wouldn't pay any mind to encoding types, but sometimes you're forced.</p>
<p>So this is all centered around a directory walk of an NTFS FS on Windows.  Certain characters in file names (unicode, it seems) couldn't be written out to files or printed to the standard windows terminal (yes, I tried "chcp 65001" to print, which didn't work, but I need to write to a standard plain text file anyway)</p>
<p>So I do the following.  As I understand it Python3 (I'm using 3.2.2) is unicode, so str() objects (and all supporting libs) are unicode, so I did this:</p>
<pre><code>absfilepath = os.path.join(root, file).encode()
</code></pre>
<p>thinking utf-8 string would be returned and all is good with the world, but then I was getting errors about implicit type conversions to <code>str()</code> when I went to file write or stdout.  So I did the following:</p>
<pre><code>hashmap[checksum] = str(absfilepath)
</code></pre>
<p>(the hashmap is dumped later).</p>
<p>thinking now it's in a native unicode Python3 string...but when I dump it into a file, using this:</p>
<pre><code>for key, val in m.items():
    f.write(key + "|" + val + "\n")
</code></pre>
<p>I still get this in the file:</p>
<pre><code>e77bceb64d179377731a94186e56281c|b'K:\Filename'
</code></pre>
<p>which is indicative as a byte array.</p>
<p>So what am I doing wrong here?  I'm sorry 'non-traditional' characters are in this directory tree, I'd rather them not be there, but they're there.  How do I store them (convert them?) into a manner that can be printed/written in normal plain text (ASCII?) and why is a byte array being returned from my hashmap where I'm clearly storing a standard string?  Dealing with unicode has been a pretty horrific experience for me.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>absfilepath = os.path.join(root, file).encode()
</code></pre>
<p><code>os.path.join()</code> returns a string, <code>str.encode()</code> converts the string to a bytes object, so <code>absfilepath</code> contains a bytes object.</p>
<pre><code>hashmap[checksum] = str(absfilepath)
</code></pre>
<p>When you call <code>str()</code> on a bytes object, the bytes object is <em>not</em> decoded but instead a string representation is created:</p>
<pre><code>&gt;&gt;&gt; str(b'K:\Filename')
"b'K:\\\\Filename'"
&gt;&gt;&gt; str(b'K:\Filename') == repr(b'K:\Filename')
True
</code></pre>
<p>So your dictionary now contains lots of <code>"b'some-bytes-string'"</code> strings.</p>
<p>The “fix” is simple: Just don’t encode the strings you get from <code>os.path.join</code>.</p>
<hr/>
<p>If you get errors while writing the strings out to the file, then consider specifying an explicit encoding when <em>opening</em> the file in text mode:</p>
<pre><code>with open('some_file', 'w', encoding='utf-8') as f:
    …
</code></pre>
<p>Then Python will automatically write strings correctly.</p>
<p>Alternatively, to be completely safe, you can also open the file in binary mode and write the encoded strings instead:</p>
<pre><code>with open('some_file', 'bw') as f:
    value = key + "|" + val + "\n"
    f.write(value.encode()) # write a bytes object
</code></pre>
<p>But as long as you are <em>within</em> Python, you don’t need to worry about special characters inside the string objects. Python can handle them; it’s just the output devices that typically fail (e.g. printing to the console).</p>
</div>
<div class="post-text" itemprop="text">
<p>You encoded your unicode string:</p>
<pre><code>absfilepath = os.path.join(root, file).encode()
#                                      ^^^^^^^^
</code></pre>
<p>This produces a bytestring. Either don't encode, or when storing the paths in your <code>hashmap</code> <em>decode</em> again:</p>
<pre><code>hashmap[checksum] = absfilepath.decode()
</code></pre>
</div>
<span class="comment-copy">It's a good idea to read <a href="http://www.joelonsoftware.com/articles/Unicode.html" rel="nofollow noreferrer">this article</a> to fix the different terms in your mind. The problem here is that the internal representation of strings in Python is just a sequence of code points. When you encode, you don't have characters anymore, you just have bytes which may be decoded back to unicode code points.</span>
<span class="comment-copy">Ok, what you're saying makes sense.  Seems I was a good bit confused as to what encode() did.  I will read this article, thank you!</span>
<span class="comment-copy">When working with filenames in Python 3, always make sure you pass <code>str</code>s.  It looks like you're unnecessarily encoding. On the console front, this module: <a href="https://github.com/Drekin/win-unicode-console" rel="nofollow noreferrer">github.com/Drekin/win-unicode-console</a> provides full Unicode support on the Windows console</span>
<span class="comment-copy">Yeah, I misunderstood the <code>str.encode()</code> function.  Definitely will change that.  Thanks for the tip for unicode support in Windows term.</span>
<span class="comment-copy">Ok, looks like i misunderstood the concept of str.encode() entirely.  I thought it gave me a str() object which represented a unicode string, not the raw byte array of it.  So if a certain unicode char was 2 bytes, after .encode() I would need to advance index by 2 to get to next "char" ?  Anyway, so looks like I either have to change the source (filenames) or change the the file encoding to unicode-8 or something which will handle them.  Alternatively I could maybe (?) use regex (which will be slow as heck I'm guessing) to find/replace non-ascii chars?  Any simple way to filter non-ascii out?</span>
<span class="comment-copy">Uhm, <a href="https://docs.python.org/3/library/stdtypes.html#str.encode" rel="nofollow noreferrer"><code>str.encode</code></a>’s default parameter value is <code>'utf-8'</code>…</span>
<span class="comment-copy">Wait, what? A <i>sane default</i>? Roight, I had that confused with the <code>open()</code> command default for <code>encoding</code>.</span>
<span class="comment-copy">Looks like I misunderstood encode().  Though if I try something like this (after I stored it like this: <code>hashmap[checksum] = absfilepath.decode()</code>), I still may get an error, right? <code>print(hashmap[checksum])</code> Because it'll be in unicode again in the map and the output device (term, file, w.e), may not be able to handle it and kick it back?</span>
<span class="comment-copy">@Syndacate: so why not encode when printing? Or use the <code>ascii()</code> function to produce ASCII-safe debugging output to print.</span>
<span class="comment-copy">@MartijnPieters:  I didn't even know about this function, it's probably my best bet I reckon, even if it does print it out weird like "\u1234" which makes it harder to post-process later with scripting - either that or I store in binary or utf-8 as somebody else suggested this way it could be read later.  Opening a file as UTF-8 and printing with ascii() may solve both, especially if I use Python (with Unicode support) to post-process the UTF-8 file later.  Thanks for your input!!</span>
