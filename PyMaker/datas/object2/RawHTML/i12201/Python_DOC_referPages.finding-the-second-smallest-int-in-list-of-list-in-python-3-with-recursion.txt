<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/35563893/recursively-find-the-kth-largest-int-in-list-of-list-of-int-in-python">Recursively find the kth largest int in list of list of int in Python</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I want to find the second smallest int in list of lists where empty list may exist. I got stuck at the flatten step. </p>
<p>my idea</p>
<ol>
<li><p>a unsorted list e.g [1, [3, 2], [[]], [4]],[[]], [12, 12], [[12], []], [[]]]</p></li>
<li><p>stucked!!!!!! Flatten the list with pure recursion. I tried to do this in the first part of recursive step. Above example become [1, 3, 2, 4], [12,12,12]  </p></li>
<li><p>find the second smallest int (completed)  </p></li>
</ol>
<p>Here is the code</p>
<pre><code>def find(abc):
#base case
if len(abc) == 2:
    if isinstance(abc[0], list) and isinstance(abc[1], list):
        re = find(abc[0] + abc[1])
    elif isinstance(abc[1], list):
        re = find(abc[:1] + abc[1])
    elif isinstance(abc[0], list):
        first = find(abc[0] + abc[1:])
    else:
        if abc[0] &gt; abc[1]:
            re = (abc[0], abc[1])
        else:
            re = (abc[1], abc[0])
# recursive step
else:
    #i think this part has problem 
    # flatten the list
    if isinstance(abc[0], list):
        re = find(abc[0] + abc[1:])
    # if this element is interger
    else:
        current = abc[0]
        second, first = find(abc[1:])
        if (second &lt; current):
            re = (second, first)
        elif (current &gt; first) and (second &gt;= current):
            re = (current, first)
        else:
            re = (first, current)            
return re
e.g   find([[[]], [12, 12], [[12], []], [[]]]) -&gt; (12, 12)
      find([1, [2, 3], [[]], [4]]) -&gt; (2, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Just Fixing the Issue:</strong>
You have to handle the case of an empty list in your recursion. A minimal (and admittedly somewhat hacky) change to your code would look something like this:</p>
<pre><code>import sys 

def find(abc):
    #base case
    if len(abc) == 2:
        if isinstance(abc[0], list) and isinstance(abc[1], list):
            re = find(abc[0] + abc[1:])
        elif isinstance(abc[1], list):
            re = find(abc[:1] + abc[1])
        elif isinstance(abc[0], list):
            re = find(abc[0] + abc[1:])
            # ^^^ fixed typo (ifs could be simplified by dropping first if)
        else:
            if abc[0] &gt; abc[1]:
                re = (abc[0], abc[1])
            else:
                re = (abc[1], abc[0])
    # recursive step
    else:
        # CHANGE HERE
        if len(abc) == 0:   # @HACK: handle empty list
            return (sys.maxsize, sys.maxsize)
        # CHANGE ENDS
        if isinstance(abc[0], list):
            re = find(abc[0] + abc[1:])
        # if this element is integer
        else:
            current = abc[0]
            second, first = find(abc[1:])
            if (second &lt; current):
                re = (second, first)
            elif (current &gt; first) and (second &gt;= current):
                re = (current, first)
            else:
                re = (first, current)            
    return re # @TODO: possibly filter out maxsize in final result
</code></pre>
<p>This is far from perfect (e.g. yielding maxsize if there are not enough values and maybe having additional bugs). </p>
<p><strong>Refactoring Your Code:</strong> 
Therefore, I would refactor your code in two ways. Firstly, I would separate out flattening and searching (i.e. flatten first and then search the flattened list):</p>
<pre><code>def flatten(li):
    for el in li:
        try:    # if strings can be in list, would have to check here
            for sub in flatten(el):
                yield sub
        except TypeError:
            yield el

def find(abc):
    abc = list(flatten(abc))

    def _smallest2(abc):
        # basically your implementation for finding the smallest two values
        if len(abc) &lt;= 2:
            return tuple(sorted(abc, reverse=True))
        current = abc[0]
        second, first = _smallest2(abc[1:])
        if (second &lt; current):
            re = (second, first)
        elif (current &gt; first) and (second &gt;= current):
            re = (current, first)
        else:
            re = (first, current)       
        return re

    return _smallest2(abc)
</code></pre>
<p>And secondly, I would use <a href="https://docs.python.org/3/library/heapq.html#heapq.nsmallest" rel="nofollow"><code>heapq.nsmallest</code></a> instead of your implementation for searching:</p>
<pre><code>import heapq

def flatten(li):
    for el in li:
        try:    # if strings can be in list, would have to check here
            for sub in flatten(el):
                yield sub
        except TypeError:
            yield el

def find(li):
    return tuple(heapq.nsmallest(2, flatten(li))[::-1])
</code></pre>
<p>If you are ok with a slightly different return value, feel free to drop the <code>tuple</code> and <code>[::-1]</code>.</p>
<p><strong>Alternative Implementation:</strong>
While I'd prefer the refactored code above for various reasons (e.g. robustness, expressiveness), here is an alternative implementation which arguably is more in line with your initial question. The main idea behind this implementation is to only check whether the first element is a list? If yes, flatten; if no, recursively go down the tail of the list:</p>
<pre><code>def find(abc):
    try:                                                          # first element is list
        return find(abc[0] + abc[1:])                             #  -&gt; flatten
    except:                                                       # first element is value
        if len(abc) &lt;= 1: return abc                              # -&gt; either end recursion
        return sorted(abc[:1] + find(abc[1:]), reverse=True)[-2:] # -&gt; or recurse over tail
</code></pre>
<p>Note that the return type is slightly different (list instead of tuple). And you could replace <code>sorted</code> with <code>heapq.nsmallest</code> (which arguably is more efficient for small <code>n</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>If your use case is huge and you want to avoid recursion, you can perform some iteration magic and avoid the recursion:</p>
<pre><code>def nested_walker(data):
    working_iterators = [iter(data)]
    while working_iterators:
        current_iterator = working_iterators.pop()
        for elem in current_iterator:
            if isinstance(elem, list):
                working_iterators.append(iter(elem))
            else:
                yield elem
</code></pre>
<p>And then, you could do things like:</p>
<pre><code>data = [[1, [3, 2], [[]], [4]],[[]], [12, 12], [[12], []], [[]]]
sorted_list = sorted(nested_walker(data))
print sorted_list[1]
</code></pre>
<p>There are more intelligent ways to retrieve the second smallest integer. To avoid sorting a potential huge size, you can use nested_walker being as it is a generator function.</p>
<hr/>
<p>As @stephan pointed out, there is a way to use <code>heapq</code> which avoids the sort:</p>
<pre><code>data = [[1, [3, 2], [[]], [4]],[[]], [12, 12], [[12], []], [[]]]
two_mins = heapq.nsmallest(2, nested_walker(data))
print two_mins[1]  # the [0] is the minimum
</code></pre>
<p>it is worth checking <a href="https://docs.python.org/3/library/heapq.html#heapq.nsmallest" rel="nofollow">the documentation about <code>heapq</code></a>, as it can be a little bit tricky in terms of performance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Iterate through the list then use <code>isinstance</code> to check if you need recursion:   </p>
<pre><code>def MIN(lst):
   mn = None
   for item in lst:
       if isinstance(item, list) and item:
           tmp = MIN(item)
       else:
           tmp = item

       if not mn:
          mn = tmp
       elif mn &gt; tmp:
           mn = tmp
   return mn

def find(lst):
  mins = []
  if not all(isinstance(item, list) for item in lst):
     mins.append(MIN(lst))
  for item in lst:
     if isinstance(item, list):
        mins.append(MIN(item))
  return filter(lambda x: x==0 or x, mins)

print find([[[]], [12, 12], [[12], []], [[]]])
print find([1, [2, 3], [[]], [4]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution in Python 3 which flattens the lists, sorts it and finally returns the second smallest item of the result:</p>
<pre><code>import collections

def flatten(l):
    for el in l:
        if isinstance(el, collections.Iterable) and not isinstance(el, (str, bytes)):
            for sub in flatten(el):
                yield sub
        else:
            yield el

a = flatten([[[]], [12, 12], [[12], []], [[]]])
b = flatten([1, [2, 3], [[]], [4]])

print(sorted(a)[1]) # 12
print(sorted(b)[1]) # 2
</code></pre>
<p>The <code>flatten</code> function was bluntly stolen from <a href="https://stackoverflow.com/questions/2158395/flatten-an-irregular-list-of-lists-in-python">this answer</a>. For Python 2.7 replace <code>(str, bytes)</code> with <code>basestring</code> in <code>flatten</code>.</p>
</div>
<span class="comment-copy">What is your exact problem?</span>
<span class="comment-copy">it cannot handle list with empty list</span>
<span class="comment-copy">So add another condition with <code>if len(abc) == 0:return</code></span>
<span class="comment-copy">Take into account the desired behaviour if there are repeated values. For instance: <code>data = [1, 1, 2, 3]</code> should result in <code>1</code> or <code>2</code>?</span>
<span class="comment-copy">i just realized i forgot to handle the empty list when i wanted to deal with empty list .</span>
<span class="comment-copy">@InWind: glad it was helpful. Looking back at your question a day later, I thought you might be also interested in a simple recursive implementation, (which I have added to the end of my answer now).</span>
<span class="comment-copy">+1 I like this solution. To avoid sorting a huge list, you could simply use <code>def find(abc): return heapq.nsmallest(2, nested_walker(abc))</code>.</span>
<span class="comment-copy">I was sure that <code>heapq</code> had some way to be used, but was in a rush. I will update the answer now, thanks!</span>
