<div class="post-text" itemprop="text">
<p>I'm launching a subprocess with the following command:</p>
<pre><code>p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
</code></pre>
<p>However, when I try to kill using:</p>
<pre><code>p.terminate()
</code></pre>
<p>or </p>
<pre><code>p.kill()
</code></pre>
<p>The command keeps running in the background, so I was wondering how can I actually terminate the process. </p>
<p>Note that when I run the command with:</p>
<pre><code>p = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
</code></pre>
<p>It does terminate successfully when issuing the <code>p.terminate()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="http://en.wikipedia.org/wiki/Process_group" rel="noreferrer">process group</a> so as to enable sending a signal to all the process in the groups. For that, you should attach a <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/setsid.html" rel="noreferrer">session id</a> to the parent process of the spawned/child processes, which is a shell in your case. This will make it the group leader of the processes. So now, when a signal is sent to the process group leader, it's transmitted to all of the child processes of this group.</p>
<p>Here's the code:</p>
<pre><code>import os
import signal
import subprocess

# The os.setsid() is passed in the argument preexec_fn so
# it's run after the fork() and before  exec() to run the shell.
pro = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                       shell=True, preexec_fn=os.setsid) 

os.killpg(os.getpgid(pro.pid), signal.SIGTERM)  # Send the signal to all the process groups
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
p.kill()
</code></pre>
<p><code>p.kill()</code> ends up killing the shell process and <code>cmd</code> is still running.</p>
<p>I found a convenient fix this by:</p>
<pre><code>p = subprocess.Popen("exec " + cmd, stdout=subprocess.PIPE, shell=True)
</code></pre>
<p>This will cause cmd to inherit the shell process, instead of having the shell launch a child process, which does not get killed.  <code>p.pid</code> will be the id of your cmd process then.</p>
<p><code>p.kill()</code> should work.</p>
<p>I don't know what effect this will have on your pipe though.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you can use <a href="https://pypi.python.org/pypi/psutil/" rel="noreferrer">psutil</a>, then this works perfectly:</p>
<pre><code>import subprocess

import psutil


def kill(proc_pid):
    process = psutil.Process(proc_pid)
    for proc in process.children(recursive=True):
        proc.kill()
    process.kill()


proc = subprocess.Popen(["infinite_app", "param"], shell=True)
try:
    proc.wait(timeout=3)
except subprocess.TimeoutExpired:
    kill(proc.pid)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I could do it using </p>
<pre><code>from subprocess import Popen

process = Popen(command, shell=True)
Popen("TASKKILL /F /PID {pid} /T".format(pid=process.pid))
</code></pre>
<p>it killed the <code>cmd.exe</code> and the program that i gave the command for.</p>
<p>(On Windows)</p>
</div>
<div class="post-text" itemprop="text">
<p>When <code>shell=True</code> the shell is the child process, and the commands are its children. So any <code>SIGTERM</code> or <code>SIGKILL</code> will kill the shell but not its child processes, and I don't remember a good way to do it.
 The best way I can think of is to use <code>shell=False</code>, otherwise when you kill the parent shell process, it will leave a defunct shell process.</p>
</div>
<div class="post-text" itemprop="text">
<p>None of this answers worked for me so Im leaving the code that did work. In my case even after killing the process with <code>.kill()</code> and getting a <code>.poll()</code> return code the process didn't terminate. </p>
<p>Following the <code>subprocess.Popen</code> <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>"...in order to cleanup properly a well-behaved application should kill the child process and finish communication..."</p>
</blockquote>
<pre><code>proc = subprocess.Popen(...)
try:
    outs, errs = proc.communicate(timeout=15)
except TimeoutExpired:
    proc.kill()
    outs, errs = proc.communicate()
</code></pre>
<p>In my case I was missing the <code>proc.communicate()</code> after calling <code>proc.kill()</code>. This cleans the process stdin, stdout ... and does terminate the process.</p>
</div>
<div class="post-text" itemprop="text">
<p>As Sai said, the shell is the child, so signals are intercepted by it -- best way I've found is to use shell=False and use shlex to split the command line:</p>
<pre><code>if isinstance(command, unicode):
    cmd = command.encode('utf8')
args = shlex.split(cmd)

p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
</code></pre>
<p>Then p.kill() and p.terminate() should work how you expect.</p>
</div>
<div class="post-text" itemprop="text">
<p>what i feel like we could use:</p>
<pre><code>import os
import signal
import subprocess
p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)

os.killpg(os.getpgid(pro.pid), signal.SIGINT)
</code></pre>
<p>this will not kill all your task but the process with the p.pid</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this is an old question but this may help someone looking for a different method. This is what I use on windows to kill processes that I've called.     </p>
<pre><code>si = subprocess.STARTUPINFO()
si.dwFlags |= subprocess.STARTF_USESHOWWINDOW
subprocess.call(["taskkill", "/IM", "robocopy.exe", "/T", "/F"], startupinfo=si)
</code></pre>
<p>/IM is the image name, you can also do /PID if you want. /T kills the process as well as the child processes. /F force terminates it. si, as I have it set, is how you do this without showing a CMD window. This code is used in python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Send the signal to all the processes in group</p>
<pre><code>    self.proc = Popen(commands, 
            stdout=PIPE, 
            stderr=STDOUT, 
            universal_newlines=True, 
            preexec_fn=os.setsid)

    os.killpg(os.getpgid(self.proc.pid), signal.SIGHUP)
    os.killpg(os.getpgid(self.proc.pid), signal.SIGTERM)
</code></pre>
</div>
<span class="comment-copy">What does your <code>cmd</code> look like? It might contain a command which triggers several processes to be started. So itâ€™s not clear which process you talk about.</span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/23434842/4279">Python: how to kill child process(es) when parent dies?</a></span>
<span class="comment-copy">does not having <code>shell=True</code> make a big difference?</span>
<span class="comment-copy"><code>preexec_fn=os.setpgrp</code> also works</span>
<span class="comment-copy">Does it work on Windows?</span>
<span class="comment-copy">How does <code>subprocess.CREATE_NEW_PROCESS_GROUP</code> relate to this?</span>
<span class="comment-copy">our testing sugggests that setsid != setpgid, and that os.pgkill only kills subprocesses that still have the same process group id.  processes that have changed process group are not killed, even though they may still have the same session id...</span>
<span class="comment-copy">@PiotrDobrogost: <a href="http://stackoverflow.com/a/13256908/4279"><code>CREATE_NEW_PROCESS_GROUP</code> can be used to emulate <code>start_new_session=True</code> on Windows</a></span>
<span class="comment-copy">Does this work on Windows and MAC.</span>
<span class="comment-copy">Nice and light solution for *nix, thanks! Works on Linux, should work for Mac as well.</span>
<span class="comment-copy">Very nice solution. If your cmd happens to be a shell script wrapper for something else, do call the final binary there with exec too in order to have only one subprocess.</span>
<span class="comment-copy">This is beautiful.  I have been trying to figure out how to spawn and kill a subprocess per workspace on Ubuntu. This answer helped me. Wish i could upvote it more than once</span>
<span class="comment-copy">this doesn't work if a semi-colon is used in the cmd</span>
<span class="comment-copy">This ended up working for me on Windows.</span>
<span class="comment-copy"><code>AttributeError: 'Process' object has no attribute 'get_children</code> for <code>pip install psutil</code>.</span>
<span class="comment-copy">I think get_children() should be children(). But it did not work for me on Windows, the process is still there.</span>
<span class="comment-copy">@Godsmith - psutil API has changed and you're right: <a href="http://pythonhosted.org/psutil/_modules/psutil.html#Process.children" rel="nofollow noreferrer">children()</a> does the same thing as get_children() used to. If it doesn't work on Windows, then you might want to create a bug ticket in <a href="https://github.com/giampaolo/psutil" rel="nofollow noreferrer">GitHub</a></span>
<span class="comment-copy">This works for windows. Thanks!</span>
<span class="comment-copy">This solution doesn't work for me in linux and python 2.7</span>
<span class="comment-copy">@xyz It did work for me in Linux and python 3.5. Check the docs for python 2.7</span>
<span class="comment-copy">@espinal, thanks, yes. It's possibly a linux issue. It's Raspbian linux running on a Raspberry 3</span>
<span class="comment-copy">In my case it doesn't really help given that cmd is "cd path &amp;&amp; zsync etc etc". So that actually makes the command to fail!</span>
<span class="comment-copy">Use absolute paths instead of changing directories...  Optionally os.chdir(...) to that directory...</span>
<span class="comment-copy">The ability to change the working directory for the child process is built-in. Just pass the <code>cwd</code> argument to <a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer"><code>Popen</code></a>.</span>
<span class="comment-copy">I used shlex, but still the issue persists, kill is not killing the child processes.</span>
