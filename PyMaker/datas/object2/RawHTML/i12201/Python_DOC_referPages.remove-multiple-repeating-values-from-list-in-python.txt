<div class="post-text" itemprop="text">
<p>I am processing large (~5000 lines) text files which have been generated by reporting software. These files have multiple header lines per page and many blank lines throughout. I have figured out a method for filtering out the data I don't need, but I am wondering if this is the best way to do this. I have this function that I use to filter the list, it is basically iterating over the list and reducing it by removing one of the filter lines each time. </p>
<pre><code>def process_block(b):
    b1 = [line for line in b if not line.startswith('100   V')]
    b2 = [line for line in b1 if not line.startswith('300   V')]
    b3 = [line for line in b2 if not line.startswith('400   V')]
    b4 = [line for line in b3 if not line.startswith('AR00000')]
    b5 = [line for line in b4 if not line.startswith('734 - C')]
    b6 = [line for line in b5 if not line.lstrip().startswith('TXN DAT')]
    b7 = [line for line in b6 if not line.startswith('   ACCO')]
    b8 = [line for line in b7 if not line.rstrip() == '']
    return b8
</code></pre>
<p>I feel like I'm doing more passes than necessary. Is there a better way to get this filtering done?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can definitely do it in one go.</p>
<pre><code>
def process_block(b)
    return [line for line in b if  
        not line.startswith(
                ('100   V', '300   V', '400   V', 'AR00000', '734 - C', '   ACCO')
            )
        and not line.lstrip().startswith('TXN DAT')
        and not line.rstrip() == ''] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#str.startswith" rel="nofollow"><code>str.startswith()</code></a> method accepts a tuple of prefix. So instead of multiple loops you can use one list comprehension and pass all the patters to one <code>startswith()</code> method.</p>
<p>And as a more pythonic way you can use following generator function to return an iterator filtered object from your file:</p>
<pre><code>def filter(file_name):
    prefixes = ("100   V", "300   V", "400   V",...)
    with open(file_name) as f:
        for line in f:
            if not line.lstrip().startswith(prefixes):
                yield line
</code></pre>
<p>If you are not consider about memory use, as a more faster way you can use a list comprehension to filter your file object out.</p>
<pre><code>filtered_obj = [line for line in file_object if not line.lstrip().startswith(prefixes)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might find these methods useful:</p>
<p>Given: </p>
<pre><code>a = ['test', 'test_1', 'test_2', 'test_3', 'test']

b = ['test']
</code></pre>
<p>We can subtract <code>b</code> from <code>a</code> as follows:</p>
<pre><code>c = list(set(a) - set(b))

print(c)
</code></pre>
<p>which produces:</p>
<pre><code>['test_3', 'test_2', 'test_1']
</code></pre>
<p>or we can remove duplicates as follows:</p>
<pre><code>c = list(dict(zip(a, [None]*len(a))).keys())

print(c)
</code></pre>
<p>which produces:</p>
<pre><code>['test_3', 'test_2', 'test', 'test_1']
</code></pre>
<p>Note that in the latter method, the order is lost. If you wish to preserve the order, use <code>collections.OrderedDict</code> from Python's native library. </p>
<p>Now it's just the matter of splitting your strings and manipulating them. </p>
</div>
<div class="post-text" itemprop="text">
<p>Put your patterns in a list and then you can veto any given line with</p>
<pre><code>patterns = ['aaa' , 'bbb']
any(line.startswith(p) for p in patterns)
</code></pre>
<p>To process the entire file, use <code>filter</code> to build an iterator</p>
<pre><code>for line in filter(lambda l: not any(l.startswith(p) for p in patterns), fp):
    print(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>str.startswith</code> can accept a tuple instead of a string:</p>
<pre><code>return [line for line in b if not line.startswith(
    '100   V', '300   V', '400   V', 'AR00000', '734 - C', '   ACCO'
    ) and not line.lstrip().startswith('TXN DATE') and line.rstrip() != '']
</code></pre>
</div>
<span class="comment-copy">You can use regex</span>
<span class="comment-copy">You are absolutely doing more passes than necessary. You could do <b>one loop</b> (starting <code>for line in b</code>) and append to a new list only if the line meets none of your conditions. Can you describe your conditions a little more generally (not as they appear in code)? It might even be simpler than that.</span>
<span class="comment-copy"><code>b1 = [line for line in b if not line.startswith('100   V') and not line.startswith('300   V') and not ...]</code></span>
<span class="comment-copy">Might also be something more ideal for sed/awk/grep.</span>
<span class="comment-copy">This was almost exactly what I needed. I just had make a couple changes to my filter strings and now I have the function down to one return statement using a list comprehension. Thanks!</span>
<span class="comment-copy">No problem. Glad to help!</span>
