<div class="post-text" itemprop="text">
<pre><code>x1 = 5
y1 = 5
x2 = 'Hello'
y2 = 'Hello'
x3 = [1,2,3]
y3 = [1,2,3]
print(x1 is y1)
print(x2 is y2)
print(x3 is y3)
</code></pre>
<p>Output</p>
<pre><code>True
True
False
</code></pre>
<p>why python assigns a different id to y3, other than x3.<br/>Here x3 and y3 are lists, python does the same with tuples and dictionaries too, I also want to know where else python has the same behaviour of assigning new id's to variables having the same values and why so?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because otherwise this would happen:</p>
<pre><code>x3 = [1,2,3]
y3 = [1,2,3]

x3[0] = "foo"
x3[0] == y3[0] // Does NOT happen!
</code></pre>
<p>In fact, </p>
<pre><code>x3[0] != y3[0]
</code></pre>
<p>which is a Good Thing™ . If <code>x3</code> and <code>y3</code> would be identical, changing one would change the other, too. That's generally not epected.</p>
<p>See also <a href="https://stackoverflow.com/questions/2123925/when-does-python-allocate-new-memory-for-identical-strings">when does Python allocate new memory for identical strings?</a> why the behaviour is different for strings.</p>
<p>Also, use <code>==</code> if you want to compare <em>values</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Tichodroma put it very nicely. However if you want to have same <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow"><code>id()</code></a> for lists, dicts, etc (if you want to have different names for the same object perhaps) that have same value, you can do it this way:</p>
<pre><code>&gt;&gt;&gt; x3 = y3 = [1,2,3]
&gt;&gt;&gt; print(x3 is y3)
True
</code></pre>
<p>In that case x3 and y3 are referencing the same list object in memory. So, if you change any one of them, the other is going to change.</p>
<pre><code>&gt;&gt;&gt; x3[1] = 10
&gt;&gt;&gt; y3
[1, 10, 3]
&gt;&gt;&gt; x3
[1, 10, 3]
</code></pre>
<h3>Bonus:</h3>
<p>If integer values are same, not always will they have same <code>id</code>. Take a look <a href="https://docs.python.org/2/c-api/int.html#c.PyInt_FromLong" rel="nofollow">here</a>.</p>
<blockquote>
<p>The current implementation keeps an array of integer objects for all
  integers between -5 and 256, when you create an int in that range you
  actually just get back a reference to the existing object.</p>
</blockquote>
<p>Test:</p>
<pre><code>&gt;&gt;&gt; n = 256
&gt;&gt;&gt; m = 256
&gt;&gt;&gt; n is m
True
&gt;&gt;&gt; n = 257
&gt;&gt;&gt; m = 257
&gt;&gt;&gt; n is m
False
&gt;&gt;&gt; 
</code></pre>
<p>One more interesting test (go figure!):</p>
<pre><code>&gt;&gt;&gt; 2**8 is 2**8
True
&gt;&gt;&gt; 2**9 is 2**9
False
</code></pre>
<p><strong>P.S.:</strong> I am running python 3.4. And the quotation from docs is for python 2.7 (I didn't find the equivalent for python 3.4). But still I am getting outputs like that in python 3.4 I am running. So the <em>current implementation</em> as said for python 2.7 seems still valid for python 3.4.</p>
</div>
<span class="comment-copy">Bonus: <code>print(253 is 252+1)</code> and <code>print(258 is 257+1)</code></span>
<span class="comment-copy">BonusBonus: <code>print("%s%s" % ("Hello" * 100,"World" * 100) is "Hello" * 100 + "World" * 100)</code></span>
<span class="comment-copy">Conclusion: Use <code>is</code> for <code>is None</code>, but for nothing more unless you know what you are doing and why you are doing it.</span>
<span class="comment-copy"><a href="https://en.wikibooks.org/wiki/Python_Programming/Data_Types#Mutable_vs_Immutable_Objects" rel="nofollow noreferrer">mutable vs immutable objects</a></span>
<span class="comment-copy">See <a href="http://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers" title="is operator behaves unexpectedly with integers">stackoverflow.com/questions/306313/…</a> basicaully what cpython does is that it saves all ints from 0 to NSMALLPOSINTS to optimize memory usage. Try for yourself <code>[sys.getrefcount(x) for x in range(300)]</code>.</span>
<span class="comment-copy">You mean to say, if x3 and y3 had same id then x3[0]==y3[0] would be True even if x3[0]='foo' and y3[0]=1?</span>
<span class="comment-copy">I agree with your answer, but your "In fact" is confusing me. What do you mean?</span>
<span class="comment-copy">In fact, changing <code>x3[0]</code> does <i>not</i> change <code>y3[0]</code>, they are <code>!=</code>. They are <i>not</i> <code>==</code>.</span>
<span class="comment-copy">Normally "being not <code>==</code>" is equivalent to "<code>!=</code>", so I still don't find it illustrative. Sorry, maybe I am nit-picking because I was trying to read between lines and I should have not...</span>
