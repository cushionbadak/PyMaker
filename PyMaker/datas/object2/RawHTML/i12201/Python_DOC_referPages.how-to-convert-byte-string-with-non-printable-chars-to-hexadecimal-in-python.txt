<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6624453/whats-the-correct-way-to-convert-bytes-to-a-hex-string-in-python-3">What's the correct way to convert bytes to a hex string in Python 3?</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<p>I have an ANSI string <code>Ď–ór˙rXüď\ő‡íQl7</code> and I need to convert it to hexadecimal like this: 
<code>06cf96f30a7258fcef5cf587ed51156c37</code> (converted with XVI32).</p>
<p>The problem is that Python cannot encode all characters correctly (some of them are incorrectly displayed even here, on Stack Overflow) so I have to deal with them with a byte string.</p>
<p>So the above string is in bytes this: <code>b'\x06\xcf\x96\xf3\nr\x83\xffrX\xfc\xef\\\xf5\x87\xedQ\x15l7'</code></p>
<p>And that's what I need to convert to hexadecimal.</p>
<p>So far I tried binascii with no success, I've tried this:</p>
<pre><code>h = ""
for i in b'\x06\xcf\x96\xf3\nr\x83\xffrX\xfc\xef\\\xf5\x87\xedQ\x15l7':
    h += hex(i)
print(h)
</code></pre>
<p>It prints: </p>
<p><code>0x60xcf0x960xf30xa0x720x830xff0x720x580xfc0xef0x5c0xf50x870xed0x510x150x6c0x37</code></p>
<p>Okay. It looks like I'm getting somewhere... but what's up with the <code>0x</code> thing?</p>
<p>When I remove 0x from the string like this:</p>
<pre><code>h.replace("0x", "")
</code></pre>
<p>I get <code>6cf96f3a7283ff7258fcef5cf587ed51156c37</code> which looks like it's correct. </p>
<p>But sometimes the byte string has a <code>0</code> next to a <code>x</code> and it gets removed from the string resulting in a incorrect hexadecimal string. (the string above is missing the 0 at the beginning).</p>
<p>Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're running python 3.5+, <code>bytes</code> type has an new <a href="https://docs.python.org/3/library/stdtypes.html#bytes.hex" rel="nofollow"><code>bytes.hex()</code></a> method that returns string representation.</p>
<pre><code>&gt;&gt;&gt; h = b'\x06\xcf\x96\xf3\nr\x83\xffrX\xfc\xef\\\xf5\x87\xedQ\x15l7'
b'\x06\xcf\x96\xf3\nr\x83\xffrX\xfc\xef\\\xf5\x87\xedQ\x15l7'
&gt;&gt;&gt; h.hex()
'06cf96f30a7283ff7258fcef5cf587ed51156c37'
</code></pre>
<p>Otherwise you can use <a href="https://docs.python.org/3/library/binascii.html#binascii.hexlify" rel="nofollow"><code>binascii.hexlify()</code></a> to do the same thing</p>
<pre><code>&gt;&gt;&gt; import binascii
&gt;&gt;&gt; binascii.hexlify(h).decode('utf8')
'06cf96f30a7283ff7258fcef5cf587ed51156c37'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As per the documentation, <a href="https://docs.python.org/3/library/functions.html#hex" rel="nofollow"><code>hex()</code></a> converts <em>“an integer number to a lowercase hexadecimal string prefixed with ‘0x’</em>.” So when using <code>hex()</code> you always get a <code>0x</code> prefix. You will always have to remove that if you want to concatenate multiple hex representations.</p>
<blockquote>
<p>But sometimes the byte string has a <code>0</code> next to a <code>x</code> and it gets removed from the string resulting in a incorrect hexadecimal string. (the string above is missing the <code>0</code> at the beginning).</p>
</blockquote>
<p>That does not make any sense. <code>x</code> is not a valid hexadecimal character, so in your solution it can <em>only</em> be generated by the <code>hex()</code> call. And that, as said above, will always create a <code>0x</code>. So the sequence <code>0x</code> can <em>never</em> appear in a different way in your resulting string, so replacing <code>0x</code> by nothing should work just fine.</p>
<p>The actual problem in your solution is that <code>hex()</code> does not enforce a two-digit result, as simply shown by this example:</p>
<pre><code>&gt;&gt;&gt; hex(10)
'0xa'
&gt;&gt;&gt; hex(2)
'0x2'
</code></pre>
<p>So in your case, since the string starts with <code>b\x06</code> which represents the number <code>6</code>, <code>hex(6)</code> only returns <code>0x6</code>, so you only get a single digit here which is the real cause of your problem.</p>
<hr/>
<p>What you can do is use format strings to perform the conversion to hexadecimal. That way you can both leave out the prefix and enforce a length of two digits. You can then use <code>str.join</code> to combine it all into a single hexadecimal string:</p>
<pre><code>&gt;&gt;&gt; value = b'\x06\xcf\x96\xf3\nr\x83\xffrX\xfc\xef\\\xf5\x87\xedQ\x15l7'
&gt;&gt;&gt; ''.join(['{:02x}'.format(x) for x in value])
'06cf96f30a7283ff7258fcef5cf587ed51156c37'
</code></pre>
<p>This solution does not only work with a bytes string but with really anything that can be formatted as a hexadecimal string (e.g. an integer list):</p>
<pre><code>&gt;&gt;&gt; value = [1, 2, 3, 4]
&gt;&gt;&gt; ''.join(['{:02x}'.format(x) for x in value])
'01020304'
</code></pre>
</div>
<span class="comment-copy">Wow, I did not know that. That’s great, thanks!</span>
<span class="comment-copy">and in reverse: <code>h = bytes.fromhex('06cf96f30a7283ff7258fcef5cf587ed51156c37')</code>.</span>
<span class="comment-copy">On Python 2, you could use <code>h.encode('hex')</code>.</span>
