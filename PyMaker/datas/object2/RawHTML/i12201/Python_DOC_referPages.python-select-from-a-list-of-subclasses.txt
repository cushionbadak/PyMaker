<div class="post-text" itemprop="text">
<p>i am a beginner of python and programming in general. I am trying to write a small program for some calculations. I have a material: concrete and several types of it. 
I created a base Concrete and several subclasses. Base class Concrete has some attributes that are equal for all subclasses. </p>
<pre><code>class Concrete:
    self.Name = name  #
    self.Rb = rb   #changes depending on concrete subclass
    self.alphabt = 0.0001 #equal for every concrete subclass

class concreteB25(Concrete):
    self.Name = 'B25'
    self.Rb = 25.0
 class concreteB30(Concrete):
    self.Name = 'B30'
    self.Rb = 30.0
</code></pre>
<p>User should select a concrete class. So i have two questions:1. How do i access the value that is equal for all subclasses(alphabt in this case). 2. how do i keep the chosen concrete? I am trying to use QCombobox but can't figure out how to use it properly for assigning. </p>
<pre><code>import sys
from PyQt5.QtWidgets import (QWidget,QComboBox,QLabel,QApplication)
import materials

class Form(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()
    def initUI(self):
        self.lbl = QLabel("Concrete",self)
        self.combo = QComboBox(self)
        concreteclasses = ['B25', 'B30']
        self.combo.addItems(concreteclasses)
        self.combo.move(50, 50)
        self.combo.activated[str].connect(self.onActivated)
        self.setGeometry(300,300,300,200)
        self.setWindowTitle('ConcreteComboBox')
        self.show()

    def onActivated(self, text):
        chosenclass = self.combo.itemText(self.combo.currentIndex())
        chosenConcrete = None
        if chosenclass == 'B25':
            chosenConcrete = materials.concreteB25()
        else:
            chosenConcrete = materials.concreteB30()
</code></pre>
<p>in materials i have concrete classes declared. Can anyone tell/suggest/help what i am doing wrong or show an example of same usage. </p>
<p>Thank you in advance. </p>
</div>
<div class="post-text" itemprop="text">
<p>I don't use Qt, so I can't help you with that side of things, but I can offer some suggestions to improve your class. </p>
<p>You don't need subclasses for the different types of concrete, just create instances of your Concrete class. To do that, you need to give the class an <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" rel="nofollow"><code>__init__</code></a> method.</p>
<p>The <code>alphabt</code> attribute can be defined as a class attribute, which is shared by all instances of the class.</p>
<p>It's a Good Idea to give a class a <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow"><code>__repr__</code></a> and/or <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow"><code>__str__</code></a> method so it provides useful information when you convert it to a string, either explicitly or when using <code>print</code>.</p>
<pre><code>class Concrete(object):
    alphabt = 0.0001

    def __init__(self, name, rb):
        self.name = name
        self.rb = rb

    def __repr__(self):
        return 'Concrete({0}, {1})'.format(self.name, self.rb)

def make_concrete(name):
    return Concrete(name, float(name[1:]))

concreteB25 = make_concrete('B25')
concreteB30 = make_concrete('B30')

print(concreteB25, concreteB30)
print(concreteB25.alphabt, Concrete.alphabt)
</code></pre>
<p><strong>output</strong></p>
<pre><code>Concrete(B25, 25.0) Concrete(B30, 30.0)
0.0001 0.0001
</code></pre>
<p>Note that we can access the <code>.alphabt</code> attribute from a <code>Concrete</code> instance or from the <code>Concrete</code> class itself.</p>
<p>BTW, the <a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="nofollow">format</a> string <code>'Concrete({0}, {1})'</code> can be simplified to <code>'Concrete({}, {})'</code> in Python 2.7 and later.</p>
<p>You could use the <code>make_concrete</code> helper function to create some pre-defined concrete instances in your <code>materials</code> module, or you could just use it in your <code>onActivated</code> method to create them "on the fly".</p>
</div>
<span class="comment-copy">thanks, in reality concrete class has many attributes: rb,rbn,rbtn, eb, and so on, in total around 15. so <b>init</b> should contain all of them, and when i create instances i should write all of them in make_concrete(name, rbn,rb, etc) . Is there a way around to initialise them faster. using a list maybe?</span>
<span class="comment-copy">@AldarBudayev: Well, you can pass a list or tuple or even a dict to a function in various ways. Take a look at <a href="https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions" rel="nofollow noreferrer">More on Defining Functions</a>, in particular <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">Unpacking Argument Lists</a>. If each of your concrete types is static (i.e. for each type all of the attributes are constant), you may find that it's better to use a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuple</a> instead of a class.</span>
