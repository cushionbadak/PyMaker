<div class="post-text" itemprop="text">
<p>I am moving code from Django 1.6 to 1.9.
In 1.6 I had this code</p>
<p>models.py</p>
<pre><code>class MyReport(models.Model):
    group_id    =   models.PositiveIntegerField(blank=False, null=False)
</code></pre>
<p>views.py</p>
<pre><code>query = MyReport.objects.filter(owner=request.user).query
query.group_by = ['group_id']
entries = QuerySet(query=query, model=MyReport)
</code></pre>
<p>The query would return <strong>one</strong> object for each 'group_id'; due to the way I use it, any table row with the group_id would do as a representative.</p>
<p>With 1.9 this code is broken. The query after the second line above is:</p>
<pre><code>SELECT "reports_myreport"."group_id", ... etc FROM "reports_myreport" WHERE "reports_myreport"."owner_id" = 1 GROUP BY "reports_myreport"."group_id", "reports_report"."otherfield", ...
</code></pre>
<p>Basically it lists <strong>all</strong> the table fields in the group by clause, making the query return the whole table.</p>
<p>Ever though in the debugger I see</p>
<pre><code>query.group_by = ['group_by'] 
</code></pre>
<p>It doesn't look like query.group_by is a method in 1.9 nor does the change-logs of 1.7-1.9 suggest that something changed.</p>
<p>Is there a better way - not depending on internal Django stuff - I can use for my query?</p>
<p>Any way to fix my current query?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.djangoproject.com/en/1.9/topics/db/aggregation/#order-by" rel="nofollow noreferrer">order_by()</a> to get the results ordered, in that same query you can order by a second criteria. </p>
<p>If your want to get the groups you will need to iterate over the collection to retrieve those values.</p>
<p>If you consume all of the results returned by the query, you can consider:</p>
<p>a) <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a> which makes an in-memory group by instead, but you should not use it for large data sets.</p>
<p>b) Another option is to use <a href="https://docs.djangoproject.com/en/1.9/topics/db/sql/#django.db.models.Manager.raw" rel="nofollow noreferrer">Manager.raw()</a> but you will need to write SQL inside Django, like this:</p>
<pre><code>for report in MyReport.objects.raw('SELECT * FROM reporting_report GROUP by group_id'):
     print(report)
</code></pre>
<p>This will work for large data sets, but you could lose compatibility with some database engines.</p>
<p><strong>Bonus:</strong> I recommend you to understand what exactly the old code did before doing a rewrite.</p>
</div>
<span class="comment-copy">What is <code>group_id</code> in relation to your <code>MyReport</code>? Could you show the relevant parts to your models?</span>
<span class="comment-copy">@Sayse `group_id' is a simple field in the mode. I edited the question with the relevant lines</span>
<span class="comment-copy">Ah ok, I was expecting it to be a foreign key... are you looking for <code>MyReport.objects.filter(owner=request.user).distinct('group_id')</code>?</span>
<span class="comment-copy">@Sayse at the moment I am not using Postgres, so I am not 100% sure. Does distinct(field) return the the table row or just the distinct fields? I can always do something like, but it doesn't seem the correct solution: ` objs = MyReport.objects.filter(owner=request.user).values_list('group_id', flat=True).distinct() for o in objs:  MyReport.objects.filter(owner=request.user, group_id=o)[0] `</span>
<span class="comment-copy">It returns distinct objects yes. So the complete models</span>
<span class="comment-copy">The old code would return one entry (complete table row) per each group_id. Whether it worked by mistake and now works as designed I don't know.   Both your solution should work but they suffer from problems as you yourself mentioned. My solution (could not get <code>code</code> to work) in the comment above also works, but I make queries as the number of groups which is far from ideal...</span>
<span class="comment-copy">Apparently, the old code worked by mistake. Doing a group_by without some aggregate is not really defined. The suggestions above (and my own in a previous comment) work. In Postgres this can be done simpler.</span>
