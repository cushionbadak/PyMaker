<div class="post-text" itemprop="text">
<p>I'm trying to determine the base of a URL, or everything besides the page and parameters. I tried using split, but is there a better way than splitting it up into pieces? Is there a way I can remove everything from the last '/'?</p>
<p>Given this:
<a href="http://127.0.0.1/asdf/login.php" rel="noreferrer">http://127.0.0.1/asdf/login.php</a></p>
<p>I would like:
<a href="http://127.0.0.1/asdf/" rel="noreferrer">http://127.0.0.1/asdf/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Well, for one, you could just use <a href="https://docs.python.org/3/library/os.path.html#os.path.dirname" rel="noreferrer"><code>os.path.dirname</code></a>:</p>
<pre><code>&gt;&gt;&gt; os.path.dirname('http://127.0.0.1/asdf/login.php')
'http://127.0.0.1/asdf'
</code></pre>
<p>It's not explicitly for URLs, but it happens to work on them (even on Windows), it just doesn't leave the trailing slash (you can just add it back yourself).</p>
<p>You may also want to look at <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlparse" rel="noreferrer"><code>urllib.parse.urlparse</code></a> for more fine-grained parsing; if the URL has a query string or hash involved, you'd want to parse it into pieces, trim the <code>path</code> component returned by parsing, then recombine, so the path is trimmed without losing query and hash info.</p>
<p>Lastly, if you want to just split off the component after the last slash, you can do an <a href="https://docs.python.org/3/library/stdtypes.html#str.rsplit" rel="noreferrer"><code>rsplit</code></a> with a <code>maxsplit</code> of <code>1</code>, and keep the first component:</p>
<pre><code>&gt;&gt;&gt; 'http://127.0.0.1/asdf/login.php'.rsplit('/', 1)[0]
'http://127.0.0.1/asdf'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best way to do this is use <a href="https://docs.python.org/3/library/urllib.parse.html" rel="nofollow noreferrer"><code>urllib.parse</code></a>.</p>
<p>From the docs:</p>
<blockquote>
<p>The module has been designed to match the Internet RFC on Relative
  Uniform Resource Locators. It supports the following URL schemes:
  <code>file</code>, <code>ftp</code>, <code>gopher</code>, <code>hdl</code>, <code>http</code>, <code>https</code>, <code>imap</code>, <code>mailto</code>, <code>mms</code>, <code>news</code>, <code>nntp</code>,
  <code>prospero</code>, <code>rsync</code>, <code>rtsp</code>, <code>rtspu</code>, <code>sftp</code>, <code>shttp</code>, <code>sip</code>, <code>sips</code>, <code>snews</code>, <code>svn</code>,
  <code>svn+ssh</code>, <code>telnet</code>, <code>wais</code>, <code>ws</code>, <code>wss</code>.</p>
</blockquote>
<p>You'd want to do something like this using <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlsplit" rel="nofollow noreferrer">urlsplit</a> and <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlunsplit" rel="nofollow noreferrer">urlunsplit</a>:</p>
<pre><code>from urllib.parse import urlsplit, urlunsplit

split_url = urlsplit('http://127.0.0.1/asdf/login.php?q=abc#stackoverflow')

# You now have:
# split_url.scheme   "http"
# split_url.netloc   "127.0.0.1" 
# split_url.path     "/asdf/login.php"
# split_url.query    "q=abc"
# split_url.fragment "stackoverflow"

# Use all the path except everything after the last '/' 
clean_path = "".join(split_url.path.rpartition("/")[:-1])

# "/asdf/"

# urlunsplit joins a urlsplit tuple
clean_url = urlunsplit(split_url)

# "http://127.0.0.1/asdf/login.php?q=abc#stackoverflow"


# A more advanced example 
advanced_split_url = urlsplit('http://foo:bar@127.0.0.1:5000/asdf/login.php?q=abc#stackoverflow')

# You now have *in addition* to the above:
# advanced_split_url.username   "foo"
# advanced_split_url.password   "bar"
# advanced_split_url.hostname   "127.0.0.1"
# advanced_split_url.port       "5000"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Get the right-most occurence of slash; use the string slice <em>through</em> that position in the original string.  The <strong>+1</strong> gets you that final slash at the end.</p>
<pre><code>link = "http://127.0.0.1/asdf/login.php"
link[:link.rfind('/')+1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No need to use a regex, you can just use <code>rsplit()</code>:</p>
<pre><code>&gt;&gt;&gt; url = 'http://127.0.0.1/asdf/login.php'
&gt;&gt;&gt; url.rsplit('/', 1)[0]
'http://127.0.0.1/asdf'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you use python3, you can use urlparse and urlunparse.</p>
<pre><code>In :from urllib.parse import urlparse, urlunparse

In :url = "http://127.0.0.1/asdf/login.php"

In :result = urlparse(url)

In :new = list(result)

In :new[2] = new[2].replace("login.php", "")

In :urlunparse(new)
Out:'http://127.0.0.1/asdf/'
</code></pre>
</div>
<span class="comment-copy"><code>re.sub(r"[^/]*(\?.*)?$", "", x)</code></span>
<span class="comment-copy">This may be considered as cheating, but you could use <code>os.path.dirname()</code>.  I'm not sure if that would work on Windows, but it works on Linux.</span>
<span class="comment-copy">@zondo: I'm on Windows, and it definitely worked for me (on Py 3.5.1).</span>
<span class="comment-copy">@ShadowRanger: No fair taking my idea. :( What do I care? I upvoted anyway.</span>
<span class="comment-copy">@zondo: I actually posted my answer before your comment. :-) I have since edited to add some alternatives and clarification (though no edit history is shown, odd), but it was literally the first thing I tried. It does help that I happen to be on Windows, so I could quickly confirm that it worked on Windows too.</span>
<span class="comment-copy">Do you know why <code>os.path.dirname</code> also handle URLs so well?</span>
<span class="comment-copy">@dalanmiller: Because they use the same separators. Even on Windows, a forward slash is a legal path separator (it's just that Windows uses backslashes by preference), so path manipulation APIs are designed to handle forward slashes everywhere, and URLs use them in the same way.</span>
<span class="comment-copy">Given that the question has to do with URLs, I'd say <code>urllib.parse</code> should be the recommended portion of stdlib to use.</span>
<span class="comment-copy">Your split and rejoin should probably use <code>'/'.join</code>, or you'll strip all the slashes. Another more clever approach might be <code>"".join(split_url.rpartition('/')[:-1]</code>, which performs only one split, and if no slashes exist, effectively becomes a noop.</span>
<span class="comment-copy">Awesome tip ShadowRanger, I've always wondered if you could do that but never thought to look. Congrats on the answer ;)</span>
<span class="comment-copy">Probably better to use <code>rindex</code> for this; otherwise, if you have a string without slashes, you'll silently return the empty string (because <code>rfind</code> will return -1, you'll add 1, and slice from 0 to 0). At least with <code>rindex</code>, you'll get an exception rather than continuing on until having an empty string causes everything to blow up.</span>
