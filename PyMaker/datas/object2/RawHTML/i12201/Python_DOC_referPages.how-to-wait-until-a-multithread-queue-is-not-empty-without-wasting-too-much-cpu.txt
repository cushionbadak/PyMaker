<div class="post-text" itemprop="text">
<p>I want to make a thread wait until a multithread queue is not empty. The queue has only one producer and one consumer. The producer places tasks in the queue when available but the producer has to wait until two or more tasks have been gathered. The reason why I don't just use the <code>get</code> method twice in order to retrieve two tasks is because it over complicates the flow of the algorithm. That cannot be depicted in the snippet bellow though, because obviously it's just an oversimplified example.</p>
<p>I need to know that the queue is not empty so that I can compare the peak of the queue (without removing it) with the element I just removed with <code>get</code></p>
<p>How it could be done with sleep:</p>
<pre><code>while myQueue.empty():
    sleep(0.05)
</code></pre>
<p>How can I do that without using sleep? Should I use <code>event.wait()</code>? If yes, I cannot figure out how I should properly use the <code>event.clear()</code> command. Since the thread that I want to make wait is also the consumer and I cannot be sure whether the queue is empty. Even if I use <code>queue.empty()</code> to check.</p>
</div>
<div class="post-text" itemprop="text">
<p>Essentially, it seems you need to implement the <code>Queue.peek()</code> method, that would return the next element in the queue without actually removing it.</p>
<p>This method is not available in the standard Queue object, but you can inherit and expand it without problems:</p>
<pre><code>from Queue import Queue
class VoyeurQueue(Queue):
    def peek(self, block=True, timeout=None):
        # ...
</code></pre>
<p>Now for the contents of new <code>peek()</code> method, you can simply copy-paste the contents of <code>get()</code> method of the base <code>Queue</code> object with some modifications. You can find it at <code>/usr/lib/python?.?/Queue.py</code> if you're on Linux, or <code>%PYTHONPATH%/lib/Queue.py</code> if you're on Windows (not sure about the latter as I'm currently on Linux machine and cannot check). In my copy of Python 2.7, the <code>get()</code> method is implemented as:</p>
<pre><code>def get(self, block=True, timeout=None):
    # ... lots of comments
    self.not_empty.acquire()
    try:
        if not block:
            if not self._qsize():
                raise Empty
        elif timeout is None:
            while not self._qsize():
                self.not_empty.wait()
        elif timeout &lt; 0:
            raise ValueError("'timeout' must be a non-negative number")
        else:
            endtime = _time() + timeout
            while not self._qsize():
                remaining = endtime - _time()
                if remaining &lt;= 0.0:
                    raise Empty
                self.not_empty.wait(remaining)
        item = self._get()
        self.not_full.notify()
        return item
    finally:
        self.not_empty.release()

def _get(self):
    return self.queue.popleft()
</code></pre>
<p>Now, for differences. You don't want to <em>remove</em> the element, so instead of <code>_get()</code> we define the following:</p>
<pre><code>def _peek(self):
    return self.queue[0]
</code></pre>
<p>And in the <code>peek()</code> method, we still use the <code>self.not_empty</code> Condition but we no longer need the <code>self.not_full.notify()</code>. So the resulting code will look like:</p>
<pre><code>from Queue import Queue

class VoyeurQueue(Queue):

    def peek(self, block=True, timeout=None):
        self.not_empty.acquire()
        try:
            if not block:
                if not self._qsize():
                    raise Empty
            elif timeout is None:
                while not self._qsize():
                    self.not_empty.wait()
            elif timeout &lt; 0:
                raise ValueError("'timeout' must be a non-negative number")
            else:
                endtime = _time() + timeout
                while not self._qsize():
                    remaining = endtime - _time()
                    if remaining &lt;= 0.0:
                        raise Empty
                    self.not_empty.wait(remaining)
            item = self._peek()
            return item
        finally:
            self.not_empty.release()

    def _peek(self):
        return self.queue[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a semaphore, initialized at zero, in parallel to the queue. Let say for example <code>mySemaphore = threading.Semaphore(0)</code>. By default the thread calling <code>mySempahore.acquire()</code> will be blocked as the semaphore is zero without touching the queue. Then when you put someting in the queue, you can call <code>mySemaphore.release()</code> that will allow one thread to execute (util the next loop is suppose).</p>
</div>
<div class="post-text" itemprop="text">
<p>Just <code>myQueue.get(block=True)</code> will bock your thread (stop its execution) until there is something to retrieve from the queue. When an item is availabe in the queue it will be returned by this call. You can add a timeout in case you want to exit if the queue is never feed.</p>
<p>See <a href="https://docs.python.org/3/library/queue.html#queue.Queue.get" rel="nofollow">https://docs.python.org/3/library/queue.html#queue.Queue.get</a>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I want to make a thread wait until a multithread queue is not empty.</p>
<p>I want to avoid retrieving the next object, that's why I am not using the get method</p>
</blockquote>
<p>If you don't mind using a sentinel object (I use one I name <code>Done</code> to tell my consumer thread we're done so it can wrap up.)</p>
<pre><code>Start = object() # sentinel object on global scope.
</code></pre>
<p>in producer:</p>
<pre><code>queue.put(Start)
</code></pre>
<p>and in worker:</p>
<pre><code>item = queue.get() # blocks until something received
if item is Start:
    print('we have now started!')
</code></pre>
<p>I'm not sure why you'd do that though, but this does seem to do what you want it to do.</p>
</div>
<span class="comment-copy">Typically this is done using pair mutex + condition variable. Haven't used these in Python though.</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/threading.html#event-objects" rel="nofollow noreferrer">docs.python.org/2/library/threading.html#event-objects</a> Notify the waiting thread as soon as the consumer empties the queue.</span>
<span class="comment-copy">Please clarify: do you want to detect a non-empty queue even if other consumer threads will process the task, or do you wish to detect a non-empty queue only if it was allocated to the thread in question? I.e. in a situation where threads A, B &amp; C are waiting for queue and a task is put into the queue, do you want thread A to wake up even though the task was picked and processed by thread B?</span>
<span class="comment-copy">Clarify: is your thread trying to consume from the same queue for which it should wait to empty, or is it consuming from another queue?</span>
<span class="comment-copy">I updated the question</span>
<span class="comment-copy">The <code>not</code> in the snippet, as the question suggests, was wrong! sorry for that. I want to block a thread until the queue is not empty.</span>
<span class="comment-copy">@LetsPlayYahtzee So essentially you want <code>Queue.get()</code>, but without actually retrieving the element from the queue? If so, you could try accessing <code>Queue.not_empty</code> <a href="https://docs.python.org/2.7/library/threading.html#condition-objects" rel="nofollow noreferrer">Condition</a> object. It's not documented, but it's what <code>Queue.get()</code> actually uses. Your code would then be practically identical to <code>Queue.get()</code>, sans actual item retrieval.</span>
<span class="comment-copy">I want to  avoid retrieving the next object, that's why I am not using the <code>get</code> method</span>
<span class="comment-copy">Then a recommend you to use a semaphore initialized at zero in parallel.  See now answer.</span>
