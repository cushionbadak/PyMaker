<div class="post-text" itemprop="text">
<p>I want to check if two lists have the same type of items for every index. For example if I have</p>
<pre><code>y = [3, "a"]
x = [5, "b"] 
z = ["b", 5]
</code></pre>
<p>the check should be <code>True</code> for <code>x</code> and <code>y</code>.
The check should be <code>False</code> for <code>y</code> and <code>z</code> because the types of the elements at the same positions are not equal.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just <a href="https://docs.python.org/2.7/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> the elements to their respective <a href="https://docs.python.org/2.7/library/functions.html#type" rel="nofollow noreferrer"><code>type</code></a> and compare those:</p>
<pre><code>&gt;&gt;&gt; x = [5, "b"] 
&gt;&gt;&gt; y = [3, "a"]
&gt;&gt;&gt; z = ["b", 5]
&gt;&gt;&gt; map(type, x) == map(type, y)
True
&gt;&gt;&gt; map(type, x) == map(type, z)
False
</code></pre>
<p>For Python 3, you will also have to turn the <code>map</code> generators into proper lists, either by using the <a href="https://docs.python.org/3/library/functions.html#func-list" rel="nofollow noreferrer"><code>list</code></a> function or with a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>:</p>
<pre><code>&gt;&gt;&gt; list(map(type, x)) == list(map(type, y))
True
&gt;&gt;&gt; [type(i) for i in x] == [type(i) for i in z]
False
</code></pre>
<hr/>
<p>I did some timing analysis, comparing the above solution to that of <a href="https://stackoverflow.com/a/35554318/1639625">@timgeb</a>, using <code>all</code> and <code>izip</code> and inputs with the first non-matching type in different positions. As expected, the time taken for the <code>map</code> solution is almost exactly the same for each input, while the <code>all</code> + <code>izip</code> solution can be <em>very</em> fast or take three times as long, depending on the position of the first difference.</p>
<pre><code>In [52]: x = [1] * 1000 + ["s"] * 1000
In [53]: y = [2] * 1000 + ["t"] * 1000 # same types as x
In [54]: z = ["u"] * 1000 + [3] * 1000 # difference at first element
In [55]: u = [4] * 2000                # difference after first half
In [56]: %timeit map(type, x) == map(type, y)
10000 loops, best of 3: 129 µs per loop
In [58]: %timeit all(type(i) == type(j) for i, j in izip(x, y))
1000 loops, best of 3: 342 µs per loop
In [59]: %timeit all(type(i) == type(j) for i, j in izip(x, z))
1000000 loops, best of 3: 748 ns per loop
In [60]: %timeit all(type(i) == type(j) for i, j in izip(x, u))
10000 loops, best of 3: 174 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Lazy evaluation with <code>all</code>:</p>
<pre><code>&gt;&gt;&gt; from itertools import izip
&gt;&gt;&gt; all(type(a) == type(b) for a,b in izip(x,y))
True
</code></pre>
<p>Use regular <code>zip</code> in Python 3, it already returns a generator.</p>
<p>If the lists can have different lengths, just check the length upfront. Checking the length is a very fast O(1) operation:</p>
<pre><code>&gt;&gt;&gt; len(x) == len(y) and all(type(a) == type(b) for a,b in izip(x,y))
True
&gt;&gt;&gt; x = [5,"b",'foo']
&gt;&gt;&gt; len(x) == len(y) and all(type(a) == type(b) for a,b in izip(x,y))
False
</code></pre>
<p>The <code>and</code> will be short-circuit evaluated, that means <code>all</code> won't even be called if the lengths differ.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another option with lambda:</p>
<pre><code>&gt;&gt;&gt; x = [5, "b"]
&gt;&gt;&gt; y = [3, "a"]
&gt;&gt;&gt; z = ["b", 5]
&gt;&gt;&gt; g = lambda t: [type(i) for i in t]
&gt;&gt;&gt; g(x) == g(y)
True
&gt;&gt;&gt; g(x) == g(z)
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's very simple when you use a generator expression:</p>
<pre><code>are_equal = all(type(i) == type(j) for i, j in zip(x, y))
</code></pre>
<p>In that example, <code>x</code> and <code>y</code> are the lists you are checking.  If you want something that you can add to:</p>
<pre><code>lists = (x, y)
are_equal = all(len(set(type(j) for j in i)) == 1 for i in zip(*lists))
</code></pre>
<p>In that way, you can just change <code>lists</code>, and it will still work.  It works by using the fact that a <code>set</code> removes all duplicates.  For each tuple that <code>zip()</code> returns, it creates a set of each item's types and checks to see if they have are the same by seeing if the length of the set is 1.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def equalTypes(list1, list2):
    if len(list1) != len(list2):
        return False
    for index, item in enumerate(list1):
        if type(item) != type(list2[index]):
            return False
    return True
</code></pre>
<p>I just iterate over the list (check if they have same length first) and then when some types mismatch I return False. At the end (no mismatch) I return True.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can keep the lazy evaluation using <code>operator.eq</code> with <code>itertools</code> which overall gives you decent average times without storing copies of the lists:</p>
<pre><code>In [12]: from itertools import imap, starmap, izip

In [13]: %timeit map(type, x) == map(type, y)
10000 loops, best of 3: 182 µs per loop

In [14]: %timeit all(type(i) == type(j) for i, j in izip(x, u))
1000 loops, best of 3: 239 µs per loop

In [15]: timeit all(type(i) == type(j) for i, j in izip(x, z))
1000000 loops, best of 3: 1.02 µs per loop

In [16]:  %timeit all(type(i) == type(j) for i, j in izip(x, u))
1000 loops, best of 3: 234 µs per loop

In [17]: timeit all(starmap(eq, izip(imap(type, x), imap(type, y))))
1000 loops, best of 3: 238 µs per loop

In [18]: timeit all(starmap(eq, izip(imap(type, x), imap(type, u))))
10000 loops, best of 3: 120 µs per loop

In [19]: timeit all(starmap(eq, izip(imap(type, x), imap(type, z))))
1000000 loops, best of 3: 901 ns per loop
</code></pre>
<p>If the lists were different lengths, just checking the lengths first ould be the simplest and fastest but if you were to incorporate it into the logic you could use <em>object</em> as the <em>fillvalue</em> to <code>itertools.izip_longest</code>:</p>
<pre><code>all(starmap(eq, izip_longest(imap(type, x), imap(type, y), fillvalue=object()))
</code></pre>
</div>
<span class="comment-copy">the use of "all(...)" would make it faster, something like @timgeb does</span>
<span class="comment-copy">@fransua Maybe, but you'd have to use <code>itertools.izip_longest</code> then, or it will not work with lists with unequal length, and IMHO this just complicates the code (unless the lists are particularly long).</span>
<span class="comment-copy">Nice, but does not work with lists with different length... maybe use <code>itertools.izip_longest</code> instead?</span>
<span class="comment-copy">It would still work, though, so I see no necessity for <code>itertools</code>.  I don't see that a list of tuples is worse than a generator.</span>
<span class="comment-copy">@tobias_k I thought about <code>izip_longest</code>, but what would you use as a fillvalue which cannot be an element of a list? I think just checking the length upfront is better here.</span>
<span class="comment-copy">@zondo a generator is more memory efficient, it can make a big difference when the lists are very large. The generator will also produce only as many tuples as needed.</span>
<span class="comment-copy">@zondo no, not all tuples are needed. For <code>x = [1, 2, 3]</code> and <code>y = ['foo', 2, 3]</code> only the first tuple is needed.</span>
<span class="comment-copy">Your second part does not compare types based on position. Particularly, it shows <code>true</code> for <code>x</code> and <code>z</code>.</span>
<span class="comment-copy">@tobias_k: Oops; I just left out a couple characters.  Fixed now.</span>
<span class="comment-copy">I don't see what you mean.  <code>set(type(j) for j in i))</code> gives a set of the type of each element in the current zip tuple.  If the length of that set is not 1, then one of those elements is a different type from the other.  I have tested it, and to all appearances, it works.  Is there something I'm missing?</span>
<span class="comment-copy">You are right, sorry, got confused what the line does and seem to have made a mistake when testing. +1 for a solution that works for comparing the types of an arbitrary number of lists, but for two lists, I think this solution is <i>very</i> hard to comprehend.</span>
<span class="comment-copy">I have attempted to give somewhat of an explanation in my answer.  Is there anything that could potentially be unclear in it?</span>
<span class="comment-copy">Explain your code...</span>
