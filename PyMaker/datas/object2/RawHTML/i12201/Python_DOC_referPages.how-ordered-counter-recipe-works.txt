<div class="post-text" itemprop="text">
<p>Reading how <code>super()</code> works, I came across <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="nofollow noreferrer">this recipe</a> on how to create an Ordered Counter:</p>
<pre><code>from collections import Counter, OrderedDict

class OrderedCounter(Counter, OrderedDict):
     'Counter that remembers the order elements are first seen'
     def __repr__(self):
         return '%s(%r)' % (self.__class__.__name__,
                            OrderedDict(self))
     def __reduce__(self):
         return self.__class__, (OrderedDict(self),)
</code></pre>
<p>For example:</p>
<pre><code>oc = OrderedCounter('adddddbracadabra')

print(oc)

OrderedCounter(OrderedDict([('a', 5), ('d', 6), ('b', 2), ('r', 2), ('c', 1)]))
</code></pre>
<p>Is someone able to explain how this magically works?</p>
<p>This also appears in the <a href="https://docs.python.org/3/library/collections.html#ordereddict-examples-and-recipes" rel="nofollow noreferrer">Python documentation</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>OrderedCounter is given as an example in the <a href="https://docs.python.org/3.4/library/collections.html?highlight=ordereddict#ordereddict-examples-and-recipes" rel="noreferrer" title="documentation">OrderedDict documentation</a>, and works without needing to override any methods: </p>
<pre><code>class OrderedCounter(Counter, OrderedDict):
    pass
</code></pre>
<p>When a class method is called, Python has to find the correct method to execute. There is a defined order in which it searches the class hierarchy called the "method resolution order" or mro.  The mro is stored in the attribute <code>__mro__</code>:</p>
<pre><code>OrderedCounter.__mro__

(&lt;class '__main__.OrderedCounter'&gt;, &lt;class 'collections.Counter'&gt;, &lt;class 'collections.OrderedDict'&gt;, &lt;class 'dict'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p>When an instance of an OrderedDict is calling <code>__setitem__()</code>, it searches the classes in order: <code>OrderedCounter</code>, <code>Counter</code>, <code>OrderedDict</code> (where it is found).  So an statement like <code>oc['a'] = 0</code> ends up calling  <code>OrderedDict.__setitem__()</code>.</p>
<p>In contrast, <code>__getitem__</code> is not overridden by any of the subclasses in the mro, so <code>count = oc['a']</code> is handled by <code>dict.__getitem__()</code>.</p>
<pre><code>oc = OrderedCounter()    
oc['a'] = 1             # this call uses OrderedDict.__setitem__
count = oc['a']         # this call uses dict.__getitem__
</code></pre>
<p>A more interesting call sequence occurs for a statement like <code>oc.update('foobar').</code> First, <code>Counter.update()</code> gets called.  The code for <code>Counter.update()</code> uses self[elem], which gets turned into a call to <code>OrderedDict.__setitem__()</code>.  And the code for <em>that</em> calls <code>dict.__setitem__()</code>.</p>
<p>If the base classes are reversed, it no longer works.  Because the mro is different and the wrong methods get called.</p>
<pre><code>class OrderedCounter(OrderedDict, Counter):   # &lt;&lt;&lt;== doesn't work
    pass
</code></pre>
<p>More info on mro can be found in the Python 2.3 <a href="https://www.python.org/download/releases/2.3/mro/" rel="noreferrer">documentation</a>.</p>
</div>
<span class="comment-copy">Can you be a bit more specific about what you don't understand?</span>
<span class="comment-copy">I see that the class inherits from Counter, and OrderedDict, but I can't see how these classes are combined to produce an OrderedCounter...I'm trying to understand what makes it work - for example, is there something special about Counter? Does this help clarify what I'm asking?</span>
<span class="comment-copy">basically ,as a general rule of thumb, avoid multiple inheritance (your co-workers will not kill you this way) ... (of coarse mixins are a little different)</span>
<span class="comment-copy">The example that you posted above is missing the <b>init</b> method that is present in the documentation you linked to, and I'm not sure, but I would expect that to be important to making it work.  You can see that you override two methods.  Any method not overriden will be inherited from <i>Count</i> and if not present will be inherited from <i>OrderedDict</i>.  If any method is on one of their superclasses it gets a little trickier.  As @JoranBeasley said "Avoid multiple inheritence" - the complex inheritance tree is why you want to avoid it (it leads to unexpected results).</span>
<span class="comment-copy">Yeah, it all has to do with which <code>dict</code> methods <code>Counter</code> actually overrides/customizes. I can't figure out exactly which those would be, but I suspect <code>Counter</code> leaves <code>__setitem__</code> and <code>__iter__</code> untouched, so your new class gets those from <code>OrderedDict</code> and that's enough to give you the ordered behaviour.</span>
