<div class="post-text" itemprop="text">
<p>I got the following function to test:</p>
<p><strong>my_package.db_engine.db_functions.py:</strong> </p>
<pre><code>from ..utils import execute_cmd
from my_package.db_engine.db_functions import dbinfo 

def dbinfo(db_name):
    params = (cmd_cfg.DB, add_pj_suffix(db_name))
    cmd = get_db_cmd_string(cmd_cfg.DBINFO, params=params)
    cmd_result = execute_cmd(cmd)
    result_dict = map_cmd_output_to_dict(cmd_result)
    return result_dict
</code></pre>
<p>This function takes the name of a database, then builds a command string from it and executes this command as <code>subprocess</code> with the <code>execute_cmd</code> method. 
I want to test this function without actually executing the <code>subprocess</code>. I only want to check if the command is built correctly and correctly passed to <code>execute_cmd</code>. Therefore I need to mock the <code>execute_cmd</code> method which is imported from module <code>utils</code>.</p>
<p>My folder structure is the following:</p>
<pre><code>my_project
|_src
| |_my_package
| | |_db_engine
| | | |_db_functions.py
| | | |_ __init__.py
| | |_utils.py
| | |_ __init__.py
| | |_ ....
| |_ __init__.py
|_tests
  |_test_db_engine.py
</code></pre>
<p>So for my test I tried the following in <code>test_db_engine.py</code>:</p>
<pre><code>import unittest
from mock import patch

from my_pacakge.db_engine.db_functions import dbinfo


def execute_db_info_cmd_mock():
    return {
            'Last Checkpoint': '1.7',
            'Last Checkpoint Date': 'May 20, 2015 10:07:41 AM'
    }


class DBEngineTestSuite(unittest.TestCase):
    """ Tests f√ºr DB Engine"""

    @patch('my_package.utils.execute_cmd')
    def test_dbinfo(self, test_patch):
        test_patch.return_value = execute_db_info_cmd_mock()
        db_info = dbinfo('MyDBNameHere')
        self.assertEqual(sandbox_info['Last Checkpoint'], '1.7')
</code></pre>
<p>The execution of the actual command yields <code>1.6</code> for <code>Last Checkpoint</code>. So to verify if the mock return value is used, I set it to <code>1.7</code>.
But the mock for the function is not used, as the execution of the test case still yields <code>1.6</code> because it is executing the actual function that should have been patched with the mock.</p>
<p>Any idea what I got wrong here?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are patching the wrong location. From the <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="noreferrer"><em>Where to patch</em> section</a>:</p>
<blockquote>
<p><code>patch()</code> works by (temporarily) changing the object that a name points to with another one. There can be many names pointing to any individual object, so for patching to work you must ensure that you patch the name used by the system under test.</p>
<p>The basic principle is that you patch where an object is <em>looked up</em>, which is not necessarily the same place as where it is defined. </p>
</blockquote>
<p>Your code-under-test finds <code>execute_cmd</code> as a global in their own module, but you didn't patch that reference:</p>
<pre><code>from ..utils import execute_cmd
</code></pre>
<p>The <code>my_package.utils.execute_cmd</code> reference is patched, but that <code>execute_cmd</code> reference in <code>my_package.db_engine.db_functions</code> will still point to the original, unpatched function.</p>
<p>Patch the imported global instead:</p>
<pre><code>@patch('my_package.db_engine.db_functions.execute_cmd')
</code></pre>
<p>Now the <code>execute_cmd</code> lookup inside <code>dbinfo</code> will use the patched mock object rather than the original global bound by the <code>from ... import ...</code> statement.</p>
</div>
<span class="comment-copy">Thank you, this worked out properly =)</span>
