<div class="post-text" itemprop="text">
<p>I am teaching myself about the <code>__prepare__</code> function. And I see this snippet at <a href="https://www.python.org/dev/peps/pep-3115/#invoking-the-metaclass" rel="nofollow noreferrer">PEP3115</a></p>
<pre class="lang-py prettyprint-override"><code># The custom dictionary
class member_table(dict):
    def __init__(self):
        self.member_names = []

    def __setitem__(self, key, value):
        # if the key is not already defined, add to the
        # list of keys.
        if key not in self:
            self.member_names.append(key)

        # Call superclass
        dict.__setitem__(self, key, value)

# The metaclass
class OrderedClass(type):

    # The prepare function
    @classmethod
    def __prepare__(metacls, name, bases): # No keywords in this case
        return member_table()

    # The metaclass invocation
    def __new__(cls, name, bases, classdict):
        # Note that we replace the classdict with a regular
        # dict before passing it to the superclass, so that we
        # don't continue to record member names after the class
        # has been created.
        result = type.__new__(cls, name, bases, dict(classdict))
        result.member_names = classdict.member_names
        return result

class MyClass(metaclass=OrderedClass):
    # method1 goes in array element 0
    def method1(self):
        pass

    # method2 goes in array element 1
    def method2(self):
        pass
</code></pre>
<p>My question is at this line:
    <code>result.member_names = classdict.member_names</code></p>
<p>How could the variable <code>classdict</code> get a attribute from the <code>member_table</code> class? I see the <code>__prepare__</code> function returns an instance of member_table, but how is the link between <code>member_table()</code> and  <code>classdict.member_names</code> generated?</p>
<p>Many thanks to all of you!</p>
</div>
<div class="post-text" itemprop="text">
<p>That is pretty straightforward, as it is exactly what prepare does.</p>
<blockquote>
<p>3.3.3.3. Preparing the class namespace Once the appropriate metaclass has been identified, then the class namespace is prepared. If the
  metaclass has a <code>__prepare__</code> attribute, it is called as <code>namespace =
  metaclass.__prepare__(name, bases, **kwds)</code> (where the additional
  keyword arguments, if any, come from the class definition).</p>
<p>If the metaclass has no <code>__prepare__</code> attribute, then the class
  namespace is initialised as an empty ordered mapping.</p>
</blockquote>
<p><a href="https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace</a></p>
<p>Which means, the <code>classdict</code> attribute that is passed into the metaclass <code>__new__</code> and <code>__init__</code> methods is exactly the same object that is returned by <code>__prepare__</code>. </p>
<p>That object should be a mapping instance, that is, an object that behaves like a dict and have at least the <code>__setitem__</code> method. This <code>__setitem__</code> method is called by Python for all variables set inside the the declared class body itself. </p>
<p>That is, for an ordinary class, with no custom metaclass, the variables are recorded in a dictionary (an ordered dictionary, as of Python 3.6). </p>
<p>That happens as Python runs each statement inside the class body. This is the same object that is returned should one call <code>locals()</code> inside the class body:</p>
<pre><code>In [21]: class M(type):
    ...:     def __prepare__(self, *args):
    ...:         class CustomDict(dict):
    ...:             __repr__ = lambda self: "I am a custom dict: " + str(id(self))
    ...:         namespace = CustomDict()
    ...:         print("From __prepare__", namespace)
    ...:         return namespace
    ...: 
    ...:     def __new__(metacls, name, bases, namespace):
    ...:         print("From __new__:", namespace)
    ...:         return super().__new__(metacls, name, bases, namespace)
    ...:     
    ...:     

In [22]: class Test(metaclass=M):
    ...:     def __init__(self):
    ...:         ...
    ...:     print("From class body:", locals(), locals()["__init__"])
    ...:     
    ...:     
From __prepare__ I am a custom dict: 140560887720440
From class body: I am a custom dict: 140560887720440 &lt;function Test.__init__ at 0x7fd6e1bd7158&gt;
From __new__: I am a custom dict: 140560887720440
</code></pre>
<p>The main use case when this feature was first designed probably was exactly the possibility of making the order of declarations inside a class body meaningful. That is, a <code>__prepare__</code> method could just return a <code>collections.OrderedDict</code>  instance, and <code>__new__</code> or <code>__init__</code> would act upon that order. As of Python 3.6, ordering of class attributes is by default - and the <code>__prepare__</code> feature remains so advanced one really has to think up of uses for it.</p>
</div>
<span class="comment-copy">Thanks for your answer! One more tiny question--Can we make sure that <code>__prepare__</code> function always returns namespace that is a dict or decorated dict type (not other type)?</span>
<span class="comment-copy">What do you mean by "make sure"? You should author your <code>__prepare__</code> and know what it returns. If it does not have to behave like a full mapping object - it needs only <code>__setitem__</code>, and that the code in the mclass <code>__init__</code> know how to deal with it.</span>
<span class="comment-copy">(if your question has been answered, don't forget to accept the answer)</span>
