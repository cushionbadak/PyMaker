<div class="post-text" itemprop="text">
<p>I have two scripts:</p>
<p><strong>Processor_child.py</strong>: Its purpose is to perform a number of data analysis and cleaning operations. This must perform the same operations when run alone (without Tkinter_parent.py) as it does when packaged into a GUI with Tkinter_parent.py.</p>
<p><strong>Tkinter_parent.py</strong>: Its purpose is to provide a GUI for those who can't use Processor_child directly.</p>
<hr/>
<p>Within Processor_child, there are <code>for</code> loops that ask the user for input on each iteration. These prompts need to appear in the Tkinter app, accept the input, and send it back to Processor_child.</p>
<p>The code below does this, raising an <code>Entry</code> field whenever there's data in the <code>Pipe</code> (added by the loop). However, it often seems to 'freeze', getting stuck loading and not progressing through the code. Sometimes, it runs perfectly as intended. (No changes in the code in these instances.)</p>
<p>How can I resolve this / make it more stable? I've commented below where the 'freeze' is happening.</p>
<p>Tkinter_parent.py:</p>
<pre><code>### Tkinter_parent.py ###
from tkinter import *
from tkinter.filedialog import askopenfilename
from tkinter import ttk
from multiprocessing import Process, Pipe
import pandas as pd
import Processor_child
import time

class GUI:
    def __init__(self, master):
        self.master = master

def gui_input(message, a_pipe = None):
    def input_done(event=None):
        entry.pack_forget()
        input_label.pack_forget()
        submit_button.pack_forget()
        a_pipe.send(entry.get())
        next_one(a_pipe)

    entry = Entry(frame)
    input_label = ttk.Label(frame, text=message)
    entry.bind("&lt;Return&gt;", input_done)
    submit_button = ttk.Button(frame, text="Submit", command=input_done)
    input_label.pack()
    entry.pack()
    submit_button.pack()

def file_select():
    dataset_path = askopenfilename()

    if __name__ == '__main__':
        pipe1, pipe2 = Pipe()

        some_vars = ['a var', 'another var']
        a_df = pd.read_csv(dataset_path)

        p_review = Process(target=Processor_child.review_with_user, args=(some_vars, a_df, pipe2))
        p_review.start()

        gui_input(pipe1.recv(), pipe1)

        #time.sleep(1)
def next_one(pipe1):
    while pipe1.poll() != True: ### CAUSES CONSTANT LOADING WITHOUT PROGRESSION
        time.sleep(0.1)

    gui_input(pipe1.recv(), pipe1)

if __name__ == '__main__':
    root = Tk()
    my_gui = GUI(root)
    root.style = ttk.Style()
    root.style.configure('my.TButton')
    root.style.configure('my.TLabel')

    canvas = Canvas(root)
    frame = Frame(canvas)
    frame.place()
    canvas.pack(side="left", fill="both", expand=True)
    canvas.create_window((45,50), window=frame, anchor="nw")

    ttk.Button(frame, text="Select", command=file_select).pack()

    root.mainloop()
</code></pre>
<p>And processor_child:</p>
<pre><code>### processor_child.py ###
import pandas as pd
from multiprocessing import *
import time

def smart_print(message, a_pipe = None):
    if __name__ == "__main__":
        print(message)
    else:
        a_pipe.send(message)

def review_with_user(var_names, dataset, a_pipe = None):
    affirmed = []
    review_message = 'Yes or no?'

    if __name__ == "__main__":
        review_response = input(review_message)
    else:
        smart_print(review_message, a_pipe)
        while a_pipe.poll() != True:
            time.sleep(0.1)

        review_response = a_pipe.recv()

    if review_response in ['Yes', 'yes']:
        for v in dataset.columns:
            smart_print(dataset[v].dropna(), a_pipe)
            if __name__ == "__main__":
                local_response = input(review_message)
            else:
                while a_pipe.poll() != True:
                    time.sleep(0.1)
                local_response = a_pipe.recv()
            if local_response in ['Yes', 'yes']:
                affirmed.append(v)

        smart_print(affirmed, a_pipe)

if __name__ == "__main__":
    var_names = ['var1', 'var2']
    df = pd.read_csv('dummy.csv')
    review_with_user(var_names, df)
</code></pre>
<hr/>
<p>This is related to the broader SO question <a href="https://stackoverflow.com/questions/46778491/how-can-i-implement-an-input-method-in-a-tkinter-parent-script-with-the-displ">How can I implement an <code>input</code> method in a Tkinter parent script, with the displayed prompt and return value being sent back to a child script?</a>, and comes from a posted, but non-functional, solution there.</p>
<p>As of Oct 23, 2017 there is still not a solution to this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Connection" rel="nofollow noreferrer">Connection</a><code>.poll()</code> call is busy-waiting and chewing through the CPU. But note that Connection objects have a <code>fileno()</code> method; this means you can use select/poll calls to put your process to sleep while waiting for them to become ready for I/O. Note that the tkinter event loop supports <a href="https://docs.python.org/3/library/tkinter.html#file-handlers" rel="nofollow noreferrer">file handlers</a> to allow you to do this without blocking the UI.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider writing your app in a client-server fashion.</p>
<p>The client, is the Tk app, which can connect to the server.
the server, simply executes whatever the client requires.
this way, you can detach the processing.
there are several ways you can do this, like cherrypy, rabbitmq and similar.</p>
<p>Recently, in desktops apps, I've used Electron, to connect to a cherrypy server, and AJAX requests from Electron using Javascript.  the final icon simply starts both, the server and the client.
this allows me to have a richer widget set, since the web is more powerful than Tk.</p>
<p>That will allow you in a possible future to have a webapp.</p>
<p>HTH</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest way is to get the input, either from the console or gui, and then send the results to the child program.  When you ask for input from the console, add a statement that opens Tkinter instead if some variable is set, and gets the info there.</p>
</div>
<div class="post-text" itemprop="text">
<p>It appears that the behaviour you are trying to achieve is to communicate with a function whilst it's running. I think that your problems could be solved by using generators. A generator lets you yield multiple values from a function, and send values to that function.</p>
<p><a href="https://docs.python.org/2.5/ref/yieldexpr.html" rel="nofollow noreferrer">Here</a> is some more information on generators if you want to know how they work.</p>
<p>I'm not entirely sure if this is exactly the behaviour you want from your program, but I have modified your code to use generators rather than multiprocessing, and it no longer freezes:</p>
<p>Processor_child.py:</p>
<pre><code>### processor_child.py ###
import pandas as pd
import time


def review_with_user(var_names, dataset):
    affirmed = []
    review_message = 'Yes or no?'

    review_response = yield review_message

    if review_response in ['Yes', 'yes']:
        for v in dataset.columns:
            local_response = yield str(dataset[v].dropna())+"\n"+review_message

        yield affirmed

if __name__ == "__main__":
    var_names = ['var1', 'var2']
    df = pd.read_csv('dummy.csv')
    gen = review_with_user(var_names, df)
    # since it is now a generator, you need yo write some code to communicate with it via the console
    # it doesn't print to the console or recieve input unless you do this manually
    while True:
        try:
            print(next(gen))
        except StopIteration:
            break
        print(gen.send(input()))
</code></pre>
<p>Tkinter_parent.py:</p>
<pre><code>### Tkinter_parent.py ###
from tkinter import *
from tkinter.filedialog import askopenfilename
from tkinter import ttk
import pandas as pd
import Processor_child
import time

class GUI:
    def __init__(self, master):
        self.master = master

def gui_input(message, p_review):
    def input_done(event=None):
        entry.pack_forget()
        input_label.pack_forget()
        submit_button.pack_forget()
        try:
            p_review.send(entry.get())
            next_one(p_review)
        except StopIteration:
            # this code is executed when there is no more output from Processor_child.review_with_user
            return

    entry = Entry(frame)
    input_label = ttk.Label(frame, text=message)
    entry.bind("&lt;Return&gt;", input_done)
    submit_button = ttk.Button(frame, text="Submit", command=input_done)
    input_label.pack()
    entry.pack()
    submit_button.pack()

def file_select():
    dataset_path = askopenfilename()

    if __name__ == '__main__':
        some_vars = ['a var', 'another var']
        a_df = pd.read_csv(dataset_path)

        p_review = Processor_child.review_with_user(some_vars, a_df)

        gui_input(next(p_review), p_review)

def next_one(p_review):
    try:
        gui_input(next(p_review), p_review)
    except StopIteration:
        # this code is executed when there is no more output from Processor_child.review_with_user
        return

if __name__ == '__main__':
    root = Tk()
    my_gui = GUI(root)
    root.style = ttk.Style()
    root.style.configure('my.TButton')
    root.style.configure('my.TLabel')

    canvas = Canvas(root)
    frame = Frame(canvas)
    frame.place()
    canvas.pack(side="left", fill="both", expand=True)
    canvas.create_window((45,50), window=frame, anchor="nw")

    ttk.Button(frame, text="Select", command=file_select).pack()

    root.mainloop()
</code></pre>
<p>Generators will throw a StopIteration exception when you call <code>next()</code> on them and they have finished, so be sure to put <code>next(p_review)</code> and and <code>p_review.send(...)</code> calls inside try blocks where appropriate.</p>
</div>
<span class="comment-copy">If your goal is to communicate with a command-line application via a tkinter GUI you might want to look at my answer <a href="https://stackoverflow.com/questions/21811464/how-can-i-embed-a-python-interpreter-frame-in-python-using-tkinter/46545426#46545426">here</a>. It uses a subprocess, with separate threads to get the output.</span>
<span class="comment-copy">It may freeze because of recursive code in gui_input and input_done</span>
<span class="comment-copy">It may freeze because of recursive code in gui_input and input_done.  Instead of next_one(a_pipe), use after which will schedule an independent process so each call to the function is still waiting for the return/exit from the next call ad infinitum, i.e. frame.after(100, next_one, a_pipe )</span>
<span class="comment-copy">Also look at multiprocessing's Queue and/or Manager.  I don't understand the problem so they may or may not work for you  <a href="https://pymotw.com/2/multiprocessing/communication.html#managing-shared-state" rel="nofollow noreferrer">pymotw.com/2/multiprocessing/…</a></span>
<span class="comment-copy">This does seem like a likely solve for Unix systems. Unfortunately I need a solution that's also robust to Windows, since most users will deploy this on Windows machines. Tkinter event loop file handlers say they do not work on Windows in the linked documentation.</span>
<span class="comment-copy">In the file handler documentation: "This feature is not available on Windows."  And in multiprocessing.connection.wait: "Windows: ... Note that pipe handles and socket handles are not waitable handles."</span>
<span class="comment-copy">Isn’t this fixed in Windows 10? That’s supposed to be shipping with a Linux compatibility layer, and it’s not going to work very well otherwise.</span>
<span class="comment-copy">I am unsure if it is fixed in Windows 10. My impression is that it likely isn't, at least without having some way to classify that packaged applications run on the Linux layer (which does not seem to be its primary purpose). In my case, Windows 7 compatibility is paramount.</span>
<span class="comment-copy">You could try Cygwin, then. They seem to be able to fix the problem, where Microsoft is unable to.</span>
