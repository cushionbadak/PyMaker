<div class="post-text" itemprop="text">
<p>Ok so I am using a script that is downloading a files from urls listed in a urls.txt. </p>
<pre><code>import urllib.request

with open("urls.txt", "r") as file:
    linkList = file.readlines()
for link in linkList:
    urllib.request.urlretrieve(link)
</code></pre>
<p>Unfortunately they are saved as temporary files due to lack of second argument in my urllib.request.urlretrieve function. As there are thousand of links in my text file naming them separately is not an option. The thing is that the name of the file is contained in those links, i.e.  /DocumentXML2XLSDownload.vm?firsttime=true&amp;repengback=true&amp;d‌​ocumentId=XXXXXX&amp;xsl‌​FileName=rher2xml.xs‌​l&amp;outputFileName=XXX‌​X_2017_06_25_4.xls where the name of the file comes after outputFileName=</p>
<p>Is there an easy way to parse the file names and then use them in  urllib.request.urlretrieve function as secondary argument? I was thinking of extracting those names in excel and placing them in another text file that would be read in similar fashion as urls.txt but I'm not sure how to implement it in Python. Or is there a way to make it exclusively in python without using excel?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could parse the link on the go.</p>
<p>Example using a <a href="https://docs.python.org/3/library/re.html#re.search" rel="nofollow noreferrer">regular expression</a>:</p>
<pre><code>import re

with open("urls.txt", "r") as file:
    linkList = file.readlines()
for link in linkList:
    regexp = '((?&lt;=\?outputFileName=)|(?&lt;=\&amp;outputFileName=))[^&amp;]+'
    match = re.search(regexp, link.rstrip())

    if match is None:
        # Make the user aware that something went wrong, e.g. raise exception
        # and/or just print something
        print("WARNING: Couldn't find file name in link [" + link + "]. Skipping...")
    else:
        file_name = match.group(0)
        urllib.request.urlretrieve(link, file_name)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use urlparse and parse_qs to get the query string</p>
<blockquote>
<pre><code>from urlparse import urlparse,parse_qs
parse = urlparse('http://www.cwi.nl:80/%7Eguido/Python.html?name=Python&amp;version=2')
print(parse_qs(parse.query)['name'][0]) # prints Python
</code></pre>
</blockquote>
</div>
<span class="comment-copy">It seems like this method returns file_name &lt;_sre.SRE_Match object; span=(156, 178), match='XXXX_2017_06_25_4.xls\n'&gt; as I get TypeError: invalid file:</span>
<span class="comment-copy">@Seidhe My bad, it should work now. Could you try again?</span>
<span class="comment-copy">It seems like there should be closing parenthesis in the print. Other than that I get this kind of error:   Traceback (most recent call last):   File "H:\My Documents\PYTHON\download.py", line 8, in &lt;module&gt;     file_name = re.search(regexp, link).group(0)   File "F:\TOO\Team\Software\Anaconda3\lib\re.py", line 173, in search     return _compile(pattern, flags).search(string)   File "F:\TOO\Team\Software\Anaconda3\lib\re.py", line 293, in _compile     p = sre_compile.compile(pattern, flags)  sre_constants.error: unterminated character set at position 47</span>
<span class="comment-copy">@Seidhe Haha damn, too many mistakes right now. Anyway, now I have actually tested the code and it works for me.</span>
<span class="comment-copy">@Seidhe Also, the check for None was useless where it was (if the matching went wrong, the code would throw an error before it ever got there). Of course, that check ("if match is None") is not necessary depending on what you want to do in the case of an error. Anyway, I updated the code again, it should make sense now. Sorry for the troubles. If any more problems arise, let me know. ;)</span>
<span class="comment-copy">As I understand it creates a dictionary of strings that come after name= and before &amp;? As I'm completely new to the Python could you please show me how it should look in my code?</span>
<span class="comment-copy">urlparse query will return the query string on that we are splitting by &amp; and creating dict which means <a href="http://www.test.com/print?name=test&amp;x=12345&amp;y=12345678" rel="nofollow noreferrer">test.com/print?name=test&amp;x=12345&amp;y=12345678</a> will create dictionary as   <code>{'name':'test','x':'12345','y':'12345678'}</code></span>
<span class="comment-copy">Please don't re-invent the stdlib. The <code>urlparse</code> module also includes the <code>parse_qs</code> method for parsing query strings and returning a dict. Your dict comprehension would simplify to <code>query_param_dict = parse_qs(parse.query)</code>.</span>
<span class="comment-copy">@PaulMcG updated accordingly and thanks</span>
