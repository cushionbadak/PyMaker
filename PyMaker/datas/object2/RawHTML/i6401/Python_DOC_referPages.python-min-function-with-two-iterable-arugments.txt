<div class="post-text" itemprop="text">
<p>I understand that min will give me the smallest item if I use a list or a group of numbers</p>
<pre><code>min([5, 10])] &gt;&gt;&gt; 5
min((5, 10)) &gt;&gt;&gt; 5
</code></pre>
<p>but when this was used in map:</p>
<pre><code>L1 = [1, 28, 36]
L2 = [2, 57, 9]
for elt in map(min, L1, L2):
    print(elt)
</code></pre>
<p>it gives me back:</p>
<pre><code>1
28
9
</code></pre>
<p>isn't map suppose to help me to apply min to L1 and L2 in turn? and I am kind of expecting:</p>
<pre><code>1
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want the <code>min</code> of each of several lists, you need to create a list (or iterable) of the lists to hand to map:</p>
<pre><code>for elt in map(min, (L1, L2)):
    print(elt)
</code></pre>
<p>That has the effect of calling <code>min(L1)</code> and then <code>min(L2)</code>.</p>
<p><code>map</code> can take any number of iterable arguments; it assembles all of the corresponding elements of the iterations and passes all of them to the provided function. So <code>map(min, L1, L2)</code> is similar to <code>(min(L1[0], L2[0]), min(L1[1], L2[1]), min(L1[2], L2[2]))</code> (except that it is an iterable, not a tuple).</p>
</div>
<div class="post-text" itemprop="text">
<p>If your lists are</p>
<pre><code>L1 = [1, 28, 36]
L2 = [2, 57, 9]
</code></pre>
<p>then</p>
<pre><code>map(min, L1, L2)
</code></pre>
<p>will apply the <code>min()</code> function to the <em>corresponding elements</em> of <code>L1</code>, <code>L2</code>:</p>
<pre><code>min( 1,  2)       # result:  1
min(28, 57)       # result: 28
min(36,  9)       # result:  9
</code></pre>
<p>(But it will do it only if there is a <em>request</em> for evaluating it (so called a <em>lazy evaluation</em>) - as the <code>for</code> loop in your case - so it will not return a <em>list</em> <code>[1, 28, 9]</code>, but a <em><code>map</code></em> object.</p>
<p>The <code>map</code> object is a sort of the <em>iterator</em> - something as a <em>recipe how to do it</em>.</p>
<p>Why? Because <em>lists</em> may be <em>very very long</em>, but the recipe is still the same - the <em>short</em> one.)</p>
</div>
<span class="comment-copy">Read the documentation for <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a>.  You're basically doing <code>map(min, zip(L1, L2))</code></span>
<span class="comment-copy">Add brackets around the <i>L1</i> and <i>L2</i> like this <code>map(min, [L1, L2]) </code>.</span>
<span class="comment-copy">Basically, as @PatrickHaugh said, it's as if his code is <code>map(min, zip(L1, L2))</code>.</span>
<span class="comment-copy">got it!! Thanks!</span>
<span class="comment-copy">@ChristianDean: In this case, it is; that's not generally the case, though. It works because <code>min</code> happens to either compute the minimum of a single iterable (if given one argument) or the minimum of all its arguments (if given more than one argument).</span>
<span class="comment-copy">@rici True, that's a good point.</span>
<span class="comment-copy">thanks a lot, it was indeed like zip(L1, L2)</span>
<span class="comment-copy">You are right - it is <i>like</i> the <code>zip()</code> built-in function, but it <i>doesn't perform <code>zip()</code></i> as a temporary result (yielding pairs) but it directly yields the <i>return values of the mapped function</i>.</span>
