<div class="post-text" itemprop="text">
<p>Say i have the string <code>NYKMIANYKCLE</code>, i want to split it into a list that has only <code>NYKMIA</code> and <code>NYKCLE</code>(splits right before second occurance of <code>'NYK'</code>).  Is there a way to do it in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer"><code>re.findall</code></a> to find all substrings starting with <code>NYK</code>, not containing another <code>NYK</code> or followed by the end-of-string character:</p>
<pre><code>&gt;&gt;&gt; s = 'NYKMIANYKCLE'
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall(r'NYK.+?(?=NYK|$)', s)
['NYKMIA', 'NYKCLE']
</code></pre>
<p>The first <code>?</code> ensures the search is non-greedy; one substring at a time, while <code>(?=NYK|$)</code> enforces an assertion that the substring is preceding the next <code>NYK...</code> substring or the end-of-string character <code>$</code>.</p>
<hr/>
<p>More tests:</p>
<pre><code>&gt;&gt;&gt; s = 'NYKMIANYKCLENYKjahsja'
&gt;&gt;&gt; re.findall(r'NYK.+?(?=NYK|$)', s)
['NYKMIA', 'NYKCLE', 'NYKjahsja']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try something like this:</p>
<pre><code>string = 'NYKMIANYKCLE'
substring = 'NYK'

first_index = string.index(substring)
second_index = string.index(substring, first_index + len(substring))
print string[:second_index], string[second_index:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since the question was about splitting, this can be done with the new <a href="https://pypi.python.org/pypi/regex" rel="nofollow noreferrer">regex module</a>,
 which allows zero width characters for splitting </p>
<pre><code>import regex
s='NYKMIANYKCLE'
print(regex.split('(?V1)(?=NYK)',s))
</code></pre>
<p><strong>output</strong></p>
<pre><code>['', 'NYKMIA', 'NYKCLE']
</code></pre>
<hr/>
<p><strong>UPDATE</strong></p>
<p>To avoid splitting at the beginning of the line</p>
<pre><code>print(regex.split('(?V1)[^^](?=NYK)',s))
</code></pre>
<p><strong>output</strong></p>
<pre><code>['NYKMI', 'NYKCLE']
</code></pre>
<p><strong>explanation</strong></p>
<pre><code>(?V1)      #Forces new version 2 of split which allows zero width chars for split
[^^]       #don't take line beginning as split
(?=NYK)    #take a position as split if the position is followed by NYK
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re
re.findall("NYK[A-Z]+", "NYKMIANYKCLE")
</code></pre>
<p>from the documentation:</p>
<blockquote>
<p>findall(pattern, string, flags=0)  </p>
<p>Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result unless they touch the beginning of another match.</p>
</blockquote>
</div>
<span class="comment-copy">Please avoid answers that are only code. In stead try to explain why this answer is correct, and what it does.</span>
<span class="comment-copy">thx for the tip!</span>
