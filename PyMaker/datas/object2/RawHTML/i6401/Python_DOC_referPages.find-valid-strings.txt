<div class="post-text" itemprop="text">
<p>A string is valid if and only if it has only two characters <code>a</code> and <code>b</code> in it (not necessary that <code>a</code> should be present) and it must have three b's in it in succession in order to be valid. For example for string of length <code>n=4</code> <code>[bbbb,bbba,abbb]</code> are valid strings that are totally valid strings are 3 and for <code>n=3</code> there is only one valid string [bbb]. <code>n</code> can be any integer up to 10**4. My approach to this problem can be naive as I am new to programming but this is how I started:</p>
<pre><code>import itertools
x=list(input().strip())
test=True
lis=[]
for _ in (x):
    if _ == 'a' or _=='b':
        continue
    else:
        test=False
        break

if test:
    y=list(itertools.permutations(x))
    print(y)
</code></pre>
<p>Now I am looking for a pattern for <code>n=5,6,7</code> and then implement it for the general but I want to eliminate all the invalid strings from list y that doesn't satisfy above conditions.I need to print count of all valid strings for a a particular integer n which corresponds to length of the string .</p>
</div>
<div class="post-text" itemprop="text">
<p>We can easily produce valid strings using <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> to produce tuples of 'a' and 'b' of the required length, join the tuples into strings, and then filter out strings that don't contain 'bbb'.</p>
<p>We don't need to store all the strings in a list. Instead, we produce them using a generator function.</p>
<p>To count the number of valid strings of a given length we still don't need to make a list. We can easily count the strings yielded by the generator using the built-in sum function and a generator expression.</p>
<p>Here's a short demo.</p>
<pre><code>from itertools import  product

def make_valid(n):
    for s in map(''.join, product('ab', repeat=n)):
        if 'bbb' in s:
            yield s

# Print all the valid strings for n = 5
for i, t in enumerate(make_valid(5), 1):
    print(i, t)
print()

# Count the number of valid strings for some small values of n
for n in range(16):
    print(n, sum(1 for _ in make_valid(n)))
print()
</code></pre>
<p><strong>output</strong></p>
<pre><code>1 aabbb
2 abbba
3 abbbb
4 babbb
5 bbbaa
6 bbbab
7 bbbba
8 bbbbb

0 0
1 0
2 0
3 1
4 3
5 8
6 20
7 47
8 107
9 238
10 520
11 1121
12 2391
13 5056
14 10616
15 22159
</code></pre>
<hr/>
<p>This strategy is ok for small <code>n</code>, but we need a formula to calculate those counts for larger <code>n</code>. Fortunately, this sequence can be found in the OEIS as sequence <a href="https://oeis.org/A050231" rel="nofollow noreferrer">A050231</a>, which lists a couple of useful formulae. It even has some Python code, although we can make a more efficient function using a different formula. Using this formula we can easily calculate the counts for large <code>n</code>, although for <code>n &gt; 1000</code> we may need to increase the recursion limit (depending on what's in the <code>cache</code> dictionary).</p>
<pre><code>import sys

def valid_num(n, cache={0:0, 1:0, 2:0, 3:1, 4:3}):
    if n in cache:
        return cache[n]
    v = cache[n] = 2 * valid_num(n-1) - valid_num(n-4) + (1 &lt;&lt; (n-4))
    return v

# Calculate the same counts using the formula
for n in range(16):
    print(n, valid_num(n))
print()

# Calculate some larger counts using the formula
for n in (20, 100, 1000):
    print(n, valid_num(n))
print()

# Calculate the count for n = 10000
sys.setrecursionlimit(10000)
n = 10000
v = valid_num(n)
print(n, 'length:', len(str(v)))
print(v)
</code></pre>
<p><strong>output</strong></p>
<pre><code>0 0
1 0
2 0
3 1
4 3
5 8
6 20
7 47
8 107
9 238
10 520
11 1121
12 2391
13 5056
14 10616
15 22159

20 825259
100 1267318799554307616411887824515
1000 10715086071862673209484250490600018100539745081012589876867705301975463230239516162056449817835254127137269714485423444296635751843450469485667983663407684446390757637525684523851088159545633725265629658895944476385164970179813685921539685461239078098993547717387680879133627403305119486713242032255067

10000 length: 3011
19950631168807583848837421626835850838234968318861924548520089498529438830221946631919961684036194597899331129423209124271556491349413781117593785932096323957855730046793794526765246551266059895520550086918193311542508608460618104685509074866089624888090489894838009253941633257850621568309473902556912388065225096643874441046759871626985453222868538161694315775626089623134328073983786389675177701186558011272310697526877798064028762732641567763583009365923237958579619694722743012623795847397854998863572912757259022370929851354671535479510177534365020486167704487189515540498377935792784729998056204236193219552902248837389484924415956257294989763770669720233733644286583000382759075539053082652941408713883472715627420221687140691149326172458181449913074158357403912912879276902845540785568622960033810574475726502542130288984975487755939111059374407249361193935123107325839835567845152301152599696481119763066457621100802588552680671318557266858044791840868082518099393177406617354957371241176940107570738702088618534197370980151722230231186806124846732235800482635363983329963660230357785349549545506065669831114315218532610109374476503772297612747522883328342787820540011850973090403518483383437648807620569472507786915081183978792023340064365641436883629372337926937368346416759281652638487818090591411436604449009422265319311879409918048008416090298359064134661715823412371674763461157363128721685818760472532914713274785795923563234731723132316960019917396064130633819807185968362914576441538717071994274286406827253010143879860255399415078316174263450870289088692073427388192608054285426524914418151339875321474768984105710841294710811517295773844059882211433112941200409216807692338045919038698016225727309613247405118664483317505367054663735478905020533879998277077423479999938238338161234544356443164377399933151023535182334388940451107785030288175719971170053676007075190227062172140481425461917515455479972068054339784181607496627198030056906424447389442115111598117425687643181400799735513708227684305240112451551816573610657557740466165389046532852242049143998343971456857060951994667027419070327679375387245482516968508426783900751557991025654896592270261372186844112570682419026071390817038382780816857411320558427785718592835834380922916168890933210737876196968898314180514932819277476011379800392972374348601006573628313908492614955299976109070068900439705816010323545500438056558640731711137133200529511554379646269211769945584022230495812252890259551503449397117011713619252886812420071394209078307064109175851940790347483097635133334458431432349757774924271783333143566842831599567399569263816537290034939347896683277449442140167815797283546947849352457384014905698858773315056621125677551281637613936596108267979291171314129517832750587062076381907831127494015516619913002000219217551370967381359461580273960378080346580481200727681280258846559027048156913034694942538168049000091115128411182728198666360471953351549972522903396839735125178400179203500439758780473093919765016217623879
</code></pre>
<hr/>
<p>Adirio mentions in the comments that we don't need to initialise the cache with <code>4: 3</code>, and that we can make this version a little more efficient by using a list instead of a dict for the cache. This works because the recursion guarantees that any new item added to the cache will always have an index 1 greater than that of the current last item in the cache.</p>
<p>Here's the improved version:</p>
<pre><code>def valid_num(n, cache=[0, 0, 0, 1]):
    if n &gt;= len(cache):
        cache.append(2 * valid_num(n-1) - valid_num(n-4) + (1 &lt;&lt; (n-4)))
    return cache[n]
</code></pre>
<p>Thanks, Adirio!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use this to generate all possible combinations for a given length <code>n</code> and then filter the invalid ones.</p>
<p>A faster method that uses comprehension (prefer for smaller <code>n</code> values):</p>
<pre><code>n = 10
combinations = [''.join(x) for x in itertools.product('ab', repeat=n)]
valid = [x for x in combinations if 'bbb' in x]
print len(valid)
</code></pre>
<p>A RAM efficient method that uses generators (prefer for bigger <code>n</code> values):</p>
<pre><code>n = 10
combinations = (''.join(x) for x in itertools.product(['a', 'b'], repeat=n))
valid = (x for x in combinations if 'bbb' in x)
print sum(1 for _ in valid)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple approach for this would be generating all the possible combinatios of strings of a certain length with only chars 'a' and 'b' and then testing if there is the 'bbb' pattern inside them.</p>
<pre><code>def recursive_function(n, seed=None, chars="ab"):
    if seed is None:
        seed = ['']
    result = []
    for char in chars:
        result.extend(list(map(lambda x: x + char, seed)))
    if n-1:
        return recursive_function(n-1, result, chars)
    else:
        return result

unfiltered = recursive_function(5)

filtered = list(filter(lambda x: 'bbb' in x, unfiltered))

print(filtered)
</code></pre>
<p>The function appends to every <code>str</code> inside the parameter <code>seed</code> the options in <code>chars</code>. So if <code>seed = ['var']</code> and <code>chars = "12"</code> =&gt; <code>result = ['var1', 'var2']</code>. Before doing that we are creating a <code>list</code> with an empty <code>str</code> if we do not provide it. After it we are checking if we have reached the desired length or calling to ourselves but reducing <code>n</code> by 1.</p>
<p>This generates a list of length equal to the length of the <code>chars</code> variable to the power of <code>n</code>: <code>len(chars)**n</code>. This means that you will get soon out of memory n=100 is giving me memory issues, depends on your mahcine, setup, ...</p>
<p>Then we filter it and convert it back to a <code>list</code> using a <code>lambda</code> function that checks if it has the substring <code>'bbb'</code>.</p>
<p>Another solution would be using itertools:</p>
<pre><code>from itertools import product

unfiltered = map(''.join, product('ab', repeat=5))
#unfiltered = (''.join(x) for x in product('ab', repeat=5)) # suggested by @DanielTrugman

filtered = filter(lambda x: 'bbb' in x, unfiltered)
#filtered = (x for x in unfiltered if 'bbb' in x) # suggested by @DanielTrugman

i = sum(1 for _ in filtered) # suggested by @PM2Ring

#for i, _ in enumerate(filtered):
#    pass
#i += 1

#i = 0
#for _ in filtered:
#    i += 1

print(i)
</code></pre>
<p>I gave some alternatives to each step as sugested by <a href="https://stackoverflow.com/users/1030410/daniel-trugman">@DanielTrugman</a> and <a href="https://stackoverflow.com/users/4014959/pm-2ring">@PM2Ring</a>, any combination of them should work. The key point in this new approach is that they are never creating a <code>list</code>, which was the one giving memory problems before, they are creating generators. A generator can be used to generate the next element and can be used in <code>for</code> loops but doesn't store the full content in memory (this also means that once I iterate over the generator, I would need to create it again if I want to use it in another <code>for</code> loop). By using enumerate each element is transormed into a tuple of the form <code>(i, element)</code> being i an auto-incremented integer starting at 0 so when the loop ends <code>i</code> equals the number of elements minus 1. An alternative to this last part would be to do it manually.</p>
<p>Remember that you can't use both as the second time the generator would be empty, either you recreate it re executing both the unfiltered and filtered part or you just use one of the methods.</p>
<p><strong>NOTE: THIS WILL TAKE AGES FOR N=10^5</strong></p>
<p><a href="https://stackoverflow.com/a/46833042/5612096">A further answer</a> by <a href="https://stackoverflow.com/users/4014959/pm-2ring">@PM2Ring</a> gives information on how you could calculate the result with a numeric formula that will be mroe effficient that iterating over the possibilities, even if they are using generators.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be done by using simple regex matching. First check whether the string contains only a's and b's. Then, create all the combinations using <code>itertools</code> and filter the ones you need using regex.</p>
<pre><code>def return_valid_strings(string):
    if re.match("^[ab]*$", string):
        y = ["".join(x) for x in itertools.permutations(string) if re.match("^[ab]*bbb[ab]*$", "".join(x))]
    return list(set(y))
</code></pre>
</div>
<span class="comment-copy">You need to clarify the problem requirements.  Are you supposed to <i>recognize</i> these strings, or print them all, or what?</span>
<span class="comment-copy">You could check each string against the <a href="https://en.wikipedia.org/wiki/Regular_expression" rel="nofollow noreferrer">regular expression</a> <code>[ab]*bbb[ab]*</code>.</span>
<span class="comment-copy">@DavisHerring  I need to print all valid strings for a particular length of integer n.Here i am trying to find a pattern</span>
<span class="comment-copy">"<code>n</code> can be any integer up to <code>10**4</code>". It will take a huge amount of time to generate all valid permutations for large <code>n</code>, since the total number is approximately <code>2**n</code></span>
<span class="comment-copy">Do you need to print all the valid strings? Or do you merely need to print <i>the number</i> of valid strings?</span>
<span class="comment-copy">As my answer is the accepted one but I find your information about the formulas quite important, I would like either to link to your answer or include this info in the accepted answer. Which do you prefer? I would obviously give you credit for it if I directly include the info in my answer.</span>
<span class="comment-copy">@Adirio Thanks for asking. I prefer if you just link to my answer, there's not much point repeating info that's already on the page.</span>
<span class="comment-copy">As this was changed to the accepted answer, I would like to suggest a couple of things: 1) The 4th value of the cache doesn't need to be given at initialization:` valid_num(4) = 2 * valid_num(3) - valid_num(0) + (1 &lt;&lt; 0) = 2 * 1 - 0 + 1 = 3<code>. 2) The cache could be stored in a </code>list` as it should be more memory efficient. I will edit your answer to show how I would do it, accept it or modify it at will.</span>
<span class="comment-copy">@Adirio Thanks for the suggestions. It didn't occur to me that a list would work here. Generally, edits that make changes to code (apart from simple formatting changes) will be rejected as conflicting with the author's intent, although if I'd been online at the time I probably would have accepted and improved your edit.</span>
<span class="comment-copy">your code doesn't include all of the valid strings for a particular length n</span>
<span class="comment-copy">@Demonking28, found the ordering mistake and fixed it</span>
<span class="comment-copy">@PM2Ring, thanks :) added</span>
<span class="comment-copy">@DanielTrugman Thank you very much for your time and effort.This works well.</span>
<span class="comment-copy">Those generators are not being executed so you dont know if it will yield a memory error or not. What's more, map usually is slightly faster when used with no-lambda functions.</span>
<span class="comment-copy">You should use standard methods when possible! <code>itertools.combinations_with_replacement</code> does exactly that!</span>
<span class="comment-copy">@Adirio Thanks ,this is what i was looking for :)</span>
<span class="comment-copy">@DanielTrugman those are ordered and in <code>tuple</code> form</span>
<span class="comment-copy">@Adirio, and what's wrong with that?</span>
<span class="comment-copy">FWIW, an elegant way to count the number of items that a generator yields is to pass a generator expression to <code>sum</code>, eg <code>sum(1 for _ in filtered)</code>.</span>
