<div class="post-text" itemprop="text">
<p>I have seen some answers to this type of question here, but not enough to really help me. I did a split on a 9- column .csv - file &amp; wrote them to vectors for other work in c++. They are subsequently written back to a folder as Single- column .csv files that basically look similar to this:</p>
<pre><code>date
20171012
20171011
20171010
20171009
20171006
20171005
20171004
</code></pre>
<p>Now I want to combine all those 9 simple csv files into 1 file again so that they stack up horizontally next to each other,like this in the new file:</p>
<pre><code>date,value,etc...     
20171012,2501593,etc..
20171011,2176309,etc..
20171010,3484064,etc..
20171009,1785852,etc..
20171006,1785852,etc..
20171005,16476641,etc..
20171004,1235406,etc..
</code></pre>
<p>I hope this is easy enough to understand. My code below is as follows:</p>
<pre><code>import csv
data = [] # Buffer list
files = ['./CalculatedOutput/quote_date.csv', './CalculatedOutput/paper.csv', './CalculatedOutput/exch.csv', './CalculatedOutput/open.csv', './CalculatedOutput/high.csv', './CalculatedOutput/low.csv', './CalculatedOutput/close.csv', './CalculatedOutput/volume.csv', './CalculatedOutput/value.csv']

for filename in files:
    with open(filename, 'r') as csvfile:
        stocks = csv.reader(csvfile)
        for row in stocks:
            new_row = [row[0]]
            data.append(new_row)
        with open("CalculatedOutput/Opera.csv", "w+") as to_file:
            writer = csv.writer(to_file , delimiter=",")
            for new_row in data:
                writer.writerow(new_row)
</code></pre>
<p>This code DOES move all the rows of the columns into 1 new file, but it just puts them underneath one another. How would I go about writing the columns next to each other,comma separated ? 
I have tried extensively with Pandas, numpy and the csv lib according to concat, merge and others, but i just can't find the right way. I don't think I'm that far off, but my python is not the best unfortunately!</p>
</div>
<div class="post-text" itemprop="text">
<p>I read you tried pandas, what went wrong there?. With pandas we can simply use pd.concat([df1,df2....]). So let's read them in and bunch them together:</p>
<pre><code>import pandas as pd

df = pd.concat((pd.read_csv(f) for f in files),axis=1) # axis1 for horizontal
df.to_csv("CalculatedOutput/Opera.csv",index=False)
</code></pre>
<hr/>
<p><strong>Example:</strong></p>
<p>Let's first create two imaginary files:</p>
<pre><code>file1 = """date
20171012
20171011
20171010
20171009
20171006
20171005
20171004"""

file2 = """number
1
2
3
4
5
6
7"""

files = [io.StringIO(f) for f in [file1,file2]]

import pandas as pd

df = pd.concat([pd.read_csv(f) for f in files],axis=1)

print(df)
</code></pre>
<hr/>
<pre><code>       date  number
0  20171012       1
1  20171011       2
2  20171010       3
3  20171009       4
4  20171006       5
5  20171005       6
6  20171004       7
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can open all the files using a single context manager with <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow noreferrer"><code>contextlib.ExitStack</code></a> (in Python 3) and then write to the output file after applying <code>zip</code> on the <em>iterable</em> of files:</p>
<pre><code>import csv
from contextlib import ExitStack

outfile = "CalculatedOutput/Opera.csv"
with ExitStack() as stack, open(outfile, "w+") as to_file:
    #Â open all files
    fs = [stack.enter_context(open(fname)) for fname in files]
    fs = map(csv.reader, fs)
    # write all rows from all files
    csv.writer(to_file).writerows(zip(*fs))
</code></pre>
<p><strong>Update</strong>:</p>
<p>If the file contains characters that cannot be decoded to UTF-8 (the default encoding for <code>open</code>), you can use intermediate surrogate characters when reading, which are replaced with their original form at write time:</p>
<pre><code>with ExitStack() as stack, open(outfile, "w+", errors='surrogateescape') as to_file :
    fs = [stack.enter_context(open(fname, errors='surrogateescape')) for fname in files]
    ...
</code></pre>
</div>
<span class="comment-copy">You need to construct a nested list, each sublist representing a single row. For each new file, you append to the sublists. Then write it all in one go at the end with <code>csv.writerows()</code> (your current method involved opening the file on every iteration which is very inefficient). I'm not at a PC currently to create an answer.</span>
<span class="comment-copy">Your indentation is a bit wonky so actually maybe you don't open on every iteration. Please fix the indentation in the question.</span>
<span class="comment-copy">Unix paste command</span>
<span class="comment-copy">Thank you ! That worked perfectly. Honestly I couldn't tell you why smth similar hasn't worked for me earlier, but that was spot on :-)</span>
<span class="comment-copy">I get this when I try to run the script : "UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf8 in position 11: invalid start byte" . I was sure these were already utf-8.</span>
<span class="comment-copy">The files contain non-ascii characters? See update.</span>
<span class="comment-copy">Thanks a lot for help, but the Pandas method worked a treat for me.</span>
<span class="comment-copy">I will try this out also when I get the chance! I am sure I'm at fault there somewhere, but I really appreciate the help :-)</span>
