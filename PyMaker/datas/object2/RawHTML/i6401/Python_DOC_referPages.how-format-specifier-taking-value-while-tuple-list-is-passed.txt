<div class="post-text" itemprop="text">
<p>I have a piece of code as below:</p>
<pre><code>tupvalue = [('html', 96), ('css', 115), ('map', 82)]
</code></pre>
<p>So while printing the above tuple in the desired format for a particular index I found a code like this:</p>
<pre><code>&gt;&gt;&gt; '%s:%d' % tupvalue[0]
'html:96'
</code></pre>
<p>I'm wondering how the single value <code>tupvalue[0]</code> is recognised as a tuple of two values by the format specifier <code>'%s:%d'</code>?  Please explain this mechanism with a documentation reference.  </p>
<p>How can I use a comprehension to format all the values in <code>tupvalue</code> in the required format as in the example shown?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, the easy question:</p>
<blockquote>
<p>How can I use a comprehension to format all the values in <code>tupvalue</code> in the required format as in the example shown?</p>
</blockquote>
<p>That's a list comprehension: <code>['%s:%d' % t for t in tupvalue]</code></p>
<p>Now, the harder question!</p>
<blockquote>
<p>how the single value <code>tupvalue[0]</code> is recognised as a tuple of two values by the format specifier <code>'%s:%d'</code>?</p>
</blockquote>
<p>Your intuition that something a bit strange is going on here is correct.  <strong>Tuples are special-cased in the language</strong> for use with string formatting.  </p>
<pre><code>&gt;&gt;&gt; '%s:%d' % ('css', 115)  # tuple is seen as two elements
'css:115'
&gt;&gt;&gt; '%s:%d' % ['css', 115]  # list is just seen as one object!
TypeError: not enough arguments for format string
</code></pre>
<p>The percent-style string formatting does not duck-type properly.  So, if you actually wanted to format a tuple, you'll have to wrap it in another tuple, unlike any other kind of object:</p>
<pre><code>&gt;&gt;&gt; '%s' % []
'[]'
&gt;&gt;&gt; '%s' % ((),)
'()'
&gt;&gt;&gt; '%s' % ()
TypeError: not enough arguments for format string
</code></pre>
<p>The relevant section of the documentation is at section <a href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting" rel="nofollow noreferrer">4.7.2. <code>printf</code>-style String Formatting</a>, where it is mentioned:</p>
<blockquote>
<p>If format requires a single argument, values may be a single non-tuple object.  Otherwise, values must be a tuple with exactly the number of items specified by the format string</p>
</blockquote>
<p>The odd handling of tuples is one of the quirks called out in the note at the beginning of that section of the documentation, and one of the reasons that the newer string formatting method <code>str.format</code> is recommended instead. </p>
<p>Note that the handling of the string formatting happens at <em>runtime</em><sup>†</sup>.  You can verify this with the abstract syntax tree:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.dump(ast.parse('"%s" % val'))
"Module(body=[Expr(value=BinOp(left=Str(s='%s'), op=Mod(), right=Name(id='val', ctx=Load())))])"
</code></pre>
<p><code>'%s' % val</code> parses to a binary operation on <code>'%s'</code> and <code>val</code>, which is handled like <code>str.__mod__(val)</code>, in CPython that's a <code>BINARY_MODULO</code> opcode.  This means it's usually up to the <code>str</code> type to decide what to do when the <code>val</code> received is incorrect<sup>*</sup>, which occurs only once the expression is <em>evaluated</em>, i.e. once the interpreter has reached that line.  So, it doesn't really matter whether the <code>val</code> is the wrong type or has too few/too many elements - that's a runtime error, not a syntax error.  </p>
<p><sup>†</sup> <sub>Except in some special cases where CPython's peephole optimizer is able to "constant fold" it at compile time.</sub></p>
<p><sup>*</sup> <sub>Unless <code>val</code>'s type subclasses <code>str</code>, in which case <code>type(val).__rmod__</code> <a href="https://stackoverflow.com/q/46854740/674039">should be</a> able to control the result.</sub></p>
</div>
<span class="comment-copy"><code>tupvalue[0]</code> -&gt; <code>('html', 96)</code> -&gt; <code>'%s:%d' %('html', 96)</code> What's the confusion?</span>
<span class="comment-copy">@julien A sample output is shown in the question</span>
<span class="comment-copy"><code>['%s:%d'%t for t in tupvalue]</code>?</span>
<span class="comment-copy">It's a single object but it is evaluated to a tuple of two values at runtime.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ is there any documentation to understand this feature properly??</span>
<span class="comment-copy">I appreciate this, it was really informative. I hope OP decides to accept your answer.</span>
<span class="comment-copy">@wim thanks for such a thorough explanation and  for completing my question by comparing with this list <code>&gt;&gt;&gt; '%s:%d' % ['css', 115]</code> , Actually that is where my question arose</span>
