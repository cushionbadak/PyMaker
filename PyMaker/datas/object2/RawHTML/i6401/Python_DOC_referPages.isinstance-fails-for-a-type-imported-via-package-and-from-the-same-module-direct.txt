<div class="post-text" itemprop="text">
<pre><code>/Project
|-- main.py
|--/lib
|  |--__init__.py
|  |--foo.py
|  |--Types.py
</code></pre>
<p><code>/Project/lib</code> has been added to the <code>PYTHONPATH</code> variables.</p>
<p><strong>Types.py:</strong></p>
<pre><code>class Custom(object):
    def __init__(self):
        a = 1
        b = 2
</code></pre>
<p><strong>foo.py:</strong></p>
<pre><code>from Types import Custom
def foo(o):
    assert isinstance(o, Custom)
</code></pre>
<p>Finally, from <strong>main.py</strong>:</p>
<pre><code>from lib.Types import Custom
from lib.foo import foo
a = Custom()
foo(a)
</code></pre>
<p>The problem now is, that <code>a</code> is of type <code>lib.foo.Custom</code>, while the isinstance call will check if it equals <code>foo.Custom</code>, which obviously returns false.</p>
<p>How can I avoid this problem, without having to change anything in the library (lib)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should not both make <code>lib</code> a package and add it to <code>PYTHONPATH</code>. This makes it possible to import its modules both as <code>lib.</code> and directly, setting yourself up for failure.</p>
<p>As you can see,</p>
<pre><code>lib.Types.Custom != Types.Custom
</code></pre>
<p>because of <a href="https://docs.python.org/3/reference/import.html" rel="nofollow noreferrer">the way Python imports work</a>.</p>
<p>Python searches the import path and parses an appropriate entry that it finds.</p>
<ul>
<li>When you import <code>lib.Types</code>, it imports the <code>lib</code> directory as a package, then <code>lib/Types.py</code> as a submodule inside it, creating module objects <code>lib</code> and <code>lib.Types</code> in <code>sys.modules</code>.</li>
<li>When you import <code>Types</code>, it imports <code>Types.py</code> as a standalone module, creating a module object <code>Types</code> in <code>sys.modules</code>.</li>
</ul>
<p>So, <code>Types</code> and <code>lib.Types</code> end up as two different module objects. Python doesn't check if they are the same file to keep things simple and to avoid second-guessing you.</p>
<p>(This is actually listed in the <a href="http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html#the-double-import-trap" rel="nofollow noreferrer">Traps for the Unwary in Pythonâ€™s Import System</a> article as the "double import trap".)</p>
<hr/>
<p>If you remove <code>lib</code> from <code>PYTHONPATH</code>, the import in <code>lib/foo.py</code> would need to become a relative import:</p>
<pre><code>from .Types import Custom
</code></pre>
<p>or an absolute import:</p>
<pre><code>from lib.Types import Custom
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When a module is imported thru two different path in the same process - like here with <code>import Types</code> in <code>foo.py</code> and <code>import lib.Types</code> in <code>main.py</code>, it is really imported twice, yielding two distinct module objects, each with it's own distinct functions and class instances (you can check by yourself using <code>id(obj_or_class)</code>), effectively breaking <code>is</code> and <code>isinstance</code> tests.</p>
<p>The solution here would be to add <code>Project</code> (not <code>Project/lib</code>) to your pythonpath (fwiw that's what should have been done anyway - pythonpath/sys.path should be a list of directories <em>containing</em> packages and modules, not the packages directories themselves) and use <code>from lib.Type import Custom</code> everywhere, so you only have one single instance of the module. </p>
</div>
<span class="comment-copy">Irrespective of the import path, the class reference would remain the same. I don't think you should be facing any issue here.</span>
<span class="comment-copy">You are missing the <code>__init__.py</code> in the <code>lib</code> directory. See <a href="https://stackoverflow.com/questions/46688216/in-python3-does-import-work-transitively/46688250#46688250">here</a></span>
<span class="comment-copy">+ <code>types</code> is a name which exists in the std lib, I'd go for a different one.</span>
<span class="comment-copy">Either change the name, or if you must keep it the same, use relative imports <code>from .types import Custom</code>. That way it would be more explicit.</span>
<span class="comment-copy"><code>__init__.py</code> in your lib folder is actually relevant. Without this file, lib would not be imported as a module, thus <code>from lib.Types import Custom</code> would fail</span>
<span class="comment-copy">Personally, I wouldn't call it a "trap" because "trap" implies something actively counterintuitive. Accessing the same thing in the same place via two different routes is a stupid thing to do -- anywhere, not just in Python. So, this is rather a due punishment for bad design. Which is always a good thing -- it both teaches the botcher a valuable lesson and saves their users and peers from suffering from their mistakes in their stead.</span>
