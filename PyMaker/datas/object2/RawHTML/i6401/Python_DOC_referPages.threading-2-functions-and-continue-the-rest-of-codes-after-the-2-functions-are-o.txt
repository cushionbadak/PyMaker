<div class="post-text" itemprop="text">
<p>I want to run 2 functions at the same time. Then wait until those 2 functions are over, and it can start processing the rest of codes.  I tried to use <code>thread</code> module but it just continue running without waiting those 2 functions finished.  My example codes are as below: </p>
<pre><code>import os, sys
import threading
from threading import Thread

class Example():
    def __init__(self):
        self.method_1()

    def method_1(self):
        for i in range(3):
            print ('new')

            def run(self):
                threading.Thread(target = function_a, args=(self,)).start()
                threading.Thread(target = function_b, args=(self,)).start()

            def function_a(self):
                for i in range(10):
                    print (1)

            def function_b(self):
                for i in range(10):
                    print (2)

            run(self)


Example()
</code></pre>
<p>If the above codes get executed, the <code>print ("new")</code> inside <code>method_1</code> will just print out immediately even before the <code>function_a</code> and <code>function_b</code> are over in each round of the <code>for i in range(3)</code>. However, what I want is that the <code>new</code> will only be printed out as <code>function_a</code> and <code>function_b</code> are finished printing <code>1</code> and <code>2</code>.  </p>
<p>That is, the codes should stop at <code>threading</code> and wait for the <code>function_a</code> and <code>function_b</code> to finish so that it can continue processing the next <code>i</code> in the <code>for i in range(3)</code>.</p>
<p>If anyone know how to solve this, please let me know. Appreciated!!</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to <code>join</code> the threads (join means "wait for it to finish"). See the <a href="https://docs.python.org/3/library/threading.html#threading.Thread.join" rel="nofollow noreferrer">docs</a>. Depending on your problem, you may want to use <code>multiprocessing</code> instead, as mentioned in the comments. I'll proceed under the assumption that you do want to do threading.</p>
<p>Defining a class with methods to ask your question was unnecessary (and, even worse, you're redefining  <code>run</code>, <code>function_a</code>, and <code>function_b</code> on every iteration). Just use some functions. You can turn them into methods later if you need to.</p>
<pre><code>import time
import threading

def function_a():
    for i in range(5):
        print('a', i)
        time.sleep(.1)

def function_b():
    for i in range(5):
        print('b', i)
        time.sleep(.1)

def run():
    thread_a = threading.Thread(target = function_a)
    thread_b = threading.Thread(target = function_b)

    thread_a.start()
    thread_b.start()

    print('threads started')

    return thread_a, thread_b

for i in range(3):
    print('new', i)

    thread_a, thread_b = run()

    print('about to join threads')

    thread_a.join()
    thread_b.join()

    print('threads joined')
</code></pre>
<p>The <code>sleep</code>s are just there to show that the two threads really are running at the same time. Example output (which may vary from run to run depending on exact timing):</p>
<pre><code>new 0
a 0
b 0
threads started
about to join threads
a 1
b 1
a 2
b 2
a 3
b 3
a 4
b 4
threads joined
new 1
a 0
b 0
threads started
about to join threads
a 1
b 1
a 2
b 2
a 3
b 3
a 4
b 4
threads joined
new 2
a 0
b 0
threads started
about to join threads
a 1
b 1
b 2
a 2
b 3
a 3
b 4
a 4
threads joined
</code></pre>
<p>EDIT: class-based example</p>
<pre><code>class Example():
    def function_a(self):
        for i in range(5):
            print('a', i)
            time.sleep(.1)

    def function_b(self):
        for i in range(5):
            print('b', i)
            time.sleep(.1)

    def get_threads(self):
        thread_a = threading.Thread(target = self.function_a)
        thread_b = threading.Thread(target = self.function_b)

        thread_a.start()
        thread_b.start()

        print('threads started')

        return thread_a, thread_b

    def run(self):
        for i in range(3):
            print('new', i)

            thread_a, thread_b = self.get_threads()

            print('about to join threads')

            thread_a.join()
            thread_b.join()

            print('threads joined')

e = Example()
e.run()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As already pointed out in the other answer, you need to join the threads. This example keeps your structure. I have added a sleep there so that you can see it works (otherwise buffered output might mess things up). </p>
<pre><code>import os, sys
import threading
from threading import Thread
from time import sleep

class Example():
    def __init__(self):
        self.method_1()

    def method_1(self):
        for i in range(3):
            print ('new')

            def run(self):
                a=threading.Thread(target = function_a, args=(self,))
                b=threading.Thread(target = function_b, args=(self,))
                a.start()
                b.start()
                a.join()
                b.join()

            def function_a(self):
                for i in range(10):
                    print (1)

            def function_b(self):
                for i in range(10):
                    print (2)

            run(self)
            sleep(1)


Example()
</code></pre>
</div>
<span class="comment-copy">I am no expert in threading, why not use multiprocessing module if you want to run two functions in parallel. That'd be a more solid approach</span>
<span class="comment-copy">I am no expert in <code>threading</code> nor <code>multiprocessing</code> too... Could you pls provide an example or solution using <code>multiprocessing</code> if possible? Appreciated!!</span>
<span class="comment-copy">See if this will help  <a href="https://www.youtube.com/watch?v=aysceqdGFw8&amp;t=482s" rel="nofollow noreferrer">youtube.com/watch?v=aysceqdGFw8&amp;t=482s</a></span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/3044580/multiprocessing-vs-threading-python?rq=1" title="multiprocessing vs threading python">stackoverflow.com/questions/3044580/â€¦</a></span>
<span class="comment-copy">I don't know if your videos is suitable for this questions.. Because for my question there is a <code>for loop</code> before the <code>threading</code>. But there's no <code>for loop</code> in that video.  I just want the <code>threading</code> stops before the functions are finished so it can start processing the next round of the <code>for loop</code>.</span>
<span class="comment-copy">Umm actually all these class/method/function has to remain the exact same structures... Because I'm building a much larger program and it's just a very small part of codes in this example.</span>
<span class="comment-copy">No worries - it should be easy to adapt my example to make the structure more like yours. Just move the functions you define in the loop into the class definition, and <code>join</code> the threads before you go to the next iteration of the loop.</span>
<span class="comment-copy">Could you pls provide an solution with a class like mine? I tried but it didn't work... It's just very confusing with those <code>self</code> arguments involved.</span>
<span class="comment-copy">@ryan9025 Done.</span>
<span class="comment-copy">@ryan9025 You really don't. I'm having trouble imagining a situation where you couldn't define them on the class itself and just pass in whatever information they need from inside <code>run</code>. You almost certainly don't need to redefine them on every loop like you do in your code.</span>
<span class="comment-copy">Appreciated!! Sorry that I have to give the answer to the other one becos he answers first.  But this solution is perfect as well</span>
<span class="comment-copy">No problem. The main thing is that it works now.</span>
