<div class="post-text" itemprop="text">
<p>I'm looking to merge two dictionaries shown below, but I was unsuccessful in doing so.</p>
<p>I have read many blog posts, but I did not find an answer.</p>
<pre><code>dict1={"KPNS": {"metadocdep": {"eta": {"sal": "2"}}, "metadocdisp": {"meta": {"head": "1"}}}, "EGLS": {"apns": {"eta": {"sal": "2"}}, "gcm": {"meta": {"head": "1"}}}}

dict2={"KPNS": {"metadocdep": {"eta": {"sal": "7"}}, "metadocdisp": {"meta": {"head": "5"}}}, "EGLS": {"apns": {"eta": {"sal": "7"}}, "gcm": {"meta": {"head": "9"}}}}
finaldict = {key:(dict1[key], dict2[key]) for key in dict1}

print finaldict
</code></pre>
<p>My final output should be like:</p>
<pre><code>{"KPNS": {"metadocdep": {"eta": {"sal": [2,7]}},
          "metadocdisp": {"meta": {"head": [1,5]}}},
 "EGLS": {"apns": {"eta": {"sal": [2,7]}},
          "gcm": {"meta": {"head": [1,9]}}}}
</code></pre>
<p>How can I do this?</p>
</div>
<div class="post-text" itemprop="text">
<h1>With defaultdict</h1>
<p>If you know what the expected depth is, you could use nested <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdicts</a> to define <code>final_dict</code>:</p>
<pre><code>from collections import defaultdict

final_dict = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))

final_dict['a']['b']['c'].append(1)
print(final_dict)
# defaultdict(&lt;function &lt;lambda&gt; at 0x7f2ae7f41e18&gt;, {'a': defaultdict(&lt;function &lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt; at 0x7f2ae636b730&gt;, {'b': defaultdict(&lt;class 'list'&gt;, {'c': [1]})})})
</code></pre>
<p>There's a lot of added output because of the <code>defaultdict</code>, but you could treat <code>final_dict</code> as a simple dict.</p>
<h1>With dicts</h1>
<p>With standard dicts, you'll have to use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>setdefault</code></a>. The code doesn't become very readable, though:</p>
<pre><code>dict1 = {"KPNS": {"metadocdep": {"eta": {"sal": "2"}}, "metadocdisp": {"meta": {
    "head": "1"}}}, "EGLS": {"apns": {"eta": {"sal": "2"}}, "gcm": {"meta": {"head": "1"}}}}

dict2 = {"KPNS": {"metadocdep": {"eta": {"sal": "7"}}, "metadocdisp": {"meta": {
    "head": "5"}}}, "EGLS": {"apns": {"eta": {"sal": "7"}}, "gcm": {"meta": {"head": "9"}}}}

final_dict = {}
for d in [dict1, dict2]:
    for level1 in d:
        for level2 in d[level1]:
            for level3 in d[level1][level2]:
                for level4 in d[level1][level2][level3]:
                    final_dict.setdefault(level1, {}).setdefault(level2, {}).setdefault(
                        level3, {}).setdefault(level4, []).append(d[level1][level2][level3][level4])

print(final_dict)
# {'KPNS': {'metadocdep': {'eta': {'sal': ['2', '7']}}, 'metadocdisp': {'meta': {'head': ['1', '5']}}}, 'EGLS': {'apns': {'eta': {'sal': ['2', '7']}}, 'gcm': {'meta': {'head': ['1', '9']}}}}
</code></pre>
<p>It might be a bit more efficient with <code>dict.items()</code>:</p>
<pre><code>for d in [dict1, dict2]:
    for level1, d2s in d.items():
        for level2, d3s in d2s.items():
            for level3, d4s in d3s.items():
                for level4, v in d4s.items():
                    final_dict.setdefault(level1, {}).setdefault(level2, {}).setdefault(
                        level3, {}).setdefault(level4, []).append(v)
</code></pre>
</div>
<span class="comment-copy">Do your dicts have constant depth or they have inderminate subdicts?</span>
<span class="comment-copy">because you have to define a structure for ur dict. is there more than 4 level? only the last level must be a list? can we have different element in the two dict in each level?</span>
<span class="comment-copy">they have constant depth</span>
<span class="comment-copy">@AdouaniRiadh Only the last level will be a list. There are no different elements in each level</span>
