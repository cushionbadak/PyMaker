<div class="post-text" itemprop="text">
<p>There seem to be two kinds of generator-based coroutine:</p>
<ol>
<li><p>From <a href="https://stackoverflow.com/a/46203922/156458">a
reply</a>
by Jim Fasarakis Hilliard:</p>
<blockquote>
<p><strong>Generator-based coroutine</strong>: A generator (<code>def</code> + <code>yield</code>) that is wrapped by  <a href="https://docs.python.org/3/library/types.html#types.coroutine" rel="nofollow noreferrer"><code>types.coroutine</code></a> . You need to wrap it in
  <code>types.coroutine</code> if you need it to be considered a coroutine object.</p>
</blockquote></li>
<li><p>From Python in a Nutshell, which doesn't explicitly call it
"generator-based coroutine":</p>
<blockquote>
<p>When you write Python code based on  <code>asyncio</code>  (ideally also using
  add-on modules from  asyncio.org),  you’ll  usually  be  writing 
  coroutine  functions.  Up  to  Python  3.4 included, such functions
  are generators using the  <code>yield from</code>  statement covered in “yield
  from (v3-only)” on page 95, decorated with  <code>@asyncio.coroutine</code> ,
  covered in “asyncio coroutines” on page 518;</p>
</blockquote>
<p>From
<a href="https://www.python.org/dev/peps/pep-0492/#differences-from-generators" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-0492/#differences-from-generators</a></p>
<blockquote>
<p>generator-based coroutines (for asyncio code must be decorated with @asyncio.coroutine)</p>
</blockquote>
<p><a href="http://masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html" rel="nofollow noreferrer">http://masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html</a>
also calls it "generator-based coroutine".</p></li>
</ol>
<p>Are the two kinds of generator-based coroutines the same concept?</p>
<p>If not, what are their differences in purposes and usages?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>They're the same kind of coroutine. <code>types.coroutine</code> and <code>asyncio.coroutine</code> are just two separate ways to create them.</p>
<p><code>asyncio.coroutine</code> is older, predating the introduction of <code>async</code> coroutines, and its functionality has shifted somewhat from its original behavior now that <code>async</code> coroutines exist.</p>
<p><code>asyncio.coroutine</code> and <code>types.coroutine</code> have subtly different behavior, especially if applied to anything other than a generator function, or if asyncio is in <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONASYNCIODEBUG" rel="nofollow noreferrer">debug mode</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I’m concerned, <code>async def</code> is the <strong>proper</strong> way to define a coroutine. <code>yield</code> and <code>yield from</code> have their purpose in generators, and they are also used to implement “futures”, which are the low-level mechanism that handles switching between different coroutine contexts.</p>
<p>I did <a href="https://default-cube.deviantart.com/art/Van-Rossum-s-Triangle-679791228" rel="nofollow noreferrer">this diagram</a> a few months ago to summarize the relationships between them. But frankly, you can safely ignore the whole business. Event loops have the job of handling all the low-level details of managing the execution of coroutines, so use one of those, like <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a>. There are also <code>asyncio</code>-compatible wrappers for other event loops, like my own <a href="https://github.com/ldo/glibcoro" rel="nofollow noreferrer"><code>glibcoro</code></a> for GLib/GTK.</p>
<p>In other words, stick to the <code>asyncio</code> API, and you can write “event-loop-agnostic” coroutines!</p>
</div>
