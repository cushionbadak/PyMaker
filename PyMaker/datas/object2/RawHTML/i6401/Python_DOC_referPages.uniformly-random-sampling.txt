<div class="post-text" itemprop="text">
<p>My problem is as follows, I have 4 playing cards face down in front of me. There is a King, Queen, Jack, and Ace. I pick a card, look at it, then put it back face down in front of me. I'm trying to simulate picking 3 cards 1000 times (you can pick the same card multiple times) i.e. one sample of 3 can be Jack, Jack, and King. I've tried to do that here:</p>
<pre><code>import random

cards=["King", "Queen", "Jack", "Ace"]

for i in range(1000):
    print([random.sample(cards, 3)])
</code></pre>
<p>All this does is print out 1000 iterations of picking 3 cards, but it never picks the same card twice, which it should.</p>
<p>What I wanna do is count how many times I pick 3 unique cards and then calculate the probability of doing so.Then I want to calculate the average number of different cards I pick each trial. I know it will help to add values to a list, but I'm not sure how to go about it. Apologize for formatting, I'm inexperienced.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should give the desired output</p>
<pre><code>import random
cards=["King", "Queen", "Jack", "Ace"]
outputs = []
k = 0
q = 0
j = 0
a = 0
for i in range(1000):
    x = random.sample(cards, 3)
    outputs.append(x[0])
for y in range(len(outputs)):
    if outputs[y] == 'King':
        k +=1
    elif outputs[y] == 'Queen':
        q += 1
    elif outputs[y] == 'Jack':
        j +=1
    elif outputs[y] == 'Ace':
        a +=1

print('No. kings =', k, 'No. Queens =', q, 'No. Jacks =', j, 'No. Aces =', a)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Does this look like what you are looking?</p>
<pre><code>from random import sample, choice
from itertools import groupby
cards=["King", "Queen", "Jack", "Ace"]
unique = 0
for i in range(1000):
    #sample will return unique
    d = sample(cards, 3)
    if len(list(groupby(d))) == 3:
        unique += 1
print(unique)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Monte-Carlo can be confusing â€” at least for me. My first step was to try out code that would produce samples of three cards. I set <code>N</code> to 10.</p>
<pre><code>for n in range(N):
    sample = [random.choice(cards) for _ in range(3)]
    print (sample)
</code></pre>
<p>The output was this. Obviously this is no guarantee that I was successful but it appears that it's possible for the code to produce all possibilities. I could try increasing <code>N</code> if I had any real worries.</p>
<pre><code>['Jack', 'Jack', 'King']
['Jack', 'Ace', 'Ace']
['Ace', 'Ace', 'Jack']
['Ace', 'Queen', 'Ace']
['Ace', 'King', 'King']
['King', 'Jack', 'King']
['Queen', 'King', 'Ace']
['Queen', 'Queen', 'Queen']
['King', 'Jack', 'Ace']
['Jack', 'Jack', 'King']
</code></pre>
<p>You want to count uniques. This might be most conveniently done by converting <code>samples</code> to a <code>set</code> and taking its <code>len</code>. Calculating an average is easy.</p>
<pre><code>unique_count = 0
for n in range(N):
    sample = [random.choice(cards) for _ in range(3)]
    unique_count += 1 if len(set(sample))==1 else 0

print(unique_count)
</code></pre>
<p>A dictionary is not a bad place to keep counts. Initialise it outside the loop and then increment entries.</p>
<pre><code>import random

cards=["King", "Queen", "Jack", "Ace"]

N = 100000

unique_count = 0
card_counts = {_: 0 for _ in cards}
for n in range(N):
    sample = [random.choice(cards) for _ in range(3)]
    unique_count += 1 if len(set(sample))==1 else 0
    for s in sample:
        card_counts[s]+=1

print(unique_count)
total = 0
for s in cards:
    total += card_counts[s]
    print (s, card_counts[s])
print (total)
</code></pre>
<p>When I'm experimenting I often try increasingly large values of N in hopes of seeing convergence.</p>
</div>
<span class="comment-copy">In the loop you will want to get the <a href="https://stackoverflow.com/search?q=python+list+unique+count">unique count</a> of the sample, check if it equals 3, and add to a count variable.</span>
<span class="comment-copy"><code>random.sample</code> selects <i>without replacement</i>. If you have Python 3.6 (or more recent) see <code>random.choice</code>. <a href="https://docs.python.org/3/library/random.html#functions-for-sequences" rel="nofollow noreferrer">Documentation</a></span>
<span class="comment-copy">@rici: If you don't have 3.6, implementing just the uniform version of <code>random.choice</code> is trivial.</span>
<span class="comment-copy">@davis: sure, no argument. But reading docs is always a good habit. You might find useful stuff.</span>
<span class="comment-copy">@rici: Of course: prefer the standard library over other libraries over doing it yourself.  I just didn't want to discourage anyone not having that version.</span>
<span class="comment-copy">when running this it gives an output of 1000 each time. This tells me that it might not be taking into account replacement (you can pick the same card multiple times). So for one sample of 3 I could pick King, Jack, and King again.</span>
<span class="comment-copy"><code>random.sample</code> function mentions already <code>Return a k length list of unique elements chosen from the population sequence</code> <a href="https://docs.python.org/2/library/random.html" rel="nofollow noreferrer">Random</a>. You could you choice instead if multiple picks are allowed.</span>
