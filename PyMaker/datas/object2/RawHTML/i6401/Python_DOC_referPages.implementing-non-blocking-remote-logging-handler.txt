<div class="post-text" itemprop="text">
<p>I'm trying to implement simple log handler that uses Python's standard <code>logging</code> library to log events to remote server. So I created custom class inherited from <code>logging.Handler</code> called <code>RemoteLogHandler</code> that accepts <code>LogRecord</code> and sends it to remote server. The handler is attached to root logger in standard <code>addHandler()</code> manner.</p>
<pre><code>from urllib import requests

class RemoteLogHandler(logging.Handler):
    def emit(self, record):
        remote_url = "http://foo.bar.baz"
        req = request.Request(remote_url, data=record.msg)
        request.urlopen(req, timeout=1)
</code></pre>
<p>This works as intended, but can obviously cause locking of the calling thread when the remote_url becomes inaccessible or starts responding slowly. So I'm trying to figure best way to make this call independent on the calling thread.</p>
<p>What I've considered:</p>
<ol>
<li>Including some non-standard library that would make the http request asynchronous</li>
<li>Using QueueHandler and QueueListener as outlined <a href="http://plumberjack.blogspot.cz/2010/09/improved-queuehandler-queuelistener.html" rel="nofollow noreferrer">here</a></li>
<li>Using asyncio</li>
</ol>
<p>All these solutions seem to be way too complex/unnecessary for achieving such simple task. Is there some better approach with less overhead in order to make this handler non-blocking?</p>
</div>
<div class="post-text" itemprop="text">
<p>For anyone who will face this, the solution turned out to be simple as described <a href="https://docs.python.org/3/howto/logging-cookbook.html#dealing-with-handlers-that-block" rel="nofollow noreferrer">here</a>.</p>
<pre><code>import queue
from logging import QueueHandler, QueueListener

# instantiate queue &amp; attach it to handler
log_queue = queue.Queue(-1)
queue_handler = QueueHandler(log_queue)

# instantiate our custom log handler (see question)
remote_handler = RemoteLogHandler()

# instantiate listener
remote_listener = QueueListener(log_queue, remote_handler)

# attach custom handler to root logger
logging.getLogger().addHandler(queue_handler)

# start the listener
remote_listener.start()
</code></pre>
<p>QueueListener runs in its own thread and listens to LogRecords that are sent by QueueHandlers which results in non-blocking logging.</p>
</div>
<span class="comment-copy">Your app shouldn't be routing its logs anywhere, see e.g. <a href="https://12factor.net/logs" rel="nofollow noreferrer">12factor.net/logs</a></span>
<span class="comment-copy">Why do you believe that the queuing solution is an overcomplication? It is the only solution here: a worker thread that pushes the records remotely, and the normal thread(s) that add the records to the queue when emitting them.</span>
<span class="comment-copy">You can also switch to the UDP traffic, and just send the datagrams in the emitting method, non-blocking. But there will be no guarantee of delivery and processing remotely (syslog handler works that way, afaik).</span>
<span class="comment-copy">You were right, I ended up using QueueHandler/Listener from logging package and it turned out to be quite straightforward.</span>
