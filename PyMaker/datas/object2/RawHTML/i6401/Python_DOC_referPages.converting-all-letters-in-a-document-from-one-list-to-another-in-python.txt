<div class="post-text" itemprop="text">
<p>I have two lists</p>
<pre><code>list1 = ['a', 'b', 'c']
list2 = ['d', 'e', 'f']
</code></pre>
<p>I have a variable with random text in it.</p>
<p><code>var = 'backout'</code></p>
<p>I want to convert all letters in the variable that exist in list1 to the letters in list2.</p>
<p><code>expectedOutput = 'edfkout'</code></p>
<p>Is there a way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to use <a href="https://docs.python.org/2/library/stdtypes.html#str.translate" rel="noreferrer"><code>str.translate</code></a> using a translation table from <a href="https://docs.python.org/2/library/string.html#string.maketrans" rel="noreferrer"><code>string.maketrans</code></a> (This is <a href="https://docs.python.org/3/library/stdtypes.html#str.maketrans" rel="noreferrer"><code>str.maketrans</code></a> in Python 3)</p>
<pre><code>from string import maketrans

s1 = 'abc'
s2 = 'def'
table = maketrans(s1, s2)
print('backout'.translate(table))
</code></pre>
<p>Edit:</p>
<p>Note that we have to use strings instead of lists as our arguments to <code>maketrans</code>.  </p>
</div>
<div class="post-text" itemprop="text">
<p>We can map the keys to values using a <code>zip()</code>wrapped with <code>dict()</code> and then iterate the letters and map them to their corresponding ones with themselves being the default (in case not found):</p>
<pre><code>keys = ['a', 'b', 'c']
values = ['d', 'e', 'f']
mapper = dict(zip(keys, values))
var = 'backout'
output = "".join([mapper.get(k, k) for k in var])
print(output) # edfkout
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Convert each char to its ascii value using <code>map(ord,list1)</code> and do the 1-1 mapping b/w list1 and list2 using <code>zip</code></p>
<pre><code>tbl = dict(zip(map(ord,list1), map(ord,list2)))
var.translate(tbl)
</code></pre>
<p>Output:</p>
<pre><code>edfkout
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For people who prefer shorter but more complicated solution (instead of using the <code>translate()</code> method), here it is:</p>
<pre><code>list1 = ['a', 'b', 'c']
list2 = ['d', 'e', 'f']
var = 'backout'

trans_dict = dict(zip(list1, list2))
out_string = ''.join([trans_dict.get(ch, ch) for ch in var])
</code></pre>
<hr/>
<p>The explanation:</p>
<pre><code> dict(zip(list1, list2))
</code></pre>
<p>creates the <code>{'a': 'd', 'b': 'e', 'c': 'f'}</code> dictionary.</p>
<pre><code>trans_dict.get(ch, ch)
</code></pre>
<p>The 1<sup>st</sup> argument is a <em>key</em> - if it <em>is found</em> in keys, we obtain its value: <code>trans_dict[ch]</code></p>
<p>The 2<sup>nd</sup> argument is a <em>default value</em> - used if the first argument is not found in keys. We obtain <code>ch</code>.</p>
<pre><code>[trans_dict.get(ch, ch) for ch in var]
</code></pre>
<p>is a list comprehension - something as creating a list from the <em>empty list</em>, appending next and next element in the <code>for</code> loop.</p>
<pre><code>''.join(list_of_string) 
</code></pre>
<p>is a standard way for <em>concatenating individual elements of the list</em> (in our case, the individual characters).<br/>
(Instead of the <em>empty</em> string there may be an <em>arbitrary string</em> - it is used for delimiting individual elements in the concatenated string)  </p>
</div>
<span class="comment-copy">Yep, this is a much better solution than mine, nice job :-) +1</span>
<span class="comment-copy">Similar answer is already given by @alfasin</span>
<span class="comment-copy">@santhosh - It is absolutely normal that 2 or more people work in their answers simultaneously, with different speeds, and that their answers are similar, as they are common pythonic and idiomatic ways how to accomplish tasks. I'm relatively slow and as you may note, my answer is much longer.</span>
