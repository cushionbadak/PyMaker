<div class="post-text" itemprop="text">
<p>Hi I am using Python to sort my GPS data based on the timestamps and also I would like to add the function of error if the location is same but different timestamp is not possible. I found that my data set is a bit weird. If you can can you suggest new data set type? So far I have this...</p>
<pre><code>dic_loc = {'latitude': [],
           'longitude': [],
           'timestamp': []}

def make_timestamped_loc(La, Lng, TS):

    dic_loc['latitude'].append(La)
    dic_loc['longitude'].append(Lng)
    dic_loc['timestamp'].append(int(TS))

make_timestamped_loc(37.481236, 126.952733, 1483196400)
make_timestamped_loc(37.310045, 127.101255, 1408323255)
make_timestamped_loc(37.383065, 126.672596, 1508322531)
make_timestamped_loc(37.383065, 126.672596, 1444999230)

def sort_locs(dictSorting):
    # sortedByTime = sorted(dictSorting.items(), key = lambda i:i[1])
    # print(sortedByTime)
    dictSorting.sort()
    # print(dic_loc)
sort_locs(dic_loc['timestamp'])
print(dic_loc)
</code></pre>
<p>This code only sort the timestamp values. But I would like my other keys to follow the order of timestamp's value.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could store <code>lat</code>, <code>lon</code> and <code>timestamp</code> in a dict:</p>
<pre><code>dic_loc = []

def make_timestamped_loc(La, Lng, TS):
   new_loc = {}
   new_loc['latitude'] = La
   new_loc['longitude'] = Lng
   new_loc['timestamp'] = int(TS)
   dic_loc.append(new_loc)
</code></pre>
<p>The sorting could be done like this:</p>
<pre><code>newlist = sorted(dic_loc, key=lambda k: k['timestamp']) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a> for this.</p>
<pre><code>from collections import namedtuple
GpsPoint = namedtuple('GpsPoint', ['timestamp', 'latitude', 'longitude'])
points = []
points.append(GpsPoint(1483196400, 37.481236, 126.952733))
points.append(GpsPoint(1408323255, 37.310045, 127.101255))
points.append(GpsPoint(1508322531, 37.383065, 126.672596))
points.append(GpsPoint(1444999230, 37.383065, 126.672596))

print(sorted(points))
</code></pre>
<p>The attributes of each point are directly accessible:</p>
<pre><code>&gt;&gt;&gt; point = GpsPoint(1444999230, 37.383065, 126.672596)
&gt;&gt;&gt; point.timestamp
1444999230
&gt;&gt;&gt; # or by index
&gt;&gt;&gt; point[0]
1444999230
&gt;&gt;&gt; point
GpsPoint(timestamp=1444999230, latitude=37.383065, longitude=126.672596)
</code></pre>
<p>And it acts like a tuple for sorting so it sorts by the first index (timestamp)</p>
<p>This is a bit of change from having lists of long/lat/time but it forces the points to stay in sync. With the dictionary of lists approach the longitudes can get into a different order to the latitudes so there's no way to get back to the original data.</p>
</div>
<div class="post-text" itemprop="text">
<p>Convert this dict into pandas dataframe.</p>
<p>then </p>
<p>sorted = my_dataframe.sort_values(by='timestamp',ascending=False)</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a simple function that does what you ask for:</p>
<pre><code>def make_timestamped_loc(La, Lng, TS):
    d = dict(latitude=La,longitude=Lng,timestamp=TS)
    features.append(d)

features = []
make_timestamped_loc(37.481236, 126.952733, 1483196400)
make_timestamped_loc(37.310045, 127.101255, 1408323255)
make_timestamped_loc(37.383065, 126.672596, 1508322531)
make_timestamped_loc(37.383065, 126.672596, 1444999230)
</code></pre>
<hr/>
<p><strong>or:</strong></p>
<hr/>
<pre><code>cols = ['latitude','longitude','timestamp']

features = []

features.append(dict(zip(cols,(37.481236, 126.952733, 1483196400))))
features.append(dict(zip(cols,(37.310045, 127.101255, 1408323255))))
features.append(dict(zip(cols,(37.383065, 126.672596, 1508322531))))
features.append(dict(zip(cols,(37.383065, 126.672596, 1444999230))))
</code></pre>
<hr/>
<p><strong>then:</strong></p>
<pre><code>sorted(features,key=lambda x: x["timestamp"])
</code></pre>
<p>Result</p>
<pre><code>[{'latitude': 37.310045, 'longitude': 127.101255, 'timestamp': 1408323255},
 {'latitude': 37.383065, 'longitude': 126.672596, 'timestamp': 1444999230},
 {'latitude': 37.481236, 'longitude': 126.952733, 'timestamp': 1483196400},
 {'latitude': 37.383065, 'longitude': 126.672596, 'timestamp': 1508322531}]
</code></pre>
<hr/>
<p><strong>Different approach:</strong></p>
<p>But may I suggest you use pandas for this:</p>
<pre><code>import pandas as pd
import io

text_in_file = u"""37.481236, 126.952733, 1483196400
37.310045, 127.101255, 1408323255
37.383065, 126.672596, 1508322531
37.383065, 126.672596, 1444999230"""

df = pd.read_csv(io.StringIO(text_in_file),header=None)
df.columns = ['latitude','longitude','timestamp']
</code></pre>
<hr/>
<p><strong>or</strong></p>
<hr/>
<pre><code>import pandas as pd
import io

cols = ['latitude','longitude','timestamp']
df = pd.DataFrame(columns=cols)

df.loc[len(df)] = (37.481236, 126.952733, 1483196400)
df.loc[len(df)] = (37.310045, 127.101255, 1408323255)
df.loc[len(df)] = (37.383065, 126.672596, 1508322531)
df.loc[len(df)] = (37.383065, 126.672596, 1444999230)
</code></pre>
<hr/>
<p><strong>then:</strong></p>
<pre><code>df.sort_values(by="timestamp").to_dict(orient="records")
</code></pre>
<p>Returns:</p>
<pre><code>[{'latitude': 37.310045000000002,
  'longitude': 127.10125499999999,
  'timestamp': 1408323255.0},
 {'latitude': 37.383065000000002,
  'longitude': 126.672596,
  'timestamp': 1444999230.0},
 {'latitude': 37.481236000000003,
  'longitude': 126.95273299999999,
  'timestamp': 1483196400.0},
 {'latitude': 37.383065000000002,
  'longitude': 126.672596,
  'timestamp': 1508322531.0}]
</code></pre>
</div>
<span class="comment-copy">Hyun you are storing the lat, long and ts values in separate <code>list</code>s inside a <code>dict</code>. That's not a good idea, they are 3 data pieces that need to be together. Instead use either <code>dict</code>s, <code>tuple</code>s, <code>collections.namedtuple</code> or any other container to group these 3 values together and then insert this container into a list. Then you only need to set the <code>key</code> parameter of the <code>sorted()</code> builtin function to be a function that returns the value you want to use to sort it. The <code>reversed</code> parameter allows you to invert the order if you find they are in the opposite order you would expect.</span>
<span class="comment-copy">Where did you get your data from? What is the input?</span>
<span class="comment-copy">@AntonvBR I simply put input like make_timestamped_loc()</span>
<span class="comment-copy">make_timestamped_loc() ?? But what happens next? Does that function return data? If you tell us how you get your data it is much easier to help</span>
<span class="comment-copy">@AntonvBR It is not for returning any data. It is just simply for sorting the data. and printing the data when run it. It is just for practice assignment</span>
<span class="comment-copy">This method only gives me empty dictionary</span>
<span class="comment-copy">I have forgotten the <code>append</code>... now it should work</span>
<span class="comment-copy">Is this dictionary type?</span>
<span class="comment-copy">Yes, the new_loc is a dictionary and the dic_loc is a list of dictionaries. Please refer to the documentation: <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">docs.python.org/3/tutorial/datastructures.html#dictionaries</a> <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer">docs.python.org/3/tutorial/datastructures.html#more-on-lists</a></span>
<span class="comment-copy">Hi I am sorry for bothering you but could you help me making making the "newlist = sorted(dic_loc, key=lambda k: k['timestamp'])" into function format??</span>
<span class="comment-copy">Thank you. But what is features  = [] is for?</span>
<span class="comment-copy">@HyunMoLukeYang To initiate an empty list which you fill your values to.</span>
<span class="comment-copy">I dont know why my result does not sort at all...</span>
<span class="comment-copy">@HyunMoLukeYang Very good question. Are you sure you used the sort function correctly?</span>
<span class="comment-copy">oh I have to give new variable I see. But can I make this into function form?</span>
