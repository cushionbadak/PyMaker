<div class="post-text" itemprop="text">
<p>I have a list that essentially goes as such:</p>
<pre><code>Dalc = [1,2,1,1,1,1,1,1,1,1,1,1,5,1,1,3,1,2,1,1,1,1,2.......]
</code></pre>
<p>It currently contains 395 elements, and I'm trying to extend it such that I keep the same percentage of 1's, 2's, 3's, 4's and 5's. Min = 1, Max = 5, and I initially did the following to try and extend the list past 10000 elements:</p>
<pre><code>from random import randint

....

Dalc_add = []
dalc_max = max(Dalc)
dalc_min = min(Dalc)
i = 0

while i &lt; 10000:
    Dalc_add.append(randint(dalc_min, dalc_max))
    i = i + 1

Dalc.append(Dalc_add)
</code></pre>
<p>What this gave was a list with the initial bias present for the first 395 iterations, but then after that the rest of the list looked like:</p>
<p><code>[1,5,3,2,3,1,4,2,4,5,2,5,3,2,1,3,4,2,1,3,3,4,1........]</code></p>
<p>A lot more 3, 4, &amp; 5 present, and it completely messes up any statistical analysis I can perform. </p>
<p>How do I extend the list as above, while also preserving the weights and biases present (with respect to frequency of occurrence) for the list values?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.random.choice.html" rel="nofollow noreferrer"><code>numpy.random.choice</code></a>. This randomly samples from the original list. If you feed it the original list, you don't need to use weights:</p>
<pre><code>import numpy as np

Dalc = [1,2,1,1,1,1,1,1,1,1,1,1,5,1,1,3,1,2,1,1,1,1,2]
new_choices = np.random.choice(Dalc, size=10000)
Dalc += list(new_choices)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have two options:</p>
<pre><code>from random import choices
Dalc.extend(choices(Dalc, k=numTimes))
</code></pre>
<p>or </p>
<pre><code>from numpy.random import choice
Dalc.extend(choice(Dalc, size=numTimes))
</code></pre>
<p>This chooses randomly from <code>Dalc</code> <code>numTimes</code> times, which should obviously keep your weights the same.</p>
<p>Which you should use depends on two things, whether <code>numTimes</code> is large and whether <code>Dalc</code> is large. Using <code>timeit</code>:</p>
<pre><code>import timeit

print('Standard | Numpy')

print(timeit.timeit('choices([1,2,3,4,5], k=10000)', setup='from random import choices', number=10000), end=' | ')
print(timeit.timeit('choice([1,2,3,4,5], size=10000)', setup='from numpy.random import choice', number=10000))

print(timeit.timeit('choices([1,2,3,4,5], k=1000)', setup='from random import choices', number=10000), end=' | ')
print(timeit.timeit('choice([1,2,3,4,5], size=1000)', setup='from numpy.random import choice', number=10000))

print(timeit.timeit('choices([1,2,3,4,5], k=100)', setup='from random import choices', number=10000), end=' | ')
print(timeit.timeit('choice([1,2,3,4,5], size=100)', setup='from numpy.random import choice', number=10000))

print(timeit.timeit('choices([1,2,3,4,5], k=10)', setup='from random import choices', number=10000), end=' | ')
print(timeit.timeit('choice([1,2,3,4,5], size=10)', setup='from numpy.random import choice', number=10000))

print(timeit.timeit('choices([1,2,3,4,5], k=5)', setup='from random import choices', number=10000), end=' | ')
print(timeit.timeit('choice([1,2,3,4,5], size=5)', setup='from numpy.random import choice', number=10000))

print()

print(timeit.timeit('choices([1,2,3,4,5]*10000, k=60)', setup='from random import choices', number=10000), end=' | ')
print(timeit.timeit('choice([1,2,3,4,5]*10000, size=60)', setup='from numpy.random import choice', number=10000))

print(timeit.timeit('choices([1,2,3,4,5]*1000, k=60)', setup='from random import choices', number=10000), end=' | ')
print(timeit.timeit('choice([1,2,3,4,5]*1000, size=60)', setup='from numpy.random import choice', number=10000))

print(timeit.timeit('choices([1,2,3,4,5]*100, k=60)', setup='from random import choices', number=10000), end=' | ')
print(timeit.timeit('choice([1,2,3,4,5]*100, size=60)', setup='from numpy.random import choice', number=10000))

print(timeit.timeit('choices([1,2,3,4,5]*10, k=60)', setup='from random import choices', number=10000), end=' | ')
print(timeit.timeit('choice([1,2,3,4,5]*10, size=60)', setup='from numpy.random import choice', number=10000))

print(timeit.timeit('choices([1,2,3,4,5], k=60)', setup='from random import choices', number=10000), end=' | ')
print(timeit.timeit('choice([1,2,3,4,5], size=60)', setup='from numpy.random import choice', number=10000))
</code></pre>
<p>Giving us the output:</p>
<pre><code>Standard | Numpy
25.372834796129872 | 1.8409739351390613
2.5144703081718696 | 0.316072358469512
0.2527455696737988 | 0.15912525398981003
0.03453532081119093 | 0.13720956183202304
0.021838018317897223 | 0.1544090297115197

1.2724984282899072 | 26.585005448108767
0.29600333450513006 | 2.7196871458182343
0.16926004909861803 | 0.4086584816186516
0.14861485298857957 | 0.16870138091688602
0.15621485532244606 | 0.1448146694886887
</code></pre>
<p>So if numTimes is quite large, Numpy is the clear winner, but if the size of <code>Dalc</code> is quite large it seems that vanilla python is the way to go.</p>
</div>
<span class="comment-copy">Sounds like you want <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices</code></a> with weights.</span>
<span class="comment-copy">if you have numpy: <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.random.choice.html" rel="nofollow noreferrer">docs.scipy.org/doc/numpy-dev/reference/generated/â€¦</a></span>
<span class="comment-copy">@PatrickHaugh I'm looking through the random.choices docs, but still a little confused where the weights are <i>set</i>, Could you explain that a little?</span>
<span class="comment-copy">That's beautiful, thank you so much!</span>
<span class="comment-copy">You don't need numpy for this, you can just use <code>import random</code> and then <code>random.choice(Dalc)</code></span>
