<div class="post-text" itemprop="text">
<p>So, I have a problem which I assume must be common:</p>
<p>I'd like to parallelize a script with a <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.pool.multiprocessing.Pool" rel="nofollow noreferrer"><strong><code>multiprocessing.Pool</code></strong></a>, handing inputs to the pool, having it process them in parallel, and receive the outputs in the parent process.</p>
<p><strong><code>apply_async()</code></strong> looks like the best fit for what I want to do. But I can't just give a callback function, since in the end I want to print all the results to a single file. I think handing it a callback which prints to a single filehandle will result in jumbled results (not even sure I can pass a filehandle between processes like that).</p>
<p>So how's the best way to submit inputs to the <code>Pool</code>, then receive the outputs and handle them in the main process? At the moment I'm just collecting the <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.pool.AsyncResult" rel="nofollow noreferrer"><strong><code>AsyncResult</code></strong></a> objects in a list and periodically iterating through it, calling a <strong><code>.get()</code></strong> method on each.</p>
<h3>Update</h3>
<p>I'll clarify a few parameters of my problem in response to comments:</p>
<ol>
<li><p>@martineau and @Juggernaut: By not "jumbled" I mean I'd really like to preserve the order of the input so that the output is in the same order.</p></li>
<li><p>@RolandSmith and @martineau: My main process is just reading inputs from a file, handing them to the pool, and printing the results. I could just call <strong><code>.apply()</code></strong>, but then the main process is waiting for the function to complete before it proceeds. I'm using <strong><code>multiprocessing</code></strong> to reap the benefits of parallelization and have many inputs processed simultaneously.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>As you requested in a comment, here's code showing how to do it with <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map" rel="nofollow noreferrer"><code>Pool.map()</code></a> instead of <code>Pool.async()</code>—which seems like a much better fit for this problem given the need to wait for all the results before further output processing can be done (e.g. it needs to be in the same order as the input).</p>
<p>As you can see it requires <em>substantially less</em> code and doesn't require sorting the results before outputting them (so is probably faster, too).</p>
<pre><code>import multiprocessing as mp
from random import randint
from time import sleep

def my_func(x):
    print('my_func:', x)
    sleep(randint(1, 3))  # Take a varying amount of time to finish.
    return x*x

if __name__ == '__main__':

    input_data = range(10)
    with mp.Pool(10) as pool:
        result_list = pool.map(my_func, input_data)  # Blocks until finished.

    print('result_list:', result_list)  # Will be in same order as input_data.
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>my_func: 3
my_func: 2
my_func: 1
my_func: 0
my_func: 8
my_func: 5
my_func: 7
my_func: 6
my_func: 4
my_func: 9
result_list: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To kind of answer your question, I don't think you can do what you want without a callback. </p>
<p>You want the results computed asynchronously, yet printed in the same order as the inputs. This implies not only having to wait until <em>all</em> of the inputs are processed before printing them, but also some way to know their relative position in the inputs so they can be sorted back into that order before outputting them.</p>
<p>So here's how to do it <strong>with</strong> one. As I previous said, the slightly tricky part is that the results must include something that indicates the corresponding position of the input so the results can be sorted in a similar order before printing. Because of that requirement, the script must wait until <em>all</em> the inputs have been processed.</p>
<p>Note that despite this, you <em>are</em> getting the benefits of parallel processing in the sense that the individual results themselves are being created by concurrent processes.</p>
<pre><code>import multiprocessing as mp
from random import randint
from time import sleep

def my_func(*args):
    print('my_func:', args)
    index, x = args
    sleep(randint(1, 3))  # Take a varying amount of time to finish.
    return index, x*x  # Return result index and value.

if __name__ == '__main__':

    result_list = []

    def errorhandler(exc):
        print('Exception:', exc)

    def log_result(result):
        # This is called whenever my_func() returns a result.
        # result_list is modified only by the main process, not the pool workers.
        result_list.append(result)

    pool = mp.Pool()
    for i in range(10):
        pool.apply_async(my_func, args=(i, i*2), callback=log_result,
                         error_callback=errorhandler)
    pool.close()
    pool.join()  # Wait for all subprocesses to finish.

    print('result_list:', result_list)
    sorted_results = [x[1] for x in sorted(result_list)]
    print('sorted results:', sorted_results)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>my_func: (5, 10)
my_func: (1, 2)
my_func: (4, 8)
my_func: (7, 14)
my_func: (3, 6)
my_func: (9, 18)
my_func: (0, 0)
my_func: (6, 12)
my_func: (2, 4)
my_func: (8, 16)
result_list: [(2, 16), (3, 36), (5, 100), (1, 4), (4, 64), (7, 196), (9, 324), (0, 0), (6, 144), (8, 256)]
sorted results: [0, 4, 16, 36, 64, 100, 144, 196, 256, 324]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I think handing it a callback which prints to a single filehandle will
  result in jumbled results</p>
</blockquote>
<p>The solution is to populate a <a href="https://docs.python.org/3/library/queue.html#queue.Queue" rel="nofollow noreferrer">Queue</a> in your callback with the result and then fetch them later. Queues are thread-safe so you don't have to worry about the jumbled results you're talking about.</p>
<pre><code>from queue import Queue
results = Queue()

def callback(result):
    results.put(result)
</code></pre>
<p>later</p>
<pre><code>item = results.get()
</code></pre>
</div>
<span class="comment-copy">What is your script doing while the <code>Pool</code> is working?</span>
<span class="comment-copy">In other words, if your script has nothing else to do while waiting for the results, then you might as well just use <code>apply()</code> which blocks until the final result is ready.</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/8533318/multiprocessing-pool-when-to-use-apply-apply-async-or-map"><b>multiprocessing.Pool: When to use apply, apply_async or map?</b></a>.</span>
<span class="comment-copy">What exactly do you mean by "jumbled results"?</span>
<span class="comment-copy">@martineau and RolandSmith: thanks for your questions. I added some clarifications to the original question.</span>
<span class="comment-copy">Thanks, I was wondering if using indices to indicate order was the best idea. As for the async + ordered requirements, I'm actually getting that without waiting until the end by chunking the inputs (what I meant by "periodically iterating through" the results list). One of the main things I was wondering is whether there's any better way? Or maybe a tweak to that idea?</span>
<span class="comment-copy">If you used <code>Pool.map()</code> it would keep the results in order, so the passing of indices, unpacking of arguments, and sorting the results would no longer be necessary. It also has an optional <code>chunksize=</code> keyword argument that allows easily "chunking" of the inputs. This would give the equivalent results. Besides allowing the concurrent processing you want to happen, it also reduces the overhead needed to get them, so it ought to make slightly faster overall.</span>
<span class="comment-copy">The are other approaches to doing this concurrently besides using a <code>Pool</code>—such as by using a <code>multiprocessing.Condition</code> variable. In their <a href="https://docs.python.org/3/library/threading.html#condition-objects" rel="nofollow noreferrer">documentation</a> they show an example of a generic producer-consumer situation. Something like that could also be used to do what you want. (No, the documentation link isn't a mistake—<a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Condition" rel="nofollow noreferrer"><code>multiprocessing.Condition</code></a> is just an alias for <code>threading.Condition</code>).</span>
<span class="comment-copy">Yeah, after looking at <code>map_async()</code> again I think it's probably the best way to do this. The end result will be basically the same as what I'm currently doing, but with less management code. If you'd like to add a new answer using it, I'll accept that instead. Otherwise, maybe I'll write one. It'd be nice for someone with the same problem to find.</span>
<span class="comment-copy">Nick: OK...<a href="https://stackoverflow.com/a/46857512/355230">done</a>.</span>
<span class="comment-copy"><code>Queue</code>s maybe thread-safe. but the results can still be "jumbled" in the sense of being out-of-order because of different subprocesses finishing at different times and basically adding their result to it in a random order.</span>
<span class="comment-copy">@martineau Since we don't have the script and the OP mentions "printing to a single file", so the results from different processes are likely to be strings and in this case, you are right. What is your solution? I don't think asynchronous operation is a solution here!</span>
<span class="comment-copy">I agree that the asynchronous processing here probably doesn't need to use <code>apply_async()</code> to do it—and have mentioned it in a comment under the question.</span>
<span class="comment-copy">@martineau I edited my answer right now. what about using <code>Lock</code>?</span>
<span class="comment-copy">Sorry, I really don't understand how using a <code>Lock</code> here would do anything that <code>Queue</code> wouldn't do automatically—or how it would ensure the results were in the proper order (if that even matters, the OP isn't clear about what they mean by "jumbled").</span>
