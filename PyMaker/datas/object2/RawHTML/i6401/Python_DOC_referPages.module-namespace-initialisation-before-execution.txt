<div class="post-text" itemprop="text">
<p>I'm trying to dynamically update code during runtime by reloading modules using <a href="https://docs.python.org/3/library/importlib.html#importlib.reload" rel="nofollow noreferrer">importlib.reload</a>. However, I need a specific module variable to be set before the module's code is executed. I could easily set it as an attribute after reloading but each module would have already executed its code (e.g., defined its default arguments).</p>
<p>A simple example:</p>
<pre><code># module.py

def do():
  try:
    print(a)
  except NameError:
    print('failed')
</code></pre>
<pre><code># main.py

import module

module.do() # prints failed

module.a = 'succeeded'

module.do() # prints succeeded
</code></pre>
<p>The desired pseudocode:</p>
<pre><code>import_module_without_executing_code module

module.initialise(a = 'succeeded')

module.do()
</code></pre>
<p>Is there a way to control module namespace initialisation (like with classes using metaclasses)?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not usually a good idea to use <code>reload</code> other than for interactive debugging.  For example, it can easily create situations where two objects of type <code>module.A</code> are not the same type.</p>
<p>What you want is <a href="https://docs.python.org/2.7/library/functions.html#execfile" rel="nofollow noreferrer"><code>execfile</code></a>.  Pass a globals dictionary (you don't need an explicit locals dictionary) to keep each execution isolated; anything you store in it ahead of time acts exactly like the "pre-set" variables you want.  If you do want to have a "real" module interface change, you can have a wrapper module that calls (or just holds as an attribute) the most recently loaded function from your changing file.</p>
<p>Of course, since you're using Python 3, you'll have to use <a href="https://stackoverflow.com/questions/436198/what-is-an-alternative-to-execfile-in-python-3">one of the replacements for <code>execfile</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Strictly speaking, I don't believe there is a way to do what you're describing in Python natively. However, assuming you own the module you're trying to import, a common approach with Python modules that need some initializing input is to use an <code>init</code> function.</p>
<p>If all you need is some internal variables to be set, like <code>a</code> in you example above, that's easy: just declare some module-global variables and set them in your <code>init</code> function:</p>
<p>Demo: <a href="https://repl.it/MyK0" rel="nofollow noreferrer">https://repl.it/MyK0</a></p>
<p><strong>Module:</strong></p>
<pre><code>## mymodule.py

a = None

def do():
  print(a)


def init(_a):
  global a
  a = _a
</code></pre>
<p><strong>Main:</strong></p>
<pre><code>## main.py

import mymodule

mymodule.init(123)
mymodule.do()

mymodule.init('foo')
mymodule.do()
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>123
foo
</code></pre>
<p>Where things can get trickier is if you need to actually redefine some functions because some dynamic internal something is dependent on the input you give. Here's one solution, borrowed from <a href="https://stackoverflow.com/a/1676860">https://stackoverflow.com/a/1676860</a>. Basically, the idea is to grab a reference to the current module by using the magic variable <code>__name__</code> to index into the system module dictionary, <code>sys.modules</code>, and then define or overwrite the functions that need it. We can define the functions locally as inner functions, then add them to the module:</p>
<p>Demo: <a href="https://repl.it/MyHT/2" rel="nofollow noreferrer">https://repl.it/MyHT/2</a></p>
<p><strong>Module:</strong></p>
<pre><code>## mymodule.py

import sys

def init(a):
  current_module = sys.modules[__name__]
  def _do():
    try:
      print(a)
    except NameError:
      print('failed')
  current_module.do = _do
</code></pre>
</div>
<span class="comment-copy">Can you give any code examples for context? It's tough to assess the sort of situation you're describing without seeing it</span>
<span class="comment-copy">@KenBellows sure, here <a href="https://hastebin.com/epulubaheq.py" rel="nofollow noreferrer">hastebin.com/epulubaheq.py</a></span>
<span class="comment-copy">That example doesn't suffer from <code>a</code>'s assignment being delayed; you just shouldn't call <code>do()</code> before setting it.</span>
<span class="comment-copy">I cleaned up the terminology, integrated your example from your comment, and gave an example of immediate module execution for anyone used to assuming that modules don't do anything at <code>import</code> time.</span>
<span class="comment-copy">Thing is, <code>reload</code> is exactly what I want because I want the aforementioned objects to be different. I want new code to be executed and completely new object created.</span>
<span class="comment-copy">@Exa: You can still do that via the wrapper approach or by installing function objects (but note that they won’t look up global names in the host module).  This is just a way to control what you replace.</span>
<span class="comment-copy">After a bunch of snooping around with importlib, I came to the conclusion that this is the best way I could approach this even if it's not the most convenient since it does not account for package modules.</span>
<span class="comment-copy">@Exa: You can provide <code>__package__</code> in the <code>exec</code> dictionary to enable relative imports.</span>
<span class="comment-copy">I do not own the module that I'm reloading, so expecting it to have a custom initialising method is a nono. It would be convenient if I could directly overwrite the module class's init though.</span>
<span class="comment-copy">@Exa: You don’t own the module, but it changes during execution?</span>
<span class="comment-copy">@DavisHerring Indeed. I am building an API wrapper whereby the developer can pass the aforementioned module so it gets reloaded / updated so as to not restart the whole application. ( I know it sound vague but I'll spare you the details )</span>
<span class="comment-copy">@Exa: Then you can surely require that the module developer <i>not</i> do bad things at import time and provide an initialization function, right?</span>
<span class="comment-copy">You can just use <code>globals()</code> rather than <code>sys.modules</code>.</span>
