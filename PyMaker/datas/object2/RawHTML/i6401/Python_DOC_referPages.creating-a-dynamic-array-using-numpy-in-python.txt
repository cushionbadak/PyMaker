<div class="post-text" itemprop="text">
<p>I want to create a dynamic array without size specification. In that array, I need to insert elements at any point I require. The remaining values in them can be either null or undefined till it gets a value assigned to it.</p>
<p>Ex:</p>
<pre><code>a = np.array([])

np.insert(a, any index value, value)
</code></pre>
<p>So, if I use <code>np.insert(a, 5, 1)</code> I should get the result as:</p>
<pre><code>array([null, null, null, null, null, 1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In MATLAB/Octave you can create and extend a matrix with indexing:</p>
<pre><code>&gt;&gt; a = []
a = [](0x0)
&gt;&gt; a(5) = 1
a =
   0   0   0   0   1
</code></pre>
<p>That is if you index a slot beyond the current end, it expands the matrix, and fills it with 0s.</p>
<p>Javascript (in a Nodejs session) does something similar</p>
<pre><code>&gt; var a = [1,2];
undefined
&gt; a
[ 1, 2 ]
&gt; a[6] = 1
1
&gt; a
[ 1, 2, , , , , 1 ]
&gt; a[3]
undefined
</code></pre>
<p>Leaving the intermediate slots undefined.</p>
<p>A Python dictionary can grow simply by indexing</p>
<pre><code>In [113]: a = {0:1, 1:2}
In [114]: a[5]=1
In [115]: a
Out[115]: {0: 1, 1: 2, 5: 1}
In [116]: a[3]
...
KeyError: 3
In [117]: a.get(3,None)
</code></pre>
<p>Dictionaries also implement a <code>setdefault</code>, and a <code>defaultdict</code>.</p>
<p>A Python <code>list</code> grows by <code>append</code> and <code>extend</code></p>
<pre><code>In [120]: a = [1,2]
In [121]: a.append(3)
In [122]: a
Out[122]: [1, 2, 3]
In [123]: a.extend([0,0,0,1])
In [124]: a
Out[124]: [1, 2, 3, 0, 0, 0, 1]
</code></pre>
<p>Lists also change size with <code>del</code> and sliced assignment, e.g. <code>a[1:2] = [0,0,0,2]</code>.</p>
<p>A numpy array is fixed in size.  To grow one, you have to make a new array by concatenation</p>
<pre><code>In [125]: a = np.arange(3)
In [126]: a
Out[126]: array([0, 1, 2])
In [127]: a = np.concatenate((a, [0,0,1]))
In [128]: a
Out[128]: array([0, 1, 2, 0, 0, 1])
</code></pre>
<p>Array functions like <code>append</code>, <code>stack</code>, <code>delete</code> and <code>insert</code> use some form of <code>concatenate</code> or allocate-n-fill.</p>
<p>In restricted cases an array can be resized (but this method is not used very often):</p>
<pre><code>In [161]: a.resize(10)
In [162]: a[-1]=10
In [163]: a
Out[163]: array([ 0,  1,  2,  0,  0,  1,  0,  0,  0, 10])
</code></pre>
</div>
<span class="comment-copy">You can't do that with numpy</span>
<span class="comment-copy">You're bounded by your machine's memory capacity, thus there's no dynamic data structure as you want. But if you want a dynamic data structure that can increases its size util a certain point (maximum capacity of the memory) that's not what you can do with Numpy arrays.</span>
<span class="comment-copy">You have to create your own data structure for the above implementation. You can initialize your array of some size with <code>None</code>  and implement insert in required fashion. You can extend the array by doubling it if the user is accessing the index outside the limit of your data structure. refer <a href="https://www.happybearsoftware.com/implementing-a-dynamic-array" rel="nofollow noreferrer">this</a>.</span>
<span class="comment-copy">How about using a dictionary?</span>
<span class="comment-copy">You do have the standard <a href="https://docs.python.org/3/library/array.html#module-array" rel="nofollow noreferrer">array</a> lib in Python which, for all intents and purposes, is a dynamic array. As for the specific behavior you gave to <code>insert</code> I doubt it to be valid (in other words, I don't think insert will add nulls automatically). My advice is for you to make your own implementation storing a numpy array (and using its methods to obtain your required behavior).</span>
