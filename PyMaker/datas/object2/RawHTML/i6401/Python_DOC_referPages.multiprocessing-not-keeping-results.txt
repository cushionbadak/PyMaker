<div class="post-text" itemprop="text">
<p>I tried to run the following multiprocessing code:</p>
<pre><code>import multiprocessing

class test(multiprocessing.Process):
    def __init__(self, name):
        multiprocessing.Process.__init__(self)
        self.name = name
        self.finished = False

    def run(self):
        print("executed")
        self.finished = True

test_list = []
test_list.append(test('first'))
test_list.append(test('second'))

for t in test_list:
    t.start()

for t in test_list:
    t.join()

for t in test_list:
    print(t.finished)
</code></pre>
<p>and get the results:</p>
<pre><code>executed
executed
False
False
</code></pre>
<p>The <code>False</code> outputs seem strange. I have set the attribute <code>finished</code> to be <code>True</code> in the method <code>run</code>, and the outputs <code>executed</code> show that the <code>run</code> method has been executed. And, if I add a line <code>print(self.finished)</code> immediately after <code>self.finished=True</code> in the method <code>run</code>, the output would be <code>True</code>. Why does the class attribute <code>finished</code> change after multiprocessing has finished?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>This will allow you to share the finished value between processes.  It uses a <code>multiprocessing.Value</code> to create a shared object using shared memory.</p>
<pre><code>from multiprocessing import Process, Value

class test(Process):
    def __init__(self, name, fin):
        Process.__init__(self)
        self.name = name
        self.finished = fin

    def run(self):
        print("executed")
        self.finished.value = True

test_list = []
test_list.append(test('first', Value('b', False)))
test_list.append(test('second', Value('b', False)))

for t in test_list:
    t.start()

for t in test_list:
    t.join()

for t in test_list:
    print(bool(t.finished.value))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>self.finished = True</code> executes in another process and only changes the variable in that process, but you are printing the value from the main process.  You need variables that are shared.</p>
<pre><code>from multiprocessing import Process,Value
from ctypes import c_bool

class test(Process):
    def __init__(self,name):
        super().__init__()
        self.name = name
        self._finished = Value(c_bool,False)

    def run(self):
        print(self.name,'executed')
        self._finished.value = True

    @property
    def finished(self):
        return self._finished.value

if __name__ == '__main__':
    test_list = [test('first'),
                 test('second')]

    for t in test_list:
        t.start()

    for t in test_list:
        t.join()

    for t in test_list:
        print(t.finished)
</code></pre>
</div>
<span class="comment-copy">t.finish is updated in other process, not in main process.  See: <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">This works, thanks!</span>
