<div class="post-text" itemprop="text">
<p>If we use algorithms with double and float arithmetic, how can we guarantee that the results are the same running it in Python and C, in x86 and x64 Linux and Windows computers and ARM microcontrollers?</p>
<p>We re using an algorithm that uses:</p>
<ul>
<li>double + double </li>
<li>double + float </li>
<li>double exp(double) </li>
<li>float * float</li>
</ul>
<p>On the same computer, compiling it for x86 and x64 MinGW gives different results. The algorithm makes a lot of math so any small error will make a difference in the end.</p>
<p>Right now the ARM mcu implementation gives the same results as the x86, but after seeing this I'm not sure whether is right or not.</p>
<p><strong>EDIT</strong></p>
<p>Precision loss is not a problem in this case, as long as it's the same in all implementations</p>
<p><strong>EDIT 2</strong></p>
<p>I'm finding these links very helpful, some hints are already in the comments:</p>
<ul>
<li><a href="https://www.reddit.com/r/programming/comments/kxbfs/is_floating_point_math_deterministic/" rel="nofollow noreferrer">Is floating point math deterministic?</a> </li>
<li><a href="https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/" rel="nofollow noreferrer">Floating point determinism</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>If we use algorithms with double and float arithmetic, how can we guarantee that the results are the same running it in Python and C, in x86 and x64 Linux and Windows computers and ARM microcontrollers?</p>
</blockquote>
<p>Generally speaking, you cannot do so except possibly by carefully implementing your own FP operations.  If you are using the various languages' standard operators and libraries and the underlying floating-point hardware, then you cannot be ensured of exact reproducability of results across different implementations.</p>
<p>In the first place, there is an issue with the internal representation of floating-point numbers.  C does not specify the representation to be used, and even if all else were equal, that means you cannot rely on the same C program running on different implementations (e.g. x86_64 and ARM) to compute identical results.</p>
<p>In practice, most everyone uses IEEE 754 floating-point formats these days, and CPython uses the underlying C implementation's <code>double</code> type to back its floats.  Even then, however, IEEE allows for a certain small amount of variation between conforming implementations.  Even directives and compilation options that request strict conformance to IEEE specifications cannot fully work around that.</p>
<p>Additionally, you specify that you want to handle both <code>double</code> and <code>float</code>, in both C and Python, but Python doesn't have a native analog of <code>float</code>.  Its native floating-point format (probably) corresponds to a C <code>double</code>.  Operations performed on different floating-point data types necessarily produce different results, even when the operands are numerically equivalent, and the difference can persist across type conversions, such as converting a <code>double</code> result to <code>float</code>.</p>
<p>There are additional details to consider as well, at the (machine) code-generation level, such as whether or when intermediate results are copied out of FPU registers into main memory (which may involve rounding) and the order in which operations are performed.</p>
<blockquote>
<p>We re using an algorithm that uses:</p>
<pre><code>double + double
double + float
double exp(double)
float * float
</code></pre>
</blockquote>
<p>If you want to <em>minimize</em> the differences in computed values, then start by choosing one floating-point data type, and using it everywhere.  For consistency between Python and C implementations, that should be <code>double</code>.</p>
<p>You should also consider disabling any and all optimizations that might change the order in which FP operations are evaluated.  That might be all optimizations whatever.  If you have options available in your C compiler to enforce strict IEEE conformance, then turn those on.</p>
<p>You should furthermore test the equivalency of the <code>exp()</code> functions on all relevant platforms.  You may need to provide your own implementation.</p>
<hr/>
<p>Whatever you do, you should recognize that if your various implementations produce different results despite all being correct in some algorithmic sense, then that's a result in itself.  It tells you something about the true precision of the computation, as implemented.</p>
<p>You must never forget that most computer FP operations produce approximate results, so even if you did manage to get all the implementations to produce identical results, that doesn't mean that those results are necessarily more right in an absolute sense than other nearby FP values. If numeric consistency is a requirement, then you ought to quantify that in terms of a specific precision of the results, implement your algorithm in a way that will deliver that precision, and ignore differences at precision higher than the one chosen.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is hard. Doubles and floats are not formalised in C or C++ standard and its accuracy is up to complier/cpu implementation. For example both float and double are allowed to be same.</p>
<p>From C++17 draft (similar in other papers)
<a href="http://eel.is/c++draft/basic.fundamental#8" rel="nofollow noreferrer">basic.fundamental</a> </p>
<blockquote>
<p>There are three floating-point types: float, double, and long double. The type double provides at least as much precision as float, and the type long double provides at least as much precision as double. The set of values of the type float is a subset of the set of values of the type double; the set of values of the type double is a subset of the set of values of the type long double. The value representation of floating-point types is implementation-defined. [ Note: This document imposes no requirements on the accuracy of floating-point operations; see also [support.limits]. — end note ]</p>
</blockquote>
<p>I don't think there is <a href="https://en.wikipedia.org/wiki/IEEE_754" rel="nofollow noreferrer">IEEE 754</a> mentioned in C or C++ standard.</p>
<p>Python derives this, where floating types are referenced on C implementation, where formalisation is <a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex" rel="nofollow noreferrer">also up to implementaion</a></p>
<blockquote>
<p>There are three distinct numeric types: integers, floating point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating point numbers are <em>usually</em> implemented using double in C; </p>
</blockquote>
</div>
<span class="comment-copy">I think you can only rely on a very specific configuration, since C doesn't mandate a specific implementation of floating point (dunno about python)</span>
<span class="comment-copy">Generally the issue on x86 is that the x87 registers are 80 bit, so, as long as the compiler doesn't spill them, you get higher precision than what would be "correct" for 64-bit double precision arithmetic. Try to use <code>-ffloat-store</code> and see if x86 and x86_64 give the same results.</span>
<span class="comment-copy">If you need the consistency that badly, you will have to give up on native FP implementations and use some homebrew/thirdparty portable libraries. And I would recommend fixed point...</span>
<span class="comment-copy">Make all FP variables <code>volatile</code> and never use a compound equation: <code>sum = a+b*c</code> --&gt; <code>product = b*c; y = a + product;</code>  Insure rounding modes match and disable FP optimizations.  For math libraries - roll your own. This will significantly reduce variation and reduce performance.</span>
<span class="comment-copy">Could it be down to differences in rounding defaults, or compiler “optimizations”? A good way to test your algorithm for instabilities is to rerun it with different rounding settings. In C99 you have <code>fenv</code> for controlling this, for Python try my <a href="https://github.com/ldo/pyfenv/" rel="nofollow noreferrer">pyfenv</a> module.</span>
<span class="comment-copy">To add "In practice, most everyone uses IEEE 754 floating-point formats these days" except for  various corners of the spec that were hard to implement or mis-implemented.  Many strive for adherence yet do not make it.  Example: I was disappointed on the weak/broken  implementations of <a href="https://stackoverflow.com/q/42166563/2410359"><code>fma()</code></a></span>
<span class="comment-copy">This is very informative and interesting, but it does not really answer the question.</span>
