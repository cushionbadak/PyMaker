<div class="post-text" itemprop="text">
<p>How do i reference a variable from an instance in a dict?     </p>
<p>this code:</p>
<pre><code>class Gold():
    def __init__(self):
        self.amount = 10

class Cheese():
    def __init__(self, gold):
        self.gold = gold
        self.wallet = {'gold' : self.gold.amount}
        self.charge ={'gold' : 10}

    def subtract(self):
        for cat, cost in self.charge.iteritems():
            if self.wallet[cat] &gt;= cost:
                self.wallet[cat] -= cost

gold = Gold()
cheese = Cheese(gold)
cheese.subtract()
print 'gold amount =', cheese.gold.amount, 'wallet =', cheese.wallet
</code></pre>
<p>yields:</p>
<pre><code>gold amount = 10 wallet = {'gold': 0}
</code></pre>
<p>and not</p>
<pre><code>gold amount = 0 wallet = {'gold': 0}
</code></pre>
<p>in the actual code i dont want a whole list of 'if' statements. so i couple a dict with all the costs (charge) in this example to a dict with all the actual values so i dont have to do</p>
<pre><code>if cost == 'gold':
    pass
if cost == 'action points':
    pass
</code></pre>
<p>etc</p>
<p>any tips on how to do this?
in the end the quistion is:</p>
<pre><code>a = 1
b = a
</code></pre>
<p>is there a way to update both a and b (b += 1 only updates b to 2)</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python:</p>
<ul>
<li>all variables are references </li>
<li>integers and strings are immutable</li>
</ul>
<p>So when you do:</p>
<pre><code>&gt;&gt;&gt; a = 1  # a points to 1
&gt;&gt;&gt; b = a  # b points to 1
&gt;&gt;&gt; b = 10   # b now points to 10, a still points to 1 and 1 is unchanged.
&gt;&gt;&gt; b
10

&gt;&gt;&gt; a
1
</code></pre>
<p>If you use a mutable data type, then it works:</p>
<pre><code>&gt;&gt;&gt; a = []
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b.append(10)
&gt;&gt;&gt; b
[10]

&gt;&gt;&gt; a
[10]

&gt;&gt;&gt; a[0] = 20
&gt;&gt;&gt; b
[20]
</code></pre>
<p>Perhaps you can create a generic container:</p>
<pre><code>class GenericContainer(object):
    def __init__(self, **kwargs):
        self._keys = set()
        for k, v in kwargs.items():
            if k in ('inventory', 'charge'):
                raise ValueError('Unable to override method {}'.format(k))
            setattr(self, k, v)
            self._keys.add(k)

    def charge(self, **kwargs):
        for k, v in kwargs.items():
            if k in ('inventory', 'charge'):
                raise ValueError('Unable to override method {}'.format(k))
            if v &lt; 0 and getattr(self, k, 0) &lt; abs(v):
                raise ValueError("You don't have enough {}".format(k))
            setattr(self, k, getattr(self, k, 0) + v)
            self._keys.add(k)
        return self

    def inventory(self):
        return {k:getattr(self, k) for k in self._keys}

    def __repr__(self):
        return str(self.inventory())
</code></pre>
<p>Then your wallet can be an instance of GenericContainer:</p>
<pre><code>&gt;&gt;&gt; wallet = GenericContainer(gold=10, silver=5)
&gt;&gt;&gt; wallet
{'gold': 10, 'silver': 5}

&gt;&gt;&gt; wallet.charge(gold=-5, silver=5)
{'gold': 5, 'silver': 10}

&gt;&gt;&gt; wallet.charge(gold=-20)
ValueError: You don't have enough gold

&gt;&gt;&gt; wallet.gold
5
</code></pre>
<p>You can set and/or retrieve the attributes directly:</p>
<pre><code>&gt;&gt;&gt; wallet.gold
5

&gt;&gt;&gt; wallet.gold += 10
&gt;&gt;&gt; wallet.gold
15

&gt;&gt;&gt; wallet
{'gold': 15, 'silver': 10}
</code></pre>
<p>You can get the attribute by name from the inventory or using <code>getattr</code>:</p>
<pre><code>&gt;&gt;&gt; wallet.inventory().get('gold', 0)
15

&gt;&gt;&gt; getattr(wallet, 'gold')
15
</code></pre>
<p>You can set it by name using dict of parameter:value or <code>setattr</code>:</p>
<pre><code>&gt;&gt;&gt; wallet.charge(**{'gold': -10})
{'gold': 5, 'silver': 10}

&gt;&gt;&gt; setattr(wallet, 'gold', 20)
&gt;&gt;&gt; wallet.gold
20
</code></pre>
<p>Looking at the result, I see why in Python I often use just a dictionary instead of creating a class - although I do miss the Javascript object syntax where you can access properties both using either <code>foo.bar</code> or <code>foo["bar"]</code>.</p>
<p>In Python, the builtin data structures are very powerful and Python developers tend to use a "we are all consenting adults" approach where you just pass data around without caring too much about attribute protection. Probably I would end up doing just this:</p>
<pre><code>&gt;&gt;&gt; wallet = {'gold': 10, 'silver': 15}
</code></pre>
<p>And instead of using a <code>charge(gold=10)</code> method:</p>
<pre><code>&gt;&gt;&gt; wallet['gold'] += 10
</code></pre>
<p>It takes time for this "it is just data" approach to sink but after that you seldom miss the more bureaucratic OO idioms so common in languages like Java or C++ specially for small projects/teams.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems like the easiest way to do this is to change <code>wallet</code> from being an attribute to being a <a href="https://docs.python.org/3/library/functions.html?highlight=property#property" rel="nofollow noreferrer"><code>property</code></a>.</p>
<pre><code>class Cheese():
    def __init__(self, gold):
        self.gold = gold
        self.charge ={'gold' : 10}

    @property
    def wallet(self):
        return {'gold': self.gold.amount)

    def subtract(self):
        for cat, cost in self.charge.iteritems():
            if self.wallet[cat] &gt;= cost:
                self.wallet[cat] -= cost
</code></pre>
<p>Properties are methods that <em>act</em> like attributes. They're calculated on-call every time rather than calculated when the object is created and never again. You use them the same way, though, so:</p>
<pre><code>&gt;&gt;&gt; print 'gold amount =', cheese.gold.amount, 'wallet =', cheese.wallet
gold amount = 0 wallet = {'gold': 0}
</code></pre>
</div>
<span class="comment-copy">Because the value in the wallet <i>isn't</i> referencing the Gold instance, and integers are immutable.</span>
<span class="comment-copy">pythontutor.com might help you to understand this. You don't reference self.gold.amount in your wallet dict. It is copied in there.</span>
<span class="comment-copy">Thats a very helpful website. Now i know <i>why</i> it doesnt work. maybe any pointers in how i <i>do</i> reference the self.gold.amount? thx a lot!</span>
<span class="comment-copy">@UpSampler no, it isn't copied. <code>wallet['gold']</code> and <code>self.gold.amount</code> both reference the exact same object, but <i>that object is immutable</i>.</span>
<span class="comment-copy">@LennartWijers I got it know. You were right, the object is immutable, but the content of <code>wallet['gold']</code> can change. It found it here: <a href="https://stackoverflow.com/questions/8056130/immutable-vs-mutable-types" title="immutable vs mutable types">stackoverflow.com/questions/8056130/immutable-vs-mutable-types</a></span>
<span class="comment-copy">thx for the answer! think im going to use the container class. But the question is still there i think,( see edit). but thx for taking the time and being helpfull!</span>
<span class="comment-copy">took me a while to comprehend your answer but it solved the problem. thx!</span>
<span class="comment-copy">though I do wonder why <code>Gold</code> needs its own class...</span>
<span class="comment-copy">the code you wrote gives me: gold amount = 10 wallet = {'gold': 10}. will start reading up on properties though</span>
<span class="comment-copy">was an example. Actual code has way more lines and uncomprehensible names</span>
<span class="comment-copy">@LennartWijers ah yes, sorry, you'll have to modify <code>self.gold</code> not <code>self.wallet</code> in <code>subtract</code></span>
