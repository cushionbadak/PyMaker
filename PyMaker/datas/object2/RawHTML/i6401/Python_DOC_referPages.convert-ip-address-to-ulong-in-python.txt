<div class="post-text" itemprop="text">
<p>How would I use python to convert an IP address that comes as a <code>str</code> to a decimal number and vice versa? </p>
<p>For example, for the IP <code>186.99.109.000 &lt;type'str'&gt;</code>, I would like to have a decimal or binary form that is easy to store in a database, and then retrieve it.</p>
</div>
<div class="post-text" itemprop="text">
<p>converting an IP string to long integer:</p>
<pre><code>import socket, struct

def ip2long(ip):
    """
    Convert an IP string to long
    """
    packedIP = socket.inet_aton(ip)
    return struct.unpack("!L", packedIP)[0]
</code></pre>
<p>the other way around:</p>
<pre><code>&gt;&gt;&gt; socket.inet_ntoa(struct.pack('!L', 2130706433))
'127.0.0.1'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a summary of all options as of 2017-06. All modules are either part of the standard library or can be installed via <code>pip install</code>.</p>
<h2>ipaddress module</h2>
<p>Module ipaddress (<a href="https://docs.python.org/3/library/ipaddress.html" rel="noreferrer">doc</a>) is part of the standard library since v3.3 but it's also available as an external module for python v2.6,v2.7.</p>
<pre><code>&gt;&gt;&gt; import ipaddress
&gt;&gt;&gt; int(ipaddress.ip_address('1.2.3.4'))
16909060
&gt;&gt;&gt; ipaddress.ip_address(16909060).__str__()
'1.2.3.4'
&gt;&gt;&gt; int(ipaddress.ip_address(u'1000:2000:3000:4000:5000:6000:7000:8000'))
21268296984521553528558659310639415296L
&gt;&gt;&gt; ipaddress.ip_address(21268296984521553528558659310639415296L).__str__()
u'1000:2000:3000:4000:5000:6000:7000:8000'
</code></pre>
<h2>No module import (IPv4 only)</h2>
<p>Nothing to import but works only for IPv4 and the code is longer than any other option.</p>
<pre><code>&gt;&gt;&gt; ipstr = '1.2.3.4'
&gt;&gt;&gt; parts = ipstr.split('.')
&gt;&gt;&gt; (int(parts[0]) &lt;&lt; 24) + (int(parts[1]) &lt;&lt; 16) + \
          (int(parts[2]) &lt;&lt; 8) + int(parts[3])
16909060
&gt;&gt;&gt; ipint = 16909060
&gt;&gt;&gt; '.'.join([str(ipint &gt;&gt; (i &lt;&lt; 3) &amp; 0xFF)
          for i in range(4)[::-1]])
'1.2.3.4'
</code></pre>
<h2>Module netaddr</h2>
<p>netaddr is an external module but is very stable and available since Python 2.5 (<a href="http://pythonhosted.org/netaddr/" rel="noreferrer">doc</a>)</p>
<pre><code>&gt;&gt;&gt; import netaddr
&gt;&gt;&gt; int(netaddr.IPAddress('1.2.3.4'))
16909060
&gt;&gt;&gt; str(netaddr.IPAddress(16909060))
'1.2.3.4'
&gt;&gt;&gt; int(netaddr.IPAddress(u'1000:2000:3000:4000:5000:6000:7000:8000'))
21268296984521553528558659310639415296L
&gt;&gt;&gt; str(netaddr.IPAddress(21268296984521553528558659310639415296L))
'1000:2000:3000:4000:5000:6000:7000:8000'
</code></pre>
<h2>Modules socket and struct (ipv4 only)</h2>
<p>Both modules are part of the standard library, the code is short, a bit cryptic and IPv4 only.</p>
<pre><code>&gt;&gt;&gt; import socket, struct
&gt;&gt;&gt; ipstr = '1.2.3.4'
&gt;&gt;&gt; struct.unpack("!L", socket.inet_aton(ipstr))[0]
16909060
&gt;&gt;&gt; ipint=16909060
&gt;&gt;&gt; socket.inet_ntoa(struct.pack('!L', ipint))
'1.2.3.4'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use class <code>IPAddress</code> in module <code>netaddr</code>.</p>
<p>ipv4 <code>str</code> -&gt; <code>int</code>:</p>
<pre><code>print int(netaddr.IPAddress('192.168.4.54'))
# OUTPUT: 3232236598
</code></pre>
<p>ipv4 <code>int</code> -&gt; <code>str</code>:</p>
<pre><code>print str(netaddr.IPAddress(3232236598))
# OUTPUT: 192.168.4.54
</code></pre>
<p>ipv6 <code>str</code> -&gt; <code>int</code>:</p>
<pre><code>print int(netaddr.IPAddress('2001:0db8:0000:0000:0000:ff00:0042:8329'))
# OUTPUT: 42540766411282592856904265327123268393
</code></pre>
<p>ipv6 <code>int</code> -&gt; <code>str</code>:</p>
<pre><code>print str(netaddr.IPAddress(42540766411282592856904265327123268393))
# OUTPUT: 2001:db8::ff00:42:8329
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.3 there is the ipaddress module that does exactly this job among others: <a href="https://docs.python.org/3/library/ipaddress.html" rel="noreferrer">https://docs.python.org/3/library/ipaddress.html</a>. Backports for Python 2.x are also available on PyPI.</p>
<p>Example usage:</p>
<pre><code>import ipaddress

ip_in_int = int(ipaddress.ip_address('192.168.1.1'))
ip_in_hex = hex(ipaddress.ip_address('192.168.1.1'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Here's One Line Answers:</h2>
<pre><code>import socket, struct

def ip2long_1(ip):
    return struct.unpack("!L", socket.inet_aton(ip))[0]
</code></pre>
<hr/>
<pre><code>def ip2long_2(ip):
    return long("".join(["{0:08b}".format(int(num)) for num in ip.split('.')]), 2)
</code></pre>
<hr/>
<pre><code>def ip2long_3(ip):
    return long("".join(["{0:08b}".format(num) for num in map(int, ip.split('.'))]), 2)
</code></pre>
<hr/>
<h2>Execution Times:</h2>
<p>ip2long_1 =&gt; 0.0527065660363234 ( The Best ) <br/>
ip2long_2 =&gt; 0.577211893924598 <br/>
ip2long_3 =&gt; 0.5552745958088666</p>
</div>
<div class="post-text" itemprop="text">
<p>One line solution without any module import:</p>
<pre><code>ip2int = lambda ip: reduce(lambda a, b: (a &lt;&lt; 8) + b, map(int, ip.split('.')), 0)
int2ip = lambda n: '.'.join([str(n &gt;&gt; (i &lt;&lt; 3) &amp; 0xFF) for i in range(0, 4)[::-1]])
</code></pre>
<p>Example:</p>
<pre><code>In [3]: ip2int('121.248.220.85')
Out[3]: 2046352469

In [4]: int2ip(2046352469)
Out[4]: '121.248.220.85'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Convert IP to integer :</p>
<pre><code>python -c "print sum( [int(i)*2**(8*j) for  i,j in zip( '10.20.30.40'.split('.'), [3,2,1,0]) ] )"
</code></pre>
<p>Convert Interger to IP :</p>
<pre><code>python -c "print '.'.join( [ str((169090600 &gt;&gt; 8*i) % 256)  for i in [3,2,1,0] ])" 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def ip2Hex(ip = None):
    '''Returns IP in Int format from Octet form'''
    #verifyFormat(ip)
    digits=ip.split('.')
    numericIp=0
    count=0
    for num in reversed(digits):
        print "%d " % int(num)
        numericIp += int(num) * 256 **(count)
        count +=1
    print "Numeric IP:",numericIp
    print "Numeric IP Hex:",hex(numericIp)

ip2Hex('192.168.192.14')
ip2Hex('1.1.1.1')
ip2Hex('1.0.0.0')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one</p>
<pre><code>def ipv4_to_int(ip):
    octets = ip.split('.')
    count = 0
    for i, octet in enumerate(octets):
        count += int(octet) &lt;&lt; 8*(len(octets)-(i+1))
    return count
</code></pre>
</div>
<span class="comment-copy"><a href="http://code.google.com/p/ipaddr-py/" rel="nofollow noreferrer">code.google.com/p/ipaddr-py</a></span>
<span class="comment-copy">Did you try google? <a href="http://www.google.co.uk/search?q=python+ip+convert" rel="nofollow noreferrer">python ip convert</a></span>
<span class="comment-copy">@PeterWood nowadays i just googled for it and the first result was this answer xD</span>
<span class="comment-copy">i'd clearly use bigindian's <code>&gt;</code> instead of <code>!</code>.</span>
<span class="comment-copy">love this line from the python documentation <code>The form '!' is available for those poor souls who claim they canâ€™t remember whether network byte order is big-endian or little-endian.</code></span>
<span class="comment-copy">This worked, thanks.</span>
<span class="comment-copy">No need to use stuff like <code>2**16</code>, just use <code>&lt;&lt; 16</code> instead.</span>
<span class="comment-copy">Thanks for the tip interestinglythere. I do like this notation (it reminds me of my first 6502 assembler programs).</span>
<span class="comment-copy">User <a href="https://stackoverflow.com/users/1697876">brisebom</a> tried to post this comment as an answer: <i>"Here is a simple benchmark test for most of the examples in @ndemou's answer. If you are already using the <code>ipaddress</code> module for your addresses, the IP int is precalculated so it is the fastest method. Otherwise, socket/struct is the fastest method by a quite a lot. <a href="https://ideone.com/cZU9Ar" rel="nofollow noreferrer">ideone.com/cZU9Ar</a>"</i></span>
<span class="comment-copy">A kind soul did some benchmarks here <a href="https://ideone.com/cZU9Ar" rel="nofollow noreferrer">ideone.com/cZU9Ar</a> -- thanks to @brisebom and artjom-b for letting us know (I only repeat it here because the link in Artjom's comment got corrupted)</span>
<span class="comment-copy">Thanks! This is very universal</span>
<span class="comment-copy">Very nice but putting the output before the input confuses me</span>
<span class="comment-copy">@ndemou Thanks for your mention, I updated it.</span>
<span class="comment-copy">For the hex(ipaddress.ip_address('192.168.1.1')), got error. 'IPv4Address' object cannot be interpreted as an integer. Seems to use hex(int(...)). It is good to know the new ipaddress module.</span>
<span class="comment-copy">Last line should be <code>ipaddress.ip_address(3232235777).__str__()</code>. This really returns <code>'192.168.1.1'</code> which is what the question asks for</span>
