<div class="post-text" itemprop="text">
<p>Is it a way in Python 3 to binary search in sorted list of lists?
<br/> Let's assume I have a list of lists:</p>
<pre><code>list = [['A', 'B', 3], ['C', 'D', 1], ['E', 'F', 2]]
</code></pre>
<p>I've sorted it by 3d element in inner list with:</p>
<pre><code>list = sorted(list , key=itemgetter(2))
</code></pre>
<p>and now list is</p>
<pre><code>[['C', 'D', 1], ['E', 'F', 2], ['A', 'B', 3]]
</code></pre>
<p>And now how can I search in this sorted list with binary search (O(log(n)) time complexity) using element from inner list by which sorting was done?
Like</p>
<pre><code>findBy(list, index_of_inner_list, value_of_inner_list_to_find)
</code></pre>
<p>Outer list is huge. Inner lists have len 50. And I need to make many queries to extract some elements from outer list based on condition related to inner lists. I was thinking about <code>bisect</code> but inner arrays would be a problem for it I think. </p>
</div>
<div class="post-text" itemprop="text">
<p>I think bisection algorithm is simply enough. </p>
<p>Python docs told us that</p>
<p><a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer">https://docs.python.org/3/library/bisect.html</a></p>
<blockquote>
<p>This module provides support for maintaining a list in sorted order
  without having to sort the list after each insertion. For long lists
  of items with expensive comparison operations, this can be an
  improvement over the more common approach. The module is called bisect
  because it uses a basic bisection algorithm to do its work. The source
  code may be most useful as a working example of the algorithm (the
  boundary conditions are already right!).</p>
</blockquote>
</div>
<span class="comment-copy">Have you read this: <a href="https://stackoverflow.com/questions/42146482/using-bisect-on-list-of-tuples-but-compare-using-first-value-only" title="using bisect on list of tuples but compare using first value only">stackoverflow.com/questions/42146482/â€¦</a> where there are several suggestions for bisect implementations with an arbitrary key function.</span>
<span class="comment-copy">Look at the last example on the <a href="https://docs.python.org/3.6/library/bisect.html#other-examples" rel="nofollow noreferrer">bisect</a> doc page. Does that look like what you're going for?</span>
<span class="comment-copy">@glibdud That example constructs a new list from the keys which destroys the <code>O(log_N)</code> performance of bisect which the OP explicitly asks for.</span>
<span class="comment-copy">@glibdud Yes, I've read that and I was wondering is it a better way in Python for things like I need. Something like Comparator in Java.</span>
<span class="comment-copy">Can you show how this relates to the question? Specifically, sorting elements by some method other than the default sorting method?</span>
