<div class="post-text" itemprop="text">
<p>Although pylint raises a warning on <code>enum.Enum(value=..., names=...)</code>, I see from the enum doc that one could programmatically create an Enum like the following</p>
<pre><code>import re
import enum
import termios

def termios_baud_rates():
    regexp = r"(?:^|,)B(?P&lt;rate&gt;\d+)"
    rates = sorted(map(int, re.findall(regexp, ",".join(dir(termios)))))
    return {"B{:d}".format(r): r for r in rates}

BAUD_RATES = enum.Enum("BAUD_RATES", termios_baud_rates())
</code></pre>
<p>But I'd also like to add methods:</p>
<pre><code>@classmethod
def valid_rate(cls, value):
    return (any(value == item.value for item in cls))
</code></pre>
<p>I think this should involve overloading metaclass <code>__prepare__(mcls, names, bases)</code> to augment bases with the names dict, but apparently bases is not how the Enum attributes are created. Anyone have any tips?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is quite simple using the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer"><code>aenum library</code></a><sup>1</sup>:</p>
<pre><code>import re
import aenum
import termios

class BaudRate(aenum.Enum):
    _ignore_ = 'cls regexp rates'

    cls = vars()
    regexp = r"(?:^|,)B(?P&lt;rate&gt;\d+)"
    rates = sorted(map(int, re.findall(regexp, ",".join(dir(termios)))))
    for value in rates:
        cls['B%d' % value] = value

    @classmethod
    def valid_rate(cls, value):
        return (any(value == item.value for item in cls))
</code></pre>
<p>The <code>_ignore_</code> tells <code>aenum</code> what to, um, <em>ignore</em> and, in fact, anything in <code>_ignore_</code> is removed from the final <code>Enum</code> class.</p>
<p>Due to a <a href="https://bugs.python.org/issue31801" rel="nofollow noreferrer">bug in Python's Enum</a> this doesn't yet work unless you use <code>aenum</code>.</p>
<hr/>
<p><sup>1</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="nofollow noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer">Advanced Enumeration (<code>aenum</code>)</a>  library.</p>
</div>
<div class="post-text" itemprop="text">
<p>What if you create a new subclass of <code>Enum</code> instead?</p>
<pre><code>from enum import Enum

class ValidEnum(Enum):

  @classmethod
  def valid_rate(cls, value):
    return (any(value == item.value for item in cls))
</code></pre>
<p>Or, depending on the use case, you could create another class that wraps the enum.</p>
<p>Either should work as follows:</p>
<pre><code>In [3]: BAUD_RATES = ValidEnum("BAUD_RATES", termios_baud_rates())

In [7]: BAUD_RATES.valid_rate(0)
Out[7]: True

In [11]: BAUD_RATES.valid_rate(213)
Out[11]: False
</code></pre>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <code>nonlocal</code> to avoid needing the <code>aenum</code> package:</p>
<pre><code>import re
import enum
import termios


regexp = r"(?:^|,)B(?P&lt;rate&gt;\d+)"
rates = sorted(map(int, re.findall(regexp, ",".join(dir(termios)))))

value = None

class BaudRate(enum.Enum):    
    nonlocal value
    for value in rates:
        locals()['B%d' % value] = value

    @classmethod
    def valid_rate(cls, value):
        return (any(value == item.value for item in cls))
</code></pre>
</div>
<span class="comment-copy">Subclassing enums: <a href="https://docs.python.org/3/library/enum.html#restricted-subclassing-of-enumerations" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">thanks this is the sort of thing I'm looking for. If you have any good reference links or gists on how this works I'd appreciate it; I'm trying to get a better understanding of how metaclass works under the hood and its applicable to my current project (ex. constructing a standardized interface / protocol class with OS specific code inserted during instantiation)</span>
<span class="comment-copy">@Icary  thanks for the example; I was hoping just to override either <code>__prepare__</code> or <code>__new__</code> in metaclass because this is the sort of thing that would call for them, i.e. changing how the Enum would be constructed before reaching class <b>new</b> or <b>init</b></span>
<span class="comment-copy">Makes sense! Wasn't sure how entry-level the question was, but sounds like it was a bit more complex than a simple subclass, in which case the <code>aenum</code> library looks like the way to go.</span>
