<div class="post-text" itemprop="text">
<p>I am trying to read a csv file into a dictionary using this code</p>
<pre><code>import csv

with open('Trials/readtest.csv', mode='r') as infile:
    reader = csv.reader(infile)
    with open('Trials/readtest_2.csv', mode='w') as outfile:
        writer = csv.writer(outfile)
        mydict = {rows[0]: type(rows[1]) for rows in reader}
    print(mydict)
</code></pre>
<p>the csv file contains this</p>
<pre><code>option 1    1
option 2    True
option 3    False
option 4    no_cursor
option 5    5
option 6    6
option 7    7
option 8    8
option 9    9
option 10   10
option 11   11
option 12   12
option 13   13
</code></pre>
<p>I am trying to create the dictionary so that each value from the first column indexes a value of a certain type in the second column. e.g, 1 would be an integer, True would be a boolean, False would be boolean, no_cursor would be a string, etc.</p>
<p>However, when I run my code, all the values saved into the dictionary is automatically converted into a string.</p>
<p>Any help on this would be greatly appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want more fine-grained control over how to parse the strings to types, for example if you had some custom objects, you'll need a different approach, but you can use <code>ast.literal_eval</code> to cover all the basic builtin types. Basically it does <code>eval</code> but safely, converting an arbitary string into an appropriate type. Read more here: <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">https://docs.python.org/3/library/ast.html#ast.literal_eval</a></p>
<pre><code>import csv
import ast

with open('Trials/readtest.csv', mode='r') as infile:
    reader = csv.reader(infile)
    with open('Trials/readtest_2.csv', mode='w') as outfile:
        writer = csv.writer(outfile)
        mydict = {rows[0]: ast.literal_eval(rows[1]) for rows in reader}
    print(mydict)
</code></pre>
</div>
<span class="comment-copy">Thank you that helped immensely! :) but it seems the literal_eval() function tries to evaluate the indexes that are literally supposed to be strings and returns an exception "Value Error: malformed string"</span>
<span class="comment-copy">It's because it expects the argument to be a valid literal, and for string literals they must be surrounded by quotes. You'd need to either create your data so that string values have quotes around them, or as a workaround you could catch the exception and make the assumption that it's supposed to be a string.</span>
