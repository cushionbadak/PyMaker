<div class="post-text" itemprop="text">
<p>I have the following function, that aims at returning the best average grade.
It takes inputs like: </p>
<pre><code>scores = [["bob",100],["bob",100],["toto",100],["frank",100]]
</code></pre>
<p>How can I improve it so it handles large inputs within a set period of time? That is to say how to have hte better run-time complexity?</p>
<p>EDIT: it should handle negative scores and empty scores.</p>
<pre><code>def maxavg(scores):
    avs=[]
    namelist=[]
    for i in range(0,len(scores)):
        name = scores[i][0]
        if name not in namelist:
            namelist.append(name)
            note = scores[i][1]
            nbnotes = 1
            for j in range(i+1,len(scores)):
                if scores[j][0]==name:
                    nbnotes+=1
                    note+=scores[j][1]
            avs.append(note/nbnotes)
    return max(avs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without going into the<code>numpy</code> <code>array</code> or <code>pandas</code> <code>dataframe</code> shown by @galaxyman, you're missing many basic Python stuff. You need to get acquainted with things like <code>dictionaries</code>. Here's an example using the <code>defaultdict</code> that initializes to 0 when assigning to a non-existing key:</p>
<pre><code>from collections import defaultdict
def maxavg(scores);
    scoredict = defaultdict(int)
    namecount = defaultdict(int)
    for name,grade in scores:
         scoredict[name] += grade
         namecount[name] += 1
    retrun max((scoredict[name]/namecount[name] for name in scoredict))
</code></pre>
<p>A regular dictionary, <code>mydict = {}</code> would fail on the first attempt to assign <code>mydict['somename'] += grade</code>, since <code>+=</code> assumes an existing key. the <code>defaultdict</code> construct surrounds such problems with a <code>try</code> <code>except</code> block, to make first initialization. I suggest you google all these things. GL. That final line is a generator, though you should check list comprehensions as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>It may fast than your code and less lines of code </p>
<pre><code>scores = [["bob",100],["bob",90],["toto",70],["frank",100]]
df = pd.DataFrame(scores,columns=['name', 'scores'])
print df.groupby('name').mean().idxmax()
</code></pre>
<p>output:</p>
<pre><code>scores    frank
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How to improve it? Glad you asked. Mostly it's a matter of using appropriate data types, which let you avoid O(N) operations within a loop. That way you avoid accidentally writing quadratic O(N^2) code. Here, it means moving from array / list to dict.</p>
<p>The <code>for i in range(0,len(scores))</code> loop is very nice Fortran, but we have an opportunity to use python idioms instead:</p>
<pre><code>for name, score in scores:
</code></pre>
<p>The <code>if name not in namelist</code> test hides a linear scan, O(N), within your loop. By using a dict we can obviate that. Also, the test for "does this name already exist?" can be buried in a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a>:</p>
<pre><code>total = collections.defaultdict(int)
n = collections.defaultdict(int)
for name, score in scores:
    total[name] += score
    n[name] += 1
avg = {name, total[name] / n[name]
       for name in scores}
return max(avg.values())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can improve your runtime by casting your variable types using cython. 
<a href="http://cython.readthedocs.io/en/latest/src/quickstart/cythonize.html" rel="nofollow noreferrer">This link</a> is a good introduction. </p>
<p>Because Python is dynamically typed, every time a loop iterates over a variable it has to determine what type of variable is returned (int, string, etc...). Using cython to set the variable types can improve speed dramatically.  </p>
</div>
<span class="comment-copy">1. Use a dictionary. 2. Do everything in one pass through the scores.</span>
<span class="comment-copy">of course it's the way today :)</span>
<span class="comment-copy">Nothing accidental about this one, there's a loop within a loop.</span>
<span class="comment-copy">Removing interpreter overhead from a quadratic algorithm still leaves you with a slow (quadratic) algorithm.</span>
<span class="comment-copy">@J_H true, I would recommend OP to follow advice of other answers to improve algorithm. But if size of input is expected to scale to extremely large and iteration is necessary, then casting variables in C will lead to vast improvements in performance.</span>
