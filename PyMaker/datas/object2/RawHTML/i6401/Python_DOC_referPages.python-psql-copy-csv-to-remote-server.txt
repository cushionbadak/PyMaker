<div class="post-text" itemprop="text">
<p>I am attempting to copy a csv (which has a header and quote character ") with python 3.6 to a table on a remote postgres 10 server. It is a large CSV (2.5M rows, 800MB) and while I previously imported it into a dataframe and then used dataframe.to_sql, this was very memory intensive so I switched to using COPY.</p>
<p>Using COPY with psycopg2 or sqlalchemy would work fine but the remote server does not have access to the local file system.</p>
<p>Using psql in the terminal I have successfully run the query below to populate the table. I don't think using \copy is possible with psycopg2 or sqlalchemy.</p>
<pre><code>\copy table (col1, col2) FROM file_location CSV HEADER QUOTE '"' NULL ''
</code></pre>
<p>However when I try to use a one line psql -c command like below, it does not work and I get the error: </p>
<p>ERROR: COPY quote must be a single one-byte character.</p>
<pre><code>psql -U user -h ip -d db -w pw -c "\copy table (col1, col2) FROM file_location CSV HEADER QUOTE '"' NULL ''"
</code></pre>
<p>Could you tell me why this is the case? </p>
<p>This one-line -c psql statement would be easier to implement with the subprocess module in python than having to open a terminal and execute a command which I'm not sure how to do. If you could suggest a workaround or different methodology that would be great.</p>
<p>======
Per Andrew's suggestion to escape the quote character this worked on the command line. However when implementing it in python like below, a new error comes up:</p>
<p>/bin/sh: -c: line 0: unexpected EOF while looking for matching `''</p>
<p>/bin/sh: -c: line 1: syntax error: unexpected end of file</p>
<pre><code>"\"\copy table (col1, col2) FROM file_location CSV HEADER QUOTE '\"' NULL ''\""
cmd = f'psql -U {user} -h {ip} -d {db} -w {pw} -c {copy_statement}'
subprocess.call(cmd, shell=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try not to use <code>shell=True</code> if you can avoid it. better to tokenize the command yourself to help sh.</p>
<pre><code>subprocess.call(["psql", "-U", "{user}", "-h", "{ip}", "-d", "{db}", "-w", "{pw}", "-c", "{copy statement}"])
</code></pre>
<p>In this case then your copy statement could be as it is passed to psql verbatim, because there are no <em>shell</em> quoting issues to take into account. (N.B. still have to quote this for python, so the string would remain as is).</p>
<hr/>
<p>If you still want to use <code>shell=True</code> then you have to escape the string literal for both python <em>and</em> shell</p>
<pre><code>"\"\copy table (col1, col2) FROM file_location CSV HEADER QUOTE '\\\"' NULL ''\""
</code></pre>
<p>will create a string in python which will be</p>
<pre><code>"\copy table (col1, col2) FROM file_location CSV HEADER QUOTE '\"' NULL ''\"
</code></pre>
<p>Which is what we found out we needed on our shell in the first place!</p>
<hr/>
<p><strong>Edit</strong> (clarifying something from the comments)<strong>:</strong></p>
<p><code>subprocess.call</code>, when not using <code>shell=True</code>, takes an iterable of arguments. </p>
<p>So you could have</p>
<pre><code>psql_command = "\"\copy table (col1, col2) FROM file_location CSV HEADER QUOTE '\\\"' NULL ''\""
# user, hostname, password, dbname all defined elsewhere above.
command = ["psql",
    "-U", user,
    "-h", hostname,
    "-d", dbname,
    "-w", password,
    "-c", psql_command,
]

subprocess.call(command)
</code></pre>
<p>See <a href="https://docs.python.org/2/library/subprocess.html#subprocess.call" rel="nofollow noreferrer">https://docs.python.org/2/library/subprocess.html#subprocess.call</a> or <a href="https://docs.python.org/3/library/subprocess.html#subprocess.call" rel="nofollow noreferrer">https://docs.python.org/3/library/subprocess.html#subprocess.call</a></p>
<p>extra edit :- Please note that to avoid shell injection, you should be using the method described here. See the warning section of <a href="https://docs.python.org/2/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer">https://docs.python.org/2/library/subprocess.html#frequently-used-arguments</a></p>
</div>
<span class="comment-copy">do you have any network connection between the two computers?</span>
<span class="comment-copy">The situation arose as I'm converting a local codebase to use docker. Using docker compose there's two containers (python3.6 conda and postgis). I could stick with the original COPY if you could suggest how to configure docker-compose? Is it as simple as opening up a port? The error when using COPY with docker says 'file does not exist' (in relation to the postgis server container).</span>
<span class="comment-copy">you could use a bat file to run execute a terminal command using the method that was successful</span>
<span class="comment-copy">Thanks for the suggestion. I'm on a mac, but yea doing a .sh might be the way to go, or I could just add that step to the Dockerfile for the python container</span>
<span class="comment-copy">Is it a shell escaping issue? try <code>'\"'</code> for the <code>QUOTE</code> argument.</span>
<span class="comment-copy">By tokenize it myself you mean hand-building the query in the subprocess.call? So no variables, just strings? In that case, your solution worked however it means I have to hard code the variables in the strings which was not what I was aiming for.</span>
<span class="comment-copy">@user578582 - you can still use variables - <code>subprocess.call</code> takes a list of tokens as its first arguments, so you can use any arbitrary array of strings. I'll update the answer with an example.</span>
<span class="comment-copy">perfect, thanks a lot!</span>
