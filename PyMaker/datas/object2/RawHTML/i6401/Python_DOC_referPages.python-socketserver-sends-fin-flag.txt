<div class="post-text" itemprop="text">
<p>I implemented the Server-Client example in Python 3.5 from <a href="https://docs.python.org/3.5/library/socketserver.html" rel="nofollow noreferrer">https://docs.python.org/3.5/library/socketserver.html</a>. The Example works for the first message in the loop but the server sends always a FIN-Flag and i don't understand why.</p>
<p>server:</p>
<pre><code>    import socketserver

class MyTCPHandler(socketserver.BaseRequestHandler):
    """
    The request handler class for our server.

    It is instantiated once per connection to the server, and must
    override the handle() method to implement communication to the
    client.
    """

    def handle(self):
        # self.request is the TCP socket connected to the client
        self.data = self.request.recv(1024).strip()
        print("{} wrote:".format(self.client_address[0]))
        print(self.data)
        # just send back the same data, but upper-cased
        self.request.sendall(self.data.upper())


if __name__ == "__main__":
    HOST, PORT = "localhost", 9999

    # Create the server, binding to localhost on port 9999
    server = socketserver.TCPServer((HOST, PORT), MyTCPHandler)

    # Activate the server; this will keep running until you
    # interrupt the program with Ctrl-C
    server.serve_forever()
</code></pre>
<p>client:</p>
<pre><code>import socket
import sys
import time

HOST, PORT = "localhost", 9999
data = " ".join(sys.argv[1:])

# Create a socket (SOCK_STREAM means a TCP socket)
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
    # Connect to server and send data
    sock.connect((HOST, PORT))
    while True:
        print("Try")
        sock.sendall(bytes(data + "\n", "utf-8"))

        # Receive data from the server and shut down
        received = str(sock.recv(1024), "utf-8")
        print("Sent:     {}".format(data))
        print("Received: {}".format(received))
        time.sleep(5)
</code></pre>
<p>Wireshark:</p>
<pre><code>17771 12:20:03.585705 127.0.0.1 127.0.0.1 59886   9999 TCP 52 59886 → distinct(9999) [SYN] Seq=0 Win=8192 Len=0 MSS=65495 WS=256 SACK_PERM=1
17772 12:20:03.585705 127.0.0.1 127.0.0.1 9999   59886 TCP 52 distinct(9999) → 59886 [SYN, ACK] Seq=0 Ack=1 Win=8192 Len=0 MSS=65495 WS=256 SACK_PERM=1
17773 12:20:03.585705 127.0.0.1 127.0.0.1 59886   9999 TCP 40 59886 → distinct(9999) [ACK] Seq=1 Ack=1 Win=8192 Len=0
17774 12:20:03.585705 127.0.0.1 127.0.0.1 59886   9999 TCP 49 59886 → distinct(9999) [PSH, ACK] Seq=1 Ack=1 Win=8192 Len=9
17775 12:20:03.585705 127.0.0.1 127.0.0.1 9999   59886 TCP 40 distinct(9999) → 59886 [ACK] Seq=1 Ack=10 Win=7936 Len=0
17776 12:20:03.585705 127.0.0.1 127.0.0.1 9999   59886 TCP 48 distinct(9999) → 59886 [PSH, ACK] Seq=1 Ack=10 Win=7936 Len=8
17777 12:20:03.585705 127.0.0.1 127.0.0.1 59886   9999 TCP 40 59886 → distinct(9999) [ACK] Seq=10 Ack=9 Win=7936 Len=0
17778 12:20:03.585705 127.0.0.1 127.0.0.1 9999   59886 TCP 48 distinct(9999) → 59886 [PSH, ACK] Seq=9 Ack=10 Win=7936 Len=8
17779 12:20:03.585705 127.0.0.1 127.0.0.1 59886   9999 TCP 40 59886 → distinct(9999) [ACK] Seq=10 Ack=17 Win=7936 Len=0
17780 12:20:03.585705 127.0.0.1 127.0.0.1 9999   59886 TCP 40 distinct(9999) → 59886 [FIN, ACK] Seq=17 Ack=10 Win=7936 Len=0
17781 12:20:03.585705 127.0.0.1 127.0.0.1 59886   9999 TCP 40 59886 → distinct(9999) [ACK] Seq=10 Ack=18 Win=7936 Len=0
17795 12:20:08.588160 127.0.0.1 127.0.0.1 59886   9999 TCP 40 59886 → distinct(9999) [FIN, ACK] Seq=10 Ack=18 Win=7936 Len=0
17796 12:20:08.588160 127.0.0.1 127.0.0.1 9999   59886 TCP 40 distinct(9999) → 59886 [ACK] Seq=18 Ack=11 Win=7936 Len=0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It all lies in <em>socketserver.py</em> (<a href="https://docs.python.org/3/library/socketserver.html" rel="nofollow noreferrer">[Python]: socketserver — A framework for network servers</a>) and few other places: I'm going to use version <strong>3.5.4</strong> as a reference (doc quotes will be version <strong>3</strong> specific):</p>
<ol>
<li><p><code>BaseServer.serve_forever(self, poll_interval=0.5)</code>(<em>#215</em>) calls <code>_handle_request_noblock</code>(<em>#234</em>):</p>
<pre><code>self._handle_request_noblock()
</code></pre></li>
<li><p><code>BaseServer._handle_request_noblock(self)</code>(<em>#306</em>) calls <code>process_request</code>(<em>#313</em>):</p>
<pre><code>self.process_request(request, client_address)
</code></pre></li>
<li><p><code>BaseServer.process_request(self, request, client_address)</code>(<em>#335</em>) calls <code>shutdown_request</code>(<em>#342</em>):</p>
<pre><code>self.shutdown_request(request)
</code></pre></li>
<li><p><code>TCPServer</code> extends <code>BaseServer</code>(<em>#370</em>):</p>
<pre><code>class TCPServer(BaseServer):
</code></pre></li>
<li><p><code>TCPServer</code> overrides <code>shutdown_request</code>(<em>#489</em>):</p>
<pre><code>def shutdown_request(self, request):
    """Called to shutdown and close an individual request."""
    try:
        #explicitly shutdown.  socket.close() merely releases
        #the socket and waits for GC to perform the actual close.
        request.shutdown(socket.SHUT_WR)
    except OSError:
        pass #some platforms may raise ENOTCONN here
    self.close_request(request)
</code></pre></li>
<li><p><code>request.shutdown(socket.SHUT_WR)</code></p>
<ul>
<li><code>request</code> is a <code>socket.socket</code> (<a href="https://docs.python.org/2/library/socket.html#socket-objects" rel="nofollow noreferrer">[Python]: Socket Objects</a>) instance</li>
</ul></li>
</ol>
<ol start="7">
<li><p><code>socket.socket.shutdown</code> is defined in <em>${PYTHON_SRC_DIR}/Modules/socketmodule.c</em>(<em>#3986</em>):</p>
<pre><code>static PyObject *
sock_shutdown(PySocketSockObject *s, PyObject *arg)
{
    int how;
    int res;

    how = _PyLong_AsInt(arg);
    if (how == -1 &amp;&amp; PyErr_Occurred())
        return NULL;
    Py_BEGIN_ALLOW_THREADS
    res = shutdown(s-&gt;sock_fd, how);
    Py_END_ALLOW_THREADS
    if (res &lt; 0)
        return s-&gt;errorhandler();
    Py_INCREF(Py_None);
    return Py_None;
}
</code></pre></li>
<li><p>As seen, it calls native <code>shutdown</code> <em>API</em>:</p>
<ul>
<li><em>Ux</em>: <a href="http://man7.org/linux/man-pages/man2/shutdown.2.html" rel="nofollow noreferrer">[man]: SHUTDOWN(2)</a></li>
<li><em>Win</em>: <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms740481(v=vs.85).aspx" rel="nofollow noreferrer">[MSDN]: shutdown function</a></li>
</ul>
<p>According to the <em>MSDN</em> link above (didn't find official <em>Ux</em> related doc, but I can't say I tried very hard searching):</p>
<blockquote>
<p>If the <em>how</em> parameter is SD_SEND, subsequent calls to the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms740149(v=vs.85).aspx" rel="nofollow noreferrer">send</a> function are disallowed. For TCP sockets, a <strong>FIN</strong> will be sent after all data is sent and acknowledged by the receiver.</p>
</blockquote>
<p><strong>Note</strong> (<em>Ux</em> &lt;-&gt; <em>Win</em> conversion): <em>SHUT_*</em> and <em>SD_*</em> corresponding constants have the same values (e.g. <em>SHUT_WR</em> = <em>SD_SEND</em> = 1)</p></li>
</ol>
</div>
<span class="comment-copy">Your servers <code>handle</code> method just reads from client and sends something back and then its done. This "done" means that the TCP connection gets closed which is done by sending a FIN. Thus, it works as implemented which might or might not be what you want. It might have been useful if you would have documented what you expect your code to actually do instead of only complaining that it does the wrong thing.</span>
<span class="comment-copy">Did this answer your question?</span>
