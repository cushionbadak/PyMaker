<div class="post-text" itemprop="text">
<p>Consider:</p>
<pre><code>class Parent():
    def __init__(self, last_name, eye_color):
        self.last_name = last_name
        self.eye_color = eye_color

    def show_info(self):
        print("Last Name - "+self.last_name)
        print("Eye Color - "+self.eye_color)

billy_cyrus = Parent("Cyrus", "blue")
</code></pre>
<p>The above is from the <a href="https://en.wikipedia.org/wiki/Udacity" rel="nofollow noreferrer">Udacity</a> Python course. I discovered I'm able to call <code>show_info</code> for instance <code>billy_cyrus</code> using either of the following:</p>
<pre><code>billy_cyrus.show_info()
Parent.show_info(billy_cyrus)
</code></pre>
<p>I'm curious as to why. Is there a difference between the two methods? If so when would one be used vs. the other? I'm using Python 3.6 if that matters.</p>
</div>
<div class="post-text" itemprop="text">
<p>In terms of just calling the method, there is no difference most of the time. In terms of how the underlying machinery, works, there is a bit of a difference.</p>
<p>Since <code>show_info</code> is a <a href="https://docs.python.org/3.6/tutorial/classes.html#method-objects" rel="nofollow noreferrer">method</a>, it is a <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">descriptor</a> in the class. That means that when you access it through an <a href="https://docs.python.org/3.6/tutorial/classes.html#instance-objects" rel="nofollow noreferrer">instance</a> in which it is not shadowed by another <a href="https://docs.python.org/3.6/tutorial/classes.html#class-and-instance-variables" rel="nofollow noreferrer">attribute</a>, the <code>.</code> operator calls <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer"><code>__get__</code></a> on the descriptor to create a bound method for that instance. A bound method is basically a closure that passes in the <code>self</code> parameter for you before any of the other arguments you supply. You can see the binding happen like this:</p>
<pre><code>&gt;&gt;&gt; billy_cyrus.show_info
&lt;bound method Parent.show_info of &lt;__main__.Parent object at 0x7f7598b14be0&gt;&gt;
</code></pre>
<p>A different closure is created every time you use the <code>.</code> operator on a class method.</p>
<p>If you access the method through the class object, on the other hand, it does not get bound. The method is a descriptor, which is just a regular attribute of the class:</p>
<pre><code>&gt;&gt;&gt; Parent.show_info
&lt;function __main__.Parent.show_info&gt;
</code></pre>
<p>You can simulate the exact behavior of binding a method before calling it by calling its <code>__get__</code> yourself:</p>
<pre><code>&gt;&gt;&gt; bound_meth = Parent.show_info.__get__(billy_cyrus, type(billy_cyrus))
&gt;&gt;&gt; bound_meth
&lt;bound method Parent.show_info of &lt;__main__.Parent object at 0x7f7598b14be0&gt;&gt;
</code></pre>
<p>Again, this will not make any difference to you in 99.99% of cases, since functionally <code>bound_meth()</code> and <code>Parent.bound_meth(billy_cyrus)</code> end up calling the same underlying function object with the same parameters.</p>
<p><strong>Where it matters</strong></p>
<p>There are a couple of places where it matters how you call a class method. One common use case is when you override a method, but want to use the definition provided in the parent class. For example, say I have a class that I made "immutable" by overriding <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer"><code>__setattr__</code></a>. I can still set attributes on the instance, as in the <code>__init__</code> method shown below:</p>
<pre><code>class Test:
    def __init__(self, a):
        object.__setattr__(self, 'a', a)
    def __setattr__(self, name, value):
        raise ValueError('I am immutable!')
</code></pre>
<p>If I tried to do a normal call to <code>__setattr__</code> in <code>__init__</code> by doing <code>self.a = a</code>, a <code>ValueError</code> would be raised every time. But by using <code>object.__setattr__</code>, I can bypass this limitation. Alternatively, I could do <code>super().__setattr__('a', a)</code> for the same effect, or <code>self.__dict__['a'] = a</code> for a very similar one.</p>
<p>@Silvio Mayolo's answer has another good example, where you would deliberately want to use the class method as a function that could be applied to many objects.</p>
<p>Another place it matters (although not in terms of calling methods), is when you use other common descriptors like <a href="https://docs.python.org/3.6/library/functions.html#property" rel="nofollow noreferrer"><code>property</code></a>. Unlike methods, properties are <a href="https://docs.python.org/2/howto/descriptor.html#descriptor-protocol" rel="nofollow noreferrer">data-descriptors</a>. This means that they define a <code>__set__</code> method (and optionally <code>__delete__</code>) in addition to <code>__get__</code>. A property creates a virtual attribute whose getter and setter are arbitrarily complex functions instead of just simple assignments. To properly use a property, you have to do it through the instance. For example:</p>
<pre><code>class PropDemo:
    def __init__(self, x=0):
        self.x = x
    @property
    def x(self):
        return self.__dict__['x']
    @x.setter
    def x(self, value):
        if value &lt; 0:
            raise ValueError('Not negatives, please!')
        self.__dict__['x'] = value
</code></pre>
<p>Now you can do something like</p>
<pre><code>&gt;&gt;&gt; inst = PropDemo()
&gt;&gt;&gt; inst.x
0
&gt;&gt;&gt; inst.x = 3
&gt;&gt;&gt; inst.x
3
</code></pre>
<p>If you try to access the property through the class, you can get the underlying descriptor object since it will be an unbound attribute:</p>
<pre><code>&gt;&gt;&gt; PropDemo.x
&lt;property at 0x7f7598af00e8&gt;
</code></pre>
<p>On a side note, hiding attributes with the same name as a property in <code>__dict__</code> is a neat trick that works because data descriptors in a class <code>__dict__</code> trump entries in the instance <code>__dict__</code>, even though instance <code>__dict__</code> entries trump non-data-descriptors in a class.</p>
<p><strong>Where it can Get Weird</strong></p>
<p>You can override a class method with an instance method in Python. That would mean that <code>type(foo).bar(foo)</code> and <code>foo.bar()</code> don't call the same underlying function at all. This is irrelevant for <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">magic methods</a> because they always use the former invocation, but it can make a big difference for normal method calls.</p>
<p>There are a few ways to <a href="https://stackoverflow.com/q/394770/2988730">override a method on an instance</a>. The one I find most intuitive is to set the instance attribute to a bound method. Here is an example of a modified <code>billy_cyrus</code>, assuming the definition of <code>Parent</code> in the original question:</p>
<pre><code>def alt_show_info(self):
    print('Another version of', self)

billy_cyrus.show_info = alt_show_info.__get__(billy_cyrus, Parent)
</code></pre>
<p>In this case, calling the method on the instance vs the class would have <em>completely</em> different results. This only works because methods are <em>non-data</em> descriptors by the way. If they were data descriptors (with a <code>__set__</code> method), the assignment <code>billy_cyrus.show_info = alt_show_info.__get__(billy_cyrus, Parent)</code> would not override anything but would instead just redirect to <code>__set__</code>, and manually setting it in b
<code>billy_cyrus</code>'s <code>__dict__</code> would just get it ignored, as happens with a property.</p>
<p><strong>Additional Resources</strong></p>
<p>Here are a couple of resources on descriptors:</p>
<ul>
<li>Python Reference - Descriptor Protocol: <a href="http://python-reference.readthedocs.io/en/latest/docs/dunderdsc/" rel="nofollow noreferrer">http://python-reference.readthedocs.io/en/latest/docs/dunderdsc/</a></li>
<li>(Official?) Descriptor HowTo Guide: <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">https://docs.python.org/3/howto/descriptor.html</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>There is no semantic difference between the two. It's entirely a matter of style. You would generally use <code>billy_cyrus.show_info()</code> in normal use, but the fact that the second approach is allowed permits you to use <code>Parent.show_info</code> to get the method as a first-class object itself. If that was not allowed, then it would not be possible (or at least, it would be fairly difficult) to do something like this.</p>
<pre><code>function = Parent.show_info
so_many_billy_cyrus = [billy_cyrus, billy_cyrus, billy_cyrus]
map(function, so_many_billy_cyrus)
</code></pre>
</div>
<span class="comment-copy">There's no difference at all. The first one is kind if syntactic sugar for the latter one. That's where the <code>self</code> parameter is from. It can, however, be useful when you want to pass a method around as a parameter (e.g. for <code>map</code> or for a callback) to use either <code>Class.method</code> or <code>instance.method</code> (the latter being a bound method).</span>
<span class="comment-copy">@tobias_k. That is not strictly, pedantically 100% true.</span>
<span class="comment-copy">@MadPhysicist That's why it's a comment and not an answer. Feel free to elaborate.</span>
<span class="comment-copy">I am drafting an answer as we speak :) I think this is an important question to ask.</span>
<span class="comment-copy">It's useful to be able to deal with objects without knowing their exact class. <code>Parent.show_info(billy_cyrus)</code> breaks down if someone wants to pass in a <code>Grandparent</code> or a <code>Guardian</code> in place of a <code>Parent</code>.</span>
<span class="comment-copy">If by "fairly difficult" you mean "use <code>lambda b: b.show_info()</code>"... but, yes, that's one case where that style could be preferred.</span>
<span class="comment-copy">I'm curious - if you were intending to use <code>show_info</code> like that wouldn't you define it outside of the class as a standalone function and not as an instance attribute?</span>
<span class="comment-copy">@wwii It is possible that you do not have control over the source code of <code>show_info</code>. I frequently work with codebases written by people who are significantly invested in the object-oriented ideas of Java, so every API call ends up, for better or worse, being a method.</span>
<span class="comment-copy">@MadPhysicist I'm sure you meant "<i>in Python 2</i>, <code>map</code> is equivalent to a list comprehension". You know, being strictly pedantically 100% correct...;-)</span>
<span class="comment-copy">In Python3, replace <code>[]</code> with <code>()</code> to get the equivalent generator expression. My mistake.</span>
