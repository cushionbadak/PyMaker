<div class="post-text" itemprop="text">
<p>I'm pulling data out of a Google doc, processing it, and writing it to a file (that eventually I will paste into a Wordpress page).</p>
<p>It has some non-ASCII symbols. How can I convert these safely to symbols that can be used in HTML source? </p>
<p>Currently I'm converting everything to Unicode on the way in, joining it all together in a Python string, then doing: </p>
<pre><code>import codecs
f = codecs.open('out.txt', mode="w", encoding="iso-8859-1")
f.write(all_html.encode("iso-8859-1", "replace"))
</code></pre>
<p>There is an encoding error on the last line: </p>
<blockquote>
<p>UnicodeDecodeError: 'ascii' codec can't decode byte 0xa0 in position
  12286: ordinal not in range(128)</p>
</blockquote>
<p><strong>Partial solution:</strong></p>
<p>This Python runs without an error:</p>
<pre><code>row = [unicode(x.strip()) if x is not None else u'' for x in row]
all_html = row[0] + "&lt;br/&gt;" + row[1]
f = open('out.txt', 'w')
f.write(all_html.encode("utf-8")
</code></pre>
<p>But then if I open the actual text file, I see lots of symbols like:</p>
<pre><code>Qur‚Äôan 
</code></pre>
<p>Maybe I need to write to something other than a text file? </p>
</div>
<div class="post-text" itemprop="text">
<p>Deal exclusively with unicode objects as much as possible by decoding things to unicode objects when you first get them and encoding them as necessary on the way out.</p>
<p>If your string is actually a unicode object, you'll need to convert it to a unicode-encoded string object before writing it to a file:</p>
<pre><code>foo = u'Δ, Й, ק, ‎ م, ๗, あ, 叶, 葉, and 말.'
f = open('test', 'w')
f.write(foo.encode('utf8'))
f.close()
</code></pre>
<p>When you read that file again, you'll get a unicode-encoded string that you can decode to a unicode object:</p>
<pre><code>f = file('test', 'r')
print f.read().decode('utf8')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.6+, you could <a href="https://docs.python.org/2/library/io.html">use <code>io.open()</code></a> that is default (<a href="https://docs.python.org/3/library/functions.html#open">builtin <code>open()</code></a>) on Python 3:</p>
<pre><code>import io

with io.open(filename, 'w', encoding=character_encoding) as file:
    file.write(unicode_text)
</code></pre>
<p>It might be more convenient if you need to write the text incrementally (you don't need to call <code>unicode_text.encode(character_encoding)</code> multiple times). Unlike <code>codecs</code> module, <code>io</code> module has a proper universal newlines support.</p>
</div>
<div class="post-text" itemprop="text">
<p>The file opened by <code>codecs.open</code> is a file that takes <code>unicode</code> data, encodes it in <code>iso-8859-1</code> and writes it to the file. However, what you try to write isn't <code>unicode</code>; you take <code>unicode</code> and encode it in <code>iso-8859-1</code> <em>yourself</em>. That's what the <code>unicode.encode</code> method does, and the result of encoding a unicode string is a bytestring (a <code>str</code> type.)</p>
<p>You should either use normal <code>open()</code> and encode the unicode yourself, or (usually a better idea) use <code>codecs.open()</code> and <em>not</em> encode the data yourself.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unicode string handling is standardized in Python 3.</p>
<ol>
<li>Char are stored in Unicode</li>
<li><p>You only need to open file in utf-8</p>
<pre><code>out1 = "(嘉南大圳 ㄐㄧㄚ　ㄋㄢˊ　ㄉㄚˋ　ㄗㄨㄣˋ )"
fobj = open("t1.txt", "w", encoding="utf-8")
fobj.write(out1)
fobj.close()
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<h2>Preface: will your viewer work?</h2>
<p>Make sure your viewer/editor/terminal (however you are interacting with your utf-8 encoded file) can read the file. This is frequently an issue on <a href="https://stackoverflow.com/questions/9321419/unicode-utf-8-text-file-gibberish-on-windows-console-trying-to-display-hebrew">Windows</a>, for example, Notepad.</p>
<blockquote>
<h2>Writing Unicode text to a text file?</h2>
</blockquote>
<p>In Python 2, use <code>open</code> from the <code>io</code> module (this is the same as the builtin <code>open</code> in Python 3):</p>
<pre><code>import io
</code></pre>
<p>Best practice, in general, use <code>UTF-8</code> for writing to files (we don't even have to worry about byte-order with utf-8).</p>
<pre><code>encoding = 'utf-8'
</code></pre>
<p>utf-8 is the most modern and universally usable encoding - it works in all web browsers, most text-editors (see your settings if you have issues) and most terminals/shells.</p>
<p>On Windows, you might try <code>utf-16le</code> if you're limited to viewing output in Notepad (or another limited viewer).</p>
<pre><code>encoding = 'utf-16le' # sorry, Windows users... :(
</code></pre>
<p>And just open it with the context manager and write your unicode characters out:</p>
<pre><code>with io.open(filename, 'w', encoding=encoding) as f:
    f.write(unicode_object)
</code></pre>
<h2>Example using many Unicode characters</h2>
<p>Here's an example that attempts to map every possible character up to three bits wide (4 is the max, but that would be going a bit far) from the digital representation (in integers) to an encoded printable output, along with its name, if possible (put this into a file called <code>uni.py</code>):</p>
<pre><code>from __future__ import print_function
import io
from unicodedata import name, category
from curses.ascii import controlnames
from collections import Counter

try: # use these if Python 2
    unicode_chr, range = unichr, xrange
except NameError: # Python 3
    unicode_chr = chr

exclude_categories = set(('Co', 'Cn'))
counts = Counter()
control_names = dict(enumerate(controlnames))
with io.open('unidata', 'w', encoding='utf-8') as f:
    for x in range((2**8)**3): 
        try:
            char = unicode_chr(x)
        except ValueError:
            continue # can't map to unicode, try next x
        cat = category(char)
        counts.update((cat,))
        if cat in exclude_categories:
            continue # get rid of noise &amp; greatly shorten result file
        try:
            uname = name(char)
        except ValueError: # probably control character, don't use actual
            uname = control_names.get(x, '')
            f.write(u'{0:&gt;6x} {1}    {2}\n'.format(x, cat, uname))
        else:
            f.write(u'{0:&gt;6x} {1}  {2}  {3}\n'.format(x, cat, char, uname))
# may as well describe the types we logged.
for cat, count in counts.items():
    print('{0} chars of category, {1}'.format(count, cat))
</code></pre>
<p>This should run in the order of about a minute, and you can view the data file, and if your file viewer can display unicode, you'll see it. Information about the categories can be found <a href="https://en.wikipedia.org/wiki/Unicode_character_property" rel="noreferrer">here</a>. Based on the counts, we can probably improve our results by excluding the Cn and Co categories, which have no symbols associated with them.</p>
<pre><code>$ python uni.py
</code></pre>
<p>It will display the hexadecimal mapping, <a href="https://en.wikipedia.org/wiki/Unicode_character_property" rel="noreferrer">category</a>, symbol (unless can't get the name, so probably a control character), and the name of the symbol. e.g.</p>
<p>I recommend <code>less</code> on Unix or Cygwin (don't print/cat the entire file to your output):</p>
<pre><code>$ less unidata
</code></pre>
<p>e.g. will display similar to the following lines which I sampled from it using Python 2 (unicode 5.2):</p>
<pre><code>     0 Cc NUL
    20 Zs     SPACE
    21 Po  !  EXCLAMATION MARK
    b6 So  ¶  PILCROW SIGN
    d0 Lu  Ð  LATIN CAPITAL LETTER ETH
   e59 Nd  ๙  THAI DIGIT NINE
  2887 So  ⢇  BRAILLE PATTERN DOTS-1238
  bc13 Lo  밓  HANGUL SYLLABLE MIH
  ffeb Sm  ￫  HALFWIDTH RIGHTWARDS ARROW
</code></pre>
<p>My Python 3.5 from Anaconda has unicode 8.0, I would presume most 3's would.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>How to print unicode characters into a file:</strong></p>
<p>Save this to file: foo.py:</p>
<pre><code>#!/usr/bin/python -tt
# -*- coding: utf-8 -*-
import codecs
import sys 
UTF8Writer = codecs.getwriter('utf8')
sys.stdout = UTF8Writer(sys.stdout)
print(u'e with obfuscation: é')
</code></pre>
<p>Run it and pipe output to file:</p>
<pre><code>python foo.py &gt; tmp.txt
</code></pre>
<p>Open tmp.txt and look inside, you see this:</p>
<pre><code>el@apollo:~$ cat tmp.txt 
e with obfuscation: é
</code></pre>
<p>Thus you have saved unicode e with a obfuscation mark on it to a file.</p>
</div>
<div class="post-text" itemprop="text">
<p>That error arises when you try to encode a non-unicode string: it tries to decode it, assuming it's in plain ASCII. There are two possibilities:</p>
<ol>
<li>You're encoding it to a bytestring, but because you've used codecs.open, the write method expects a unicode object. So you encode it, and it tries to decode it again. Try: <code>f.write(all_html)</code> instead.</li>
<li>all_html is not, in fact, a unicode object. When you do <code>.encode(...)</code>, it first tries to decode it.</li>
</ol>
</div>
<span class="comment-copy">The program you're using to open it is not interpreting the UTF-8 text correctly. It should have an option to open the file as UTF-8.</span>
<span class="comment-copy">Thanks. This runs without an error, but then if I open the text file, I see a bunch of weird symbols :) I need to copy and paste the text into a Wordpress page (don't ask). Is there any way I can actually print the symbols that are there? I guess not to a txt file, right, but maybe to something else?</span>
<span class="comment-copy">What are you using to open the text file? I'm guessing you're on Windows, and you're opening it in Notepad, which isn't too intelligent with encodings. What happens when you open it in Wordpad?</span>
<span class="comment-copy">Man, I spent so much time to find this! Thank you!</span>
<span class="comment-copy">This works for Python 3 too (obvious, but still worth pointing out).</span>
<span class="comment-copy">But this does not work on Python 2, right? (I should said, on this Python 3 code, it looks so concise and reasonable)</span>
<span class="comment-copy">it should not work on Python 2.  We stay on Python 3.  3 is so much better.</span>
<span class="comment-copy">I was pretty excited about this answer, but it gives an error on my machine.  When I copy/paste your code, I get an error: "TypeError: must be str, not bytes"</span>
