<div class="post-text" itemprop="text">
<p>I have a folder full of files that need to be modified in order to extract the true file in it's real format. </p>
<p>I need to remove a certain number of bytes from BOTH the beginning and end of the file in order to extract the data I am looking for. </p>
<p>How can I do this in python? </p>
<ul>
<li>I need this to work recursively on an entire folder only</li>
<li>I also need this to output (or modify the exisiting) file with the bytes removed.</li>
</ul>
<p>I would greatly appreciate any help or guidance you can provide.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>Recursive iteration over files <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow noreferrer">os.walk</a></li>
<li>Change position in file: <a href="https://docs.python.org/3/tutorial/inputoutput.html?highlight=seek" rel="nofollow noreferrer">f.seek</a></li>
<li>Get file size: <a href="https://docs.python.org/3/library/os.html#os.stat" rel="nofollow noreferrer">os.stat</a></li>
<li>Remove data from current position to end of file: <a href="https://docs.python.org/3/tutorial/inputoutput.html?highlight=truncate" rel="nofollow noreferrer">f.truncate</a></li>
</ol>
<p>So, base logic:</p>
<ol>
<li>Iterate over files</li>
<li>Get file size.</li>
<li>Open file ('rb+' i suppouse )</li>
<li>Seek to position from wich you want read file</li>
<li>Read until bytes you want to drop ( f.read(file_size - top_dropped - bottom_dropped ) )</li>
<li>Seek(0)</li>
<li>Write read text to file</li>
<li>Truncate file</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Your question is pretty badly constructed, but as this is somewhat advanced stuff I'll provide you with a code.</p>
<p>You can now use os.walk() to recursively traverse directory you want and apply my slicefile() function.</p>
<p>This code does the following:</p>
<ol>
<li><p>After checking validity of start and end arguments it creates a memory map on top of an opened file.
mmap() creates a memory map object that mapps, in this case, portion of a file system over which the file is written. The object exposes both a string-like and file-like interface with some additional methods like move(). So you can treat memory map either as a string or as a file or use size(), move(), resize() or whatever additional methods you need.</p></li>
<li><p>We calculate what is a distance between our start and end, i.e. this is how much bytes we will have in the end.</p></li>
<li><p>We move stream of bytes, end-start long, starting from our start position to the 0 position i.e. we move them backwards for number of bytes indicated by starting point.</p></li>
<li><p>We discard the rest of file. I.e. we resize it to end-start bytes. So, what is left is our new string.</p></li>
</ol>
<p>The operation will be longer as the file is bigger. Unfortunately there is nothing much you can do about it. If a file is big, this is your best bet. The procedure is the same as when removing items from a start/middle of an  in-memory array, except this has to be buffered (in chunks) not to fill RAM too much.</p>
<p>If your file is smaller than a third of your free RAM space, you can load it whole into a string with f.read(), then perform string slicing on the loaded content ( s = s[start:end] ) and then write it back into file by opening it again and just doing f.write(s).
If you have enough disk space, you can open another file, seek to the starting point you want in the original file and then read it in chunks and write these into the new file. Perhaps even using shutil.copyfileobj(). After that, you remove the original file and use os.rename() to put the new one in its place. These are your only 3 options.
Whole file into RAM; move by buffering backward and then resizing; and, copying into another file, then renaming it. The second option is most universal and won't fail you for small or big files. Therefore I used it.</p>
<p>OK, Not only 3 options. There is a fourth option. It could be possible to cut off N number of bytes from beginning of the file by manipulating the file system itself using low-level operations. To write a kind of truncate() function that truncates the beginning instead of the end. But this would be pretty suicidal. In the end memory fragmentation would occur and whole mess will arise. You don't need such speed anyway. You will be patient until your script finishes. :D</p>
<p>Why did i use mmap()?</p>
<p>Because it uses memory maps implemented in OS rather than completely new code. This reduces number of system calls needed to deal with the opened file. Half of the work is thrust upon operating system, leaving Python to breathe easily.</p>
<p>Because it is mostly written in C which makes it a touch faster than its pure Python implementation would be.</p>
<p>Because it implements move() which wee need. The buffering and everything is already written, so no needs for bulky while loop which would be the alternative (manual) solution.</p>
<p>And so on...</p>
<pre><code>
from mmap import mmap

def slicefile (path, start=0, end=None):
    f = open(path, "r+b") # Read and write binary
    f.seek(0, 2)
    size = f.tell()
    start = 0    if start==None else start
    end   = size if end==None   else end
    start = size+start if start&lt;0 else start
    end   = size+end   if end&lt;0   else end
    end   = size if end&gt;size else end
    if (end==size and start==0) or (end&lt;=start):
        f.close()
        return
    # If start is 0, no need to move anything, just cut off the rest after end
    if start==0:
        f.seek(end)
        f.truncate()
        f.close()
        return
    # Modify in place using mapped memory:
    newsize = end-start
    m = mmap(f.fileno(), 0)
    m.move(0, start, newsize)
    m.flush()
    m.resize(newsize)
    m.close()
    f.close()

</code></pre>
</div>
<span class="comment-copy">What have you tried so far, where is the code? + provide sample of the data in the file, your question is too broad</span>
<span class="comment-copy">I have no clue where to start this in python, my file can only be seen in hex at the moment. As soon as I remove the first 4 or so bytes and a few from the end  (using a hex editor) I then get my gzip file.</span>
<span class="comment-copy">You can easily remove bytes at the end of a file, but you can't just remove bytes from the start of a file (or in the middle). You need to either replace them with other bytes, or read the bytes you want to keep and write them back to the original file, or to a new file.</span>
<span class="comment-copy">Ok I will start here. Thank you so much for your input yuroslav!</span>
<span class="comment-copy">Is this python 2 or 3?</span>
<span class="comment-copy">It's Python 2.5 and later. As for 3.x, well I don't see anything that wouldn't be compatible unless they changed mmap module. I don't have it here so I cannot try. This code essentially does what Yaroslav Surzhikov described.</span>
<span class="comment-copy">Thank you Dalen. I greatly appreciate your time! I'm still having trouble understanding this piece of code. Perhaps I should better explain my plight. I have a folder with a bunch of files extracted from a cell phone's disk. The files are essentially junk until the first 8 or so bytes from the beginning and the last 12 or so from the end are removed. Once that happens they become gzip files, which have the forensic evidence I need. I could do this by hand, one at a time, in a hex editor, but I really need the script since I have at least 1000 files</span>
<span class="comment-copy">See my edit. I tried to explain everything. I also added some improvements to the code.</span>
<span class="comment-copy">I also advise you, if there are 1000 or more files, either to use Python 3.x or download the scandir module from pypi.python.org and use its walk() function instead of os.walk(). Otherwise you will wait a bit until os.listdir() finds all 1000 files in your directory, and this will freak you out. Don't worry, slicefile(8, -12) will do it for you. I'll add the possibility to use negative indices. Perhaps you can even use some trickery with Python's gzip module that would ignore invalid bytes and extract your files automatically.</span>
