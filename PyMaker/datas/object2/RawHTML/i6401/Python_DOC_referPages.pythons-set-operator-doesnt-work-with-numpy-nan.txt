<div class="post-text" itemprop="text">
<p>I noticed a problem converting lists of NaN values to sets:</p>
<pre><code>import pandas as pd
import numpy as np

x = pd.DataFrame({'a':[None,None]})
x_numeric = pd.to_numeric(x['a']) #converts to numpy.float64
set(x_numeric)
</code></pre>
<p>This SHOULD return {nan} but instead returns {nan, nan}.  However, doing this:</p>
<pre><code>set([numpy.nan, numpy.nan])
</code></pre>
<p>returns the expected {nan}.  The former are apparently class numpy.float64, while the latter are by default class float. </p>
<p>Any idea why set() doesn't work with numpy.float64 NaN values? I'm using Pandas version 0.18 and Numpy version 1.10.4.</p>
</div>
<div class="post-text" itemprop="text">
<p>NaNs in a float64 array don't point to the same space in memory as np.NaN, (they, like every other number in the array, 8 bytes in the array). We can see this when we take the <a href="https://docs.python.org/3/library/functions.html#id" rel="noreferrer"><code>id</code></a>:</p>
<pre><code>In [11]: x_numeric
Out[11]:
0   NaN
1   NaN
Name: a, dtype: float64

In [12]: x_numeric.apply(id)
Out[12]:
0    4657312584
1    4657312536
Name: a, dtype: int64

In [13]: id(np.nan)
Out[13]: 4535176264

In [14]: id(np.nan)
Out[14]: 4535176264
</code></pre>
<p>It's kindof a python "gotcha" that this occurs, since it's an optimization (before checking set equality python checks if it's the same object: has the same <code>id</code> / location in memory):</p>
<pre><code>In [21]: s = set([np.nan])

In [22]: np.nan in s
Out[22]: True

In [23]: x_numeric.apply(lambda x: x in s)
Out[23]:
0    False
1    False
Name: a, dtype: bool
</code></pre>
<p>The reason it's a "gotcha" is because NaN, unlike most objects is not equal to itself:</p>
<pre><code>In [24]: np.nan == np.nan
Out[24]: False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Numpy is a red herring here - <code>np.nan</code> is just a name for <code>float('nan')</code>, which shows the same problem:</p>
<pre><code>&gt;&gt;&gt; a = float('nan')
&gt;&gt;&gt; b = float('nan')
&gt;&gt;&gt; {a, b}
{nan, nan}
&gt;&gt;&gt; {a, a}
{nan}
</code></pre>
<p>As Andy says, this is about set equality trying <code>x is y</code> before <code>x == y</code> when checking for set membership.</p>
</div>
<span class="comment-copy">In numpy two nan's are not equal. In a list they may be identical but not in numpy array. To find out try <code>set(np.array([np.nan,np.nan]))</code>. In pandas they series will be in numpy array format</span>
<span class="comment-copy"><code>x_numeric.unique()</code> returns only <code>[nan]</code>, this is interesting.</span>
<span class="comment-copy">Well Im confused now a  bit more.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ That fixes my immediate problem, thanks! Oddly np.unique(x_numeric) still returns {nan, nan}.</span>
<span class="comment-copy">@AndyHayden I see! Thanks for the answer as well, it was very informative. See if you can answer <a href="https://stackoverflow.com/questions/46842793/datetime-conversion-how-to-extract-the-inferred-format">mine</a> too.. :-)</span>
<span class="comment-copy">This is a really good example deserves more votes.</span>
