<div class="post-text" itemprop="text">
<p>I have this list of dictionary:</p>
<pre><code>MylistOfdict = [{'Word': 'surveillance',
  'Word No': 1},
 {'Word': 'equivocal',
  'Word No': 2}]
</code></pre>
<p>I want to create a new list of dictionary (<code>word_db2</code>) that has 3 dictionaries for each dictionary in <code>MylistOfdict</code>. In addition to key and values of MylistOfdict, each of those dictionary should have 'Card Type' key with value Type 1, Type 2, Type 3 and 'Card Key' key with incremental value</p>
<p>Code:</p>
<pre><code>word_db2 = []

key = 1
for i in MylistOfdict:
    for j in range(1, 4):
        i['Card Type'] = 'Type '+str(j)
        i['Card Key'] = key
        print(i)

        word_db2.append(i)
        key += 1
</code></pre>
<p>Output:</p>
<pre><code>{'Word No': 1, 'Card Key': 1, 'Word': 'surveillance', 'Card Type': 'Type 1'}
{'Word No': 1, 'Card Key': 2, 'Word': 'surveillance', 'Card Type': 'Type 2'}
{'Word No': 1, 'Card Key': 3, 'Word': 'surveillance', 'Card Type': 'Type 3'}
{'Word No': 2, 'Card Key': 4, 'Word': 'equivocal', 'Card Type': 'Type 1'}
{'Word No': 2, 'Card Key': 5, 'Word': 'equivocal', 'Card Type': 'Type 2'}
{'Word No': 2, 'Card Key': 6, 'Word': 'equivocal', 'Card Type': 'Type 3'}
</code></pre>
<p>This output is correct, but <code>word_db2</code> stores only last appended value in every iteration</p>
<pre><code>print(word_db2)
</code></pre>
<p>Output:</p>
<pre><code>[{'Card Key': 3, 'Card Type': 'Type 3', 'Word': 'surveillance', 'Word No': 1},
 {'Card Key': 3, 'Card Type': 'Type 3', 'Word': 'surveillance', 'Word No': 1},
 {'Card Key': 3, 'Card Type': 'Type 3', 'Word': 'surveillance', 'Word No': 1},
 {'Card Key': 6, 'Card Type': 'Type 3', 'Word': 'equivocal', 'Word No': 2},
 {'Card Key': 6, 'Card Type': 'Type 3', 'Word': 'equivocal', 'Word No': 2},
 {'Card Key': 6, 'Card Type': 'Type 3', 'Word': 'equivocal', 'Word No': 2}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's review the loop body logic step by step:</p>
<ol>
<li>take one of the dicts</li>
<li>modify it</li>
<li>append it to the end of the list</li>
</ol>
<p>So the key point you missed is that you modify and append the same object that was selected on the first step. And at the end of the snippet <code>word_db2</code> contains six object refs, but only two unique. As a result, the output shows similar rows.</p>
<p>You can make a <strong>shallow copy</strong> of a dict before modifying and appending it:</p>
<pre><code>for j in range(1, 4):
    i = dict(i)
    i['Card Type'] = 'Type '+str(j)
    i['Card Key'] = key
    print(i)

    word_db2.append(i)
    key += 1
</code></pre>
<p>As further note, if the dict contains other mutable objects like nested dicts, you should make a <strong>deep copy</strong>:</p>
<pre><code>import copy
old_dict = {'a': [1, 2, 3], 'b': [4, 5, 6]}
new_dict = copy.deepcopy(old_dict)
old_dict['a'][1] = 7
new_dict['a'][1] # 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you append a dictionary to a list, a reference to the original object itself is appended. So, you are currently just modifying the existing object's keys and values in each iteration of the inner loop, so the last written value is the only thing which persists. </p>
<p>To do what you require, you would need to create a new dictionary object in each iteration of the inner loop. For the shown dictionaries in MylistOfdict, a simple dictionary comprehension would work. But if you have more complex dictionaries, use the <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer" title="copy">copy</a> module's deepcopy method. </p>
<pre><code>MylistOfdict = [{'Word': 'surveillance', 'Word No': 1}, 
                {'Word': 'equivocal', 'Word No': 2}]
word_db2 = []

key = 1
for i in MylistOfdict:
    for j in range(1, 4):
        # Creating a new dictionary object and copying keys and values from i
        new_dict = {k: v for k, v in i.items()}
        new_dict['Card Type'] = 'Type '+str(j)
        new_dict['Card Key'] = key

        print(new_dict)

        word_db2.append(new_dict)
        key += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't use the same dict, make copies of them:</p>
<pre><code>word_db2 = []

key = 1
for i in MylistOfdict:
    for j in range(1, 4):
        i = dict(i)
        i['Card Type'] = 'Type '+str(j)
        i['Card Key'] = key
        print(i)

        word_db2.append(i)
        key += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use deepcopy. What's happening is that your append call is just appending a reference to the original object.</p>
<pre><code>from copy import deepcopy

my_list_of_dict = [{'Word': 'surveillance',
                    'Word No': 1},
                   {'Word': 'equivocal',
                    'Word No': 2}]
word_db2 = []

key = 1
for i in my_list_of_dict:
    for j in range(1, 4):
        i['Card Type'] = 'Type ' + str(j)
        i['Card Key'] = key
        print(i)
        word_db2.append(deepcopy(i))
        key += 1


for i in word_db2:
    print(i)
</code></pre>
</div>
<span class="comment-copy">You reuse the same dictionary.  Instead make copies of the dictionary.  Inside <code>for j in range(1, 4):</code> put as the first line of the inner loop <code>i = dict(i)</code>.  Also <code>i</code> is a bad name for a dictionary.  Convention would be to call it <code>d</code>.  <code>i</code> usually denotes an integer.</span>
<span class="comment-copy">Thanks, it is working.</span>
<span class="comment-copy">Thanks for the explanation.</span>
<span class="comment-copy">Good idea, but note that selected object (i) still modified before copying. So you should make a copy and then modify it. Please edit the snippet</span>
<span class="comment-copy"><code>deepcopy</code> is unnecessary.  A shallow copy is sufficient.  The easiest way to make a shallow copy of a dictionary is to pass it to <code>dict</code> (as in <code>copy_of_d = dict(d)</code>).  Also making the copy after modification mutates the contents of <code>MylistOfdict</code> which may be an unwanted side effect.  To avoid this the copy should be made at the top of the inner loop.</span>
