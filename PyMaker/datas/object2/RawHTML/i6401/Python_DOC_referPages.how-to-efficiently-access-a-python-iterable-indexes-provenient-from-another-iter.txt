<div class="post-text" itemprop="text">
<p>I have a list <code>X</code> and a list <code>Y</code> where there are some shuffled indexes.</p>
<pre><code>X = ['a', 'b', 'c', 'd','e']
Y = [ 1 ,  3 ,  4 ,  0 , 2 ]
</code></pre>
<p>I want to have a new list <code>Z</code> such that</p>
<pre><code>Z = [ X[i] for i in Y ] = ['b', 'd', 'e', 'a', 'c']
</code></pre>
<p>The issue is that i have to do this multiple times, for such big <code>arrays</code>. There is any more efficient approach than the list-by-comprehension for loops?</p>
<p><strong>Note:</strong> <code>numpy</code> solutions are apreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a> accepts multiple indices, one solution is:</p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt; operator.itemgetter(*Y)(X)
('b', 'd', 'e', 'a', 'c')
</code></pre>
<p>The efficient one (as posted in comments) would be via <code>numpy</code>'s array indexing:</p>
<pre><code>np.array(X)[Y]
</code></pre>
<p>but <strong>only</strong> if <code>X</code> and <code>Y</code> are converted to <code>numpy.array</code> once (ahead of use) and used many times.</p>
<hr/>
<h3>Performance tests</h3>
<p>Indexing <code>1k</code> elements (<code>Y</code>) from a list of <code>1M</code> elements (<code>X</code>).</p>
<pre><code># setup
import random
import numpy as np
X = [random.randint(0,100) for i in range(1000000)]
Y = [random.randint(0,1000000) for i in range(1000)]
</code></pre>
<h3>1) List comprehension ~ 34 µs</h3>
<pre><code>%timeit [X[i] for i in Y]
10000 loops, best of 3: 34 µs per loop
</code></pre>
<h3>2) <code>itemgetter</code> ~ 16.6 µs</h3>
<pre><code>%timeit operator.itemgetter(*Y)(X)
100000 loops, best of 3: 16.6 µs per loop
</code></pre>
<h3>3) <code>numpy</code>, arrays converted on fly ~ 31.6 ms   ⇒   slowest</h3>
<pre><code>%timeit np.array(X)[Y]
10 loops, best of 3: 31.6 ms per loop
</code></pre>
<h3>4) <code>numpy</code>, arrays pre-converted ~ 1.72 µs   ⇒   fastest</h3>
<pre><code>x = np.array(X)
y = np.array(Y)
%timeit x[y]
1000000 loops, best of 3: 1.72 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Convert your lists to NumPy arrays and use the second as the index for the first:</p>
<pre><code>x, y = np.array(x), np.array(y)
Z = x[y]
</code></pre>
</div>
<span class="comment-copy"><code>X = np.array(X); result = X[Y]</code>, also it seems your "expected output" is incorrect.</span>
<span class="comment-copy">THANKS!! I guess the question is closed.</span>
<span class="comment-copy">No, the output is actually correct.</span>
<span class="comment-copy">..."provenient"?</span>
<span class="comment-copy">In timetests, <code>itemgetter</code> is fastest.  list comprehension about half its speed. and array even slower.  Array approaches the list comprehension speed if <code>X</code> is already an array.</span>
<span class="comment-copy">@hpaulj, cool, let me update the answer with some tests then.</span>
<span class="comment-copy">@randomir very clever answer, thanks!</span>
<span class="comment-copy">@Pedro, thanks, you're welcome!</span>
