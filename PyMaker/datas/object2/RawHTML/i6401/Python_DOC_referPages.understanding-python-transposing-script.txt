<div class="post-text" itemprop="text">
<p>I found a Python script called transpose_file.py which can transpose space-delimited files. It looks like so:</p>
<pre><code> import fileinput

 m = []
 for line in fileinput.input():
     m.append(line.strip().split(" "))
 for row in zip(*m):
     print " ".join(row)
</code></pre>
<p>I want to make sure I understand what each line does, as I am very new to Python.</p>
<p>1) First, we import a module called fileinput which allows you to read files and parse through them? Not sure why using a simple with open(sys.argv[1],'r') as f etc would not work</p>
<p>2) Make an empty list called m</p>
<p>3) For each line in your input file, strip any space, tab or newline at the end of the line, and make space the delimiter (i.e. your input file is delimited)</p>
<p>4) For each row ... not sure what the rest means. What does zip(*m) mean? Once this is done, we print a space and we join the row? I just don't see how this results in a transposition.</p>
<p>Any explanation would be deeply appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p><code>fileinput</code> supports other methods of file input as well. It can effectively do <code>open(sys.argv[1],'r')</code>, but also supports other possibilities - see the Python <a href="https://docs.python.org/3/library/fileinput.html" rel="nofollow noreferrer">documentation</a> for this.</p></li>
<li><p>Your understanding of 2 and 3 is broadly correct</p></li>
<li><p>For each line, the line is stripped of whitespace and then split by spaces. This results in a grid representing each space-delimited part of the file.</p></li>
<li><p><code>zip(*)</code> is effectively Python's transposition operator. For example:</p>
<pre><code>In [1]: data = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

In [2]: data
Out[2]: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

In [3]: transp = list(zip(*data))

In [4]: transp
Out[4]: [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
</code></pre>
<p>You have to coerce it to a <code>list</code> as <code>zip</code> returns an iterable. <code>zip</code> is perhaps more commonly used to "zip" together two lists, so you can iterate over them together:</p>
<pre><code>In [1]: list(zip(["one", "three", "five"], ["two", "four", "six"]))
Out[1]: [('one', 'two'), ('three', 'four'), ('five', 'six')]
</code></pre>
<p>This is also well <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">documented</a>.</p>
<p>The <code>*</code> operator separates each sublist of the grid into a separate argument to <code>zip</code>.</p>
<p><code>" ".join</code> joins together each string in an iterable with a space - eg</p>
<pre><code>In [1]: " ".join(["foo", "bar", "baz"])
Out[1]: 'foo bar baz'
</code></pre>
<p>This just puts the space delimiters back into your newly transposed series of strings. It is again, <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer">documented</a>.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Your analysis is basically correct.</p>
<p>Note that </p>
<pre><code>line.strip().split(" ")
</code></pre>
<p>is a little fragile. It strips all leading &amp; trailing whitespace from the line, and then splits the line into a list of strings, using a single space as the delimiter. This may not do what you want if the line contains runs of more than one space, or if it contains tabs.</p>
<hr/>
<p>The <code>zip</code> function iterates over its arguments in parallel, building tuples from the corresponding items in each arg. So first it generates a tuple of all the first items, then all the second items, etc. </p>
<p>Eg:</p>
<pre><code>for t in zip([1, 2, 3], [4, 5, 6], [7, 8, 9]):
    print(t)
print()
</code></pre>
<p><strong>output</strong></p>
<pre><code>(1, 4, 7)
(2, 5, 8)
(3, 6, 9)
</code></pre>
<p>As you can see, this results in a transposition.</p>
<p>We can use the <code>*</code> "splat" operator to pass a list of sequences to <code>zip</code>, the "splat" operator unpacks the list so that <code>zip</code> sees each of those sequences as a separate arg.</p>
<pre><code>lst = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
]

for t in zip(*lst):
    print(t)
</code></pre>
<p>This gives the same output as before.</p>
<p>The "splat" operator isn't just a special feature of <code>zip</code>: you can use it on any function that takes multiple arguments. There's also the "double-splat" operator <code>**</code>, which unpacks dictionaries into keyword=value pairs.</p>
<p>If the sequences differ in length then <code>zip</code> stops when there are no more items left in the shortest sequence. However, there's a related function in the standard <code>itertools</code> module: <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a>, which takes an optional <code>fillvalue</code>. It keeps going until the longest sequence is exhausted, using <code>fillvalue</code> to fill the gaps. The default <code>fillvalue</code> is <code>None</code>.</p>
<hr/>
<p>In regard to <code>fileinput</code>, some people just find it convenient, I prefer <code>with open(</code>...</p>
</div>
