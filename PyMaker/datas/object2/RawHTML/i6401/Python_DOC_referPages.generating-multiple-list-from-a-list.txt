<div class="post-text" itemprop="text">
<p>What is the best way to append a list of</p>
<pre><code>A = [1,2,3,4,5]
</code></pre>
<p>and obtain a list of this sort;</p>
<pre><code>B = [[1], [1, 2], [1,2,3], [1,2,3,4], [1,2,3,4,5]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just a list comprehension with slicing</p>
<pre><code>B = [A[:i] for i in range(1, len(A) + 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>And another list comprehension that avoids playing with indices too much.</p>
<pre><code>A = [1,2,3,4,5]

B = [A[:i+1] for i, _ in enumerate(A)]
print(B)  # [[1], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the best way and the most basic way is to use <code>List Comprehensions</code> !</p>
<pre><code>A = [1,2,3,4,5]
B = [A[:i+1] for i in range(len(A))]
print B
</code></pre>
<p>Output:</p>
<pre><code>[[1], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5]]
</code></pre>
<p>By the way for the example that you gave above even this will work:</p>
<pre><code>B = [A[:i] for i in A]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>A = [1,2,3,4,5]

B = []

for x in range(1,len(A)+1):
    B.append(list(A[0:x]))

print(B)
</code></pre>
<p>Output:</p>
<pre><code>[[1], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you describe here is what is known in some functional programming languages as <code>inits</code>.</p>
<p>We can construct an <code>inits</code> function that works on infinite generators and with lazy loading as follows:</p>
<pre><code>from itertools import islice

def inits(xs):
    ls = []
    for i,x in enumerate(xs,1):
        ls.append(x)
        yield islice(ls,i)
</code></pre>
<p>For your case, we can then perform a <code>map(list,...)</code> and also perform <code>list(..)</code> on the result:</p>
<pre><code>&gt;&gt;&gt; list(map(list,inits(A)))
[[1], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5]]
</code></pre>
<p>The advantage of this appraoch is that it works with infinite generators, as well as with collections that can be enumerated, but do not support slicing. Furthermore memory is shared among the differenct <code>islice</code>s, so we do not construct explicit lists, unless we explicitly want this (like in the above example).</p>
</div>
<span class="comment-copy">If you want all possible combinations, you should probably give <code>itertools</code> a look : <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html</a></span>
<span class="comment-copy">@Lo√Øc: no, he wants all possible inits.</span>
<span class="comment-copy">Maybe I was too quick to downvote. As you said, for me this solution is not pythonic and then not 'correct' (for me), even though is valid. I think each language has its 'style' and then our duty is try to preserve it. Said this, I am not a 'guru' nor an expert</span>
