<div class="post-text" itemprop="text">
<p><strong>Sorry for the strange title didn't know how to explain it better (feel free to edit it).</strong></p>
<p>I'm not able to figure out how to (efficiently) do the following. Let's say I have a set <code>{a,b,c}</code>, I want to get the following output:</p>
<pre><code>{a: {b,c}}
{b: {a,c}}
{c: {a,b}}
</code></pre>
<p>I found a way to do so, but I think it's not efficient/pythonic (because I suspect that there is a function in Python to do so):</p>
<pre><code>set1 = {'a','b','c'}
output = []
for item in set1:
    temp_set = set1.copy()
    temp_set.remove(item)
    output.append({item: temp_set})
print(output)
</code></pre>
<p>This will print: <code>[{'b': {'c', 'a'}}, {'c': {'b', 'a'}}, {'a': {'b', 'c'}}]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, there's a more compact way: use the <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.difference" rel="nofollow noreferrer">set difference</a> operator.</p>
<pre><code>set1 = {'a','b','c'}
output = [{u: set1-{u}} for u in set1]
print(output)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[{'c': {'a', 'b'}}, {'a': {'c', 'b'}}, {'b': {'c', 'a'}}]
</code></pre>
<hr/>
<p>Another related way to do this is to make a 1 item tuple from <code>u</code> rather than a set. The benefit is that tuples are simpler than sets, and faster to build; OTOH, Python sets are reasonably efficient, although they do have the overhead of a hash table. </p>
<pre><code>set1 = {'a','b','c'}
output = [{u: set1.difference((u,))} for u in set1]
print(output)
</code></pre>
<p>This code gives equivalent output to the previous code.</p>
<p>Even though we're calling the set difference method that method doesn't actually build a set from its iterable arg, it merely iterates over it directly.</p>
</div>
<div class="post-text" itemprop="text">
<p>The set difference approach of PM 2Ring is fine and the most compact. For completeness sake and since it is more generally applicable, e.g. if you want your dict values to be lists, tuples or generators, the following conditional comprehension based version should be suggested:</p>
<pre><code>output = [{u: {x for x in set1 if x != u}} for u in set1]
# output = [{u: [x for x in set1 if x != u]} for u in set1]
# output = [{u: (x for x in set1 if x != u)} for u in set1]
</code></pre>
</div>
<span class="comment-copy">I can't find anything particularly inefficient here. Possibly replace the first two lines in the loop with <code>temp_set = { x for x in set1 if x != item }</code> to avoid having to remove the element, but without profiling I really can't tell if it's faster.</span>
<span class="comment-copy">Compact, maybe; instantiating a new set just so one can subtract it, probably not super-efficient. Still, better profile.</span>
<span class="comment-copy">@Amadan Fair point, although set construction is pretty cheap. We could do it with a tuple instead if we use the method form of set difference. But that wouldn't really be much of a saving.</span>
<span class="comment-copy">@Amadan I don't see why <code>set1-{u}</code> would need to build an extra set from which to subtract.</span>
<span class="comment-copy">@schwobaseggl We're constructing a new set with <code>{u}</code>.</span>
<span class="comment-copy">@PM2Ring Oh, the singleton on the right :) that overhead is so small I didn't even consider it.</span>
<span class="comment-copy">I suspect that the Python loop in the inner set comprehension will be significantly slower than the internal loop executed by the set difference operation. Also, we can't store unhashable things like lists in sets, so there's no point getting too general.</span>
<span class="comment-copy">@PM2Ring I agree about the performance part. But dict values do not have to be hashable. I added two more examples to illustrate my point.</span>
<span class="comment-copy">Dict values certainly don't need to be hashable, but dict keys and set items do.</span>
