<div class="post-text" itemprop="text">
<p>It all began last night when I was making a script that required 8 or so packages including <code>pygame.mixer</code> which on my computer importing this takes a few seconds.  </p>
<p>This meant that before the script even started I had to wait 10 or so seconds for all the imports to load.  Because I want the script to obviously be as fast as possible could I start running the script while getting the imports with something like this:</p>
<pre><code>import threading


def import_modules():
    import tkinter as tk
    from pygame import mixer
    import json
    import webbrowser
    print('imports finished')

a = threading.Thread(target=import_modules)
a.start()
for i in range(10000):
    print('Getting Modules')
</code></pre>
<p>So my question is:</p>
<p>Is this considered bad practice and will it cause problems?</p>
<p>If so are there alternatives I could use? </p>
<p>Or is it OK to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using CPython, this might not yield as much improvement as you'd expect.</p>
<p>CPython has a Global Interpreter Lock ("GIL") that ensures that only one thread at a time can be executing Python bytecode.</p>
<p>So whenever the import thread is executing Python code, the other thread is not running. The GIL is released by a thread when it is e.g. waiting on I/O. So there will be some time savings because of that.</p>
<p>There is a difference of opinion as to whether tkinter is truly thread-safe. It is still considered wise to run the tkinter main loop in the original thread, and to not invoke tkinter calls from other threads, because that <em>can</em> lead to crashes.</p>
<p>The GIL also can cause problems for GUI programs. If you are using a second thread for a long-running calculation, the user interface might become less responsive. There are at least two possible solutions. The first one is to split the long-running calculation up into small pieces which are each executed by a <code>after</code> method. The second is to run the calculation in a different <em>process</em>.</p>
<hr/>
<p>Follow-up questions from the comments:</p>
<blockquote>
<p>is there anything else to speed up execution time?</p>
</blockquote>
<p>The first thing you must to do is <em>measure</em>; what <em>exactly</em> causes the problem. Then you can look into the problem areas and try to improve them.</p>
<p>For example module load times. Run your app under a <a href="https://pypi.python.org/pypi/line_profiler/" rel="nofollow noreferrer">profiler</a> to see how long the module loads take and why.</p>
<p>If <code>pygame.mixer</code> takes too long to load, you could use your platform's native mixer. UNIX-like operating systems generally have a <code>/dev/mixer</code> device, while ms-windows has different API's for it. Using those definitely won't take 10 seconds. 
There is a cost associated with this: you will loose portability between operating systems.</p>
<blockquote>
<p>What are the alternatives</p>
</blockquote>
<p>Using multiple cores is a usual tactic to try and speed things up. Currently on CPython the only <em>general</em> way get code to run in parallel on multiple cores is with <code>multiprocessing</code> or <code>concurrent.futures</code>.</p>
<p>However it depends on the nature of your problem if this tactic can work.</p>
<p>If your problem involves doing the same calculations over a huge set of data, that is relatively easy to parallelize. In that case you can expect a maximal speedup roughly equivalent to the numbers of cores you use.</p>
<p>It could be that your problem consists of multiple steps, each of which depends on the result of a previous step. Such problems are serial in nature and are much harder to execute in parallel.</p>
<p>Other ways to possible speed things up could be to use another Python implementation like <a href="https://pypy.org/" rel="nofollow noreferrer">Pypy</a>. Or you could use <a href="http://cython.org/" rel="nofollow noreferrer">cython</a> together with type hints to convert performance-critical parts to compiled C code.</p>
</div>
<span class="comment-copy">While you can perform imports in another thread, it probably won't achieve what you want to achieve.</span>
<span class="comment-copy">@user2357112  Why? It does seem to speed up the imports.</span>
<span class="comment-copy">What do you mean by "start running the script"? If the script needs the "8 or so packages", how can it start running before those have been imported?</span>
<span class="comment-copy">@user4815162342 That's the thing.  I could get the packages I need initially by importing the normal way then get the others as the script runs and by the time one of those packages are needed they will have already loaded.</span>
<span class="comment-copy">Beyond the GIL, there is a <a href="https://stackoverflow.com/q/12389526/364696">global lock protecting module imports as well</a>, so threading imports is doubly pointless.</span>
<span class="comment-copy">@ShadowRanger Is this still the case in current Python 3 versions? Somewhere between 3.1 and 3.6 the mention of import in threaded code seems to have disappeared from the threading chapter of the Python documentation.</span>
<span class="comment-copy">Ok This seems like a bad idea with Tkinter what about the other modules (not GUI) will they be affected?  What are the alternatives (if any) Everything except the standard library calls could be <code>pyc</code> files is there anything else to speed up execution time?</span>
<span class="comment-copy">@RolandSmith: Ah, yes, forgot that <a href="https://docs.python.org/3/whatsnew/3.3.html#a-finer-grained-import-lock" rel="nofollow noreferrer">in 3.3 they introduced per module import locks</a>. So just blocked by the GIL; the import locks would only be a problem if you imported the same module in multiple threads (which can be easier to do than you would think, since most imports trigger imports of dependent modules).</span>
<span class="comment-copy">@Simon That is probably an effect of your operating system's cache warming up. Most operating systems today use free memory as a disk cache, because disk is much slower than RAM. After a couple of tries, all your modules files will be in that disk cache, where they can be accessed quicker. :-)If you were to reboot your PC, you would probably see the same thing again. The operating system has other influences as well.  The general concensus seems to be that disk operations on ms-windows are significantly slower than on e.g. Linux.</span>
