<div class="post-text" itemprop="text">
<p>I'm trying to subclass the IntEnum to start members' value at a certain value and then automatically set the value for subsequent members.  This is my class:</p>
<pre class="lang-python prettyprint-override"><code>class Abc(IntEnum):
  def __init__(self, n=100):
    super().__init__()
    self._value_ = n + len(self.__class__.__members__)

  A = () # 100
  B = () # 101

Abc.A == Abc.B # expects False, but gets True
</code></pre>
<p>As shown above the comparison between the members is not correct.  When printing out Abc.<strong>dict</strong>, I noticed that it _value2member_map_ does not look correct either.</p>
<pre><code>mappingproxy({'A': &lt;Abc.A: 100&gt;,
          'B': &lt;Abc.B: 101&gt;,
          '__doc__': 'An enumeration.',
          '__init__': &lt;function __main__.Abc.__init__&gt;,
          '__module__': '__main__',
          '__new__': &lt;function enum.Enum.__new__&gt;,
          '_generate_next_value_': &lt;function enum.Enum._generate_next_value_&gt;,
          '_member_map_': OrderedDict([('A', &lt;Abc.A: 100&gt;),
                       ('B', &lt;Abc.B: 101&gt;)]),
          '_member_names_': ['A', 'B'],
          '_member_type_': int,
          '_value2member_map_': {0: &lt;Abc.B: 101&gt;}})
</code></pre>
<p>Notice how '_value2member_map_' has key 0 instead of the expected values 100 and 101.  I must be missing something in the init function, but I could not figure out how to properly do what I intended.  Any help is appreciated.
Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, there's a more idiomatic—and dead simple—way to do what you seem to be trying to do:</p>
<pre><code>class Abc(IntEnum):
    A = 100
    B = auto()
</code></pre>
<p>Or, given that you're putting 100 and 101 in as comments anyway, live code is always better than comments:</p>
<pre><code>class Abc(IntEnum):
    A = 100
    B = 101
</code></pre>
<p>The fact that you're <em>not</em> doing either of those is a signal to the reader that you're probably doing to do something more complicated. Except that, as far as I can tell, you aren't, so this is misleading.</p>
<p>Plus, you're combining two patterns that have directly opposite connotations: as <a href="https://docs.python.org/3/library/enum.html#omitting-values" rel="nofollow noreferrer">the docs</a> say, using the <code>()</code> idiom "signifies to the user that these values are not important", but using <code>IntEnum</code> obviously means that the numeric values of these enumeration constants are not just important but the whole point of them.</p>
<p>Not only that, but the user has to read through your method code to figure out what those important numeric values are, instead of just immediately reading them off.</p>
<hr/>
<p>Anyway, if you want to get this to work, the problem is that replacing <code>_value_</code> after initialization isn't documented to do any good, and in fact it doesn't. </p>
<p>What you want to override is <code>__new__</code>, not <code>__init__</code>, as in <a href="https://docs.python.org/3/library/enum.html#using-a-custom-new" rel="nofollow noreferrer">the auto-numbering example in the docs</a>. </p>
<p>But there are two differences here (both related to the fact that you're using <code>IntEnum</code> instead of <code>Enum</code>):</p>
<ul>
<li>You cannot call <code>object.__new__</code>, because an <code>IntEnum</code> is an <code>int</code>, and <code>object.__new__</code> can't be used on instances of builtin types like <code>int</code>. You can figure out the right base class dynamically from looking through <code>cls</code>'s mro, or you can just hardcode <code>int</code> here.</li>
<li>You don't need an intermediate base class here to do the work. (You might still want one if you were going to create multiple auto-numbered <code>IntEnum</code>s, of course.)</li>
</ul>
<p>So:</p>
<pre><code>class Abc(IntEnum):
    def __new__(cls, n=100):
        value = len(cls.__members__) + n
        obj = int.__new__(cls, value)
        obj._value_ = value
        return obj
    A = ()
    B = ()
</code></pre>
</div>
<span class="comment-copy">You're trying to rely on undocumented internal behavior of the <code>enum</code> module. Even if you got that right in a way that happened to work with whichever version of Python you're using, is that really something you want to do?</span>
<span class="comment-copy">I am not trying to do anything special. Your first example is exactly what I need. Thank you very much.</span>
