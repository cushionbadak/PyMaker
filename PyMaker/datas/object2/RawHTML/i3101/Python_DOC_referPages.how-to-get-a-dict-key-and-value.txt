<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/18552001/accessing-dict-keys-element-by-index-in-python3">Accessing dict_keys element by index in Python3</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>Imagine I have a <code>dict</code> like this:</p>
<pre><code>d = {'key': 'value'}
</code></pre>
<p>The <code>dict</code> contains only one key value.
I am trying to get <code>key</code> from this <code>dict</code>, I tried <code>d.keys()[0]</code> but it returns <code>IndexError</code>, I tried this:</p>
<pre><code>list(d.keys())[0]
</code></pre>
<p>It works just fine but I think it is not a good way of doing this because it creates a new list and then get it first index.
<br/>
Is there a better way to do this? I want to get the <code>value</code> too. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you know (or expect) there is exactly one key / value pair then you could use unpacking to get the key and the value. eg.</p>
<pre><code>[item] = d.items()
assert item == ('key', 'value')
</code></pre>
<p>You can take this one step further and unpack the key / value pair too.</p>
<pre><code>[[k, v]] = d.items()
assert k == 'key'
assert v == 'value'
</code></pre>
<p>Of course this throws an error if the dictionary has multiple key / value pairs. But then this is useful. Dictionaries are unordered pre python 3.7 (<code>dict</code> is ordered in CPython 3.6, but it's an implementation detail), so doing <code>list(d.items())[0]</code> can give inconsistent results. Even in 3.7+ the ordering is over insertion, not any natural ordering of the keys, so you could still get surprising results.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is some information for you below, but I believe that you don't fully understand dictionaries. They are unsorted, meaning that the list created will be in random order, so indexing will return unpredictable answers.</p>
<p>Since Python 3, d.keys() no longer returns a list, and instead returns a dictionary object which doesn't support indexing and subsequently would return IndexError. Unfortunately, you will simply have to use list(). </p>
<p>If the option is available (i.e. You are going to loop through the list), you could go:</p>
<pre><code>for item in d.keys():
    # Do something
</code></pre>
<p>which means that you don't have to convert it to a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it the silly way:</p>
<pre><code>def silly(d:dict):
    for k,v in d.items():
        return (k,v) # will only ever return the "first" one 
                     # with 3.7 thats the first inserted one
</code></pre>
<p>Using </p>
<pre><code>list(d.items())[0]
</code></pre>
<p>at least gives you <em>key</em> and <em>value</em> at once (and throw on empty dicts). </p>
<p>With dictionarys being "insert-ordered" from 3.7 onwards there might evolve some methods to <em>"get the first"</em> or <em>"get the last"</em> of it, but so far <code>dict</code> were unordered and indexing into them (or getting first/last) made no sense.</p>
</div>
<span class="comment-copy">and <code>d.items()[0]</code> returns <code>IndexError</code> same as <code>.keys()</code></span>
<span class="comment-copy">YOure right. <code>items()</code> is just a <a href="https://docs.python.org/3/library/stdtypes.html#dict.items" rel="nofollow noreferrer">view</a></span>
<span class="comment-copy">For Python 3:      next(iter(d.values()))  Python 2:      d.itervalues().next()  For an empty dictionary you need do extra errorhandling (StopIteration error).</span>
<span class="comment-copy">@mehrdad-pedramfar Well if the size if 1 maybe. But if you have a large one next will be much quicker.</span>
<span class="comment-copy">next(iter(d.items())) would be the best solution for large dictionaries</span>
<span class="comment-copy">Thanks, I think it is the best answer.</span>
<span class="comment-copy">3.7: they are "sorted" ... <a href="https://mail.python.org/pipermail/python-dev/2017-December/151283.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-dev/2017-December/151283.html</a></span>
