<div class="post-text" itemprop="text">
<p>I've got an array of (random) floating point numbers. I want to round each value up to a limit of an arbitrary grid. See the following example:</p>
<pre><code>import numpy as np
np.random.seed(1)

# Setup
sample = np.random.normal(loc=20, scale=6, size=10)
intervals = [-np.inf, 10, 12, 15, 18, 21, 25, 30, np.inf]

# Round each interval up
for i in range(len(intervals) - 1):
    sample[np.logical_and(sample &gt; intervals[i], sample &lt;= intervals[i+1])] = intervals[i+1]
</code></pre>
<p>This results in:</p>
<pre><code>[ 30.  18.  18.  15.  30.  10.  inf  18.  25.  21.]
</code></pre>
<p>How can I avoid the <code>for</code> loop? I'm sure there's some way using NumPy's array magic that I don't see right now.</p>
</div>
<div class="post-text" itemprop="text">
<p>If <code>intervals</code> is sorted, you can use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.searchsorted.html" rel="noreferrer"><code>np.searchsorted</code></a>:</p>
<pre><code>np.array(intervals)[np.searchsorted(intervals, sample)]
# array([ 30.,  18.,  18.,  15.,  30.,  10.,  inf,  18.,  25.,  21.])
</code></pre>
<hr/>
<p><code>searchsorted</code> returns the index of the interval where the element belongs to:</p>
<pre><code>np.searchsorted(intervals, sample)
# array([7, 4, 4, 3, 7, 1, 8, 4, 6, 5])
</code></pre>
<p>The default <code>side='left'</code> returns the smallest index of such interval and the result falls into the <em>left open, right close</em> scenario.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use Pandas <code>cut()</code>:</p>
<pre><code>import pandas as pd

pd.cut(sample, intervals, labels=intervals[1:]).tolist()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option is:</p>
<pre><code>np.array(intervals)[(sample[:,None] &gt; intervals).sum(axis=1)]
#array([30., 18., 18., 15., 30., 10., inf, 18., 25., 21.])
</code></pre>
<p>Essentially we build a mask that checks to see if the sample is greater than the interval (assumes it's already sorted as in your example). Then we sum along the first axis, which will add up a 1 for every interval that the value is greater than. </p>
<p>The resultant sums are the indices in the <code>intervals</code> array.</p>
<p>A non-NumPy solution using a list comprehension (obviously includes the <code>for</code> loop, but should be relatively efficient with the generator):</p>
<pre><code>new_sample = [next(i for i in intervals if i&gt;s) for s in sample]
#[30, 18, 18, 15, 30, 10, inf, 18, 25, 21]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Did not run a check but:</p>
<pre><code> from bisect import bisect

 for index, value in enumerate(sample):
     sample[index] = intervals[ bisect( intervals, value)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If <code>values</code> is a 1D arrays with your values, you could do something like</p>
<pre><code>diff = values &lt; intervals[:, None]
t = np.argmax(diff, axis=0)
new_values = intervals[t]
</code></pre>
</div>
<span class="comment-copy">Compared this answer with @blue_note's and @pault's answer using <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a>: it's twice as fast as blue_note's and thrice as fast as pault's. (Sampling of data was taken into the timeit-loop. Results may differ for larger samples / grids).</span>
<span class="comment-copy">Makes sense that this is the fastest because <code>searchshorted</code> can short circuit. My solution computes the intervals in a different way, but it requires comparing each value in <code>sample</code> to each interval. Would you mind benchmarking <code>[next(i for i in intervals if i&gt;s) for s in sample]</code> - it obviously has the for loop, but I am wondering how much the <code>next()</code> saves in time. @ascripter</span>
<span class="comment-copy">@pault: <code>[next(i for i in intervals if i&gt;s) for s in sample]</code> takes about 4.5 the time compared to <code>searchsorted</code></span>
<span class="comment-copy">OP wanted to avoid the <code>for</code> loop</span>
<span class="comment-copy">Indeed but I wanted to share a solution that does not require <code>numpy</code>, <code>bisect</code> is a built-in.</span>
