<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/23998026/why-isnt-this-a-syntax-error-in-python">Why isn't this a syntax error in python?</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>Inputting the command <code>0xbin()</code> returns False:</p>
<pre><code>&gt;&gt;&gt; 0xbin()
False
</code></pre>
<p>Why does that happen? This syntax should have no meaning whatsoever. Functions cannot start with 0, there are no "i" and "n" in hex, and the bin function must have some arguments.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python seems to interpret <code>0xbin()</code> as <code>0xb in ()</code>, meaning is eleven in an empty tuple.
The answer is no, therefore <code>False</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you disassemble the code, you'll see that <a href="https://stackoverflow.com/a/51521235/6260170">Yself's answer</a>, which mentions that <code>0xbin()</code> is interpreted as <code>0xb in ()</code>, is confirmed:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis('0xbin()')
  1           0 LOAD_CONST               0 (11)
              2 BUILD_TUPLE              0
              4 COMPARE_OP               6 (in)
              6 RETURN_VALUE
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use Python's own tokenizer to check!</p>
<pre><code>import tokenize
import io
line = b'0xbin()'
print(' '.join(token.string for token in tokenize.tokenize(io.BytesIO(line).readline) if token.type!=59))
</code></pre>
<p>This prints the tokens in your string, separated by spaces. In this case, the result will be:</p>
<pre><code>0xb in ( ) 
</code></pre>
<p>In other words, it returns False because the number 11 (<code>0xb</code>) is not in the empty tuple (<code>()</code>).</p>
<p>(Thanks to Roman Odaisky for suggesting the use of <code>tokenize</code> in the comments!)</p>
<p>EDIT: To explain the code a bit more thoroughly: the <code>tokenize</code> function expects input in a bit of a weird format, so <code>io.BytesIO(line).readline</code> is a function that turns a sequence of bytes into something <code>tokenize</code> can read. <code>tokenize</code> then tokenizes it and returns a series of <code>namedtuple</code>s; we take the string representing each one and join them together with spaces. The <code>type != 59</code> part is used to ignore the encoding specifier that would otherwise show up at the beginning.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/ast.html" rel="noreferrer">AST</a> module to get the <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noreferrer">abstract syntax tree</a> of the expression:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; m = ast.parse('0xbin()')
&gt;&gt;&gt; ast.dump(m)
'Module(
    body=[Expr(
               value=Compare(left=Num(n=11),
                             ops=[In()],
                             comparators=[Tuple(elts=[],
                                                ctx=Load())
                                         ]
                            ))])'
</code></pre>
<p>See the <a href="https://docs.python.org/2/library/ast.html#abstract-grammar" rel="noreferrer">abstract grammar</a> for how to interpret the expression, but tl;dr: <code>Num(n=11)</code> is the <code>0xb</code> part, and <code>Tuple(elts=[], ...)</code> hints towards an empty tuple rather than a function call.</p>
</div>
<span class="comment-copy">It takes arguments! <code>0xbin(013,37)</code></span>
<span class="comment-copy">@nneonneo and if you want to get <code>True</code> you can try <code>0xbin(11,)</code> with a single argument</span>
<span class="comment-copy"><code>0xbin(013,37)</code> will also give you True ;) (in Python 2.7)</span>
<span class="comment-copy">Compare and contrast with <code>0xband()</code>.  <a href="https://docs.python.org/3/library/tokenize.html" rel="nofollow noreferrer">Tokenizer</a> is greedy and takes 0xba as a token.</span>
<span class="comment-copy">@people who are voting to reopen: Please explain why this is not a dupe.  If you convince me, I'll dupehammer reopen it.</span>
<span class="comment-copy">So apparently "in", "is" etc don't require spaces? First time I encountered this, but it makes sense as "&lt;" and "==" don't require them as well.</span>
<span class="comment-copy">Apparently yes. The <a href="https://docs.python.org/3.6/reference/lexical_analysis.html#whitespace-between-tokens" rel="nofollow noreferrer">Python Reference</a> says whitespace between tokens is only needed "if their concatenation could be interpreted as a different token". But I have only ever seen such code in <a href="https://codegolf.stackexchange.com/">Code Golf</a>.</span>
<span class="comment-copy">@MattS This is why valid python identifiers (and many other languages) only accept alpha or underscore for the first letter of the identifier then allow numeric afterwards. The actual implementation is fairly complicated because of full Unicode support, but the pure ASCII regex for an identifier would be: <code>r'[_a-zA-Z][_a-zA-Z0-9]*'</code></span>
<span class="comment-copy">@Aaron: <code>[_[:alpha:]][_[:alnum:]]*</code> in regular expression languages that allow (Unicode) characters classes, i. e. not Pythonâ€™s. ;-]</span>
<span class="comment-copy">Wow, I thought this kind of parsing was only done in Fortran and BASIC. I can't believe a modern language does it.</span>
<span class="comment-copy"><code>list(tokenize.tokenize(io.BytesIO(b"0xbin()").readline))</code> might be more appropriate</span>
<span class="comment-copy">This is the best answer yet, the "dis" and "ast" answers obscure what is going on behind uncommon notations, this shows it clearly in normal python.</span>
