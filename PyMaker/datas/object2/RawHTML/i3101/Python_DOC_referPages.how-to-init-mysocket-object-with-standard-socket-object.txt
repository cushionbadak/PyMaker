<div class="post-text" itemprop="text">
<p>I want to write my own socket class for server-client talking with RSA and AES encryption, and for server side I need to overload accept() function to return not (socket, address) pair, but (MySocket, address). So that's why I need MySocket class to be initializable with another socket.</p>
<p>This is simplified version of my code:</p>
<pre><code>import socket as sock

class MySocket(sock.socket):
  def __init__(self, socket_obj = None):
    if socket_obj == None:
      sock.socket.__init__(self, family = sock.AF_INET, type = sock.SOCK_STREAM)
    else:
      assert(socket_obj.family == sock.AF_INET and socket_obj.type == sock.SOCK_STREAM)
      self = socket_obj

    self.key = 'value'

my_socket = MySocket() # works fine

print('First worked')

my_socket = MySocket(socket_obj = sock.socket()) # falls with error

print('Second also worked')
</code></pre>
<p>And after executing this code, I get an error:</p>
<pre><code>Traceback (most recent call last):
  File "./pyoverflow.py", line 19, in &lt;module&gt;
    my_socket = MySocket(socket_obj = sock.socket()) # falls with error
  File "./pyoverflow.py", line 13, in __init__
    self.key = 'value'
AttributeError: 'socket' object has no attribute 'key'
</code></pre>
<p>As I understand, the problem is in the #9 string <code>self = socket_obj</code>, but googling the error didn't give anything.</p>
</div>
<div class="post-text" itemprop="text">
<p>If <code>MySocket</code> is a subclass of <code>socket</code>, then a <code>MySocket</code> instance is a <code>socket</code> instance; it can't become a different <code>socket</code> instance, nor can you change another <code>socket</code> instance into a <code>MySocket</code> if it wasn't one already.<sup>1</sup></p>
<p>Just assigning <code>self = socket_obj</code> doesn't do anything useful. <code>self</code> is just a local variable inside the <code>__init__</code> method. So, for the rest of the body of that method, when you do something to <code>self</code>, you're doing it to <code>socket_obj</code> instead of to your actual self. Assigning to its <code>key</code> attribute fails, as you saw. But, even if it didn't fail, all you would have done would be to modify <code>socket_obj</code>, while leaving yourself basically uninitialized.</p>
<p>There are two possible things that <em>do</em> make sense here, however.</p>
<hr/>
<p>First, instead of <em>being</em> a <code>socket</code>, your <code>MySocket</code> can <em>own</em> a <code>socket</code>, and provide the same interface as the <code>socket</code> type by delegating calls to its owned <code>socket</code>. Then, you can easily choose whether to own a newly-created socket, or one that was passed in. Something like this:</p>
<pre><code>class MySocket:
    def __init__(self, socket_obj = None):
        if socket_obj is None:
            socket_obj = socket.socket(self, family = sock.AF_INET, type = sock.SOCK_STREAM)
        self._socket_obj = socket_obj
        self.key = 'value'
    def accept(self):
        addr, s = self._socket_obj.accept()
        return addr, MySocket(s)
    def __getattr__(self, name):
        if name.startswith('_'):
            raise AttributeError(name)
        return getattr(self._socket_obj, name)
</code></pre>
<p>Writing explicit delegators (whether manually, or by looping over <code>inspect.getmembers(socket.socket)</code> and creating them programmatically) is probably a better design here than <code>__getattr__</code>, but this gets the idea across.</p>
<hr/>
<p>The other option is to to do effectively what <a href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket" rel="nofollow noreferrer"><code>ssl.SSLSocket</code></a> does.</p>
<p>Socket objects are basically just a thin wrapper around a file descriptor. You can call <a href="https://docs.python.org/3/library/socket.html#socket.socket.detach" rel="nofollow noreferrer"><code>detach</code></a> on a socket to steal its fd, and then you can pass that fd into the <a href="https://docs.python.org/3/library/socket.html#socket.socket" rel="nofollow noreferrer"><code>socket</code></a> initializer:</p>
<pre><code>class MySocket(sock.socket):
    def __init__(self, socket_obj=None):
        if socket_obj is None:
            super().__init__(family=sock.AF_INET, type=sock.SOCK_STREAM)
        else:
            super().__init__(fileno=socket_obj.detach())
        self.key = 'value'
    def accept(self):
        addr, s = super().accept()
        return addr, MySocket(s)
</code></pre>
<p>What <code>SSLSocket</code> actually does is more complicated (although it's not <em>that</em> complicated, and it may be worth reading <a href="https://github.com/python/cpython/blob/3.7/Lib/ssl.py#L781" rel="nofollow noreferrer">the source</a>).</p>
<p>But also, notice that its interface is different. Stealing another socket's fd is kind of a strange thing to do in a constructor call, so instead, <code>SSLSocket(socket_obj)</code> will raise a <code>TypeError</code>, and you're instead required to use a <a href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket" rel="nofollow noreferrer"><code>wrap_socket</code></a> function. This is probably a less confusing design.</p>
<p>However, if you don't need the extra complexity of having different Context objects that all wrap sockets differently, you might just want a <code>@classmethod</code> alternate constructor method, instead of an external factory function.</p>
<hr/>
<p><sub>1. Actually, in Python, you <em>can</em> sometimes change the type of a live object, by setting its <code>__class__</code> attribute. But this is almost always a bad idea, and wanting to do so is usually a sign that your design has gone very wrong somewhere.</sub></p>
</div>
<span class="comment-copy">This code doesn’t make any sense. Assigning a new value to <code>self</code> just rebinds the local variable <code>self</code> to another object for the rest of this function. So now, you’re calling <code>self.key = value</code> on that other object, which fails. But if it didn’t fail, you still wouldn’t have done anything to the <code>MySocket</code> you’re supposed to be initializing, but instead to the other object you rebound <code>self</code> to.</span>
