<div class="post-text" itemprop="text">
<p>I want to efficiently categorize the elements of a given list <code>L1</code>. This list can be arbitrary long, so I am looking for an efficient way to do the following.</p>
<p>The list <code>L1</code> contains several elements <code>[e_1,...,e_N]</code> that can be compared with a generic function called <code>areTheSame(e1,e2)</code>. If this function returns <code>True</code>, it means that both elements belong to the same category. </p>
<p>At the end, I want to have another list <code>L2</code>, which in turn contains different lists <code>[LC_1, ..., LC_M]</code>. Each <code>LC</code> list contains all the elements from the same category.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that the function is transitive and reflective (and if it's not, the whole grouping does not seem to make much sense), it is enough to compare each word to one "representative" from each group, e.g. just the first or last element. If no such group exists, create a new group, e.g. using <code>next</code> with an empty list as default element.</p>
<pre><code>lst = "a list with some words with different lengths".split()
areTheSame = lambda x, y: len(x) == len(y)
res = []
for w in lst:
    l = next((x for x in res if areTheSame(w, x[0])), [])
    if l == []:
        res.append(l)
    l.append(w)
</code></pre>
<p>Result: <code>[['a'], ['list', 'with', 'some', 'with'], ['words'], ['different'], ['lengths']]</code></p>
<p>Still, this has complexity O(n*k), where n is the number of words and k the number of groups. It would be more efficient if instead of <code>areTheSame(x,y)</code> you had a function <code>getGroup(x)</code>, then you'd have O(n). That is, instead of testing whether two elements belong to the same group, that function would extract the attribute(s) that determine which group the element belongs to. In my example, that's just the <code>len</code> of the strings, but in your case it might be more complex.</p>
<pre><code>getGroup = lambda x: len(x)
d = collections.defaultdict(list)
for w in lst:
    d[getGroup(w)].append(w)
</code></pre>
<p>Result: <code>{1: ['a'], 4: ['list', 'with', 'some', 'with'], 5: ['words'], 9: ['different'], 7: ['lengths']}</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I believe you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools groupby</a> function but might need to modify the <code>areTheSame</code> function so it will be a keyfunc, i.e. will yield some kind of key.</p>
<pre><code>L1 = sorted(L1, key=keyfunc)
L2 = [list(g) for _, g in groupby(L1, keyfunc))
</code></pre>
</div>
<span class="comment-copy">I think you can do it with O(N**2) time, first find the unique elements, then append the same category on it in the next loop.</span>
<span class="comment-copy">If <code>areTheSame</code> transitive and reflective? I.e. it it enough to compare each element to any one representative of each group to make sure it belongs to that group or not?</span>
<span class="comment-copy">Great! I didn't get what <code>getGroup(x)</code> would do</span>
<span class="comment-copy">@user3473823 In my example, <code>getGroup(x)</code> would just return the <code>len</code> of the string. It's difficult to say if such a key-function exists in your case, though. Think of it as some kind of hashing function where the hash is the same for each element in any of the groups.</span>
<span class="comment-copy">I think the <code>getGroup(x)</code> function doesn't exist in my case. Moreover, I have the problem of dealing with unhashable elements, so they can not be used as keys in the <code>d</code> dictionary.</span>
<span class="comment-copy">@user3473823 If they can not be keys, you can just use a list-of-lists instead of a dict and then compare to te first or last element in that list, or append a new list if none matches. About the key/compare function: How does your function look, or what does it do exactly?</span>
<span class="comment-copy">@user3473823 I changed the first version to use a list-of-lists instead of a dict, as a dict does not really help here and this way the elements do not have to be hashable.</span>
<span class="comment-copy">It might be difficult to convert <code>areTheSame</code> into a key function. Depending on the function, <a href="https://docs.python.org/3.5/library/functools.html#functools.cmp_to_key" rel="nofollow noreferrer"><code>cmp_to_key</code></a> might help, but I think this only works if the function returns <code>0</code> or <code>-1/+1</code> instead of <code>True</code> or <code>False</code>.</span>
