<div class="post-text" itemprop="text">
<p>Given a Python object of any kind, is there an easy way to get the list of all methods that this object has?</p>
<p>Or,</p>
<p>if this is not possible, is there at least an easy way to check if it has a particular method other than simply checking if an error occurs when the method is called?</p>
</div>
<div class="post-text" itemprop="text">
<p>It appears you can use this code, replacing 'object' with the object you're interested in:</p>
<pre><code>object_methods = [method_name for method_name in dir(object)
                  if callable(getattr(object, method_name))]
</code></pre>
<p>I discovered it at <a href="https://web.archive.org/web/20180901124519/http://www.diveintopython.net/power_of_introspection/index.html" rel="noreferrer">this site</a>. Hopefully, that should provide some further detail!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the built in <code>dir()</code> function to get a list of all the attributes a module has.  Try this at the command line to see how it works.</p>
<pre><code>&gt;&gt;&gt; import moduleName
&gt;&gt;&gt; dir(moduleName)
</code></pre>
<p>Also, you can use the <code>hasattr(module_name, "attr_name")</code> function to find out if a module has a specific attribute.</p>
<p>See the <a href="http://www.ibm.com/developerworks/library/l-pyint.html" rel="noreferrer">Guide to Python introspection</a> for more information.</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest method is to use <code>dir(objectname)</code>. It will display all the methods available for that object. Cool trick.</p>
</div>
<div class="post-text" itemprop="text">
<p>To check if it has a particular method:</p>
<pre><code>hasattr(object,"method")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe that what you want is something like this: </p>
<blockquote>
<p>a list of attributes from an object</p>
</blockquote>
<p>In my humble opinion, the built-in function <code>dir()</code> can do this job for you. Taken from <code>help(dir)</code> output on your Python Shell:</p>
<blockquote>
<p>dir(...)</p>
<pre><code>dir([object]) -&gt; list of strings
</code></pre>
<p>If called without an argument, return the names in the current scope.</p>
<p>Else, return an alphabetized list of names comprising (some of) the attributes of the given object, and of attributes reachable from it.</p>
<p>If the object supplies a method named <code>__dir__</code>, it will be used; otherwise
     the default dir() logic is used and returns:</p>
<ul>
<li>for a module object: the module's attributes.</li>
<li>for a class object:  its attributes, and recursively the attributes of its bases.</li>
<li>for any other object: its attributes, its class's attributes, and
     recursively the attributes of its class's base classes.</li>
</ul>
</blockquote>
<p><strong>For example:</strong></p>
<pre><code>$ python
Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.

&gt;&gt;&gt; a = "I am a string"
&gt;&gt;&gt;
&gt;&gt;&gt; type(a)
&lt;class 'str'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; dir(a)
['__add__', '__class__', '__contains__', '__delattr__', '__doc__',
'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__',
'__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__',
'__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__',
'__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__',
'__setattr__', '__sizeof__', '__str__', '__subclasshook__',
'_formatter_field_name_split', '_formatter_parser', 'capitalize',
'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find',
'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace',
'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition',
'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip',
'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title',
'translate', 'upper', 'zfill']
</code></pre>
<hr/>
<p>As I was checking your issue, I decided to demonstrate my train of thought, with a better formatting of the output of <code>dir()</code>.</p>
<p><strong>dir_attributes.py (Python 2.7.6)</strong></p>
<pre><code>#!/usr/bin/python
""" Demonstrates the usage of dir(), with better output. """

__author__ = "ivanleoncz"

obj = "I am a string."
count = 0

print "\nObject Data: %s" % obj
print "Object Type: %s\n" % type(obj)

for method in dir(obj):
    # the comma at the end of the print, makes it printing 
    # in the same line, 4 times (count)
    print "| {0: &lt;20}".format(method),
    count += 1
    if count == 4:
        count = 0
        print
</code></pre>
<p><strong>dir_attributes.py (Python 3.4.3)</strong></p>
<pre><code>#!/usr/bin/python3
""" Demonstrates the usage of dir(), with better output. """

__author__ = "ivanleoncz"

obj = "I am a string."
count = 0

print("\nObject Data: ", obj)
print("Object Type: ", type(obj),"\n")

for method in dir(obj):
    # the end=" " at the end of the print statement, 
    # makes it printing in the same line, 4 times (count)
    print("|    {:20}".format(method), end=" ")
    count += 1
    if count == 4:
        count = 0
        print("")
</code></pre>
<p>Hope that I have contributed :).</p>
</div>
<div class="post-text" itemprop="text">
<p>On top of the more direct answers, I'd be remiss if I didn't mention <a href="http://ipython.scipy.org/" rel="noreferrer">iPython</a>.
Hit 'tab' to see the available methods, with autocompletion.</p>
<p>And once you've found a method, try:</p>
<pre><code>help(object.method) 
</code></pre>
<p>to see the pydocs, method signature, etc.</p>
<p>Ahh... <a href="http://en.wikipedia.org/wiki/REPL" rel="noreferrer">REPL</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you specifically want <strong>methods</strong>, you should use <a href="https://docs.python.org/2/library/inspect.html#inspect.ismethod" rel="noreferrer">inspect.ismethod</a>.</p>
<p>For method names:</p>
<pre><code>import inspect
method_names = [attr for attr in dir(self) if inspect.ismethod(getattr(self, attr))]
</code></pre>
<p>For the methods themselves:</p>
<pre><code>import inspect
methods = [member for member in [getattr(self, attr) for attr in dir(self)] if inspect.ismethod(member)]
</code></pre>
<p>Sometimes <a href="https://docs.python.org/3/library/inspect.html#inspect.isroutine" rel="noreferrer"><code>inspect.isroutine</code></a> can be useful too (for built-ins, C extensions, Cython without the "binding" compiler directive).</p>
</div>
<div class="post-text" itemprop="text">
<p>Open bash shell (ctrl+alt+T on Ubuntu). Start python3 shell in it. Create object to observe methods of. Just add a dot after it and press twice "tab" and you'll see something like that:</p>
<pre><code> user@note:~$ python3
 Python 3.4.3 (default, Nov 17 2016, 01:08:31) 
 [GCC 4.8.4] on linux
 Type "help", "copyright", "credits" or "license" for more information.
 &gt;&gt;&gt; import readline
 &gt;&gt;&gt; readline.parse_and_bind("tab: complete")
 &gt;&gt;&gt; s = "Any object. Now it's a string"
 &gt;&gt;&gt; s. # here tab should be pressed twice
 s.__add__(           s.__rmod__(          s.istitle(
 s.__class__(         s.__rmul__(          s.isupper(
 s.__contains__(      s.__setattr__(       s.join(
 s.__delattr__(       s.__sizeof__(        s.ljust(
 s.__dir__(           s.__str__(           s.lower(
 s.__doc__            s.__subclasshook__(  s.lstrip(
 s.__eq__(            s.capitalize(        s.maketrans(
 s.__format__(        s.casefold(          s.partition(
 s.__ge__(            s.center(            s.replace(
 s.__getattribute__(  s.count(             s.rfind(
 s.__getitem__(       s.encode(            s.rindex(
 s.__getnewargs__(    s.endswith(          s.rjust(
 s.__gt__(            s.expandtabs(        s.rpartition(
 s.__hash__(          s.find(              s.rsplit(
 s.__init__(          s.format(            s.rstrip(
 s.__iter__(          s.format_map(        s.split(
 s.__le__(            s.index(             s.splitlines(
 s.__len__(           s.isalnum(           s.startswith(
 s.__lt__(            s.isalpha(           s.strip(
 s.__mod__(           s.isdecimal(         s.swapcase(
 s.__mul__(           s.isdigit(           s.title(
 s.__ne__(            s.isidentifier(      s.translate(
 s.__new__(           s.islower(           s.upper(
 s.__reduce__(        s.isnumeric(         s.zfill(
 s.__reduce_ex__(     s.isprintable(       
 s.__repr__(          s.isspace(           
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem with all methods indicated here is that you CAN'T be sure that a method doesn't exist.</p>
<p>In Python you can intercept the dot calling thru <code>__getattr__</code> and <code>__getattribute__</code>, making it possible to create method "at runtime"</p>
<p>Exemple:</p>
<pre><code>class MoreMethod(object):
    def some_method(self, x):
        return x
    def __getattr__(self, *args):
        return lambda x: x*2
</code></pre>
<p>If you execute it, you can call method non existing in the object dictionary...</p>
<pre><code>&gt;&gt;&gt; o = MoreMethod()
&gt;&gt;&gt; o.some_method(5)
5
&gt;&gt;&gt; dir(o)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattr__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'some_method']
&gt;&gt;&gt; o.i_dont_care_of_the_name(5)
10
</code></pre>
<p>And it's why you use the <a href="https://docs.python.org/2/glossary.html#term-eafp" rel="nofollow">Easier to ask for forgiveness than permission</a> paradigms in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest way to get list of methods of any object is to use <code>help()</code> command.</p>
<pre><code>%help(object)
</code></pre>
<p>It will list out all the available/important methods associated with that object.</p>
<p>For example:</p>
<pre><code>help(str)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One can create a <code>getAttrs</code> function that will return an object's callable property names</p>
<pre><code>def getAttrs(object):
  return filter(lambda m: callable(getattr(object, m)), dir(object))

print getAttrs('Foo bar'.split(' '))
</code></pre>
<p>That'd return</p>
<pre><code>['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',
 '__delslice__', '__eq__', '__format__', '__ge__', '__getattribute__', 
 '__getitem__', '__getslice__', '__gt__', '__iadd__', '__imul__', '__init__', 
 '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', 
 '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', 
 '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', 
 '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 
 'remove', 'reverse', 'sort']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no reliable way to list all object's methods. <code>dir(object)</code> is usually useful, but in some cases it may not list all methods. According to <a href="https://docs.python.org/2/library/functions.html#dir" rel="nofollow"><code>dir()</code> documentation</a>: <em>"With an argument, <strong>attempt</strong> to return a list of valid attributes for that object."</em></p>
<p>Checking that method exists can be done by <code>callable(getattr(object, method))</code> as already mentioned there.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>...is there at least an easy way to check if it has a particular method other than simply checking if an error occurs when the method is called</p>
</blockquote>
<p>While "<a href="http://docs.python.org/2/glossary.html#term-eafp" rel="nofollow">Easier to ask for forgiveness than permission</a>" is certainly the Pythonic way, what you are looking for maybe:</p>
<pre><code>d={'foo':'bar', 'spam':'eggs'}
if 'get' in dir(d):
    d.get('foo')
# OUT: 'bar'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Take a list as an object</p>
<pre><code>obj = []
</code></pre>
<p><code>list(filter(lambda x:callable(getattr(obj,x)),obj.__dir__()))</code></p>
<p>You get:</p>
<pre><code>['__add__',
 '__class__',
 '__contains__',
 '__delattr__',
 '__delitem__',
 '__dir__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__getitem__',
 '__gt__',
 '__iadd__',
 '__imul__',
 '__init__',
 '__init_subclass__',
 '__iter__',
 '__le__',
 '__len__',
 '__lt__',
 '__mul__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__reversed__',
 '__rmul__',
 '__setattr__',
 '__setitem__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 'append',
 'clear',
 'copy',
 'count',
 'extend',
 'index',
 'insert',
 'pop',
 'remove',
 'reverse',
 'sort']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In order to search for a specific method in a whole module</p>
<pre><code>for method in dir(module) :
  if "keyword_of_methode" in method :
   print(method, end="\n")
</code></pre>
</div>
<span class="comment-copy">Relevant: <a href="https://stackoverflow.com/q/46033277/1959808">stackoverflow.com/q/46033277/1959808</a></span>
<span class="comment-copy">I'm not sure what you are trying to accomplish here, but having "method" in those 3 places doesn't make sense to me. Replacing "object" with "the object you're interested in" will return all the callables for any object with a single callable. Please help me understand the point.</span>
<span class="comment-copy">Maybe you meant <code>[getattr(obj, method) for method in dir(obj) if method==method_name and callable(getattr(obj, method_name))]</code> which could be used like: 'obj={'foo':'bar'}; method_name='get'; x=[getattr(obj, method) for method in dir(obj) if method==method_name and callable(getattr(obj, method_name))];' and then <code>if(len(x)): x[0]('foo')</code> ...I know that is really nasty on one line, but comments don't allow line breaks</span>
<span class="comment-copy">It's a list comprehension, returning a list of methods where method is an item in the list returned by dir(object), and where each method is added to the list only if getattr(object,method) returns a callable.</span>
<span class="comment-copy">How exactly do you use this? To say print a list of the methods.</span>
<span class="comment-copy">@marsh To print the methods: <code>print [method for method in dir(object) if callable(getattr(object, method))]</code>.</span>
<span class="comment-copy"><code>hasattr</code> helped my use case to find if python object has particular member variable or method.</span>
<span class="comment-copy">It also displays the attributes of the object, so if you want to specifically find methods, it will not work.</span>
<span class="comment-copy">Yes. Agreed. But, I am not aware of any other technique to only get the list of methods. Maybe the best idea is to get the list of both attributes and methods and then use &lt;hasattr(object, "method_name"&gt; to further filter it out?</span>
<span class="comment-copy">See the accepted answer</span>
<span class="comment-copy">@neuronet, I'm trying to run the accepted answer but getting an <code>AttributeError: module 'pandas.core.common' has no attribute 'AbstractMethodError'</code>. Any ideas? See deets at  <a href="https://stackoverflow.com/q/54713287/9677043">stackoverflow.com/q/54713287/9677043</a>. +1 to @Pawan Kumar b/c the answer works, and to @ljs for the promise of a filtered list of just the methods.</span>
<span class="comment-copy">since the OP is looking for a method and not just and attribute, I think you want to go a step further with: <code>if hasattr(obj,method) and callable(getattr(obj,method)):</code></span>
<span class="comment-copy">Contributed? Yours answer worked for me in Python 2.7.12, so hell yeah!</span>
<span class="comment-copy">Relevant answer: <a href="https://stackoverflow.com/a/1911287/1959808">stackoverflow.com/a/1911287/1959808</a></span>
