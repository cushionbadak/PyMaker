<div class="post-text" itemprop="text">
<p>Code first:</p>
<pre><code>def another_func(func):
    func()


def outer_func(pa=1, pb=2):
    def inner_func():
        print(pa)
    print(type(inner_func))
    another_func(inner_func)

if __name__ == '__main__':
    outer_func()
    #print "1"
</code></pre>
<p>I am not sure that, "inner_func" calls a parameter of "outer_func", but that is in the body of "outer_func". How can it "know" there is a "pa" when called by another_func?</p>
<p>I mean, what is actually passed to another_func when its called in "outer_func"? It seems there is something more than a reference of the function object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Function objects in Python aren't just functions, they're <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="nofollow noreferrer"><em>closures</em></a>:<sup>1</sup> they carry around a reference to the local environment where the <code>def</code> statement was executed.</p>
<p>In particular, local variables from inside <code>outer_func</code> can be accessed from inside <code>inner_func</code>. (Even if you <code>return inner_func</code>, those values are kept alive so the closure will still work, for as long as <code>inner_func</code> is alive.)</p>
<p>If you add a <code>nonlocal</code> statement inside <code>inner_func</code>, it can even reassign the local variables from the body of <code>outer_func</code>.</p>
<hr/>
<p>How does this work?</p>
<p>Well, a <code>def</code> statement<sup>2</sup> is just a statement, like any other. What it does is something like this:</p>
<pre><code>inner_func = _make_closure(&lt;code from compiling inner_func body&gt;, locals())
</code></pre>
<p>That <code>&lt;code from compiling inner_func body&gt;</code> is actually a constant value—the compiler compiles the body of every function in your module into constant <code>code</code> objects at <code>import</code> time.</p>
<p>But the function object that comes back from that <code>_make_closure</code> is a new thing that's created on the fly, and it has a reference to the local variables baked into it. Every time you run <code>outer_func</code>, it creates a new <code>inner_func</code> closure from the same <code>&lt;code&gt;</code>, each one capturing the current local environment.</p>
<hr/>
<p>The details are a little more complicated—and, to some extent, they differ between implementations, so this will be CPython-specific.</p>
<p>Part of the compiler's job is figuring out what kind of variable each name in a function is. You may have read the rules on globals vs. locals (a variable is local if and only if you have an assignment for the name somewhere in the function body, and there's no <code>global</code> statement). But closures make things more complicated. </p>
<ul>
<li><p>If a variable <em>would</em> have been local, but a nested function references the variable without assigning to it, or has a <code>nonlocal</code> statement, then it's a cell variable in the outer function, and a free variable in the inner function.<sup>3</sup></p></li>
<li><p>When the interpreter calls a function, it creates a <code>frame</code> object that holds the local namespace—the references to all of the function's local variables. </p></li>
<li><p>But cell variables are special: the interpreter creates a special <code>cell</code> object for each one, and a reference to that cell goes into the namespace, so there's an extra dereference in front of the value every time you access or change it. </p></li>
<li><p>And what that <code>_make_closure</code> pseudo-code above does is to copy the cells from the outer function's frame to a special attribute on the nested function called <code>__closure__</code>.</p></li>
<li><p>Then, when you call the inner function, the interpreter copies those cells from the <code>__closure__</code> into the frame for that function. </p></li>
<li><p>So, the outer function's frame and the inner function's frame both have references to the same cells, which is how they can share variables.</p></li>
</ul>
<p>From more on this, see the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> module's docs, which show you how to find things like <code>__closure__</code> and <code>co_freevars</code> in your interactive interpreter, and the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> module which lets you look at the actual bytecode that your functions get compiled to.</p>
<hr/>
<p><sub>1. This is one of those words that has a slew of related but different meanings. "Closure" can mean the technique of capturing the local namespace in a function, or it can mean the captured namespace, or it can mean the function with a captured namespace attached to it, or it can mean one of the variables in the captured namespace. Usually it's obvious which one you mean from context. If not, you have to say something like "closure capture" or "closure function" or "closure variable".</sub></p>
<p><sub>2. In case you're wondering, <code>lambda</code> expressions work exactly the same way as <code>def</code> statements. And <code>class</code> definitions are not identical, but similar.</sub></p>
<p><sub>3. It's actually still more complicated if you have multiple layers of nesting, but let's ignore that.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>You seem to be confusing the code if the function with the function object. The code object is evaluated only once, when the source file is read. However, a new function object called <code>inner_func</code> is created every time <code>outer_func</code> is called. This happens because a <code>def</code> statement is a type of assignment: it associates a function object with the specified name.</p>
<p>The function object contains a reference to its code as a matter of course, along with references to all the namespaces it will need to operate, including it's parent's nonlocal namespace and the global module namespace.</p>
<p>So the value of <code>pa</code> in <code>inner_func</code> is going to be whatever it is in <code>outer_func</code> at the time of calling. The reference is to the namespace, not the name itself. If <code>outer_func</code> returns (think decorators), the namespace will be fixed, and only accessible through <code>inner_func</code>'s special reference to it.</p>
</div>
<span class="comment-copy">any variables the parent scope can read, the inner scope can also read ... however editing the values gets wonky with scope... there is no way to replace the parents locally scoped variables .... the inner function can only edit variables that are local to it or are in the global space and explicitly invoked globally</span>
<span class="comment-copy">@JoranBeasley: <code>nonlocal</code> lets you assign to closure variables in Python 3.</span>
<span class="comment-copy">whoops i forgot about that :P i misspoke</span>
<span class="comment-copy">Hope you don't mind the title change.</span>
<span class="comment-copy">What level of detail are you looking for here? I wrote an answer that starts kind of near the surface level and goes about halfway down, but if you're interested in things like how the compiler knows when to emit <code>LOAD_DEREF</code> and what the C API is for dealing with cell objects, or if you just need a gentle introduction to the idea of closures at a language-agnostic level, it's probably not ideal.</span>
<span class="comment-copy">Beat me to it :)</span>
<span class="comment-copy">It's very detailed, and i think i may need more reading then. Thank you for your help!</span>
<span class="comment-copy">Nice job keeping the implementation out of the concept. A Python interpreter could use something like a chain map for its locals environments (as some Lisps do), and it would be perfectly valid, and your explanation would still fit that perfectly, while mine really wouldn't. (Also, good point about function objects also carrying around <code>__globals__</code>.)</span>
<span class="comment-copy">Precise ! Thank you for your help!</span>
<span class="comment-copy">@abarnert. Thanks for the high praise</span>
