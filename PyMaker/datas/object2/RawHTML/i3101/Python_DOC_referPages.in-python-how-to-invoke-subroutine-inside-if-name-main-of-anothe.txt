<div class="post-text" itemprop="text">
<p>Assuming that I am in a python console and want to launch another python program in the same process. The python program looks like this:</p>
<pre><code>import sys

if __name__ == '__main__':
      args = sys.argv
      for key in args:
          print(key)
</code></pre>
<p>and I'm not allowed to modify it.</p>
<p>What is the proper way of doing this? Can I call it's 'main function' with a different list of arguments like C++ or Java?</p>
<p>I'm not against method are are considered hacking. Python is a highly extendable interpreted language and I'll do whatever necessary to bypass this restriction</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't "call its main function", because it doesn't have one.</p>
<p>In fact, the usual way to handle this is to move all those code into a function, then make the <code>__main__</code> guard code just call that:</p>
<pre><code>def main(args):
    for key in args:
        print(key)

if __name__ == '__main__':
    main(sys.argv)
</code></pre>
<p>Then you <em>can</em> call its main function, passing it any args you want.</p>
<p>But if you can't fix the file, that won't work.</p>
<hr/>
<p>So, what <em>can</em> you do? It all depends on how exactly you need to follow the usual <code>python another.py</code> semantics.</p>
<hr/>
<p>The quick&amp;dirty way is to do what <a href="https://stackoverflow.com/a/51550500/908494">blhsing's answer</a> suggests: read the file, and <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code></a> it with the <a href="https://docs.python.org/3/library/functions.html#globals" rel="nofollow noreferrer">globals</a> from your own script:</p>
<pre><code>with open('another.py') as f:
    exec(f.read(), globals())
</code></pre>
<p>Notice that this is going to leave <code>sys.argv</code> untouched. You can, of course, manually set it to something else first:</p>
<pre><code>_argv = sys.argv
sys.argv = ['args', 'i', 'want', 'it', 'to', 'see']
try:
    with open('another.py') as f:
        exec(f.read(), globals())
finally:
    sys.argv = _argv
</code></pre>
<hr/>
<p>If you're doing this from another module, rather than from your top-level script, that won't work, but with a slight modification, it will:</p>
<pre><code>with open('another.py') as f:
    exec(f.read(), sys.modules['__main__'].__dict__)
</code></pre>
<hr/>
<p>But you may be better off creating a clean global namespace. The script may not expect to have your globals sitting aroundâ€”and it may change things you don't want it to change. This is just as easy:</p>
<pre><code>with open('another.py') as f:
    exec(f.read(), {})
</code></pre>
<p>(Note that this will still automatically inherit the current <a href="https://docs.python.org/3/library/builtins.html#module-builtins" rel="nofollow noreferrer"><code>builtins</code></a>, which you usually want. If you <em>don't</em> want that for some reason, see the <code>exec</code> docs.)</p>
<hr/>
<p>If you want to guarantee that you're executing it exactly the same way as running a script normally, use the <a href="https://docs.python.org/3/library/runpy.html" rel="nofollow noreferrer"><code>runpy</code></a> module.</p>
<p>When you run <code>python -m another</code>, what it ultimately does is:</p>
<pre><code>runpy.run_module(sys.argv[0], run_name="__main__", alter_sys=True)
</code></pre>
<p>So, you can do the same thing manually:</p>
<pre><code>runpy.run_module('another', run_name='__main__')
</code></pre>
<p>Whether you want to add <code>alter_sys=True</code> depends on what you're after. Without it, if the script tries to access <code>sys.argv</code> (as your script does) or <code>sys.modules['__main__']</code>, it will see your values, instead of its own.</p>
<hr/>
<p>If you want to emulate <code>python another.py</code>, you'd want to use <a href="https://docs.python.org/3/library/runpy.html" rel="nofollow noreferrer"><code>importlib</code></a> to create a full <code>__spec__</code> and related objects, then calls <code>runpy.run_path</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can read the file and use <code>exec</code> to execute the code with the current globals so that <code>__name__ == '__main__'</code> would be true.</p>
<pre><code>exec(open('file.py').read(), globals())
</code></pre>
</div>
<span class="comment-copy">To clarify, are you not allowed to touch the python file at all? Sounds like some CTF question to me.</span>
<span class="comment-copy">Run it as a script, as it is intended to be run.</span>
<span class="comment-copy">@pkqxdd, no I can't, specifically, the original untouchable file is mavproxy.py. this is definitely not  a CTF question</span>
<span class="comment-copy">thanks a lot! very comprehensive and exactly what I'm looking for.</span>
