<div class="post-text" itemprop="text">
<p>I have the following code, in which I simply have a decorator for caching a function's results, and as a concrete implementation, I used the Fibonacci function.</p>
<p>After playing around with the code, I wanted to print the <code>cache</code> variable, that's initiated in the <code>cache</code> wrapper.
(It's not because I suspect the cache might be faulty, I simply want to know how to <strong>access</strong> it without going into debug mode and put a breakpoint inside the decorator)</p>
<p>I tried to explore the <code>fib_w_cache</code> function in debug mode, which is supposed to actually be the wrapped <code>fib_w_cache</code>, but with no success.</p>
<pre><code>import timeit


def cache(f, cache = dict()):

    def args_to_str(*args, **kwargs):
        return str(args) + str(kwargs)

    def wrapper(*args, **kwargs):
        args_str = args_to_str(*args, **kwargs)
        if args_str in cache:
            #print("cache used for: %s" % args_str)
            return cache[args_str]
        else:
            val = f(*args, **kwargs)
            cache[args_str] = val
            return val
    return wrapper


@cache
def fib_w_cache(n):
    if n == 0: return 0
    elif n == 1: return 1
    else:
        return fib_w_cache(n-2) + fib_w_cache(n-1)


def fib_wo_cache(n):
    if n == 0: return 0
    elif n == 1: return 1
    else:
        return fib_wo_cache(n-1) + fib_wo_cache(n-2)


print(timeit.timeit('[fib_wo_cache(i) for i in range(0,30)]', globals=globals(), number=1))
print(timeit.timeit('[fib_w_cache(i) for i in range(0,30)]', globals=globals(), number=1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>cache</code> is of course a perfectly normal local variable in scope within the <code>cache</code> function, and a perfectly normal nonlocal cellvar in scope within the <code>wrapper</code> function, so if you want to access the value from there, you just do it—as you already are.</p>
<p>But what if you wanted to access it from somewhere else? Then there are two options.</p>
<hr/>
<p>First, <code>cache</code> happens to be defined at the global level, meaning any code anywhere (that hasn't hidden it with a local variable named <code>cache</code>) can access the function object.</p>
<p>And if you're trying to access the values of a function's default parameters from outside the function, they're available in the attributes of the function object. The <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> module docs explain the inspection-oriented attributes of each builtin type:</p>
<ul>
<li><code>__defaults__</code> is a sequence of the values for all positional-or-keyword parameters, in order.</li>
<li><code>__kwdefaults__</code> is a mapping from keywords to values for all keyword-only parameters.</li>
</ul>
<p>So:</p>
<pre><code>&gt;&gt;&gt; def f(a, b=0, c=1, *, d=2, e=3): pass
&gt;&gt;&gt; f.__defaults__
(0, 1)
&gt;&gt;&gt; f.__kwdefaults__
{'e': 3, 'd': 2}
</code></pre>
<p>So, for a simple case where you know there's exactly one default value and know which argument it belongs to, all you need is:</p>
<pre><code>&gt;&gt;&gt; cache.__defaults__[0]
{}
</code></pre>
<p>If you need to do something more complicated or dynamic, like get the default value for <code>c</code> in the <code>f</code> function above, you need to dig into other information—the only way to know that <code>c</code>'s default value will be the second one in <code>__defaults__</code> is to look at the attributes of the function's code object, like <code>f.__code__.co_varnames</code>, and figure it out from there. But usually, it's better to just use the <code>inspect</code> module's helpers. For example:</p>
<pre><code>&gt;&gt;&gt; inspect.signature(f).parameters['c'].default
1
&gt;&gt;&gt; inspect.signature(cache).parameters['cache'].default
{}
</code></pre>
<hr/>
<p>Alternatively, if you're trying to access the cache from inside <code>fib_w_cache</code>, while there's no variable in lexical scope in that function body you can look at, you do know that the function body is only called by the decorator <code>wrapper</code>, and it <em>is</em> available there.</p>
<p>So, you can get your stack frame</p>
<pre><code>frame = inspect.currentframe()
</code></pre>
<p>… follow it back to your caller:</p>
<pre><code>back = frame.f_back
</code></pre>
<p>… and grab it from that frame's locals:</p>
<pre><code>back.f_locals['cache']
</code></pre>
<p>It's worth noting that <code>f_locals</code> works like the <a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer"><code>locals</code></a> function: it's actually a copy of the internal locals storage, so modifying it may have no effect, and that copy flattens nonlocal cell variables to regular local variables. If you wanted to access the actual cell variable, you'd have to grub around in things like <code>back.f_code.co_freevars</code> to get the index and then dig it out of the function object's <code>__closure__</code>. But usually, you don't care about that.</p>
</div>
<div class="post-text" itemprop="text">
<p>I admit this is not an "elegant" solution in a sense, but keep in mind that python functions are also objects. So with some slight modification to your code, I managed to inject the cache as an attribute of a decorated function:</p>
<pre><code>import timeit


def cache(f):

    def args_to_str(*args, **kwargs):
        return str(args) + str(kwargs)

    def wrapper(*args, **kwargs):
        args_str = args_to_str(*args, **kwargs)
        if args_str in wrapper._cache:
            #print("cache used for: %s" % args_str)
            return wrapper._cache[args_str]
        else:
            val = f(*args, **kwargs)
            wrapper._cache[args_str] = val
            return val
    wrapper._cache = {}
    return wrapper


@cache
def fib_w_cache(n):
    if n == 0: return 0
    elif n == 1: return 1
    else:
        return fib_w_cache(n-2) + fib_w_cache(n-1)

@cache
def fib_w_cache_1(n):
    if n == 0: return 0
    elif n == 1: return 1
    else:
        return fib_w_cache(n-2) + fib_w_cache(n-1)


def fib_wo_cache(n):
    if n == 0: return 0
    elif n == 1: return 1
    else:
        return fib_wo_cache(n-1) + fib_wo_cache(n-2)

print(timeit.timeit('[fib_wo_cache(i) for i in range(0,30)]', globals=globals(), number=1))
print(timeit.timeit('[fib_w_cache(i) for i in range(0,30)]', globals=globals(), number=1))
print(fib_w_cache._cache)
print(fib_w_cache_1._cache) # to prove that caches are different instances for different functions
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just for a sake of completeness, python has caching decorator built-in in <code>functools.lru_cache</code> with some inspecting mechanisms:</p>
<pre><code>from functools import lru_cache

@lru_cache(maxsize=None)
def fib_w_cache(n):
    if n == 0: return 0
    elif n == 1: return 1
    else:
        return fib_w_cache(n-2) + fib_w_cache(n-1)

print('fib_w_cache(10) = ', fib_w_cache(10))
print(fib_w_cache.cache_info())
</code></pre>
<p>Prints:</p>
<pre><code>fib_w_cache(10) =  55
CacheInfo(hits=8, misses=11, maxsize=None, currsize=11)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I managed to find a solution (in some sense by @Patrick Haugh's advice).</p>
<p>I simply accessed <code>cache.__defaults__[0]</code> which holds the cache's dict.</p>
<p>The insights about the shared cache and how to avoid it we're also quite useful.</p>
<p>Just as a note, the <code>cache</code> dictionary can only be accessed through the <code>cache</code> function object. It cannot be accessed through the decorated functions (at least as far as I understand). It logically aligns well with the fact that the cache is shared in my implementation, where on the other hand, in the alternative implementation that was proposed, it is local per decorated function.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make a class into a wrapper. </p>
<pre><code>def args_to_str(*args, **kwargs):
    return str(args) + str(kwargs)

class Cache(object):
    def __init__(self, func):
        self.func = func
        self.cache = {}

    def __call__(self, *args, **kwargs):
        args_str = args_to_str(*args, **kwargs)
        if args_str in self.cache:
            return self.cache[args_str]
        else:
            val = self.func(*args, **kwargs)
            self.cache[args_str] = val
            return val
</code></pre>
<p>Each function has its own cache. you can access it by calling <code>function.cache</code>.  This also allows for any methods you wish to attach to your function.  </p>
<p>If you wanted all decorated functions to share the same cache, you could use a class variable instead of an instance variable:</p>
<pre><code>class SharedCache(object):
    cache = {}
    def __init__(self, func):
        self.func = func

    #rest of the the code is the same


@SharedCache
def function_1(stuff):
    things
</code></pre>
</div>
<span class="comment-copy">What do you mean by "tried to explore the fib_w_cache function in debug mode"?</span>
<span class="comment-copy">Also, where are you trying to print the <code>cache</code> variable? It's a perfectly normal cellvar in scope within the <code>wrapper</code> body. Of course it's not available inside the <code>fib_w_cache</code>, but if you really need to get it, the calling stack frame is that <code>wrapper</code>, so you can always <code>inspect</code> your way up to it. You can also access it from the global environment as <code>cache.__defaults__[0]</code></span>
<span class="comment-copy">Two side notes: (1) The mutable default value means that if you apply the same decorator to a bunch of functions, they're all going to share the same <code>cache</code> value; is that really what you wanted? (2) Calling both the function and the parameter <code>cache</code> is just asking for confusion. The compiler is fine with it, but a human reader using the debugger?</span>
<span class="comment-copy">I think a sensible approach would be to specify a <code>cache_=dict()</code> of each <code>wrapper</code>, and then you can see that object with <code>fid_w_cache.__defaults__</code></span>
<span class="comment-copy">@abarnert You are perfectly correct. I know that two functions sharing that decorator will also share the same cache, and for now I can ignore the source of confusion in the variables' names (that code is just me trying to understand things, not part of any other project). I specifically want to understand how to access the mutable keyword argument <code>cache</code>, since I know it certainly lives somewhere (I guess that it's inside the <code>cache</code> function object), but not sure how to do it.</span>
<span class="comment-copy">You actually regarded another question I thought about when writing this one, regarding the use of two different functions. Since mutable keyword arguments are instantiated only once, in my original code the cache would be shared between all the functions that hold the cache decorator. So in terms of correctness your code is undoubtedly better, and I understand it perfectly Yet, I'm interested in the case I mentioned, specifically on how to access a mutable keyword argument without explicitly printing it from withing the function. I guess it would be through the <code>cache</code> function object.</span>
<span class="comment-copy">@GoldenSpecOps You can access it by <code>decorated_function._cache</code>, as shown in the last line of my example. It is a <code>dict</code> object.</span>
<span class="comment-copy">As I mentioned, I only care about accessing this variable, the cache mechanism could have been replaced with any decorator that stores a mutable keyword argument.</span>
<span class="comment-copy">Turning the decorator into a class is practically the same as the solutions that were already offered, the <code>Cache</code> and <code>SharedCache</code> are no different than putting the <code>cache</code> variable as a keyword argument for the decorator itself, and putting it as an attribute of the wrapper, respectively.</span>
<span class="comment-copy">@EliranAbdoo yes, of course.  This is a common enough and legitimate alternative.  It offers some different possibilities in terms of easily writing methods and other controls of the function, so, even though it doesn't solve the problem any better, I thought it would be nice to tack on as a separate solution.</span>
