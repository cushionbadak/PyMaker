<div class="post-text" itemprop="text">
<p>In Python 3.6.5, this works fine:</p>
<pre><code>command = "ffmpeg -i {0} -vsync 0 -q:v 2 -vf select=\"eq(pict_type\,PICT_TYPE_I)\" -r 30 {1}/frame%03d.jpg".format(file_path, output_path)
</code></pre>
<p>That's obviously a long line, so I used a line continuation:</p>
<pre><code>command = "ffmpeg -i {0} -vsync 0 -q:v 2 -vf select=\"eq(pict_type\,PICT_TYPE_I)\" -r 30 {1}/frame%03d.jpg"\
    .format(file_path, output_path)
</code></pre>
<p>However, at startup, this generates a <code>DeprecationWarning</code>:</p>
<pre><code> DeprecationWarning: invalid escape sequence \,
  command = "ffmpeg -i {0} -vsync 0 -q:v 2 -vf select=\"eq(pict_type\,PICT_TYPE_I)\" -r 30 {1}/frame%03d.jpg"\
</code></pre>
<p>This does <em>not</em>, however:</p>
<pre><code>command = "foo {0} bar {1}"\
    .format(file_path, output_path)
</code></pre>
<p>I use line continuations all over the rest of the project; none have resulted in <code>DeprecationWarning</code>. Other questions like <a href="https://stackoverflow.com/questions/50504500/deprecationwarning-invalid-escape-sequence-what-to-use-instead-of-d">this one</a> mention this warning, but none for continuation characters that I can find.</p>
<p>What causes this warning, and why does it only appear in this very narrow case?</p>
<p><strong>Edit</strong>: This has nothing to do with the line continuation. The reason the error presented to me only some of the time has to do with Django's <code>runserver</code>. The first time <code>runserver</code> is run, the error is not reported. But if a change causes a reload, then the error is reported when the reloader runs.</p>
</div>
<div class="post-text" itemprop="text">
<p>This has nothing to do with your line continuation, it's with using <code>\,</code> as an escape sequence in your string.</p>
<p>The warning explicitly includes <code>\,</code>:</p>
<pre><code>DeprecationWarning: invalid escape sequence \,
</code></pre>
<p>And that's why your later example doesn't warn: because the string doesn't have a <code>\,</code> or other unrecognized escape sequence in it.</p>
<p>As explained in the docs for <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow noreferrer">String and Byte literals</a>:</p>
<blockquote>
<p>Changed in version 3.6: Unrecognized escape sequences produce a <code>DeprecationWarning</code>. In some future version of Python they will be a <code>SyntaxError</code>.</p>
</blockquote>
<p>This change is mentioned in <a href="https://docs.python.org/3/whatsnew/3.6.html#deprecated-python-behavior" rel="nofollow noreferrer">What's New in Python 3.6</a>, with a link to <a href="https://bugs.python.org/issue27364" rel="nofollow noreferrer">issue #27364</a>, which links to <a href="http://comments.gmane.org/gmane.comp.python.devel/151612" rel="nofollow noreferrer">an earlier discussion on the -dev mailing list</a>.</p>
<p>Traditionally, Python allowed unrecognized escape sequences in string literals and just processed them as if they weren't escapes, so <code>\,</code> literally means a backslash and a comma, because this makes it easier to see what's going wrong when you print out the string in the debugger.</p>
<p>But this leads to all kinds of confusion, especially for Windows users (who get away with <code>'C:\Spam'</code>, <code>'C:\spam'</code>, and <code>'C:\Vikings'</code>, but get errors with <code>'C:\vikings'</code>), and for people coming from any of the huge number of languages that follow C-style escape rules (where <code>\,</code> would mean just a commaâ€”although most C compilers will generate a warning for that), which is presumably why you now get a warning.</p>
</div>
<div class="post-text" itemprop="text">
<p>try using lists for commands:</p>
<pre><code>command = [
    "ffmpeg",
    "-i", file_path,
    "-vsync", "0", 
    "-q:v", "2",
    "-vf", 'select="eq(pict_type,PICT_TYPE_I)"',
    "-r", "30", 
    os.path.join(output_path, "frame%03d.jpg"),
]
</code></pre>
<p>Then call it without using <code>shell=True</code>:</p>
<pre><code>subprocess.run(command)
</code></pre>
<p>By doing this, you have multiple advantages:</p>
<ol>
<li>You are <strong>free from quote and escape hell</strong> - you don't have to add quotes or escape anything. Spaces are no longer delimiters, the parameters will be passed as in the list.</li>
<li>You don't have to use string interpolation (<code>.format</code>) because you can just pass the parameter separately to the list.</li>
<li>By not using the shell, you avoid executing one extra process for nothing - why execute a shell to run your command when you can run it directly?</li>
</ol>
</div>
<span class="comment-copy">That explains it; I figured it was something like that. But why does the presence of a line continuation character impact whether that's outputted or not?</span>
<span class="comment-copy">@Ares I don't think it does. I can't reproduce that behavior; any situation where I get a warning for the second one, I get a warning if I change it to the first one. Can you provide a reproducible test case that shows a difference? If so, it's probably a bug that should be reported.</span>
<span class="comment-copy">@Ares: It doesn't matter whether the line continuation character is there or not (I reproduce either way as long as <code>DeprecationWarning</code>s are enabled). If you're launching or using the code in different ways, you might have different warning levels set though (by default, <code>DeprecationWarning</code>s aren't emitted, but one of your tests might be enabling it).</span>
<span class="comment-copy">@abarnert et al; I figured it out; the issue has to do with Django's reloader behavior. The first time <code>runserver</code> executes, no warning appears, but when the reloader runs, the warning appears. I incorrectly attributed the behavior to the changes made in my code rather than Django's reloader.</span>
<span class="comment-copy">@Ares: They likely set the handling behavior for <code>DeprecationWarning</code> to either <code>module</code> (prints when first raised in a given module, then silent thereafter) or <code>once</code> (prints each class of warning the first time it occurs program-wide, then never again). Either way would get the behavior you describe.</span>
<span class="comment-copy">While this is 100% true, it doesn't explain the cause of the problem, and it's not necessarily the correct answer (e.g. if <code>subprocess</code> isn't being used directly, it's possible they're either printing this for some reason, or passing it to some third party API).</span>
<span class="comment-copy">@ShadowRanger Agreed, but I think this answer will really help the OP, most people use commands with <code>subprocess</code> and (argh) <code>os.system</code>.</span>
<span class="comment-copy">@nosklo I suggested <code>os.system</code> should be moved to <code>subprocess.system</code> in 3.0. Guido's reply was something like: Nice idea, but nothing humanly possible will stop people from finding that function, calling it, and then asking why they can't capture the output. It's a law of nature.</span>
