<div class="post-text" itemprop="text">
<p>I have a particular problem, but I will make the example more general.
I have a <strong>Parent</strong> class with a mandatory constructor parameter and a few optional ones, each with a default value. Then, I inherit <strong>Child</strong> from it and add a mandatory parameter, and inherit <strong>GrandChild</strong> from <strong>Child</strong> and add another mandatory parameter to the constructor. The result is similar to this:</p>
<pre><code>class Parent():

    def __init__(self, arg1, opt_arg1='opt_arg1_default_val', opt_arg2='opt_arg2_default_val',
                 opt_arg3='opt_arg3_default_val', opt_arg4='opt_arg4_default_val'):
        self.arg1 = arg1
        self.opt_arg1 = opt_arg1
        self.opt_arg2 = opt_arg2
        self.opt_arg3 = opt_arg3
        self.opt_arg4 = opt_arg4


class Child(Parent):
    def __init__(self, arg1, arg2, opt_arg1, opt_arg2, opt_arg3, opt_arg4):
        super().__init__(arg1, opt_arg1, opt_arg2, opt_arg3, opt_arg4)
        self.arg2 = arg2

class GrandChild(Child):
    def __init__(self, arg1, arg2, arg3, opt_arg1, opt_arg2, opt_arg3, opt_arg4):
        super().__init__(arg1, arg2, opt_arg1, opt_arg2, opt_arg3, opt_arg4)
        self.arg3 = arg3
</code></pre>
<p>The problem is that this looks rather ugly, especially if I want to inherit more classes from Child, I'd have to copy/paste all the arguments in that new class's constructor.</p>
<p>In search for a solution, I found <a href="https://stackoverflow.com/questions/35262673/passing-arguments-to-superclass-constructor-without-repeating-them-in-childclass">here</a> that I can solve this problem using **kwargs like so:</p>
<pre><code>class Parent():

    def __init__(self, arg1, opt_arg1='opt_arg1_default_val', opt_arg2='opt_arg2_default_val',
                 opt_arg3='opt_arg3_default_val', opt_arg4='opt_arg4_default_val'):
        self.arg1 = arg1
        self.opt_arg1 = opt_arg1
        self.opt_arg2 = opt_arg2
        self.opt_arg3 = opt_arg3
        self.opt_arg4 = opt_arg4


class Child(Parent):
    def __init__(self, arg1, arg2, **kwargs):
        super().__init__(arg1, **kwargs)
        self.arg2 = arg2

class GrandChild(Child):
    def __init__(self, arg1, arg2, arg3,**kwargs):
        super().__init__(arg1, arg2,**kwargs)
        self.arg3 = arg3
</code></pre>
<p>However, I am not sure if this is the right way.</p>
<p>There is also a slight inconvenience while creating objects of these classes. I am using PyCharm to develop, and in this case the IDE has a useful method of displaying a function/class constructor arguments. For instance, in the first example, </p>
<p><a href="https://i.stack.imgur.com/kaoLl.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/kaoLl.png"/></a></p>
<p>This makes it much easier to develop and can help future developers as well since they can see what other arguments the function has. However, in the second example, the optional arguments are not shown anymore:</p>
<p><a href="https://i.stack.imgur.com/UaomH.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/UaomH.png"/></a></p>
<p>And I do not think it is a good practice to use **kwargs in this case, since one would have to dig deeper into the code up to the Parent class to check what optional arguments it has.</p>
<p>I've also looked into using the Builder pattern, but then all I do is move the arguments list from my classes to builder classes, and I have the same problem, builders with lots of arguments that when inherited will create even more arguments on top of the already existing ones. Also in Python, as much as I see, Builder doesn't really make much sense considering all class members are public and can be accessed without needing setters and getters.</p>
<p>Any ideas on how to solve this constructor problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>The basic idea is to write code that generates the <code>__init__</code> method for you, with all the parameters specified explicitly rather than via <code>*args</code> and/or <code>**kwargs</code>, and without even needing to repeat yourself with all those <code>self.arg1 = arg1</code> lines.</p>
<p>And, ideally, it can make it easy to add type annotations that PyCharm can use for popup hints and/or static type checking.<sup>1</sup></p>
<p>And, while you're at it, why not build a <code>__repr__</code> that displays the same values? And maybe even an <code>__eq__</code>, and a <code>__hash__</code>, and maybe lexicographical comparison operators, and conversion to and from a <code>dict</code> whose keys match the attributes for each JSON persistence, and…</p>
<p>Or, even better, use a library that takes care of that for you.</p>
<p>Python 3.7 comes with such a library, <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer"><code>dataclasses</code></a>. Or you can use a third-party library like <a href="https://pypi.org/project/attrs/" rel="nofollow noreferrer"><code>attrs</code></a>, that works with Python 3.4 and (with some limitations) 2.7. Or, for simple cases (where your objects are immutable, and you want them to work like a tuple of their attributes in specified order), you can use <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a>, which works back to 3.0 and 2.6.</p>
<p>Unfortunately, <code>dataclasses</code> doesn't quite work for your use case. If you just write this:</p>
<pre><code>from dataclasses import dataclass

@dataclass
class Parent:
    arg1: str
    opt_arg1: str = 'opt_arg1_default_val'
    opt_arg2: str = 'opt_arg2_default_val'
    opt_arg3: str = 'opt_arg3_default_val'
    opt_arg4: str = 'opt_arg4_default_val'

@dataclass
class Child(Parent):
    arg2: str
</code></pre>
<p>… you'll get an error, because it tries to place the mandatory parameter <code>arg2</code> after the default-values parameters <code>opt_arg1</code> through <code>opt_arg4</code>.</p>
<p><code>dataclasses</code> doesn't have any way to reorder parameters (<code>Child(arg1, arg2, opt_arg1=…</code>), or to force them to be keyword-only parameters (<code>Child(*, arg1, opt_arg1=…, arg2)</code>). <code>attrs</code> doesn't have that functionality out of the box, but you can add it.</p>
<p>So, it's not quite as trivial as you'd hope, but it's doable.</p>
<hr/>
<p>But if you wanted to write this yourself, how would you create the <code>__init__</code> function dynamically?</p>
<p>The simplest option is <code>exec</code>. </p>
<p>You've probably heard that <code>exec</code> is dangerous. But it's only dangerous if you're passing in values that came from your user. Here, you're only passing in values that came from your own source code.</p>
<p>It's still ugly—but sometimes it's the best answer anyway. <a href="https://github.com/python/cpython/blob/3.6/Lib/collections/__init__.py#L301" rel="nofollow noreferrer">The standard library's <code>namedtuple</code> used to be one giant <code>exec</code> template.</a>, and <a href="https://github.com/python/cpython/blob/3.7/Lib/collections/__init__.py#L394" rel="nofollow noreferrer">even the current version uses <code>exec</code> for most of the methods</a>, and <a href="https://github.com/python/cpython/blob/3.7/Lib/dataclasses.py#L339" rel="nofollow noreferrer">so does <code>dataclasses</code></a>.</p>
<p>Also, notice that all of these modules store the set of fields somewhere in a private class attribute, so subclasses can easily read the parent class's fields. If you didn't do that, you could use the <code>inspect</code> module to get the <code>Signature</code> for your base class's (or base classes', for multiple inheritance) initializer and work it out from there. But just using <code>base._fields</code> is obviously a lot simpler (and allows storing extra metadata that doesn't normally go in signatures).</p>
<p>Here's a dead simple implementation that doesn't handle most of the features of <code>attrs</code> or <code>dataclasses</code>, but does order all mandatory parameters before all optionals.</p>
<pre><code>def makeinit(cls):
    fields = ()
    optfields = {}
    for base in cls.mro():
        fields = getattr(base, '_fields', ()) + fields
        optfields = {**getattr(base, '_optfields', {}), **optfields}
    optparams = [f"{name} = {val!r}" for name, val in optfields.items()]
    paramstr = ', '.join(['self', *fields, *optparams])
    assignstr = "\n    ".join(f"self.{name} = {name}" for name in [*fields, *optfields])
    exec(f'def __init__({paramstr}):\n    {assignstr}\ncls.__init__ = __init__')
    return cls

@makeinit
class Parent:
    _fields = ('arg1',)
    _optfields = {'opt_arg1': 'opt_arg1_default_val',
                  'opt_arg2': 'opt_arg2_default_val',
                  'opt_arg3': 'opt_arg3_default_val',
                  'opt_arg4': 'opt_arg4_default_val'}

@makeinit
class Child(Parent):
    _fields = ('arg2',)
</code></pre>
<p>Now, you've got exactly the <code>__init__</code> methods you wanted on <code>Parent</code> and <code>Child</code>, fully inspectable<sup>2</sup> (including <code>help</code>), and without having to repeat yourself.</p>
<hr/>
<p><sub>1. I don't use PyCharm, but I know that well before 3.7 came out, their devs were involved in the discussion of <code>@dataclass</code> and were already working on adding explicit support for it to their IDE, so it doesn't even have to evaluate the class definition to get all that information. I don't know if it's available in the current version, but if not, I assume it will be. Meanwhile, <code>@dataclass</code> already just works for me with IPython auto-completion, emacs flycheck, and so on, which is good enough for me. :)</sub></p>
<p><sub>2. … at least at runtime. PyCharm may not be able to figure things out statically well enough to do popup completion.</sub></p>
</div>
<span class="comment-copy">In addition to the problem you raised, this solution only works if you always pass all the optional arguments as keywords. (If you wanted to require that, you should have made them keyword-only arguments in <code>Parent</code>, by doing <code>def __init__(self, arg1, *, opt_arg1=…)</code>.)</span>
<span class="comment-copy">Aren't the optional params in Parent keywords? opt_arg1 is the name and 'opt_arg1_default_val' is the default value. Am I missing something?</span>
<span class="comment-copy">Oh, I see. In GrandChild I can pass anything to arg1, but it doesn't have to be named arg1. But the solution still works, just the mandatory arguments should not be named arg1,arg2 when creating the objects, but simply passed values without keywords. Either way, the problem is another.</span>
<span class="comment-copy">Unless you're willing to write your own plugin for PyCharm you won't get your desired effect - I'm not sure it would be a smart thing to do, anyway, given that both positional and keyword arguments can be ignored - you'd have to do a heavy code analysis to figure out if the arguments are even used up the inheritance chain. After all, if the positional/keyword arguments are not important enough to name them explicitly in your <code>__init__()</code> signature - they are not important enough to be type-hinted.</span>
<span class="comment-copy">@GeorgeIrimiciuc Keyword-only parameters can have default values or not have them, and so can normal (keyword-or-positional) parameters. The fact that parameters with default values in a function definition look a lot like keyword arguments in a function call is just a red herring.</span>
<span class="comment-copy">Won't your code example break when trying to create the Child's <code>__init__</code> method because <code>arg2</code> will be appended to the base class' argument list, hence making a non-default argument follow a default argument (<code>opt_arg4</code>)?</span>
<span class="comment-copy">@shmee Oops, you might be right. It looks like keyword-only params were deferred from the proposal. I’ll test when I get to a computer, and rewrite if needed. Thanks for the catch.</span>
<span class="comment-copy">Hm, I don't think I like the exec idea. I'd have to use it every time I do inheritance. I mean in other languages Builder would solve this problem, at least partially. Strange how in Python there isn't an easier way for this. But makeinit() doesn't feel very.. OOP-ish.</span>
<span class="comment-copy">@GeorgeIrimiciuc No, you don't have to do it every time you do inheritance; you just do it once, and apply the decorator every time you do inheritance. Just like with <code>dataclasses</code> and <code>attrs</code>, you don't have to write the <code>dataclasses</code> library, just do <code>@dataclass</code>.</span>
<span class="comment-copy">@GeorgeIrimiciuc Anyway, you <i>can</i> implement the builder pattern in Python—in fact, the <code>attrs</code> docs shows how to integrate it (and other variations on alternate constructor idioms) with <code>attrs</code>. It's just more verbose than doing it all automatically in a one-liner, so you don't need to use it most of the time.</span>
