<div class="post-text" itemprop="text">
<p>I understand that the <code>__del__</code> function of a Python class <a href="https://stackoverflow.com/questions/6104535/i-dont-understand-this-python-del-behaviour">is not treated in the way that many people might expect</a>: as a destructor.</p>
<p>I also understand that there are more 'pythonic' and arguably more elegant ways to tidy up, particularly with use of the <a href="https://stackoverflow.com/a/865272/5196274">with construct</a>.</p>
<p>However, when writing code that may be used by an audience less versed in pythonic ways, when cleanup is important, is there an elegant way I can simply get <code>__del__</code> to work as a destructor reliably, without interfering with python's natural use of <code>__del__</code>?</p>
<p>The expectation that <code>__del__</code> behave as a destructor doesn't seem <em>unreasonable</em> and at the same time is quite common.  So I'm simply wondering if there is an elegant way to make it work as per that expectation - disregarding the many debates that can be had over the merits of how pythonic it is.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you understand all that, why not do it in the Pythonic way? Compare another class where cleanup is important: <code>tempfile.TemporaryDirectory</code>.</p>
<pre><code>with TemporaryDirectory() as tmp:
    # ...
# tmp is deleted

def foo():
    tmp = TemporaryDirectory()
foo()
# tmp is deleted
</code></pre>
<p>How do they do this? Here's the relevant bit:</p>
<pre><code>import weakref
class Foo():
    def __init__(self, name):
        self.name = name
        self._finalizer = weakref.finalize(self, self._cleanup, self.name)
        print("%s reporting for duty!" % name)

    @classmethod
    def _cleanup(cls, name):
        print("%s feels forgotten! Bye!" % name)

    def cleanup(self):
        if self._finalizer.detach():
            print("%s told to go away! Bye!" % self.name)

def foo():
    print("Calling Arnold")
    tmpfoo = Foo("Arnold")
    print("Finishing with Arnold")

foo()
# =&gt; Calling Arnold
# =&gt; Arnold reporting for duty
# =&gt; Finishing with Arnold
# =&gt; Arnold feels forgotten. Bye!

def bar():
    print("Calling Rocky")
    tmpbar = Foo("Rocky")
    tmpbar.cleanup()
    print("Finishing with Rocky")

bar()
# =&gt; Calling Rocky
# =&gt; Rocky reporting for duty!
# =&gt; Rocky told to go away! Bye!
# =&gt; Finishing with Rocky
</code></pre>
<p><code>weakref.finalize</code> will trigger <code>_cleanup</code> when the object is garbage-collected, or at the end of the program if it's still around. We can keep the finaliser around so that we can explicitly kill the object (using <code>detach</code>) and mark it as dead so the finaliser is not called (when we want to manually handle the cleanup).</p>
<p>If you want to support the context usage with <code>with</code>, it is trivial to add <code>__enter__</code> and <code>__exit__</code> methods, just invoke <code>cleanup</code> in <code>__exit__</code> ("manual cleanup" as discussed above).</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a pattern I have been employing that achieves this using the <a href="https://docs.python.org/3/library/atexit.html" rel="nofollow noreferrer">atexit</a> python module.</p>
<pre><code>class Demo(object):
    def __init__(self, *args, **kwargs):
        import atexit
        atexit.register(self.__del__)

    def __del__(self):
        print("__del__ being called!")

t1 = Demo()
t2 = Demo()

quit()
</code></pre>
<p>When pasted into a python command prompt, this is the total output:</p>
<pre><code>Python 3.6.0 (v3.6.0:41df79263a11, Dec 23 2016, 08:06:12) [MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
&gt;&gt;&gt; class Demo(object):
...     def __init__(self, *args, **kwargs):
...         import atexit
...         atexit.register(self.__del__)
...
...     def __del__(self):
...         print("__del__ being called!")
...
&gt;&gt;&gt; t1 = Demo()
&gt;&gt;&gt; t2 = Demo()
&gt;&gt;&gt;
&gt;&gt;&gt; quit()
__del__ being called!
__del__ being called!
</code></pre>
</div>
<span class="comment-copy">Consider warning the user that if you had to cleanup in <code>__del__</code> then their program is actually broken...</span>
<span class="comment-copy">When do you want the cleanup to occur? What's the scope?</span>
<span class="comment-copy">Document your code and show examples of how to use <code>with</code>. It's not difficult to learn.</span>
<span class="comment-copy">Any particular reason why you made <code>_cleanup</code> a classmethod?</span>
<span class="comment-copy">@Aran-Fey: Indeed: <a href="https://docs.python.org/3/library/weakref.html#weakref.finalize" rel="nofollow noreferrer">Docs</a>: "<b>Note:</b> It is important to ensure that <code>func</code>, <code>args</code> and <code>kwargs</code> do not own any references to <code>obj</code>, either directly or indirectly, since otherwise <code>obj</code> will never be garbage collected. In particular, <code>func</code> should not be a bound method of <code>obj</code>."</span>
<span class="comment-copy">So that means you don't have access to the instance in the finalizer? That's pretty useless then, isn't it? Is there a way to pass the instance to the finalizer?</span>
<span class="comment-copy">@Aran-Fey: That defeats the point. Pass any information relevant to the finalizer through args/kwargs, like <code>name</code> here. I'd argue that if it were useless it would not be used (and it obviously is, for example in the cited <code>TemporaryDirectory</code> class).</span>
<span class="comment-copy">How does that defeat the point? If I need information about the instance that's being deleted, I don't want to have to pass all the required values as arguments. There's no reason why that should be necessary. Having access to the instance would be the easiest, cleanest, and least error-prone solution.</span>
<span class="comment-copy">I do however need to check how doing this may impact upon natural garbage collection and what happens if a class is garbage collected before exit! Bah!</span>
<span class="comment-copy">You may <code>atexit.unregister(self.__del__)</code> at the end of <code>__del__</code> to avoid it being called multiple times by garbage collection+end of program.</span>
<span class="comment-copy">What if the module is part of a long running process?</span>
