<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/expressions.html#membership-test-details" rel="nofollow noreferrer">The official documentation</a> indicates that python first tries to check via <code>__contains__()</code>, then <code>__iter__()</code>, and finally <code>__getitem__()</code>, depending on which function is defined, in order to resolve an <code>in</code> call.
Eg: </p>
<pre><code>if y in x:
    print("y present in x")
else:
    print("y not present in x")
</code></pre>
<p>The linked documentation indicates that if there exists any non negative index <code>i</code> such that <code>x[i] == y</code>, then the result is <code>True</code> else <code>False</code>.
How does it perform a search over all such <code>i</code>? A linear traversal over 'all' positive numbers seems out of the question. There must be some bounds in which the linear traversal happens (for lists, it should be 0 to len()). How are those bounds determined?  </p>
</div>
<div class="post-text" itemprop="text">
<p>Aaah, I think get it... You want to know how the <em>key</em> is obtained to iterate over all elements on custom containers that do not have neither <code>__contains__()</code> nor <code>__iter__()</code> - simple, it works exactly using linear iteration until <a href="https://docs.python.org/3/library/exceptions.html#IndexError" rel="nofollow noreferrer"><code>IndexError</code></a> is encountered, as stated in the documentation:</p>
<blockquote>
<p>... if a class defines <code>__getitem__()</code>, <code>x in y</code> is <code>True</code> if and only if there is a non-negative integer index <code>i</code> such that <code>x == y[i]</code>, and <strong>all lower integer indices do not raise <code>IndexError</code> exception. (If any other exception is raised, it is as if in raised that exception)</strong>.</p>
</blockquote>
<p>Case in point:</p>
<pre><code>class CustomClass(object):

    def __getitem__(self, item):
        if item &gt; 20:  # lets force the break so that it doesn't go to sys.maxsize
            raise IndexError()
        print(item)  # print the item requested
        # implied: return None so it doesn't match 5

result = 5 in CustomClass()  # this will keep printing numbers until 20
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The purpose of these special methods is to give <em>you</em>, the designer of your data structure, a way to perform lookups in a fast way that is appropriate to your situation. For example, you could derive a class from <code>list</code> that is enhanced by a reverse index for fast lookup by value. (Obviously this would slow down insertion since the index needs to be updated, but let's assume that you'll be doing a lot of lookups so you know it's worth it.)</p>
<p>If your class has no way to improve on the default access, you don't need to define the special methods. Python will fall back on whatever is available, including sequential search.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How does it perform a search over all such <code>i</code>?</p>
</blockquote>
<p>This depends, pretty much on the data structure of the object in which the search is performing on. For example if you have a <code>list</code> object, the complexity of membership checking is O(n) and if you have a data structure that uses hashtable accessing its items (the <code>__getitem__</code> attribute) such as dictionary or set the complexity is approximately O(1).</p>
<p>So in general for user defined objects it works as it's explained in documentation. For objects without hash table it's a linear search and for objects with hash table its a constant search.   </p>
</div>
<div class="post-text" itemprop="text">
<p>The iteration for objects without <code>__contains__</code> or <code>__iter__</code> occurs <a href="https://github.com/python/cpython/blob/48ed88a93bb0bbeaae9a4cfaa533e4edf13bcb51/Objects/iterobject.c#L48" rel="nofollow noreferrer">here</a>. The sequence scan occurs <a href="https://github.com/python/cpython/blob/a6fdddb7df00aefad2ec6e362dbf10d4bd8bff32/Objects/abstract.c#L1969" rel="nofollow noreferrer">here</a>. The decision to use <code>__contains__</code> or falling back on iteration occurs <a href="https://github.com/python/cpython/blob/48ed88a93bb0bbeaae9a4cfaa533e4edf13bcb51/Objects/abstract.c#L2061" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>That's exactly how it works. Here's a demonstration using <code>list</code>:</p>
<pre><code>$ for a in `seq 6`; do python3 -m timeit -s "a = 10**$a" 'a in list(range(a))'; done
1000000 loops, best of 3: 0.84 usec per loop
100000 loops, best of 3: 3.04 usec per loop
10000 loops, best of 3: 57.7 usec per loop
1000 loops, best of 3: 639 usec per loop
100 loops, best of 3: 6.74 msec per loop
10 loops, best of 3: 70.3 msec per loop
</code></pre>
<p>You can observe the time complexity increasing proportional to the size of the container.</p>
</div>
<span class="comment-copy">For regular lists/sequences, that's exactly what happens - Python goes through each of their elements attempting to equate them with the search element.</span>
<span class="comment-copy">@zwer There the <code>__contains__</code> is explicitly defined, so the question doesn't arise.</span>
<span class="comment-copy">What's the alternative to a linear traversal? Magic?</span>
<span class="comment-copy">@moooeeeep I was referring to <a href="https://github.com/bslatkin/effectivepython/blob/master/example_code/item_28.py" rel="nofollow noreferrer">github.com/bslatkin/effectivepython/blob/master/example_code/â€¦</a> when the question arose in my mind. See <code>class IndexableNode</code> on the page.</span>
<span class="comment-copy">It starts with <code>0</code> and keeps adding <code>1</code> until it finds the item or gets an <code>IndexError</code>.  If it ever gets an <code>IndexError</code> it stops and returns <code>False</code></span>
<span class="comment-copy">Yeah, that statement wasn't on its own clear to me. Now that you point it, I look dumb :(</span>
<span class="comment-copy">Whoa thanks for those source code links!</span>
<span class="comment-copy">But the question is not for lists since <code>__contains__</code> is explicitly defined for lists. Its for custom classes.</span>
