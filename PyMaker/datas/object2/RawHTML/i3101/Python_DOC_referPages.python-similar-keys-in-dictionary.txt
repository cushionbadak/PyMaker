<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/10664856/make-dictionary-with-duplicate-keys-in-python">make dictionary with duplicate keys in python</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/11141383/is-there-a-way-to-preserve-duplicate-keys-in-python-dictionary">Is there a way to preserve duplicate keys in python dictionary</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<p>i have dictionary: <code>dict = {key1:value1, key2:value2, key3:value3, key1:value4, key2:value5, key3:value6}</code></p>
<p>if i print keys from dictionary</p>
<pre><code>def my_func():
    for key in dict:
        print(key)
</code></pre>
<p>it print only last 3 keys:
for example:</p>
<pre><code>   key1
   key2
   key3
</code></pre>
<p>but keys in dictionary can be same.
Can you explain me why? if the key is the same, how to print like this: </p>
<pre><code>key2:value2,value5
</code></pre>
<p>if it is possible.
thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>To achieve a result like <code>key2:value2,value5</code>, you can use a <code>collections.defaultdict</code>.</p>
<p>Here's the example from the <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">docs</a>:</p>
<pre><code>&gt;&gt;&gt; s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; for k, v in s:
...     d[k].append(v)
...
&gt;&gt;&gt; sorted(d.items())
[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The keys in the dictionary cannot be the same. Statement <code>key1:value4</code>, effectively translates too:</p>
<pre><code>x = {key1:value1, key2:value2, key3:value3}
x[key1] = value4
</code></pre>
<p>So your just overwriting the previous value. To have the desired effect you should implement a custom dict that stores the values in a list, and then some custom method to clear the list assuming that evey statement like <code>x[key1] = value1</code> appends the value and does not replace it.</p>
<pre><code>    class CustomDictOne(dict):
       def __init__(self):
          self._mydict = defaultdict(lambda:[])

       def __setitem__(self, key, item):
           self._mydict[key].append(item)

        def clear(self,key)
           self._mydict[key] = []

        def __getitem__(self, key):
           return self._mydict[key]
</code></pre>
<p>If you use a custom field name like I did <code>_mydict</code> you should also re-implement all the other methods:</p>
</div>
<span class="comment-copy">You cannot have duplicate keys in a dictionary</span>
<span class="comment-copy"><code>dict = {key1:value1, key2:value2, key3:value3, key1:value4, key2:value5, key3:value6}</code> =&gt; data is lost as soon as you declared it.</span>
<span class="comment-copy">@Rakesh thank you</span>
<span class="comment-copy">have a look at <code>collections.defaultdict</code> <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">thank you for resolution :-)</span>
