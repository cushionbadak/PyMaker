<div class="post-text" itemprop="text">
<p>Please, I want an easier and simplest way for extracting every first elements from the keys of this dictionary:</p>
<pre><code>s = [((3, 6), 9.0), ((1, 6), 8.0), ((3, 8), 8.0), ((3, 7), 7.0), ((0, 6), 7.0), ((1, 8), 7.0), ((0, 8), 6.0), ((2, 4), 6.0), ((1, 7), 6.0), ((2, 6), 5.0), ((2, 9), 5.0), ((0, 7), 5.0), ((3, 5), 5.0), ((2, 8), 4.0), ((1, 5), 4.0), ((0, 4), 4.0), ((3, 2), 4.0), ((2, 3), 4.0), ((2, 1), 3.0), ((1, 2), 3.0), ((2, 7), 3.0), ((1, 4), 3.0), ((0, 5), 3.0), ((0, 9), 3.0), ((3, 0), 2.0), ((0, 3), 2.0), ((2, 0), 2.0), ((3, 4), 2.0), ((0, 2), 2.0), ((1, 9), 2.0), ((1, 3), 1.0), ((2, 5), 1.0), ((3, 9), 1.0), ((1, 0), 1.0), ((0, 1), 1.0), ((3, 1), 1.0), ((3, 3), 0.0), ((1, 1), 0.0), ((0, 0), 0.0), ((2, 2), 0.0)]
</code></pre>
<p>I want to get something like this:</p>
<pre><code>[3, 1, 3, 3, 0, 1, 0, 2, 1, 2, 2, 0, 3, 2, 1, 0, 3, 2, 2, 1, 2, 1, 0, 0, 3, 0, 2, 3, 0, 1, 1, 2, 3, 1, 0, 3, 3, 1, 0, 2]
</code></pre>
<p>This is what I did: </p>
<pre><code>l = [a[0][0] for a in s]
</code></pre>
<p>I want an efficient way of doing that</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>s</code> is a list of nested tuples. But you could easily create a <code>dict</code> from it, by passing it to the <code>dict</code> constructor. But if you actually have a <code>dict</code> you can efficiently extract the 1st item from each key tuple using <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a>. </p>
<pre><code>from operator import itemgetter

s = [
    ((3, 6), 9.0), ((1, 6), 8.0), ((3, 8), 8.0), ((3, 7), 7.0), ((0, 6), 7.0), ((1, 8), 7.0), 
    ((0, 8), 6.0), ((2, 4), 6.0), ((1, 7), 6.0), ((2, 6), 5.0), ((2, 9), 5.0), ((0, 7), 5.0), 
    ((3, 5), 5.0), ((2, 8), 4.0), ((1, 5), 4.0), ((0, 4), 4.0), ((3, 2), 4.0), ((2, 3), 4.0), 
    ((2, 1), 3.0), ((1, 2), 3.0), ((2, 7), 3.0), ((1, 4), 3.0), ((0, 5), 3.0), ((0, 9), 3.0), 
    ((3, 0), 2.0), ((0, 3), 2.0), ((2, 0), 2.0), ((3, 4), 2.0), ((0, 2), 2.0), ((1, 9), 2.0), 
    ((1, 3), 1.0), ((2, 5), 1.0), ((3, 9), 1.0), ((1, 0), 1.0), ((0, 1), 1.0), ((3, 1), 1.0), 
    ((3, 3), 0.0), ((1, 1), 0.0), ((0, 0), 0.0), ((2, 2), 0.0)
]

d = dict(s)
print(d)

a = list(map(itemgetter(0), d))
print(a)
</code></pre>
<p><strong>output</strong></p>
<pre><code>{(3, 6): 9.0, (1, 6): 8.0, (3, 8): 8.0, (3, 7): 7.0, (0, 6): 7.0, (1, 8): 7.0, (0, 8): 6.0, (2, 4): 6.0, (1, 7): 6.0, (2, 6): 5.0, (2, 9): 5.0, (0, 7): 5.0, (3, 5): 5.0, (2, 8): 4.0, (1, 5): 4.0, (0, 4): 4.0, (3, 2): 4.0, (2, 3): 4.0, (2, 1): 3.0, (1, 2): 3.0, (2, 7): 3.0, (1, 4): 3.0, (0, 5): 3.0, (0, 9): 3.0, (3, 0): 2.0, (0, 3): 2.0, (2, 0): 2.0, (3, 4): 2.0, (0, 2): 2.0, (1, 9): 2.0, (1, 3): 1.0, (2, 5): 1.0, (3, 9): 1.0, (1, 0): 1.0, (0, 1): 1.0, (3, 1): 1.0, (3, 3): 0.0, (1, 1): 0.0, (0, 0): 0.0, (2, 2): 0.0}
[3, 1, 3, 3, 0, 1, 0, 2, 1, 2, 2, 0, 3, 2, 1, 0, 3, 2, 2, 1, 2, 1, 0, 0, 3, 0, 2, 3, 0, 1, 1, 2, 3, 1, 0, 3, 3, 1, 0, 2]
</code></pre>
<p>However, you probably should <em>not</em> do this, unless you're using Python 3.6+, because in earlier versions dictionaries do not preserve insertion order, so there is no guarantee that the items in <code>a</code> are in the same order as the items in <code>s</code>. </p>
<p>If you don't actually have a <code>dict</code>, but you just have that <code>s</code> list, then your code </p>
<pre><code>l = [a[0][0] for a in s]
</code></pre>
<p>is perfectly fine.</p>
</div>
<span class="comment-copy">There are no dictionaries in your code.</span>
<span class="comment-copy">Your way is super efficient. Also there is no dictionary here.</span>
<span class="comment-copy">This is already efficient, and <code>s</code> is a list of nested tuples as opposed to a dictionary</span>
<span class="comment-copy">Yeah! Am sorry for the typo! Thanks you guys for the repy</span>
<span class="comment-copy">Thanks @PM 2Ring, I actually meant the "list of nested tuples". Anyway your reply is super, I've leant alot from it.</span>
