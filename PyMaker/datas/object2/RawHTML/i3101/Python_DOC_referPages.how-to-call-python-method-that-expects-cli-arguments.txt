<div class="post-text" itemprop="text">
<p>Not really sure how else to phrase this,
But I am converting a bash script to python, and I am trying to call a method in a python library that typically is called via the CLI. That method uses argparse and expects 2 arguments when it's called.</p>
<p>I'm not sure how to call this method and provide the two arguments when calling it from a separate python script.</p>
<p>What I've tried:</p>
<pre><code>&gt;&gt;  from somelibrary import mymethod as method
&gt;&gt;  method.main('foo', 'bar')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: main() takes 0 positional arguments 
but 2 were given

&gt;&gt;&gt; method.main()
usage: [-h] foo bar
: error: the following arguments are required: 
foo, bar
</code></pre>
<p>Any help is greatly appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>That function is almost certainly calling the <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.parse_args" rel="nofollow noreferrer"><code>Argparser.parse_args()</code></a> method with no Python arguments:</p>
<pre><code>parser.parse_args()
</code></pre>
<p>This takes the arguments from the <a href="https://docs.python.org/3/library/sys.html#sys.argv" rel="nofollow noreferrer"><code>sys.argv</code> list</a>, taking all elements except for the first.</p>
<p><code>sys.argv</code> is just a list, so you can set your own:</p>
<pre><code>import sys
from somelibrary import mymethod as method

sys.argv[1:] = ['foo', 'bar']
method()
</code></pre>
<p>Preferably, if you can alter that project or suggest changes, you should (ask to) update the <code>main()</code> function to take arguments:</p>
<pre><code>def main(args=None):
    if args is None:
        args = sys.argv[1:]

    # ...

    parser.parse_args(args)
</code></pre>
<p>You may need to consider the possibility that the script is not designed to be imported into another program (it may alter global state that other parts of your program rely on, or it could end with <code>sys.exit()</code> and thus close your program unless you specifically catch the <code>SystemExit</code> exception. It may be easier to just run the script with as a child process instead, using:</p>
<pre><code>import sys
import subprocess

result = subprocess.run([sys.executable, '/path/to/somelibrary', 'foo', 'bar'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use <code>sys.argv</code> - it contains the arguments passed to the py script.</p>
<pre><code>from somelibrary import mymethod as method
&gt;&gt;&gt; sys.argv[1:] = ['foo', 'bar']
&gt;&gt;&gt; method.main()
</code></pre>
</div>
<span class="comment-copy">Would be helpful to see what <code>mymethod</code> looks like</span>
<span class="comment-copy">Is there a reason you don't just run the module as a CLI command via the <code>subprocess</code> module? Presumably <code>main</code> returns nothing of use, so <code>subprocess.run([sys.executable, '-m', 'somelibrary', 'foo', 'bar'])</code> seems like the straightforward solution...</span>
<span class="comment-copy">What is the thing you're trying to call? Do you control it? Can you change it to take arguments? Are you sure there isn't some more appropriate entry point when using this code as a library?</span>
<span class="comment-copy">@user2357112 I'm essentially calling a method that accepts two arguments: a sqlite file, and a tsv file. It will populate the sqlite database with the contents of the tsv file. I don't control it. I don't believe I can change it either.</span>
<span class="comment-copy">@user2357112 Update! I talked to the owner of it, and I can change it to accept args. I'm going to do that</span>
<span class="comment-copy">I'd love to hear what is not helpful or wrong about my answer, to deserve a downvote. That way I can improve my answer!</span>
<span class="comment-copy">Thank Martijn Pieters! I chose this one as the best answer, because I ended up getting permission to modify main in order to accept arguments.</span>
<span class="comment-copy">This assumes that <code>sys.argv</code> didn't have any other arguments in it yet. Replacing the contents, rather than <code>extend</code>ing, is likely more reliable.</span>
<span class="comment-copy">@ShadowRanger OP is testing the code in the intepreter - I'm positive it doesn't have more arguments</span>
<span class="comment-copy"><code>$ ipython3 --classic</code>, <code>&gt;&gt;&gt; sys.argv</code> produces <code>['/path/to/ipython3', '--classic']</code>. And even if it didn't, the interactive interpreter is often used to test something you want to use in a script later on. The new approach you edited in is just safer in the general case.</span>
<span class="comment-copy">Awesome, this works! When I do implement it, however, it'll be called from a celery task in django. Not sure if that'll drastically change things?</span>
