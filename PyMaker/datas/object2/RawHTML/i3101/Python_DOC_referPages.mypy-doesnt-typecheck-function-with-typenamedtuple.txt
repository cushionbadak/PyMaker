<div class="post-text" itemprop="text">
<p>I have a function that accepts a class that derives from <code>NamedTuple</code> and converts it into a schema. However when I run MyPy on the following code it fails with <code>Argument 1 to "to_schema" has incompatible type "Type[Foo]"; expected "Type[NamedTuple]"</code></p>
<pre><code>from typing import NamedTuple, Type


def to_schema(named_tuple: Type[NamedTuple]):
    pass

class Foo(NamedTuple):
    pass


to_schema(Foo) 
</code></pre>
<p>Is there a way to properly type the code so that it typechecks with MyPy?</p>
<p>Edit:
Python documentation states that <code>Type[Foo]</code> accepts any subclasses of <code>Foo</code> (<a href="https://docs.python.org/3/library/typing.html#typing.Type" rel="nofollow noreferrer">https://docs.python.org/3/library/typing.html#typing.Type</a>). I have multiple subclasses of <code>NamedTuple</code>, for entities in our data model, so I'm looking for a way to annotate the function in a way that would typecheck.</p>
</div>
<div class="post-text" itemprop="text">
<p>The root issue with your code is that <code>NamedTuple</code> is not an actual type -- it's actually just a special sort of "type constructor" that synthesizes an entirely new class and type. E.g. if you try printing out the value of <code>Foo.__mro__</code>, you'll see <code>(&lt;class '__main__.Foo'&gt;, &lt;class 'tuple'&gt;, &lt;class 'object'&gt;)</code> -- <code>NamedTuple</code> is not present there at all.</p>
<p>That means that <code>NamedTuple</code> isn't actually a valid type to use at all -- in that regard, it's actually a little surprising to me that mypy just silently lets you construct <code>Type[NamedTuple]</code> to begin with.</p>
<p>To work around this, you have several potential approaches:</p>
<ol>
<li><p>Rather then using <code>Type[NamedTuple]</code>, use either <code>Type[tuple]</code> or <code>Type[Tuple[Any]]</code>.</p>
<p>Your <code>Foo</code> genuinely <em>is</em> a subtype of a tuple, after all.</p></li>
<li><p>If you need methods or fields that are specifically present only in namedtuples, use a custom protocol. For example, if you particularly need the <code>_asdict</code> method in namedtuples, you could do:</p>
<pre><code>from typing_extensions import Protocol

class NamedTupleProto(Protocol):
    def _asdict(self) -&gt; Dict[str, Any]: ...

def to_schema(x: Type[NamedTupleProto]) -&gt; None: pass

class Foo(NamedTuple):
    pass

to_schema(Foo)
</code></pre>
<p>Note that you will need to install the <code>typing_extensions</code> third party library to use this, though there are plans to <a href="https://www.python.org/dev/peps/pep-0544/" rel="nofollow noreferrer">formalize Protocols</a> and add it to Python at some point. (I forget if the plan was Python 3.7 or 3.8).</p></li>
<li><p>Add a type ignore or a cast on the call to <code>to_schema</code> to silence mypy. This isn't the greatest solution, but is also the quickest.</p></li>
</ol>
<p>For related discussion, see <a href="https://github.com/python/mypy/issues/3915" rel="nofollow noreferrer">this issue</a>. Basically, there's consensus on the mypy team that somebody ought to do something about this NamedTuple thing, whether it's by adding an error message or by adding an officially sanctioned protocol, but I think people are too busy with other tasks/bugs to push this forward. (So if you're bored and looking for something to do...)</p>
</div>
<span class="comment-copy">Great, thanks for the detailed answer! I’m ignoring the typecheck for now, but I’ll definitely look into a better solution now — probably implementing my own protocol, since I need <code>_asdict</code></span>
