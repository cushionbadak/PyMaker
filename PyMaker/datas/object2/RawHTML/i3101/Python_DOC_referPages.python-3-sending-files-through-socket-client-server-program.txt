<div class="post-text" itemprop="text">
<p>I am having the above issue. The client is suppose to ask for a filename and send the file name to the server after which the server will open the file and display it. Problem is that the server isn't opening the file and displaying it. </p>
<p>Below is the client.</p>
<pre><code>#!/usr/bin/env python3 
import socket, os.path, datetime, sys

def Main():
    host = '127.0.0.1'
    port = 50001

    s = socket.socket()
    s.connect((host, port))

    Filename = input("Type in ur file ")
    s.send(Filename.encode('utf-8'))
    data = s.recv(1024).decode('utf-8')
    s.close()

if __name__ == '__main__':
    Main()
</code></pre>
<p>Below is the server</p>
<pre><code>#!/usr/bin/env python3

import socket
import os
import sys



def Main():
    host = '127.0.0.1'
    port = 50001

    s = socket.socket()
    s.bind((host,port))
    print("server Started")
    s.listen(1)
    c, addr = s.accept()
    print("Connection from: " + str(addr))
    while True:
        data = c.recv(1024).decode('utf-8')
        myfile = open(data, "r")
        if not data:
            break
        print("from connected user: " + myfile)

    c.close()

if __name__ == '__main__':
    Main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've made few minimal adjustments to your code with which it runs as so that <code>server.py</code> continuously listens on a given port and sends back data which each invocation of <code>client.py</code> asks for.</p>
<p><strong>server.py</strong></p>
<pre><code>#!/usr/bin/env python3
import socket
import os
import sys

def Main():
    host = '127.0.0.1'
    port = 50001

    s = socket.socket()
    s.bind((host,port))
    print("server Started")
    s.listen(1)
    while True:
        c, addr = s.accept()
        print("Connection from: " + str(addr))
        filename = ''
        while True:
            data = c.recv(1024).decode('utf-8')
            if not data:
                break
            filename += data
        print("from connected user: " + filename)
        myfile = open(filename, "rb")
        c.send(myfile.read())
        c.close()

if __name__ == '__main__':
    Main()
</code></pre>
<p><strong>client.py</strong></p>
<pre><code>#!/usr/bin/env python3 
import socket, os.path, datetime, sys

def Main():
    host = '127.0.0.1'
    port = 50001

    s = socket.socket()
    s.connect((host, port))

    Filename = input("Type in ur file ")
    s.send(Filename.encode('utf-8'))
    s.shutdown(socket.SHUT_WR)
    data = s.recv(1024).decode('utf-8')
    print(data)
    s.close()

if __name__ == '__main__':
    Main()
</code></pre>
<p>And now a bit of explanation.</p>
<p>On the server side. The outer loop accepts a connection, then reads from the connection until done (more on this later). Prints your debugging info, but note you were trying to <code>print</code> the file object and not the filename (which would fail trying to concatenate). I also open the file in binary mode (that way I can skip the <code>str</code> -&gt; <code>bytes</code> translation.</p>
<p>On the client side. I've added closing the writing end of the socket when the file has been sent. Note you might want to use <a href="https://docs.python.org/3/library/socket.html#socket.socket.sendall" rel="nofollow noreferrer"><code>sendall</code></a> instead of <a href="https://docs.python.org/3/library/socket.html#socket.socket.send" rel="nofollow noreferrer"><code>send</code></a> for this use case: check those docs links for details. And I've added a <code>print</code> for the incoming data.</p>
<p>Now that bit with shutting down the writing end in the client and the inner loop reading (and also related to the <code>sendall</code> hint. Which BTW also holds true for the server side, otherwise you should loop, as you might see your content truncated; other option is to also have a sending loop.). Stream sockets will guarantee you get your bytes in in order you've send them. On itself it has no idea whether your message is complete and it also does not guarantee in how many and how large chunks will the data be sent and received (resp.).</p>
<p>The inner loop of server keep reading until we see an <code>EOF</code> (we've receive zero length string in python <code>socket</code>). This would happen (be returned by <code>recv</code> when the remote socket (or at least its writing end) has been shut down. Since we still want to reuse the connection, we only do that on the sending end in the client. Hope this helps you to move ahead.</p>
</div>
<span class="comment-copy">See this post to get an idea of how file transfer should be done: <a href="https://stackoverflow.com/q/27241804/1190388">stackoverflow.com/q/27241804/1190388</a></span>
<span class="comment-copy">Oh wow. It actually prints the file content right now. Just got a question, by opening the file in binary mode won't it limit the functionality of the file? For example if i open the file in r mode i can do <code>myfile.readline()</code> however i can't do that in rb mode.</span>
<span class="comment-copy">When in doubt, check the <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">docs</a>. TL;DR: you can use <code>readline()</code>. Apart from the <code>bytes</code>/<code>str</code> difference and mostly behind the scene details, you should get the same behavior on those higher level interfaces. It's not really all that important, but basically, I see no point of converting data forth and back. So, I'd leave all the conversion to the client for handling console input/output talking to a human. And I got a bit lazy on that too.</span>
<span class="comment-copy">Alright. I get your explanation. Thanks alot for your help. Learn quite a few things today. ^^</span>
