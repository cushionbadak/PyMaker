<div class="post-text" itemprop="text">
<p>I was attempting to create a thread class that could be terminated by an exception (since I am trying to have the thread wait on an event) when I created the following:</p>
<pre><code>import sys

class testThread(threading.Thread):
    def __init__(self):
        super(testThread,self).__init__()
        self.daemon = True

    def run(self):
        try:
            print('Running')
            while 1:
                pass
        except:
            print('Being forced to exit')

test1 = testThread()
test2 = testThread()

print(test1.daemon)
test1.run()
test2.run()

sys.exit()
</code></pre>
<p>However, running the program will only print out one Running message, until the other is terminated. Why is that?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you're calling the <a href="https://docs.python.org/3/library/threading.html#threading.Thread.run" rel="nofollow noreferrer"><code>run</code></a> method.</p>
<p>This is just a plain old method that you implement, which does whatever you put in its body. In this case, the body is an infinite loop, so calling <code>run</code> just loops forever.</p>
<p>The way to start a thread is the <a href="https://docs.python.org/3/library/threading.html#threading.Thread.start" rel="nofollow noreferrer"><code>start</code></a> method. This method is part of the <code>Thread</code> class, and what it does is:</p>
<blockquote>
<p>Start the thread’s activity.</p>
<p>It must be called at most once per thread object. It arranges for the object’s <code>run()</code> method to be invoked in a separate thread of control.</p>
</blockquote>
<p>So, if you call this, it will start a new thread, make that new thread run your <code>run()</code> method, and return immediately, so the main thread can keep doing other stuff.<sup>1</sup> That's what you want here.</p>
<hr/>
<p><sub>1. As pointed out by Jean-François Fabre, you're still not going to get any real parallelism here. Busy loops are never a great idea in multithreaded code, and if you're running this in CPython or PyPy, almost all of that busy looping is executing Python bytecode while holding the GIL, and only one thread can hold the GIL at a time. So, from a coarse view, things look concurrent—three threads are running, and all making progress. But if you zoom in, there's almost no overlap where two threads progress at once, usually not even enough to make up for the small scheduler overhead.</sub></p>
</div>
<span class="comment-copy">You want to call <code>start</code> on a thread object to start it in a background thread. Calling <code>run</code> just runs it in the current thread.</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/threading.html#threading.Thread.start" rel="nofollow noreferrer"><i><code>start()</code> Start the thread’s activity.  It must be called at most once per thread object. <b>It arranges for the object’s <code>run()</code> method to be invoked in a separate thread of control.</b></i></a></span>
<span class="comment-copy">I was pretty sure this had a dup on the canonical list of dups, but it doesn't. I can't find a good dup, so I wrote an answer, but I'm still pretty sure there must be one, which probably has a more detailed explanation. Hopefully someone else can find it.</span>
<span class="comment-copy">aargh <code>run</code>, <code>start</code> ... well, okay. The busy loop is also not really a recommendation</span>
<span class="comment-copy">@Jean-FrançoisFabre Yeah, but CPython will forcibly interrupt each thread every so often to give the others a chance to run, so it'll at worst <i>appear</i> to be running concurrently, it'll just run 20% slower than a single thread instead of 200% faster… So, probably not getting into here.</span>
<span class="comment-copy">@Jean-FrançoisFabre But I added a footnote anyway, because I can never resist writing too many words…</span>
<span class="comment-copy">great answer as always :) your dedication on the site is just awesome.</span>
