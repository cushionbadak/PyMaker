<div class="post-text" itemprop="text">
<p>I have a class that is essentially a wrapper around a dictionary:</p>
<pre><code>class Wrapper(dict):

    ...

    def __getitem__(self, item: Hashable) -&gt; Any:
        return self.wrapped[item]
</code></pre>
<p>When checking the annotations with <code>mypy</code>, it yields an <code>Explicit "Any" is not allowed</code> when checking this code. My guess is that this stems from the concept that <code>Any</code> is the ancestor and successor of all other types. How should I annotate such function where I want to allow anything to be returned?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really need a custom mapping (do you?) I'll recommend to not inherit from <code>dict</code> as it can cause a lot of pain in the future (you should re-define its methods or sometimes you will be using <code>self.wrapped</code> and sometimes not).</p>
<p>We can simply use <code>MutableMapping</code> ABC from <a href="https://docs.python.org/3/library/collections.abc.html#module-collections.abc" rel="nofollow noreferrer"><code>collections.abc</code> module</a> and define basic methods (like <code>__getitem__</code>), the rest (<code>keys()</code>, <code>values</code>, <code>items()</code> are defined already).</p>
<p>About <code>mypy</code>: I prefer to define helper type variables for elements/keys/values/etc. inside of a class.</p>
<p>So we can end up with something like</p>
<pre><code>from collections import abc
from typing import (Dict,
                    Iterator,
                    TypeVar)


class Wrapper(abc.MutableMapping):
    KeyType = TypeVar('KeyType')
    ValueType = TypeVar('ValueType')

    def __init__(self, wrapped: Dict[KeyType, ValueType]) -&gt; None:
        self.wrapped = wrapped

    def __delitem__(self, key: KeyType) -&gt; None:
        del self.wrapped[key]

    def __len__(self) -&gt; int:
        return len(self.wrapped)

    def __iter__(self) -&gt; Iterator[KeyType]:
        return iter(self.wrapped)

    def __setitem__(self, key: KeyType, value: ValueType) -&gt; None:
        self.wrapped[key] = value

    def __getitem__(self, key: KeyType) -&gt; ValueType:
        return self.wrapped[key]
</code></pre>
<h1>Test</h1>
<p>Running <code>mypy</code> with <code>--disallow-any-explicit</code> flag causes no errors/warnings.</p>
</div>
<div class="post-text" itemprop="text">
<p>This happens when the <code>disallow_any_explicit</code> is set to <code>True</code> for that module in the configuration file. Just remove that option for the default <code>False</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have provided insufficient information in the question to recreate this error but if your sole question is:</p>
<blockquote>
<p>How should I annotate such function where I want to allow anything to be returned?</p>
</blockquote>
<p>The simple answer is <strong>don't annotate it at all</strong>. It will by default act as <code>Any</code>.</p>
</div>
<span class="comment-copy">I would guess that they want you to just remove the annotation, but I'm still surprised that an explicit <code>Any</code> would be actually forbidden.</span>
<span class="comment-copy">Also, you appear to be making the common mistake of inheriting from <code>dict</code> <i>and</i> having another dict as an instance variable. Don't do that; pick one or the other, or you'll end up wasting space and having very confusing bugs where data ends up in one dict when you were expecting it to land in the other.</span>
