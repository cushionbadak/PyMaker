<div class="post-text" itemprop="text">
<p><em>Note: The <a href="https://stackoverflow.com/questions/8898294/convert-utf-8-with-bom-to-utf-8-with-no-bom-in-python">possible duplicate</a> concerns an older version of Python and this question has already generated unique answers.</em></p>
<p>I have been working on a script to process <a href="https://gutenberg.org" rel="nofollow noreferrer">Project Gutenberg Texts</a> texts into an internal file format for an application I am developing. In the script I process chapter headings with the <code>re</code> module. This works very well except in one case: the first line. My regex will always fail on the first Chapter marker at the first line if it includes the ^ caret to require the regex match to be at the beginning of the line because the BOM is consumed as the first character. (Example regex: <code>^Chapter</code>).</p>
<p>What I've discovered is that if I do not include the caret, it won't fail on the first line, and then <code>&lt;feff&gt;</code> is included in the heading after I've processed it. An example:</p>
<pre><code>&lt;h1&gt;&lt;feff&gt;Chapter I&lt;/h1&gt;
</code></pre>
<p>The advice according to <a href="https://stackoverflow.com/questions/1972362/why-is-my-bash-script-adding-feff-to-the-beginning-of-files">this SO question</a> (from which I learned of the BOM) is to fix your script to not consume/corrupt the BOM. <a href="https://stackoverflow.com/questions/2456380/utf-8-html-and-css-files-with-bom-and-how-to-remove-the-bom-with-python">Other SO questions</a> talk about decoding the file with a codec but discuss errors I never encounter and do not discuss the syntax for opening a file with the template decoder.</p>
<p>To be clear: </p>
<p>I generally use pipelines of the following format:</p>
<pre><code>cat -s &lt;filename&gt; | &lt;other scripts&gt; | python &lt;scriptname&gt; [options] &gt; &lt;outfile&gt;
</code></pre>
<p>And I am opening the file with the following syntax:</p>
<pre><code>import sys

fin = sys.stdin

if '-i' in sys.argv: # For command line option "-i &lt;infile&gt;"
    fin = open(sys.argv[sys.argv.index('-i') + 1], 'rt')

for line in fin:
    ...Processing here...
</code></pre>
<p><strong>My question is what is the proper way to handle this? Do I remove the BOM before processing the text? If so, how? Or do I use a decoder on the file before processing it (I am reading from stdin, so <em>how</em> would I accomplish this?)</strong></p>
<p>The files are stored in UTF-8 encoding with DOS endings (<code>\r\n</code>). I convert them in vim to UNIX file format before processing using <code>set ff=unix</code> (I have to do several manual pre-processing tasks before running the script).</p>
</div>
<div class="post-text" itemprop="text">
<p>As a complement to the existing answer, it is possible to filter the UTF8 BOM from stdin with the codecs module. Simply you must use <code>sys.stdin.buffer</code> to access the underlying byte stream and decode it with a <code>StreamReader</code></p>
<pre><code>import sys
import codecs

# trick to process sys.stdin with a custom encoding
fin = codecs.getreader('utf_8_sig')(sys.stdin.buffer, errors='replace')


if '-i' in sys.argv: # For command line option "-i &lt;infile&gt;"
    fin = open(sys.argv[sys.argv.index('-i') + 1], 'rt',
               encoding='utf_8_sig', errors='replace')

for line in fin:
    ...Processing here...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, <code>stdin</code> <em>should</em> be auto-decoded properly, but if it's not working for you (and for Python 2) you need to specify <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONIOENCODING" rel="nofollow noreferrer">PythonIOEncoding</a> before invoking your script like</p>
<pre><code>PYTHONIOENCODING="UTF-8-SIG" python &lt;scriptname&gt; [options] &gt; &lt;outfile&gt;
</code></pre>
<p>Notice that this setting also makes <code>stdout</code> working with <code>UTF-8-SIG</code>, so your <code>&lt;outfile&gt;</code> will maintain the original encoding.</p>
<p>For your <code>-i</code> parameter, just do <code>open(path, 'rt', encoding="UTF-8-SIG")</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You really don't need to import <code>codecs</code> or anything to deal with this. As lenz suggested in comments just check for the BOM and throw it out.</p>
<pre><code>for line in input:
    if line[0] == "\ufeff":
        line = line[1:] # trim the BOM away

    # the rest of your code goes here as usual
</code></pre>
</div>
<span class="comment-copy">Hmm, <code>fin = sys.argv[sys.argv.index('-i') + 1]</code> should give you a filename in <code>fin</code>. It should then be opened with an <code>open</code> call that you have not shown and that is the place where you could declare that you want to filter the BOM out. Could you please show your <code>open</code> instruction?</span>
<span class="comment-copy">@Serge I apologize. I typed it from memory and forgot to include the open. However, I mostly use <code>sys.stdin</code> because I've been using it in pipelines. I would especially like to know how to declare it with <code>sys.stdin</code>.</span>
<span class="comment-copy">Python 3 should transparently normalize the line endings with text files (Python 2 had <code>'Ur' </code> for opening a file for reading with line-ending normalization) . The gist of the proposed duplicate is to use the <code>utf-8-sig</code> encoding when opening the file to transparently ignore the BOM, too.</span>
<span class="comment-copy">If you are preprocessing the files anyway, it might be the easiest to chop it off in that process. Check the first character and remove it if it is the "zero-width non-breaking space".</span>
<span class="comment-copy">See e.g. <a href="https://stackoverflow.com/questions/45240387/how-can-i-remove-the-bom-from-a-utf-8-file" title="how can i remove the bom from a utf 8 file">stackoverflow.com/questions/45240387/â€¦</a></span>
<span class="comment-copy">This actually seems to be the most elegant solution as it (seems to me) to be more portable than the other solutions. How will it handle non-utf-8 encoded scripts? Will it choke?</span>
<span class="comment-copy">My comment seems to be due to a misunderstanding of BOMs and character encoding. After perusing <a href="https://chat.stackexchange.com/rooms/62721/discussion-on-answer-by-stephane-chazelas-how-can-i-remove-the-bom-from-a-utf-8">this Unix.SE discussion</a> as well as <a href="https://www.quora.com/How-common-is-UTF-16BE-or-even-UTF-32-for-text-files-e-g-XML-or-JSON-yes-I-JSON-only-allows-UTF-8" rel="nofollow noreferrer">this quora question</a> I have come to the conclusion that I will probably never need to worry about the BOM except to remove it and therefore take this answer as the final, most elegant and portable solution.</span>
<span class="comment-copy">Can I just export an environment variable or does your solution require <code>PYTHONIOENCODING="UTF-8-SIG"</code> to be declared while I'm running the script?</span>
<span class="comment-copy">Yes, declaring it as an environment variable should affect all python scripts</span>
<span class="comment-copy">If you set it earlier in the script, it will remain set for the duration of the script (unless you explicitly unset or change it, of course). You need to <code>export</code> it so it's visible to subprocesses such as Python.</span>
<span class="comment-copy">@tripleee: When you say "set it earlier in the script" is the script you are referring to my python script of my pipeline-command? I am curious because if I can just write this into my python script toward the top that might be the simplest solution.</span>
<span class="comment-copy">The shell script containing the pipeline. If the Python script is simple you can embed it in the shell script but I would probably look into doing the preprocessing in Python too instead.</span>
