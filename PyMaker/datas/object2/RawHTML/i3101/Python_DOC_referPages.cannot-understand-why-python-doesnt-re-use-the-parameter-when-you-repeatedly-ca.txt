<div class="post-text" itemprop="text">
<p>I'm watching a tutorial on python and it uses this example:</p>
<pre><code>def add_spam(menu=[]):
    menu.append("spam")
    return menu
</code></pre>
<p>If you call <code>add_spam()</code> repeatedly then the menu list increases in size. This is new to me since I am from a C# background. But OK, fair enough.</p>
<p>To get around this it says that you should set the menu parameter to <code>None</code> but I cannot understand why that works. Here is the code they use:</p>
<pre><code>def add_spam(menu=None):
    if menu is None:
        menu = []
    menu.append('spam')
    return menu
</code></pre>
<p>If you call it the first time though menu will be set to [], and the second time surely if it's 'remembering' the parameter as in the first example, menu will be [] at that point and therefore it will just append spam to the list as in the first example.</p>
<p>The video neglects any explanation other than you should use an immutable type so I cannot understand how this works.</p>
<p>Edit cos I still don't get it:</p>
<p>What I'm seeing is that the function captures the variable, so it takes menu=[] and stores that secretly somewhere, imagine a private variable called _menu, so that if you call it again it doesn't re-evaluate it just continues to use _menu and thus it grows.</p>
<p>In the second example, I do not understand why it isn't simply taking menu=None and storing <em>that</em> secretly as _menu, so _menu = None and then when you call the 2nd function, it sets _menu=[] and it continues exactly as the first example and it grows.</p>
<p>The fact that None is immutable doesn't seem relevant to me, as you're not doing None=[] you're doing menu=[] so menu then stops being what it was before and becomes [] and you can modify it as you like.</p>
<p>Unless it's some hard-coded feature that if you put None it will not do the copying behaviour then I do not understand the difference between the two.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Python‚Äôs default arguments are evaluated once when the function is defined, not each time the function is called (like it is in say, Ruby).</p>
</blockquote>
<p><a href="https://docs.python-guide.org/writing/gotchas/" rel="nofollow noreferrer">https://docs.python-guide.org/writing/gotchas/</a></p>
<p>From Python's docs, some more detail:</p>
<blockquote>
<p>Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same ‚Äúpre-computed‚Äù value is used for each call.</p>
</blockquote>
<p><a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions" rel="nofollow noreferrer">https://docs.python.org/3/reference/compound_stmts.html#function-definitions</a></p>
<p>Lists are mutable objects, whereas <code>None</code> is immutable, hence the behavior you see.</p>
</div>
<div class="post-text" itemprop="text">
<p>Setting <code>menu = []</code> inside the function is just rebinding the name <code>menu</code> to a new object inside the scope of that function call. It doesn't change the original <code>menu</code> object in the scope where the function was defined. Appending to <code>menu</code> within the function, on the other hand, actually modifies the object in memory associated with the name <code>menu</code> in the function definition (because lists are mutable). This object was created when the function was first defined, and is shared between calls of the function. </p>
<p>If you want to understand more, look into the python scoping/namespace behavior, of which default argument sharing is mostly just a subset. But basically,</p>
<pre><code>def foo(bar=None): #executed once
    bar = [] #executed every time the function is called 
</code></pre>
</div>
<span class="comment-copy">Conceptually a duplicate of <a href="https://stackoverflow.com/q/366422/2564301">stackoverflow.com/q/366422/2564301</a> ‚Äì the <i>why</i> is <a href="http://effbot.org/zone/default-values.htm" rel="nofollow noreferrer">mentioned in a comment</a> but unfortunately the link in that to the official documentation has been declared Out of Cheese.</span>
<span class="comment-copy">Almost a dupe of <a href="https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument" title="least astonishment and the mutable default argument">stackoverflow.com/questions/1132941/‚Ä¶</a>.</span>
<span class="comment-copy">It uses the variable that's stored away for the default value of the parameter. Once the name is rebound to a new object, that value doesn't matter any more</span>
<span class="comment-copy">Objects created within the body of a function (as opposed to the definition) are certainly created anew each call.</span>
<span class="comment-copy">But you can only ever do it once, safely, and if anything goes wrong in your program it can be left in a broken state. And if anyone externally calls your function they will break it and/or receive unexpected results. If it's computationally expensive, safer to just handle that yourself, no?</span>
<span class="comment-copy">üò∂ Can you expand on how this works out, using OP's code as an example?</span>
<span class="comment-copy">If the same pre-computed value is used for each call, why does calling the first example multiple times cause <code>menu</code> to get bigger and bigger? Surely it would use the precomputed value of <code>[]</code> every time? And if it doesn't do this, then the second example wouldn't fix it either.</span>
<span class="comment-copy">See the edit: <code>None</code> is immutable, a list is not.</span>
<span class="comment-copy">But the reference to None is gone, when it gets set to [], so all you have then is <code>menu</code> set to <code>[]</code> so the immutability doesn't seem like it should be a factor</span>
<span class="comment-copy">Sure, if you nest calls like so: <code>add_spam(add_spam())</code> (ie, if you reuse the returned value). But if you call <code>add_spam</code> with no arguments repeatedly, then menu gets bound to <code>None</code> repeatedly, and "overwritten", but <i>only</i> inside the scope of the function.</span>
<span class="comment-copy">Yes, I think I sort of get it now. In the first instance it has a hidden variable (I read about <b>defaults</b> but let's keep it simple) called say, _menu. So it does <code>_menu = []</code>  and when you call it a 2nd time it does <code>menu = _menu</code> to provide your value, ie. retrieves the stored value so everything is appended. In the second instance, it does <code>_menu = None</code> the first time, and when you call it a second time, it does menu = _menu so both will be <code>None</code>, and when you set <code>menu = []</code> it doesn't change <code>_menu</code> since <code>_menu</code> does not point to <code>menu</code>.</span>
