<div class="post-text" itemprop="text">
<p><strong>Context</strong></p>
<p>I am relatively new to python / computer programming and trying to wrap my head around some basic concepts by playing around with them.</p>
<p>In my understanding, python is an interpreted language i.e. it evaluates the line of code as it is being executed.</p>
<p><strong>Question</strong></p>
<p>In a function, why does interpreter check for a variable assignment by going down the code and not execute the line it is on, especially, since all relevant information is available?</p>
<p><strong><em>Example:</em></strong></p>
<pre><code>def spam():

    eggs = 'spam local'
    print(eggs)

    global eggs
    print(eggs)                      

eggs = 'global'

print(eggs) 
</code></pre>
<p><strong>Error:</strong>
The code above results in the following error:</p>
<p>"SyntaxError: name 'eggs' is used prior to global declaration"</p>
<p><strong>Confusion:</strong></p>
<p>In my mind, 2nd line explicitly assigns "spam local" to the variable 'eggs'. Hence, when the interpreter reaches line 3 i.e print(eggs), it should print "spam local" and not go down the code to see there is a global declaration of the variable and return the SyntaxError.</p>
<p>Why is the interpreter not executing the line it is one, given that all relevant information is available?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>In my understanding, python is an interpreted language i.e. it evaluates the line of code as it is being executed.</p>
</blockquote>
<p>No.<sup>1</sup> Python compiles a module at a time. All function bodies are compiled to bytecode, and the top-level module code is compiled to bytecode. That's what a <code>.pyc</code> file is—all those bytecode objects marshaled into a container.<sup>2</sup></p>
<p>When you <code>import</code> a module, its top-level bytecode is interpreted. (If there isn't a <code>.pyc</code> file, the <code>.py</code> file is compiled on the fly to get that bytecode.)</p>
<p>One more thing that might not seem obvious at first: While a function body is compiled, a <code>def</code> statement (or <code>lambda</code> expression) is compiled into interpretable bytecode, basically a call to a function that builds a function object out of the body's compiled bytecode.</p>
<hr/>
<p>You can reproduce all of this manually if you want to, which can be handy for experimenting with how things work. You can call <a href="https://docs.python.org/3/library/functions.html#compile" rel="nofollow noreferrer"><code>compile</code></a> on some module source with <code>exec</code> mode to compile it the same way an <code>import</code> would, and you can call <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code></a> on the result to run it the same way an <code>import</code> would, and you can even play with the <a href="https://docs.python.org/3/library/marshal.html" rel="nofollow noreferrer"><code>marshal</code></a> module to build your own <code>.pyc</code> files from scratch or load them up. (In fact, if you're on Python 3.3+, this isn't just equivalent to what <code>import</code> does, it's exactly what <code>import</code> does; <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer"><code>importlib</code></a> is written in Python.)</p>
<p>You can also view what the compiler has done (or would do, on source code that you haven't compiled yet and just have as a string) with the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> and <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> modules.</p>
<hr/>
<p>Part of the process of compiling a function body is detecting which names are local, cell, free, or global. A name is always consistently just one kind, for the entire lifetime of the function, which makes things easier to reason about.</p>
<p>Forgetting about cellvar/freevar cases (which are only needed for closures), the rule is very simple:</p>
<ul>
<li>If there's a <code>global</code> statement for a name in a function body, it's global.</li>
<li>Otherwise, if there's an assignment to a name in a function body,<sup>3</sup> it's local.</li>
<li>Otherwise, it's global.</li>
</ul>
<p>For the full details (and slightly more accurate details<sup>4</sup>), see <a href="https://docs.python.org/3/reference/executionmodel.html#naming-and-binding" rel="nofollow noreferrer">Naming and binding</a> in the reference documentation.</p>
<p>In versions of Python before 2.2, it was legal to assign to a variable and then declare it <code>global</code> later in the same function. In 2.1, this followed the rules explained above: the first assignment was to the global. Which is pretty misleading, especially since it almost always happened only be accident. Which is presumably why it was made an error to do that. In earlier versions, things are just nuts.<sup>5</sup></p>
<hr/>
<p><sub>1. Well, in the interactive interpreter, it <em>does</em> sort of do this—but even there, it's a statement at a time, not a line at a time. For example, a four-line compound statement like a <code>def</code> or <code>for</code> is compiled and interpreted all at once.</sub></p>
<p><sub>2. Actually, the "container" bit is pretty trivial. In fact, everything is recursively already part of the top-level module bytecode object—e.g., a top-level function's name, bytecode, etc. are all just constant values stored in the module bytecode, just like any other constant values.</sub></p>
<p><sub>3. Things that count as assignments including being a parameter, or being a target or member of a target list for an assignment statement, a <code>del</code> statement, a <code>for</code> statement or clause, an <code>as</code> clause, an <code>import</code>, a <code>def</code> or <code>class</code>, or, in 3.8+, an assignment expression.</sub></p>
<p><sub>4. A Python implementation doesn't actually <em>have</em> to determine all of this stuff at compile time, as long as the semantics end up the same. So the reference is written in terms that could be followed even by an implementation without a compiler. But in practice, at least CPython, PyPy, MicroPython, Jython, and IronPython work out the name bindings at compile time.</sub></p>
<p><sub>5. Python 0.9 had no <code>global</code>, and different scoping rules in general. In 1.1, as far as I can tell, the rule is that an assignment before the <code>global</code> statement rebinds the global if there already is one (you still et a local in the frame, but it stays unbound), but binds a local variable otherwise, which makes no sense to me. I've never managed to get 1.5, 1.6, or 2.0 to build on a modern system, but the code is clearly different from early 1.x and from 2.1, so for all I know they actually did what you were expecting here… or maybe they did something just as crazy as 1.1, but completely different.</sub></p>
</div>
<span class="comment-copy">"In my understanding, python is an interpreted language i.e. it evaluates the line of code as it is being executed." And that's where you're wrong.</span>
<span class="comment-copy">Python first compiles its code to bytecode and then it gets executed through the Python run-time.</span>
<span class="comment-copy">Thanks for the feedback @ignacio Vazquez-Abrams.</span>
<span class="comment-copy">Aha! Didn't know about code being compiled to bytecode before being executed. Many thanks, @zwer! Really appreciate it.</span>
<span class="comment-copy">This is very very helpful, @abarnert ! Thank you very much!</span>
<span class="comment-copy">Point 5 in interesting.  I guess I was using intuition in that if there is no variable assignment in a function, the interpreter searches for a global variable. Hence, I wanted to check if I assign a variable explicitly and then use it, before using the global variable in a function, will that work?  Many thanks for the inputs @abarnert !!</span>
<span class="comment-copy">@Longshort By "point 5", do you mean footnote 5? Anyway, your intuition is correct, but I don't understand what you're trying to do with it. How did you plan to "check if I assign a variable"? If you mean by manually reading the source, or by programmatically calling <code>ast.compile</code> and walking the tree to see if there are any assignments to that name, or something like that, then sure, you could do that, but what's the point? If it's not obvious that access to <code>spam</code> will be global, it's probably better to put an explicit <code>global spam</code> at the top of the function.</span>
<span class="comment-copy">Yes, I meant footnote 5.  On the issue of "checking", as I mentioned I was playing with some basic concepts to see if something worked.</span>
<span class="comment-copy">@Longshort It may be worth looking at the members of <code>f.__code__</code> (as documented in <code>inspect</code>). If a name appears in <code>co_varnames</code> or <code>co_cellvars</code> it's local; if it appears in <code>co_names</code> it's global-or-builtin; if it appears in <code>co_freevars</code> it's nonlocal. Or you can <code>dis.dis(f)</code>, if you're willing to learn a bit about bytecode—<code>LOAD_FAST</code>/<code>STORE_FAST</code> is for locals, etc.</span>
