<div class="post-text" itemprop="text">
<p>this code does not run as I want it to:</p>
<pre><code>class A():        
    def __init__(self,b,c):

        self.b = 1
        self.c = 2

def get_dict(self):

    mydict={}        
    for att in A():
        mydict[att]=self.att
    return mydict

print(get_dict(s))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You mean by this:</p>
<pre><code>class A():        
    def __init__(self):

        self.b = 1
        self.c = 2

def get_dict(self):

    mydict={}        
    for att in [i for i in dir(A()) if not i.startswith('__')]:
        mydict[att]=getattr(self,att)
    return mydict

print(get_dict(A()))
</code></pre>
<p>Output:</p>
<pre><code>{'b': 1, 'c': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just use the special attribute <code>__dict__</code> of you class:</p>
<pre><code>class A():
    def __init__(self,b,c):

        self.b = 1
        self.c = 2
</code></pre>
<p>Output:</p>
<pre><code>a = A(3,4)
print(a.__dict__)

{'b': 3, 'c': 4}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>__dict__</code> attribute to get a dict of all the attributes of an object.</p>
<pre><code>class A():
    def __init__(self,b,c):

        self.b = b
        self.c = c

    def get_dict(self):
        return self.__dict__

print(A(1, 2).get_dict())
</code></pre>
<p>This outputs:</p>
<pre><code>{'b': 1, 'c': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This question is a bit ambiguous.</p>
<p>If you're asking for the simple attributes for instances of simple classes, this is exactly what the <a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow noreferrer"><code>vars</code></a> builtin is for:</p>
<pre><code>def get_dict(self):
    return vars(self)
</code></pre>
<p>While we're at it, it's pretty weird to call a parameter <code>self</code> when you're not writing a method; let's call it something different:</p>
<pre><code>def get_dict(obj):
    return vars(obj)
</code></pre>
<hr/>
<p>But there are a lot of things this won't pick up, including:</p>
<ul>
<li>Properties.</li>
<li>Any attributes of a <code>__slots__</code> class.</li>
<li>Class attributes.</li>
<li>Dynamic attributes from <code>__getattr__</code>/<code>__getattribute__</code> and <code>__dir__</code>.</li>
</ul>
<p>If you want as many of those as possible, that's what the <a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow noreferrer"><code>dir</code></a> builtin is for. But <code>dir</code> just returns a list of names; you then have to look each one up:</p>
<pre><code>def get_dict(obj):
    return {name: getattr(obj, name) for name in dir(obj)}
</code></pre>
<p>This is pretty close to "every <code>whatever</code> I could do an <code>obj.whatever</code> with".</p>
<hr/>
<p>But that's probably <em>more</em> than you want. It'll include private members, and bound methods, and special stuff used by the Python interpreter. You have to decide exactly what you want to filter out, but once you have a rule, it should be easy to implement. For example:</p>
<pre><code>def get_dict(obj):
    public = ((name, getattr(obj, name)) for name in dir(obj) if not name.startswith('_'))
    noncallablepublic = {name: value for name, value in everything if not callable(value)}
    return noncallablepublic
</code></pre>
<p>If you want to get fancier, look at the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> module, which has helper functions for this kind of filtering.</p>
<hr/>
<p>While we're at it, if you have a good reason for doing this on some particular set of classes, you might want to design those classes to be easier to convert to a dict—and to be able to customize how they're converted.</p>
<p>For example, if you build your classes with <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer"><code>@dataclass</code></a>—or with the third-party <code>attrs</code> library, which is more powerful and doesn't require Python 3.7—it's trivial:</p>
<pre><code>&gt;&gt;&gt; @dataclasses.dataclass
... class A:
...     b: int = 1
...     c: int = 2
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a
A(b=1, c=2)
&gt;&gt;&gt; print(dataclasses.asdict(a))
{'b': 1, 'c': 2}
</code></pre>
<p>The <code>dataclasses</code> library built the <code>__init__</code> method for me, and also the <code>__repr__</code> method, and the other stuff needed to support things like <code>asdict</code>, so I didn't have to write anything at all.</p>
</div>
<span class="comment-copy">What's <code>s</code>, BTW Do some expanation</span>
<span class="comment-copy">Please see <a href="https://stackoverflow.com/help/how-to-ask">How to Ask</a></span>
<span class="comment-copy">See: <a href="https://stackoverflow.com/tour">stackoverflow.com/tour</a></span>
<span class="comment-copy">Why did you name the parameter <code>self</code> when not an instance method?</span>
<span class="comment-copy">What if each instance had multiple values? How would we run the code</span>
<span class="comment-copy">Why are you doing <code>dir(A())</code> instead of taking the dir of the object you’re actually given? This only works in this example by coincidence (because you happen to be passing in another <code>A()</code>, and there’s nothing tricky in <code>A.__init__</code>).</span>
<span class="comment-copy">@cricket_007 This answer just copied the API from the OP's question, so I think you're asking the wrong person.</span>
<span class="comment-copy">This won’t work on properties, class attributes, slots classes, classes with dynamic dir/getattr, etc. If you’re going to dig into internals in the first place, you might as well do it right.</span>
