<div class="post-text" itemprop="text">
<p>I'm trying to replace every instance of a single letter followed by a = sign followed by a letter with spaces between = and the letters.  So <code>h=e</code> would be replaced with <code>h = e</code>.  This is what I have right now:</p>
<pre><code>definition = 'h=e'
definition = re.sub(r"\w=\w", r"\w\s=\s\w", definition)
</code></pre>
<p>But that yields <code>\w\s=\s\w</code> rather than <code>h = e</code>.  What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>The replacement shouldn't be another regular expression, it should be an ordinary string (or a function).</p>
<p><a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer">https://docs.python.org/3/library/re.html#re.sub</a></p>
<blockquote>
<pre><code>re.sub(pattern, repl, string, count=0, flags=0)
</code></pre>
<p>Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isnâ€™t found, string is returned unchanged. <strong>repl can be a string or a function</strong></p>
</blockquote>
<p>For example:</p>
<pre><code>definition = 'h=e'
definition = re.sub(r"(\w)=(\w)", "\g&lt;1&gt; = \g&lt;2&gt;", definition)
print(definition)
</code></pre>
<p>But it would be easier to use a word boundary here:</p>
<pre><code>definition = 'h=e'
definition = re.sub(r"\b=\b", " = ", definition)
print(definition)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can avoid consuming the part of the string you don't want to replace, but still assert that the parts around it match something by using lookahead/lookbehind assertions.</p>
<pre><code>&gt;&gt;&gt; re.sub(r"(?&lt;=\w)=(?=\w)", " = ", "h=e")
'h = e'
</code></pre>
<p>You can put whatever pattern in these. e.g.</p>
<pre><code>&gt;&gt;&gt; re.sub(r"(?&lt;=x)=(?=y)", " = ", "y=z z=q y=x x=y a=b")
'y=z z=q y=x x = y a=b'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Change </p>
<pre><code>re.sub(r"\w=\w", r"\w\s=\s\w", definition)
</code></pre>
<p>to</p>
<pre><code>re.sub(r'(\w)=(\w)', r"\g&lt;1&gt; = \g&lt;2&gt;", definition)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The docs for <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a> specifically mention that</p>
<blockquote>
<p>Unknown escapes such as <code>\&amp;</code> are left alone.</p>
</blockquote>
<p>A literal space in the replacement is all you need. <code>\s</code> is meaningless there. You also need to add groups to your expression to capture the part of the substitution that you <em>don't</em> want to replace:</p>
<blockquote>
<p>Backreferences, such as <code>\6</code>, are replaced with the substring matched by group 6 in the pattern.</p>
</blockquote>
<p>Your substitution should look something like this then:</p>
<pre><code>definition = re.sub(r"(\w)=(\w)", r"\1 = \2", definition)
</code></pre>
</div>
<span class="comment-copy">If you mean space in the replacement, use space, not a regex meaning "any type of whitespace"</span>
<span class="comment-copy">The replacement in re.sub explicitly allows backreferences that refer to capture groups in the original match.</span>
<span class="comment-copy">Thanks that did it.</span>
