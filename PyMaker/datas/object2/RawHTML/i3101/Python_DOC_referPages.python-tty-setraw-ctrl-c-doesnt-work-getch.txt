<div class="post-text" itemprop="text">
<p>This is my code.</p>
<pre><code>def getch():
    fd = sys.stdin.fileno()
    old_Settings = termios.tcgetattr(fd)
    try: 
        tty.setraw(sys.stdin.fileno())
        sys.stdin.flush()
    except KeyboardInterrupt:
        print ("[Error] Abnormal program termination")
    finally:
        termios.tcsetattr(fd,termios.TCSADRAIN,old_settings)
    return ch
</code></pre>
<p>In this code, KeyboardInterrupt exception doesn't work.</p>
<p>Thank you</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, when you set your TTY to raw mode—or, in particular, when you disable the <a href="http://man7.org/linux/man-pages/man3/termios.3.html" rel="nofollow noreferrer"><code>termios</code></a> setting <code>ISIG</code>—you no longer get the corresponding behavior:</p>
<blockquote>
<pre><code>  ISIG   When any of the characters INTR, QUIT, SUSP, or DSUSP are
         received, generate the corresponding signal.
</code></pre>
</blockquote>
<p>In other words, the character <code>INTR</code>, aka <code>^C</code> in most terminals, no longer generates a <code>SIGINT</code> signal, which <a href="https://docs.python.org/3/library/signal.html" rel="nofollow noreferrer">is what Python uses to raise a <code>KeyboardInterrupt</code></a>.</p>
<p>This is how full-screen programs like <code>emacs</code> can use <code>^C</code> as a control character instead of just quitting.</p>
<p>So, there are two options:</p>
<hr/>
<p>Instead of calling <code>setraw</code>, set the exact set of <code>termios</code> flags you want, making sure not to disable <code>ISIG</code>. </p>
<p>It's worth looking at the source to Python's <a href="https://github.com/python/cpython/blob/3.7/Lib/tty.py#L18" rel="nofollow noreferrer"><code>tty.setraw</code></a> to see exactly what it does, to use as a baseline. </p>
<p>You could just do exactly the same thing without the <code>ISIG</code>. But really, you should read the docs to learn what each of these things means.</p>
<p>And make sure to <code>man termios</code> on your own system, don't search online; things are a bit different on Linux vs. macOS/*BSD, and there are minor differences even between versions of the same OS.</p>
<p>Even after reading the docs, and experimenting on your own, it may not be entirely clear what effect every setting has. <a href="https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html" rel="nofollow noreferrer">This article</a> seems to do a decent job explaining things what goes into raw mode, and what each of the relevant flags actually means (although I only quickly skimmed it—and. again, you still need to read <code>man termios</code> for your platform).</p>
<hr/>
<p>Alternatively, you can just handle <code>^C</code> manually. </p>
<p>You're already reading a character at a time with <code>sys.stdin.read(1)</code>, so when someone hits <code>^C</code>, you're going to read a <code>'\x03'</code> character. </p>
<p>You can do whatever you want when that happens, including <code>raise KeyboardInterrupt</code>.</p>
<hr/>
<p>As a side note, if this is Python 3, you may want to read in binary mode:</p>
<pre><code>ch = sys.stdin.buffer.raw.read(1)
sys.stdin.flush()
</code></pre>
<p>(Then you'll check against <code>b'\x03'</code> instead of <code>'\x03'</code>. of course.)</p>
<p>In text mode, you should get a whole character at a time, even if it's a multibyte character in UTF-8 (or whatever your locale is). Which <em>seems</em> simpler at first—but that can actually be misleading, because a single character can still be only part of a keystroke. For example, with most terminals, an up arrow sends 3 characters (<code>'\x1B[A'</code>)<code>, but</code>read(1)` will just give you the first one.</p>
</div>
<span class="comment-copy">After the edits, your code seems to be missing the <code>ch = sys.stdin.read(1)</code>, which is probably kind of important to this function.</span>
<span class="comment-copy">I wanted to know what I can get when I hit ^C. I used '\x03'. Thank you very much!!</span>
