<div class="post-text" itemprop="text">
<p>I am working with a .dll that contains a single call which returns an array of function pointers.  GetMyApi() returns a pointer to a struct, which is an array of function pointers.  The functions themselves have different individual inputs and outputs. What I have tried so far:</p>
<p>[C code that I can't easily alter]
C:</p>
<pre><code>typedef struct My_Api_V2
{
    int                 (__cdecl *IsValidInt)(int i);
    int                 (__cdecl *InvalidInt)();
    int                 (__cdecl *IsValidSize)(size_t i);
} my_Api_V2;

const my_Api_V2* GetMyApi(int version);   // This function is accessed from DLL
</code></pre>
<p>Python effort:</p>
<pre><code>from ctypes import *

my_dll = cdll.LoadLibrary(path_to_my_dll)
my_api = my_dll.GetMyApi
my_api.argtypes[c_int]  #version number
my_api.restypes = c_void_p

firstfuncptr = my_api(2)
firstfunc = prototype(firstfuncptr)
firstfunc.argtypes[c_int]
firstfunc.restypes = c_int

test = firstfunc(23)
</code></pre>
<p>At this point, I am just trying to get the first function of the function list returned to work.  Any help pointing me in better direction is appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Things are not as easy as one might think at 1<sup>st</sup> glance. I'm going to post a dummy example that happens to contain the 2 ways of working with functions from <em>.dll</em>s (<em>.so</em>s) (as explained in <a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer">[Python 3]: ctypes - A foreign function library for Python</a>).</p>
<p><em>dll.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include &lt;stdio.h&gt;

#if defined(_WIN32)
#    define DLL_EXPORT __declspec(dllexport)
#    pragma warning(disable: 4477)  // !!! Just to avoid having additional code (macro for size_t), do NOT do this !!!
#else
#    define DLL_EXPORT
#endif

#define PRINT_MSG_0() printf("        [%s] (%d) - [%s]\n", __FILE__, __LINE__, __FUNCTION__)
#define PRINT_MSG_1I(ARG0) printf("        [%s] (%d) - [%s]:  ARG0: %d\n", __FILE__, __LINE__, __FUNCTION__, ARG0)


static int IsValidInt(int i) {
    PRINT_MSG_1I(i);
    return -i;
}

static int InvalidInt() {
    PRINT_MSG_0();
    return 0;
}

static int IsValidSize (size_t i) {
    PRINT_MSG_1I(i);
    return -i;
}


typedef struct DllInterfaceV2Struct {
    int (__cdecl *IsValidIntFuncPtr)(int i);
    int (__cdecl *InvalidIntFuncPtr)();
    int (__cdecl *IsValidSizeFuncPtr)(size_t i);
} DllInterfaceV2;


static DllInterfaceV2 intfV2 = {IsValidInt, InvalidInt, IsValidSize};


#if defined(__cplusplus)
extern "C" {
#endif

DLL_EXPORT const DllInterfaceV2 *GetInterfaceV2(int version);

#if defined(__cplusplus)
}
#endif


DLL_EXPORT const DllInterfaceV2 *GetInterfaceV2(int version) {
    if (version == 2) {
        return &amp;intfV2;
    } else {
        return NULL;
    }
}
</code></pre>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import ctypes


DLL_NAME = "test.dll"
DLL_FUNC_NAME = "GetInterfaceV2"

# "Define" the Python counterparts for C stuff in order to be able to use it

IsValidIntFuncPtr = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int)
InvalidIntFuncPtr = ctypes.CFUNCTYPE(ctypes.c_int)
IsValidSizeFuncPtr = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_size_t)

class DllInterfaceV2(ctypes.Structure):
    _fields_ = [
        ("is_valid_int", IsValidIntFuncPtr),
        ("invalid_int", InvalidIntFuncPtr),
        ("is_valid_size", IsValidSizeFuncPtr)
    ]


# Now, play with C stuff

def test_interface_ptr(intf_ptr):
    print("Testing returned interface: {:}\n".format(intf_ptr))
    if not intf_ptr:
        print("    NULL pointer returned from C\n")
        return
    intf = intf_ptr.contents  # Dereference the pointer
    res = intf.is_valid_int(-2718281)
    print("    `is_valid_int` member returned: {:d}\n".format(res))
    res = intf.invalid_int()
    print("    `invalid_int` member returned: {:d}\n".format(res))
    res = intf.is_valid_size(3141592)
    print("    `is_valid_size` member returned: {:d}\n\n".format(res))


def main():
    test_dll = ctypes.CDLL(DLL_NAME)
    get_interface_v2_func = getattr(test_dll, DLL_FUNC_NAME)  # Or simpler: test_dll.GetInterfaceV2
    get_interface_v2_func.argtypes = [ctypes.c_int]
    get_interface_v2_func.restype = ctypes.POINTER(DllInterfaceV2)

    pintf0 = get_interface_v2_func(0)
    test_interface_ptr(pintf0)
    pintf2 = get_interface_v2_func(2)
    test_interface_ptr(pintf2)


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li><p><em>C</em> part:</p>
<ul>
<li>I had to add some dummy code in order to test and illustrate the behavior</li>
<li>Although you mentioned that it's not modifiable, I changed stuff (mostly naming / coding style, ...):

<ul>
<li>Both letter cases + <em>underscore</em>s don't look nice (at least to me)</li>
<li>"<em>my</em>" (or any of its variants) in (functions, classes, or any other) names simply scratches my brain</li>
</ul></li>
</ul></li>
<li><p><em>Python</em> part:</p>
<ul>
<li>As I stated in my comment, the <em>C</em> stuff would have to be "duplicated" in <em>Python</em></li>
</ul></li>
<li><p>Although I consider this a <strong>major</strong> design flaw, in order to keep things as close as possible to the question, I simply followed it (<em>GetInterfaceV2</em> (the <strong><em>V2</em></strong> part) doesn't make any sense considering its arg (<em>version</em>))</p>
<ul>
<li>My personal opinion (without having all the context, though) is that (in order to ensure scalability) the function should return a generic structure, with an additional field (e.g. <em>version</em>) that could be checked by client apps.</li>
</ul></li>
</ul>
<p><strong>Output</strong>:</p>
<blockquote>
<pre class="lang-bat prettyprint-override"><code>(py35x64_test) e:\Work\Dev\StackOverflow\q051507196&gt;"c:\Install\x86\Microsoft\Visual Studio Community\2015\vc\vcvarsall.bat" x64

(py35x64_test) e:\Work\Dev\StackOverflow\q051507196&gt;dir /b
code.py
dll.c

(py35x64_test) e:\Work\Dev\StackOverflow\q051507196&gt;cl /nologo dll.c  /link /DLL /OUT:test.dll
dll.c
   Creating library test.lib and object test.exp

(py35x64_test) e:\Work\Dev\StackOverflow\q051507196&gt;dir /b
code.py
dll.c
dll.obj
test.dll
test.exp
test.lib

(py35x64_test) e:\Work\Dev\StackOverflow\q051507196&gt;"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" code.py
Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32

Testing returned interface: &lt;__main__.LP_DllInterfaceV2 object at 0x00000219984EBAC8&gt;

   NULL pointer returned from C

Testing returned interface: &lt;__main__.LP_DllInterfaceV2 object at 0x00000219984EBB48&gt;

        [dll.c] (16) - [IsValidInt]:  ARG0: -2718281
    `is_valid_int` member returned: 2718281

        [dll.c] (22) - [InvalidInt]
    `invalid_int` member returned: 0

        [dll.c] (28) - [IsValidSize]:  ARG0: 3141592
    `is_valid_size` member returned: -3141592
</code></pre>
</blockquote>
</div>
<span class="comment-copy">If you are writting the C part, could you post a minimal, working, example from that?</span>
<span class="comment-copy">It's <code>my_api.restype</code> and <code>my_api.argtypes = [c_int]</code> (same pattern in multiple places). And setti ng it to <code>void*</code> won't get you anywhere. You should define <code>My_Api_V2</code> counterpart in <i>Python</i>.</span>
<span class="comment-copy">One problem I see right away is my_api returns not a pointer, but a pointer to a list of pointers.</span>
<span class="comment-copy">Thank you for this detailed and comprehensive response.  Some of the odd naming was due to me cutting the code back a bit to fit into a smaller example.</span>
<span class="comment-copy">FWIW, I think this answer will be of value to others as well.</span>
<span class="comment-copy">You're welcome :)</span>
<span class="comment-copy">BTW, would you mark the solution as an answer to the question? As some other users (that don't read comments) to be aware of the fact that it solved the problem.</span>
<span class="comment-copy">OK.  I added a bounty.</span>
