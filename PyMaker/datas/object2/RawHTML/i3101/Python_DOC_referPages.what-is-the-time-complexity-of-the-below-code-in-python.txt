<div class="post-text" itemprop="text">
<p>Below is a code to remove the recurrent alphabets from a string in python. I would like to know the time complexity of this code. More specifically time complexity of line <code>if string_1[i] not in char_found:</code>. Searching in a list.</p>
<p>Also if possible can this be explained using space allocated by a list.</p>
<pre><code>def remove_recorring_char(string_1):
    result = ""
    char_found = []
    for i in range(0,len(string_1)):
        if string_1[i] not in char_found:
            char_found.append(string_1[i])
            result = result+string_1[i]
    return result

if __name__== "__main__":
    print(remove_recorring_char("aabbbcc"))
    print(remove_recorring_char("chdsgdsgggsggsjddaaxcvcj"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>if string_1[i] not in char_found:
</code></pre>
<p>This line does two things:</p>
<p>First, it accesses <code>string_1[i]</code>. That takes constant time, because strings are basically just arrays of characters.</p>
<p>Then it searches in a list <code>char_found</code>, comparing that character <code>string_1[i]</code> to each element until one matches. That takes (worst-case) linear time in the length of <code>char_found</code>. And, since <code>char_found</code> could (worst-case) be all of the characters in <code>string_1[:i]</code>, that's linear in the length of <code>string_1</code>.</p>
<p>So, this line is <code>O(N)</code>.</p>
<p>And of course this line is inside an outer loop that's even more obviously <code>O(N)</code>: <code>for i in range(0,len(string_1)):</code>. So, that combination of the two is <code>O(N**2)</code>.</p>
<p>Even if you fix that <code>in</code> test to be constant time, you also do <code>result = result+string_1[i]</code> inside the loop. String concatenation is worst-case linear in the length of the string. Recent versions of CPython and PyPy have some optimizations so it's sometimes amortized constant time, like appending to a list, but Python the language doesn't guarantee those optimizations. And <code>result</code> is, worst-case, also as long as <code>string_1</code>. So, the whole thing is still <code>O(N**2)</code>, unless your interpreter is extra nice.</p>
<hr/>
<p>You could reduce the whole thing to <code>O(N)</code> by making two small changes.</p>
<p>First, use a <code>set</code> rather than a <code>list</code> for <code>char_found</code>. Searching a set, and adding to it, are both amortized constant-time operations.</p>
<p>Second, use a <code>list</code> rather than a <code>str</code> for <code>result</code>, then do <code>result = ''.join(result)</code> at the end. Appending to a list is amortized constant-time. Converting a list back to a string is of course linear time, but you're not doing it inside your loops, so that's fine.</p>
</div>
<span class="comment-copy">Is the time complexity of if statement is O(n)? I'm looking for a reasoning here.</span>
<span class="comment-copy">Membership tests on lists are O(N) on the size of the list (a linear search is used). You should use a <code>set</code> object, which has constant-time membership testing, and would be the typical container used in this situation.</span>
<span class="comment-copy">It's worth looking at the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">Recipes</a> in the <code>itertools</code> docs. The <code>unique_everseen</code> function is a slightly more general version of what you're doing (it works on any iterable, not just strings, and can take an optional <code>key</code> function that works the same way as in <code>sort</code> or <code>max</code>), and also a good demonstration of how to do this efficiently.</span>
<span class="comment-copy">To add to what @juanpa.arrivillaga says, set isn't just more efficient, it's also probably clearer. When you use a set, it means you don't care about order, don't need duplicate values, and aren't doing anything but membership tests (and related things like intersection—all values in both set A and set B—or difference—all values in set A but not set B), because that's what sets do.</span>
<span class="comment-copy">Thank you. Was looking for this!</span>
<span class="comment-copy">Cheat for Python 3.6 or better: <code>print(''.join(dict.fromkeys('chdsgdsgggsggsjddaaxcvcj')))</code> prints <code>chdsgjaxv</code>. (Yes I know dictionary order isn't guaranteed in the docs until 3.7.)  Same time complexity as using a set.</span>
<span class="comment-copy">@StevenRumbalski <code>print(''.join(toolz.unique('chdsgdsgggsggsjddaaxcvcj')))</code> is even shorter, and I think more obvious in meaning, and it works back to 2.6/3.2. It does require a third-party library. But you can just copy <code>unique_everseen</code> out of the <code>itertools</code> recipes to get the same effect.</span>
<span class="comment-copy">Shorter if you're not counting imports, but definitely way clearer. There's no way I would put the <code>dict.fromkeys</code> version in my code without a short comment so my point about the import is moot.</span>
