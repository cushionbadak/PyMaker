<div class="post-text" itemprop="text">
<p>Recently i discovered that there is <a href="https://docs.djangoproject.com/en/dev/ref/models/fields/#field-options" rel="noreferrer">not-documented <code>django.db.models.fields.Field.name</code></a> option:</p>
<blockquote>
<pre><code>@total_ordering
class Field(RegisterLookupMixin):  #   here we have it
    ...                                   ↓↓↓↓↓↓↓↓↓
    def __init__(self, verbose_name=None, name=None, primary_key=False,
                 max_length=None, unique=False, blank=False, null=False,
                 db_index=False, rel=None, default=NOT_PROVIDED, editable=True,
                 serialize=True, unique_for_date=None, unique_for_month=None,
                 unique_for_year=None, choices=None, help_text='', db_column=None,
                 db_tablespace=None, auto_created=False, validators=(),
                 error_messages=None):
        ...
</code></pre>
</blockquote>
<p>There is <a href="https://github.com/django/django/blob/master/django/db/models/fields/__init__.py#L64-L77" rel="noreferrer">mention</a> of it in doc-way:</p>
<blockquote>
<pre><code># A guide to Field parameters:
#
#   * name:      The name of the field specified in the model.
#   * attname:   The attribute to use on the model object. This is the same as
#                "name", except in the case of ForeignKeys, where "_id" is
#                appended.
#   * db_column: The db_column specified in the model (or None).
#   * column:    The database column for this field. This is the same as
#                "attname", except if db_column is specified.
#
# Code that introspects values, or does other dynamic things, should use
# attname. For example, this gets the primary key value of object "obj":
#
#     getattr(obj, opts.pk.attname)
</code></pre>
</blockquote>
<p>Description above is related with <a href="https://code.djangoproject.com/ticket/683" rel="noreferrer">#683 ([patch] Saving with custom db_column fails)</a> ticket.</p>
<p>So if we look through whole <a href="https://github.com/django/django/blob/master/django/db/models/fields/__init__.py#L89-L894" rel="noreferrer"><code>django.db.models.fields.Field</code></a> class, this seems as <code>name</code> option is setting attribute name, which make real name of variable invalid:</p>
<p>Suppose we have our model:</p>
<pre><code># models.py
from django.db import models


class SomeModel(models.Model):
    first = models.CharField(max_length=50, verbose_name='first', name='second')
    third = models.CharField(max_length=50, verbose_name='third')
</code></pre>
<p>What <code>django-admin shell</code> tells us:</p>
<pre><code>In[2]: from app.models import SomeModel
In[3]: SomeModel.objects.create(first='first', third='third')
Traceback (most recent call last):
  File "/Users/ailove/Home/personal/untitled/venv/lib/python3.6/site-packages/IPython/core/interactiveshell.py", line 2963, in run_code
    exec(code_obj, self.user_global_ns, self.user_ns)
  File "&lt;ipython-input-3-08e446dfd6e3&gt;", line 1, in &lt;module&gt;
    SomeModel.objects.create(first='first', third='third')
  File "/Users/ailove/Home/personal/untitled/venv/lib/python3.6/site-packages/django/db/models/manager.py", line 82, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/Users/ailove/Home/personal/untitled/venv/lib/python3.6/site-packages/django/db/models/query.py", line 415, in create
    obj = self.model(**kwargs)
  File "/Users/ailove/Home/personal/untitled/venv/lib/python3.6/site-packages/django/db/models/base.py", line 495, in __init__
    raise TypeError("'%s' is an invalid keyword argument for this function" % kwarg)
TypeError: 'first' is an invalid keyword argument for this function
In[4]: obj = SomeModel.objects.create(second='second', third='third')
In[5] obj.third
Out[5]: 'third'
In[6]: obj.second
Out[6]: 'second'
In[7]: obj.first
Traceback (most recent call last):
  File "/Users/ailove/Home/personal/untitled/venv/lib/python3.6/site-packages/IPython/core/interactiveshell.py", line 2963, in run_code
    exec(code_obj, self.user_global_ns, self.user_ns)
  File "&lt;ipython-input-7-f0deaec10795&gt;", line 1, in &lt;module&gt;
    obj.first
AttributeError: 'SomeModel' object has no attribute 'first'
</code></pre>
<p>Question is kinda broad, but i am also curious.</p>
<p><strong>Is this <code>name</code> option is a thing that only helped to develop <code>django</code>, or ordinary developers can also make use of it? And if we can, what for?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>I've found <code>name</code> useful if I want a model's field to have a getter and setter and <strong>hide the naming convention introduced by the getter/setter from the Django ORM and the database</strong>. </p>
<p>A fairly common pattern in Python is to have the getter and setter be named after the public name of the field, and have the field that holds the value of the field start with an underscore which <a href="https://docs.python.org/3.7/tutorial/classes.html#private-variables" rel="noreferrer"><em>by convention</em></a> indicates that it is private. So for instance you'd have a setter and getter named <code>foo</code> and the "private" field for it named <code>_foo</code>:</p>
<pre><code>class Something(object):
    _foo = "some default value"

    @property
    def foo(self):
        return self._foo

    @foo.setter
    def foo(self, val):
        self._foo = val
</code></pre>
<p>The code above is barebones. Presumably, in a real-world scenario you'd have additional code in your getter or setter to do some additional work. (Otherwise, there's no reason for the getter and setter.) Assuming an instance of the class above named <code>instance</code>, you access <code>instance.foo</code> and you do not touch <code>instance._foo</code> because the <code>_foo</code> field is not part of the public API.</p>
<p>If you want to take the pattern above and implement it on a Django model you <em>could</em> just do this:</p>
<pre><code>class MyModel(models.Model):
    _foo = models.TextField()

    @property
    def foo(self):
        return self._foo

    @foo.setter
    def foo(self, val):
        self._foo = val
</code></pre>
<p>However, the net result is that your field is known to the Django ORM as <code>_foo</code> and it is stored in a column named <code>_foo</code> in the database. Some people will be okay with this, but in my projects I prefer that the existence of the getter/setter in Python not affect the name of the field elsewhere. In order to have the same name in the Django ORM and for the column name, you can do:</p>
<pre><code>_foo = models.TextField(name="foo")
</code></pre>
<p>Doing this will set the name of the field as seen in the Django ORM, so this works:</p>
<pre><code>MyModels.objects.get(foo=...)
</code></pre>
<p>Otherwise, you'd have to use the underscore and do <code>MyModels.objects.get(_foo=...)</code>. And it also sets the name of the database column so in raw SQL you'd access the column as <code>foo</code>. If you happen to want a different column name, you have to use the <code>db_column</code> argument to set the name: <code>models.TextField(name="foo", db_column="something_else")</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Another example is useful when you want to have one of name from <a href="https://docs.python.org/3/library/keyword.html#keyword.kwlist" rel="nofollow noreferrer"><code>keyword.kwlist</code></a>, e.g.</p>
<pre><code>class Emails(models.Model):
    from_ = models.CharField(name='from', ...)  # workaround to have `.from` field
    to = models.CharField(...)
    content = models.TextField(...)
</code></pre>
<p>since initially it will <strong>forbid to set field with name to <code>from</code></strong> with exception: <code>SyntaxError: invalid syntax</code></p>
</div>
<span class="comment-copy">It is usually constructed to add <i>fields</i> to a Django model <i>later</i> in the process. If set to <code>None</code>, it (later) takes the name of the class attribute.</span>
<span class="comment-copy">Furthermore you can use the <code>some_field.name</code> to get the name of a certain field. For example if you obtain the list of fields, with <code>SomeModel._meta</code>.</span>
<span class="comment-copy">@WillemVanOnsem i kinda see what you are saying about <b>later</b> adding. I believe if you put that to your answer with more use cases it would be really usefull for further searchers (but i already grateful for your comments).:)</span>
<span class="comment-copy">Well, this is an use-case I had not thought about. Good to know that it is an option if I ever need it.</span>
