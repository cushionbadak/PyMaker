<div class="post-text" itemprop="text">
<p>Is there a way to make sure all imports listed in all of my python files are in <code>PYTHONPATH</code>. Basically a validator for all my imports in files.</p>
<p><strong>My approach</strong>:  Change all file path from / to "." e.g. foo/bar to foo.bar and then run:
<code>pkgutil.find_loader("foo.bar")</code></p>
<p><strong>Problem</strong>: It does not work if I have foo.bar.zoo.data as a module</p>
<pre><code>export PYTHONPATH=$(pwd):"my_lib_path"
for root,dir,files in os.walk(work_dir):
        for filename in files:
            if not "__init__" in filename and filename.endswith(".py"):
               print "Testing file {}".format(os.path.join(root,filename))
               filepath = os.path.join(root,filename)
               filepath = filepath.replace(work_dir,'',)
               filepath = filepath.replace('/', '.')
               filepath = filepath.lstrip(".").rstrip(".py")
               print " testing filepath" , filepath
               # tried this also 
               '''for imp, name, _ in pkgutil.iter_modules(root):
                   full_name = "{}.{}".format(root,name)
               '''    module = imp.find_module(full_name)
               mod = pkgutil.find_loader(filepath)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best way to do this is to use the <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer"><code>importlib</code></a> (Python 3.1+) or <a href="https://docs.python.org/2/library/imp.html" rel="nofollow noreferrer"><code>imp</code></a> (Python 2.x) module to do all the steps an <code>import</code> would do up to, but not including, running the code. </p>
<p>The key functions for each Python version are:</p>
<ul>
<li>3.4-3.8: <a href="https://docs.python.org/3/library/importlib.html#importlib.util.find_spec" rel="nofollow noreferrer"><code>importlib.util.find_spec</code></a></li>
<li>3.3-3.3: <a href="https://docs.python.org/3.3/library/importlib.html#importlib.find_loader" rel="nofollow noreferrer"><code>importlib.find_loader</code></a>.</li>
<li>3.1-3.2: <a href="https://docs.python.org/3.2/library/importlib.html#importlib.machinery.PathFinder.find_module" rel="nofollow noreferrer"><code>importlib.find_module</code></a></li>
<li>3.0-3.0: <a href="https://docs.python.org/3.0/library/imp.html#imp.find_module" rel="nofollow noreferrer"><code>imp.find_module</code></a></li>
<li>1.5-2.7: <a href="https://docs.python.org/2/library/imp.html#imp.find_module" rel="nofollow noreferrer"><code>imp.find_module</code></a></li>
<li>0.9-1.4: No idea. (There were no packages yet; everything was different…)</li>
</ul>
<hr/>
<p>Advantages of doing it this way:</p>
<ul>
<li>It works whether the module is a normal Python module, a <code>.pyc</code>-only module, a C extension module, a builtin, or some funky special type of module that you've installed a custom import hook for.</li>
<li>It works even if the module is inside a <code>.egg</code>, or in the frozen bootstrap collection, or if the whole library is wrapped up in a <code>.zip</code> or even buried inside a <code>.exe</code>.</li>
<li>It automatically takes care of the funky rules, like figuring out what is or isn't a valid namespace package extension directory (including dealing with things like <code>site.py</code> and old-style <code>setuptools</code> path-injection) that would be a huge pain to get right.</li>
</ul>
<hr/>
<p>In 3.4+, this is literally the same code that <code>import</code> uses, because the entire import system is written in Python. For older versions, that's not true—but for 2.3+, it's guaranteed to get you the same thing you would get in an import hook, which is almost surely close enough.</p>
<hr/>
<p>Quoting the 3.7 docs:</p>
<blockquote>
<p><code>importlib.util.find_spec(name, package=None)</code></p>
<p>Find the spec for a module, optionally relative to the specified <strong>package</strong> name. If the module is in <code>sys.modules</code>, then <code>sys.modules[name].__spec__</code> is returned (unless the spec would be <code>None</code> or is not set, in which case <code>ValueError</code> is raised). Otherwise a search using <code>sys.meta_path</code> is done. <code>None</code> is returned if no spec is found.</p>
<p>If <strong>name</strong> is for a submodule (contains a dot), the parent module is automatically imported.</p>
<p><strong>name</strong> and <strong>package</strong> work the same as for <code>import_module()</code>.</p>
</blockquote>
<p>(You don't really have to care what a spec is here; if Python can find the spec for a module, the module is present; if it returns <code>None</code>, the module is not present.)</p>
<p>So, this will just magically handle <code>foo.bar.zoo.data</code>.</p>
<p>If you look at the <a href="https://docs.python.org/3/library/importlib.html#checking-if-a-module-can-be-imported" rel="nofollow noreferrer">Examples</a>, there's one that does exactly what you want, "Checking if a module can be imported".</p>
<pre><code>def test_module(name):
    if not importlib.util.find_spec(name):
        raise ImportError(name)
</code></pre>
<hr/>
<p>From the 2.7 docs:</p>
<blockquote>
<p><code>imp.find_module(name[, path])</code></p>
<p>Try to find the module <em>name</em>. If <em>path</em> is omitted or <code>None</code>, the list of directory names given by <code>sys.path</code> is searched, but first a few special places are searched: the function tries to find a built-in module with the given name (<code>C_BUILTIN</code>), then a frozen module (<code>PY_FROZEN</code>), and on some systems some other places are looked in as well (on Windows, it looks in the registry which may point to a specific file).</p>
<p>Otherwise, <em>path</em> must be a list of directory names; each directory is searched for files with any of the suffixes returned by <code>get_suffixes()</code> above. Invalid names in the list are silently ignored (but all list items must be strings).</p>
<p>If search is successful, the return value is a 3-element tuple <code>(file, pathname, description)</code>:</p>
<p><em>file</em> is an open file object positioned at the beginning, <em>pathname</em> is the pathname of the file found, and <em>description</em> is a 3-element tuple as contained in the list returned by <code>get_suffixes()</code> describing the kind of module found.</p>
<p>If the module does not live in a file, the returned <em>file</em> is <code>None</code>, <em>pathname</em> is the empty string, and the <em>description</em> tuple contains empty strings for its suffix and mode; the module type is indicated as given in parentheses above. If the search is unsuccessful, <code>ImportError</code> is raised. Other exceptions indicate problems with the arguments or environment.</p>
<p>If the module is a package, <em>file</em> is <code>None</code>, <em>pathname</em> is the package path and the last item in the <em>description</em> tuple is <code>PKG_DIRECTORY</code>.</p>
<p>This function does not handle hierarchical module names (names containing dots). In order to find <em>P.M</em>, that is, submodule <em>M</em> of package <em>P</em>, use <code>find_module()</code> and <code>load_module()</code> to find and load package <em>P</em>, and then use <code>find_module()</code> with the <em>path</em> argument set to <code>P.__path__</code>. When <em>P</em> itself has a dotted name, apply this recipe recursively.</p>
</blockquote>
<p>As you can see, it's a little more complicated—it doesn't magically handle <code>foo.bar.zoo.data</code>; you will need to find <code>foo</code>, verify that it's a package, load it, find <code>bar</code>, etc., and finally find (but not load) <code>data</code>.</p>
<p>Something like this (untested):</p>
<pre><code>def test_module(name):
    parts = name.split('.')
    path = None
    for part in parts[:-1]:
        file, pathname, description = imp.find_module(part, path)
        if description[-1] != imp.PKG_DIRECTORY:
            raise ImportError(name)
        pkg = imp.load_module(part, file, pathname, description)
        path = pkg.__path__
    file, pathname, description = imp.find_module(part[-1], path)
</code></pre>
</div>
<span class="comment-copy">i looked at it actually i think importlib.util.find_spec was introduce in python3+ . unfortunately i am using python 2.7</span>
<span class="comment-copy">@Stock So you have to use <code>imp</code> instead. I've edited the answer to point at the function you want. No example in the docs to copy and paste, and it doesn't quite handle everything 100% the same way as <code>import</code> itself does, but it should be all you need.</span>
<span class="comment-copy">@Stock Rewrote it to cover 2.7 more directly.</span>
<span class="comment-copy">Thanks for the smaple above, so the call  pkg = imp.load_module(part, file, pathname, description)  returns a a tuple and pkg.__path__ does now work unfortunately, i tried to take pick items from the tuple but no luck :(</span>
<span class="comment-copy">@Stock <code>imp.load_module</code> returns a tuple? That’s not what the docs say. And not what I see on any 2.7 I have, or what <a href="https://pymotw.com/2/imp/" rel="nofollow noreferrer">this blog author sees</a>, and I can’t find anything online about that. What is the tuple it returns?</span>
