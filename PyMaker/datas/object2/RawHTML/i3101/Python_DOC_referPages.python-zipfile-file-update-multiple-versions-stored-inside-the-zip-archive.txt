<div class="post-text" itemprop="text">
<p>Let's say we have a test.zip file and we update a file:</p>
<pre><code>zfh = zipfile.ZipFile("test.zip", mode = "a")
zfh.write("/home/msala/test.txt")
zfh.close()
</code></pre>
<p>Repeating a few times this "update", using the builtin method <a href="https://docs.python.org/2/library/zipfile.html" rel="nofollow noreferrer">printdir()</a>
I see in the archive there are stored not only the last one "test.txt" but also all the previous copies of the file.</p>
<p>Ok, I understand the zipfile library hasn't a delete method.</p>
<p>Questions:</p>
<ul>
<li>if I call the builtin method extract("/home/msala/test.txt"),
which copy of the file is extracted and written to the file system ?</li>
<li>inside the zip archive, is there any flag telling that old copies .. are old copies, superseded by the last one ? </li>
</ul>
<p>At the moment I list all the stored files and sort them by filename, last modification time...</p>
</div>
<div class="post-text" itemprop="text">
<p>The tl;dr is no, you can't do this without building a bit of extra info—but that can be done without sorting, and, even if you <em>did</em> have to sort, the performance cost would be irrelevant.</p>
<hr/>
<p>First, let me explain how zipfiles work. (Even if you understand this, later readers with the same problem may not.)</p>
<p>Unfortunately, <a href="https://www.iso.org/standard/60101.html" rel="nofollow noreferrer">the specification is a copyrighted and paywalled ISO document</a>, so I can't link to it or quote it. The original <a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT" rel="nofollow noreferrer">PKZip APPNOTE.TXT</a> which is the de facto pro-standardization standard is available, however. And numerous sites like <a href="https://en.wikipedia.org/wiki/Zip_(file_format)" rel="nofollow noreferrer">Wikipedia</a> have nice summaries.</p>
<p>A zipfile is 0 or more fragments, followed by a central directory.</p>
<p>Fragments are just treated as if they were all concatenated into one big file.</p>
<p>The body of the file can contain zip entries, in arbitrary order, along with anything you want. (This is how DOS/Windows self-extracting archives work—the unzip executable comes at the start of the first fragment.) Anything that looks like a zip entry, but isn't referenced by the central directory, is not treated as a zip entry (except when repairing a corrupted zipfile.)</p>
<p>Each zip entries starts with a header that gives you the filename, compression format, etc. of the following data.</p>
<p>The directory is a list of directory entries that contain most of the same information, plus a pointer to where to find the zip entry.</p>
<p>It's the order of directory entries that determines the order of the files in the archive.</p>
<hr/>
<blockquote>
<p>if I call the builtin method extract("/home/msala/test.txt"), which copy of the file is extracted and written to the file system ?</p>
</blockquote>
<p>The behavior isn't really specified anywhere.</p>
<p>Extracting the <em>whole</em> archive should extract both files, in the order present in the zip directory (the same order given by <a href="https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile.infolist" rel="nofollow noreferrer"><code>infolist</code></a>), with the second one overwriting the first. </p>
<p>But extracting by name doesn't have to give you both—it could give you the last one, or the first, or pick one at random.</p>
<p>Python gives you the last. The way this works is that, when reading the directory, it builds a dict mapping filenames to <code>ZipInfo</code>s, just adding them as encountered, so the last one will overwrite the previous ones. (<a href="https://github.com/python/cpython/blob/3.7/Lib/zipfile.py#L1259" rel="nofollow noreferrer">Here's the 3.7 code.</a>) Whenever you try to access something by filename, it just looks up the filename in that dict to get the <code>ZipInfo</code>.</p>
<p>But is that something you want to rely on? I'm not sure. On the one hand, this behavior has been the same from Python 1.6 to 3.7, which is usually a good sign that it's not going to change, even if it's never been documented. On the other hand, there are open issues—including <a href="https://bugs.python.org/issue6818" rel="nofollow noreferrer">#6818</a>, which is intended to add deletion support to the library one way or another—that could change it.</p>
<hr/>
<p>And it's really not that hard to do the same thing yourself. With the added benefit that you can use a different rule—always keep the first, always keep the one with the latest mod time, etc.</p>
<p>You seem to be worried about the performance cost of sorting the infolist, which is probably not worth worrying about. The time it takes to read and parse the zip directory is going to make the cost of your sort virtually invisible.</p>
<p>But you don't really <em>need</em> to sort here. After all, you don't want to be able to get all of the entries with a given name in some order, you just want to get one particular entry for each name. So, you can just do what <code>ZipFile</code> does internally, which takes only linear time to build, and constant time each time you search it. And you can use any rule you want here.</p>
<pre><code>entries = {}
for entry in zfh.infolist():
    if entry.filename not in entries:
        entries[entry.filename] = entries
</code></pre>
<p>This keeps the <em>first</em> entry for any name. If you want to keep the last, just remove the <code>if</code>. If you want to keep the latest by modtime, just change it <code>if entry.date_time &gt; entries[entry.filename].date_time:</code>. And so on.</p>
<p>Now, instead of relying on what happens when you call <code>extract("home/msala/test.txt")</code>, you can call <code>extract(entries["home/msala/test.txt"])</code> and know that you're getting the first/last/latest/whatever file of that name.</p>
<hr/>
<blockquote>
<p>inside the zip archive, is there any flag telling that old copies .. are old copies, superseded by the last one ?</p>
</blockquote>
<p>No, not really.</p>
<p>The way to delete a file is to remove it from the central directory. Which you do just by rewriting the central directory. Since it comes at the end of the zipfile, and is almost always more than small enough to fit on even the smallest floppy, this was generally considered fine even back in the DOS days.</p>
<p>(But notice that if you unplug the computer in the middle of it, you've got a zipfile without a central directory, which has to be rebuilt by scanning all of the file entries. So, many newer tools will instead, at least for smaller files, rewrite the whole file to a tempfile then rename it over the original, to guarantee a safe, atomic write.)</p>
<p>At least some early tools would sometimes, especially for gigantic archives, rewrite the entry's pathname's first byte with a NUL. But this doesn't really mark the entry as deleted, it just renames it to <code>"\0ome/msala/test.txt"</code>. And many modern tools will in fact treat it as meaning exactly that and give you weird errors telling you they can't find a directory named <code>'ome'</code> or <code>''</code> or something else fun. Plus, this means the filename in the directory entry no longer matches the filename in the file entry header, which will cause many modern tools to flag the zipfile as corrupted.</p>
<p>At any rate, Python's <code>zipfile</code> module doesn't do either of these, so you'd need to subclass <code>ZipFile</code> to add the support yourself.</p>
</div>
<div class="post-text" itemprop="text">
<p>I solved this way, similar to database records management.</p>
<p>Adding a file to the archive, I look for previous stored copies (same filename).
For each of them, I set their field "comment" to a specific marker, for example "deleted".</p>
<p>We add the new file, with comment = empty.</p>
<p>As we like, we can "vacuum": shrink the zip archive using the usually tools (under the hood a new archive is created, discarding the files having the comment set to "deleted").</p>
<p>This way, we have also a simple "versioning".
We have all the previous files copies, until the vacuum.</p>
</div>
<span class="comment-copy">can't you re-create the archive from scratch?</span>
<span class="comment-copy">related very closely: <a href="https://stackoverflow.com/questions/4653768/overwriting-file-in-ziparchive" title="overwriting file in ziparchive">stackoverflow.com/questions/4653768/…</a>. But there are no answers for your questions.</span>
<span class="comment-copy">I found evil the documentation doesn't explain about extract(&lt;filename&gt;) which copy of the file is written to disk</span>
<span class="comment-copy">I don't need to recreate the file, I only need a good way (without sort) to know which is the last copy inserted. Perhaps inside the ZIP there IS this info. I don't understand if zipfile uses and/or provides it.</span>
<span class="comment-copy">I understand. The drawback is that it creates "evil twin" files in your archive.</span>
<span class="comment-copy">I am not worried about sort(). I am worried, as a general rule, to not re-invent the wheel.</span>
<span class="comment-copy">@Massimo In this case, the "wheel" is just a dict mapping filenames to <code>ZipInfo</code> objects. That's trivial enough that doing it yourself, rather than relying on undocumented internals of the module, is probably a better idea.</span>
