<div class="post-text" itemprop="text">
<p>I made a bunch of functions that control a message-based instrument. I know how to use them but the functions should be fool-proof in case somebody else wants to code with it after I'm gone. Here is an example function:</p>
<pre><code>def AutoRange(self, Function, Source, Value):
    """Enable or disable the instrument autoranging feature.\n
    :Function: "source" or "measure".
    :Source: "v" or "i".
    :Value: 0 or 1."""

    # &lt;Something goes here to check if the inputs are valid&gt;
    self.WRITE("smua.%s.autorange%s = %s" %(Function, Source, Value))
</code></pre>
<p>To comply with the input requirements I initially added a <code>RaiseException</code> at the start in an ugly way:</p>
<pre><code>    AllowedFunctions = ("source", "measure")
    AllowedSources = ("v", "i")
    AllowedValues = (0, 1)
    if not(Function in AllowedFunctions and Source in AllowedSources and Value in AllowedValues):
        raise Exception("/!\ Error in Keithley.Autorange(): Input not allowed.")
</code></pre>
<p>After reading about <code>assert()</code> I replaced the <code>if</code> with this:</p>
<pre><code>    MyErrorMessage = "/!\ Error in Keithley.Autorange(): Input not allowed."
    assert (Function in ("source", "measure")), MyErrorMessage
    assert (Source in ("v", "i")), MyErrorMessage
    assert (Value in (0, 1)), MyErrorMessage
</code></pre>
<p>A possible neater variant would be this:</p>
<pre><code>    ValidInputs = (    Function in ("source", "measure")
                   and Source in ("v", "i")
                   and Value in (0, 1))

    assert (ValidInputs), "/!\ Error in Keithley.Autorange(): Input not allowed."
</code></pre>
<p>The second option is nicer now that I think of it because then I can tell specifically which input was invalid. So my question is: <strong>is this how you should handle assertions? 1</strong> <code>assert()</code> <strong>for 1 input? If not, what is the adviced structure?</strong> Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not do what Python does?</p>
<p>Let's see an example:</p>
<pre><code>open("foo", "q")
# =&gt; ValueError: invalid mode: 'q'
</code></pre>
<p><code>open</code> is in C, but you can see how it looks like for e.g <a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/lzma.py#L289" rel="nofollow noreferrer"><code>gzip.open</code></a>:</p>
<pre><code>if "t" in mode:
    if "b" in mode:
        raise ValueError("Invalid mode: %r" % (mode,))
</code></pre>
<p>Don't be scared of making the code a little longer; you can't really avoid it in Python. And also, "Error in Keithley.Autorange(): Input not allowed." doesn't tell the programmer which input is not allowed. In this case, explicit and clear is better than clever and short.</p>
<p>I'd do:</p>
<pre><code>def auto_range(self, function, source, value):
    if function not in ["source", "measure"]:
        raise ValueError("Invalid function: %s" % function)
    if source not in ["v", "i"]:
        raise ValueError("Invalid source: %s" % source)
    if value not in [0, 1]:
        raise ValueError("Invalid value: %d" % value)
    # ...
</code></pre>
<p>Not directly relevant to your questions, but it is best to stick to the language's coding style: in Python, variables are in <code>snake_case</code> (lowercase with underscores).</p>
</div>
<span class="comment-copy"><code>assert</code> is not intended for such use, to quote the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement" rel="nofollow noreferrer">official documentation</a>: "Assert statements are a convenient way to insert <b>debugging</b> assertions into a program" - you can get Python to easily ignore all assertions with <code>-O</code> parameter. Just validate your inputs the old fashion way (you can use a validation map to save on verbosity) and raise appropriate exceptions when needed.</span>
<span class="comment-copy">Yes, thank you. just before seeing your reply I made an edit about how I should really tell which input was invalid instead of sending a general error that is not indicative enough.</span>
<span class="comment-copy">There are at least two that come to mind: consistency, and the fact noted by @zwer that assert-checks can be disabled to speed up a production system. The point I'm making is, what's good enough for Python should be good enough for Guimoute :) And Python does not value compactness. You want compact, go learn J or something (sample: <code>quicksort=: (($:@(&lt;#[), (=#[), $:@(&gt;#[)) ({~ ?@#)) ^: (1&lt;#)</code>)</span>
<span class="comment-copy">Then set as appropriate. I was halfway to making that line <code>if not 0 &lt;= x &lt;= 1:</code> just to make a point. If it was meant to be a boolean, I wouldn't even validate it, just see if it's truthy, really. All that beside the point: Python code is full of functions where <i>documentation string</i> is several times bigger than the code. It truly does not matter.</span>
<span class="comment-copy">well, I know you know :)</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre careful with your suggestion because that makes "vi" a valid input that does not raise errors while only "v" and "i" are supported.</span>
