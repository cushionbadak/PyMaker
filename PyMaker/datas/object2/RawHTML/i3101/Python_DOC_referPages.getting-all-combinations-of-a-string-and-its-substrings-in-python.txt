<div class="post-text" itemprop="text">
<p>I've seen many questions on getting all the possible substrings (i.e., adjacent sets of characters), but none on generating all possible strings including the combinations of its substrings.</p>
<p>For example, let:</p>
<pre><code>x = 'abc'
</code></pre>
<p>I would like the output to be something like:</p>
<pre><code>['abc', 'ab', 'ac', 'bc', 'a', 'b', 'c']
</code></pre>
<p>The main point is that we can remove multiple characters that are not adjacent in the original string (as well as the adjacent ones).</p>
<p>Here is what I have tried so far:</p>
<pre><code>def return_substrings(input_string):
    length = len(input_string)
    return [input_string[i:j + 1] for i in range(length) for j in range(i, length)]

print(return_substrings('abc'))
</code></pre>
<p>However, this only removes sets of adjacent strings from the original string, and will not return the element <code>'ac'</code> from the example above.</p>
<p>Another example is if we use the string <code>'abcde'</code>, the output list should contain the elements <code>'ace'</code>, <code>'bd'</code> etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this easily using <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="noreferrer"><code>itertools.combinations</code></a></p>
<pre><code>&gt;&gt;&gt; from itertools import combinations
&gt;&gt;&gt; x = 'abc'
&gt;&gt;&gt; [''.join(l) for i in range(len(x)) for l in combinations(x, i+1)]
['a', 'b', 'c', 'ab', 'ac', 'bc', 'abc']
</code></pre>
<p>If you want it in the reversed order, you can make the <code>range</code> function return its sequence in reversed order</p>
<pre><code>&gt;&gt;&gt; [''.join(l) for i in range(len(x),0,-1) for l in combinations(x, i)]
['abc', 'ab', 'ac', 'bc', 'a', 'b', 'c']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a fun exercise. I think other answers may use itertools.product or itertools.combinations. But just for fun, you can also do this recursively with something like</p>
<pre><code>def subs(string, ret=['']):
    if len(string) == 0:
        return ret
    head, tail = string[0], string[1:]
    ret = ret + list(map(lambda x: x+head, ret))
    return subs(tail, ret)

subs('abc')
# returns ['', 'a', 'b', 'ab', 'c', 'ac', 'bc', 'abc']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@Sunitha <a href="https://stackoverflow.com/a/51538300/7692463">answer</a> provided the right tool to use. I will just go and suggest an improved way while using your <code>return_substrings</code> method. Basically, <strong>my solutions will take care of duplicates</strong>.</p>
<hr/>
<p>I will use <code>"ABCA"</code> in order to prove validity of my solution. Note that it would include a duplicate <code>'A'</code> in the returned list of the accepted answer. </p>
<p><strong>Python 3.7+ solution</strong>,</p>
<pre><code>x= "ABCA"
def return_substrings(x):
    all_combnations = [''.join(l) for i in range(len(x)) for l in combinations(x, i+1)]
    return list(reversed(list(dict.fromkeys(all_combnations))))
    # return list(dict.fromkeys(all_combnations)) for none-reversed ordering

print(return_substrings(x))
&gt;&gt;&gt;&gt;['ABCA', 'BCA', 'ACA', 'ABA', 'ABC', 'CA', 'BA', 'BC', 'AA', 'AC', 'AB', 'C', 'B', 'A']
</code></pre>
<p><strong>Python 2.7 solution</strong>,</p>
<p>You'll have to use <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a> instead of a normal <code>dict</code>. Therefore,</p>
<pre><code> return list(reversed(list(dict.fromkeys(all_combnations))))
</code></pre>
<p>becomes </p>
<pre><code>return list(reversed(list(OrderedDict.fromkeys(all_combnations))))
</code></pre>
<p><strong>Order is irrelevant for you ?</strong></p>
<p>You can reduce code complexity if order is not relevant,</p>
<pre><code>x= "ABCA"
def return_substrings(x):
    all_combnations = [''.join(l) for i in range(len(x)) for l in combinations(x, i+1)]
    return list(set(all_combnations))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def return_substrings(s):
    all_sub = set()
    recent = {s}

    while recent:
        tmp = set()
        for word in recent:
            for i in range(len(word)):
                tmp.add(word[:i] + word[i + 1:])
        all_sub.update(recent)
        recent = tmp

    return all_sub
</code></pre>
</div>
<span class="comment-copy">Do you <i>really</i> want to do this the hard way? It's very easy to do it with the standard <code>itertools.combinations</code> function, and it will run faster, too.</span>
<span class="comment-copy">This is basically a string version of <code>whats a good way to find power_set</code>.  <a href="https://stackoverflow.com/questions/1482308/whats-a-good-way-to-combinate-through-a-set" title="whats a good way to combinate through a set">stackoverflow.com/questions/1482308/â€¦</a></span>
<span class="comment-copy">Those are combinations, not "iterations". A combination is basically a subset where order does not matter.  If order matters, it's a permutation.</span>
<span class="comment-copy">@MikeHousky Thanks for the correction, I'll change the title.</span>
<span class="comment-copy">If you ever want to take care of strings like <code>"AAAA"</code> and not have unnecessary duplicates, look at my answer.</span>
<span class="comment-copy">@PM2Ring.. Updated the answer to get the o/p in reversed order too</span>
<span class="comment-copy">Also, shouldn't it be <code>len(x)</code> and not <code>len(s)</code> ?</span>
<span class="comment-copy">@scharette. Thanks... It should have been <code>len(x)</code>.</span>
<span class="comment-copy">Although Python comes with "batteries included", it's certainly good for people to see how to do this task recursively. Now see if you can get the output in the order shown in the question without using sorting. :evil grin:</span>
<span class="comment-copy">@PM2Ring Maybe a merge between my answer and his could do it ;)</span>
