<div class="post-text" itemprop="text">
<p>I have tried using the Pydub library; however, it only allows the reduction or increase of a certain amount of decibels. How would I proceed if I wanted, for example, to reduce the volume of the wav by a certain percent?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is simple enough to just do with just the tools in the stdlib.</p>
<p>First, you use <a href="https://docs.python.org/3/library/wave.html" rel="nofollow noreferrer"><code>wave</code></a> to open the input file and create an output file:</p>
<pre><code>pathout = os.path.splitext(path)[0] + '-quiet.wav' 
with wave.open(path, 'rb') as fin, wave.open(pathout, 'wb') as fout:
</code></pre>
<p>Now, you have to copy over all the wave params, and hold onto the sample width for later:</p>
<pre><code>fout.setparams(fin.getparams())
sampwidth = fin.getsampwidth()
</code></pre>
<p>Then you loop over frames until done:</p>
<pre><code>while True:
    frames = bytearray(fin.readframes(1024))
    if not frames:
        break
</code></pre>
<p>You can use <a href="https://docs.python.org/3/library/audioop.html" rel="nofollow noreferrer"><code>audioop</code></a> to process this data:</p>
<pre><code>frames = audioop.mul(frames, sampwidth, factor)
</code></pre>
<p>… but this will only work for 16-bit little-endian signed LPCM wave files (the most common kind, but not the only kind). You could solve that with other functions—most importantly, <code>lin2lin</code> to handle 8-bit unsigned LPCM (the second most common kind). But it's worth understanding how to do it manually:</p>
<pre><code>for i in range(0, len(frames), sampwidth):
    if sampwidth == 1:
        # 8-bit unsigned
        frames[i] = int(round((sample[0] - 128) * factor + 128)
    else:
        # 16-, 24-, or 32-bit signed
        sample = int.from_bytes(frames[i:i+sampwidth], 'little', signed=True)
        quiet = round(sample * factor)
        frames[i:i+sampwidth] = int(quiet).to_bytes(sampwidth, 'little', signed=True)
</code></pre>
<p><code>audioop.mul</code> only handles the <code>else</code> part—but it does more than I've done here. In particular, it has to handle cases with factors over 1—a naive multiply would clip, which will just add weird distortion without adding the desired max energy. (It's worth reading <a href="https://bitbucket.org/pypy/pypy/src/2ca5d2f3a174ec02ebf49f889aee1efe1922d71a/lib_pypy/audioop.py" rel="nofollow noreferrer">the pure Python implementation from PyPy</a> if you want to learn the basics of this stuff.)</p>
<p>If you also want to handle float32 files, you need to look at the format, because they have the same <code>sampwidth</code> as int32, and you'll probably want the <code>struct</code> module or the <code>array</code> module to pack and unpack them. If you want to handle even less common formats, like a-law and µ-law, you'll need to read <a href="http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html" rel="nofollow noreferrer">a more detailed format spec</a>. Notice that <code>audioop</code> has tools for handling most of them, like <code>ulaw2lin</code> to convert µ-law to LPCM so you can process it and convert it back—but again, it might be worth learning how to do it manually. And for some of them, like CoolEdit float24/32, you pretty much have to do it manually.</p>
<p>Anyway, once you've got the quieted frames, you just write them out:</p>
<pre><code>fout.writeframes(frames)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="https://docs.python.org/3.5/library/audioop.html#audioop.mul" rel="nofollow noreferrer"><code>mul</code> function</a> from the <a href="https://docs.python.org/3.5/library/audioop.html" rel="nofollow noreferrer">built-in <code>audioop</code> module</a>. This is what <a href="https://github.com/jiaaro/pydub/blob/da21c384bd5f86ffd8395e5a0e827941563e1b58/pydub/effects.py#L331" rel="nofollow noreferrer">pydub uses internally</a>, after converting the decibel value to a multiplication factor.</p>
</div>
<span class="comment-copy">I'm not sure how to use it. Isn't factor supposed to be between 0 and 1? It seems to make no sound when it's 0, a higher (and a bit distorted) sound between 0 and 1, apply no change when it's 1 and make a very quiet sound when it's higher than 1.</span>
<span class="comment-copy">It's a factor applied to the raw sample value. For example, a factor of 0.8 should reduce every sample value by 20%.</span>
<span class="comment-copy">@J6MK2 If your wave files are 16-bit int, <code>mul</code> should just work. If they're 8-bit uint, or 32-bit float, or one of the less common formats like 8-bit a-law, that might be the issue.</span>
<span class="comment-copy">@abarnert Looks like the issue was that I was actually using 8-bit uint wavs after all.</span>
