<div class="post-text" itemprop="text">
<p>What the program should do is take steps and a number and than output you how many unique sequences there are with exactly x <code>steps</code> to create <code>number</code>. </p>
<p>Does someone know how I can save some memory - as I should make this work for pretty huge numbers within a 4 second limit.</p>
<pre><code>def IsaacRule(steps, number):
    if number in IsaacRule.numbers:
        return 0
    else:
        IsaacRule.numbers.add(number)
    if steps == 0:
        return 1
    counter = 0
    if ((number - 1) / 3) % 2 == 1:
        counter += IsaacRule(steps-1, (number - 1) / 3)
    if (number * 2) % 2 == 0:
        counter += IsaacRule(steps-1, number*2)

    return counter

IsaacRule.numbers = set()

print(IsaacRule(6, 2))
</code></pre>
<p>If someone knows a version with memoization I would be thankful, right now it works, but there is still room for improvement. </p>
</div>
<div class="post-text" itemprop="text">
<p>Baseline: <code>IsaacRule(50, 2)</code> takes 6.96s</p>
<h1>0) Use the LRU Cache</h1>
<p>This made the code take longer, and gave a different final result</p>
<h1>1) Eliminate the if condition: <code>(number * 2) % 2 == 0</code> to <code>True</code></h1>
<p><code>IsaacRule(50, 2)</code> takes 0.679s. Thanks Pm2Ring for this one. </p>
<h1>2) Simplify <code>((number - 1) / 3) % 2 == 1</code> to <code>number % 6 == 4</code> and use floor division where possible:</h1>
<p><code>IsaacRule(50, 2)</code> takes 0.499s</p>
<p>Truth table: </p>
<pre><code>| n | n-1 | (n-1)/3 | (n-1)/3 % 2 | ((n-1)/3)%2 == 1 |
|---|-----|---------|-------------|------------------|
| 1 | 0   | 0.00    | 0.00        | FALSE            |
| 2 | 1   | 0.33    | 0.33        | FALSE            |
| 3 | 2   | 0.67    | 0.67        | FALSE            |
| 4 | 3   | 1.00    | 1.00        | TRUE             |
| 5 | 4   | 1.33    | 1.33        | FALSE            |
| 6 | 5   | 1.67    | 1.67        | FALSE            |
| 7 | 6   | 2.00    | 0.00        | FALSE            |
</code></pre>
<p>Code: </p>
<pre><code>def IsaacRule(steps, number):
    if number in IsaacRule.numbers:
        return 0
    else:
        IsaacRule.numbers.add(number)
    if steps == 0:
        return 1
    counter = 0
    if number % 6 == 4:
        counter += IsaacRule(steps-1, (number - 1) // 3)
    counter += IsaacRule(steps-1, number*2)

    return counter
</code></pre>
<h1>3) Rewrite code using sets</h1>
<p><code>IsaacRule(50, 2)</code> takes 0.381s</p>
<p>This lets us take advantage of any optimizations made for sets. Basically I do a breadth first search here. </p>
<h1>4) Break the cycle so we can skip keeping track of previous states.</h1>
<p><code>IsaacRule(50, 2)</code> takes 0.256s</p>
<p>We just need to add a check that <code>number != 1</code> to break the only known cycle. This gives a speed up, but you need to add a special case if you start from 1. Thanks Paul for suggesting this!</p>
<pre><code>START = 2
STEPS = 50

# Special case since we broke the cycle
if START == 1:
    START = 2
    STEPS -= 1

current_candidates = {START} # set of states that can be reached in `step` steps

for step in range(STEPS):
    # Get all states that can be reached from current_candidates
    next_candidates = set(number * 2 for number in current_candidates if number != 1) | set((number - 1) // 3 for number in current_candidates if number % 6 == 4)

    # Next step of BFS
    current_candidates = next_candidates
print(len(next_candidates))
</code></pre>
</div>
<span class="comment-copy">You can speed it up a little with a memoization cache, eg <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a>. That will use <i>more</i> memory though. And it doesn't save a lot of recursive calls. Eg with <code>IsaacRule(40, 1)</code> I get a count of 66588 and these cache stats: CacheInfo(hits=6057, misses=48335, maxsize=None, currsize=48335). But I guess 12% or so cache hits is better than nothing.</span>
<span class="comment-copy">BTW, you should be using the floor division operator <code>//</code> for this. It won't hurt to use <code>/</code> in Python 2, but it makes a difference in Python 3.</span>
<span class="comment-copy">I just noticed that your 2nd <code>if</code> is redundant: <code>(number * 2) % 2 == 0</code> is true for any integer. But I haven't closely analyzed your code's logic. Are you <i>sure</i> it's doing the right thing?</span>
<span class="comment-copy">haha nice thx PM 2Ring - removing the second if already made the deal for &lt;= 53 steps and 2^(53-steps) numbers now its just about optimication :P  Why should I use floor divition?  ps: with floor divition ((number - 1) // 3) % 2 == 1 I get the wrong output 5 instead of 4</span>
<span class="comment-copy">We need to use float division in the condition check, though. As an example, 23 cannot be generated by the 3n+1 rule, but <code>((23 - 1) // 3) % 2 == 1</code>. Alternatively, this condition should be replaced with <code>number % 6 == 4</code></span>
<span class="comment-copy">really nice, couldnt think of a way without recursion to do this even tho I don't quite understand it yet ... why is next_candidates = set(...) | set(...)  choosing the right next number with * 2 or the other</span>
<span class="comment-copy">It's doing the equivalent of: <code>for number in current_candidates: next_candidates.append(2 * number); if (... == 4) next_candidates.append(...)</code>. basically I'm trying to get all the possible successors of <code>current_candidates</code></span>
<span class="comment-copy">I don't think you need <code>seen_numbers</code> if you filter out <code>number != 1</code> in the first set comprehension.</span>
<span class="comment-copy">@PaulHankin good point, thanks! Strictly speaking, that's only true if the Collatz conjecture is true :). We also need a special case for starting at 1, but it gives a nice speed-up</span>
<span class="comment-copy">I found that  <code>{n * 2 for n in c - {1}}</code>  works better for larger number of steps than <code>set(number * 2 for number in current_candidates if number != 1)</code> . cheaper to generate a set with number and then remove 1 after just once instead of checking every potential number for equiality</span>
