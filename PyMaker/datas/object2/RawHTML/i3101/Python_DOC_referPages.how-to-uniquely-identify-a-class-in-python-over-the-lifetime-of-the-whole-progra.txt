<div class="post-text" itemprop="text">
<h1>Question</h1>
<p>How to uniquely identify a class in Python over the lifetime of the whole program? I'm interested in both built-in types and user-defined ones. <code>id</code> is not suitable because:</p>
<blockquote>
<p>[<code>id</code>] returns the “identity” of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.</p>
</blockquote>
<p>Is it possible?</p>
<h1>Concrete use-case</h1>
<p>I have a dictionary with strings as keys and Python's types/classes as values. For example:</p>
<p><code>{'tid': int, 'name': str, 'color': str}</code></p>
<p>The problem is to uniquely identify a combination of strings and types and use it as basis for comparison. Therefore, dictionary <code>{'tid': int, 'name': str, 'color': str}</code> and  dictionary <code>{'tid': float, 'name': str, 'color': str}</code> should be ruled unequal. Similarly, <code>{'tid': int, 'name': str, 'color': str}</code> and  <code>{'tid': int, 'name': str, 'colour': str}</code>.</p>
<h1>The catch</h1>
<p>Additionally, the comparison should work if names and types are hashed and result is stored (because comparing integers is faster then comparing dicts). For example:</p>
<pre><code>def hash_heading(dct):
    s = ''
    for k, v in OrderedDict(dct).items():
        s += k + str(id(v))
    return hash(s)
</code></pre>
<p>This introduces the risk that two classes A and B, with disjoint lifetimes, are assigned the same <code>id</code> (in case A was destroyed before B was declared) and, therefore, the check passes.</p>
<hr/>
<p><br/>
[1] <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#id</a></p>
</div>
<div class="post-text" itemprop="text">
<p>First of all: built-in types and custom Python types are all just Python objects. For the purposes of <code>id()</code> there are no differences you need to be concerned about.</p>
<p>You really do want to use <code>id()</code> to track classes. Because if the <code>id()</code> has changed, that means you no longer have the same class. And vice-versa, because <code>id()</code> values can be re-used for objects with non-overlapping life-times, having the same <code>id()</code> value does not mean you still have the same object.</p>
<p>Classes are meant to be singletons. Classes are rarely redefined, because most code would define them at the module level and modules are singletons too (they live in <code>sys.modules</code> and are loaded just the once).</p>
<p>Moreover, a class with a different ID <strong>is not the same class</strong>. It may have the same name, it may live in the same module, but you can't use one to assert that instances of the other are of the same type. You should not try to track classes across the lifetime of Python and disregard their <code>id()</code> value.</p>
<p>A quick demo to illustrate why you can't:</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; module.Foo = type('Foo', (), {'__module__': module.__name__})
&gt;&gt;&gt; module.Foo
&lt;class 'foo.Foo'&gt;
&gt;&gt;&gt; id(module.Foo)
140646171069480
&gt;&gt;&gt; foo_instance = module.Foo()
&gt;&gt;&gt; isinstance(foo_instance, module.Foo)
True
&gt;&gt;&gt; module.Foo = type('Foo', (), {'__module__': module.__name__})  # new class, same name, same location!
&gt;&gt;&gt; id(module.Foo)
140646170684440
&gt;&gt;&gt; isinstance(foo_instance, module.Foo)
False
&gt;&gt;&gt; type(foo_instance)
&lt;class 'foo.Foo'&gt;
&gt;&gt;&gt; type(foo_instance) is not module.Foo
True
</code></pre>
<p>The <code>foo_instance</code> instance is an instance of the class <code>Foo</code>, but it is the <em>first</em> <code>Foo</code> class it is an instance of. By creating a new <code>Foo</code> class, <code>id()</code> changed with it, but it tells you we now have a distinct, new class object that is a different object.</p>
<p>And if you were to only track the <code>id()</code>, if all references to the original <code>Foo</code> were to be removed, the object removed from memory, and then a new <code>Foo</code> was created, <em>it could have the same <code>id()</code> value</em>, as <code>id()</code> values can be re-used. So you could have a <em>new</em> <code>Foo</code>, with the same <code>id()</code>. This matters less, because old <code>Foo</code> could only have been deleted from memory if there were no more references. Instances hold a reference to their class, so if there are instances of a class, the class continues to be retained in memory.</p>
<p>If all you are doing is comparing classes contained in dictionaries, then you don't need to resort to <code>id()</code> testing <em>at all</em>, because class equality tests only ever return true for objects that are identical. <code>reference_to_class == other_reference_to_class</code> is only ever <code>True</code> if both references are to the same class object; the test is essentially the same as <code>reference_to_class is other_reference_to_class</code>. And dictionaries hold references to all their contents, keeping those contents alive. By virtue of storing types in a dictionary, you ensured their <code>id()</code> values can't change either.</p>
<p>The post you link to is not asking about the <code>id()</code> of classes. They are discussing the <code>id()</code> values of <strong>instances</strong>; it discusses things like multiple instances having different <code>id()</code> values, and that creating and discarding instances in quick succession does not guarantee that the <code>id()</code> of the first is reused for the second.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming your use case is something like this (but not as trivial and pointless): You're keeping a set of every collection of types you've seen since startup, so you can do something like this:</p>
<pre><code>def seen_before(types):
    if ???:
        print("I've seen those types before")

&gt;&gt;&gt; seen_before({'name': str, 'value': int})
&gt;&gt;&gt; seen_before({'name': str, 'value': int})
I've seen those types before!
</code></pre>
<hr/>
<p>The problem is, you can't stick a dict mapping strings to types in a set. </p>
<p>So, your idea was to flatten that out into something hashable, by storing, say, a frozenset or sorted tuple of <code>(name, id(typ))</code> pairs.</p>
<p>But the problem is:</p>
<pre><code>&gt;&gt;&gt; class C: pass
&gt;&gt;&gt; seen_before({'name': str, 'value': C})
&gt;&gt;&gt; del C
&gt;&gt;&gt; class D: pass
&gt;&gt;&gt; seen_before({'name': str, 'value': D})
I've seen those types before!
</code></pre>
<p>While this is <em>unlikely</em> to happen (your users are unlikely to ever destroy a class like that), it's not <em>impossible</em>. <code>C</code> and <code>D</code> have disjoint lifetimes, so they could end up with the same <code>id</code>.</p>
<hr/>
<p>But you don't need the <code>id</code> here. Types are already hashable, so you can just store them instead of their <code>id</code>s:</p>
<pre><code>def seen_before(types, *, _cache=set()):
    tup = tuple(sorted(map(tuple, types.items()))
    if tup in _cache:
        print("I've seen those types before")
    _cache.add(tup)
</code></pre>
<p>Now, because you're storing the types in the set, any type anyone ever passes you will live forever, so the whole issue of types with disjoint lifetimes colliding never arises.</p>
<hr/>
<p>If you <em>wanted</em> to use the ids instead of the types themselves, for some other reason, that would still work… as long as you stored the types somewhere:</p>
<pre><code>def seen_before(types, *, _cache=set(), _typestash=set()):
    tup = tuple(sorted((name, id(typ)) for name, typ in types.items()))
    if tup in _cache:
        print("I've seen those types before")
    else:
        _cache.add(tup)
        _typestash.update(types.values())
</code></pre>
<p>… or:</p>
<pre><code>def seen_before(types, *, _cache={}):
    tup = tuple(sorted((name, id(typ)) for name, typ in types.items()))
    if tup in _cache:
        print("I've seen those types before")
    else:
        _cache[tup] = list(types.values())
</code></pre>
<hr/>
<p>In idiomatic Python code, types usually live forever anyway, and there are only a few hundred of them, so this is fine.</p>
<p>But what if someone were doing something weird, like creating and destroying huge types in a loop? Storing a million arbitrary-sized types might be a lot more expensive than storing a million 64-bit ints.</p>
<p>Or, what if someone were doing something <em>really</em> weird, like creating types with a metaclass with a <code>__del__</code> method that does something important? Then storing every type you're handed is making an important semantic change (and one that's pretty well hidden, making it hard to debug).</p>
<p>You could mitigate both of these problems by storing weakrefs to the types, instead of the types themselves (and then using the pair of the type's and weakref's ids as a key instead of just the type's id). Even if the type goes away, its dead weakref will not. Even if a new type gets the same id, it won't match the dead weakref, so it will get a new one, so its pair of ids will be different.</p>
<p>Of course storing weakrefs still isn't free, or even quite as cheap as storing ints. But at least they're of static and pretty small size, no matter how big the things they refer to are. And they don't interfere with their targets' destruction any more than storing the <code>id</code>s do.</p>
</div>
<span class="comment-copy">Are you trying to uniquely identify the class, or a particular instance of that class?</span>
<span class="comment-copy">Can you elaborate on what exactly it is you're trying to do?</span>
<span class="comment-copy">Classes are rarely deleted or re-defined. If the id of a class changes, <b>it is not the same class</b> anyway.</span>
<span class="comment-copy">have you tried just saving the class (or an instance's <code>__class__</code> value) to a global value with the lifetime you want?</span>
<span class="comment-copy">The problem is that without knowing what your use case is, it’s next to impossible to guess what answer will satisfy you. The fact that you’re refusing to answer people’s questions doesn’t help.</span>
<span class="comment-copy">Thank you for the answer. I assumed that, classes being objects themselves, changing ids affects classes too. If that's incorrect, my bad.</span>
<span class="comment-copy">@Siegmeyer: of course they are objects, and they have an <code>id()</code>. But their lifetime doesn't just stop and start randomly. Classes are defined when the code that contains the <code>class</code> statement executes (or when you use the <code>type()</code> function as I did in my answer). They are removed from memory when nothing references them any more. That would generally not happen in the lifetime of a Python program.</span>
<span class="comment-copy">Technically, it’s possible to create and destroy new classes as fast as you can create and destroy anything else. It’s not something you’d have any idiomatic reason to do, but it is something you <i>could</i> do. So it is possible for two different classes (of the same metaclass or otherwise) to have non-overlapping lifetimes and reuse the same id values.</span>
<span class="comment-copy">@Siegmeyer: <b>as long as there is a reference to an object</b> their id won't change. Storing objects in a dictionary means there is at least one reference to that object, the dictionary.</span>
<span class="comment-copy">@abarnert: sure, in theory. But then there are 0 references to the old class anyway. Making <code>id()</code> even less appealing as a means to track them.</span>
<span class="comment-copy">Again - thanks a lot. This is very informative. In my case it's quite safe to assume that users will not do anything weird like that, but I will certainly look into weak-refs.</span>
