<div class="post-text" itemprop="text">
<p>I made a small program and tested that it <em>does</em> keep the order. However, I still want to be sure that <code>deepcopy</code> is guaranteed to do that.</p>
<pre><code>import copy
import collections

a_dict = collections.OrderedDict()
a_dict['m'] = 10
a_dict['u'] = 15
a_dict['c'] = 5
a_dict['h'] = 25
a_dict['a'] = 55
a_dict['s'] = 30

print(a_dict)

other_dict = copy.deepcopy(a_dict)

other_dict['g'] = 75
other_dict['r'] = 35

print(other_dict)
</code></pre>
<p>The output of this program is </p>
<pre><code>OrderedDict([('m', 10), ('u', 15), ('c', 5), ('h', 25), ('a', 55), ('s', 30)])
OrderedDict([('m', 10), ('u', 15), ('c', 5), ('h', 25), ('a', 55), ('s', 30), ('g', 75), ('r', 35)])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In CPython, it appears the order is preserved. I drew that conclusion from inspecting the implementation of <code>deepcopy</code>. In this case, it will find either the <code>__reduce_ex__</code> or <code>__reduce__</code> method on your <code>OrderedDict</code> object to use for pickling:</p>
<p>(<a href="https://github.com/python/cpython/blob/master/Lib/copy.py#L159-L161" rel="nofollow noreferrer">https://github.com/python/cpython/blob/master/Lib/copy.py#L159-L161</a>)</p>
<pre><code>def deepcopy(x, memo=None, _nil=[]):
...
                    reductor = getattr(x, "__reduce_ex__", None)
                    if reductor is not None:
                        rv = reductor(4)
                    else:
                        reductor = getattr(x, "__reduce__", None)
                        if reductor:
                            rv = reductor()
</code></pre>
<p>Those return <code>odict_iterator</code> objects for constructing, so order would be preserved:</p>
<pre><code>&gt;&gt;&gt; a = {}
&gt;&gt;&gt; b = collections.OrderedDict()
&gt;&gt;&gt; a['a'] = 1
&gt;&gt;&gt; b['a'] = 1
&gt;&gt;&gt; a.__reduce_ex__(4)
(&lt;function __newobj__ at 0x10471a158&gt;, (&lt;class 'dict'&gt;,), None, None, &lt;dict_itemiterator object at 0x104b5d958&gt;)
&gt;&gt;&gt; a.__reduce__()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/opt/local/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/copyreg.py", line 65, in _reduce_ex
    raise TypeError("can't pickle %s objects" % base.__name__)
TypeError: can't pickle dict objects
&gt;&gt;&gt; b.__reduce_ex__(4)
(&lt;class 'collections.OrderedDict'&gt;, (), None, None, &lt;odict_iterator object at 0x104c02d58&gt;)
&gt;&gt;&gt; b.__reduce__()
(&lt;class 'collections.OrderedDict'&gt;, (), None, None, &lt;odict_iterator object at 0x104c5c780&gt;)
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Correctly implemented copying via <code>copy.deepcopy</code> should produce an object that is equal to the original (assuming equality is defined at all). While no, there is no explicit documented guarantees regarding <code>OrderedDict</code> and <code>copy.deepcopy</code> specifically, if the ordering of <code>OrderedDict</code> changed in the copy, it would not be equal to the original <code>OrderedDict</code>, which would violate the expectation of copy-equality in a big way.</p>
<p>No firm guarantee can truly be given, since the <code>__deepcopy__</code> method of a key or a value could do something truly terrible (modifying the source <code>OrderedDict</code> for instance), but aside from pathological cases, you can rely on <code>copy.deepcopy</code> to preserve ordering.</p>
</div>
<div class="post-text" itemprop="text">
<p>deepcopy of an object should return an object of the same type. so an ordereddict returned as a copy should remain ordered?</p>
<p><strong>EDIT</strong> - This is not completely correct answer. Please look at Greg's comment below.</p>
</div>
<span class="comment-copy">You would have to look in the c code to see if deepcopy is able to copy the linked list that defines the ordereddicts order. My guess is itâ€™s doable.</span>
<span class="comment-copy">It looks like there is no special casing for <code>OrderedDict</code> in the <code>copy</code> module, which means it ends up pickling and unpickling to perform the deep copy; <a href="https://github.com/python/cpython/blob/3.6/Objects/odictobject.c#L956" rel="nofollow noreferrer">the implementation of <code>__reduce__</code></a> returns the <code>items</code> iterator as the fifth item of its return <code>tuple</code>, which, per the <code>__reduce__</code> docs, <a href="https://docs.python.org/3/library/pickle.html#object.__reduce__" rel="nofollow noreferrer">means it will be iterated in that order with the first element used as the key, and the second as the value</a>, so the implementation intentionally preserves order.</span>
<span class="comment-copy">I can't believe you put the coolest part of your answer in a comment :)</span>
<span class="comment-copy">@GregSchmit: It's Python, so implementation details aren't official; the spec is the documentation, not the CPython reference interpreter; implementation details are subject to change from version to version and interpreter to interpreter. Nothing specifically requires the specific implementation chosen (though it is a straightforward one); in theory, some other Python interpreter might choose a different one.</span>
<span class="comment-copy">I don't think the OP doubted that they'd get back another <code>OrderedDict</code>, they were just concerned that the new version might have <i>different</i> ordering.</span>
<span class="comment-copy">Ok. If the returned object is an OrderedDict, should it not be ordered? If the returned object is an OrderedDict and it is not ordered, then it's violating the definition of the datastructure. This was the point that I was trying to make.</span>
<span class="comment-copy">@mod0, then I don't think you understand OrderedDicts work. They keep the order that objects were added, so if you have two of them in different order, you don't necessarily know which one is "right". The question is asking if the same order is preserved, which isn't a given as you imply, since during the copying, the interpreter could copy in a different order and therefore return a different OrderedDict.</span>
<span class="comment-copy">@GregSchmit you are correct. I apologize for having made the assumption that the keys are sorted. I will edit my answer to reflect that.</span>
<span class="comment-copy">@mod0 It happens; no worries!</span>
