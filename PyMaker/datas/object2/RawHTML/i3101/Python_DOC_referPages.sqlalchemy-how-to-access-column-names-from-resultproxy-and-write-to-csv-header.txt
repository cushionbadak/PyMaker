<div class="post-text" itemprop="text">
<p>I am trying to use SQLAlchemy to establish a connection to a PostgreSQL Database, execute a SQL query and print the output of the file to a file in linux. </p>
<pre><code>from sqlalchemy import create_engine
import yaml
import csv

outfile = open('/path/filename.csv', 'wb')
outcsv = csv.writer(outfile, delimiter='\t')


with open('config.yml') as f:
    cfg = yaml.safe_load(f)
    username = cfg['credentials']['username']
    password = cfg['credentials']['password']
    host = cfg['credentials']['host'] 
    port = cfg['credentials']['port']
    dbname = cfg['credentials']['dbname']
    engine = create_engine('postgresql://{}:{}@{}:{}/{}'.format(username, password, host, port, dbname))
    result = engine.execute("""select * from db.tablename """)

    # dump column titles (optional)
    outcsv.writerow(x[0] for x in result.description)

    # dump rows
    outcsv.writerows(result.fetchall())
    outfile.close()
</code></pre>
<p>However, I am getting the following error message - 
Traceback (most recent call last):
  File "", line 12, in 
<strong>AttributeError: 'ResultProxy' object has no attribute 'description'</strong></p>
<p>If I comment the below command, I am successfully able to get the query result but without the headers.
outcsv.writerow(x[0] for x in result.description)</p>
<p>Upon researching, I found the method - result._metadata.keys can generate the headers. However, it generates in some form of a list that I can't attach as header.</p>
<p>Please advise if there is any way to get the file header as well as the data into a csv file. Please consider the fact that I am beginner in Python while answering the above.</p>
</div>
<div class="post-text" itemprop="text">
<p>In this row in your example:</p>
<pre><code>result = engine.execute("""select * from db.tablename """)
</code></pre>
<p>the variable <code>result</code> is pointed to an instance of the class <a href="http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.ResultProxy" rel="nofollow noreferrer"><code>sqlalchemy.engine.ResultProxy</code></a>.</p>
<p>You want to get the column names to write to the first row of your csv file, and through inspecting your <code>result</code> object found <code>result._metadata.keys</code> which returns a regular python <code>list</code> of column names.</p>
<p>A convention in Python is that whenever an attribute, variable or method on an object is prefaced with an underscore (e.g. <code>_metadata</code>) that means it's not intended to be a public API, and the maintainers of the package may change their implementation in such a manner that breaks your code if you rely on these things (however unlikely for a stable library such as SQLAlchemy). Fortunately, in this case there is a documented public API for you to get what you need: <a href="http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.ResultProxy.keys" rel="nofollow noreferrer"><code>ResultProxy.keys()</code></a>.</p>
<p>Remember that your <code>result</code> variable points to a <code>ResultProxy</code> instance, so you can access the <code>keys()</code> method on that to get the column names, e.g:</p>
<pre><code>result.keys()
</code></pre>
<p>What happens when we try to write to your csv file:</p>
<pre><code>outcsv.writerow(result.keys())
</code></pre>
<p>We get this exception:</p>
<pre><code>TypeError: a bytes-like object is required, not 'str'
</code></pre>
<p>I'm going to assume that this is what you refer to when you say:</p>
<blockquote>
<p>However, it generates in some form of a list that I can't attach as
  header.</p>
</blockquote>
<p>You can have a look at the <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer"><code>open()</code></a> API but the issue is that you've opened the file in such a manner that it expects binary data, not the strings that are returned from <code>result.keys()</code>. So if we change the line where you open your file to:</p>
<pre><code>outfile = open('/path/filename.csv', 'w')
</code></pre>
<p><code>outfile.writerow</code> will accept the result of <code>result.keys()</code>.</p>
<p>Everything else should "just work".</p>
<p>Here is the code I used to test:</p>
<pre><code>import csv

from sqlalchemy import Column, Integer, String, create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()
engine = create_engine('sqlite:///:memory:', echo=False)
Session = sessionmaker(bind=engine)

class Model(Base):
    __tablename__ = 'model'
    id = Column(Integer, primary_key=True)
    col1 = Column(String(10))
    col2 = Column(String(10))

if __name__ == '__main__':
    # create some test data
    Base.metadata.drop_all(bind=engine)
    Base.metadata.create_all(bind=engine)
    s = Session()
    data = dict(col1='a', col2='b')
    s.add_all(Model(**data) for _ in range(5))
    s.commit()
    s.close()
    # put the session away and work with the engine

    result = engine.execute("select * from model")

    outfile = open('filename.csv', 'w', newline='')
    outcsv = csv.writer(outfile, delimiter='\t')
    outcsv.writerow(result.keys())
    outcsv.writerows(result.fetchall())
</code></pre>
<p>here's the contents of the csv:</p>
<pre><code>id  col1    col2
1   a   b
2   a   b
3   a   b
4   a   b
5   a   b
</code></pre>
</div>
<span class="comment-copy">You can convert keys to a list using <code>list(result._metadata.keys)</code></span>
<span class="comment-copy">It worked at my end too. The explanation was very detailed and immensely helpful.</span>
