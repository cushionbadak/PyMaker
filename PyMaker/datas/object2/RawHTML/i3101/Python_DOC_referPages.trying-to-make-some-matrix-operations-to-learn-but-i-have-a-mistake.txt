<div class="post-text" itemprop="text">
<p>I want this program in python</p>
<pre><code>m = [[1,0,0],
     [0,1,0],
     [0,0,1]]

n = [[1,2,3],
     [2,3,4],
     [2,4,1]]

def cofactor(s,j):
    p = m.copy()
    for i in range(0,len(p)):
        p[i].pop(s)
    p.pop(j)
    return p
cofact = cofactor(2,1)
print(cofact)
print(m)
</code></pre>
<p>To give me back this </p>
<pre><code>[[1, 0], [0, 0]]
[[1,0,0],[0,1,0],[0,0,1]]
</code></pre>
<p>but instead is giving </p>
<pre><code>  [[1, 0], [0, 0]]
[[1, 0], [0, 1], [0, 0]]
</code></pre>
<p>And I do not know what am i doing wrong. I need to understand and find my mistake. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>From Python documentation, <a href="https://docs.python.org/3/reference/datamodel.html#data-model" rel="nofollow noreferrer">3. Data models &gt;&gt;&gt; 3.1. Objects, values and types</a> </p>
<blockquote>
<p>Some objects contain references to other objects; these are called containers. Examples of containers are tuples, lists and dictionaries. The references are part of a containerâ€™s value. In most cases, when we talk about the value of a container, we imply the values, not the identities of the contained objects; however, when we talk about the mutability of a container, only the identities of the immediately contained objects are implied. So, if an immutable container (like a tuple) contains a reference to a mutable object, its value changes if that mutable object is changed.</p>
</blockquote>
<p>Elements (lists and their respective elements) of m and p refer to same objects. If these objects are changed it reflects in both container objects. It can be easily verified. </p>
<p>After assingment of m add:</p>
<pre><code>print(id(m[0]), id(m[0][0])) 
</code></pre>
<p>And after assignment of p inside function body:</p>
<pre><code>print(id(p[0]), id(m[0][0]))
</code></pre>
<p>You will see that identities of these objects are same.</p>
<p>You should also check explanation in <a href="https://docs.python.org/3.7/library/copy.html" rel="nofollow noreferrer">The Python Standard Library &gt;&gt;&gt; 8. Data types &gt;&gt;&gt; 8.10. copy - Shallow and deep copy operations</a></p>
<blockquote>
<p>Assignment statements in Python do not copy objects, they create bindings between a target and an object. For collections that are mutable or contain mutable items, a copy is sometimes needed so one can change one copy without changing the other. This module provides generic shallow and deep copy operations (explained below).</p>
</blockquote>
<p>In order to avoid such problems in future I recommend checking out StackOverflow contributor <a href="https://stackoverflow.com/users/14343/ned-batchelder">Ned Batchelder</a> very good explanation about names and values: <a href="https://nedbatchelder.com/text/names1.html" rel="nofollow noreferrer">Python Names and Values</a></p>
</div>
<span class="comment-copy"><code>m.copy()</code> is a shallow copy.</span>
<span class="comment-copy">Add <code>import copy</code> and replace <code>p = m.copy()</code> with <code>p = copy.deepcopy(m)</code></span>
<span class="comment-copy">What is the difference between them?</span>
<span class="comment-copy"><a href="https://stackoverflow.com/a/17246744/9435107">Check this link</a></span>
