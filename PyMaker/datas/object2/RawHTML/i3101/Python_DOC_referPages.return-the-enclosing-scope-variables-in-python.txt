<div class="post-text" itemprop="text">
<p><strong>Given</strong></p>
<p>I have a function, <code>scope</code>, which can be declared inside an enclosing namespace, i.e. a <em>module</em>, <em>class</em> or <em>function</em>.  Variables of interest are located immediately outside this function.</p>
<p>How do I generically access the variables/parameters and their values declared within <em>any</em> enclosing namespace?</p>
<p><strong>Example</strong></p>
<p>Sample pseudo-code for capturing function variables (<code>b</code>) and parameters (<code>c</code>):</p>
<pre><code>a = 1
def func(c=3)
    b = 2
    def scope():
        return ...
    return scope()
</code></pre>
<p>Expected Output</p>
<pre><code>func()
# {'c': 3, 'b': 2}
</code></pre>
<hr/>
<p><strong>Attempts</strong></p>
<p>I've had moderate success at the module-level, e.g. <code>a = 1</code>:</p>
<pre><code># module-level
a = 1
def scope():
    return {k: v for k, v in globals().items() if not k.startswith("_")}

scope()
# {'a': 1, ...}
</code></pre>
<p>I can also access class attributes from methods, e.g. <code>b = 2</code>:</p>
<pre><code># class-level
a = 1
class Klass:
    b = 2
    def scope(self):
        obj = self.__class__
        return obj.__dict__

Klass().scope()
# {'b': 2, ...}
</code></pre>
<p>I can only partially access variables and parameters inside an enclosing function:</p>
<pre><code># function-level
a = 1
def func(c=3):
    b = 2
    def scope():
        obj = func
        return obj.__code__.co_varnames
    return scope()

func()
# ('c', 'b', 'scope')
</code></pre>
<p>While <code>__code__.co_varnames</code> successfully gives the enclosing variables (excluding <code>a</code>), I am interested the values as well (e.g. <code>{'c': 3, 'b': 2}</code>).</p>
<p>I have made many unmentioned attempts including <code>inspect</code> functions, other code object methods, <code>dir()</code>, and object special methods.  My preference is to implement more generic and idiomatic code for detecting variables in an enclosing namespace, although any advice is appreciated.  </p>
<p>I am also aware of Python idioms and the nature of this question.  I am still intrigued by its possibilities, and I thank anyone willing to stretch beyond the norm.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's kinda cheating, but</p>
<pre><code>def scope(outer=locals()):
    return outer
</code></pre>
<p>works. (It's cheating because the default argument is evaluated at definition time by the defining code, thus <code>locals()</code> is run in the enclosing scope and thus it's not actually the <code>scope</code> function reaching out to the enclosing scope.)</p>
<p>Note that the directory returned by <code>locals()</code> may or may not change when the corresponding scope is modified after the call. If you want consistent behavior across Python implementations (or even across your different use-cases), make a deep copy either in the default argument or in the body of the <code>scope</code> function.</p>
<pre><code># module-level

a = 1

def scope(outer=locals()):
    return outer

e = 5
result = scope()
f = 6

public_result = {k: v for k, v in result.items() if not k.startswith('_')}
assert (
    # allowed:
    public_result == dict(a=1)
    or
    # C-Python 3.6 behavior:
    public_result == dict(a=1, scope=scope, e=5, result=result, f=6)
)
</code></pre>
<pre><code># class-level

a = 1


class Klass:
    b = 2

    @staticmethod
    def _scope(outer=locals()):  # Hidden from public result, because I have
        return outer             # no idea how to refer to it from the outside.

    d = 4


e = 5
result = Klass._scope()
f = 6

public_result = {k: v for k, v in result.items() if not k.startswith('_')}
assert (
    # allowed:
    public_result == dict(b=2)
    or
    # CPython 3.6 behavior:
    public_result == dict(b=2, d=4)  # would also contain `scope` if it wasn't hidden
)
</code></pre>
<pre><code># function-level

a = 1


def func(c=3):
    b = 2

    def scope(outer=locals()):
        return outer

    return scope(), scope

    d = 4


e = 5
result, scope_fu = func()
f = 6

assert (
    # C-Python 3.6 behaviour:
    result == dict(b=2, c=3)
    or
    # also allowed:
    result == dict(b=2, c=3, scope=scope_fu, d=4)
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While python will give you ways to do this, you REALLY don't want to.  Function/classes/etc should not expose their internals to the calling code, as that breaks abstraction and makes code fragile.  Functions should take in arguments and return output values, but the internal algorithm and especially variable names shouldn't be exposed.</p>
</div>
<span class="comment-copy">Have you looked at <code>locals()</code>?</span>
<span class="comment-copy">@dawg Yes I've tried <code>locals()</code>, but it is not clear how to access enclosing variables from inside <code>scope()</code>.  Also it works for functions, and less so for classes per <a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer">the docs</a></span>
<span class="comment-copy">Do you need this ability for anything or are you asking out of interest? (Either is fine, but if you have a problem you want to solve by inspecting the enclosing scope, it's probably worth also considering completely different approaches that don't require that kind of introspection. We'd need to know more about the problem though.)</span>
<span class="comment-copy">@das-g, many thanks.  The problem is akin to what I've described.  I want a function that when called sees the surrounding variables, not beyond it.  I know now other route other than introspection to accomplish this.  If you have other ideas, I am open to them.  It is personal interest.</span>
<span class="comment-copy">(In the case it's not obvious: I'm trying to find out whether this is an <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a>.)</span>
<span class="comment-copy">Brilliant approach!  You should probably use a disclaimer, this is NOT a good idea for most use cases in Python.  Thanks for your patience.</span>
<span class="comment-copy">This argument seems bogus, as you can easily <i>access</i> variables from enclosing scopes unless you shadow them yourselves with your own variables of identical names. If you can access them, why shouldn't you be allowed to discover them by introspection?</span>
<span class="comment-copy">Sorry, I should have clarified the directionality of this.  Yes, it is common practice to have closures access variables from their calling code.  That is expected (although you should still limit the calling scope to as narrow as possible for similar reasons).  However you don't want to go to the reverse because it leads to you relying on variable names in other code.  You'll find yourself performing trivial refactorings like renaming variables and suddenly everything breaks because you relied on those exact strings elsewhere.  It's just fragile coding style.</span>
<span class="comment-copy">The whole point of block-scoped languages is that "this variable is only valid inside this chunk of code."  That idiom creates protection from memory accesses, encapsulation of algorithms and ideas, and keeps code flexible and resilient to change.  Breaking that apart by exposing variable names is actively going out of your way to defy that paradigm to your detriment.  If you plan to need a value after a function, then it should either be declared at a higher scope or have its value returned from the function.</span>
<span class="comment-copy">If I understand the question correctly, it <i>is</i> about the direction of looking from the inner scope (the <code>scope()</code> function) into the enclosing scope (without knowing that outer scope a-priori, though, which <i>is indeed</i> kinda strange - maybe a debugging usecase?), not the other way around.</span>
<span class="comment-copy">"If you really want to shoot yourself in the foot you can, but I don't recommend it."</span>
