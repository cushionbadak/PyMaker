<div class="post-text" itemprop="text">
<p><strong>EDITED:</strong></p>
<p>I have an array of <strong><em>n</em></strong> sorted values.</p>
<p>I want to create <strong><em>m</em></strong> sub-arrays so that my best element goes into my first sub-array, my second element goes into my second sub array, etc, and my <strong><em>n+1-th</em></strong> best element goes into my first sub array.</p>
<p>If I have just two arrays its easy but if I want more than two sub-arrays I don't know how to do it.</p>
<p>for example if I have an initial array:</p>
<pre><code>a = [50, 45, 40, 35, 30, 25, 20, 10, 9, 8]
</code></pre>
<p>And I want 3 sub-arrays I should get:</p>
<pre><code>x1: [50, 35, 20, 8]
x2: [45, 30, 10]
x3: [40, 25, 9]
</code></pre>
<p>What's the most efficient/pythonic way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>FOR X SUBLISTS :</strong></p>
<p>One possibility would be to do :</p>
<pre><code>def get_sublists(original_list, number_of_sub_list_wanted):
    sublists = list()
    for sub_list_count in range(number_of_sub_list_wanted): 
        sublists.append(original_list[sub_list_count::number_of_sub_list_wanted])
    return sublists
</code></pre>
<p>You can then unpack the sub-lists stored in <code>sublist</code>.</p>
<p>For example : </p>
<pre><code>a = [5,4,3,2,1,0]
x1, x2 = get_sublists(a, 2)
</code></pre>
<p>will grant you the expected output.</p>
<p>This is the trivial solution. Their is probably something more pythonic in itertools or an other lib.</p>
<p><em>If you don't understand how this code works , take a look at <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow noreferrer">the documentation of a slice</a>.</em> </p>
</div>
<div class="post-text" itemprop="text">
<h3>For 2 arrays</h3>
<pre><code>x1, x2 = map(list, zip(*zip(*[iter(a)] * 2)))

print(x1, x2, sep='\n')

[5, 3, 1]
[4, 2, 0]
</code></pre>
<hr/>
<h3>For 3 arrays</h3>
<pre><code>x1, x2, x3 = map(list, zip(*zip(*[iter(a)] * 3)))

print(x1, x2, x3, sep='\n')

[5, 2]
[4, 1]
[3, 0]
</code></pre>
<hr/>
<h3>Why this works</h3>
<ol>
<li><code>iter(a)</code> creates an iterator on the list <code>a</code>.  When you iterate through it, the elements get used up and eventually the iterator becomes exhausted.</li>
<li><code>[iter(a)] * 2</code> creates a list that looks like this <code>i = iter(a); [i, i]</code>.  Notice that the <strong>same</strong> iterator shows up twice.  That means that when I take an element from the first <code>i</code>, I also take it from the second <code>i</code> because they point to the same iterator.</li>
<li>So! when I use <code>zip</code> on the unpacked list of the same iterator <code>zip(*[iter(a)] * 2)</code>, As I pair things up, I'm pulling from the same iterator and therefore naturally exhausting them in the order we want.</li>
<li>I then use another <code>zip</code> to transpose the results and then <code>map</code> with <code>list</code> to make them lists instead of tuples.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = [5, 4, 3 ,2, 1, 0]

def get_original_val(original, x):
    return [original[index] for index in x]

def get_index(a):
    index_x1, index_x2 = [], []
    local_list = a if not len(a) % 2 else a + [0]
    for idx, x in enumerate(local_list):
        target = index_x2 if idx % 2 else index_x1
        target.append(idx)
    get_x1 = get_original_val(a, index_x1)
    get_x2 = get_original_val(a,  index_x2)
    return get_x1, get_x2

&gt;&gt;&gt;x1, x2 = get_index(a)
&gt;&gt;&gt;x1
[5, 3, 1]
&gt;&gt;&gt;x2
[4, 2, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Below will give the desired answer,</p>
<pre><code>a = [5, 4, 3 ,2, 1, 0]
a.sort(reverse=True)
x1 = []
x2 = []
for i in range(len(a)):
   x1.append(a[i]) if (i%2==0) else x2.append(a[i])
print x1, x2
</code></pre>
</div>
<span class="comment-copy"><code>a.reshape(3,2).T</code>? It seems your method is equivalent to sorting by columns</span>
<span class="comment-copy">You also can have any of this list singularly by doing something like <code>a[y::x]</code> with x the number of sublist, and y the number sublist index you're trying to get (starting from 0). For example if you want x2 from your example you do <code>a[1::2]</code> See the slice documentation <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#slice</a></span>
<span class="comment-copy">I think I wrongly formulated the problem: please check my edit</span>
<span class="comment-copy">All the answer bellow are for "2 sub-lists" when you start with "I want to create x sub-arrays". Maybe edit your question for it to be clear.</span>
<span class="comment-copy">yes thanks just did that @T.Nel</span>
<span class="comment-copy">Can you explain the code..?</span>
<span class="comment-copy">Yes.  Working on it (-:</span>
<span class="comment-copy">I think the author asked for a more general solution, he wants to create x sub-arrays not 2.</span>
<span class="comment-copy">I think the author asked for a more general solution, he wants to create x sub-arrays not 2.</span>
<span class="comment-copy">Just now saw the edition. Thanks for informing.</span>
