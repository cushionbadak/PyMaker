<div class="post-text" itemprop="text">
<p>I was playing around with some ctype-structures and found out something interesting that got me wondering about my implementation. A MWE is as follows:</p>
<pre><code>from ctypes import *
import numpy as np

class test_bitfield(Structure):
    _fields_ = [("x", c_uint16, 9),
                ("y", c_uint8, 5),
                ("z", c_uint16, 4)]

bf = test_bitfield(np.uint64(9), np.uint64(9), np.uint64(9))

print(bf.x, ", ", bf.y, ", ", bf.z)
</code></pre>
<p>Whose output is:</p>
<blockquote>
<blockquote>
<p>9, 0 ,9</p>
</blockquote>
</blockquote>
<p>Which was something that I was not expecting. </p>
<p>By turning <code>bf.y</code> into a <code>c_uint16</code>, I get what I would have expected from the beginning: <code>9, 9, 9</code>.</p>
<p>Having a glance to the documentation I see that <a href="https://docs.python.org/3/library/ctypes.html#bit-fields-in-structures-and-unions" rel="nofollow noreferrer" title="Bit fields are only possible for integer fields">bitfields are only possible for integer fields</a>, which doesn't really specify that <code>c_uint8</code> are not supported. I then referred to the available <a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/ctypes/test/test_bitfields.py" rel="nofollow noreferrer">tests</a>, where I see that no <code>c_uint8</code> or <code>c_char</code> is included. However, trying to use a <code>c_char</code> throws a TypeError, whereas c_uint8 doesn't throw.</p>
<p>Could someone just clarify what is going on? Are bit fields just not implemented for <code>uint_8</code>? Or am I just using it wrong? Any type of clarification is highly appreciated!</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Note: Mac OS X python 2.7 and 3.6 have the same output</p>
<p>so... for some reason you can't use the 8 bit types signed or unsigned and divide them with a bitfield ... I will look into docs for the "why"</p>
<pre><code>from ctypes import *

class test_bitfield(Structure):
    _fields_ = [("x", c_uint16, 9),
                ("y", c_uint16, 6),
                ("z", c_uint16, 4)]

bf = test_bitfield(1,255,3)

print(bf.x, ", ", bf.y, ", ", bf.z)
</code></pre>
<p>outputs: <code>(1, ', ', 63, ', ', 3)</code> which is cool, dropping the 2 top bits: <code>255 - 128 - 64 = 63</code></p>
<p>and </p>
<pre><code>from ctypes import *

class test_bitfield(Structure):
    _fields_ = [("x", c_uint16, 9),
                ("y", c_uint8, 8),
                ("z", c_uint16, 4)]

bf = test_bitfield(1,255,3)

print(bf.x, ", ", bf.y, ", ", bf.z)
</code></pre>
<p>prints: <code>(1, ', ', 255, ', ', 3)</code> ok... sane</p>
<p><strong>But,</strong></p>
<pre><code>from ctypes import *

class test_bitfield(Structure):
    _fields_ = [("x", c_uint16, 9),
                ("y", c_uint8, 7),
                ("z", c_uint16, 4)]

bf = test_bitfield(1,255,3)

print(bf.x, ", ", bf.y, ", ", bf.z)
</code></pre>
<p>prints: <code>(1, ', ', 0, ', ', 3)</code></p>
</div>
<span class="comment-copy">c_uint8 should be an integer field, what version of python is this, running on what arch.... and what interpreter (possibly important with FFI stuff)</span>
<span class="comment-copy">well.. I guess it doesn't</span>
<span class="comment-copy">Thanks for the analysis. It is still very confusing for me because by modifying my example to take out the "x" from the structure and the print, and leaving everything else the same, it actually outputs <code>9, 9</code> as I would have expected. It is as if the neighbor memory and datatype also affect the bit field, which would tell that it is doing something (meaning it is supported (?)), although I don't know yet what is the thing it is doing.</span>
