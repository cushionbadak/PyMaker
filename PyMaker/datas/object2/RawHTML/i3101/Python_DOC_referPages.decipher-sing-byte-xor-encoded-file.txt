<div class="post-text" itemprop="text">
<p>I have a binary file single-byte xor encoded with a single byte, I tried to brute force files and compare the hash of the generated file with original and couldn't find it, I confirmed the original hash with the author.</p>
<p>the code I wrote</p>
<pre><code>#!/usr/bin/env python3

def bin_xor(data, key):
    for i in range(len(data)):
        data[i] ^= key
    return data

data = bytearray(open('sample',  'rb').read())
for key in range(0x00,0xff):
    decoded = bin_xor(data, key)
    name = str(key) + '.bin'
    open(name, "wb").write(decoded)
</code></pre>
<p>it will generate 255 .bin file then I compare the hash of the files and didn't find it.</p>
</div>
<div class="post-text" itemprop="text">
<p>By using the stop value of <code>0xff</code> in your <code>range</code>, you are actually missing <code>0xff</code> itself.</p>
<p>Excerpt from <a href="https://docs.python.org/3/library/stdtypes.html#ranges" rel="nofollow noreferrer"><code>range</code>'s documentation</a>:</p>
<blockquote>
<p>For a positive step, the contents of a range r are determined by the
  formula r[i] = start + step*i where i &gt;= 0 and r[i] &lt; stop.</p>
</blockquote>
<p>You should instead use <code>0x100</code> as the stop value.</p>
<pre><code>for key in range(0x00,0x100):
</code></pre>
</div>
<span class="comment-copy">I had a co-worker use single-byte xor "encryption" and I immediately saw the xor byte because there was a section of data that was 0x00 so the xor byte was immediately obvious. If you want encryption use real encryption such as AES.</span>
<span class="comment-copy">thank @zaph I'm not looking for real encryption, I was just deciphering a file, but it's all done, It was a typo in the hash I wrote.</span>
<span class="comment-copy">thanks for your comment, I did miss 0xff but still the answer is not correct, I'm not sure.</span>
<span class="comment-copy">Thanks, it appeared it was a typo in the hash thanks.</span>
