<div class="post-text" itemprop="text">
<p>I have two lists:</p>
<pre><code>big_list = [2, 1, 2, 3, 1, 2, 4]
sub_list = [1, 2]
</code></pre>
<p>I want to remove all sub_list occurrences in big_list.</p>
<p>result should be <code>[2, 3, 4]</code></p>
<p>For strings you could use this:</p>
<pre><code>'2123124'.replace('12', '')
</code></pre>
<p>But AFAIK this does not work for lists.</p>
<p>This is not a duplicate of <a href="https://stackoverflow.com/questions/42881650/removing-a-sublist-from-a-list">Removing a sublist from a list</a> since I want to remove all sub-lists from the big-list. In the other question the result should be <code>[5,6,7,1,2,3,4]</code>.</p>
<p>Update: For simplicity I took integers in this example. But list items could be arbitrary objects.</p>
<p>Update2:</p>
<p>if <code>big_list = [1, 2, 1, 2, 1]</code> and <code>sub_list = [1, 2, 1]</code>, 
I want the result to be <code>[2, 1]</code> (like <code>'12121'.replace('121', '')</code>)</p>
<p>Update3:</p>
<p>I don't like copy+pasting source code from StackOverflow into my code. That's why I created second question at software-recommendations: <a href="https://softwarerecs.stackexchange.com/questions/51273/library-to-remove-every-occurrence-of-sub-list-from-list-python">https://softwarerecs.stackexchange.com/questions/51273/library-to-remove-every-occurrence-of-sub-list-from-list-python</a></p>
<p>Update4: if you know a library to make this one method call, please write it as answer, since this is my preferred solution. </p>
<p>The test should pass this test:</p>
<pre><code>def test_remove_sub_list(self):
    self.assertEqual([1, 2, 3], remove_sub_list([1, 2, 3], []))
    self.assertEqual([1, 2, 3], remove_sub_list([1, 2, 3], [4]))
    self.assertEqual([1, 3], remove_sub_list([1, 2, 3], [2]))
    self.assertEqual([1, 2], remove_sub_list([1, 1, 2, 2], [1, 2]))
    self.assertEquals([2, 1], remove_sub_list([1, 2, 1, 2, 1], [1, 2, 1]))
    self.assertEqual([], remove_sub_list([1, 2, 1, 2, 1, 2], [1, 2]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You'd have to implement it yourself. Here is the basic idea:</p>
<pre><code>def remove_sublist(lst, sub):
    i = 0
    out = []
    while i &lt; len(lst):
        if lst[i:i+len(sub)] == sub:
            i += len(sub)
        else:
            out.append(lst[i])
            i += 1
    return out
</code></pre>
<p>This steps along every element of the original list and adds it to an output list if it isn't a member of the subset. This version is not very efficient, but it works like the string example you provided, in the sense that it creates a new list not containing your subset. It also works for arbitrary element types as long as they support <code>==</code>. Removing <code>[1,1,1]</code> from <code>[1,1,1,1]</code> will correctly result in <code>[1]</code>, as for a string.</p>
<p>Here is an <a href="https://ideone.com/WEPcZM" rel="noreferrer">IDEOne link</a> showing off the result of</p>
<pre><code>&gt;&gt;&gt; remove_sublist([1, 'a', int, 3, float, 'a', int, 5], ['a', int])
[1, 3, &lt;class 'float'&gt;, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try <code>del</code> and <code>slicing</code>. The worst time complexity is <code>O(N^2)</code>.</p>
<pre><code>sub_list=['a', int]
big_list=[1, 'a', int, 3, float, 'a', int, 5]
i=0
while i &lt; len(big_list):
    if big_list[i:i+len(sub_list)]==sub_list:
        del big_list[i:i+len(sub_list)]
    else:
        i+=1

print(big_list)
</code></pre>
<p>result:</p>
<pre><code>[1, 3, &lt;class 'float'&gt;, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A recursive approach:</p>
<pre><code>def remove(lst, sub):
    if not lst:
        return []
    if lst[:len(sub)] == sub:
        return remove(lst[len(sub):], sub)
    return lst[:1] + remove(lst[1:], sub)
print(remove(big_list, sub_list))
</code></pre>
<p>This outputs:</p>
<pre><code>[2, 3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A improved version to check whether <code>lst[i:i+len(sub)] &lt; len(lst)</code></p>
<pre><code>def remove_sublist(lst, sub):
    i = 0
    out = []
    sub_len = len(sub)
    lst_len = len(lst)
    while i &lt; lst_len:
        if (i+sub_len) &lt; lst_len:
            if lst[i: i+sub_len] == sub:
                i += sub_len
            else:
                out.append(lst[i])
                i += 1
        else:
            out.append(lst[i])
            i += 1

    return out
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>def remove_sublist(lst, sub):
    max_ind_sub = len(sub) - 1
    out = []
    i = 0
    tmp = []

    for x in lst:
        if x == sub[i]:
            tmp.append(x)
            if i &lt; max_ind_sub: # partial match 
                i += 1
            else:  # found complete match
                i = 0
                tmp = []
        else:
            if tmp:  # failed partial match 
                i = 0
                out += tmp
            if x == sub[0]:  # partial match
                i += 1
                tmp = [x]
            else:
                out.append(x)

    return out
</code></pre>
<p>Performance:</p>
<pre><code>lst = [2, 1, 2, 3, 1, 2, 4]
sub = [1, 2]
%timeit remove_sublist(lst, sub)  # solution of Mad Physicist
%timeit remove_sublist_new(lst, sub)
&gt;&gt;&gt; 2.63 µs ± 112 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
&gt;&gt;&gt; 1.77 µs ± 13.7 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
<p><strong>Update</strong></p>
<p>My first solution had a bug. Was able to fix it (updated my code above) but the method looks way more complicated now. In terms of performance it still does better than the solution from <em>Mad Physicist</em> on my local machine.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>itertools.zip_longest</code> to create n element tuples (where n is length of sub_list) and then filter the current element and next n-1 elements when one of the element matched the sub_list</p>
<pre><code>&gt;&gt;&gt; from itertools import zip_longest, islice
&gt;&gt;&gt; itr = zip_longest(*(big_list[i:] for i in range(len(sub_list))))
&gt;&gt;&gt; [sl[0] for sl in itr if not (sl == tuple(sub_list) and next(islice(itr, len(sub_list)-2, len(sub_list)-1)))]
[2, 3, 4]
</code></pre>
<p>To improve the efficiency, you can calculate <code>tuple(sub_list)</code> and <code>len(sub_list)</code> before hand you start filtering</p>
<pre><code>&gt;&gt;&gt; l = len(sub_list)-1
&gt;&gt;&gt; tup = tuple(sub_list)
&gt;&gt;&gt; [sl[0] for sl in itr if not (sl == tup and next(islice(itr, l-1, l)))]
[2, 3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Update</strong>: The <a href="https://github.com/erikrose/more-itertools/" rel="nofollow noreferrer"><code>more_itertools</code></a> library has released  <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.replace" rel="nofollow noreferrer"><code>more_itertool.replace</code></a>, a tool that solves this particular problem (see Option 3).  </p>
<p>First, here are some other options that work on generic iterables (lists, strings, iterators, etc.):</p>
<p><strong>Code</strong></p>
<p><em>Option 1 - without libraries</em>:</p>
<pre><code>def remove(iterable, subsequence):
    """Yield non-subsequence items; sans libraries."""
    seq = tuple(iterable)
    subsequence = tuple(subsequence)
    n = len(subsequence)
    skip = 0

    for i, x in enumerate(seq):
        slice_ = seq[i:i+n]
        if not skip and (slice_ == subsequence):
            skip = n
        if skip:
            skip -= 1
            continue
        yield x   
</code></pre>
<p><em>Option 2 - with <a href="https://github.com/erikrose/more-itertools/" rel="nofollow noreferrer"><code>more_itertools</code></a></em></p>
<pre><code>import more_itertools as mit


def remove(iterable, subsequence):
    """Yield non-subsequence items."""
    iterable = tuple(iterable)
    subsequence = tuple(subsequence)
    n = len(subsequence)
    indices = set(mit.locate(mit.windowed(iterable, n), pred=lambda x: x == subsequence))

    it_ = enumerate(iterable)
    for i, x in it_:
        if i in indices:
            mit.consume(it_, n-1)
        else:
            yield x
</code></pre>
<p><strong>Demo</strong> </p>
<pre><code>list(remove(big_list, sub_list))
# [2, 3, 4]

list(remove([1, 2, 1, 2], sub_list))
# []

list(remove([1, "a", int, 3, float, "a", int, 5], ["a", int]))
# [1, 3, float, 5]

list(remove("11111", "111"))
# ['1', '1']

list(remove(iter("11111"), iter("111")))
# ['1', '1']
</code></pre>
<hr/>
<p><em>Option 3 - with <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.replace" rel="nofollow noreferrer"><code>more_itertools.replace</code></a></em></p></div>
<div class="post-text" itemprop="text">
<p>More readable than any above and with no additional memory footprint:</p>
<pre><code>def remove_sublist(sublist, mainlist):

    cursor = 0

    for b in mainlist:
        if cursor == len(sublist):
            cursor = 0
        if b == sublist[cursor]:
            cursor += 1
        else:
            cursor = 0
            yield b

    for i in range(0, cursor):
        yield sublist[i]
</code></pre>
<p>This is for onliner if you wanted a function from library, let it be this</p>
<pre><code>[x for x in remove_sublist([1, 2], [2, 1, 2, 3, 1, 2, 4])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Kinda different approach in Python 2.x!</p>
<pre><code>from more_itertools import locate, windowed
big_list = [1, 2, 1, 2, 1]
sub_list = [1, 2, 1]

"""
Fetching all starting point of indexes (of sub_list in big_list)
to be removed from big_list. 
"""

i = list(locate(windowed(big_list, len(sub_list)), pred=lambda x: x==tuple(sub_list)))

""" 
Here i comes out to be [0, 2] in above case. But index from 2 which 
includes 1, 2, 1 has last 1 from the 1st half of 1, 2, 1 so further code is
to handle this case.
PS: this won't come for-
big_list = [2, 1, 2, 3, 1, 2, 4]
sub_list = [1, 2]
as here i comes out to be [1, 4]
"""

# The further code.
to_pop = []
for ele in i:
    if to_pop:
        if ele == to_pop[-1]:
            continue
    to_pop.extend(range(ele, ele+len(sub_list)))

# Voila! to_pop consists of all the indexes to be removed from big_list.

# Wiping out the elements!
for index in sorted(to_pop, reverse=True):
    del big_list[index]
</code></pre>
<p>Note that you need to delete them in reverse order so that you don't throw off the subsequent indexes.</p>
<p>In Python3, signature of <strong>locate()</strong> will differ.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>(For final approach, see last code snippet)</strong></p>
<p>I'd have thought a simple string conversion would be sufficient:</p>
<pre><code>big_list = [2, 1, 2, 3, 1, 2, 4]
sub_list = [1, 2]

new_list = list(map(int, list((''.join(map(str, big_list))).replace((''.join(map(str, sub_list))), ''))))
</code></pre>
<p>I'm essentially doing a find/replace with the string equivalents of the lists. I'm mapping them to integers afterwards so that the original types of the variables are retained. This will work for any size of the big and sub lists.</p>
<p>However, it's likely that this won't work if you're calling it on arbitrary objects if they don't have a textual representation. Moreover, this method results in only the textual version of the objects being retained; this is a problem if the original data types need to be maintained.</p>
<p>For this, I've composed a solution with a different approach:</p>
<pre><code>new_list = []
i = 0
while new_list != big_list:
    if big_list[i:i+len(sub_list)] == sub_list:
        del big_list[i:i+len(sub_list)]
    else:
        new_list.append(big_list[i])
        i += 1
</code></pre>
<p>Essentially, I'm removing every duplicate of the sub_list when I find them and am appending to the new_list when I find an element which isn't part of a duplicate. When the new_list and big_list are equal, all of the duplicates have been found, which is when I stop. I haven't used a try-except as I don't think there should be any indexing errors.</p>
<p>This is similar to @MadPhysicist's answer and is of roughly the same efficiency, but mine <strong>consumes less memory</strong>.</p>
<p><strong>This second approach will work for any type of object with any size of lists and therefore is much more flexible than the first approach. However, the first approach is quicker if your lists are just integers.</strong></p>
<p>However, I'm not done yet! I've concocted a one-liner list comprehension which has the same functionality as the second approach!</p>
<pre><code>import itertools
new_list = [big_list[j] for j in range(len(big_list)) if j not in list(itertools.chain.from_iterable([ list(range(i, i+len(sub_list))) for i in [i for i, x in enumerate(big_list) if x == sub_list[0]] if big_list[i:i+len(sub_list)] == sub_list ]))]
</code></pre>
<p>Initially, this seems daunting, but I assure you it's quite simple! First, i create a list of the indices where the first element of the sublist has occured. Next, for each of these indices, I check if the following elements form the sublist. If they do, the range of indices which form the duplicate of the sublist is added to another list. Afterwards, I use a function from itertools to flatten the resulting list of lists. Every element in this flattened list is an index which is in a duplicate of the sublist. Finally, I create a new_list which consists of every element of the big_list which has an index not found in the flattened list.</p>
<p><strong>I don't think that this method is in any of the other answers. I like it the most as it's quite neat once you realise how it works and is very efficient</strong> (due to the nature of list comprehensions).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use recursion with a generator:</p>
<pre><code>def remove(d, sub_list):
   if d[:len(sub_list)] == sub_list and len(sub_list) &lt;= len(d[:len(sub_list)]):
      yield from [[], remove(d[len(sub_list):], sub_list)][bool(d[len(sub_list):])]
   else:
      yield d[0]
      yield from [[], remove(d[1:], sub_list)][bool(d[1:])]

tests = [[[2, 1, 2, 3, 1, 2, 4], [1, 2]], [[1, 2, 1, 2], [1, 2]], [[1, 'a', int, 3, float, 'a', int, 5], ['a', int]], [[1, 1, 1, 1, 1], [1,1,1]]]
for a, b in tests:
  print(list(remove(a, b)))
</code></pre>
<p>Output:</p>
<pre><code>[2, 3, 4]
[]
[1, 3, &lt;class 'float'&gt;, 5]
[1, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just for fun, here is the closest approximation to a one-liner:</p>
<pre><code>from functools import reduce

big_list = [2, 1, 2, 3, 1, 2, 4]
sub_list = [1, 2]
result = reduce(lambda r, x: r[:1]+([1]+r[2:-r[1]],[min(len(r[0]),r[1]+1)]+r[2:])[r[-r[1]:]!=r[0]]+[x], big_list+[0], [sub_list, 1])[2:-1]
</code></pre>
<p>Don't trust that it works? Check it <a href="https://ideone.com/ZRSSQc" rel="nofollow noreferrer">on IDEone</a>!</p>
<p>Of course it's far from efficient and is disgustfully cryptic, however it should help to convince the OP to accept <a href="https://stackoverflow.com/a/51518791/6394138">@Mad Physicist's answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you are trying to achieve can be done by converting it into list of strings and after replacing again convert it to integer type.</p>
<p><strong>In a single line you can do it like this</strong></p>
<pre><code>map(int,list(("".join(map(str, big_list))).replace("".join(map(str, sub_list)),'').replace(''.join((map(str, sub_list))[::-1]),'')))
</code></pre>
<p>Input</p>
<pre><code>big_list = [1, 2, 1, 2, 1]
sub_list = [1, 2, 1]
</code></pre>
<p>Output</p>
<blockquote>
<p>[2, 1]</p>
</blockquote>
<p>Input</p>
<pre><code>big_list = [2, 1, 2, 3, 1, 2, 4]
sub_list = [1, 2]
</code></pre>
<p>Ouput</p>
<blockquote>
<p>[2, 3, 4]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>As compact as I can:</p>
<pre><code>a=[]
for i in range(0,len(big_list)):
    if big_list[i]==1 and big_list[i+1]==2:
        a.extend((i,i+1))
[big_list[x] for x in [x for x in range(len(big_list)) if x not in a]]

Out[101]: [2, 3, 4]
</code></pre>
<p>Same approach in R:</p>
<pre><code>big_list &lt;- c(2, 1, 2, 3, 1, 2, 4)
sub_list &lt;- c(1,2)

a&lt;-c()
for(i in 1:(length(big_list)-1)){if (all(big_list[c(i,i+1)]==sub_list)) a&lt;-c(a,c(i,i+1)) }
big_list[-a]
[1] 2 3 4
</code></pre>
<p>I think R is easier. </p>
<p><code>[big_list[x] for x in [x for x in range(len(big_list)) if x not in a]]</code> is equivalent to <code>big_list[-a]</code> </p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/42881650/removing-a-sublist-from-a-list">Removing a sublist from a list</a></span>
<span class="comment-copy">Just for clarification, if you have <code>big_list = [1, 2, 1, 2, 1]</code> and <code>sub_list = [1, 2, 1]</code> do you want the result to be <code>[2, 1]</code> or <code>[]</code> (i.e. remove per occurrence or remove all items that match the <code>sub_list</code> pattern)?</span>
<span class="comment-copy">@Marcus.Aurelianus Probably because most upvotes on that answer occurred on a few days: Stack Overflow has a daily reputation cap at 200. So if more than 20 people upvote your answers within 24h, only the first 20 upvotes (×10 = 200 points) are counted.</span>
<span class="comment-copy">Finally, the statement "I like to reuse software" is specious at best, given everything else you've say said. There is nothing preventing you from reusing the software besides a completely artificial constraint that you've imposed.</span>
<span class="comment-copy">If there is an external library to solve this problem, would you require an optimized solution written in C, or would you accept something implemented in Python? In the latter case, I could just upload my solution to GitHub with a setup.py file and call it a library.</span>
<span class="comment-copy">come on, you can do better than this! =)</span>
<span class="comment-copy">@lenik. Fair enough. Hopefully that's less lazy. I couldn't come up with a more streamlined solution unfortunately. And doing it in-place wasn't going to be any prettier.</span>
<span class="comment-copy">@jpp. I don't think the questions are equivalent. There are things you can do to get just the first element that wouldn't be possible here, like short circuiting the loop. At the same time, getting all the subsequences is more general than getting just the one.</span>
<span class="comment-copy">@jpp. I did think that before I started writing an answer though. They problems are very closely related, but I couldn't come up with a nice generator that I could just call next on or run to completion since we're removing elements here.</span>
<span class="comment-copy">@jpp. I changed the title of this one.</span>
<span class="comment-copy">This is not correct. Try <code>sub_list = [1, 2]</code> and <code>big_list = [1, 2, 1, 2]</code>. Result should be <code>[]</code> but you get <code>[1, 2]</code>. If you delete in-place, you have to move backwards.</span>
<span class="comment-copy">@Mad Physicist , updated, passed, mind change your downvote?</span>
<span class="comment-copy">Yes, this is very nice. Arguably better than mine.</span>
<span class="comment-copy">@Physicist,Thanks sir.</span>
<span class="comment-copy">This is not <i>super</i> efficient, but very neat.</span>
<span class="comment-copy">This is not improved in terms of legibility. The short subsequences at the end will never be equal to sub anyway and list is smart enough to check length first for ==.</span>
<span class="comment-copy">You're basically making the check harder to read <i>and</i> less efficient.</span>
<span class="comment-copy">If list 'sub' is a big one, I think 'if (i+sub_len) &lt; lst_len' should be more efficent than 'if lst[i: i+sub_len] == sub' from the view of perfomance. 'lst[i: i+sub_len]' will need to generate a list and this will cost memory, right?</span>
<span class="comment-copy">I suppose so. Too bad lists don't let you get a view instead of a copy of the slice. +1</span>
<span class="comment-copy">I'm really not a fan of the <code>tuple(iterable)</code> here. You're losing all the benefits of lazy evaluation just to get slicing. If you're going to write a generator solution, you should try to hold it to the same standards as the <code>itertools</code> generators, so you can hook them together into a lazily evaluated pipeline.</span>
<span class="comment-copy">No I was referring to the other two.  <code>iterable = tuple(iterable)</code> and <code>seq = tuple(iterable)</code></span>
<span class="comment-copy">Ah I see.  We cast to tuples in order to use native slicing.  The other option could be to use <code>itertools.islice</code>, but of course that requires a library.  In Option 1, I mention you can remove the first two lines that cast to tuples.  Then they would work on sequences only.  Perhaps i'll add an option with <code>itertools</code>.  Thanks.</span>
<span class="comment-copy">@PatrickHaugh I appreciate the feedback.  You mentioned "...try to hold it to the same standards as the <code>itertools</code> generators".  However, <code>tuple(iterable)</code> is not uncommon in <code>itertools</code>, i.e. the combinatorics examples in the <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">docs</a> and <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipes</a>.  Which standards do you mean?</span>
<span class="comment-copy">Nice using <code>more_itertools</code>.  What do you mean by "In Python3, signature of <code>locate()</code> will differ."?</span>
<span class="comment-copy">refer <a href="http://more-itertools.readthedocs.io/en/latest/_modules/more_itertools/more.html#locate" rel="nofollow noreferrer">link</a></span>
<span class="comment-copy">"Of course it's far from efficient and is disgustfully cryptic, however it should help to convince the OP to accept @Mad Physicist's answer." +1 for that</span>
<span class="comment-copy">According to the question this should work for any type: objects, classes, ... AFAIK you can't make very object to a string. You could pickle them to a string .... but this sounds wired.</span>
