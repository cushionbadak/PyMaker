<div class="post-text" itemprop="text">
<p>I'm writing a discord bot using discord.py rewrite, and I want to run a function every day at a certain time.  I'm not experienced with async functions at all and I can't figure out how to run one without using "await."  This is only a piece of my code which is why some things may not be defined.</p>
<pre><code>async def send_channel():
    try:
        await active_channel.send('daily text here')
    except Exception:
        active_channel_id = None
        active_channel = None

async def timer():
    while True:
        schedule.run_pending()
        await asyncio.sleep(3)
        schedule.every().day.at("21:57").do(await send_channel())

@bot.event
async def on_ready():
    print("Logged in as")
    print(bot.user.name)
    print(bot.user.id)
    print("------")

    bot.loop.create_task(timer())
</code></pre>
<p>Using the <code>schedule.every().day.at("00:00").do()</code> function, I get this error when I put <code>await send_channel()</code> in the paramaters of <code>.do()</code>:</p>
<blockquote>
<p>self.job_func = functools.partial(job_func, *args, **kwargs)
  TypeError: the first argument must be callable</p>
</blockquote>
<p>But when I don't use await, and I just have <code>send_channel()</code> as parameters, I get this error:</p>
<blockquote>
<p>RuntimeWarning: coroutine 'send_channel' was never awaited</p>
</blockquote>
<p>I'm not super good at programming so if someone could try to dumb it down for me that would be awesome.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>What you're doing doesn't work because <code>do</code> takes a <em>function</em> (or another callable), but you're trying to <code>await</code> or call a function, and then pass it the result.</p>
<p><code>await send_channel()</code> blocks until the send finishes and then gives you <code>None</code>, which isn't a function. <code>send_channel()</code> returns a coroutine that you can await later to do some work, and that isn't a function either.</p>
<p>If you passed it just <code>send_channel</code>, well, that is a function, but it's an <code>ascynio</code> coroutine function, which <code>schedule</code> won't know how to run.</p>
<hr/>
<p>Also, rather than trying to integrate <code>schedule</code> into the <code>asyncio</code> event loop, and figure out how to wrap async jobs up as <code>schedule</code> tasks and vice versa and so on, it would far easier to just give <code>schedule</code> its own thread.</p>
<p><a href="https://schedule.readthedocs.io/en/stable/faq.html#how-to-continuously-run-the-scheduler-without-blocking-the-main-thread" rel="nofollow noreferrer">There's a FAQ entry on this</a>:</p>
<blockquote>
<p><strong>How to continuously run the scheduler without blocking the main thread?</strong></p>
<p>Run the scheduler in a separate thread. Mrwhick wrote up a nice solution in to this problem <a href="https://github.com/mrhwick/schedule/blob/master/schedule/__init__.py" rel="nofollow noreferrer">here</a> (look for run_continuously()).</p>
</blockquote>
<p>The basic idea is simple. Change your <code>timer</code> function to this:</p>
<pre><code>schedstop = threading.Event()
def timer():
    while not schedstop.is_set():
        schedule.run_pending()
        time.sleep(3)
schedthread = threading.Thread(target=timer)
schedthread.start()
</code></pre>
<p>Do this at the start of your program, before you even start your <code>asyncio</code> event loop.</p>
<p>At exit time, to stop the scheduler thread:</p>
<pre><code>schedstop.set()
</code></pre>
<p>Now, to add a task, it doesn't matter whether you're in your top-level code, or in an async coroutine, or in a <code>scheduler</code> task, you just add it like this:</p>
<pre><code>schedule.every().day.at("21:57").do(task)
</code></pre>
<hr/>
<p>Now, back to your first problem. The task you want to run isn't a normal function, it's an <code>asyncio</code> coroutine, which has to be run on the main thread as part of the main event loop.</p>
<p>But that's exactly what <a href="https://docs.python.org/3/library/asyncio-dev.html#concurrency-and-multithreading" rel="nofollow noreferrer"><code>call_soon_threadsafe</code></a> is for. What you want to call is:</p>
<pre><code>bot.loop.call_soon_threadsafe(send_channel)
</code></pre>
<p>To ask <code>scheduler</code> to run that, you just pass <code>bot.loop.call_soon_threadsafe</code> as the function and <code>send_channel</code> as the argument.</p>
<p>So, putting it all together:</p>
<pre><code>schedule.every().day.at("21:57").do(
    bot.loop.call_soon_threadsafe, send_channel)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is an old question, but I recently ran into the same issue. You can use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe" rel="nofollow noreferrer"><code>run_coroutine_threadsafe</code></a> to schedule a coroutine to the event loop (rather than a callback):</p>
<pre><code>asyncio.run_coroutine_threadsafe(async_function(), bot.loop)
</code></pre>
</div>
<span class="comment-copy">Is the threading part necessary?  Because I couldn't get it to work and I'm not very familiar with threading (I know I should be.)  In terms of "schedule.every().day.at("21:57").do(     bot.loop.call_soon_threadsafe, send_channel)", that part wasn't working for me either.  I'm still getting an error, coroutine 'send_channel' was never awaited.  And I think the send_channel() function has to have async to work.</span>
