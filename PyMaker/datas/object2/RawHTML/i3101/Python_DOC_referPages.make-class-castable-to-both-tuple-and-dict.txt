<div class="post-text" itemprop="text">
<p>I would like to define a class so that its instances can be casted to both <code>tuple</code> and <code>dict</code>. An example:</p>
<pre><code>class Point3:
    ...

p = Point(12, 34, 56)

tuple(p)  # gives (12, 34, 56)
dict(p)   # gives { 'x': 12, 'y': 34, 'z': 56 }
</code></pre>
<p>I have found that if I define <code>__iter__</code> as an iterator that yields single values then the instance can be casted to <code>tuple</code> and if it instead yields double values then it can be casted to <code>dict</code>:</p>
<pre><code>class Point3:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    # This way makes instance castable to tuple
    def __iter__(self):
        yield self.x
        yield self.y
        yield self.z

    # This way makes instance castable to dict
    def __iter__(self):
        yield 'x', self.x
        yield 'y', self.y
        yield 'z', self.z
</code></pre>
<p>Is there any way to make instances castable to <strong>both</strong> <code>tuple</code> and <code>dict</code> in Python 2.7?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could just subclass <code>NamedTuple</code> (Other types are available, ask your doctor.):</p>
<pre><code>from typing import NamedTuple


class Point(NamedTuple):
    x: float
    y: float
    z: float

    def __add__(self, p):
        return Point(self.x+p.x, self.y+p.y, self.z+p.z)


p = Point(1, 2, 3)
q = Point(5, 5, 5)

print(p.x, p.y, p.z)
print(p+q)
print(tuple(p))
</code></pre>
<p>.</p>
<pre><code>$ python pointless.py
1 2 3
Point(x=6, y=7, z=8)
(1, 2, 3)
</code></pre>
<p>If the tool you are using has <em>any</em> regard for idiomatic Python, the named tuple should be acceptable as is, anyway. I would try it!</p>
<p>If you were to use dictionaries, I would recommend using the explicit <code>tuple(p.values())</code> (when subclassing) or maybe <code>p.coordinates</code> or <code>p.xyz</code> as property (when wrapping), rather than relying on some magic behing the scenes.</p>
<hr/>
<p>Legacy version, no warranty.</p>
<pre><code>from collections import namedtuple


_Point = namedtuple('Point', 'x y z')


class Point(_Point):
    __slots__ = ()

    def __add__(self, p):
        return Point(self.x+p.x, self.y+p.y, self.z+p.z)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't do what you originally wanted to do (ie, have two different <code>__iter__</code> methods) because it doesn't make any sense. But you can fake it using the mapping protocol (see below).</p>
<p>However before going into that, if you <em>really</em> want to cast to a <code>dict</code>, <a href="https://stackoverflow.com/questions/35282222/in-python-how-do-i-cast-a-class-object-to-a-dict/35282286#35282286">have a look at this answer</a> for some better options.</p>
<hr/>
<p>My suggestion is to either:</p>
<ol>
<li>Do what was suggested in the other answer and utilize <code>namedtuple</code>, which gives you the <code>_asdict()</code> method "for free".</li>
<li>Implement the class utilizing the <a href="https://docs.python.org/2/c-api/mapping.html" rel="nofollow noreferrer">mapping protocol</a> (as explained in the previous link above). If you do that, you can circumvent the <code>__iter__</code> method entirely when casting to <code>dict</code>.</li>
</ol>
<p>You might do that like this; however this is a little bit odd:</p>
<pre><code>class Point3:
    _fields = tuple("xyz")
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
    def __iter__(self):
        for f in self._fields:
            yield getattr(self, f)
    def keys(self):
        return self._fields
    def __getitem__(self, i):
        if i in self._fields:
            return getattr(self, i)
        raise KeyError("{!r} is not a valid field".format(i))
</code></pre>
<p>With the above, the <code>dict</code> is created using the <code>keys()</code> and <code>__getitem__()</code> rather than <code>__iter__</code>:</p>
<pre><code>&gt;&gt;&gt; dict(Point3(1, 2, 3))
{'x': 1, 'y': 2, 'z': 3}
</code></pre>
<p>Using the mapping protocol can also come in handy because you can "cast"- that is, unpack your object in the form of keyword arguments- to any other type that accepts the same field names as keyword arguments, e.g.:</p>
<pre><code>point= XYZer(**point3_instance)
</code></pre>
<hr/>
<p>For other people (not the OP) who are able to benefit from the latest version of Python 3 (3.7): I highly recommend using the <code>dataclasses</code> module:</p>
<pre><code>from dataclasses import dataclass, asdict, astuple

@dataclass
class Point:
    x: float
    y: float
    z: float
</code></pre>
<p>Use it like so:</p>
<pre><code>&gt;&gt;&gt; p = Point(1,2,3)
&gt;&gt;&gt; asdict(p)
{'x': 1, 'y': 2, 'z': 3}
&gt;&gt;&gt; astuple(p)
(1, 2, 3)
</code></pre>
</div>
<span class="comment-copy">Why not just define methods on your class called <code>.to_tuple()</code> and <code>.to_dict()</code> that convert to tuple and dict in whatever ways you want?</span>
<span class="comment-copy">there is no "type casting" in Python. why would you want to convert your objects to plain dicts or lists, anyway? just implement the access methods you want and use them directly.</span>
<span class="comment-copy">@BrenBarn. That's kind of the way I've solved it now. I have made the class "castable" to <code>tuple</code> and used <code>.to_dict()</code> for creating dictionaries.</span>
<span class="comment-copy">@md2perpe This is a good question, but you need a switch somewhere. When do you want to cast it as a dictionary and when do you want to cast it as a tuple (becasue both calls <code>__iter__</code>).</span>
<span class="comment-copy">@md2perpe: if that is so, then that tool is severely broken. subclass <code>Point</code> from <code>dict</code> (or <code>namedtuple</code>) and use <code>tuple(p.items())</code> wherever necessary.</span>
<span class="comment-copy">Syntax error on <code>x : float</code>. Reported Python version: 2.7.11.</span>
<span class="comment-copy">i am very sorry to hear that. <a href="https://pythonclock.org" rel="nofollow noreferrer">pythonclock.org</a> best of luck!</span>
<span class="comment-copy">Note: As of 3.7, if you need a mutable class, <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">the <code>dataclasses</code> module</a> is basically a souped up version of <code>typing.NamedTuple</code>, but with mutability by default, and much greater configurability.</span>
<span class="comment-copy">To point #2, you don't need to use unpacking syntax with the <code>dict</code> constructor; you can just do <code>dict(point)</code>; <code>dict(**point)</code> is somewhat redundant (it converts to <code>dict</code> to unpack, then reads the result to initialize the new <code>dict</code>).</span>
<span class="comment-copy">@ShadowRanger that's a good point i had forgotten that the mapping protocol short-circuits <code>__iter__</code>.</span>
<span class="comment-copy">@ShadowRanger fixed.</span>
