<div class="post-text" itemprop="text">
<p>I am looking for a way to run part of python code/function to be run as the different user in Linux, instead of make another script. </p>
<p>For example:</p>
<pre><code>def function1(args):
    # stuffs 

def function2():
    # stuffs
</code></pre>
<p>I would like to call the function <code>function1</code> from <code>function2</code> with passing couple of arguments and the <code>function1</code> should accept those arguments and execute the stuffs as the different user and return the result. Since I have to call some stuffs in between during the entire execution and so I don't want to create multiple scripts for small piece of code. Basically am trying to connect database in the function <code>function1</code> (the database connection can be done as that particular user only) and run the query and get the result. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is a bit more difficult than you might expect. First of all, Python provides <a href="https://docs.python.org/3/library/os.html#os.setuid" rel="noreferrer"><code>os.setuid()</code></a> and <a href="https://docs.python.org/3/library/os.html#os.setgid" rel="noreferrer"><code>os.setguid()</code></a> to change the current user/group of the running script and you can create a context manager to do your bidding for you and automatically revert back to the currently executing user:</p>
<pre><code>import os

class UnixUser(object):

    def __init__(self, uid, gid=None):
        self.uid = uid
        self.gid = gid

    def __enter__(self):
        self.cache = os.getuid(), os.getgid()  # cache the current UID and GID
        if self.gid is not None:  # GID change requested as well
            os.setgid(self.gid)
        os.setuid(self.uid)  # set the UID for the code within the `with` block

    def __exit__(self, exc_type, exc_val, exc_tb):
        # optionally, deal with the exception
        os.setuid(self.cache[0])  # revert back to the original UID
        os.setgid(self.cache[1])  # revert back to the original GID
</code></pre>
<p>And to test it:</p>
<pre><code>def test():
    print("Current UID: {}".format(os.getuid()))  # prints the UID of the executing user

test()  # executes as the current user

with UnixUser(105):
    test()  # executes as the user with UID: 105
</code></pre>
<p>You can even create a neat decorator to select that some functions should always execute as another user:</p>
<pre><code>def as_unix_user(uid, gid=None):  # optional group
    def wrapper(func):
        def wrapped(*args, **kwargs):
            with UnixUser(uid, gid):
                return func(*args, **kwargs)  # execute the function
        return wrapped
    return wrapper

def test1():
    print("Current UID: {}".format(os.getuid()))  # prints the UID of the executing user

@as_unix_user(105)
def test2():
    print("Current UID: {}".format(os.getuid()))  # prints the UID of the executing user

test1()  # executes as the current user
test2()  # executes as the user with UID: 105
</code></pre>
<p>The kicker? Next to not being thread-safe, it will only work if both the current user, and the user you want to execute the function as, have <a href="http://man7.org/linux/man-pages/man2/setuid.2.html" rel="noreferrer"><code>CAP_SETUID</code></a> and, optionally, <a href="http://man7.org/linux/man-pages/man2/setgid.2.html" rel="noreferrer"><code>CAP_SETGID</code></a> capabilities.</p>
<p>You can get away with having only one user with these capabilities run the main script and then fork when necessary, changing the UID/GID only on the forked process:</p>
<pre><code>import os

def as_unix_user(uid, gid=None):  # optional group
    def wrapper(func):
        def wrapped(*args, **kwargs):
            pid = os.fork()
            if pid == 0:  # we're in the forked process
                if gid is not None:  # GID change requested as well
                    os.setgid(gid)
                os.setuid(uid)  # set the UID for the code within the `with` block
                func(*args, **kwargs)  # execute the function
                os._exit(0)  # exit the child process
        return wrapped
    return wrapper

def test1():
    print("Current UID: {}".format(os.getuid()))  # prints the UID of the executing user

@as_unix_user(105)
def test2():
    print("Current UID: {}".format(os.getuid()))  # prints the UID of the executing user

test1()  # executes as the current user
test2()  # executes as the user with UID: 105
</code></pre>
<p>The kicker here? You don't get the return data from the forked function. If you need it, you'll have to pipe it back to the parent process and then wait in the parent for it to finish. You'll also need to choose a format to pass the data between processes (if simple enough, I'd recommend JSON or resort back to native <code>pickle</code>)...</p>
<p>At that point, you're already doing half of what the <a href="https://docs.python.org/3/library/subprocess.html" rel="noreferrer"><code>subprocess</code></a> module is doing so you might as well just launch your function as a subprocess and be done with it. If you have to go through such hoops to achieve your desired result, chances are your original design is at fault. In your case - why not just provide the permissions to the current user to access the DB? The user will need to have the capabilities to switch to another user who can so you're not gaining anything in terms of security from it - you're only complicating your life.</p>
</div>
<span class="comment-copy">You can't do that. You must use two processes.</span>
<span class="comment-copy">do you mean a different <i>database</i> user or a different <i>linux</i> user?</span>
<span class="comment-copy">@Mohl Different linux user is fine for me.</span>
<span class="comment-copy">I don't think that's possible unless you're sshing into another computer</span>
<span class="comment-copy">@ᴡʜᴀᴄᴋᴀᴍᴀᴅᴏᴏᴅʟᴇ3000 SSHing is required only when we try to execute something on the remote server. But in my case the user resides on the same system only.</span>
<span class="comment-copy">Thanks for the detailed information. I tried with <code>os.setreuid(user_id, user_id)</code> but when we just change the user id it doesn't take effect of the environment variables of that user. I think its better to split the script into multiple scripts and run them through subprocess using <code>su -</code>.</span>
