<div class="post-text" itemprop="text">
<p>I have a generator function <code>A</code>.</p>
<p>For example (in reality I have a more complex function <code>A</code>),</p>
<pre><code>def A():
    yield from [i**2 for i in range(20)]
</code></pre>
<p>Writing another generator function <code>B</code>, I want to enumerate all elements that <code>A</code> returns except the first element.</p>
<p>What are <em>concise</em> ways to implement this in Python 3?</p>
</div>
<div class="post-text" itemprop="text">
<p>Usually, you don't need this in an expression, so you just call <code>next(it)</code>, ignoring the results, to consume and discard the first element.</p>
<hr/>
<p>However, if the iterator might be empty, you have to decide what you want to happen:</p>
<ul>
<li>Maybe you want to raise <code>StopIteration</code>, in which case <code>next(it)</code> is fine.</li>
<li>Maybe you want to raise something else, in which case you <code>next(it)</code> inside an <code>except StopIteration: raise SomethingElse()</code>.</li>
<li>Maybe you just want to leave the iterator empty, in which case you can call <code>next(it, None)</code>. </li>
</ul>
<p>You can find examples of these in the stdlib and docs. For example, if you scan through the recipes in <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code></a>:</p>
<pre><code>def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)
</code></pre>
<p>This is doing exactly what you want to doâ€”skip the first element of <code>b</code>. And if <code>iterable</code> is empty, you don't want an error here; you just want to iterate nothing. So, <code>next(b, None)</code>.</p>
<hr/>
<p>What if you need to do this in the middle of an expression?</p>
<p>Then you can write a function that skips the first element:</p>
<pre><code>def skip_first(iterable):
    it = iter(iterable)
    next(it, None)
    return it
</code></pre>
<p>(Again, you have to decide what you want to happen for an empty iterable.)</p>
<p>This returns a first-skipped version of the iterator, so you can use it inline. (It <em>also</em> mutates the iterator you passed in, of course, but you normally only use on a temporary value that you're not keeping any references to, so that's not a problem.)</p>
<p>Or, if you need to return a generator instead of an arbitrary iterator (usually you don't):</p>
<pre><code>def skip_first(iterable):
    it = iter(iterable)
    next(it, None)
    yield from it
</code></pre>
<p>Or you can use the more general version of the same idea, <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a>. The following have the same effect:</p>
<pre><code>it = skip_first(it)
it = itertools.islice(it, 1, None)
</code></pre>
<hr/>
<p>While we're on the <code>itertools</code> recipes, it's worth looking at <code>consume</code>:</p>
<pre><code>def consume(iterator, n=None):
    "Advance the iterator n-steps ahead. If n is None, consume entirely."
    # Use functions that consume iterators at C speed.
    if n is None:
        # feed the entire iterator into a zero-length deque
        collections.deque(iterator, maxlen=0)
    else:
        # advance to the empty slice starting at position n
        next(islice(iterator, n, n), None)
</code></pre>
<p>Forget the <code>None</code> part; the interesting bit is that it skips <code>n</code> elements with an <code>islice</code> and a <code>next</code>. (Notice that it's mutating <code>iterator</code> in-place, not returning something.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="noreferrer"><code>itertools.islice</code></a>:</p>
<pre><code>itertools.islice(generator,1,None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>Disclaimer: See @abarnert and @Solaxun's answers above.</em></p>
<p><em>Just thought that the following should be mentioned</em></p>
<p>If you have e.g. <code>original = iter((1,2,3,4,5))</code></p>
<p>Then</p>
<pre><code>first, remaining = next(original), original
</code></pre>
<p>where <code>remaining</code> is the iterator without the first element. </p>
<hr/>
</div>
<span class="comment-copy">Show the code you have for A</span>
<span class="comment-copy">using <code>next()</code> ?</span>
<span class="comment-copy"><code>_, *rest = your_iterator</code></span>
<span class="comment-copy">@dfundako: I tried to accomplish your request (see edited code), but: a. <code>A()</code> is somehow too complex, b. <code>A()</code> is not yet written :-)</span>
<span class="comment-copy">Thanks for the comment.. was updating it myself.  The distinction here between this approach and others such as <code>first, *rest = generator</code> is that this will preserve the lazyness of the generator (rather than consuming the entire thing up front).</span>
