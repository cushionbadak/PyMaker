<div class="post-text" itemprop="text">
<p>I'm trying to write a function decorator that tests for bounds of x, y</p>
<pre><code>#this is my bound test function
def boundtest(func):
    def onDecorator(self, x, y, *args, **kwargs):
        print(x, y, *args, **kwargs)
        assert x in range(self.width) and y in range(self.height)
        return func(x, y, *args, **kwargs)

    return onDecorator

class Game:
    #these are the functions that need bound checking

    @boundtest
    def at(self, x: int, y: int) -&gt; int:
        return self.map[x, y]

    @boundtest
    def set(self, x: int, y: int, data):
        self.map[x, y] = data.value
</code></pre>
<p>When I execute <code>game.set(1, 1, Color.RED)</code> I get:</p>
<pre><code>Traceback (most recent call last):
  File "C:\Users\Ben\Desktop\Projects\bubble-breaker-bot\game.py", line 61, in &lt;module&gt;
    game.set(1, 1, Color.RED)
  File "C:\Users\Ben\Desktop\Projects\bubble-breaker-bot\game.py", line 21, in onDecorator
    return func(x, y, *args, **kwargs)
TypeError: set() missing 1 required positional argument: 'data'
</code></pre>
<p>I need the boundtest function to check if <code>x</code> and <code>y</code> are in range of <code>self.width</code>, and <code>self.height</code> respectively while being able to pass an arbitrary amount of parameters to the function it is decorating.</p>
<p>Why does this happen?</p>
</div>
<div class="post-text" itemprop="text">
<p>Decorators are applied to function objects, not to bound methods. This means you need to <em>pass on the <code>self</code> argument manually</em>:</p>
<pre><code>def boundtest(func):
    def onDecorator(self, x, y, *args, **kwargs):
        print(x, y, *args, **kwargs)
        assert x in range(self.width) and y in range(self.height)
        return func(self, x, y, *args, **kwargs)

    return onDecorator
</code></pre>
<p>Python uses a process called <em>binding</em> to turn a function into a bound method, and calling a bound method automatically passes in whatever it is bound <em>to</em> as the first argument; this is how <code>self</code> is passed into a method when you call a fuction on an instance. See the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer"><em>Descriptor HowTo</em></a> for details. Instead of manually passing on <code>self</code>, you could <a href="https://docs.python.org/3/reference/datamodel.html#invoking-descriptors" rel="nofollow noreferrer">invoke descriptor binding manually</a>, by calling <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer"><code>func.__get__()</code></a> to produce a bound method:</p>
<pre><code>def boundtest(func):
    def onDecorator(self, x, y, *args, **kwargs):
        print(x, y, *args, **kwargs)
        assert x in range(self.width) and y in range(self.height)
        bound_method = func.__get__(self, type(self))
        return bound_method(x, y, *args, **kwargs)

    return onDecorator
</code></pre>
<p>That binding behaviour was applied to the <code>onDecorator</code> function object your decorator returned when <code>game.set</code> was being resolved, but not to the wrapped <code>func</code> object.</p>
</div>
<span class="comment-copy">@heemayl: I added the usual exposition with links to the documentation.</span>
<span class="comment-copy">Is there a better way to go about writing a decorator? Following PEP 20 the zen of python "Simple is better than complex. Flat is better than nested." the nested function seems a bit obnoxious if you ask me.</span>
<span class="comment-copy">@BenjaminKosten: Not sure why you think that. A decorator is expected to return either the original function or a replacement object. The easiest and simplest way to produce a replacement that re-uses the original is by using a nested function object that then has access to the original as a closure. The added advantage is that the produced function object is unique; you can and should use <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>@functools.wraps(func)</code></a> to copy across identifying information. And decorators greatly help make the rest of your code simple!</span>
<span class="comment-copy">@BenjaminKosten: however, you could take a look at the <a href="http://decorator.readthedocs.io/en/latest/" rel="nofollow noreferrer"><code>decorator</code> project</a> if you feel that that would produce clearer code for you.</span>
