<div class="post-text" itemprop="text">
<p>code example from <a href="https://www.mimecast.com/developer/documentation/downloading-siem-logs/" rel="nofollow noreferrer">https://www.mimecast.com/developer/documentation/downloading-siem-logs/</a> shows a script that can be used to download logs from a service in python 2.7.</p>
<p>I am working on updating the script to be compatible with python 3 but cannot figure out how to get a string to pass into the hmac.new section for the hash generation here:</p>
<pre><code>SECRET_KEY = 'SECRET KEY FOR YOUR ADMINISTRATOR'
secret_key = SECRET_KEY
def create_signature(data_to_sign, secret_key):
        digest = hmac.new(secret_key.decode("base64"), data_to_sign, digestmod=hashlib.sha1).digest()
        return base64.encodestring(digest).rstrip()
</code></pre>
<p>trying to run this as-is results in "LookupError, 'base64' is not a text encoding; use codecs.decode() to handle arbitrary codecs"</p>
<p>I was trying to convert the variable to bytes prior to or inside this function by using the </p>
<p><code>base64.b64decode</code>
or <code>bytes(secret_key)</code></p>
<p>functions but that results in "TypeError, Unicode-objects must be encoded before hashing" and I'm just not finding a lot of information on how to get a string variable to pass into hmac.new().</p>
<p>I am pretty sure this is related to the change between python 2 and 3 where strings are stored as unicode in 3 where it was raw data in 2, but I'm not familiar enough with these encodings to understand how to properly translate them when passing them around</p>
</div>
<div class="post-text" itemprop="text">
<p>Just think what's <code>bytes</code> and what's <code>str</code>:</p>
<p><strong>EDIT</strong>: according to the <a href="https://docs.python.org/3.7/library/hmac.html?highlight=hmac#hmac.new" rel="nofollow noreferrer">docs for <code>hmac.new</code></a> and <a href="https://docs.python.org/3.7/library/hashlib.html#module-hashlib" rel="nofollow noreferrer">the <code>hashlib</code> module</a>, <code>data_to_sign</code> must also be <code>bytes</code>.</p>
<ol>
<li><code>secret_key</code> is a <code>str</code> -&gt; convert it to <code>bytes</code></li>
<li><code>data_to_sign</code> is possibly a <code>str</code> as well -&gt; convert it to <code>bytes</code></li>
<li><code>base64.b64decode</code> accepts and outputs <code>bytes</code> -&gt; do nothing</li>
<li><code>hmac.new</code> accepts <code>bytes</code> too -&gt; we're already ready</li>
<li><code>digest</code> returns <code>bytes</code> -&gt; we want to <code>b64encode</code> it, and <code>b64encode</code> accepts <code>bytes</code>, so we're good</li>
<li>You want to output a <code>str</code> (although <code>bytes</code> may be just fine) -&gt; <code>decode</code> the result of <code>b64encode</code></li>
</ol>
<p>You may also supply an <code>encoding</code> argument to your function, if you want to work with an encoding different from the default (<a href="https://docs.python.org/3/library/stdtypes.html?highlight=str%20encode#str.encode" rel="nofollow noreferrer">utf-8</a>).</p>
<p>Code:</p>
<pre><code>import base64

def create_signature(data_to_sign: str, secret_key: str, encoding='utf-8') -&gt; str:
    secret_key = secret_key.encode(encoding) # convert to bytes
    data_to_sign = data_to_sign.encode(encoding) # convert to bytes
    secret_key = base64.b64decode(secret_key) # this is still bytes

    digest = hmac.new(secret_key, data_to_sign, digestmod=hashlib.sha1).digest() # still bytes

    digest_b64 = base64.b64encode(digest) # bytes again

    return digest_b64.decode(encoding) # that's now str
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The error message is telling you what you need to do:</p>
<pre><code>TypeError, Unicode-objects must be encoded before hashing
</code></pre>
<p>To encode a Unicode object (that is, a <code>str</code>), you just call its <a href="https://docs.python.org/3/library/stdtypes.html#str.encode" rel="nofollow noreferrer"><code>encode</code></a> method.</p>
<p>You have to decide what encoding you want. Usually, this is UTF-8. If you're on a modern Python 3, UTF-8 is guaranteed to be the default, so you can just write this:</p>
<pre><code>secret_key_bytes = secret_key.encode()
</code></pre>
<p>If you want a different encoding (or if you want UTF-8 but you're on an older Python), specify it explicitly:</p>
<pre><code>secret_key_bytes = secret_key.encode('Latin-1')
</code></pre>
</div>
<span class="comment-copy">As a side note, IIRC, 3.7 will give you a deprecation warning for <a href="https://docs.python.org/3/library/hmac.html" rel="nofollow noreferrer"><code>hmac.new</code></a>, because it's being removed entirely for a new <code>hmac.digest</code> that doesn't have a default value for <code>digestmod</code>. If you aren't seeing that warning, just make a note of it so it doesn't surprise you in 3.8; if you are, and you don't need to be compatible with 3.4-3.6, just changing the <code>new</code> to <code>digest</code> should fix it.</span>
<span class="comment-copy">using this was still returning the "TypeError, Unicode-objects must be encoded before hashing" message, tested with this exact code with the parameters: SECRET_KEY = "cGFzc3dvcmQ="</span>
<span class="comment-copy">@ForrestBerrey, is <code>data_to_sign</code> <code>str</code> in your code? If yes, see the edit to my answer</span>
<span class="comment-copy">this was the problem, I was confused by the docs as they only explicitly call out "key is a bytes or bytearray object giving the secret key. If msg is present, the method call update(msg) is made. digestmod is the digest name, digest constructor or module for the HMAC object to use." so I was thinking the error had to be related to the secret_key when it was the data_to_sign the entire time. Thank you for clarifying that point</span>
<span class="comment-copy">I did try this as well using the .encode() .encode('utf-8') and .encode('Latin-1') variations and all continued to result in the "TypeError, Unicode-objects must be encoded before hashing" problem</span>
<span class="comment-copy">@ForrestBerrey You're going to have to show us the code that you tried. Obviously you got something wrong, but it's impossible for anyone to guess what you got wrong without seeing the code.</span>
<span class="comment-copy">You are correct, I was under the false assumption that the data_to_sign field could be passed as a string due to my incorrect interpretation of the hmac.new() documentation. Thank you for your review and comments</span>
