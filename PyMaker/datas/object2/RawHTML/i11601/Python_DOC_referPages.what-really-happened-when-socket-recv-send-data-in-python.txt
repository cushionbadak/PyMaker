<div class="post-text" itemprop="text">
<p>I have read this from <a href="https://docs.python.org/3/howto/sockets.html?highlight=socket" rel="nofollow">Socket Programming HOWTO in Python Documentation</a></p>
<blockquote>
<p>you can transform your client socket into a file-like beast and use read and write. ... except to warn you that you need to use flush on sockets. These are buffered “files”, and a common mistake is to write something, and then read for a reply. Without a flush in there, you may wait forever for the reply, because the request may still be in your output buffer.</p>
<p>Now we come to the major stumbling block of sockets - send and recv operate on the network buffers</p>
</blockquote>
<p><code>socket object</code> in Python is a file descriptor, and you can use <code>makefile()</code> to get a <code>file object</code> associated with the socket. </p>
<p>According to the warning,</p>
<blockquote>
<p>you need to use flush on sockets. These are <strong>buffered “files”</strong>...Without a flush in there, you may wait forever for the reply, <strong>because the request may still be in your output buffer</strong>...send and recv operate on the <strong>network buffers</strong></p>
</blockquote>
<p>I think when <code>socket send/recv</code>, there are actually two buffers: "file buffer" and "network buffer". If you transform <code>socket</code> to <code>file like object</code> and use <code>write(data)</code>, first, data is written into "file output buffer", then into "network send buffer" by using <code>flush</code>. All this can explain the warning in the documentation: use <code>flush</code> after <code>write</code> or the <code>read</code> may block forever.</p>
<p>I drew a picture to show my opinion about underlying "two buffers" for <code>socket</code>.</p>
<p><a href="http://i.stack.imgur.com/qHiFq.png" rel="nofollow">socket transfer data model</a> </p>
<p>So <strong>my question</strong> is how to understand the quote above? Is my "two buffers" model to understand right? Hope your reply, thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, your model is largely correct. It may be helpful to understand that the "network buffers" being referred to in that quote reside in the operating system (i.e. not within the bounds of your process address space), while the "file buffers" are actually implemented within your process by the python runtime. This is why <code>flush</code> is required: the boundary between file buffers and network buffers in your diagram is essentially the operating system's "system call interface". </p>
<p>In other words, when you call <code>socket.send</code>, the data bytes from your buffer are transferred directly into the operating system network buffers (subject to space availability). They will then be sent to the network peer according to standard network mechanisms (TCP, etc). However, when you use <code>makefile</code> you are essentially building a buffering mechanism around this. When you write to the "file-like object", bytes are simply transferred to a hidden buffer maintained in association with the file (but still within your process' address space). Calling <code>flush</code> then does the equivalent of <code>socket.send</code>; moves those bytes into the operating system's buffers for transmission. </p>
<p>There are two cases where one would typically use <code>makefile</code>: (1) you have some other existing code that expects a file-like object that you wish to use in order to construct the bytes to be sent/received via the network, or (2) you <em>want</em> the buffering behavior, say, for performance reasons (of course, you could always implement such buffering yourself using <code>str</code> or <code>bytes</code> objects, but it is often more convenient to simply write to a file-like object).</p>
</div>
