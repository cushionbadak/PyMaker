<div class="post-text" itemprop="text">
<p>I want to find the average of all scores above and below the median (not including the median), but I have no idea have to go about doing this.</p>
<pre><code>import collections

def main():
    names = ["gymnastics_school", "participant_name", "all_around_points_earned"]
    Data = collections.namedtuple("Data", names)
    data = []
    values =[]

    with open('state_meet.txt','r') as f:   
        for line in f:
            line = line.strip()
            items = line.split(',')
            items[2] = float(items[2])
            data.append(Data(*items))        
            values.append(items[2])
    print("summary of data:")



    sorted_data = sorted (values)
    if len(data)%2==0:
        a =sorted_data[len(values)//2]

        b = sorted_data[len(values)//2-1]
        median_val = (a+b)//2
    else:
        median_val = sorted_data[(len(values)-1)//2]

    print("   median score",median_val)   #median
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We now have <a href="https://docs.python.org/3/library/statistics.html" rel="nofollow"><code>statistics</code></a> as part of the standard library:</p>
<pre><code>import statistics

nums = list(range(10))
med = statistics.median(nums)

hi_avg = statistics.mean(i for i in nums if i &gt; med)
lo_avg = statistics.mean(i for i in nums if i &lt; med)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the build-in function <code>filter</code> and <code>sum</code>. For example</p>
<pre><code>above_med = filter(lambda x: x&gt;median_val,  values)
print(" average of scores above median ", sum(above_med)/len(above_med))
</code></pre>
<h1>Edited:</h1>
<p>As suggested by @ChrisP, you can also use the standard package <code>statistics</code> introduced since python 3.4.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an example:</p>
<pre><code>import numpy as np

data_array = np.array(data)

med = np.median(data)

ave_above_med = data_array[data_array &gt; med].mean()
</code></pre>
<p>so the function would be:</p>
<pre><code>import numpy as np

def average_above_med(data):
    data_array = np.array(data)
    med = np.median(data)
    response = data_array[data_array &gt; med].mean()

    return response
</code></pre>
<p>This is a test of that:</p>
<pre><code>test_data = [1, 5, 66, 7, 5]
print(average_above_med(test_data))
</code></pre>
<p>which displays:</p>
<pre><code>36.5
</code></pre>
<p>Hope this helps.</p>
</div>
<span class="comment-copy">Python has a <a href="https://docs.python.org/3/library/statistics.html" rel="nofollow noreferrer"><code>statistics</code> module</a> as part of the standard library!</span>
<span class="comment-copy">You're missing a question.</span>
<span class="comment-copy">What does this code have to do with your problem?</span>
<span class="comment-copy">I'm not sure if this is a valid approach for large data. You're iterating through the entire dataset. If say, we're dealing with a 4D MRI image (90 x 90 x 60 x 10) with 4,860,000 iterations for each process? This will take a week to finish!</span>
<span class="comment-copy">@PouriaHadjibagheri, I don't understand; 4.8 million observations isn't large data. I just ran this with <code>range(4860000)</code> no problem. Also, the question doesn't mention scale and the OP is already reading the data into memory and sorting.</span>
<span class="comment-copy">Chris, I didn't make an aggressive comment, merely an opinion? Regarding 4.86m, trust me, it is when it comes to data of float64 in 4D images. Here is the closest example I can come up with: <code>a = [a**2 for a in np.random.rand(int(4.68e6))]</code> vs  <code>np.random.rand(int(4.68e6))**2</code> . The former takes 1.53 sec and the latter 73.7 ms (over 20 times faster). I didn't mean your solution was invalid. For me as someone who specialises in optimisation, it is not a valid approach. The solution nonetheless remains a valid one. Also, we should always consider the data, because we never know.</span>
<span class="comment-copy">what about the below/</span>
<span class="comment-copy">what about the below?</span>
<span class="comment-copy">I would personally use <code>Numpy</code> because it uses vectorisation (as opposed to iteration implemented in C or Fortran) and is as such considerably faster when dealing with large volumes of data.</span>
<span class="comment-copy">Oh and please not that had written <code>data</code> instead of <code>data_array</code> in my function. I have now corrected that.</span>
