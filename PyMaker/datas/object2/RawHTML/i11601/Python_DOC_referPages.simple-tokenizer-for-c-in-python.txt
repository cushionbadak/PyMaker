<div class="post-text" itemprop="text">
<p>Struggling to find a Python library of script to tokenize (find specific tokens like function definition names, variable names, keywords etc.). </p>
<p>I have managed to find keywords, whitespaces etc. using something like <a href="https://docs.python.org/3/library/re.html#writing-a-tokenizer" rel="nofollow">this</a> but I found it quite a challenge for <strong>function/class definition names etc</strong>. I was hoping of using a pre-existent script; I explored <a href="http://pygments.org/docs/lexers/#lexers-for-c-c-languages" rel="nofollow">Pygments</a> with no success. Its <a href="https://bitbucket.org/birkenfeld/pygments-main/src/ef81d4814bc6b6894cc054b3b66bb2dcbf79add9/pygments/lexers/c_cpp.py?at=default&amp;fileviewer=file-view-default" rel="nofollow">lexer</a> seems amazing for what I want but have no idea how to utilize it in Python and to also get <strong>positions</strong> for each found token.</p>
<p>For example I am looking at doing something like that:</p>
<pre><code>int fac(int n)
{
    return (n&gt;1) ? n∗fac(n−1) : 1;
}
</code></pre>
<p>from the source code above I would like to get:</p>
<blockquote>
<p>function_name: 'fac' at position (x, y)
  variable_name: 'n' at position (x, y+8)</p>
</blockquote>
<p>EDITED:
Any suggestions will be appreciated since I am in the dark here regarding tokenizations and parsing in C++?</p>
</div>
<div class="post-text" itemprop="text">
<p>Eli Bendersky is a smart guy, and sometimes active here on SO. He's got a blog post on this issue which I'll refer you directly to: <a href="http://eli.thegreenplace.net/2011/07/03/parsing-c-in-python-with-clang/" rel="nofollow">Parsing C++ in Python with Clang</a>.</p>
<p>Because things disappear, here's the takeaway:</p>
<p>Eli Bendersky wrote a C language (<strong>not</strong> C++) parser in Python, called <code>pycparser</code>. People keep asking him if he's going to add support for C++. He is not. He recommends instead that people use the Python bindings for libclang to get access to "a C API that the Clang team vows to keep relatively stable, allowing the user to examine parsed code at the level of an abstract syntax tree (AST)".</p>
<p>You can find the bindings separately on PyPI <a href="https://pypi.python.org/pypi/clang/3.5" rel="nofollow">here.</a> Note though that you'll have to have clang installed, so you may just want to point your PYTHON_PATH directly at the install location.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're struggling to find a python library to do what you want because what you want is impossible to do, fundamentally. </p>
<blockquote>
<p>I have managed to find keywords, whitespaces etc. using something like this but I found it quite a challenge for function/class definition names etc</p>
</blockquote>
<p>You mean like this:</p>
<pre><code>foo = 3
def foo():pass
</code></pre>
<p>What is <code>foo</code>? All a tokenizer should/can tell you is that foo is an identifier. It's <em>context</em> tells you whether it's a variable or a function declaration. You need a parser to handle context free grammars. Mathematically, the space of context free grammars is too large for a standard lexer to tackle. </p>
<p>Try a parser: <a href="https://docs.python.org/2/library/parser.html" rel="nofollow noreferrer">here's one in python</a></p>
<p>Normally I'd try and provide you links here to distinguish between the topics, but this is too broad to provide a single good link to. If you're interested, start with any standard compiler text. Elsewhere on SE, we see this question pop up as a <a href="https://softwareengineering.stackexchange.com/questions/198399/is-it-possible-to-create-a-single-tokenizer-to-parse-this">theoretical question</a> and, in some form, <a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags">as a famous question about html</a>.</p>
<p>Once you realize that tokenizers are (usually) built (largely) on regular expressions, it becomes more obvious why your task is not going to end happily.</p>
<hr/>
<p>Now that you know the terminology, I think you'll find <a href="https://stackoverflow.com/questions/1444961/is-there-a-good-python-library-that-can-parse-c">this SO article useful</a>, which recommends <a href="http://gccxml.github.io/HTML/Index.html" rel="nofollow noreferrer">gcc-ml</a>. I don't know how up-to-date it is, but it's the type of program you're looking for.</p>
</div>
<span class="comment-copy">Are you talking about "function/class definitions" as in recognizing their syntax? If so, that's fundamentally a problem not suited for a tokenizer, and you need something that can handle contex-free grammars, i.e., a parser</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/36801263/tokenizer-with-pygments-in-python">Tokenizer with Pygments in Python</a>.  You asked this question a few minutes ago!</span>
<span class="comment-copy">@ChrisP I tried to expand it and differentiate it from my previous question in the sense that now I am detailing on another and more generic (perhaps) route.</span>
<span class="comment-copy">Questions asking people to recommend a tool are off-topic.</span>
<span class="comment-copy">@en_Knight I should have made it clearer, I will edit my question. To simply answer your point, no I do not want the syntax but merely to extract the name of it and -obviously- to identify that it is a function being defined at that line.</span>
<span class="comment-copy">This is a good answer. I tried to address why OP wasn't able to do what he was trying to do, but this seems to have some more practical solution involved. +1</span>
<span class="comment-copy">Your points are really helpful; indeed I am searching in the dark because I was misunderstanding what I was looking for. So, are you aware of any parsers that handle C++ in the way I mention in my description?</span>
<span class="comment-copy">Yes. Gcc is a good one :) All kidding aside, <i>any</i> parser can handle C++. I wouldn't try to unroll your own - C++ is a very complex language. The one I sited is a good one, but again, take an existing C++ compiler and just you the parse tree. Most compilers I am familiar with allow you to dump this information without fully compiling</span>
<span class="comment-copy">@nk-fford see my edit, I think it has the type of thing you're looking for</span>
