<div class="post-text" itemprop="text">
<p>Is there a nice Pythonic way to loop over a list, retuning a pair of elements? The last element should be paired with the first.</p>
<p>So for instance, if I have the list [1, 2, 3], I would like to get the following pairs:</p>
<ul>
<li>1 - 2</li>
<li>2 - 3</li>
<li>3 - 1</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>A Pythonic way to access a list pairwise is: <code>zip(L, L[1:])</code>. To connect the last item to the first one:</p>
<pre><code>&gt;&gt;&gt; L = [1, 2, 3]
&gt;&gt;&gt; zip(L, L[1:] + L[:1])
[(1, 2), (2, 3), (3, 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use a <a href="https://docs.python.org/3/library/collections.html#collections.deque"><code>deque</code></a> with <a href="https://docs.python.org/3/library/functions.html#zip"><code>zip</code></a> to achieve this.</p>
<pre><code>&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt;
&gt;&gt;&gt; l = [1,2,3]
&gt;&gt;&gt; d = deque(l)
&gt;&gt;&gt; d.rotate(-1)
&gt;&gt;&gt; zip(l, d)
[(1, 2), (2, 3), (3, 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd use a slight modification to the <code>pairwise</code> recipe from the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> documentation</a>:</p>
<pre><code>def pairwise_circle(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ... (s&lt;last&gt;,s0)"
    a, b = itertools.tee(iterable)
    first_value = next(b, None)
    return itertools.zip_longest(a, b,fillvalue=first_value)
</code></pre>
<p>This will simply keep a reference to the first value and when the second iterator is exhausted, <code>zip_longest</code> will fill the last place with the first value.</p>
<p>(Also note that it works with iterators like generators as well as iterables like lists/tuples.)</p>
<p>Note that <a href="https://stackoverflow.com/a/36927946/5827215">@Barry's solution</a> is very similar to this but a bit easier to understand in my opinion and easier to extend beyond one element.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would pair <a href="https://docs.python.org/3.5/library/itertools.html#itertools.cycle" rel="noreferrer"><code>itertools.cycle</code></a> with <code>zip</code>:</p>
<pre><code>import itertools

def circular_pairwise(l):
    second = itertools.cycle(l)
    next(second)
    return zip(l, second)
</code></pre>
<p><code>cycle</code> returns an iterable that yields the values of its argument in order, looping from the last value to the first.</p>
<p>We skip the first value, so it starts at position <code>1</code> (rather than <code>0</code>).</p>
<p>Next, we <code>zip</code> it with the original, unmutated list.  <code>zip</code> is good, because it stops when any of its argument iterables are exhausted.  </p>
<p>Doing it this way avoids the creation of any intermediate lists: <code>cycle</code> holds a reference to the original, but doesn't copy it.  <code>zip</code> operates in the same way.</p>
<p>It's important to note that this will break if the input is an <code>iterator</code>, such as a <code>file</code>, (or a <code>map</code> or <code>zip</code> in <a class="post-tag" href="/questions/tagged/python-3" rel="tag" title="show questions tagged 'python-3'">python-3</a>), as advancing in one place (through <code>next(second)</code>) will automatically advance the iterator in all the others.  This is easily solved using <a href="https://docs.python.org/3.5/library/itertools.html#itertools.tee" rel="noreferrer"><code>itertools.tee</code></a>, which produces two independently operating iterators over the original iterable:</p>
<pre><code>def circular_pairwise(it):
    first, snd = itertools.tee(it)
    second = itertools.cycle(snd)
    next(second)
    return zip(first, second)
</code></pre>
<p><code>tee</code> <em>can</em> use large amounts of additional storage, for example, if one of the returned iterators is used up before the other is touched, but as we only ever have one step difference, the additional storage is minimal.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are more efficient ways (that don't built temporary lists), but I think this is the most concise:</p>
<pre><code>&gt; l = [1,2,3]
&gt; zip(l, (l+l)[1:])
[(1, 2), (2, 3), (3, 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use a list comprehension, and take advantage of the fact that <code>l[-1]</code> is the last element.</p>
<pre><code>&gt;&gt;&gt; l = [1,2,3]
&gt;&gt;&gt; [(l[i-1],l[i]) for i in range(len(l))]
[(3, 1), (1, 2), (2, 3)]
</code></pre>
<p>You don't need a temporary list that way.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>Pairwise circular Python 'for' loop</h1>
</blockquote>
<p>If you like the accepted answer, </p>
<pre><code>zip(L, L[1:] + L[:1])
</code></pre>
<p>you can go much more memory light with semantically the same code using <code>itertools</code>:</p>
<pre><code>from itertools import islice, chain #, izip as zip # uncomment if Python 2
</code></pre>
<p>And this barely materializes anything in memory beyond the original list (assuming the list is relatively large):</p>
<pre><code>zip(l, chain(islice(l, 1, None), islice(l, None, 1)))
</code></pre>
<p>To use, just consume (for example, with a list):</p>
<pre><code>&gt;&gt;&gt; list(zip(l, chain(islice(l, 1, None), islice(l, None, 1))))
[(1, 2), (2, 3), (3, 1)]
</code></pre>
<p>This can be made extensible to any width:</p>
<pre><code>def cyclical_window(l, width=2):
    return zip(*[chain(islice(l, i, None), islice(l, None, i)) for i in range(width)])
</code></pre>
<p>and usage:</p>
<pre><code>&gt;&gt;&gt; l = [1, 2, 3, 4, 5]
&gt;&gt;&gt; cyclical_window(l)
&lt;itertools.izip object at 0x112E7D28&gt;
&gt;&gt;&gt; list(cyclical_window(l))
[(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]
&gt;&gt;&gt; list(cyclical_window(l, 4))
[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 1), (4, 5, 1, 2), (5, 1, 2, 3)]
</code></pre>
<h2>Unlimited generation with <code>itertools.tee</code> with <code>cycle</code></h2>
<p>You can also use <code>tee</code> to avoid making a redundant cycle object:</p>
<pre><code>from itertools import cycle, tee
ic1, ic2 = tee(cycle(l))
next(ic2)    # must still queue up the next item
</code></pre>
<p>and now:</p>
<pre><code>&gt;&gt;&gt; [(next(ic1), next(ic2)) for _ in range(10)]
[(1, 2), (2, 3), (3, 1), (1, 2), (2, 3), (3, 1), (1, 2), (2, 3), (3, 1), (1, 2)]
</code></pre>
<p>This is incredibly efficient, an expected usage of <code>iter</code> with <code>next</code>, and elegant usage of <code>cycle</code>, <code>tee</code>, and <code>zip</code>.</p>
<p>Don't pass <code>cycle</code> directly to <code>list</code> unless you have saved your work and have time for your computer to creep to a halt as you max out its memory - if you're lucky, after a while your OS will kill the process before it crashes your computer. </p>
<h2>Pure Python Builtin Functions</h2>
<p>Finally, no standard lib imports, but this only works for up to the length of original list (IndexError otherwise.)</p>
<pre><code>&gt;&gt;&gt; [(l[i], l[i - len(l) + 1]) for i in range(len(l))]
[(1, 2), (2, 3), (3, 1)]
</code></pre>
<p>You can continue this with modulo:</p>
<pre><code>&gt;&gt;&gt; len_l = len(l)
&gt;&gt;&gt; [(l[i % len_l], l[(i + 1) % len_l]) for i in range(10)]
[(1, 2), (2, 3), (3, 1), (1, 2), (2, 3), (3, 1), (1, 2), (2, 3), (3, 1), (1, 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Amazing how many different ways there are to solve this problem.</p>
<p>Here's one more. You can use the <code>pairwise</code> recipe but instead of zipping with <code>b</code>, <code>chain</code> it with the first element that you already popped off. Don't need to <code>cycle</code> when we just need a single extra value:</p>
<pre><code>from itertools import chain, izip, tee

def pairwise_circle(iterable):
    a, b = tee(iterable)
    first = next(b, None)
    return izip(a, chain(b, (first,)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I like a solution that does not modify the original list and does not copy the list to temporary storage:</p>
<pre><code>def circular(a_list):
    for index in range(len(a_list) - 1):
        yield a_list[index], a_list[index + 1]
    yield a_list[-1], a_list[0]

for x in circular([1, 2, 3]):
    print x
</code></pre>
<p>Output:</p>
<pre><code>(1, 2)
(2, 3)
(3, 1)
</code></pre>
<p>I can imagine this being used on some very large in-memory data.</p>
</div>
<div class="post-text" itemprop="text">
<p>This one will work even if the list <code>l</code> has consumed most of the system's memory. (If something guarantees this case to be impossible, then zip as posted by chepner is fine)</p>
<pre><code>l.append( l[0] )
for i in range( len(l)-1):
   pair = l[i],l[i+1]
   # stuff involving pair
del l[-1] 
</code></pre>
<p>or more generalizably (works for any offset <code>n</code> i.e. <code>l[ (i+n)%len(l) ]</code> )</p>
<pre><code>for i in range( len(l)):
   pair = l[i], l[ (i+1)%len(l) ]
   # stuff
</code></pre>
<p>provided you are on a system with decently fast modulo division (i.e. not some pea-brained embedded system). </p>
<p>There seems to be a often-held belief that indexing a list with an integer subscript is un-pythonic and best avoided. Why? </p>
</div>
<div class="post-text" itemprop="text">
<p>This is my solution, and it looks Pythonic enough to me:</p>
<pre><code>l = [1,2,3]

for n,v in enumerate(l):
    try:
        print(v,l[n+1])
    except IndexError:
        print(v,l[0])
</code></pre>
<p>prints:</p>
<pre><code>1 2
2 3
3 1
</code></pre>
<p>The generator function version:</p>
<pre><code>def f(iterable):
    for n,v in enumerate(iterable):
        try:
            yield(v,iterable[n+1])
        except IndexError:
            yield(v,iterable[0])

&gt;&gt;&gt; list(f([1,2,3]))
[(1, 2), (2, 3), (3, 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this?</p>
<pre><code>li = li+[li[0]]
pairwise = [(li[i],li[i+1]) for i in range(len(li)-1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import izip, chain, islice

itr = izip(l, chain(islice(l, 1, None), islice(l, 1)))
</code></pre>
<p>(As above with <a href="https://stackoverflow.com/a/36917579/435563">@j-f-sebastian's "zip" answer</a>, but using itertools.)</p>
<p>NB: <strong>EDITED</strong> given helpful nudge from <a href="https://stackoverflow.com/users/1157100/200-success">@200_success</a>. previously was:</p>
<pre><code>itr = izip(l, chain(l[1:], l[:1]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just another try</p>
<pre><code>&gt;&gt;&gt; L = [1,2,3]
&gt;&gt;&gt; zip(L,L[1:]) + [(L[-1],L[0])]
[(1, 2), (2, 3), (3, 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to consume too much memory, you can try my solution:</p>
<p><code>[(l[i], l[(i+1) % len(l)]) for i, v in enumerate(l)]</code></p>
<p>It's a little slower, but consume less memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>L = [1, 2, 3]
a = zip(L, L[1:]+L[:1])
for i in a:
    b = list(i)
    print b</p>
</div>
<div class="post-text" itemprop="text">
<p>this seems like combinations would do the job.</p>
<pre><code>from itertools import combinations
x=combinations([1,2,3],2)
</code></pre>
<p>this would yield a generator. this can then be iterated over as such</p>
<pre><code>for i in x:
  print i
</code></pre>
<p>the results would look something like </p>
<pre><code>(1, 2)
(1, 3)
(2, 3)
</code></pre>
</div>
<span class="comment-copy">related <a href="http://stackoverflow.com/q/18648824">Construct a circular loop in python</a></span>
<span class="comment-copy">@BhargavRao Should probably close that one as a dupe of this one</span>
<span class="comment-copy">@Barry The answers here are just great, Hence I did not hammer. I needed someone to reassure that the reverse dupe is better. Thanks (and I added a comment there too)</span>
<span class="comment-copy">If the list is huge, this may be inadvisable</span>
<span class="comment-copy">@AaronHall correct. But remember: <a href="http://c2.com/cgi/wiki?PrematureOptimization" rel="nofollow noreferrer">"Premature optimization is the root of all evil"</a>. If the memory is an issue or to support arbitrary iterables (not just sequences), <a href="http://stackoverflow.com/a/36917655/4279"><code>itertools</code> solution can be used.</a></span>
<span class="comment-copy">Oh, I see that you're linking to a different answer. Unfortunately the answer you're linking to isn't extensible to more than 2 elements in width. I do have the direct itertools analogue to your suggestion, below, however.</span>
<span class="comment-copy">@AaronHall Would it still be problematic in Python 3 versus 2.x? 3's <code>zip</code> (among other things) is pretty darn efficient.</span>
<span class="comment-copy">@SeldomNeedy Python 2's <code>zip(*iterables)</code> is like 3's <code>list(zip(*iterables))</code> - which is why I suggest importing <code>izip as zip</code> for Python 2 in my answer - <a href="http://stackoverflow.com/a/36918720/541136">stackoverflow.com/a/36918720/541136</a> - JF actually assumes Python 2's <code>zip</code> in this answer, which compounds the issue of unnecessary creation of long lists in memory. JF's answer uses 200% more memory than necessary for lists (8 bytes per item), as well as the memory for each tuple (relatively enormous at 64 bytes per tuple, see <a href="http://stackoverflow.com/a/30316760/541136">stackoverflow.com/a/30316760/541136</a>) 800% more, so 1000% more total (assuming lazy evaluation.)</span>
<span class="comment-copy">The deque rotates very fast, but it's also rather memory heavy.</span>
<span class="comment-copy">Sure.  For small solutions this is quick and clean.  It also demonstrates <code>deque.rotate</code> which can be extremely useful.</span>
<span class="comment-copy">most elegant I believe.</span>
<span class="comment-copy">@GrijeshChauhan have you seen <a href="http://stackoverflow.com/a/36927946/5827215">@Barry's solution</a>?</span>
<span class="comment-copy">Thanks for this. Great that it works with any generator!</span>
<span class="comment-copy">The logic isn't extensible to more than a second element.</span>
<span class="comment-copy">@AaronHall, If I had any reason to extend it further I'd wrap it in a <code>cycle</code>.</span>
<span class="comment-copy">Now this is clean, easy to read, and efficient!</span>
<span class="comment-copy">@PythonNut Thanks, that's what I love about <code>itertools</code>, and functional programming in general, it allows extremely clean, concise code, while still being easy to read.</span>
<span class="comment-copy">It fails if the input is an iterator.</span>
<span class="comment-copy">@J.F.Sebastian: Edited, thanks.</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/itertools.html#itertools.cycle" rel="nofollow noreferrer">The <code>cycle</code> docs</a> specifically state that they save a copy of each item in the input iterable -- so you're not saving any space over making a copy of the list. Several of the other answers avoid this problem, using <code>chain</code> or <code>fillvalue</code>.</span>
<span class="comment-copy">Thish as a problem if the list is really long.  It creates another list <code>(l+l)</code> twice the size.</span>
<span class="comment-copy">Sure; I was going for maximum conciseness in this answer.</span>
<span class="comment-copy">"This is a problem if the list is really long." Creating another list, long or not, is not a problem in itself; it's just a fact to be aware of.</span>
<span class="comment-copy">You would need <code>xrange</code> in Python 2 to avoid a temporary list. Creating a list of number from 1 to n is just as expensive as creating a shallow copy of a list with <code>n</code> items.</span>
<span class="comment-copy">I think too similar to your to be its own answer, this could also be something like  <code>[(l[i-1], it) for i, it in enumerate(l)]</code>. You should probably note that both of these methods put the last element requested first.</span>
<span class="comment-copy">@chepner : I tend to assume python3 when not specified ;)</span>
<span class="comment-copy">porglezomp's right, the first element of the list should be (1,2) not (3,1).</span>
<span class="comment-copy">you may want to mention that unless you have some sort of end point (in this case <code>range(10)</code>) the cycle will never end.</span>
<span class="comment-copy">Sure they'll end, just pass them to list, and they'll end when you run out of memory. :D</span>
<span class="comment-copy">This is the best solution. Efficient, easy to read and reusable.</span>
<span class="comment-copy">You last sentence should be a separate question. The answer is that new Python programmers coming from C, C++, or Java write <code>for i in range(len(a_list)): print a_list[i]</code> instead of <code>for x in a_list: print x</code>.</span>
<span class="comment-copy">Indexing a list with integer indexes is unpythonic because if you just need the element, then <code>for el in iterable:</code> is the way to go. If you also need the index, <code>enumerate()</code> is the way to go. So manual indexing should be avoided.</span>
<span class="comment-copy">That's very cool...</span>
<span class="comment-copy">If you're going to use <code>itertools</code>, then @RoadieRich's solution is better, because it avoids the copying and slicing.</span>
<span class="comment-copy">Good point -- for some reason had it in my head that slice was "copy on write". Edited to use islice.</span>
<span class="comment-copy">Welcome to StackOverflow! Please consider adding some explanation to your code. Thank you!</span>
<span class="comment-copy">Your results do not match the OP's example.</span>
<span class="comment-copy">really? you are assuming the order matters...I assumed only the combinations mattered. which would mean that this answer is correct.</span>
<span class="comment-copy">consider a longer list perhaps, given <code>[1,2,3,4,5]</code> the result would be <code>[(1,2), (2,3), (3,4), (4,5), (5,1)]</code> which is not combinations but just pairs in the list.</span>
