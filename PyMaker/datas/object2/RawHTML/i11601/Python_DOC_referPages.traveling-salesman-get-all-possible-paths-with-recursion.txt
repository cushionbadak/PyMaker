<div class="post-text" itemprop="text">
<p>I am trying to write a recursion method to calculate all possible paths of the traveling salesman problem:</p>
<pre><code>def allPaths(toCover, path=""):

    path = path + toCover[0]
    toCover.remove(toCover[0])

    if len(toCover)&gt;0:
        for x in range (0, len(toCover)):
            #swop cities
            temp = toCover[0]
            toCover[0] = toCover[x]
            toCover[x] = temp
            allPaths(toCover, path)
    else :
        print path


cities = ["A", "B", "C", "D"]

allPaths(cities)
</code></pre>
<p>So, I have a list of cities.</p>
<p>I add the first city in the list to the current path.
I remove the added city from the cities <code>toCover</code> list.
For each remaining city in the list I call the <code>allPaths()</code> function again. I modify the list parameter, that each city is on index 0 once.</p>
<p>(I want call the allPaths with the following list instances:</p>
<pre><code>[B,C,D]
[C,B,D]
[D,C,B]
</code></pre>
<p>)</p>
<p>However, when I am debugging this, the cities-<code>toCover</code> list gets modified across all "instances" of allPaths. Which means, it returns the first valid path "ABCD", but then does not continue because for the next call, all cities have already been removed.</p>
<p>What am I doing wrong?</p>
<p>I hope this explanation is some what clear...</p>
</div>
<div class="post-text" itemprop="text">
<p>the solution is easy. It's because <code>toCover</code> (wich should be named <code>to_cover</code>, if you ask me, but hey, it's your code ^^) is a list.
Lists are mutable, that means that every instance holds a <em>reference</em> to the original object, resulting in the problem that all changes are done on all references (ok, they are really just done to the object, but the references point to that object, so...).</p>
<p>You can solve it in three ways:</p>
<ul>
<li><p>Using a tuple instead, or just using the list as if it was a tuple</p>
<p>You replace <code>cities = ["A", "B", "C", "D"]</code> with <code>cities = ("A", "B", "C", "D")</code> (if you want a tuple), and use <code>toCover = toCover[1:]</code> instead of <code>toCover.remove(toCover[0])</code>, wich should be (if it <em>should</em> modify the underlying object) <code>del toCover[0]</code> anyway.</p>
<p><code>x[1:]</code> creates a slice of a list or a tuple (although you can implement almost anything for that operator in your own types), resulting in a new instance that has any element except the first one. See <a href="https://ramisayar.com/hidden-features-in-python-slicing-and-sliding/" rel="nofollow">here</a> (the python documentation lacks a real explanation, don't ask me why).</p></li>
<li><p>Duplicating the list over and over again</p>
<p>This solution is the common way to deal with the problem, but it really isn't the way to go here. This gets around the reference by copying the list like this: <code>toCover = toCover[:]</code> (this should be at the top of your function). It creates a slice (again: <a href="https://ramisayar.com/hidden-features-in-python-slicing-and-sliding/" rel="nofollow">this link</a>) containing the whole list, effectivly copying it.</p></li>
<li><p>Using <code>itertools.permutations</code> wich does the thing you want to do. (see @John Coleman 's comment on your question) See the <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow">python documentation</a> for more details.</p></li>
</ul>
<p>I hope I could help,</p>
<p>CodenameLambda</p>
</div>
<span class="comment-copy">It is a fun exercise to work out the details -- but if all you want is a solution <code>itertools</code> has permutations already built in.</span>
