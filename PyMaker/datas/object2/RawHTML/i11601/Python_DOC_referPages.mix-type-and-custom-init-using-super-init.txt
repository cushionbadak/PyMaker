<div class="post-text" itemprop="text">
<h1>What I've succeeded to do so far:</h1>
<p>I've made an <code>elem</code> class to represent html elements (<code>div</code>, <code>html</code>, <code>span</code>, <code>body</code>, etc.).</p>
<p>I'm able to derivate this class like this to make subclasses for each element:</p>
<pre><code>class elem:
    def __init__(self, content="", tag="div", attr={}, tag_type="double"):
        """Builds the element."""
        self.tag = tag
        self.attr = attr
        self.content = content
        self.tag_type = tag_type

class head(elem):
    """A head html element."""

    def __init__(self, content=None, **kwargs):
        super().__init__(tag="head", content=content, **kwargs)
</code></pre>
<p>And it works pretty well.</p>
<p>But I have to write this for each subclass declaration, and that's pretty repetitive and redundant if I want to do every HTML tag type.</p>
<p>So I was trying to make a <code>make_elem()</code> function that would make my class by taking the corresponding tag name as a string parameter.</p>
<p>So instead of the previous class definition, I would simply have something like this:</p>
<pre><code>head = make_elem_class("head")
</code></pre>
<h1>Where I'm stuck</h1>
<p>This function should create a class. And the <code>__init__()</code> method from this class should call the <code>__init__()</code> method from the class it inherits from.</p>
<p>I tried to make this <code>make_elem_class()</code> function and it looked like this :</p>
<pre><code>def make_elem_class(name):
    """Dynamically creates the class with a type() call."""

    def init(self, content=None, **kwargs):
        super().__init__(tag=name, content=None, **kwargs)

    return type(name, (elem,), {"__init__" : init})
</code></pre>
<p>But when running <code>html = make_elem_class('html')</code>, then <code>html("html element")</code> I get the following error:</p>
<pre><code>Traceback (most recent call last):
  File "elements.py", line 118, in &lt;module&gt;
    html("html element")
  File "elements.py", line 20, in init
    super().__init__(tag=name, content=None, **kwargs)
TypeError: object.__init__() takes no parameters
</code></pre>
<p>I guess that it has something to do with the empty <code>super()</code> call, so I tried with <code>super(elem, self)</code> instead. But it obviously doesn't work better.</p>
<p>How could I achieve this?</p>
<p><strong>NB :</strong> If I remove the <code>"__init__":init</code> from the dictionnary in the <code>type()</code> call, it works fine but the tag isn't correctly set in my elem. I've also tried to directly pass <code>{"tag":name}</code> to <code>type()</code> but it didn't work either.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't use the no-argument form of <code>super()</code> here, as there is no <code>class</code> statement here to provide the context that that function normally needs.</p>
<p>Or rather, you can't unless you provide that context yourself; you need to set the name <code>__class__</code> as a closure here:</p>
<pre><code>def make_elem_class(name):
    """Dynamically creates the class with a type() call."""

    def init(self, content=None, **kwargs):
        super().__init__(tag=name, content=content, **kwargs)

    __class__ = type(name, (elem,), {"__init__" : init})
    return __class__
</code></pre>
<p><code>super()</code> automatically will take the <code>__class__</code> value from the closure. Note that I pass on the value for <code>content</code>, not <code>None</code>, to the <code>elem.__init__</code> method; you wouldn't want to lose that value.</p>
<p>If that is <a href="https://stackoverflow.com/questions/19608134/why-is-python-3-xs-super-magic">too magical</a> for you, explicitly name the class and <code>self</code> when calling <code>super()</code>; again, the class is going to be taken from the closure:</p>
<pre><code>def make_elem_class(name):
    """Dynamically creates the class with a type() call."""

    def init(self, content=None, **kwargs):
        super(elemcls, self).__init__(tag=name, content=content, **kwargs)

    elemcls = type(name, (elem,), {"__init__" : init})
    return elemcls
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What's about a more straight-forward solution like inferring the tag for the class <code>__name__</code>?</p>
<pre><code>class elem:
    def __init__(self, content="", tag=None, attr={}, tag_type="double"):
        """Builds the element."""
        self.tag = tag or self.__class__.__name__
        ...
</code></pre>
<p>And then:</p>
<pre><code>class div(elem): pass
class head(elem): "Optional docstring for &lt;head&gt;"
...
</code></pre>
<p>A bit less magic (controversial), and a bit more explicit. :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this is a little bit of an XY problem. In that you've asked to how to use <code>super</code> in a dynamically created class, but what you really want is a less verbose way to set various class variables and defaults for your subclasses. </p>
<p>Since you don't expect all instances of the same tag class to share the same tag name, you might as well set it as a class variable rather than an instance variable. eg.</p>
<pre><code>from abc import ABC, abstractmethod

class Elem(ABC):
    tag_type = "double" # the default tag type

    def __init__(self, content="", attr=None, tag_type=None):
        """Builds the element."""
        self.attr = attr if attr is not None else {}
        self.content = content
        if tag_type is not None:
            self.tag_type = tag_type

    @property
    @abstractmethod
    def tag(self):
        """All base classes should identify the tag they represent"""
        raise TypeError("undefined tag for {}".format(type(self)))

class Head(Elem):
    tag = "head"
    tag_type = "text"

class Div(Elem):
    tag = "div"

h = Head()
d = Div()
h1 = Head(tag_type="int")

assert h.tag == "head"
assert d.tag == "div"
assert h1.tag == "head"
assert h.tag_type == "text"
assert d.tag_type == "double"
assert h1.tag_type == "int"
</code></pre>
<p>You can now write very short child classes, and still have your classes explicitly declared. You'll note that I changed a couple of the defaults to <code>None</code>. For <code>attr</code>, this is because having mutable default arguments won't work how you expect -- it'll behave more like it's a shared class variable. Instead, have the default as <code>None</code>, if <code>attr</code> has not been specified then create a new <code>attr</code> for each instance. The second (<code>tag_type</code>) is so that if <code>tag_type</code> is specified then the instance will have it's <code>tag_type</code> set, but all other instances will rely on the class for the default value.</p>
</div>
<span class="comment-copy">Can you produce a simplified <code>elem</code> class too please? I also can't reproduce your exact exception, I get <code>RuntimeError: super(): __class__ cell not found</code> instead. Are you perhaps using <code>make_elem_class</code> as a static or classmethod somewhere?</span>
<span class="comment-copy">Or, alternatively, did you perhaps set <code>__class__ = elem</code> somewhere?</span>
<span class="comment-copy">@MartijnPieters Sure! I edited my post, the <code>__init__()</code> method is complete.  And no <code>__class__ = elem</code> in my code.</span>
<span class="comment-copy">Try this yourself; you can't get your exception with just the <code>elem</code> class as you posted (the <code>make_html()</code> method is not needed here, it is never reached).</span>
<span class="comment-copy">Your solutions work both perfectly! It may be simplified (I'm not a Python expert and may not have the right vocabulary), but does <code>super()</code> search for the class name we pass to it in the local scope (<code>__class__</code> by default if no argument is passed, and <code>__class__</code> is created when using a <code>class myclass():</code> syntaxe?)?</span>
<span class="comment-copy">@vmonteco: see the already linked <a href="https://stackoverflow.com/q/19608134">Why is Python 3.x's super() magic?</a>; <code>super()</code> looks for a <i>closure cell</i>, and this closure cell is automatically provided by the Python compiler when you a) create a method in a <code>class</code> block, and <code>b</code> the name <code>super</code> is used in that method.</span>
<span class="comment-copy">@vmonteco: normally closure cells are only created when you use a name from a parent function scope (like <code>name</code> in your <code>make_elem_class</code>, to be able to use that in the <code>init()</code> function such a cell must be created).</span>
<span class="comment-copy">Not sure that that is less magic, honestly. And we are only lucky that there are no HTML tags that happen to be <a href="https://docs.python.org/3/reference/lexical_analysis.html#keywords" rel="nofollow noreferrer">reserved Python keywords</a>. Using a class attribute may be the better idea <code>self.tag</code> would then read from <code>elem.tag</code>, which you'd override in a subclass. Easily set with <code>'tag': name</code> in the dictionary passed to <code>type()</code>.</span>
<span class="comment-copy">Fair enough! Not really less magic, probably, rather a sort of embedded DSL for this kind of things.</span>
