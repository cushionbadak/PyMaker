<div class="post-text" itemprop="text">
<p>In python, <code>staticmethod</code>s are "just functions", and I can refer to them in two different ways:</p>
<pre><code>&gt;&gt;&gt; class A:
...     @staticmethod
...     def f():
...         pass
... 
&gt;&gt;&gt; a=A()
&gt;&gt;&gt; A.f
&lt;function A.f at 0x7f20f8cd3f28&gt;
&gt;&gt;&gt; a.f
&lt;function A.f at 0x7f20f8cd3f28&gt;
&gt;&gt;&gt; a.f is A.f
True
</code></pre>
<p>Both <code>a.f</code> and <code>A.f</code> are names that refer to the same object, which happens to be "just a function". Great.</p>
<p>Now, say I have a <code>classmethod</code>:</p>
<pre><code>&gt;&gt;&gt; class B:
...     @classmethod
...     def f(cls):
...         pass
... 
&gt;&gt;&gt; b=B()
&gt;&gt;&gt; b.f is B.f
False
</code></pre>
<p>I know that <code>b.f</code> and <code>B.f</code> are <em>not</em> functions: they're <em>bound mothods</em>. This means that the <code>cls</code> argument is implicit, and is always equal to <code>B</code>. Because of this, I would understand that if <code>B2</code> is a subclass of <code>B</code>, <code>B2().f is B().f</code> would be false, because they're bound methods with different <code>cls</code> arguments. But I don't understand why <code>B().f is B.f</code> yields <code>False</code>. Shouldn't they be the same object, just like <code>A().f</code> and <code>A.f</code>?</p>
<p>EDIT: This question is not the same as "<a href="https://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python">What is the difference between @staticmethod and @classmethod in Python?</a>". I know the difference between <code>staticmethod</code> and <code>classmethod</code>. I want to know one specific thing, which is not addressed in the "umbrella" question linked.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>B().f</code> and <code>B.f</code> are different objects because Python creates a new bound method object each time you refer to a non-static method via attribute access.</p>
<p>For example, <code>B.f is B.f</code> is also <code>False</code>.</p>
<pre><code>&gt;&gt;&gt; B.f is B.f
False
</code></pre>
<p>Similarly, you will get a new method object even if the instance stays the same:</p>
<pre><code>&gt;&gt;&gt; b = B()
&gt;&gt;&gt; b.f is b.f
False
</code></pre>
<p><code>@staticmethod</code> creates a new static method object, but</p>
<blockquote>
<p>When a static method object is retrieved from a class or a class
  instance, the object actually returned is the wrapped object, which is
  not subject to any further transformation.</p>
</blockquote>
<p>(from <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow">Data model</a>)</p>
<p>In this case <code>A.f</code> always returns the same <code>f</code> function object.</p>
</div>
<span class="comment-copy">A class is like a definition.  The <code>instance</code> is an actual use of that definition.  So the <code>class</code> is a recipe, and the <code>instance</code> is the cake.  Since the recipe is not the cake, and only the instructions on how to make a cake, they are not the same.</span>
<span class="comment-copy">@DuckPuncher did you read the body of my question? I want to know why <code>B().f is B.f</code> is false and <code>A().f is A.f</code> is true.</span>
<span class="comment-copy">See also, "User-defined methods" here: <a href="https://docs.python.org/2/reference/datamodel.html#types" rel="nofollow noreferrer">docs.python.org/2/reference/datamodel.html#types</a></span>
<span class="comment-copy">FWIW, <code>b=B(); b.f is b.f</code> is false, also.</span>
