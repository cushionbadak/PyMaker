<div class="post-text" itemprop="text">
<p>Often, I care about the exact calls the system under test makes to another part of the software (which I mock in the test), but not about the order, in which those calls happen. (E.g. because the end effect on the <em>real</em> other part replaced by the mock does not depend on the order of these calls.)</p>
<p>In other words, I want my test to</p>
<ul>
<li>fail if not all expected calls have been made</li>
<li>fail if unexpected calls have been made (so <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_has_calls" rel="nofollow noreferrer"><code>unittest.mock.Mock.assert_has_calls</code></a> does not suffice)</li>
<li><strong>not</strong> fail if only the <strong>order</strong> of the calls changed</li>
<li>fail if a call has been made less or more often than expected</li>
</ul>
<p>So, I have to inspect the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.mock_calls" rel="nofollow noreferrer"><code>mock_calls</code> property</a> of the mock object. I can do that in a generic and reasonably comprehensible way with PyHamcrest's <a href="https://pyhamcrest.readthedocs.org/en/v1.8.5/sequence_matchers/#module-hamcrest.library.collection.issequence_containinginanyorder" rel="nofollow noreferrer"><code>contains_inanyorder</code></a>:</p>
<pre><code>#!/usr/bin/env python3
from unittest import TestCase, main
from unittest.mock import Mock, call
from hamcrest import assert_that, contains_inanyorder as contains_in_any_order

class TestMockCalls(TestCase):
    def test_multiple_calls(self):
        m = Mock()
        m('foo')
        m.bar('baz')
        m('foo')
        assert_that(
            m.mock_calls, contains_in_any_order(
                call('foo'),
                call('foo'),
                call.bar('baz'),
            )
        )

if __name__ == '__main__':
    main()
</code></pre>
<p>This works fine for passing tests, like the one above:</p>
<pre class="lang-none prettyprint-override"><code>$&gt; ./test_mock_calls.py
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
</code></pre>
<p>It also fails when it should fail (as specified above, e.g. when you change one of the <code>m('foo')</code> to <code>m('F00')</code>), but the output in that case is not as useful as it could be:</p>
<pre class="lang-none prettyprint-override"><code>$&gt; ./test_mock_calls.py
F
======================================================================
FAIL: test_multiple_calls (__main__.TestMockCalls)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "./test_mock_calls.py", line 16, in test_multiple_calls
    call.bar('bay'),
AssertionError: 
Expected: a sequence over [, , ] in any order
     but: not matched: 


----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
</code></pre>
<p>The only information (apart from which test and which assertion failed) I can gather from this, is how many calls on the mock were expected in total (by counting the commas between the square brackets), but not what calls were expected and, more importantly, what and how many calls were actually observed.</p>
<p>Is this a bug in <code>unittest.mock</code> or PyHamcrest or am I using them wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <code>call</code> (<code>_Call</code>) itself if a kind of mock, and overrides <code>__getattr__</code>. When hamcrest starts checking whether it has a <code>decribe_to</code> attribute, things start going wrong.</p>
<p>I think that since both modules are doing introspective things, no single one is to blame, and special cases should be implemented on either side to play well with the other (probably in hamcrest, since <code>mock</code> is a standard module).</p>
<p>A user-side workaround is to do:</p>
<pre><code>from unittest.mock import _Call
_Call.describe_to = lambda c, d: d.append(str(c))
</code></pre>
</div>
<span class="comment-copy">Looks like there's a <a href="https://github.com/hamcrest/PyHamcrest/pull/70" rel="nofollow noreferrer">pull request</a> to solve this in PyHamcrest.</span>
