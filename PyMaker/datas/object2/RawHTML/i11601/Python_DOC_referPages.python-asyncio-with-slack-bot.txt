<div class="post-text" itemprop="text">
<p>I'm trying to make a simple Slack bot using asyncio, largely using the example <a href="https://stackoverflow.com/questions/30460929/how-to-create-an-event-loop-with-some-coroutines-running-forever">here</a> for the asyncio part and <a href="https://medium.com/@julianmartinez/how-to-write-a-slack-bot-end-to-end-d6a8542c854b#.2d7gty2o1" rel="nofollow noreferrer">here</a> for the Slack bot part. </p>
<p>Both the examples work on their own, but when I put them together it seems my loop doesn't loop: it goes through once and then dies. If <code>info</code> is a list of length equal to 1, which happens when a message is typed in a chat room with the bot in it, the coroutine is supposed to be triggered, but it never is. (All the coroutine is trying to do right now is print the message, and if the message contains "/time", it gets the bot to print the time in the chat room it was asked in). Keyboard interrupt also doesn't work, I have to close the command prompt every time.</p>
<p>Here is my code:</p>
<pre><code>import asyncio
from slackclient import SlackClient
import time, datetime as dt

token = "MY TOKEN"
sc = SlackClient(token)

@asyncio.coroutine
def read_text(info):
    if 'text' in info[0]:
        print(info[0]['text'])
        if r'/time' in info[0]['text']:
            print(info)
            resp = 'The time is ' + dt.datetime.strftime(dt.datetime.now(),'%H:%M:%S')
            print(resp)
            chan = info[0]['channel']
            sc.rtm_send_message(chan, resp)


loop = asyncio.get_event_loop()
try:
    sc.rtm_connect()
    info = sc.rtm_read()
    if len(info) == 1:
        asyncio.async(read_text(info))
    loop.run_forever()

except KeyboardInterrupt:
    pass
finally:
    print('step: loop.close()')
    loop.close()
</code></pre>
<p>I think it's the loop part that's broken, since it never seems to get to the coroutine. So maybe a shorter way of asking this question is what is it about my try: statement that prevents it from looping like in the asyncio example I followed? Is there something about <code>sc.rtm_connect()</code> that it doesn't like?</p>
<p>I'm new to asyncio, so I'm probably doing something stupid. Is this even the best way to try and go about this? Ultimately I want the bot to do some things that take quite a while to compute, and I'd like it to remain responsive in that time, so I think I need to use asyncio or threads in some variety, but I'm open to better suggestions.</p>
<p>Thanks a lot,
Alex</p>
</div>
<div class="post-text" itemprop="text">
<p>I changed it to the following and it worked:</p>
<pre><code>import asyncio
from slackclient import SlackClient
import time, datetime as dt

token = "MY TOKEN"    
sc = SlackClient(token)

@asyncio.coroutine
def listen():
    yield from asyncio.sleep(1)
    x = sc.rtm_connect()
    info = sc.rtm_read()
    if len(info) == 1:
        if 'text' in info[0]:
            print(info[0]['text'])
            if r'/time' in info[0]['text']:
                print(info)
                resp = 'The time is ' + dt.datetime.strftime(dt.datetime.now(),'%H:%M:%S')
                print(resp)
                chan = info[0]['channel']
                sc.rtm_send_message(chan, resp)

    asyncio.async(listen())


loop = asyncio.get_event_loop()
try:
    asyncio.async(listen())
    loop.run_forever()

except KeyboardInterrupt:
    pass
finally:
    print('step: loop.close()')
    loop.close()
</code></pre>
<p>Not entirely sure why that fixes it, but the key things I changed were putting the <code>sc.rtm_connect()</code> call in the coroutine and making it <code>x = sc.rtm_connect()</code>. I also call the <code>listen()</code> function from itself at the end, which appears to be what makes it loop forever, since the bot doesn't respond if I take it out. I don't know if this is the way this sort of thing is supposed to be set up, but it does appear to continue to accept commands while it's processing earlier commands, my slack chat looks like this:</p>
<pre><code>me [12:21 AM] 
/time

[12:21] 
/time

[12:21] 
/time

[12:21] 
/time

testbotBOT [12:21 AM] 
The time is 00:21:11

[12:21] 
The time is 00:21:14

[12:21] 
The time is 00:21:16

[12:21] 
The time is 00:21:19
</code></pre>
<p>Note that it doesn't miss any of my <code>/time</code> requests, which it would if it weren't doing this stuff asynchronously. Also, if anyone is trying to replicate this you'll notice that slack brings up the built in command menu if you type "/". I got around this by typing a space in front.</p>
<p>Thanks for the help, please let me know if you know of a better way of doing this. It doesn't seem to be a very elegant solution, and the bot can't be restarted after I use the a cntrl-c keyboard interrupt to end it - it says </p>
<pre><code>Task exception was never retrieved
future: &lt;Task finished coro=&lt;listen() done, defined at asynctest3.py:8&gt; exception=AttributeError("'NoneType' object has no attribute 'recv'",)&gt;
Traceback (most recent call last):
  File "C:\Users\Dell-F5\AppData\Local\Programs\Python\Python35-32\Lib\asyncio\tasks.py", line 239, in _step
    result = coro.send(None)
  File "asynctest3.py", line 13, in listen
    info = sc.rtm_read()
  File "C:\Users\Dell-F5\Envs\sbot\lib\site-packages\slackclient\_client.py", line 39, in rtm_read
    json_data = self.server.websocket_safe_read()
  File "C:\Users\Dell-F5\Envs\sbot\lib\site-packages\slackclient\_server.py", line 110, in websocket_safe_read
    data += "{0}\n".format(self.websocket.recv())
AttributeError: 'NoneType' object has no attribute 'recv'
</code></pre>
<p>Which I guess means it's not closing the websockets nicely. Anyway, that's just an annoyance, at least the main problem is fixed.</p>
<p>Alex</p>
</div>
<div class="post-text" itemprop="text">
<p>Making blocking IO calls inside a coroutine defeat the very purpose of using asyncio (e.g. <code>info = sc.rtm_read()</code>). If you don't have a choice, use <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.run_in_executor" rel="nofollow">loop.run_in_executor</a> to run the blocking call in a different thread. Careful though, some extra locking might be needed.</p>
<p>However, it seems there's a few asyncio-based slack client libraries you could use instead:</p>
<ul>
<li><a href="https://pypi.python.org/pypi/slacker-asyncio" rel="nofollow">slacker-asyncio</a> - fork of <a href="https://github.com/os/slacker" rel="nofollow">slacker</a>, based on <a href="https://pypi.python.org/pypi/aiohttp" rel="nofollow">aiohttp</a></li>
<li><a href="https://github.com/jcarbaugh/butterfield" rel="nofollow">butterfield</a> - based on <a href="https://github.com/os/slacker" rel="nofollow">slacker</a> and <a href="https://pypi.python.org/pypi/websockets" rel="nofollow">websockets</a></li>
</ul>
<hr/>
<p>EDIT: <a href="https://github.com/jcarbaugh/butterfield" rel="nofollow">Butterfield</a> uses the Slack real-time messaging API. It even provides an <a href="https://github.com/jcarbaugh/butterfield#echo-bot-example" rel="nofollow">echo bot example</a> that looks very much like what you're trying to achieve:</p>
<pre><code>import asyncio
from butterfield import Bot

@asyncio.coroutine
def echo(bot, message):
    yield from bot.post(
        message['channel'],
        message['text']
    )

bot = Bot('slack-bot-key')
bot.listen(echo)
butterfield.run(bot)
</code></pre>
</div>
<span class="comment-copy">I'm worried that this question may be too broad. Is there any way you could ask a more specific question, or ask a series of questions that make up this one?</span>
<span class="comment-copy">Fairly sure the part that is broken is the loop, since it never even calls the coroutine. I guess a shortened question would be is there something about the <code>sc.rtm_connect()</code> call that prevents the asyncio loop object from looping like normal?</span>
<span class="comment-copy">Ah I see, so although it won't miss commands, the individual loops will stop others being executed, is that right? Thanks for all the information, I will try to fix.</span>
<span class="comment-copy">I don't think Slacker uses the realtime methods though, right? Which I think means I wouldn't be able to make a bot that responds to different messages sent to it?</span>
<span class="comment-copy">@AlexS See if my edit helps</span>
<span class="comment-copy">Thanks, I'll have a go with Butterfield. I'm a little concerned that it doesn't seem to be very developed, and there hasn't been much work on it since early last year.</span>
