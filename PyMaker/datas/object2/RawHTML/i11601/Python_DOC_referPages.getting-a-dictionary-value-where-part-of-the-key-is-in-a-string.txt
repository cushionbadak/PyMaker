<div class="post-text" itemprop="text">
<p>Take a dictionary</p>
<pre><code>dict = {"word":{"a":{"b":2}}}
</code></pre>
<p>I want to get the value 2.
To access this I can do this <code>dict["word"]["a"]["b"]</code></p>
<p>However I want to know can I have part of the key (the <code>["a"]["b]</code> section) in a string</p>
<p>And refer to it something like this</p>
<pre><code>string = "[\"a\"][\"b\"]"

dict["word"]string
</code></pre>
<p>Or something like that</p>
<p>I know this syntax is incorrect but is it possible to do something like this?</p>
<p>in Python 3.x</p>
<p>EDIT:
A better dict example may be this</p>
<pre><code>    dict = {
"word":{"a":{"b":2}}
"hello":{"a":{"b":1}}
"mouse":{"a":{"b":5}}
}
</code></pre>
<p>How to get the value of b in each case? where you want to avoid hard coding in the <code>["a"]["b"]</code> bit of the key in the event that it could change.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use <code>dict</code> as variable name as it shadows the built-in function. </p>
<hr/>
<p>One of the ways to do it is using the <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer"><code>re</code> module</a>. The main idea here is that you are utilizing a regular expression to find out the keys. Once you have the list of keys, extracting data is a easy task.</p>
<pre><code>&gt;&gt;&gt; d = {"word":{"a":{"b":2}}}
&gt;&gt;&gt; s = '["a"]["b"]'
&gt;&gt;&gt; import re
&gt;&gt;&gt; keys = re.findall(r'\["(.+?)"\]',s)
&gt;&gt;&gt; d["word"][keys[0]][keys[1]]
2
</code></pre>
<p>If there are a lot of keys, then you can use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>reduce</code></a> from <code>functools</code> package. (as JonClements has mentioned in a <a href="https://stackoverflow.com/questions/36874773/getting-a-dictionary-value-where-part-of-the-key-is-in-a-string/36874916?noredirect=1#comment61316913_36874916">comment</a>)</p>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; functools.reduce(dict.__getitem__, keys, d['word'])
2
</code></pre>
<p>For longer dicts, you can use a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a></p>
<pre><code>&gt;&gt;&gt; d = {
... "word":{"a":{"b":2}},
... "hello":{"a":{"b":1}},
... "mouse":{"a":{"b":5}}
... }
&gt;&gt;&gt; [functools.reduce(dict.__getitem__, keys, d[i]) for i in d]
[2, 5, 1]
</code></pre>
<p>However note that due to the unordered nature of the dictionary keys, the output of the list may not be as expected. A better way is to reduce the complete dictionary to a new one (using a dict comprehension), as in</p>
<pre><code>&gt;&gt;&gt; {i:functools.reduce(dict.__getitem__, keys, d[i]) for i in d}
{'word': 2, 'mouse': 5, 'hello': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best way is to write your own syntax that you would parse. You have to use a charachter that will never appear in the key, a popular example is <code>.</code>, but similary, <code>$</code>, <code>|</code> work as well.</p>
<pre><code>def get(d, key):
    kp = key.split('.')
    for k in kp:
        d = d[k]
    return d

d = {'a': {'b': 2}}
get(d, 'a.b')
&gt;&gt;&gt; 2
</code></pre>
<p>EDIT for the update to the question:</p>
<p>So do you want to be able to get a list of values of a.b specifically in each of those cases? if so you can still use the method above like so</p>
<pre><code>d = {
 "word":{"a":{"b":2}},
 "hello":{"a":{"b":1}},
 "mouse":{"a":{"b":5}},
}

# nesting calls to get just to show it is flexible like that
[get(get(d, k), 'a.b') for k in d.keys()]
# if you wanted to generate a dict of {"word": val} it would look like this
{k:get(get(d, k), 'a.b') for k in d.keys()}
</code></pre>
<p>it even works if your variable part is in the middle</p>
<pre><code>d = {
 "x": {"word":{"a":{"b":2}}},
 "x": {"hello":{"a":{"b":1}}},
 "x": {"mouse":{"a":{"b":5}}},
}

# using more calls to get just to show it is flexible like that
[get(get(d, 'x.'+k), 'a.b') for k in get(d, 'x').keys()]
</code></pre>
</div>
<span class="comment-copy">What's the context of using this?</span>
<span class="comment-copy">This might be a case "xy problem" - referring to nested dictionary items via a string in that way is not possible, but what you want to do with that is likely possible... in another way. So, what do you want to do with that?</span>
<span class="comment-copy">Python has an <code>eval</code> function which likely could make it work - but I agree with the previous comments.</span>
<span class="comment-copy">you could use somethink like this otherwise: <a href="https://pypi.python.org/pypi/easydict/" rel="nofollow noreferrer">pypi.python.org/pypi/easydict</a></span>
<span class="comment-copy">I don't understand why that requires for you to use this method? Why can't you just get the keys using .keys() method?</span>
<span class="comment-copy">Of course - once you've extracted the keys (in whatever syntax) you can adapt: <code>functools.reduce(dict.__getitem__, 'ab', d['word'])</code> to make this more flexible... Just need to get the <code>'ab'</code> in a nice syntax (maybe even taking something from <code>input</code> and running <code>ast.literal_eval</code> on it...)</span>
<span class="comment-copy">Probably want to make the keys a list/tuple instead (ie: keep your original <code>re.findall</code> <code>keys</code>) of a string in case there's multi-char/non-string keys :)</span>
<span class="comment-copy">And of course - when using the list-comp the order of the values (assuming) they're important may be surprising - unless the source is an <code>OrderedDict</code> :)</span>
<span class="comment-copy">@Jon, Yeah. True. Perhaps we can have a list of tuples as in (key,value), Something like <code>[('word', 2), ('mouse', 5), ('hello', 1)]</code>.</span>
<span class="comment-copy">Or just a new <code>dict</code>? <code>{'word': 2, 'mouse': 5, 'hello': 1}</code> - but then we're still guessing at the use the OP has in mind...</span>
