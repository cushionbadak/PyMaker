<div class="post-text" itemprop="text">
<p>From a list of tuple <code>l</code>, I need to filter the element which is at least euclidean distance from tuple <code>x</code>. </p>
<ol>
<li><p>Can I do this using <em>list comprehension</em> or <em>lambda function</em>? You can take <code>l = [(0,0), (1,1), (2,3), (3,4), (4,5)]</code> and <code>x=(3,0)</code>.</p></li>
<li><p>Suppose there are more than one elements in <code>l</code> whose euclidean distance is minimum at same time. Then I need to return random elements from <strong>those</strong> elements. Can this be done using list comprehension or lambda function too?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>First you should define a function to get the <a href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="nofollow noreferrer">Euclidian distance</a>. One way would be to just convert the tuples to complex numbers and get their absolute difference. </p>
<pre><code>&gt;&gt;&gt; dist = lambda t1, t2: abs(complex(*t1) - complex(*t2))
</code></pre>
<p>Alternatively, you could define your own function. That might even be faster, since you do not really need to take the square root if you just want to find the value that has the minimum distance.
You can then use that function as a key function to the <a href="https://docs.python.org/3/library/functions.html#min" rel="nofollow noreferrer"><code>min</code></a> builtin.</p>
<pre><code>&gt;&gt;&gt; l = [(0,0), (1,1), (2,3), (3,4), (4,5)]
&gt;&gt;&gt; x = (3,0)
&gt;&gt;&gt; min(l, key = lambda y: dist(y, x))
(1, 1)
</code></pre>
<p>If you want to get all the minimum values, you could store that value in a variable and use a list comprehension to get all values whose distance is equal to that value.</p>
<pre><code>&gt;&gt;&gt; m = min(dist(y, x) for y in l)
&gt;&gt;&gt; [y for y in l if dist(x, y) == m]
[(1, 1)]
</code></pre>
<p>If you want a random value of those, use <a href="https://docs.python.org/3/library/random.html#random.choice" rel="nofollow noreferrer"><code>random.choice</code></a>:</p>
<pre><code>&gt;&gt;&gt; random.choice(_)
(1, 1)
</code></pre>
<p>Note, however, that this approach will iterate the list twice, and also calculate the distance of each value twice -- once to find the (any) minimum value, and then again to compare each value to that minimum. If performance is very important, you should use <a href="https://stackoverflow.com/a/36813596/1639625">@Kasramvd</a>'s appraoch.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an efficient approach using dictionary:</p>
<pre><code>from operator import itemgetter
from random import choice

def find_mins(x, lst):
    x1, y1 = x
    result = {}
    for x2, y2 in lst:
        quad_dist = (x1 - x2)**2 + (y1 - y2)**2
        result.setdefault(quad_dist, []).append((x2, y2))
    return choice(min(result.items(), key=itemgetter(0))[1])
</code></pre>
<p>Demo :</p>
<pre><code>l = [(0,0), (1,1), (2, 2), (2,3), (3,4), (4,5)]
x = (3,0)

find_mins(x, l)
(1, 1)
find_mins(x, l)
(2, 2)
find_mins(x, l)
(2, 2)
</code></pre>
<p>This function will categorize your coordinates based on their distance from intended point then find the minimum based on the distance and return the list of relative coordinates, then you can use <code>random.choice()</code> to pick up a random point.</p>
</div>
<span class="comment-copy">1) Yes. 2) Yes. Did you try it?</span>
<span class="comment-copy">@DisplayName I have no idea how to do this in one line. For 3 lines of code, yes I have.</span>
<span class="comment-copy">I was just trying to golf around. Performance is not my concern at the moment since my dataset is small.</span>
