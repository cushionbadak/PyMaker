<div class="post-text" itemprop="text">
<p>I am currently building a little library, and I ran across a problem with descriptors: I created a python descriptor and it has to store values for seperate classes, but I don't want to use the class as storage. And I don't want the user having to inherit anything for those descriptors to work.</p>
<p>But when an instance of the object is deleted, I want to delete its data in the descriptor for that instance. (The instance can be deleted, because the descriptor doesn't hold a reference to it, I index those with their id's in a dictionary)</p>
<p>And this has to be done, because another instance can be created, with the same id, resulting in a 'data transfer' from the old object to the new, and that is not helpful in <em>any</em> way.</p>
<p>Is there a way to let the descriptor know that an instance of the class the descriptor is part of was deleted?</p>
<p>(<code>__delete__</code> just fires if the attribute is deleted, not if the instance is getting removed)</p>
<p>Here's a little bit of code to show you what this is all about:</p>
<pre class="lang-py prettyprint-override"><code>class CounterDescriptor(object):  # I need the answer for something different, but the problem is the same. My code is just much larger and a whole lot more complicated.
    def __init__(self) -&gt; None:
        self.counts = {}

    def __get__(self, instance: object, owner: type) -&gt; object:
        instance_id = id(instance)
        if instance_id not in self.counts:
            self.counts[instance_id] = 0
        self.counts[instance_id] += 1
        return self.counts[instance_id]

    def __set__(self, instance: object, value: int) -&gt; None:
        self.counts[id(instance)] = int(value)


class SomethingUsingTheCounterDescriptor(object):
    x = CounterDescriptor()

x = SomethingUsingTheCounterDescriptor()
x.x  # \-&gt; count goes one higher (-&gt; now it is 1)
del x  # Now I want to get rid of the data stored for x in the CounterDescriptor.
</code></pre>
<p>I'll just thank you in advance,</p>
<p>CodenameLambda</p>
</div>
<div class="post-text" itemprop="text">
<p>Another version with weak references that does not need hashable instances:</p>
<pre><code>from weakref import ref


class CounterDescriptor(object): 

    def __init__(self) -&gt; None:
        self.counts = {}
        self.refs = {}

    def _clean_up(self):
        for id_, ref in self.refs.items():
            if ref() is None:
                del self.counts[id_]

    def __get__(self, instance: object, owner: type) -&gt; object:
        self._clean_up()
        inst_id = id(instance)
        if instance is None:
            return self.counts
        if inst_id not in self.counts:
            self.counts[inst_id] = 0
            self.refs[inst_id] = ref(instance)
        self.counts[inst_id] += 1
        return self.counts[inst_id]

    def __set__(self, instance: object, value: int) -&gt; None:
        self._clean_up()
        inst_id = id(instance)
        self.counts[inst_id] = int(value)
        self.refs[inst_id] = ref(instance)

class SomethingUsingTheCounterDescriptor(object):
    x = CounterDescriptor()
s = SomethingUsingTheCounterDescriptor()
s.x
s.x
print(SomethingUsingTheCounterDescriptor.x)
del s
print(SomethingUsingTheCounterDescriptor.x)
</code></pre>
<p>Output:</p>
<pre><code>{4460071120: 2}
{}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your instances are hasbable, you could use a <a href="https://docs.python.org/3/library/weakref.html?highlight=weakkeydictionary#weakref.WeakKeyDictionary" rel="nofollow"><code>WeakKeyDictionary</code></a> instead
of the standard dictionary:</p>
<pre><code>from weakref import WeakKeyDictionary

class CounterDescriptor(object): 

    def __init__(self) -&gt; None:
        self.counts = WeakKeyDictionary()

    def __get__(self, instance: object, owner: type) -&gt; object:
        if instance is None:
            return self.counts
        if instance not in self.counts:
            self.counts[instance] = 0
        self.counts[instance] += 1
        return self.counts[instance]

    def __set__(self, instance: object, value: int) -&gt; None:
        self.counts[instance] = int(value)


class SomethingUsingTheCounterDescriptor(object):
    x = CounterDescriptor()

s = SomethingUsingTheCounterDescriptor()
s.x  # \-&gt; count goes one higher (-&gt; now it is 1)
s.x
print(dict(SomethingUsingTheCounterDescriptor.x))
del s  # Now I want to get rid of the data stored for x in the CounterDescriptor.
print(dict(SomethingUsingTheCounterDescriptor.x))
</code></pre>
<p>Output:</p>
<pre><code>{&lt;__main__.SomethingUsingTheCounterDescriptor object at 0x1032a72b0&gt;: 2}
{}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'll just use following approach:</p>
<pre class="lang-python prettyprint-override"><code>import sys
from typing import Dict, List


class CounterDescriptor(object): 

    def __init__(self) -&gt; None:
        self.counts = {}  # type: Dict[int, int]
        self.references = []  # type: List[object]

    def _do_cleanup(self) -&gt; None:
        deleted = 0
        for i, v in enumerate(self.references[:]):
            if sys.getrefcount(v) == 7:
            # found by trying. I know of 4 references: self.references, the copy, v and the argument submitted to getrefcount
                del self.references[i - deleted]
                deleted += 1

    def __get__(self, instance: object, owner: type) -&gt; object:
        self._do_cleanup()

        instance_id = id(instance)
        if instance not in self.counts:
            self.counts[instance_id] = 0
            self.references.append(instance)
        self.counts[instance_id] += 1
        return self.counts[instance_id]

    def __set__(self, instance: object, value: int) -&gt; None:
        self._do_cleanup()

        instance_id = id(instance)
        if instance_id not in self.counts:
            self.references.append(instance)
        self.counts[instance_id] = int(value)


class SomethingUsingTheCounterDescriptor(object):
    x = CounterDescriptor()

s = SomethingUsingTheCounterDescriptor()
s.x  # \-&gt; count goes one higher (-&gt; now it is 1)
s.x
print(SomethingUsingTheCounterDescriptor.x.counts)
del s
print(SomethingUsingTheCounterDescriptor.x.counts)
</code></pre>
<p>It yields the expected results.
In my run:</p>
<pre><code>{4323824640: 1}
{}
</code></pre>
<p>Although I got that idea pretty early in trying to solve this problem, I discarded it because it is <em>not very</em> pythonic.
But I have to thank @Mike Müller because he got me to think about reference counting again, wich lead me to picking it up again.</p>
<p>I'll mark this question as solved after the two days I have to wait, although it really isn't, because this solution is anything but beautiful.</p>
</div>
<span class="comment-copy">Please provide some example code. I didn't understand:: I created a python descriptor and it has to store values for seperate classes, but I don't want to use the class as storage. PS: <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">docs.python.org/3/reference/…</a> The following methods only apply when an instance of the class containing the method (a so-called descriptor class) appears in an owner class (the descriptor must be in either the owner’s class dictionary or in the class dictionary for one of its parents).</span>
<span class="comment-copy">Are weak references guaranteed to yield None if the object is gone? Or can it yield another object if somebody is <i>very, very</i> unlucky?</span>
<span class="comment-copy">docs: <i>Return a weak reference to object. The original object can be retrieved by calling the reference object if the referent is still alive; if the referent is no longer alive, calling the reference object will cause <code>None</code> to be returned.</i></span>
<span class="comment-copy">Thanks. (the <i>original object</i> implies that it will be safe, I'd guess)</span>
<span class="comment-copy"><code>An object is hashable if it has a hash value which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash value.</code> <a href="https://docs.python.org/3/glossary.html" rel="nofollow noreferrer">see here</a>. This doesn't help, considering that hashable objects that are equal have to have the same hash, hence I cannot deal with them without breaking them. (Because I don't want to change anything in the resulting object. My descriptor should be able to be a replacement for existing properties.)</span>
<span class="comment-copy">But this can be used at other cases that are similar. I'll now write an answer with the solution I'll now use, although it isn't really beautiful. Feel free to improve it.</span>
