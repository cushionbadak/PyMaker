<div class="post-text" itemprop="text">
<p>I have a dictionary like this:</p>
<pre><code>d = {1: ['a', 'b', 'c'], 2: ['d'], 3: ['e','f'], 4: ['g'], 5: ['h', 'i']}
</code></pre>
<p>I want to return a dictionary this:</p>
<pre><code>d = {1: ['a', 'b', 'c'], 2:'d', 3: ['e', 'f'], 4: 'g', 5: ['h', 'i']}
</code></pre>
<p>so far I have:</p>
<pre><code>for values in d.values():
    if len(values) == 1:
       ?strip []?
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You seem to be dealing with lists, not strings, as values in your <code>dict</code>. Thus, Stripping won't work (even if it were syntactically correct). However, you can simply set the value to the first element of the <code>list</code>:</p>
<pre><code>for k in d:
    if len(d[k]) == 1:
        d[k] = d[k][0]
</code></pre>
<p>The brackets <code>[]</code> are merely a presentational feature of the underlying type <code>list</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>try this</p>
<pre><code>d = {1: ['a', 'b', 'c'], 2: ['d'], 3: ['e','f'], 4: ['g'], 5: ['h', 'i']}
f= lambda x: x[0] if len(x)==1 else x
{i:f(d[i]) for i in d}
</code></pre>
</div>
<span class="comment-copy">You've got an answer already, so I'll just add this: making this change will actually make your data structure harder to use, since you'll have to decide which way to process it. Unless you are doing this only for printout purposes, it's a bad idea.</span>
<span class="comment-copy">Adding to what @Austin said...  Consider that both lists and strings are iterable, so the obvious way to consume the first dictionary's lists --- iterating over their elements --- is also a <i>perfectly valid operation</i> on the strings that will occasionally appear in their place.  Although operating on individual characters of a string is probably not your goal, it won't even produce a warning from Python.  The output will likely be incorrect but plausible, which is actually <i>worse</i> than blatantly incorrect.</span>
<span class="comment-copy">To further boost what Austin and Kevin are saying: Since it's often very difficult in Python to differentiate between lists and strings, so the way you want the values in the dictionary to be will make it harder to write follow-on code properly since it will then have to deal (differently) with each the two possible types of data, assuming it can tell them apart â€” therefore doing what you want to do is probably unwise.</span>
<span class="comment-copy">thanks. the issue arrises when I merge dictionaries together. The merged dictionary creates a list for each key. Is there a way to merge dictionaries without creating object type list for keys that have only one value?</span>
<span class="comment-copy">@Cainster That strikes me as a significantly different topic, and should probably be posted as a separate question... assuming it isn't already on Stack Overflow somewhere.</span>
<span class="comment-copy">Rather than using <code>d[k]</code>, you can use <a href="https://docs.python.org/3/library/stdtypes.html#dict.items" rel="nofollow noreferrer"><code>for k,v in d.items(): ...</code></a></span>
<span class="comment-copy">Welcome to Stack Overflow, and thanks for your submission!  Would you please take a few moments to add an explanation of how your solution works?  This will be helpful as a future reference for users who may encounter the same problem.</span>
<span class="comment-copy">sorry. thats true - im newby here.. trying to get some reputation for bounting my question ) so, second line is <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow noreferrer">lambda function</a> look here about.. fits well for small logic. 3-rd line making a dict with calling lambda function with every dictionary element. take a look <a href="https://www.python.org/dev/peps/pep-0274/" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">There's no need to use a lambda or <code>d[i]</code> here: <code>{k: v[0] if len(v) == 1 else v for k,v in d.items()}</code>. See <a href="https://docs.python.org/3/library/stdtypes.html#dict.items" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#dict.items</a></span>
<span class="comment-copy">I'd also add that this is more robust than the other answer, as it doesn't modify the collection being iterated.</span>
