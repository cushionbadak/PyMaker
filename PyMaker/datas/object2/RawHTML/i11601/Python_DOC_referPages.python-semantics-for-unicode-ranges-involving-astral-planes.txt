<div class="post-text" itemprop="text">
<p>What exactly are the intended semantics for character ranges in regular expressions if one or both endpoints of the range are outside the BMP? I've observed that the following input behaves different in Python 2.7 and 3.5:</p>
<pre><code>import re
bool(re.match(u"[\u1000-\U00021111]", "\u1234"))
</code></pre>
<p>In my 2.7 I get <code>False</code>, in 3.5 I get <code>True</code>. The latter makes sense to me. The former is perhaps due to <code>\U00021111</code> being represented by a surrogate pair <code>\ud844\udd11</code>, but even then I don't understand it since <code>\u1000-\ud844</code> should include <code>\u1234</code> just fine.</p>
<ul>
<li>Is this specified somewhere?</li>
<li>Is this intended behavior?</li>
<li>Does this just depend on the Python version, or also on compile-time flags regarding UTF-16 vs. UTF-32?</li>
<li>Is there a way to get consistent behavior without case distinctions?</li>
<li>If case distinctions are unavoidable, what excatly are the conditions?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Just use the <code>u</code> prefix with the input string to tell Python it is a Unicode string:</p>
<pre><code>&gt;&gt;&gt; bool(re.match(u"[\u1000-\U00021111]", u"\u1234")) # &lt;= See u"\u1234"
True
</code></pre>
<p>In Python 2.7, you need to decode the strings to Unicode each time you process them. In Python 3, all strings are Unicode by default, and it is stated in the <a href="https://docs.python.org/3/howto/unicode.html" rel="nofollow">docs</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is what I found out so far.</p>
<p><a href="https://www.python.org/dev/peps/pep-0261/" rel="nofollow">PEP 261</a> which got accepted for Python 2.2 introduced a compile-time flag to build unicode support either using a narrow UTF-16 representation or a wide UTF-32 representation of characters. Check <code>hex(sys.maxunicode)</code> or <code>len(u'\U00012345')</code> to distinguish these at runtime: narrow builds will report a maximum of <code>0xffff</code> and a length of <code>2</code>, wide builds a maximum of <code>0x10ffff</code> and a length of <code>1</code>. <a href="https://www.python.org/dev/peps/pep-0393/" rel="nofollow">PEP 393</a> for Python 3.3 hides the implementation details of a unicode string, making all strings appear like UTF-32 (without actually wasting that much space unless neccessary). So narrow builds prior to 3.3 will decompose codepoints on astral planes into surrogate pairs, and treat the individual surrogates independently both for the construction of the regular expression and the string to be matched against. Or at least I could find no indication to the contrary.</p>
<p>As Wiktor pointed out, my example was plain stupid since I forgot the <code>u</code> prefix to the second string literal. Therefore Python 2 will parse this not as an escape sequence but as a byte string instead. That explains why it looked as though the codepoint wasn't included in that range even after surrogate pairs were taken into account.</p>
<p>As for intended behavior: Since Python 3.3 the distinction based on build type should become obsolete. Treating each codepoint as a unit, no matter the plane, should be the way forward for Python 3. But backwards compatibility on narrow builds poses a conflicting goal for older versions.</p>
</div>
<span class="comment-copy">Thanks! I feel stupid for not having noticed this. However, the underlying problem remains: <code>bool(re.match(u"[\u1000-\U00021111]", u"\ueeee"))</code> still gives different results. I know it's bad style to edit a question once it has been answered, in a way such that the answer no longer applies. Would you be OK with me doing it anyway, or should I post a new question?</span>
<span class="comment-copy">Please check <a href="https://ideone.com/p9Jsgv" rel="nofollow noreferrer">this Python 2.7 IDEONE demo</a>. <code>print(bool(re.match(u"[\u1000-\U00021111]", u"\ueeee")))</code> prints <code>True</code>. Your Python 2.7 should be set up to allow Unicode input (see <code># -*- coding: utf-8 -*-</code> pragma).</span>
<span class="comment-copy">@WiktorStribiżew <code>#coding:utf8</code> does nothing in this case.  It declares the encoding of the source file itself, and there are no non-ASCII characters in this source.</span>
<span class="comment-copy">@MvG: you could omit <code>u''</code> prefix in Unicode literals if you add <code>from __future__ import unicode_literals</code> (you have to use <code>b''</code> prefix to create bytestrings in this case). Here it doesn't matter but in general, pass <code>flags=re.UNICODE</code> too (it changes how <code>\d</code>, <code>\w</code>, etc are interpreted inside a regex).</span>
<span class="comment-copy">@WiktorStribiżew: your last comment should talk about narrow/wide python builds (it is not about Python 2 vs. 3—though the recent Python 3 versions use flexible Unicode representation and therefore there is no longer narrow/wide build distinction). For example, Linux typically uses a wide <code>python</code> build, see <a href="http://stackoverflow.com/a/36885376/4279">MvG's answer which provides more details</a>.</span>
<span class="comment-copy">Python 3.3 uses flexible Unicode representation (I don't think it hides the implementation more than e.g., a wide python build does—it is the opposite: the abstraction leaks for non-BMP characters on narrow python builds). It is not obvious why the regex module can't handle surrogate pairs.</span>
<span class="comment-copy">@J.F.Sebastian: I agree that there is no reason surrogate pairs <i>cannot</i> be handled by the re module, but my observation indicates that the <i>are not</i> being handled. I'm guessing that this was out of simplicity at first, and out of backwards compatibility later. Many other UTF-16-based languages do the same: Java, JavaScript, … I'm not sure I understand your argument about the abstraction leaking. But I think that there should be no difference between 3.3+ and a wide &lt;3.3 at the Python level, although there will be differences at the extension module level. Is that what you meant?</span>
<span class="comment-copy">We are in agreement but there is a tiny-tiny difference: you say: <i>"Python 3.3 <b>hides</b> the implementation details"</i>, I say that a narrow python build <b>exposes</b> its (deficient) implementation. The outcome is the same, the difference is there you put the accent/stress.  "Abstraction leaks" means that a narrow Python build doesn't respect the notion that a Unicode string is a sequence of Unicode codepoints in Python (a single Unicode codepoint may be represented as two codepoints (surrogate pair)).</span>
