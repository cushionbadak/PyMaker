<div class="post-text" itemprop="text">
<p>I am using Python (Canopy) extensively for Earth science application. Because my application is memory consuming, I am trying find way to erase variable that I don't need any more in my programs, I tried to use del command to erase the variable memory, but I found that space used by Canopy is still the same. Any ideas about how to erase variable completely from the memory. 
thanks</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>You can't manually nuke an object from your memory in Python!</strong></p>
<p>The Python Garbage Collector (GC) will automatically free up memory of objects that have no existing references any more (implementation details differ per interpreter). It's periodically checking for abandoned objects in background without your interaction. </p>
<p>So to get an object recycled, you have to eliminate all references to it by assigning a different value (e.g. None) to all variables that pointed to the object. You can also delete a variable name using the <code>del</code> statement, but as you already noticed, this only deletes the name with the reference, but not the object and its data itself. Only the GC can do that.</p>
</div>
<span class="comment-copy">Is there a test case you could show us? Also, try <code>__import__("gc").collect()</code>.</span>
<span class="comment-copy">When using a language like Python, you really don't have any direct control over when memory is deallocated.  If you need that level of control, consider writing your code in C and handling memory management yourself.</span>
<span class="comment-copy">Canopy uses an ipython kernel that may keep variables for future interactive use; depending on what you are doing, restarting the kernel is sometimes a good idea to restore memory and refresh the namespace.</span>
<span class="comment-copy"><code>del</code> does not delete objects, it removes references to them. Use <a href="https://docs.python.org/2/library/sys.html#sys.getrefcount" rel="nofollow noreferrer"><code>sys.getrefcount()</code></a> or <a href="https://docs.python.org/2/library/weakref.html" rel="nofollow noreferrer"><code>weakrefs</code></a> to see whether there's something that is keeping an object alive</span>
<span class="comment-copy">It's complicated. Take a look at <a href="http://stackoverflow.com/questions/15455048/releasing-memory-in-python" title="releasing memory in python">stackoverflow.com/questions/15455048/releasing-memory-in-python</a></span>
<span class="comment-copy">And even then, the reclaimed memory isn't returned back to the OS immediately. Like many sophisticated programs the CPython interpreter has its own internal memory management for efficiency reasons. You can read about Python's memory arenas in the link in my comment on the question, and in <a href="https://docs.python.org/3/c-api/memory.html" rel="nofollow noreferrer">the docs</a>.</span>
<span class="comment-copy">All the responses and comments above are correct. To sum up: deleting <i>all</i> Python references to an object (including implicit references in the IPython kernel), and then forcing Python garbage collector to run will make the memory eligible for re-use in the same Python process, and will  often but not always make it for re-use by the OS. But even then it won't necessarily show up in OS stats.</span>
<span class="comment-copy">All, thanks  a lot for your help. It is clear now that erasing variable from memory is not straight forward, I think that I can apply some technique like shown here by deleting all python reference and then calling the GC, or by creating subprocess as mention above. Yet, I am using my script on different platform, thus I am not sure whether such techniques will work effectively across different platform. I have to test it. Thanks again.</span>
<span class="comment-copy">Byte Commander, did you meant in your title that  ** I cannot automatically …….**</span>
