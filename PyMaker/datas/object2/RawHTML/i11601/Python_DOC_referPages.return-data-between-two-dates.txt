<div class="post-text" itemprop="text">
<p>I have some code which parses through a number of .CVS files, retrieves all the data for several columns and places the data in a data frame (called dfs).  I am now trying to return all of the data fields in dfs that are between two dates only.</p>
<p>I am trying to use the command:</p>
<pre><code>return dfs[(dfs['date'] &gt;= startDate) &amp; (dfs['date'] &lt;= endDate)] 
</code></pre>
<p>but get the following error:</p>
<pre><code>KeyError: 'date'
</code></pre>
<p>Could someone let me know what I've done wrong please? 
Please see below for my code:</p>
<pre><code>def getTimeseriesData(path,column_num,startDate,endDate):
    colNames = ['date']
    dfs = []

    allfiles = glob.glob(os.path.join(path, "*.csv"))
    for fname in allfiles:

        name = os.path.splitext(fname)[0]
        name = os.path.split(name)[1]
        colNames.append(name)

        df = pd.read_csv(fname, header=None, usecols=[0, column_num,4,5], 
                        parse_dates=[0], dayfirst=True,
                        index_col=[0], names=['date', name+'_LAST',name+'_VOLUME',name+'_MKTCAP'])

        df = df.groupby(level=0).agg('mean')

        dfs.append(df)        

    dfs = pd.concat(dfs, axis=1)

    return dfs[(dfs['date'] &gt;= startDate) &amp; (dfs['date'] &lt;= endDate)] #&lt;&lt;--I think this is the problem
</code></pre>
<p>the head of dfs (from which I want to return data between two dates (say between 2001-01-03 and 2001-01-05) looks like this:</p>
<pre><code>            BBG.XLON.BTA.S_LAST  BBG.XLON.BTA.S_VOLUME  BBG.XLON.BTA.S_MKTCAP  \
date                                                                            
2001-01-02                  572               26605510               37494.60   
2001-01-03                  560               24715470               36708.00   
2001-01-04                  613               52781855               40182.15   
2001-01-05                  630               56600152               41296.50   
2001-01-08                  633               41014402               41493.15   

            BBG.XLON.VOD.S_LAST  BBG.XLON.VOD.S_VOLUME  BBG.XLON.VOD.S_MKTCAP  
date                                                                           
2001-01-02                  NaN                    NaN                    NaN  
2001-01-03               225.00              444328736            145216.0020  
2001-01-04               239.00              488568000            154251.6643  
2001-01-05               242.25              237936704            156349.2288  
2001-01-08               227.75              658059776            146990.8642 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here <code>date</code> is the name of your index and not a column name:</p>
<p>Change:</p>
<pre><code>return dfs[(dfs['date'] &gt;= startDate) &amp; (dfs['date'] &lt;= endDate)] 
</code></pre>
<p>into:</p>
<pre><code>return dfs[(dfs.index &gt;= startDate) &amp; (dfs.index &lt;= endDate)] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can do it much simpler if your index is monotonically increasing sequence of dates:</p>
<p>showing all rows, but only first two columns:</p>
<pre><code>In [98]: df.iloc[:, [0,1]]
Out[98]:
            BBG.XLON.BTA.S_LAST  BBG.XLON.BTA.S_VOLUME
date
2001-01-02                  572               26605510
2001-01-03                  560               24715470
2001-01-04                  613               52781855
2001-01-05                  630               56600152
2001-01-08                  633               41014402
</code></pre>
<p>filtering rows, showing first two columns:</p>
<pre><code>In [99]: df.loc['2001-01-03':'2001-01-05', df.columns[0,1]]
Out[99]:
            BBG.XLON.BTA.S_LAST  BBG.XLON.BTA.S_VOLUME
date
2001-01-03                  560               24715470
2001-01-04                  613               52781855
2001-01-05                  630               56600152
</code></pre>
<p>or in your case:</p>
<pre><code>return dfs.loc[startDate:endDate]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python, '&amp;' is is bitwise "and", <code>and</code> is logical "and".</p>
<p>Best to use a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a> here.</p>
<pre><code>return [df for df in dfs if df['date'] &gt;= startDate and df['date'] &lt;= endDate]
</code></pre>
<p>The will go through the <code>dfs</code> list, check for each element the <code>if</code> conditions and return a new list with all the elements that met those conditions.</p>
</div>
<span class="comment-copy">Can you give some example csv dada?</span>
<span class="comment-copy">Hi linusg, sure, sample data now included in the question</span>
<span class="comment-copy">Thanks Mike, that hit the spot</span>
<span class="comment-copy">Your code does not look like coming  from my answer. I use: <code>dfs[(dfs.index &gt;= startDate) &amp; (dfs.index &lt;= endDate)] </code>.</span>
<span class="comment-copy">Slicing only works  same as the method of the OP if the dates are monotonic increasing.</span>
<span class="comment-copy">@MikeMüller, that's not correct. Using <code>.ix[]</code> will also work on randomly distributed dates in the index</span>
<span class="comment-copy">Try: <code>r = df.reindex(df.index[::-1])</code> Now <code>r[(r.index &gt;= start) &amp; (r.index&lt;=end)]</code> vs. <code>r.ix[start:end]</code></span>
<span class="comment-copy">@MikeMüller, i've added an example for you to my answer - please check</span>
<span class="comment-copy"><code>len(r.ix[startDate : endDate])</code> --&gt; <code>0</code> vs. <code>len(r[(r.index &gt;= startDate) &amp; (r.index &lt;= endDate)])</code> --&gt; <code>11</code>.</span>
<span class="comment-copy">Thanks C14L, I tried the line you posted but I got the following error: TypeError: string indices must be integers.  Any idea what I should do?</span>
<span class="comment-copy">I don't know Pandas, but there seems to be a string instead of a <code>dict()</code> or <code>list()</code> somewhere. Does this <code>dfs = pd.concat(dfs, axis=1)</code> convert the <code>dfs</code> list into a string? Or maybe <code>df = df.groupby(level=0).agg('mean')</code> converts the individual <code>df</code> lines into a string? To be able to sort it, you need a <code>list()</code> of <code>dict()</code> objects. If you have a table that is one long string, you would need to parse it before being able to sort it.</span>
