<div class="post-text" itemprop="text">
<p>Update------------------</p>
<p><code>object</code> is a instance of <code>type</code>, but at the same time, <code>object</code> is also the base class of <code>type</code>. And <code>type</code> is a instance of <code>object</code>. I'm really confused about this. it's totally unlogical. Why python do this?</p>
<pre><code>&gt;&gt;&gt; isinstance(object,type)
True
&gt;&gt;&gt; isinstance(type,object)
True
&gt;&gt;&gt; type.__bases__
(&lt;class 'object'&gt;,)
</code></pre>
<p>Original--------------------------------</p>
<p>I know <code>type</code> has <code>mro</code>. but I can't figure out why <code>mro</code> can be called from <code>object</code>. How python implement this?</p>
<pre><code>&gt;&gt;&gt; object.mro()
[&lt;class 'object'&gt;]
&gt;&gt;&gt; 'mro' in dir(object)
False
&gt;&gt;&gt; 'mro' in object.__dict__
False
&gt;&gt;&gt; 'mro' in dir(type)
True
&gt;&gt;&gt; 'mro' in type.__dict__
True
&gt;&gt;&gt; issubclass(type,object)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/datamodel.html#invoking-descriptors" rel="nofollow">Descriptors</a> are involved.</p>
<p>When resolving <code>object.mro</code>, the interpreter first looks for <code>'mro'</code> in <code>object.__dict__</code>.</p>
<pre><code>&gt;&gt;&gt; object.__dict__['mro']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'mro'
</code></pre>
<p>Since <code>'mro'</code> is not in <code>object.__dict__</code>, the interpreter looks in <code>type(object).__dict__</code>.</p>
<pre><code>&gt;&gt;&gt; type(object).__dict__['mro']
&lt;method 'mro' of 'type' objects&gt;
</code></pre>
<p>This object is a descriptor since it has a <code>__get__</code> method.  So the interpreter invokes the <code>__get__</code> method to obtain the actual value of <code>object.mro</code>.</p>
<p>Based on the documentation you might think that since <code>object</code> is a class it would call <code>__get__(None, object)</code> but in this case <code>object</code> is being considered as an instance of class <code>type</code> so the interpreter calls <code>__get__(object, type(object))</code> to get the result.</p>
<pre><code>&gt;&gt;&gt; type(object).__dict__['mro'].__get__(object, type(object))
&lt;built-in method mro of type object at 0x1047d2ae0&gt;
</code></pre>
<p>To confirm that the result is what we're looking for:</p>
<pre><code>&gt;&gt;&gt; type(object).__dict__['mro'].__get__(object, type(object)) == object.mro
True
&gt;&gt;&gt; type(object).__dict__['mro'].__get__(object, type(object))()
[&lt;class 'object'&gt;]
</code></pre>
</div>
<span class="comment-copy">Because class attributes can always be accessed from an instance.</span>
<span class="comment-copy">@Ignacio Vazquez-Abrams thanks but still confusing</span>
<span class="comment-copy">@IgnacioVazquez-Abrams That's not the whole story, <code>type.mro != object.mro</code>.</span>
<span class="comment-copy">@tcpiper You should probably post your update as a separate question if you want people to see and answer it.</span>
