<div class="post-text" itemprop="text">
<p>I building SPA on Django and I have one huge function with many <code>if</code> statement for checking state name of my object field. Like this:    </p>
<pre><code>if self.state == 'new':
    do some logic
if self.state == 'archive':
    do some logic
</code></pre>
<p>and so on. I reading nice book "Fluent python" now, and I mention about <code>@singledispatch</code> decorator, it looks so great, but it can overide function only with diferent type of parametres like <code>str</code>, <code>int</code>, etc.<br/>
Question is, if there in python or Django way to separate logic like in my huge function with overided function like <code>singledispatch</code> do? </p>
</div>
<div class="post-text" itemprop="text">
<p>There is, though you have to write it. One possibility is to create a <a href="https://docs.python.org/3/howto/descriptor.html" rel="noreferrer">descriptor</a> that does the dispatching based on <code>instance.state</code> or any chosen <code>state_attr</code>:</p>
<pre><code>class StateDispatcher(object):

    def __init__(self, state_attr='state'):
        self.registry = {}
        self._state_attr = state_attr

    def __get__(self, instance, owner):
        if instance is None:
            return self

        method = self.registry[getattr(instance, self._state_attr)]
        return method.__get__(instance, owner)

    def register(self, state):
        def decorator(method):
            self.registry[state] = method
            return method

        return decorator
</code></pre>
<p><a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="noreferrer">https://docs.python.org/3/howto/descriptor.html#functions-and-methods</a>:</p>
<blockquote>
<p>To support method calls, functions include the <code>__get__()</code> method for binding methods during attribute access. This means that all functions are non-data descriptors which return bound or unbound methods depending whether they are invoked from an object or a class.</p>
</blockquote>
<p>In your stateful class you can then create a dispatcher and register methods:</p>
<pre><code>class StateMachine(object):

    dispatcher = StateDispatcher()
    state = None

    @dispatcher.register('test')
    def test(self):
        print('Hello, World!', self.state)

    @dispatcher.register('working')
    def do_work(self):
        print('Working hard, or hardly working?', self.state)
</code></pre>
<p>Let's see it in action:</p>
<pre><code>&gt;&gt;&gt; sm = StateMachine()
&gt;&gt;&gt; sm.state = 'test'
&gt;&gt;&gt; sm.dispatcher()
Hello, World! test
&gt;&gt;&gt; sm.state = 'working'
&gt;&gt;&gt; sm.dispatcher()
Working hard, or hardly working? working
&gt;&gt;&gt; sm.state = None
&gt;&gt;&gt; sm.dispatcher()
Traceback (most recent call last):
  ...
  File "dispatcher.py", line 11, in __get__
    method = self.registry[getattr(instance, self._state_attr)]
KeyError: None
</code></pre>
<p>Note that this is a quite evil method of dispatching based on state, since for future readers of your code the whole mechanism will be hard to follow.</p>
<p>Another method of dispatching on textual state is to encode the state in your method names and choose the correct method based on that in a dispatching function. Many python classes use this pattern (<a href="https://docs.python.org/3/library/ast.html#ast.NodeVisitor" rel="noreferrer"><code>ast.NodeVisitor</code></a> for example):</p>
<pre><code>class StateMachine(object):

    def dispatch(self, *args, **kwgs):
        getattr(self, 'do_{}'.format(self.state))(*args, **kwgs)

    def do_new(self):
        print('new')

    def do_archive(self):
        print('archive')


sm = StateMachine()
sm.state = 'new'
sm.dispatch()
sm.state = 'archive'
sm.dispatch()
</code></pre>
</div>
<span class="comment-copy">Thank a lot for intresting answer. I realy have to learn this <code>descriptor</code> magic</span>
