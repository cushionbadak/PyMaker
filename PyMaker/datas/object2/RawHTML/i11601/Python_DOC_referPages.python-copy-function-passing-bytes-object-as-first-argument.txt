<div class="post-text" itemprop="text">
<p>I have a class, shown below, that inherits from <code>datetime.date</code></p>
<pre><code>class my_class(datetime.date):
    def __new__(cls, arg1=None):
        print ("arg1: ", arg1)
        return super().__new__(cls, 2015, 11, 2)
</code></pre>
<p>When I <code>copy</code> (or <code>deepcopy</code>) an instance of this class, as shown below,</p>
<pre><code>import copy
my_obj = my_class(5)
copy.copy(my_obj)
</code></pre>
<p>I get the following output</p>
<pre><code>arg1:  5
arg1:  b'\x07\xdf\x0b\x02'
</code></pre>
<p>So clearly some <code>bytes</code> object is passed as the first argument when doing a <code>copy</code> (or <code>deepcopy</code>). I know that the <code>copy</code> function works by passing arguments to the constructor of the object in question such that an identical object will be created...so why is it passing these <code>bytes</code> objects?</p>
<p>This behaviour seems to occur only when inheriting from immutable objects, since when I tested this when inheriting from a <code>list</code> object, the <code>copy</code> function did not pass a <code>bytes</code> object.</p>
<p>(Note that the class I defined above is a very (very!) simplified case of a real class I am using, that also inherits from <code>datetime.date</code>)</p>
<p>Thanks in advance</p>
<p><strong>NOTE</strong></p>
<p>I am using Python 3.5.1</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason this happens is because internally <code>copy</code> and <code>deepcopy</code> make use of <code>pickle</code> to facilitate object state serialisation. From the <a href="https://docs.python.org/3/library/copy.html" rel="nofollow">docs</a>:</p>
<blockquote>
<p>This module does not copy types like module, method, stack trace, stack frame, file, socket, window, array, or any similar types. It does “copy” functions and classes (shallow and deeply), by returning the original object unchanged; this is compatible with the way these are treated by the pickle module. </p>
<p>...</p>
<p>In fact, the <code>copy</code> module uses the registered <code>pickle</code> functions from the <code>copyreg</code> module.</p>
</blockquote>
<p>Why does <code>copy</code> need to <code>pickle</code>? Because:</p>
<blockquote>
<p>A shallow copy <strong>constructs a new compound object</strong> and then (to the extent possible) inserts references into it to the objects found in the original.</p>
</blockquote>
<p>To do that, though, <code>copy</code> needs to be able to understand the object hierarchy. Pickling is designed to solve that problem by mapping a hierarchy to a standard serialised format. </p>
<p>This also is where the byte objects come from. </p>
<blockquote>
<p>“Pickling” is the process whereby a Python object hierarchy is converted into a <strong>byte stream</strong>, and “unpickling” is the inverse operation, whereby a byte stream (from a binary file or bytes-like object) is converted back into an object hierarchy.</p>
</blockquote>
<p>It would appear that, for whatever reason (maybe <code>datetime.date</code> implements <code>__new__</code> in a special way?), the unpickling isn't reproducing the integer argument passed to <code>__new__</code>. </p>
<p>Why? I have no earthly idea. Poke around a little bit and see what you can dig up. </p>
<h2>The Solution</h2>
<p>The docs also make it pretty clear what to do if <code>copy()</code> or <code>deepcopy()</code> are misbehaving for you - define your own copy implementation!</p>
<blockquote>
<p>In order for a class to define its own copy implementation, it can define special methods <code>__copy__()</code> and <code>__deepcopy__()</code>. </p>
<p>The former is called to implement the shallow copy operation; no additional arguments are passed. </p>
<p>The latter is called to implement the deep copy operation; it is passed one argument, the memo dictionary. </p>
<p>If the <code>__deepcopy__()</code> implementation needs to make a deep copy of a component, it should call the <code>deepcopy()</code> function with the component as first argument and the memo dictionary as second argument.</p>
</blockquote>
</div>
<span class="comment-copy">Please check your class because when we do <code>my_obj = my_class(5)</code> we get <code>return super().__new__(cls, 2015, 11, 2) TypeError: super() takes at least 1 argument (0 given)</code> for the current class definition</span>
<span class="comment-copy">@trinchet I had no such issues when running that command (and I copied and pasted that code from my editor into the question bar on SO). I am using Python 3.5.1, with WinPython 64-bit.</span>
<span class="comment-copy">@trinchet <a href="http://stackoverflow.com/questions/19608134/why-is-python-3-xs-super-magic">In Python 3.x, super() can be called with no arguments</a>. OP is using 3.5, so would recommend using that.</span>
<span class="comment-copy">Thanks for the insight. I am assuming that a deepcopy also needs to understand the object hierarchy, since the <code>__new__</code> function in that case also ends up with a serialized object? (and of course, it still needs to produce a new object with the current hierarchy preserved, although now with references to new objects)</span>
<span class="comment-copy">Yes, deepcopy also uses pickle to map the object hierarchy.</span>
