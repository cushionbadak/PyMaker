<div class="post-text" itemprop="text">
<p>I'd like to make a python decorator which memoizes functions. For example, if</p>
<pre><code>@memoization_decorator    
def add(a, b, negative=False):
    print "Computing"
    return (a + b) * (1 if negative is False else -1)

add(1, 2)
add(1, b=2)
add(1, 2, negative=False)
add(1, b=2, negative=False)
add(a=1, b=2, negative=False)
add(a=1, b=2)
</code></pre>
<p>I'd like the output to be</p>
<pre><code>Computing
3
3
3
3
3
3
</code></pre>
<p>and the output should be the same under any permutation of the last 6 lines.</p>
<p>This amounts to finding a map sending equivalent sets of <code>*args, **kwargs**</code> to a unique key for the memoization cache <code>dict</code>. THe above example has <code>*args, **kwargs</code> equal to </p>
<pre><code>(1, 2), {}
(1,), {'b': 2}
(1, 2), {'negative': False}
(1,), {'b': 2, 'negative': False}
(), {'a': 1, 'b': 2, 'negative': False}
(), {'a': 1, 'b': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the memoization you can use <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow"><code>functools.lru_cache()</code></a>.</p>
<p><strong>Edit:</strong> The problem with this for your use case is that it does not consider two function calls to be the same if the way they specify their arguments differs.  To address this we can write our own decorator which sits on top of <code>lru_cache()</code> and transforms arguments into a single canonical form:</p>
<pre><code>from functools import lru_cache, wraps
import inspect

def canonicalize_args(f):
    """Wrapper for functools.lru_cache() to canonicalize default                                                          
    and keyword arguments so cache hits are maximized."""

    @wraps(f)
    def wrapper(*args, **kwargs):
        sig = inspect.getargspec(f.__wrapped__)

        # build newargs by filling in defaults, args, kwargs                                                            
        newargs = [None] * len(sig.args)
        newargs[-len(sig.defaults):] = sig.defaults
        newargs[:len(args)] = args
        for name, value in kwargs.items():
            newargs[sig.args.index(name)] = value

        return f(*newargs)

    return wrapper

@canonicalize_args
@lru_cache()
def add(a, b, negative=False):
    print("Computing")
    return (a + b) * (1 if negative is False else -1)
</code></pre>
<p>Now <code>add()</code> is called only once for the entire set of calls in the question.  Every call is made with all three arguments specified positionally.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/inspect.html#inspect.getcallargs" rel="nofollow"><code>inspect.getcallargs()</code></a> to get a canonical argument list for a function. Wrapping it in a decorator shouldn't be too hard.</p>
<pre><code>In [1]: def add(a, b, negative=False):
    ...:     print("Computing")
    ...:     return (a + b) * (1 if negative is False else -1)
    ...:
    ...:

In [2]: inspect.getcallargs(add, 1, 2)
Out[2]: {'a': 1, 'b': 2, 'negative': False}

In [3]: inspect.getcallargs(add, 1, 2, True)
Out[3]: {'a': 1, 'b': 2, 'negative': True}

In [4]: inspect.getcallargs(add, 1, 2, negative=False)
Out[4]: {'a': 1, 'b': 2, 'negative': False}

In [5]: inspect.getcallargs(add, 1, b=2, negative=False)
Out[5]: {'a': 1, 'b': 2, 'negative': False}

In [6]: inspect.getcallargs(add, 1, b=2)
Out[6]: {'a': 1, 'b': 2, 'negative': False}
</code></pre>
</div>
<span class="comment-copy">I tried what you suggested, and it's not working. For example, executing <code>add(1,2)</code> and <code>add(1, 2, negative=False)</code> in succession gives <code>Computing \\ 3</code> both times, so the second call is being computed rather than returned from the cache.</span>
<span class="comment-copy">@JonWarneke: I see what you mean.  I've expanded my answer to include a full solution.</span>
<span class="comment-copy">This appears to be broken for a function that accepts <code>**kwargs</code> in addition to regular arguments.</span>
