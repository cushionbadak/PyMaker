<div class="post-text" itemprop="text">
<p>I currently have a <code>for-loop</code>, which is going through an incredible number of iterations to check something, and when it goes to a new iteration, I need it to check whether or not a variable I have is the same size of the current iteration.<br/>
Here is an example code of what I'm doing:</p>
<pre><code>import datetime
now = datetime.datetime.now()
printcounter = 0
for i in range(3,100000000000+1,2):
     if (printcounter == 1000000000):
          print(i,"at %d" %now.hour, "hours and %d"  % now.minute, "minutes.")
          printcounter = 0
     else:
          #Do operation
          printcounter += 1
</code></pre>
<p>However, since it's going through possibly millions of math heavy operations before I get my answer, I noticed that by striping this code of the 'printcounter' variable and not giving me a progress report gave me a significant speedup, by whole minutes sometimes.  </p>
<p>Is there any way of only checking whether or not the 'printercounter' variable is equal to 10000, however without making it check <em>every single</em> iteration?<br/>
I personally can't think of anyway without resorting to nesting for loops, which can get very dirty, and I'd rather not have.  </p>
<p>By the way, I'm using Windows 8.1, Python 3.5.1, if that makes any difference.</p>
<p><strong>Edit:</strong><br/>
I understand that it takes a significant portion of time to print, however, if I instead print to a file; my harddisk being <em>very</em> fast, then I still get the same, albeit reduced, difference in time. Also, I have been wanting to get the solution to this implemented in a lot of other scripts, so even if it's not a major problem here, I'd still like to know how to do it.</p>
<p><strong>Edit 2:</strong><br/>
Perhaps it's my fault for not being clear. I was looking to see if it was possible to check a value every once in a while, not every single time. For example, I don't want my code to check if 'printcounter' is equal to 1000000000 when it's 1, that's ridiculous. I know machines operate ridiculously fast, and so it doesn't matter, but I was curious to see if it was possible to reduce the number of times it checks that way, rather than having a dumb code which allows itself to be sloppy or lazy just because it's quick enough to correct for it.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to check the variable every iteration, make it unnecessary...<br/>
by doing something like this instead:</p>
<pre><code>import datetime

iterations = 100000000000
subiterations = 10000
chunks, remaining = divmod(iterations, subiterations)

now = datetime.datetime.now()
printcounter = 0
for i in range(chunks):
    for j in range(subiterations):
        #Do operation
        pass

    printcounter += subiterations
    print('{:,d} at {} hours {} minutes'.format(printcounter, now.hour, now.minute))

if remaining:
    for j in range(remaining):
        #Do operation
        pass

    printcounter += remaining
    print('{:,d} at {} hours {} minutes'.format(printcounter, now.hour, now.minute))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The speedup isn't because of checking that variable.  It's because of the print statement itself.  So no, there's no way to speed it up further besides removing that statement.</p>
<p>And to answer your specific question explicitly: you could restructure your code such that it isn't necessary to make that check, for example, using nested for loops.  But that will likely be slower.  The time it takes to check that one boolean comparison is very small.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>printcounter</code> is incremented at every iteration, why not use nested for loops?</p>
<p>Something roughly like this:</p>
<pre><code>import datetime
now = datetime.datetime.now()

for j in range(100):
    print(j, "at %d" %now.hour, "hours and %d"  % now.minute, "minutes.")
    for i in range(1000000000):
          #Do operation
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not going to make much difference because the int math is small compared to the actual print statement, but:</p>
<pre><code>import datetime


now = datetime.datetime.now()
step = 2
init = 3
for i in range(init, 100000000000+1, step):
    if (i % 10000*step) == init:  #since we start at 3 and step by 2
         print(i,"at %d" %now.hour, "hours and %d"  % now.minute, "minutes.")
    # Do Stuff
</code></pre>
<p>This structure will eliminate a few operations, but none of them are slow operations.  But in terms of code structuring this is how I'd do it. </p>
</div>
<span class="comment-copy">The <code>if</code> statement is not the cause of your troubles. You can see this yourself by <a href="https://github.com/what-studio/profiling" rel="nofollow noreferrer">profiling your Python code</a> so you know what parts of your program are really taking the most time.</span>
<span class="comment-copy">You really want to print these 10,000,000 intermediary progress reports? O_o</span>
<span class="comment-copy">@Reblochon Masque It doesn't print everything, just every 10000th iteration it gives me a status check.</span>
<span class="comment-copy">Yes, <code>10,000,000 = 100,000,000,000 / 10,000</code>, this is why I asked! As is, your set up will print 10 million "status check" lines!</span>
<span class="comment-copy">@Reblochon Masque Hmm... Oops. This isn't my main programme, I was developing this in a separate environment and I setup the numbers without thinking too much, but that was an impressive spot, and it would probably be the reason of the slow down in a different circumstance, I'll change the question now.</span>
<span class="comment-copy">How did you do this? You made it ludicrously fast as well.</span>
<span class="comment-copy">The "trick" is using the built-in <a href="https://docs.python.org/3/library/functions.html?highlight=divmod#divmod" rel="nofollow noreferrer"><code>divmod</code></a> function to calculate <code>(a // b, a % b)</code> to determine the number times the variable <i>would have been</i> incremented (after doing <code>subiternations</code>), and then just incrementing it once every time that many have been completed.</span>
<span class="comment-copy">Neat: I was thinking along the lines of chained iterators, yielding some print trigger in between "chunks", but this is way simpler and better. I am stealing it!</span>
<span class="comment-copy">Also, is it faster to do <code>printcounter += subiterations</code> every <code>i</code> loop iteration than using <code>i * subiterations</code> in the print? (I don't expect any significant difference between both. Just wondering.)</span>
<span class="comment-copy">@Jérôme: Technically I would expect doing <code>chunk</code> additions rather than an equal number of multiplies to be faster — and, regardless, the difference to be completely insignificant. One can often answer Python speed questions oneself by using the <a href="https://docs.python.org/3/library/timeit.html#module-timeit" rel="nofollow noreferrer"><code>timeit</code></a> module. In addition (;-), it's a very useful tool to learn how to use.</span>
<span class="comment-copy">I understand that it's very small, but multiply it by a million times it has to check and it starts to become noticeable.</span>
<span class="comment-copy">This is very interesting, however a double for-loop significantly slows the process down.</span>
<span class="comment-copy">The <code>range(3,100000000000+1,2 / 10000)</code> raises a <code>TypeError</code>.</span>
<span class="comment-copy">Yes, I provided this sample just to illustrate the concept of nested loops. I didn't test it and indeed, I overlooked that part.</span>
<span class="comment-copy">Well, I suppose you did say "roughly like this" and one <i>could</i> write their own <code>frange()</code> function/class that accepted floating-point arguments (although it would be tricky due to computer floating-point math issues). Regardless, your code would still be very slow, because if it worked it would do the operation many more times than the OP's due to the values of the parameters given to both the inner and outer for-loops (not simply because it used a nested pair them).</span>
<span class="comment-copy">Well... sure. The parameters are his to decide, as a trade-off between speed and feedback. Again, the idea was just to illustrate what a nested loop is, nothing more. I changed them to something faster (with less feedback), since this might be obvious only to me. Anyway, thanks for confirming I'm not missing something else.</span>
<span class="comment-copy"><code>xrange == range</code> - this is python 3</span>
<span class="comment-copy">Ah, so it is.  I'll fix that.</span>
