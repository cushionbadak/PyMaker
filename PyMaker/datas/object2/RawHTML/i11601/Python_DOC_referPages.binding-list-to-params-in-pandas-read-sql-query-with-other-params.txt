<div class="post-text" itemprop="text">
<p>I've been trying to test various methods for making my code to run. To begin with, I have this list:</p>
<p><code>member_list = [111,222,333,444,555,...]</code></p>
<p>I tried to pass it into this query:</p>
<pre class="lang-py prettyprint-override"><code>query = pd.read_sql_query(
"""
select member id
    ,yearmonth
from queried_table
where yearmonth between ? and ?
    and member_id in ?
""", db2conn, params = [201601, 201603, member_list])
</code></pre>
<p>However, I get an error that says:</p>
<blockquote>
<p>'Invalid parameter type.  param-index=2 param-type=list', 'HY105'</p>
</blockquote>
<p>So I looked around and tried using formatted strings:</p>
<pre class="lang-py prettyprint-override"><code>query = pd.read_sql_query(
"""
select member id
    ,yearmonth
from queried_table
where yearmonth between ? and ?
    and member_id in (%s)
""" % ','.join(['?']*len(member_list), db2conn, params = [201601, 201603, tuple(member_list)])
</code></pre>
<p>Now, I get the error:</p>
<blockquote>
<p>'The SQL contains 18622 parameter markers, but 3 parameters were supplied', 'HY000'</p>
</blockquote>
<p>because it's looking to fill in all the <code>?</code> placeholders in the formatted string.</p>
<p>So, ultimately, is there a way to somehow evaluate the list and pass each individual element to bind to the <code>?</code> or is there another method I could use to get this to work?</p>
<p>Btw, I'm using <code>pyodbc</code> as my connector.</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Break this up into three parts to help isolate the problem and improve readability:</p>
<ol>
<li>Build the SQL string</li>
<li>Set parameter values</li>
<li>Execute <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql_query.html" rel="nofollow noreferrer">pandas.read_sql_query</a></li>
</ol>
<hr/>
<h2>Build SQL</h2>
<p>First ensure <code>?</code> placeholders are being set correctly. Use <a href="https://docs.python.org/3.5/library/string.html#format-examples" rel="nofollow noreferrer">str.format</a> with <a href="https://docs.python.org/3.5/library/stdtypes.html#str.join" rel="nofollow noreferrer">str.join</a> and <a href="https://docs.python.org/3.5/library/functions.html#len" rel="nofollow noreferrer">len</a> to dynamically fill in <code>?</code>s based on <code>member_list</code> length. Below examples assume 3 <code>member_list</code> elements.</p>
<h3>Example</h3>
<pre><code>member_list = (1,2,3)
sql = """select member_id, yearmonth
         from queried_table
         where yearmonth between {0} and {0}
         and member_id in ({1})"""
sql = sql.format('?', ','.join('?' * len(member_list)))
print(sql)
</code></pre>
<h3>Returns</h3>
<pre><code>select member_id, yearmonth
from queried_table
where yearmonth between ? and ?
and member_id in (?,?,?)
</code></pre>
<hr/>
<h2>Set Parameter Values</h2>
<p>Now ensure parameter values are organized into a <em>flat</em> tuple</p>
<h3>Example</h3>
<pre><code># generator to flatten values of irregular nested sequences,
# modified from answers http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python
def flatten(l):
    for el in l:
        try:
            yield from flatten(el)
        except TypeError:
            yield el

params = tuple(flatten((201601, 201603, member_list)))
print(params)
</code></pre>
<h3>Returns</h3>
<pre><code>(201601, 201603, 1, 2, 3)
</code></pre>
<hr/>
<h2>Execute</h2>
<p>Finally bring the <code>sql</code> and <code>params</code> values together in the <code>read_sql_query</code> call</p>
<pre><code>query = pd.read_sql_query(sql, db2conn, params)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're using python 3.6+ you could also use a formatted string litteral for your query (cf <a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498" rel="nofollow noreferrer">https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498</a>)</p>
<pre><code>start, end = 201601, 201603
selected_members = (111, 222, 333, 444, 555)  # requires to be a tuple

query = f"""
    SELECT member_id, yearmonth FROM queried_table
    WHERE yearmonth BETWEEN {start} AND {end}
      AND member_id IN {selected_members}
"""

df = pd.read_sql_query(query, db2conn)
</code></pre>
</div>
<span class="comment-copy">The flatten function did it!!! However, I think I just ran into a problem with a parameter cap. Apparently, my member list has 84000+ members, but when I try to dynamically fill in the <code>?</code> placeholders for all those members, Python limited to a max of 18,622. Looks like I'm going to have to split my member list to do this. Thanks for you help!</span>
<span class="comment-copy">Happy to help. Since you're working with that many <code>member_list</code> values,  will likely get better performance (and fix the parameter limitation) by populating another table then inner join to filter results. <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_sql.html#pandas-dataframe-to-sql" rel="nofollow noreferrer">pandas.DataFrame.to_sql</a> might help with table creation.</span>
<span class="comment-copy">Thanks Bryan. Unfortunately, I don't have write access to the schema and the IT department won't give me access. Otherwise, I would have gone down that route.</span>
<span class="comment-copy">Very good and detailed solution/example, thank you!</span>
<span class="comment-copy">For <code>pymysql</code> you need a <code>%s</code> placeholder, so it should be <code>','.join(['%s'] * len(member_list))</code></span>
<span class="comment-copy">note: 'start' and 'end' might need to be cast as strings depending on the type of the 'yearmonth' column in your DB table...</span>
<span class="comment-copy">While your proposed method will work, it wouldn't be recommended because it would be prone to SQL injection attacks.</span>
<span class="comment-copy">There is indeed a slight risk (but a lot of things would make the query fail anyway). That being said, the proposed solution doesn't provide a whole lot more security (just checking that the past list is enumerable via the usage of join). I think if you take it far enough that might also be prone to injection attacks... Anyway, first it wasn't not clear to me that the query served a front-end directy; second, the responsibility of validating the input should be in a function wrapping that query, not the query string itself...</span>
<span class="comment-copy">Last thing, depending on the DB engine used, you might need to validate the <code>selected_members</code> tuple when it's composed of a single element. That's because in python it would print as <code>(111,)</code> whereas (at least via psycopg2) the query would only successfully be parsed if it was <code>(111)</code>.</span>
