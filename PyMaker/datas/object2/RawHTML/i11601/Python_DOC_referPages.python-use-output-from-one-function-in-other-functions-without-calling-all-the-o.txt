<div class="post-text" itemprop="text">
<p>I have one core function that I call from many of the other functions in my script.  Problem is that I do not want each function when it calls the core function to run it.  Is there a way of storing the output of the core function so that when its called for the second, third time etc its not run?</p>
<p>E.g.</p>
<pre><code>def core_func(a,b,c):
  do something....
  return x,y,z

def func2(a,b,c):
  x,y,z = core_func(a,b,c)
  do something with x,y,z

def func3(a,b,c):
  x,y,z = core_func(a,b,c)
  do something with x,y,z
</code></pre>
<p>etc..</p>
<p>func3 here would call core_func again after func2 has called it.  How can I prevent that but at the same time use core_func output?  A possible solution maybe return the outputs from func2 and use in func3 (but this would get a bit ugly).</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>variable = core_func(arguments)

func2(variable)

func3(variable)
</code></pre>
<p>Store the results of the function in a variable!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://wiki.python.org/moin/PythonDecoratorLibrary#Memoize" rel="nofollow">memoize</a></p>
<blockquote>
<p>Caches a function's return value each time it is called.</p>
</blockquote>
<p>So, every time you call the function with the same parameters you'll get the return value without the computing time</p>
<p>i.e:</p>
<p>If you're using Python2 you need to implement it, you can have a look how it's implemented on the link above and then apply it to your function:</p>
<pre><code>class memoized(object):
      '''Decorator. Caches a function's return value each time it is called.
      If called later with the same arguments, the cached value is returned
      (not reevaluated).
      '''
      def __init__(self, func):
         self.func = func
         self.cache = {}
      def __call__(self, *args):
         if not isinstance(args, collections.Hashable):
            # uncacheable. a list, for instance.
            # better to not cache than blow up.
            return self.func(*args)
         if args in self.cache:
            return self.cache[args]
         else:
            value = self.func(*args)
            self.cache[args] = value
            return value
      def __repr__(self):
         '''Return the function's docstring.'''
         return self.func.__doc__
      def __get__(self, obj, objtype):
         '''Support instance methods.'''
         return functools.partial(self.__call__, obj)

@memoized
def core_func(a, b, c):
  do something....
  return x,y,z
</code></pre>
<p>If you're using Python3 you've it for free with the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow">lru_cache decorator</a></p>
<blockquote>
<p>Decorator to wrap a function with a memoizing callable that saves up
  to the maxsize most recent calls. It can save time when an expensive
  or I/O bound function is periodically called with the same arguments.</p>
</blockquote>
<pre><code>from functools import lru_cache

@lru_cache(maxsize=32)
def core_func(a, b, c):
  do something....
  return x,y,z
</code></pre>
</div>
<span class="comment-copy">This answer would be better if you showed an actual example</span>
<span class="comment-copy">@BryanOakley done, just added examples and a better explanation. Thanks for the feedback.</span>
<span class="comment-copy">Never knew you could do this. Pretty cool if your function has a large overhead.</span>
