<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/zlib.html" rel="nofollow">Source</a></p>
<blockquote>
<p>Changed in version 3.0: Always returns an unsigned value. To generate the same numeric value across all Python versions and platforms, use <strong>crc32(data) &amp; 0xffffffff</strong>.</p>
</blockquote>
<p>But why do we need to use a bitwise and with a binary number set to all 1's? Wont the result be the same regardless (as in any binary number BITWISE ANDED with all 1's will always be the same binary number)? This seemingly arbitrary detail makes me uncomfortable.</p>
</div>
<div class="post-text" itemprop="text">
<p>The bitwise <code>&amp;</code> forces a conversion of the value to an unsigned integer.  Consider, for example:</p>
<pre><code>&gt;&gt;&gt; -2 &amp; 0xffffffff
4294967294
</code></pre>
<p>Based on the comment you have quoted, in 3.0 Python was changed to <em>always</em> return an unsigned value, while in previous versions the <code>crc32()</code> method may have returned a signed value.</p>
<p>For example, in Python 2.7.11:</p>
<pre><code>&gt;&gt;&gt; crc32('the quick brown fox')
-1849621814
</code></pre>
<p>But in Python 3.4.3:</p>
<pre><code>&gt;&gt;&gt; crc32(b'the quick brown fox')
2445345482
</code></pre>
<p>So you get different values here, but if in Python 2.7 you perform the bitwise and, you get the same value as in Python 3.4:</p>
<pre><code>&gt;&gt;&gt; crc32('the quick brown fox') &amp; 0xffffffff
2445345482
</code></pre>
</div>
<span class="comment-copy">Just to clarify, the bitwise and operator (w/ nothing to do with python) performed on a binary number and a binary number consisting of all 1's - by definition would never change anything <code>XXXX</code> &amp; <code>1111</code> = <code>XXXX</code> always. It just so happens that in python, the bitwise and operator also converts the numbers to unsigned. Is this correct? (note that this is not the equivalent of just using abs) Is my thinking correct?</span>
