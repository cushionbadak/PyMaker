<div class="post-text" itemprop="text">
<p>I get a <code>TypeError</code> when I try to get data from <code>MySQL</code> table and assign it to a <code>queryset</code> using following code in Django <code>ModelViewSet</code></p>
<pre><code>def queryset(self, request):
      conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='password123', db='sakila')
      cur = conn.cursor()
      cur.execute("SELECT  city_id, city, country_id FROM city")
      json.dumps(list(cur))

      cur.close()
      conn.close()
</code></pre>
<p>It gives me following error</p>
<blockquote>
<p>Exception Value:
  'method' object is not iterable</p>
</blockquote>
<p>What am I doing wrong? Any solutions? I'm kind of a noob so if you could explain the solution too, that would be great.</p>
<pre><code>Traceback:

  File "C:\Users\Naila Akbar\AppData\Local\Programs\Python\Python35-32\lib\site-packages\django\core\handlers\base.py" in get_response
  149.                     response = self.process_exception_by_middleware(e, request)

&gt; File "C:\Users\Naila Akbar\AppData\Local\Programs\Python\Python35-32\lib\site-packages\django\core\handlers\base.py" in get_response
  147.                     response = wrapped_callback(request, *callback_args, **callback_kwargs)

&gt; File "C:\Users\Naila Akbar\AppData\Local\Programs\Python\Python35-32\lib\site-packages\django\views\decorators\csrf.py" in wrapped_view
  58.         return view_func(*args, **kwargs)

&gt; File "C:\Users\Naila Akbar\AppData\Local\Programs\Python\Python35-32\lib\site-packages\rest_framework\viewsets.py" in view
  87.             return self.dispatch(request, *args, **kwargs)

&gt; File "C:\Users\Naila Akbar\AppData\Local\Programs\Python\Python35-32\lib\site-packages\rest_framework\views.py" in dispatch
  466.             response = self.handle_exception(exc)

&gt; File "C:\Users\Naila Akbar\AppData\Local\Programs\Python\Python35-32\lib\site-packages\rest_framework\views.py" in dispatch
  463.             response = handler(request, *args, **kwargs)

&gt; File "C:\Users\Naila Akbar\AppData\Local\Programs\Python\Python35-32\lib\site-packages\rest_framework\mixins.py" in list
  48.         return Response(serializer.data)

&gt; File "C:\Users\Naila Akbar\AppData\Local\Programs\Python\Python35-32\lib\site-packages\rest_framework\serializers.py" in data
  674.         ret = super(ListSerializer, self).data

&gt; File "C:\Users\Naila Akbar\AppData\Local\Programs\Python\Python35-32\lib\site-packages\rest_framework\serializers.py" in data
  239.                 self._data = self.to_representation(self.instance)

&gt; File "C:\Users\Naila Akbar\AppData\Local\Programs\Python\Python35-32\lib\site-packages\rest_framework\serializers.py" in to_representation
  614.             self.child.to_representation(item) for item in iterable

&gt; Exception Type: TypeError at /cities/

&gt; Exception Value: 'method' object is not iterable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are using the Django REST framework, then you are expected to produce <em>model instances</em> (database results) or simple <em>Python</em> primitives (built-in types), and it'll take care of serialisation to JSON <em>for you</em>. By abstracting away the serialization, the framework can implement content-negotiation, where the client can pick what format they receive the data in. That <em>could</em> be JSON, but it could also be something else. I suspect that returning a JSON string is going to upset the assumptions the framework makes.</p>
<p>Return your cursor data in a <code>rest_framework.response.Response</code> object instead, do <strong>not</strong> serialize this yourself:</p>
<pre><code>from rest_framework.response import Response
from contextlib import closing

# ...
conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='password123', db='sakila')
with closing(conn), conn as cur:
    with cur:
        cur.execute("SELECT  city_id, city, country_id FROM city")
        return Response(list(cur))
</code></pre>
<p>From the <a href="http://www.django-rest-framework.org/api-guide/responses/" rel="nofollow"><em>Responses</em> section in the API Guide</a>:</p>
<blockquote>
<p>REST framework supports HTTP content negotiation by providing a <code>Response</code> class which allows you to return content that can be rendered into multiple content types, depending on the client request.</p>
<p>The <code>Response</code> class subclasses Django's <code>SimpleTemplateResponse</code>. <strong><code>Response</code> objects are initialised with data, which should consist of native Python primitives</strong>. REST framework then uses standard HTTP content negotiation to determine how it should render the final response content.</p>
</blockquote>
<p>In the above example I also used <a href="https://docs.python.org/3/library/contextlib.html#contextlib.closing" rel="nofollow"><code>contextlib.closing()</code></a> to ensure the connection is closed even if there are exceptions in the view, and then used the connection as a context manager to produce the cursor, and then the cursor to ensure it too is closed.</p>
<p>If you do have an an actual model, then use the Django ORM and don't create direct connections yourself. You are using a big, well-integrated machine and are ignoring 95% of that machine here. You won't get connection pooling, transaction management, pagination, etc. etc. etc. Just use proper querysets and model views in that case.</p>
</div>
<span class="comment-copy">Please include the <b>full</b> traceback of your exception, because it isn't clear where that error is coming from.</span>
<span class="comment-copy">@MartijnPieters I don't know how to include traceback but I try..</span>
<span class="comment-copy">I don't see where it happens in the code you posted, but since the error is <code>'method' object is not iterable</code> and you have a method called <code>queryset</code> and a local var called <code>queryset</code> I suspect they are getting mixed up somewhere, but I don't see where.  Try changing one of those names and see if it changes anything.</span>
<span class="comment-copy">@nephlm tried..still same</span>
<span class="comment-copy">still same error ..</span>
<span class="comment-copy">I'm doing like this cur.execute("SELECT  city_id, city, country_id FROM city")  queryset = json.dumps(list(cur))</span>
<span class="comment-copy">@NullPointer: yes, that's correct. Please add the full traceback to your question, because if you still get that error then <i>your posted code is not the cause</i>.</span>
<span class="comment-copy">added...please check updated question</span>
<span class="comment-copy">@NullPointer: does your function return anything?</span>
