<div class="post-text" itemprop="text">
<p>I want to input text to python and process it in parallel. For that purpose I use <code>multiprocessing.Pool</code>. The problem is that sometime, not always, I have to input text multiple times before anything is processed.</p>
<p>This is a minimal version of my code to reproduce the problem:</p>
<pre class="lang-py prettyprint-override"><code>import multiprocessing as mp
import time

def do_something(text):
    print('Out: ' + text, flush=True)
    # do some awesome stuff here

if __name__ == '__main__':
    p = None
    while True:
        message = input('In: ')
        if not p:
            p = mp.Pool()
        p.apply_async(do_something, (message,))
</code></pre>
<p>What happens is that I have to input text multiple times before I get a result, no matter how long I wait after I have inputted something the first time. (As stated above, that does not happen every time.)</p>
<pre><code>python3 test.py
In: a
In: a
In: a
In: Out: a
Out: a
Out: a
</code></pre>
<p>If I create the pool before the while loop or if I add <code>time.sleep(1)</code> after creating the pool, it seems to work every time. Note: I do not want to create the pool before I get an input.</p>
<p>Has someone an explanation for this behavior?</p>
<p>I'm running Windows 10 with Python 3.4.2
EDIT: Same behavior with Python 3.5.1</p>
<hr/>
<p>EDIT:</p>
<p>An even simpler example with Pool and also ProcessPoolExecutor. I think the problem is the call to <code>input()</code> right after appyling/submitting, which only seems to be a problem the first time appyling/submitting something.</p>
<pre class="lang-py prettyprint-override"><code>import concurrent.futures
import multiprocessing as mp
import time

def do_something(text):
    print('Out: ' + text, flush=True)
    # do some awesome stuff here

# ProcessPoolExecutor
# if __name__ == '__main__':
#     with concurrent.futures.ProcessPoolExecutor() as executor:
#         executor.submit(do_something, 'a')
#         input('In:')
#         print('done')

# Pool
if __name__ == '__main__':
    p = mp.Pool()
    p.apply_async(do_something, ('a',))
    input('In:')
    p.close()
    p.join()
    print('done')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code works when I tried it on my Mac.</p>
<p>In Python 3, it might help to explicitly declare how many processors will be in your pool (ie the number of simultaneous processes).</p>
<p>try using <code>p = mp.Pool(1)</code></p>
<pre><code>import multiprocessing as mp
import time

def do_something(text):
    print('Out: ' + text, flush=True)
    # do some awesome stuff here

if __name__ == '__main__':
    p = None
    while True:
        message = input('In: ')
        if not p:
            p = mp.Pool(1)
        p.apply_async(do_something, (message,))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I could not reproduce it on Windows 7 but there are few long shots worth to mention for your issue. </p>
<ol>
<li>your AV might be interfering with the newly spawned processes, try  temporarily disabling it and see if the issue is still present.</li>
<li>Win 10 might have different IO caching algorithm, try inputting larger strings. If it works, it means that the OS tries to be smart and sends data when a certain amount has piled up.</li>
<li>As Windows has no fork() primitive, you might see the delay caused by the <a href="https://docs.python.org/3.5/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow">spawn </a> starting method.</li>
<li>Python 3 added a new pool of workers called <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="nofollow">ProcessPoolExecutor</a>, I'd recommend you to use this no matter the issue you suffer from.</li>
</ol>
</div>
<span class="comment-copy">Interestingly, on my Linux system it seems to always start processing input immediately, as expected: <a href="https://asciinema.org/a/4rhu9ibapsq8aalnj6z5ncugb" rel="nofollow noreferrer">asciinema.org/a/4rhu9ibapsq8aalnj6z5ncugb</a>  I wonder if maybe the <code>flush=True</code> isn't actually causing output to be flushed? That would be easy to test (create a unique file per invocation of <code>do_something</code>, for example).</span>
<span class="comment-copy">@larsks: Just tried it with creating files. It produces the same behavior.</span>
<span class="comment-copy">@skrrgwasme: The pool is created only once within the loop. The code I really use joins and closes the pool if EOF is read.</span>
<span class="comment-copy">@the Are you ever <i>missing</i> the output of your first input, or does it just come late? I just entered "a", "b", and "c", and they indeed did appear late, but I saw all three eventually appear. Did any of your input fail to appear entirely?</span>
<span class="comment-copy">@skrrgwasme: yes, the output appears late, but I'm not missing anything. Actually after the first time it returns something, it works as expected and returns everything immediately.</span>
<span class="comment-copy">1) AV? Anti Virus? I don't have anything running 2) Normally I use string with a length beyond 1000. It still shows the same problem. 4) Results in the same behavior</span>
