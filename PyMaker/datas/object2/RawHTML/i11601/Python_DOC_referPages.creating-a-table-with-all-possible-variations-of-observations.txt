<div class="post-text" itemprop="text">
<p>I have an Excel spreadsheet of data with outputs and features to predict this output. For example a row of a certain output will look similar to this:</p>
<pre><code> Y     X1     X2     X3     X4     X5
 A     Y      N      Y          
</code></pre>
<p>The variables X1, X2, and X3 are important and have to be Y, N, Y respectively to get the correct Y output. However, X4 and X5 can be anything. X4 can be Y, N, or NA; X5 can be any number 1-10. I want to use Python to make all variations of this output. So I want something like this:</p>
<pre><code>Y     X1     X2     X3    X4     X5
A     Y      N      Y     Y      1
A     Y      N      Y     Y      2
A     Y      N      Y     Y      3
.
.
A     Y      N      Y     N      1
.
.
etc.
</code></pre>
<p>Is there a way I can do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's fairly easy to do if you use the <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>product</code></a> combinatoric generator in the <a href="https://docs.python.org/3/library/itertools.html#module-itertools" rel="nofollow">itertools</a> module. </p>
<p>What you haven't said is exactly what form you want the output to be in, so I've assumed (csv file-like) tab-delimited strings. Each raw row produced in the <code>for</code> loop is a tuple of values like <code>('Y', 'N', 'Y', 'NA', 7)</code> but you can readily change this as necessary (one example is shown far below).</p>
<pre><code>from itertools import product

possible_observations = [
    ['Y'],             # X1
    ['N'],             # X2
    ['Y'],             # X3
    ['Y', 'N', 'NA'],  # X4
    range(1, 11)       # X5
]

print('\t'.join(('X1', 'X2', 'X3', 'X4', 'X5')))  # column headers
for row in product(*possible_observations):
    print('\t'.join(map(str, row)))
</code></pre>
<p>Output (with <code>»</code> representing a tab character):</p>
<pre class="lang-none prettyprint-override"><code>X1»   X2»   X3»   X4»   X5
Y»    N»    Y»    Y»    1
Y»    N»    Y»    Y»    2
Y»    N»    Y»    Y»    3
Y»    N»    Y»    Y»    4
Y»    N»    Y»    Y»    5
Y»    N»    Y»    Y»    6
Y»    N»    Y»    Y»    7
Y»    N»    Y»    Y»    8
Y»    N»    Y»    Y»    9
Y»    N»    Y»    Y»    10
Y»    N»    Y»    N»    1
Y»    N»    Y»    N»    2
Y»    N»    Y»    N»    3
Y»    N»    Y»    N»    4
Y»    N»    Y»    N»    5
Y»    N»    Y»    N»    6
Y»    N»    Y»    N»    7
Y»    N»    Y»    N»    8
Y»    N»    Y»    N»    9
Y»    N»    Y»    N»    10
Y»    N»    Y»    NA»   1
Y»    N»    Y»    NA»   2
Y»    N»    Y»    NA»   3
Y»    N»    Y»    NA»   4
Y»    N»    Y»    NA»   5
Y»    N»    Y»    NA»   6
Y»    N»    Y»    NA»   7
Y»    N»    Y»    NA»   8
Y»    N»    Y»    NA»   9
Y»    N»    Y»    NA»   10
</code></pre>
<p>If you instead wanted to save all the variations in a list, that could be done like this:</p>
<pre><code>possible_combinations = list(product(*possible_observations))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not something like:</p>
<pre><code>def all_variations():
    rows = []
    for letter in ['Y', 'N', 'NA']:
        for number in range(1,11):
            row = ['A', 'Y', 'N', 'Y', letter, number]
            rows.append(row)
    return rows
</code></pre>
<p>and if you want your column names you can use pandas and make a DataFrame:</p>
<pre><code>import pandas as pd

data = all_variations()
cols = ['Y'] + ['X{number}'.format(number=num) for num in range(1,6)]
df = pd.DataFrame(rows, columns=cols)

print df
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>product</code> function of the <code>itertools</code> module.
Here is a sample code:</p>
<pre><code>  from itertools import product

  X4 = ['Y', 'N', 'NA']
  X5 = list(range(1,11))
  Ct = ['A', 'Y', 'N', 'Y']

  for elt in  product(X4, map(str, X5) ) :
     print( '\t'.join( Ct[:] + list(elt)  )  )
</code></pre>
</div>
<span class="comment-copy">Itertools has many built-in combination and permutation operations <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow noreferrer">docs.python.org/2/library/itertools.html</a></span>
<span class="comment-copy">Thank you! This worked for what I was trying to do. However, I have another question. If I wanted to save this into an Excel file or csv file, how would I save these rows to do that? I tried to make it into a list rather than tab-delimited strings and assign the list a name but when I do that I only get a list of the last row of variations.</span>
<span class="comment-copy">You could make them into a list with <code>combos = [row for row in product(X1, X2, X3, X4, X5)]</code>. To create a csv file, just <code>file.write()</code> each tab-delimited string as a line of a file opened for writing by adding a newline (<code>'\n'</code>) character to the end of each. If you would prefer comma-delimited just change the  <code>'\t'.join</code> to <code>','.join</code>.</span>
<span class="comment-copy">P.S. You can, of course, also use a <a href="https://docs.python.org/3/library/csv.html#csv.writer" rel="nofollow noreferrer"><code>csv.writer</code></a> object to create a csv file. However, creating an Excel file would require using one of the many third-party modules available.</span>
<span class="comment-copy">I actually just figured something out that seems to have worked for me. I made it into a list and used data.append(list()) then created a data frame to save it. Thank you for your help!</span>
<span class="comment-copy">You're welcome.</span>
<span class="comment-copy">The whole point of <code>itertools.product</code> is so you don't have to create a potentially very large list like <code>M</code> when you can instead just iterate through the values it yields.</span>
<span class="comment-copy">Thank you @martineau  for this comment, I edited the answer according to what you noticed.</span>
