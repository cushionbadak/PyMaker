<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/100732/why-is-if-not-someobj-better-than-if-someobj-none-in-python">Why is “if not someobj:” better than “if someobj == None:” in Python?</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
</ul>
</div>
<p>I'm trying to understand this piece of code </p>
<pre><code>def listSum(ls):
    if not ls:
        return 0

    return ls[0] + listSum(ls[1:])
</code></pre>
<p>Two things bug me a bit </p>
<ol>
<li><code>if not ls:</code> - What does it mean? As nothing has been specified, what is it looking for?</li>
<li><code>ls[0] + listSum(ls[1:])</code> - I've tried using <code>listSum(ls[0:])</code> only and I have running error. Why? Why should I stick to <code>ls[0] + listSum(ls[1:])</code>?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Imagine it's called...</p>
<pre><code>listSum([3, 5, 3, 7])
</code></pre>
<p>It get down to...</p>
<pre><code>return ls[0] + listSum(ls[1:])
</code></pre>
<p>...which is evaluated as...</p>
<pre><code>return 3 + listSum([5, 3, 7])
</code></pre>
<p>Then <code>listSum([5, 3, 7])</code> as <code>5 + listsum([3, 7])</code>.</p>
<p>Then <code>listSum([3, 7])</code> as <code>3 + listsum([7])</code>.</p>
<p>Then <code>listSum([7])</code> as <code>7 + listsum([])</code>, which is where the <code>not ls</code> kicks in and returns <code>0</code>.</p>
<p>So, the complete thing is then evaluated as...</p>
<pre><code>3 + 5 + 3 + 7 + 0
</code></pre>
<p>Notes:</p>
<ul>
<li><p><code>listSum(ls[1:])</code> is shortening the list each time - reducing the complexity of the remaining problem, until an invocation of <code>listSum</code> receives an empty list: the trivial case that <code>if not ls: return 0</code> handles</p></li>
<li><p>recursive solutions are often made up of two parts: a solution for the simplest possible input (or sometimes, a couple very simple cases), and something saying how to take an arbitrarily complicated input and reduce it to a formula making one or more recusive calls that are each at least a little bit simpler, always moving towards that simplest possible input</p></li>
<li><p><em>"I've tried using <code>listSum(ls[0:])</code>"</em> - <code>ls[0:]</code> returns a copy of <code>ls</code> - it would ask for the same list to be processed ad infinitum</p></li>
<li><p>it's arguably more intuitive to explicitly handle a list of one element - <code>if len(ls) == 1: return ls[0]</code> - but then if anyone called <code>listSum([])</code> you'd try to access <code>[0]</code> (in the other code below the <code>if</code>) and raise an exception; handling the empty list makes the function easier to use <em>if</em> <code>listSum([])</code> returning <code>0</code> is sane for your application, but on the other hand having <code>listSum([])</code> raise an exception might uncover bugs where lists are unexpectedly empty - you can decide which is more useful to you; happily if you do handle the empty-list case, <code>len(ls) == 1</code> case then "just works" with the same recursion logic</p></li>
</ul>
</div>
<span class="comment-copy">1. See <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#truth-value-testing</a>, it's the idiom for <i>"if <code>ls</code> is empty"</i>. 2. If you pass the whole list (<code>ls[0:]</code> or just <code>ls[:]</code>) into the recursive call, how will it ever become empty?</span>
<span class="comment-copy">Thanks @jonrsharpe. Should I close my question?</span>
<span class="comment-copy">Empty containers are <code>False</code>.</span>
<span class="comment-copy">@jonrsharpe thanks for the grammatical amendments and removing the <code>hard time</code> ;)</span>
<span class="comment-copy">Hi @tony-d, let's say I'm stupid and I want to keep carrying <code>listSum(ls[0]:)</code>, what would me prevent me in doing so?</span>
<span class="comment-copy">@AndyK the system recursion limit? Again, if you're not shortening the list of each recursive call, you never reach the terminating condition of an empty list.</span>
<span class="comment-copy">Hi @AndyK - recursive calls do need some way to know when to stop, otherwise they'll either hang the program or crash when the stack is exhausted, as jonrsharpe mentions.</span>
<span class="comment-copy">@TonyD many thanks for your time and patience. You've totally nailed my questions. Kudos</span>
<span class="comment-copy">@AndyK: you're welcome.  Recursion does a lot of peoples' heads in - mine too at times - so if I save anyone a little grief, great.  Cheers.</span>
