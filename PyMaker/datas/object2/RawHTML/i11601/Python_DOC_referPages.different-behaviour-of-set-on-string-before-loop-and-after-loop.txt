<div class="post-text" itemprop="text">
<p>These two pieces of code give two different results! Why?</p>
<pre><code>len(sorted(set([w.lower() for w in text1])))
17231

len(sorted([w.lower() for w in set(text1)]))
19317
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since lower and upper form of characters don't have same <a href="https://docs.python.org/3/library/functions.html?highlight=enumerate#hash" rel="nofollow"><em>hash value</em></a>, the set function doesn't assume them as duplicate. Therefore after converting all the characters to lower case the <code>set()</code> function will remove more characters from your string in first code.</p>
<p>Consider the following example:</p>
<pre><code>&gt;&gt;&gt; text2 = 'ABCDEFabcdef'
&gt;&gt;&gt; 
&gt;&gt;&gt; set(w.lower() for w in text2)
set(['a', 'c', 'b', 'e', 'd', 'f'])
&gt;&gt;&gt; [w.lower() for w in set(text2)]
['a', 'a', 'c', 'b', 'e', 'd', 'f', 'f', 'c', 'b', 'e', 'd']
</code></pre>
<p>You can use <code>hash()</code> function to see the hash value of characters:</p>
<pre><code>&gt;&gt;&gt; hash('A')
8320025024
&gt;&gt;&gt; hash('a')
12416037344
</code></pre>
<p>A bit more:</p>
<p>Now if you want to get a unique result of lower characters you should use the first approach. But if you are dealing with a large text you better to use a generator expression instead of a list comprehension:</p>
<pre><code>set(w.lower() for w in text1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; text1 = 'Aa'
&gt;&gt;&gt; set(text1)  # has two elements because the input has two different elements
{'a', 'A'}
&gt;&gt;&gt; [w.lower() for w in set(text1)]
['a', 'a']
&gt;&gt;&gt; [w.lower() for w in text1]
['a', 'a']
&gt;&gt;&gt; set([w.lower() for w in text1])  # has one element because the input has two equal elements
{'a'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first version converts all the strings to lower case, then removes duplicates, then sorts. The second version removes duplicates, then converts to lower case, then sorts.</p>
<p>So for each pair of input strings that differ only in case, the second version will emit two (lower case) entries that match.</p>
<p>Are you seeing other differences?</p>
<p>Edit: You changed the code to just take the <code>len()</code> of the resulting lists, so you won't see the details. Try diffing the lists.</p>
</div>
<span class="comment-copy">because you're doing two entirely different things..?</span>
<span class="comment-copy">Since lower and upper form of characters don't have same hash value, the set function doesn't assume them as duplicate, hence after converting all the characters to lower case the set might remove more characters from your string.</span>
<span class="comment-copy">There is no need to mention hash values. Using hashes is a feature of the implementation, an optimisation. if <code>hash('A')</code> and <code>hash('a')</code> were equal the result would be the same because ultimately the set checks if the elements are equal.</span>
<span class="comment-copy">@AlexHall No, I think that's what makes the OP think the result should be the same, because apparently the both codes are the same (without changing any specific input)</span>
