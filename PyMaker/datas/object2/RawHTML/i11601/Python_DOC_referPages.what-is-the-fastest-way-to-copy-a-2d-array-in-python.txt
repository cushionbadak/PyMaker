<div class="post-text" itemprop="text">
<p>I have to make a very large number of simulations on a <code>R*C</code> grid.</p>
<p>These simulations are altering the grid, so I need to copy my reference grid before each, and then apply my simulating function on the fresh new grid.</p>
<p>What is the fastest way to do this in Python?</p>
<hr/>
<p><em>Since I have not found a similar question on StackOverflow, I did the tests myself and decided to post them here thinking they could be useful to other people.</em></p>
<p><em>The answer will be a community response so that other people can add new measurements with possibly other techniques.</em></p>
<p><em>If you add another method, remember to measure all the old tests and update them because the time depends on the computer used, avoid biasing the results.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>I used a bash variable for setting up the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow"><code>timeit</code></a> tests:</p>
<pre><code>setup="""
R = 100
C = 100
from copy import deepcopy
import numpy as np
ref = [[i for i in range(C)] for _ in range(R)]
ref_np = np.array(ref)
cp = [[100 for i in range(C)] for _ in range(R)]
cp_np = np.array(cp)
"""
</code></pre>
<p>Just for convenience, I also set a temporary alias <code>pybench</code>:</p>
<pre><code>alias pybench='python3.5 -m timeit -s "$setup" $1'
</code></pre>
<hr/>
<h1>Python 3</h1>
<p><em>Python 3.5.0+ (default, Oct 11 2015, 09:05:38)</em></p>
<ul>
<li><p><strong>Deepcopy:</strong></p>
<pre><code>&gt;&gt;&gt; pybench "cp = deepcopy(ref)"
100 loops, best of 3: 8.29 msec per loop
</code></pre></li>
<li><p><strong>Modifying pre-created array using index:</strong></p>
<pre><code>&gt;&gt;&gt; pybench \
"for y in range(R):
    for x in range(C):
        cp[y][x] = ref[y][x]"
1000 loops, best of 3: 1.16 msec per loop
</code></pre></li>
<li><p><strong>Nested list comprehension:</strong></p>
<pre><code>&gt;&gt;&gt; pybench "cp = [[x for x in row] for row in ref]"
1000 loops, best of 3: 390 usec per loop
</code></pre></li>
<li><p><strong>Slicing:</strong></p>
<pre><code>&gt;&gt;&gt; pybench "cp = [row[:] for row in ref]"
10000 loops, best of 3: 45.8 usec per loop
</code></pre></li>
<li><p><strong>NumPy copy:</strong></p>
<pre><code>&gt;&gt;&gt; pybench "cp_np = np.copy(ref_np)"
100000 loops, best of 3: 6.03 usec per loop
</code></pre></li>
<li><p><strong>Copying to pre-created NumPy array:</strong></p>
<pre><code>&gt;&gt;&gt; pybench "np.copyto(cp_np, ref_np)"
100000 loops, best of 3: 4.52 usec per loop
</code></pre></li>
</ul>
<hr/>
<p>There is nothing very surprising in these results, as you might have guessed, use NumPy is enormously faster, especially if one avoids creating a new table each time.</p>
</div>
<span class="comment-copy">What kind of array? NumPy ndarray? python array? nested python list? some other array?</span>
