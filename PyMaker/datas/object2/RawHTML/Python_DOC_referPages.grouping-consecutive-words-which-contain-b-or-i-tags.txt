<div class="post-text" itemprop="text">
<p>I have data looks: </p>
<pre><code>[[('Natural', 'JJ', 'B'), ('language', 'NN', 'I'), ('processing', 'NN', 'I'), ('is', 'VBZ', 'O'), ('one', 'CD', 'O'), ('of', 'IN', 'O'), ('the', 'DT', 'O'), ('important', 'JJ', 'O'), ('branch', 'NN', 'O'), ('of', 'IN', 'O'), ('CS', 'NNP', 'B'), ('.', '.', 'I')] ... ...]]
</code></pre>
<p>I want to group the consecutive words which have tags B or I and ignore which have 'O' tags. </p>
<p>The output keywords should look like:</p>
<p><strong>Natural language processing</strong>,
<strong>CS</strong>,
<strong>Machine learning</strong>,
<strong>deep learning</strong></p>
<p>I did code as follows:</p>
<pre><code>data=[[('Natural', 'JJ', 'B'), ('language', 'NN', 'I'), ('processing', 'NN', 'I'), ('is', 'VBZ', 'O'), ('one', 'CD', 'O'), ('of', 'IN', 'O'), ('the', 'DT', 'O'), ('important', 'JJ', 'O'), ('branch', 'NN', 'O'), ('of', 'IN', 'O'), ('CS', 'NNP', 'B'), ('.', '.', 'I')],
[('Machine', 'NN', 'B'), ('learning', 'NN', 'I'), (',', ',', 'I'), ('deep', 'JJ', 'I'), ('learning', 'NN', 'I'), ('are', 'VBP', 'O'), ('heavily', 'RB', 'O'), ('used', 'VBN', 'O'), ('in', 'IN', 'O'), ('natural', 'JJ', 'B'), ('language', 'NN', 'I'), ('processing', 'NN', 'I'), ('.', '.', 'I')],
[('It', 'PRP', 'O'), ('is', 'VBZ', 'O'), ('too', 'RB', 'O'), ('cool', 'JJ', 'O'), ('.', '.', 'O')]]
Key_words = []
index = 0
for sen in data:
    for i in range(len(sen)):
        while index &lt; len(sen):
</code></pre>
<p>I do not know what to do next. Could anyone please help me?. </p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use <code>itertools.groupby</code> for a fairly compact solution:</p>
<pre><code>import itertools
import string

data = [[('Natural', 'JJ', 'B'), ('language', 'NN', 'I'), ('processing', 'NN', 'I'), ('is', 'VBZ', 'O'), ('one', 'CD', 'O'), ('of', 'IN', 'O'), ('the', 'DT', 'O'), ('important', 'JJ', 'O'), ('branch', 'NN', 'O'), ('of', 'IN', 'O'), ('CS', 'NNP', 'B'), ('.', '.', 'I')],
[('Machine', 'NN', 'B'), ('learning', 'NN', 'I'), (',', ',', 'I'), ('deep', 'JJ', 'I'), ('learning', 'NN', 'I'), ('are', 'VBP', 'O'), ('heavily', 'RB', 'O'), ('used', 'VBN', 'O'), ('in', 'IN', 'O'), ('natural', 'JJ', 'B'), ('language', 'NN', 'I'), ('processing', 'NN', 'I'), ('.', '.', 'I')],
[('It', 'PRP', 'O'), ('is', 'VBZ', 'O'), ('too', 'RB', 'O'), ('cool', 'JJ', 'O'), ('.', '.', 'O')]]

punctuation = set(string.punctuation)
keywords = [[' '.join(w[0] for w in g) for k, g in itertools.groupby(sen, key=lambda x: x[0] not in punctuation and x[2] != 'O') if k] for sen in data]

print(keywords)
# [['Natural language processing', 'CS'],
#  ['Machine learning', 'deep learning', 'natural language processing'],
#  []]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to get the first values in the tuple wherever 'O' is not present as the third element, right? You can do it this way. </p>
<pre><code>output = [j[0] for i in data for j in i if(j[2]!='O')]
</code></pre>
<p>The above code is same as</p>
<pre><code>for i in data:
    for j in i:
        if(j[2]!='O'): # if(j[2] in ['I','B']) also works
            print(j[0]) # Or append to the output list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Hope this helps. </p>
<pre><code>remove_o = list(filter(lambda x: x[2] in ['I', 'B'], data))
words = [item[0] for item in remove_o]
reuslt = ' '.join(words)
</code></pre>
</div>
