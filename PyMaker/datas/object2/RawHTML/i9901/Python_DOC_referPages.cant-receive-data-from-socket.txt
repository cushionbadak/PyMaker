<div class="post-text" itemprop="text">
<p>I'm making a client-server program, and there is problem with client part.
Problem is in infinite receiving data. I've tested this particular class, listed below, in a python interpreter. I've succesfuly(maybe not) connected to google, but then program stoped in function recvData() in data = self.socket.recv(1024)</p>
<pre><code>class client():
def __init__(self, host, port):
    self.host = host
    self.port = port

    self.socket = self.connect()
    self.command = commands()


def connect(self):
    '''
    Connect to a remote host.
    '''
    try:
        import socket
        return socket.create_connection((self.host, self.port))
    except socket.error:
        print(":: Failed to connect to a remote port : ")

def sendCommand(self, comm):
    '''
    Send command to remote host
    Returns server output
    '''
    comman = comm.encode()
    # for case in switch(comman):
    #         if case(self.command.RETRV_FILES_LIST.encode()):
    #             self.socket.send(b'1')
    #             return self.recvData()

    #         if case():
    #             print(":: Got wrong command")

    if (comman == b'1'):
        self.socket.send(b'1')
        return self.recvData()

def recvData(self):
    '''
    Receives all the data
    '''
    i = 0
    total_data = []
    while(True):
        data = self.socket.recv(1024)
        if not data: break
        total_data.append(data)
        i += 1
        if i &gt; 9:
            break
    return total_data
</code></pre>
<p>about commented part :
I thought problem in Case realization, so used just if-then statement. But it's not.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that <code>self.socket.recv(1024)</code> only returns an empty string when the socket has been shut down on the server side and all data has been received. The way you coded your client, it has no idea that the full message has been received and waits for more. How you deal with the problem depends very much on the protocol used by the server. </p>
<p>Consider a web server. It sends a line-delimited header including a <code>content-length</code> parameter telling the client exactly how many bytes it should read. The client scans for newlines until the header is complete and then uses that value to do <code>recv(exact_size)</code> (if large, it can read chunks instead) so that the recv won't block when the last byte comes in.</p>
<p>Even then, there a decisions to make. The client knows how large the web page is but may want to send a partial data to the caller so it can start painting the page before all the data is received. Of course, the caller needs to know that is what happens - there is a protocol or set of rules for the API itself.</p>
<p>You need to define how the client knows a message is complete and what exactly it passes back to its caller. A great way to deal with the problem is to let some other protocol such as [zeromq](<a href="http://zeromq.org/" rel="nofollow noreferrer">http://zeromq.org/</a> do the work for you. A simple python client / server can be implemented with <a href="https://docs.python.org/3/library/xmlrpc.client.html" rel="nofollow noreferrer">xmlrpc</a>. And there are many other ways.</p>
<p>You said you are implementing a client/server program then you mentioned "connected to google" and telnet... These are all very different things and a single client strategy won't work with all of them.</p>
</div>
<span class="comment-copy">You call <code>recvData</code> and it hangs forever?</span>
<span class="comment-copy">Could you add a little more information about the outcome of running the code (are you getting an exception? ending silently? hanging?), and what you expect the outcome to be?</span>
<span class="comment-copy">yeah it is, it blocks on receiving data</span>
<span class="comment-copy">@glibdud  it ends silently outcome i want is same as telnet when i connect to google with telnet and sends '1' it response with 404 html</span>
<span class="comment-copy">Not really enough info here to say for sure, but I imagine the server is waiting for more data. If you're just sending the character "1", that's not a full (or valid) HTTP request.</span>
<span class="comment-copy">thanks for answer! Problem was in sending message to google withouth line ending '\n' But thank you for zeromq, it fits perfect in my pet project :)</span>
<span class="comment-copy">@Fireship Great! Simply reading through zeromq patterns is the best introduction to network programming on the planet.</span>
