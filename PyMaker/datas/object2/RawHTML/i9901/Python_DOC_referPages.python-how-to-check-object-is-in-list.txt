<div class="post-text" itemprop="text">
<p>I have an object to store data: </p>
<pre><code>Vertex(key, children)
</code></pre>
<p>and a list to store this objects </p>
<pre><code>vertices = []
</code></pre>
<p>im using another list </p>
<pre><code>key_vertices = [] 
</code></pre>
<p>to store keys of my vertices, so i can easy access(withot looping every object), each time i need to check vertex with such key exist, like that:</p>
<pre><code>if key not in self.key_vertices:
    # add a new key to the array
    self.key_vertices.append(key)
    # create a vertex object to store dependency information
    self.verteces.append(Vertex(key, children))
</code></pre>
<p>i think it a bit complicated, maybe someone now better way, to store multiple Vertices objects with ability easy to check and access them</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>your example works fine, the only problem you could have is a performance issue with the <code>in</code> operator for <code>list</code> which is <code>O(n)</code>.</p>
<p>If you don't care about the order of the keys (which is likely), just do this:</p>
<pre><code>self.key_vertices = set()
</code></pre>
<p>then:</p>
<pre><code>if key not in self.key_vertices:
    # add a new key to the array
    self.key_vertices.add(key)
    # create a vertex object to store dependency information
    self.verteces.append(Vertex(key, children))
</code></pre>
<p>you'll save a lot of time in the <code>in</code> operator because <code>set</code> <code>in</code> is way faster due to key hashing.</p>
<p>And if you don't care about order in <code>self.verteces</code>, just do a dictionary, and in that case, you probably don't need the first <code>key</code> parameter to your <code>Vertex</code> structure.</p>
<pre><code>self.verteces = dict()

if key not in self.verteces:
    # create a vertex object to store dependency information
    self.verteces[key] = Vertex(children)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you need to check for membership, a list is not the best choice as every object in the list will be checked.</p>
<p>If <code>key</code> is hashable, use a set.
If it's not hashable but is comparable, use a tree (unavailable in the standard library). Try to make it hashable.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand correctly, you want to check if an element has already been added for <code>O(1)</code> (i.e. that you do not have to check every element in the list).</p>
<p>The easiest way to do that is use a <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer">set</a>. A set is an unordered <em>list</em> that allows you to check if an element exists with a constant time <code>O(1)</code>. You can think of a set like a dict with keys only but it works just like a list:</p>
<pre><code>for value in mySet:
     print(value)

print("hello" in mySet)
</code></pre>
<p>If you need an ordered list (most of the time, you don't), your approach is pretty good but I would use a set instead:</p>
<pre><code>self.vertece_set = set() # Init somewhere else ;)

if key not in self.vertece_set:
    # add a new key to the array
    self.vertece_set.add(key)
    # create a vertex object to store dependency information
    self.verteces.append(Vertex(key, children))
</code></pre>
</div>
<span class="comment-copy">Nope. That's about as simple as your gonna get. Don't fall into the trap of thinking there's always a more cleaver way of doing something. What your doing now is perfectly fine.</span>
<span class="comment-copy">@leaf Wow, you again. I would add that this way is actually pretty clever, since it makes use of magic method <code>__contains__</code>. OP did not (need to) take advantage of this, but it allows to implement a better or specific behaviour for the <code>in</code> operator.</span>
<span class="comment-copy">@Rightleg That, and his code is already Pythonic. Now if he wants optimizations, then he will have to change a few things. It seems that Jean-François Fabre's covers this pretty well already.</span>
<span class="comment-copy">".. because set in is way faster due to order." What?</span>
<span class="comment-copy">@Javier my hands wrote something my head was thinking otherwise :) fixed. thx</span>
<span class="comment-copy">let's settle on "an operator eventually implemented by a C function". fixed.</span>
<span class="comment-copy">if it's comparable, you can use <code>bisect</code>, which <i>is</i> in the standard library.</span>
<span class="comment-copy">That's useful for searching but if you insert in the middle of a list, it's an O(n) operation.</span>
<span class="comment-copy">you are right about that. Given the <code>key</code> name, our only hope is to assume that it is hashable :)</span>
<span class="comment-copy">apparently search trees aren't going to happen anytime soon ... <a href="http://stackoverflow.com/questions/17857496/built-in-binary-search-tree-in-python" title="built in binary search tree in python">stackoverflow.com/questions/17857496/…</a>. But such packages exist: <a href="http://stackoverflow.com/questions/2298165/pythons-standard-library-is-there-a-module-for-balanced-binary-tree" title="pythons standard library is there a module for balanced binary tree">stackoverflow.com/questions/2298165/…</a></span>
<span class="comment-copy">That's fine. Not everything needs to be in the standard lib.</span>
