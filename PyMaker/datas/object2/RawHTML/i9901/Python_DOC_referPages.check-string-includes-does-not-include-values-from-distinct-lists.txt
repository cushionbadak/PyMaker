<div class="post-text" itemprop="text">
<pre><code>listIncludedFolders = ["Criteria1"]
listExcludedFolders = ["Criteria2"]

for dirpath, dirnames, filenames in os.walk(root):

    proceed = False

    for each in listIncludedFolders:
        if each in dirpath:
            proceed = True

    if proceed == True:
        for each in listExcludedFolders:
            if each in dirpath:
                proceed = False

    if proceed == True:
        print(dirpath)
</code></pre>
<p>I'm trying to achieve the following code but in a more pythonic way. Using generators I can manage to proceed based on a single list's items:</p>
<pre><code>if any(dir in dirpath for dir in listIncludedFolders):
    print(dirpath)
</code></pre>
<p>...but I can't add the second comparison. I managed in the below to have a single additional criteria but I need to iterate over a list of additional criteria:</p>
<pre><code>if any(dir in dirpath for dir in listIncludedFolders if("Criteria2" not in dirpath)):
    print(dirpath)
</code></pre>
<p>How can I achieve this 'cleanly'?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can avoid walking into subtrees that are excluded in the first place. This solution is also more robust than the original approach, assuming that testing for substrings to determine inclusion and exclusion of folders is not what is meant (do you really want to exclude the folder named "Criteria2345"?) </p>
<pre><code>for dirpath, dirnames, filenames in os.walk(root):
    if set(dirpath.split(os.path.sep)) &amp; set(listIncludedFolders):
        print(dirpath)
    for ex in [dnam for dnam in dirnames if dnam in listExcludedFolders]:
        dirnames.remove(ex)
</code></pre>
<p>Note however that if <code>root</code> is in the exclude-list it would be ignored in this implementation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Combine two condition with <code>and</code> operator with another <code>any</code> call:</p>
<pre><code>if any(each in dirpath for each in listIncludedFolders) and \
        not any(each in dirpath for each in listExcludedFolders):
    print(dirpath)
</code></pre>
<p>or with another <code>and</code> call (with condition negated):</p>
<pre><code>if any(each in dirpath for each in listIncludedFolders) and \
       all(each not in dirpath for each in listExcludedFolders):
    print(dirpath)
</code></pre>
<p>BTW, <code>(... for .. in .. if ..)</code> is a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a>, not a <a href="https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries" rel="nofollow noreferrer">list comrpehension</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>this works perfectly:</p>
<pre><code>listIncludedFolders = ["Criteria1"]
listExcludedFolders = ["Criteria2"]

for dirpath, dirnames, filenames in os.walk(root):

    if any(each in dirpath for each in listIncludedFolders) and \
            not any(each in dirpath for each in listExcludedFolders):
        print(dirpath)
</code></pre>
</div>
<span class="comment-copy">I'm not sure I follow your recommendation here. The results I'm seeing are that using os.walk the excluded directories aren't being entered. I also understood that os.path.walk was deprecated and should be avoided. I certainly don't want to waste time in directories...</span>
<span class="comment-copy">Hey thanks for the hint that <code>os.path.walk</code> is deprecated. I am sure that your code above enters also the excluded directories. Turns out you can avoid that also with os.walk. I edited the answer accordingly.</span>
<span class="comment-copy">Thanks - I tried your code. It runs about a lot faster than the one I posted as an answer but it also finds more folders rather than those found by the answer I posted. Maybe because of the line "if set(dirpath.split(os.path.sep)) &amp; set(listIncludedFolders):". Could you please explain this line? I'm not sure what its doing.</span>
<span class="comment-copy">The expression on the left is the set of all directory names that are part of <code>dirpath</code>. The expression on the right is the set of the elements of <code>listIncludedFolders</code>. The operator <code>&amp;</code> returns the intersection of both sets. Since the truth value of the empty set is <code>False</code>, for a <code>dirpath</code> to be printed it is necessary that it contains at least one directory that is also in 'listIncludedFolders'.</span>
<span class="comment-copy">The reason that this finds more folders than the other solution most certainly is that in this solution only <code>dirpaths</code> are excluded that contain a path-element that is also contained in <code>listExcludedFolders</code>. In the other solution, also <code>dirpaths</code>are excluded which have a substring equal to any element in <code>listExcludedFolders</code>.</span>
