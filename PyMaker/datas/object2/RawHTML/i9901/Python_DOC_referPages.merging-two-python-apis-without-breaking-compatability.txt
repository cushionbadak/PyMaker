<div class="post-text" itemprop="text">
<h2>Here is the scenario:</h2>
<p>Storage system <code>A</code> (Java) is the default and has a Python API <code>API_A</code>. Storage system <code>B</code> (Java/C++) was recently introduced, but did not have a Python API. People "somehow" made <code>B</code> work with <code>API_A</code>, but it is extremely slow, especially as the scale increases. Since, this was the only choice for a Python API, a lot of code now depends on <code>API_A</code> to interact with <code>B</code>.</p>
<p>The team from Storage system <code>B</code> now has a Python API, <code>API_B</code>. <code>API_B</code> is clearly more efficient. However, there are a lot of variations between <code>API_A</code> and <code>API_B</code>. For example, the list directory methods return objects with completely different fields. <code>API_B</code> does not allow recursive deletes for directories, but <code>API_A</code> does. And so on...</p>
<h2>The Question:</h2>
<p>What is the best way to merge the two APIs without breaking compatibility? In particular, since <code>API_A</code> has been in the use, what is the best way to integrate <code>API_B</code> into it transparently?</p>
<p>I don't think creating decorators will work as method signatures vary between the APIs. There are some methods in <code>API_A</code> not present in <code>API_B</code>. (Raising <code>NotImplementedException</code> is the only option here).</p>
<p>The only solution I can think of is the naive one, where I have to do this checking in every function in <code>API_A</code>:</p>
<pre><code>if self.isStorageA:
    return method_of_A(args)
else:
    return method_of_B(args, args)
</code></pre>
<p>I am looking for a better and more maintainable way to do this. Any help is greatly appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<h2>Write a wrapper library for API B that "looks like" API A</h2>
<p>In particular, it must provide exactly the same methods with exactly the same signatures.  If API B does not implement some functionality (like recursive enumeration), the wrapper must re-implement this functionality in terms of API B.  For example, you might write a function that enumerates the current directory, then every subdirectory, and so on recursively, to replace the native functionality of API A.  If it is not possible to do this (that is, if there is some functionality which API A provides and which cannot be done with API B at all), then API B is not a suitable replacement for API A and you should not go forward with your plan.</p>
<p>You should also write a series of unit tests for your wrapper which ensure that it behaves the same as API A does in a variety of conditions specifically including edge cases.  If A already has unit tests, then just use those.</p>
<p>Finally, once you're certain the wrapper is indistinguishable from A, you can replace A with the wrapper.  It's simple enough to just replace the modules and packages, but if this does not work for you for whatever reason, you can replace A in <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="nofollow noreferrer"><code>sys.modules</code></a> to ensure imports of A get the wrapper instead.</p>
</div>
<span class="comment-copy">Thanks. That makes a lot of sense. However, the goal is not to replace <code>API_A</code> completely. There are services which use it to interact with both <code>A</code> and <code>B</code>. I need to integrate them such that calls to <code>API_A</code> will go through <code>API_B</code> if they were aimed for <code>B</code>.</span>
<span class="comment-copy">Python is flexible enough to support that in most reasonable circumstances.  You can pass classes and modules as arguments to functions, or store them in instance variables.  It should be quite possible to control which implementation is used on a case by case basis as needed.</span>
