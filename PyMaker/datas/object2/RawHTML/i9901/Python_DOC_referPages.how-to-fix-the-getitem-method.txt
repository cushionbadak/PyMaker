<div class="post-text" itemprop="text">
<pre><code>def pnamedtuple(type_name, field_names, mutable=False):
    pass

    class type_name:
        def __init__(self, x, y):
            self.x = x
            self.y = y
            self._fields = ['x','y']
            self._mutable = False

        def get_x(self):
            return self.x

        def get_y(self):
            return self.y

        def __getitem__(self,i):
            if i &gt; 1 or i &lt;0:
                raise IndexError
            if i == 0 or i == 'x':
                return self.get_x():
            if i == 1 or i == 'y':
                return self.get_y():
</code></pre>
<p>the <strong>getitem</strong> method to overload the [] (indexing operator) for this class: an index of 0 returns the value of the first field name in the field_names list; an index of 1 returns the value of the second field name in the field_names list, etc. Also, the index can be a string with the named field. So, for p = Point(1,2) writing p.get_x(), or p[0]), or p['x'] returns a result of 1. Raise an IndexError with an appropriate message if the index is out of bounds int or a string that does not name a field. </p>
<p>I am not sure how to fix the <em>getitme</em> function. below is the bsc.txt</p>
<pre><code>c--&gt;t1 = Triple1(1,2,3)
c--&gt;t2 = Triple2(1,2,3)
c--&gt;t3 = Triple3(1,2,3)
# Test __getitem__ functions
e--&gt;t1[0]--&gt;1
e--&gt;t1[1]--&gt;2
e--&gt;t1[2]--&gt;3
e--&gt;t1['a']--&gt;1
e--&gt;t1['b']--&gt;2
e--&gt;t1['c']--&gt;3
^--&gt;t1[4]--&gt;IndexError
^--&gt;t1['d']--&gt;IndexError
^--&gt;t1[3.2]--&gt;IndexError
</code></pre>
<p>can someone tell how to fix my _getitem _ function to get the output in bsc.txt? many thanks. </p>
</div>
<div class="post-text" itemprop="text">
<p>You've spelled <code>__getitem__</code> incorrectly. Magic methods require two <code>__</code> underscores before and after them.</p>
<p>So you haven't overloaded the original <code>__getitem__</code> method, you've simply created a new method named <code>_getitem_</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 does not allow strings and integers to be compared with <code>&gt;</code> or <code>&lt;</code>; it's best to stick with <code>==</code> if you don't yet know the type of <code>i</code>. You could use <code>isinstance</code>, but here you can easily convert the only two valid integer values to strings (or vice versa), then work only on strings.</p>
<pre><code>def __getitem__(self, i):
    if i == 0:
        i = "x"
    elif i == 1:
        i = "y"

    if i == "x":
        return self.get_x()
    elif i == "y":
        return self.get_y()
    else:
        raise IndexError("Invalid key: {}".format(i))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>your function is interesting, but there are some issues with it:</p>
<ol>
<li><p>In python 3 you can't compare string with numbers, so you first should check with <code>==</code> against know values and or types. For example</p>
<pre><code>def __getitem__(self,i):
    if i in {0,"x"}:
        return self.x
    elif i in {1,"y"}:
        return self.y
    else:
        raise IndexError(repr(i))  
</code></pre></li>
<li><p>But defined like that (in your code or in the example above) for an instance t1 this <code>t1[X]</code> for all string X others than <code>"x"</code> or <code>"y"</code> will always fail as you don't adjust it for any other value. And that is because  </p></li>
<li><p><code>pnamedtuple</code> looks like you want for it to be a factory like <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>collections.namedtuple</code></a>, but it fail to be general enough because you don't use any the arguments of your function at all. And no, <code>type_name</code> is not used either, whatever value it have is throw away when you make the class declaration.</p></li>
</ol>
<p>how to fix it?</p>
<ol>
<li><p>You need other ways to store the value of the fields and its respective name, for example a dictionary lets call it <code>self._data</code></p></li>
<li><p>To remember how you called yours field, use the argument of your function, for instance <code>self._fields = field_names</code></p></li>
<li><p>To accept a unknown number of arguments use * like <code>__init__(self, *values)</code> then verify that you have the same numbers of values and fields and build your data structure of point 1 (the dictionary)</p></li>
</ol>
<p>Once that those are ready then <code>__getitem__</code> become something like: </p>
<pre><code>def __getitem__(self, key):
    if key in self._data:
        return self._data[key]
    elif isintance(key,int) and 0 &lt;= key &lt; len(self._fields):
        return self._data[ self._fields[key] ]
    else:
        raise IndexError( repr(key) )
</code></pre>
<p>or you can simple inherit from a appropriate <code>namedtuple</code> and the only thing you need to do is overwrite its <code>__getitem__</code> like</p>
<pre><code>def __getitem__(self,key):
    if key in self._fields:
        return getattr(self,key)
    return super().__getitem__(key)
</code></pre>
</div>
<span class="comment-copy">There's a difference between <code>_getitem_</code> and <code>__getitem__</code>. Only the latter is a special method.</span>
<span class="comment-copy">ok, I fixed it, but it is still not producing the correct result</span>
<span class="comment-copy"><code>indexError</code> is not <code>IndexError</code>. Also, is this Python2 or Python 3?</span>
<span class="comment-copy">3.................</span>
<span class="comment-copy">Instead of checking for a valid index and then raising <code>IndexError</code>, just return a value for a valid index and raise the error if you don't.</span>
<span class="comment-copy">ok, I fixed it, but it is still not producing the correct result</span>
