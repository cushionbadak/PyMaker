<div class="post-text" itemprop="text">
<p>I have am building an application that involves and some non-django functionality.
I have an app 'wit' under the source  directory that is a django application and that has test cases that are being deferred.</p>
<pre><code>src/wit/   test_django_file1.py, test_django_file2.py etc.
</code></pre>
<p>But there are also test cases under that are not being discovered or run</p>
<pre><code>src/utils/ test_nondjango1.py and test_nondjango2.py
</code></pre>
<p>src/utils is not a django application in the installed apps list</p>
<p>When I run do</p>
<pre><code>cd src/
python manage.py test
</code></pre>
<p>The tests under src/utils are not being discovered or run</p>
<p>I am using django jenkins report coverage to get coverage reports.
I would idealy like all the test cases to be invoked with one invocation so that over all code coverage reporting works.</p>
<p>Or else I would like to know how to invoke separately if the above is not possibly so that I get to run all my test cases anyway.</p>
<p>How do I debug this, and figure out which directories are being explored.</p>
</div>
<div class="post-text" itemprop="text">
<h3>Debugging</h3>
<p>Is your utils dir a valid python package (has an <code>__init__.py</code>?).
And, are the modules under it importable? E.g can you do the following:</p>
<pre><code>cd root_dir/
python -c "from src.utils import test_nondjango1"
</code></pre>
<p>If the above raises an <code>ImportError</code>, making it importable is one way you can make the tests "discoverable". Another way would be to specify the directory explicitly when running the tests:</p>
<pre><code>python manage.py tests src.wit src/utils/
</code></pre>
<p>This provides two labels to the <a href="https://docs.djangoproject.com/en/1.10/topics/testing/overview/#running-tests" rel="nofollow noreferrer">test runner</a>: <code>src.wit</code> which a full Python dotted path and <code>src/utils/</code> which is a relative directory.</p>
<h3>Explanation</h3>
<p>[Django docs state] that it "unittest moduleâ€™s <a href="https://docs.python.org/3/library/unittest.html#test-discovery" rel="nofollow noreferrer">built-in test discovery</a>". The first paragraphs in the linked docs say:</p>
<blockquote>
<p>Unittest supports simple test discovery. In order to be compatible
  with test discovery, all of the test files must be modules or packages
  (including namespace packages) importable from the top-level directory
  of the project (this means that their filenames must be valid
  identifiers).</p>
<p>Test discovery is implemented in TestLoader.discover(), but can also
  be used from the command line...</p>
</blockquote>
<p>Just to clarify further, the <a href="https://docs.python.org/3/library/unittest.html#unittest.TestLoader.discover" rel="nofollow noreferrer"><code>discover()</code> method docs</a> says:</p>
<blockquote>
<p><strong>discover</strong>(start_dir, pattern='test*.py', top_level_dir=None)</p>
<p>Find all the test modules by recursing into subdirectories from the
  specified start directory, and return a TestSuite object containing
  them. Only test files that match pattern will be loaded. (Using shell
  style pattern matching.) Only module names that are importable (i.e.
  are valid Python identifiers) will be loaded.</p>
<p>All test modules must be importable from the top level of the project.
  If the start directory is not the top level directory then the top
  level directory must be specified separately.</p>
<p>If importing a module fails, for example due to a syntax error, then
  this will be recorded as a single error and discovery will continue.
  If the import failure is due to SkipTest being raised, it will be
  recorded as a skip instead of an error.</p>
</blockquote>
</div>
