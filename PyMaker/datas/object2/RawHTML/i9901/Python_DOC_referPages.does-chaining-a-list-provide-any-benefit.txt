<div class="post-text" itemprop="text">
<p>As I dimly understand it, itertools.chain.from_iterable is for combining two or more things that return iterables, i.e. things that use the yield keyword and when used as such they are memory efficient.</p>
<p>I have this code I'm trying to decipher. Someone else wrote it.</p>
<pre><code>all_rows = []
with open(__file__, 'rt') as reader:
    for row in reader:
        all_rows.append(row)
magic = list(itertools.chain.from_iterable(all_rows))
for line in magic:
    print(line)
</code></pre>
<p>Wouldn't it be better to just use all_rows directly since it is already an in memory data structure?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are not chaining one list. You are chaining the <strong>contents</strong> of that list:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; all_rows = ['lorem ipsum', 'and so on']
&gt;&gt;&gt; list(itertools.chain.from_iterable(all_rows))
['l', 'o', 'r', 'e', 'm', ' ', 'i', 'p', 's', 'u', 'm', 'a', 'n', 'd', ' ', 's', 'o', ' ', 'o', 'n']
</code></pre>
<p>You'd have a point if your code was simply using <code>chain(all_rows)</code> instead of <code>chain.from_iterable(all_rows)</code>; then you are absolutely right. There is no point in chaining off a single iterable that is already a list, then convert that chain to a list again.</p>
<p>But the <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable()</code> function</a> takes the <em>contents</em> of an iterable and chains those together. It then depends on the elements in the list.</p>
<p>For your example, chaining multiple strings, the advantage is that you don't have to build a larger list first. You'd otherwise have to use <code>list(''.join(all_rows))</code>.</p>
</div>
<span class="comment-copy">Shoot, my example must have a bug. Anyhow, the actual code reads in files to a list of strings and then calls list(itertools.chain.from_iterable(all_rows)) before iterating across the rows in a for-in loop.</span>
<span class="comment-copy">@MatthewMartin: that does sound wasteful, why build a list when iterating in a loop? If you don't need random access, then don't call <code>list()</code> on that and just iterate.</span>
<span class="comment-copy">@MatthewMartin: also, if the actual code reads in files into a list of strings, consider using a generator that produces those contents instead to not have to hold everything in memory.</span>
<span class="comment-copy">Thanks, this confirms my suspicion. For what it's worth, some other developer wrote this &amp; seems to have wrapped a lot of already-in-memory lists with this from_iterable</span>
