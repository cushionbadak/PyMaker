<div class="post-text" itemprop="text">
<p>Can you help me on how to make this script work.</p>
<p>For Defrag</p>
<pre><code>import os;
defragmentation=os.popen('defrag.exe /C').read()
print(defragmentation);
</code></pre>
<p>For Disk Clean up</p>
<pre><code>import os;
clean=os.popen('cleanmgr.exe /sagerun:1').read()
print(clean);
</code></pre>
<p>Upon trying this scripts, it didnt do anything and no error message prompt. Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>If your <code>defrag.exe</code> or <code>cleanmgr.exe</code> are not in your <code>path</code>, they won't execute and you won't get an error message</li>
<li>You would need to run the scripts as an administrator to make them work.</li>
<li>You don't need to terminate your lines with a semi-colon in Python</li>
</ul>
<p>If you want to find the the correct full path of your executable, you can use the following script:</p>
<pre><code>paths = os.getenv('path').split(';')
path_defrag = ''

for p in paths:
    if os.access(os.path.join(p, 'defrag.exe'), os.X_OK):
        path_defrag = os.path.join(p, 'defrag.exe')
        break
if not path_defrag:
    print('defrag.exe is not in your path or cannot be executed')
</code></pre>
<ul>
<li>I'd suggest to Spectras' idea and read the output while it comes and not once everything is finished</li>
<li>In addition I think Python is an overkill here, a simple batch file will do the job</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Building upon my comment: my bet here is the script works perfectly, but you expect to see output right away and, not seeing any, abort the program.</p>
<p>However, read() will stop your script until the command completes. And only then will the pringint happen. Thus, no output will ever be displayed until after the command has completed.</p>
<p>I would change it like this:</p>
<pre><code>with os.popen('cleanmgr.exe /sagerun:1') as fd:
    chunks = iter(lambda: fd.read(1), '')
    for chunk in chunks:
        sys.stdout.write(chunk)
</code></pre>
<p>The idea being to print as it goes: when a size is specified, <code>read</code> does not loop until the descriptor is closed, it returns as soon as it reads something.</p>
<p>It's not the most efficient here as it will read chars one by one. For the programs you're running it should not matter much, and reading more without introducing buffering delays with python is complex.</p>
<p>If you are not using the output in your program and just want it to pass through, maybe you'd be better off just calling :</p>
<pre><code>import subprocess
subprocess.check_call(['cleanmgr.exe', '/sagerun:1'])
</code></pre>
<p>With no additional parameters, output will just go to your script's output. The function waits until the command completes before returning.</p>
</div>
<div class="post-text" itemprop="text">
<p>the problem you face is because you are trying to launch 64-bit executable out of 32-bit process.
When your python or cmd prompt you launch the scripts is 32-bit, it will launch defrag.exe in 32-bit mode if you just specify defrag.exe alone without full path.</p>
<p>And cleanmgr does not return anything, you should just get an empty string back.
Try code below, it should works for both python 32-bit or 64-bit targeting 64-bit OS</p>
<pre><code>import os
print('running disk defragmentation, this might take some time ...')
# you might wanna try out with %systemroot%\sysnative\defrag.exe /A first,
# Else, it might really take some time for defragmentation
if sys.maxsize &gt; 2**32:
    defragmentation=os.popen('defrag.exe /C').read() # run from 64-bit        
else:
    defragmentation=os.popen(r'%systemroot%\sysnative\defrag.exe /C').read() # run from 32-bit

print(defragmentation)


print('running disk cleanup, this might take some time ...')
clean=os.popen('cleanmgr.exe /sagerun:1').read() # should works in both 32-bit and 64-bit
print(clean) # cleanmgr run from gui and don't return anything, this should be empty
</code></pre>
<p>Suggest to use subprocess instead, os.popen is deprecated</p>
<pre><code>import sys
import subprocess

if sys.maxsize &gt; 2**32:
    run_cmd = 'defrag /C' # 64-bit python/cmd
else:
    run_cmd = r'%systemroot%\sysnative\defrag /C' # 32-bit python/cmd

output, err = subprocess.Popen(run_cmd, stdout=subprocess.PIPE, shell=True).communicate()
print(output)
if err:
    print('process fail, error {}'.format(err))
else:
    print('process sucess')

# repeat with run_cmd = 'cleanmgr /sagerun:1'
</code></pre>
</div>
<span class="comment-copy">What exactly do you expect?</span>
<span class="comment-copy">Did you write those scripts?</span>
<span class="comment-copy">@spectras - i need to run a disk defrag and disk clean up in background.</span>
<span class="comment-copy">What OS that i targeted ? XP ? Win7 ? And 32bit or 64 bit ?</span>
<span class="comment-copy">Also, check whether your python is 32 or 64 bit with sys.version</span>
<span class="comment-copy"><code>&gt;&gt;&gt; os.popen('foobar')</code> gives <code>sh: 1: foobar: not found</code>. Don't know about windows, but on Ubuntu it certainly writes an error message onto stderr.</span>
<span class="comment-copy">@spectras: Windows and Ubuntu are different here. On Windows it just gives back an empty string if the program is not found.</span>
<span class="comment-copy">im running in Windows by the way.</span>
<span class="comment-copy">@MaximilianPeters - hey bro, how can i determine if it is not in my path. can you help me build a script for disk clean up and disk defrag? Im running in windows OS</span>
<span class="comment-copy">@MaximilianPeters&gt; interesting flaw. Anyway, my bet here is the script works perfectly, but @user2926827 expects to see output right away and, not seeing any, aborts the program. However, due to calling <code>read()</code> and printing after, no output will ever be displayed until <b>after</b> the command has completed.</span>
<span class="comment-copy">@user2926827&gt; see the suggestion I added of using <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_call" rel="nofollow noreferrer"><code>check_call()</code></a> by the way, if you don't actually need the output inside your script, it's much simpler.</span>
<span class="comment-copy">thank you for editing the script. however can you add on the code that once the disk clean up is done it will show a notification on users screen that it has been finished?</span>
<span class="comment-copy">Just print whatever you want after  <code>check_call</code> returns. But maybe your issue is <a href="http://stackoverflow.com/questions/1000900/how-to-keep-a-python-script-output-window-open">the window closes immediately</a>?</span>
<span class="comment-copy">Hi Spectras. Can you please check the Disk Defrag script? thank you.</span>
<span class="comment-copy">@user2926827&gt; I checked it out, and actually reading more than 1 byte at a time in python without introducing buffering delay makes complex code. Did you try simply using the <code>subprocess.check_call</code> thing? It's one line, it lets the output go to the screen and it waits until the command has completed. You can just do whatever you want after, including writing stuff or sending email. If on Windows for instance, try adding a single <code>input()</code> at the end to prevent the window from closing immediately.</span>
<span class="comment-copy">thanks for the swift response man. will try it and keep you posted once i encountered an error.</span>
<span class="comment-copy">upon running the code. it shows an error with "The system cannot find the path specified. b" pocess success. "</span>
<span class="comment-copy">its because you already running with python 64-bit, check updated code which should works on both python 32 and 64-bit</span>
<span class="comment-copy">i tried the updated code and shows the same error bro.</span>
<span class="comment-copy">sorry, i make a mistake in version checking, please try again</span>
