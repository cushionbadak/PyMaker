<div class="post-text" itemprop="text">
<p>I was looking at the implementation of <code>Complex</code> in the <code>numbers</code> module and noticed <code>__sub__</code> and <code>__rsub__</code>s implementation that looked like this:</p>
<pre><code>def __sub__(self, other):
    """ self - other """
    return self + -other

def __rsub__(self, other):
    """ other - self """
    return -self + other
</code></pre>
<p>This confused me. </p>
<p>Firstly, I'm not really sure why these were implemented (guessing all subclasses of <code>Complex</code> can fall-back to it?) and, secondly, I can't understand why they chose to use the unary <code>-</code> like this for its implementation. </p>
<p>Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a generic implementation that subclasses can use, yes, if they so desire. This is an additional goal; the primary goal of these ABC types is to be able to duck-type numeric types (see <a href="https://www.python.org/dev/peps/pep-3141/" rel="nofollow noreferrer">PEP 3141 – <em>A Type Hierarchy for Numbers</em></a>.</p>
<p>The implementation uses unary minus to avoid recursion; if you used <code>self - other</code> then Python uses <code>self.__sub__(other)</code> or <code>self.__rsub__(other)</code> <em>again</em>.</p>
<p>Because subtraction can be cast as addition with a unary minus operation, the authors of the ABC were able to provide you these methods as a bonus; the alternative would be to provide <code>@abstracmethod</code> methods instead, forcing subclasses to provide a concrete implementation. Your subclass can now, <em>optionally</em>, implement those methods in a different way if that is more efficient, but they don't <em>have</em> to.</p>
<p>This is a pattern used in all ABCs the standard library provides. If you take a look at the <a href="https://docs.python.org/3/library/collections.abc.html#module-collections.abc" rel="nofollow noreferrer">documentation for the <code>collections.abc</code> module</a> you'll notice a <em>Mixin Methods</em> column; these are all methods the respective ABC has provided as concrete implementations that may or may not rely on the abstract methods defined by that ABC or its base classes.</p>
<p>Also see the general <a href="https://www.python.org/dev/peps/pep-3119/" rel="nofollow noreferrer">PEP 3119 – <em>Introducing Abstract Base Classes</em></a> upon which PEP 3141 is built:</p>
<blockquote>
<p>Some ABCs also provide concrete (i.e. non-abstract) methods; for example, the <code>Iterator</code> class has an <code>__iter__</code> method returning itself, fulfilling an important invariant of iterators (which in Python 2 has to be implemented anew by each iterator class). These ABCs can be considered "mix-in" classes.</p>
</blockquote>
</div>
<span class="comment-copy">Makes sense, I was <i>thinking</i> of recursion but I wanted to verify that it indeed is the cause. Do you have any thoughts on why it was only <code>__sub__</code> and <code>__rsub__</code>?  That is, can you see any reason why a dunder like <code>__add__</code> wouldn't do?</span>
<span class="comment-copy">@user6774416: you can't express those methods in a way that would only rely on the other methods already defined, so they are kept abstract.</span>
<span class="comment-copy"><code>__neg__</code> is left unimplemented, so you <i>must</i> define that. Once that is defined, you can either use the predefined <code>__sub__/__rsub__</code>, or provide your own (possibly more efficient) versions.</span>
