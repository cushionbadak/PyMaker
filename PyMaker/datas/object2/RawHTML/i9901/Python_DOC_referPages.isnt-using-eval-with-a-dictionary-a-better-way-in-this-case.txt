<div class="post-text" itemprop="text">
<p>The two functions below perform an arithmetic operation on two integers and return an integer result.</p>
<p>I've heard a lot about eval() being really bad to use because it can cause many problems. But taking a look at the code I've written below, it seems that eval() spares many lines of code, right?</p>
<pre><code>def dict_calculate(operation, num1, num2):
    operations = {'add': '+', 'subtract': '-', 'multiply': '*', 'divide': '//'}
    return eval(str(num1) + operations[operation] + str(num2))

def conditional_calculate(operation, num1, num2):
    if operation == 'add':
        return num1 + num2
    if operation == 'subtract':
        return num1 - num2
    if operation == 'multiply':
        return num1 * num2
    if operation == 'divide':
        return num1 // num2

if __name__ == "__main__":
    x = 10
    y = 5

    print(str(dict_calculate('add', x, y)) + ', ', end='')
    print(str(dict_calculate('subtract', x, y)) + ', ', end='')
    print(str(dict_calculate('multiply', x, y)) + ', ', end='')
    print(str(dict_calculate('divide', x, y)))

    print(str(conditional_calculate('add', x, y)) + ', ', end='')
    print(str(conditional_calculate('subtract', x, y)) + ', ', end='')
    print(str(conditional_calculate('multiply', x, y)) + ', ', end='')
    print(str(conditional_calculate('divide', x, y)))
</code></pre>
<p>Outputs are the same for both functions</p>
<pre><code>15, 5, 50, 2
15, 5, 50, 2
</code></pre>
<p>Isn't eval best to use in this type of case? If not, is there a better way than eval() to achieve this same type of code-efficiency?</p>
<p>Thanks a lot.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this:</p>
<pre><code>import operator
def dict_calculate(operation, num1, num2):
    operations = {'add': operator.add,
                  'subtract': operator.sub,
                  'multiply': operator.mul,
                  'divide': operator.floordiv}
    return operations[operation](num1, num2)
</code></pre>
<p>If you don't want to import another module, you can do this:</p>
<pre><code>def dict_calculate(operation, num1, num2):
    operations = {'add': '__add__',
                  'subtract': '__sub__',
                  'multiply': '__mul__',
                  'divide': '__floordiv__'}
    return getattr(num1, operations[operation])(num2)
</code></pre>
</div>
<span class="comment-copy">Will you properly sanitise/validate all user input to ensure you're not eval'ing something which has bad side effects…?</span>
<span class="comment-copy">Take a look at the <a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer"><code>operator</code> module</a>, or define your own functions for each operator. Functions are just objects, you can store them in a dictionary.</span>
<span class="comment-copy">@deceze I see what you mean... Is there any way to avoid that without writing many if statements?</span>
<span class="comment-copy">And you should never let the number of lines of a solution determine if it is suitable or not. It could be <i>one factor</i>, but don't let that excuse the use of <code>eval()</code>.</span>
<span class="comment-copy">Understood, thanks very much.</span>
<span class="comment-copy">I was about to post a similar answer. That is much more secure than using <code>eval()</code>, because here you reduce the possible operations to actual arithmetic operations, instead of allowing the user to do <i>anything</i> by using eval (like deleting/modifying files, etc.)</span>
<span class="comment-copy">Amazing, so I guess the wisdom here is to just use helper functions with dictionaries rather than evaluating string versions of operators directly. Thanks very much.</span>
<span class="comment-copy">If you keep the original operator names instead of more or less arbitrary aliases, you can even do <code>getattr(operator, operation)(num1, num2)</code>…</span>
<span class="comment-copy">@deceze I was thinking just the same :-)</span>
<span class="comment-copy">@BuggyLemon You're welcome :-)</span>
