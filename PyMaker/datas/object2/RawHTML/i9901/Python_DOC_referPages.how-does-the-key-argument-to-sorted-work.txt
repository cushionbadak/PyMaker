<div class="post-text" itemprop="text">
<p>Code 1:    </p>
<pre><code>&gt;&gt;&gt; sorted("This is a test string from Andrew".split(), key=str.lower)
    ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']
</code></pre>
<p>Code 2:</p>
<pre><code>&gt;&gt;&gt; student_tuples = [
...     ('john', 'A', 15),
...     ('jane', 'B', 12),
...     ('dave', 'B', 10),
... ]
&gt;&gt;&gt; from operator import itemgetter, attrgetter
&gt;&gt;&gt;
&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
</code></pre>
<p>Why in code 1, is <code>()</code> omitted in <code>key=str.lower</code>, and it reports error if parentheses are included, but in code 2 in <code>key=itemgetter(2)</code>, the parentheses are kept?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>key</code> argument to <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer"><code>sorted</code></a> expects a function, which <code>sorted</code> then applies to each item of the thing to be sorted. The results of <code>key(item)</code> are compared to each other, instead of each original <code>item</code>, during the sorting process.</p>
<p>You can imagine it working a bit like this:</p>
<pre><code>def sorted(thing_to_sort, key):
    #
    # ... lots of complicated stuff ...
    #
            if key(x) &lt; key(y):
                # do something
            else:
                # do something else
    #
    # ... lots more complicated stuff ...
    #
    return result
</code></pre>
<p>As you can see, the parentheses <code>()</code> are added to the function <code>key</code> <em>inside</em> <code>sorted</code>, applying it to <code>x</code> and <code>y</code>, which are items of <code>thing_to_sort</code>.</p>
<p>In your first example, <a href="https://docs.python.org/3/library/stdtypes.html#str.lower" rel="nofollow noreferrer"><code>str.lower</code></a> is the function that gets applied to each <code>x</code> and <code>y</code>.</p>
<p><a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>itemgetter</code></a> is a bit different. It's a function which <em>returns another function</em>, and in your example, it's <em>that other function</em> which gets applied to <code>x</code> and <code>y</code>.</p>
<p>You can see how <code>itemgetter</code> works in the console:</p>
<pre><code>&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; item = ('john', 'A', 15)
&gt;&gt;&gt; func = itemgetter(2)
&gt;&gt;&gt; func(item)
15
</code></pre>
<p>It can be a little hard to get your head around "higher order" functions (ones which accept or return other functions) at first, but they're very useful for lots of different tasks, so it's worth experimenting with them until you feel comfortable.</p>
</div>
<div class="post-text" itemprop="text">
<p>poking around with the console a bit
<code>str.lower</code> reefers to the method 'lower' of 'str' objects
and <code>str.lower()</code> is a function, how ever <code>str.lower()</code> requires an argument, so properly written it would be <code>str.lower("OH BOY")</code> and it would return <code>oh boy</code> the error is because you did not pass any arguments to the function but it was expecting one.</p>
</div>
<span class="comment-copy">Thank you for crystal clear explanation, Piraeus!</span>
