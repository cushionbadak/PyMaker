<div class="post-text" itemprop="text">
<pre><code>class LN:
    def __init__(self,value,next=None):
        self.value = value
        self.next  = next

def list_to_ll(l):
    if l == []:
        return None
    front = rear = LN(l[0])
    for v in l[1:]:
        rear.next = LN(v)
        rear = rear.next
    return front

def add_after(ll,value,new):
    for item in ll:
        if item == value:
            ll.insert(ll.index(value),new)
</code></pre>
<p>I am working on an iterative function named <code>add_after</code>. It takes linked list and two values, value and new. It mutates the linked list such that every occurrence of the value is now followed by new. For example:</p>
<pre><code>a = list_to_ll([2,1,8,2,2,4,2,5,2])
</code></pre>
<p>add_after(a,2,-1) results in a referring to a linked list containing the values 1-&gt;8-&gt;2-&gt;-1-&gt;4-&gt;2-&gt;-1-&gt;5-&gt;2-&gt;-1-&gt;None.</p>
<p>add_after(a,2,2) for the original list in a results in a referring to a linked list containing the values 1-&gt;8-&gt;2-&gt;2-&gt;4-&gt;2-&gt;2-&gt;5-&gt;2-&gt;2-&gt;None.</p>
<p>plus( I am not allowed to use lists, tuples, sets, or dicts in my code)</p>
<p>use linked lists processing only</p>
<p>when I run my <code>add_after</code> it gives me an error:</p>
<pre><code>add_after(ll,2,-1)
for item in ll:
TypeError: 'LN' object is not iterable
</code></pre>
<p>can anyone help me to fix my <code>add_after</code> function? many thanks. </p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>Make <code>LN</code> iterable, by defining <code>__iter__</code> methods which yields nodes:</li>
<li>Make <code>add_after</code> link new node.</li>
</ol>
<hr/>
<pre><code>class LN:
    def __init__(self, value, next=None):
        self.value = value
        self.next  = next

    def __iter__(self):  # yield all linked node (including the first node)
        node = self
        while node is not None:
            yield node
            node = node.next

def list_to_ll(l):
    if l == []:
        return None
    front = rear = LN(l[0])
    for v in l[1:]:
        rear.next = LN(v)
        rear = rear.next
    return front

def add_after(ll, value, new):
    for item in ll:
        if item.value == value:
            ll.next = LN(new, ll.next)  # Make new node and link after current node
            break
    # TODO: Handle not-found case.


ll = list_to_ll([2,1,8,2,2,4,2,5,2])
add_after(ll, 2, -1)
for item in ll:
    print(item.value)

# Prints 2, -1, 1, 8, 2, 2, 4, 2, 5, 2
</code></pre>
<hr/>
<p><strong>UPDATE</strong> after reading OP's comment =&gt; changing only <code>add_after</code> (manually loop through nodes):</p>
<pre><code>def add_after(ll, value, new):
    node = ll
    while node is not None:
        if node.value == value:
            node.next = LN(new, node.next)
            break
        node = node.next
</code></pre>
<p>NOTE: I made <code>add_after</code> add only one node. I will leave it as your work to add multiple nodes.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>ll</code> is an object of user-defined class <code>LN</code>. It is not iterable like a list, hence a for-each construct would not work in this context.</p>
<p>The following would be the alternative.</p>
<pre><code>def add_after(ll,value,new):
    item = ll
    while item is not None:
        if item.value == value:
            newnode = LN(new, item.next)
            item.next = newnode
            break
        else:
            item = item.next
</code></pre>
<p>Addressing the OP's concern on inserting at the <em>n</em>th occurrence, the following code can be also applicable:</p>
<pre><code>def add_after(ll,value,new,occ=1):
    item = ll
    while item is not None:
        if item.value == value:
            occ -= 1
            if occ == 0:
                newnode = LN(new, item.next)
                item.next = newnode
                break
        item = item.next
</code></pre>
<p>The optional fourth argument determines after which occurrence should the new value be inserted. For example, <code>add_after(ll, 2, -1, 2)</code> adds -1 after the second occurrence of 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution using recursion. I've also added a helper method <code>flatten</code> to visualise the changes for when I was testing.</p>
<pre><code>def add_after(ll, at_value, new_value):
    if ll.value == at_value:
        ll.next = LN(new_value, ll.next)
        if ll.next is not None and ll.next.next is not None:
            # skips over the newly added LN
            add_after(ll.next.next, at_value, new_value)
    elif ll.next is not None:
        add_after(ll.next, at_value, new_value)

def flatten(ll):
    if ll.next is None:
        return [ll.value]
    return [ll.value] + flatten(ll.next)

# Output
&gt;&gt;&gt; a = list_to_ll([2,1,8,2,2,4,2,5,2])
&gt;&gt;&gt; flatten(a)
[2, 1, 8, 2, 2, 4, 2, 5, 2]
&gt;&gt;&gt; add_after(a, 2, -1)
&gt;&gt;&gt; flatten(a)
[2, -1, 1, 8, 2, -1, 2, -1, 4, 2, -1, 5, 2, -1]
&gt;&gt;&gt; b = list_to_ll([2,1,8,2,2,4,2,5,2])
&gt;&gt;&gt; add_after(b, 2, 2)
&gt;&gt;&gt; flatten(b)
[2, 2, 1, 8, 2, 2, 2, 2, 4, 2, 2, 5, 2, 2]
</code></pre>
</div>
<span class="comment-copy">Your linked list is not iterable meaning you can't use a for loop on it. You also can't use <code>insert</code> or <code>index</code> as <code>ll</code> is a <code>LN</code> not a <code>list</code>.</span>
<span class="comment-copy">thanks, but actually I am only allowed to make changes on add_after function, I am not allowed to define the iter function.</span>
<span class="comment-copy">Great! So that's what <code>__iter__</code> is for! Can this be used in any class definition to make it iterable?</span>
<span class="comment-copy">@Ã‰beIsaac, Yes it is. Check this out: <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#iterator-types</a></span>
<span class="comment-copy">@jiahuiding, I updated the answer which iterate manually (does not require <code>__iter__</code> change)</span>
<span class="comment-copy">cool, it worked for the first value. but why it doesn't work for the rest? it seems to iterates through the whole list.</span>
<span class="comment-copy">@jiahuiding:  <i>why it doesn't work for the rest?</i> Could you expand a bit on that? Is it not working for other inputs?</span>
<span class="comment-copy">when I call add_after(ll,2,-1), ll =[1,8,2,4,2,5,2] it returns 1-&gt;8-&gt;2-&gt;-1-&gt;4-&gt;2-&gt;5-&gt;2-&gt;None  only the first 2 followed by the -1</span>
<span class="comment-copy">@jiahuiding: Yes, that is what is supposed to happen: insertion after the <i>first</i> occurrence. If you want to insert at a different position, you may have to add an extra argument to the code. Would you want me to do that for you in <i>this post</i>?</span>
<span class="comment-copy">ok, since I am not sure how to insert the value to more than one position.</span>
<span class="comment-copy">Hi, when I test your code, it seems that it only add the new_value to the first at_value that appears.</span>
<span class="comment-copy">hi, I checked again, but your code seems to loop forever....</span>
<span class="comment-copy">Ah, I see, it fails when adding a value after the same value. <code>add_after(a, 2, 2)</code> I'll get on that.</span>
<span class="comment-copy">thanks, now it seems to work for the first two values, when I call add_after_r(ll,2,-1) to the ll = [1,8,2,4,2,5,2] it returns  1-&gt;8-&gt;2-&gt;-1-&gt;4-&gt;2-&gt;-1-&gt;5-&gt;2-&gt;None  and when I call add_after_r(ll,2,-1) to the ll = [2,2,1,8,2,4,2,5,2] it returns 2-&gt;-1-&gt;2-&gt;-1-&gt;1-&gt;8-&gt;2-&gt;4-&gt;2-&gt;5-&gt;2-&gt;None</span>
<span class="comment-copy">Can you explain to me why it does not work for the rest of the values? I am a little confused.</span>
