<div class="post-text" itemprop="text">
<p>My question is about sockets programming in Python on Linux, but since Python's <code>socket</code> module is just a wrapper over system calls (<code>recv</code>, <code>recvfrom</code> etc.), it's not strongly about Python.</p>
<p>So, according to <a href="https://docs.python.org/2/library/socket.html#socket.socket.recv" rel="nofollow noreferrer">docs</a>, when we call a <code>recv</code> method, </p>
<blockquote>
<p>For best match with hardware and network realities, the value of bufsize should be a relatively small power of 2, for example, 4096</p>
</blockquote>
<p>What does it mean?</p>
<blockquote>
<p>best match with hardware and network realities</p>
</blockquote>
<p>Mostly I care about the performance.</p>
<p>Will it be a bottleneck in my network software, if I pass my custom buffer (that I use as a data container later in my code, it's just a <em>memoryview</em> if it matters) with some <em>not-power-of-two</em> custom size to <a href="https://docs.python.org/2/library/socket.html#socket.socket.recv_into" rel="nofollow noreferrer">socket.recv_into</a> method? </p>
<p>It'll be just one line of code, clear and short.</p>
<p>But my buffer's size can be 17 or 51 or whatever, so I'm wondering, should I implement some internal ring-like buffer with a "good" size (like 4096) and use it to read the data from a socket in chunks with such a "good" size and write it there, and then copy to my buffer?</p>
<p>Does it have any sense in terms of performance?</p>
<p>Or my current scheme (when I read the data from a socket in chunks with a "bad" size, that doesn't match "power of 2" rule) is fine?</p>
<p>In other words: will it affect the performance, if we read from sockets in chunks with 1023 size, rather than 1024? </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>For best match with hardware and network realities, the value of
  bufsize should be a relatively small power of 2, for example, 4096</p>
</blockquote>
<p>You should consider the max size of Ethernet packets (~1500 bytes) and the max size of TCP packets (~64K). You really want a buffer larger than the first (so 1024, is probably out of the question) and you probably don't need more than the latter. so go with 2K, 4K, 8K, 16K, 32K, or 64K.</p>
<p>They are also hinting that the kernel uses buffers with a size of powers of 2 (probably 64K due to TCP max packet size), you want to take the effort and match it so there won't be a small/medium sized leftover (modulu your packet size) when reading.</p>
<p>Example: Let's say you are using a 1023 byte buffer, and since a lot of data is being sent, then the TCP packet is maxed out at 64K. You'll have 64 iterations of 1023 bytes and a wasteful extra iteration of 64 bytes.</p>
</div>
<span class="comment-copy">If that really bugs you, you can always create a <a href="https://docs.python.org/3/library/io.html#io.BufferedReader" rel="nofollow noreferrer">BufferedReader</a> on top of your socket. It will ensure reads are done in reasonable chunks, while letting you read the amounts you like.</span>
<span class="comment-copy">yeah, thanks, it makes sense</span>
<span class="comment-copy">Also, there is an extra cost of making 64 system calls for 1kb instead of 1 system call of 64kb. System calls involve changing a lot of internal processor state, that takes time. That's why we do buffering: doing the 1 system call and dividing in chunks in user space avoids the system call overhead.</span>
