<div class="post-text" itemprop="text">
<p>I'm interested in applying genetic algorithm using DEAP in Python. An example implementation for <a href="http://deap.readthedocs.io/en/master/examples/ga_knapsack.html" rel="nofollow noreferrer">knapasack can be seen here</a>. I'm trying to create my own crossover function, and I want to preserve the lengths of the parents as follows:</p>
<pre><code># Crossover
def crossover(ind1, ind2):
    print len(ind1), len(ind2) #&lt;------ length at the beginning
    temp1 = copy.deepcopy(set(ind1))
    temp2 = copy.deepcopy(set(ind2))
    uniform = list(temp1.union(temp2))
    while len(ind1) &gt; 0:
        ind1.pop()
    while len(ind2) &gt; 0:
        ind2.pop()
    for i in range(max_no):
        ind1.add(random.choice(uniform))
        ind2.add(random.choice(uniform))
    print len(ind1), len(ind2) #&lt;---- length at the end
    return ind1, ind2
</code></pre>
<p>However, the lengths of ind1 and in2 at the beginning of the function differ from the lengths of ind1 and ind2 at the end. The length of both ind1 and ind2 at the beginning should be equal to max_no. I was hoping someone could give me a hint as to why that is. I'm pretty stumped. </p>
<p>Thanks, and any help would be much appreciated. </p>
<p>Edit: Here is my mutation function. I'm also trying to preserve the variable length of individual here as you can see</p>
<pre><code>def mutation(individual):
    if len(individual) &gt; 0:
        individual.remove(random.choice(list(individual)))
        individual.add(random.choice(nodes))
    return individual,
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code is mostly equivalent to this:</p>
<pre><code>import random

ind1 = set(range(100))
ind2 = set(range(100)[::-1])
uniform = list(ind1.union(ind2))
max_no = 100
while len(ind1) &gt; 0:
        ind1.pop()
while len(ind2) &gt; 0:
    ind2.pop()
for i in range(max_no):
    ind1.add(random.choice(uniform))
    ind2.add(random.choice(uniform))
</code></pre>
<h1>Result</h1>
<pre><code>&gt;&gt;&gt; print(len(ind1),len(ind2))
(64, 61)
</code></pre>
<p>Because your individuals are sets, when you add random numbers, every so often it happens that you add something twice. Then the length of the resulting sets will be different on every run, because nothing is added if it's already in the individual.</p>
<p>To solve your problem you can use <code>random.sample</code> instead:</p>
<pre><code>import random

ind1 = set(range(100))
ind2 = set(range(-100,0,-1)[::-1])
uniform = list(ind1.union(ind2))
max_no = 100
while len(ind1) &gt; 0:
    ind1.pop()
while len(ind2) &gt; 0:
    ind2.pop()
for x in random.sample(uniform,max_no):
    ind1.add(x)
for x in random.sample(uniform,max_no):
    ind2.add(x)
</code></pre>
<h1>Result</h1>
<pre><code>&gt;&gt;&gt; print(len(ind1),len(ind2))
(100, 100)
</code></pre>
<p>Having said that, <code>set</code> individuals proved extremely painful for me. <code>sequence</code> individuals are by far the best supported. From the <a href="https://deap.readthedocs.io/en/master/api/tools.html#deap.tools.cxOnePoint" rel="nofollow noreferrer">documentation</a> it's apparent that <code>dict</code> and <code>set</code> as a special case of <code>dict</code> are <a href="https://docs.python.org/3/glossary.html#term-sequence" rel="nofollow noreferrer">not considered <code>sequence</code> types:</a></p>
<blockquote>
<p>sequence </p>
<p>An iterable which supports efficient element access using integer
  indices via the <strong>getitem</strong>() special method and defines a <strong>len</strong>()
  method that returns the length of the sequence. Some built-in sequence
  types are list, str, tuple, and bytes. Note that dict also supports
  <strong>getitem</strong>() and <strong>len</strong>(), but is considered a mapping rather than a sequence because the lookups use arbitrary immutable keys rather than
  integers.</p>
</blockquote>
</div>
<span class="comment-copy">What type is an individual? it seems like it's a <code>set</code>? <code>.add</code> will be a no-op if the operand already exists.</span>
<span class="comment-copy">Yes, individual functions as a set. What do you mean by no-op?</span>
<span class="comment-copy">Thanks, that's perfect!</span>
