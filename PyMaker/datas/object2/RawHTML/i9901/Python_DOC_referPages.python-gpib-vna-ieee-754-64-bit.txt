<div class="post-text" itemprop="text">
<p>I need help,
I convert a program written in HPBASIC to python a VNA network analyzer.
Whose data format is:
Data Transfer Format:
FMB Select IEEE-754 64-bit data transfer format.</p>
<p>Binary Data Transfer Message Format :</p>
<p>MSB MODE: Byte Count Byte Count Bytes</p>
<p>Here is an excerpt:</p>
<p>OUTPUT @ Vna360B; "FMB MSB"! Transfer format 64-bit, most significant byte.                                                                             ! FMB (64-bit) 3068 (Maximum Number of Collected Points).
OUTPUT @ Vna360B; "OFV"! Output frequency values.
ENTER @ Vna360B; P, S! Return two integers.
ENTER @ Vna360b; Freqs (*)! Return Array foat frequencies.</p>
<p>Here's what I get with Pyvisa
I should have gotten by decoding a value of 2.6 Ghz:</p>
<p>Out: [ '\ x00 \ x08A \ x08A \ xe3_ \ x1b @ \ x00 \ x00']</p>
<p>My questions are:
What is this format, Binary, hexa?
How to make python to decode '\ x00 \ x08A \ x08A \ xe3_ \ x1b @ \ x00 \ x00'  ?</p>
<p>Thank you for your help.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Formats</h2>
<p>The data is a list of bytes. You can decode the bytes in any number of different ways. For example, we can iterate through the bytes and list the bytes decoded as integers:</p>
<pre><code>for b in bytearray(b'\x00\x08A\x08A\xe3_\x1b@\x00\x00\x00'):
    print(b)

Output: 
0
8
65
8
65
227
95
27
64
0
0
0
</code></pre>
<p>Or we can consider each byte as an ASCII character:</p>
<pre><code>for b in bytearray(b'\x00\x08A\x08A\xe3_\x1b@\x00\x00\x00'):
    print(b)

Output: 


A

A
ã
_

@
</code></pre>
<p>Note that most of these characters aren't visible. Some are the backspace character! An <a href="http://www.asciitable.com/" rel="nofollow noreferrer">ASCII code table</a> can show you how each byte is being decoded. Both of the two above approaches consider each byte separately. One byte is too small to store your value of 2.6 GHz.</p>
<h2>Decoding Larger Formats</h2>
<p>The <code>struct</code> <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">module</a> is made for reading packed byte arrays into python-readable values and writing python values into byte arrays. Struct is a builtin package, you don't have to install it separately. First, let's start with our known value: 2.6 GHz. We'll pack that as a bytearray and see how it compares with the value recieved from the instrument:</p>
<pre><code>import struct
struct.pack('&lt;d', 2.6e9)

Output:
b'\x00\x00\x00@\x1b_\xe3A'
</code></pre>
<p>This looks just like the end of the array we read from the instrument! The only difference is that the order is backward. The instrument must be using "big-endian" rather than "little-endian" byte order. (To read more about byte order, see the <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">struct docs</a>.) We can switch the byte order by using <code>&gt;</code> instead of <code>&lt;</code>.</p>
<pre><code>import struct
struct.pack('&gt;d', 2.6e9)

Output:
b'A\xe3_\x1b@\x00\x00\x00'
</code></pre>
<p>This matches the end of the array exactly! (In your original example, you may have cut off one of the zeros when pasting your result.) The first 4 bytes probably have some other meaning, you'll have to check the manual of the network analyzer for details. In order to read the bytes and convert to a float, we'll use <code>unpack</code>:</p>
<pre><code>struct.unpack('&gt;d', b'\x00\x08A\x08A\xe3_\x1b@\x00\x00\x00'[4:])

Output:
(2600000000.0,)
</code></pre>
<p>The output is returned as a tuple. Since only enough bytes exist for one float value, the tuple has length 1.</p>
</div>
