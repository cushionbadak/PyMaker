<div class="post-text" itemprop="text">
<p>First time caller here ...</p>
<p>For some reason, I am not getting the desired result from my "for" loops. Below is the snippet of code. The loops work perfectly first time through as LOOP 2 does in fact return back to LOOP 1. But second time through LOOP 2 does not execute. I haven't written code in 25 years, but loving Python. Just need to get through some initial trial and error. Thanks in advance to anyone who can advise on this topic.</p>
<pre><code>import csv

filename='cookie_data.csv'
lookup_filename='ip_addresses.csv'

with open(filename) as file_object, open(lookup_filename) as lookup_file_object:

    reader=csv.DictReader(file_object)
    l_reader=csv.DictReader(lookup_file_object)

    for row in reader:
        user_ip=row['ip_address']
        print("LOOP 1 " + user_ip)

        for l_row in l_reader:
            lookup_ip=l_row['lookup_ip']
            print("LOOP 2 " + user_ip + lookup_ip)
</code></pre>
<p>The output looks like this:
LOOP 1 99.246.228.140
LOOP 2 99.246.228.140
LOOP 2 137.104.238.184
LOOP 2 137.104.238.184
LOOP 2 99.246.228.140
LOOP 2 81.182.15.119
LOOP 1 137.104.238.184
LOOP 1 137.104.238.184
LOOP 1 74.110.238.103</p>
<p>I intend to test for a match of the string(ip address) each time through the loop. The first loop is fine, then second time through it does not execute loop 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that your readers are attached to streams.  As such, you are only expected to iterate through them once.  The next time you iterate through, it's already at end of file, so it doesn't find anything else (hence "the second loop doesn't execute").</p>
<p>You can fix this by <a href="https://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects" rel="nofollow noreferrer">seek</a>ing the fileobject back to the start each time you finish with it:</p>
<pre><code>import os

for row in reader:
    user_ip=row['ip_address']
    print("LOOP 1 " + user_ip)

    for l_row in l_reader:
        lookup_ip=l_row['lookup_ip']
        print("LOOP 2 " + user_ip + lookup_ip)

    # I prefer to explicitly say where we're seeking from, though I 
    # could have just left it as seek(0).
    lookup_file_object.seek(0, os.SEEK_SET)
</code></pre>
</div>
<span class="comment-copy">What do you mean by "does not execute"? Can you elaborate?</span>
<span class="comment-copy">A sample of your data might help.</span>
<span class="comment-copy">@Jeff Incidentally, since you're new here, let me just give you this link from the help system: <a href="http://stackoverflow.com/help/someone-answers">stackoverflow.com/help/someone-answers</a></span>
<span class="comment-copy">@Scott the file_object.seek worked perfectly. Never would have determined that solution on my own. But now I am curious about my approach: is there a more elegant or appropriate solution to having more than one file "open" for processing? Or another question is does it make sense to break any of the current code into functions? This type of problem of processing many rows of separate files, I will need to solve in my applications. Thanks.</span>
<span class="comment-copy">Stack Overflow is usually pretty tightly focused - questions should typically not be grouped together, because it makes it harder for other people to find the same question and answer.  So my best response is: "ask another question."  That said, yours is somewhat open-ended, so might not be a good separate question.  Functions don't seem to matter for what you've shown of your algorithm.  Repeatedly reading from the same file is one of the least efficient ways of doing things; it likely would be a lot better to read l_reader once, store the data in a dictionary, and then query that dictionary.</span>
