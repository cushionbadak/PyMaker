<div class="post-text" itemprop="text">
<p>I have the following situation.<br/></p>
<pre><code>class Class1():
    def __init__(self, param1):
        self.param = param1
    def my_func_1(self):
        return "Hello " + self.param1

class Class2():
    def __init__(self):
        self.instance_of_class_1 = Class1('Real')

    def do_it(self):
        return self.instance_of_class_1.my_func_1()

class Class3():
    def __init__(self):
        self.instace_of_class_2 = Class2()

    def do_it(self):
        return self.instace_of_class_2.do_it()
</code></pre>
<p>I have a test that initiates a <code>Class3</code> object but I want to mock the new  instance of <code>Class1</code> inside the constructor of <code>Class2</code>. This is what i did so far:</p>
<pre><code>def test_my_classes():
    with patch('my.module.Class1') as class_1_mock:
        class_1_mock.my_func_1.return_value = "Hello Fake"
        class_3 = Class3()
        assert class_3.do_it() == 'Hello Fake' #fails
</code></pre>
<p>I'm guessing because <code>Class1</code> constructor takes params - its not a simple patch.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are mocking <code>Class1</code> correctly, but forgot to take into account it is <em>called</em> to produce an instance. The <code>my_func_1</code> would be looked up on the call result (on the instance):</p>
<pre><code>def test_my_classes():
    with patch('my.module.Class1') as class_1_mock:
        class_1_mock.return_value.my_func_1.return_value = "Hello Fake"
</code></pre>
<p>Mock doesn't care that you produced an instance or that <code>my_func_1</code> is a bound method, only that you call <code>Class1</code>.</p>
<p>You can then make assertions if the class was called with the correct parameters, if you so desire:</p>
<pre><code>class_1_mock.assert_called_once_with('Real')
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from mock import patch
&gt;&gt;&gt; class Class1():
...     def __init__(self, param1):
...         self.param = param1
...     def my_func_1(self):
...         return "Hello " + self.param1
...
&gt;&gt;&gt; class Class2():
...     def __init__(self):
...         self.instance_of_class_1 = Class1('Real')
...     def do_it(self):
...         return self.instance_of_class_1.my_func_1()
...
&gt;&gt;&gt; class Class3():
...     def __init__(self):
...         self.instace_of_class_2 = Class2()
...     def do_it(self):
...         return self.instace_of_class_2.do_it()
...
&gt;&gt;&gt; with patch('__main__.Class1') as class_1_mock:
...     class_1_mock.return_value.my_func_1.return_value = "Hello Fake"
...     class_3 = Class3()
...     print class_3.do_it() == 'Hello Fake'
...
True
&gt;&gt;&gt; class_1_mock.mock_calls
[call('Real'), call().my_func_1()]
</code></pre>
<p>I included <code>class_1_mock.mock_calls</code> to show that <code>call().my_func_1()</code> is included; that's the <code>Class1('Real')</code> instance being used to provide the <code>my_func_1()</code> method call.</p>
</div>
<span class="comment-copy">Why does <code>Class2.do_it()</code> use <code>print</code>? You can't test any return values without <code>return</code> <i>statements</i>.</span>
<span class="comment-copy">mistake in the code - will fix. assume it returns the string.</span>
<span class="comment-copy">When i debug the test and get to the line of initialization of Class1 then i see its of type <code>my.module.Class1</code> and not <code>MagicMock</code> - This is not the wanted affect.</span>
<span class="comment-copy">@MrT.: are you certain you <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">patched the right location</a> then?</span>
<span class="comment-copy">OK - now i understand my problem. I used the module where the class was defined and not where the class was used! Thanks :)</span>
