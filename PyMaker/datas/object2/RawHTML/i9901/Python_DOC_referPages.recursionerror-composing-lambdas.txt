<div class="post-text" itemprop="text">
<p>I am trying to write a function that composes any number of lambda functions. </p>
<p>I have two simple lambda functions.</p>
<pre><code>f = lambda x: x + 1
g = lambda x: x**2
</code></pre>
<p>My attempt at a composing function is this:</p>
<pre><code>def compose(*functions):
    composed = lambda x: x  # Function that returns input
    for function in reversed(functions):
        composed = lambda x: function(composed(x))
    return composed
</code></pre>
<p>My thinking was to loop through the variable number of functions, each time making the <code>composed</code> function include a new function inside it.</p>
<p>Then I could make a function that is a composition of <code>f</code> and <code>g</code></p>
<pre><code>c = compose(f, g)
</code></pre>
<p>So calling <code>c(5)</code> should return <code>f(g(5))</code>, which is 26. But instead, I get </p>
<pre><code>RecursionError: maximum recursion depth exceeded
</code></pre>
<p>I thought introducing an intermediate variable might fix the problem.</p>
<pre><code>def compose(*functions):
    composed = lambda x: x  # Function that returns input
    for function in reversed(functions):
        intermediate = lambda x: function(composed(x))
        composed = intermediate
    return composed
</code></pre>
<p>But the same error is raised.</p>
<p>Is there a way to fix this?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, I think your approach will suffer from <em>late closure binding</em>, as <code>function</code> in lambda will only take the last value of function at the end of the iteration. Secondly, <code>composed</code> will only call itself recursively in the end also due to the first reason; <code>composed</code> - the lambda - calls the last value of <code>composed</code> - itself!</p>
<p>One possible fix is to bind <code>composed</code> and <code>function</code> to the <code>lambda</code> at each iteration:</p>
<pre><code>def compose(*functions):
    composed = lambda x: x
    for function in reversed(functions):
        composed = lambda x, function=function, composed=composed: function(composed(x))
    return composed

print(compose(f, g)(5))
# 26
</code></pre>
<p>But your overall problem looks like a good use case for <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a>:</p>
<pre><code>from functools import reduce

def compose(*functions):
    def inner(v):
        return reduce(lambda x, y: y(x),  reversed(functions), v)
    return inner

print(compose(f, g)(5))
# 26
</code></pre>
</div>
<span class="comment-copy">Good solution, but can you spot the bug in the OP's attempt?</span>
<span class="comment-copy">@juanpa.arrivillaga Having a look at it</span>
<span class="comment-copy">yeah, just figured out it was due to late-binding.</span>
