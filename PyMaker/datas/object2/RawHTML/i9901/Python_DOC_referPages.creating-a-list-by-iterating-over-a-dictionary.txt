<div class="post-text" itemprop="text">
<p>I defined a dictionary like this (list is a list of integers):</p>
<pre><code>my_dictionary = {'list_name' : list, 'another_list_name': another_list}
</code></pre>
<p>Now, I want to create a new list by iterating over this dictionary. In the end, I want it to look like this:</p>
<pre><code>my_list = [list_name_list_item1, list_name_list_item2, 
                list_name_list_item3, another_list_name_another_list_item1]
</code></pre>
<p>And so on.</p>
<p>So my question is: How can I realize this?</p>
<p>I tried</p>
<pre><code>for key in my_dictionary.keys():
    k = my_dictionary[key]
    for value in my_dictionary.values():
        v = my_dictionary[value]
        v = str(v)
        my_list.append(k + '_' + v)
</code></pre>
<p>But instead of the desired output I receive a <em>Type Error</em> (unhashable type: 'list') in line 4 of this example.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're trying to get a dictionary item by it's value whereas you already have your value.</p>
<p>Do it in one line using a list comprehension:</p>
<pre><code>my_dictionary = {'list_name' : [1,4,5], 'another_list_name': [6,7,8]}

my_list = [k+"_"+str(v) for k,lv in my_dictionary.items() for v in lv]

print(my_list)
</code></pre>
<p>result:</p>
<pre><code>['another_list_name_6', 'another_list_name_7', 'another_list_name_8', 'list_name_1', 'list_name_4', 'list_name_5']
</code></pre>
<p>Note that since the order in your dictionary is not guaranteed, the order of the list isn't either. You could fix the order by sorting the items according to keys:</p>
<pre><code>my_list = [k+"_"+str(v) for k,lv in sorted(my_dictionary.items()) for v in lv]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>my_list = []
for key in my_dictionary:
    for item in my_dictionary[key]:
        my_list.append(str(key) + '_' + str(item))
</code></pre>
<p>Hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your immediate problem is that <code>dict().values()</code> is a generator yielding the values from the dictionary, not the keys, so when you attempt to do a lookup on line 4, it fails (in this case) as the values in the dictionary can't be used as keys.  In another case, say <code>{1:2, 3:4}</code>, it would fail with a <code>KeyError</code>, and <code>{1:2, 2:1}</code> would not raise an error, but likely give confusing behaviour.</p>
<p>As for your actual question, lists do not attribute any names to data, like dictionaries do; they simply store the index.</p>
<pre><code>def f()
    a = 1
    b = 2
    c = 3
    l = [a, b, c]

    return l
</code></pre>
<p>Calling <code>f()</code> will return <code>[1, 2, 3]</code>, with any concept of <code>a</code>, <code>b</code>, and <code>c</code> being lost entirely.</p>
<p>If you want to simply concatenate the lists in your dictionary, making a copy of the first, then calling <code>.extend()</code> on it will suffice:</p>
<pre><code>my_list = my_dictionary['list_name'][:]
my_list.extend(my_dictionary['another_list_name'])
</code></pre>
<p>If you're looking to keep the order of the lists' items, while still referring to them by name, look into the <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict class in collections</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You've written an outer loop over keys, then an inner loop over values, and tried to use each value as a key, which is where the program failed. Simply use the dictionary's <code>items</code> method to iterate over key,value pairs instead:</p>
<pre><code>["{}_{}".format(k,v) for k,v in d.items()]
</code></pre>
<p>Oops, failed to parse the format desired; we were to produce each item in the inner list. Not to worry...</p>
<pre><code>d={1:[1,2,3],2:[4,5,6]}
list(itertools.chain(*(
      ["{}_{}".format(k,i) for i in l]
      for (k,l) in d.items() )))
</code></pre>
<p>This is a little more complex. We again take key,value pairs from the dictionary, then make an inner loop over the list that was the value and format those into strings. This produces inner sequences, so we flatten it using chain and *, and finally save the result as one list. </p>
<p>Edit: Turns out Python 3.4.3 gets quite confused when doing this nested as generator expressions; I had to turn the inner one into a list, or it would replace some combination of k and l before doing the formatting. </p>
<p>Edit again: As someone posted in a since deleted answer (which confuses me), I'm overcomplicating things. You can do the flattened nesting in a chained comprehension:</p>
<pre><code>["{}_{}".format(k,v) for k,l in d.items() for v in l]
</code></pre>
<p>That method was also posted by Jean-François Fabre. </p>
</div>
<div class="post-text" itemprop="text">
<p>Use list comprehensions like this</p>
<pre><code>d = {"test1":[1,2,3,],"test2":[4,5,6],"test3":[7,8,9]}

new_list = [str(item[0])+'_'+str(v) for item in d.items() for v in item[1]]
</code></pre>
<p>Output：</p>
<pre><code>new_list:
['test1_1',
 'test1_2',
 'test1_3',
 'test3_7',
 'test3_8',
 'test3_9',
 'test2_4',
 'test2_5',
 'test2_6']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's initialize our data</p>
<pre><code>In [1]: l0 = [1, 2, 3, 4]

In [2]: l1 = [10, 20, 30, 40]

In [3]: d = {'name0': l0, 'name1': l1}
</code></pre>
<p>Note that in my example, different from yours, the lists' content is not strings... aren't lists heterogeneous containers?</p>
<p>That said, you cannot simply join the keys and the list's items, you'd better cast these value to strings using the <code>str(...)</code> builtin.</p>
<p>Now it comes the solution to your problem... I use a list comprehension
with two loops, the outer loop comes first and it is on the items (i.e., key-value couples) in the dictionary, the inner loop comes second and it is on the items in the corresponding list.</p>
<pre><code>In [4]: res = ['_'.join((str(k), str(i))) for k, l in d.items() for i in l]

In [5]: print(res)
['name0_1', 'name0_2', 'name0_3', 'name0_4', 'name1_10', 'name1_20', 'name1_30', 'name1_40']

In [6]: 
</code></pre>
<p>In your case, using <code>str(k)+'_'+str(i)</code> would be fine as well, but the current idiom for joining strings with a fixed <code>'text'</code> is the <code>'text'.join(...)</code> method.  Note that <code>.join</code> takes a SINGLE argument, an iterable, and hence in the list comprehension I used <code>join((..., ...))</code>
to collect the joinands in a single argument.</p>
</div>
<span class="comment-copy">thank you so much for your help! I'm pretty new to Python so I appreciate your explanation and solution! :)</span>
<span class="comment-copy">It's not that values() is a generator; it's that values aren't keys. In his case, they're lists, which aren't hashable and thus <i>can't</i> be keys, so he gets a type error instead of a key error.</span>
<span class="comment-copy">I worded it poorly; it should say "is" rather than "returns".</span>
<span class="comment-copy">post scriptum — As others have said in their answers, you have NO GUARANTEE about any particular order of the <code>k, l</code> items retrieved in  the outer loop.</span>
