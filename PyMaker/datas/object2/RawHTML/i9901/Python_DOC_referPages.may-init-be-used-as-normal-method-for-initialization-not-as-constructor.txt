<div class="post-text" itemprop="text">
<p>Sometimes it looks reasonable to use <code>__init__</code> as initialization method for already existing object, i.e.:</p>
<pre><code>class A():
    def __init__(self, x):
        self.x = x

    def set_state_from_file(self, file):
        x = parse_file(file)
        self.__init__(x)
</code></pre>
<p>As alternative to this implementation I see the following:</p>
<pre><code>class A():
    def __init__(self, x):
        self.init(x)        

    def init(self, x):
        self.x = x

    def set_state_from_file(self, file):
        x = parse_file(file)
        self.init(x)
</code></pre>
<p>It seems to me as over-complication of code. Is there any guideline on this situation?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__init__</code> is not a constructor. It is an initialisation method, called <em>after</em> the instance was already constructed for you (the actual constructor method is called <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__()</code></a>).</p>
<p>You can always call it again from your code if you need to re-initialise, this isn't a style violation. In fact, it is used in the Python standard library; see the <a href="https://hg.python.org/cpython/file/3.5/Lib/multiprocessing/heap.py#l223" rel="nofollow noreferrer"><code>multiprocessing.heap.Heap()</code> implementation</a> for example:</p>
<pre><code>def malloc(self, size):
    # return a block of right size (possibly rounded up)
    assert 0 &lt;= size &lt; sys.maxsize
    if os.getpid() != self._lastpid:
        self.__init__()                     # reinitialize after fork
</code></pre>
<p>or the <a href="https://hg.python.org/cpython/file/3.5/Lib/_threading_local.py#l194" rel="nofollow noreferrer"><code>threading.local</code> implementation</a>, which uses a context manager to defer initialisation.</p>
<p>There is otherwise nothing special about the <code>__init__</code> method itself. It is merely automatically called by <code>type.__call__</code> (after creating the instance with <code>instance = cls.__new__(cls, *args, **kwargs)</code>, <code>cls.__init__(instance, *args, **kwargs)</code> is called if it is available).</p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to Martjin's answer: a common pattern in Python is to use classmethods as factory methods, ie:</p>
<pre><code>class A():
    def __init__(self, x):
        self.x = x

    @classmethod
    def from_file(cls, file):
        x = parse_file(file)
        return cls(x)


a1 = A(42)
a2 = A.from_file(open("/path/to/file"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found some differences between <code>__init__</code> and 'normal' methods:</p>
<p>1., <code>__init__</code> is not allowed to return anything: TypeError will be raised.</p>
<p>2., If <code>__init__</code> raises error, <code>__del__</code> will be called:
UPDATE by Martijn Pieters: this is only for constructor calls, not for generic usage, see comments below.</p>
<pre><code> class A(object):
     def __init__(self):
           print('__init__')
           raise ValueError('__init__ error')
           pass

    def method(self):
        raise ValueError('method error')

    def __del__(self):
        print("__del__")

def main():
    try:
        a = A()
        a.method()
    except ValueError as e:
        print(e)
    print('exit main')

if __name__ == '__main__':
    main()
    print('end of file')
</code></pre>
<p>will output:</p>
<pre><code>__init__
__init__ error
__del__
exit main
end of file
</code></pre>
</div>
<span class="comment-copy">Why not have a non-member function to parse the file, and create a new instance? It seems you'd have to re-write the class each time you wanted to initialise it from a different source, which violates the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="nofollow noreferrer">Single Responsibility Principle</a>.</span>
<span class="comment-copy">@Peter Wood, what about <code>__init__</code> in <code>__setstate__</code>?</span>
<span class="comment-copy">-----------------------------------</span>
<span class="comment-copy">@Sklavit then obviously the "classmethod as alternate constructor" pattern is not what you need &lt;g&gt;</span>
<span class="comment-copy">What has this got to do with reusing the <code>__init__</code> method on an existing instance?</span>
<span class="comment-copy">@Martijn Pieters this answer is also the answer for the question above.</span>
<span class="comment-copy">@MartijnPieters I've seen peoples reusing <code>__init__</code> from another method when what they really wanted was an alternate constructor...</span>
<span class="comment-copy">Yes, of course the new instance will be cleared; an exception during construction (which includes calling the <code>__init__</code> initialiser) means the new object can't be returned; the exception broke the normal flow, no assignment takes place, and no references are left. If you used <code>inst = A.__new__(A)</code> and <code>inst.__init__()</code> you would still have a reference to the object and <code>__del__</code> would <i>not</i> be called. This has nothing to do with <code>__init__</code>, it is a normal method.</span>
<span class="comment-copy">I'm not sure what all this has to do with reusing the <code>__init__</code> method on an existing instance however.</span>
<span class="comment-copy">Also, the <code>TypeError</code> is thrown by the code that calls <code>__init__</code>; the method is not special, only the caller is (but no more so that other code that uses special methods that break their agreed-to contract; try returning something other than a string from <code>__str__</code> for example). Call the <code>__init__</code> method directly and nothing happens if you returned something from it other than <code>None</code>.</span>
<span class="comment-copy">@ Martijn Pieters, you are right. Just add this comment to your answer and it will be the best and accepted.</span>
<span class="comment-copy">I'm not sure that details on how <code>__init__</code> is being called when a new instance is created matter to your style question. Your question certainly didn't try to return something from <code>__init__</code>, and any code that tried to conditionally return something would be rather confusing. At that point factoring out the portion that needs to return something would be a much better choice.</span>
