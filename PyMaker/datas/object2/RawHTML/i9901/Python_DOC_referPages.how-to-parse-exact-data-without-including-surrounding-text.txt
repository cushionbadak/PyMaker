<div class="post-text" itemprop="text">
<p>My code is very close to succeeding but I just need a little help. </p>
<p>I have 100's of pages of data but I am working on parsing only 1 page perfectly before I apply it to the others. In this one page, which is an email, I need to extract several things: a Date, Sector, Fish Species, Pounds, and Money. So far I have been successful in using RegularExpressions to recognize certain words and extract the data from that line: such as looking for "Sent" because I know the Date information will always follow that, and looking for either "Pounds" or "lbs" because the Pounds information will always precede that.</p>
<p>The problem I am having is that my code is grabbing the entire line that the data is on, not just the numeric data. I want to grab just the number value for Pounds, for example, but I realize this will be extremely difficult because every one of the 100's of emails is worded differently. I'm not sure if it is even possible to make this code foolproof because I need RegEx to recognize the text that surrounds the data, but not include it in my export command. So will I simply be blindly grabbing at characters following certain recognized words?</p>
<p>Here is a piece of my code used for extracting the Pounds data:</p>
<pre><code>for filename in os.listdir(path):
    file_path = os.path.join(path, filename)
    if os.path.isfile(file_path):
        with open(file_path, 'r') as f:
            sector_result = []
            pattern = re.compile("Pounds | lbs", re.IGNORECASE)
            for linenum, line in enumerate(f):
            if pattern.search(line) != None:
                sector_result.append((linenum, line.rstrip('\n')))
                for linenum, line in sector_result:
                    print ("Pounds:", line)
</code></pre>
<p>And here is what it prints out:</p>
<pre><code>Pounds: -GOM Cod up to 5,000 lbs (live wt) @ 1.40 lbs
Pounds: -GOM Cod up to 5,000 lbs (live wt) @ 1.40 lbs
Pounds: -American Plaice 2,000 lbs      .60 lbs or best offer
</code></pre>
<p>Ideally I would just like the 5,000 lb numeric value to be exported but I am not sure how I would go about grabbing just that number. </p>
<p>Here is the original email text I need to parse:</p>
<pre><code>From: 
Sent: Friday, November 15, 2013 2:43pm
To: 

Subject: NEFS 11 fish for lease

Greetings,

NEFS 11 has the following fish for lease:

-GOM Cod up to 5,000 lbs (live wt) @ 1.40 lbs
-American Plaice 2,000 lbs      .60 lbs or best offer
</code></pre>
<p>Here is another separate email though that will need to be parsed; this is why writing this code is difficult because it'll have to tackle a variety of differently worded emails, since all are written by different people: </p>
<pre><code>From:
Sent: Monday, December 09, 2013 1:13pm
To:

Subject: NEFS 6 Stocks for lease October 28 2013

Hi All,

The following is available from NEFS VI:

4,000  lbs. GBE COD (live wt)

10,000 lbs. SNE Winter Flounder

10,000 lbs. SNE Yellowtail

10,000 lbs GB Winter Flounder

Will lease for cash or trade for GOM YT, GOM Cod, Dabs, Grey sole stocks on equitable basis.  

Please forward all offers.

Thank you,
</code></pre>
<p><a href="https://i.stack.imgur.com/XBb4U.png" rel="nofollow noreferrer"><img alt="And here is another image of data that can be found in the emails...I can handle parsing the written txt in the body of emails, I can handle parsing the attached PDFs, but I am completely lost with how to handle these. So any ideas anyone has I'm all ears" src="https://i.stack.imgur.com/XBb4U.png"/></a></p>
<p>Any and all help is appreciated, as well as question asking criticism. Thanks. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a regex flexible enough:</p>
<pre><code>for filename in os.listdir(path):
    file_path = os.path.join(path, filename)
    if os.path.isfile(file_path):
        with open(file_path, 'r') as f:
            pattern = r'(\d[\d,.]+)\s*(?:lbs|[Pp]ounds)'
            content = f.read()

            ### if you want only the first match ###
            match = re.search(pattern, content)
            if match:
                print(match.group(1))

            ### if you want all the matches ###
            matches = re.findall(pattern, content)
            if matches:
                print(matches)
</code></pre>
<p>You could be more thorough with the regex if needed.</p>
<p>Hope this helps!</p>
<p><strong>UPDATE</strong></p>
<p>The main part here is the regular expression <code>(\d[\d,.]+)\s*(?:lbs|[Pp]ounds)</code>. This is a basic one, explained as follows:</p>
<pre><code>(                      
    \d                 -&gt; Start with any digit character
    [\d,.]+            -&gt; Followed by either other digits or commas or dots
)                      
\s*                    -&gt; Followed by zero or more spaces
(?:                    
    lbs|[Pp]ounds      -&gt; Followed by either 'lbs' or 'Pounds' or 'pounds'
)                      
</code></pre>
<p>The parenthesis define the capturing group, so <code>(\d[\d,.]+)</code> is the stuff being captured, so basically the numeric part. </p>
<p>The parenthesis with a <code>?:</code> define a non-capturing group.  </p>
<p>This regex will match:</p>
<ul>
<li>2,890 lbs (capturing '2,890')</li>
<li>3.6 pounds (capturing '3.6')</li>
<li>5678829 Pounds</li>
<li>23       lbs</li>
<li>9,894Pounds</li>
<li>etc</li>
</ul>
<p>As well as unwanted stuff like:</p>
<ul>
<li>2..... lbs</li>
<li>3,4,6,7,8 pounds</li>
</ul>
<p>It will not match:</p>
<ul>
<li>7,423</li>
<li>23m lbs</li>
<li>45 ppounds</li>
<li>2.8 Pound</li>
</ul>
<p>You could make a much more complicated regex depending on the complexity of the contents you have. I would think this regex is good enough for your purposes.</p>
<p>Hope this helps clarify</p>
</div>
<div class="post-text" itemprop="text">
<p>Regex can recognize and <strong>not</strong> export text around a value, this is called a non-capturing group. For example:</p>
<p><code>Pounds: -GOM Cod up to 5,000 lbs (live wt) @ 1.40 lbs</code></p>
<p>To recognize, <code>up to</code>, the value you want, and <code>(live wt)</code> you could write a regex like this:</p>
<pre><code>(?: up to).(\d+,\d+.lbs).(?:\(live wt\))
</code></pre>
<p>Essentially <code>(?:)</code> is a matching group that isn't captured, so the regex only captures the middle bracketed group.</p>
<p>If you provide the exact surrounding text you want I can be more specific. </p>
<p><strong>Edit:</strong></p>
<p>Going off your new examples I can see that the only similarity between all examples is that you have a number (in the thousands so it has a <code>,</code>), followed by some amount of whitespace, followed by <code>lbs</code>. So your regex would look like:</p>
<pre><code>(?:(\d+,\d+)\s+lbs)
</code></pre>
<p>This will return the matches of the numbers themselves. You can see an example it working <a href="https://regex101.com/r/DTr5db/3" rel="nofollow noreferrer">here</a>. This regex will exclude the smaller values, by virtue of ignoring values that are not in the thousands (i.e. that do not contain a <code>,</code>).</p>
<p><strong>Edit 2:</strong> </p>
<p>Also I'd figure I'd point out that this can be done entirely without regex using <a href="https://docs.python.org/3/library/string.html" rel="nofollow noreferrer">str.split()</a>. Instead of trying to find a particular word pattern, you can just use the fact that the number you want will be the word before <code>lbs</code>, i.e. if <code>lbs</code> is at position <code>i</code>, then your number is at position <code>i-1</code>. </p>
<p>The only other consideration you have to face is how to deal with multiple values, the two obvious ones are:</p>
<ol>
<li>Biggest value.</li>
<li>First value.</li>
</ol>
<p>Here's how both cases would work with your original code:</p>
<pre><code>def max_pounds(line):
    pound_values = {}
    words = line.split()
    for i, word in enumerate(words):
        if word.lower() == 'lbs':
            # Convert the number into an float
            # And save the original string representation.
            pound_values[(float(words[i-1].replace(',','')))] = words[i-1]
    # Print the biggest numerical number.
    print(pound_values[max(pound_values.keys())])

def first_pounds(line):
    words = line.split()
    for i, word in enumerate(words):
        if word.lower() == 'lbs':
            # print the number and exit.
            print(words[i-1])
            return

for filename in os.listdir(path):
    file_path = os.path.join(path, filename)
    if os.path.isfile(file_path):
        with open(file_path, 'r') as f:
            sector_result = []
            pattern = re.compile("Pounds | lbs", re.IGNORECASE)
            for linenum, line in enumerate(f):
            if pattern.search(line) != None:
                sector_result.append((linenum, line.rstrip('\n')))
                for linenum, line in sector_result:
                    print ("Pounds:", line)
                    # Only one function is required.
                    max_pounds(line)
                    first_pounts(line)
</code></pre>
<p>The one caveat is that the code doesn't handle the edge case where <code>lbs</code> is the first word, but this is easily handled with a <code>try-catch</code>.</p>
<p>Neither regex or split will work if the value before <code>lbs</code> is something other than the number. If you run into that problem I would suggest searching your data for offending emails - and if the number is small enough editing them by hand. </p>
</div>
<span class="comment-copy">Please provide a sample or snippet of your source data that you are trying to parse.</span>
<span class="comment-copy">I have added the original email message. What makes this entire project difficult is that every email will not look like that, simply because they are all written by different people.</span>
<span class="comment-copy">So can you briefly explain your code to me so I understand it... As you have written it it'll recognize the word Pounds, I can see that, but then what will it capture exactly? The first (or all) occurrence of the word Pounds in the txt file? Or will it capture just (and only just) the numeric value before or after the word Pounds? In this case the 5,000 or 2,000....</span>
<span class="comment-copy">Updated the answer with some more explanation. Hope it helps</span>
<span class="comment-copy">That is an amazing clarification, thank you so much, RegEx has always been super complex to me but you've helped a lot. I tried using your code and it is almost perfect......when I ran the code that is used to find all the matches (the re.findall code) it captured the 5000 and 2000 pound values, but it also captured the 1.40 and .60 dollar amounts too... is there anyway to exclude those? Or rather, a way to only grab the number-characters directly adjacent to the key word Pounds?</span>
<span class="comment-copy">I'm not sure if I'm understanding correctly. You want to capture the number adjacent to the key word <code>Pounds</code>, but that word doesn't even appear in the two emails you attached. What we could do is to capture only the first occurrence in each sentence, would that help?</span>
<span class="comment-copy">Hmm well what I meant was capture the number adjacent to either the keyword "pounds" or "lbs" since both options occur. By first occurrence though do you mean first occurrence of a number? Because sometimes the first number will be a dollar amount</span>
<span class="comment-copy">That makes perfect sense. That technique would work perfectly if every email was surrounded by the same words, but as you can see in just the two examples above that I edited in, each one is different. Some (as above) will only have the "lbs" after the numeric value....if that is the case is there a way to recognize the "lbs" and then capture the number directly before it? Will that be a blind grab that might grab more or less than the desired 4,000 ?</span>
<span class="comment-copy">I've updated my answer to specifically capture <code>lbs</code> and the previous number, regardless of the amount of whitespace between the number and <code>lbs</code>. Let me know if you need anything more complicated!</span>
<span class="comment-copy">I've also added a non-regex method in case you feel more comfortable with it.</span>
<span class="comment-copy">That is honestly a very smart way to go about solving this, RegEx really does have endless possibilities.. the only thing with that method though is wouldn't it also capture the price? Since it's price per pound it'll be "@ 1.40 lbs" and won't that code also then capture the 1.40?</span>
<span class="comment-copy">I know some of the weights will be less than 1,000 but I'm not sure if it's a significant enough amount to warrant changing up all the code. I will need prices though, as well as dates, sectors, fish species, etc but I think I have that under control.... I just simply changed what the compiler is looking for, so instead of "Pounds or lbs" I have it searching for one of the 20-30 fish species, or for price I have it searching for "Price or @ or $"....but as with weights, it was grabbing the whole line, but I think now I can apply what you've provided me to fix it all</span>
