<div class="post-text" itemprop="text">
<pre><code>def ListNum(x):
    list1 = []
    for i in (x):
        if x[i] &lt; x [i + 1]:
            list1.append[i]
        else:
            break
    return(list1)
ListNum([1,2,3,4,5,6,2,3,4])
</code></pre>
<p>So, I input a list of numbers and go through the list and check if the first value in that list is less than the second value if so add it to <code>list1</code>, carry on until the value is greater than the next value.</p>
<p>So, if I input <code>ListNum([1,2,3,4,5,6,2,3,4])</code></p>
<p>i should get <code>list1[1,2,3,4,5,6]</code></p>
<p>but its not working</p>
</div>
<div class="post-text" itemprop="text">
<p>I assume that you <em>never</em> want to add the last item in <code>x</code> to <code>list1</code> because there isn't an item after it to compare it with.</p>
<p>Your code doesn't work properly because <code>for i in (x):</code> iterates over the <em>items</em> in <code>x</code>, not their indices. But even if it did iterate over the  indices your code could crash with an <code>IndexError</code> because it could attempt to compare the last item in the list with the item after it, which doesn't exist</p>
<p>Here are several ways to do this.</p>
<pre><code>from itertools import takewhile

def list_nums0(x):
    list1 = []
    for i in range(len(x) - 1):
        if x[i] &lt; x[i + 1]:
            list1.append(x[i])
        else:
            break
    return list1

def list_nums1(x):
    list1 = []
    for u, v in zip(x, x[1:]):
        if u &lt; v:
            list1.append(u)
        else:
            break
    return list1

def list_nums2(x):
    list1 = []
    for i, u in enumerate(x[:-1], 1):
        if u &lt; x[i]:
            list1.append(u)
        else:
            break
    return list1

def list_nums3(x):
    return [t[0] for t in takewhile((lambda a:a[0] &lt; a[1]), zip(x, x[1:]))]

list_nums = list_nums3
print(list_nums([1,2,3,4,5,6,2,3,4]))
</code></pre>
<p><strong>output</strong></p>
<pre><code>[1, 2, 3, 4, 5]
</code></pre>
<p><code>list_nums0</code> simply iterates over the indices of <code>x</code>. </p>
<p><code>list_nums1</code> uses <code>zip</code> to iterate in parallel over <code>x</code> and <code>x[1:]</code>. This puts the current &amp; next items into <code>u</code> and <code>v</code>.</p>
<p><code>list_nums2</code> uses <code>enumerate</code> to get the current item in <code>u</code> and the index of the next item in <code>i</code>.</p>
<p><code>list_nums3</code> uses <code>takewhile</code> to iterate over the tuples yielded by <code>zip</code> until we get a pair of items that don't satisfy the test. It performs the whole operation in a list comprehension, which is slightly more efficient that using <code>.append</code> in a traditional <code>for</code> loop. </p>
<hr/>
<p>Here are versions that also add the last item in the list if we get that far. The simple way to do this is to create a new temporary list that has a last item guaranteed to be greater than the "real" last item. </p>
<pre><code>from itertools import takewhile

def list_nums0(x):
    x = x + [x[-1] + 1]
    list1 = []
    for i in range(len(x) - 1):
        if x[i] &lt; x[i + 1]:
            list1.append(x[i])
        else:
            break
    return list1

def list_nums1(x):
    list1 = []
    for u, v in zip(x, x[1:] + [x[-1] + 1]):
        if u &lt; v:
            list1.append(u)
        else:
            break
    return list1

def list_nums2(x):
    x = x + [x[-1] + 1]
    list1 = []
    for i, u in enumerate(x[:-1], 1):
        if u &lt; x[i]:
            list1.append(u)
        else:
            break
    return list1

def list_nums3(x):
    return [t[0] for t in takewhile((lambda a:a[0] &lt; a[1]), zip(x, x[1:] + [x[-1] + 1]))]

# test all the functions

funcs = (
    list_nums0,
    list_nums1,
    list_nums2,
    list_nums3,
)

data = [1, 2, 3, 4, 5, 6, 0]
print('data', data)
for i, list_nums in enumerate(funcs):
    print(i, list_nums(data))

data = [1, 2, 3, 4, 5, 6]
print('data', data)
for i, list_nums in enumerate(funcs):
    print(i, list_nums(data))
</code></pre>
<p><strong>output</strong></p>
<pre><code>data [1, 2, 3, 4, 5, 6, 0]
0 [1, 2, 3, 4, 5]
1 [1, 2, 3, 4, 5]
2 [1, 2, 3, 4, 5]
3 [1, 2, 3, 4, 5]
data [1, 2, 3, 4, 5, 6]
0 [1, 2, 3, 4, 5, 6]
1 [1, 2, 3, 4, 5, 6]
2 [1, 2, 3, 4, 5, 6]
3 [1, 2, 3, 4, 5, 6]
</code></pre>
<p>Of course, this strategy will fail if you pass an empty list. The simple way around that is to put this at the top of the function:</p>
<pre><code>if not x:
    return []
</code></pre>
<p>Eg,</p>
<pre><code>def list_nums1(x):
    if not x:
        return []
    list1 = []
    for u, v in zip(x, x[1:] + [x[-1] + 1]):
        if u &lt; v:
            list1.append(u)
        else:
            break
    return list1
</code></pre>
<p>We can rewrite <code>list_nums3</code> like this to keep it a one-liner:</p>
<pre><code>def list_nums3(x):
    return [] if not x else [t[0] for t in takewhile((lambda a:a[0] &lt; a[1]), zip(x, x[1:] + [x[-1] + 1]))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need the indexes, you can zip your list like this:</p>
<pre><code>def ListNum(x):
    list1 = []
    for e1, e2 in zip(x, x[1:]):
        if e1 &lt; e2:
            list1.append(e1)
        else:
            break
    return list1
</code></pre>
<p>This also has the benefit of fixing the bug when the list is sorted.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you do <code>for i in x</code>, you iterate through elements in <code>x</code>, not their indexes.</p>
<p>To iterate through indexes, you have to do <code>for i in range(len(x))</code>.</p>
</div>
<span class="comment-copy">Should <code>ListNum([1,2,3,4])</code> return <code>[1,2,3,4]</code> or just <code>[1,2,3]</code> ?</span>
<span class="comment-copy">What result are you getting? Is it an error message?</span>
<span class="comment-copy">so if you enter ListNum([1,2,3,4]) it should return [1,2,3,4]</span>
<span class="comment-copy">what about the 6? [1, 2, 3, 4, 5, 6]</span>
<span class="comment-copy">@adam In <code>[1,2,3,4,5,6,2,3,4]</code>, 6 is not less than the following item 2, so we don't copy it to the new list and we break out of the loop.</span>
<span class="comment-copy">@adam: Ok I just saw your new comment on the question. Give me a couple of minutes...</span>
<span class="comment-copy">@adam: Please see my updated answer.</span>
<span class="comment-copy">this works, but do you mind explain how the zip works. Never used it before. (also, thank you! I'm very grateful )</span>
<span class="comment-copy">@adam: See <a href="https://docs.python.org/3.3/library/functions.html#zip" rel="nofollow noreferrer">the docs for <code>zip</code></a>. Also see the related function <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a>.</span>
<span class="comment-copy">Why not <code>for index, value in enumerate(x)</code> ?</span>
<span class="comment-copy">That's another option, although I'd do <code>for index, _ in enumerate(list1)</code> because <code>value</code> is not used.</span>
<span class="comment-copy">@yper the value <i>is</i> use... it is appended to <code>list1</code></span>
<span class="comment-copy">@juanpa.arrivillaga OP meant to use <code>i</code> as index, not value. See the result he wants.</span>
<span class="comment-copy">@yper The OP's code is all sorts of confused. <code>.append[i]</code> will throw an error anyway. I can only <i>assume</i> OP means to add the value due to this: "go through the list and check if the first value in that list is less than the second value if so add it to list1"</span>
