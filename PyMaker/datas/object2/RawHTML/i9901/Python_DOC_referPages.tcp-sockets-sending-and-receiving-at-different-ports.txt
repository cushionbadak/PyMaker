<div class="post-text" itemprop="text">
<p>I try to write a python script (3.5.2) that uses nonblocking tcp sockets. The sockets receive data from an application, does some conversion stuff and sends it back to that application. Because the conversion could take some time it should be async. Furthermore my application is not able to send and receive data at the same port. So my idea is to send the data from my application via port 4711 (just an example) to my python script and send the results back via port 4712.</p>
<p>Up to now I did not work with python or sockets at all. My question is about architecture. I want to ensure that my script can receive data all the time via 4711 (several different tasks), is working on that data (if there is something to do) and sends the data back via 4712 - everything async. So my application is able to send a big work load (several tasks) and as soon as the result(s) are ready send it back, one by one.</p>
<p>I am a bit overhelmed at the moment about sockets and I dont know how to ensure that the receiving and sending does not block itself or the conversion process etc. Can someone provide a description or an example how this has to look like?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>My question is about architecture.</p>
</blockquote>
<h1>1. <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a></h1>
<p>Use <code>asyncio</code> concurrent network communications. Run event loop with <a href="https://github.com/MagicStack/uvloop" rel="nofollow noreferrer">uvloop</a>.</p>
<h1>2. Any MQ solution</h1>
<p>RabbitMQ, ZeroMQ, etc, any of them will allow you to place new tasks in the queue and run as many workers to make computations as you want.</p>
</div>
<span class="comment-copy">I donâ€™t quite get why you require to use different ports. TCP does the multiplexing for you. Each client which connects to your python server will give a different socket. You could then fork off a process/spawn a thread to handle the request and send the response back on the socket for the connection. New connections can be accepted at any time on the server socket. Is this lack of understanding of sockets on your side, or am I missing something which makes this design impossible for you and <i>requires</i> to use different ports?</span>
<span class="comment-copy">I think there is both correct. I have I lack of knowledge. :) But there is really a reason for this. The application I use (its a third party application, not developed by me) I just able to send data by a defined port. If it should listen I have to choose a different port. There could not be a data sink and a data source at the same port...</span>
<span class="comment-copy">I already saw RabbitMQ and that is actually a really good option. The problem is that the application that provides the data (third party solution, not developed by me) does not support MQs at all. The only good solution seems to be tcp sockets.  Does asyncio communicate over tcp sockets? I have to dive into the topic but if there are prerequisites I think that I cannot use this.</span>
<span class="comment-copy">@Stefan just as you sad, "the application that provides the data" you have to write an app that will listen for the socket connection and answer as usually, but <code>asyncio</code> can not handle long running tasks this is where RabbitMQ doing his job by sending data to processing to task queue, some workers will handle it and place to output queue, then you will listen output queue with <code>asyncio</code> and will respond to client with processed data.</span>
<span class="comment-copy">Ah, ok, I think now I got it. The application conntects to an tcp socket and transfers the data. This data is put to a queue to store it until it will be processed. After processing I can send it again to the queue. The next script reads this queue and sends it over tcp to my application. Do you mean that? Ok, seems to be a bit complicated because of this tcp and queue writing/reading but it could indeed solve my problem.</span>
<span class="comment-copy">@Stefan I did not take into account anything except how to optimize performance, and IMHO it is one of the most robust solutions that will provide high performance with scalability.</span>
<span class="comment-copy">Ok, thank you very much for you input!</span>
