<div class="post-text" itemprop="text">
<p>Does <code>obj == iter(obj)</code> imply that <code>obj</code> isn't repeatedly iterable and vice versa? I didn't see any such wording in the docs, but according to <a href="https://stackoverflow.com/questions/9884132/what-exactly-are-pythons-iterator-iterable-and-iteration-protocols#comment62722931_9884259">this comment</a>, the standard library checks if an object is <em>repeatedly iterable</em> <a href="https://hg.python.org/cpython/file/ce31ee3b1e69/Lib/statistics.py#l551" rel="nofollow noreferrer">by testing <code>if iter(obj) is obj</code></a>:</p>
<blockquote>
<p>@agf: There are parts of the Python standard library that rely on this part of the spec; <a href="https://hg.python.org/cpython/file/ce31ee3b1e69/Lib/statistics.py#l551" rel="nofollow noreferrer">they detect whether something is an iterator/generator by testing <code>if iter(obj) is obj:</code></a>, because a true iterator/generator object will have <code>__iter__</code> defined as the identity function. If the test is true, they convert to <code>list</code> to allow repeated iteration, otherwise, it's assumed that the object is repeatably iterable, and they can use it as is.<br/>
  – <a href="https://stackoverflow.com/users/364696/shadowranger">ShadowRanger</a> <a href="https://stackoverflow.com/questions/9884132/what-exactly-are-pythons-iterator-iterable-and-iteration-protocols#comment62722931_9884259">Jun 3 at 17:23</a> </p>
</blockquote>
<p>The docs do state that if <code>obj</code> is an iterator, it's required that <code>iter(obj)</code> returns <code>obj</code>. But I don't think that's enough to conclude that non-repeatedly iterable objects can be identified using <code>iter(obj) is obj</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>All iterators are iterables, but not all iterables are iterators.</p>
<p>The only <a href="https://docs.python.org/3/library/stdtypes.html#container.__iter__" rel="noreferrer">requirement</a> of an iterable is that it defines an <code>__iter__()</code> method which returns an iterator:</p>
<blockquote>
<p>One method needs to be defined for container objects to provide iteration support:</p>
<p><strong><code>container.__iter__()</code></strong><br/>
  Return an iterator object.</p>
</blockquote>
<p>An <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="noreferrer">iterator</a> must follow the <em>iterator protocol</em>, which has two requirements:</p>
<ol>
<li><p>It has an <code>__iter__()</code> method <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__iter__" rel="noreferrer">that returns the object itself</a>:</p>
<blockquote>
<p><strong><code>iterator.__iter__()</code></strong><br/>
  Return the iterator object itself.</p>
</blockquote></li>
<li><p>It has a <code>__next__()</code> method which returns the next item on each call, and, once exhausted, raises <code>StopIteration</code> <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="noreferrer">on every subsequent call</a>:</p>
<blockquote>
<p>Once an iterator’s <code>__next__()</code> method raises <code>StopIteration</code>, it must continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken.</p>
</blockquote></li>
</ol>
<p>These requirements mean that iterators are never repeatable, and that you can always confirm that an iterable is an iterator (and therefore unrepeatable by definition) by confirming that <code>iter(obj) is obj</code> is <code>True</code>:</p>
<pre><code>def is_unrepeatable(obj):
    return iter(obj) is obj
</code></pre>
<p><strong>However:</strong> since the only requirement of an iterable is that <code>iter(obj)</code> returns <em>some</em> iterator, you <em>can't</em> prove that it <em>is</em> repeatable. An iterable could define an <code>__iter__()</code> method which returns an iterator with different behaviour each time it's called: for instance, it could return an iterator which iterates over its elements the first time it's called, but on subsequent calls, return an iterator which immediately raises <code>StopIteration</code>.</p>
<p>This behaviour would be strange (and annoying), but is not prohibited. Here's an example of a non-repeatable iterable class which is not an iterator:</p>
<pre><code>class Unrepeatable:

    def __init__(self, iterable):
        self.iterable = iterable
        self.exhausted = False

    def __iter__(self):
        if self.exhausted:
            return
        else:
            self.exhausted = True
            yield from self.iterable
</code></pre>
<p></p>
<pre><code>&gt;&gt;&gt; x = Unrepeatable([1,2,3])
&gt;&gt;&gt; list(x)
[1, 2, 3]
&gt;&gt;&gt; list(x)
[]
&gt;&gt;&gt; iter(x) is x
False
&gt;&gt;&gt; 
</code></pre>
<p>I wouldn't hesitate to call such a "fake iterator" badly-behaved, and I can't think of a situation where you'd find one in the wild, but as demonstrated above, it is possible.</p>
</div>
<span class="comment-copy">To go further: while it's trivial to come up with a pathological counter-example, I think it's safe to assume "<code>iter(obj) is not obj</code> &lt;=&gt; obj is reiterable" in practice. See this <a href="https://mail.python.org/pipermail/python-ideas/2013-September/023241.html" rel="nofollow noreferrer">discussion</a> by core python devs on this very issue. I've not seen an example of a non-reiterable, non-iterator iterable that isn't also either useless or nonsensical.</span>
<span class="comment-copy">@shadydog: At least on Python 2.7, <code>urllib.urlopen</code> is a real-world counterexample. It returns an object with <code>iter(obj) is not obj</code>, but with file-like one-shot iteration behavior. I don't know if the Python 3 equivalent behaves the same. <code>iter(x) is iter(x)</code> is a slightly more reliable check that catches <code>urllib.urlopen</code>; I don't know of anything it fails on that anyone actually uses, but it still can't catch everything.</span>
