<div class="post-text" itemprop="text">
<p>I have a problem shown below that wants to find the quickest way to get between any two points by using only the moves of a knight in chess. My first thought was to us the <code>A*</code> algorithm or <code>Dijkstra's</code> algorithm however, <strong>I don't know how to make sure only the moves of a knight are used.</strong> I would appreciate it if you could suggest a better algorithm or just some tips to help me. Thank you.</p>
<blockquote>
<p>Write a function called answer(src, dest) which takes in two parameters: the source square, on which you start, and the destination square, which is where you need to land to solve the puzzle.  The function should return an integer representing the smallest number of moves it will take for you to travel from the source square to the destination square using a chess knight's moves (that is, two squares in any direction immediately followed by one square perpendicular to that direction, or vice versa, in an "L" shape).  Both the source and destination squares will be an integer between 0 and 63, inclusive, and are numbered like the example chessboard below:</p>
</blockquote>
<pre>
-------------------------
| 0| 1| 2| 3| 4| 5| 6| 7|
-------------------------
| 8| 9|10|11|12|13|14|15|
-------------------------
|16|17|18|19|20|21|22|23|
-------------------------
|24|25|26|27|28|29|30|31|
-------------------------
|32|33|34|35|36|37|38|39|
-------------------------
|40|41|42|43|44|45|46|47|
-------------------------
|48|49|50|51|52|53|54|55|
-------------------------
|56|57|58|59|60|61|62|63|
-------------------------
</pre>
</div>
<div class="post-text" itemprop="text">
<p>Approach the problem in the following way:</p>
<p><strong>Step 1</strong>: Construct a graph where each square of the chess board is a vertex.</p>
<p><strong>Step 2</strong>: Place an edge between vertices exactly when there is a single knight-move from one square to another.</p>
<p><strong>Step 3</strong>: Apply Dijkstra's algorithm. Dijkstra's algorithm is an algorithm to find the length of a path between two vertices (squares).</p>
</div>
<div class="post-text" itemprop="text">
<p>For this problem, simply doing a breadth-first search is enough (Dijkstra and BFS work in same way for unweighted graphs). To ensure that only the chess knight's moves are used, you'll have to define the moves in a proper way.</p>
<p>Notice that a chess knight moves two squares to any direction, then one square perpendicular to that. This means it can move two squares left of right then one square up or down, or two squares up or down then one square left or right.</p>
<p>The calculation will be much easier if you identify the cells by rows (0 - 7) and columns (0 - 7) instead of 0 - 63. This can be done easily by dividing the cell index by 8 and using the quotient and remainder as row and column indices. So, if the knight is at position <code>(x, y)</code> now, its next possible positions can be any of <code>(x - 2, y - 1), (x - 2, y + 1), (x + 2, y - 1), (x + 2, y + 1), (x - 1, y - 2), (x - 1, y + 2), (x + 1, y - 2), (x + 1, y + 2)</code>. Be careful that all of these 8 cells may not be inside the grid, so discard the locations that falls out of the board.</p>
</div>
<div class="post-text" itemprop="text">
<p>While User_Targaryen's answer is the best because it directly answers your question, I would recommend an algebraic solution, if your goal is computing is the delivery of an answer in the shortest amount of time.</p>
<p>To shorten the algorithm, use reflections about the x, y, and xy axes, so as to consider only positive (x, y) where x &gt;= y, and place the starting move at the origin, coordinate (0, 0).  This is one octant (one eighth) of the possible directions.</p>
<p>A hint to discovering the solution is to use graph-paper or Dijkstra's algorithm with the restriction of reaching all points in the first octant up to 5 moves, and display this as a grid.  Each cell of the grid should be labeled with a digit representing the minimum number of moves.</p>
<p>Let me know if you would like to broaden your question and would like additional information.</p>
</div>
<div class="post-text" itemprop="text">
<p>For the algorithm you need to find all neighbours for a given node. Using a divmod <a href="https://docs.python.org/3/library/functions.html#divmod" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#divmod</a> it should be easy to translate the 0-63 notation to row and column, making the knights move easy to calculate </p>
</div>
<span class="comment-copy">Joseph, thank you for the interesting problem.  I will add my approach in an answer, but I just wanted to say a few things quickly.  (1) there are multiple shortest solutions to the problem; (2) an algebraic solution exists, given x and y offsets; (3) there is an 8 sided symmetry (actually 4 x 2), there for you can study the case where x &gt; y and x and y are both positive or zero.</span>
