<div class="post-text" itemprop="text">
<p>I have searched and I'm unable to come up with any good reason to use python's <code>__enter__</code> /<code>__exit__</code> rather than <code>__init__</code> (or <code>__new__</code> ?) / <code>__del__</code> .</p>
<p>I understand that <code>__enter__</code> / <code>__exit__</code> are intended for use with the <code>with</code> statement as context managers, and the <code>with</code> statement is great. But the counterpart to that is that any code in those blocks is <em>only</em> executed in that context. By using these instead of <code>__init__</code> / <code>__del__</code> I appear to be creating an implicit contract with callers that they must use <code>with</code>, yet there's no way to enforce such a contract, and the contract is only communicated via documentation (or reading the code). That seems like a bad idea.</p>
<p>I seem to get the same effect using <code>__init__</code> / <code>__del__</code> inside of a <code>with</code> block. But by using them rather than the context management methods my object is also useful in other scenarios.</p>
<p>So can anybody come up with a compelling reason why I would <em>ever</em> want to use the context management methods rather than the constructor/destructor methods?</p>
<p>If there's a better place to ask a question like this, please let me know, but it seems like there's not much good information about this out there.</p>
<h1><em>Follow Up:</em></h1>
<p><em>This question was based on a bad (but likely common) assumption because I always used <code>with</code> to instantiate a new object, in which case <code>__init__/__del__</code> come very close to the same behavior as <code>__enter__/__exit__</code> (except that you can't control when or if <code>__del__</code> will be executed, it's up to garbage collection and if the process is terminated first it may never be called). But if you use pre-existing objects in <code>with</code> statements they are of course quite different.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>There are several differences you appear to have missed:</p>
<ul>
<li><p>Context manager get a chance to provide a new object just for the block you are executing. Some context managers just return <code>self</code> there (like file objects do), but, as an example, database connection objects could return a cursor object tied to the current transaction.</p></li>
<li><p>Context managers are not just notified of the context ending, but also if the exit was caused by an exception. It can then decide on handling that event or otherwise react differently during exit. Using a database connection as an example again, based on there being an exception you could either commit or abort the transaction.</p></li>
<li><p><code>__del__</code> is only called when <em>all</em> references to an object are removed. This means you can't rely on it being called if you need to have multiple references to it that you may or may not control the lifetime of. A context manager exit is precisely defined however.</p></li>
<li><p>Context managers can be <em>reused</em>, and they can keep state. The database connection again; you create it once, then use it as a context manager again and again, and it'll keep that connection open. There is no need to create a new object each time for this. </p>
<p>This is important for thread locks, for example; you <em>have</em> to keep state so that only one thread can hold the lock at a time. You do this by creating <em>one</em> lock object, then use <code>with lock:</code> so different threads executing that section each can be made to wait before entering that context.</p></li>
</ul>
<p>The <code>__enter__</code> and <code>__exit__</code> methods form the <em>context manager protocol</em>, and you should only use these if you actually want to manage a context. The goal of context managers is to simplify common <code>try...finally</code> and <code>try...except</code> patterns, not to manage the lifetime of a single instance. See <a href="https://www.python.org/dev/peps/pep-0343/" rel="nofollow noreferrer">PEP 343 – <em>The "with" Statement</em></a>:</p>
<blockquote>
<p>This PEP adds a new statement "with" to the Python language to make it possible to factor out standard uses of try/finally statements.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><code>del x</code> doesn’t directly call <code>x.__del__()</code></p>
<p>You have no control over when <code>.__del__</code> is called, or in fact <a href="https://docs.python.org/3/reference/datamodel.html#object.__del__" rel="nofollow noreferrer">whether it gets called at all</a>.  </p>
<p>Therefore, using <code>__init__</code>/<code>__del__</code> for context management is not reliable.  </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>By using these instead of <code>__init__</code> / <code>__del__</code> I appear to be creating an implicit contract with callers that they must use <code>with</code>, yet there's no way to enforce such a contract</p>
</blockquote>
<p>You have a contract either way. If users use your object without realizing it requires cleanup after use, they'll screw things up no matter how you implement the cleanup. They might keep a reference to your object forever, for example, preventing <code>__del__</code> from running.</p>
<p>If you have an object that requires special cleanup, you need to make this requirement explicit. You need to give users <code>with</code> functionality and an explicit <code>close</code> or similar method, to let users control when the cleanup occurs. You can't hide the cleanup requirement inside a <code>__del__</code> method. You might want to implement <code>__del__</code> too, as a safety measure, but you can't use <code>__del__</code> <em>in place of</em> <code>with</code> or an explicit <code>close</code>.</p>
<hr/>
<p>With that said, Python makes no promises that <code>__del__</code> will run, ever. The standard implementation will run <code>__del__</code> when an object's refcount drops to 0, but that might not happen if a reference survives to the end of the script, or if the object is in a reference cycle. Other implementations don't use refcounting, making <code>__del__</code> even less predictable.</p>
</div>
<span class="comment-copy">When (and even whether) <code>__del__</code> gets called is nondeterministic. You could lose data by depending on <code>__del__</code> for cleanup.</span>
<span class="comment-copy">possible dupe:  <a href="http://stackoverflow.com/a/6772907/674039">stackoverflow.com/a/6772907/674039</a></span>
<span class="comment-copy">Your first two points are really about the <code>with</code> statement, not enter and exit. I agree that <code>with</code> is terrific, but in this question I'm more concerned about the best way to write a flexible object that can be used inside <code>with</code> or not. I get the <code>__del__</code> point.</span>
<span class="comment-copy">@BobDoolittle: there is little point in implementing <code>__enter__</code> and <code>__exit__</code> <b>without</b> the <code>with</code> statement. The <code>with</code> statement is the reason we have those methods in the first place.</span>
<span class="comment-copy">Of course there is. It's the difference between a server and a client. Between a caller and a service. I write an object. Somebody else may use it. They may use it in a <code>with</code> block or not, and I have no way to enforce usage. I should write my object in such a way that it will perform correctly in either case. Like <code>File</code> objects - I can use then in a <code>with</code> statement or not, and they work either way. Outside of a <code>with</code> block I should call close() however (but I suspect <code>__del__</code> does this also).</span>
<span class="comment-copy">@BobDoolittle: the <code>__enter__</code> and <code>__exit__</code> methods are a <i>protocol</i>. You'd only implement those if you wanted to support using your object as a context manager. You can't use an object as a context manager otherwise. Don't implement the protocol if you don't want to be a context manager. This is the same choice as implementing the mapping or container or number protocols. You'd implement those if your use case warrants it.</span>
<span class="comment-copy">@BobDoolittle: You seem to be conflating <i>creating</i> a context manager with using it to manage a context. The two are <i>separate steps</i>. It is often convenient to open a file and use it as a context manager at the same time, but you don't have to. Why would you have to? Locks can be used as context manager again and again and again. See <a href="//stackoverflow.com/a/19484315">Other builtin or practical examples of python `with` statement usage?</a> for more examples of context managers.</span>
<span class="comment-copy">I understand your point about <code>__del__</code>. But not wrt <code>__init__</code>. <code>__init__</code> should be reliable inside or outside of context management. At this point, I'm thinking the best way to write a flexible object is to put your initialization code in <code>__init__</code>, rather than <code>__enter__</code>, and to make <code>__exit__</code> do the same thing as <code>__del__</code> (while protecting against duplicate execution). In fact, I suspect that's exactly what the File objects do.</span>
<span class="comment-copy">@BobDoolittle: <code>__init__</code> is for initialization, so if you want to do initialization, do it there. <code>__enter__</code> is for work that should happen specifically on entering a <code>with</code> statement; for example, <code>__enter__</code> might lock a lock and <code>__exit__</code> unlock it.</span>
