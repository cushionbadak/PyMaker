<div class="post-text" itemprop="text">
<p>I'm using the below module to log events in my modules. I call it as follows:</p>
<p>module 1</p>
<pre><code>from tools.debug_logger import debug_logger
self.logger = debug_logger().start_logger('module1')
self.logger.debug("Top left corner found")
</code></pre>
<p>module2:</p>
<pre><code>from tools.debug_logger import debug_logger
self.logger = debug_logger().start_logger('module2')
self.logger.debug("Top left corner found")
</code></pre>
<p>and here the file /tools/debug_logger.py</p>
<pre><code>import logging, logging.handlers
import sys
class debug_logger(object):
    def start_logger(self,name):
        logger = logging.getLogger(name)
        logger.setLevel(logging.DEBUG)
        if not len(logger.handlers):
            fh = logging.handlers.RotatingFileHandler('log/pokerprogram.log', maxBytes=1000000, backupCount=10)
            fh.setLevel(logging.DEBUG)
            fh2 = logging.handlers.RotatingFileHandler('log/pokerprogram_info_only.log', maxBytes=1000000, backupCount=5)
            fh2.setLevel(logging.INFO)
            er = logging.handlers.RotatingFileHandler('log/errors.log', maxBytes=2000000, backupCount=2)
            er.setLevel(logging.WARNING)
            ch = logging.StreamHandler(sys.stdout)
            ch.setLevel(1)
            fh.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
            fh2.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
            er.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
            ch.setFormatter(logging.Formatter('%(name)s - %(levelname)s - %(message)s'))
            logger.addHandler(fh)
            logger.addHandler(fh2)
            logger.addHandler(ch)
            logger.addHandler(er)
        return logger
</code></pre>
<p>Everything works fine and I get log files for the respective levels, but when the RotatingFileHandler is called I sometimes get an error. It is as if various instances want to do the rotation at the same time, even though I'm quite sure this shouldn't happen as I make sure there's only 1 handler with  <code>if not len(logger.handlers)</code> as recommended here: <a href="https://stackoverflow.com/questions/7173033/duplicate-log-output-when-using-python-logging-module">Duplicate log output when using Python logging module</a>.</p>
<p>Any suggestion what could be causing this file access violation during the rotation would be appreciated.</p>
<pre><code>PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: 'C:\\Users\\Nicolas\\Dropbox\\PythonProjects\\Poker\\log\\pokerprogram.log' -&gt; 'C:\\Users\\Nicolas\\Dropbox\\PythonProjects\\Poker\\log\\pokerprogram.log.1'
</code></pre>
<p>I believe the permission error occur because when the rotation occurs other modules are still writing to the file. </p>
<p>What would be the best way to do logging from multiple modules when I write to a file and use this RotatingFileHandler? Is there any best practice?</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe you are getting your logging setup wrong. The recommended way to setup logging is to <em>not</em> define any handlers nor logging levels into the modules, but define all the configuration in the main file.</p>
<p>For example in <code>module1.py</code>:</p>
<pre><code>import logging

logger = logging.getLogger(__name__)

# use logger.info/logger.debug etc.
</code></pre>
<p>In <code>module2.py</code> you put exactly the same code:</p>
<pre><code>import logging

logger = logging.getLogger(__name__)

# use logger.info/logger.debug etc.
</code></pre>
<p>Note that <code>__name__</code> is the module name, so it will be something like <code>package.module1</code> or <code>package.module2</code>. Using dotted names automatically creates hierarchies of loggers, so that's why it's customary to just use the <code>__name__</code> of the module to get the logger.</p>
<p>There is no need for <code>module1</code> and <code>module2</code> to contain anything else related to logging. They should <em>not</em> decide where the logging output goes or its level, because this is something that who launches the application should control. Hence it is best handled in the main executable.</p>
<p>Now in your main executable you define your handlers:</p>
<pre><code>import logging, logging.handlers

fh = logging.handlers.RotatingFileHandler('log/pokerprogram.log', maxBytes=1000000, backupCount=10)
fh.setLevel(logging.DEBUG)
fh2 = logging.handlers.RotatingFileHandler('log/pokerprogram_info_only.log', maxBytes=1000000, backupCount=5)
fh2.setLevel(logging.INFO)
er = logging.handlers.RotatingFileHandler('log/errors.log', maxBytes=2000000, backupCount=2)
er.setLevel(logging.WARNING)
ch = logging.StreamHandler(sys.stdout)
ch.setLevel(1)
fh.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
fh2.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
er.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
ch.setFormatter(logging.Formatter('%(name)s - %(levelname)s - %(message)s'))
</code></pre>
<p>And finally you just add the handlers to the <em>root logger</em> and set the root logger's level to the lowest level among the handlers:</p>
<pre><code>root = logging.getLogger()
root.setLevel(logging.DEBUG)
# alternatively:
# root.setLevel(min([fh.level, fh2.level, ch.level, er.level])

root.addHandler(fh)
root.addHandler(fh2)
root.addHandler(ch)
root.addHandler(er)
</code></pre>
<p>This works due to the hierarchical nature of loggers. When <code>module1.logger.debug</code> is called, if the logger has no handlers it will pass the log record to its parent logger, which will continue to do so up until the root logger, which finally uses its handlers to handle the log record.</p>
<p>It is necessary to also set the root logger level because it defaults to <code>WARNING</code>, while other loggers default to <code>NOTSET</code> (which causes the delegation mentioned before).</p>
<p>Alternatively you add the same handlers to both module loggers explicitly:</p>
<pre><code>from &lt;package&gt; import module1, module2

module1.logger.setLevel(logging.DEBUG)
module2.logger.setLevel(logging.DEBUG)

module1.logger.addHandler(fh)
module2.logger.addHandler(fh)
module1.logger.addHandler(fh2)
module2.logger.addHandler(fh2)
module1.logger.addHandler(ch)
module2.logger.addHandler(ch)
module1.logger.addHandler(er)
module2.logger.addHandler(er)
</code></pre>
<p>There is no harm in adding the same handler object to multiple loggers. This makes sure that the handlers do not try to concurrently rotate the file.</p>
</div>
<span class="comment-copy">You are doing it wrong. Your modules should <i>not</i> define any handlers nor set the logging levels. Only the main executable should setup the handlers and the levels to be used... this simplifies everything since after you do this there's always just one handler for that file and there is no chance for that error to occur.</span>
<span class="comment-copy">The with  <code>if not len(logger.handlers):</code> I ensure there is only 1 handler. What's a better way to do this?</span>
<span class="comment-copy">No you do not. Because module1 and module2 have different names, which means that the loggers returned by <code>getLogger</code> are different and hence you are adding one handler for module1 and one for module2. So, sure a single logger does not have more than one handler, but you <i>do</i> have two handlers using the same file and this causes the error you see.</span>
<span class="comment-copy">I see, makes sense. So what's the best way to resolve it so I can easily call the routine and import it to the different modules?</span>
<span class="comment-copy">There is no need for importing it. I've wrote an answer describing the typical logging setup that works in most situations. The <code>module1</code> and <code>module2</code> should only import the <code>logging</code> module and get their loggers via <code>logging.getLogger(__name__)</code>. Everything else regarding configuration of the logging output is handled from the executable. This makes sense because it's the guy that launches the application that should be able to decide where to log something and at which level, not the module itself!</span>
<span class="comment-copy">Can you confirm that it's necessary to set the log level again in each module, otherwise it will be set to default of logging.WARNING?</span>
<span class="comment-copy">@nickpick Ah, sorry I forgot to add: you can just set the level of the root logger. I'll edit this in the answer.</span>
<span class="comment-copy">@nickpick Take a llok at the documentation for <a href="https://docs.python.org/3/library/logging.html#logging.Logger.setLevel" rel="nofollow noreferrer"><code>setLevel</code></a>. It says that by default the root logger is set at <code>WARNING</code>, while other loggers are by default at <code>NOTSET</code>. When a logger is at level <code>NOTSET</code> the delegation to the parent logger takes place, that's why if you decide to add the handlers directly to the two module loggers then you have to modify their level, while if you add them to the root logger you should not set their level.</span>
<span class="comment-copy">I added the handlers with their respective levels to the root logger, but still need to set the level in the modules.</span>
<span class="comment-copy">@nickpick If those module follow the same structure you can simply set the level you want for them. For example: if my application uses the <code>pika</code> package, I can just put <code>logging.getLogger('pika').setLevel(logging.WARNING)</code>. Now all messages sent to the <code>pika</code> logger will be filtered according to that level.</span>
