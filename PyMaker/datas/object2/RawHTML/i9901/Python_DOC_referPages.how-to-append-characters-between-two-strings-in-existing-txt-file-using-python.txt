<div class="post-text" itemprop="text">
<p>I am trying to add "," between a lot of data in .txt file and I also want to delete the second rows.</p>
<p>This is example of my txt file</p>
<pre><code>       1       1     139     178     128      83     140     140      87      87
       2       1     199     204     130     111     198     198      89      89
       3       1     188     182     107     120     183     183     109     109
       ......
</code></pre>
<p>'....' here means thousand of data.</p>
<p>and I want to print the result in a new .txt file</p>
<p>This is the results I wanted.</p>
<pre><code>   1,       139,     178,     128,      83,     140,     140,      87,      87
   2,       199,     204,     130,     111,     198,     198,      89,      89
   3,       188,     182,     107,     120,     183,     183,     109,     109
   .....
</code></pre>
<p>I really hope some one here can help me with this problem and I appreciate your help very much!</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>First, iterate over the lines:</p>
<pre><code>with open(filename) as f:
  for line in f:
    # can process the line here
</code></pre>
<p>Now lets see what we can do with each line:</p>
<pre><code>words = line.split() # split on whitespace
del words[1] # remove the word at index 1
joined = ", ".join(words)
print(joined) # can print to stdout, or write to another file
</code></pre>
<p>Updates after followup:</p>
<p>Once you open a file, <code>f</code> in this example, you can treat it as an iterator of lines. That's why <code>for line in f</code> works. You can also manipulate it as you would any other iterator but what you want to do has some side effects and here's why:</p>
<h1>list in memory</h1>
<p>If you have a list in memory and want to access only some items, it's easy enough to to slice it and iterate over that although there are inefficiencies involved:</p>
<pre><code>lines = [...] # a list of lines in memory

# inefficient - creates expensive intermediate lists, one for each slice, and another one for the concatenated list
for line in lines[2:12] + lines[15:22]:
  # process line

# slightly more efficient - creates less intermediate lists, one for each slice
from itertools import chain
for line in chain(lines[2:12, lines[15:22]):
  # process line
</code></pre>
<p>If you use <code>islice</code> beware that it's even more expensive - <code>islice</code> can consume the entire list until reaching the slice, instead of slicing efficiently.</p>
<h1>Why doesn't islice work with <code>f</code></h1>
<p><code>f</code> is indeed an iterator of lines, but it only goes forward. This is great - you can process a file with billions of lines like this and not use too much memory - but it also means that once <code>islice</code> consumes lines that's it. You need to find a way to filter the lines you need without "random access", that is without needing to jump arbitrary numbers of steps forwards and backwards in the sequence. You can do this if you add the line indexes to the iteration.</p>
<p>Here's a trivial way:</p>
<pre><code>def line_index_is_interesting(index):
  return 2 &lt;= index &lt;= 11 or 15 &lt;= index &lt;= 21

with open(filename) as f:
  index = 0
  for line in f:
    if line_index_is_interesting(index):
      # process line
    index += 1
</code></pre>
<p>This way you process each line just once, never using a lot of memory. By adding the state of the 'index' variable you can make your decision easily.</p>
<h1>This sounds useful - is this built-into Python?</h1>
<p>Yes, it's a built-in function called <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate</a>:</p>
<pre><code>with open(filename) as f:
  for i, line in enumerate(f):
    if line_index_is_interesting(i):
          # process line
</code></pre>
</div>
<span class="comment-copy">Thank you so much for your answer! It helps a lot. Though I have 1 followup question, I want to applied this solution only to several rows, e.g. row 2-11 and 15-21. I tried to skip some rows using itertools.islice() and it works just fine. But when I applied your answer into this itertools.islice, the loop stops after the first line. Do you know what went wrong?</span>
