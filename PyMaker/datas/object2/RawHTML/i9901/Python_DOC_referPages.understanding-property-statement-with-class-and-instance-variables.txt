<div class="post-text" itemprop="text">
<p>So I have read a lot about property keyword and I believe I have gotten the gist of it. I came across this example</p>
<pre><code>class PeopleHeight:
    def __init__(self, height = 150):
        self.height = height

    def convert_to_inches(self):
        return (self.height * 0.3937)

    def get_height(self):
        print("Inside the getter method")
        return self._height

    def set_height(self, value):
        if value &lt; 0:
            raise ValueError("Height cannot be negative")
        print("Inside the setter method")
        self._height = value

    height = property(get_height, set_height) #----&gt;CONFUSING
</code></pre>
<p>and the last statement which is confusing me </p>
<pre><code> height = property(get_height, set_height)
</code></pre>
<p>I understand that the property statement has the signature </p>
<pre><code>property(fget=None, fset=None, fdel=None, doc=None)
</code></pre>
<p>What I dont get is <code>get_height</code> and  <code>set_height</code>. I understand that height is a class variable (not an instance variable) but what about <code>get_height</code> and <code>set_height</code>.I am thinking that above should have been</p>
<pre><code>height = property(get_height, set_height)
</code></pre>
<p>but thats wrong syntax as there is no self.My question is why dont we get an error when we say:</p>
<pre><code>property(get_height, set_height)
</code></pre>
<p>as there are no definitions of get_height or set_height set as class scope.</p>
</div>
<div class="post-text" itemprop="text">
<p>The statements in the <code>class</code> body are all executed when the <code>class</code> statement is executed, as if the they are all inside a function. This produces a set of names, that then are used to set the class attributes. See the <a href="https://docs.python.org/3/reference/compound_stmts.html#class-definitions" rel="nofollow noreferrer"><code>class</code> statement documentation</a>:</p>
<blockquote>
<p>The class’s suite is then executed in a new execution frame (see Naming and binding), using a newly created local namespace and the original global namespace. (Usually, the suite contains mostly function definitions.) When the class’s suite finishes execution, its execution frame is discarded but its local namespace is saved. [4] A class object is then created using the inheritance list for the base classes and the saved local namespace for the attribute dictionary.</p>
</blockquote>
<p>Each of the <code>def ...</code> statements produce function objects, assigned to the function name, so <code>get_height</code> and <code>set_height</code> are both <em>just functions</em>, that then end up as attributes on the class. The same applies for the <code>height = property(get_height, set_height)</code> line; it accesses the names <code>get_height</code> and <code>set_height</code>, calls the <code>property()</code> callable with these as parameters and the result is assigned to the name <code>height</code>.</p>
<p>You may be confused how methods and the <code>property</code> object later on get access to the instance (the <code>self</code> argument in methods). Both functions and <code>property</code> objects are <a href="https://docs.python.org/3/reference/datamodel.html#descriptors" rel="nofollow noreferrer"><em>descriptor</em> objects</a>; any descriptor object that is accessed on an instance and is found on the class is <em>automatically</em> bound to the instance through this protocol. Also see the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer"><em>Descriptor HOWTO</em></a>.</p>
<p>You can execute all those steps manually in the interpreter:</p>
<pre><code>&gt;&gt;&gt; def get_height(self):
...     print("Inside the getter method")
...     return self._height
...
&gt;&gt;&gt; def set_height(self, value):
...     if value &lt; 0:
...         raise ValueError("Height cannot be negative")
...     print("Inside the setter method")
...     self._height = value
...
&gt;&gt;&gt; height = property(get_height, set_height)
&gt;&gt;&gt; height
&lt;property object at 0x105758188&gt;
&gt;&gt;&gt; height.fget
&lt;function get_height at 0x10560ce18&gt;
&gt;&gt;&gt; height.fset
&lt;function set_height at 0x10567e730&gt;
&gt;&gt;&gt; class FakeHeight:
...     _height = 42
...
&gt;&gt;&gt; instance = FakeHeight()
&gt;&gt;&gt; height.__get__(instance)  # descriptor access
Inside the getter method
42
&gt;&gt;&gt; height.__set__(instance, 82)  # descriptor setting
Inside the setter method
&gt;&gt;&gt; instance._height
82
</code></pre>
</div>
<span class="comment-copy"><code>get_height</code> and <code>set_height</code> <i>are</i> set in class scope. All functions in the <code>class</code> body are class-scope objects.</span>
<span class="comment-copy">i thought they were instance scope because they had self as a parameter</span>
<span class="comment-copy">No, only attributes you set on <code>self</code> are instance attributes. Methods receive the instance as the first argument, commonly named <code>self</code>, but that's not really <a href="https://docs.python.org/3/glossary.html#term-nested-scope" rel="nofollow noreferrer">a <i>scope</i> as Python understands it</a>.</span>
<span class="comment-copy">Not sure what I am suppose to be looking at the link you just posted</span>
<span class="comment-copy">Check out the <code>@property</code> decorator too.</span>
<span class="comment-copy">"You may be confused how methods and the property object later on get access to the instance (the self argument in methods)." This is exactly what is confusing me. Thanks I am going to read up on descriptor objects</span>
<span class="comment-copy">Thanks descirptors cleared this up</span>
