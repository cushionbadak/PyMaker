<div class="post-text" itemprop="text">
<p>I'm a new programmer learning python and am having trouble with how to approach this task:</p>
<p>So essentially I have a string of numbers to read imported from a file, and need to add the sum of the first number to the second and convert it to the correct ascii character.  So, for example if I am reading the string:</p>
<pre><code>'36 30 25 40 80 4' 
</code></pre>
<p>I would want to add 36 to 30, then 25 to 40, then 80 to 4 and so on, before converting them to the corresponding ASCII character and printing (so in this case 'CAT').</p>
<p>So far i recognize that i need to use a split command to split the string, and then a for loop to take the data for consecutive numbers. I can get the correct value for the first letter, but am having trouble 'telling' the program to atuomatically move on to add [2] to [3] after adding [1] to [0]. I also need to do this for multiple lines.  </p>
<p>Again, I'm a new coder so any help is greatly appreciated. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Another method that is less opaque (though more verbose) than Patrick's proposal would be:</p>
<pre><code>&gt;&gt;&gt; x = '36 30 25 40 80 4'
&gt;&gt;&gt; nums = [int(n) for n in x.split()]
&gt;&gt;&gt; ''.join(chr(sum(nums[i:i+2])) for i in range(0, len(nums), 2))
'BAT'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a special usage of <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> to pair up elements: </p>
<pre><code>s = '36 30 25 40 80 4'
ints = map(int, s.split()) #make into list of ints
sums = map(sum, zip(*[iter(ints)]*2))
print(''.join([chr(i) for i in sums]))
</code></pre>
<p>Edit: technically the <code>iter</code> is unnecessary here, but I write it because I sometimes forget when I do need it.</p>
<p>Edit 2: addressing jsbuenos points below:</p>
<p><a href="https://docs.python.org/3.4/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> takes a function and an iterable (like a list) and applies the function to every element of that iterable. So <code>list(map(int, ['1', '2']))</code> is the same as <code>[int('1'), int('2')]</code>.  The <code>list</code> is there because <code>map</code> actually returns an iterator that produces the values one at a time instead of all at once.</p>
<p>The usage of <a href="https://docs.python.org/3.4/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> here looks complex, but that's mostly all the punctuation.  Let's try and break it down.  As I mentioned, we don't need the <code>iter</code> here because <code>ints</code> is a <code>map</code> object, and thus already an iterator, so we don't have to make an iterator for it.  So now it looks like</p>
<pre><code>sums = map(sum, zip(*[ints]*2))
</code></pre>
<p>All the <code>map</code> is doing is adding up the pairs after we pair them up, so let's discard that too.</p>
<pre><code>zip(*[ints]*2)
</code></pre>
<p>The trick to understanding this is understanding that list multiplication happens first</p>
<pre><code>zip(*[ints, ints])
</code></pre>
<p>The <code>*</code> in front of an iterable is the unpacking operator.  Think of it as the list dumping its arguments into the function</p>
<pre><code>zip(ints, ints)
</code></pre>
<p>So what is <code>zip</code> actually doing?  The normal usage of <code>zip</code> is to take two iterables and pair the elements up, like so.</p>
<pre><code>list(zip([1,2,3], [4,5,6])) #put the results from zip into a list
[(1, 4), (2, 5), (3, 6)]
</code></pre>
<p>It works with more than two lists too, but that's not what we're here for.</p>
<p>It's important to note that in <code>zip(ints, ints)</code> the two <code>ints</code> arguments are the same object.  This means that when zip makes the first pair, it first gets the next element from its first argument, <code>ints</code>.  That's <code>36</code>.  Then it gets the next element from its second argument which is the same <code>ints</code>.  So the next element is <code>30</code>.  It then yields those two elements in a tuple, and goes on to repeat the process for the rest of the iterator.</p>
<p>If you're asking yourself "Why write <code>zip(*[iter(ints)]*2)</code> when <code>zip(ints, ints)</code> means the same thing?" it's because you have to make sure that the arguments are the same object, or it doesn't work.  Doing <code>zip(iter(ints),iter(ints))</code> wouldn't work because each <code>iter</code> returns a different, though identical, iterator. I have trouble remembering when I have to use <code>iter</code>, so to play it safe I just use it all the time.</p>
</div>
<div class="post-text" itemprop="text">
<p>If this is ascii encoding, I think you actually have 'BAT' instead of 'CAT'.  </p>
<pre><code>&gt;&gt;&gt; s = '36 30 25 40 80 4'
&gt;&gt;&gt; ints = [int(n) for n in s.split()]             # convert strings to integers
&gt;&gt;&gt; summed = [x+y for x,y in zip(ints[0::2], ints[1::2])]        # summing pairs
&gt;&gt;&gt; bytearray(summed).decode('ascii')                   # decoding to ascii text
'BAT'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it with a no brainer like this:</p>
<pre><code>In [18]: str='36 30 25 40 80 4'

In [19]: nums=str.split()

In [20]: for i in range(0, len(nums), 2):
    print(int(nums[i]) + int(nums[i+1]))
   ....:     
66
65
84
</code></pre>
<p>Possibly you want to check, that the len(nums) is even. If not an IndexError will be thrown.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use for loop with range with step 2</p>
<pre><code>    for i in range(0, 6, 2):
        do something to el[i] and el[i+1]
</code></pre>
<p>This way you can tell program to go to wanted index. Here i in loop will get values: [0, 2, 4]</p>
</div>
<div class="post-text" itemprop="text">
<p>Another solution:</p>
<pre><code>string = '36 30 25 40 80 4'
numbers = [int(e) for e in string.split()]
res = ''.join([chr(numbers[i]+numbers[i+1]) for i in range(0,len(numbers),2)])
print(res)
</code></pre>
<p><strong><em>Output:</em></strong> BAT</p></div>
<div class="post-text" itemprop="text">
<p>You may do it using <em>list comprehesnion</em> as:</p>
<pre><code>&gt;&gt;&gt; my_string = '36 30 25 40 80 4'
&gt;&gt;&gt; num_list = [int(num) for num in my_string.split()] # list of numbers
&gt;&gt;&gt; ''.join(chr(sum(c_num)) for c_num in zip(num_list[:-1:2], num_list[1::2]))
'BAT'     #                                    ^ iterate simultaneous value with step 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A slight alteration from Patricks answer. </p>
<pre><code>&gt;&gt;&gt; t = "36 30 25 40 80 4"
&gt;&gt;&gt; t_s = map(int,t.split())
&gt;&gt;&gt; t_s
[36, 30, 25, 40, 80, 4]
&gt;&gt;&gt; "".join([chr(sum(c)) for c in zip(t_s[1::2],t_s[::2])])
'BAT'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use extended list slicing to get pairs of adjacent numbers:</p>
<pre><code>s = '36 30 25 40 80 4'
a = [int(x) for x in s.split()] #convert to integers
firsthalf = a[::2] #every other starting from 0
secondhalf = a[1::2] #every other starting from 1
</code></pre>
<p>Then you can use <code>zip</code> to pair the halves to be summed:</p>
<pre><code>pairs = zip(firsthalf, secondhalf)
</code></pre>
<p>then you can map <code>sum</code> on each part of paris:</p>
<pre><code>ordinals = [sum(x) for x in pairs]
</code></pre>
<p>to finally convert to a string, call:</p>
<pre><code>print(''.join([chr(x) for x in ordinals])) #prints: 'BAT'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Many way to do this but without creating a number of intermediate lists you can simply create an iterator and use a generator to construct the string:</p>
<pre><code>&gt;&gt;&gt; s = '36 30 25 40 80 4'
&gt;&gt;&gt; i = iter(map(int, s.split()))
&gt;&gt;&gt; ''.join(chr(sum(x)) for x in zip(i, i))
'BAT'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can convert the string to the iterator returning ints, and use <code>next</code> function inside a list comprehension:</p>
<pre><code>s = '36 30 25 40 80 4' 

# iter is not necessary in python3
itr = iter(map(int, s.split()))
word = ''.join(chr(a+next(itr)) for a in itr)

print(word)
# BAT
</code></pre>
<p>IMO this is a bit cleaner because there is no explicit indexing.</p>
</div>
<span class="comment-copy">Are you getting cats and bats mixed up?</span>
<span class="comment-copy">This was actually much easier to understand than Patrick's as I haven't learned map and zip functions yet. Thanks!</span>
<span class="comment-copy">@chillbro at jsbuenos suggestion, I've edited in a brief overview of what's going on in my example, so I hope that helps you understand what I'm doing there. I hope it helps.</span>
<span class="comment-copy">"Technically" I have serious doubts whether you are actually helping any self-proclaimed "new coder" with syntax like that without explaining yourself.</span>
<span class="comment-copy">@jsbueno Sorry, i don't quite follow.  Are you saying that i should remove the disclaimer, that i should remove the <code>iter</code>, or that I should explain what <code>iter</code> is doing here?</span>
<span class="comment-copy">I am saying that you should add another example, with a simple, mlultiline <code>for</code> on top of that, write in plain English wht is going on, and them keep your current  example, and explain int in plain English - otherwise this answer is just good as code golfing for yourself, not for the OP - who won't understand none of  <code>map</code>, <code>zip</code> and the comprehension at the end.</span>
<span class="comment-copy"><code>map(sum, zip(*[iter(s)]*2))</code> is not very pythonic</span>
<span class="comment-copy">@PatrickHaugh The explanation is enlightening, but this approach still strikes me more as a "cool hack" than a best practice.</span>
<span class="comment-copy"><code>bytearray(summed).decode('ascii') </code> something out of the box, +1</span>
<span class="comment-copy">Not quite what was asked...</span>
<span class="comment-copy">This is not what the OP asked</span>
