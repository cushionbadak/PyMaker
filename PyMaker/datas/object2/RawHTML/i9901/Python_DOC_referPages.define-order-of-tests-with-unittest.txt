<div class="post-text" itemprop="text">
<p>Is there a way in Python <code>unittest</code> to set the order in which test cases are run? </p>
<p>In my current <code>TestCase</code> class, some testcases have side-effects that set conditions for the others to run properly. Now I realize the proper way to do this is to use <code>setUp()</code> to do all setup realted things, but I would like to implement a design where each successive test builds slightly more state that the next can use. I find this much more elegant.</p>
<pre><code>class MyTest(TestCase):
  def test_setup(self):
   #do something
  def test_thing(self)
   #do something that depends on test_setup()
</code></pre>
<p>Ideally, I would like the tests to be run in the order they appear in the class. It appears that they run in alphabetical order.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't make them independent tests - if you want a monolithic test, write a monolithic test.</p>
<pre><code>class Monolithic(TestCase):
  def step1(self):
      ...

  def step2(self):
      ...

  def _steps(self):
    for name in dir(self): # dir() result is implicitly sorted
      if name.startswith("step"):
        yield name, getattr(self, name) 

  def test_steps(self):
    for name, step in self._steps():
      try:
        step()
      except Exception as e:
        self.fail("{} failed ({}: {})".format(step, type(e), e))
</code></pre>
<p>If the test later starts failing and you want information on all failing steps instead of halting the test case at the first failed step, you can use the <code>subtests</code> feature: <a href="https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests</a></p>
<p>(The subtest feature is available via <code>unittest2</code> for versions prior to Python 3.4: <a href="https://pypi.python.org/pypi/unittest2" rel="nofollow noreferrer">https://pypi.python.org/pypi/unittest2</a> )</p>
</div>
<div class="post-text" itemprop="text">
<p>Its a good practice to always write a monolithic test for such expectations, however if yer a goofy dude like me, then you could simply write ugly looking methods in alphabetical order so that they are sorted from a to b as mentioned in the python docs <a href="http://docs.python.org/library/unittest.html">http://docs.python.org/library/unittest.html</a></p>
<blockquote>
<p>Note that the order in which the various test cases will be run is
  determined by sorting the test function names with respect to the
  built-in ordering for strings</p>
</blockquote>
<p><em>EXAMPLE:</em></p>
<pre><code>  def test_a_first():
  print "1"
  def test_b_next(): 
  print "2" 
  def test_c_last(): 
  print "3"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/unittest.html" rel="nofollow noreferrer">http://docs.python.org/library/unittest.html</a></p>
<blockquote>
<p>Note that the order in which the various test cases will be run is determined by sorting the test function names with respect to the built-in ordering for strings.</p>
</blockquote>
<p>So just make sure <code>test_setup</code>'s name has the smallest string value.</p>
<p><strong>Note that you should not rely on this behavior â€” different test functions are supposed to be independent of the order of execution.</strong> See <a href="https://stackoverflow.com/a/5387956">ngcohlan</a>'s answer above for a solution if you explicitly need an order.</p>
</div>
<div class="post-text" itemprop="text">
<p>Old question, but another way that I didn't see listed in any related questions: <strong>Use a <code>TestSuite</code></strong>.</p>
<p>Another way to accomplish ordering is to add the tests to a <a href="https://docs.python.org/2/library/unittest.html#unittest.TestSuite" rel="noreferrer"><code>unitest.TestSuite</code></a>. This seems to respect the order in which the tests are added to the suite using <code>suite.addTest(...)</code>. To do this:</p>
<ul>
<li><p>Create one or more TestCase subclasses, </p>
<pre><code>class FooTestCase(unittest.TestCase):
    def test_ten():
        print('Testing ten (10)...')
    def test_eleven():
        print('Testing eleven (11)...')

class BarTestCase(unittest.TestCase):
    def test_twelve():
        print('Testing twelve (12)...')
    def test_nine():
        print('Testing nine (09)...')
</code></pre></li>
<li><p>Create a callable test-suite generation <strong><em>added in your desired order</em></strong>, adapted from <a href="https://docs.python.org/2/library/unittest.html#organizing-test-code" rel="noreferrer">the docs</a> and <a href="https://stackoverflow.com/questions/12011091/trying-to-implement-python-testsuite">this question</a>:</p>
<pre><code>def suite():
    suite = unittest.TestSuite()
    suite.addTest(BarTestCase('test_nine'))
    suite.addTest(FooTestCase('test_ten'))
    suite.addTest(FooTestCase('test_eleven'))
    suite.addTest(BarTestCase('test_twelve'))
    return suite
</code></pre></li>
<li><p>Execute the test-suite, e.g.,</p>
<pre><code>if __name__ == '__main__':
    runner = unittest.TextTestRunner(failfast=True)
    runner.run(suite())
</code></pre></li>
</ul>
<p>For context, I had need for this and wasn't satisfied with the other options. I settled on the above way of doing test ordering. I didn't see this TestSuite method listed any of the several "unit-test ordering questions" (e.g., this question and others including <a href="https://stackoverflow.com/questions/16364433/execution-order-on-python-unittest">execution order</a>, or <a href="https://stackoverflow.com/questions/4005695/changing-order-of-unit-tests-in-python">changing order</a>, or <a href="https://stackoverflow.com/questions/4095319/unittest-tests-order">tests order</a>).</p>
</div>
<div class="post-text" itemprop="text">
<p>I ended up with a simple solution that worked for me:</p>
<pre><code>class SequentialTestLoader(unittest.TestLoader):
    def getTestCaseNames(self, testCaseClass):
        test_names = super().getTestCaseNames(testCaseClass)
        testcase_methods = list(testCaseClass.__dict__.keys())
        test_names.sort(key=testcase_methods.index)
        return test_names
</code></pre>
<p>And then</p>
<pre><code>unittest.main(testLoader=utils.SequentialTestLoader())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Tests which really depend on each other should be explicitly chained into one test.</p>
<p>Tests which require different levels of setup, could also have their corresponding <code>setUp()</code> running enough setup - various ways thinkable.</p>
<p>Otherwise <code>unittest</code> handles the test classes and test methods inside the test classes in alphabetical order by default (even when <code>loader.sortTestMethodsUsing</code> is None). <code>dir()</code> is used internally which sorts by guarantee.</p>
<p>The latter behavior can be exploited for <strong>practicability</strong> - e.g. for having the latest-work-tests run first to speed up the edit-testrun-cycle.
But that behavior should not be used to establish <strong>real dependencies</strong>. Consider that tests can be run individually via command-line options etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>@ncoghlan's answer was exactly what I was looking for when I came to this thread. I ended up modifying it to allow each step-test to run, even if a previous step had already thrown an error; this helps me (and maybe you!) to discover and plan for the propagation of error in multi-threaded database-centric software.</p>
<pre><code>class Monolithic(TestCase):
  def step1_testName1(self):
      ...

  def step2_testName2(self):
      ...

  def steps(self):
      '''
      Generates the step methods from their parent object
      '''
      for name in sorted(dir(self)):
          if name.startswith('step'):
              yield name, getattr(self, name)

  def test_steps(self):
      '''
      Run the individual steps associated with this test
      '''
      # Create a flag that determines whether to raise an error at
      # the end of the test
      failed = False

      # An empty string that the will accumulate error messages for 
      # each failing step
      fail_message = ''
      for name, step in self.steps():
          try:
              step()
          except Exception as e:
              # A step has failed, the test should continue through
              # the remaining steps, but eventually fail
              failed = True

              # get the name of the method -- so the fail message is
              # nicer to read :)
              name = name.split('_')[1]
              # append this step's exception to the fail message
              fail_message += "\n\nFAIL: {}\n {} failed ({}: {})".format(name,
                                                                       step,
                                                                       type(e),
                                                                       e)

      # check if any of the steps failed
      if failed is True:
          # fail the test with the accumulated exception message
          self.fail(fail_message)
</code></pre>
</div>
<span class="comment-copy">I am quite new to unit testing, and I get the feeling that monolithic test is bad. Is that true? Just build my test suite, and I really depend on monolithic test using your code. Is this a sign that I approach unit testing in a bad way? Thanks</span>
<span class="comment-copy">Pure unit tests offer the benefit that when they fail, they often tell you <i>exactly</i> what is wrong. You can also just rerun the tests that failed when trying to fix them. Monolithic tests like this don't have those benefits: when they fail, it's a debugging exercise to figure out what went wrong. On the other hand, tests like this are often a lot easier and quicker to write, especially when retrofitting tests to an existing application that wasn't built with unit testing in mind.</span>
<span class="comment-copy">there is no need for all the code, just use a better naming convention for the testnames... like "test_1_newuser" and "test_2_signin" this works because the tests are sorted  respect to the built-in ordering for strings.</span>
<span class="comment-copy">@shakirthow If the order of execution matters, they're not unit tests any more - they're steps in a scenario test. That's still a worthwhile thing to do, but it's best handled either as a larger test case as shown, or using a higher level behavioural testing framework like <a href="http://pythonhosted.org/behave/" rel="nofollow noreferrer">pythonhosted.org/behave</a></span>
<span class="comment-copy">Note, in your code <code>sorted()</code> is not really necessary, because <code>dir()</code> returns the step methods alphabetically sorted by guarantee. That's why also <code>unittest</code> handles the test classes and test methods in alphabetical order by default (even when <code>sortTestMethodsUsing</code> is None) - which can be exploited for practicability to e.g. have the latest-work-tests running first for speeding up the edit-testrun-cycle.</span>
<span class="comment-copy">IMO this approach is better than adding more code as workaround.</span>
<span class="comment-copy">Why do you say it's good practice to write monolithic tests?  Check out the more sophisticated way Java <a href="http://testng.org/doc/documentation-main.html#dependent-methods" rel="nofollow noreferrer">TestNG does it</a> with test groups and dependencies.  In any case, I'm a goofy guy too, and when I write my tests in alpha order, I've found it useful to pass state through global variables, because the test runner may create different instances for each test.</span>
<span class="comment-copy">@Joshua Just like every other thing out there, there is no "one solution to rule them all", Monolithinc solution is often a good design practise considered by some programmers, ordered tests or scenario driven tests break one of the design rules for testing which is "one test per expectation", but you don't have to adhere to this. I am not a big java fan, and just because a framework tries to do something doesn't necessary mean its a good practise.  And the word test group it self doesn't make sence to me, but feel free to do whatever bruh.</span>
<span class="comment-copy">Different testrunner, different behavior. Your advice is unhelpful for writing stable code snd tests.</span>
<span class="comment-copy">this is good except that it creates a new class for each test case.  is there a way to retain data from test_ten and use it in test_eleven?</span>
<span class="comment-copy">@thang if you make things <code>@classmethod</code> then they can persist state across instances.</span>
<span class="comment-copy">When doing this do you know if <code>setUpClass</code> is called? Or does it need to be run manually?</span>
<span class="comment-copy">@NickChapman how does that make sense? @ classmethod pretty much makes it a static function (with class info as a parameter)</span>
<span class="comment-copy">@thang <code>@classmethod != @staticmethod</code>!!! Be careful, they are totally different things. <code>@staticmethod</code> will allow you to invoke the method without having an instance of the class. <code>@classmethod</code> gives you access to the class and on the class itself you can store information. For example if you do <code>cls.somevar = 10</code> inside of a class method then all instances of that class and all other class methods will see that <code>somevar = 10</code> after that function has been run. Classes themselves are objects that you can bind values onto.</span>
