<div class="post-text" itemprop="text">
<p>I have kind of a brain fog trying to solve the following structure and maybe someone can assist in solving this issue.</p>
<pre><code> 10 11 12 00   11 12 13 01  12 13 14 02  13 14 15 03   14 15 16 04   15 16 17 05

 10 11 12 20   11 12 13 21  12 13 14 22  13 14 15 23   14 15 16 24   15 16 17 25

 10 11 12 02   11 12 13 03  12 13 14 04  13 14 15 05   14 15 16 06   15 16 17 07

 10 11 12 22   11 12 13 23  12 13 14 24  13 14 15 25   14 15 16 26   15 16 17 27
</code></pre>
<p>How would an algorithm/set of loops look like that generates this table? The order of appearance is not important. Just all bundles of four pairs should pop up. The pairs need actually to be individual digits, i.e. a <code>10</code> is a <code>1</code> and a <code>0</code>, not a <code>ten</code>!</p>
<p>EDIT: there is certainly a pattern in the numbers. But I did not manage to create an appropriate loop to 'catch' the pattern.</p>
<p>one pattern in first row is (if only this can be solved would help already): </p>
<pre><code> x = 1
 i = 0
 xi  x(i+1) x(i+2) (x-1)i     x(i+1)  x(i+2) x(i+3) (x-1)(i+1) ... 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This code generates the desired data as a 3D list of strings.</p>
<pre><code>a = (0, 0), (2, 0), (0, 2), (2, 2)
b = 10, 11, 12
result = [
    [
        [str(i + j) for j in b] + [str(u) + str(v+i)] for i in range(6)
    ] for u, v in a
]

# Display the resulting list in a relatively compact way    
for row in result:
    print([' '.join(u) for u in row])
</code></pre>
<p><strong>output</strong></p>
<pre><code>['10 11 12 00', '11 12 13 01', '12 13 14 02', '13 14 15 03', '14 15 16 04', '15 16 17 05']
['10 11 12 20', '11 12 13 21', '12 13 14 22', '13 14 15 23', '14 15 16 24', '15 16 17 25']
['10 11 12 02', '11 12 13 03', '12 13 14 04', '13 14 15 05', '14 15 16 06', '15 16 17 07']
['10 11 12 22', '11 12 13 23', '12 13 14 24', '13 14 15 25', '14 15 16 26', '15 16 17 27']
</code></pre>
<hr/>
<p>If these pairs are actually supposed to be pairs of integers we need a slightly different strategy:</p>
<pre><code>from pprint import pprint

a = (0, 0), (2, 0), (0, 2), (2, 2)
b = 10, 11, 12
result = [
    [
        [divmod(i + j, 10) for j in b] + [(u, v+i)] for i in range(6)
    ] for u, v in a
]

pprint(result)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[[[(1, 0), (1, 1), (1, 2), (0, 0)],
  [(1, 1), (1, 2), (1, 3), (0, 1)],
  [(1, 2), (1, 3), (1, 4), (0, 2)],
  [(1, 3), (1, 4), (1, 5), (0, 3)],
  [(1, 4), (1, 5), (1, 6), (0, 4)],
  [(1, 5), (1, 6), (1, 7), (0, 5)]],
 [[(1, 0), (1, 1), (1, 2), (2, 0)],
  [(1, 1), (1, 2), (1, 3), (2, 1)],
  [(1, 2), (1, 3), (1, 4), (2, 2)],
  [(1, 3), (1, 4), (1, 5), (2, 3)],
  [(1, 4), (1, 5), (1, 6), (2, 4)],
  [(1, 5), (1, 6), (1, 7), (2, 5)]],
 [[(1, 0), (1, 1), (1, 2), (0, 2)],
  [(1, 1), (1, 2), (1, 3), (0, 3)],
  [(1, 2), (1, 3), (1, 4), (0, 4)],
  [(1, 3), (1, 4), (1, 5), (0, 5)],
  [(1, 4), (1, 5), (1, 6), (0, 6)],
  [(1, 5), (1, 6), (1, 7), (0, 7)]],
 [[(1, 0), (1, 1), (1, 2), (2, 2)],
  [(1, 1), (1, 2), (1, 3), (2, 3)],
  [(1, 2), (1, 3), (1, 4), (2, 4)],
  [(1, 3), (1, 4), (1, 5), (2, 5)],
  [(1, 4), (1, 5), (1, 6), (2, 6)],
  [(1, 5), (1, 6), (1, 7), (2, 7)]]]
</code></pre>
<hr/>
<p>Here's a variation of the 2nd solution that uses "traditional" for loops instead of nested list comprehensions. Hopefully, it's a little easier to read. :)</p>
<pre><code>a = (0, 0), (2, 0), (0, 2), (2, 2)
b = 10, 11, 12
result = []
for u, v in a:
    row = []
    for i in range(6):
        row.append([divmod(i + j, 10) for j in b] + [(u, v+i)])
    result.append(row)
</code></pre>
<p>The built-in <a href="https://docs.python.org/3/library/functions.html#divmod" rel="nofollow noreferrer"><code>divmod</code></a> function performs division and modulus on its arguments, so when <code>a</code> and <code>b</code> are integers <code>divmod(a, b)</code> is equivalent to <code>a // b, a % b</code>. If <code>x</code> is a two digit integer `divmod(x, 10) returns a tuple containing those 2 digits.    </p>
</div>
<div class="post-text" itemprop="text">
<p>I have come up with an efficient algorithm for this problem :)</p>
<pre><code>for row in range(4):
    extra = 0
    if row &gt;= 2:
        extra = 2
    for column in range(6):
        print(10+column, 11+column, 12+column, str(2*(row%2))+"."+str(column + extra), end = "  ")
    print()
</code></pre>
<p>Think of it like a table, you want to work through row by row, then column by column. I used the column and the row in the algorithm to determine what the numbers should be</p>
<p>Add a comment if there's anything you don't understand :)</p>
</div>
<span class="comment-copy">Can you show what you've tried, pointing out which bit you're having trouble with?</span>
<span class="comment-copy">is this homework?</span>
<span class="comment-copy">Why are the last 2 groups (<code>16 17 18 26</code> and <code>17 18 19 27</code>) and not (<code>14 15 16 26</code> and <code>15 16 17 27</code>)? What sort of data structure is this table? Is it just a string, or is it supposed to be some kind of list?</span>
<span class="comment-copy">@PM2Ring, amended, sorry, false copy and paste. And yes, it's a kind of list</span>
<span class="comment-copy">Just out of interest, what is this for?</span>
<span class="comment-copy">this result is about what I was looking for. But tbh I do not grasp the code, yet. Will need to dig into it.</span>
<span class="comment-copy">@Al_Iskander I'll add a variation of the 2nd solution that uses "traditional" for loops, which may be a little easier to understand.</span>
<span class="comment-copy">perfect. very helpful. many thanks</span>
<span class="comment-copy">Thank you. The result is in the right direction. But @PM 2Ring's answer addresses the issue with the digits more directly.</span>
<span class="comment-copy">not a problem :)</span>
