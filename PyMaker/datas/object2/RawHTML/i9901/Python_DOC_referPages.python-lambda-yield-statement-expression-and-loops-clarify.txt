<div class="post-text" itemprop="text">
<p><code>TLDR:</code>  Can we implement <code>yield</code> or generator statement (with a loop) within a <code>lambda</code>? </p>
<p>My question is to clarify:</p>
<p>Whether the following simple loop function can be implemented with yield</p>
<pre><code>def loopyield():
   for x in range(0,15):
      yield x
print(*loopyield())
</code></pre>
<p>Results in error:</p>
<pre><code>lamyield=lambda x: yield x for x in range(0,15)
                       ^
SyntaxError: invalid syntax
</code></pre>
<p>Which looks like, it was expecting something as right operand for unwritten return statement but found the <code>yeild</code> and getting confused.</p>
<p>Is there a proper legit way to achieve this in a loop? </p>
<p>Side note: <code>yield</code> can be statement/expression depending on who you ask : <a href="https://stackoverflow.com/questions/20142450/yield-statement-or-expression">yield - statement or expression?</a></p>
<p><strong>Final Answer :</strong> yield can be used with lambda but the limitation(single-line) makes it useless.  <code>for/while</code> not possible in lambda because they are not expressions.  <em>-user2357112</em> implicit for loop is possible with list comprehension, and yield is valid within the list comprehension. -<em>wim</em></p>
<p><strong>Verdict-</strong> Explicit loops not possible because lambdas in python can only contain expressions, and to write an explicit loop you will need to use statements. <em>-wim</em></p>
</div>
<div class="post-text" itemprop="text">
<p>The one-liner you seem to be trying to create is actually technically possible with a lambda, you just need to help the parser a bit more:</p>
<pre><code>&gt;&gt;&gt; lamyield = lambda: [(yield x) for x in range(15)]
&gt;&gt;&gt; print(*lamyield())
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
</code></pre>
<p>This uses a for loop implicitly in a list comprehension.  It is not possible with an explicit <code>while</code> loop or <code>for</code> loop outside of a comprehension.  That's because lambdas in python can only contain <a href="https://docs.python.org/3/reference/expressions.html" rel="noreferrer">expressions</a>, and to write an explicit loop you will need to use <a href="https://docs.python.org/3/reference/compound_stmts.html" rel="noreferrer">statements</a>.</p>
<p><a href="https://docs.python.org/3.7/whatsnew/3.7.html#deprecated" rel="noreferrer"><strong>Note:  this syntax is deprecated in Python 3.7, and will raise <code>SyntaxError</code> in Python 3.8</strong></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Is it any necessity for using <code>yeild</code> inside of <code>lambda</code> if you can rewrite it with generator such that?</p>
<pre><code>In[1]: x = (i for i in range(15))
In[2]: x
Out[2]: &lt;generator object &lt;genexpr&gt; at 0x7fbdc69c3f10&gt;

In[3]: *x
Out[3]: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14

In[4]: x = (i for i in range(0, 15))
In[5]: x.__next__()
Out[5]: 0

In[6]: next(x)
Out[6]: 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You actually can loop through a lambda in useful ways, it's just that the example you provided isn't a great use case.</p>
<p>One instance where you might want to use <code>yield</code> inside a <code>lambda</code> might be to lazily execute expensive functions only when needed. Like so:</p>
<pre class="lang-py prettyprint-override"><code>for check, args in (lambda: (
                            (yield (expensive_check1(), ["foo", "bar"])), 
                            (yield (expensive_check2(), ["baz"])),
                            (yield (expensive_check3(), []), [])),
                    ))():
    if check:
        x = do_the_thing(*args)
        break
else:
    raise Exception("oh noes!!!")
</code></pre>
<p>* Note that this syntax will still work in Python 3.8, since it is not using the <code>yield</code> inside of a comprehension.</p>
</div>
<span class="comment-copy">"but you can also use a statement like <code>print()</code> as long as it is contained in a single line" - wrong! <code>print</code> is a function in Python 3, and <code>print</code> calls are ordinary expressions. You cannot use arbitrary single-line statements inside a <code>yield</code> call.</span>
<span class="comment-copy">Trying to write this with a <code>lambda</code> is pointless. If you want to stuff it onto a single line, <code>(x for x in range(0, 15))</code> would be a direct genexp translation of your generator function.</span>
<span class="comment-copy">I agree. I was trying to test a theory. On second thought, with the limitation of <code>lambda</code> having to fit into a single statement, I doubt I can achieve anything at all to have a loop within a <code>lambda</code>. But it will be good to finally clarify this because it has been bugging me.</span>
<span class="comment-copy">While you can technically put a <code>yield</code> in a lambda function, the constraints of lambda functions make it essentially never a useful thing to do.</span>
<span class="comment-copy">You'd have to parenthesise <code>(yield x)</code>. But the whole <code>for</code> loop syntax is not a valid expression anyway.</span>
<span class="comment-copy">Yeah. Like someone pointed out, it is basically a generator obj. Do you know if it can be done with <code>for</code>/<code>while</code>. Also, you can't really do anything with lambda one-line.</span>
<span class="comment-copy">Note that the results are completely different on Python 2. This code depends in a really subtle way on the fact that on Python 3, the list comprehension is implemented with <i>another</i> anonymous function inside the anonymous function created by <code>lambda</code>.</span>
<span class="comment-copy">Wow, what is going on here? Could you explain what <code>[(yield x) for x in range(15)]</code> does? What does the expression return?</span>
<span class="comment-copy">It returns a generator object.  When you iterate the generator you will get the values yielded during the iteration of the  comprehension.  When the iteration is complete, the <code>StopIteration</code> exception instance will have a <code>value</code> attribute.  This will be the list comprehension result: it will be a list of length 15, and the elements of this list will be the items which were <i>sent</i> into the generator.</span>
<span class="comment-copy">you can also do something like this-- which lazily evaluates each function, and will NOT be deprecated in 3.8: <code>lamyield = lambda: ((yield expensive_func1()), (yield expensive_func2()), (yield expensive_func3()))</code></span>
