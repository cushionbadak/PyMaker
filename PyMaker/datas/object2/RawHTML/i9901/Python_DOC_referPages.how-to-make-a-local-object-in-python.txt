<div class="post-text" itemprop="text">
<p>I wonder why Python behaves differently in the cases below?</p>
<p><strong>Case 1.</strong> I change local integer variable but global variable remains the same. Well, that's OK.</p>
<pre><code>N = 1

def Func1(x):
    x = 0

Func1(N)
print(N) # prints 1
</code></pre>
<p><strong>Case 2.</strong> I change property of local object... and it seems that I've changed global object.</p>
<pre><code>class C1:
    def __init__(self):
        self.A = 1

Obj1 = C1()

def Func2(x):
    x.A = 0  #here is a confusing moment

Func2(Obj1)
print(Obj1.A) #prints 0
</code></pre>
<p>Maybe I have incomplete understanding about can object actually be local or not? In that case how can I code something similar to "local object"?</p>
</div>
<div class="post-text" itemprop="text">
<p>In python, arguments to functions are <em>passed by assignment</em>. [1]
And in python, objects are not copied on assignment.
So in your second example, to make what you call a <em>local copy</em> of the object, you will have to copy it explicitly, for instance using <code>copy.deepcopy(x)</code> [2]</p>
<p>So your second code would become:</p>
<pre><code>import copy
class C1:
    def __init__(self):
        self.A = 1

Obj1 = C1()

def Func2(x):
    x = copy.deepcopy(x) # Make a local copy of the object
    x.A = 0  #No more confusion

Func2(Obj1)
print(Obj1.A) #prints 1
</code></pre>
<p>[1] <a href="https://docs.python.org/3.4/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="nofollow noreferrer">https://docs.python.org/3.4/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference</a> </p>
<p>[2] <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">https://docs.python.org/3/library/copy.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Your comparing apples to oranges(or whatever you wanna say). In your first case you were trying to change the value of a global variable inside of a function. Your global variable did not change when you called a function because <strong>Python passes variables by assignment not by reference</strong>. Observe what happens when we pass by assignment in your first case:</p>
<pre><code>&gt;&gt;&gt; N = 1
&gt;&gt;&gt; def foo(x):
    x = 0
    return x

&gt;&gt;&gt; foo(N) # this will not change N. we need to pass N by assingment
0
&gt;&gt;&gt; N
1
&gt;&gt;&gt; N = foo(N) # this will change N
&gt;&gt;&gt; N
0
&gt;&gt;&gt; 
</code></pre>
<p>This behavior is documented in <a href="https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="nofollow noreferrer">Python3 FAQ</a>:</p>
<blockquote>
<p>Remember that <strong>arguments are passed by assignment in Python</strong>. Since assignment just creates references to objects, thereâ€™s no alias between an argument name in the caller and callee, and so no call-by-reference per se.</p>
</blockquote>
<p>The emphasis is mine. </p>
<p>In your second case, you did not change the value of a global variable. <code>Obj1</code> is an object not a variable. <strong>You changed the attribute of <code>Obj1</code> not <code>Obj1</code> itself</strong>. See what happens when we attempt to pass <code>Obj1</code> by reference:</p>
<pre><code>&gt;&gt;&gt; class CL:
    def __init__(self):
        self.A = 1


&gt;&gt;&gt; Obj1 = CL()
&gt;&gt;&gt; def foo(x):
    # lets try chaning the actual value that Obj1 holds
    x = None


&gt;&gt;&gt; foo(Obj1) # did it change?
&gt;&gt;&gt; Obj1
&lt;__main__.CL object at 0x03B29B50&gt;
&gt;&gt;&gt;  # Nope
</code></pre>
</div>
<span class="comment-copy">You didn't change the global object. You changed the data in the global object.</span>
<span class="comment-copy">How can I create something like global object?</span>
