<div class="post-text" itemprop="text">
<p>I have a dictionary of names and the number of times the names appear in the phone book:</p>
<pre><code>names_dict = {
    'Adam': 100,
    'Anne': 400,
    'Britney': 321,
    'George': 645,
    'Joe': 200,
    'John': 1010,
    'Mike': 500,
    'Paul': 325,
    'Sarah': 150
}
</code></pre>
<p>Preferably without using <code>sorted()</code>, I want to iterate through the dictionary and create a new dictionary that has the top five names only:</p>
<pre><code>def sort_top_list():
  # create dict of any 5 names first
  new_dict = {}
  for i in names_dict.keys()[:5]:
    new_dict[i] = names_dict[i]:

  # Find smallest current value in new_dict
  # and compare to others in names_dict
  # to find bigger ones; replace smaller name in new_dict with bigger name
  for k,v in address_dict.iteritems():
    current_smallest = min(new_dict.itervalues())
    if v &gt; current_smallest:
      # Found a bigger value; replace smaller key/ value in new_dict with larger key/ value
      new_dict[k] = v
      # ?? delete old key/ value pair from new_dict somehow
</code></pre>
<p>I seem to be able to create a new dictionary that gets a new key/ value pair whenever we iterate through names_dict and find a name/ count that is higher than what we have in new_dict. I can't figure out, though, how to remove the smaller ones from new_dict after we add the bigger ones from names_dict.</p>
<p>Is there a better way - without having to import special libraries or use <code>sorted()</code> - to iterate through a dict and create a new dict of the top N keys with the highest values?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use the <a href="https://docs.python.org/3/library/heapq.html#heapq.nlargest" rel="nofollow noreferrer"><code>heapq.nlargest()</code> function</a> to achieve this:</p>
<pre><code>import heapq
from operator import itemgetter

top_names = dict(heapq.nlargest(5, names_dict.items(), key=itemgetter(1)))
</code></pre>
<p>This uses a more efficient algorithm (O(NlogK) for a dict of size N, and K top items) to extract the top 5 items as <code>(key, value)</code> tuples, which are then passed to <code>dict()</code> to create a new dictionary.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import heapq
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; names_dict = {'Adam': 100, 'Anne': 400, 'Britney': 321, 'George': 645, 'Joe': 200, 'John': 1010, 'Mike': 500, 'Paul': 325, 'Sarah': 150}
&gt;&gt;&gt; dict(heapq.nlargest(5, names_dict.items(), key=itemgetter(1)))
{'John': 1010, 'George': 645, 'Mike': 500, 'Anne': 400, 'Paul': 325}
</code></pre>
<p>You probably want to use the <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code> class</a> instead. The <a href="https://docs.python.org/3/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer"><code>Counter.most_common()</code> method</a> would have made your use-case trivial to solve. The implementation for that method uses <code>heapq.nlargest()</code> under the hood.</p>
<p>These are <em>not</em> special libraries, they are part of the Python standard library. You otherwise would have to implement a <a href="https://en.wikipedia.org/wiki/Binary_heap" rel="nofollow noreferrer">binary heap</a> yourself to achieve this. Unless you are specifically studying this algorithm, there is little point in re-implementing your own, the <a href="https://hg.python.org/cpython/file/3.5/Lib/heapq.py" rel="nofollow noreferrer">Python implementation</a> is highly optimised with an <a href="https://hg.python.org/cpython/file/3.5/Modules/_heapqmodule.c" rel="nofollow noreferrer">extension written in C</a> for some critical functions). </p>
</div>
<div class="post-text" itemprop="text">
<p>I do not know, why you don't want to use sort and the solution is not perfect and even doesn't match your problem exactly, but I hope it can inspire you to find your own implementation. I think it was only a short example for the real Problem you have.</p>
<p>But as you have seen on the other answer: Normally it is better to use code, that is written before instead of do all the things yourself. </p>
<pre><code>names_dict = {'Joe' : 200, 'Anne': 400, 'Mike': 500, 'John': 1010, 'Sarah': 150, 'Paul': 325, 'George' : 645, 'Adam' : 100, 'Britney': 321}

def extract_top_n(dictionary, count):
    #first step: Find the topmost values
    highest_values = []
    for k,v in dictionary.iteritems():
        print k,v, highest_values, len(highest_values)
        highest_values.append(v)
        l = len(highest_values)
        for i in range(l-1):
            print i,l
            if l-i &lt; 1:
                break
            if highest_values[l-i-1]&gt;highest_values[l-i-2]:
                temp = highest_values[l-i-2]
                highest_values[l-i-2] = highest_values[l-i-1]
                highest_values[l-i-1] = temp
        highest_values = highest_values [:count]

    #fill the dirctionary with all entries at least as big as the smallest of the biggest
    #but pay attention: If there are more than 2 occurances of one of the top N there will be more than N entries in the dictionary
    last_interesting = highest_values[len(highest_values)-1]
    return_dictionary = {}    
    for k,v in dictionary.iteritems():
        if v &gt;= last_interesting:
            return_dictionary[k] = v
    return return_dictionary

print extract_top_n(names_dict,3)        
</code></pre>
</div>
<span class="comment-copy">Is there any particular reason you don't want to use <code>sorted</code>?</span>
<span class="comment-copy">It's just an exercise. I know sorted is used a ton but I wanted to see if it was possible without any 'extra' stuff like sorted (dictionary iterator if fine). I've seen some of the answers to questions like this on SO but they use sorted.</span>
<span class="comment-copy">you could loop through the dict (or a hard copy of it) and pop the largest value every time, five times. Just remember to store the keys every time you replace your temp max</span>
<span class="comment-copy">There's nothing to stop you doing it yourself.  You would probably just write your own sort and pass<code>d.items()</code> to it.</span>
<span class="comment-copy">they appear to be sorted but that is not actually true in the general case, right? this is afterall just a dict. Also why not <code>Collections.Ordereddict(sorted(...))</code>? Is it because you would have to "slice" it afterwards by jumping to a <code>list</code> and then back?</span>
<span class="comment-copy">@Ev.Kounis I used Python 3.6 where the new dict implementation happens to preserve input order.</span>
<span class="comment-copy">Wow, didn't know that. Maybe it's worth mentioning! Thanks. +1</span>
<span class="comment-copy">@Ev.Kounis sorted has to do more work as it has to put all elements in order, not just the top 5.</span>
<span class="comment-copy">@kevingduck: as I said, you could implement a heap yourself. It is not <i>that</i> hard, the <a href="https://hg.python.org/cpython/file/3.5/Lib/heapq.py" rel="nofollow noreferrer"><code>heapq</code> module source</a> is available.</span>
