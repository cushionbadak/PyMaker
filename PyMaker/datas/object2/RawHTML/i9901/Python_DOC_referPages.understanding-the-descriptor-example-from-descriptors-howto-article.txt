<div class="post-text" itemprop="text">
<p>I am trying to wrap my head around the concept of descriptors and I have had no success lately. This <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">article</a> of descriptor How to has really helped and at the same time it has also confused me. I am struggling with this example here
on why <code>m.x</code> calls <code>def __get__(self, obj, objtype):</code></p>
<pre><code>class RevealAccess(object):
    def __init__(self, initval=None, name='var'):
        self.val = initval
        self.name = name

    def __get__(self, obj, objtype):
        print('Retrieving', self.name)
        return self.val

    def __set__(self, obj, val):
        print('Updating', self.name)
        self.val = val

&gt;&gt;&gt; class MyClass(object):
...     x = RevealAccess(10, 'var "x"')
...     y = 5
...
&gt;&gt;&gt; m = MyClass()
&gt;&gt;&gt; m.x
Retrieving var "x"
10
</code></pre>
<p>I believe the reason i am struggling with this is because I am confused by the following statement in the article</p>
<blockquote>
<p>The details of invocation depend on whether obj is an object or a
  class. For objects, the machinery is in <code>object.__getattribute__()</code>
  which transforms <code>b.x</code> into <code>type(b).__dict__['x'].__get__(b, type(b))</code>.
  The implementation works through a precedence chain that gives data
  descriptors priority over instance variables, instance variables
  priority over non-data descriptors, and assigns lowest priority to
  <code>__getattr__()</code> if provided</p>
</blockquote>
<p>I am not sure what the author means here by object or class. Does object mean an instance of a class ? I understand that when we do <code>instance.var</code> python internally does a <code>instance.__dict__["var"]</code> if that is not found then it does <code>class.__dict__["var"]</code>. I kind of lost it after that concept. Could anyone explain a little on how this example is working. How is the definition <code>def __get__(self, obj, objtype):</code> being called with <code>m.x</code>. I would be very grateful if anyone could clear this up.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, by <em>object</em> the author means an instance, not a class. The distinction comes from where the descriptor lives; the descriptor is defined on the class, so when accessing that descriptor <em>directly on the class</em> a different path is followed from when you access that descriptor on an instance of the class.</p>
<p>In your example, <code>m</code> is an instance. That instance itself has no attribute <code>m</code> (<code>'x' in m.__dict__</code> is <code>False</code>). Python also looks at <code>type(m)</code> to resolve that attribute, and <code>type(m)</code> here is <code>MyClass</code>. <code>'x' in MyClass.__dict__</code> is <code>True</code>, and <code>MyClass.__dict__['x'].__get__</code> exists, so Python now knows that that object is a descriptor.</p>
<p>So, because there is no <code>m.__dict__['x']</code>, but there <em>is</em> a <code>type(m).__dict__['x'].__get__</code>, that method is called with <code>m</code> and <code>type(m)</code> as arguments, leading to <code>type(m).__dict__['x'].__get__(m, type(m))</code>. </p>
<p>If <code>'x' in MyClass.__dict__</code> is true but <code>MyClass.__dict__['x'].__get__</code> did <em>not</em> exist (so that object is <em>not</em> a descriptor object), then <code>MyClass.__dict__['x']</code> would have been returned directly.</p>
<p>The situation gets more interesting if you tried to add the <code>x</code> attribute to the instance <em>too</em>. In that case it matters if <code>MyClass.__dict__['x'].__set__</code> or <code>MyClass.__dict__['x'].__delete__</code> exist, making the descriptor a <em>data</em> descriptor. Data descriptors always win in the case of a tie. So <em>if</em> <code>MyClass.__dict__['x'].__get__</code> and <em>at least one of</em> <code>MyClass.__dict__['x'].__set__</code> or <code>MyClass.__dict__['x'].__delete__</code> exist, it doesn't matter anymore if <code>m.__dict__['x']</code> also exists. Python won't even look for it.</p>
<p>However, if there are no <code>__set__</code> or <code>__delete__</code> methods on the descriptor object on the class, then <code>m.__dict__['x']</code> wins and is returned. In that case the descriptor is a regular, non-data descriptor and it loses out to the instance attribute.</p>
<p>Last but not least, if <code>'x' in type(m).__dict__</code> is false (there is no object on the class), then <code>m.__dict__['m']</code> is returned. The descriptor protocol is only applied to objects found on the class, never to attributes on the instance.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Does object mean an instance of a class ?</p>
</blockquote>
<p>Yes.</p>
<blockquote>
<p>How is the definition <code>def __get__(self, obj, objtype):</code> being called with <code>m.x</code>.</p>
</blockquote>
<p>Because of just what the documentation you quoted says:</p>
<blockquote>
<p>For objects, the machinery is in <code>object.__getattribute__()</code> which transforms <code>b.x</code> into <code>type(b).__dict__['x'].__get__(b, type(b))</code>. </p>
</blockquote>
<p><code>object.__getattribute__</code> is mechanism that implements what happens when you do something like <code>m.x</code>.  So, explicitly:</p>
<pre><code>m.x
type(m).__dict__['x'].__get__(m, type(m))
MyClass.__dict__['x'].__get__(m, MyClass)
RevealAccess(10, 'var "x"').__get__(m, MyClass)
</code></pre>
<p>so the last line calls the <code>__get__</code> method of the <code>RevealAccess</code> class.</p>
</div>
<span class="comment-copy">If you use the parameter names:  <code>def __get__(self, instance, owner)</code> it might be clearer. <code>RevealAccess</code> is a descriptor class and <code>MyClass</code> is the owner class.  Bear in mind that classes are objects, so <code>owner</code> will be the class object <code>MyClass</code>.</span>
<span class="comment-copy">AWESOME!! Thank you so much for clearing this up.</span>
<span class="comment-copy">Could you also explain what would have happened if x was an instance variable in <code>MyClass</code>rather than a class variable ? (i.e) <code>if m ('x' in m.__dict__ is True).</code></span>
<span class="comment-copy">@JamesFranco: <i>in addition</i> to <code>MyClass.x</code> existing?</span>
<span class="comment-copy">No if <code>MyClass.x</code> did not exist and instead if it was <code>InstanceOfMyClass.x</code> (i.e) if x was declared in the <code>init</code> method as <code>self.x</code>.</span>
<span class="comment-copy">@JamesFranco: in that case there is no conflict. Descriptors are only supported no the class, not the instance, so <code>m.__dict__['x']</code> is returned directly.</span>
