<div class="post-text" itemprop="text">
<p>Hi I have a question regarding to the <code>time.sleep()</code> function in python 3. What I am trying to do is looping a list of value periodically with the rate of 0.001 second/ point. It works fine with 0.01 or higher rate. But at 0.001 or smaller, the rate is heavily affected by opening or turning off other programs. 
For example, I have a list of 100 points and run with 0.001 second per point. Then it would take approximately 100*0.001 = 0.1 second to finish it. However, when I run the code, it takes way longer about 1 second to finish. Then I turn on Google Chrome and open stack overflow or quora websites, then it runs at the right speed about 0.11 second.
I am wondering if there is any solution to fix this issue or an alternative of <code>time.sleep()</code> that won't be affected by the other programs. Here is my code for testing <code>time.sleep()</code>.</p>
<pre><code>import time
from timeit import default_timer as timer
import threading

my_points = [1,2,3,4,5,6,7,8,9,10,
            11,12,13,14,15,16,17,18,19,20,
            21,22,23,24,25,26,27,28,29,30,
            31,32,33,34,35,36,37,38,39,40,
            41,42,43,44,45,46,47,48,49,50,
            51,52,53,54,55,56,57,58,59,60,
            61,62,63,64,65,66,67,68,69,70,
            71,72,73,74,75,76,77,78,79,80,
            81,82,83,84,85,86,87,88,89,90,
            91,92,93,94,95,96,97,98,99,100,]

def execute():
   while True:
      start = timer()
      for i in my_points:
         print (i, flush = True)
         time.sleep(0.001) #Problem is here

      end = timer()
      print ("Total time run per cycle: ", end - start)
      time.sleep(2) #To read the time

execute()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The manual entry for <a href="https://docs.python.org/3/library/time.html#time.sleep" rel="nofollow noreferrer">time.sleep</a></p>
<blockquote>
<p>time.sleep(secs)</p>
<p>Suspend execution of the calling thread for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signalâ€™s catching routine. Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system.</p>
<p>Changed in version 3.5: The function now sleeps at least secs even if the sleep is interrupted by a signal, except if the signal handler raises an exception (see PEP 475 for the rationale).</p>
</blockquote>
<p>makes it pretty clear that the actual sleep time will only approximate the requested time.  I have separately read that the resolution on Windows is 1/60 s, though I don't know if that is still true.  </p>
<p>You can do much better using the tkinter root.after function.  When I run the following in IDLE</p>
<pre><code>import tkinter as tk
from time import perf_counter as timer

root = tk.Tk()
n = 1000
def tick():
    global n
    if n:
        #print(n)
        root.after(1, tick)
        n -= 1
    else:
        print(timer() - start)
        root.quit()

root.after(1, tick)
start = timer()
root.mainloop()
</code></pre>
<p>the output is repeatably just under 1.05 seconds, very close to the target 1.00.  If I uncomment the tick print statement, the time is 4.2 seconds.  In IDLE, the print goes through a socket to a separate process, which is a bit slow.  Running in Windows Command Prompt, the 1000 print time is 1.3 seconds.  I expect that this is about what you would get outputting to a serial post as long as the recipient can keep up with the flow.</p>
<p>EDIT One could do something similar with the relatively new <code>asyncio</code> module, and with a bit more effort, even use the newer <code>async for</code> syntax.  But I do not have the needed knowledge memorized. </p>
</div>
<div class="post-text" itemprop="text">
<p>In general sleep functions in POSIX, and presumably Windows as well, are guaranteed to sleep for at least the duration specified (unless interrupted earlier by a signal), but they may sleep arbitrarily long after the specified duration depending on when the OS thread scheduler decides to wake the thread.</p>
<p>You could try running your program with a realtime scheduling policy, e.g. in case you're using Linux see <a href="https://docs.python.org/3/library/os.html#os.sched_setscheduler" rel="nofollow noreferrer">https://docs.python.org/3/library/os.html#os.sched_setscheduler</a> and <a href="http://man7.org/linux/man-pages/man2/sched_setscheduler.2.html" rel="nofollow noreferrer">http://man7.org/linux/man-pages/man2/sched_setscheduler.2.html</a> .</p>
</div>
<span class="comment-copy">What problem are you actually trying to solve here that requires precise sleeping of exactly a millisecond?</span>
<span class="comment-copy">not exact a millisecond. I can be off a little bit but not as ten times bigger. That's what I'm concerned with.</span>
<span class="comment-copy">Again, what problem are you actually trying to solve with this approach? Perhaps there's a better way to do it in general.</span>
<span class="comment-copy">Sorry for misunderstanding your question earlier. I'm sending a list of points through Serial port to the Arduino to create a waveform using firmate firmware. Therefore, the faster the rate between points, the nicer the waveform looks.</span>
<span class="comment-copy">If faster is better, why have any delay?</span>
<span class="comment-copy">Very interesting solution. I ran it and it worked. Since my application already has tkinter applied, I need to figure out how to do after for a specific frame that contains the button to trigger this function. Thanks so much!</span>
<span class="comment-copy">I believe you can simply omit the module-level root.after call and make <code>tick</code> the button command.  Or call it from the button command function after doing setup.</span>
<span class="comment-copy">I ran into the same problem again even with tk after() function. It only runs well when Chrome is on. very weird.</span>
<span class="comment-copy">I just found out another interesting thing that this only happens on Windows machine. I have tried it on my Mac and it works fine.</span>
