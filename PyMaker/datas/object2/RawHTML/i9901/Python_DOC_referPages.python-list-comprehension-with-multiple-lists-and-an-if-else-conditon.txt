<div class="post-text" itemprop="text">
<p>I would like to loop over two equally long sets and determine whether elements in each set are also in an array.</p>
<p>This is a Hackerrank question of which I have already solved. However, I am using Hackerrank to further understanding of Python. I have been learning about list comprehension and whilst I do believe how I am attempting to use it to be considered bad production code I still would like to explore the possibilities of the language syntax for my own knowledge.</p>
<p>This is the code that sets it up:</p>
<pre><code>n, m = map(int, input().split())
arr = list(map(int, input().split()))
A = set(map(int, input().split()))
B = set(map(int, input().split()))
</code></pre>
<p>The task is to output an integer with a value of +1 for every element both in A and arr and -1 for every element both in B and arr.</p>
<p>Sample Input:</p>
<pre><code>3 2
1 5 3
3 1
5 7
</code></pre>
<p>Sample Output:</p>
<pre><code>1
</code></pre>
<p>This achieves the required results:</p>
<pre><code>print(sum([1 for a in A if a in arr]) + sum([-1 for b in B if b in arr]))
</code></pre>
<p>However, this is closer to what I would like to achieve:</p>
<pre><code>sum([1 if a in arr else -1 if b in arr for a, b in zip(A, B)])
</code></pre>
<p>EDIT (this is closer actually):</p>
<pre><code>print(sum(1 if a in arr -1 if b in arr for a, b in zip(A, B)))
</code></pre>
<p>As you can see both are one-liners so it's not about attempting to reduce the code but rather to just understand the possibilities of list comprehension and pythonic code. If this is not possible or even bad practice I am very interested also.</p>
<p>This is the Hackerrank link:
<a href="https://www.hackerrank.com/challenges/no-idea" rel="nofollow noreferrer">https://www.hackerrank.com/challenges/no-idea</a></p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, forgo the list comprehension; feed the values directly into <code>sum()</code> with a generator expression:</p>
<pre><code>sum(1 for a in A if a in arr)
</code></pre>
<p>If <code>A</code> is a <em>set</em>, use the <a href="https://docs.python.org/3/library/stdtypes.html#set.intersection" rel="nofollow noreferrer"><code>set.intersection()</code> method</a> to extract the common values, then <em>take the length of the result</em>:</p>
<pre><code>len(A.intersection(arr)))
</code></pre>
<p>This is faster than trying to test <code>arr</code> for each value. This <em>does</em> produce a new <code>set()</code> object first however, but you were creating a list before so that's not much difference.</p>
<p>At that point it is <em>far simpler</em> just to subtract the second length:</p>
<pre><code>len(A.intersection(arr)) - len(B.intersection(arr))
</code></pre>
<p>You can avoid creating sets altogether by looping over <code>arr</code> and testing each value in <code>arr</code> against either <code>A</code> or <code>B</code>; this too is faster because set membership tests are O(1) constant time:</p>
<pre><code>sum(1 if v in A else -1 if v in B else 0 for v in arr)
</code></pre>
<p>Your method, of testing <code>a in arr</code> for every value in the set <code>A</code>, requires a full list scan of <code>arr</code> if the value <code>a</code> is not present; this makes membership testing against a list a O(N) linear time problem, and you do so for every value in <code>A</code> <em>and</em> for every value in <code>B</code>, so you end up with O((A+B) * N) == O(KN) time. Testing each value in <code>arr</code> against the set is only O(N * 1) == O(N) time.</p>
<p>Moreover, if values in <code>arr</code> <em>are not unique</em>, your approach would actually lead to to the wrong answer; you'd only count happy or unhappy numbers <em>once</em>, while the problem requires them to be counted each time they appear.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about coverting array to set and taking intersection</p>
<pre><code>s = set(arr)
print(len(A.intersection(s)) - len(B.intersection(s)))
</code></pre>
<p>Edit:
     This solution will not work for duplicate values in <code>arr</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Your solution is great but here's a catch. You're using a <code>set</code> data structure for the two sets of numbers and a <code>list</code> for your array. When applying the <code>in</code> operator on top of list you're doing a O(n) search  whereas in a set the same operation is O(logn) (In python average case is O(1)!). So your total time complexity is O(2 * m * n) = O(m*n). You could search in a reverse manner such as:</p>
<p><code>For each element in array, if element in A then +1, if element in B then -1.</code></p>
<p>The total complexity of this would be O(n * 2 * logm) = O(n*logm)</p>
<p>More about python time complexities <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This is the answer I submitted as it worked using list comprehension as I first thought. This was only necessary as the array may have multiples of the same element as such the count would need to reflect that.</p>
<pre><code>n, m = map(int, input().split())
arr = list(input().split())
A, B = set(input().split()), set(input().split())
print(sum([(e in A) - (e in B) for e in arr]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The most efficient way of solving the problem is probably to put the items of <code>A</code> and <code>B</code> into a dictionary (as keys), with the values being <code>1</code> or <code>-1</code> depending on which set they came from. This will let you scan through the list <code>arr</code> and easily get the value to add to the sum:</p>
<pre><code>ab_dict = {a: 1 for a in A}
ab_dict.update((b, -1) for b in B)

result = sum(ab_dict.get(x, 0) for x in arr)
</code></pre>
<p>The calculation of the result has the same computational complexity as using couple of conditional operators in a generator expression (<code>sum(1 if x in A else -1 if x in b else 0 for x in arr)</code>), but should be faster by some constant factor since for each item there's only one dict lookup instead of two set membership tests.</p>
</div>
<span class="comment-copy">Why use a list comprehension <i>at all</i> if you are turning the list into a set immediately? You can use a set comprehension instead.</span>
<span class="comment-copy">By the way, I don't think you need the list comprehensions, if I remember well <code>sum()</code> accepts any iterable so you can remove the <code>[]</code> and pass it the generators.</span>
<span class="comment-copy">@spectras I did not know that. I shall attempt it without the list comprehensions. I also just noticed <code>else if</code> would be incorrect as it should be two <code>if</code> statements so the second condition is checked even if the first isn't true</span>
<span class="comment-copy">I'm re-reading and I think attempting to do both sums in one is kinda misguided, as you are summing different things from different containers. It's not only that it will not work (without twisting the data in odd ways), it's also that it does not make sense from a logic point of view.</span>
<span class="comment-copy">Since a unit value is only being added and subtracted this makes much more sense and the use of set theory is cleaner.</span>
<span class="comment-copy">I was also thinking about this, but I don't think it works correctly if <code>arr</code> can have duplicate values (which should be counted more than once).</span>
<span class="comment-copy">@Blckknght&gt; actually, the problem statement does not say they should be counted more than once.  <i>“For each  integer in the array, if i ∊ A, you add 1 to your happiness”.</i> So that's just 1, no matter how many times it is in A.</span>
<span class="comment-copy">@RaviKumar: but you can test with <code>arr = [1, 1]</code> and <code>A = set([1])</code>, <code>B = set([0])</code>. The output <i>should</i> be <code>2</code>, but this code produces <code>1</code> instead.</span>
<span class="comment-copy">@MartijnPieters Solution provided by OP iterates over every element of <code>A</code> and <code>B</code> and checks if elements are present in <code>arr</code>. So answer should be 1 for your example.</span>
<span class="comment-copy">@RaviKumar: I know what the OP posted, but that doesn't mean their answer is <i>correct</i> however.</span>
<span class="comment-copy">I only found this out moments before your post. This is a great point.</span>
