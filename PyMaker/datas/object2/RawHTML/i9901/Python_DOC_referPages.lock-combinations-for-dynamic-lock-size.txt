<div class="post-text" itemprop="text">
<p>In the following I will give two examples that have different dimension values.</p>
<p>Lock-1</p>
<pre><code># numbers are the shown values on the so in this case: 0,1,2
numbers = 5
# fields are those things i can turn to change my combination
fields = 4
</code></pre>
<p>So what I would expect for all of my posibilities is</p>
<pre><code>0   0   0   5
0   0   1   4
0   0   2   3
0   0   3   2
0   0   4   1
0   0   5   0
0   1   0   4
0   1   1   3
0   1   2   2
0   1   3   1
0   1   4   0
0   2   0   3
0   2   1   2
0   2   2   1
0   2   3   0
0   3   0   2
0   3   1   1
0   3   2   0
0   4   0   1
0   4   1   0
0   5   0   0
1   0   0   4
1   0   1   3
1   0   2   2
1   0   3   1
1   0   4   0
1   1   0   3
1   1   1   2
1   1   2   1
1   1   3   0
1   2   0   2
1   2   1   1
1   2   2   0
1   3   0   1
1   3   1   0
1   4   0   0
2   0   0   3
2   0   1   2
2   0   2   1
2   0   3   0
2   1   0   2
2   1   1   1
2   1   2   0
2   2   0   1
2   2   1   0
2   3   0   0
3   0   0   2
3   0   1   1
3   0   2   0
3   1   0   1
3   1   1   0
3   2   0   0
4   0   0   1
4   0   1   0
4   1   0   0
5   0   0   0
</code></pre>
<p>My second lock has the following values:</p>
<pre><code>numbers = 3
values = 3
</code></pre>
<p>So what I would expect as my posibilities would look like this</p>
<pre><code>0   0   3
0   1   2
0   2   1
0   3   0
1   0   2
1   1   1
1   2   0
2   0   1
2   1   0
3   0   0
</code></pre>
<p>I know this can be done with <code>itertools.permutations</code> and so on, but I want to generate the rows by building them and not by overloading my RAM. I figured out that the last 2 rows are always building up the same way.
So I wrote a funtion which builds it for me:</p>
<pre><code>def posibilities(value):
    all_pos = []

    for y in range(value + 1):
        posibility = []
        posibility.append(y)
        posibility.append(value)

        all_pos.append(posibility)

        value -= 1

    return all_pos
</code></pre>
<p>Now I want some kind of way to fit the other values dynamically around my function, so e.g. Lock - 2 would now look like this:</p>
<pre><code>0   posibilities(3)
1   posibilities(2)
2   posibilities(1)
3   posibilities(0)
</code></pre>
<p>I know I should use a <code>while</code> loops and so on, but I can't get the solution for dynamic values.</p>
</div>
<div class="post-text" itemprop="text">
<p>You <em>could</em> do this recursively, but it's generally best to avoid recursion in Python unless you <em>really</em> need it, eg, when processing recursive data structures (like trees). Recursion in standard Python (aka CPython) is not very efficient because it cannot do <a href="https://en.wikipedia.org/wiki/Tail_call" rel="nofollow noreferrer">tail call</a> elimination. Also, it applies a recursion limit (which is by default 1000 levels, but that can be modified by the user).</p>
<p>The sequences that you want to generate are known as <a href="https://en.wikipedia.org/wiki/Composition_%28combinatorics%29" rel="nofollow noreferrer">weak compositions</a>, and the Wikipedia article gives a simple algorithm which is easy to implement with the help of the standard <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> function.</p>
<pre><code>#!/usr/bin/env python3

''' Generate the compositions of num of a given width

    Algorithm from 
    https://en.wikipedia.org/wiki/Composition_%28combinatorics%29#Number_of_compositions

    Written by PM 2Ring 2016.11.11
'''

from itertools import combinations

def compositions(num, width):
    m = num + width - 1
    last = (m,)
    first = (-1,)
    for t in combinations(range(m), width - 1):
        yield [v - u - 1 for u, v in zip(first + t, t + last)]

# test

for t in compositions(5, 4):
    print(t)

print('- ' * 20)

for t in compositions(3, 3):
    print(t)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[0, 0, 0, 5]
[0, 0, 1, 4]
[0, 0, 2, 3]
[0, 0, 3, 2]
[0, 0, 4, 1]
[0, 0, 5, 0]
[0, 1, 0, 4]
[0, 1, 1, 3]
[0, 1, 2, 2]
[0, 1, 3, 1]
[0, 1, 4, 0]
[0, 2, 0, 3]
[0, 2, 1, 2]
[0, 2, 2, 1]
[0, 2, 3, 0]
[0, 3, 0, 2]
[0, 3, 1, 1]
[0, 3, 2, 0]
[0, 4, 0, 1]
[0, 4, 1, 0]
[0, 5, 0, 0]
[1, 0, 0, 4]
[1, 0, 1, 3]
[1, 0, 2, 2]
[1, 0, 3, 1]
[1, 0, 4, 0]
[1, 1, 0, 3]
[1, 1, 1, 2]
[1, 1, 2, 1]
[1, 1, 3, 0]
[1, 2, 0, 2]
[1, 2, 1, 1]
[1, 2, 2, 0]
[1, 3, 0, 1]
[1, 3, 1, 0]
[1, 4, 0, 0]
[2, 0, 0, 3]
[2, 0, 1, 2]
[2, 0, 2, 1]
[2, 0, 3, 0]
[2, 1, 0, 2]
[2, 1, 1, 1]
[2, 1, 2, 0]
[2, 2, 0, 1]
[2, 2, 1, 0]
[2, 3, 0, 0]
[3, 0, 0, 2]
[3, 0, 1, 1]
[3, 0, 2, 0]
[3, 1, 0, 1]
[3, 1, 1, 0]
[3, 2, 0, 0]
[4, 0, 0, 1]
[4, 0, 1, 0]
[4, 1, 0, 0]
[5, 0, 0, 0]
- - - - - - - - - - - - - - - - - - - - 
[0, 0, 3]
[0, 1, 2]
[0, 2, 1]
[0, 3, 0]
[1, 0, 2]
[1, 1, 1]
[1, 2, 0]
[2, 0, 1]
[2, 1, 0]
[3, 0, 0]
</code></pre>
<p>FWIW, the above code can generate the 170544 sequences of <code>compositions(15, 8)</code> in around 1.6 seconds on my old 2GHz 32bit machine, running on Python 3.6 or Python 2.6. (The timing information was obtained by using the Bash <code>time</code> command).</p>
<hr/>
<p>FWIW, here's a recursive version taken from <a href="https://stackoverflow.com/a/36748940/4014959">this answer</a> by user3736966. I've modified it to use the same argument names as my code, to use lists instead of tuples, and to be compatible with Python 3.</p>
<pre><code>def compositions(num, width, parent=[]):
    if width &gt; 1:
        for i in range(num, -1, -1):
            yield from compositions(i, width - 1, parent + [num - i])
    else:
        yield parent + [num]
</code></pre>
<p>Somewhat surprisingly, this one is a little faster than the original version, clocking in at around 1.5 seconds for <code>compositions(15, 8)</code>.  </p>
<p>If your version of Python doesn't understand <code>yield from</code>, you can do this:</p>
<pre><code>def compositions(num, width, parent=[]):
    if width &gt; 1:
        for i in range(num, -1, -1):
            for t in compositions(i, width - 1, parent + [num - i]):
                yield t 
    else:
        yield parent + [num]
</code></pre>
<p>To generate the compositions in descending order, simply reverse the <code>range</code> call, i.e. <code>for i in range(num + 1):</code>.</p>
<p>Finally, here's an unreadable one-line version. :)</p>
<pre><code>def c(n, w, p=[]):
    yield from(t for i in range(n,-1,-1)for t in c(i,w-1,p+[n-i]))if w-1 else[p+[n]]
</code></pre>
<hr/>
<p>Being an inveterate tinkerer, I couldn't stop myself from making yet another version. :) This is simply the original version combined with the code for <code>combinations</code> listed in the itertools docs. Of course, the real <code>itertools.combinations</code> is <a href="https://github.com/python-git/python/blob/master/Modules/itertoolsmodule.c" rel="nofollow noreferrer">written in C</a> so it runs faster than the roughly equivalent Python code shown in the docs.</p>
<pre><code>def compositions(num, width):
    r = width - 1
    indices = list(range(r))
    revrange = range(r-1, -1, -1)
    first = [-1]
    last = [num + r]

    yield [0] * r + [num]
    while True:
        for i in revrange:
            if indices[i] != i + num:
                break
        else:
            return
        indices[i] += 1
        for j in range(i+1, r):
            indices[j] = indices[j-1] + 1
        yield [v - u - 1 for u, v in zip(first + indices, indices + last)]
</code></pre>
<p>This version is about 50% slower than the original at doing <code>compositions(15, 8)</code>: it takes around 2.3 seconds on my machine.</p>
</div>
<span class="comment-copy">Why do you think itertools fills up your RAM? It's specifically designed to be a lazy iterator, it doesn't create all permutations at once.</span>
<span class="comment-copy">@jonrsharpe well actually we tried it out. And it took way longer then our own solutions.</span>
<span class="comment-copy">That's different to filling up your RAM, though...</span>
<span class="comment-copy">well let's say it was taking way too long. might be better</span>
<span class="comment-copy">You really need to state explicitly if it's a requirement that the combinations you're returning <i>add up to</i> <code>numbers</code> (rather than that just being the maximum allowed value for each digit). That's not a normal requirement for a lock combination. Nor is is something that <code>itertools</code> will do for you directly.</span>
<span class="comment-copy">Thanks for the link to Tail call. Learned stuff.</span>
<span class="comment-copy">WoW! Thanks a lot mate. That is exactly what I was searching for.</span>
<span class="comment-copy">@fab-da-boy  My pleasure! In case you're interested, I've added a recursive solution I found elsewhere on SO to my answer. Despite what I said earlier, that recursive solution should be ok.</span>
<span class="comment-copy">Dayum. Sickly well done! I am new to generators. But this is exactly what i was looking for! Thanks a lot, once again.</span>
<span class="comment-copy">@fab-da-boy Thanks! I'm a little surprised that that recursive version is so fast. FWIW, I've added another iterative solution. It's based on my original version but it generates the combinations internally, so it's slower than the original.</span>
