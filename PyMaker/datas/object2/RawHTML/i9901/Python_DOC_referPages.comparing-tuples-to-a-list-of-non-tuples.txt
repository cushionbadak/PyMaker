<div class="post-text" itemprop="text">
<p>Wrote the code below to take in a list/set and a string and if I am able to break the string into two words that are in the list then I return. I know I'm close, I just cant get the comparison right or something. </p>
<p>e.g.</p>
<pre><code>wordBreakEasy("snowfall", ("apple", "fall", ..., "snow"))
</code></pre>
<p>would return <code>True</code>.</p>
<pre><code>def wordBreakEasy(str1, wordset):
   wordset1 = set(wordset)
   breakup = ['%s %s' % (str1[:i], str1[i:]) for i in range(1, len(str1))]
   newlist = []
   for x in breakup:
     newlist.append((x.split()))
   wordset2 = set(map(tuple, newlist))

   for wordset2 in wordset1:
</code></pre>
<p>This is where I don't know where to go now.        </p>
</div>
<div class="post-text" itemprop="text">
<p>Add your word pairs as tuples, rather than as a space-delimited single string, then filter that list on tuples that are a <em>subset</em> of your <code>wordset1</code> set:</p>
<pre><code>breakup = [(str1[:i], str1[i:]) for i in range(1, len(str1))]
present = [tup for tup in breakup if not wordset1.issuperset(tup)]
</code></pre>
<p>I used the <a href="https://docs.python.org/3/library/stdtypes.html#set.isdisjoint" rel="nofollow noreferrer"><code>set.issuperset()</code> method</a> here; it returns <code>True</code> if all of the elements in the argument iterable are present in the set, so if it returns <code>True</code> only if both elements in the tuple are present.</p>
<p>Only <em>then</em> combine the words into a single string:</p>
<pre><code>newlist = [' '.join(tup) for tup in present]
</code></pre>
<p>You don't need those intermediary lists, really; you only need to find if there is <em>any</em> such tuple that is a subset for your function to return <code>True</code>:</p>
<pre><code>breakup = ((str1[:i], str1[i:]) for i in range(1, len(str1)))
return any(wordset1.issuperset(tup) for tup in breakup)
</code></pre>
<p>I turned <code>breakup</code> into a generator expression; no need for the whole list to be built if you can find a matching word-pair early on. The <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any()</code> function</a> returns <code>True</code> as soon as one of the values it iterates over is true. Since that's a generator expression too, this tests word pairs lazily until a match is found.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; def wordBreakEasy(str1, wordset):
...     wordset1 = set(wordset)
...     breakup = ((str1[:i], str1[i:]) for i in range(1, len(str1)))
...     return any(wordset1.issuperset(tup) for tup in breakup)
...
&gt;&gt;&gt; wordBreakEasy("snowfall", ("apple", "fall", "...", "snow"))
True
&gt;&gt;&gt; wordBreakEasy("snowflake", ("apple", "fall", "...", "snow"))
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is an example with itertools.combinations</p>
<pre><code>def word_break(s, words):
    return (s in map("".join, itertools.combinations(words , 2)) or
            s in map("".join, itertools.combinations(words[::-1] , 2)))

word_break('snowfall', ['fall', 'green', 'white', 'cheese', 'snow'])
</code></pre>
<blockquote>
<p>True</p>
</blockquote>
</div>
<span class="comment-copy">Just to doublecheck; <code>"snowflake"</code> would not return True because <code>'flake'</code> is not in the word set, right?</span>
<span class="comment-copy">Is yours actually printing True or False?? My just ends finishes with exit code 0. I know, dumb question. Just trying to rap my head around it all. Actually just read through your most recent edit. All clear now! This needs 17 thumbs up. thx</span>
<span class="comment-copy">@KelvinDavis: the function <i>returns</i> a boolean value. If you were supposed to print that value, add <code>print()</code>.</span>
<span class="comment-copy">Try that algorithm with 1000 words in <code>words</code>. :)</span>
<span class="comment-copy">:) indeed, but it is still a nice solution when len(words) &lt; 3000</span>
