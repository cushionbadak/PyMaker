<div class="post-text" itemprop="text">
<p>Should I use atomic counter with Locking or can I use this? </p>
<pre><code> def somefunc(someparam):
     if someparam:
        dic['key'] +=1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, your code is not threadsafe, because using an <code>+=</code> augmented assignment on a dictionary value takes 3 opcodes to execute:</p>
<pre><code>&gt;&gt;&gt; dis.dis(compile("dic['key'] += 1", '', 'exec'))
  1           0 LOAD_NAME                0 (dic)
              3 LOAD_CONST               0 ('key')
              6 DUP_TOPX                 2
              9 BINARY_SUBSCR
             10 LOAD_CONST               1 (1)
             13 INPLACE_ADD
             14 ROT_THREE
             15 STORE_SUBSCR
             16 LOAD_CONST               2 (None)
             19 RETURN_VALUE
</code></pre>
<p>The opcode at position 9, <code>BINARY_SUBSCR</code> retrieves the current value from the dictionary. Anywhere between opcodes 9 and 15 (where <code>STORE_SUBSCR</code> puts the value back in), a thread-switch could take place and a different thread could have updated the dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's built-in structures are thread safe for single operations. The GIL (global interpreter lock) takes care of that. But it is mostly difficult to see where a statement becomes more operations.</p>
<p>Adding a lock will give you peace of mind:</p>
<pre><code>def somefunc(someparam):
    if someparam:
        with lock:
            dic['key'] +=1
</code></pre>
</div>
<span class="comment-copy">Thanks! Thats all I needed to know, I knew that dic are thread safe, but I was not sure about +=</span>
<span class="comment-copy">@OlzhasShaikenov: dictionaries are not necessarily thread-safe; if the object you are storing is an instance of a Python-defined class with <code>__hash__</code> and / or <code>__eq__</code> defined, then those methods will be executed by the interpreter when storing the object and a thread context switch can take place.</span>
<span class="comment-copy">This does not gel with what I have come to understand about the GIL and its purpose <i>at all</i> from general reading. Is its purpose then to make a single opcode threadsafe? Is there something specific I could search to understand the GIL in this context?</span>
<span class="comment-copy">@roganjosh yes, the GIL is there to ensure each opcode is processed in its entirety, leaving the evaluation loop free to make changes to the interpreter state without fear of race conditions. The <a href="https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock" rel="nofollow noreferrer">Python C API has some information</a>; follow the links from there.</span>
<span class="comment-copy">Thanks, I knew that I can use a lock.  Question was if that specific operation  was thread-safe, <a href="http://effbot.org/pyfaq/what-kinds-of-global-value-mutation-are-thread-safe.htm" rel="nofollow noreferrer">effbot.org/pyfaq/â€¦</a></span>
