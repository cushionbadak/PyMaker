<div class="post-text" itemprop="text">
<p>Anyone has any idea how to get my destructor called on object destruction?</p>
<pre><code>def __del__(self):
    os.unlink(self.pidfile)
</code></pre>
<p>Scenario: There is a Daemon that runs Process. Daemon gets a SIGTERM, and immediately sends a SIGTERM to Process. Process stops execution without <code>__del__</code> called.</p>
</div>
<div class="post-text" itemprop="text">
<p>As referenced in the comments, defining an <code>__exit__</code> method for your object and using <a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer">the with statement</a> is the preferred way of "destructing" objects.  It's more explicit and predictable.</p>
<p>However, even using the <code>with</code> statement won't guarantee clean destruction of your object if a SIGTERM is received.  In order to do something when a signal is received, you'll have to add a signal handler.</p>
<pre><code>import signal
import sys

def handle_signal(signum, frame):
    print('Got signal')
    #  Do some cleanup
    sys.exit(signum)  # Maybe ???

signal.signal(signal.SIGTERM, handle_signal)
</code></pre>
<p>At this point, you might consider calling <code>del your_object</code> in the signal handler, but even that is not guaranteed to call the <code>__del__</code> method if there are still references to that object in the program (see the docs for <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__del__#object.__del__" rel="nofollow noreferrer">__del__</a>)</p>
<p>So bottom line I think is not to expect things to go absolutely smoothly and predictably if you're depending on SIGTERM to close your Python programs.</p>
</div>
<span class="comment-copy">Are there still references to that stopped process?</span>
<span class="comment-copy">You can't.  Finalizers are not guaranteed to run.  Use <a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer">the <code>with</code> statement</a> instead of <code>__del__()</code>.  Then set a signal handler for <code>SIGTERM</code> that raises an exception which the <code>with</code> statement can react to.</span>
<span class="comment-copy">@Kevin: Finalizers aren't guaranteed to run, but we actually have more problems than that, because context manager <code>__exit__</code>s and <code>finally</code> blocks don't run by default either when Python gets a SIGTERM.</span>
<span class="comment-copy">sys.exit raises SystemExit so it will run <code>__exit__</code> cleanup code automatically.</span>
