<div class="post-text" itemprop="text">
<p>There is an answered question about <code>classmethod</code> and <code>property</code> combined together: <a href="https://stackoverflow.com/questions/128573/using-property-on-classmethods">Using property() on classmethods</a></p>
<p>I still don't understand the cause of the problem, please help.</p>
<p>My understanding of <code>classmethod</code> was that it simply replaces <code>self</code> with <code>cls</code>. With this in mind I wrote several classmethods during the past few years and now I see I was wrong all that time.</p>
<p>So what is the difference between <code>@classmethod</code> and <code>@cm</code> from the code below?</p>
<pre><code>def cm(func):
    def decorated(self, *args, **kwargs):
        return func(self.__class__, *args, **kwargs)
    return decorated

class C:
    V = 0 

    @property
    @classmethod
    def inc1(cls):
        cls.V += 1
        print("V1 =", cls.V)

    @property
    @cm 
    def inc3(cls):
        cls.V += 3
        print("V3 =", cls.V)

c = C() 
#c.inc1  # fails with:  TypeError: 'classmethod' object is not callable
c.inc3   # works
</code></pre>
<p><code>inc3</code> with <code>cm</code> works, but <code>inc1</code> with <code>classmethod</code> does not.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>what is the difference between @classmethod and @cm from the code below?</p>
</blockquote>
<p>decorator is calling during class creation time before an instance is  created.</p>
<p>In your case, since @cm returns <code>func(self.__class__, *args, **kwargs)</code>, which is relied on <code>self</code>, it should be used as a instance method.</p>
<p>On the other hand, @classmethod is able to use before an instance is created.</p>
<pre><code>def cm(func):
    def decorated(self, *args, **kwargs):
        return func(self.__class__, *args, **kwargs)
    return decorated

class C:
    @classmethod
    def inc1(cls):
        (blablabla)
    @cm 
    def inc3(cls):
        (blablabla)

C().inc1() # works as a instance method
C.inc1()   # works as a classmethod
C().inc3() # works as a instance method
C.inc3()   # TypeError: unbound method decorated() must be called with C instance as first argument (got nothing instead)
</code></pre>
<hr/>
<p>For a combination of classmethod and property, it could be done by return an customized object. <a href="https://stackoverflow.com/questions/5189699/how-can-i-make-a-class-property-in-python">Reference</a></p>
<pre><code>class ClassPropertyDescriptor(object):   
    def __init__(self, f):
        self.f = f
    def __get__(self, obj, klass=None):
        if klass is None:
            klass = type(obj)
        return self.f.__get__(obj, klass)()

def classproperty(func):
    if not isinstance(func, (classmethod, staticmethod)):
        func = classmethod(func)    
    return ClassPropertyDescriptor(func)

class C:
    @classproperty
    def inc1(cls):
        (blablabla)

C.inc1   # works as a classmethod property
</code></pre>
<p><strong>[Edit]</strong></p>
<blockquote>
<p>Q. What does the classmethod() call do with the method it decorates to achieve that? </p>
</blockquote>
<p>The implementation can be done by using <a href="https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods" rel="nofollow noreferrer">descriptor</a></p>
<pre><code>class ClassMethodDescriptor(object):    
    def __init__(self, f):
        self.f = f
    def __get__(self, obj, klass=None):
        if klass is None:
            klass = type(obj)
        def newfunc(*args):
            return self.f(klass, *args)
        return newfunc

def myclassmethod(func):
    return ClassMethodDescriptor(func)  

class C:
    @myclassmethod
    def inc1(cls):
        (blablabla)

C.inc1()   # works as a classmethod
</code></pre>
<blockquote>
<p>Q. Why is the result not callable?</p>
</blockquote>
<p>Because the implementation of <code>ClassMethodDescriptor</code> does not define <code>__call__</code> function. Once using <code>@property</code>, it will return ClassMethodDescriptor which is not callable.</p>
</div>
<div class="post-text" itemprop="text">
<p>The difference is that classmethod is not callable, and cm method is callable. This means that when the property(class) makes a call to the inputed func(which it is supposed to do), it works as you'll except for cm, but will not work for classmethod since classmethod does not have a <strong>call</strong> implemented.  </p>
</div>
<div class="post-text" itemprop="text">
<p>class method does not know anything about instance and does not require it. 
instance method knows about it's instance and it's class.</p>
<pre><code>class Foo:
    some = 'some'

class Bar(Foo):
    def __init__(self):
        self.some = 'not some'
    @classmethod
    def cls_some(cls):
        print(cls.some)
    def instance_some(self):
        print(self.some)



Bar.cls_some()
&gt;&gt;&gt;some
Bar().instance_some()
&gt;&gt;&gt;not some
</code></pre>
<p>Also as you can see you don't need an instance to call classmethod.</p>
</div>
<span class="comment-copy">You wrote that classmethods don't need an instance. What does the classmethod() call do with the method it decorates to achieve that? Why is the result not callable?</span>
<span class="comment-copy">I updated my answer. Hope this will be helpful for you.</span>
<span class="comment-copy">Thank you, it is clearer now. <code>@classmethod</code> transforms a function to a descriptor. Invoking this descriptors returns a callable function. Last missing piece is why it was designed this way. I can only guess that the main reason is "<i>The details of invocation depend on whether obj is an object or a class.</i>" (source: Descriptor HowTo Guide on docs.python.org). This makes it possible to distinguish these two cases and thus provide the right <code>cls</code> as the first argument. As I said, just guessing.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/15031999/2740386">This</a> will help you to understand the staticmethod in C++/Java/Python and introduce the definition of classmethod in python. Quote the most important sentence "use a @classmethod when you need access to the class, but not the instance"</span>
<span class="comment-copy">You have shown that  classmethods are different, because they don't need an instance. What does the classmethod() call do with the method it decorates to achieve that? Why is the result not callable?</span>
