<div class="post-text" itemprop="text">
<p>I'm new to Python 3 and it seems that I can't quite completely grasp unicode and character encoding.</p>
<p>I'm working with the output of another tool that returns the content of an html page as a bytes object. Other tools we use need this output to be in bytes type, but, I'd like to convert the bytes output to a string for some parsing and comparison to other strings. For cases that I'm interested in, printing the output bytes object shows only characters and no \x or \u binary. I'm a little confused on how best to do this and why the methods that create the desired output, actually do work.</p>
<p>I've read elsewhere that .decode() should be used in this context and this does work, but I don't understand why I am decoding an object that is already characters. From what I understand, decoding is intended for binary numbers, for example:</p>
<pre><code>&gt;&gt;&gt; b'\x41'.decode('utf-8')
'A'
</code></pre>
<p>In my understanding, all I really want to do is tell Python that an object that's been labeled as a bytes type object is actually a str object. Simply using the str() function on the bytes object also accomplishes this goal, but adds the "b" prefix and adds quotations around the string.</p>
<p>Here are the two solutions I'm working with:</p>
<pre><code>&gt;&gt;&gt; str(b'htmltext')
"b'htmltext'"

&gt;&gt;&gt; b'htmltext'.decode('utf-8')
'htmltext'
</code></pre>
<p>Essentially, either of these solutions appears to achieve what I'm looking for, but the decode() obviously seems cleaner and, from what I've read, the recommended method. I'm wondering why decode() works, given that, apparently, I'm not converting binary numbers to characters. Furthermore, is there any reason other than the unappealing "b" and quotation marks in the output that str() would not be a valid solution here?</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't confuse the developer-friendly <em>representation</em> of the <code>bytes</code> object with the data that is contained in it. You have binary data either way.</p>
<p>The developer representation makes it easy for you to see what is contained by showing anything that just <em>happens</em> to be a valid ASCII codepoint as that ASCII character, rather than the <code>\xhh</code> escape code. It's just easier to read text encoded as ASCII that way, and a lot of the world's text happens to be ASCII encoded.</p>
<p>You'll have a harder time when the data is not within the ASCII range however:</p>
<pre><code>&gt;&gt;&gt; 'Åæøéï'.encode('utf8')
b'\xc3\x85\xc3\xa6\xc3\xb8\xc3\xa9\xc3\xaf'
</code></pre>
<p>That's a UTF-8 byte sequence encoding text with accents. The above may be a little bit contrived, but most non-English text will include <em>some</em> non-ASCII text. Even English text can contain em-dashes or fancy quotes, and the <code>b'...'</code> bytes version of that is not nearly as readable as the properly decoded text version:</p>
<pre><code>&gt;&gt;&gt; '“Kragerø” is a town in Norway – in the province of Vestfold'.encode('utf8')
b'\xe2\x80\x9cKrager\xc3\xb8\xe2\x80\x9d is a town in Norway \xe2\x80\x93 in the province of Vestfold'
</code></pre>
<p>Note that the <code>b'....'</code> output is the result of using the <a href="https://docs.python.org/3/library/functions.html#repr" rel="nofollow noreferrer"><code>repr()</code> function</a> on a <code>bytes</code> object; that calls the <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer"><code>object.__repr__()</code> method</a>, which has the explicit function of producing a developer-friendly string for you. There is no dedicated <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer"><code>object.__str__()</code> method</a> on a <code>bytes</code> object, the <code>__repr__</code> method is called instead, even when you use the <code>str()</code> function. The proper way to convert a <code>bytes</code> <em>value</em> to a string is to decode (using the correct codec for the data).</p>
<p>Of course, when you have binary data that represents <em>something else</em>, like, say, image data, then keep it as <code>bytes</code>. There is no text to decode there.</p>
</div>
<span class="comment-copy">Once you understand <i>why</i> Python3 separates strings and binary data into two different types, this will be a lot easier to answer. See <a href="http://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3" rel="nofollow noreferrer">eli.thegreenplace.net/2012/01/30/…</a></span>
<span class="comment-copy"><i>Everything</i> is binary data.</span>
<span class="comment-copy">It is so natural to think that every thing in computers has a  binary representation, but in Python it's not that way - too bad!  In particular, strings are unicode objects with no encoding and an encoding is a map from unicode objects to bytes objects. It's one way to see strings, bytes objects and their relationship, but I don't see what is gained.</span>
<span class="comment-copy">This explanation is very helpful. This fills in a gap in my understanding that was haunting me elsewhere as well. Thanks!</span>
