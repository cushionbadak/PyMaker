<div class="post-text" itemprop="text">
<p>I am working on the 3SUM problem (taken from leetcode), which takes a list as input and finds all unique triplets in the lists such that a+b+c=0. I am not really sure what my code is doing wrong, but it currently returns an empty list for this list [-1, 0, 1, 2, -1, -4], so it is not recognizing any triplets that sum to 0. I would appreciate any suggestions or improved code.</p>
<p>Here's my code:</p>
<pre><code>result = []
nums.sort()
l = 0
r=len(nums)-1
for i in range(len(nums)-2):
    while (l &lt; r):
        sum = nums[i] + nums[l] + nums[r]
        if (sum &lt; 0):
            l = l + 1
        if (sum &gt; 0):
            r = r - 1
        if (sum == 0): 
            result.append([nums[i],nums[l],nums[r]])
print(result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A couple things to note.</p>
<ol>
<li>Don't use <code>sum</code> as a variable name because that's a built-in function.</li>
<li>Your indexing is a little problematic since you initialize <code>l = 0</code> and have <code>i</code> begin at <code>0</code> as well.</li>
<li>Don't rest on your laurels: increment the value of <code>l</code> when you find a successful combination. It's really easy to forget this step!</li>
</ol>
<p>An edited version of your code below.</p>
<pre><code>nums = [-1, 0, 1, 2, -1, -4]
result = []
nums.sort()
r=len(nums)-1
for i in range(len(nums)-2):
    l = i + 1  # we don't want l and i to be the same value.
               # for each value of i, l starts one greater
               # and increments from there.
    while (l &lt; r):
        sum_ = nums[i] + nums[l] + nums[r]
        if (sum_ &lt; 0):
            l = l + 1
        if (sum_ &gt; 0):
            r = r - 1
        if not sum_:  # 0 is False in a boolean context
            result.append([nums[i],nums[l],nums[r]])
            l = l + 1  # increment l when we find a combination that works

&gt;&gt;&gt; result
[[-1, -1, 2], [-1, 0, 1], [-1, 0, 1]]
</code></pre>
<p>If you wish, you can omit the repeats from the list.</p>
<pre><code>unique_lst = []
[unique_lst.append(sublst) for sublst in result if not unique_lst.count(sublst)]

&gt;&gt;&gt; unique_lst
[[-1, -1, 2], [-1, 0, 1]]
</code></pre>
<hr/>
<p>Another approach uses <a href="https://docs.python.org/3/library/itertools.html" rel="noreferrer">itertools.combinations</a>. This doesn't require a sorted list.</p>
<pre><code>from itertools import combinations

result = []
for lst in itertools.combinations(nums, 3):
    if sum(lst) == 0:
        result.append(lst)
</code></pre>
<hr/>
<p>A nested for loop version. Not a big fan of this approach, but it's basically the brute-force version of the itertools.combinations solution. Since it's the same as approach as above, no sort is needed.</p>
<pre><code>result = []
for i in range(0, len(nums)-2):
    for j in range(i + 1, len(nums)-1):
        for k in range(j + 1, len(nums)):
            if not sum([nums[i], nums[j], nums[k]]):  # 0 is False
                result.append([nums[i], nums[j], nums[k]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I did a similar approach as 3novak, but I added in the case where the number list is less than three integers returning an empty list.</p>
<pre><code>class Solution:
def threeSum(self, nums):
    """
    :type nums: List[int]
    :rtype: List[List[int]]
    """        
    # if less than three numbers, don't bother searching
    if len(nums) &lt; 3:
        return []

    # sort nums and use current sum to see if should have larger number or smaller number
    nums = sorted(nums)
    triplets = []
    for i in range(len(nums)-2):    # i point to first number to sum in list
        j = i + 1                   # j points to middle number to sum in list
        k = len(nums) - 1           # k points to last number to sum in list
        while j &lt; k:
            currSum = nums[i] + nums[j] + nums[k]
            if currSum == 0:
                tmpList = sorted([nums[i], nums[j], nums[k]])
                if tmpList not in triplets:
                    triplets.append(tmpList)
                j += 1 # go to next number to avoid infinite loop
            # sum too large, so move k to smaller number
            elif currSum &gt; 0:
                k -= 1
            # sum too small so move j to larger number
            elif currSum &lt; 0:
                j += 1
    return triplets
</code></pre>
<p>I'm doing the same problem at leetcode, but still have a runtime error. This may be able to be done by using a binary search tree-like algorithm to find the third result, as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Uncomment print statement from my solution:</p>
<pre><code>class Solution:


    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        # print('Input: {}'.format(nums))
        nums.sort() # inplace sorting, using only indexes
        N, result = len(nums), []
        # print('Sorted Input: {}'.format(nums))
        for i in range(N):

            if i &gt; 0 and nums[i] == nums[i-1]:
                # print("Duplicate found(when 'i' iterate ) at index: {}, current: {}, prev: {}, so JUMP this iteration------".format(i,nums[i], nums[i-1]))
                continue

            target = nums[i]*-1
            s,e = i+1, N-1
            # print('~'*50)
            # print("Target: {} at index: {} &amp; s: {}  e: {} {}".format(target,i, s, e, '----'*2))

            while s&lt;e: # for each target squeeze in s &amp; e
                if nums[s]+nums[e] == target:
                    result.append([nums[i], nums[s], nums[e]])
                    # print(' {} + {} == {}, with  s: {} &lt; e: {}, Triplet: {},  MOVING --&gt; R'.format(nums[s], nums[e], target,s, e,result))
                    s = s+1

                    while s&lt;e and nums[s] == nums[s-1]: # duplicate
                        # print("Duplicate found(when 's' iterates) at s: {} &lt; e: {}, WILL KEEP MOVING ---&gt; R  (s: {}) == (s-1: {})".format(s, e, nums[s], nums[s - 1]))
                        s = s+1
                elif nums[s] + nums[e] &lt; target:
                    # print(' {} + {} &lt; {}, with s: {} e: {}, MOVING ---&gt; R'.format(nums[s], nums[e], target,s, e))
                    s = s+1

                else:
                    # print(' {} + {} &gt; {}, with s: {} e: {}, MOVING &lt;--- L'.format(nums[s], nums[e], target,s, e))
                    e = e-1

        return result
</code></pre>
<p>It will help you to understand the algorithm better. Also, this algorithm is 3 times faster than the above available options. It takes ~892.18 ms compared to the above alternative with runs in ~4216.98 ms time. The overhead is because of the additional removal of duplicates logic. </p>
</div>
<span class="comment-copy">It is not an answer, it is a suggestion, so please move it into a comment.</span>
<span class="comment-copy">"I would appreciate any suggestions or improved code." I think this is under the category of improved code.</span>
<span class="comment-copy">@3novak Thank you so much! This looks great and itertools seems useful to keep in mind! I would totally use this code myself, but since I am practicing my coding skills (and may not be allowed to use imports on tests or interviews), I am really looking for code that isn't simplified too much by imports.</span>
<span class="comment-copy">Got it. Thanks for the direction, everyone. I really like the <code>while</code> approach on the sorted list. My edited response makes some suggestions for modifying that approach to obtain the desired output. Let me know if this raises other questions.</span>
<span class="comment-copy">@3novak Thank you so much for adding to your response. That was super helpful!</span>
