<div class="post-text" itemprop="text">
<p>I think my file may be mixed encoding and it is a pretty wierd file. The program I made works fine when I open a more normally encoded file. I have been extremely confused for the past 4 hours with how to get this working properly.
actually probably quite a bit longer than 4 &gt;.&gt;.</p>
<pre><code>import os

os.chdir("C:\\Users\\Kingsaber\\documents\\Desktop\\coding")

with open("file1.txt", "r", encoding = "utf-8") as a:
    line1 = a.read().splitlines()
with open("file2.txt", "r", encoding = "utf-8") as b:
    line2 = b.read().splitlines()

temp3 = tuple(set(line1) - set(line2))
print(temp3)

changes = open("output.txt", "w")
temp3 = list(temp3)

with open("output.txt", 'w') as file_handler:
    for item in temp3:
        file_handler.write("{}\n".format(item))
</code></pre>
<p>Python throws out the error</p>
<pre><code>Traceback (most recent call last):
  File "C:\Users\Kingsaber\Documents\Desktop\diff2.py", line 11, in &lt;module&gt;
    line1 = a.read().splitlines()
  File "C:\Python34\lib\codecs.py", line 313, in decode
    (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf-8' codec can't decode bytes in position 725130-725131: invalid continuation byte`
</code></pre>
<p>The idea is to open 2 very large files with about 100000 lines of code and compare file 1 to file 2 for unique lines. I found someone using a set to do this and so far after testing it with a quick txt file I created in notepad it has worked fine.</p>
<p>It seems like the file that I am trying to open however has invalid bytes for utf-8 inside of it. I would like to remove these invaid bytes before passing it into the tuple. Any help would be much obliged as I have actually tried to google for the correct way to do this but haven't found or understood a correct solution. I will actually link 1 of the files in case it helps since it is quite abnormal. Also is there a way to actually check the bytes that are invalid in notepad++. I was curious to find out what was causing the error. Viewing the file in notepad++ as a utf-8 encoded file seems to display text fine.</p>
<p><a href="http://www.mediafire.com/file/5uax2g962ad1ali/file1.txt" rel="nofollow noreferrer">http://www.mediafire.com/file/5uax2g962ad1ali/file1.txt</a></p>
<p>Is there no way to have python just ignore these bytes?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem can be boiled down to </p>
<pre><code>text = open("file1.txt", "r", encoding = "utf-8").read()
</code></pre>
<p>You can fix it by changing how the decoder handles errors. The choices are "strict" (default), "replace" (put ? in) and "ignore" (skip). UTF-8 has the interesting property that it can figure out where the next character starts so you shouldn't loose too much.</p>
<p>...and you can make the set from the get go</p>
<pre><code>with open("file1.txt", "r", encoding = "utf-8", errors="replace") as a:
    set1 = set(a)
</code></pre>
</div>
<span class="comment-copy"><i>"I found someone using a tuple to do this..."</i> - Are you sure it was not a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer"><code>set()</code></a>?</span>
<span class="comment-copy">Also, could you show the full traceback your getting?</span>
<span class="comment-copy">The error is quite clear: there's an invalid byte in that position. Other than reading up to the offending byte, or trying to hack and correct the file with a hex editor, there's not too much you can do.</span>
<span class="comment-copy">yes it was a set() haha. I updated the post with the error.</span>
<span class="comment-copy">I see a hex editor? Is there not a way to ignore these invalid bytes without manually editing it that way?</span>
<span class="comment-copy">The “replace” error handler uses <code>�</code> (U+FFFD) as the replacement character, not <code>?</code>.  There's also “surrogateescape”, which replaces the unknown bytes with the unpaired surrogate characters U+DC80 through U+DCFF, useful for preserving the original corrupted data.</span>
<span class="comment-copy">@dan04 - interesting. i guess shouldn't trust ASCII versions of the doc!</span>
<span class="comment-copy">Or you may have just been confusing it with the inverse construct of <code>open(filename, 'w', encoding='ASCII', errors='replace')</code> (or any other encoding that doesn't include the <code>�</code> character), which actually does replace non-encodable characters with an ASCII <code>?</code> (0x3F).</span>
<span class="comment-copy">Thanks man that worked perfectly.</span>
