<div class="post-text" itemprop="text">
<p>I have a list of lists:</p>
<pre><code>l = [['a1', 2], ['a1', 3], ['a1', 1], ['b1', 4], ['b1', 2], ['b1', 6], ['c1', 2]]
</code></pre>
<p>I would like to compare each "sub-list" with the others "sub-lists", match those that have the same value for index <code>[0]</code> and just keep the ones that have the biggest index <code>[1]</code>, so that the result is something like this:</p>
<pre><code>resultingList = [['a1', 3], ['b1', 6], ['c1', 2]]
</code></pre>
<p>I've been trying various for-loops and conditional statements, but I've got stuck. </p>
<p>Could someone give me a hand with this and put me on the right track?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a></p>
<pre><code>from itertools import groupby
l=[['a1',2],['a1',3],['a1',1],['b1',4],['b1',2],['b1',6],['c1',2]]
l = [max(g, key=lambda x: x[1]) for k, g in groupby(sorted(l), key=lambda x: x[0])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Natural answer is using <code>itertools.groupby</code>, grouped by first element of the sublist, and simply apply <code>max</code> to each group. Since first grouped elements are the same, <code>max</code> naturally maxes according to second element: the integer.</p>
<pre><code>import itertools

l=[['a1',2],['a1',3],['a1',1],['b1',4],['b1',2],['b1',6],['c1',2]]

print([max(v) for _,v in itertools.groupby(l,lambda x : x[0])])
</code></pre>
<p>result:</p>
<pre><code>[['a1', 3], ['b1', 6], ['c1', 2]]
</code></pre>
<p>Note: if the list is not sorted according to first element values, <code>sorted(l)</code> needs to be used instead of <code>l</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Make a dictionary to hold all the max values:</p>
<pre><code>L = [['a1',2],['a1',3],['a1',1],['b1',4],['b1',2],['b1',6],['c1',2], ...]
d = {}

for k,v in L:
    d[k] = max(d.get(k, -float('inf'), v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could replace the <code>lambda</code> expressions in @Patrick Haugh's solution by <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a> like this:</p>
<pre><code>In [18]: from itertools import groupby

In [19]: from operator import itemgetter

In [20]: l = [['b1', 2], ['a1', 2], ['a1', 3], ['c1', 2], ['a1', 1], ['b1', 4], ['b1', 6]]

In [21]: [max(g, key=itemgetter(1)) for _, g in groupby(sorted(l), itemgetter(0))]
Out[21]: [['a1', 3], ['b1', 6], ['c1', 2]]
</code></pre>
</div>
<span class="comment-copy">show us your attempt(s)</span>
<span class="comment-copy">Look at <code>itertools.groupby()</code>.</span>
<span class="comment-copy">no need to sort l, it seems already sorted. And if you sort it, no need to pass a lambda. Natural sort works fine here (that's minor)</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre I waffled on it, but I figured that there was no guarantee of real data looking as nice as the test data.  I'm not sure what you mean by "no need to pass a lambda".  It's my understanding that the default behaviour of <code>groupby</code> is to use the identity to generate keys, so wouldn't that fail to group <code>['a1', 1]</code> and <code>['a1', 2]</code> for example?</span>
<span class="comment-copy">I misread, I thought <code>lambda</code> was inside the <code>sorted</code> function. I agree.</span>
