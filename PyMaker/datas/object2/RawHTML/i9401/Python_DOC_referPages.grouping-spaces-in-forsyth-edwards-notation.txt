<div class="post-text" itemprop="text">
<p>In <a href="https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation" rel="nofollow noreferrer">Forsyth-Edwards notation</a>, I have a string like this:</p>
<pre><code>string = rnbqkbnr/pppppppp/********/********/********/********/PPPPPPPP/RNBQKBNR
</code></pre>
<p>where <code>*</code> represents an empty space.
It needs to be notated like this:</p>
<pre><code>string = rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR
</code></pre>
<p>where the '8' represents the number of empty spaces.</p>
<p>For example, given a string like this:</p>
<pre><code>string = rnbqkbnr/pppppppp/*r*****/****p***/********/*******/PPPPPPPP/RNBQKBNR
</code></pre>
<p>The result should be:</p>
<pre><code>string = rnbqkbnr/pppppppp/1r6/4p3/8/8/PPPPPPPP/RNBQKBNR
</code></pre>
<p>Can anyone help me in the right direction?</p>
</div>
<div class="post-text" itemprop="text">
<p>The first thing that comes to mind is <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">regular expressions</a>. A regex that matches a sequence of spaces is just <code>\s+</code>, and you can use <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub()</code></a> or the <a href="https://docs.python.org/3/library/re.html#re.regex.sub" rel="nofollow noreferrer"><code>sub()</code> method of a compiled pattern</a> to replace matches (i.e. sequences of spaces) with whatever you like. You can give <code>sub()</code> a function as the replacement value, and that function will be called on each <a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow noreferrer">match object</a> to compute the actual replacement.</p>
<pre><code>re.sub(r'\s+', lambda m: str(m.end() - m.start()), string)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>re.sub</code> and substitute into the string the length of the matches:</p>
<pre><code>import re
s = re.sub("\\*+", lambda x: str(len(x.group(0))), s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without regex, you may achieve the same result using <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> with <em>list comprehension</em> expression as:</p>
<pre><code>from itertools import groupby, chain
s = 'rnbqkbnr/pppppppp/*r*****/****p***/********/*******/PPPPPPPP/RNBQKBNR'

new_str = ''.join(chain(*[[str(len(list(j)))] if i else list(j) \     
                      for i, j in groupby(s, lambda x: x=='*')]))
</code></pre>
<p>Cleaner version of this could be written with explicit <code>for</code> loop as:</p>
<pre><code>my_string = 'rnbqkbnr/pppppppp/*r*****/****p***/********/*******/PPPPPPPP/RNBQKBNR'
new_list = []

for is_blank, group in groupby(my_string, lambda x: x=='*'):
    temp_list = list(group)
    if is_blank:
        temp_list = [str(len(temp_list))]
    new_list.extend(temp_list)

new_str = ''.join(new_list)
</code></pre>
<p>Final value hold by <code>new_str</code> will be:</p>
<pre><code>&gt;&gt;&gt; new_str
'rnbqkbnr/pppppppp/1r5/4p3/8/7/PPPPPPPP/RNBQKBNR'
</code></pre>
</div>
<span class="comment-copy">If I understand the notation correctly, your second example is wrong - it looks like you're missing a square in a the third and sixth ranks. And the desired output doesn't match the input either; you have <code>1r7</code> instead of <code>1r5</code> (which corresponds to what you wrote) or <code>1r6</code> (which it should be). Again, if I understand the notation correctly, which I'm not sure I do.</span>
<span class="comment-copy">@DavidZ - I suspect that's just a made-up value the OP is trying to run the substitutions on.  The last example doesn't describe a legal board position anyway, since there are 3 black rooks and 9 black pawns on the board, with the extra pieces having already moved, but white having not yet moved at all.</span>
<span class="comment-copy">I see, you're right. I made a typo. the correct one must be 1r6 i corrected it. And yes it's a made up value for example. Thanks</span>
<span class="comment-copy">You can just use <code>len</code> on the match rather than doing the arithmetic yourself.</span>
<span class="comment-copy">No, match objects don't have a <code>__len__()</code> method. (Believe me, I checked.)</span>
<span class="comment-copy">I meant on the first group, as per my answer.</span>
<span class="comment-copy">Yes, but there's no particular advantage in doing that over subtracting the end and start positions.</span>
<span class="comment-copy">It's a matter of opinion, but I think the intent is clearer if  you use <code>len</code>, and doing your own arithmetic is just another way of introducing a bug.</span>
