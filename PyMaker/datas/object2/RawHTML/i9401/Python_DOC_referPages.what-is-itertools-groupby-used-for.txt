<div class="post-text" itemprop="text">
<p>While reading the python documentation I came across the <code>itertools.groupby()</code>
function. It was not very straightforward so I decided to look up some info here on stackoverflow. I found something from <a href="https://stackoverflow.com/questions/773/how-do-i-use-pythons-itertools-groupby">How do I use Python's itertools.groupby()?</a>.</p>
<p>There seems to be little info about it here and in the documentation so I decided I to post my observations for comments.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>To start with, you may read the documentation <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">here</a>.</p>
<p>I will place what I consider to be the most important point first. I hope the reason will become clear after the examples.</p>
<p><strong>ALWAYS SORT ITEMS WITH THE SAME KEY TO BE USED FOR GROUPING SO AS TO AVOID UNEXPECTED RESULTS</strong></p>
<p><code>itertools.groupby(iterable, key=None or some func)</code>
takes a list of iterables and groups them based on a specified key. The key specifies what action to apply to each individual iterable, the result of which is then used as the heading for each grouping the items; items which end up having same 'key' value will end up in the same group.</p>
<p>The return value is an iterable similar to a dictionary in that it is of the form <code>{key : value}</code>.</p>
<p>Example 1</p>
<pre><code># note here that the tuple counts as one item in this list. I did not
# specify any key, so each item in the list is a key on its own.
c = groupby(['goat', 'dog', 'cow', 1, 1, 2, 3, 11, 10, ('persons', 'man', 'woman')])
dic = {}
for k, v in c:
    dic[k] = list(v)
dic
</code></pre>
<p>results in</p>
<pre><code>{1: [1, 1],
 'goat': ['goat'],
 3: [3],
 'cow': ['cow'],
 ('persons', 'man', 'woman'): [('persons', 'man', 'woman')],
 10: [10],
 11: [11],
 2: [2],
 'dog': ['dog']}
</code></pre>
<p>Example 2</p>
<pre><code># notice here that mulato and camel don't show up. only the last element with a certain key shows up, like replacing earlier result
# the last result for c actually wipes out two previous results.

list_things = ['goat', 'dog', 'donkey', 'mulato', 'cow', 'cat', ('persons', 'man', 'woman'), \
               'wombat', 'mongoose', 'malloo', 'camel']
c = groupby(list_things, key=lambda x: x[0])
dic = {}
for k, v in c:
    dic[k] = list(v)
dic
</code></pre>
<p>results in</p>
<pre><code>{'c': ['camel'],
 'd': ['dog', 'donkey'],
 'g': ['goat'],
 'm': ['mongoose', 'malloo'],
 'persons': [('persons', 'man', 'woman')],
 'w': ['wombat']}
</code></pre>
<p>Now for the sorted version</p>
<pre><code> # but observe the sorted version where I have the data sorted first on same key I used for grouping
list_things = ['goat', 'dog', 'donkey', 'mulato', 'cow', 'cat', ('persons', 'man', 'woman'), \
               'wombat', 'mongoose', 'malloo', 'camel']
sorted_list = sorted(list_things, key = lambda x: x[0])
print(sorted_list)
print()
c = groupby(sorted_list, key=lambda x: x[0])
dic = {}
for k, v in c:
    dic[k] = list(v)
dic
</code></pre>
<p>results in</p>
<pre><code>['cow', 'cat', 'camel', 'dog', 'donkey', 'goat', 'mulato', 'mongoose', 'malloo', ('persons', 'man', 'woman'), 'wombat']
{'c': ['cow', 'cat', 'camel'],
 'd': ['dog', 'donkey'],
 'g': ['goat'],
 'm': ['mulato', 'mongoose', 'malloo'],
 'persons': [('persons', 'man', 'woman')],
 'w': ['wombat']}
</code></pre>
<p>Example 3</p>
<pre><code>things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "harley"), \
          ("vehicle", "speed boat"), ("vehicle", "school bus")]
dic = {}
f = lambda x: x[0]
for key, group in groupby(sorted(things, key=f), f):
    dic[key] = list(group)
dic
</code></pre>
<p>results in</p>
<pre><code>{'animal': [('animal', 'bear'), ('animal', 'duck')],
 'plant': [('plant', 'cactus')],
 'vehicle': [('vehicle', 'harley'),
  ('vehicle', 'speed boat'),
  ('vehicle', 'school bus')]}
</code></pre>
<p>Now for the sorted version. I changed the tuples to lists here. Same results either way.</p>
<pre><code>things = [["animal", "bear"], ["animal", "duck"], ["vehicle", "harley"], ["plant", "cactus"], \
          ["vehicle", "speed boat"], ["vehicle", "school bus"]]
dic = {}
f = lambda x: x[0]
for key, group in groupby(sorted(things, key=f), f):
    dic[key] = list(group)
dic
</code></pre>
<p>results in</p>
<pre><code>{'animal': [['animal', 'bear'], ['animal', 'duck']],
 'plant': [['plant', 'cactus']],
 'vehicle': [['vehicle', 'harley'],
  ['vehicle', 'speed boat'],
  ['vehicle', 'school bus']]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As always the <a href="https://docs.python.org/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">documentation of the function</a> should be the first place to check. However <code>itertools.groupby</code> is certainly one of the trickiest <code>itertools</code> because it has some possible pitfalls:</p>
<ul>
<li><p>It only groups the items if their <code>key</code>-result is the same for successive items:</p>
<pre><code>from itertools import groupby

for key, group in groupby([1,1,1,1,5,1,1,1,1,4]):
    print(key, list(group))
# 1 [1, 1, 1, 1]
# 5 [5]
# 1 [1, 1, 1, 1]
# 4 [4]
</code></pre>
<p>One could use <code>sorted</code> before - if one wants to do an overall <code>groupby</code>.</p></li>
<li><p>It yields two items, and the second one is an iterator (so one needs to iterate over the second item!). I explicitly needed to cast these to a <code>list</code> in the previous example.</p></li>
<li><p>The second yielded element is discarded if one advances the <code>groupby</code>-iterator:</p>
<pre><code>it = groupby([1,1,1,1,5,1,1,1,1,4])
key1, group1 = next(it)
key2, group2 = next(it)
print(key1, list(group1))
# 1 []
</code></pre>
<p>Even if <code>group1</code> isn't empty!</p></li>
</ul>
<p>As already mentioned one can use <code>sorted</code> to do an overall <code>groupby</code> operation but that's extremely inefficient (and throws away the memory-efficiency if you want to use groupby on generators). There are better alternatives available if you can't guarantee that the input is <code>sorted</code> (which also don't require the <code>O(n log(n))</code> sorting time overhead):</p>
<ul>
<li><a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a></li>
<li><a href="https://iteration-utilities.readthedocs.io/en/latest/generated/groupedby.html#iteration_utilities.groupedby" rel="nofollow noreferrer"><code>iteration_utilities.groupedby</code></a></li>
<li>probably more.</li>
</ul>
<p>However it's great to check local properties. There are two recipes in the <a href="https://docs.python.org/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code>-recipes section</a>:</p>
<pre><code>def all_equal(iterable):
    "Returns True if all the elements are equal to each other"
    g = groupby(iterable)
    return next(g, True) and not next(g, False)
</code></pre>
<p>and:</p>
<pre><code>def unique_justseen(iterable, key=None):
    "List unique elements, preserving order. Remember only the element just seen."
    # unique_justseen('AAAABBBCCDAABBB') --&gt; A B C D A B
    # unique_justseen('ABBCcAD', str.lower) --&gt; A B C A D
    return map(next, map(itemgetter(1), groupby(iterable, key)))
</code></pre>
</div>
<span class="comment-copy">Did you checked <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>grouby()</code> document</a>? Which part was not straight forward in this?</span>
<span class="comment-copy">@MoinuddinQuadri The first sentence of the OP's question states that they read the Python documentation.</span>
<span class="comment-copy">you ask a question for which you have an elaborate answer prepared? really? why not have all that in the question and leave the answers section for discussion?</span>
<span class="comment-copy">@hiroprotagonist <a href="https://stackoverflow.blog/2011/07/its-ok-to-ask-and-answer-your-own-questions/">It's perfectly acceptable to ask a question for the sole purpose of answering it</a>. I've done it myself.  "why not have all that in the question" Because an answer isn't part of a question. An answer is an answer.</span>
<span class="comment-copy">@EmettSpeer My actual question is <i>"Which part was not straight forward in this?"</i>. I mentioned the link to the doc just to make sure that OP checked the official Python document, and not of any tutorial</span>
<span class="comment-copy">"<code>itertools.groupby(iterable, key=None or some func)</code> takes a list of iterables" Does it take a list of iterables, or just an iterable? A list is an iterable.</span>
<span class="comment-copy">The docs doesn't say explicitly. But from the examples I posted you can see that I used both a list and nested list. So it can take an "iterable" (Example 1) as well as a "list of iterables" (Example 2). You may even pass in a single string and you'd still be in business</span>
<span class="comment-copy">Thanks. I'll definitely take note in case I need some alternatives sometime. For now I'm reading the docs section by section so as not to jumble up everything. And a happy new  year to you</span>
