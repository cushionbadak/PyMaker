<div class="post-text" itemprop="text">
<p>I'm learning Flask by building a blackjack game. </p>
<p>I've written a <code>game.py</code> module that contains the game logic. In it, I define the dealer's shoe as such: (this is an excerpt)</p>
<pre><code>class Blackjack(object):
    def __init__(self):
        pass

    NO_OF_DECKS = 1

    SUITS = ['clubs', 'spades', 'diamonds', 'hearts']

    RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']

    VALUES = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8,
              '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10}

class Shoe(Blackjack):
    """ Creates a new shoe object from which cards are dealt 
    to the player and the dealer.

    Input arguments:
    decks :: the number of decks the player wishes to play with.
    """
    def __init__(self, decks=1):
        self.cards_in_shoe = {}
        self.total_cards = decks * 52
        for i in Blackjack.SUITS:
            self.cards_in_shoe[i] = Blackjack.RANKS * decks

    def get_random_card(self):

        random_suit = random.choice(self.cards_in_shoe.keys())
        cards_in_suit = self.cards_in_shoe[random_suit]
        random_card = random.choice(cards_in_suit)

        cards_in_suit.remove(random_card)

        # deleting suit if cards exhausted.
        if len(self.cards_in_shoe[random_suit]) == 0:
            del self.cards_in_shoe[random_suit]

        return (random_suit, random_card)

    def remaining_cards_in_shoe(self):
        """ Returns the total number of cards remaining to be
        drawn for both player and dealer.
        """
        return sum(len(v) for v in self.cards_in_shoe.itervalues())
</code></pre>
<p>Now, in my 'trygame.html' template, I would like to be able to deal new cards, with the <code>remaining_cards_in_shoe</code> property decreasing with every new card dealt. Unfortunately, this is currently not working. With a single deck, the counter remains at 51 (after the first card has been dealt).</p>
<p>Here is my current <code>@app.route('/trygame')</code> view:</p>
<pre><code>@app.route('/trygame', methods=['GET', 'POST'])
def trygame():

    shoe = game.Shoe()
    card = shoe.get_random_card()
    remaining_cards = shoe.remaining_cards_in_shoe()

    return render_template('trygame.html',
                           card=card,
                           remaining_cards=remaining_cards)
</code></pre>
<p>Now, I suspect the issue comes with always reinitializing the shoe object. The button on the template is simply defined as:</p>
<pre><code>&lt;p&gt;Here we will insert a card:  {{ card }}&lt;/p&gt;
&lt;p&gt;Remaining cards in shoe: {{ remaining_cards }}&lt;/p&gt;

&lt;form action="/trygame" method="post"&gt;
  &lt;button type="submit" class="btn btn-primary"&gt;Deal card&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p>I am unsure how to proceed at this point, as I'm not 100% certain where the issue lies. I have attempted creating a session, but I do not know how to store a class instance in it, with its methods available. Additionally, I'm not sure if it's a wise idea to do this in the first place. I'd like to avoid the user being able to see the content of the cards dictionary.</p>
<p>I was hoping I could do something like this:</p>
<pre><code>@app.route('/trygame', methods=['GET', 'POST'])
def trygame():
# I believe this is the way to go, but it won't work
    print session

    if request.method == 'POST':
        card = session['shoe'].get_random_card()
        remaining_cards= session['shoe'].remaining_cards_in_shoe()
        return render_template('trygame.html',
                               card=card,
                               remaining_cards=remaining_cards)

    session['shoe'] = game.Shoe()
    card = session['shoe'].get_random_card()
    remaining_cards = session['shoe'].remaining_cards_in_shoe()

    return render_template('trygame.html', 
                           card=card,
                           remaining_cards=remaining_cards)
</code></pre>
<p>But it's not working.
What exactly IS the issue?
What are my options? <code>current_app</code>, <code>session</code>, <code>redis</code>? 
What is best practice in this scenario, and could you provide a working example?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try reading up on these things, <a href="http://flask-sqlalchemy.pocoo.org/2.1/" rel="nofollow noreferrer">SQLAlchemy in Flask</a> and <a href="http://flask.pocoo.org/docs/0.12/quickstart/#sessions" rel="nofollow noreferrer">Sessions in Flask.</a> You can use both of these. The database, or SQLAlchemy, will store the card indefinitely until you delete them. The session will store the cards on the client side until they delete them, either the browser is closed or the client manually deletes a session. </p>
<p>For the problem you are trying to solve, a card dealing game, I suggest using sessions. Here is a bit of example code.</p>
<pre><code>from flask import session
import random

session['user cards'] = []
# Default cards = empty list. Do the above to reset.

def deal_card():
  card_drawn = random.choice(CARDS)
  session['user cards'].append(card_drawn)
  # The "CARDS" variable is not here but it's just a list of cards.
  CARDS.pop(CARDS.index(card_drawn))

def print_cards():
  for card in session['user cards']:
    print(card)
</code></pre>
</div>
<span class="comment-copy">I don't think this solves my issue. The way I see it, I need to store the object including the possibility to perform method calls on it. My current problem is that <code>cards_remaining_in_shoe()</code> is being reset.</span>
<span class="comment-copy">Or maybe it does and I just don't fully understand it yet. Thank you for the resources, I do some research. Perhaps involve server side sessions with redis. Also reading up on HTTP</span>
<span class="comment-copy">Sounds good, if you're getting a reset within a class with Python you might want to read up on <a href="https://docs.python.org/3/library/gc.html" rel="nofollow noreferrer">Python Garbage Collecting.</a> Python garbage collects automatically whenever it thinks that too much storage is being used, this may or may not be what your problem is.</span>
