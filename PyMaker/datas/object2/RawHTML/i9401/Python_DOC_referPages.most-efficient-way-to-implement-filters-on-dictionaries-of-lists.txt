<div class="post-text" itemprop="text">
<p>I have created a data structure for my purposes, which is a simple dictionary with a list of values as data:</p>
<pre><code>{'Procedure_name': ('compound', 'hardware', 'tempval', 'colorval', 'energyval'), .....}
</code></pre>
<p>imagine a sequence of procedures, where you mix 2 compounds, and record temperature variation, potential energy, variance in color and such, this is what each entry in the dictionary represent.</p>
<p>What would be the best way to achieve a filter implementation? This is an example of what would like to achieve. My filter mostly will aim at use just few parameters (like compound, hardware), either as single or as combined</p>
<pre><code>dataset = {'Att1_Cl': ('carb', 'Spectrometer_v1', '33', '0.25', '445'), 
    'Att1_Na': ('carb', 'Spectrometer_v1', '34.2', '0.21', '401'), 
    'Att1_Si': ('alc', 'Photometer_V2', '32.1', '0.43', '521'), 
    'Att1_Cr': ('carb', 'Photometer_V3', '32.5', '0.49', '511')}

def filter_data(filter)
    ....
    return filtered_data # the entry from the dictionary that satisfy the condition
</code></pre>
<p>As output examples:</p>
<pre><code>print (filter_data (['carb']))

Att1_Cl
('carb', 'Spectrometer_v1', '33', '0.25', '445')
Att1_Na
('carb', 'Spectrometer_v1', '34.2', '0.21', '401') 
Att1_Cr
('carb', 'Photometer_V3', '32.5', '0.49', '511')

print (filter_data (['Spectrometer_v1']))

Att1_Cl
('carb', 'Spectrometer_v1', '33', '0.25', '445')
Att1_Na
('carb', 'Spectrometer_v1', '34.2', '0.21', '401')

print (filter_data (['carb', 'Photometer_V3']))

Att1_Cr
('carb', 'Photometer_V3', '32.5', '0.49', '511')
</code></pre>
<p>I was thinking to use a list as possible parameters, and compare each entry in the dataset; but I can't find an efficient way to get this done. This is my first approach</p>
<pre><code>def filter_data(filter):

    for procedure in dataset:
        single_dataset = dataset[procedure]
        if filter in single_dataset:
            print(procedure)
            print(single_dataset)
</code></pre>
<p>This works if I have one entry, but if I have multiple entry in the filter list; I have to make more than one pass on the dataset, and this is not really efficient nor scalable, in case I will add more parameters to my data structure.
The other alternative that I had in mind, was to save pre-made filters, that get called via the filter parameter passed to the function, but this is a nightmare from the perspective of maintain code, since each change in the filter has to be hardcoded.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of storing the parameters as <code>list</code> you could store them as nested dictionaries. This would make the filter implementation easier and it would also allow you to filter based on parameters and not only their values. Say you want to find all the procedures where <code>tempval == '30'</code>. If you call <code>filter_data (['30'])</code> you might get procedures where <code>energyval</code> is <code>'30'</code> instead.</p>
<p>One way to filter the nested <code>dict</code> is to use generator expression with <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow noreferrer"><code>all</code></a> within <code>if</code> block. You could easily convert the generator to desired return type or terminate the filtering when first match is found:</p>
<pre><code>dataset = {
    'Att1_Cl': {'compound': 'carb', 'hardware': 'Spectrometer_v1', 'tempval': '33', 'colorval': '0.25', 'energyval': '445'}, 
    'Att1_Na': {'compound': 'carb', 'hardware': 'Spectrometer_v1', 'tempval': '34.2', 'colorval': '0.21', 'energyval': '401'}, 
    'Att1_Si': {'compound': 'alc', 'hardware': 'Photometer_V2', 'tempval': '32.1', 'colorval': '0.43', 'energyval': '521'}, 
    'Att1_Cr': {'compound': 'carb', 'hardware': 'Photometer_V3', 'tempval': '32.5', 'colorval': '0.49', 'energyval': '511'}
}

def filter_data(f):
    return ((k, v) for k, v in dataset.items() if all(v[fk] == fv for fk, fv in f.items()))

print(list(filter_data({'compound': 'carb', 'hardware': 'Spectrometer_v1'})))
</code></pre>
<p>Output:</p>
<pre><code>[('Att1_Cl', {'energyval': '445', 'tempval': '33', 'hardware': 'Spectrometer_v1', 'compound': 'carb', 'colorval': '0.25'}), 
 ('Att1_Na', {'energyval': '401', 'tempval': '34.2', 'hardware': 'Spectrometer_v1', 'compound': 'carb', 'colorval': '0.21'})]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm developing a chatbot which needed filtering functionality that I believe is similar to what you require. I maintain a database of 'response articles' that have the form <code>&lt;&lt;response template&gt;&gt; #tag1 #tag2 ... #tagN</code>. For example: "Hi there, how are you doing? <code>#greeting</code> <code>#wellbeing</code>".</p>
<p>This allows me to implement logic within the chatbot where it tries to compose appropriate responses via a tag requirement system which supports both "And" and "Or" sub-requirements. These sub-requirements can be nested to form a tree structure.</p>
<p>These tag requirements can be parsed from a string. For example, the string "emote,cute;emote,happy" can be satisfied by any response article containing <em>either</em> <code>#emote</code> and <code>#cute</code> <em>or</em> <code>#emote</code> and <code>#happy</code>.</p>
<p>In your case, the response article would be analogous to the procedure name, and the response classifications to the procedure attributes. You could adopt something similar to my approach to specify requirements like "carb,spectrometer*;alk,spectrometer*" to match all procedures that involve a spectrometer and involve either 'carb' or 'alk' (or both).</p>
<p>My code is written in C# but hopefully you might still find it useful. <a href="https://github.com/TAGC/Mofichan/blob/develop/src/Mofichan.DataAccess/Response/TagRequirement.cs" rel="nofollow noreferrer">This page</a> is probably the best place to start looking, and you can see examples of its usage in <a href="https://github.com/TAGC/Mofichan/blob/1a85a01d3cc6dfc20630664aec86e42bdc4a69fd/test/Mofichan.Tests/DataAccess/TagRequirementTests.cs" rel="nofollow noreferrer">this test class.</a></p>
<p>For the sake of convenience and redundancy I'll copy the code below.</p>
<p><strong>Implementation</strong></p>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Mofichan.DataAccess
{
    /// &lt;summary&gt;
    /// Represents a tag requirement.
    /// &lt;para&gt;&lt;/para&gt;
    /// These will typically be used to filter the kind of responses
    /// Mofichan will choose to respond with based on the tags
    /// associated with each possible response she knows about.
    /// &lt;/summary&gt;
    internal interface ITagRequirement
    {
        /// &lt;summary&gt;
        /// Returns whether this &lt;c&gt;ITagRequirement&lt;/c&gt; is satisfied by
        /// the provided collection of tags.
        /// &lt;/summary&gt;
        /// &lt;param name="tags"&gt;The tag collection.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if &lt;c&gt;this&lt;/c&gt; is satisfied; otherwise, &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        bool SatisfiedBy(IEnumerable&lt;string&gt; tags);
    }

    /// &lt;summary&gt;
    /// Provides static fields and methods.
    /// &lt;/summary&gt;
    internal static class TagRequirement
    {
        internal static readonly char AndSeparator = ',';
        internal static readonly char OrSeparator = ';';

        private static readonly string TagMatch = @"[a-zA-Z0-9\-]+";
        private static readonly string AndMatcher = string.Format(@"((?&lt;and&gt;{0}){1})*(?&lt;and&gt;{0})", TagMatch, AndSeparator);
        private static readonly string OrMatcher = string.Format(@"^((?&lt;or&gt;{0}){1})*(?&lt;or&gt;{0})$", AndMatcher, OrSeparator);

        /// &lt;summary&gt;
        /// Parses a string and returns the represented &lt;see cref="ITagRequirement"/&gt;. 
        /// &lt;/summary&gt;
        /// &lt;param name="representation"&gt;The tag requirement string representation.&lt;/param&gt;
        /// &lt;returns&gt;The represented tag requirement.&lt;/returns&gt;
        /// &lt;exception cref="ArgumentException"&gt;Thrown if the representation is invalid.&lt;/exception&gt;
        public static ITagRequirement Parse(string representation)
        {
            var root = new AnyTagRequirement(from orGroup in GetMatchesFromRegex(representation, OrMatcher, "or")
                                             let andGroup = from tag in GetMatchesFromRegex(orGroup, AndMatcher, "and")
                                                            select new LeafTagRequirement(tag)
                                             let allTagRequirement = new AllTagRequirement(andGroup)
                                             select allTagRequirement);

            return root;
        }

        private static IEnumerable&lt;string&gt; GetMatchesFromRegex(string input, string pattern, string matchName)
        {
            var regex = Regex.Match(input, pattern);

            if (!regex.Success)
            {
                var message = string.Format("Input '{0}' is invalid for pattern '{1}'", input, pattern);
                throw new ArgumentException(message);
            }

            var captures = regex.Groups[matchName].Captures;

            return from i in Enumerable.Range(0, captures.Count)
                   select captures[i].Value;
        }
    }

    internal abstract class CompositeTagRequirement : ITagRequirement
    {
        protected CompositeTagRequirement(IEnumerable&lt;ITagRequirement&gt; children)
        {
            this.Children = children;
        }

        public IEnumerable&lt;ITagRequirement&gt; Children { get; }

        public abstract bool SatisfiedBy(IEnumerable&lt;string&gt; tags);
    }

    internal sealed class AllTagRequirement : CompositeTagRequirement
    {
        public AllTagRequirement(IEnumerable&lt;ITagRequirement&gt; children) : base(children)
        {
        }

        public override bool SatisfiedBy(IEnumerable&lt;string&gt; tags)
        {
            return this.Children.All(it =&gt; it.SatisfiedBy(tags));
        }

        public override string ToString()
        {
            return string.Join(TagRequirement.AndSeparator.ToString(), this.Children);
        }
    }

    internal sealed class AnyTagRequirement : CompositeTagRequirement
    {
        public AnyTagRequirement(IEnumerable&lt;ITagRequirement&gt; children) : base(children)
        {
        }

        public override bool SatisfiedBy(IEnumerable&lt;string&gt; tags)
        {
            return this.Children.Any(it =&gt; it.SatisfiedBy(tags));
        }

        public override string ToString()
        {
            return string.Join(TagRequirement.OrSeparator.ToString(), this.Children);
        }
    }

    internal sealed class LeafTagRequirement : ITagRequirement
    {
        private readonly string requiredTag;

        public LeafTagRequirement(string tag)
        {
            this.requiredTag = tag;
        }

        public bool SatisfiedBy(IEnumerable&lt;string&gt; tags)
        {
            return tags.Contains(this.requiredTag);
        }

        public override string ToString()
        {
            return this.requiredTag;
        }
    }
}
</code></pre>
<p><strong>Tests</strong></p>
<pre><code>using System;
using System.Collections.Generic;
using Mofichan.DataAccess;
using Shouldly;
using Xunit;

namespace Mofichan.Tests.DataAccess
{
    public class TagRequirementTests
    {
        public static IEnumerable&lt;object&gt; TagRequirementExamples
        {
            get
            {
                yield return new object[]
                {
                    // Requirement
                    "foo",

                    // Satisfied by
                    new[]
                    {
                        new[] { "foo" },
                    },

                    // Unsatisfied by
                    new[]
                    {
                        new[] { "bar" },
                        new[] { "baz" },
                    },
                };

                yield return new object[]
                {
                    // Requirement
                    "foo;bar",

                    // Satisfied by
                    new[]
                    {
                        new[] { "foo" },
                        new[] { "foo" },
                        new[] { "foo", "bar" },
                    },

                    // Unsatisfied by
                    new[]
                    {
                        new[] { "baz" },
                    },
                };

                yield return new object[]
                {
                    // Requirement
                    "foo,bar;baz",

                    // Satisfied by
                    new[]
                    {
                        new[] { "foo", "bar", "baz" },
                        new[] { "foo", "bar" },
                        new[] { "foo", "baz" },
                        new[] { "baz" },
                    },

                    // Unsatisfied by
                    new[]
                    {
                        new[] { "bar" },
                        new[] { "foo" },
                    },
                };
            }
        }

        [Theory]
        [MemberData(nameof(TagRequirementExamples))]
#pragma warning disable S2368 // Public methods should not have multidimensional array parameters
        public void No_Exception_Should_Be_Thrown_When_Valid_Tag_Requirement_Representation_Is_Parsed(
#pragma warning restore S2368 // Public methods should not have multidimensional array parameters
            string validRepresentation, string[][] _, string[][] __)
        {
            // EXPECT we can parse the valid tag requirement representation without exception.
            TagRequirement.Parse(validRepresentation).ShouldNotBeNull();
        }

        [Theory]
        [InlineData("")]
        [InlineData("@illegal?characters")]
        [InlineData("multiword tag without hyphen")]
        public void Exception_Should_Be_Thrown_When_Invalid_Tag_Requirement_Representation_Is_Parsed(
            string invalidRepresentation)
        {
            // EXPECT that an exception is thrown when we try to parse the invalid representation.
            Assert.Throws&lt;ArgumentException&gt;(() =&gt; TagRequirement.Parse(invalidRepresentation));
        }

        [Theory]
        [MemberData(nameof(TagRequirementExamples))]
#pragma warning disable S2368 // Public methods should not have multidimensional array parameters
        public void Tag_Requirements_Should_Declare_Satisfaction_From_Provided_Tags_As_Expected(
#pragma warning restore S2368 // Public methods should not have multidimensional array parameters
            string tagRequirementRepr,
            string[][] expectedSatisfiedBy,
            string[][] expectedUnsatisfiedBy)
        {
            // GIVEN a tag requirement based on the provided representation.
            var tagRequirement = TagRequirement.Parse(tagRequirementRepr);

            // EXPECT that the tag requirement is satisfied by provided groups of tags as appropriate.
            expectedSatisfiedBy.ShouldAllBe(tagGroup =&gt; tagRequirement.SatisfiedBy(tagGroup));

            // EXPECT that the tag requirement is unsatisfied by provided groups of tags as appropriate.
            expectedUnsatisfiedBy.ShouldAllBe(tagGroup =&gt; !tagRequirement.SatisfiedBy(tagGroup));
        }
    }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>single_dataset = ['carb', 'Photometer_V3']

for procedure in dataset:

    s = dataset[procedure]

    if [ x for x in single_dataset if x in s] == single_dataset:

        print procedure,s
</code></pre>
</div>
<span class="comment-copy">Did you ever get an answer on this that seemed satisfactory? I have the same exact need.</span>
<span class="comment-copy">Not yet, I think Niemmi solution is the most feasible; although I have to try it out first.</span>
<span class="comment-copy">thanks. i built a similar implementation around all() -- i was hoping thered be something a little more efficient than that though</span>
