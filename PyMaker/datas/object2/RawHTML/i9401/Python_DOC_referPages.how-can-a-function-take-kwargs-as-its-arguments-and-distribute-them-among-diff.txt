<div class="post-text" itemprop="text">
<p>Suppose I have two classes...</p>
<pre><code>class A:

    def __init__(self, *args, arg1="default1", arg2="default2"):
        # Initialise class A


class B:

    def __init__(self, arg3="default3", arg4="default4"):
        # Initialise class B
</code></pre>
<p>Each class has its own keyword arguments, and one has positional arguments.</p>
<p>Now suppose there is a function which creates an instance of each of these classes, using its own arguments to do so:</p>
<pre><code>def make_objs(*args, arg1="default1", arg2="default2", arg3="default3", arg4="default4"):
    objA = ClassA(*args, arg1=arg1, arg2=arg2)
    objB = ClassB(arg3=arg3, arg4=arg4)
</code></pre>
<p>Here I manually allocate the keyword arguments that the function received to the correct class. This is a bit tedious though - I have to duplicate the keywords in the function definition, and changing the classes will mean changing the function's arguments.</p>
<p>Ideally, I would do something like this:</p>
<pre><code>def make_objs(*args, **kwargs):
    objA = ClassA(*args, **kwargs)
    objB = ClassB(**kwargs)
</code></pre>
<p>Where each class would take all the keyword arguments and extract only those which are relevant to it. That's not what the above code would actually do of course, it will throw an Exception because <code>ClassA</code> is not expecting an argument called <code>arg3</code>.</p>
<p>Is there anyway to do this? Some way of making the function take <code>**kwargs</code> as an argument and determine which arguments can go to which class?</p>
</div>
<div class="post-text" itemprop="text">
<p>To avoid all the repetitious typing you could create a utility function which uses the <a href="https://docs.python.org/3/library/inspect.html#module-inspect" rel="nofollow noreferrer"><code>inspect</code></a> module to examine the calling sequence of the functions / methods involved.</p>
<p>Here's a runnable example of applying it to your code. The utility function is the one named <code>get_kwarg_names</code>:</p>
<pre><code>from inspect import signature, Parameter

class ClassA:
    def __init__(self, *args, arg1="default1", arg2="default2"):
        print('ClassA.__init__(): '
              '*args={}, arg1={!r}, arg2={!r}'.format(args, arg1, arg2))

class ClassB:
    def __init__(self, arg3="default3", arg4="default4"):
        print('ClassB.__init__(): arg3={!r}, arg4={!r}'.format(arg3, arg4))

def get_kwarg_names(function):
    """ Return a list of keyword argument names function accepts. """
    sig = signature(function)
    keywords = []
    for param in sig.parameters.values():
        if(param.kind == Parameter.KEYWORD_ONLY or
            (param.kind == Parameter.POSITIONAL_OR_KEYWORD and
                param.default != Parameter.empty)):
            keywords.append(param.name)
    return keywords

# Sample usage of utility function above.
def make_objs(*args, arg1="default1", arg2="default2",
                     arg3="default3", arg4="default4"):

    local_namespace = locals()
    classA_kwargs = {keyword: local_namespace[keyword]
                        for keyword in get_kwarg_names(ClassA.__init__)}
    objA = ClassA(*args, **classA_kwargs)

    classB_kwargs = {keyword: local_namespace[keyword]
                        for keyword in get_kwarg_names(ClassB.__init__)}
    objB = ClassB(**classB_kwargs)

make_objs(1, 2, arg1="val1", arg2="val2", arg4="val4")
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>ClassA.__init__(): *args=(1, 2), arg1='val1', arg2='val2'
ClassB.__init__(): arg3='default3', arg4='val4'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you add <code>*arg</code> and <code>**kwargs</code> in <code>__init__</code> method of your classes you can achieve the behavior you are expecting. Like in the exaple below:</p>
<pre><code>class A(object):

    def __init__(self, a, b, *arg, **kwargs):
        self.a = a
        self.b = b

class B(object):

    def __init__(self, c, d, *arg, **kwargs):
        self.c = c
        self.d = d

def make_objs(**kwargs):
    objA = A(**kwargs)
    objB = B(**kwargs)

make_objs(a='apple', b='ball', c='charlie', d='delta')
</code></pre>
<p>But the caveat here is that if you print <code>objA.c</code> and <code>objA.d</code> it will return <code>charlie</code> and <code>delta</code> as passed in the <code>make_objs</code> parameters. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class A:
    def __init__(self, *args, a1 = 'd1', a2 = 'd2'):
        self.a1 = a1
        self.a2 = a2
class B:
    def __init__(self, a3 = 'd3', a4 = 'd4'):
        self.a3 = a3
        self.a4 = a4
</code></pre>
<p>Use <a href="https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object" rel="nofollow noreferrer">inpect.signature</a> to get the call signatures then filter <code>kwargs</code> before creating the objects.</p>
<pre><code>from inspect import signature
from inspect import Parameter

sig_a = signature(A)
sig_b = signature(B)

def f(*args, **kwargs):
    d1 = {}
    d2 = {}
    for k, v in kwargs.items():
        try:
            if sig_a.parameters[k].kind in (Parameter.KEYWORD_ONLY,
                                            Parameter.POSITIONAL_OR_KEYWORD,
                                            Parameter.VAR_KEYWORD):
                 d1[k] = v
        except KeyError:
            pass
        try:
            if sig_b.parameters[k].kind in (Parameter.KEYWORD_ONLY,
                                            Parameter.POSITIONAL_OR_KEYWORD,
                                            Parameter.VAR_KEYWORD):
                d2[k] = v
        except KeyError:
            pass
    return (A(args, **d1), B(**d2))

d = {'a1':1, 'a2':2, 'a3':3, 'a4':4}   
x, y = f(2, **d)

&gt;&gt;&gt; x.a1
1
&gt;&gt;&gt; x.a2
2
&gt;&gt;&gt; y.a3
3
&gt;&gt;&gt; y.a4
4
&gt;&gt;&gt; 
</code></pre>
<hr/>
<p>The checks to see if the Parameter is a keyword parameter may be overkill.</p>
</div>
<span class="comment-copy">How about for the <code>constructor</code> arguments in <code>class A</code> you add <code>*arg</code> and <code>**kwarg</code> after <code>arg1</code> and <code>arg2</code>? Same goes for <code>class B</code>.</span>
<span class="comment-copy">Question: When are you going to unpack the <code>*args</code> in <code>classA</code>? Can you please provide the full definition of your <code>constructor</code> for <code>classA</code>?</span>
<span class="comment-copy">The function is actually: <a href="https://github.com/samirelanduk/quickplots/blob/2.0/quickplots/quick.py#L4" rel="nofollow noreferrer">github.com/samirelanduk/quickplots/blob/2.0/quickplots/…</a></span>
<span class="comment-copy">Class A is <a href="https://github.com/samirelanduk/quickplots/blob/2.0/quickplots/series.py#L133" rel="nofollow noreferrer">github.com/samirelanduk/quickplots/blob/2.0/quickplots/…</a></span>
<span class="comment-copy">Class B is <a href="https://github.com/samirelanduk/quickplots/blob/2.0/quickplots/charts.py#L61" rel="nofollow noreferrer">github.com/samirelanduk/quickplots/blob/2.0/quickplots/…</a></span>
<span class="comment-copy">I like this better, I was tempted to make it a function that returned valid parameters but didn't get around to it.</span>
<span class="comment-copy">Good. I tried to make something fairly generic so it could be easily modified if necessary and reused if desired. However, note it does require that the keyword arguments to all be unique. If my answer solves your problem, please consider accepting it.</span>
<span class="comment-copy">Sorry, I should have specified that I am already using *args for classA. classA's <b>init</b> is <code>(self, *args, **kwargs)</code> and the function takes <code>(*args, **kwargs)</code>.</span>
<span class="comment-copy">Can you update your question again with that information? Thanks. Also can you be more specific to what were you expecting to achieve. I may not be clear on your question.</span>
<span class="comment-copy">Thanks, I have just done so.</span>
