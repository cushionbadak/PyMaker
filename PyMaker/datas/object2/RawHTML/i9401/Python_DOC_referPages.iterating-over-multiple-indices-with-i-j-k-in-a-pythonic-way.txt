<div class="post-text" itemprop="text">
<p>i need to iterate over a tuple of indices. all indices must be in the range
<code>[0, N)</code> with the condition <code>i &gt; j</code>. The toy example I present here deals with
only two indices; I will need to extend that to three (with <code>i &gt; j &gt; k</code>) or more.</p>
<p>The basic version is this:</p>
<pre><code>N = 5
for i in range(N):
    for j in range(i):
        print(i, j)
</code></pre>
<p>and it works just fine; the output is</p>
<pre><code>1 0
2 0
2 1
3 0
3 1
3 2
4 0
4 1
4 2
4 3
</code></pre>
<p>I don't want to have one more indentation level for every additional index,
therefore I prefer this version:</p>
<pre><code>for i, j in ((i, j) for i in range(N) for j in range(i)):
    print(i, j)
</code></pre>
<p>this works perfectly well, does what it should and gets rid of the extra
indentation level.</p>
<p>I was hoping to be able to have something more elegant (for two indices that is
not all that relevant, but for three or more it becomes more relevant). What I came up with so far is this:</p>
<pre><code>from itertools import combinations

for j, i in combinations(range(N), 2):
    print(i, j)
</code></pre>
<p>This iterates over the same pair of indices just fine. The only thing that is
different is the order in which the pairs appear:</p>
<pre><code>1 0
2 0
3 0
4 0
2 1
3 1
4 1
3 2
4 2
4 3
</code></pre>
<p>As the order of what I am doing with these indices is relevant, I therefore cannot use this.</p>
<p>Is there an elegant, short, pythonic way to iterate over these indices in the same order that the very first example produces? Keep in mind that <code>N</code> will be large, so sorting is not something I would want to do.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could solve this generally as follows:</p>
<pre><code>def indices(N, length=1):
    """Generate [length]-tuples of indices.

    Each tuple t = (i, j, ..., [x]) satisfies the conditions 
    len(t) == length, 0 &lt;= i &lt; N  and i &gt; j &gt; ... &gt; [x].

    Arguments:
      N (int): The limit of the first index in each tuple.
      length (int, optional): The length of each tuple (defaults to 1).

    Yields:
      tuple: The next tuple of indices.

    """
    if length == 1:
       for x in range(N):
           yield (x,)
    else:
       for x in range(1, N):
            for t in indices(x, length - 1):
                yield (x,) + t
</code></pre>
<p>In use:</p>
<pre><code>&gt;&gt;&gt; list(indices(5, 2))
[(1, 0), (2, 0), (2, 1), (3, 0), (3, 1), (3, 2), (4, 0), (4, 1), (4, 2), (4, 3)]
&gt;&gt;&gt; list(indices(5, 3))
[(2, 1, 0), (3, 1, 0), (3, 2, 0), (3, 2, 1), (4, 1, 0), (4, 2, 0), (4, 2, 1), (4, 3, 0), (4, 3, 1), (4, 3, 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an approach with <a href="https://docs.python.org/2/library/itertools.html#itertools.combinations" rel="noreferrer"><code>itertools.combinations</code></a> to have a generic number of <em>levels</em> -</p>
<pre><code>map(tuple,(N-1-np.array(list(combinations(range(N),M))))[::-1])
</code></pre>
<p>Or a bit twisted one with same method -</p>
<pre><code>map(tuple,np.array(list(combinations(range(N-1,-1,-1),M)))[::-1])
</code></pre>
<p>, where N : number of elements and M : number of levels.</p>
<p>Sample run -</p>
<pre><code>In [446]: N = 5
     ...: for i in range(N):
     ...:     for j in range(i):
     ...:         for k in range(j):  # Three levels here
     ...:             print(i, j, k)
     ...:             
(2, 1, 0)
(3, 1, 0)
(3, 2, 0)
(3, 2, 1)
(4, 1, 0)
(4, 2, 0)
(4, 2, 1)
(4, 3, 0)
(4, 3, 1)
(4, 3, 2)

In [447]: N = 5; M = 3

In [448]: map(tuple,(N-1-np.array(list(combinations(range(N),M))))[::-1])
Out[448]: 
[(2, 1, 0),
 (3, 1, 0),
 (3, 2, 0),
 (3, 2, 1),
 (4, 1, 0),
 (4, 2, 0),
 (4, 2, 1),
 (4, 3, 0),
 (4, 3, 1),
 (4, 3, 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>product</code> from <code>itertools</code> if you don't mind the inefficiency of throwing out most of the generated tuples. (The inefficiency gets worse as the <code>repeat</code> parameter increases.)</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; for p in ((i,j) for (i,j) in product(range(5), repeat=2) if i &gt; j):
...   print p
...
(1, 0)
(2, 0)
(2, 1)
(3, 0)
(3, 1)
(3, 2)
(4, 0)
(4, 1)
(4, 2)
(4, 3)
&gt;&gt;&gt; for p in ((i,j,k) for (i,j,k) in product(range(5), repeat=3) if i &gt; j &gt; k):
...   print p
...
(2, 1, 0)
(3, 1, 0)
(3, 2, 0)
(3, 2, 1)
(4, 1, 0)
(4, 2, 0)
(4, 2, 1)
(4, 3, 0)
(4, 3, 1)
(4, 3, 2)
</code></pre>
<hr/>
<p>Update: Instead of tuple unpacking, using indexing for the filter. This allows the code to be written a little more compactly. Only <code>my_filter</code> needs to be changed for tuples of varying sizes.</p>
<pre><code>from itertools import product, ifilter
def my_filter(p):
    return p[0] &gt; p[1] &gt; p[2]

for p in ifilter(my_filter, product(...)):
    print p
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is an approach based on the observation that it is easier to generate the <em>negatives</em> of the indices in the (reverse of) the desired order It is similar to the approach of @Divakar and like that has the drawback of requiring the list to be created in memory:</p>
<pre><code>def decreasingTuples(N,k):
    for t in reversed(list(itertools.combinations(range(1-N,1),k))):
        yield tuple(-i for i in t)

&gt;&gt;&gt; for t in decreasingTuples(4,2): print(t)

(1, 0)
(2, 0)
(2, 1)
(3, 0)
(3, 1)
(3, 2)
&gt;&gt;&gt; for t in decreasingTuples(4,3): print(t)

(2, 1, 0)
(3, 1, 0)
(3, 2, 0)
(3, 2, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>a somewhat 'hacky' attempt using <code>eval</code> (just adding this for completeness. there are nicer answers here!). </p>
<p>the idea is to construct a string like</p>
<pre><code>'((a, b, c) for a in range(5) for b in range(a) for c in range(b))'
</code></pre>
<p>and return the <code>eval</code> of that:</p>
<pre><code>def ijk_eval(n, depth):
    '''
    construct a string representation of the genexpr and return eval of it...
    '''

    var = string.ascii_lowercase
    assert len(var) &gt;= depth &gt; 1  # returns int and not tuple if depth=1

    for_str = ('for {} in range({}) '.format(var[0], n) +
               ' '.join('for {} in range({})'.format(nxt, cur)
                        for cur, nxt in zip(var[:depth-1], var[1:depth])))
    return eval('(({}) {})'.format(', '.join(var[:depth]), for_str))
</code></pre>
<p>can be used this way and produces the right results.</p>
<pre><code>for i, j in ijk_eval(n=5, depth=2):
    print(i, j)
</code></pre>
<p>the construction is not very nice - but the result is: it is a regular <code>genexpr</code> and just as efficient as those are.</p>
</div>
<span class="comment-copy">Maybe <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow noreferrer"><code>yield from</code></a> (supported from Python 3.3) could make the code more compact, like <code>yield from range(N)</code></span>
<span class="comment-copy">@lazzzis I thought about that, but it needs to do something to each value before yielding it</span>
<span class="comment-copy">aha! rearranging the output from <code>combinations</code>. looks interesting!</span>
<span class="comment-copy">@hiroprotagonist Well its not meant to be a generator as I am using it as a NumPy array. So, to get the final output, we need to wrap it up with tuple : <code>tuple(map(tuple,(N-1-np.array(list(combinations(range(N),M))))[::-1]))</code>. That answers your question?</span>
<span class="comment-copy">@hiroprotagonist Or if you don't mind an array of indices as the final output : <code>N-1-np.array(list(combinations(range(N),M)))[::-1]</code>.</span>
<span class="comment-copy">the drawback is that you create a list and have all the indices in memory; it's no longer a 'pure' generator, right? unfortunately <code>islice</code> can not handle negative steps...</span>
<span class="comment-copy">@hiroprotagonist No, it's not a generator once we have wrapped it with <code>np.array()</code> there and thus creates all output indices in memory. Would that be a problem?</span>
<span class="comment-copy">that looks very clean indeed. thanks! will have to time how bad the inefficiency gets...</span>
<span class="comment-copy">You can alleviate some of the inefficiency with <code>product(*[range(5-x) for x in range(3)])</code> (where <code>5</code> and <code>3</code> are modified as desired, of course), but that detracts from the elegance without really solving the issue entirely.</span>
<span class="comment-copy">yup, that is the same as the one in my comment in <a href="http://stackoverflow.com/a/41522251/4954037">Divakar's answer</a> (the one with <code>def ijk(n, depth)</code>), right? still like it!</span>
<span class="comment-copy">ah, no, now i see the difference!</span>
<span class="comment-copy">@hiroprotagonist Slightly different, since I am using a range which loops through negative values -- if it was exactly the same I wouldn't have posted. jon sharpe's seems best.</span>
