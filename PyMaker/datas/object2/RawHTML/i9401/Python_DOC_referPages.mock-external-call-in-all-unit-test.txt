<div class="post-text" itemprop="text">
<p>I need to create some kind of <code>MockMixin</code> for my tests. It should include mocks for everything that calls external sources.
For example, each time I save model in admin panel I call some remote URLs. It would be good, to have that mocked and use like that:</p>
<pre><code>class ExampleTestCase(MockedTestCase):
    # tests
</code></pre>
<p>So each time I save model in admin, for example in functional tests, this mock is applied instead of calling remote URLs.</p>
<p>Is that actually possible? I'm able to do that for 1 particular test, that is not a problem. But it'd be more useful to have some global mock because I use it a lot.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="http://www.voidspace.org.uk/python/mock/patch.html#mock.patch"><code>mock</code> documentation</a>:</p>
<blockquote>
<p>Patch can be used as a TestCase class decorator. It works by
  decorating each test method in the class. This reduces the boilerplate
  code when your test methods share a common patchings set.</p>
</blockquote>
<p>This basically means that you can create a base test class with <code>@patch</code> decorator applied on it that would mock your external calls while every test method inside would be executed.</p>
<p>Also, you can use <a href="http://mock.readthedocs.org/en/latest/patch.html#start-and-stop"><code>start()</code> and <code>stop()</code></a> patcher's methods in <code>setUp()</code> and <code>tearDown()</code> methods respectively:</p>
<pre><code>class BaseTestCase(TestCase):
    def setUp(self):
        self.patcher = patch('mymodule.foo')
        self.mock_foo = self.patcher.start()

    def tearDown(self):
        self.patcher.stop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just to add to <a href="https://stackoverflow.com/a/25857701/3357935">alecxe's answer</a>, if you are using <code>teardown()</code> then <a href="https://docs.python.org/3/library/unittest.mock.html#patch-methods-start-and-stop" rel="noreferrer">according to the docs</a> </p>
<blockquote>
<p>you must ensure that the patching is “undone” by calling <code>stop</code>. This can be fiddlier than you might think, because if an exception is raised in the <code>setUp</code> then <code>tearDown</code> is not called.</p>
</blockquote>
<p>If an exception is raised in your tests, your patching won't be undone. A better way would be to call <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.addCleanup" rel="noreferrer"><code>addCleanup()</code></a> inside your <code>setUp()</code>. Then you can omit the <code>tearDown()</code> method altogether.</p>
<pre><code>class BaseTestCase(TestCase):
    def setUp(self):
        self.patcher = patch('mymodule.foo')
        self.mock_foo = self.patcher.start()
        self.addCleanup(self.patcher.stop) # add this line
</code></pre>
</div>
<span class="comment-copy">And that also means I have to decorate each of my test cases, and not the <code>Mixin</code> test class. It's also quite inconvenient that I have to put additional parameter for each test method. But it's better than nothing.</span>
<span class="comment-copy">@galozek please see the relevant topics: <a href="http://stackoverflow.com/questions/12219967/how-to-mock-a-base-class-with-python-mock-library">here</a> and <a href="http://stackoverflow.com/questions/11194847/how-do-i-directly-mock-a-superclass-with-python-mock">here</a>.</span>
<span class="comment-copy">the 2nd solution worked. I tried that approach but was missing <code>start()</code>/<code>stop()</code> part. Thanks.</span>
<span class="comment-copy">Note that you might be better off using <code>self.addCleanup(self.patcher.stop)</code> instead of doing it in <code>tearDown</code> since cleanup gets run whether or not there is an exception.  See @Meistro's answer.</span>
<span class="comment-copy">Don't forget to include imports: <code>from unittest import TestCase</code>, <code>from import unittest.mock import patch</code></span>
<span class="comment-copy"><code>tearDown</code> will always be called, even if your tests raise an exception.</span>
<span class="comment-copy">From the docs: "If setUp() fails, meaning that tearDown() is not called, then any cleanup functions added will still be called." So it's still better to call <code>addCleanup</code> than hope that no exceptions are raised in <code>setUp</code>.</span>
<span class="comment-copy">Don't forget to include imports: <code>from unittest import TestCase</code>, <code>from import unittest.mock import patch</code></span>
