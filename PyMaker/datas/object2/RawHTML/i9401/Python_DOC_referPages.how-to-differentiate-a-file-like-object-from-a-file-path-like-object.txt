<div class="post-text" itemprop="text">
<h2>Summary:</h2>
<p>There is a variety of function for which it would be very useful to be able to pass in two kinds of objects: an object that represents a path (usually a string), and an object that represents a stream of some sort (often something derived from <code>IOBase</code>, but not always). How can this variety of function differentiate between these two kinds of objects so they can be handled appropriately?  </p>
<hr/>
<p>Say I have a function intended to write a file from some kind of object file generator method: </p>
<pre><code>spiff = MySpiffy()

def spiffy_file_makerA(spiffy_obj, file):
    file_str = '\n'.join(spiffy_obj.gen_file()) 
    file.write(file_str)

with open('spiff.out', 'x') as f:
    spiffy_file_makerA(spiff, f)
    ...do other stuff with f...
</code></pre>
<p>This works. Yay. But I'd prefer to not have to worry about opening the file first or passing streams around, at least sometimes... so I refactor with the ability to take a file path like object instead of a file like object, and a <code>return</code> statement:</p>
<pre><code>def spiffy_file_makerB(spiffy_obj, file, mode):
    file_str = '\n'.join(spiffy_obj.gen_file()) 
    file = open(file, mode)
    file.write(file_str)
    return file

with spiffy_file_makerB(spiff, 'file.out', 'x') as f:
    ...do other stuff with f...
</code></pre>
<p>But now I get the idea that it would be useful to have a third function that combines the other two versions depending on whether <code>file</code> is file like, or file path like, but returns the f destination file like object to a context manager. So that I can write code like this: </p>
<pre><code>with  spiffy_file_makerAB(spiffy_obj, file_path_like, mode = 'x') as f:
    ...do other stuff with f...
</code></pre>
<p>...but also like this: </p>
<pre><code>file_like_obj = get_some_socket_or_stream()

with spiffy_file_makerAB(spiffy_obj, file_like_obj, mode = 'x'):
    ...do other stuff with file_like_obj...
    # file_like_obj stream closes when context manager exits 
    # unless `closefd=False` 
</code></pre>
<p>Note that this will require something a bit different than the simplified versions provided above. </p>
<p>Try as a I might, I haven't been able to find an obvious way to do this, and the ways I have found seem pretty contrived and just a potential for problems later. For example:</p>
<pre><code>def spiffy_file_makerAB(spiffy_obj, file, mode, *, closefd=True):
    try: 
        # file-like (use the file descriptor to open)
        result_f = open(file.fileno(), mode, closefd=closefd)
    except TypeError: 
        # file-path-like
        result_f = open(file, mode)
    finally: 
        file_str = '\n'.join(spiffy_obj.gen_file()) 
        result_f.write(file_str)
        return result_f
</code></pre>
<p>Are there any suggestions for a better way? Am I way off base and need to be handling this completely differently? </p>
</div>
<div class="post-text" itemprop="text">
<p>For my money, and this is an opinionated answer, checking for the attributes of the file-like object for the operations you will need is <strong>a</strong> pythonic way to determine an object’s type because that is the nature of pythonic <a href="https://en.wikipedia.org/wiki/Duck_typing">duck tests/duck-typing</a>:</p>
<blockquote>
<p>Duck typing is heavily used in Python, with the canonical example being file-like classes (for example, <code>cStringIO</code> allows a Python string to be treated as a file).  </p>
</blockquote>
<p><a href="https://docs.python.org/2/glossary.html#term-duck-typing">Or from the python docs’ definition of duck-typing</a></p>
<blockquote>
<p>A programming style which does not look at an object’s type to determine if it has the right interface; instead, the method or attribute is simply called or used (“<em>If it looks like a duck and quacks like a duck, it must be a duck.</em>”) By emphasizing interfaces rather than specific types, well-designed code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using <code>type()</code> or <code>isinstance()</code>. (Note, however, that duck-typing can be complemented with abstract base classes.) Instead, it typically employs <code>hasattr()</code> tests or EAFP programming.</p>
</blockquote>
<p>If you feel very strongly that there is some very good reason that just checking the interface for suitability isn't enough, you can just reverse the test and test for <code>basestring</code> or <code>str</code> to test whether the provided object is path-like.  The test will be different depending on your version of python.</p>
<pre><code>is_file_like = not isinstance(fp, basestring) # python 2
is_file_like = not isinstance(fp, str) # python 3
</code></pre>
<p>In any case, for your context manager, I would go ahead and make a full-blown object like the below in order to wrap the functionality that you were looking for.  </p>
<pre><code>class SpiffyContextGuard(object):
    def __init__(self, spiffy_obj, file, mode, closefd=True):
        self.spiffy_obj = spiffy_obj
        is_file_like = all(hasattr(attr) for attr in ('seek', 'close', 'read', 'write'))
        self.fp = file if is_file_like else open(file, mode)
        self.closefd = closefd

    def __enter__(self):
        return self.fp

    def __exit__(self, type_, value, traceback):
        generated = '\n'.join(self.spiffy_obj.gen_file())
        self.fp.write(generated)
        if self.closefd:
            self.fp.__exit__()
</code></pre>
<p>And then use it like this:</p>
<pre><code>with SpiffyContextGuard(obj, 'hamlet.txt', 'w', True) as f:
    f.write('Oh that this too too sullied flesh\n')

fp = open('hamlet.txt', 'a')
with SpiffyContextGuard(obj, fp, 'a', False) as f:
    f.write('Would melt, thaw, resolve itself into a dew\n')

with SpiffyContextGuard(obj, fp, 'a', True) as f:
    f.write('Or that the everlasting had not fixed his canon\n')
</code></pre>
<p>If you wanted to use try/catch semantics to check for type suitability, you could also wrap the file operations you wanted to expose on your context guard:</p>
<pre><code>class SpiffyContextGuard(object):
    def __init__(self, spiffy_obj, file, mode, closefd=True):
        self.spiffy_obj = spiffy_obj
        self.fp = self.file_or_path = file 
        self.mode = mode
        self.closefd = closefd

    def seek(self, offset, *args):
        try:
            self.fp.seek(offset, *args)
        except AttributeError:
            self.fp = open(self.file_or_path, mode)
            self.fp.seek(offset, *args)

    # define wrappers for write, read, etc., as well

    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        generated = '\n'.join(self.spiffy_obj.gen_file())
        self.write(generated)
        if self.closefd:
            self.fp.__exit__()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Probably not the answer you're looking for, but from a taste point of view I think it's better to have functions that only do one thing. Reasoning about them is easier this way.</p>
<p>I'd just have two functions: <code>spiffy_file_makerA(spiffy_obj, file)</code>, which handles your first case, and a convenience function that wraps <code>spiffy_file_makerA</code> and creates a file for you.</p>
</div>
<div class="post-text" itemprop="text">
<p>my suggestion is to pass <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib.Path</code> objects</a> around. you can simply <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes" rel="nofollow noreferrer"><code>.write_bytes(...)</code></a> or  <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text" rel="nofollow noreferrer"><code>.write_text(...)</code></a> to these objects.</p>
<p>other that that you'd have to check the type of your <code>file</code> variable (this is how polymorphism can be done in python):</p>
<pre><code>from io import IOBase

def some_function(file)
    if isinstance(file, IOBase):
        file.write(...)
    else:
        with open(file, 'w') as file_handler:
            file_handler.write(...)
</code></pre>
<p>(i hope <a href="https://docs.python.org/3/library/io.html#io.IOBase" rel="nofollow noreferrer"><code>io.IOBase</code></a> is the most basic class to check against...). and you would have to catch possible exceptions around all that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach to this problem, inspired by this talk from <a href="https://www.youtube.com/watch?v=HTLu2DFOdTg" rel="nofollow noreferrer">Raymond Hettinger at PyCon 2013</a>, would be to keep the two functions separate as suggested by a couple of the other answers, but to bring the functions together into a class with a number of alternative options for outputting the object. </p>
<p>Continuing with the example I started with, it might look something like this: </p>
<pre><code>class SpiffyFile(object):
    def __init__(self, spiffy_obj, file_path = None, *, mode = 'w'):
        self.spiffy = spiffy_obj
        self.file_path = file_path
        self.mode = mode
    def to_str(self):
        return '\n'.join(self.spiffy.gen_file())
    def to_stream(self, fstream):
        fstream.write(self.to_str())
    def __enter__(self):
        try:
            # do not override an existing stream
            self.fstream
        except AttributeError:
            # convert self.file_path to str to allow for pathlib.Path objects
            self.fstream = open(str(self.file_path), mode = self.mode)
        return self
    def __exit__(self, exc_t, exc_v, tb):
        self.fstream.close()
        del self.fstream
    def to_file(self, file_path = None, mode = None):
        if mode is None:
            mode = self.mode
        try:
            fstream = self.fstream
        except AttributeError:
            if file_path is None:
                file_path = self.file_path
            # convert file_path to str to allow for pathlib.Path objects
            with open(str(file_path), mode = mode) as fstream:
                self.to_stream(fstream)
        else:
            if mode != fstream.mode:
                raise IOError('Ambiguous stream output mode: \
                           provided mode and fstream.mode conflict')
            if file_path is not None:
                raise IOError('Ambiguous output destination: \
                           a file_path was provided with an already active file stream.')
            self.to_stream(fstream)
</code></pre>
<p>Now we have lots of different options for exporting a <code>MySpiffy</code> object by using a <code>SpiffyFile</code> object. We can just write it to a file directly: </p>
<pre><code>from pathlib import Path
spiff = MySpiffy()
p = Path('spiffies')/'new_spiff.txt'
SpiffyFile(spiff, p).to_file()
</code></pre>
<p>We can override the path, too:</p>
<pre><code>SpiffyFile(spiff).to_file(p.parent/'other_spiff.text')
</code></pre>
<p>But we can also use an existing open stream:</p>
<pre><code>SpiffyFile(spiff).to_stream(my_stream)
</code></pre>
<p>Or, if we want to edit the string first we could open a new file stream ourselves and write the edited string to it: </p>
<pre><code>my_heading = 'This is a spiffy object\n\n'
with open(str(p), mode = 'w') as fout:
    spiff_out = SpiffyFile(spiff).to_str()
    fout.write(my_heading + spiff_out)
</code></pre>
<p>And finally, we can just use a context manager with the <code>SpiffyFile</code> object directly to as many different locations- or streams- as we like (note that we can pass the <code>pathlib.Path</code> object directly without worrying about string conversion, which is nifty):</p>
<pre><code>with SpiffyFile(spiff, p) as spiff_file:
    spiff_file.to_file()
    spiff_file.to_file(p.parent/'new_spiff.txt')
    print(spiff_file.to_str())
    spiff_file.to_stream(my_open_stream)
</code></pre>
<p>This approach is more consistent with the mantra: explicit is better than implicit. </p>
</div>
<span class="comment-copy">I once found a <a href="https://leemendelowitz.github.io/blog/decorating-python-file-functions.html" rel="nofollow noreferrer">&lt;blog entry&gt;</a> about this issue. This can be done with a decorator.</span>
<span class="comment-copy">FWIW I think the exception route is the right way to go. As soon as you start checking types, you hurt portability (py 2 but maybe you don't care) and also invite bugs in future python versions.</span>
<span class="comment-copy">It's very common for open/load methods in Python modules to detect the type of the object passed, beit filename or file object. Perhaps have a look at the code behind PIL's image open: <a href="http://pillow.readthedocs.io/en/3.1.x/reference/Image.html#PIL.Image.open" rel="nofollow noreferrer">pillow.readthedocs.io/en/3.1.x/reference/…</a></span>
<span class="comment-copy">This answer is a quick education in the advantages of duck typing, it reveals a pattern that's useful not just to solve similar problems in Python but also in other languages, and what a good quote to choose too.</span>
<span class="comment-copy">Getting answers like this is why I love the bounty system.</span>
<span class="comment-copy">This is no longer best practice; you'll need to check for <code>PathLike</code> <i>and</i> <code>str</code> because there's now an actual <code>PathLike</code> thing. What I've described also isn't best practice, but it's the smallest modification required to your code to make it work with path-like objects (if I'm not making a stupid mistake).</span>
<span class="comment-copy">Actually, best practice is <code>try: fp = os.fspath(fp) except TypeError:</code>.</span>
<span class="comment-copy">I originally didn't like this answer, but after thinking about it a bit more, it's a worthwhile point of view. I have added another answer expanding on this idea.</span>
<span class="comment-copy">It's surprising to me that there isn't a more obvious check out there- like a stream abstract baseclass (I know <code>io.IOBase</code> is an ABC but I don't think it implements a <code>__subclasshook__</code>), or something. Is io.IOBase really going to catch any kind of stream?</span>
<span class="comment-copy">unfortunately <a href="https://www.python.org/dev/peps/pep-3116/" rel="nofollow noreferrer">PEP 3116</a> does not mention a <code>__subclasshook__</code> (neither does the doc; did not look at the source). you might define an own abstract base class with  a <code>__subclasshook__</code> that checks for a <code>write()</code> method. apart from that <code>IOBase</code> should be the parent of any stream. (can't speak for 3rd party libraries, of course...)</span>
<span class="comment-copy">I've been exploring the <code>pathlib</code> module a bit more today, and it is very powerful. I am leaning toward abandoning the old/usual way of resolving strings into file streams altogether (using <code>open</code> and <code>os.path</code>, etc etc). The only potential problem with this I see is that a function that expects to be seeing <code>Path</code> objects is going to throw around exceptions when passed strings representing <code>Path</code>s. I suppose I could just wrap the (potential) strings in <code>Path</code>s each time a function getting something path-like is called, but that seems wrong since they might be a <code>Path</code> subclass. Thoughts?</span>
<span class="comment-copy">@RickTeachey i have never subclassed <code>Path</code>, i usually call <code>Path(str(obj))</code> so if the subclass has a reasonable <code>__str__</code> method you should be fine... i have cleaned up my codebase so i really can pass <code>Path</code> objects and do not have to cast.</span>
<span class="comment-copy">I suppose I actually meant, instead of subclassing <code>Path</code>, that it could be a different object implementing the path-like protocol. So assuming it can be passed to <code>Path</code> without consequence seems hazardous. However, <code>Path(str(obj))</code> seems like an OK way around the problem.</span>
