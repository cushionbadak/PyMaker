<div class="post-text" itemprop="text">
<p>I have a <em>kivy</em> application in <strong>python</strong> which uses some threads.
As python is not able to run these threads on different Cores due to the Global Interpreter Lock, I would have liked to try to use <strong>PyPy</strong> for it and see if I can make the threads run faster of different cores since <strong>PyPy</strong> is different and offers <strong>stackless</strong> (what ever that is? :).</p>
<p>Does somebody has some information to share on how to make a simple python program, which launches some threads by the module <code>threading</code>, running with the pypy interpreter such that it uses this <strong>stackless</strong> featuer?</p>
</div>
<div class="post-text" itemprop="text">
<p>Pypy won't resolve Python problems of running a single-thread each time, since it also makes use of the GIL - <a href="http://doc.pypy.org/en/latest/faq.html#does-pypy-have-a-gil-why" rel="nofollow noreferrer">http://doc.pypy.org/en/latest/faq.html#does-pypy-have-a-gil-why</a></p>
<p>Besides that, Kivy is a complex project embedding Python itself - although I don't know it very well, I doubt it is possible to switch the Python used in it for Pypy.</p>
<p>Depending on what you are doing, you may want to use the <code>multiprocessing</code>  module instead of  <code>threading</code> -  it is a drop-in replacement that will make transparent inter-process calls to Python functions, and can therefore take advantage of multiple-cores.
<a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">https://docs.python.org/3/library/multiprocessing.html</a></p>
<p>This is standard in cPython and can likely be used from within Kivy, <em>if</em> (and only if)  all code in the subprocess just take care of number-crunching, and so on, and all user interaction and display updates are made on the main process.</p>
</div>
<span class="comment-copy">@noɥʇʎԀʎzɐɹƆ: that bounty description is way, way too broad. Please don't use a bounty to hijack other questions and expand their scope.</span>
<span class="comment-copy">Stackless threads are kind of greent threeds, they do not support SMP. They are more like as if the interpreter has it's own scheduler and schedules that threads by itself. But from the perspective of the operating system this is still <i>one</i> process. To make use of SMP you need use multiprocessing or resort to native threads with C or Cython or something like.</span>
<span class="comment-copy">jeah, I am at the moment trying an implementation with the multiprocessing tools, its kind of shitty, because going to communication means I need to communicate a lot of stuff, which before was shared memory =), python in this respect really sucks, and I just recently heard about the GIL</span>
<span class="comment-copy">using shared memory to communicate with threads winds up biting you anyway... use queues.   python's queue object works great.</span>
<span class="comment-copy">I agreed that when the subject is shared memory parallelization python sucks, and I love python. You may use Cython or C with pthreads to achieve that, while still having a python interface.</span>
