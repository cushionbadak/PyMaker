<div class="post-text" itemprop="text">
<p>Consider the string <code>Building Centre</code>.  If asked to abbreviate this to fit a specific number of characters, you and I may choose very different but equally valid representations.  For instance, three valid 7 character representations are:</p>
<p><code>BLD CNT</code></p>
<p><code>BLD CTR</code></p>
<p><code>BLDNGCT</code></p>
<p>These are generated by:</p>
<ol>
<li>Using only existing letters in the string (can't abbreviate using z)</li>
<li>Using them in the order they appear (<code>LBD</code> is not valid since L does not come before B in <code>Building</code>).</li>
<li>Selecting up to as many characters (including spaces) as indicated.</li>
</ol>
<p>I'm looking to write a breadth or depth of search based algorithm to generate all such short forms for a given string and desired length.</p>
<p>Before I go about writing the script, I am wondering if something similar has already been implemented.  If not, how would you suggest I write something like this?  Besides <code>itertools</code>, are there any useful libraries?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, this can be beautifully done with <code>itertools</code>:</p>
<pre><code>import itertools

text = 'Building Centre'
length = 7
shorts = [''.join(short) for short in itertools.combinations(text, length)]
print(shorts)  # 6435 different versions!
</code></pre>
<p>Note that <code>itertools.combinations</code> does indeed preserve the order. You way want to check out <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">the docs</a></p>
<h3>Edit</h3>
<p>If short forms with fewer than <code>length</code> characters should be allowed as well, you can use</p>
<pre><code>shorts = list(itertools.chain(*((''.join(short) for short in itertools.combinations(text, l))
                                for l in range(1, length + 1))))
</code></pre>
<p>As stated in the comments, some short forms get generated twice. To fix this, use e.g. <code>shorts = list(set(shorts))</code>.</p>
</div>
<span class="comment-copy">It doesn't sound like BFS/DFS problem, to me it sounds more like "find all the (ordered) subsequences of certain length" of a string</span>
<span class="comment-copy"><code>for x in itertools.combinations("Building Centre", 7): 	print "".join(x)</code></span>
<span class="comment-copy">"<i>Besides <code>itertools</code> ...</i>" - Why do you omit <code>itertools</code> from the set of possible answers?</span>
<span class="comment-copy">Would <code>' Centre'</code> be one of the "equally valid representations"? It seems like if you want plausible abbreviations then you need to add more constraints.</span>
<span class="comment-copy">If this isn't homework but instead you really want to automatically generate plausible abbreviations, this looks promising: <a href="https://github.com/ppannuto/python-abbreviate" rel="nofollow noreferrer">github.com/ppannuto/python-abbreviate</a></span>
<span class="comment-copy">"Selecting <i>up to</i> as many characters ..." -- so shouldn't you loop over <code>range(1+length)</code>?</span>
<span class="comment-copy">Also -- <code>BDE</code> (for example) might be <i>generated</i> twice but probably shouldn't be <i>returned</i> twice. Perhaps run <code>shorts</code> through <code>set()</code> first.</span>
<span class="comment-copy">AH! See, I was using permutation instead of combination.  Thank you!</span>
