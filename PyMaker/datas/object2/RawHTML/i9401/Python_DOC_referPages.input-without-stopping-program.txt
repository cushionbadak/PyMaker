<div class="post-text" itemprop="text">
<p>I am trying to make a countdown timer that prints the time remaining, and when you input something, it prints what you inputted. My problem is I don't want to wait for the input, just keep running the timer. My incorrect code:</p>
<pre><code>timer = 100
while True:
    print(timer)
    timer -= 1

    if input('&gt; '):
        print('the output of input')
</code></pre>
<p>You could say I want to have the timer printing the time in the background.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a function that will timeout if no input is given:</p>
<pre><code>import select
import sys

def timeout_input(timeout, prompt="", timeout_value=None):
    sys.stdout.write(prompt)
    sys.stdout.flush()
    ready, _, _ = select.select([sys.stdin], [], [], timeout)
    if ready:
        return sys.stdin.readline().rstrip('\n')
    else:
        sys.stdout.write('\n')
        sys.stdout.flush()
        return timeout_value
</code></pre>
<p>You can easily modify it so it shows the remaining time by changing the timeout value on <code>select.select</code> to <code>1</code>, and looping <code>timeout</code> times.</p>
</div>
<div class="post-text" itemprop="text">
<p>Standard input and standard output (accessed via <code>input()</code> and <code>print()</code>) are not a good choice for writing interactive asynchronous user interface (UI).  Python support a few UIs via it's standard library.  For example, <a href="https://docs.python.org/3/howto/curses.html" rel="nofollow noreferrer">curses</a> is a text based user interface available on many POSIX systems.  Here is an exmaple code for showing a countdown timer while accepting a number from the user:</p>
<pre><code>import time
import curses


def get_number(seconds):
    def _get_number(stdscr):
        stdscr.clear()
        timeout = time.time() + seconds
        s = ""
        while time.time() &lt;= timeout:
            time_left = int(timeout - time.time())
            stdscr.addstr(0, 0, 'Countdown: {} {}'.format(time_left,
                                                          "*" * time_left + " " * seconds))
            stdscr.addstr(2, 0, ' ' * 50)
            stdscr.addstr(2, 0, 'Your Input: {}'.format(s))
            stdscr.refresh()
            stdscr.timeout(100)
            code = stdscr.getch()
            stdscr.addstr(10, 0, 'Code: {}'.format(code))  # for debug only
            stdscr.refresh()
            if ord("0") &lt;= code &lt;= ord("9"):
                s += chr(code)
                continue

            if code == 10 and s:  # newline
                return int(s)

            if code == 127:  # backspace
                s = s[:-1]

    return curses.wrapper(_get_number)

print(get_number(10))
</code></pre>
</div>
<span class="comment-copy">look for <code>getch()</code> or similar function - it is not in standard library.</span>
<span class="comment-copy">If you're using a unix-like OS, you can <code>select([sys.stdin])</code>, or use <code>curses.getch</code>, if on Windows, then it is more complicated.</span>
<span class="comment-copy">so if <code>select([sys.stdin]) != ''</code> then do x</span>
<span class="comment-copy">You can also use a <a href="https://docs.python.org/2/library/threading.html#timer-objects" rel="nofollow noreferrer">threading.Timer</a> object and keep the blocking <code>input</code> call.</span>
<span class="comment-copy">The problem with this is I need to accept strings of a 2 digit length.</span>
<span class="comment-copy">So instead of <code>if code == 10 and s</code> write <code>if len(s) == 2</code></span>
<span class="comment-copy">doesn't <code>getch</code> get 1 character?</span>
<span class="comment-copy">Yes, but see the loop with <code>s += ...</code> above. Just try the code.</span>
