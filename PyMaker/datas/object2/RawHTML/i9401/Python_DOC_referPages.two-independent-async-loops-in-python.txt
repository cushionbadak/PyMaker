<div class="post-text" itemprop="text">
<p>What would be a good approach to execute two asynchronous loops running in parallel in Python, using <code>async/await</code>?</p>
<p>I've thought about something like the code below, but can't wrap my head around how to use <code>async</code>/<code>await</code>/<code>EventLoop</code> in this particular case.</p>
<pre><code>import asyncio

my_list = []

def notify():
    length = len(my_list)
    print("List has changed!", length)

async def append_task():
    while True:
        time.sleep(1)
        await my_list.append(random.random())
        notify()

async def pop_task():
    while True:
        time.sleep(1.8)
        await my_list.pop()
        notify()

loop = asyncio.get_event_loop()
loop.create_task(append_task())
loop.create_task(pop_task())
loop.run_forever()
</code></pre>
<p>Expected output:</p>
<pre><code>$ python prog.py
List has changed! 1 # after 1sec
List has changed! 0 # after 1.8sec
List has changed! 1 # after 2sec
List has changed! 2 # after 3sec
List has changed! 1 # after 3.6sec
List has changed! 2 # after 4sec
List has changed! 3 # after 5sec
List has changed! 2 # after 5.4sec
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this works fine:</p>
<p>note: you wanted to await fast non-io bound operations (<code>list.append</code> and <code>list.pop</code> that are not even coroutines); what you can do is <code>await</code><a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.sleep" rel="nofollow noreferrer"><code>asyncio.sleep(...)</code></a> (which is a coroutine and yield control back to the caller):</p>
<pre><code>import asyncio
import random

my_list = []


def notify():
    length = len(my_list)
    print("List has changed!", length)

async def append_task():
    while True:
        await asyncio.sleep(1)
        my_list.append(random.random())
        notify()

async def pop_task():
    while True:
        await asyncio.sleep(1.8)
        my_list.pop()
        notify()


loop = asyncio.get_event_loop()
cors = asyncio.wait([append_task(), pop_task()])
loop.run_until_complete(cors)
</code></pre>
<p><code>time.sleep</code> itself is blocking and does not play nicely with <code>await</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>List objects do not have awaitable operations, nor do they need to as there is no I/O or other delay you could handle asynchronously.</p>
<p>You also want to use <code>asyncio.sleep()</code>, not <code>time.sleep()</code>; the latter <em>blocks</em>.</p>
<p>The following works just fine; I added in a timestamp in the <code>notify</code> to show this off better:</p>
<pre><code>from datetime import datetime
# ...

start = datetime.now()
def notify():
    length = len(my_list)
    print("t: {:.1f}, List has changed! {}".format(
        (datetime.now() - start).total_seconds(), length))

async def append_task():
    while True:
        await asyncio.sleep(1)
        my_list.append(random.random())
        notify()

async def pop_task():
    while True:
        await asyncio.sleep(1.8)
        my_list.pop()
        notify()
</code></pre>
<p>Note that we use <code>await</code> on the <code>asyncio.sleep()</code> call; that provides a point where your coroutine (<em>cooperative</em> routine) yields control to another routine.</p>
<p>This produces:</p>
<pre><code>$ python asyncio_demo.py
t: 1.0, List has changed! 1
t: 1.8, List has changed! 0
t: 2.0, List has changed! 1
t: 3.0, List has changed! 2
t: 3.6, List has changed! 1
t: 4.0, List has changed! 2
t: 5.0, List has changed! 3
t: 5.4, List has changed! 2
t: 6.0, List has changed! 3
</code></pre>
</div>
<span class="comment-copy">So what output are you getting instead? <code>BaseEventLoop</code> is not a concrete loop implementation; use <code>asyncio.get_event_loop()</code> to get a concrete loop for your platform.</span>
<span class="comment-copy">Also, <code>list</code> operations are not awaitable. <code>time.sleep()</code> won't yield to other coroutines.</span>
<span class="comment-copy">could you explain what to do if I do have a blocking function (such as time.sleep())? All examples use this asyncio.sleep(), but I have actual long computations (or i/o bound stuff), and it's unclear to me how to wrap it such that this example would work. Thanks a lot.</span>
<span class="comment-copy">@Fab: asyncio will not help with cpu-bound functions. and if your i/o-bound stuff is not built on asyncio it will not work either (that is why <code>time.sleep()</code> does not work, but <code>asyncio.sleep()</code> does.) you need to call coroutines that yield the program flow back to the caller to get a benefit from the async loop.</span>
<span class="comment-copy">Thanks a lot, hiro. That clears things up considerably. I've been looking in the wrong place then!</span>
<span class="comment-copy">Asyncio not available on 2.7.</span>
<span class="comment-copy">@rbonallo that is true. but as the question is about <code>asyncio</code> it is about python 3. or what is your point?</span>
