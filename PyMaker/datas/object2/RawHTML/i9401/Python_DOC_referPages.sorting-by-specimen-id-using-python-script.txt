<div class="post-text" itemprop="text">
<p>I have a python script to merge data files with the same format, remove duplicate headers only, adds two new blank lines between every every three lines, except first instance is the first four lines to include headers.</p>
<pre><code>import glob

read_files = glob.glob("*.txt")

header_saved = False
linecnt=0
with open("merged_data.txt", "wb") as outfile:
    for f in read_files:
        with open(f, "rb") as infile:
            header = next(infile)
            if not header_saved:
                outfile.write(header)
                header_saved = True
            for line in infile:
                outfile.write(line)
                linecnt=linecnt+1
                if (linecnt%3)==0:
                    outfile.write("\n\n")
</code></pre>
<p>Example input file text (infile 1):</p>
<pre><code>Specimen_ID Measured_by_initals Measure_date    Sex Beak_length Pronotal_width  Right_fore_femur_length Right_fore_femur_width  Left_fore_femur_length  Left_fore_femur_width   Right_hind_femur_length Right_hind_femur_width  Left_hind_femur_length  Left_hind_femur_width   Right_hind_femur_area   Left_hind_femur_area    Right_hind_tibia_width  Left_hind_tibia_width   Notes
a   1   30-Dec-16   M   4   4   4   4   4   4   4   4   4   4   4   4   4   4   
b   1   30-Dec-16   F   4   4   4   4   4   4   4   4   4   4   4   4   4   4   beak bent
c   1   30-Dec-16   M   4   4   4   4   4   4   4   4   4   4   4   4   4   4   
d   1   30-Dec-16   F   4   4   4   4   4   4   4   4   4   4   4   4   4   4   
e   1   30-Dec-16   F   4   4   4   4   4   4   4   4   4   4   4   4   4   4   pronotum deformed
f   1   30-Dec-16   F   4   4   4   4   4   4   4   4   4   4   4   4   4   4
</code></pre>
<p>Example input file text (infile 2):</p>
<pre><code>Specimen_ID Measured_by_initals Measure_date    Sex Beak_length Pronotal_width  Right_fore_femur_length Right_fore_femur_width  Left_fore_femur_length  Left_fore_femur_width   Right_hind_femur_length Right_hind_femur_width  Left_hind_femur_length  Left_hind_femur_width   Right_hind_femur_area   Left_hind_femur_area    Right_hind_tibia_width  Left_hind_tibia_width   Notes
a   2   30-Dec-16   M   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 
b   2   30-Dec-16   F   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 
c   2   30-Dec-16   M   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 
d   2   30-Dec-16   F   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 
e   2   30-Dec-16   F   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 
f   2   30-Dec-16   F   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 
</code></pre>
<p>I would now like to modify the script so that it will sort the output by <code>Specimen_ID</code>, while keeping the two blank lines in between every three lines (i.e., there should be two blank lines after each unique <code>Specimen_ID</code>). Any suggestions on sorting the rows? I see a lot on sorting multidimensional data or python lists, but not much on 2D tables. </p>
<p>Also, I've encountered some odd behavior in that if I export my data from Excel in tab-delimited txt files, this script will only result in output that contains the contents of the first infile, but not the others. Yet, if I copy and paste the example data from this website into a txt file and use these as infiles, I have no problems. Does anyone know why I'm experiencing this issue?</p>
</div>
<div class="post-text" itemprop="text">
<p>I changed your test data to already be in a list by line.  This is roughly equivalent to what would be returned by readlines():</p>
<pre><code>data_1 = """
Specimen_ID Measured_by_initals Measure_date    Sex Beak_length Pronotal_width  Right_fore_femur_length Right_fore_femur_width  Left_fore_femur_length  Left_fore_femur_width   Right_hind_femur_length Right_hind_femur_width  Left_hind_femur_length  Left_hind_femur_width   Right_hind_femur_area   Left_hind_femur_area    Right_hind_tibia_width  Left_hind_tibia_width   Notes
a   1   30-Dec-16   M   4   4   4   4   4   4   4   4   4   4   4   4   4   4
b   1   30-Dec-16   F   4   4   4   4   4   4   4   4   4   4   4   4   4   4   beak bent
c   1   30-Dec-16   M   4   4   4   4   4   4   4   4   4   4   4   4   4   4
d   1   30-Dec-16   F   4   4   4   4   4   4   4   4   4   4   4   4   4   4
e   1   30-Dec-16   F   4   4   4   4   4   4   4   4   4   4   4   4   4   4   pronotum deformed
f   1   30-Dec-16   F   4   4   4   4   4   4   4   4   4   4   4   4   4   4
""".split('\n')[1:-1]

data_2 = """
Specimen_ID Measured_by_initals Measure_date    Sex Beak_length Pronotal_width  Right_fore_femur_length Right_fore_femur_width  Left_fore_femur_length  Left_fore_femur_width   Right_hind_femur_length Right_hind_femur_width  Left_hind_femur_length  Left_hind_femur_width   Right_hind_femur_area   Left_hind_femur_area    Right_hind_tibia_width  Left_hind_tibia_width   Notes
a   2   30-Dec-16   M   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1
b   2   30-Dec-16   F   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1
c   2   30-Dec-16   M   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1
d   2   30-Dec-16   F   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1
e   2   30-Dec-16   F   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1
f   2   30-Dec-16   F   4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1 4.1
""".split('\n')[1:-1]
</code></pre>
<p>This program removes the need to count lines, by reading in all of the data before writing any data back out:</p>
<pre><code>headers = []
data = {}

# Go through the data for each file and sort by specimen id
for file_data in (data_1, data_2):
    headers.append(file_data[0])
    for line in file_data[1:]:
        # specimen id is first column of space separated data
        specimen_id = line.split(' ', 1)[0].strip()

        # store each line in a list per specimen id
        if specimen_id not in data:
            data[specimen_id] = []
        data[specimen_id].append(line)

# output the merged data
with open("merged_data.txt", "wb") as outfile:
    for specimen_id in sorted(data):
        outfile.write(headers[0] + '\n')
        for line in data[specimen_id]:
            outfile.write(line + '\n')
        outfile.write("\n\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would probably recommend using <a href="http://pandas.pydata.org/" rel="nofollow noreferrer">pandas</a> for working with tabular data in general, since you could easily just read in the data using <code>from_csv()</code>, then call <code>sort_values(by='Specimen ID')</code>, and then iterate over the output to print out the newlines.</p>
<p>Assuming these input files are tab-delimited files, here's how you would read them in and sort them, with <code>pandas</code>:</p>
<pre><code>import pandas as pd
import glob
try:
    from io import StringIO
except ImportError:
    from StringIO import StringIO

dfs = []
for infile in glob.glob('*.txt'):
    # Infile can be a file path or an open file object
    df = pd.read_csv(infile, delimiter='\t')
    dfs.append(df)

df = pd.concat(dfs)     # Combine all the dataframes you loaded in.

df.sort_values(by='Specimen_ID')

# Write this to an intermediate StringIO object before the next step.
o_s = StringIO()
df.to_csv(o_s, sep='\t', index=False)
o_s.seek(0)
lines = o_s.readines()   # Get CSV as a list of lines.
</code></pre>
<p>At this point, you want to dump them out. Without your requirement that they have a blank line every 3 lines, you would just do <code>df.to_csv('merged_text.csv', sep='\t', index=False)</code> and you'd be good (<code>sep</code> to make it tab-delimited, <code>index</code> because <code>pandas</code> will add a numeric index when you read it in and you don't want that to be written out, since it is meaningless), but instead we read it into a list of lines so we can iterate over them and write extra lines as necessary:</p>
<pre><code># This will read through o_s 3 lines at a time and then append a blank "line"
# before writing it.
with open('merged_data.txt', 'w') as f:
    f.writelines(lines[0])   # Write the header line
    for ii in range(1, len(lines) // 3):
        # Write three lines at a time after the header, then an extra newline
        f.writelines(lines[(3 * ii + 1):(3 * (ii + 1) + 1)] + ['\n'])
</code></pre>
<p>If you don't want to use <code>pandas</code> for this, you can try the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code></a> module:</p>
<pre><code>import csv
from operator import itemgetter

lines_in = []
header_line = None
for infile in glob.glob('*.txt'):
    with open(infile, 'r') as f:
        reader = csv.reader(f, delimiter='\t')
        first_line = next(reader)
        if header_line is None:
            header_line = first_line

        # Append all the lines
        lines_in += list(reader)

# Making the assumption that Specimen_ID is always the first column
lines = sorted(lines, key=itemgetter(0))

# Write this out as a well-formatted CSV
o_s = StringIO()
writer = csv.writer(o_s, delimiter='\t')
writer.writerow(header_line)
writer.writerows(lines)

lines = o_s.readlines()
</code></pre>
<p>Once you have <code>lines</code>, you can use the same code I used above to write it to the output file.</p>
</div>
<span class="comment-copy">Do you need to use just the python standard library for this? Generally when people work with tabular data, they use <a href="http://pandas.pydata.org/" rel="nofollow noreferrer">pandas</a>. What you're asking for is not difficult using pure python (just use <code>sorted</code> with a custom <code>key</code> argument), but it's going to be faster and clearer with pandas, likely.</span>
<span class="comment-copy">Is pandas a module within python?</span>
<span class="comment-copy">Pandas is a python library, you can click the link. You install it with <code>pip install pandas</code>. When trying to look at how to do this, though, I realized that your text input format is a bit ambiguous. It seems like you're using a whitespace-delimited tabular input format, but there is unescaped whitespace in the entries, and the data doesn't seem to line up right when there are missing values - like, "bent beak" seems to be under "Right_fore_femur_length", not "Notes". Probably better generate those inputs as csv if possible.</span>
<span class="comment-copy">Not sure about the whitepsace-delimited tabular input format. Textwrangler is showing me tab delimited. Of course everything doesn't line up since everything is separated by one tab and the column headers are longer than values. I can try csv format.</span>
<span class="comment-copy">I think it's possible that SO might not be preserving the <code>\t</code> characters or something when you paste it in. It seems well-formated when I replace <code>/\h+/</code> with <code>\t</code> (manually avoiding the spaces in the notes) and it worked just fine.</span>
<span class="comment-copy">This doesn't seem to sort the data...</span>
<span class="comment-copy">It groups and then sorts by specimen id (a-f in the example)</span>
<span class="comment-copy">Ah, didn't see the <code>sorted(data)</code> in there, was expecting it elsewhere. Fair enough.</span>
