<div class="post-text" itemprop="text">
<p>Simply return some (markdown) string in flask:</p>
<pre><code>@app.route("/raw/", methods=['GET'])
def sometext():
    return "This is an **example**"

## Main procedure
if __name__ == "__main__":
    app.run(debug=True, port=8000) 
</code></pre>
<p>If you call pandoc directly (<code>pandoc http://localhost:8000/raw</code>) or with <code>subprocess</code>, you get no problem:</p>
<pre><code>import subprocess, os

url = "http://localhost:8000/raw"
pbody = subprocess.run(["pandoc", url], check=True, stdout=subprocess.PIPE)
print(pbody.stdout.decode())
</code></pre>
<p>But if you call pandoc within flask method:</p>
<pre><code>@app.route("/get", methods=['GET'])
def index():
    url = "{}".format(url_for('sometext', _external=True))
    pbody = subprocess.run(["pandoc", url], check=True, stdout=subprocess.PIPE, universal_newlines=True)
    print("***Error: ", pbody.stderr)
    return pbody.stdout
</code></pre>
<p>Then when you access to <code>http://localhost:8000/get</code> you get Responsetimeout error from pandoc:</p>
<pre><code>pandoc: HttpExceptionRequest Request {
  host                 = "localhost"
  port                 = 8000
  secure               = False
  requestHeaders       = []
  path                 = "/raw/"
  queryString          = ""
  method               = "GET"
  proxy                = Nothing
  rawBody              = False
  redirectCount        = 10
  responseTimeout      = ResponseTimeoutDefault
  requestVersion       = HTTP/1.1
}
 ResponseTimeout
</code></pre>
<p>References: <a href="http://flask.pocoo.org/docs/0.12/api/#flask.url_for" rel="nofollow noreferrer">url_for in flask API</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As I recall the Flask http server is single threaded so it can't handle the '/raw' request while it's still in the process of handling the '/get' request.</p>
<p><a href="https://stackoverflow.com/a/14823968/508716">Answer to another SO question</a> suggests using <code>app.run(threaded=True)</code> that may be enough for personal use. For production use you should consider a real web server like nginx or apache.</p>
<p>Even then, assuming pandoc supports it (I've no idea) you may want to consider sending the markdown input to pandoc stdin and avoid the extra HTTP request altogether, something like (untested)</p>
<pre><code>markdown = StringIO("This is an **example**")
pbody = subprocess.run(["pandoc"], check=True, stdin=markdown, stdout=subprocess.PIPE, universal_newlines=True)
</code></pre>
</div>
<span class="comment-copy">Or create a real WSGI app. Like <a href="http://flask.pocoo.org/docs/0.12/deploying/wsgi-standalone/" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">The <code>stringIO</code> does not work (python3). Using <a href="https://docs.python.org/3/library/io.html#io.StringIO" rel="nofollow noreferrer">io</a> library I get <code>io.UnsupportedOperation: fileno</code> with <code>markdown = io.StringIO("This is an **example**")</code>. Anyone knows how to use <code>stdin</code> in subprocess in python3?</span>
<span class="comment-copy">It must work with stringIO because in bash you can call <code>echo 'some text' | pandoc -</code> works</span>
