<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/27427067/python-how-to-check-if-an-item-was-added-to-a-set-without-2x-hash-lookup">Python: how to check if an item was added to a set, without 2x (hash, lookup)</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I'm looking for a way to add a <code>value</code> to a <code>set</code> but I also need to know if the value was in the <code>set</code> before I added it. With the additional restriction that the <code>hash</code> of the value is only calculated once (if it wasn't contained before I added it).</p>
<p>It would be quite easy without the restriction:</p>
<pre><code>def contains_add(aset, value):
    contains = value in aset
    if not contains:
        aset.add(value)
    return contains
</code></pre>
<p>But unfortunatly the <code>hash</code> method of the value is quite expensive and I can't (easily) change that class.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way would be to create a temporary <code>set</code> containing the <code>value</code> and then using <a href="https://docs.python.org/3/library/stdtypes.html#set.isdisjoint" rel="nofollow noreferrer"><code>set.isdisjoint</code></a> and <a href="https://docs.python.org/3/library/stdtypes.html#set.update" rel="nofollow noreferrer"><code>set.update</code></a> - both don't require to recalculate the <code>hash</code>:</p>
<pre><code>def set_contains_add(aset, value):
    anotherset = {value}
    containsnot = anotherset.isdisjoint(aset)
    if containsnot:
        aset.update(anotherset)
    return not containsnot
</code></pre>
<p>To verify that this only calculates the <code>hash</code> once:</p>
<pre><code>class MyClass(object):
    def __init__(self, value):
        self._value = value

    def __hash__(self):
        print('hashing')
        return hash(self._value)

    def __eq__(self, other):
        return self._value == other._value

    def __repr__(self):
        return '{}({})'.format(self.__class__.__name__, self._value)

&gt;&gt;&gt; myset = set()
&gt;&gt;&gt; set_contains_add(myset, MyClass(1))
hashing
False
&gt;&gt;&gt; set_contains_add(myset, MyClass(1))
hashing
True
</code></pre>
<p>However this approach is definetly slower than the function presented in the question <strong>if</strong> the <code>hash</code> function isn't expensive!</p>
<hr/>
<p>Another way (<strong>not really recommended because it uses private functions</strong>) is to use the Python-C-API (3.5+) of <code>dict</code> (if one assumes that a <code>dict</code> would be an acceptable alternative to a <code>set</code>). Here simulated with Cython:</p>
<pre><code>%load_ext cython

%%cython

from cpython.object cimport PyObject, PyObject_Hash

cdef extern from "Python.h":
    PyObject* _PyDict_GetItem_KnownHash(object mp, object key, Py_hash_t hash)
    int _PyDict_SetItem_KnownHash(object mp, object key, object item, Py_hash_t hash) except -1
    int _PyDict_Contains(object mp, object key, Py_hash_t hash) except -1

def dict_contains_add(object mydict, object key):
    cdef Py_hash_t keyhash = PyObject_Hash(key)
    cdef bint contains = _PyDict_Contains(mydict, key, keyhash)
    if not contains:
        _PyDict_SetItem_KnownHash(mydict, key, 0, keyhash)
    return contains

&gt;&gt;&gt; mydict = dict()
&gt;&gt;&gt; dict_contains_add(mydict, MyClass(1))
hashing
False
&gt;&gt;&gt; dict_contains_add(mydict, MyClass(1))
hashing
True
</code></pre>
<p>On the plus side <code>dict_contains_add</code> is really fast (faster than the function presented in the question) but as it (mis-)uses private functions only avaiable for python 3.5 and later it may not be a good alternative.</p>
</div>
<span class="comment-copy">You could also write a wrapper class that caches the hash value of whatever it wraps.</span>
<span class="comment-copy">@BrenBarn Good idea, I will try that. Thank you.</span>
