<div class="post-text" itemprop="text">
<p>I have two lists containing strings. I want to take each item in the <code>base_list</code> and search to see if there is a match for the first 3 characters in any values from the <code>custom list</code>. If there is a match, replace the original value in <code>base_list</code> with the one from <code>custom_list</code>. If there is no match, keep the original value.</p>
<pre><code>base_list = ["abc123", "cde123", "efg456", "ghi123"]

custom_list = ["abc321", "efg654"]
</code></pre>
<p>Desired Output:</p>
<pre><code>modified_base_list = ["abc321", "cde123", "efg654", "ghi123"]
</code></pre>
<p>Eventually I also want to write this new <code>modified_base_list</code> as a file containing the items, one per line.</p>
<p>I've tried:</p>
<pre><code>modified_base_list = []

for custom in custom_list:
    for base in base_list:
        if custom[:3] == base[:3]:
            modified_base_list.append(custom)
        else:
            modified_base_list.append(base)


print(modified_base_list)

with open('newfile.txt', 'w') as f:
    for s in modified_base_list:
        f.write(s)
</code></pre>
<p>***EDITING QUESTION to account for lists that have 15k+ lines to find a faster way to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a list comprehension containing a generator expression:</p>
<pre><code>base_list = ["abc123", "cde123", "efg456", "ghi123"]
custom_list = ["abc321", "efg654"] 
modified_base_list = [next((y for y in custom_list if y[:3] == x[:3]), x) for x in base_list]
# ['abc321', 'cde123', 'efg654', 'ghi123']
</code></pre>
<p>Note that I'm assuming if the same 3 character prefix occurs multiple times in <code>custom_list</code> that you only wish to take the first instance.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a solution that mutates the original list, replacing only those where the desired match exists:</p>
<pre><code>&gt;&gt;&gt; base_list = ["abc123", "cde123", "efg456", "ghi123"]
&gt;&gt;&gt; custom_list = ["abc321", "efg654"]
&gt;&gt;&gt; for i, x in enumerate(base_list):
        for test in custom_list:
            if test[:3] == x[:3]:
                base_list[i] = test
                break

&gt;&gt;&gt; base_list
['abc321', 'cde123', 'efg654', 'ghi123']
</code></pre>
<p>Of course if you don’t want to modify the original list, you can create a coopy of it first using <code>modified_base_list = base_list[:]</code>.</p>
<hr/>
<p>You can also follow your own idea but in that case, you have to make sure that you are primarily iterating over <code>base_list</code> and won’t add items multiple times:</p>
<pre><code>modified_base_list = []
for base in base_list:
    found = False
    for custom in custom_list:
        if custom[:3] == base[:3]:
            modified_base_list.append(custom)
            found = True
            break

    if not found:
        modified_base_list.append(base)
</code></pre>
<p>You can also use <code>for…else</code> here instead of that utility variable <code>found</code>:</p>
<pre><code>for base in base_list:
    for custom in custom_list:
        if custom[:3] == base[:3]:
            modified_base_list.append(custom)
            break
    else:
        modified_base_list.append(base)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try the following with <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer"><code>filter()</code></a>:</p>
<pre><code>res = []

for i in base_list:
    temp = list(filter(lambda j: j[:3] == i[:3], custom_list))
    if temp:
        res.append('**{}**'.format(temp.pop()))
    else:
        res.append(i)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt;&gt;&gt; res
['**abc321**', 'cde123', '**efg654**', 'ghi123']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a combination of <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer"><code>list comprehension</code></a> and <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> for this:</p>
<pre><code>base_list = ["abc123", "cde123", "efg456", "ghi123"]

custom_list = ["abc321", "efg654"]

smaller_custom = [y[:3] for y in custom_list]

modified_base_list = ["**{}**".format(custom_list[smaller_custom.index(x[:3])]) if x[:3] in smaller_custom else x for x in base_list]
# ['**abc321**', 'cde123', '**efg654**', 'ghi123']

with open('output_data.txt','w') as outfile:
    outfile.write("\n".join(modified_base_list))
</code></pre>
<p>I hope this helps.</p>
</div>
<span class="comment-copy">What is the output? What should it be?</span>
<span class="comment-copy"><code>["**{}**".format(x) if x[:3] in map(lambda y: y[:3],custom_list) else x for x in base_list]</code>.</span>
<span class="comment-copy">can you explain what the "next" statement is doing?</span>
<span class="comment-copy">@JiaLi <code>next</code> finds the first occurrence for which the generator expression is <code>True</code>, if there are no occurrences, the default value is set to <code>x</code></span>
<span class="comment-copy">Are you sure he wanted to modify <code>base_list</code>? In his code, he create a new list.</span>
<span class="comment-copy">@leaf I was following the question title that says <i>“replace original list”</i>. But if that’s not desired, you can easily create a copy first and start with that.</span>
<span class="comment-copy">Thanks for the help on this. Is there any way to speed this up for a big list? My lists are created from parsing files that have 15000+ lines.</span>
<span class="comment-copy">Which is the big list? You will have to iterate <code>base_list</code> completely anyway, so you cannot speed that up. If your <code>custom_list</code> is very large, you could optimize it by creating a lookup for those lines first, so you can match them in constant time without having to loop over and over.</span>
<span class="comment-copy">hi Abdou, the result list only marks the items in the original list that had matches but i need to replace the actual value also that was found in custom_list where first 3 characters match.</span>
<span class="comment-copy">Please see edits.</span>
