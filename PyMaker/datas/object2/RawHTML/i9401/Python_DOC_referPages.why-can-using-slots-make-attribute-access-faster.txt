<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/14118564/how-does-slots-avoid-a-dictionary-lookup">How does __slots__ avoid a dictionary lookup?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>This question: <a href="https://stackoverflow.com/questions/472000/usage-of-slots">Usage of __slots__?</a> answers that <code>__slots__</code> can make attribute access faster. But I want to know why?</p>
<p>What happens when we define <code>__slots__</code> in a class?</p>
</div>
<div class="post-text" itemprop="text">
<p>As for <em>why</em> <strong>access</strong> is faster Guido <a href="https://python-history.blogspot.com/2010/06/inside-story-on-new-style-classes.html" rel="nofollow noreferrer">talks about it here</a>:</p>
<blockquote>
<p>In particular, in order to make data descriptors work properly, any
  manipulation of an object's attributes first involved a check of the
  class dictionary to see if that attribute was, in fact, a data
  descriptor. If so, the descriptor was used to handle the attribute
  access instead of manually manipulating the instance dictionary as is
  normally the case. However, this extra check also meant that an extra
  lookup would be performed prior to inspecting the dictionary of each
  instance. Thus the use of <code>__slots__</code> was a way to optimize the lookup
  of data attributes—a fallback, if you will, in case people were
  disappointed with the performance impact of the new class system.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>From documentation (<a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer">slots</a>):</p>
<blockquote>
<p>By default, instances of both old and new-style classes have a dictionary for attribute storage. This wastes space for objects having very few instance variables. The space consumption can become acute when creating large numbers of instances.</p>
<p>The default can be overridden by defining <code>__slots__</code> in a new-style class definition. The <code>__slots__</code> declaration takes a sequence of instance variables and reserves just enough space in each instance to hold a value for each variable. Space is saved because <code>__dict__</code> is not created for each instance.</p>
</blockquote>
<p>Using <code>__slots__</code> gives memory and performance optimizations.</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/14118564/how-does-slots-avoid-a-dictionary-lookup" title="how does slots avoid a dictionary lookup">stackoverflow.com/questions/14118564/…</a></span>
<span class="comment-copy"><code>__slots__</code> is an optimisation feature which does away with the <code>__dict__</code> dictionary - hence the optimisation.   It has a number of disadvantages.  It has to be constructed and maintained 'manually', whereas <code>__dict__</code> is dynamic.  Second, inherited classes must use it as well, otherwise they might be slower.  Thirdly, it breaks code that expects there to be a <code>__dict__</code>.</span>
