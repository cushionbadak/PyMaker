<div class="post-text" itemprop="text">
<p>This function is meant to take a generic dictionary (that might, recursively, contain other dictionaries and lists) and put all its contents on a single, linear list.</p>
<pre><code>def make_a_list(a):
  print type(a)
  if (type(a) == type({})):
    return make_a_list(a.keys()) + make_a_list(a.values())
  elif (type(a) == type([])):
    if len(a) &gt; 1:
      return make_a_list(a[0]) + make_a_list(a[1:])
    return a
  else:
    return [a]
</code></pre>
<p>It did its job, but I wonder:
a) did I forget any important data types? (eg. I forgot sets)
b) what would be a more pythonic way to write it? (esp. could I write a list comprehension?)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can avoid list-creation/concatenation in your function by using <code>yield</code>.</p>
<pre><code>def make_a_list(a):
  if isinstance(a, dict):
    yield from make_a_list(a.keys())
    yield from make_a_list(a.values())
  elif isinstance(a, (list, tuple, set)):
    for x in a:
      yield from make_a_list(x)
  else:
    yield a
</code></pre>
<p>This is a generator, so if you really need a list, you can do:</p>
<pre><code>def make_a_real_list(a):
    return list(make_a_list(a))
</code></pre>
<p>Also note <code>isinstance</code> is better than directly comparing types.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can always get rid of these simple types of recursion using your own stack / queue.</p>
<p>First, use the proper tests suggested in the comments, must importantly the <code>__iter__</code> thing.</p>
<p>Then:</p>
<pre><code>things_to_flatten = []
things_to_flatten.append(a)
new_list = []
while things_to_flatten:
  current = things_to_flatten.pop(0)
  if isinstance(current, dict):
      things_to_flatten.extend(current.keys())
      things_to_flatten.extend(current.values())
  elif hasattr(current, '__iter__'):
      things_to_flatten.extend(current)
  else:
      new_list.append(current)
</code></pre>
<p>There's probably some tweaks to make it more efficient, such as realizing that dictionary keys can't be dicts or lists. But, they could be tuples, and those are iterable, so... better to stick with a general check.</p>
</div>
<div class="post-text" itemprop="text">
<p>May I recommend the following solution? The <code>main</code> and <code>make_a_list</code> functions test your idea and show a better was to implement it respectively. If you do not mind working with the concept of iterable objects and generators, the <code>test</code> function and <code>flatten</code> generator may be a better demonstration on how to approach the problem. Please adjust your code for what is most desirable and performs better.</p>
<pre><code>#! /usr/bin/env python3
def main():
    obj = 1
    print('make_a_list({!r}) = {!r}'.format(obj, make_a_list(obj)))
    obj = {1, 2, 3}
    print('make_a_list({!r}) = {!r}'.format(obj, make_a_list(obj)))
    obj = [1, 2, 3]
    print('make_a_list({!r}) = {!r}'.format(obj, make_a_list(obj)))
    obj = [1]
    print('make_a_list({!r}) = {!r}'.format(obj, make_a_list(obj)))
    obj = 'a', 'b', 'c'
    print('make_a_list({!r}) = {!r}'.format(obj, make_a_list(obj)))
    obj = {1: 2, 3: 4, 5: 6}
    print('make_a_list({!r}) = {!r}'.format(obj, make_a_list(obj)), end='\n\n')


def make_a_list(obj):
    if isinstance(obj, dict):
        return make_a_list(list(obj.keys())) + make_a_list(list(obj.values()))
    if isinstance(obj, list):
        if len(obj) &gt; 1:
            return make_a_list(obj[0]) + make_a_list(obj[1:])
        return obj
    return [obj]


def test():
    obj = 1
    print('list(flatten({!r})) = {!r}'.format(obj, list(flatten(obj))))
    obj = {1, 2, 3}
    print('list(flatten({!r})) = {!r}'.format(obj, list(flatten(obj))))
    obj = [1, 2, 3]
    print('list(flatten({!r})) = {!r}'.format(obj, list(flatten(obj))))
    obj = [1]
    print('list(flatten({!r})) = {!r}'.format(obj, list(flatten(obj))))
    obj = 'a', 'b', 'c'
    print('list(flatten({!r})) = {!r}'.format(obj, list(flatten(obj))))
    obj = {1: 2, 3: 4, 5: 6}
    print('list(flatten({!r})) = {!r}'.format(obj, list(flatten(obj))))


def flatten(iterable):
    if isinstance(iterable, (list, tuple, set, frozenset)):
        for item in iterable:
            yield from flatten(item)
    elif isinstance(iterable, dict):
        for item in iterable.keys():
            yield from flatten(item)
        for item in iterable.values():
            yield from flatten(item)
    else:
        yield iterable


if __name__ == '__main__':
    main()
    test()
</code></pre>
</div>
<span class="comment-copy">More generally, you could check if an element is iterable or not (see if it has the <code>__iter__</code> method among its attributes) and then iterate over its elements. Unless you think it is too large this way. Regards.</span>
<span class="comment-copy">Or use the abstract base classes in <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer"><code>collections.abc</code></a></span>
<span class="comment-copy">you should use <code>isinstance</code> instead of <code>type(a) == type({})</code>. At the very least, <code>type(a) == dict</code>. But use <code>isinstance(a, dict)</code></span>
<span class="comment-copy">Also, <code>make_a_list(a.keys()</code>) could just be <code>make_a_list(a)</code>. However, it probably isn't necessary since keys cannot be <code>dict</code>s or <code>list</code>s because both are unhashable.</span>
<span class="comment-copy">If this is <b>working code</b> that you think could be improved, see <a href="https://codereview.stackexchange.com">Code Review</a>. If not, please review <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a> and clarify the issue.</span>
<span class="comment-copy">Maybe <code>things_to_flatten.extend(current)</code> for the <code>elif:</code> clause? For that matter, maybe <code>.extend()</code> for the <code>dict</code> case, also.</span>
