<div class="post-text" itemprop="text">
<p>After checking numerous times, I did find inconsistent info about the topic.</p>
<p>In some case, I did find that <code>__init__ and __del__</code> are the python equivalent of constructors and destructors. This seems to be true for <code>__init__</code>, since I see it called when the class is created; but <code>__del__</code> is never called, when the program end.</p>
<p>In other cases, I did find that <code>__del__</code> is bad, and you have to explicitly deallocate everything by hand.</p>
<p>Now, the issue is: which is which? Because using a unittest.TestCase class, when I call <code>__del__</code> it never get called. Sadly I can't use tear down because I need to start a process before the tests run, and end it once I am done with the tests</p>
</div>
<div class="post-text" itemprop="text">
<p>There are few SO posts in which this kind of behavior that you see, namely for example that <code>__del__</code> doesn't gets called, is kind of discussed. To name a few sources that I found interesting, both SO and the <code>__del__</code> documentation:<br/>
<a href="https://stackoverflow.com/questions/1481488/what-is-the-del-method-how-to-call-it">What is the __del__ method, How to call it?</a><br/>
<a href="https://stackoverflow.com/questions/6104535/i-dont-understand-this-python-del-behaviour">I don't understand this python __del__ behaviour</a><br/>
<a href="https://docs.python.org/3/reference/datamodel.html#object.__del__" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#object.<strong>del</strong></a> </p>
<p>I found especially illuminating the section from the documentation:  </p>
<blockquote>
<p>Note: <code>del x</code> doesn’t directly call <code>x.__del__()</code> — the former decrements the reference count for x by one, and the latter is only called when x‘s reference count reaches zero. Some common situations that may prevent the reference count of an object from going to zero include: circular references between objects (e.g., a doubly-linked list or a tree data structure with parent and child pointers); a reference to the object on the stack frame of a function that caught an exception (the traceback stored in sys.exc_info()<a href="https://stackoverflow.com/questions/6104535/i-dont-understand-this-python-del-behaviour">2</a> keeps the stack frame alive); or a reference to the object on the stack frame that raised an unhandled exception in interactive mode (the traceback stored in sys.last_traceback keeps the stack frame alive). The first situation can only be remedied by explicitly breaking the cycles; the second can be resolved by freeing the reference to the traceback object when it is no longer useful, and the third can be resolved by storing None in sys.last_traceback. Circular references which are garbage are detected and cleaned up when the cyclic garbage collector is enabled (it’s on by default). Refer to the documentation for the gc module for more information about this topic.  </p>
</blockquote>
<p>So there are clearly cases in which  <code>__del__</code> might not be called because the reference count of an object hasn't reached zero and in the note few cases are listed in which this situation might happen.</p>
</div>
<span class="comment-copy">@DYZ CPython uses reference counting, not garbage collection, so you can generally count on something being freed once every reference to it is gone. Other versions of Python may operate differently of course.</span>
<span class="comment-copy">@MarkRansom Yep you are right.</span>
<span class="comment-copy">What do you mean by "when I call <code>__del__</code> it never get called"? How do you call it? This method (just like any other method whose name starts with <code>__</code>) should never be called by hand. It is called automatically when all references to the object are gone. In particular, when you execute <code>del</code> statement.</span>
<span class="comment-copy">I think if you want to be a pedant <code>__init__</code> is not technically a constructor, but an initializer (hence the name), and the constructor is <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a>.</span>
<span class="comment-copy"><code>__del__</code> does get called when there are no more references to the object.  In the case of unittest TestCases, the runner is keeping a reference to them, so they're not going away.  You should look at <a href="https://docs.python.org/2/library/unittest.html#setupclass-and-teardownclass" rel="nofollow noreferrer"><code>setUpClass()</code> and <code>tearDownClass()</code></a>.  They're probably closer to what you want.</span>
<span class="comment-copy">The part related to the reference count is really interesting; thanks for the links</span>
