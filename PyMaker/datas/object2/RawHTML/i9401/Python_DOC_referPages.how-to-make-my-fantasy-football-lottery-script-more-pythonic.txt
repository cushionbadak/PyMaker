<div class="post-text" itemprop="text">
<p>I've built a simple script that chooses a number from a list of set lottery numbers pre-chosen by our fantasy football commissioner. Per the results of this years fantasy football results, each team depending on how well or poor they did in the regular season receives a designated number of chances to pick a lottery number.</p>
<p>The problem is that the script I've written chooses all numbers for one team before it moves onto the next team. I would like the script to pick numbers one at a time moving down the list of teams. There is an added level of complexity because not all teams have the same number of chances of picking a lottery number.</p>
<p>So I'm using counters for each team which decrements down to zero, which would mean they have chosen all the numbers allotted to them. I'm not sure how to make this script pick numbers one at a time.</p>
<p>Here is my code:</p>
<pre><code>import random

lottery_numbers = ['1234','1235','1236','1237','1238','1239',
'1245','1246','1247','1248','1249','1256','1257','1258','1259',
'1267','1268','1269','1278','1279','1289','1345','1346','1347',
'1348','1349','1356','1357','1358','1359','1367','1368','1369',
'1378','1379','1389','1456','1457','1458','1459','1467','1468',
'1469','1478','1479','1489','1567','1568','1569','1578','1579',
'1589','1678','1679','1689','1789','2345','2346','2347','2348',
'2349','2356','2357','2358','2359','2367','2368','2369','2378',
'2379','2389','2456','2457','2458','2459','2467','2468','2469',
'2478','2479','2489','2567','2568','2569','2578','2579','2589',
'2678','2679','2689','2789','3456','3457','3458','3459','3467',
'3468','3469','3478','3479','3489','3567','3568','3569','3578',
'3579','3589','3678','3679','3689','3789','4567','4568','4569',
'4578','4579','4589','4678','4679','4689','4789','5678','5679',
'5689','5789','6789']

#Lists below will hold the final picks per the random selector and chances defined. 
lori = []
danny = []
joon = []
alex = []
abepat = []
jonny = []
jung = []
teho = []
jess = []

#Chances at lottery numbers used as counters.
HayanYujaMarinara = 30
hyobbes = 24
swoop = 19
alsizzle = 15
pabe = 12
youngbuck = 10
grimey = 8
hotay = 5
sopower = 3

#Lotto function to randomly select numbers and assign to general manager lists defined above. 
def lotto():
    #Define lottery pick chances per commissioner.
    while HayanYujaMarinara != 0:
        strong_island = random.choice(lottery_numbers)
        lori.append(strong_island)
        lottery_numbers.remove(strong_island)
        HayanYujaMarinara -= 1

    while hyobbes != 0:
        d4l = random.choice(lottery_numbers)
        danny.append(d4l)
        lottery_numbers.remove(d4l)
        hyobbes -= 1

    while swoop != 0:
        commish = random.choice(lottery_numbers)
        joon.append(commish)
        lottery_numbers.remove(commish)
        swoop -= 1

    while alsizzle != 0:
        texas = random.choice(lottery_numbers)
        alex.append(texas)
        lottery_numbers.remove(texas)
        alsizzle -= 1

    while pabe != 0:
        BestFriendsForever = random.choice(lottery_numbers)
        abepat.append(BestFriendsForever)
        lottery_numbers.remove(BestFriendsForever)
        pabe -= 1

    while youngbuck != 0:
        oldbuck = random.choice(lottery_numbers)
        jonny.append(oldbuck)
        lottery_numbers.remove(oldbuck)
        youngbuck -= 1

    while grimey != 0:
        LittleKidLover = random.choice(lottery_numbers)
        jung.append(LittleKidLover)
        lottery_numbers.remove(LittleKidLover)
        grimey -= 1

    while hotay != 0:
        amazebooths = random.choice(lottery_numbers)
        teho.append(amazebooths)
        lottery_numbers.remove(amazebooths)
        hotay -= 1

    while sopower != 0:
        soWeak = random.choice(lottery_numbers)
        jess.append(soWeak)
        lottery_numbers.remove(soWeak)
        sopower -= 1

if __name__ == '__main__':
    lotto()
print "[+]" + "Lori's lottery numbers are \n" + str(sorted(lori, key=int))
print "**********************************************************"
print "[+]" + "Danny's lottery numbers are \n" + str(sorted(danny, key=int))
print "**********************************************************"
print "[+]" + "Joon's lottery numbers are \n" + str(sorted(joon, key=int))
print "**********************************************************"
print "[+]" + "Alex's lottery numbers are \n" + str(sorted(alex, key=int))
print "**********************************************************"
print "[+]" + "Pabe's lottery numbers are \n" + str(sorted(abepat, key=int))
print "**********************************************************"
print "[+]" + "Jonny's lottery numbers are \n" + str(sorted(jonny, key=int))
print "**********************************************************"
print "[+]" + "Jung's lottery numbers are \n" + str(sorted(jung, key=int))
print "**********************************************************"
print "[+]" + "Teho's lottery numbers are \n" + str(sorted(teho, key=int))
print "**********************************************************"
print "[+]" + "Jess's lottery numbers are \n" + str(sorted(jess, key=int))
print "**********************************************************"
print "[xXx]" + "Remaining lottery numbers \n" + str(sorted(lottery_numbers, key=int))`
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Mathematically there's no difference between assigning all the numbers for a give team first, or going round robin. At least, that's true as long as your numbers are being selected at random, which it seems they are (if inefficiently). So you don't technically need to change anything.</p>
<p>But if you want to change things anyway, there are much more elegant ways you can go about it. For one thing, using separate variables for each person in your league is very awkward (you should use a list!). A big performance improvement would be to shuffle the list of numbers just once, then take values from it in order (rather than selecting random items and needing to delete them from the middle of the list).</p>
<p>Here's my quick (minimally tested) attempt at solving this, using <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">the <code>roundrobin</code> recipe from the <code>itertools</code> documentation</a>:</p>
<pre><code>from random import shuffle
from itertools import repeat, cycle, islice
from collections import OrderedDict, defaultdict

def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).next for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))

lottery_numbers = ['1234','1235','1236','1237','1238','1239',
'1245','1246','1247','1248','1249','1256','1257','1258','1259',
'1267','1268','1269','1278','1279','1289','1345','1346','1347',
'1348','1349','1356','1357','1358','1359','1367','1368','1369',
'1378','1379','1389','1456','1457','1458','1459','1467','1468',
'1469','1478','1479','1489','1567','1568','1569','1578','1579',
'1589','1678','1679','1689','1789','2345','2346','2347','2348',
'2349','2356','2357','2358','2359','2367','2368','2369','2378',
'2379','2389','2456','2457','2458','2459','2467','2468','2469',
'2478','2479','2489','2567','2568','2569','2578','2579','2589',
'2678','2679','2689','2789','3456','3457','3458','3459','3467',
'3468','3469','3478','3479','3489','3567','3568','3569','3578',
'3579','3589','3678','3679','3689','3789','4567','4568','4569',
'4578','4579','4589','4678','4679','4689','4789','5678','5679',
'5689','5789','6789'] # this could probably be automatically generated

def lotto(draws_dict):
    results = defaultdict(list)

    numbers = list(lottery_numbers) # copy
    shuffle(numbers) # shuffles in place
    num_iter = iter(numbers)

    draw_sequence = roundrobin(*(repeat(player, count)
                                 for player, count in draws_dict.items()))

    for i, (player, numbers) in enumerate(zip(draw_sequence, num_iter)):
        print("Draw #{}, for {}: {}".format(i+1, player, number))
        results[player].append(number)

    print("\nFinal results:")
    for player, draws in results.items():
        print("{}: {}".format(player, ", ".join(map(str, sorted(draws)))))

    print("Unselected numbers: {}".format(", ".join(num_iter)))

    return results

if __name__ == "__main__":
    num_draws = OrderedDict([('lori', 30), ('danny', 24), ('joon', 19),
                             ('alex', 15), ('abepat', 12), ('jonny', 10),
                             ('jung', 8), ('teho', 5), ('jess', 3)])
    results = lotto(num_draws)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Round-robin isn't necessary for a random selection.<br/>
You really should think of factoring out your common code. In addition, you might want to consider a different data structure - namely a <code>dict</code>:</p>
<pre><code>import random
chances = [('lori', 30), ('danny', 24), ...]
random.shuffle(lottery_numbers)

lotto = {name: [lottery_numbers.pop() for _ in range(no_tickets)] for name, no_tickets in chances}

for name, tickets in lotto.items():
    print("[+] {}'s lottery numbers are".format(name))
    print(' '.join(str(t) for t in sorted(tickets)))
    print('****')
print("[xXx] Remaining lottery numbers")
print(' '.join(str(t) for t in sorted(lottery_tickets)))
</code></pre>
<p>Output:</p>
<pre><code>[+] lori's lottery numbers are
1237 1238 1259 1267 1269 1279 1345 1359 1378 1389 1458 1459 1789 2346 2347 2348 2378 2456 2458 2459 2468 2478 2489 3467 3469 3689 3789 4679 4789 5678
****
[+] danny's lottery numbers are
1236 1246 1278 1379 1479 1578 1589 1678 1689 2379 2467 2567 2678 2679 2789 3567 3569 3579 3589 3678 4568 4569 4578 5689
...
</code></pre>
</div>
<span class="comment-copy">This is maybe a better fit for the code review SE site</span>
<span class="comment-copy">Is it awkward because i gave someone the "little kid lover" variable? haha. Thanks for the input good sir/ma'am. Round robin from intertools looks legit to me.</span>
<span class="comment-copy">Mostly the issue is how specific your code is to the situation. In my version, you could add an extra team very easily, just by changing the <code>OrderedDict</code> that gets created at the bottom. In your original code, you'd need to write a whole extra branch of logic and add a bunch of new variables.</span>
