<div class="post-text" itemprop="text">
<p>I have a program (NLTK-NER) which provides me with this list:</p>
<pre><code>[
    ('Barak', 'PERSON'),
    ('Obama', 'PERSON'),
    ('is', 'O'),
    ('the', 'O'),
    ('president', 'O'),
    ('of', 'O'),
    ('United', 'LOCATION'),
    ('States', 'LOCATION'),
    ('of', 'LOCATION'),
    ('America', 'LOCATION')
]
</code></pre>
<p>As you can see "Barak" and "Obama" are words of type "PERSON", and I want to merge them (and words of type "LOCATION") together, like this:</p>
<pre><code>['Barak Obama','is','the','president', 'of','United States of America']
</code></pre>
<p>How can I approach this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>What we're looking to do here, essentially, is group some items of <code>classified_text</code> together â€¦ so it stands to reason that <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code></a> can help. First of all, we need a key function that treats items with the tags <code>'PERSON'</code> or <code>'LOCATION'</code> as similar, and all other items as distinct.</p>
<p>This is slightly complicated by the fact that we need a way to distinguish adjacent items that have the same tag (other than <code>'PERSON'</code> or <code>'LOCATION'</code>), e.g. <code>('is', 'O'), ('the', 'O')</code> etc. We can use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate()</code></a> for that:</p>
<pre><code>&gt;&gt;&gt; list(enumerate(classified_text))
[..., (2, ('is', 'O')), (3, ('the', 'O')), (4, ('president', 'O')), ...]
</code></pre>
<p>Now that we know what we're going to provide as input to <code>groupby()</code>, we can write our key function:</p>
<pre><code>def person_or_location(item):
    index, (word, tag) = item
    if tag in {'PERSON', 'LOCATION'}:
        return tag
    else:
        return index
</code></pre>
<p>Notice that the structure of <code>index, (word, tag)</code> in the assignment matches the structure of each item in our enumerated list.</p>
<p>Once we've got that, we can write another function to do the actual merging:</p>
<pre><code>from itertools import groupby

def merge(tagged_text):
    enumerated_text = enumerate(tagged_text)
    grouped_text = groupby(enumerated_text, person_or_location)
    return [
        ' '.join(word for index, (word, tag) in group)
        for key, group in grouped_text
    ]
</code></pre>
<p>Here it is in action:</p>
<pre><code>&gt;&gt;&gt; merge(classified_text)
['Barak Obama', 'is', 'the', 'president', 'of', 'United States of America']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the first thing it came to my mind, pretty sure it could be optimised but is a good start.        </p>
<pre><code>    classified_text = [('Barak', 'PERSON'), ('Obama', 'PERSON'), ('is', 'O'), ('the', 'O'), ('president', 'O'), ('of', 'O'), ('United', 'LOCATION'), ('States', 'LOCATION'), ('of', 'LOCATION'), ('America', 'LOCATION')]

    # Reverse the list so it pops the first element
    classified_text.reverse()
    # Create an aux list to store the result and add the first item
    new_text = [classified_text.pop(), ]
    # Iterate over the text
    while classified_text:
        old_word = new_text[-1]
        new_word = classified_text.pop()

        # If previous word has same type, merge. 
        # Avoid merging 'O' types
        if old_word[1] == new_word[1] and new_word[1] != 'O':
            new_text[-1] = (
                ' '.join((old_word[0], new_word[0])),
                new_word[1],
            )

        # If not just add the tuple
        else:
            new_text.append(new_word)

    # Remove the types from the list and you have your result
    new_text = [x[0] for x in new_text]
</code></pre>
</div>
<span class="comment-copy">Wow, that's way better than I would have done it.</span>
