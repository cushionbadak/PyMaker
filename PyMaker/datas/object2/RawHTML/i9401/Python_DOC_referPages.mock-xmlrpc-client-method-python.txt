<div class="post-text" itemprop="text">
<p>I am in the process of learning unit testing, however I am struggling to understand how to mock functions for unit testing.  I have reviewed many how-to's and examples but the concept is not transferring enough for me to use it on my code.  I am hoping getting this to work on a actual code example I have will help.</p>
<p>In this case I am trying to mock isTokenValid.</p>
<p>Here is example code of what I want to mock.</p>
<pre><code>&lt;in library file&gt;

import xmlrpc.client as xmlrpclib   

class Library(object):
    def function:
        #...
        AuthURL = 'https://example.com/xmlrpc/Auth'
        auth_server = xmlrpclib.ServerProxy(AuthURL)
        socket.setdefaulttimeout(20)
        try:
            if pull == 0:
                valid = auth_server.isTokenValid(token)
        #...
</code></pre>
<p>in my unit test file I have </p>
<pre><code>import library

class Tester(unittest.TestCase):
    @patch('library.xmlrpclib.ServerProxy')
    def test_xmlrpclib(self, fake_xmlrpclib):
        assert 'something'
</code></pre>
<p>How would I mock the code listed in 'function'?   Token can be any number as a string and valid would be a int(1)</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, you can and should mock <code>xmlrpc.client.ServerProxy</code>; your library imports <code>xmlrpc.client</code> as a new name, but it is still the same module object so both <code>xmlrpclib.ServerProxy</code> in your library and <code>xmlrpc.client.ServerProxy</code> lead to the same object.</p>
<p>Next, look at how the object is used, and look for <em>calls</em>, the <code>(..)</code> syntax. Your library uses the server proxy like this:</p>
<pre><code># a call to create an instance
auth_server = xmlrpclib.ServerProxy(AuthURL)
# on the instance, a call to another method
valid = auth_server.isTokenValid(token)
</code></pre>
<p>So there is a chain here, where the mock is called, and the return value is then used to find another attribute that is also called. When mocking, you need to look for that same chain; use the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value" rel="noreferrer"><code>Mock.return_value</code> attribute</a> for this. By default a new mock instance is returned when you call a mock, but you can also set test values.</p>
<p>So to test your code, you'd want to influence what <code>auth_server.isTokenValid(token)</code> returns, and test if your code works correctly. You may also want to assert that the correct URL is passed to the <code>ServerProxy</code> instance.</p>
<p>Create separate tests for different outcomes. Perhaps the token is valid in one case, not valid in another, and you'd want to test both cases:</p>
<pre><code>class Tester(unittest.TestCase):
    @patch('xmlrpc.client.ServerProxy')
    def test_valid_token(self, mock_serverproxy):
        # the ServerProxy(AuthURL) return value
        mock_auth_server = mock_serverproxy.return_value
        # configure a response for a valid token
        mock_auth_server.isTokenValid.return_value = 1

        # now run your library code
        return_value = library.Library().function()

        # and make test assertions
        # about the server proxy
        mock_serverproxy.assert_called_with('some_url')
        # and about the auth_server.isTokenValid call
        mock_auth_server.isTokenValid.assert_called_once()
        # and if the result of the function is expected
        self.assertEqual(return_value, 'expected return value')

    @patch('xmlrpc.client.ServerProxy')
    def test_invalid_token(self, mock_serverproxy):
        # the ServerProxy(AuthURL) return value
        mock_auth_server = mock_serverproxy.return_value
        # configure a response; now testing for an invalid token instead
        mock_auth_server.isTokenValid.return_value = 0

        # now run your library code
        return_value = library.Library().function()

        # and make test assertions
        # about the server proxy
        mock_serverproxy.assert_called_with('some_url')
        # and about the auth_server.isTokenValid call
        mock_auth_server.isTokenValid.assert_called_once()
        # and if the result of the function is expected
        self.assertEqual(return_value, 'expected return value')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are many <a href="http://www.voidspace.org.uk/python/mock/mock.html#mock.Mock.return_value" rel="nofollow noreferrer">mock attributes</a> to use, and you can change your patch decorator usage a little as follows:</p>
<pre><code>class Tester(unittest.TestCase):
    def test_xmlrpclib(self):
        with patch('library.xmlrpclib.ServerProxy.isTokenValid') as isTokenValid:
            self.assertEqual(isTokenValid.call_count, 0)
            # your test code calling xmlrpclib
            self.assertEqual(isTokenValid.call_count, 1)
            token = isTokenValid.call_args[0]  # assume this token is valid
            self.assertEqual(isTokenValid.return_value, 1)
</code></pre>
<p>You can adjust the code above to satisfy your requirements.</p>
</div>
