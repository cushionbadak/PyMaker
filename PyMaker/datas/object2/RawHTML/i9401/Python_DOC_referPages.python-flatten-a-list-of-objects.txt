<div class="post-text" itemprop="text">
<p>I have a list of Objects and each object has inside it a list of other object type. I want to extract those lists and create a new list of the other object.</p>
<pre><code>List1:[Obj1, Obj2, Obj3]

Obj1.myList = [O1, O2, O3]
Obj2.myList = [O4, O5, O6]
Obj3.myList = [O7, O8, O9]
</code></pre>
<p>I need this:</p>
<p><code>L = [O1, O2, O3, O4, ...., O9];</code></p>
<p>I tried <code>extend()</code> and <code>reduce()</code> but didn't work</p>
<pre><code>bigList = reduce(lambda acc, slice: acc.extend(slice.coresetPoints.points), self.stack, [])
</code></pre>
<p>P.S.</p>
<p>Looking for python flatten a list of list didn't help as I got a list of lists of other object.</p>
</div>
<div class="post-text" itemprop="text">
<p>using <code>itertools.chain</code> (or even better in that case <code>itertools.chain.from_iterable</code> as niemmi noted) which avoids creating temporary lists and using <code>extend</code></p>
<pre><code>import itertools
print(list(itertools.chain(*(x.myList for x in List1))))
</code></pre>
<p>or (much clearer and slightly faster):</p>
<pre><code>print(list(itertools.chain.from_iterable(x.myList for x in List1)))
</code></pre>
<p>small reproduceable test:</p>
<pre><code>class O:
    def __init__(self):
        pass

Obj1,Obj2,Obj3 = [O() for _ in range(3)]

List1 = [Obj1, Obj2, Obj3]

Obj1.myList = [1, 2, 3]
Obj2.myList = [4, 5, 6]
Obj3.myList = [7, 8, 9]

import itertools
print(list(itertools.chain.from_iterable(x.myList for x in List1)))
</code></pre>
<p>result:</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve that with one-line <a href="https://docs.python.org/3.1/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer"><code>list comprehension</code></a>:</p>
<pre><code>[i for obj in List1 for i in obj.myList]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>list.extend()</code> returns <code>None</code>, not a list. You need to use concatenation in your lambda function, so that the result of the function call is a list: </p>
<pre><code>bigList = reduce(lambda x, y: x + y.myList, List1, [])
</code></pre>
<p>While this is doable with <code>reduce()</code>, using a list comprehension would be both faster and more pythonic:</p>
<pre><code>bigList = [x for obj in List1 for x in obj.myList]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not exactly rocket science:</p>
<pre><code>L = []
for obj in List1:
    L.extend(obj.myList)
</code></pre>
</div>
<span class="comment-copy">Did you try <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer">this</a>?</span>
<span class="comment-copy">@User9182736455 yes but I didn't know how to implement it for a list of objects which each contains a list of other oject....</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python">Making a flat list out of list of lists in Python</a></span>
<span class="comment-copy">Alternatively you could use <code>chain.from_iterable</code> so that unpacking is not required: <code>itertools.chain.from_iterable(x.myList for x in List1)</code></span>
