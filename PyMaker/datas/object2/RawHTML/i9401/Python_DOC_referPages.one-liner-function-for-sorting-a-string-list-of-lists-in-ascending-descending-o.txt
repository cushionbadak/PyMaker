<div class="post-text" itemprop="text">
<p>Let's assume that I have the following list of lists:</p>
<pre><code>[[list1], [list2], ..., [listK]]
</code></pre>
<p>where list1, list2, ..., listK are lists of N strings.</p>
<pre><code> [list1] = [string11, string12, ..., string1N]
 [list2] = [string21, string22, ..., string2N]
    .              .
    .              .
    .              .
</code></pre>
<p>Now, let's say I want to choose some specific subset of inner list to be sorted in a descending order, and the rest in ascending order. 
For instance, let's assume that N=5, and I first would like to sort the outer list by sorting by first, third, fifth strings of the inner list in the ascending order and by then second and fourth strings in the descending order.</p>
<p>If I didn't care about the ascending/descending, and wanted to sort all in the ascending order, there would be an easy one liner solution to it: </p>
<pre><code>outer_list.sort(key = lambda lst: (lst[0], lst[2], lst[4], lst[1], lst[3]))
</code></pre>
<p>but since we have a condition: first, third, fifth strings of the inner list in the ascending order and then by second and fourth strings in the descending order, I was wondering if there's a simple addition to the code above to make it a one liner solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to all of the other fine answers here, you can also write your own ordering class:</p>
<pre><code>from functools import total_ordering

@total_ordering
class MyOrdering(object):
    def __init__(self, value):
        self.value = value
    def __eq__(self, other):
        return other.value == self.value
    def __lt__(self, other):
        for i in [0, 2, 4]:
            if self.value[i] != other.value[i]:
                return self.value[i] &lt; other.value[i]
        for i in [1, 3]:
            if self.value[i] != other.value[i]:
                return self.value[i] &gt; other.value[i]
        return False
</code></pre>
<p>And then you can sort using the MyOrdering class as your key function:</p>
<pre><code>outer_list.sort(key=MyOrdering)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sorting is <a href="https://docs.python.org/3/howto/sorting.html#sort-stability-and-complex-sorts" rel="nofollow noreferrer">stable in python</a> but <code>.sort</code> is in-place. So if you insist on a single line you could do something like this with <code>sorted</code>:</p>
<pre><code>outer_list = sorted(sorted(outer_list, key=lambda x: (x[0], x[2], x[4])), key=lambda x: (x[1], x[3]), reverse=True)
</code></pre>
</div>
<span class="comment-copy">I don't think your <code>__lt__</code> is correct. It says <code>('b', 'b', 'a', 'b', 'b') &lt; ('a', 'b', 'b', 'b', 'b')</code>. It should only consider the next position when the previous are equal.</span>
<span class="comment-copy">I cleaned the corrected code up for you.</span>
<span class="comment-copy">Thank you @ThijsvanDien</span>
<span class="comment-copy">To have any chance of fitting this one-liner on one line, you could use <code>itemgetter(0, 2, 4)</code> and <code>itemgetter(1, 3)</code>. And mind all the copying of course.</span>
