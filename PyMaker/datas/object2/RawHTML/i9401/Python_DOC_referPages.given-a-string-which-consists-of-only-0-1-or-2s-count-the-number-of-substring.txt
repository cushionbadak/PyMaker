<div class="post-text" itemprop="text">
<p>I am trying to learn algorithm/data structure. To improve my knowledge, I am trying to solve some of the online problems.
One of the problem I am trying to solve is given at <a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=1443" rel="nofollow noreferrer">practiceque</a></p>
<p>I have tried below method:</p>
<pre><code>def count_zero_one_two():
    s = '102100211'
    s_len = len(s)
    count = 0
    for i in range (s_len-1):
        j = i+1
        k = j+1
        #print i, j, k, count
        #print s[i], s[j], s[k]
        if k &gt; (s_len-1):
            print "end"
            break

        elif (s[i] != s[j]) and (s[i] !=s[k]) and (s[j] != s[k]):
            print s[i], s[j], s[k]
            print "not equal"
            count = count+1
            #print count
        else:
            print s[i], s[j], s[k]
            print "equal"
        k = j +i
    print count


count_zero_one_two()
</code></pre>
<p><strong>Question: if my input string is "102100211" then count should be 5 but I am getting 4. Any idea?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>I would solve it like this:</p>
<pre><code>def count_zero_one_two(s):
    num = 0
    for i in range(len(s)):
        for j in range(1, len(s)/3 + 1):
            if all(s[i:i+3*j].count(n) == j for n in '012'):
                num += 1
    return num
</code></pre>
<p><a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow noreferrer"><code>all()</code></a> is used to check that all the 3 characters (for each iteration) are in '012'.</p>
<p>The inner <code>for</code> loop is used to count the number of 0, 1 and 2 in sequences of length 3, 6, 9, etc.</p>
<p><strong>Output:</strong></p>
<pre><code>&gt;&gt;&gt; s = '0102010'
&gt;&gt;&gt; count_zero_one_two(s)
2
&gt;&gt;&gt; 
&gt;&gt;&gt; s = '102100211'
&gt;&gt;&gt; count_zero_one_two(s)
5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import Counter

def countSub(s):
    result = []

    for i in range(3, len(s), 3):
        t = s[:i]
        c = list(Counter(t).values())
        if (c[0]==c[1]==c[2]):
            result.append((t, c[0]))

    return result


def count(s):
    result = []
    for i in range(len(s)-2):
        result.extend(countSub(s[i:]))

    return set(result)




ss = count("102100211")    
print("%s substrings found: " % len(ss), ss)    
</code></pre>
<p>output:</p>
<pre><code>4 substrings found (not counting duplicates and empty strings): 
     {('021', 1), ('210021', 2), ('210', 1), ('102', 1)}
</code></pre>
</div>
<span class="comment-copy">So the problem is: Given a string which consists of only 0, 1 or 2s, count the number of substring which have equal number of 0s, 1s and 2s.</span>
<span class="comment-copy">102, 021, 210, 021,210021 - Those are your answers for this example. Hopefully this convinces you that you need a new approach to this problem.</span>
<span class="comment-copy">Here's one problem with your syntax: <code>x='9999999'</code> <code>for i in range(len(x)-1): print i</code> will return <code>0, 1, 2, 3, 4, 5, 6</code> or something like that, not <code>9, 9, 9...</code> as you seem to expect.</span>
<span class="comment-copy">Clearly your algorithm is wrong, since you look only at substrings of length 3. Please edit this question to become much more specific, or you will have this question closed for being too broad or for not clearly specifying the problem. See <a href="http://stackoverflow.com/help/mcve">How to create a Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">Even in this case, for string '102100211' - num = 4 but expected output is 5</span>
<span class="comment-copy">@RoryDaulton, Now, it should work for the other cases!</span>
<span class="comment-copy">Yes, I think it would work now. The code <code>n in s[i:i+3*j]</code> seems to be redundant, since the <code>count(n) == j</code> check ensures that. If I am not mistaken, this algorithm is O(n**3) where n is len(s), which means order one billion for length 1000. I can't think of a much faster algorithm, off the top of my head.</span>
<span class="comment-copy">Thank you @ettanany!</span>
