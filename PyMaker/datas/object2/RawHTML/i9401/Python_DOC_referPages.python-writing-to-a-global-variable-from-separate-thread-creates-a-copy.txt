<div class="post-text" itemprop="text">
<p>I am trying to create a global state variable, which is written in a callback method (event handler).
However, the callback creates a copy (deep) on another memory location, which is not being seen (of course) by the other methods.
Here is the situation</p>
<pre><code>class Server:
  def __init__(self):
    self.callbacks=[]
    #create a web server instance to listen to requests
    self.app=Flask("test")

  def add_callback(self, func):
    self.calbacks.append(func)
    self.app.add_url_rule("/test", "test", self.handle_http_request)

  def handle_http_request(self):
    content = request.get_json(silent=True)
    for ca in self.callbacks:
      ca(content)

  def start_server(self):
    #some stuff starting flask here...


class SomeModule:
  def __init__(self):
    self.ws=Server()
    self.ws.add_callback(self.callback)
    self.callback_called=False

  def callback(self, content):
    print "callback executing---"
    print "var addr before callback assign: "+str(hex(id(self.callback_called)))
    self.callback_called=True
    print "var addr after callback assign: "+str(hex(id(self.callback_called)))

  def start(self):
    self.ws.start()
    #send a request to the server using the request library, which invokes all the trigger
    #check the state variable:
    print "var addr before check: "+str(hex(id(self.callback_called)))
    if (not self.callback_called):
      raise Exception("error...")

if __name__ == '__main__':
  sm=SomeModule()
  sm.start()
</code></pre>
<p>The output is then:</p>
<pre>
callback executing---
var addr before callback assign: 0x927910
var addr before callback assign: 0x927930
var addr before check: 0x927910
</pre>
<p>Can anyone suggest me a way how to avoid this?
In c++ its clear how to access pointer and mutex. Here however, I did not manage to find any ways to do a secure write on the variable...</p>
<p>Thanks a lot in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you're using multithreading, and not multiprocessing in your tags, I'll still go ahead and post this answer.. Might be helpful for some.</p>
<p>Some objects are <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">immutable</a>, copied as you said. Other variables, such as <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">dictionaries</a> tend not to be and can be manipulated from functions or threats (not sure if threads only apply to certain cases).</p>
<p>If you pass a <code>dict</code> as a parameter to a thread for instance, that variable can be manipulated and that affects the original version of your variable.</p>
<p>However, doing this is risky. There might be update collisions, access violations and in general just hard to keep track of where things happen.</p>
<p>But here's an example of how to pass a <code>dict</code> into a thread and present the change. It's crude, but gives you a working example.</p>
<pre><code>from threading import *

class server(Thread):
    def __init__(self, o):
        self.o = o
        Thread.__init__(self)
        self.start()

    def run(self):
        for i in range(3):
            self.o['test'] = i

test_var = {'test' : 0}
server(test_var)

while len(enumerate()) &gt; 1: # Stupid and oversimplified wait for threads to end.
    pass

print(test_var)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem was actually somewhere else. :( The reason was, that Flask (the Webserver) was started in a separate thread and there some instances are copied for some reason. I did not dig any further, Just avoided to use Flask and switched to cherrypy and started it in a non-blocking mode.
Thinkgs started to work there as expected.</p>
<p>@torxed, thank you very much for your help. It indeed pointed me into the right direction!</p>
</div>
<span class="comment-copy">Thank you very much. When I replace the variable self.callback_called with a dict, the memory inspection shows indeed the same location. However, even if the varibale is set to eg.<code>self.callback_called['done'] = True</code> it is seen as False again during the check.  Feeling like I miss something obvious.... :(</span>
<span class="comment-copy">@mojovski Are you printing the variable to quickly? Because in my test I get it working perfectly. Could you paste you trial code over at <a href="https://gist.github.com/" rel="nofollow noreferrer">gist.github.com</a> ?</span>
<span class="comment-copy">You're more than welcome :) To bad the question wasn't tagged with <code>Flask</code>, because I overlooked that in your code :) Glad it all worked out tho!</span>
