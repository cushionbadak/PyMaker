<div class="post-text" itemprop="text">
<p>Here is a console demonstration:</p>
<pre><code>&gt;&gt;&gt; x = "aâ€Šb"
&gt;&gt;&gt; x
'a\u200ab'
&gt;&gt;&gt; repr( x )
"'a\\u200ab'"
</code></pre>
<p>So it seems pprint is using the same technology as printing strings does.</p>
<p>Admittedly the white space character between a &amp; b in the initial value bound to x is, indeed U+200a.  But when using UTF-8 input and output encodings, why would any characters be converted to \u notation for output?</p>
<p>Question 2, of course, is how can one learn what is the whole set of characters are converted in that manner?</p>
<p>Question 3, of course, is how can one suppress that behavior?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>pprint</code> prints the representation of the object you pass it. From <a href="https://docs.python.org/3/library/pprint.html" rel="nofollow noreferrer">the docs</a></p>
<blockquote>
<p>The pprint module provides a capability to â€œpretty-printâ€ arbitrary
  Python data structures in a form which can be used as input to the
  interpreter.</p>
</blockquote>
<p>And "a form which can be used as input to the interpreter" means you get the object's <em>representation</em>, i.e., what its <code>__repr__</code> method returns.</p>
<p>If you want strings to be printed using their <code>__str__</code> method instead of their <code>__repr__</code> then don't use <code>pprint</code>.</p>
<hr/>
<p>Here's a Python 3 code snippet that looks for chars that get represented using a <code>\u</code> escape code:</p>
<pre><code>for i in range(1500):
    c = chr(i)
    r = repr(c)
    if r'\u' in r:
        print('{0:4} {0:04x} {1} {2}'.format(i, r, c))
</code></pre>
<p><strong>output</strong></p>
<pre><code> 888 0378 '\u0378' Í¸
 889 0379 '\u0379' Í¹
 896 0380 '\u0380' Î€
 897 0381 '\u0381' Î
 898 0382 '\u0382' Î‚
 899 0383 '\u0383' Îƒ
 907 038b '\u038b' Î‹
 909 038d '\u038d' Î
 930 03a2 '\u03a2' Î¢
1328 0530 '\u0530' Ô°
1367 0557 '\u0557' Õ—
1368 0558 '\u0558' Õ˜
1376 0560 '\u0560' Õ 
1416 0588 '\u0588' Öˆ
1419 058b '\u058b' Ö‹
1420 058c '\u058c' ÖŒ
1424 0590 '\u0590' Ö
1480 05c8 '\u05c8' ×ˆ
1481 05c9 '\u05c9' ×‰
1482 05ca '\u05ca' ×Š
1483 05cb '\u05cb' ×‹
1484 05cc '\u05cc' ×Œ
1485 05cd '\u05cd' ×
1486 05ce '\u05ce' ×
1487 05cf '\u05cf' ×
</code></pre>
<p>Note that codepoints &gt; 0xffff get represented using a <code>\U</code> escape code, when necessary.</p>
<pre><code>for i in range(65535, 65600):
    c = chr(i)
    r = repr(c)
    if r'\u' in r.lower():
        print('{0:4} {0:04x} {1} {2}'.format(i, r, c))
</code></pre>
<p><strong>output</strong></p>
<pre><code>65535 ffff '\uffff' ï¿½
65548 1000c '\U0001000c' ğ€Œ
65575 10027 '\U00010027' ğ€§
65595 1003b '\U0001003b' ğ€»
65598 1003e '\U0001003e' ğ€¾
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I finally found the documentation that explains it.
From <a href="http://%20https://docs.python.org/3/c-api/unicode.html" rel="nofollow noreferrer">Python Unicode documentation</a>:</p>
<p>int Py_UNICODE_ISPRINTABLE(Py_UNICODE ch)</p>
<pre><code>Return 1 or 0 depending on whether ch is a printable character. Nonprintable characters are those characters defined in the Unicode character database as â€œOtherâ€ or â€œSeparatorâ€, excepting the ASCII space (0x20) which is considered printable. (Note that printable characters in this context are those which should not be escaped when repr() is invoked on a string. It has no bearing on the handling of strings written to sys.stdout or sys.stderr.)
</code></pre>
<p>It partly answers the first question (the fact, not the reason why), and leads to the exact answer for Question 2.</p>
<p><a href="https://www.compart.com/en/unicode/category/Zs" rel="nofollow noreferrer">Unicode space separator characters</a></p>
<p>I suppose the desire to be visually unambiguous is the reason for the fact... all those separator characters look "the same" (white space). That might be important if you are examining a paper log, but if examining it online, copy/pasting to a hex display tool, or to <a href="http://r12a.github.io/apps/conversion/" rel="nofollow noreferrer">This wonderfully helpful Unicode decoder</a> is certainly sufficient, without interrupting the flow of the text when the details of which separator was used is not important (which, in my opinion, is most of the non-paper time).</p>
<p>Question 3 can apparently be done in one of two ways: Creating a subclass of str with a different <strong>repr</strong> (disrupts existing code) or creating a subclass of pprint with a format function that avoids calling <strong>repr</strong> for str, but just includes the value directly.</p>
</div>
<span class="comment-copy">Clever to write code to look for them, which could answer question 2 nicely, but not the others. Perhaps analysis of the complete list would give clues. Certainly if the codes are not defined as characters by Unicode, one would expect \u notation, but for defined characters, I was surprised.</span>
<span class="comment-copy">@Victoria You shouldn't be surprised that \x, \u and \U notation is used in the repr of a string. The repr of an object needs to be robust &amp; unambiguous. It's designed to be used by programmers, eg in source code &amp; directly in the interpreter. It's <i>not</i> supposed to be displayed to the user: they should only see properly formatted output created using the <code>__str__</code> method of the string, eg what <code>print(my_string)</code> displays.</span>
<span class="comment-copy">@Victoria (cont) For further info on this important topic please take a look at the discussions of <code>__str__</code> vs <code>__repr__</code> in the docs, including the tutorial. Also see <a href="http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python">here</a> and the relevant linked pages.</span>
<span class="comment-copy">Your link, and some further searching based on keywords found in them finally let me to the answers. Thanks for contributing.</span>
<span class="comment-copy">@Victoria You may find the <a href="https://docs.python.org/3/library/unicodedata.html" rel="nofollow noreferrer">unicodedata</a> module of interest. In particular, the <code>category</code> function is useful for determining what a particular char is for, and the <code>name</code> function returns the char's official name. Note that you can use Unicode names in strings, using a <code>\N{name}</code> escape sequence.</span>
