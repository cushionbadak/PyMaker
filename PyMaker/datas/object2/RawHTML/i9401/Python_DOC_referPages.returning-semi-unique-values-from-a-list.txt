<div class="post-text" itemprop="text">
<p>Not sure how else to word this, but say I have a list containing the following sequence:</p>
<pre><code>[a,a,a,b,b,b,a,a,a]
</code></pre>
<p>and I would like to return:</p>
<pre><code>[a,b,a]
</code></pre>
<p>How would one do this in principle?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby</code>, this groups consecutive same elements in the same group and return an iterator of key value pairs where the key is the unique element you are looking for:</p>
<pre><code>from itertools import groupby  

[k for k, _ in groupby(lst)]
# ['a', 'b', 'a']
</code></pre>
<hr/>
<pre><code>lst = ['a','a','a','b','b','b','a','a','a']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Psidoms way is a lot better, but I may as well write this so you can see how it'd be possible just using basic loops and statements. It's always good to figure out what steps you'd need to take for any problem, as it usually makes coding the simple things a bit easier :)</p>
<pre><code>original = ['a','a','a','b','b','b','a','a','a']
new = [original[0]]

for letter in original[1:]:
    if letter != new[-1]:
        new.append(letter)
</code></pre>
<p>Basically it will append a letter if the previous letter is something different.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using list comprehension:</p>
<pre><code>original = ['a','a','a','b','b','b','a','a','a']
packed = [original[i] for i in range(len(original)) if i == 0 or original[i] != original[i-1]]
print(packed)  # &gt; ['a', 'b', 'a']
</code></pre>
<p>Similarly (thanks to pylang) you can use <code>enumerate</code> instead of <code>range</code>:</p>
<pre><code>[ x for i,x in enumerate(original) if i == 0 or x != original[i-1] ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.unique_justseen" rel="nofollow noreferrer"><code>more_itertools</code></a> has an implementation of the <code>unique_justseen</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipe from <code>itertools</code></a>:</p>
<pre><code>import more_itertools as mit

list(mit.unique_justseen(["a","a","a","b","b","b","a","a","a"]))
# ['a', 'b', 'a']
</code></pre>
</div>
<span class="comment-copy">Maybe "Collapse/compress duplicate elements in a list" ?</span>
<span class="comment-copy">Thanks for the useful suggestions everyone :).  Much appreciated.</span>
<span class="comment-copy">How about <code>for i, _ in enumerate(lst)</code> instead?</span>
<span class="comment-copy">Even better: <code>[lst[i] for i,x in enumerate(lst) if i == 0 or x != lst[i-1]]</code></span>
