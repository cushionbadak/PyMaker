<div class="post-text" itemprop="text">
<p>I wonder what's the correct way of converting (deserializing) a string to a Python's Enum class. Seems like <code>getattr(YourEnumType, str)</code> does the job, but I'm not sure if it's safe enough.</p>
<p>Just to be more specific, I would like to convert a <code>'debug'</code>string to an Enum object like this:</p>
<pre><code>class BuildType(Enum):
    debug = 200
    release = 400
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This functionality is already built in to Enum [1]:</p>
<pre><code>&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class Build(Enum):
...   debug = 200
...   build = 400
... 
&gt;&gt;&gt; Build['debug']
&lt;Build.debug: 200&gt;
</code></pre>
<p>[1] Official docs: <a href="https://docs.python.org/3/library/enum.html#programmatic-access-to-enumeration-members-and-their-attributes" rel="noreferrer"><code>Enum programmatic access</code></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Another alternative (especially useful if your strings don't map 1-1 to your enum cases) is to add a <code>staticmethod</code> to your <code>Enum</code>, e.g.:</p>
<pre><code>class QuestionType(enum.Enum):
    MULTI_SELECT = "multi"
    SINGLE_SELECT = "single"

    @staticmethod
    def from_str(label):
        if label in ('single', 'singleSelect'):
            return QuestionType.SINGLE_SELECT
        elif label in ('multi', 'multiSelect'):
            return QuestionType.MULTI_SELECT
        else:
            raise NotImplementedError
</code></pre>
<p>Then you can do <code>question_type = QuestionType.from_str('singleSelect')</code></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def custom_enum(typename, items_dict):
    class_definition = """
from enum import Enum

class {}(Enum):
    {}""".format(typename, '\n    '.join(['{} = {}'.format(k, v) for k, v in items_dict.items()]))

    namespace = dict(__name__='enum_%s' % typename)
    exec(class_definition, namespace)
    result = namespace[typename]
    result._source = class_definition
    return result

MyEnum = custom_enum('MyEnum', {'a': 123, 'b': 321})
print(MyEnum.a, MyEnum.b)
</code></pre>
<p>Or you need to convert string to <strong>known</strong> Enum?</p>
<pre><code>class MyEnum(Enum):
    a = 'aaa'
    b = 123

print(MyEnum('aaa'), MyEnum(123))
</code></pre>
<p>Or:</p>
<pre><code>class BuildType(Enum):
    debug = 200
    release = 400

print(BuildType.__dict__['debug'])

print(eval('BuildType.debug'))
print(type(eval('BuildType.debug')))    
print(eval(BuildType.__name__ + '.debug'))  # for work with code refactoring
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I just want to notify this does not work in python 3.6</p>
<pre><code>class MyEnum(Enum):
    a = 'aaa'
    b = 123

print(MyEnum('aaa'), MyEnum(123))
</code></pre>
<p>You will have to give the data as a tuple like this</p>
<pre><code>MyEnum(('aaa',))
</code></pre>
<p>EDIT: 
This turns out to be false. Credits to a commenter for pointing out my mistake</p>
</div>
<span class="comment-copy">Yes, this is what I was looking for. A link to official docs on that matter would be nice.</span>
<span class="comment-copy">@Vladius:  Added link.</span>
<span class="comment-copy">What about a fallback value in case the input needs to be sanitised? Something in the sort of <code>Build.get('illegal', Build.debug)</code>?</span>
<span class="comment-copy">@Hetzroni:  <code>Enum</code> does not come with a <code>.get()</code> method, but you can add one as needed, or just make a base <code>Enum</code> class and always inherit from that.</span>
<span class="comment-copy">@Dragonborn:  That will not work.</span>
<span class="comment-copy">I mean I would like to convert a <code>debug</code> string to an enum of such:  <code>python class BuildType(Enum):     debug = 200     release = 400 </code></span>
<span class="comment-copy">Great tips! Is using <code>__dict__</code> the same as <code>getattr</code>? I'm worrying about name collisions with internal Python attributes....</span>
<span class="comment-copy">Oh... yes it the same as <code>getattr</code>. I see no reason for name collisions. You just can't set keyword as field of class.</span>
<span class="comment-copy">Using Python 3.6.6, I could not reproduce this behaviour. I think you may have made a mistake while testing (I know I did the first time when checking this). If you accidentally put a <code>,</code> (comma) after each element (as if the elements were a list) then it treats each element as a tuple. (i.e. <code>a = 'aaa',</code> is actually the same as <code>a = ('aaa',)</code>)</span>
<span class="comment-copy">You are right, It was different bug in my code. I Somehow thought you needed to put <code>,</code> behind every line while defining the enum which turned the values into tuples somehow</span>
