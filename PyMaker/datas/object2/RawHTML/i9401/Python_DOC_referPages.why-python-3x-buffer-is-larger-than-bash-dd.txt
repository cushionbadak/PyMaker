<div class="post-text" itemprop="text">
<p>I want to copy a big file (&gt;=1GB) to memory:</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from subprocess import check_output
from shlex import split

zeroes = open('/dev/zero')

SCALE = 1024

B = 1
KB = B * SCALE
MB = KB * SCALE
GB = MB * SCALE

def ck(str):
    print('{}:\n{}\n'.format(str, check_output(split('free -m')).decode()))

ck('## Before')

buffer = zeroes.read(GB)

ck('## After')  
</code></pre>
<p>Output:</p>
<pre><code>## Before:
              total        used        free      shared  buff/cache   available
Mem:          15953        7080        6684         142        2188        8403
Swap:          2047           0        2047


## After:
              total        used        free      shared  buff/cache   available
Mem:          15953        9132        4632         142        2188        6351
Swap:          2047           0        2047
</code></pre>
<p>Obviously 6684 - 4632 = 2052 MB (which is almost 2x the size of expected 1 GB).</p>
<p>Tests with <code>dd</code> show expected results:</p>
<pre><code># mkdir -p /mnt/tmpfs/
# mount -t tmpfs -o size=1000G tmpfs /mnt/tmpfs/
# free -m 
              total        used        free      shared  buff/cache   available
Mem:          15953        7231        6528         144        2192        8249
Swap:          2047           0        2047
# dd if=/dev/zero of=/mnt/tmpfs/big_file bs=1M count=1024
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 0.695143 s, 1.5 GB/s
# free -m 
              total        used        free      shared  buff/cache   available
Mem:          15953        7327        5406        1168        3219        7129
Swap:          2047           0        2047
</code></pre>
<p>What's the problem? Why python was 2x as large?</p>
<p>What are the best practices to replicate <em>desired output</em> *  in <code>Python 3x</code>?</p>
<p>* Desired output - <code>python</code> uses the same amount of memory as <code>dd</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>See <a href="https://stackoverflow.com/questions/26079392/how-is-unicode-represented-internally-in-python">How is unicode represented internally in Python?</a>.</p>
<p>Because you aren't specifying that your file is binary, you're reading unicode characters, which require 2-4 bytes per character to store in-memory, even for a codepoint represented as a single byte on-disk.</p>
<hr/>
<p>Use:</p>
<pre><code>zeroes = open('/dev/zero', 'rb') # the 'b' flag is critical here!
</code></pre>
<p>...to open your file to read bytestrings.</p>
</div>
<span class="comment-copy">Re: "desired output" -- what <i>is</i> your desired output? If you want to work with huge storage buffers -- in any language -- you're better off using memory-mapped IO.</span>
<span class="comment-copy">BTW, if your content is a Unicode string instead of a bytestring... well, there's your problem.</span>
<span class="comment-copy">...to read bytes, use <code>zeroes = open('/dev/zero', 'rb')</code></span>
<span class="comment-copy">...as an aside, please <i>stop</i> propagating the silly <code>check_output(split('string with spaces'))</code> idiom -- it encourages bugs that don't happen in <code>check_output(['string', 'with', 'spaces'])</code>, as parameters that are going to be substituted in need to be shell-quoted first. (That is to say, <code>check_output(split('rm -- %s' % filename))</code> can delete multiple files if passed a name with spaces or glob characters, whereas <code>check_output(['rm', '--', filename])</code> is guaranteed to delete only one).</span>
<span class="comment-copy">@CharlesDuffy I have never seen a case when <code>/dev/zero</code> was an unicode string.</span>
<span class="comment-copy">Since the implementation of PEP 393 in Python 3.3 unicode strings use  internally represented in a number of different ways. Depending on requirements, 1, 2 or 4 byte sequences can be used to store a character (<a href="https://docs.python.org/3/c-api/unicode.html" rel="nofollow noreferrer">unicode api</a> ). These are fixed width encodings and I believe correspond to latin-1, USC-2, and UTF-32. There is no need to use a 2 or 4-byte representation when decoding <code>/dev/zeros</code> as characters. The data can be adequately stored using latin-1. Try: <code>s = '\0' * (1 &lt;&lt; 20); print(sys.getsizeof(s))</code>. The result is 1MB + 25 bytes.</span>
