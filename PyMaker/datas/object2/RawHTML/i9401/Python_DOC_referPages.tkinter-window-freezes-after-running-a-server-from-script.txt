<div class="post-text" itemprop="text">
<p>I am making a program that creates an separate python web server, the server being:</p>
<pre><code>import os, sys
from http.server import HTTPServer, CGIHTTPRequestHandler

webdir = '.'
port = 8000
print('Server Now Running')
os.chdir(webdir)
srvraddr = (('' , port))
srvrobj = HTTPServer(srvraddr, CGIHTTPRequestHandler)
srvrobj.serve_forever()
</code></pre>
<p>and then original program runs that server from command line:</p>
<pre><code>def runServer(self):
    os.system('Webserver.py')
</code></pre>
<p>All of this is done with buttons in a Tkinter window.  When this function is called, the Tkinter window freezes and the next button cannot be pressed (one which would pull up a local html file in Safari, through the server).  </p>
<p>I've looked around and it looks like I might need threading or something...</p>
<p>I have am left clueless as to how I would go about this.  Can provide more of my original program if necessary (it's a bit clunky).</p>
<p>I'm looking for a simple solution or maybe a specific reference to get me heading in the right direction.</p>
<p>Very new (3 months) to Python, so please keep this in mind.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3.5/library/subprocess.html" rel="nofollow noreferrer">subprocess</a></p>
<pre><code>import subprocess

s = subprocess.Popen(['Webserver.py'])
</code></pre>
<p>or maybe it will need <code>python</code> to start script</p>
<pre><code>s = subprocess.Popen(['python', 'Webserver.py'])
</code></pre>
<p>or you can run </p>
<pre><code>s = subprocess.Popen(['python3', '-m', 'http.server', '--cgi', '8000'])
</code></pre>
<p>and later you can stop process</p>
<pre><code>s.kill()
</code></pre>
<hr/>
<ul>
<li><code>Popen</code> (without argument <code>shell=True</code>) expects argument as list </li>
<li>after you close program subprocess still works so you have to kill them before you close program.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Since the exit code of the called program is the return value of the function os.system, the program is blocked until the called program exited. </p>
<p>Try using the non-blocking <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="nofollow noreferrer" title="subprocess">subprocess.Popen</a> instead.</p>
</div>
<span class="comment-copy">when you run <code>os.system</code> then it waits till it ends. And this way <code>mainloop</code> can't do its job - receives key/mouse event, sends to widgets, redraws widgets, etc. You need module <code>threading</code> or <code>subprocess</code> to run server as separated thread/process and then <code>mainloop</code> will can do its job.</span>
<span class="comment-copy">researching this now... could you give me an idea of what that would look like in this program?</span>
<span class="comment-copy"><a href="https://docs.python.org/3.5/library/threading.html" rel="nofollow noreferrer">threading</a> and <a href="https://docs.python.org/3.5/library/subprocess.html" rel="nofollow noreferrer">subprocess</a></span>
<span class="comment-copy">Totally worked!!! That was incredibly easy.  Here's my new function:  def runServer(self): 		    nm = self.e2.get() 		    fld = "/Users/peer/temp/" + self.e1.get() + "/" + nm + ".py" 		    s = subprocess.Popen(['python3', fld]).  with e2 being the name of the web server file and e1 being it's created top folder.    Thanks Much</span>
<span class="comment-copy">I'm now looking to see where I should put s.kill().  Remember I'm in a Tkinter window... I need to keep server running until program closes.</span>
<span class="comment-copy">you can put <code>s.kill()</code> after <code>mainloop()</code> - it will be executed after you close window. Or if you have button to close window then assign function which do <code>s.kill()</code> and <code>window.destroy()</code></span>
<span class="comment-copy">So,  p = self.runServer, subprocess.Popen(p) ??? I'm lost.  Reading basics of threading now.  An example would be invaluable.</span>
