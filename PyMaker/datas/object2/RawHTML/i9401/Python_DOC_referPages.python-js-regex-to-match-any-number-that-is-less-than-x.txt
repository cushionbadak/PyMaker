<div class="post-text" itemprop="text">
<p>I have some JSON data in a text file, something like:</p>
<pre><code>..."priority":1,...
..."priority":3,...
..."priority":5,...
</code></pre>
<p>what I want to do is match all lines where priority is less than or equal to 3. </p>
<p>so the matches would be:</p>
<pre><code>..."priority":1,...
..."priority":3,...
</code></pre>
<p>So my basic regex might look like:</p>
<pre><code>/"priority":[0-9],/
</code></pre>
<p>and a simple script to test this</p>
<pre><code>const regex = /"priority":[0-9],/;

const str = '{"dateCreated":"2016-12-31T06:41:32.298Z","pid":15154,"count":1,"uid":"77d55631-36ab-4805-aa17-1c984c8d4d04","priority":1,"isRead":false,"line":"foo bar baz"}';

console.log(regex.test(str));   // true
</code></pre>
<p>so this will match any number 0-9, but how can I match X and below? Where X might be a 2 digit number?</p>
<p>Is this a concise way to do that somehow?</p>
<p>The raw data in the file looks like this:</p>
<pre><code>{"dateCreated":"2016-12-31T20:31:42.928Z","pid":5502,"count":0,"uid":"b21ac5eb-e25f-411c-80e9-955ff6eab964","priority":2,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:43.058Z","pid":5502,"count":1,"uid":"19f69863-7bf7-45f1-99b8-30fe332e88b9","priority":1,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:43.262Z","pid":5502,"count":2,"uid":"ee8ca050-d1b5-4787-8d9f-78b17a9c4e9e","priority":1,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:43.462Z","pid":5502,"count":3,"uid":"40fdbf37-0caf-4dde-b6fa-8522cd333b6e","priority":1,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:43.666Z","pid":5502,"count":4,"uid":"d1928b11-e93c-413a-8e4e-49ac8a7b38b5","priority":1,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:43.865Z","pid":5502,"count":5,"uid":"9fdff4bc-5126-43f9-85c6-d1212bac777b","priority":1,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:44.071Z","pid":5502,"count":6,"uid":"3058cc78-eea6-4de9-96de-69c107b73724","priority":1,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:44.271Z","pid":5502,"count":7,"uid":"52899ff3-2c17-4392-9409-a24152d4d15c","priority":1,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:44.468Z","pid":5502,"count":8,"uid":"a775cd96-be9e-4713-83d3-92441d73443d","priority":1,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:44.675Z","pid":5502,"count":9,"uid":"4fedb82b-1fb9-4049-870e-ff3bdf32fd5e","priority":2,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:44.877Z","pid":5502,"count":10,"uid":"c3fd144c-0182-4777-80a8-ce5db0da6525","priority":2,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:45.075Z","pid":5502,"count":11,"uid":"70fde6ea-f57c-4d2c-9eb0-d2b04fae23f2","priority":1,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:45.277Z","pid":5502,"count":12,"uid":"540db3c7-bfe0-4d09-b4b6-d8922455c8d5","priority":3,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:45.483Z","pid":5502,"count":13,"uid":"1eca7c3b-be01-4457-885f-b7cb807952aa","priority":1,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:45.683Z","pid":5502,"count":14,"uid":"d7f3cf02-e302-49d5-9977-fac592349335","priority":1,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:45.881Z","pid":5502,"count":15,"uid":"8760aa12-5c10-456f-8ae1-b570bc939ff7","priority":2,"isRead":false,"line":"foo bar baz"}
{"dateCreated":"2016-12-31T20:31:46.087Z","pid":5502,"count":16,"uid":"152a51da-d253-4245-999d-6518318c305d","priority":1,"isRead":false,"line":"foo bar baz"}
</code></pre>
<p>(It's newline separate JSON data)</p>
</div>
<div class="post-text" itemprop="text">
<p>This isn't a good case for <code>regex</code>. Instead, you should be loading the file using the json module, and then simply testing for the value of "priority".</p>
<pre><code>import json

with open('./sample_json.json', 'r') as json_data_file:
    json_data = json_data_file.readlines()
json_data_file.closed
</code></pre>
<p>Using a list comprehension, we create a list of  <code>dicts</code>, one for each line in <code>json_data</code>:</p>
<pre><code>json_array = [json.loads(line) for line in json_data]
</code></pre>
<p>Finally, we run your greater-than less-than test for each <code>dict</code> in <code>json_array</code> and print each result:   for line in json_array:</p>
<pre><code>    if line['priority'] &lt; 20:
        print("Success!")
</code></pre>
<hr/>
<blockquote>
<p>Note that we could accomplish this by using a <code>for</code> loop instead of the list comprehension, with the same result:</p>
</blockquote>
<pre><code>json_array = []
for line in json_data:
    json_array.append(json.loads(line))
</code></pre>
<hr/>
<p>To learn more about the <code>json</code> module, read up on it here:</p>
<p><a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">https://docs.python.org/3/library/json.html</a></p>
<hr/>
<p>For easier copy/pasting, here's the uninterrupted code:</p>
<hr/>
<pre><code>import json

with open('./sample_json.json', 'r') as json_data_file:
    json_data = json_data_file.readlines()
json_data_file.closed

# Using list comprehension to populate json_array
json_array = [json.loads(line) for line in json_data]

# Using for loop to populate json_array
json_array = []
for line in json_data:
    json_array.append(json.loads(line))

for line in json_array:
    if line['priority'] &lt; 20:
        print("Success!")
</code></pre>
<hr/>
<p>Note that with the parsed JSON as a <code>dict</code>, you have access to any of the keys for each line of your JSON:</p>
<pre><code>for item in json_array:
    for key in item.keys():
        print("KEY:", key, "VALUE:", json_array[0][key])
    print()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using JSON load/parse etc, is definitely right way to do this, but in terms of solving this with regex</p>
<p>The brute force method, like so:</p>
<pre><code>"\"priority\":(1|2|3|4),"
</code></pre>
<p>should work just fine for smaller integers, and is probably pretty non-error-prone.</p>
</div>
<span class="comment-copy">Tried this? <code>[0-3][0-9]?</code></span>
<span class="comment-copy">with your implementation, could you simply have /"priority":(\d+)/ and then just throw out all matches where int(match_object.group(1)) &gt;= X  ?</span>
<span class="comment-copy">Regular expressions are a bad tool for this job. If <code>X</code> is a number with digits <code>Y</code> and <code>Z</code>, then the expression you are looking for is something like this <code>r"\d|[0-%d]\d|%d[0-%d]" % (Y-1,Y,Z)</code>.</span>
<span class="comment-copy">Regex is for matching string patterns it doesn't really understand numbers so much as the character that represents that number and then only between 0-9.</span>
<span class="comment-copy">Any reaon you do not want to <code>json.loads</code> the text and then use <code>filter</code> on the resultant data structure?</span>
<span class="comment-copy">Well, in this case, each line is a JSON, but the whole file cannot be read and parsed as a whole. Only lines can be parsed individually. Think of this as log files with JSON data as the raw data. But yes, it's better to parse each line as JSON, and then look at the data, than use regex, agreed</span>
<span class="comment-copy">Can you add a section of your file that shows the structure, before and after the JSON?</span>
<span class="comment-copy">Yeah will do, will update the OP</span>
<span class="comment-copy">Excellent. Thanks.</span>
<span class="comment-copy">It would be pretty easy to test both methods, but that would a good candidate for a different Question. As far as C implementations, there are several JSON libraries in that world, too. <a href="http://www.digip.org/jansson/" rel="nofollow noreferrer">digip.org/jansson</a>, <a href="https://bitbucket.org/yarosla/nxjson" rel="nofollow noreferrer">bitbucket.org/yarosla/nxjson</a> and <a href="https://github.com/DaveGamble/cJSON" rel="nofollow noreferrer">github.com/DaveGamble/cJSON</a>, for example.</span>
