<div class="post-text" itemprop="text">
<p>During an interactive session in IPython, when you get an error in MySQL (e.g. <code>IntegrityError: (1062, "Duplicate entry 'CM' for key 'PRIMARY'")</code>) , and then modify some code in your file and rerun <code>%run main.py</code>, you are going to be hung up since the last error still opens the connection in MySQL.</p>
<p>In order to successfully run the program again, you first terminate the program you just rerun via Ctrl+C, and then re-rerun the program again.</p>
<p>I find it pretty bothersome. Is it feasible to kill the connection just before running <code>%run main.py</code> again?</p>
<p>Example:</p>
<pre><code>con = pymysql.connect(user=user, passwd=passwd, host=host, db=dbname)
cur = con.cursor()

# The error happens on this line, and then it gets out of the program
# without closing the connection
cur.execute(query, (i["code"], i["name"]))

con.commit()
cur.close(); con.close()
</code></pre>
<hr/>
<h3>UPDATE</h3>
<p>Sorry for forgetting to note it, but if I close the connection in the code, isn't it that, if I understand it correctly, I cannot debug the error since the connection is gone now, right? That is definitely not what I want, so I asked "kill the connection <strong>just before running <code>%run main.py</code></strong> again"...</p>
</div>
<div class="post-text" itemprop="text">
<p>what about </p>
<pre><code>try:
    con = ...
    ...
finally:
    if con is not None:
       con.close()
</code></pre>
<p>a finally will always be executed, no matter what happens inside.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/contextlib.html#contextlib.closing" rel="nofollow noreferrer"><code>contextlib.closing</code></a> to close the connection automatically as soon as leave the indentation: </p>
<pre><code>from  contextlib import closing

with closing(pymysql.connect(user=user, passwd=passwd, host=host, db=dbname)) as con:
    cur = con.cursor()

    # The error happens on this line, and then it gets out of the program without closing the connection
    cur.execute(query, (i["code"], i["name"]))
    con.commit()
    cur.close()
</code></pre>
<p>This also closes it in the case of an exception.</p>
</div>
