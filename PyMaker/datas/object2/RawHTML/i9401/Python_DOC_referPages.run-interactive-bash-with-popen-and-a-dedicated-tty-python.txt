<div class="post-text" itemprop="text">
<p>I need to run an interactive Bash instance in a separated process in Python with it's own dedicated TTY (I can't use pexpect).
I used this code snippet I commonly see used in similar programs:</p>
<pre><code>master, slave = pty.openpty()

p = subprocess.Popen(["/bin/bash", "-i"], stdin=slave, stdout=slave, stderr=slave)

os.close(slave)

x = os.read(master, 1026)

print x

subprocess.Popen.kill(p)
os.close(master)
</code></pre>
<p>But when I run it I get the following output:</p>
<pre><code>$ ./pty_try.py
bash: cannot set terminal process group (10790): Inappropriate ioctl for device
bash: no job control in this shell
</code></pre>
<p>Strace of the run shows some errors:</p>
<pre><code>...
readlink("/usr/bin/python2.7", 0x7ffc8db02510, 4096) = -1 EINVAL (Invalid argument)
...
ioctl(3, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0x7ffc8db03590) = -1 ENOTTY (Inappropriate ioctl for device)
...
readlink("./pty_try.py", 0x7ffc8db00610, 4096) = -1 EINVAL (Invalid argument)
</code></pre>
<p>The code snippet seems pretty straightforward, is Bash not getting something it needs? what could be the problem here?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a solution to run an interactive command in subprocess. It uses pseudo-terminal to make stdout non-blocking(also some command needs a tty device, eg. bash). it uses select to handle input and ouput to the subprocess.</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import select
import termios
import tty
import pty
from subprocess import Popen

command = 'bash'
# command = 'docker run -it --rm centos /bin/bash'.split()

# save original tty setting then set it to raw mode
old_tty = termios.tcgetattr(sys.stdin)
tty.setraw(sys.stdin.fileno())

# open pseudo-terminal to interact with subprocess
master_fd, slave_fd = pty.openpty()

# use os.setsid() make it run in a new process group, or bash job control will not be enabled
p = Popen(command,
          preexec_fn=os.setsid,
          stdin=slave_fd,
          stdout=slave_fd,
          stderr=slave_fd,
          universal_newlines=True)

while p.poll() is None:
    r, w, e = select.select([sys.stdin, master_fd], [], [])
    if sys.stdin in r:
        d = os.read(sys.stdin.fileno(), 10240)
        os.write(master_fd, d)
    elif master_fd in r:
        o = os.read(master_fd, 10240)
        if o:
            os.write(sys.stdout.fileno(), o)

# restore tty settings back
termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_tty)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the solution that worked for me at the end (as suggested by qarma) :</p>
<pre><code>libc = ctypes.CDLL('libc.so.6')

master, slave = pty.openpty()
p = subprocess.Popen(["/bin/bash", "-i"], preexec_fn=libc.setsid, stdin=slave, stdout=slave, stderr=slave)
os.close(slave)

... do stuff here ...

x = os.read(master, 1026)
print x
</code></pre>
</div>
<span class="comment-copy">That's quite normal — you got an <b>interactive shell</b> without <b>job control</b>.</span>
<span class="comment-copy">If you want job control too, you need your shell to become a process leader — that is start new "session", it's achieved with <code>start_new_session=True</code> keyword argument to <code>Popen</code> (since Python 3.2). If you need more control, use <code>preexec_fn=...</code></span>
<span class="comment-copy">Ok, that sound reasonable. I understand that the <code>start_new_session=True</code> is only relevant to &gt;3.2. Is there an equivalent in 2.7? Sorry, probably should have mentioned the python version in the question.</span>
<span class="comment-copy">You can do that by hand by calling <code>setsid()</code> in <code>preexec_fn</code> via <code>ctypes</code></span>
<span class="comment-copy">I think this question is about same fundamentals as <a href="http://stackoverflow.com/questions/23826695/handling-keyboard-interrupt-when-using-subproccess/23839524#23839524" title="handling keyboard interrupt when using subproccess">stackoverflow.com/questions/23826695/…</a> <a href="http://stackoverflow.com/questions/33119213/run-program-in-another-process-and-receive-pid-in-python/33120039#33120039" title="run program in another process and receive pid in python">stackoverflow.com/questions/33119213/…</a> <a href="http://stackoverflow.com/questions/37737649/how-to-destroy-an-exe-filenot-converted-from-py-by-run-as-the-same-script/37776347#37776347" title="how to destroy an exe filenot converted from py by run as the same script">stackoverflow.com/questions/37737649/…</a> <a href="http://stackoverflow.com/questions/13243807/popen-waiting-for-child-process-even-when-the-immediate-child-has-terminated/13256908#13256908" title="popen waiting for child process even when the immediate child has terminated">stackoverflow.com/questions/13243807/…</a> it could be considered a duplicate.</span>
<span class="comment-copy">From docs, <code>pty.spawn</code> seem to do similar stuff but simpler interface. <a href="https://docs.python.org/3/library/pty.html#example" rel="nofollow noreferrer">docs.python.org/3/library/pty.html#example</a> Are they doing the same?</span>
<span class="comment-copy">@balki <code>pty.spawn</code> looks good to do similar jobs.</span>
<span class="comment-copy">I doubt you need <code>-i</code> any more with all the other things, bash should detect it's environment.</span>
