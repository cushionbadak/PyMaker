<div class="post-text" itemprop="text">
<p>Let's say we have an arbitrary object of an unknown type and we want to access an equally arbitrary attribute associated with this object, queried as a string name. I am looking for a best-practice approach for obtaining this value.</p>
<p>In pseudo-code/Python, the current strategy I am considering is along these lines:</p>
<pre><code>def access_attribute(obj, attr):
    if type(obj) == types.FunctionType:
        return access_attribute(obj(), attr)
    elif type(obj) == types.DictType:
        return obj.get(attr)
    # ... etc.
</code></pre>
<p>A couple items to consider:</p>
<ul>
<li>What happens if the attribute does not exist on the object? I am okay raising an exception.</li>
<li>The attribute may be deeply nested.</li>
</ul>
<p>I figure this is the kind of problem that must be solved by programming languages and DSL interpreters, but I don't know of a standard/commonly accepted best practice.</p>
<p>The idea of passing custom stored DSL/code to <code>eval</code> at runtime along with the object has been broached, but I want to avoid this particular solution for now and prefer a Pythonic one.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3.5/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr(object, name[, default])</code></a> seems to answer at least the first half of your question and this point: </p>
<blockquote>
<p>What happens if the attribute does not exist on the object? I am okay raising an exception.</p>
</blockquote>
<p>I'd argue that this is a best practice since it's part of the standard library.</p>
<p>Regarding your second point:</p>
<blockquote>
<p>The attribute may be deeply nested.</p>
</blockquote>
<p>A solution would be to use <a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow noreferrer"><code>dir(object)</code></a> (which will list all the attributes of an object) and loop over those for non-dict objects, but i'm less confident about the 'best-practice' aspect of this solution.</p>
</div>
<span class="comment-copy">I too am interested in an answer to this question. I've run into multiple cases where having the ability to access attributes via configuration would be beneficial, but have run into difficulty with the many types in complex Object hierarchies...</span>
<span class="comment-copy">Not sure if there is a best practice. As far as existing approaches go, I have worked with the <code>Accessor</code> class in django-tables2 (<a href="https://github.com/bradleyayers/django-tables2/blob/master/django_tables2/utils.py" rel="nofollow noreferrer">code</a>) which does a pretty generic and nested attribute lookup by name (attributes, dict-keys, list-indexes, 0-arg methods, etc.).</span>
<span class="comment-copy">@schwobaseggl thanks for the reference to django-tables2. The Accessor code is definitely along similar lines. There may very well be ideas there to borrow and reflect upon.</span>
<span class="comment-copy">What's you mean by <i>The attribute may be deeply nested</i> exactly?</span>
<span class="comment-copy">You should also mention how you want the client to interact, i.e. the API.  I second the django-tables2 too (had looked at it).  But it, like Template substitution code with nested look ups, expects the path to be a string.  Ditto <code>operator.attrgetter</code>.  Also, if it's nested, can you switch higher levels from attributes to dicts?  <code>foo.a[b].c</code>?</span>
<span class="comment-copy">I think this directly ignores the question regarding the different types of access that would be used and how to best determine how to traverse the object structure.</span>
