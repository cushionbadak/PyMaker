<div class="post-text" itemprop="text">
<p>I'd like to have implement an <code>update</code> method in my class that recreates the class but changes just one constructor argument.</p>
<p>My attempt:</p>
<pre><code>class Updateable:
    def update(self, var, var_str, **kwargs):
        kwargs.update(self._vars)
        kwargs[var_str] = var
        self.__init__(**kwargs)

class Rectangle(Updateable):
    def __init__(self, length, perimeter):
        self._vars = locals()
        self.length = length
        self.width = 0.5*(perimeter - 2.*length)      

r = Rectangle(10, 20)
r.update('perimeter', 16)
</code></pre>
<p>The problem is, the whole <code>locals()</code> thing, I think, is pretty dodgy, and it means that any class that is <code>Updateable</code> needs to assign <code>self._vars</code>.</p>
<p>What would be the correct way to achieve this functionality?  Decorators, metaclasses?  Something simpler?</p>
</div>
<div class="post-text" itemprop="text">
<p>Please correct me if I misunderstood your question, or if you don't want high level advise and your just question solved.</p>
<p>What your <code>__init__</code> currently does is recalculate the properties of a geometric shape if a (possibly relevant) variable is changed. Step 1 is to take this out of the <code>__init__</code>, and into a seperate <code>def</code> which is called by init. The main thing here is that you do not pass variables to this function, but use the class variables which have been set in either <code>__init__</code> or one the superclass updating methods.</p>
<p>Step 2 is to change your update function.
Python has a form of getters and setters called <a href="http://www.python-course.eu/python3_properties.php" rel="nofollow noreferrer">properties</a> allowing you to hook tasks to updating your variables. On the other hand a more generalized way is more similar to your own update, and is listed as option 2 below</p>
<h1>Example alternative</h1>
<pre><code>class Updateable:
    # Option 1
    @property
    def perimeter(self):
        return self.__perimeter

    @perimeter.setter
    def perimeter(self, perimeter):
        self.__perimeter = perimeter
        self.recalculate_everything() # or self.calculate_width() or something

    # Option 2
    def update(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)
        self.recalculate_everything

class Rectable(Updateable):
    def __init__(self, length, perimeter):
        self.__length = length
        self.__perimeter = perimeter
        recalculate_everything()

    def recalculate_everything():
        self.calculate_width()
        ...     

    def calculate_width():
        self.__width = 0.5*(self.__perimeter - 2.*self.__length)     
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Laurens Koppenol suggested using <code>properties</code> (Python's generic support for computed attribute) which is a good idea but his example code is both broken in many ways and more complicated than it has to be, so here's a simpler, working and pythonic example (no <code>Updatable</code> class nor any other extraneous stuff required):</p>
<pre><code>class Rectangle(object):
    def __init__(self, length, perimeter):
        self.length = length
        self.perimeter = perimeter

    @property
    def width(self):
        return 0.5*(self.perimeter - 2.*self.length)     
</code></pre>
<p>If you want to cache the <code>width</code> value (to avoid useless computations) but still make sure it's updated when <code>length</code> or <code>perimeter</code> change, you'll need to make them all properties:</p>
<pre><code>class Rectangle(object):
    def __init__(self, length, perimeter):
        self.length = length
        self.perimeter = perimeter

    @property
    def length(self):
        return self._length

    @length.setter
    def length(self, value):
        self._length = value
        self._width = None


    @property
    def perimeter(self):
        return self._perimeter

    @length.setter
    def perimiter(self, value):
        self._perimeter = value
        self._width = None

    @property
    def width(self):
        if self._width is None:
            self._width = 0.5*(self.perimeter - 2.*self.length)     
        return self._width
</code></pre>
<p>or (if you have a lot of such stuff) use some "cached_property with invalidation" implementation as this one: <a href="https://stackoverflow.com/questions/41228551/storing-calculated-values-in-an-object/41230310#41230310">Storing calculated values in an object</a></p>
<p>edit: wrt/ your question, the call to <code>locals</code> is indeed ugly (and can easily break - you may have local variables that are not supposed to be parts of <code>_vars</code>), as well as the need to explicitely set <code>self._vars</code> in child classes. Also the <code>update()</code> API is itself quite ugly IMHO. Now you don't need anything fancy to make the whole thing more pythonic - here's a solution whose only boilerplate is the need to call <code>Updateable.__init__</code> with named arguments (won't work with positional ones):</p>
<pre><code>class Updateable(object):
    def __init__(self, **kwargs):
        self._vars = kwargs

    def update(self, **kwargs):
        vars = self._vars.copy()
        vars.update(**kwargs)
        self.__init__(**vars)


class Rectangle(Updateable):
    def __init__(self, length, perimeter):
        super(Rectangle, self).__init__(length=length, perimeter=perimeter)
        self.length = length
        self.width = 0.5*(perimeter - 2.*length)

r = Rectangle(10, 20)
r.update(perimeter=40)
</code></pre>
<p>As a side note, I personnaly find quite disturbing that your <code>Rectangle</code> class takes a <code>perimeter</code> argument but stores a <code>width</code> instead... Maybe you should consider a <code>perimeter</code> property ? (even if read-only to avoid recomputing etc)</p>
</div>
<div class="post-text" itemprop="text">
<p>As others have observed, computations like <code>width</code> should be moved to a property or method; they don't belong in an initialiser.</p>
<p>If you really want to return a new instance, this would work for the simplest cases, where the instance's attributes are immutable objects like strings or integers:</p>
<pre><code>import copy

class Copyable:

    """Mixin to create copies with a changed attribute."""

    def copy_and_modify(self, var, var_str, **kwargs):
        new = copy.copy(self)
        setattr(new, var, var_str)
        return new

class Rectangle(Copyable):

    def __init__(self, length, perimeter):
        self.perimeter = perimeter
        self.length = length

    @property
    def width(self):
        return 0.5 * (self.perimeter - 2.0 * self.length)
</code></pre>
<p>however if your objects contain nested mutable structures such as dictionaries or lists you would need to change <code>copy_and_modify</code> to use <code>copy.deepcopy</code> (but note deep copying is slow)</p>
<pre><code>class Copyable:

    def copy_and_modify(self, var, var_str, **kwargs):
        new = copy.deepcopy(self)
        setattr(new, var, var_str)
        return new
</code></pre>
<p>You can define <code>__copy__</code> and <code>__deepcopy__</code> methods in your subclasses <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">as described in the docs</a> to fine-tune control over the copying process.</p>
</div>
<span class="comment-copy">Calling <code>__init__</code> after the object already exists seems a bit strange.  Why not just have a <code>recalculate_width</code> method or something?</span>
<span class="comment-copy">Because I want it to work for other classes I have, which all have different argument names.  Sometimes it's <code>width</code>, sometimes it's <code>angle</code>, sometimes it's <code>wavelength</code>, could be anything.</span>
<span class="comment-copy">1/ Don't use double underscores for implementation attributes - this triggers a name mangling function that will break inheritance. Only use a single leading underscore. 2/ if you use inheritance, then call the superclass initializer. 3/ In Python 2.x, properties won't properly work with old-style classes. 4/ Your "Updatable" class should either define "recalculate_everything()" with a default implementation or be an abstract base class (cf the stlib's ABC module). 5/ you have a NameError in <code>Rectangle.__init__</code> (...)</span>
<span class="comment-copy">And 6. manually setting the implementation attributes in the initializer instead of using the propery setters kind of defeat the whole point of having a property.</span>
<span class="comment-copy">Oh and yes too: the point of <code>Updatable</code> was to be generic - it should know nothing about specific implementation attributes.</span>
<span class="comment-copy">Thanks for your constructive criticism</span>
<span class="comment-copy">In your second example, did you mean to assign to <code>self._length/_perimeter</code> in the initialisation method?</span>
<span class="comment-copy">So the thing is, I want to apply the updating to many classes, all which have different parameters, and I wanted to avoid having to write every single parameter as a <code>propery</code>.  This is why I tried to make a generic class that could do this.  Not sure if this is possible.</span>
<span class="comment-copy">@snakecharmerb  no, I meant what I wrote : assigning to <code>self.length</code> and <code>self.perimeter</code>.  Why would I bypass my properties setters and break the <code>width</code> getter code ?</span>
<span class="comment-copy">Ah my bad, I'm too used to read-only properties</span>
<span class="comment-copy">@Jean-Luc yes sorry - cf my edited answer that do address your question. But I can't garantee it will never break anything....</span>
<span class="comment-copy">If it creates a new instance, the method should not be named <code>update()</code>.</span>
<span class="comment-copy">@brunodesthuilliers  I was adhering to the OP's original convention, but you are correct.  The OP was re-initialising the existing instance rather creating a new one.  I'll fix the name later today.  <code>create_modified_copy</code> perhaps?  Also, I will rename the mixin to something that corresponds to more closely to it's purpose.</span>
