<div class="post-text" itemprop="text">
<p>I'm often in the need of temporarily switching the value of a variable out with something else, do some computation which depends on this variable, and then restore the variable to its original value. E.g:</p>
<pre><code>var = 0
# Assign temporary value and do computation
var_ori = var
var = 1
do_something_with_var()  # Function that reads the module level var variable
# Reassign original value
var = var_ori
</code></pre>
<p>This seems like an obvious opportunity for using a context manager (the <code>with</code> statement). Does the Python standard library contain any such context manager?</p>
<h3>Edit</h3>
<p>I am aware that this sort of thing is most often handled by other, better means than temporarily changing a variable. I am however not asking for obvious workarounds.</p>
<p>In my actual work case, I can not alter the <code>do_something_with_var</code> function. Actually this is not even a function, but a string of code which gets evaluated in the context of the global namespace as part of some metaprogramming. The example I gave was the simplest I could think of that kept my problem with the temporary variable. I did not ask to get a workaround (proper version) of my example code, but rather to get an answer on my written question.</p>
</div>
<div class="post-text" itemprop="text">
<p>Nope, because a context manager can't assign variables in the caller's scope like that. (Anyone who thinks you could do it with <code>locals</code> or <code>inspect</code>, try using the context manager you come up with inside a function. It won't work.)</p>
<p>There <em>are</em> utilities for doing that with things that aren't local variables, such as module globals, other object attributes, and dicts... but they're <a href="https://docs.python.org/3/library/unittest.mock.html#the-patchers" rel="nofollow noreferrer"><code>unittest.mock.patch</code></a> and its related functions, so you should strongly consider other alternatives before using them in a non-testing context. Operations like "temporarily modify this thing and then restore it" tend to lead to confusing code, and may indicate you're using too much global state.</p>
</div>
<div class="post-text" itemprop="text">
<p>The simple answer to your question:</p>
<blockquote>
<p>Does the Python standard library contain any such context manager?</p>
</blockquote>
<p>is "No, it does not."</p>
</div>
<div class="post-text" itemprop="text">
<p>My mistake, instead perhaps something like this, it is not built-in:</p>
<pre><code>class ContextTester(object):
    """Initialize context environment and replace variables when completed"""

    def __init__(self, locals_reference):
        self.prev_local_variables = locals_reference.copy()
        self.locals_reference = locals_reference

    def __enter__(self):
        pass

    def __exit__(self, exception_type, exception_value, traceback):
        self.locals_reference.update(self.prev_local_variables)



a = 5
def do_some_work():
    global a
    print(a)
    a = 8
print("Before context tester: {}".format(a))
with ContextTester(locals()) as context:
    print("In context tester before assignment: {}".format(a))
    a = 6
    do_some_work()
    print("In context tester after assignment: {}".format(a))
print("After context tester: {}".format(a))
</code></pre>
<p>Output:</p>
<pre><code>Before context tester: 5
In context tester before assignment: 5
6
In context tester after assignment: 8
After context tester: 5
</code></pre>
<p>For clarity, so you know it's actually doing something:</p>
<pre><code>class ContextTester(object):
    """Initialize context environment and replace variables when completed"""

    def __init__(self, locals_reference):
        self.prev_local_variables = locals_reference.copy()
        self.locals_reference = locals_reference

    def __enter__(self):
        pass

    def __exit__(self, exception_type, exception_value, traceback):
        #self.locals_reference.update(self.prev_local_variables)
        pass

a = 5
def do_some_work():
    global a
    print(a)
    a = 8
print("Before context tester: {}".format(a))
with ContextTester(locals()) as context:
    print("In context tester before assignment: {}".format(a))
    a = 6
    do_some_work()
    print("In context tester after assignment: {}".format(a))
print("After context tester: {}".format(a))
a = 5
print("Before context tester: {}".format(a))
with ContextTester(locals()) as context:
    print("In context tester before assignment: {}".format(a))
    a = 6
    print("In context tester after assignment: {}".format(a))
print("After context tester: {}".format(a))
</code></pre>
<p>Output:</p>
<pre><code>Before context tester: 5
In context tester before assignment: 5
6
In context tester after assignment: 8
After context tester: 8

Before context tester: 5
In context tester before assignment: 5
In context tester after assignment: 6
After context tester: 6
</code></pre>
<p>You could also do this:</p>
<pre><code>def wrapper_function(func, *args, **kwargs):
    prev_globals = globals().copy()
    func(*args, **kwargs)
    globals().update(prev_globals)
</code></pre>
<p>It should be noted that if you try to use the with statement within a function, you'll want to use globals() as the reference to locals and it may have unintended consequences, might still anyways.</p>
<p>I wouldn't recommend doing this at all, but should work.</p>
</div>
<span class="comment-copy">I chose not to vote on the question, but I'd argue that if you often need such a construct there are bigger design issues to be addressed.</span>
<span class="comment-copy">Previously answered: <a href="http://stackoverflow.com/questions/3024925/python-create-a-with-block-on-several-context-managers?rq=1" title="python create a with block on several context managers">stackoverflow.com/questions/3024925/â€¦</a></span>
<span class="comment-copy">@BillSchumacher: Uh, what? How is that question relevant?</span>
<span class="comment-copy">I did think that something like <code>inspect</code> would be needed if I were to write the context manager myself, which is too ugly for me to bother. But why should this not even be possible? Does <code>with</code> somehow hide the function stacks?</span>
<span class="comment-copy">@jmd_dk: No, it's just that Python doesn't provide access to the data structures that hold function-local variables.</span>
<span class="comment-copy">@jmd_dk - It's not possible because it's not remotely necessary. Functions work with global values in a way that doesn't affect those values by accepting them as parameters (and making a copy within the function, if necessary).</span>
<span class="comment-copy">I'm pretty sure we all know he wants a work-able solution as well ;-)</span>
<span class="comment-copy">@leaf: I think it's fair to say that we also know that the question is pretty misguided, so giving workable solutions isn't necessarily constructive. ;-)</span>
<span class="comment-copy">@NPE I'm so tired of that attitude. Half of the question (the edit) is taken up by a pointless confirmation that I really do want an actual answer, rather than being dismissed. I had a technical question and expected a technical answer.</span>
<span class="comment-copy">Thanks, but it appears that you still manually set <code>a = 5</code> back again once the work is done. Also, <code>do_some_work</code> should only read the global <code>a</code>, not reassign it.</span>
<span class="comment-copy">The bottom example was meant to show normal python operation without resetting the variables at all.</span>
