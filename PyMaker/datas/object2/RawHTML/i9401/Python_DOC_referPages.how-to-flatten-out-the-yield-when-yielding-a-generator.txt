<div class="post-text" itemprop="text">
<p>I have this function <code>g()</code> my goal is to yield a result similar to <code>product()</code> but with constrained number of appearance for each group of characters. So in the code below instead of doing <code>product(a, repeat=3)</code> <code>g()</code> is supposed to yield all the combinations where characters from <code>a</code> appear 2 times and characters from <code>b</code> appear 1 time. Here is what I have :</p>
<pre><code>from itertools import permutations, product

a='ABC'
b=['*', '%3A']
l=[a]*2+[b]

def g(list):
    for p in permutations(list):
        yield product(*p)


result=g(l)
</code></pre>
<p>So the problem I'm facing is that when I <code>yield</code> the result I got a nested iterator that is painful to use and when I use return it just returns the generator corresponding to only the first loop turn, just as if I did : <code>g()</code> only consisted of <code>def g(): return product(*next(permutations(list)))</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you are python 3.3 or later you can use <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator" rel="nofollow noreferrer">PEP 380: Syntax for Delegating to a Subgenerator</a> ... just do <code>yield from</code></p>
<pre><code>from itertools import permutations, product

a='ABC'
b=['*', '%3A']
l=[a]*2+[b]

def g(list):
    for p in permutations(list):
        yield from product(*p)


result=g(l)
</code></pre>
</div>
<span class="comment-copy">Think about what you would do if you weren't writing a <code>g</code> generator, and you just wanted to call <code>some_function(x)</code> on every combination. Write that code, and then replace <code>some_function</code> with <code>yield</code>.</span>
<span class="comment-copy">What version of python are you targeting (wondering if <code>yield from</code> could be used here)?</span>
<span class="comment-copy">@snakecharmerb python 3, oh yes you're right there is <code>yield from</code> I totally forgot, I solved the problem using <code>c=chain(c,product(*p))</code> and returning c at the end, had the idea just after posting that.</span>
<span class="comment-copy">I noticed that if I do <code>result=sorted(map(list, g(l)))</code> that <code>all(result[i] == result[i+1] for i in range(0, 6, 2))</code> is <code>True</code>.  In other words, it seems you get two identical sets of results.  Do you want that?</span>
<span class="comment-copy">Or use <code>from sympy.utilities.iterables import multiset_permutations</code> which may be more efficient.</span>
<span class="comment-copy">I forgot about yield from thanks for the tip this is useful</span>
