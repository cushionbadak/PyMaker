<div class="post-text" itemprop="text">
<p>Have a class Run that has a "has many" relationship to a class Tag.
I need to be able to filter runs based on a function of the tags (tag_collection).</p>
<p>Below is a snippet of my code.  In this case I am using the automapper, but I don't think that matters too much.</p>
<pre><code>Base = automap_base()

class Run(Base):
    __tablename__ = 'runs'
    macro_id = Column(ForeignKey('macros.id'))  

    @hybrid_property
    def tag_count(self):
        return(len(self.tag_collection))

    @hybrid_property
    def default_region(self):
        return(reduce(lambda  memo, t: memo or t.name == "region" and t.value == "default", self.tag_collection, False))

    @default_region.expression
    def default_region(cls):
        # how do I do the query here?

class Tag(Base):
    __tablename__ = 'tags'
    run_id = Column(ForeignKey('runs.id'))    
</code></pre>
<p>If I get an instance of a Run,  I can make use of the <code>default_region</code> property, but when I run a query, and try to filter using the <code>default_region</code> property, I either get the Run class passed in (as self) in the <code>@hybird_property</code> decorated <code>default_region</code> method or I end up in the <code>@default_region.expression</code> decorated <code>default_region</code> method,  which also receives the Run class.</p>
<p>Example query:</p>
<pre><code>session.query(Run).filter(Run.default_region == True).all()
</code></pre>
<p>I think I need to do a query in the <code>@default_region.expression</code> decorated <code>default_region</code> method, but I don't see how to get a handle on the session.  I know about <code>Session.object_session(someobject)</code>,  but I think <code>someobject</code> needs to be an instance of the orm class not the class itself.</p>
<p>I think I am either completely wrong about my methodology of the filtering, or I need to somehow get a handle to the session object in that <code>@default_region.expression</code> decorated <code>default_region</code> method.</p>
<p>Is there a better way to accomplish this filtering?</p>
<p>How do a get the session in the<code>@default_region.expression</code> decorated <code>default_region</code> method?</p>
</div>
<div class="post-text" itemprop="text">
<p>This looks to me to be a <a href="http://docs.sqlalchemy.org/en/latest/orm/extensions/hybrid.html#correlated-subquery-relationship-hybrid" rel="nofollow noreferrer"><em>Correlated Subquery Relationship Hybrid</em></a>. When <code>Run.default_region</code> is added as a filter, you want to update the query to add</p>
<pre><code>WHERE EXISTS (
    SELECT 1 FROM tags
    WHERE run_id = runs.id
      AND name = "region"
      AND value = "default")
</code></pre>
<p>Return that as an expression, with the <a href="http://docs.sqlalchemy.org/en/latest/core/selectable.html#sqlalchemy.sql.expression.exists" rel="nofollow noreferrer"><code>exists()</code> function</a>:</p>
<pre><code>from sqlalchemy.sql import exists, and_

@default_region.expression
def default_region(cls):
    return exists([1]).where(and_(
        Tag.run_id == cls.id,
        Tag.name == 'region',
        Tag.value == 'default'))
</code></pre>
<p>Note that you want to <em>avoid</em> using <code>== True</code> or <code>== False</code> here, there is no need! Just use the property directly:</p>
<pre><code>session.query(Run).filter(Run.default_region).all()
</code></pre>
<p>or use <code>~</code> to negate:</p>
<pre><code>session.query(Run).filter(~Run.default_region).all()
</code></pre>
<p>By defining the <a href="http://docs.sqlalchemy.org/en/latest/orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.expression" rel="nofollow noreferrer"><code>.expression</code> method</a> for the property, you have told SQLAlchemy to use that method when accessing the property on the class, so the context is <em>always the class</em> there. Without defining <code>.exists</code> (or a <a href="http://docs.sqlalchemy.org/en/latest/orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property.comparator" rel="nofollow noreferrer"><code>.comparator</code></a>), <code>Run.default_region</code> would call the <code>default_region</code> getter (the method decorated with `@hybrid_property) as a class method, so only then would that method have to then work with either an instance <em>or</em> a class being passed in. For some hybrid property implementations, that happens to work by virtue of how they use attributes on the context.</p>
<p>As for the implementation of the <code>default_region</code> <em>instance</em> property, I'd not use <code>reduce()</code> there; use the <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any()</code> function</a>:</p>
<pre><code>@hybrid_property
def default_region(self):
    return any(
        t.name == "region" and t.value == "default"
        for t in self.tag_collection)
</code></pre>
<p><code>any()</code> stops iterating over the supplied generator expression when a match has been found.</p>
</div>
<span class="comment-copy">So <code>default_region</code> is true when there is a row in <code>tags</code> with the right <code>runs.id</code> foreign key, and <code>name</code> set to <code>region</code> and <code>value</code> set to <code>default</code>?</span>
<span class="comment-copy">yes,  I probably will have other "connivence" methods like this as well.</span>
<span class="comment-copy">This seems to work fine.  I figured I did not need the == True (I added it at some point trying to debug things),  and yes I had not seen any(), seems like the way to go.   I think part of my problem with this, is it's not clear to me that <i>context</i> of the @default_region.expression decorated default_region method is. If possible, could you add that to your answer?</span>
<span class="comment-copy">@nPn: the <code>@default_region.expression</code> is always passed the class. It is only used when you use <code>Run.default_region</code>, so accessing the name of the property <i>on the class</i>, a use that only applies to building expressions (such as in <code>.filter(Run.default_region)</code> and <code>.filter(~Run.default_region)</code>. If you <i>don't</i> define the <code>.expression</code> method, then SQLAlchemy would fall back to the <code>@hybrid_property</code>-decorated method, at which point the class is passed in instead of the instance.</span>
<span class="comment-copy">@nPn: put differently: by using <code>.expression</code> you made it possible to separate the instance and class context cases.</span>
<span class="comment-copy">Right, I got that part (separating instance and class) .  If I have this right,  the .expression decorated method requires you to return and sql expression that will be executed later as part of the overall query,  while the @hybrid_property decorated expression simply runs in the context of the object.  I was trying to force the .expression to do the actual query and return values, rather than simply return the expression.</span>
<span class="comment-copy">@nPn: exactly; you return an expression that can be a part of a larger query expression. See it as a hook to provide the expression for the  <code>Class.hybrid_property_name</code> <i>placeholder</i> in any SQLAlchemy ORM expression.</span>
