<div class="post-text" itemprop="text">
<p>I'd like to combine multiple arrays in a matrix to achieve an all 0 array </p>
<pre><code>(0,0,0,0,0)
</code></pre>
<p>For example:</p>
<p>I have this matrix where array[0] is the index of each array:</p>
<pre><code>[0,(0,1,0,1,0)]
[1,(0,1,0,0,0)]
[2,(0,0,1,1,0)]
[3,(0,0,1,0,0)]
[4,(0,0,1,0,0)]
</code></pre>
<p>If I xor arrays 3 and 4 I got an all zeros arrays or I could xor arrays 0,1,2 and 4. </p>
<p>I don't know if it exists any library in python to calculate these things o something like that. I've been looking for it days.</p>
<p>Any ideas how to do it?</p>
<p>I have tried numpy library and tried to do xor method</p>
<pre><code>for i in range(len(MODS)):
        num = []
        for j in range(len(MODS[i][1])):
            if i+1 &lt; len(MODS):
                if xor(MODS[i][1][j],MODS[i+1][1][j]) == 0:
                    num.append(0)
                    continue
                else:
                    break
            else:
                break
</code></pre>
<p>The problem is that this method only compares pairs of arrays. </p>
<p>I'm looking for any combinations of arrays which do the trick.</p>
</div>
<div class="post-text" itemprop="text">
<p>This finds all combinations of rows with <code>xor</code> value resulting in a zero (<code>False</code>). </p>
<p>For finding all combinations of rows, use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a>.</p>
<pre><code>import numpy as np
from itertools import combinations

A = np.array([[0,1,0,1,0],
              [0,1,0,0,0],
              [0,0,1,1,0],
              [0,0,1,0,0],
              [0,0,1,0,0]])

print('All combinations of rows with xor resulting in zero: ')

for i in range(1, len(A)+1):
    for x in combinations(A, i):
        if not np.logical_xor.reduce(x).any():
            print(x)

# All combinations of rows with xor resulting in zero:
# (array([0, 0, 1, 0, 0]), array([0, 0, 1, 0, 0]))             
# (array([0, 1, 0, 1, 0]), array([0, 1, 0, 0, 0]), array([0, 0, 1, 1, 0]), array([0, 0, 1, 0, 0]))                        
# (array([0, 1, 0, 1, 0]), array([0, 1, 0, 0, 0]), array([0, 0, 1, 1, 0]), array([0, 0, 1, 0, 0]))
</code></pre>
</div>
<span class="comment-copy">take a look at <a href="http://www.numpy.org/" rel="nofollow noreferrer"><code>numpy</code></a></span>
<span class="comment-copy">Show the work you have done so far! not how to do something...</span>
<span class="comment-copy">"to calculate these things o something like that" - what exactly are you trying to do? It would be helpful if you showed the desired output for your example.</span>
<span class="comment-copy">Also, as already mentioned, if you have some code that you tried, but it didn't work, you can include it in your post and describe why it doesn't do what you want. Then someone might be able to help you.</span>
<span class="comment-copy">Are you looking for all combinations of arrays which do the trick? Or any combination? Or the shortest one? How many arrays are we talking?</span>
<span class="comment-copy">Start the range at 1 and then you don't need <code>if x</code>. Consider <code>np.logical_xor.reduce(x).any()</code> instead of <code>any(...)</code> (I personally think it reads nicer, might also be faster). Ideally duplicate arrays in the input should be removed first to make this faster and avoid duplicates in the output (as there are now), although if OP needs the indices of the arrays that will make things harder.</span>
<span class="comment-copy">@AlexHall thanks for your point; will update accordingly.</span>
<span class="comment-copy">@Austin thank you so much, but I also need the indices of the arrays to operate with the original ones later. However this is far more thank I had, thank you again</span>
<span class="comment-copy">@Austin thanks to your code I could modify it a little bit to get what I wanted. Thanks! (:</span>
