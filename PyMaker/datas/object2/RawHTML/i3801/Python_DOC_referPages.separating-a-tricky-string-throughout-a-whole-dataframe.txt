<div class="post-text" itemprop="text">
<pre><code>0    NC_000001.10:g.955563G&gt;C
1    NC_000001.10:g.955597G&gt;T
2    NC_000001.10:g.955619G&gt;C
3    NC_000001.10:g.957640C&gt;T
4    NC_000001.10:g.976059C&gt;T
5    NC_000003.11:g.37090470C&gt;T
6    NC_000012.11:g.133256600G&gt;A
7    NC_012920.1:m.15923A&gt;G
</code></pre>
<p>I have a column in a dataset that looks like the above. Using the first row as an example, the information I'd like to be left with is one column containing 955563, and one column containing G&gt;C. I've played around with a couple of regular expressions I've found here but haven't found one that does the trick.</p>
</div>
<div class="post-text" itemprop="text">
<p>The following works for your example:</p>
<pre><code>df[0].str.extract(':\w\.(\d+)(.+)')
#           0    1
#0     955563  G&gt;C
#1     955597  G&gt;T
#2     955619  G&gt;C
#3     957640  C&gt;T
#4     976059  C&gt;T
#5   37090470  C&gt;T
#6  133256600  G&gt;A
#7      15923  A&gt;G
</code></pre>
<p>If the last "column" always has the A&gt;A structure, where A is a single letter, then you can be more specific with:</p>
<pre><code>df[0].str.extract(':\w\.(\d+)(\w&gt;\w)')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>':.*\.(\d+)(\w&gt;\w)'
</code></pre>
<p><code>:.*\.</code> looks for <code>:</code> and any character (since your example has both 'g' and 'm') up to the period before the area we want to capture.</p>
<p>First Group: <code>(\d+)</code> matches 1 or more digits.</p>
<p>Second Group: <code>(\w&gt;\w)</code> matches word character followed by <code>&gt;</code> followed by word character</p>
</div>
<div class="post-text" itemprop="text">
<p>This is one way without regex. Note this solution uses <a href="https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals" rel="nofollow noreferrer">formatted string literals</a> from Python 3.6 (<a href="https://www.python.org/dev/peps/pep-0498/" rel="nofollow noreferrer">PEP 498</a>).</p>
<pre><code>def splitter(x):
    y = x.rsplit('.', maxsplit=1)[-1].split('&gt;')
    return int(y[0][:-1]), f'{y[0][-1]}&gt;{y[1]}'

df[['2', '3']] = df[1].apply(splitter).apply(pd.Series)

print(df)

   0                            1          2    3
0  0     NC_000001.10:g.955563G&gt;C     955563  G&gt;C
1  1     NC_000001.10:g.955597G&gt;T     955597  G&gt;T
2  2     NC_000001.10:g.955619G&gt;C     955619  G&gt;C
3  3     NC_000001.10:g.957640C&gt;T     957640  C&gt;T
4  4     NC_000001.10:g.976059C&gt;T     976059  C&gt;T
5  5   NC_000003.11:g.37090470C&gt;T   37090470  C&gt;T
6  6  NC_000012.11:g.133256600G&gt;A  133256600  G&gt;A
7  7       NC_012920.1:m.15923A&gt;G      15923  A&gt;G
</code></pre>
</div>
<span class="comment-copy">Are they always in that format? i.e. no longer or no shorter in any section of the string? If so, you don't need regex, you can just use <a href="https://pandas.pydata.org/pandas-docs/version/0.21/generated/pandas.Series.str.slice.html" rel="nofollow noreferrer"><code>str.slice()</code></a></span>
<span class="comment-copy">Unfortunately they do vary in length.</span>
<span class="comment-copy">Please add a line of a different length to your example. Which component varies in length?</span>
<span class="comment-copy">I added a couple of ways in which they can vary in lines 6/7</span>
<span class="comment-copy">Alternatively it could even be worth anchoring the extract to the end of the string: <code>df[1].str.extract('(\d+)(\w&gt;\w)$', expand=True)</code></span>
<span class="comment-copy">@JonClements Sure. Having a <code>[mg]</code> instead of <code>\w</code> is another possible improvement.</span>
<span class="comment-copy">Sure... but since the criteria does seem to be something matching A&gt;A at the end of the string preceded by one or more digits... the anchoring to the end describes that better without the worry about what the characters are or how many are before the digits, whether they appear after a <code>:</code> or whatever, and precludes the possibility of a weird input happening to match the pattern somewhere not at the end of the string.</span>
<span class="comment-copy">This almost works, but column '3' needs to contain G&gt;C, G&gt;T, etc, while column 2 is strictly a number. And to the above, only upvotes for everyone from me :)</span>
<span class="comment-copy">@Justin, Should look better now :)</span>
