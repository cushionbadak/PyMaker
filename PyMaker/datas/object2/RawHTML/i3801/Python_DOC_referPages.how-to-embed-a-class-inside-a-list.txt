<div class="post-text" itemprop="text">
<p>Currently, I am building a project that allows the simulation of a Magic The Gathering game so I can see how often I draw specific cards and how long it takes to win a match - i.e. take the opponent's life down from 20 to 0. 
The code that I am using now uses OOP for individual cards and individual decks. These are imported into a main piece of code - the project is on GitHub at <a href="https://github.com/jimbob88/MTG" rel="nofollow noreferrer">https://github.com/jimbob88/MTG</a>.
Card.py:</p>
<pre><code>class Card:
    """Define MTG Card"""

    def __init__(self, name, cc, supertype):
        """(Card, int, str) -&gt; Nonetype"""
        self.name = name; self.cc = cc; self.supertype = supertype
        self.cardData = [self.name, self.cc, self.supertype]

    def __str__(self):

        card_string = super().__str__()

        return str(self.cardData)
</code></pre>
<p>This is a simple class that stores the name, casting cost and the type of card. It also contains a variable - cardData - that returns a list with the name, casting cost and supertype. Then these cards are inputted as a list to a class named Deck. Deck.py:</p>
<pre><code>from random import shuffle;  import csv
class Deck:
    """Define MTG Deck"""

    def __init__(self, name, author, colour, cards):
        self.name = name; self.author = author; self.colour = colour; self.cards = cards
        self.hand = []; self.csvData = []
</code></pre>
<p>The Deck class than places this list into a variable - self.cards. The Deck also contains the variables for the name of the deck, the author of the deck and the colour of the deck. Finally, I have my main script named MTG.py that builds the deck than runs it - here is the area where I have encountered a problem. MTG.py:</p>
<pre><code>from Deck import *; from Card import * 
dcards = []         
while True:
    #if input('End?') != 'end':
    #    continue
    #else:
    #    break
    userCardName = input('Card Name: ')
    userCC = input('Converted Mana Cost(INT): ')
    userSuperType = input('Card SuperType: ')
    userAmount = input('Amount: ')
    dcards.extend([[Card(userCardName, userCC, userSuperType).cardData(), userAmount]])
    print(str(dcards))
    end = input('End? ')
    if end == 'y':
        break
RedBurn = Deck('RedBurn','James Blackburn', 'Red',dcards)
</code></pre>
<p>This code has an infinite loop that asks users for a card name, casting cost, Supertype and the amount of those cards. It then inputs that into the class - Card(userCardName, userCC, userSuperType) - in a list with cardData. It then goes onto repeat this process until the loop is broken. After this, it places all the user gained data into the Deck class.. My problem is my next stage of development is to allow the casting of cards and the basic rules that apply to this. Basically, only one land can be cast each turn and if I want to cast - for example, a creature - I have to tap a land type. So to have a land type tapped it can't be used again. Until the next turn. My idea to fix this was to input each card as an object instead of as a list so I could have a separate self.variable inside this object named isTapped.</p>
<pre><code>dcards.extend([[Card(userCardName, userCC, userSuperType), userAmount]])
</code></pre>
<p>Although this causes the card to be seen as -  <code>&lt;Card.Card object at 0x7f8dad97f630&gt;</code> - the memory allocation not as it's actual value. Does anyone know how I could do this, any help in other bits of the code would be appreciated,
Thanks in advance,
James Blackburn.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you print a list of Cards the list itself will print its elements using <strong>repr</strong>() of that element, not <strong>str</strong>(): </p>
<pre><code># no __str__ 
class One():
    def __init__(self):
        pass

# self-styled __str__
class Two():
    def __init__(self):
        pass
    def __str__(self):
        return "TwoClass: Stylish aint it?"
    def __repr__(self):
        return "REPR of TwoClass: Stylish aint it?"

# Test: print both class instances    
k = [ One(), Two(), [Two()]]  # obj , obj, [obj] inside - see output for what print uses

print(*k,sep="\n\n")
</code></pre>
<p>Output:</p>
<pre><code>&lt;__main__.One object at 0x7fdf5df7a438&gt;

TwoClass: Stylish aint it?

[Repr of TwoClass: Stylish aint it?]
</code></pre>
</div>
<span class="comment-copy">read up on <code>__repr__(self)</code> and <code>__str__(self)</code> starting point: <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__str__</a> and  <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__repr__</a></span>
<span class="comment-copy">@PatrickArtner Thanks for the tips I'll try and minimize my code and leave the full code for the GitHub code.</span>
<span class="comment-copy">def __str__(self):          card_string = super().__str__()          return str(self.cardData) And yet I still receive the same error</span>
<span class="comment-copy">@wowcha you are printing a <code>list of cards</code> - not a <code>card</code>. the list of cards displays its own content using <code>__repr__</code>  not <code>__str__</code>.You also need to <code>__repr__(self)</code> for cards for them to show up "nice" inside lists</span>
<span class="comment-copy">@wowcha edited to make it more clear</span>
<span class="comment-copy">Thank  You for your help I'll just try this now.</span>
