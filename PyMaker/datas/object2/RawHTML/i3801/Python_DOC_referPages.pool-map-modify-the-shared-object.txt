<div class="post-text" itemprop="text">
<p>Consider the following toy example. I am making a parallelization to compute the value of square function while making some modifications of the shared object A. </p>
<pre><code>import multiprocessing

A = [1, 2]

def square(i):

    A[i] = 2 + A[i]

    return i * i

square(0)
square(1)

print(A)

A = [1, 2]

multiprocessing.Pool().map(square, [0, 1])

print(A)
</code></pre>
<p>The output is the following</p>
<pre><code>[3, 4]
[1, 2]
</code></pre>
<p>But I expect it to be</p>
<pre><code>[3, 4]
[3, 4]
</code></pre>
<p>As indicated above, the serial version of square function managed to change A from [1, 2] to [3, 4]. But the pool.map failed to modify A. So I am asking how to modify the shared object using pool().map. Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>If your <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer"><code>startmethod</code></a> is <code>spawn</code> or <code>forkserver</code>, then <code>A</code> is not a shared object in the first place. And if you're on Windows, <code>spawn</code> is the default, and only choice.</p>
<p>If your <code>startmethod</code> is <code>fork</code>, then <code>A</code> may be a shared object—but if it is, it isn't actually safe to mutate it without any locks.</p>
<p>As explained in <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">Sharing state between processes</a>, you should try as hard as possible to not need shared objects—it's kind of the whole point of multiprocessing that the processes are isolated from each other—but if you really do need them, you have to do something a bit more complicated.</p>
<p>The first option is using shared memory. In this case, you're using your list as a fixed-sized array of small ints, which you can simulate with an <code>Array('i', [1, 2])</code>, which you can use exactly as in the example in the docs. For more complicated cases, you often need to add a <code>Lock</code> or other synchronization mechanism to protect the shared memory. This is pretty efficient and simple, but it only works when your shared data is something that can be mapped to low-level types like this.</p>
<p>The second option is using a <code>Manager.list([1, 2])</code>, which you can use exactly as in the very next example in the docs. This is a lot less efficient—it works by creating a queue and passing messages back and forth that tell the main process to do the work whenever you want to access or mutate the list—but it has the advantage of being dead simple to use.</p>
<hr/>
<p>But again, it's usually better to not do either of these things, and instead rewrite your code to not need shared data in the first place. Usually this means returning more data from the pool tasks, and then having the main process assemble the returned values in some way. Of course this is tricky if, e.g., other tasks inherently need to see the mutated values.  (In such cases, you'd often have to build 80% of what <code>Manager</code> is doing, at which point you might as well just use <code>Manager</code>…). But in your toy example, that isn't the case. (And, in fact, when you <em>think</em> that's unavoidably necessary, it often means you haven't thought through how nondeterminism is going to affect your algorithm, and it wouldn't have worked anyway…)</p>
<p>Here's an example of how you could do this with your toy problem:</p>
<pre><code>import multiprocessing

def square(i, aval):
    # actual return value, i, and value to set A[i] to
    return i*i, i, 2+aval

A = [1, 2]
# pass each A[i] into the function
for result, i, aval in multiprocessing.Pool().starmap(square, zip([0, 1], A)):
    # get the new A[i] out of the function and store it
    A[i] = aval    
print(A)
</code></pre>
</div>
<span class="comment-copy">Depending on your platform (or, actually, your start method, but usually you leave that to the default, which depends on your platform), <code>A</code> is either not a shared object in the first place, or it is a shared object but you need locks around it. The right way to handle this is usually either <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">shared memory</a>, a <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer"><code>Manager</code></a>, or rewriting your code so it passes immutable objects back instead.</span>
<span class="comment-copy">Thanks for such detailed answer! Following your answer and thoughts, I found a similar question in stackoverflow that has been well solved, which I will post below. My case is even simpler than that. A is a list of independent but complicated objects (linear programming models). Process i modifies the i^th object independently. So A is seen by all processes but each entry of A is manipulated independently. In the end, I want to get the modified A. I am wondering if there are more concise ways to do it.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/1675766/how-to-combine-pool-map-with-array-shared-memory-in-python-multiprocessing" title="how to combine pool map with array shared memory in python multiprocessing">stackoverflow.com/questions/1675766/…</a></span>
<span class="comment-copy">@J.Lin Then the simplest way to do that is to not share the list at all. Just return the value. Then. In the main process, instead of ignoring the return values from <code>map</code>, use them to modify <code>A[i]</code>. Or, maybe even more simply, just do something like <code>A[:] = pool.map(…)</code>, or even <code>A = list(pool.map(…))</code>.</span>
<span class="comment-copy">The return value from map is the value of my square function. In the above toy example, it's [0,1]. But I want [3,4].</span>
<span class="comment-copy">@J.Lin Sure, but in your toy example, you’re not using the return value for anything, so you can change it to return something else instead. And if your real code actually <i>does</i> have a return value that you use, then you can change it to return a pair of two values—the actual return value, and the <code>A[i]</code> value—and then change the main code that was doing, say, <code>for ret in pool.map(…):</code> to do <code>for ret, aval in pool.map(…):</code>. (You may actually need to return <code>i</code> as well, or you may be able to use <code>enumerate(pool.map(…))</code>, or you may not need it at all if you can just build a new A.)</span>
