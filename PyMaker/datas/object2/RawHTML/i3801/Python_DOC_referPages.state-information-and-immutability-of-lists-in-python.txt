<div class="post-text" itemprop="text">
<p>I am a beginner in Python and using Mark Lutz's book to learn the fundamentals of Python. </p>
<p>Here's an example that the author uses to demonstrate storing state information using lists:</p>
<pre><code>def tester(start):
    def nested(label):
        print(label,state[0])
        state[0] += 1
    state = [start]
    return nested
</code></pre>
<p>Here's the code to test state information:</p>
<pre><code>F = tester(3)
F('sam')
F('sam')
</code></pre>
<p>You would see that the counter increases from 3 and then continues. In essence, above code stores initial state <code>start</code> (passed during initialization of the object) in <code>[state]</code> and increments it every time <code>label</code> is called. </p>
<p>However, I am unsure why Python doesn't throw an error in <code>nested</code> block. Specifically, <code>[state]</code> is local to <code>tester</code> and not <code>nested.</code> </p>
<p>To demonstrate what I mean, I am going to replace <code>state[0]</code> by <code>state.</code></p>
<pre><code>def tester(start):
    def nested(label):
        print(label,state) #Replaced state[0] with state
        state += 1         #Replaced state[0] with state
        print("after:",state)
    state = start          #Replaced state[0] with state
    return nested
</code></pre>
<p>Technically, above code should also work fine because all I have done is that replaced the list with the variable. However, PyCharm wouldn't even run this code. I get an error <code>nboundLocalError: local variable 'state' referenced before assignment</code></p>
<p>Can someone please explain why the version with <code>list</code> works fine? The author has stated that "this leverages the mutability of lists, and relies on the fact that in-place object do not classify a name as local."</p>
<p>I am not really sure what that means. Can someone please help me? Thanks for any help extended to me.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow noreferrer">You should read this section of the documentation</a>. </p>
<p>Basically, in both versions the scope of the nested block allows it to interact with the namespace of the encompassing block.  The difference is that you are not reassigning <code>state</code> in the first example, you're mutating it. </p>
<p>In the second example, Python knows that you are going to assign a value to that reference later in the function, so it is treated as a name from the local <code>nested</code> namespace, rather than the outer <code>tester</code> namespace.</p>
<p>You can use the <code>nonlocal</code> keyword to circumvent this and use the other reference from the other namespace </p>
<pre><code>def tester(start):
    def nested(label):
        nonlocal state
        print(label,state) 
        state += 1         
        print("after:",state)
    state = start          
    return nested
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From what I understand, because <code>nested</code> is nested under <code>tester</code>, it would have access to any objects and variables that belong to <code>tester</code> because <code>tester</code> is the parent function and <code>nested</code> is the child function in this case. Python will not produce an error because of <a href="https://www.python-course.eu/python3_inheritance.php" rel="nofollow noreferrer">inheritance</a>.</p>
<p>And about replacing <code>state[0]</code> with <code>state</code>, Python automatically assumes that <code>state</code> is an <code>integer</code> because you are trying to add to it. While <code>state</code> is a list, and you can't add to is unless you <a href="https://developers.google.com/edu/python/lists" rel="nofollow noreferrer">append</a> an element to it- which this isn't your case. The reason why <code>state[0]</code> works and not <code>state</code> is because <code>state[0]</code> is an element in the <code>state</code> list and it adds 0 to it.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a function of 1) how Python variable assignment actually just creates aliases (pointers) to underlying values in memory, and the difference between how mutable and immutable types are treated; and 2) some Python "magic" related to closures. The crux of your question is really the first point. </p>
<p>To address that, take for example the following:</p>
<pre><code>a = 3
b = 3
</code></pre>
<p>Both a and b point to the same underlying object:</p>
<pre><code>assert hex(id(a)) == hex(id(b)) 
</code></pre>
<p>is True. However, then setting <code>b = 4</code> will cause b to point to a different object in memory (showing that the int is immutable).</p>
<p>However, a list is mutable (modifiable "in place"). For example: <code>c = [2]</code> will have the same memory location before and after an operation like <code>c[0] = 3</code>.</p>
<p>There are a lot of implications of this very basic explanation that take some time to interpret. For example, variables can’t “point to” other variables, but rather still point to underlying objects.</p>
<p>As a result, lists can exhibit "weird" behavior (another common, related confusion revolves around setting a default parameter value as a list that's then modified in the function), but can also be taken advantage of in the way your example shows.</p>
</div>
<span class="comment-copy">Thanks for your help. I read the link pointed by you. So, the bigger question is that why does Python allow mutable objects (<code>list</code>) to be changed without <code>nonlocal</code> and doesn't allow immutable objects <code>numeric</code> (or <code>integer</code>)? I'd appreciate some thoughts. Thanks in advance. Sorry, if my question is too basic.</span>
<span class="comment-copy">Imagine the name of a variable being like an address that directs you to an house. When you change the contents of a mutable type like a  list, that's like moving furniture around inside the house.  You can make the house very different, but it's still the same house, located at the same address.  But when you change an immutable type, you can't change the house.  So instead you change your address to a different house.  <code>nonlocal</code> lets you change addresses that other namespaces are holding.  If you changed <code>state[0] += 1</code> to <code>state = [state[0] + 1]</code> in example 1, you would get the same error.</span>
