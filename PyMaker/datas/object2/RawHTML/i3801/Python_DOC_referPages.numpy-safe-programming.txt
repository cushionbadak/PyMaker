<div class="post-text" itemprop="text">
<p>Are there any sources or guidelines for safe, bug-free numerical programming with numpy?</p>
<p>I'm asking because I've painfully learned that numpy does many things that seem to really ask for bugs to happen, such as...</p>
<p>Adding matrices of different sizes ("broadcasting") without complaining:</p>
<pre><code>In: np.array([1]) + np.identity(2)
Out: array([[ 2.,  1.],
            [ 1.,  2.]])
</code></pre>
<p>Returning different data types depending on the input:</p>
<pre><code>In: scalar1 = 1
In: scalar2 = 1.
In: np.array(scalar1).dtype
Out: dtype('int32')
In: np.array(scalar2).dtype
Out: dtype('float64')
</code></pre>
<p>Or simply not performing a desired operation (again, depending on the data type) without raising any warnings:</p>
<pre><code>In: np.squeeze(np.array([[1, 1]])).ndim
Out: 1
In: np.squeeze(np.matrix([[1, 1]])).ndim
Out: 2
</code></pre>
<p>These are all very hard to discover bugs, since they do not raise any exceptions or warnings and often return results of the valid data types / shapes. Therefore my question: <strong>Are there any general guidelines for improving the safety and preventing bugs in mathematical programming with numpy?</strong></p>
<p>[Note that I don't believe that this answer will attract "opinionated answers and discussions" since it is not about personal recommendations, but rather asking whether there are any existing guidelines or sources on the subject at all - of which I could not find any.]</p>
</div>
<div class="post-text" itemprop="text">
<p>Frequently I ask SO questioners, what's the <code>shape</code>? the <code>dtype</code>? even the <code>type</code>.  Keeping tracking of those properties is a big part of good <code>numpy</code> programming.  Even in MATLAB I found that getting the <code>size</code> right was 80% of debugging.</p>
<h2>type</h2>
<p>The <code>squeeze</code> example revolves around <code>type</code>, the <code>ndarray</code> class versus the <code>np.matrix</code> subclass:</p>
<pre><code>In [160]: np.squeeze(np.array([[1, 1]]))
Out[160]: array([1, 1])
In [161]: np.squeeze(np.matrix([[1, 1]]))
Out[161]: matrix([[1, 1]])
</code></pre>
<p><code>np.matrix</code> object is, by definition, always 2d.  That's the core of how it redefines <code>ndarray</code> operations.</p>
<p>Many <code>numpy</code> functions delegate their work to <code>methods.  The code for</code>np.squeeze` is:</p>
<pre><code>try:
    squeeze = a.squeeze
except AttributeError:
    return _wrapit(a, 'squeeze')
try:
    # First try to use the new axis= parameter
    return squeeze(axis=axis)
except TypeError:
    # For backwards compatibility
    return squeeze()
</code></pre>
<p>So <code>In [161]</code> is really:</p>
<pre><code>In [163]: np.matrix([[1, 1]]).squeeze()
Out[163]: matrix([[1, 1]])
</code></pre>
<p><code>np.matrix.squeeze</code> has its own documentation.</p>
<p>As a general rule we discourage the use of <code>np.matrix</code>.  It was a created years ago to make things easier for wayward MATLAB programmers.  Back in those days MATLAB only had 2d matrices (even now MATLAB 'scalars' are 2d).</p>
<h2>dtype</h2>
<p><code>np.array</code> is a powerful function.  Usually its behavior is intuitive, but sometimes it makes too many assumptions.  </p>
<p>Usually it takes clues from the input, whether integer, float, string, and/or lists:</p>
<pre><code>In [170]: np.array(1).dtype
Out[170]: dtype('int64')
In [171]: np.array(1.0).dtype
Out[171]: dtype('float64')
</code></pre>
<p>But it provides a number of parameters.  Use those if you need more control:</p>
<pre><code>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)

In [173]: np.array(1, float).dtype
Out[173]: dtype('float64')
In [174]: np.array('1', float).dtype
Out[174]: dtype('float64')
In [177]: np.array('1', dtype=float,ndmin=2)
Out[177]: array([[1.]])
</code></pre>
<p>Look at it's docs, and also at the <a href="https://docs.scipy.org/doc/numpy/reference/routines.array-creation.html" rel="nofollow noreferrer">https://docs.scipy.org/doc/numpy/reference/routines.array-creation.html</a> page which lists many other array creation functions.  Look at some their code as well.</p>
<p>For example <code>np.atleast_2d</code> does a lot of <code>shape</code> checking:</p>
<pre><code>def atleast_2d(*arys):
    res = []
    for ary in arys:
        ary = asanyarray(ary)
        if ary.ndim == 0:
            result = ary.reshape(1, 1)
        elif ary.ndim == 1:
            result = ary[newaxis,:]
        else:
            result = ary
        res.append(result)
    if len(res) == 1:
        return res[0]
    else:
        return res
</code></pre>
<p>Functions like this are good examples of defensive programming.</p>
<p>We get a lot SO questions about 1d arrays with <code>dtype=object</code>.  </p>
<pre><code>In [272]: np.array([[1,2,3],[2,3]])
Out[272]: array([list([1, 2, 3]), list([2, 3])], dtype=object)
</code></pre>
<p><code>np.array</code> tries to create a multidimensional array with a uniform <code>dtype</code>.  But if the elements differ in size or can't be cast to the same <code>dtype</code>, it will fall back on <code>object</code> dtype.  This is one of those situations where we need to pay attention to <code>shape</code> and <code>dtype</code>.</p>
<h2>broadcasting</h2>
<p>Broadcasting has been a part of <code>numpy</code> forever, and there's no way of turning it off.  Octave and MATLAB have added it later, and do enable warning switches.</p>
<p>The first defensive step is to understand the broadcasting principles, namely</p>
<ul>
<li>it can expand the beginning dimensions to match</li>
<li>it coerce unitary dimensions to match.</li>
</ul>
<p>So a basic example is:</p>
<pre><code>In [180]: np.arange(3)[:,None] + np.arange(4)
Out[180]: 
array([[0, 1, 2, 3],
       [1, 2, 3, 4],
       [2, 3, 4, 5]])
</code></pre>
<p>The first term is (3,) expanded to (3,1).  The second is (4,) which, by broadcasting expands to (1,4).  Together (3,1) and (1,4) broadcast to (3,4).</p>
<p>Many numpy functions have parameters that make keeping track of dimensions easier.  For example <code>sum</code> (and others) has a <code>keepdims</code> parameter:</p>
<pre><code>In [181]: arr = _
In [182]: arr.sum(axis=0)
Out[182]: array([ 3,  6,  9, 12])         # (4,) shape
In [183]: arr.sum(axis=0,keepdims=True)
Out[183]: array([[ 3,  6,  9, 12]])       # (1,4) shape
In [184]: arr/_                           # (3,4) / (1,4) =&gt; (3,4)
Out[184]: 
array([[0.        , 0.16666667, 0.22222222, 0.25      ],
       [0.33333333, 0.33333333, 0.33333333, 0.33333333],
       [0.66666667, 0.5       , 0.44444444, 0.41666667]])
</code></pre>
<p>In this case the <code>keepdims</code> isn't essential since (3,4)/(4,) works.  But with <code>axis=1</code> sum the shape becomes (3,) which can't broadcast with (3,4).  But (3,1) can:</p>
<pre><code>In [185]: arr/arr.sum(axis=1,keepdims=True)
Out[185]: 
array([[0.        , 0.16666667, 0.33333333, 0.5       ],
       [0.1       , 0.2       , 0.3       , 0.4       ],
       [0.14285714, 0.21428571, 0.28571429, 0.35714286]])
</code></pre>
<p>To manage shapes I like to:</p>
<ul>
<li>display <code>shape</code> while debugging</li>
<li>test snippets interactively</li>
<li>test with diagnostic shapes, e.g. <code>np.arange(24).reshape(2,3,4)</code></li>
<li><code>assertion</code> statements in functions can be useful <code>assert(arr.ndim==1)</code></li>
</ul>
<h2>typing</h2>
<p>Recent Python 3 versions have added a <code>typing</code> module</p>
<p><a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">https://docs.python.org/3/library/typing.html</a></p>
<p>Even for built-in Python types it's provisional.  I'm not sure much has been added for <code>numpy</code>.  </p>
</div>
<div class="post-text" itemprop="text">
<p>In some ways, an answer to this question is no different than general guidelines for safe programming:</p>
<ul>
<li>Check and sanitise code early, for every function</li>
<li>Maintain relevant unit tests.</li>
</ul>
<p>Yes, this may sound like extra overhead, but the reality is you're probably already doing such checks and tests by hand anyway, so it's good practice to put it down on paper and formalise / automate the process. E.g., while you may have never expected a <code>matrix</code> output specifically, any unit test that checked your output is the expected <code>array</code> would have failed reliably. </p>
<p>You might also want to have a look at specialised testing tools that are specific to scientific code, e.g. the <a href="https://hypothesis.works/" rel="nofollow noreferrer">Hypothesis</a> package</p>
<p>One thing that <em>is</em> specific to numpy is the handling of Floating Errors; the default simply 'prints' a warning statement to stdout, which can be missed easily (and does not cater for proper exception handling workflows). You can convert this functionality to throw proper warnings / exceptions that you can capture, via the <code>numpy.seterr</code> method -- e.g. <code>numpy.seterr(all='raise')</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use numpy in a "safer" way, you'll probably have to create your own safety net. One way to do so would be to define wrappers that enforce the rules you want your code to obey. You can come up with your own wrappers and tests as you go along and/or stumble upon behaviour that you consider problematic.</p>
<p><strong>Some toy examples:</strong></p>
<p><em>Always have float arrays:</em></p>
<pre><code>def arrayf64(*args, **kwargs):
    kwargs.setdefault("dtype", np.float64)
    return np.array(*args, **kwargs)
</code></pre>
<p><em>Disable broadcasting:</em></p>
<pre><code>def without_broadcasting(op, arr1, arr2):
    assert arr1.ndim == arr2.ndim
    return op(arr1, arr2)
</code></pre>
<p><em>Warn when using <code>np.matrix</code>:</em></p>
<pre><code>def safe_np_matrix(*args, **kwargs):
    warnings.warn('Unsafe code detected. Usage of np.matrix found.')
    return np.matrix(*args, **kwargs)

np.matrix = safe_np_matrix
</code></pre>
</div>
<span class="comment-copy">Well one guideline straight from the developers of numpy is not to use <code>numpy.matrix</code> ever</span>
<span class="comment-copy">That's a lesson we also had to learn, but unfortunately, some methods sometimes seem to return <code>np.matrix</code> objects...? I've resorted to explicitly converting everything I get using <code>np.array</code>.</span>
<span class="comment-copy">What exactly would you consider unsafe in the examples you've given? I think numpy may well have some unintuitive behaviour, but there is nothing you can do to avoid it besides reading the documentation of each individual function/method you use.</span>
<span class="comment-copy">@dangom I think he is referring to <i>magic things</i> happening when not expected. I consider those things features, but compared to Eigen (C++) for example, where the type-system is much much more strict and all / most of these things won't compile. It's obviously the user to reason about which kind of assumptions / design his library should bring. Maybe he should add some frequent assertions in his case (and compare with high-quality codebases like scipy, pandas, scikit-learn, matplotlib).</span>
<span class="comment-copy">I know that the behavior in all of the above examples makes sense in some way, the problem is that for the things I do (implementing algebraic algorithms), they are all completely undesirable (I never want to broadcast at all, I never want to work with ints - especially not mixed with floats - and I'd expect methods to at least raise a warning when they can't work with their input variable. What I'm asking for are ways to reduce the chance of <i>accidentally</i> doing one of the above things, without noticing it.</span>
<span class="comment-copy">Thanks a lot for your reply! This is definitely very useful information and advice for a safer programming style in numpy. Unfortunately, however, it does rely on the individual developer knowing these things and manually attempting to follow them. I was hoping for either "There is guideline XY on safe numpy programming, which you can point contributors to", or "There is method YZ for checking automatically whether contributors adhere to these standards."</span>
<span class="comment-copy">This (implementing unit tests and assertions) is more or less what we do right now, but it relies on individual developers attempting to follow good style, and succeeding in doing so. I was hoping for some more automated method of enforcing / checking these general requirements.</span>
<span class="comment-copy">Hypothesis looks interesting, but (as you say) it is somewhat unrelated to the particulars of this question. Still might look into it, thanks for the pointer!</span>
<span class="comment-copy">This is an interesting approach [see my comments @the other answers: this approach does automate the checks], but I am somewhat hesitant to start writing my own wrappers for basic numpy functions... I guess it'll take a <i>lot</i> of trial and error and learning to get things right and working seamlessly with base numpy. Somehow I was hoping somebody had already done something along these lines... :-/</span>
