<div class="post-text" itemprop="text">
<p>I would like to create an application that reads the name and grade of 4 students, prints the average and says which student is above average. For instance:</p>
<ul>
<li>Student 1: John

<ul>
<li>Grade of John: 90</li>
</ul></li>
<li>Student 2: Paul

<ul>
<li>Grade of Paul: 85</li>
</ul></li>
<li>Student 3: Ringo

<ul>
<li>Grade of Ringo: 80</li>
</ul></li>
<li>Student 4:

<ul>
<li>Grade of George: 75</li>
</ul></li>
</ul>
<p>The average of grades is 82.5 and John and Paul are above average. Here's my code:</p>
<pre><code>grade_list = []

st1 = input("Sudent 1: ")
grade1 = int(input("Grade of %s: " % (st1)))
st2 = input("Student 2: ")
grade2 = int(input("Grade of %s: " % (st2)))
st3 = input("Student 3: ")
grade3 = int(input("Grade of %s: " % (st3)))
st4 = input("Student 4: ")
grade4= int(input("Grade of %s: " % (st4)))

avg = (grade1 + grade2 + grade3 + grade4) / 4

grade_list.append(grade1)
grade_list.append(grade2)
grade_list.append(grade3)
grade_list.append(grade4)


for x in grade_list:
    if x &gt; avg:
        print(x)
</code></pre>
<p>I'm able to print the grades of the students that are above average, but how can I print their names? I've tried to sort the grades_list and create a new list for the names, but it didn't help me. Any tips? (Sorry for the bad title)</p>
</div>
<div class="post-text" itemprop="text">
<p>First, let me simplify your code a bit to make the rest of this easier. Instead of this:</p>
<pre><code>grade_list = []
# ...
grade_list.append(grade1)
grade_list.append(grade2)
grade_list.append(grade3)
grade_list.append(grade4)
</code></pre>
<p>… you can just do this:</p>
<pre><code>grade_list = [grade1, grade2, grade3, grade4`]
</code></pre>
<p>Now, you build a second list of names:</p>
<pre><code>name_list = [st1, st2, st3, st4]
</code></pre>
<p>And now you can either loop over the two lists in lock-step using <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a>:</p>
<pre><code>for name, grade in zip(name_list, grade_list):
    if grade &gt; avg:
        print(name, grade)
</code></pre>
<p>… or you can loop over the indexes of <code>grade_list</code> instead of the members:</p>
<pre><code>for i in range(len(grade_list)):
    if grade_list[i] &gt; avg:
        print(name_list[i], grade_list[i]))
</code></pre>
<p>The first one is obviously cleaner and less verbose, so if you can understand how <code>zip</code> works, that's the one you should probably use.</p>
<hr/>
<p>But let me show you an even nicer way to solve this:</p>
<pre><code>students, grades = [], []
for i in range(4):
    students = input(f"Student {i+1}: ")
    grade = int(input(f"Grade of {st}: "))
    students.append(student)
    grades.append(grade)

avg = sum(grades) / len(grades) # or, even better, statistics.mean(grades)

for name, grade in zip(names, grades):
    if grade &gt; avg:
        print(name, grade)
</code></pre>
<p>Now, you don't have to repeat yourself four times—and, if you want to change it to handle John, Paul, Ringo, George, and Brian, or even to ask the user how many students to handle, you only need to replace that <code>4</code> with <code>5</code> or <code>int(input("How many students? "))</code>, and the rest of your code still works.</p>
<p>(If you're not using Python 3.6, you can't use "f-strings" like <code>f"Student {i+1}: "</code>, but you can change those to use <code>%</code>, as you're already used to.)</p>
<hr/>
<p>Other ideas to play with once you've got the basics working:</p>
<ul>
<li>Use a list of pairs (tuples, or lists, with two elements), instead of a pair of lists.</li>
<li>Use a list of instances of some very simple class (maybe built with <code>namedtuple</code>, <code>@dataclass</code>, or <code>@attr</code>) instead of just pairs.</li>
<li>Use a <code>dict</code> instead of a list of pairs. Notice that this requires names to be unique (which you might actually want), and abandons any notion of order.

<ul>
<li>Or use an <code>OrderedDict</code>, which gives you the same benefits without losing ordering.</li>
<li>Or use a third-party collection class like <code>blist.sorteddict</code> that can keep things sorted by name, or by grade, or whatever you want.</li>
</ul></li>
</ul>
<p>These all have different pros and cons, so it's worth working through a bunch of them to compare. <a href="https://stackoverflow.com/a/50614716/908494">jpp's answer</a> demonstrates the <code>dict</code> solution—as you can see, it's cleaner and simpler in some ways, less so in others.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is an extension to <a href="https://stackoverflow.com/a/50614191/9209546">@abarnet's post</a>, showing an alternative way to structure your data.</p>
<p>If the student <em>number</em> is not important, you can use an unordered collection such as a dictionary. If ordering is important, the below solution can be adapted to use <code>collections.OrderedDict</code>.</p>
<p>Note that dictionary keys must be unique; so duplicate names are not permitted with this structure. You can, however, create a dictionary of tuples to map a unique identifying number to (name, score).</p>
<pre><code>from statistics import mean

# initialise dictionary
name_grade_dict = {}

# iterate number of students    
for i in range(4):
    student = input(f"Student {i+1}: ")
    grade = int(input(f"Grade of {student}: "))
    name_grade_dict[student] = grade  # add name -&gt; grade mapping to dict

# calculate average using statistics.mean
avg = mean(name_grade_dict.values())

# iterate dictionary using dict.items view
for name, grade in name_grade_dict.items():
    if grade &gt; avg:
        print(name, grade)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should use a two-dimensional array(a.k.a. matrix) so that you have pairs of names and grades:</p>
<pre><code>[['Student1', grade1],
 ['Student2', grade2],
 ['Student3', grade3],
 ['Student4', grade4]]
</code></pre>
<p>That's how I would do it.</p>
</div>
<span class="comment-copy">Poor George. Even after "Something", people still want to grade him for "Don't Bother Me" and his attempts at American folk-rock.</span>
<span class="comment-copy">The only other thing I'd add is prior to Py3, you have to force it away from integer division to get the expected result.</span>
<span class="comment-copy">@TemporalWolf The OP is pretty clearly using Python 3, or his <code>input</code> calls are already wrong, and he's already getting 82.5. In 2018, I don't think there's much point in writing Python 2-compatible answers for people who aren't asking for them.</span>
<span class="comment-copy">@jpp Yeah, I originally wrote this with <code>dict</code>, but then started thinking about what if the order is important and started writing about <code>OrderedDict</code>—and then noticed that the OP mentioned the idea of sorting the grades, at which point I decided that it was going to get too long and verbose even for me, so I scrapped all of that. Meanwhile, I'd probably reach for <code>namedtuple</code> before <code>dataclass</code> for something this trivial, at least while 3.7 is still in beta (and <code>attrs</code> is too overpowered, cute, and unstable to count as a backport for novices), but I didn't go down that road.</span>
<span class="comment-copy">@abarnert, Yep, noted, I posted a <code>dict</code> version anyway; if it doesn't help with this specific problem, at least it shows how an unordered solution would work.</span>
<span class="comment-copy">It might be worth mentioning what happens if you have two students with the same name. (Whether that's a feature or a bug depends on the OP's problem, of course.)</span>
