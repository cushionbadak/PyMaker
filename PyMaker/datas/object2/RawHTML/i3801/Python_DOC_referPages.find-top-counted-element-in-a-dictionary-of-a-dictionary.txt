<div class="post-text" itemprop="text">
<p>I have a dictionary of dictionary myDict:</p>
<pre><code>myDict = { 'cow': {'A':2, 'B':5, 'C':3},
           'cat': {'A':7, 'B':1, 'C':6},
           'dog': {'A':1, 'B':4, 'C':3},
           'bird': {'A':5, 'B':7, 'C':9}
         }
</code></pre>
<p>I want to find the top count element for each animal in this case, i.e. the output should be:</p>
<pre><code>myNewTable = {'cow':'B', 'cat':'A', 'dog':'B', 'bird':'C'}
</code></pre>
<p>I tried to achieve this using the following code:</p>
<pre><code> myNewTable = max(x.items(), key=operator.itemgetter(1))[0] for x in myDict
</code></pre>
<p>but got the following error:</p>
<pre><code>File "&lt;ipython-input-11-3bcb909a6476&gt;", line 28
    myNewTable = max(x.items(), key=operator.itemgetter(1))[0] for x in myDict
                                                                ^
SyntaxError: invalid syntax
</code></pre>
<p>What did I do wrong here ? And how could I fix this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are using comprehension syntax but haven't wrapped it in a specific type (e.g. <code>list =&gt; []</code>, <code>set =&gt; {}</code>, <code>dict =&gt; {:}</code>). So fixing your code it would look like:</p>
<pre><code>In []:
[max(myDict[x].items(), key=operator.itemgetter(1))[0] for x in myDict]

Out[]:
['B', 'A', 'B', 'C']
</code></pre>
<p>But you wanted it as a <code>dict</code>, so perhaps you meant:</p>
<pre><code>In []:
{x: max(myDict[x].items(), key=operator.itemgetter(1))[0] for x in myDict}

Out[]:
{'bird': 'C', 'cat': 'A', 'cow': 'B', 'dog': 'B'}
</code></pre>
<p>But can be specified more succinctly (as per @coldspeed's answer):</p>
<pre><code>{x: max(myDict[x], key=myDict[x].get) for x in myDict}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, your syntax is wrong, but you have the right idea. A nice and succinct solution using <code>max</code> and <code>dict.get</code> can be built on by iterating over <code>myDict</code>:</p>
<pre><code>&gt;&gt;&gt; {k : max(v, key=v.get) for k, v in myDict.items()}
{'bird': 'C', 'cat': 'A', 'cow': 'B', 'dog': 'B'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another alternative using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> with its <a href="https://docs.python.org/3/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer"><code>.most_common(...)</code></a> method:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter

&gt;&gt;&gt; {k: Counter(v).most_common(1)[0][0] for k, v in myDict.items()}
{'cat': 'A', 'bird': 'C', 'cow': 'B', 'dog': 'B'}
</code></pre>
<p>This will be useful in general <strong>if you want to select more than one highest count elements from the nested dict</strong>. For example, below is the sample to select list of two most common keys in dict:</p>
<pre><code>&gt;&gt;&gt; {k: [x[0] for x in Counter(v).most_common(2)] for k, v in myDict.items()}
{'dog': ['B', 'C'], 'bird': ['C', 'B'], 'cat': ['A', 'C'], 'cow': ['B', 'C']}
</code></pre>
<hr/>
<p>From the <a href="https://docs.python.org/3/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer"><strong><code>Counter.most_common([n])</code></strong> document</a>:</p>
<blockquote>
<p>Return a <code>list</code> of the <code>n</code> most common elements and their counts from the most common to the least. If <code>n</code> is omitted or <code>None</code>, <code>most_common()</code> returns all elements in the counter. Elements with equal counts are ordered arbitrarily:</p>
</blockquote>
</div>
