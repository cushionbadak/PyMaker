<div class="post-text" itemprop="text">
<p>I'm trying to learn how metaclasses work in python 3. Things I want to know are: which functions are called, in what order, and their signatures and returns.</p>
<p>As an example, I know <code>__prepare__</code> gets called when a class with a metaclass is instantiated with arguments <code>metaclass, name_of_subclass, bases</code> and returns a dictionary representing the future namespace of the instantiated object. </p>
<p>I feel like I understand <code>__prepare__</code>'s step in the process well. What I don't, though, are <code>__init__</code>, <code>__new__</code>, and <code>__call__</code>. What are their arguments? What do they return? How do they all call each other, or in general how does the process go? Currently, I'm stuck on understanding when <code>__init__</code> is called.</p>
<p>Here is some code I've been messing around with to answer my questions:</p>
<pre><code>#!/usr/bin/env python3

class Logged(type):

    @classmethod
    def __prepare__(cls, name, bases):
        print('In meta __prepare__')
        return {}

    def __call__(subclass):
        print('In meta __call__')
        print('Creating {}.'.format(subclass))
        return subclass.__new__(subclass)

    def __new__(subclass, name, superclasses, attributes, **keyword_arguments):
        print('In meta __new__')
        return type.__new__(subclass, name, superclasses, attributes)

    def __init__(subclass, name, superclasses, attributes, **keyword_arguments):
        print('In meta __init__')

class Thing(metaclass = Logged):

    def __new__(this, *arguments, **keyword_arguments):
        print('In sub __new__')
        return super(Thing, this).__new__(this)

    def __init__(self, *arguments, **keyword_arguments):
        print('In sub __init__')

    def hello(self):
        print('hello')

def main():
    thing = Thing()
    thing.hello()

if __name__ == '__main__':
    main()
</code></pre>
<p>From this and some googling, I know that <code>__new__</code> is really a static method that returns an instance of some object (usually the object where <code>__new__</code> is defined, but not always), and that <code>__init__</code> is called of an instance when it is made. By that logic, I'm confused as to why <code>Thing.__init__()</code> isn't being called. Could someone illuminate?</p>
<p>The output of this code prints 'hello', so an instance of Thing is being created, which further confuses me about init. Here's the output:</p>
<pre><code>In meta __prepare__
In meta __new__
In meta __init__
In meta __call__
Creating &lt;class '__main__.Thing'&gt;
In sub __new__
hello
</code></pre>
<p>Any help understanding metaclasses would be appreciated. I've read quite a few tutorials, but I've missed some of these details.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all: <code>__prepare__</code> is optional, you don't need to supply an implementation if all you are doing is return a default <code>{}</code> empty dictionary.</p>
<p>Metaclasses work <em>exactly like classes</em>, in that when you call them, then they produce an object. Both classes and metaclasses are <em>factories</em>. The difference is that a metaclass produces a class object when called, a class produces an instance when called.</p>
<p>Both classes and metaclasses define a default <code>__call__</code> implementation, which basically does:</p>
<ol>
<li>Call <code>self.__new__</code> to produce a new object.</li>
<li>if that new object is an instance of self / a class with this
metaclass, then <em>also</em> call <code>__init__</code> on that object.</li>
</ol>
<p>You produced your own <code>__call__</code> implementation, which doesn't implement that second step, which is why <code>Thing.__init__</code> is never called.</p>
<p>You may ask: <em>but the <code>__call__</code> method is defined on the metaclass</em>. That's correct, so it is <em>exactly that method</em> that is called when you call the class with <code>Thing()</code>. All special methods (starting and ending with <code>__</code>) are <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">called on the type</a> (e.g. <code>type(instance)</code> is the class, and <code>type(class)</code> is the metaclass) precisely because Python has this multi-level hierarchy of instances from classes from metaclasses; a <code>__call__</code> method on the class itself is used to make instances callable. For <code>metaclass()</code> calls, it is the <code>type</code> object itself that provides the <code>__call__</code> implementation. That's right, metaclasses are both subclasses and instances of <code>type</code>, at the same time.</p>
<p>When writing a metaclass, you should only implement <code>__call__</code> if you want to customise what happens when you call the class. Leave it at the default implementation otherwise.</p>
<p>If I remove the <code>__call__</code> method from your metaclass (and ignore the <code>__prepare__</code> method), then <code>Thing.__init__</code> is once again called:</p>
<pre><code>&gt;&gt;&gt; class Logged(type):
...     def __new__(subclass, name, superclasses, attributes, **keyword_arguments):
...         print('In meta __new__')
...         return type.__new__(subclass, name, superclasses, attributes)
...     def __init__(subclass, name, superclasses, attributes, **keyword_arguments):
...         print('In meta __init__')
...
&gt;&gt;&gt; class Thing(metaclass = Logged):
...     def __new__(this, *arguments, **keyword_arguments):
...         print('In sub __new__')
...         return super(Thing, this).__new__(this)
...     def __init__(self, *arguments, **keyword_arguments):
...         print('In sub __init__')
...     def hello(self):
...         print('hello')
...
In meta __new__
In meta __init__
&gt;&gt;&gt; thing = Thing()
In sub __new__
In sub __init__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the metaclass's <code>__call__</code> method, you're calling <code>Thing</code>'s <code>__new__</code> only, but not <code>__init__</code>. It seems that the default behaviour of <code>__call__</code> is to invoke both of them, as seen when we call the metaclass's inherited <code>__call__</code>:</p>
<pre><code>    def __call__(subclass):
        print('In meta __call__')
        print('Creating {}.'.format(subclass))
        return super().__call__(subclass)
</code></pre>
<p>This prints:</p>
<pre><code>Creating &lt;class '__main__.Thing'&gt;.
In sub __new__
In sub __init__
</code></pre>
</div>
<span class="comment-copy"><code>__new__</code> is not a static method; it's a <i>class</i> method that is special-cased so that you don't have to decorate it with <code>@classmethod</code>.</span>
<span class="comment-copy">I guess I don't understand the nuance differences, but I believe you're right @chepner. That's what I meant to get to, more-or-less.</span>
<span class="comment-copy">Class methods receive the invoking class as its first argument; static methods do not.</span>
<span class="comment-copy">The output of your answer at the end really brought to light what was going on, supported by the rest of your answer. Thank you!</span>
<span class="comment-copy">You've got it; <code>type.__call__()</code> calls <code>__new__()</code> first, then calls <code>__init__()</code> if <code>__new__()</code> returned an instance of the class. See <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__new__</a></span>
<span class="comment-copy">Thank you! This is precisely the crux of my immediate problem. I wish it was possible to pick two answers, since Martin answered more questions, because you're answer truly helped me fix my problem quickly.</span>
