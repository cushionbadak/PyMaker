<div class="post-text" itemprop="text">
<p>given letters: example of letters</p>
<pre><code>letters = 'hutfb' 
</code></pre>
<p>I am given a file with a list of words.</p>
<p>I need to write a recursive function that allows me to check all possibilities the letters can make. If the possibility is in the list of words from the file, I need to print that specific word. </p>
<p>so for letters given</p>
<p>they can create the words:</p>
<ul>
<li>a</li>
<li>cat</li>
<li>ac</li>
<li>act</li>
<li>cab</li>
</ul>
<p>and so on and on </p>
<p>each combination the letters make I need to check the file to see if its a valid word. if it is I need to print them. </p>
<p>I don't know how start to write this function.</p>
</div>
<div class="post-text" itemprop="text">
<p>I agree with @dparolin about processing the words file to see if words conform to the letters, not generating possible words and seeing if they are in the file.  This allows us not to read the file into memory, as we only need to examine one word at a time.  And it can be done with a recursive test:</p>
<pre><code>letters = 'catbt'

def is_match(letters, word):

    if not word:
        return True

    if not letters:
        return False

    letter = letters.pop()

    if letter in word:
        word.remove(letter)

    return is_match(letters, word)

with open('words.txt') as words:
    for word in words:
        word = word.strip()

        if is_match(list(letters), list(word)):
            print(word)
</code></pre>
<p><strong>EXAMPLE USAGE</strong></p>
<pre><code>% python3 test.py
act
at
bat
cab
cat
tab
tact
%
</code></pre>
<p>And we should be able to work with lots of letters without issue.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately I cannot help just now with a recursive function, but given that a higher count of letters/characters can easily explode into billions of potential combinations if not filtered during creation I have a quirky alternative by iterating over the known words. Those have to be in memory anyway.</p>
<p>[EDIT] Removed the sorting as it does not really provide any benefit, fixed an issue where I falsely set to true on iteration</p>
<pre><code># Some letters, separated by space
letters = 'c a t b'
# letters = 't t a c b'

# # Assuming a word per line, this is the code to read it
# with open("words_on_file.txt", "r") as words:
#     words_to_look_for = [x.strip() for x in words]
#     print(words_to_look_for)

# Alternative for quick test
known_words = [
    'cat',
    'bat',
    'a',
    'cab',
    'superman',
    'ac',
    'act',
    'grumpycat',
    'zoo',
    'tab'
]

# Create a list of chars by splitting
list_letters = letters.split(" ")

for word in known_words:
    # Create a list of chars
    list_word = list(word)
    if len(list_word) &gt; len(list_letters):
        # We cannot have longer words than we have count of letters
        # print(word, "too long, skipping")
        continue

    # Now iterate over the chars in the word and see if we have
    # enough chars/letters
    temp_letters = list_letters[:]

    # This was originally False as default, but if we iterate over each
    # letter of the word and succeed we have a match
    found = True
    for char in list_word:
        # print(char)
        if char in temp_letters:
            # Remove char so it cannot match again
            # list.remove() takes only the first found
            temp_letters.remove(char)
        else:
            # print(char, "not available")
            found = False
            break

    if found is True:
        print(word)
</code></pre>
<p>You could copy&amp;paste a product function from the itertools <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">documentation</a> and use the code provided by ExtinctSpecie, it has no further dependencies, however I found without tweaking it returns all potential options including duplications of characters which I did not immediately understand.</p>
<pre><code>def product(*args, repeat=1):
    # product('ABCD', 'xy') --&gt; Ax Ay Bx By Cx Cy Dx Dy
    # product(range(2), repeat=3) --&gt; 000 001 010 011 100 101 110 111
    pools = [tuple(pool) for pool in args] * repeat
    result = [[]]
    for pool in pools:
        result = [x+[y] for x in result for y in pool]
    for prod in result:
        yield tuple(prod)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools
str = "c a t b"
letters = list(str.replace(" ",""))
words_to_look_for = []

for index, letter in enumerate(letters):
    keywords = [''.join(i) for i in itertools.product(letters, repeat = index+1)]
    words_to_look_for.extend(keywords)

print(words_to_look_for)
</code></pre>
<p><a href="https://stackoverflow.com/questions/7074051/what-is-the-best-way-to-generate-all-possible-three-letter-strings">https://stackoverflow.com/questions/7074051/....</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As noted above, this <em>will not</em> be feasible for any more than the number of letters countable on your two hands.  There's just too many possibilities to check.  But if you were to try this, here's how the code would look.</p>
<pre><code>letters = ['a', 'b', 'c']

def powerset(letters):
    output = [set()]
    for x in letters:
        output.extend([y.union({x}) for y in output])
    return output

for subset in powerset(letters):
    for potential_word in map(''.join, itertools.permutations(list(subset))):
        # Check if potential_word is a word
</code></pre>
<p>This won't try words with duplicate letters (that would be another layer of insanity), but it will try all possible potential words that could be formed by a subset of the letters you give in any order.</p>
<p>[edit] Just realized you requested a recursive solution.  Dunno if that's required or not, but the powerset function could be changed to be recursive.  I think that would make it uglier and harder to comprehend, though.</p>
</div>
<span class="comment-copy">Your first step is to clarify the requirements. Can a letter be repeated in the word? For example, could <code>tat</code> be acceptable for your given example?</span>
<span class="comment-copy">no it can not unless the letters = t t a c</span>
<span class="comment-copy">Seems like you are looking subsets of an array. Take a look at <a href="https://stackoverflow.com/questions/26332412/python-recursive-function-to-display-all-subsets-of-given-set" title="python recursive function to display all subsets of given set">stackoverflow.com/questions/26332412/â€¦</a></span>
<span class="comment-copy">@Teomanshipahi: The OP is looking at all permutations of all non-empty subsets of an array.</span>
<span class="comment-copy">this works if the file is little but if it is too long text file, you get an error.</span>
<span class="comment-copy">@thecode, I tested this with a file containing over 200,000 words, one per line.  What format and size file are you working with?</span>
<span class="comment-copy">@thecode, I retested this code with a file containing over 300,000 words and the alphabet tripled as <code>letters</code> and it ran fine.  The recursion depth shouldn't be any more than the shorter of <code>letters</code> or <code>word</code>, which would have to be close to 1,000 characters to cause a <code>RecursionError</code>.  Did you modify the code?  What are you using for <code>letters</code>?  Is there some sort of deviant entry in the file tripping the code?</span>
<span class="comment-copy">As you ultimately only want to print the possible words from letters that also show up in a list of actually/correct/known words I chose this path.To be such a match I iterate over each word that could be valid and then check if all of these characters are contained in the initial letters, to make it easier sorted. Still think this will yield the result asked for. You will not be able to know all possible words from the letters provided without having such a "dictionary".</span>
<span class="comment-copy">Actually I just retested and it does not work exact enough, e.g. my code will accept 'tabb' although there is only one 'b' and I assume an issue surrounding the removal of characters. Will try to provide an update + make sure you can see all permutations in case you need them.</span>
<span class="comment-copy">Thanks for the clarification, but how can you know it is a potential word without either using the known-words file in the first place or use another "algorithm" that will guess it could be a word. The function that will work with the letters would have to have some sort of knowledge what could be a word before it selectively can check against your word file. If this is important, I am sure it can be done, but it will definitely be much more complicated than iterating over even a million known words.</span>
<span class="comment-copy">the file has a list of valid words. so if the combination is in the file then that means its a valid word.</span>
<span class="comment-copy">Could you elaborate if you have memory limitations (like must be running on embedded MicroPython with 512K memory or something similar ? As I cannot comment yet on @cdlane answer, I would like to understand at what size this will break. Given that answer it should actually only have a line (word) at a time in memory. If you tried and have an error message let us know.</span>
