<div class="post-text" itemprop="text">
<p>In numpy, if I have an array of floats, dynamically create a boolean mask of where this array equals a particular value and do a bitwise AND with a boolean array, I get an error:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([1.0, 2.0, 3.0])
&gt;&gt;&gt; a == 2.0 &amp; b

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: ufunc 'bitwise_and' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe'
</code></pre>
<p>If I save the result of the comparison to a variable and carry out the bitwise AND however, it works:</p>
<pre><code>&gt;&gt;&gt; c = a == 2.0
&gt;&gt;&gt; c &amp; b
array([False,  True, False], dtype=bool)
</code></pre>
<p>The objects created seem the same in each case though:</p>
<pre><code>&gt;&gt;&gt; type(a == 2.0)
&lt;type 'numpy.ndarray'&gt;
&gt;&gt;&gt; (a == 2.0).dtype
dtype('bool')
&gt;&gt;&gt; type(c)
&lt;type 'numpy.ndarray'&gt;
&gt;&gt;&gt; c.dtype
dtype('bool')
</code></pre>
<p>Why the difference?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>&amp;</code> has higher <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="noreferrer">precedence</a> than <code>==</code>, so the expression</p>
<pre><code>a == 2.0 &amp; b
</code></pre>
<p>is the same as</p>
<pre><code>a == (2.0 &amp; b)
</code></pre>
<p>You get the error because bitwise <code>and</code> is not defined for a floating point scalar and a boolean array.</p>
<p>Add parentheses to get what you expected:</p>
<pre><code>(a == 2.0) &amp; b
</code></pre>
</div>
<span class="comment-copy">try <code>np.bitwise_and(a==2.0,b)</code></span>
<span class="comment-copy">Thank you. That makes perfect sense now!</span>
