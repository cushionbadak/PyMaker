<div class="post-text" itemprop="text">
<p>Suppose I have a function which takes a dictionary as a parameter:</p>
<pre><code>def f(d: dict) -&gt; None:
    x = d["x"]
    print(x)
</code></pre>
<p>Can I specify that this dictionary <em>must</em> have the key <code>"x"</code> to mypy? I'm looking for something similar to <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html" rel="nofollow noreferrer">interface from typescript</a>, without changing <code>d</code> to a class.</p>
<p>The reason I don't want to change <code>d</code> to a class, is because I am modifying a large existing codebase to add <code>mypy</code> type checking and this dictionary is used in many places. I would have to modify a lot of code if I had to change all instances of <code>d["x"]</code> to <code>d.x</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, with <code>typing</code> (PEP 484 and PEP 526) you can't declare that a specific key is to be present in a container. All that you can declare are the <em>types</em>, not the runtime contents. <code>'x'</code> is a <em>specific string value</em>, not a type.</p>
<p>I know you specifically don't want to have to do this, but the perhaps the answer <em>is</em> to consider a different data structure, such as a named tuple or a dataclass, where you can specify the attribute a type has.</p>
<p>This is what the typescript declaration does, really:</p>
<blockquote>
<p>The <code>printLabel</code> function has a single parameter that requires that the object passed in has a property called <code>label</code> of type string.</p>
</blockquote>
<p>Python attributes are the moral equivalent of Typescript object properties. That Typescript object notation and Python dictionaries have a lot in common perhaps confuses matters, but you should not look upon Typescript object declarations as anything but classes, when trying to map concepts to Python.</p>
<p><code>mypy</code> does include extensions to <code>typing</code> which fall outside of the Python type hinting standard. This includes the <a href="https://mypy.readthedocs.io/en/latest/more_types.html#typeddict" rel="nofollow noreferrer"><code>mypy_extensions.TypeDict</code> object</a>, which works a lot like a <a href="https://docs.python.org/3/library/typing.html#typing.TypeVar" rel="nofollow noreferrer"><code>typing.TypeVar</code> declaration</a>:</p>
<pre><code>from mypy_extensions import TypedDict

SomeDict = TypeDict('SomeDict', {'x': str})

def f(d: SomeDict) -&gt; None:
    x = d['x']
    print(x)
</code></pre>
<p>or using a class-based syntax:</p>
<pre><code>class SomeDict(TypeDict)
    x: str
</code></pre>
<p>Keys in a <code>TypeDict</code> declaration are either all required, or all optional (when you set <code>total=False</code> on the declaration); you'd have to use inheritance to produce a type with some keys optional, see the documentation linked. </p>
<p>But be aware that <code>TypeDict</code> is <em>experimental</em> and could be dropped again or altered drastically in a future mypy release, and is not available in other Python type-hint checkers.</p>
</div>
<div class="post-text" itemprop="text">
<p>Mypy extends PEP 484 by providing a <a href="http://mypy.readthedocs.io/en/latest/more_types.html#typeddict" rel="nofollow noreferrer"><code>TypedDict</code></a> type. This allows specifying specific attributes of a dict type. In your case you can do the following:</p>
<pre><code>from mypy_extensions import TypedDict

# you can also do HasX = TypedDict('HasX', {'x': str})
class HasX(TypedDict):
    x: str

def f(x: HasX) -&gt; None:
    reveal_type(d["x"])  # error: Revealed type is 'builtins.str'
</code></pre>
</div>
<span class="comment-copy">This isn't true, mypy has <code>TypedDict</code>, as in @ethanhs answer</span>
<span class="comment-copy">@Gricey: indeed, so it does. It's a mypy-specific extension, and I was sticking with the official <code>typing</code> specification for Python only.</span>
