<div class="post-text" itemprop="text">
<p>I am trying to export a user list from a Jaspersoft server into a CSV format as we do not currently have access to the DB or any Administration panel and we would have to raise a support ticket and wait for 2 days each time we would like a list. I figured I will try my luck using REST API and python and with the help of requests module I managed to export the XML that holds this information. The format of the extracted XML is this. </p>
<p>Sample XML:</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;users&gt;
    &lt;user&gt;
        &lt;emailAddress&gt;doejoe@email.com&lt;/emailAddress&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;fullName&gt;John Doe&lt;/fullName&gt;
        &lt;username&gt;doejoe&lt;/username&gt;
        &lt;roles&gt;
            &lt;role&gt;
                &lt;externallyDefined&gt;false&lt;/externallyDefined&gt;
                &lt;name&gt;MANAGER&lt;/name&gt;
                &lt;desc&gt;Beatings will continue until morale improves&lt;/desc&gt;
            &lt;/role&gt;
            &lt;role&gt;
                &lt;externallyDefined&gt;false&lt;/externallyDefined&gt;
                &lt;name&gt;DIRECTOR&lt;/name&gt;
            &lt;/role&gt;
        &lt;/roles&gt;
    &lt;/user&gt;
     &lt;user&gt;
        &lt;emailAddress&gt;kathysmith@email.com&lt;/emailAddress&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;fullName&gt;Kathy Smith&lt;/fullName&gt;
        &lt;username&gt;kathysmith&lt;/username&gt;
        &lt;externallyDefined&gt;false&lt;/externallyDefined&gt;
        &lt;roles&gt;
            &lt;role&gt;
                &lt;externallyDefined&gt;false&lt;/externallyDefined&gt;
                &lt;name&gt;USER&lt;/name&gt;
                &lt;desc&gt;User Description&lt;/desc&gt;
            &lt;/role&gt;
            &lt;role&gt;
                &lt;externallyDefined&gt;false&lt;/externallyDefined&gt;
                &lt;name&gt;SUPER_MANAGER&lt;/name&gt;
                &lt;desc&gt;Super Manager description.&lt;/desc&gt;
            &lt;/role&gt;
             &lt;role&gt;
                &lt;externallyDefined&gt;false&lt;/externallyDefined&gt;
                &lt;name&gt;SUPER_DIRECTOR&lt;/name&gt;
            &lt;/role&gt;
        &lt;/roles&gt;
    &lt;/user&gt;
&lt;/users&gt;
</code></pre>
<p>My code until now:</p>
<pre><code>import lxml.etree as ET
import csv

# load file
tree = ET.parse('Format.xml')
# iterate through each user tag
users = tree.findall('.//user')

with open('user_list.csv', "wb") as csv_file:
    writer = csv.writer(csv_file, delimiter=',')
    for user in users:
        email = user.find('emailAddress').text
        enabled = user.find('enabled').text
        externallyDefined = user.find('externallyDefined').text
        fullName = user.find('fullName').text
        tenantId = user.find('tenantId').text
        username = user.find('username').text
        writer.writerow(email + ',' + enabled + ',' + externallyDefined + ',' + fullName + ',' + tenantId + ',' + username)
</code></pre>
<p>As you can tell - I am not a programmer or even close enough to that, so apologies should your eyes bleed - started learning python 3 weeks ago. My code is not working for several reasons:</p>
<ul>
<li>Each user can have from 1 to X amount of Roles so all the examples I managed to find have a standard amount of children.</li>
<li>Some user attributes might be missing so I get an error when not found.</li>
<li>Some attributes are repeating themselves e.g. ExternallyDefined in both user and role!</li>
<li>My loops export each letter to a separate cell but that is something I believe I can solve.</li>
</ul>
<p>My end goal would be something like this:</p>
<p><img alt="Excel Image" src="https://i.stack.imgur.com/T2yLR.png"/></p>
<p>Any help/direction how I will tackle any of these issues will be greatly appreciated as I am completely lost at this point. Have a great weekend! </p>
</div>
<div class="post-text" itemprop="text">
<p>try something like this:</p>
<pre><code>import lxml.etree as ET
import csv

# load file
tree = ET.parse('users.xml')
# iterate through each user tag
users = tree.findall('.//user')

# just w mode, no wb. wb is for binary data
with open('user_list.csv', "w") as csv_file:
    writer = csv.writer(csv_file, delimiter=',')
    # write headers
    writer.writerow([
        'email', 'enabled', 'externallyDefined',
        'fullName', 'tenantId', 'username', 'director',
        'manager', 'user', 'super manager', 'super director'
        ])
    for user in users:
        email = user.find('emailAddress').text
        enabled = user.find('enabled').text

        # process optional element
        externallyDefined = user.find('externallyDefined')
        if externallyDefined is not None:
            externallyDefined = externallyDefined.text

        fullName = user.find('fullName').text

        # another optional element
        tenantId = user.find('tenantId')
        if tenantId is not None:
            tenantId = tenantId.text

        username = user.find('username').text

        # collect nested elements (roles)
        user_roles = {}
        roles = user.find('roles').findall('role')
        for role in roles:
            user_roles[role.find('name').text] = True

        writer.writerow([
            email, enabled, externallyDefined, fullName,
            tenantId,  username, user_roles.get('DIRECTOR'),
            user_roles.get('MANAGER'), user_roles.get('USER'),
            user_roles.get('SUPER_MANAGER'), user_roles.get('SUPER_DIRECTOR')
            ])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The general approach is simple. </p>
<ul>
<li>Iterate all users, </li>
<li>extract the values of a fixed set of XPath expressions per user, </li>
<li>write those values to a CSV file</li>
</ul>
<p>...which we can generalize as:</p>
<ul>
<li>Iterate all results of an initial XPath expression, </li>
<li>extract the values of a fixed set of XPath expressions per result, </li>
<li>return those as a nested list (i.e. "rows of columns")</li>
</ul>
<p>For this we basically need </p>
<ul>
<li>One function, let's call it <code>extract_val()</code>, that takes an XML node, runs XPath against it, and return the first found value.<br/>
This is necessary since lxml's <code>.xpath()</code> method <a href="http://lxml.de/xpathxslt.html#xpath-return-values" rel="nofollow noreferrer">can return</a> both simple values (strings, booleans, floats) and lists of nodes or values.</li>
<li>A function, let's say <code>xml_extract()</code>, that can take an XML document, iterate over objects and apply our <code>extract_val()</code> to each of them, returning a list of values</li>
<li>A list of XPaths we want to extract - this will correspond to our CSV columns later</li>
<li>Finally <code>csv.writerows()</code> to write them out all at once.</li>
</ul>
<p>In code:</p>
<pre><code>import lxml.etree as ET

def extract_val(context_node, xpath):
    '''Extracts one value from an XML node'''
    result = context_node.xpath(xpath)
    if isinstance(result, list):
        result = result[0] if len(result) &gt; 0 else None
    if isinstance(result, ET._Element):
        return result.text
    if isinstance(result, (bool, float, str)):
        return result

def xml_extract(tree_or_path, object_xpath, property_xpaths):
    '''Extracts lists of values from an XML tree (or path to an XML file)'''
    if isinstance(tree_or_path, ET._ElementTree):
        tree = tree_or_path
    if isinstance(tree_or_path, str):
        tree = ET.parse(tree_or_path)
    for elem in tree.xpath(object_xpath):
        yield [extract_val(elem, path) for path in property_xpaths]

#----------------------------------------------------------------------
import csv

with open('user_list.csv', 'w', encoding='utf8', newline='') as csv_file:
    writer = csv.writer(csv_file, delimiter=',')
    rows = xml_extract('Format.xml', '//user', [
        'emailAddress',
        'enabled',
        'externallyDefined',
        'fullName',
        'tenantId',
        'username',
        'count(roles/role[name = "DIRECTOR"]) &gt; 0',
        'count(roles/role[name = "MANAGER"]) &gt; 0',
    ])
    writer.writerows(rows)
</code></pre>
<p>This approach is flexible enough to extract tables of values from any XML, you might want to <a href="https://docs.python.org/3/tutorial/modules.html" rel="nofollow noreferrer">turn it into a module</a>, for reuse.</p>
</div>
<span class="comment-copy">You should include the desired output, especially for things that repeat themselves and for people with multiple roles.</span>
<span class="comment-copy">@Tomalak Thank you, I have added a screenshot of what we do manually for hundreds of users. Anything close to that would be fine!</span>
<span class="comment-copy">Thank you so much! The only problem [which is my fault for not explaining] is that the sample only contains lets say 5 Roles. Is there any way I can read all the unique roles from the XML and fill them in? If not, that is OK - I can still hardcode them!</span>
<span class="comment-copy">@HRG, yes it's possible. <a href="https://gist.github.com/nobbynobbs/1fa8c1fa959f2d3e70abbdaa76d6e827" rel="nofollow noreferrer">gist.github.com/nobbynobbs/1fa8c1fa959f2d3e70abbdaa76d6e827</a>  But I don't know if overhead will be significant or not (for large xml files).</span>
<span class="comment-copy">@HRG also, there is problem - roles columns would be in the random order, cuz i'm using set for collecting them. you can sort roles collection in alphabetical order if you want or just hardcode roles list.</span>
<span class="comment-copy">Thank you so much - The data set is quite small [less than 1000 users] so it takes less than a second to process. I think its perfect Thank you very much!</span>
