<div class="post-text" itemprop="text">
<p>My data is in the format of HH:MM:SS.milliseconds. How can I calculate average of such data in Python? I need average in form of miliseconds. I looked at several other similar postings but they do not answer my question.</p>
<pre><code>My data =  0:00:00.618000
           0:00:00.593000
           0:00:00.569000
           0:00:00.572000
           0:00:00.636000
           0:00:01
           0:00:01
           0:00:00.546000
           0:00:00.400000
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't know you data size or if you require a built-in solution or not.</p>
<p>However, one simple solution involves using <code>pandas</code>. If you have</p>
<pre><code>mydata = ["0:00:00.618000",
          "0:00:00.593000",
          "0:00:00.569000",
          "0:00:00.572000",
          "0:00:00.636000",
          "0:00:01",
          "0:00:01",
          "0:00:00.546000",
          "0:00:00.400000"]
</code></pre>
<p>You can use <code>pd.to_timedelta</code> and <code>mean</code> and just do</p>
<pre><code>pd.Series(pd.to_timedelta(mydata)).mean()
</code></pre>
<p>Might be/might not be overkill, but its really readable and straightforward.</p>
</div>
<div class="post-text" itemprop="text">
<p>The first step is to parse all those timestamps into something that you can perform arithmetic on. This can be <a href="https://docs.python.org/3/library/datetime.html#timedelta-objects" rel="nofollow noreferrer"><code>timedelta</code></a> objects, or integer microseconds (or milliseconds, since your times all have 0 micros), or float seconds, or any other reasonable type.</p>
<p>For example, assuming that input is one big string:</p>
<pre><code>ts = []
for h, m, s, u in re.findall(r'(\d+):(\d+):(\d+)(?:\.(\d+))?', bigstring):
    h, m, s = int(h), int(m), int(s)
    u = int(u) if u else 0
    ts.append(datetime.timedelta(hours=h, minutes=m, seconds=s, microseconds=u))
</code></pre>
<p>If it's a list of strings, or a file object, etc. just change it to iterate that and do <code>re.search</code> on each one, instead of iterating <code>re.findall</code>.</p>
<p>Then we can average them the same as any other values:</p>
<pre><code>sum(ts, datetime.timedelta()) / len(ts)
</code></pre>
<p>Since I used <code>timedelta</code> values, that's what the result will be:</p>
<pre><code>datetime.timedelta(0, 0, 659333)
</code></pre>
<p>… or, if you <code>print</code> it:</p>
<pre><code>0:00:00.659333
</code></pre>
<p>… or, if you want it as, say, a number of seconds, just call its <code>total_seconds()</code> method:</p>
<pre><code>0.659333
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It looks like the input consists of strings. Those should be converted to <a href="https://docs.python.org/3/library/datetime.html#datetime-objects" rel="nofollow noreferrer"><code>datetime.datetime</code></a> objects. Use <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime" rel="nofollow noreferrer"><code>datetime.datetime.strptime</code></a> to do that.</p>
<p>After that, the average of anything is calculated as <code>sum(values) / len(values)</code>, but unfortunately you cannot sum dates. What you can is sum date differences, so you'll have to make some conversions</p>
<p>For example:</p>
<pre><code>dates = [datetime.datetime(1951, 1, 5),
         datetime.datetime(1951, 1, 7),
         datetime.datetime(1951, 1, 7)]

base_datetime = datetime.datetime.now()  # really, anything

relative_dates = [d-base_datetime for d in dates]

average_relative_datetime = sum(relative_dates, datetime.timedelta()) / len(relative_dates)

result = base_datetime + average_relative_datetime  # datetime.datetime(1951, 1, 6, 8, 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming that each of these is a string, you can do the following using no libraries in both python 2 and 3</p>
<pre><code>def mean(numbers):
    return float(sum(numbers)) / max(len(numbers), 1)

def timestamp_to_millis(timestamp):
    hour, min, sec = map(float, timestamp.split(':'))
    mills = (((hour * 60 + min) * 60) + sec) * 1000
    return millis


my_data = # [ timestamps ... ]
my_mean = mean(map(timestamp_to_millis, my_data))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one approach using <code>datetime.timedelta</code>. The tricky part is converting strings into <code>timedelta</code> objects. Sequence unpacking makes this easier and efficient to implement.</p>
<pre><code>from datetime import timedelta

data = ['0:00:00.618000', '0:00:00.593000', '0:00:00.569000',
        '0:00:00.572000', '0:00:00.636000', '0:00:01',
        '0:00:01', '0:00:00.546000', '0:00:00.400000']

def converter(x):
    if '.' not in x:
        x += '.000000'
    hrs, mins, secs, millis = map(int, x[:-3].replace('.', ':').split(':'))
    return timedelta(hours=hrs, minutes=mins, seconds=secs, milliseconds=millis)

res = sum(map(converter, data), timedelta(0)) / len(data)

print(res)

0:00:00.659333
</code></pre>
<p>Note that <code>sum</code> only appears to work with <code>timedelta</code> objects with the added <code>timedelta(0)</code> argument, this trick <a href="https://stackoverflow.com/a/3617540/9209546">courtesy of @JochenRitzel</a>.</p>
</div>
<span class="comment-copy">First, your format has microseconds, not milliseconds (even though the last three digits are always 0, so they might as well be millis).</span>
<span class="comment-copy">Anyway: Convert them into <code>datetime.timedelta</code> objects, or integer microseconds or milliseconds, or float seconds, or any other type that can do basic arithmetic, and then you can average them the same way you'd average anything else: either with <code>statistics.mean</code>, or just <code>sum(times) / len(times)</code>.</span>
<span class="comment-copy">What have you tried? Hint: convert everything to pure millisecond representation</span>
<span class="comment-copy">Also, why have you tagged this with both -3.x and -2.7? Do you actually need code that works in both?</span>
<span class="comment-copy">@abarnert: I will try what you have suggested. I am a beginner in python. No, I don't want code in 3.x just in 2.7. I mistakely tagged 3.x. Thank you for your response.</span>
<span class="comment-copy">RafaelC: Thank you. Can we do something similar in list?</span>
<span class="comment-copy">If you want to implement it yourself, I'd recommend @abarnert 's answer :)</span>
<span class="comment-copy">@A.S This code already takes a list, and if you need the result to be a list instead of a <code>Series</code>, you can just call <code>list</code> on it.</span>
