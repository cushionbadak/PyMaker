<div class="post-text" itemprop="text">
<p>I am writing a program in python which contains many constant variables. I would like to create a file which will hold all these variables like .h file in C that contains many #define. I tried to use <a href="https://docs.python.org/3/library/configparser.html" rel="noreferrer">configparser</a> however I didn't find it easy and fun to use. </p>
<p>Do you know a better way? </p>
</div>
<div class="post-text" itemprop="text">
<p>Python does not allow constant declarations like C or C++.</p>
<p>Normally in Python, constants are capitalized (<a href="https://www.python.org/dev/peps/pep-0008/#constants" rel="nofollow noreferrer">PEP 8</a> standards) which helps the programmer know it's a constant. </p>
<p>Ex. <code>MY_CONSTANT = "Whatever"</code></p>
<p>Another valid way of doing it which I don't use but heard of, is using a method:</p>
<pre><code>def MY_CONSTANT():
    return "Whatever"
</code></pre>
<p>Now in theory, calling <code>MY_CONSTANT()</code> acts just like a constant.</p>
<p><strong>EDIT</strong></p>
<p>Like the comments says, someone can go and change the value by calling</p>
<pre><code>MY_CONSTANT = lambda: 'Something else'
</code></pre>
<p>but don't forget the same person can call <code>MY_CONSTANT = "Something else"</code> in the first example and change the initial value. In both cases it is unlikely but possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are no constants in Python, the way they exist in C or Java. You can imitate them by functions:</p>
<pre><code>def FOO():
  return "foo"
</code></pre>
<p>You can wrap the function call in a property, and thus make it look like a variable:</p>
<pre><code>class Const:
  @property
  def FOO(self):
    return "foo"

CONST = Const()  # You need an instance

if something == CONST.FOO:
  ...
</code></pre>
<p>With a bit of meta stuff, one can get unsettable attributes with a terse syntax:</p>
<pre><code>def const(cls):
    # Replace a class's attributes with properties,
    # and itself with an instance of its doppelganger.
    is_special = lambda name: (name.startswith("__") and name.endswith("__"))
    class_contents = {n: getattr(cls, n) for n in vars(cls) if not is_special(n)}
    def unbind(value):  # Get the value out of the lexical closure.
        return lambda self: value
    propertified_contents = {name: property(unbind(value))
                             for (name, value) in class_contents.items()}
    receptor = type(cls.__name__, (object,), propertified_contents)
    return receptor()  # Replace with an instance, so properties work.


@const
class Paths(object):
    home = "/home"
    null = "/dev/null"
</code></pre>
<p>Now you can access <code>Paths.home</code> as a normal value, but can't assign to it. You can define several classes decorated with <code>@const</code>, as you might use several <code>.h</code> files.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use something like this:</p>
<p>Files structure:</p>
<pre><code>myapp/
    __init__.py
    settings.py
    main.py
</code></pre>
<p>settings.py</p>
<pre><code>CONST_A = 'A'
CONST_B = 'B'
</code></pre>
<p>__init__.py</p>
<pre><code>from . import settings as global_settings


class Settings:

def __init__(self):
    for setting in dir(global_settings):
        if setting.isupper():
            setattr(self, setting, getattr(global_settings, setting))

def __setattr__(self, attr, value):
    if not getattr(self, attr, None):
        super().__setattr__(attr, value)
    else:
        raise TypeError("'constant' does not support item assignment")


settings = Settings()
</code></pre>
<p>main.py</p>
<pre><code>import settings

print(settings.CONST_A)  # prints A

settings.CONST_A = 'C'  # raises TypeError error

print(settings.CONST_A)  # prints A

settings.CONST_C = 'C'  # also able to add new constants
print(settings.CONST_C)  # prints C
</code></pre>
<p>Overwritten __setattr__ in <em>Settings</em> class makes all the attributes read-only.
The only requirement is to have all the constants in your <strong>settings.py</strong> written in capital letters.
But be aware, that it's not gonna work if you import variables directly:</p>
<pre><code>from settings import CONST_A

print(settings.CONST_A)  # prints A

settings.CONST_A = 'C'  # sets C

print(settings.CONST_A)  # prints C
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python isn't preprocessed. You can just create a file constant.py</p>
<pre><code>#!/usr/bin/env python
# encoding: utf-8
"""
constant.py
"""

MY_CONSTANT = 50
</code></pre>
<p>Import constant.py file when ever you want constant values like below example.</p>
<pre><code>#!/usr/bin/env python
# encoding: utf-8
"""
example.py
"""
import constant
print constant.MY_CONSTANT * 2
</code></pre>
<p>This way you can use constants across project.</p>
<p>You also have the option, if the constants are tied to a particular class and used privately within that class of making them specific to that class:</p>
<pre><code>class Foo(object):
   GOOD = 0
   BAD = 1

   def __init__(self...
</code></pre>
<p>If you want to define and use entire module, making them on top of the module</p>
<pre><code>PIE = 3.47

class Foo(object):
   def __init__(self...
</code></pre>
</div>
<span class="comment-copy">As far as configuration variables go, you can set environment variables and read them from within your code.  You could also use JSON or YAML files.</span>
<span class="comment-copy">related post: <a href="https://stackoverflow.com/questions/2682745/how-do-i-create-a-constant-in-python" title="how do i create a constant in python">stackoverflow.com/questions/2682745/…</a></span>
<span class="comment-copy"><code>MY_CONSTANT = lambda: 'Something else'</code> – Not sure why you'd bother with a "constant function", it's not any more constant.</span>
<span class="comment-copy">@scharette The point is that whether you use <code>def</code> or <code>lambda</code>, you can still easily change the value of <code>MY_CONSTANT</code>; it's just a name that refers to some object, whether that object be an <code>int</code> or a <code>function</code>. Plus, the overhead of calling a function (both the lexical overhead of having to add <code>()</code> and the run-time overhead of setting up the stack frame) outweigh any perceived benefit.</span>
<span class="comment-copy"><code>MY_CONSTANT = lambda: "new value"!</code> is just as easy to write as <code>MY_CONSTANT = "new value!"</code>; making it a function doesn't do anything useful.</span>
<span class="comment-copy">You're right, this is not how I understood what he meant. I'm not trying to say this is a real constant, he's asking for C like constants, which doesn't exist in built-in python. My point is if someone is calling <code>MY_CONSTANT = lambda: 'Something else'</code> he really wants to change the value.</span>
<span class="comment-copy">Samething goes for someone changing the constant itself in C. I mean a constant is a constant until the day someone goes around and change the inital value...</span>
