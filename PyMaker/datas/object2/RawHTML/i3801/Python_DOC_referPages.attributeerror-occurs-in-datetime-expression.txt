<div class="post-text" itemprop="text">
<p>While following Python tutorials, I came to know about the built-in <code>repr()</code> function, which according to the official documentation:</p>
<blockquote>
<p>Returns a <strong>string</strong> containing a printable representation of an object. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to <code>eval()</code>, otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object. A class can control what this function returns for its instances by defining a <code>__repr__()</code> method.</p>
<p><a href="https://docs.python.org/3/library/functions.html#repr" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#repr</a></p>
</blockquote>
<p>To sum up, for many object types including most built-ins, <code>eval(repr(obj)) == obj</code> (or the equivalent  <code>obj == eval(repr(obj))</code> returns <strong>True</strong>, also mentioned in the above documentation. </p>
<p>But, while executing the following code, <code>AttributeError: type object 'datetime.datetime' has no attribute 'datetime'</code> occurs in the last statement i.e. <code>print(today == eval(repr(today))</code>.</p>
<pre><code>from datetime import datetime

s = 'Hello, Pythoneers'
print(s == eval(repr(s)))  # no errors here

today = datetime.now()
print(today == eval(repr(today))) # error occurs here
</code></pre>
<p>Can someone explain the reason behind this behavior?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>datetime</code> uses <code>datetime.datetime(...)</code> in the representation:</p>
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; datetime.datetime.now()
datetime.datetime(2018, 5, 27, 16, 46, 59, 491342)
</code></pre>
<p>That's the <em>module name</em>, followed by the class name, which is an attribute of the module:</p>
<pre><code>&gt;&gt;&gt; datetime
&lt;module 'datetime' from '/.../lib/python3.6/datetime.py'&gt;
&gt;&gt;&gt; datetime.datetime
&lt;class 'datetime.datetime'&gt;
</code></pre>
<p>The name <code>datetime</code> <em>in your example</em> doesn't reference the module but the class inside the module:</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime  # the form used in your question
&gt;&gt;&gt; datetime
&lt;class 'datetime.datetime'&gt;
</code></pre>
<p>Use <code>import datetime</code> instead, then use <code>today = datetime.datetime.now()</code>.</p>
<p><code>repr()</code> calls the <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer"><code>object.__repr__()</code> method</a>, which is not passed any information on how your code is referencing the class; so the instance can't adjust what string it generates. Even if more information was available, you wouldn't want to generate different strings <em>anyway</em>; do you really want to figure out what <code>fluzborx.datetime()</code> is when someone jokingly used <code>import datetime as fluzborx</code> somewhere?</p>
<p>Note that the goal of <code>repr()</code> is to <em>aid debugging</em>, not to provide full serialisation support of data types. If you want to serialise <code>datetime</code> instances, use a proper serialisation format such as <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer"><code>pickle</code></a>, or write your own datetime -&gt; string and string -&gt; datetime conversions (e.g. for JSON, perhaps use ISO8601 string conversions).</p>
</div>
<span class="comment-copy"><code>datetime</code> uses <code>datetime.datetime(...)</code> in the representation. The name <code>datetime</code> <i>in your example</i> doesn't reference the module but the class inside the module. Use <code>import datetime</code> instead, then use <code>today = datetime.datetime.now()</code>.</span>
