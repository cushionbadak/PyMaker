<div class="post-text" itemprop="text">
<p>Please, how can I get all these binary permutations, but without repetition in Python?</p>
<pre><code> a = list(itertools.permutations([1, 1, 0, 0]))
 for i in range(len(a)):
     print a[i]

    (1, 1, 0, 0)
    (1, 1, 0, 0)
    (1, 0, 1, 0)
    ...
</code></pre>
<p>It would be great if it would be roughly efficient since I'll have to do that with a list of even 30 elements like this.</p>
</div>
<div class="post-text" itemprop="text">
<p>As @Antti said in a comment, this is equivalent to looking for <code>combinations</code> of positions of the input list which determine which bits in the output are 1.</p>
<pre><code>from itertools import combinations

def binary_permutations(lst):
    for comb in combinations(range(len(lst)), lst.count(1)):
        result = [0] * len(lst)
        for i in comb:
            result[i] = 1
        yield result

for perm in binary_permutations([1, 1, 0, 0]):
    print(perm)
</code></pre>
<p>Output:</p>
<pre><code>[1, 1, 0, 0]
[1, 0, 1, 0]
[1, 0, 0, 1]
[0, 1, 1, 0]
[0, 1, 0, 1]
[0, 0, 1, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's the algorithm from <a href="https://stackoverflow.com/a/2075867/918959">the accepted answer to the generic algorithm question</a>, adapted into Python 3 (should work in Python 2.7+). The function <code>generate(start, n_bits)</code> will generate all <em>n-bit</em> integers starting from <code>start</code> lexicographically.</p>
<pre><code>def generate(start, n_bits):
    # no ones to permute...
    if start == 0:
        yield 0
        return

    # fastest count of 1s in the input value!!
    n_ones = bin(start).count('1')

    # the minimum value to wrap to when maxv is reached;
    # all ones in LSB positions
    minv = 2 ** n_ones - 1

    # this one is just min value shifted left by number of zeroes
    maxv = minv &lt;&lt; (n_bits - n_ones)

    # initialize the iteration value
    v = start

    while True:
        yield v

        # the bit permutation doesn't wrap after maxv by itself, so,
        if v == maxv:
            v = minv

        else:
            t = ((v | ((v - 1))) + 1)
            v = t | (((((t &amp; -t)) // ((v &amp; -v))) &gt;&gt; 1) - 1)

        # full circle yet?
        if v == start:
            break

for i in generate(12, 4):
    print('{:04b}'.format(i))
</code></pre>
<p>Prints</p>
<pre><code>1100
0011
0101
0110
1001
1010
</code></pre>
<p>If list output is generated, this can then be decorated:</p>
<pre><code>def generate_list(start):
    n_bits = len(start)
    start_int = int(''.join(map(str, start)), 2)

    # old and new-style formatting in one
    binarifier = ('{:0%db}' % n_bits).format

    for i in generate(start_int, n_bits): 
        yield [int(j) for j in binarifier(i)]

for i in generate_list([1, 1, 0, 0]):
    print(i)
</code></pre>
<p>prints</p>
<pre><code>[1, 1, 0, 0]
[0, 0, 1, 1]
[0, 1, 0, 1]
[0, 1, 1, 0]
[1, 0, 0, 1]
[1, 0, 1, 0]
</code></pre>
<p>What is nice about this algorithm is that you can <em>resume</em> it at any point. If you find a way to calculate good starting points, it is possible to parallelize too. And the <em>numbers</em> should be more compact than lists, so you could use them if possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you are trying to do is choose two positions at which the element will be <code>1</code>.</p>
<h2>Code</h2>
<pre><code>from itertools import combinations

def bit_patterns(size, ones):
    for pos in map(set, combinations(range(size), ones)):
        yield [int(i in pos) for i in range(size)]
</code></pre>
<h2>Output</h2>
<pre><code>&gt;&gt;&gt; print(*bit_patterns(4, 2), sep='\n')
[1, 1, 0, 0]
[1, 0, 1, 0]
[1, 0, 0, 1]
[0, 1, 1, 0]
[0, 1, 0, 1]
[0, 0, 1, 1]
</code></pre>
<h2>Alternative</h2>
<p>A fun alternative is to see the desired output as the binary representations which have only two ones. We can use this definition to get the output you want.</p>
<pre><code>from itertools import combinations

def bit_patterns(size, ones):
    for t in combinations([1 &lt;&lt; i for i in range(size)], ones):
        yield [int(n) for n in f'{sum(t):0{size}b}']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a recursive solution:</p>
<pre><code>def bin_combs_iter(ones, zeros):
    if not zeros:
        yield [1] * ones
    elif not ones:
        yield [0] * zeros
    else:
        for x in bin_combs_iter(ones - 1, zeros):
            x.append(1)
            yield x
        for x in bin_combs_iter(ones, zeros - 1):
            x.append(0)
            yield x


def bin_combs(ones, zeros):
    return list(bin_combs_iter(ones, zeros))
</code></pre>
</div>
<span class="comment-copy">I.e. you're asking for "binary numbers of length N and exactly M bits set"</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/1851134/generate-all-binary-strings-of-length-n-with-k-bits-set?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" title="generate all binary strings of length n with k bits set">stackoverflow.com/questions/1851134/…</a></span>
<span class="comment-copy">The idea of permutations of values with duplicates is ambiguous about the discernibility of the duplicates. As <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer">the docs</a> explain, <code>itertools.permutations</code> chooses always discernible, because that's the hard one. Because the easy one—the one you want–is just… what @AnttiHaapala said.</span>
<span class="comment-copy">@AlexHall but it is algorithm, not Python. SIGH.</span>
<span class="comment-copy">Related: <a href="//stackoverflow.com/q/6284396">permutations with unique values</a></span>
<span class="comment-copy">It will be good not to take the MCVE too literally, for example, if the code can still do something sensible with an input like <code>[1, 1, 0, 0, 'potato']</code>.</span>
<span class="comment-copy">This is fascinating and I'm glad you did it, but I'd feel uncomfortable using it as I have no idea why it works. The source doesn't explain why, so to some extent I'm just blindly trusting that it works. It would be nice to see it thoroughly tested against one of the other methods. A performance comparison would also help justify it.</span>
<span class="comment-copy">@AlexHall it is simple: you just count the number of digits, generate powers of 2 up to N - 1; then count number of ones; change the <b>2</b> and 4 accordingly</span>
<span class="comment-copy">You need to call <code>bin_combs_iter</code> recursively, not <code>bin_combs</code>, or you'll use lots of memory for large inputs.</span>
