<div class="post-text" itemprop="text">
<p>Why Python Descriptor Work for Class Level Attribute and not for an Instance Level Attribute.</p>
<pre><code>class PropDescriptor:

    def __init__(self,*args):
        print("Init {} {}".format(type(self),args))
        self.value = 0

    def __get__ (self,instance,owner):
        print("get using descriptor")
        return instance.instance_att

    def __set__(self, instance, value):
        print("set using descriptor")
        instance.instance_att = value


class TestClass:
    class_att = PropDescriptor()

    def __init__(self):
        self.instance_att = PropDescriptor()



t = TestClass()
print("set instance level...")
t.instance_att = 3

print("\nget instance level...")
print(t.instance_att)

print("\nset class level...")
t.class_att = 4

print("\nget class level...")
print(t.class_att)
</code></pre>
<p>Output:</p>
<pre><code>Init &lt;class '__main__.PropDescriptor'&gt; ()
Init &lt;class '__main__.PropDescriptor'&gt; ()
set instance level...

get instance level...
3

set class level...
set using descriptor

get class level...
get using descriptor
4
</code></pre>
<p>looks like the descriptor is not used for the <code>instance_att</code>. </p>
<p>I found this <a href="https://stackoverflow.com/questions/428264/why-do-managed-attributes-just-work-for-class-attributes-and-not-for-instance-at">identical</a> question, but it doesn't really answer the question All answers refer the second question in the post.   </p>
<p><a href="https://docs.python.org/3/reference/datamodel.html#invoking-descriptors" rel="nofollow noreferrer">The Python documentation</a> specifys:</p>
<blockquote>
<p><strong>Instance Binding</strong> </p>
<p>If binding to an object instance, a.x is transformed</p>
<p>into the call: <code>type(a).__dict__['x'].__get__(a, type(a))</code>.</p>
</blockquote>
<p>But:
The first part of the (my code equivalent) statement <code>type(t).__dict__["instance_att"]</code>, raises an <em>KeyError</em> as <code>type(t).__dict__</code> does not have such an attribute. It is an instance level att. Isn't it?</p>
<p>What am I missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>The quick answer: <code>t.instance_att</code> is handled by <code>object.__getattribute__</code>, and its definition simply ignores the value's <code>__get__</code> and <code>__set__</code> methods when it is found in the instance dictionary of <code>t</code>.</p>
<p>The longer answer starts with explaining how attribute lookups are handled. They aren't built into the language, but rather handled by the <code>__getattribute__</code> method of some class. Being rarely overridden, this almost always means <code>object.__getattribute__</code>, which is implemented in C by <a href="https://github.com/python/cpython/blob/3.6/Objects/object.c#L1035" rel="nofollow noreferrer"><code>_PyObject_GenericGetAttrWithDict</code></a>.</p>
<p>Rather than explain that algorithm in detail here, I refer you to <a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/" rel="nofollow noreferrer">https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/</a>, which has fantastic diagrams to explain both object-attribute lookup and class-attribute lookup.</p>
<hr/>
<p>There is at least one answer here at Stack Overflow with includes the diagram, but I cannot locate it at the moment, so I apologize for the off-site reference. I'll include a link (or possibly close this as a duplicate) if I can find it.</p>
</div>
<span class="comment-copy">What's the idea behind the fact that descriptors only support class level attributes and not instance level? Is there one?</span>
<span class="comment-copy">I'm going to delete my answer for now, as I can't find a concrete explanation for what right now is just my opinion as to why you get the observed behavior.</span>
<span class="comment-copy">I've completely rewritten the answer to emphasize that the observed behavior is simply a consequence of how <code>object.__getattribute__</code> is implement, which <i>reflects</i> the intended use of descriptors without making it a language-level decision. You could override <code>__getattribute__</code> to do whatever you want for your class.</span>
<span class="comment-copy">This is a technical explanation for how attribute lookup is conducted.But it does not explain the logic behind. Why class level descriptor is working whereas instance level is handled differently.</span>
