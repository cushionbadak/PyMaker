<div class="post-text" itemprop="text">
<p>Python provides the feature of overloading <code>==</code> operator AND <code>!=</code> operator. But, why? Isn't it enough to overload <code>==</code> and <code>!=</code> is automatically the opposite (in truth value) of <code>==</code>? </p>
<p>Shouldn't the result of one imply the other automatically?</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't <em>have</em> to, python isn't forcing you to. In fact, the <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow noreferrer">documentation</a> explains the what and why:</p>
<blockquote>
<p>By default, <code>__ne__()</code> delegates to <code>__eq__()</code> and inverts the result
  unless it is <code>NotImplemented</code>. There are no other implied relationships
  among the comparison operators, for example, the truth of (<code>x&lt;y</code> or <code>x==y</code>) does not imply <code>x&lt;=y</code>.</p>
</blockquote>
<p>In general, the truth of <code>x==y</code> does not have need to imply that <code>x!=y</code> is false. If your data model needs to reflect this relationship, python lets you do so with minimal headache.</p>
<p>Note that for earlier versions of python, not even this relationship was implied. For example, </p>
<pre><code>class Foo:
    def __init__(self, val):
        self.val = val

    def __eq__(self, other):
        return self.val == other.val

f1, f2 = Foo(1), Foo(1)
</code></pre>
<p>Now, <code>f1 == f2</code> returns <code>True</code> on any version. HOWEVER,  <code>f1 != f2</code> returns <code>False</code> on python-3.x, but <code>True</code> on python-2.x (because <code>__ne__</code> is not implied on python-2.x, and in general two user defined objects are not equal if their IDs are not the same, i.e., not the same object).  </p>
</div>
<span class="comment-copy">Say you have <code>x = 1</code> and <code>y = 2</code>, it is indeed useless to do <code>if x == 1 and x != 2</code>, however checking <code>if x == 1 and x != y</code> is another story, if there is the possibility of <code>x = y</code>.</span>
<span class="comment-copy">Imagine a filter in an ORM for a database. With both operators overloaded there can be different SQL generated for them.</span>
<span class="comment-copy">Note: This isn't a <i>bad</i> question. With a little rephrasing, this is a good question highlighting a particular design feature of python.</span>
<span class="comment-copy">Thnx. I didn't even check the documentation. My bad. Thank you.</span>
<span class="comment-copy"><code>In general, the truth of x==y does not have need to imply that x!=y is false.</code> Can you give an example when such a model might be useful?</span>
<span class="comment-copy">@Truth-seek I may not be the best person to answer that question, but take a look at this <a href="https://stackoverflow.com/questions/50548843/why-overload-both-equality-and-inequality-operator/50548858#comment88108500_50548843">comment</a> by Klaus D.</span>
