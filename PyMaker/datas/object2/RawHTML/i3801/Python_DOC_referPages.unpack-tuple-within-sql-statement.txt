<div class="post-text" itemprop="text">
<p>I am using <code>Python</code> and <code>PyMySQL</code>. I want to fetch a number of items from a  MySQL database according to their ids:</p>
<pre><code>items_ids = tuple([3, 2])
sql = f"SELECT * FROM items WHERE item_id IN {items_ids};"
</code></pre>
<p>I am using the formatted string literals (<code>f" "</code>, <a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498" rel="nofollow noreferrer">https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498</a>) to evaluate the tuple inside the SQL statement.</p>
<p>However,I want to get back the items in the order specified by the tuple so firstly the item with <code>item_id = 3</code> and then the item with <code>item_id = 2</code>. To accomplish this I have to use the <code>ORDER BY FIELD</code> clause (see also here: <a href="https://stackoverflow.com/questions/396748/ordering-by-the-order-of-values-in-a-sql-in-clause?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa">Ordering by the order of values in a SQL IN() clause</a>). </p>
<p>But if I write something like this:</p>
<pre><code>items_ids = tuple([3, 2])
sql = f"SELECT * FROM items WHERE item_id IN {items_ids} ORDER BY FIELD{(item_id,) + items_ids};"
</code></pre>
<p>then <code>item_id</code> in the <code>ORDER BY FIELD</code> clause is considered as an undeclared python variable</p>
<p>and if I write something like this:</p>
<pre><code>items_ids = tuple([3, 2])
sql = f"SELECT * FROM items WHERE item_id IN {items_ids} ORDER BY FIELD{('item_id',) + items_ids};"
</code></pre>
<p>then <code>item_id</code> in the <code>ORDER BY FIELD</code> clause is considered as a string and not as a SQL variable and in this case <code>ORDER BY FIELD</code> does not do anything. </p>
<p><strong>How can I evaluate the tuple <code>(item_id,) + items_ids</code> in the SQL statement by maintaining <code>item_id</code> as a SQL variable in the <code>ORDER BY FIELD</code> clause?</strong></p>
<p>Obviously I can sort the items after they have returned from the database according to <code>items_ids</code> and without bothering so much with MySQL but I was just wondering how to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Please don't use f-strings, or any string formatting, for passing values to SQL queries. That's the road to <a href="https://en.wikipedia.org/wiki/SQL_injection" rel="nofollow noreferrer">SQL injection</a>. Now you may be thinking: "it's a tuple of integers, what bad could happen?" First of all a single element Python tuple's string representation is not valid SQL. Secondly, someone may follow the example with user controllable data other than tuples of ints (so having these bad examples online perpetuates the habit). Also the reason why you have to resort to your "cunning" solution is using the wrong tools for the job.</p>
<p>The correct way to pass values to SQL queries is to <a href="https://pymysql.readthedocs.io/en/latest/user/examples.html" rel="nofollow noreferrer">use placeholders</a>. In case of pymysql the placeholder is – a bit confusingly – <code>%s</code>. Don't mix it with manual %-formatting. In case of having to pass a variable amount of values to a query you do have to resort to some string building, but you build the placeholders, not the values:</p>
<pre><code>item_ids = (3, 2)
item_placeholders = ', '.join(['%s'] * len(item_ids))

sql = f"""SELECT * FROM items
          WHERE item_id IN ({item_placeholders})
          ORDER BY FIELD(item_id, {item_placeholders})"""

# Produces:
#
#     SELECT * FROM items
#     WHERE item_id IN (%s, %s)
#     ORDER BY FIELD(item_id, %s, %s)

with conn.cursor() as cur:
    # Build the argument tuple
    cur.execute(sql, (*item_ids, *item_ids))
    res = cur.fetchall()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A solution with <code>.format()</code> is the following:</p>
<pre><code>items_ids = tuple([3, 2])
items_placeholders = ', '.join(['{}'] * len(items_ids))

sql = "SELECT * FROM items WHERE item_id IN {} ORDER BY FIELD(item_id, {});".format(items_ids, items_placeholders).format(*items_ids)

# with `.format(items_ids, items_placeholders)` you get this: SELECT * FROM items WHERE item_id IN (3, 2) ORDER BY FIELD(item_id, {}, {});
# and then with `.format(*items_ids)` you get this: SELECT * FROM items WHERE item_id IN (3, 2) ORDER BY FIELD(item_id, 3, 2);
</code></pre>
<p>A rather tricky solution with <code>f-strings</code> is the following:</p>
<pre><code>sql1 = f"SELECT * FROM items WHERE item_id IN {item_ids} ORDER BY FIELD(item_id, "
sql2 = f"{items_ids};"
sql = sql1 + sql2[1:]

# SELECT * FROM items WHERE item_id IN (3, 2) ORDER BY FIELD(item_id, 3, 2);
</code></pre>
<p>But as <code>@IIija</code> mentions,  I may get a <code>SQL injection</code> with it because <code>IN {item_ids}</code> cannot  accommodate one-element tuples as such.</p>
<p>Additionally, using <code>f-strings</code> to unpack tuples in strings is perhaps more difficult than using <code>.format()</code> as others have mentioned before (<a href="https://stackoverflow.com/questions/38763895/formatted-string-literals-in-python-3-6-with-tuples?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa">Formatted string literals in Python 3.6 with tuples</a>) since you cannot use <code>*</code> to unpack a tuple within a <code>f-string</code>. However, perhaps you may come up with a solution for this (which is using a iterator?) to produce this </p>
<pre><code>sql = f"SELECT * FROM items WHERE item_id IN ({t[0]}, {t[1]}) ORDER BY FIELD(item_id, {t[0]}, {t[1]});"
</code></pre>
<p>even though I do not have the solution for this in my mind right now. You are welcome to post a solution of this kind if you have it in your mind.</p>
</div>
<span class="comment-copy">Can you try this  sql = f"SELECT * FROM items WHERE item_id IN {items_ids} ORDER BY FIELD(item_id, {items_ids});" if you need item_ids in order you can use sql = f"SELECT * FROM items WHERE item_id IN {items_ids} ORDER BY FIELD(item_id, {sorted(items_ids)});"</span>
<span class="comment-copy">Thank you for your comment. <code>items_ids = tuple([3, 2])</code> is already a tuple so <code>(item_id, {items_ids})</code> throws an error for the SQL query.</span>
<span class="comment-copy">Thank you for your answer(upvote). I posted also an answer with using <code>.format()</code> and <code>f-strings</code>.</span>
<span class="comment-copy">The 1-tuple case fails in <code>f"... IN {item_ids} ..."</code>, because the string representation of  a Python tuple includes the comma. The point about SQL injection was that your particular case is possibly "safe", but that depends on the source of <code>items_ids</code> and it not allowing anything other than tuples of integers (not for example mixed tuples of ints and strings, from the user). On the other hand when using the driver's placeholders you simply don't have to worry about such things. Depending on your driver you get nice data conversions for free as well.</span>
<span class="comment-copy">Ok, thanks for the comment. I corrected it. :)</span>
<span class="comment-copy">By the way, if you can instantly see how you can built <code>sql = f"SELECT * FROM items WHERE item_id IN ({t[0]}, {t[1]}) ORDER BY FIELD(item_id, {t[0]}, {t[1]});"</code> in order to actually use the <code>f-strings</code> without risking any SQL injection then let me know please. Even though I suspect that this solution will rather more complex than yours and mine with <code>.format()</code></span>
<span class="comment-copy">The way to build safe SQL query strings using f-strings would be to quote the passed in values manually: <code>f"SELECT * FROM items WHERE item_id IN ({quote(t[0])}, {quote(t[1])})"</code>, but that gets annoying real fast and it is really easy to forget or get wrong (see: PHP). Or you could argue, that you're only using <code>int</code> values, so it's ok to just format them in... until they aren't. The way to avoid the risk of SQL injection is to use parameterized queries and let the DB-API driver handle the values.</span>
<span class="comment-copy">Yes, ok manually is obvious. But then obviously you cannot handle tuples of different lengths (without modifying again things manually).</span>
