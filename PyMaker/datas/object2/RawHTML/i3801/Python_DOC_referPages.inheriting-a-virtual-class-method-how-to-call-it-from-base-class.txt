<div class="post-text" itemprop="text">
<p>Let <code>B</code> inherit from <code>A</code>. Suppose that some of <code>B</code>'s behavior depends on the class attribute <code>cls_x</code> and we want to set up this dependency during construction of <code>B</code> objects. Since it is not a simple operation, we want to wrap it in a class method, which the constructor will call. Example:</p>
<pre class="lang-py prettyprint-override"><code>class B(A):
  cls_x = 'B'

  @classmethod
  def cm(cls):
    return cls.cls_x

  def __init__(self):
    self.attr = B.cm()
</code></pre>
<p>Problem: <code>cm</code> as well as <code>__init__</code> will always be doing the same things and their behavior must stay the same in each derived class. Thus, we would like to put them both in the base class and <strong>not</strong> define it in any of the derived classes. The only difference will be the caller of <code>cm</code> - either <code>A</code> or <code>B</code> (or any of <code>B1</code>, <code>B2</code>, each inheriting from <code>A</code>), whatever is being constructed. So what we'd like to have is something like this:</p>
<pre class="lang-py prettyprint-override"><code>class A:
  cls_x = 'A'

  @classmethod
  def cm(cls):
    return cls.cls_x

  def __init__(self):
    self.attr = ClassOfWhateverIsInstantiated.cm()  #how to do this?

class B(A):
  cls_x = 'B'
</code></pre>
<p>I feel like it's either something very simple I'm missing about Python's inheritance mechanics or the whole issue should be handled entirely differently.</p>
<p>This is different than <a href="https://stackoverflow.com/q/20925137/6919631">this</a> question as I do not want to override the class method, but move its implementation to the base class entirely.</p>
</div>
<div class="post-text" itemprop="text">
<p>Look at it this way: Your question is essentially "How do I get the class of an instance?". The answer to that question is to use the <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer"><code>type</code></a> function:</p>
<pre><code>ClassOfWhateverIsInstantiated = type(self)
</code></pre>
<p>But you don't even need to do that, because classmethods can be called directly through an instance:</p>
<pre><code>def __init__(self):
    self.attr = self.cm()  # just use `self`
</code></pre>
<p>This works because classmethods automatically look up the class of the instance for you. From <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>[A classmethod] can be called either on the class (such as <code>C.f()</code>) or on an instance
  (such as <code>C().f()</code>). The instance is ignored except for its class.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>For <code>ClassOfWhateverIsInstantiated</code> you can just use <code>self</code>:</p>
<pre><code>class A:
  cls_x = 'A'

  @classmethod
  def cm(cls):
    return cls.cls_x

  def __init__(self):
    self.attr = self.cm()  # 'self' refers to B, if called from B

class B(A):
  cls_x = 'B'

a = A()
print(a.cls_x) # = 'A'
print(A.cls_x) # = 'A'

b = B()
print(b.cls_x) # = 'B'
print(B.cls_x) # = 'B'
</code></pre>
<p>To understand this, just remember that class B is inheriting the <em>methods</em> of class A. So when <code>__init__()</code> is called during B's instantiation, it's called in the context of class B, to which <code>self</code> refers.</p>
</div>
<span class="comment-copy">I should have seen this link way earlier. To a programmer with a C/C++ background, the following is very enlightening: "<i>Class methods are different than C++ or Java static methods. If you want those, see <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow noreferrer">staticmethod()</a> in this section.</i>"</span>
<span class="comment-copy">This works but I'd like to understand why. Does it mean that <code>self</code> binds to the object as well as its class, depending on what is being requested (classmethod or normal)?</span>
<span class="comment-copy">B inherit's A's methods. Just imagine that the <code>__init__</code> method was defined in B.</span>
<span class="comment-copy">I understand that. I was confused by the fact that I can use classmethods both as <code>B.cm()</code> and <code>b.cm()</code>, and <code>self</code> will be automatically resolved for me, which @Aran-Fey explained in their answer.</span>
<span class="comment-copy">Oh I see. Yeah, there's no difference between <code>b.cm()</code> and <code>B.cm()</code></span>
