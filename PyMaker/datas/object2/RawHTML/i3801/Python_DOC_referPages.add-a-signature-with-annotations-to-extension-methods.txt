<div class="post-text" itemprop="text">
<p>When embedding Python in my application, and writing an extension type, I can add a <code>signature</code> to the method by using a properly crafted <code>.tp_doc</code> string.</p>
<pre><code>static PyMethodDef Answer_methods[] = {
  { "ultimate", (PyCFunction)Answer_ultimate, METH_VARARGS, 
    "ultimate(self, question='Life, the universe, everything!')\n"
    "--\n"
    "\n"
    "Return the ultimate answer to the given question." },
  { NULL }
};
</code></pre>
<p>When <code>help(Answer)</code> is executed, the following is returned (abbreviated):</p>
<pre><code>class Answer(builtins.object)
 |
 |  ultimate(self, question='Life, the universe, everything!')
 |      Return the ultimate answer to the given question.
</code></pre>
<p>This is good, but I'm using Python3.6, which has support for annotations.  I'd like to annotate question to be a string, and the function to return an int.  I've tried:</p>
<pre><code>static PyMethodDef Answer_methods[] = {
  { "ultimate", (PyCFunction)Answer_is_ultimate, METH_VARARGS, 
    "ultimate(self, question:str='Life, the universe, everything!') -&gt; int\n"
    "--\n"
    "\n"
    "Return the ultimate answer to the given question." },
  { NULL }
};
</code></pre>
<p>but this reverts to the <code>(...)</code> notation, and the documentation becomes:</p>
<pre><code> |  ultimate(...)
 |      ultimate(self, question:str='Life, the universe, everything!') -&gt; int
 |      --
 |
 |      Return the ultimate answer to the given question.
</code></pre>
<p>and asking for <code>inspect.signature(Answer.ultimate)</code> results in an exception.</p>
<pre><code>Traceback (most recent call last):
  File "&lt;string&gt;", line 11, in &lt;module&gt;
  File "inspect.py", line 3037, in signature
  File "inspect.py", line 2787, in from_callable
  File "inspect.py", line 2266, in _signature_from_callable
  File "inspect.py", line 2090, in _signature_from_builtin
ValueError: no signature found for builtin &lt;built-in method ultimate of example.Answer object at 0x000002179F3A11B0&gt;
</code></pre>
<p>I've tried to add the annotations after the fact with Python code:</p>
<pre><code>example.Answer.ultimate.__annotations__ = {'return': bool}
</code></pre>
<p>But the builtin method descriptors can't have annotations added this way.</p>
<pre><code>Traceback (most recent call last):
  File "&lt;string&gt;", line 2, in &lt;module&gt;
AttributeError: 'method_descriptor' object has no attribute '__annotations__'
</code></pre>
<p>Is there a way to add annotations to extension methods, using the C-API?</p>
<hr/>
<p>Argument Clinic looked promising and may still be very useful, but as of 3.6.5, it <a href="https://docs.python.org/3/howto/clinic.html#using-real-argument-clinic-converters-instead-of-legacy-converters" rel="nofollow noreferrer">doesn't support annotations</a>.</p>
<blockquote>
<p><code>annotation</code><br/>
  The annotation value for this parameter. Not currently supported, because PEP 8 mandates that the Python library may not use annotations.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<h3>TL;DR There is <em>currently</em> no way to do this.</h3>
<h2>How do signatures and C extensions work together?</h2>
<p>In theory it works like this (for Python C extension objects):</p>
<ul>
<li>If the C function has the "correct docstring" the signature is stored in the <code>__text_signature__</code> attribute.</li>
<li>If you call <code>help</code> or <code>inspect.signature</code> on such an object it parses the <code>__text_signature__</code> and tries to construct a signature from that.</li>
</ul>
<p>If you use the argument clinic you don't need to write the "correct docstring" yourself. The signature line is generated based on comments in the code. However the 2 steps mentioned before still happen. They just happen <em>to the automatically generated signature line</em>.</p>
<p>That's why built-in Python functions like <code>sum</code> have a <code>__text-signature__</code>s:</p>
<pre><code>&gt;&gt;&gt; sum.__text_signature__
'($module, iterable, start=0, /)'
</code></pre>
<p>The signature in this case is generated through the argument clinic based <a href="https://github.com/python/cpython/blob/v3.6.5/Python/bltinmodule.c#L2212-L2228" rel="nofollow noreferrer">on the comments around the <code>sum</code> implementation</a>.</p>
<h2>What are the problems with annotations?</h2>
<p>There are several problems with annotations:</p>
<ul>
<li><p>Return annotations break the contract of a "correct docstring". So the <code>__text_signature__</code> will be empty when you add a return annotation. That's a major problem because a workaround would necessarily involve re-writing the part of the CPython C code that is responsible for the docstring -&gt; <code>__text_signature__</code> translation! That's not only complicated but you would also have to provide the changed CPython version so that it works for the people using your functions.</p>
<p>Just as example, if you use this "signature":</p>
<pre><code>ultimate(self, question:str='Life, the universe, everything!') -&gt; int
</code></pre>
<p>You get:</p>
<pre><code>&gt;&gt;&gt; ultimate.__text_signature__ is None
True
</code></pre>
<p>But if you remove the return annotation:</p>
<pre><code>ultimate(self, question:str='Life, the universe, everything!')
</code></pre>
<p>It gives you a <code>__text_signature__</code>:</p>
<pre><code>&gt;&gt;&gt; ultimate.__text_signature__
"(self, question:str='Life, the universe, everything!')"
</code></pre></li>
<li><p>If you don't have the return annotation it still won't work because annotations are explicitly not supported (currently).</p>
<p>Assuming you have this signature:</p>
<pre><code>ultimate(self, question:str='Life, the universe, everything!')
</code></pre>
<p>It doesn't work with <code>inspect.signature</code> (the exception message actually says it all):</p>
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; inspect.signature(ultimate)
Traceback (most recent call last):
...
    raise ValueError("Annotations are not currently supported")
ValueError: Annotations are not currently supported
</code></pre>
<p>The function that is responsible for the parsing of <code>__text_signature__</code> is <a href="https://github.com/python/cpython/blob/v3.6.5/Lib/inspect.py#L1938-L2076" rel="nofollow noreferrer"><code>inspect._signature_fromstr</code></a>. In theory it could be possible that you <em>maybe</em> could make it work by monkey-patching it (return annotations still wouldn't work!). But maybe not, there are several places that make assumptions about the <code>__text_signature__</code> that may not work with annotations.</p></li>
</ul>
<h2>Would <a href="https://docs.python.org/c-api/function.html#PyFunction_SetAnnotations" rel="nofollow noreferrer"><code>PyFunction_SetAnnotations</code></a> work?</h2>
<p>In the comments this C API function was mentioned. However that deliberately doesn't work with C extension functions. If you try to call it on a C extension function it will raise a <code>SystemError: bad argument to internal function call</code>. I tested this with a small Cython Jupyter "script":</p>
<pre><code>%load_ext cython

%%cython

cdef extern from "Python.h":
    bint PyFunction_SetAnnotations(object func, dict annotations) except -1

cpdef call_PyFunction_SetAnnotations(object func, dict annotations):
    PyFunction_SetAnnotations(func, annotations)

&gt;&gt;&gt; call_PyFunction_SetAnnotations(sum, {})

---------------------------------------------------------------------------
SystemError                               Traceback (most recent call last)
&lt;ipython-input-4-120260516322&gt; in &lt;module&gt;()
----&gt; 1 call_PyFunction_SetAnnotations(sum, {})

SystemError: ..\Objects\funcobject.c:211: bad argument to internal function
</code></pre>
<p>So that also doesn't work with C extension functions.</p>
<h2>Summary</h2>
<p>So return annotations are completely out of the question currently (at least without distributing your own CPython with the program). Parameter annotations <em>could</em> work if you monkey-patch a private function in the <code>inspect</code> module. It's a Python module so it <em>could</em> be feasible, but I haven't made a proof-of-concept so treat this as a <em>maybe possible, but probably very complicated and almost certainly not worth the trouble</em>.</p>
<p>However you can always just wrap the C extension function with a Python function (just a very thing wrapper). This Python wrapper can have function annotations. It's more maintenance and a tiny bit slower but saves you all the hassle with signatures and C extensions. I'm not exactly sure but if you use Cython to wrap your C or C++ code it might even have some automated tooling (writing the Python wrappers automatically).</p>
</div>
<span class="comment-copy">First, could you switch to using <a href="https://docs.python.org/3/howto/clinic.html" rel="nofollow noreferrer">Argument Clinic</a> (or using a higher-level language like C++ or Rust that has nice wrappers that can generate all the boilerplate for you even more easily)?</span>
<span class="comment-copy">I believe if you're doing it all manually, you can't do it declaratively inside the <code>PyMethodDef</code>, you have to construct the function and then call <code>PyFunction_SetAnnotations</code> or something like that on the result, but honestly, I'd only use the raw C API for trivial things where adding annotations would be overkill, so I don't know.</span>
<span class="comment-copy">@abarnert I’ll have to look for those C++ wrappers.  It is a C++ project, and I switched to C files for the python C-API, so I could use <code>{ .tp_doc = "..." }</code> named structure initializer syntax when declaring the <code>PyTypeObject</code>s. (facepalm)  As well as at Argument Clinic, I’ll look into <code>PyFunction_SetAnnotations</code> too.  Thanks.</span>
