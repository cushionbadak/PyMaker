<div class="post-text" itemprop="text">
<p>How to code a program that shows me the item that appears most <strong>side-by-side</strong>?</p>
<p>Example:</p>
<pre><code>6 1 6 4 4 4 6 6
</code></pre>
<p>I want four, not six, because there are only two sixes together.</p>
<p>This is what I tried (from comments):</p>
<pre><code>c = int(input())
h = [] 
for c in range(c):
    h.append(int(input()))
final = []
n = 0    
for x in range(c-1):
    c = x
    if h[x] == h[x+1]:
        n+=1
        while h[x] != h[c]:
            n+=1
        final.append([h[c],n])
print(final)        
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Depends on what exactly you want for an input like</p>
<pre><code>lst = [1, 1, 1, 2, 2, 2, 2, 1, 1, 1]
</code></pre>
<p>If you consider the four <code>2</code> the most common, because it's the longest unbroken stretch of same items, then you can <a href="https://docs.python.org/3.5/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> same values and pick the one with <code>max</code> <code>len</code>:</p>
<pre><code>max((len(list(g)), k) for k, g in itertools.groupby(lst))
# (4, 2)  # meaning 2 appeared 4 times
</code></pre>
<p>If you are interested in the element that appears the most often next to itself, you can <code>zip</code> the list to get pairs of adjacent items, filter those that are same, pass them through a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a>, and get the <code>most_common</code>:</p>
<pre><code>collections.Counter((x,y) for (x,y) in zip(lst, lst[1:]) if x == y).most_common(1)
# [((1, 1), 4)]  # meaning (1,1) appeared 4 times
</code></pre>
<p>For your example of <code>6 1 6 4 4 4 6 6</code>, both will return <code>4</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code> maxcount=0; //store maximum number item side by side
num=-1; //store element with max count 
 for i=0 to n //loop through your array
        count=0; 
        in=i;
        while(arr[in++]==arr[i]){//count number of side by side same element
           count++;
        }
        maxcount=max(maxcount,count);
        num= maxcount==count? arr[i]:num;
        i=in-1;
endfor;
</code></pre>
</div>
<span class="comment-copy">Can you please show what did you try as of now?</span>
<span class="comment-copy">This : <a href="https://hastebin.com/gojegocobe.py" rel="nofollow noreferrer">hastebin.com/gojegocobe.py</a></span>
<span class="comment-copy">What do you mean "most side by side"? In a single batch? What is the "most side-by-side" in <code>1 1 1 2 2 2 2 1 1 1</code>?</span>
<span class="comment-copy">@tobias_k The 4 2s surely</span>
<span class="comment-copy">If you want something without any libraries, you can achieve this with a simple loop and some counting variables. Something along the lines of <a href="https://ideone.com/Mfn82g" rel="nofollow noreferrer">this</a>. Probably just easier to use <code>groupby</code> or <code>Counter</code> as shown below.</span>
