<div class="post-text" itemprop="text">
<p>I have JSON file which contains followingly encoded strings:</p>
<p><code>"sender_name": "Horn\u00c3\u00adkov\u00c3\u00a1",
</code></p>
<p>I am trying to parse this file using the <code>json</code> module. However I am not able to decode this string correctly.</p>
<p>What I get after decoding the JSON using <code>.load()</code> method is <code>'HornÃ\xadkovÃ¡'</code>. The string should be correctly decoded as <code>'Horníková'</code> instead.</p>
<p>I read the JSON specification and I understasnd that after <code>\u</code> there should be 4 hexadecimal numbers specifing <em>Unicode number</em> of character. But it seems that in this JSON file <em>UTF-8 encoded bytes</em> are stored as <code>\u</code>-sequences.</p>
<p>What type of encoding is this and how to correctly parse it in Python 3?</p>
<p>Is this type JSON file even valid JSON file according to the specification? </p>
</div>
<div class="post-text" itemprop="text">
<p>Your text is already encoded and you need to tell this to Python by using a <code>b</code> prefix in your string but since you're using json and the input needs to be string you have to decode your encoded text manually. Since your input is not byte you can use <code>'raw_unicode_escape'</code> encoding to convert the string to byte without encoding and prevent the <code>open</code> method to use its own default encoding. Then you can simply use aforementioned approach to get the desired result.</p>
<p>Note that since you need to do the encoding and decoding your have to read file content and perform the encoding on loaded string, then you should use <a href="https://docs.python.org/3/library/json.html#json.loads" rel="nofollow noreferrer"><code>json.loads()</code></a> instead of <a href="https://docs.python.org/3/library/json.html#json.load" rel="nofollow noreferrer"><code>json.load()</code></a>.</p>
<pre><code>In [168]: with open('test.json', encoding='raw_unicode_escape') as f:
     ...:     d = json.loads(f.read().encode('raw_unicode_escape').decode())
     ...:     

In [169]: d
Out[169]: {'sender_name': 'Horníková'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The JSON you are reading was written incorrectly and the Unicode strings decoded from it will have to be re-encoded with the wrong encoding used, then decoded with the correct encoding.</p>
<p>Here's an example:</p>
<pre><code>#!python3
import json

# The bad JSON you have
bad_json = r'{"sender_name": "Horn\u00c3\u00adkov\u00c3\u00a1"}'
print('bad_json =',bad_json)

# The wanted result from json.loads()
wanted = {'sender_name':'Horníková'}

# What correctly written JSON should look like
good_json = json.dumps(wanted)
print('good_json =',good_json)

# What you get when loading the bad JSON.
got = json.loads(bad_json)
print('wanted =',wanted)
print('got =',got)

# How to correct the mojibake string
corrected_sender = got['sender_name'].encode('latin1').decode('utf8')
print('corrected_sender =',corrected_sender)
</code></pre>
<p>Output:</p>
<pre><code>bad_json = {"sender_name": "Horn\u00c3\u00adkov\u00c3\u00a1"}
good_json = {"sender_name": "Horn\u00edkov\u00e1"}
wanted = {'sender_name': 'Horníková'}
got = {'sender_name': 'HornÃ\xadkovÃ¡'}
corrected_sender = Horníková
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Reencode to bytes, and then redecode to text.</p>
<pre><code>&gt;&gt;&gt; 'HornÃ\xadkovÃ¡'.encode('latin-1').decode('utf-8')
'Horníková'
</code></pre>
<blockquote>
<p>Is this type JSON file even valid JSON file according to the specification?</p>
</blockquote>
<p>No.</p>
<blockquote>
<p>A <em>string</em> is a sequence of zero or more <strong>Unicode characters</strong>, wrapped in double quotes, using backslash escapes <em>[emphasis added]</em>.</p>
</blockquote>
<p><a href="http://json.org/" rel="nofollow noreferrer">source</a></p>
<blockquote>
<p>A string is a sequence of <strong>Unicode code points</strong> wrapped with quotation marks (U+0022). [...] Any code point may be represented as a hexadecimal escape sequence [...] represented as a six-character sequence: a reverse solidus, followed by the lowercase letter u, followed by four hexadecimal digits that encode the code point <em>[emphasis added]</em>.</p>
</blockquote>
<p><a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf" rel="nofollow noreferrer">source</a></p>
<p>UTF-8 byte sequences are neither Unicode characters nor Unicode code points.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know enough about JSON to be able to say whether this is valid or not, but you can parse these strings using the <code>raw_unicode_escape</code> codec:</p>
<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; "Horn\u00c3\u00adkov\u00c3\u00a1".encode('raw_unicode_escape').decode('utf8')
'Horníková'
</code></pre>
</div>
<span class="comment-copy">Are you specifying an encoding when you open the file that's being passed to <code>json.load()</code>?</span>
<span class="comment-copy">@Will Keeling Yes, I tried with specifing encoding as utf-8, but also without specified the encoding - both options gave same result.</span>
<span class="comment-copy">Is it possible to do this incrementally (i.e. without reading the whole file first, encode it and then pass it to the JSON parser)?</span>
<span class="comment-copy">@SamuelePilleri That's in contradiction with the JSON file's nature. However there are couple of efforts out there to make that possible in some cases. Python doesn't support that by default.</span>
<span class="comment-copy">Not 100% sure why (isn't it a recursive descent parser?), anyway what I actually meant is if there is a way to progressively encode/decode the stream without loading it in memory first.</span>
<span class="comment-copy">Please see <a href="https://stackoverflow.com/questions/53242216/load-a-json-with-raw-unicode-escape-encoded-strings">this question</a></span>
