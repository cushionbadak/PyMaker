<div class="post-text" itemprop="text">
<p>Here are my strings :</p>
<pre><code>-rwxrwx--- Administrators/unknown      563092   0% 2018-05-29 02:16:49 E:/program files/bak fil/sql server (mssqlserver)/var/work.log

-rwxrwx--- kandep2/Domain Users      563092   0% 2018-05-29 02:16:49 E:/program files/bak fil/sql server (mssqlserver)/var/dummy.log
</code></pre>
<p>I would like to capture everything in a group except 0%.
So far, i have the following regex:</p>
<pre><code>([rwexXst-]+) ([^1-9]+) +(\d+)+.+? +(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) (.*)
</code></pre>
<p>This works for the first row, but it fails on the second row because second row username has a number in it. </p>
<p>How should i modify my regex to get output like this:</p>
<p>Group#1</p>
<pre><code>-rwxrwx---
Administrators/unknown
563092
2018-05-29 02:16:49
E:/program files/bak fil/sql server (mssqlserver)/var/work.log
</code></pre>
<p>Group #2</p>
<pre><code>-rwxrwx---
kandep2/Domain Users 
563092
2018-05-29 02:16:49
E:/program files/bak fil/sql server (mssqlserver)/var/dummy.log
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let me suggest <a href="https://docs.python.org/3/howto/regex.html#non-capturing-and-named-groups" rel="nofollow noreferrer">named groups</a>. Also, try and generalize your regex so you don't have to count exact spaces.</p>
<p>Try:</p>
<pre><code>pattern = re.compile(r'''(?P&lt;rw&gt;[rwexXst\-]+)\s+
(?P&lt;dir&gt;\w+(?:\s+\w+)?\/\w+(?:\s+\w+)?)\s+
(?P&lt;nums&gt;\d+)(?:.+\%)?\s+
(?P&lt;date&gt;\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\s+
(?P&lt;msg&gt;.*)$''', flags=re.M|re.X)

test_text = '''
-rwxrwx--- Administrators/unknown      563092   0% 2018-05-29 02:16:49 E:/program files/bak fil/sql server (mssqlserver)/var/work.log

-rwxrwx--- kandep2/Domain Users      563092   0% 2018-05-29 02:16:49 E:/program files/bak fil/sql server (mssqlserver)/var/dummy.log
'''

for i in re.finditer(test_text):
    match = re.search(i)
    if match:
        print(match.groupdict())
        print(match.groups())
</code></pre>
<p>Or the even simpler:</p>
<pre><code>for match in pattern.finditer(test_text):
    print(match.groupdict())
    print(match.groups())
</code></pre>
<p>Should give you:</p>
<pre><code>{'rw': '-rwxrwx---', 
 'dir': 'Administrators/unknown', 
 'nums': '563092', 
 'date': '2018-05-29 02:16:49', 
 'msg': 'E:/program files/backup agents for cluster groups/sql server (mssqlserver)/var/work.log'}
('-rwxrwx---', 
 'Administrators/unknown', 
 '563092', 
 '2018-05-29 02:16:49', 
 'E:/program files/bak fil/sql server (mssqlserver)/var/work.log')
{'rw': '-rwxrwx---', 
 'dir': 'kandep2/Domain Users', 
 'nums': '563092', 
 'date': '2018-05-29 02:16:49', 
 'msg': 'E:/program files/backup agents for cluster groups/sql server (mssqlserver)/var/dummy.log'}
('-rwxrwx---', 
 'kandep2/Domain Users', 
 '563092', '2018-05-29 02:16:49', 
 'E:/program files/bak fil/sql server (mssqlserver)/var/dummy.log')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a verbose expression with named capturing groups like so:</p>
<pre><code>(?P&lt;rights&gt;-[-rwx]+)\s+         # rights -&gt; one of -,r,w,x
(?P&lt;group&gt;(?:(?!\s{2,}).)+)\s+  # anything not two consecutive whitespaces
(?P&lt;uid&gt;\d+)\s+                 # only digits
(?:[\d%]+)\s+                   # digits and %
(?P&lt;date&gt;[- :\d]+)\s+           # the date
(?P&lt;filename&gt;.+)                # and the filename
</code></pre>
<p><hr/>
In <code>Python</code> this is:</p>
<pre><code>import re

data = """
-rwxrwx--- Administrators/unknown      563092   0% 2018-05-29 02:16:49 E:/program files/bak fil/sql server (mssqlserver)/var/work.log

-rwxrwx--- kandep2/Domain Users      563092   0% 2018-05-29 02:16:49 E:/program files/bak fil/sql server (mssqlserver)/var/dummy.log
"""

rx = re.compile(r'''
    (?P&lt;rights&gt;-[-rwx]+)\s+
    (?P&lt;group&gt;(?:(?!\s{2,}).)+)\s+
    (?P&lt;uid&gt;\d+)\s+
    (?:[\d%]+)\s+
    (?P&lt;date&gt;[- :\d]+)\s+
    (?P&lt;filename&gt;.+)''', re.M | re.X)

results = [m.groupdict() for m in rx.finditer(data)]
print(results)
</code></pre>
<p>This will yield</p>
<pre><code>[
    {'rights': '-rwxrwx---', 'group': 'Administrators/unknown', 'uid': '563092', 'date': '2018-05-29 02:16:49', 'filename': 'E:/program files/bak fil/sql server (mssqlserver)/var/work.log'}, 
    {'rights': '-rwxrwx---', 'group': 'kandep2/Domain Users', 'uid': '563092', 'date': '2018-05-29 02:16:49', 'filename': 'E:/program files/bak fil/sql server (mssqlserver)/var/dummy.log'}
]
</code></pre>
<p><hr/>
The idea is to capture anything of interest and to match (or use non-capturing groups) for the "garbage". See <a href="https://regex101.com/r/FdKPMD/1" rel="nofollow noreferrer"><strong>a demo for the expression on regex101.com</strong></a>.  </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Solution without regex.</strong></p>
<pre><code>from pprint import pprint

input_row = '-rwxrwx--- kandep2/Domain %Users      563092   0%% 2018-05-29 02:16:49 E:/program $files/bak fil/sql server (mssqlserver)/var/dummy.log'


def parse(value):
    v = value.index(':/')

    row = input_row[:v-1].strip()
    row = row.split()

    return {
        'rw': row.pop(0),
        'date': '%s %s' % (row.pop(-2), row.pop(-1)),
        'value': row.pop(-1),
        'nums': row.pop(-1),
        'msg': input_row[v-1:],
        'dir': ' '.join(row),
    }


pprint(parse(input_row))
</code></pre>
<p><strong>Result:</strong></p>
<pre><code>{'date': '2018-05-29 02:16:49',
 'dir': 'kandep2/Domain %Users',
 'msg': 'E:/program $files/bak fil/sql server (mssqlserver)/var/dummy.log',
 'nums': '563092',
 'rw': '-rwxrwx---',
 'value': '0%%'}
</code></pre>
</div>
<span class="comment-copy">Great!! what if i don't want dict style output but single units?</span>
<span class="comment-copy">@PetPan a regex match object has several choices for extracting the result, including by order with the <code>match.groups()</code> method.</span>
<span class="comment-copy">what would be one line regex to get all groups? if i don't want dict style output?</span>
<span class="comment-copy">@PetPan its listed in my previous comment: <code>match_variable.groups()</code></span>
<span class="comment-copy">@PetPan cleaned up a mistake in the pattern and added a simpler way to extract the data as well as added the <code>.groups()</code> we discussed in the comments</span>
