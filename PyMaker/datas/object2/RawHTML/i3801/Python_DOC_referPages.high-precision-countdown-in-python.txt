<div class="post-text" itemprop="text">
<p>I need to implement a countdown timer in python. I tried this, but the program get stuck and I have to do a forced quit.  For the same reason, I can't have an infinitive loop into the run() method. How can I do?</p>
<pre><code>class th(Thread):
    def __init__(self):
        Thread.__init__(self)

    def run(self):
        printer()

def printer():
    print(time.time()*1000.0)
    time.sleep(1)
    printer()

thread1 = th()
thread1.start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You didn't say which OS you're using, so I'll assume that you're using a system with a standard ANSI/VT100 terminal, so we can use ANSI escape sequences to move the cursor, etc. If you're using a non-standard OS these sequences may not work in your terminal.</p>
<p>This program displays the number of seconds since the program was launched, at the top of the terminal window. The time display is updated every 0.1 seconds. Beneath the time display there's an <code>input</code> prompt, which waits for the user to close the program.</p>
<pre><code>from time import perf_counter
from threading import Timer

# Some ANSI/VT100 Terminal Control Escape Sequences
CSI = '\x1b['
CLEAR = CSI + '2J'
CLEAR_LINE = CSI + '2K'
SAVE_CURSOR = CSI + 's'
UNSAVE_CURSOR = CSI + 'u'
GOTO_LINE = CSI + '%d;0H'

def emit(*args):
    print(*args, sep='', end='', flush=True)

start_time = perf_counter()
def time_since_start():
    return '{:.6f}'.format(perf_counter() - start_time)

def show_time(interval):
    global timer
    emit(SAVE_CURSOR, GOTO_LINE % 1, CLEAR_LINE, time_since_start(), UNSAVE_CURSOR)
    timer = Timer(interval, show_time, (interval,))
    timer.start()

# Set up scrolling, leaving the top line fixed
emit(CLEAR, CSI + '2;r', GOTO_LINE % 2)

# Start the timer loop
show_time(interval=0.1)

input('Press Enter to stop the timer:')
timer.cancel()

# Cancel scrolling
emit('\n', SAVE_CURSOR, CSI + '0;0r', UNSAVE_CURSOR)
</code></pre>
<p>This code was derived from <a href="https://stackoverflow.com/a/45164619/4014959">this previous answer of mine</a>.</p>
<hr/>
<p>Here's a more primitive version, with no cursor control, apart from using the <code>'\r'</code> Carriage Return control character, which should work on any system. You probably don't need the <code>flush=True</code> arg to <code>print</code>, depending on your terminal.</p>
<pre><code>from time import time as perf_counter
from threading import Timer

start_time = perf_counter()

def show_time(interval):
    global timer
    print('  {:.6f}'.format(perf_counter() - start_time), end='\r', flush=True)
    timer = Timer(interval, show_time, (interval,))
    timer.start()

# Start the timer loop
show_time(interval=0.1)

input(15 * ' ' + ': Press Enter to stop the timer.\r')
timer.cancel()
</code></pre>
</div>
<span class="comment-copy">can you show the complete code?</span>
<span class="comment-copy">"The program crashes" is not an acceptable problem description.</span>
<span class="comment-copy">How does it crash? Why are you inheriting Thread? You can use threading without making your own class</span>
<span class="comment-copy">Change the recursive call to a while loop</span>
<span class="comment-copy">How is that supposed to be a countdown timer? It counts up! BTW, <a href="https://stackoverflow.com/questions/41777880/functions-that-help-to-understand-jsondict-structure"><code>time.time</code></a> is <i>not</i> intended for use as a high precision timing function. See <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow noreferrer">time.perf_counter</a>.</span>
