<div class="post-text" itemprop="text">
<p>I have several Python classes I use for calling C-code, using <code>c-types</code>. The return struct looks something like the below example.</p>
<pre><code>import ctypes

class MyCClass(ctypes.Structure):
    _fields_ = [('n_values', ctypes.c_int),\
                ('values', ctypes.c_double * 5)]

    def __repr__(self):
        return """n_values : {0}, values : {1}""".format(self.n_values,\
                             self.values)

    def __len__(self):
        return self.n_values

    def __getitem__(self, key):
        return self.values[key]
</code></pre>
<p>The <code>values</code> array is fixed size to ease the call to C (using a variable size array here is not an option). The "actual" length of the array is controlled by the <code>n_values</code> variable. </p>
<p>For instance if <code>values</code> is an array of three numbers, say <code>1</code>, <code>2</code> and <code>3</code>,<code>values=[1, 2, 3, 0, 0]</code> and <code>n_values=3</code>.</p>
<p>This is all fine. The problem is when i implement <code>__len__</code> and <code>__getitem__</code>.</p>
<p>I want to be able to write code like this</p>
<pre><code>for value in my_class:
    #do something
</code></pre>
<p>But the iterator does not seem to "get" that the <code>values</code>-array is only <code>n_values</code> long. I.e. it does not seem to use <code>MyCClass.__len__</code> to halt the iteration. Instead it seems to iterate over the full length of <code>values</code>.</p>
<pre><code>my_class = MyCClass()

my_class.n_values = 3
sample_values = [1, 2, 3]
for i in range(3):
    my_class.values[i] = sample_values[i]

i = 0
for value in my_class:
    print(i)
    i += 1
0
1
2
3
4
</code></pre>
<p>I want </p>
<pre><code>i = 0
for value in my_class:
    print(i)
    i += 1
0
1
2
</code></pre>
<p>I know I can code </p>
<pre><code>for i in range(my_class):
    # do something with my_class[i]
</code></pre>
<p>but that is not what I want.</p>
<p>Does anybody know how to fix this?</p>
</div>
<div class="post-text" itemprop="text">
<p>With the old-school iterator types, the only way is to raise an <code>IndexError</code>:</p>
<pre><code>def __getitem__(self, key):
    if key &gt;= len(self):
        raise IndexError
    return self.values[key]
</code></pre>
<p>For a cleaner solution, consider using the more modern iteration protocol, i.e. returning an <em>iterator</em> instance from an <code>__iter__</code> method defined on your <em>iterable</em>.  That's documented <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">here</a>.</p>
</div>
<span class="comment-copy">define an <code>__iter__</code> method in MyCClass.</span>
<span class="comment-copy">Yes, because the "old" getitem based iterator protocol simply keeps going until it encounters an <code>IndexError</code>. Just implement the iterator protocol using <code>__iter__</code> and a generator, or perhaps using a custom iterator class that implements <code>__iter__</code> (returning self) and <code>__next__</code></span>
<span class="comment-copy">Worked like a charm. I'll read up on <code>__iter__</code>. Thanks.</span>
