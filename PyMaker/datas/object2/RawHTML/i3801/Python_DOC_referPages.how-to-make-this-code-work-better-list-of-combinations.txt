<div class="post-text" itemprop="text">
<pre><code>import random

def ordenar(inputx):
    inputx = list(inputx)
    inputx = sorted(inputx, key=int)
    return inputx

def get_numbers(totall):
    return random.sample(numeros, totall)

numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]

all_jogos = []
maximo_repetido = 9

vezes = 0

while True:
    numbers = get_numbers(15)
    for i in all_jogos:
        total_repetido = len(set(numbers).intersection(i))
        if total_repetido &lt;= maximo_repetido:
            vezes += 1
        else:
            vezes = 0
            break
    if vezes &gt;= len(all_jogos):
        all_jogos.append(numbers)
        print("%s," % ordenar(numbers))
</code></pre>
<p>Basically my intention is to generate lists of 15 numbers, so that there are no more than 9 numbers repeated between them (variable <code>maximo_repetido</code>), generating as many lists as possible. The comparison is made with all the lists contained in <code>all_jogos</code>, which grows with each loop as long as the condition is accepted.</p>
<p><strong>The problem</strong> is that all possible results can never occur, since validation / comparison is only done after generating 15 random numbers.</p>
<p>How do you make the condition / validation / comparison to be made when you are going to generate the numbers, forcing you to search for only the possible results?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations(iterable, n)</code></a> gives you all the <code>n</code>-length combinations of elements in <code>iterable</code>. That's what you want to use here.</p>
<pre><code>import itertools

numbers = range(1, 26)

combos = itertools.combinations(numbers, 15)
</code></pre>
<p><code>combos</code> is now an iterator (<em>not</em> a list, note, so if you need to read through it more than once you need to cast it explicitly) of all 15-length combinations of the numbers 1-25, and you can use A* or some other pathfinding algorithm to find the best possible solution.</p>
</div>
<span class="comment-copy">Side-note: <code>ordenar</code> can and should simplify to just <code>return sorted(inputx)</code>; the inputs are already sequences of integers, so <code>key=int</code> is redundant, and <code>sorted</code> already converts to a new <code>list</code> before sorting, so manually constructing a list with <code>list()</code> just means an extra pointless temporary list.</span>
<span class="comment-copy">That's true, thank you!</span>
<span class="comment-copy">note that there is <i>definitely</i> a mathematical solution for this that will run in constant time, but finding that solution is up to you!</span>
<span class="comment-copy">This code does not limit the maximum number of repeated items among all possible lists. (Maximum 9)</span>
<span class="comment-copy">@Geek right -- that's part of the job of your pathfinding algorithm (not included here). This problem is generalized to "How can I find out what combination of an iterator maximizes a certain utility function."</span>
<span class="comment-copy">Thanks, but it still is not solution to my problem. I have no idea how to end your code to work as I wish, since I am a beginner in python.</span>
<span class="comment-copy">Thank you, now I understand your idea :)</span>
