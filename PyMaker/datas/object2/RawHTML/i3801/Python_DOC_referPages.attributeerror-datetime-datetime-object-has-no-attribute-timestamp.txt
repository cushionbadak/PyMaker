<div class="post-text" itemprop="text">
<p><strong>Please Help - I keep receiving the following Traceback Error:</strong></p>
<p>Currently Running Python 2.0 </p>
<p>I'm attempting to utilize Python's Plotly library to display an infographic illustrating bitcoin prices. I've tried importing datetime at the top of my code but this doesn't appear to solve the problem. </p>
<pre><code>Traceback (most recent call last):
  File "project_one.py", line 165, in &lt;module&gt;
    crypto_price_df = get_crypto_data(coinpair)
  File "project_one.py", line 155, in get_crypto_data
    json_url = base_polo_url.format(poloniex_pair, start_date.timestamp(), end_date.timestamp(), pediod)
AttributeError: 'datetime.datetime' object has no attribute 'timestamp'
</code></pre>
<p><strong>My Code Starts Here</strong></p>
<pre><code>import numpy as np
import pandas as pd
from pandas import Series, DataFrame, Panel
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
import seaborn as sns
import sklearn as sk
import scipy as sp
import os
import pickle
import quandl
import datetime
import plotly.plotly as py
import plotly.graph_objs as go
import plotly.figure_factory as ff
from plotly import tools
from plotly.offline import iplot, init_notebook_mode
from IPython.display import display, HTML
init_notebook_mode(connected=True)


def get_quandl_data(quandl_id):

    cache_path = '{}.pkl'.format(quandl_id).replace('/','-')
    try:
        f = open(cache_path, 'rb')
        df = pickle.load(f)   
        print('Loaded {} from cache'.format(quandl_id))
    except (OSError, IOError) as e:
        print('Downloading {} from Quandl'.format(quandl_id))
        df = quandl.get(quandl_id, returns="pandas")
        df.to_pickle(cache_path)
        print('Cached {} at {}'.format(quandl_id, cache_path))
    return df


btc_usd_price_kraken = get_quandl_data('BCHARTS/KRAKENUSD')



exchanges = ['COINBASE','BITSTAMP','ITBIT']

exchange_data = {}

exchange_data['KRAKEN'] = btc_usd_price_kraken

for exchange in exchanges:
    exchange_code = 'BCHARTS/{}USD'.format(exchange)
    btc_exchange_df = get_quandl_data(exchange_code)
    exchange_data[exchange] = btc_exchange_df

def merge_dfs_on_column(dataframes, labels, col):

    series_dict = {}
    for index in range(len(dataframes)):
        series_dict[labels[index]] = dataframes[index][col]

    return pd.DataFrame(series_dict) 


btc_usd_datasets = merge_dfs_on_column(list(exchange_data.values()), 
list(exchange_data.keys()), 'Weighted Price')



def df_scatter(df, title, seperate_y_axis=False, y_axis_label='', 
scale='linear', initial_hide=False):

    label_arr = list(df)
    series_arr = list(map(lambda col: df[col], label_arr))

    layout = go.Layout(
        title=title,
        legend=dict(orientation="h"),
        xaxis=dict(type='date'),
        yaxis=dict(
            title=y_axis_label,
            showticklabels= not seperate_y_axis,
            type=scale
        )
    )

    y_axis_config = dict(
        overlaying='y',
        showticklabels=False,
        type=scale )

    visibility = 'visible'
    if initial_hide:
        visibility = 'legendonly'


    trace_arr = []
    for index, series in enumerate(series_arr):
        trace = go.Scatter(
            x=series.index, 
            y=series, 
            name=label_arr[index],
            visible=visibility
        )


        if seperate_y_axis:
            trace['yaxis'] = 'y{}'.format(index + 1)
            layout['yaxis{}'.format(index + 1)] = y_axis_config    
        trace_arr.append(trace)

    fig = go.Figure(data=trace_arr, layout=layout)
    py.plot(fig)



df_scatter(btc_usd_datasets, 'Bitcoin Price (USD) By Exchange')


btc_usd_datasets.replace(0, np.nan, inplace=True)


df_scatter(btc_usd_datasets, 'Bitcoin Price (USD) By Exchange')


btc_usd_datasets['avg_btc_price_usd'] = btc_usd_datasets.mean(axis=1)



btc_trace = go.Scatter(x=btc_usd_datasets.index, 
y=btc_usd_datasets['avg_btc_price_usd'])
py.plot([btc_trace])



def get_json_data(json_url, cache_path):

    try:        
        f = open(cache_path, 'rb')
        df = pickle.load(f)   
        print('Loaded {} from cache'.format(json_url))
    except (OSError, IOError) as e:
        print('Downloading {}'.format(json_url))
        df = pd.read_json(json_url)
        df.to_pickle(cache_path)
        print('Cached {} at {}'.format(json_url, cache_path))
    return df

# Helper Function that Generates Poloniex API HTTP requests
base_polo_url = 'https://poloniex.com/public? 
command=returnChartData&amp;currencyPair={}&amp;start={}&amp;end={}&amp;period={}'
start_date = datetime.datetime.strptime('2015-01-01', '%Y-%m-%d') # get 
data from the start of 2015
end_date = datetime.datetime.now() # up until today
pediod = 86400 # pull daily data (86,400 seconds per day)

def get_crypto_data(poloniex_pair):

    json_url = base_polo_url.format(poloniex_pair, start_date.timestamp(), end_date.timestamp(), pediod)
    data_df = get_json_data(json_url, poloniex_pair)
    data_df = data_df.set_index('date') 
    return data_df


altcoins = ['ETH','LTC','XRP','ETC','STR','DASH','SC','XMR','XEM']
altcoin_data = {}
for altcoin in altcoins:
    coinpair = 'BTC_{}'.format(altcoin)
    crypto_price_df = get_crypto_data(coinpair)
    altcoin_data[altcoin] = crypto_price_df
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp" rel="nofollow noreferrer"><code>timestamp</code></a> method was added in Python 3.3. So if you're using Python 2.0, or even 2.7, you don't have it. </p>
<p>There are backports of current <code>datetime</code> to older Python versions on PyPI, but none of them seems to be official, or up-to-date; you might want to try searching for yourself.</p>
<p>There are also a number of third-party replacement libraries that add functionality that isn't in (2.x) <code>datetime</code>, including the ability to convert to Unix timestamps.</p>
<hr/>
<p>You can just <a href="https://github.com/python/cpython/blob/3.6/Lib/datetime.py#L1547" rel="nofollow noreferrer">copy the function out of the source code from 3.3 or later</a>:</p>
<pre><code>def timestamp(self):
    "Return POSIX timestamp as float"
    if self._tzinfo is None:
        s = self._mktime()
        return s + self.microsecond / 1e6
    else:
        return (self - _EPOCH).total_seconds()
</code></pre>
<p>… but you will have to modify things a bit to get them to work, because:</p>
<ul>
<li><code>_EPOCH</code> is deleted at the end of the module.</li>
<li>The 3.x <code>_EPOCH</code> is a tz-aware object built with a proper UTC timezone, which you don't have in 2.x unless you're using a third-party library like <code>pytz</code>.</li>
<li>The <code>_mktime</code> method and <code>_tzinfo</code> attribute don't exist on 2.x <code>datetime</code>, so you need to simulate what they do as well.</li>
</ul>
<p>If you don't need the same function to work equally well for naive, GMT, and tz-aware datetimes, it won't be that hard, but it's still not quite trivial—and if you do need the full functionality, it's going to be more painful.</p>
<hr/>
<p>Or it may be easier to port the equivalent code given in <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp" rel="nofollow noreferrer">the docs</a>.</p>
<p>For aware <code>datetime</code> instances:</p>
<pre><code>(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()
</code></pre>
<p>Of course you still don't have that <code>timezone.utc</code>, but for this purpose, you don't need a full timezone object; you can use an instance of the example <code>UTC</code> class in the <a href="https://docs.python.org/2/library/datetime.html#datetime.tzinfo.fromutc" rel="nofollow noreferrer">2.x <code>tzinfo</code> docs</a>.</p>
<p>… for naive:</p>
<pre><code>timestamp = dt.replace(tzinfo=timezone.utc).timestamp()
</code></pre>
<p>… or:</p>
<pre><code>timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)
</code></pre>
<p>Since you don't have aware datetimes, that last one is all you need.</p>
<hr/>
<p>If your Python is old enough, <code>timedelta</code> may not have a <code>__div__</code> method. In that case (if you haven't found a backport), you have to do division manually as well, by calling <code>total_seconds</code> on each one, making sure at least one of them is a float, and dividing the numbers:</p>
<pre><code>timestamp = ((dt - datetime(1970, 1, 1)).total_seconds() / 
    float(timedelta(seconds=1).total_seconds()))
</code></pre>
<p>But in this particular case, it should be pretty obvious that the divisor is just going to be 1.0, and dividing by 1.0 is the same as doing nothing, so:</p>
<pre><code>timestamp = (dt - datetime(1970, 1, 1)).total_seconds()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As the other answers state, <code>datetime.timestamp()</code> was added on <strong>Python 3.3</strong>.</p>
<p>To get a similar behavior on Python &lt; 3.3, you need to use <code>time.mktime()</code>:</p>
<pre><code>import time

def to_seconds(date):
    return time.mktime(date.timetuple())
</code></pre>
<p>And then, instead of calling <code>start_date.timestamp()</code>, you just call <code>to_seconds(start_date)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>.timestamp()</code> method was added in python version 3.3 [<a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp" rel="nofollow noreferrer">source</a>], so you can't use <code>.timestamp()</code> in Python 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>All you need in Python 2.x is to use the method <code>time()</code> from the <code>time</code> module, like this:</p>
<pre><code>&gt;&gt;&gt; from time import time
&gt;&gt;&gt; time()
1535495731.95094
</code></pre>
<p>It will give you the same than the <code>timestamp()</code> method from a <code>datetime</code> object from Python 3.x:</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; datetime.now().timestamp()
1535495993.949849
</code></pre>
<p>But this is only valid when you need the current timestamp, not any timestamp.</p>
<p>Official doc: <a href="https://docs.python.org/2/library/time.html#time.time" rel="nofollow noreferrer">https://docs.python.org/2/library/time.html#time.time</a></p>
</div>
<span class="comment-copy">are you sure you're running python 2.0? it's probably 2.7</span>
<span class="comment-copy">The <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp" rel="nofollow noreferrer"><code>timestamp</code></a> method was added in Python 3.3. So if you're using Python 2.0, or even 2.7, you don't have it. You'll need to either get a backport off PyPI, <a href="https://github.com/python/cpython/blob/3.6/Lib/datetime.py#L1547" rel="nofollow noreferrer">copy the function out of the source code from 3.3 or later</a> (and possibly modify things a bit to get it to work), use a third-party library, or upgrade to a modern Python.</span>
<span class="comment-copy">When I execute in Python 2.7 the last example <code>(dt - datetime(1970, 1, 1)) / timedelta(seconds=1)</code>, I get the error <code>TypeError: unsupported operand type(s) for /: 'datetime.timedelta' and 'datetime.timedelta'</code>, and I don't know where I should get the variable / module <code>timezone</code> from the previous example.</span>
<span class="comment-copy">@MarianoRuiz Well, you could just use one of the other options instead of picking the only one that doesn't work on your version of Python… but if you want to know how to divide timedeltas in old Python, I've added another section in a new edit.</span>
<span class="comment-copy">Thanks @abarnert , the last examples worked in Python 2.7, and you explanation it's pretty clear</span>
<span class="comment-copy">This only works for naive datetimes. For which you don't need the <code>time</code> module in the first place; just <code>(date - epoch) / timedelta(seconds=1)</code>. (Well, it does work for aware datetimes if they happen to be in your local timezone, but that's not something to rely on.)</span>
<span class="comment-copy">in short this is the best implementation when you don't want to mess with time zones.</span>
