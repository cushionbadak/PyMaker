<div class="post-text" itemprop="text">
<p>Would I be better off using <code>memoryview</code>, <code>itertools.islice</code> or something else (e.g. <code>var = (start, stop)</code>) as a pointer in Python to a substring of a very large string?</p>
<p>Context: I have some very long strings that I need to manipulate (cut and paste substrings, etc.) without creating a new string each time.</p>
<p>I accomplish that by making a binary search tree in which each node represents a substring and then using split/merge operations (a Rope data structure).</p>
<p>Each node needs a reference attached to it to the substring of the original very large string that the node represents. (That's necessary so that, when I walk the tree in-order to produce the final edited string, I get back the parts of the original string in the amended sequence.)</p>
<p>I could attach a tuple representing start/stop values to each node and then use slicing <code>string[start:stop]</code>, but in C you would use a pointer and a character count.</p>
<p>Would it be better to do something similar in Python, either with <code>memoryview</code> or with <code>islice</code> or with something else?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not familiar enough with the rope data structure or your specific requirements to know how hard a requirement it is not to copy data around. For a lot of use cases having an extra copy in memory isn't a problem, but some optimizations or large files may require other solutions.</p>
<p>Of the options you listed, memoryview is the only one that won't create an additional copy in memory. See <a href="https://stackoverflow.com/questions/18655648/what-exactly-is-the-point-of-memoryview-in-python">this</a> question for more information, as well as an answer that includes an example of where memoryview can be useful. While it can speed up some operations, as in the case of the example, there may be better ways to approach the problem or structure your code that eliminate the need to begin with. Your use case and mileage may vary of course.</p>
<p>I also found some links talking about <a href="https://helpful.knobs-dials.com/index.php/Mmap" rel="nofollow noreferrer">memory mapped (mmap)</a> files, and <a href="https://helpful.knobs-dials.com/index.php/Python_usage_notes_-_struct,_buffer,_array,_bytes,_memoryview" rel="nofollow noreferrer">memoryview</a> (buffer in py2) interfaces. If you do end up needing zero-copy pointers I'd definitely suggest checking out the memoryview interface.</p>
</div>
<span class="comment-copy">How did you load the string into memory? If it's from the filesystem you might want to look into <a href="https://docs.python.org/3.6/library/mmap.html" rel="nofollow noreferrer"><code>mmap</code></a></span>
<span class="comment-copy">Thanks, @metatoaster, will do. At present, I'm reading test files into memory all at once and storing them as default unicode strings in python3. But in the future, I'd like to be able to handle large files in chunks.</span>
<span class="comment-copy">Oh, if you are doing actual human readable text manipulation this can be trickier, you might want to consider using <code>ctypes</code> directly, such as <a href="https://docs.python.org/3/library/ctypes.html#ctypes.create_unicode_buffer" rel="nofollow noreferrer"><code>ctypes.create_unicode_buffer</code></a> and work directly within it.</span>
<span class="comment-copy">I would vote for <code>memoryview</code> here, if you are fine with working with what are essentially bytes. <code>itertools.islice</code> will be memory efficient but will only allow a single pass, and will be slow</span>
