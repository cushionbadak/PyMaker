<div class="post-text" itemprop="text">
<pre><code>             A      B   C
0   2002-01-12  Sarah  39
1   2002-01-12   John  17
2   2002-01-12  Susan  30
3   2002-01-15  Danny  12
4   2002-01-15  Peter  25
5   2002-01-15   John  25
6   2002-01-20   John  16
7   2002-01-20   Hung  10
8   2002-02-20   John  20
9   2002-02-20  Susan  40
10  2002-02-24  Rebel  40
11  2002-02-24  Susan  15
12  2002-02-24   Mark  38
13  2002-02-24  Susan  30
</code></pre>
<p>I want to select full <code>A</code> groups that contain <code>John</code> and <code>Susan</code>.</p>
<p>Output should be:</p>
<pre><code>             A      B   C
0   2002-01-12  Sarah  39
1   2002-01-12   John  17
2   2002-01-12  Susan  30
6   2002-01-20   John  16
7   2002-01-20   Hung  10
8   2002-02-20   John  20
9   2002-02-20  Susan  40
</code></pre>
<p>I've tried:</p>
<pre><code>df.groupby('A').apply(lambda x: ((df.B == x.John) &amp; (df.B == x.Susan)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>groupby</code> + <code>transform</code> to create a flag for the groups that satisfy that condition. And then you can mask the original <code>df</code> by that flag. If you don't want to modify the original <code>df</code> you can create a separate <code>Series</code> named <code>flag</code>, otherwise you can also just assign it to a column in your original <code>df</code></p>
<pre><code>import pandas as pd
# As Haleemur Ali points out, use x.values to make it faster
flag = df.groupby('A').B.transform(lambda x: (x.values == 'Susan').any() &amp; (x.values == 'John').any())
</code></pre>
<p>Then you can filter the <code>df</code></p>
<pre><code>df[flag]
#            A      B   C
#0  2002-01-12  Sarah  39
#1  2002-01-12   John  17
#2  2002-01-12  Susan  30
#8  2002-02-20   John  20
#9  2002-02-20  Susan  40
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>create an array of dates as the intersection of dates that contain <code>John</code> &amp; dates that contain <code>Susan</code>:</p>
<pre><code>dates = np.intersect1d(
    df.A.values[df.B.values == 'John'], 
    df.A.values[df.B.values == 'Susan']
)
</code></pre>
<p>then use the dates array to filter the dataframe</p>
<pre><code>df[df.A.isin(dates)]

# outputs:
            A      B   C
0  2002-01-12  Sarah  39
1  2002-01-12   John  17
2  2002-01-12  Susan  30
8  2002-02-20   John  20
9  2002-02-20  Susan  40
</code></pre>
<h3>Timings:</h3>
<p>Comparing the solutions provided by <a href="https://stackoverflow.com/users/9209546/jpp">jpp</a>, <a href="https://stackoverflow.com/users/4333359/alollz">ALollz</a> and mine above:</p>
<p>The numpy based solution is several times more efficient than the others.</p>
<pre><code>In [288]: def hal(df):
     ...:     dates = np.intersect1d(
     ...:      df.A.values[df.B.values == 'John'], 
     ...:      df.A.values[df.B.values == 'Susan']
     ...:     )
     ...:     return df[df.A.isin(dates)]
     ...:

In [289]: def jpp(df):
     ...:     s = df.groupby('A')['B'].apply(set)
     ...:     return df[df['A'].map(s) &gt;= {'John', 'Susan'}]
     ...:

In [290]: def alollz(df):
     ...:     flag = df.groupby('A').B.transform(lambda x: ((x=='Susan').any() &amp; (x == 'John').any()).sum().astype('boo
     ...: l'))
     ...:     return df[flag==True]
     ...:

In [291]: %timeit hal(df)
394 µs ± 6.42 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

In [292]: %timeit jpp(df)
1.46 ms ± 27.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

In [293]: %timeit alollz(df)
4.9 ms ± 75 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
<p>However, the solution proposed by ALollz can be sped up 2X by omitting some extra unneeded operations and going down to numpy arrays for comparison.</p>
<pre><code>In [294]: def alollz_improved(df):
     ...:     v = df.groupby('A').B.transform(lambda x: (x.values=='Susan').any() &amp; (x.values=='John').any())
     ...:     return df[v]
     ...:

In [295]: %timeit alollz_improved(df)
2.2 ms ± 38.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Create a series mapping each date to a <code>set</code> of names. Then use <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.issuperset" rel="nofollow noreferrer"><code>set.issuperset</code></a> via syntactic sugar <code>&gt;=</code>:</p>
<pre><code>s = df.groupby('A')['B'].apply(set)

res = df[df['A'].map(s) &gt;= {'John', 'Susan'}]

print(res)

            A      B   C
0  2002-01-12  Sarah  39
1  2002-01-12   John  17
2  2002-01-12  Susan  30
8  2002-02-20   John  20
9  2002-02-20  Susan  40
</code></pre>
</div>
<span class="comment-copy"><code>2002-01-20</code> doesn't contain <code>Susan</code>, yet is in your output</span>
<span class="comment-copy">Yeah. I quickly realized I had a few unnecessary operations. :p. Not sure why your answer got a downvote, it's succinct. Actually, the true time difference seems to be in using <code>x.values</code> instead of <code>x</code>.</span>
<span class="comment-copy">Thanks, I like your approach. its straight-forward. Not sure about the downvote. it would be nicer if the downvoter would point out areas of improvement</span>
