<div class="post-text" itemprop="text">
<p>I am running a TASEP simulation in Python, where lattice-sites on a lattice of a given size can be either empty or occupied (0 or 1).</p>
<p>The simulation gives me a plot of the lattice configuration (whether a state is occupied or not) for a given simulation-time, but not how many (number) of the states that are occupied.</p>
<p>I can't get Python to count the number of occupied states because the graph comes from a simulation and not a list.</p>
<p>TASEP code:</p>
<pre><code>import random, pylab, math
random.seed()
L=100 # Number of lattice sites
alpha=.2 # Rate of entry
beta=.4 # Rate of exit

Ntime=200000 # Simulation steps
state=[0 for k in range(L+1)]
for iter in range(Ntime):
   k=random.randint(0,L)
   if k==0:
      if random.random() &lt; alpha: state[1]=1
   elif k==L:
         if random.random() &lt; beta: state[L]=0
   elif state[k]==1 and state[k+1]==0: 
      state[k+1]=1
      state[k]=0
   if iter%2000 == 0: 
      yaxis=[]
      for i in range(L):
          if state[i+1]==1: yaxis.append(i)
      xaxis=[iter for k in range(len(yaxis))]
      pylab.plot(xaxis,yaxis,'r.')
pylab.xlabel('Number of steps')
pylab.ylabel('System configuration')
pylab.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/tBgXR.png" rel="nofollow noreferrer">Here is a plot from the simulation</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Ok, so I basically fixed up your code because, no offence, but it was kind of a mess before (see the comments). </p>
<pre><code>import random
import matplotlib.pyplot as plt

fig, axs = plt.subplots(nrows=2, sharex=True)

L = 100  # Number of lattice sites
alpha = 0.2  # Rate of entry
beta = 0.4  # Rate of exit

n_time = 200000  # Simulation steps
record_each = 2000
state = [0]*(L + 1)
record = []  # store a record of the total number of states occupied

for itr in range(n_time):

    rand_int = random.randint(0, L)

    if rand_int == 0:
        if random.random() &lt; alpha:
            state[1] = 1
    elif rand_int == L:
        if random.random() &lt; beta:
            state[L] = 0
    elif state[rand_int] == 1 and state[rand_int + 1] == 0:
        state[rand_int + 1] = 1
        state[rand_int] = 0

    if itr % record_each == 0:
        yaxis = [i for i in range(L) if state[i + 1] == 1]
        axs[1].plot([itr]*len(yaxis), yaxis, 'r.')
        record.append(sum(state))  # add the total number of states to the record

axs[0].plot(range(0, n_time, record_each), record)  # plot the record
axs[1].set_xlabel('Number of steps')
axs[1].set_ylabel('System configuration')
axs[0].set_ylabel('Number of states occupied')
plt.show()
</code></pre>
<p>This outputs </p>
<p><a href="https://i.stack.imgur.com/G40rt.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/G40rt.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>The solution proposed by FHTMitchell is correct but inefficient. The <code>sum</code> operation requires O(L) work to be performed at each iteration, making the overall program O(L * n_time).</p>
<p>Note that:</p>
<ul>
<li>you start out with an <code>occupied_state_count</code> of 0;</li>
<li>the <code>occupied_state_count</code> should be incremented only if a zero state gets switched to a one;</li>
<li>the <code>occupied_state_count</code> should be decremented only if a one state gets switched to a zero;</li>
<li>if you're already in the target state, no change is needed and short-circuiting can avoid an unnecessary call to <code>random()</code>;</li>
<li>and finally, when two states are toggled in opposite directions (your final <code>elif</code>) there is no need to change the <code>occupied_state_count</code>.</li>
</ul>
<p>Applying all of the above yields the following O(n_time) implementation, which is quite a bit faster:</p>
<pre><code>import random
import matplotlib.pyplot as plt

fig, axs = plt.subplots(nrows=2, sharex=True)

L = 100  # Number of lattice sites
alpha = 0.2  # Rate of entry
beta = 0.4  # Rate of exit

n_time = 200000  # Simulation steps
record_each = 2000
state = [0]*(L + 1)
occupied_state_count = 0
record = []  # store a record of the total number of states occupied

for itr in range(n_time):

    rand_int = random.randint(0, L)

    if rand_int == 0:
        if state[1] == 0 and random.random() &lt; alpha:
            state[1] = 1
            occupied_state_count += 1
    elif rand_int == L:
        if state[L] == 1 and random.random() &lt; beta:
            state[L] = 0
            occupied_state_count -= 1
    elif state[rand_int] == 1 and state[rand_int + 1] == 0:
        state[rand_int + 1] = 1
        state[rand_int] = 0

    if itr % record_each == 0:
        yaxis = [i for i in range(L) if state[i + 1] == 1]
        axs[1].plot([itr]*len(yaxis), yaxis, 'r.')
        record.append(occupied_state_count)  # add the total number of states to the record

axs[0].plot(range(0, n_time, record_each), record)  # plot the record
axs[1].set_xlabel('Number of steps')
axs[1].set_ylabel('System configuration')
axs[0].set_ylabel('Number of states occupied')
plt.show()
</code></pre>
</div>
<span class="comment-copy">The state is stored in a list called <code>state</code>. Have you tried <code>sum(state)</code>? That will give you the number of occupied states at a given time step...</span>
<span class="comment-copy">don't use <code>iter</code> as variable, it shadows the built in <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter</code></a> function. And <code>pylab</code> is deprecated. Use <code>import matplotlib.pyplot as plt</code> instead. <a href="https://docs.python.org/3/library/random.html#random.seed" rel="nofollow noreferrer"><code>random.seed()</code></a> doesn't actually do anything unless you pass a variable and please have a look at the <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">python style guide</a> (e.g. put spaces either side of operators).</span>
<span class="comment-copy">I'll try your suggestions.</span>
<span class="comment-copy">Thank you! I'll try your suggestion.</span>
