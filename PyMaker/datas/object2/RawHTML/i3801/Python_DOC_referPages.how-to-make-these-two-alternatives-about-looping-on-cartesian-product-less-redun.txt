<div class="post-text" itemprop="text">
<p>In the following function <code>f</code>, we can either loop on <code>a</code> first or on <code>b</code> first.</p>
<p><strong>How to make its code less redundant?</strong></p>
<pre><code>def myfunction(a):
    pass

def f(first_loop_on_a=True):
    if first_loop_on_a:
        for a in range(10):
            A = "%010i" % a               
            myfunction(a)
            for b in range(5):
                print A, b
    else:
        for b in range(5):
            for a in range(10):
                A = "%010i" % a
                myfunction(a)
                print A, b

f(True)
f(False)
</code></pre>
<p>I was thinking about <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>product</code></a>, but still, we would have:</p>
<pre><code>def myfunction2(a, b):
    A = "%010i" % a               
    myfunction(a)
    print A, b

def f(first_loop_on_a=True):
    if first_loop_on_a:
        for a, b in product(range(10), range(5)):
            myfunction2(a, b)
    else:
        for b, a in product(range(5), range(10)):
            myfunction2(a, b)
</code></pre>
<p>which is still a bit redundant.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about using a generator expression to flip the tuples when you do the <code>product</code> with the source of the <code>b</code> values first:</p>
<pre><code>def f(first_loop_on_a=True):
    if first_loop_on_a:
        gen = product(range(10, range(5))
    else:
        gen = (a, b for b, a in product(range(5), range(10)))

    for a, b in gen:
        myfunction2(a, b)
</code></pre>
<p>I would note that this is still not the same as your original function, since in the original, <code>myfunction</code> gets called a different number of times between the two branches (either 10 times or 50). The new function always calls it (via <code>myfunction2</code>) in the inner loop, so it will always be run 50 times.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your function is too repetitive, you can refactor things step by step.</p>
<p>The commonality you want to factor out is calling <code>myfunction2(a, b)</code> on some iterator. But the second iterator not only has the <code>product</code> args reversed, but the elements of each pair as well. So:</p>
<pre><code>def f(first_loop_on_a=True):
    if first_loop_on_a:
        prod = product(range(10), range(5))
    else:
        prod = (b, a for (a, b) in product(range(5), range(10)))
    for a, b in prod:
        myfunction2(a, b)
</code></pre>
<hr/>
<p>If you're doing this multiple times, you can factor out that tuple-flipping into a function:</p>
<pre><code>def flippair(p):
    a, b = p
    return b, a
def f(first_loop_on_a=True):
    if first_loop_on_a:
        prod = product(range(10), range(5))
    else:
        prod = map(flippair, product(range(5), range(10)))
    for a, b in prod:
        myfunction2(a, b)
</code></pre>
<p>(Or, of course, <code>flippair</code> could just return <code>p[::-1]</code>—or, since you don't need tuples, but just any kind of iterable, just use <code>reversed</code>. But this way seems more explicit, and still easily concise enough.)</p>
<hr/>
<p>But I think the best solution is to use keyword arguments for <code>myfunction</code>:</p>
<pre><code>def kwify(order, pairs):
    return (dict(zip(order, pair)) for pair in pairs)
def f(first_loop_on_a=True):
    if first_loop_on_a:
        prod = kwify('ab', product(range(10), range(5)))
    else:
        prod = kwify('ba', product(range(5), range(10)))
    for kwpair in prod:
        myfunction2(**kwpair)
</code></pre>
<p>This makes it really obvious that you're passing <code>a</code> values as <code>a</code> and <code>b</code> values as <code>b</code>, rather than flipping them so they end up in <code>b</code> and <code>a</code> and then flipping them back to pass them in reverse order.</p>
<hr/>
<p>While we're at it, why repeat the ranges?</p>
<pre><code>def kwify(order, pairs):
    return (dict(zip(order, pair)) for pair in pairs)
def f(first_loop_on_a=True):
    arange, brange = range(10), range(5)
    if first_loop_on_a:
        prod = kwify('ab', product(arange, brange))
    else:
        prod = kwify('ba', product(brange, arange))
    for kwpair in prod:
        myfunction2(**kwpair)
</code></pre>
<hr/>
<p>… at which point you can give <em>them</em> names as well:</p>
<pre><code>def kwify(order, pairs):
    return (dict(zip(order, pair)) for pair in pairs)
def f(first_loop_on_a=True):
    ranges = {'a': range(10), 'b': range(5)}
    order = 'ab' if first_loop_on_a else 'ba'
    prod = kwify(order, product(*itemgetter(*order)(ranges)))
    for kwpair in prod:
        myfunction2(**kwpair)
</code></pre>
<hr/>
<p>… or, maybe even factor out the calls to <code>range</code>:</p>
<pre><code>def kwify(order, pairs):
    return (dict(zip(order, pair)) for pair in pairs)
def f(first_loop_on_a=True):
    ranges = {'a': 10, 'b': 5}
    order = 'ab' if first_loop_on_a else 'ba'
    prod = kwify(order, product(*map(range, itemgetter(*order)(ranges))))
    for kwpair in prod:
        myfunction2(**kwpair)
</code></pre>
<p>This is probably horrible overkill for just choosing "a-then-b" vs. "b-then-a", but if you wanted this to extend to choosing different permutations of three variables, or arbitrary orders from a dynamic list, etc., it would probably be worth doing.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could map through <code>reversed</code>:</p>
<pre><code>&gt;&gt;&gt; import itertools as it
&gt;&gt;&gt; 
&gt;&gt;&gt; def itr(A, B, a_first=True):
...     return it.product(*map(range, (A, B))) if a_first else map(reversed, it.product(*map(range, (B, A))))
... 
&gt;&gt;&gt; [(a, b) for a, b in itr(2, 3, True)]
[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]
&gt;&gt;&gt; [(a, b) for a, b in itr(2, 3, False)]
[(0, 0), (1, 0), (0, 1), (1, 1), (0, 2), (1, 2)]
</code></pre>
</div>
<span class="comment-copy">Your first option calls <code>myfunction</code> a lot less than your second. Is this important? It's not clear whether <code>myfunction</code> is supposed to represent a function used for its side effects or its return value.</span>
<span class="comment-copy">@user2357112 Yes it <i>would</i> be important. But as it was already difficult to find an answer, I didn't add this as a criteria, but ideally yes, it's important to have less calls, at least in the <code>for a, for b</code> order (in the other order, it's impossible, so we cannot do anything about it).</span>
<span class="comment-copy">I'm pretty sure I'm not supposed to encourage that sort of frivolity, but who cares (+1). May I challenge you to make the last one work with either <code>myfunc(**kwtuple)</code> or <code>myfunc(*kwtuple.values()</code>?</span>
<span class="comment-copy">@PaulPanzer If someone wants this because <code>myfunc</code> can’t be rewritten to take keyword arguments, <code>*(v for k, v in sorted(kwdict.items()))</code> is about the best I can think of on the fly. But that seems to step well over the line between clever and silly that I was already dancing on (not to mention that it depends on the fact that <code>'a'&lt;'b'</code>).</span>
<span class="comment-copy">I just realized what was bothering me about this code: <code>partial(zip, order)</code> is a nicely mappable function in its own right, so in my head I was thinking of… basically <code>partial(map, partial(zip, order))</code> as a reusable function. Which is how you’d probably write this in Haskell, but pretty far from Pythonic. I didn’t even realize I was thinking in those terms, but that’s exactly why it feels “too clever to actually use”.</span>
