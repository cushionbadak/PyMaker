<div class="post-text" itemprop="text">
<p>Let's say I have a (simplified) class as below. I am using it for a program configuration (hyperparameters).</p>
<pre><code># config.py
class Config(object):      # default configuration
    GPU_COUNT = 1
    IMAGES_PER_GPU = 2
    MAP = {1:2, 2:3}

    def display(self):
        pass

# experiment1.py
from config import Config as Default
class Config(Default):     # some over-written configuration
    GPU_COUNT = 2
    NAME='2'            

# run.py
from experiment1 import Config
cfg = Config()
...
cfg.NAME = 'ABC'            # possible runtime over-writing

# Now I would like to save `cfg` at this moment
</code></pre>
<p>I'd like to save this configuration and restore later. The member functions must be out of concern when restoring.</p>
<p><strong>1. When I tried pickle:</strong></p>
<pre><code>import pickle
with open('cfg.pk', 'rb') as f: cfg = pickle.load(f)

##--&gt; AttributeError: Can't get attribute 'Config' on &lt;module '__main__'&gt;
</code></pre>
<p>I saw a solution using <code>class_def</code> of <code>Config</code>, but I wish I can restore the configuration without knowing the class definition (eg, export to dict and save as JSON)</p>
<p><strong>2. I tried to convert class to dict</strong> (so that I can export as JSON)</p>
<pre><code>cfg.__dict__     # {'NAME': 'ABC'}
vars(cfg)        # {'NAME': 'ABC'} 
</code></pre>
<p>In both cases, it was difficult to access attributes. Is it possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>The question's title is "how to convert python class to dict", but I suspect you are really just looking for an easy way to represent (hyper)parameters.</p>
<p>By far the easiest solution is to not use classes for this. I've seen it happen on some machine learning tutorials, but I consider it a pretty ugly hack. It breaks some semantics about classes vs objects, and the difficulty pickling is a result from that. How about you use a simple class like this one:</p>
<pre><code>class Params(dict):
    __getattr__ = dict.__getitem__
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__

    def __getstate__(self):
        return self

    def __setstate__(self, state):
        self.update(state)

    def copy(self, **extra_params):
        return Params(**self, **extra_params)
</code></pre>
<p>It can do everything the class approach can. Predefined configs are then just objects you should copy before editing, as follows:</p>
<pre><code>config = Params(
    GPU_COUNT = 2,
    NAME='2',
)
other_config = config.copy()
other_config.GPU_COUNT = 4
</code></pre>
<p>Or alternatively in one step:</p>
<pre><code>other_config = config.copy(
    GPU_COUNT = 4
)
</code></pre>
<p>Works fine with pickle (although you <em>will</em> need to have the <code>Params</code> class somewhere in your source), and you could also easily write <code>load</code> and <code>save</code> methods for the <code>Params</code> class if you want to use JSON.</p>
<p>In short, do not use a class for something that really is just an object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thankfully, @evertheylen's answer was great to me. However, the code returns error when <code>p.__class__ = Params</code>, so I slightly changed as below. I think it works in the same way.</p>
<pre><code>class Params(dict):
    __getattr__ = dict.__getitem__
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__

    def __getstate__(self):
        return self

    def __setstate__(self, state):
        self.update(state)

    def copy(self, **extra_params):
        lhs = Params()
        lhs.update(self)
        lhs.update(extra_params)
        return lhs
</code></pre>
<p>and you can do </p>
<pre><code>config = Params(
    GPU_COUNT = 2,
    NAME='2',
)
other_config = config.copy()
other_config.GPU_COUNT = 4
</code></pre>
</div>
<span class="comment-copy">Try importing <code>Config</code> into the file where your are trying to unpickle it.</span>
<span class="comment-copy">I don't understand what you're asking here. Is your goal= to switch from Pickle to some kind of JSON-based storage, or is that just something you're trying to do to get around the problem that your class isn't pickleable out of the box? If you actually did want to use pickle, have you skimmed <a href="https://docs.python.org/3/library/pickle.html#pickling-class-instances" rel="nofollow noreferrer">Pickling Class Instances</a> in the docs? Or tried just dropping in <a href="https://pypi.org/project/dill/" rel="nofollow noreferrer"><code>dill</code></a> in place of <code>pickle</code> to see if that works?</span>
<span class="comment-copy">Anyway, <code>cfg.__dict__</code> doesn't include attributes from the class(es). The <code>dir</code> function, or various functions in <code>inspect</code>, can get them. But then you need to filter out all kinds of things like methods and special attributes like <code>__module__</code> and so on, and… that's all doable if you understand the guts of Python classes well enough to come up with and then implement a suitable rule, but not usually a path worth going down for serialization.</span>
<span class="comment-copy">And really, you shouldn't <i>need</i> to store those attributes. When you unpickle the instance later, that creates a new <code>Config</code> instance, which is missing the same instance attributes, and therefore inherits the class attributes in the same way as the original, so it all just works—unless you're doing something uncommon and complicated, in which case you probably need to explain what that something is.</span>
<span class="comment-copy">Do you want to convert a <i>class</i> to a dictionary, or an <i>object</i>?</span>
<span class="comment-copy">Great!! Thanks. It looks so good. One question! When I tried <code>config.copy()</code>, an error returns: <code>__class__ assignment only supported for heap types or ModuleType subclasses</code>. How can I deal with this?</span>
<span class="comment-copy">Good that it works for you :) I was about to do something similar: <code>def copy(self, **extra_params): return Params(**self, **extra_params)</code></span>
