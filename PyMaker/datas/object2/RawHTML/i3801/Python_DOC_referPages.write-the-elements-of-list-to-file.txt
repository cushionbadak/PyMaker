<div class="post-text" itemprop="text">
<p>Bigram is a list which looks like-</p>
<pre><code>[('a', 'b'), ('b', 'b'), ('b', 'b'), ('b', 'c'), ('c', 'c'), ('c', 'c'), ('c', 'd'), ('d', 'd'), ('d', 'e')]
</code></pre>
<p>Now I am trying to wrote each element if the list as a separate line in a file with this code-</p>
<pre><code> bigram = list(nltk.bigrams(s.split()))
 outfile1.write("%s" % ''.join(ele) for ele in bigram)
</code></pre>
<p>but I am getting this error :</p>
<blockquote>
<p>TypeError: write() argument must be str, not generator</p>
</blockquote>
<p>I want the result as in file-</p>
<pre><code>('a', 'b') 
('b', 'b')
('b', 'b')
('b', 'c')
('c', 'c')
......
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you're passing a generator comprehension to <code>write</code>, which needs strings.</p>
<p>If I understand correctly you want to write one representation of tuple per line.</p>
<p>You can achieve that with:</p>
<pre><code>outfile1.write("".join('{}\n'.format(ele) for ele in bigram))
</code></pre>
<p>or</p>
<pre><code>outfile1.writelines('{}\n'.format(ele) for ele in bigram)
</code></pre>
<p>the second version passes a generator comprehension to <code>writelines</code>, which avoids to create the big string in memory before writing to it (and looks more like your attempt)</p>
<p>it produces a file with this content:</p>
<pre><code>('a', 'b')
('b', 'b')
('b', 'b')
('b', 'c')
('c', 'c')
('c', 'c')
('c', 'd')
('d', 'd')
('d', 'e')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>outfile1.writelines("{}\n".format(ele) for ele in bigram)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the operator precedence problem.</p>
<p>You want an expression like this:</p>
<pre><code>("%s" % ''.join(ele)) for ele in bigram
</code></pre>
<p>Instead, you get it interpreted like this, where the part in the parens is indeed a generator:</p>
<pre><code>"%s" % (''.join(ele) for ele in bigram)
</code></pre>
<p>Use the explicit parentheses.</p>
<p>Please note that <code>("%s" % ''.join(ele)) for ele in bigram</code> is <em>itself</em> a generator. You need to call <code>write</code> on each element from it.</p>
<p>If you want to write each pair in a separate line, you have to add line separators explicitly. The easiest, to my mind, is an explicit loop:</p>
<pre><code>for pair in bigram:
  outfile.write("(%s, %s)\n" % pair)
</code></pre>
</div>
<span class="comment-copy">You can't write a generator. Can you show us how you are writing (more code in your function) and what you want as desired output?</span>
<span class="comment-copy">@jpp I have made the changes</span>
<span class="comment-copy">it worked...thanks!</span>
<span class="comment-copy">I specifically looked up the documentation of <a href="https://docs.python.org/3/library/io.html#io.IOBase.writelines" rel="nofollow noreferrer"><code>writelines</code></a> and used a list comprehension first because it says "Write a list of lines to the stream". Good to know it also works with generators but I guess it should actually say "an iterable of lines"...</span>
<span class="comment-copy">yeah, it works with any iterable because it processes line after line, doesn't need the whole list beforehand.</span>
<span class="comment-copy">OP has edited question in the meanwhile. Your code produces lines like aa, ab, ... not the tuple representations. Besides, code without any explanation isn't very useful...</span>
<span class="comment-copy">when I open the file it is showing &lt;generator object &lt;genexpr&gt; at 0x0000023CBC1B9990&gt;</span>
<span class="comment-copy">Updated the answer.</span>
