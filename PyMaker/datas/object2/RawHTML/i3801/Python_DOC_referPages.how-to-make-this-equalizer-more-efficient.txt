<div class="post-text" itemprop="text">
<p>So I have been working on making an equalizer and the problem I am facing is that the pyaudio stream is streaming much faster than the speed with which the eq. is finding the bass component of the audio file. I will briefly outline the implementation:
<br/>
I have created two extra threads and have used tkinter for the gui. Thread 1 computes the bass component (fn bass() ) of the sound in chunks of 50ms data.
<br/>
Thread 2 plots that by actually creating a rectangle in tkinter with varying top left coordinates.
<br/>
flag2 keeps the main thread running, while flag synchronizes the bass() and plot() functions. The last part of the code is to ensure that the display doesn't go faster than the song itself( however the exact opposite is the concern right now).
<hr/>
I am attaching the code here:</p>
<pre><code>import numpy as np
from scipy.io import wavfile 
from numpy import fft as fft
import time
import tkinter as tk
import threading
import pyaudio
import wave

CHUNK = 1024
wf = wave.open("test3.wav", 'rb')
p = pyaudio.PyAudio()

###
def callback(in_data, frame_count, time_info, status):
    data = wf.readframes(frame_count)
    return (data, pyaudio.paContinue)

stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),
                channels=wf.getnchannels(),
                rate=wf.getframerate(),
                output=True,
                stream_callback=callback)

####

rate,audData = wavfile.read("test3.wav")

print ("Rate "+str(rate))
print ("Length of wav file(in s) = " + str(audData.shape[0]/rate))

ch1=audData[:]
tim = 0.050
pt=int(tim*rate)

flag2 = True
flag = False
cnt = 0
value=0

def bass():
    global pt
    global cnt
    global audData
    global value
    global flag2
    global flag

    cnt +=1
    fourier=fft.fft(ch1[((cnt-1)*pt):((cnt)*pt)])
    fourier = abs(fourier) / float(pt)
    fourier = fourier[0:25]
    fourier = fourier**2

    if (cnt+1)*pt &gt; len(audData[:]) :
        flag2 = False

    value = (np.sum(fourier))/pt
    flag= True
    return

def plot():
    global value
    global flag

    root=tk.Tk()

    canvas =tk.Canvas(root,width=200,height=500)
    canvas.pack()

    while True:
        if flag:
            canvas.delete("all")
            flag=False
            greenbox = canvas.create_rectangle(50,500-(value/80),150,500,fill="green")
            print(value/80) # to check whether it excees 500
        root.update_idletasks()    
        root.update()

    return

def sound():
    global data
    global stream
    global wf
    global CHUNK

    stream.start_stream()

    while stream.is_active():
        time.sleep(0.1)

    stream.stop_stream()
    stream.close()
    wf.close()
    p.terminate()


bass()
t1 = threading.Thread(target=plot, name='t_1')
t2 = threading.Thread(target=sound, name='t_2')
t1.start()
t2.start()

while flag2:
    a = time.time()
    bass()
    b=time.time()
    while (b-a) &lt; tim :
        time.sleep(0.015)
        b=time.time()
</code></pre>
<p>To overcome this processing speed problem, I tried to process 1 in every 3 chunks:</p>
<pre><code>cnt +=1
    fourier=fft.fft(ch1[((3*cnt-3)*pt):((3*cnt-2)*pt)])
    fourier = abs(fourier) / float(pt)
    fourier = fourier[0:25]
    fourier = fourier**2

    if (3*cnt+1)*pt &gt; len(audData[:]) :
        flag2 = False
#######
 while (b-a) &lt; 3*tim :
        time.sleep(0.015)
        b=time.time()
</code></pre>
<p>But this even this is not up to the mark. The lag is visible after a few seconds. Any ideas on how to improve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of efficiency, a more realistic solution might be delay matching.  If you can determine the latency of your FFT and display (etc.) processes, the you can either delay sound output (using a fifo of some number of audio samples), or have the visualization process look ahead in the playback file read by the equivalent number of samples.</p>
</div>
<span class="comment-copy">Write your own FFT-function? For any 2^N chunk the algorithm is quite a simple (division part in it is binary shifting, which is way faster than regular division arithmetic). Other solution is to reduce the chunk above to e.g. 512.</span>
<span class="comment-copy">While I don't know if that's related to your problem, your inter-thread communication is not thread safe, which can always cause strange effects. For example, you should replace the booleans <code>flag</code> and <code>flag2</code> with <a href="https://docs.python.org/3/library/threading.html#event-objects" rel="nofollow noreferrer"><code>threading.Event</code></a>s. Apart from that, the <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">GIL</a> will basically serialize your threads anyway, so multi-threading might not even help at all, performance-wise.</span>
