<div class="post-text" itemprop="text">
<p>I want to create a list of all possible (x,y) values.</p>
<p>For example - for input (x=2,y=3) the output should be:</p>
<pre><code>np.array([
[0,0],
[0,1],
[0,2],
[1,0],
[1,1],
[1,2]])
</code></pre>
<p>The order doesn't really matter</p>
</div>
<div class="post-text" itemprop="text">
<p>Quick and dirty:</p>
<pre><code>&gt;&gt;&gt; np.argwhere(np.ones((2, 3)))
array([[0, 0],
       [0, 1],
       [0, 2],
       [1, 0],
       [1, 1],
       [1, 2]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Inspired by Divakar's <a href="https://stackoverflow.com/a/45857632/4909087"><code>indices_merged_arr</code></a>, this should be <em>fast</em>.</p>
<pre><code>def indices_for(m, n):
    i, j = np.ogrid[:m, :n]
    v = np.empty((m, n, 2), dtype=np.uint32)
    v[..., 0] = i
    v[..., 1] = j
    v.shape = (-1, 2)

    return v
</code></pre>
<p></p>
<pre><code>&gt;&gt;&gt; indices_for(3, 2)
array([[0, 0],
       [0, 1],
       [0, 2],
       [1, 0],
       [1, 1],
       [1, 2]])
</code></pre>
<hr/>
<pre><code>m, n = 10000, 10000
%timeit indices_for(m, n)
607 ms ± 9.12 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit np.argwhere(np.ones((m, n)))
4.69 s ± 225 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
</div>
<span class="comment-copy">Please update our question with your previous attempts.</span>
<span class="comment-copy">Have you looked at <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> ?</span>
<span class="comment-copy">What exactly is your issue? If you store this code in an array, it will give you this output...</span>
<span class="comment-copy">Reopening as it isn't a duplicate of those links, regardless of whatever else it might be.</span>
<span class="comment-copy">I don't care about the upvotes, but I finally 1UP'd you on an answer ;)</span>
<span class="comment-copy">And coversely I am relishing the success of my populist answer ;-)</span>
<span class="comment-copy">Meh. By the way, I don't think this is a duplicate.</span>
<span class="comment-copy">Certainly not the best links with that.</span>
<span class="comment-copy">This question is pretty much a duplicate but I couldn't find exactly the same duplicate. However, the answer of this question can be found within target questions's answers. Please add the questions to the list if you found a more accurate one. Also a much faster approach for this solution (specially fir larger arrays) could be <code>np.dstack(np.indices((2, 3))).reshape(6, 2)</code>.</span>
<span class="comment-copy">Now that you reopened a quation with no attempt please add a benchmark with <code>np.dstack(np.indices((m, n))).reshape(m*n, 2)</code> too :)). Nice attempt tho(+).</span>
<span class="comment-copy">@Kasramvd not on my machine now so can't benchmark :( but I've tried something similar with hstack and np.indices (I am aware of the function) but it's performance severely left something to be desired. Anyway, I'll test it in the morning. I'm still not convinced of the closure but it definitely could be a dupe of something else... so let me know and I'll close it when I get my votes back (I'm all out for today).</span>
<span class="comment-copy">@Kasramvd wait, can you please try it for m,n=10000,10000 as in my answer?</span>
<span class="comment-copy">I was about to do that it the IPython raises memory error. This is problem with Ipyhton-3 that I always encounter to.</span>
<span class="comment-copy">@Kasramvd what is your code doing that ours isn't? :P</span>
