<div class="post-text" itemprop="text">
<p>I have a script that seemed to run slow and that i profiled using cProfile (and visualisation tool <a href="https://julien.danjou.info/guide-to-python-profiling-cprofile-concrete-case-carbonara/" rel="nofollow noreferrer">KCacheGrind</a>)</p>
<p>It seems that what is taking almost 90% of the runtime is the import sequence, and especially the running of the <code>_ _ init _ _.py</code> files...</p>
<p>Here a screenshot of the KCacheGrind output (sorry for attaching an image...)</p>
<p><a href="https://i.stack.imgur.com/yMiPx.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/yMiPx.png"/></a></p>
<p>I am not very familiar with how the import sequence works in python ,so maybe i got something confused... I also placed <code>_ _ init _ _.py</code> files in everyone of my custom made packages, not sure if that was what i should have done.</p>
<p>Anyway, if anyone has any hint, greatly appreciated!</p>
<hr/>
<p>EDIT: additional picture when function are sorted by self:</p>
<p><a href="https://i.stack.imgur.com/xcDYT.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/xcDYT.png"/></a></p>
<hr/>
<p>EDIT2:</p>
<p>here the code attached, for more clarity for the answerers:</p>
<pre><code>from strategy.strategies.gradient_stop_and_target import make_one_trade

from datetime import timedelta, datetime
import pandas as pd
from data.db import get_df, mongo_read_only, save_one, mongo_read_write, save_many
from data.get import get_symbols

from strategy.trades import make_trade, make_mae, get_prices, get_signals, \
    get_prices_subset
#from profilehooks import profile


mongo = mongo_read_only()


dollar_stop = 200
dollar_target = 400
period_change = 3


signal = get_df(mongo.signals.signals, strategy = {'$regex' : '^indicators_group'}).iloc[0]


symbol = get_symbols(mongo, description = signal['symbol'])[0]


prices = get_prices(
    signal['datetime'], 
    signal['datetime'].replace(hour = 23, minute = 59),
    symbol,
    mongo)


make_one_trade(
    signal, 
    prices, 
    symbol,             
    dollar_stop,
    dollar_target,
    period_change)
</code></pre>
<p>The function get_prices simply get data from a mongo db database, and make_one_trade does simple calculation with pandas. This never poses problem anywhere else in my project.</p>
<hr/>
<p>EDIT3:</p>
<p>Here the Kcache grind screen when i select 'detect cycle' option in View tab:</p>
<p><a href="https://i.stack.imgur.com/CNf7g.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/CNf7g.png"/></a></p>
<p>Could that actually mean that there are indeed circular imports in my self created packages that takes all that time to resolve?</p>
</div>
<div class="post-text" itemprop="text">
<p>No. You are conflating <em>cumulative time</em> with time spent in the top-level code of the <code>__init__.py</code> file itself. The top-level code calls other methods, and <em>those together</em> take a lot of time.</p>
<p>Look at the <em>self</em> column instead to find where all that time is being spent. Also see <a href="https://stackoverflow.com/questions/40404007/what-is-the-difference-between-tottime-and-cumtime-in-a-python-script-profiled-w">What is the difference between tottime and cumtime in a python script profiled with cProfile?</a>, the <em>incl.</em> column is the cumulative time, <em>self</em> is the total time.</p>
<p>I'd just filter out all the <code>&lt;frozen importlib.*&gt;</code> entries; the Python project has already made sure those paths are optimised.</p>
<p>However, your second screenshot does show that in your profiling run, all that your Python code busied itself with was loading bytecode for modules to import (the <a href="https://docs.python.org/3/library/marshal.html" rel="nofollow noreferrer"><code>marshal</code> module</a> provides the Python bytecode serialisation implementation). Either the Python program did nothing but import modules and no other work was done, or it is using some form of dynamic import that is loading a large number of modules or is otherwise ignoring the normal module caches and reloading the same module(s) repeatedly.</p>
<p>You can profile import times using Python 3.7's new <a href="https://docs.python.org/3.7/using/cmdline.html#id5" rel="nofollow noreferrer"><code>-X importtime</code> command-line switch</a>, or you could use a dedicated <a href="https://github.com/cournape/import-profiler" rel="nofollow noreferrer">import-profiler</a> to find out why imports take such a long time.</p>
</div>
<span class="comment-copy">No. You are conflating <i>aggregate time</i> with time spent in the method itself. <code>__init__</code> calls other methods, and <i>those together</i> take a lot of time.</span>
<span class="comment-copy">I am not terribly clear on what you are asking here?</span>
<span class="comment-copy">@MartijnPieters Normally clicking on the function in the graph shows the child function, bu here it seems to be some kind of loop, and all function are tagged as  &lt;module&gt;, so its not informing me what takes time...</span>
<span class="comment-copy">@jimbasquiat: That's because the <code>&lt;frozen importlib.*&gt;</code> paths all end in native C implementations for critical path sections, which are not picked up by cProfile. You really want to filter those out.</span>
<span class="comment-copy">@StephenRauch I don't understand how to continue with profiling here as the arrows goes in a loop, and it seems to be importing that takes time. If anyone has had some experience with this kind of situation, I would be glad to know how to proceed to understand what is taking time, how to spot it.</span>
<span class="comment-copy">I re-uploaded the image to show better where the arrows lead to. I understand the difference between the tottime and cumtime, my problem is that is here the arrows never point to an actual function , but goes in a loop, and only seems to spend time in that 'import' part of the script - Just added a picture where function are sorted by self to explain better my problem</span>
<span class="comment-copy">@jimbasquiat: that does show that your program spends most of the time loading bytecode caches when importing (the <code>marshal</code> module is used for serialisation / deserialisation of Python bytecode). At this point I have to ask: does your code does <i>anything at all</i> beyond importing modules? Does it use any kind of dynamic module loading that is ignoring the <code>sys.modules</code> cache?</span>
<span class="comment-copy">I edited the question to show / briefly explain the code and show an additional KCacheGrind screen. Thx again for your help!</span>
<span class="comment-copy">All the code run.. I could find the name of the function get_prices and make_one_trade in the profiling log - but they take very little time to run, that;s why it is completely buried under the massive time taken by the import. Is it possible that I made mistake with creating the <b>init</b>.py files in my project, or something else that could affect the time that my custom create packages takes to load? I had that problem before already on the same project</span>
<span class="comment-copy">@jimbasquiat: your code is much larger than just that one file, what does the <code>data</code> package do? And this is rapidly getting too broad to answer; I can't help you debug a full project here.</span>
