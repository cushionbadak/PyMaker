<div class="post-text" itemprop="text">
<p>I have a problem with a problem, that got a bit problematic as problems go.</p>
<p>situation:</p>
<p>I need to combine items in list(s) of variable sizes, with variable sized elements, store those combinations and then iterate through them. I tried itertools, but I get too many combinations, which I have no idea how to properly "clean".
I get correct combinations by just creating as many for loops as the number of "op" elements in the input list is.</p>
<p>example:
NOTE: number of "op" dictionaries may vary! Ignore values as such, what matters is, I use list of "op" dictionaries to basically get all custom controls in Nuke GUI element called NoOp node. I need to iterate through each of the controls for each value, making all possible combinations:</p>
<pre><code>for option1 in op1["options"]:
    for option2 in op2["options"]:
        for option3 in op3["options"]:
            print op1["control"], option1, op2["control"], option2,   op3["control"], option3     
</code></pre>
<p>For now i am just trying to get my head around how to define the base case :/</p>
<pre><code>def getCombos(controls, n = 0):
        #combos = []
        if n == 0:
            #return [(control["control"], option) for control in controls for option in control["options"]]
            return [(item["control"], option) for item in controls for option in item["options"]]
        else:
            for control in controls:
                return(getCombos(controls, n-1))
                n -= 1


op1 = {"control": "Material", "options": ["Glass", "Metal", "Wood"]}
op2 = {"control": "Base",
       "options": ["Chrome", "Brass", "Bronce", "Gold", "Nickel", "Red Gold"]}
op3 = {"control": "Color", "options": ["Red", "Blue", "Green", "Cyan", "SomeWonderfulNewColor"]}


controls = [op1, op2, op3]
#NOTE: number of elements (dict) in list controls may vary!

for i,combo in enumerate(getCombos(controls, n=len(controls))):
    print i, combo
</code></pre>
<p>ATM this script just recursively prints the controls</p>
<p>How do I use recursion for this case, and more importantly, should I use recursion at all, and if yes, how do I approach such a case and break it down to it's components?
Cheers,</p>
</div>
<div class="post-text" itemprop="text">
<p>Not 100% sure what you are trying to achieve, but if you want to get all the combination of options, you should use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a>:</p>
<pre><code>&gt;&gt;&gt; list(itertools.product(op1["options"], op2["options"], op3["options"]))
[('Glass', 'Chrome', 'Red'),
 ('Glass', 'Chrome', 'Blue'),
 ('Glass', 'Chrome', 'Green'),
 ...
 ('Wood', 'Red Gold', 'Cyan'),
 ('Wood', 'Red Gold', 'SomeWonderfulNewColor')]
</code></pre>
<p>If you want to combine those with the respective <code>control</code>, you could write a helper function to get the pairs, then get the <code>product</code> of those:</p>
<pre><code>&gt;&gt;&gt; pairs = lambda op: [(op["control"], o) for o in op["options"]]
&gt;&gt;&gt; pairs(op1)
[('Material', 'Glass'), ('Material', 'Metal'), ('Material', 'Wood')]

&gt;&gt;&gt; list(itertools.product(*map(pairs, (op1, op2, op3))))
[(('Material', 'Glass'), ('Base', 'Chrome'), ('Color', 'Red')),
 (('Material', 'Glass'), ('Base', 'Chrome'), ('Color', 'Blue')),
 (('Material', 'Glass'), ('Base', 'Chrome'), ('Color', 'Green')),
 ...
 (('Material', 'Wood'), ('Base', 'Red Gold'), ('Color', 'Cyan')),
 (('Material', 'Wood'), ('Base', 'Red Gold'), ('Color', 'SomeWonderfulNewColor'))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Absolutely you should use recursion:</p>
<pre><code>def print_all(controls, idx, combination):
    if idx == len(controls):
        print(combination)
        return

    for x in controls[idx]['options']:
        print_all(controls, idx+1, combination + " " + controls[idx]['control'] + " " + str(x))


op1 = {"control": "Material", "options": ["Glass", "Metal", "Wood"]}
op2 = {"control": "Base",
   "options": ["Chrome", "Brass", "Bronce", "Gold", "Nickel", "Red Gold"]}
op3 = {"control": "Color", "options": ["Red", "Blue", "Green", "Cyan", "SomeWonderfulNewColor"]}
op4 = {"control": "year", "options": [2010, 2020]}

controls = [op1, op2, op3, op4]

print_all(controls, 0, "")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a way to print all combinations in three steps:</p>
<ol>
<li>Go from <code>{control: control_val, options: options_vals}</code> to <code>{control_val: options_vals}</code>. This is done by the <code>from_record</code> function.</li>
<li>Transform <code>{control_val: options_vals}</code> to a list of <code>[(control_val, options_val)]</code>. This is done by <code>iter_dict</code>.</li>
<li>Take a product of such lists across all different op's.</li>
<li>Format and print. 3 and 4 are handled by <code>print_combinations</code>.</li>
</ol>
<hr/>
<pre><code>from itertools import product


def from_record(dct):
    return {dct["control"]: dct["options"]}


def iter_dict(dct):
    yield from ((k, v) for k, vs in dct.items() for v in vs)


def print_combinations(dcts):
    for item in product(*(iter_dict(from_record(dct)) for dct in dcts)):
        print(", ".join(["{}: {}".format(*t) for t in item]))


op1 = {"control": "Material", "options": ["Glass", "Metal", "Wood"]}
op2 = {
    "control": "Base",
    "options": ["Chrome", "Brass", "Bronce", "Gold", "Nickel", "Red Gold"],
}
op3 = {
    "control": "Color",
    "options": ["Red", "Blue", "Green", "Cyan", "SomeWonderfulNewColor"],
}

print_combinations([op1, op2, op3])

# e.g.
# Material: Glass, Base: Chrome, Color: Red
# Material: Glass, Base: Chrome, Color: Blue
# Material: Glass, Base: Chrome, Color: Green
# Material: Glass, Base: Chrome, Color: Cyan
# Material: Glass, Base: Chrome, Color: SomeWonderfulNewColor
</code></pre>
<hr/>
<p>Alternatively, all possible combinations may be listed more compactly by combining different op dicts:</p>
<pre><code>res = dict()
ops = [op1, op2, op3]
for op in ops:
    res.update(from_record(op))


# {'Base': ['Chrome', 'Brass', 'Bronce', 'Gold', 'Nickel', 'Red Gold'],
 # 'Color': ['Red', 'Blue', 'Green', 'Cyan', 'SomeWonderfulNewColor'],
 # 'Material': ['Glass', 'Metal', 'Wood']}
</code></pre>
</div>
<span class="comment-copy">While I like the introduction, the post lacks a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> with concrete sample data. Input, expected output and wrong output from your current approach.</span>
<span class="comment-copy">What sort of "combinations" do you want? Have you tried <code>itertools.product(opt1["options"], opt2["options"], ...)</code>?</span>
<span class="comment-copy">maybe I really should put tuples in previous example:   for option1 in op1["options"]:     for option2 in op2["options"]:         for option3 in op3["options"]:             print (op1["control"], option1), (op2["control"], option2),   (op3["control"], option3)  I will try the solutions already posted, cheers</span>
<span class="comment-copy">Copy the code in a file, correct the indentation and run it.</span>
<span class="comment-copy">This solution looks very elegant to me, how can I change the output from strings to pairs and store those in a list for further use?</span>
<span class="comment-copy">@Klemen would you tell me what those pairs look like?</span>
<span class="comment-copy">('Material', 'Glass'), ('Base', 'Chrome'), ('Color', 'Red')), ('Material', 'Glass'), ('Base', 'Chrome'), ('Color', 'Blue')), ('Material', 'Glass'), ('Base', 'Chrome'), ('Color', 'Green')), .. ('Material', 'Wood'), ('Base', 'Red Gold'), ('Color', 'Cyan')), ('Material', 'Wood'), ('Base', 'Red Gold'), ('Color', 'SomeWonderfulNewColor'))</span>
<span class="comment-copy">[ [('Material', 'Wood'), ('Base', 'Red Gold'), ('Color', 'Red'), ('year', '2020')], [('Material', 'Wood'), ('Base', 'Red Gold'), ('Color', 'Blue'), ('year', '2010')], [('Material', 'Wood'), ('Base', 'Red Gold'), ('Color', 'Blue'), ('year', '2020')] ]  ???</span>
<span class="comment-copy">Makes sense. You should probably add an example of what you want in the question.</span>
