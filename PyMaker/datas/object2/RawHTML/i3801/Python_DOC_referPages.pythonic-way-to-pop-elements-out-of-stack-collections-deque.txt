<div class="post-text" itemprop="text">
<p>TL;DR: see code at the bottom.</p>
<p>I'm implementing a <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation#Postfix_evaluation_algorithm" rel="nofollow noreferrer">Reverse Polish Notation calculator</a> in Python, using the <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer">collections.deque</a> stack implementation.</p>
<p>Since I'm handling also the case of functions with multiple arguments, I use a separator symbol that I place before the actual arguments. For example, given the following expression as input: <code>max(2, 3, 4)</code>, the <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm" rel="nofollow noreferrer">Shunting Yard</a> algorithm produces the following iterable: <code>['|', '2', '3', '4', 'max']</code>.</p>
<p>When I iterate over it, the separator and the numbers are pushed onto a stack; if a function is encountered, all the previous elements up to the separator are "popped" out of the stack and appended into a list.</p>
<p>Is there a more pythonic way to pop out elements from the end of a stack up to a certain condition?
My code so far:</p>
<pre><code>args = []
while op_stack[-1] != FUNC_ARGS_SEPARATOR:
    args.append(op_stack.pop())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you've got is fine; there is no reasonable way to accomplish this task with the iterator protocol (which is usually how you'd clean up stuff like this).</p>
<p>In theory, if you flipped the order of your <code>op_stack</code> (so the top was on the left, not the right), you might be able to use <code>.index</code> to find the separator, then do a bulk slice and <code>args.extend</code>, then a bulk <code>del</code> slice, but it's hardly worth the trouble (especially when the separator is likely to be found relatively quickly).</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another solution with iterators. I wouldn't call it an improvement over your current solution, but it is different.</p>
<pre><code>from collections import deque
import itertools

d = deque(["|", "2", "3", "4", "max"])

args = list(
    itertools.takewhile(
        # Check if elt is a separator.
        # Side-effect: append separator if encountered.
        lambda elt: elt != "|" or d.append(elt),
        # Pop forever.
        (d.pop() for _ in itertools.repeat(None)),
    )
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With the help of a friend we ended up the <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer">iter</a> keyword with <code>sep</code> as <em>sentinel</em>:</p>
<pre><code>from collections import deque

sep = "|"
op_stack = deque([sep, 2, 3, 4])

args = iter(op_stack.pop, sep)

print(list(args))
</code></pre>
<p>which should be one of the most pythonic and KISS way to solve this, so I'm going to accept this as the answer.</p>
<p>Thanks for the help folks!</p>
</div>
<span class="comment-copy">Do you think there could be a way to convert this into a generator? I don't need a list, since then I expand the <code>args</code>  var as input of a function. I was thinking about a sort of <a href="https://docs.python.org/3.5/library/itertools.html#itertools.takewhile" rel="nofollow noreferrer">takewhile</a>, acting on a stack and yielding popped elements.</span>
<span class="comment-copy">@AlbertoChiusole: The problem with <code>takewhile</code> is that it necessarily takes and returns not only the elements "taken", but also takes and drops the first element that doesn't meet the criteria. Working around that requires abusive filter functions (ones with side-effects, as in Yakym's answer, which violate the general expectation that functional programming tools, which the <code>itertools</code> module is basically nothing but, be side-effect free). You <i>can</i> do it, but it's  <i>definitely</i> not more Pythonic.</span>
<span class="comment-copy">@AlbertoChiusole: You could make some sort of hand-rolled generator specific to <code>deque</code> (well it would work on any mutable sequence type, just not arbitrary iterables), but again, not a particularly Pythonic approach: <code>def popuntil(filt, seq): while seq and filt(seq[-1]): yield seq.pop()</code></span>
<span class="comment-copy">drop <code>list</code> to get an iterator.</span>
