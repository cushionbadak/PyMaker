<div class="post-text" itemprop="text">
<p>Finally I fix this ask use code like this:(2018-06-03)</p>
<pre><code>class Main:
    @app.route('^/$')
    def default(self):
        return 'hello from class ccc'

module=sys.modules[func.__module__]
cls=getattr(module,func.__qualname__.replace('.'+func.__name__,''))      
ins=cls()
m=getattr(cls,func.__name__)    
resp.body=m(cls) #func.__module__+'.'+func.__qualname__+' func:'+func.__name__
</code></pre>
<p>That's not pyhonic right?I'm new guy to python</p>
<p>//////old</p>
<pre><code>class D:
    def __init__(self):
        self.handlers={}

    def check(self,func):
        self.handlers['h']=func

        def decorator(*args,**kwargs):
            return func(*args,**kwargs)
        return decorator

    def call(self,p):
        return self.handlers['h'](p)

d=D()

class Test:
    @d.check
    def prt(self,v):
        print(v)

t=Test()
d.call(123)
</code></pre>
<p>There is error infoï¼šprt() missing 1 required positional argument: 'v'</p>
<p>It seems need a parameter named 'self' but how can i pass it?</p>
<p>//edit (2018-06-01)</p>
<p>Thanks to all.I ask this cause I try write a python web framework.And I want route to a method of class like below</p>
<pre><code>app=MyFrm()

class Controller:
    @app.route('/')
    def hello():
        return 'hello world'
</code></pre>
<p>But existing do like below.It's no need or nobody to do this in python?</p>
<pre><code>app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"
</code></pre>
<p>Now I fixed this problem use @staticmethod</p>
</div>
<div class="post-text" itemprop="text">
<p>Decorators are applied <em>when the function is declared</em>, so just before the class is created to which the functions are registered as methods.</p>
<p>So <code>func</code> passed into your decorator is <em>not bound to an instance</em>, and you can't just call it without explicitly passing in an instance. Moreover, you don't have access to the instance stored in <code>t</code>, that's created entirely outside of the decorator.</p>
<p>You'd have to explicitly pass along the instance to call the method on:</p>
<pre><code>t = Test()
d.call(t, 123)
</code></pre>
<p>or register methods <em>after</em> creating an instance, in the <code>__init__</code> method. Methods are bound when you look them up as an attribute on an instance, via the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">decriptor protocol</a>. Only bound methods have a reference to the instance that is to be bound to <code>self</code>:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     def bar(self):
...         return self
...
&gt;&gt;&gt; Foo.bar  # unbound
&lt;function Foo.bar at 0x108d38f28&gt;
&gt;&gt;&gt; Foo.bar()  # no self to bind to
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: bar() missing 1 required positional argument: 'self'
&gt;&gt;&gt; instance = Foo()
&gt;&gt;&gt; instance.bar  # bound method
&lt;bound method Foo.bar of &lt;__main__.Foo object at 0x109a916d8&gt;&gt;
&gt;&gt;&gt; instance.bar.__self__ is instance  # to the instance
True
&gt;&gt;&gt; instance.bar()  # so the instance is passed in for self
&lt;__main__.Foo object at 0x109a916d8&gt;
&gt;&gt;&gt; Foo.bar(instance)  # or you can do it manually
&lt;__main__.Foo object at 0x109a916d8&gt;
</code></pre>
<p>If you <em>do</em> fix your registration to store bound methods, you'll need to take into account that the registration is now an extra reference to the instance, keeping it alive in memory even if all other references to the instance are removed. If this is an issue, you'd need to use <em>weak references to the unbound function and the instance</em>, not to the method, as methods are created <em>dynamically and generally have no other references to them</em>. See <a href="https://stackoverflow.com/questions/21826700/using-python-weakset-to-enable-a-callback-functionality">using python WeakSet to enable a callback functionality</a></p>
</div>
<span class="comment-copy">What's the point of the <code>decorator</code> inner function? Why not just return <code>func</code> unaltered?</span>
<span class="comment-copy">I don't get it. What are the decorator and the <code>call</code> function supposed to do?</span>
<span class="comment-copy">@Aran-Fey: imagine an event handler system, and the OP wants to register those methods in a class as event callbacks.</span>
<span class="comment-copy">@MartijnPieters That doesn't make any sense though. There's no <code>Test</code> instance that could be passed to the <code>prt</code> method. If that's what they're trying to do, it's fundamentally flawed. If you're right, the OP needs to explain which <code>Test</code> instance should be passed to <code>prt</code> and why.</span>
<span class="comment-copy">@Aran-Fey: that is the common flaw in such systems, yes. You and I know that decorators are applied to the function before the class object is even created, and how binding works. To people new to Python that's all very magical and it is not always clear to them why the function passed to a decorator doesn't have <code>self</code> filled in.</span>
<span class="comment-copy">If <code>d.call</code> takes an instance as the first argument that's forwarded to the decorated methods, that would mean that the decorator can only be used with methods (and no functions). I'm not convinced that this is a good solution.</span>
<span class="comment-copy">@Aran-Fey: that's again an inherent problem with callback registrations for methods. Either you handle those explicitly (store weak refences to both the instance and the unbound function or live with hard reference and store the bound method to a specific instance at registration time), or you have to make sure the calling code passes in all arguments including an instance.</span>
<span class="comment-copy">@Aran-Fey: basically, you should never use a decorator to register handlers if you were thinking of using per-instance callbacks. If you are registering with a decorator on the class, then you must either have a registry to look up suitable instance(s) to bind the method to, or use static / class methods only.</span>
<span class="comment-copy">Ah, I misunderstood. I thought you were suggesting to rewrite <code>d.call</code> to <i>always</i> expect an instance as the first argument. My bad. I take back everything I said; that's a perfectly acceptable solution.</span>
