<div class="post-text" itemprop="text">
<p>A <code>set</code> uses <code>.update</code> to add multiple items, and <code>.add</code> to add a single one. Why doesn't <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> work the same way? </p>
<p>To increment a single <code>Counter</code> item using <code>Counter.update</code>, you have to add it to a list:</p>
<pre><code>c = Counter()

for item in something:
    for property in properties_of_interest:
        if item.has_some_property: # pseudocode: more complex logic here
            c.update([item.property])
        elif item.has_some_other_property:
            c.update([item.other_property])
        # elif... etc
</code></pre>
<p>Can I get <code>Counter</code> to act like <code>set</code> (i.e. eliminate having to put the property in a list)?</p>
<p><strong>Edit:</strong> Use Case: Imagine a case where you have some unknown objects, and you're trying many different things quickly to find out some preliminary things about them: performance and scaling don't matter, and a comprehension would make adding and subtracting logic time-consuming.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, you don't really need to use methods of <code>Counter</code> in order to count, do you? There's a <code>+=</code> operator for that, which also works in conjunction with Counter.</p>
<pre><code>c = Counter()
for item in something:
    if item.has_some_property:
        c[item.property] += 1
    elif item.has_some_other_property:
        c[item.other_property] += 1
    elif item.has_some.third_property:
        c[item.third_property] += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; c = collections.Counter(a=23, b=-9)
</code></pre>
<p>You can add a new element and set its value like this:</p>
<pre><code>&gt;&gt;&gt; c['d'] = 8
&gt;&gt;&gt; c
Counter({'a': 23, 'd': 8, 'b': -9})
</code></pre>
<p>Increment:</p>
<pre><code>&gt;&gt;&gt; c['d'] += 1
&gt;&gt;&gt; c
Counter({'a': 23, 'd': 9, 'b': -9} 
</code></pre>
<p>Note though that <code>c['b'] = 0</code> does not delete:</p>
<pre><code>&gt;&gt;&gt; c['b'] = 0
&gt;&gt;&gt; c
Counter({'a': 23, 'd': 9, 'b': 0})
</code></pre>
<p>To delete use <code>del</code>:</p>
<pre><code>&gt;&gt;&gt; del c['b']
&gt;&gt;&gt; c
Counter({'a': 23, 'd': 9})
</code></pre>
<p>Counter is a dict subclass</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a more Pythonic way to do what you want:</p>
<pre><code>c = Counter(item.property for item in something if item.has_some_property)
</code></pre>
<p>It uses a <a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow">generator expression</a> instead of open-coding the loop.</p>
<p><strong>Edit:</strong> Missed your no-list-comprehensions paragraph. I still think this is the way to actually use <code>Counter</code> in practice. If you have too much code to put into a generator expression or list comprehension, it is often better to factor that into a function and call that from a comprehension.</p>
</div>
<span class="comment-copy">So whats wrong with your code and <code>Counter.update</code>?</span>
<span class="comment-copy">I have to stick it onto a fake list. It's not a big deal; I'm just wondering if there's a thought behind no <code>add</code>.</span>
<span class="comment-copy">The <code>update</code> method accept an iterable aas argument and  the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs.</span>
<span class="comment-copy">Like I said in a comment - how does <code>add</code> even help you there - you're doing selections on <b>what</b> to add... I'm failing to see the point - can you give an example of how the <code>.add</code> would work?</span>
<span class="comment-copy">Does <code>has_some_property</code> actually have different logic than just taking the property itself? - Also note - with the current <code>helper</code> you may get  <code>None</code> results into your <code>Counter</code> - which may be desirable or not...</span>
<span class="comment-copy">A list comprehension, a generator expression -- can do it, but with complex if/elif/elif/etc, it doesn't work.</span>
<span class="comment-copy">@bahmait and how do you imagine <code>set.add</code> helps with complex <code>if/elif/elif</code> etc...?</span>
<span class="comment-copy">@bahmait: Just edited. Factoring that logic into a separate function is the Pythonic way to do this, I guess. I agree that an <code>add()</code> method might be a nice addition, but perhaps the omission was deliberate to push people to the generator style.</span>
<span class="comment-copy">@JonClements wouldn't it make things easy to read if doing a bunch of things on each pass in addition to updating the counter? I was looking for the <code>+= 1</code> for cases where slow is fine, and having all the logic in one place is nice. Does that make sense?</span>
<span class="comment-copy">@bahmait yup... the answer you've accepted is definitely the most readable and scalable :)</span>
