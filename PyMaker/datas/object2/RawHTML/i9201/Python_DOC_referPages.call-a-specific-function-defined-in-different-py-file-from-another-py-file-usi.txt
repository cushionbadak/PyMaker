<div class="post-text" itemprop="text">
<p>I have a .py file containing some functions. SO it looks  like:-</p>
<pre><code>class Test_suites():
    def fun1():
        print("hello fun1 here")
    def fun2():
        print("hello fun2 here")
    def fun3():
        print("hello fun3 here")
    def fun4():
      print("hello fun4 here")
</code></pre>
<p>Now I have another file which takes input from user and try to call that specific function from first python file.It looks like:-</p>
<pre><code>from test_suites import Test_Suites

ob=Test_Suites()
dictionary={1:'fun1',2:'fun2',3:'fun3',4:'fun4'}
user_input=eval(input("enter the test case number"))
string=dictionary[user_input]
ob.string()
</code></pre>
<p>but it is throwing a error :-ImportError: cannot import name 'Test_Suites'  </p>
<p>Please give some insight of how to solve this problem.
thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Like I said in my comment, use <code>getattr</code> to access a function by its name.</p>
<pre><code>#test_suites.py
def fun1():
    print("hello fun1 here")
def fun2():
    print("hello fun2 here")
def fun3():
    print("hello fun3 here")
def fun4():
  print("hello fun4 here")


import test_suites

func1 = getattr(test_suites, 'func1')
# call func1()
#...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In your code <code>string</code> is a string with the name of the function you want to call. <code>ob.string()</code> looks for a function namend string on the object <code>ob</code>. To get a an attribute with name <code>name</code> from an object <code>obj</code> use <code>getattr(obj, name)</code>, so in your case:</p>
<pre><code>getattr(ob, string)()
</code></pre>
<p>Also as Tagc points out in the comments <code>eval</code> is a bad idea in the way you use it. Instead use <code>user_input=int(input("enter the test case number"))</code> which parses the given string to an integer.</p>
<p>If you ever need something more flexible you can use <code>ast.literal_eval</code> from the <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">ast module</a> which can also parse lists, dicts, ... (<a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">https://docs.python.org/3/library/ast.html#ast.literal_eval</a>)</p>
</div>
<span class="comment-copy"><code>from test_suites import Test_Suites</code> should be <code>from test_suites import Test_suites</code>. The <code>s</code> in <code>Suites</code> is small in the class definition. Import it the way it is defined.</span>
<span class="comment-copy">@Tagc Don't do it. If he tries, he will be in trouble.</span>
<span class="comment-copy">to run a function by its name (either from a module or a class) use <code>getattr(&lt;object&gt;, '&lt;function_name&gt;')</code></span>
<span class="comment-copy">Yeah sorry, the point I'm trying to make is how dangerous that code is. Don't try it out OP</span>
<span class="comment-copy">Deleted it, but OP really needs to change that code.</span>
<span class="comment-copy">"Instead use <code>ast.literal_eval</code>" Why not just <code>int(input(...))</code> in this case, though?</span>
<span class="comment-copy">Yup !! Its working @syntonym</span>
<span class="comment-copy">@Tagc You are right, in this case it's pointless. But I see no downside of using <code>ast.literal_eval</code>, but in slightly different usecases <code>int(input())</code> might not work, but <code>literal_eval</code> would. For these cases I wanted to point other users in the right direction (<code>ast.literal_eval</code> can be hard to find, if you don't know where it is). Or do you see any downsides of using it here?</span>
<span class="comment-copy">@syntonym Downsides are that it's less clear (<code>int(input(...))</code> is more readable) and that an exception is raised immediately at that point if the user does not enter an integer (it's good practice to have errors generate as early as possible, to help track down problems).</span>
