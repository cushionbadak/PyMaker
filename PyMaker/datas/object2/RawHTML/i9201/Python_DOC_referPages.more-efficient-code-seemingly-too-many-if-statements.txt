<div class="post-text" itemprop="text">
<p>I've looked into this but I couldn't find anything that helped me (Apologies if the answer to something similar is out there that could have helped me). I'm writing a currency converter that suffers from tons of <code>if</code>'s that just doesn't seem efficient nor can I imagine very nicely readable, so I'd like to know how I can write more efficient code in this case:</p>
<pre><code>prompt = input("Input") #For currency, inputs should be written like "C(NUMBER)(CURRENCY TO CONVERT FROM)(CURRENCY TO CONVERT TO)" example "C1CPSP"

if prompt[0] == "C": #Looks at first letter and sees if it's "C". C = Currency Conversion
    #CP = Copper Piece, SP = Silver Piece, EP = Electrum Piece, GP = Gold Piece, PP = Platinum Piece
    ccint = int(''.join(list(filter(str.isdigit, prompt)))) # Converts Prompt to integer(Return string joined by str.(Filters out parameter(Gets digits (?), from prompt))))
    ccalpha = str(''.join(list(filter(str.isalpha, prompt)))) #Does the same thing as above expect with letters

    if ccalpha[1] == "C": #C as in start of CP
        acp = [ccint, ccint/10, ccint/50, ccint/100, ccint/1000] #Array of conversions. CP, SP, EP, GP, PP
        if ccalpha[3] == "C": #C as in start of CP
            print(acp[0]) #Prints out corresponding array conversion
        if ccalpha[3] == "S": #S as in start of SP, ETC. ETC.
            print(acp[1])
        if ccalpha[3] == "E":
            print(acp[2])
        if ccalpha[3] == "G":
            print(acp[3])
        if ccalpha[3] == "P":
            print(acp[4])
    if ccalpha[1] == "S":
        asp = [ccint*10, ccint, ccint/10, ccint/10, ccint/100]
        if ccalpha[3] == "C":
            print(asp[0])
        if ccalpha[3] == "S":
            print(asp[1])
        if ccalpha[3] == "E":
            print(asp[2])
        if ccalpha[3] == "G":
            print(asp[3])
        if ccalpha[3] == "P":
            print(asp[4])
    if ccalpha[1] == "E":
        aep = [ccint*50, ccint*5 ,ccint , ccint/2, ccint/20]
        if ccalpha[3] == "C":
            print(aep[0])
        if ccalpha[3] == "S":
            print(aep[1])
        if ccalpha[3] == "E":
            print(aep[2])
        if ccalpha[3] == "G":
            print(aep[3])
        if ccalpha[3] == "P":
            print(aep[4])
    if ccalpha[1] == "G":
        agp = [ccint*100, ccint*10, ccint*2, ccint, ccint/10]
        if ccalpha[3] == "C":
            print(agp[0])
        if ccalpha[3] == "S":
            print(agp[1])
        if ccalpha[3] == "E":
            print(agp[2])
        if ccalpha[3] == "G":
            print(agp[3])
        if ccalpha[3] == "P":
            print(agp[4])
    if ccalpha[1] == "P":
        app = [ccint*1000, ccint*100, ccint*20, ccint*10, ccint]
        if ccalpha[3] == "C":
            print(app[0])
        if ccalpha[3] == "S":
            print(app[1])
        if ccalpha[3] == "E":
            print(app[2])
        if ccalpha[3] == "G":
            print(app[3])
        if ccalpha[3] == "P":
            print(app[4])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can always use dictionaries for lookups:</p>
<pre><code>lookup = {'C': {'C': ccint, 'S': ccint/10, 'E': ccint/50, 'G': ccint/100, 'P': ccint/1000},
          'S': {'C': ccint*10, 'S': ccint, 'E': ccint/10, 'G': ccint/10, 'P': ccint/100},
          'E': {'C': ccint*50, 'S': ccint*5, 'E': ccint, 'G': ccint/2, 'P': ccint/20},
          'G': {'C': ccint*100, 'S': ccint*10, 'E': ccint*2, 'G': ccint, 'P': ccint/10},
          'P': {'C': ccint*1000, 'S': ccint*100, 'E': ccint*20, 'G': ccint*10, 'P': ccint}
         }
</code></pre>
<p>Then all your <code>if</code>s are mostly covered by:</p>
<pre><code>print(lookup[ccalpha[1]][ccalpha[3]])
</code></pre>
<p>However is it possible that other characters are included? Then you'd need to introduce a fallback:</p>
<pre><code>try:
    print(lookup[ccalpha[1]][ccalpha[3]])
except KeyError:
    # Failed to find an entry for the characters:
    print(ccalpha[1], ccalpha[3], "combination wasn't found")
</code></pre>
<hr/>
<p>As noted it's not the most efficient way because it calculates every conversion (even unneccessary ones) each time. It could be more efficient to have a baseline, for example <code>P</code> and have the factors saved:</p>
<pre><code>lookup = {'C': 1000,
          'S': 100,
          'E': 50,
          'G': 10,
          'P': 1,
          }

# I hope I have them the right way around... :-)
print(ccint * lookup[ccalpha[3]] / lookup[ccalpha[1]])  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of converting directly from the source unit to the target unit, you should do it in two steps:</p>
<pre><code>factors = { 'CP': 1, 'SP': 10, and so on }

def convert_currency(amount, from_unit, to_unit):
    copper = amount * factors[from_unit]
    return copper / factors[to_unit]
</code></pre>
<p>This code is all you need. You can call it like this:</p>
<pre><code>print(convert_currency(12345, 'SP', 'EP'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another approach, using a <em>matrix</em> (in fact just a list of lists):</p>
<pre><code>conversion_rate = [[1, 1 / 10, 1 / 50, 1 / 100, 1 / 1000],
                   [1 * 10, 1, 1 / 10, 1 / 10, 1 / 100],
                   [1 * 50, 1 * 5, 1, 1 / 2, 1 / 20],
                   [1 * 100, 1 * 10, 1 * 2, 1, 1 / 10],
                   [1 * 1000, 1 * 100, 1 * 20, 1 * 10, 1]]
currency_value =  {'C':0,'S': 1, 'E': 2, 'G': 3, 'P': 4}

from_ = currency_value[ccalpha[1]]
to = currency_value[ccalpha[3]]

print(ccint*conversion_rate[from_][to])
</code></pre>
<p>First you create the currency conversion matrix.
Then you match currency with a number (pretty wuch like an <code>enum</code> in other languages such as C or Java). For this you use a dictionary: it is like a list except that you define indexes (it is not from 0 to length - 1).
Then you get the appropriate conversion rate, multiply it with your number and print it.</p>
<p>This is pretty similar to MSeifert answer, except that you use less dictionary, so it may be easier to understand if you’re not comfortable with those. </p>
</div>
<span class="comment-copy">Are you familiar with dictionaries?</span>
<span class="comment-copy">I am not sorry to say</span>
<span class="comment-copy">You can use dictionary instead of if statement, but for smaller expressions like you have used, the efficiency becomes meaningless since the if statement is already lot faster for small expressions. But dictionary does provide a better readability. Another thing to provide better readability would be to use a for loop or a generator but dictionary provides better readability and efficiency so its better option(<a href="http://scottlobdell.me/2014/05/time-efficiency-statements-vs-python-dictionaries" rel="nofollow noreferrer">Efficiency comparison of if statement and dictionary</a>) (MSeifert has provided the required dictionary)</span>
<span class="comment-copy">You could also try regular expressions from the <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">re</a> module.</span>
<span class="comment-copy">I have not used dictionaries before, they are seemingly like arrays? And for <code>print(lookup[ccalpha[1]][ccalpha[3]])</code>, it would go to the corresponding letter and then go into the set of {} to find the letter of [3]? I would like to make sure my understanding is correct. Thank you.</span>
<span class="comment-copy">A dictionary consists of key-value pairs, instead of accessing the items by index (like for arrays) you access them by key, for example if <code>ccalpha[1] = 'S'</code> and <code>ccalpha[3] = 'E'</code> this will first get the dictionary for <code>'S'</code>: <code>{'C': ccint*10, 'S': ccint, 'E': ccint/10, 'G': ccint/10, 'P': ccint/100}</code> and then choose the value for <code>'E'</code>: <code>ccint/10</code>.</span>
<span class="comment-copy">This code computes all possible conversions but then only uses one of them. It is therefore inefficient.</span>
<span class="comment-copy">@RolandIllig Point taken, I've included an alternative which doesn't calculate them every time.</span>
<span class="comment-copy">Is there any specific reason as to use one over the other (matrix and dictionary) besides preference?</span>
<span class="comment-copy">It depends on what you are doing, here I don’t see any.</span>
