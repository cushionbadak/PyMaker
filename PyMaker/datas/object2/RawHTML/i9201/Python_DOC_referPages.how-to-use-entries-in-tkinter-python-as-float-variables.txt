<div class="post-text" itemprop="text">
<p>In Python, how can I parse a numeric string like <code>"545.2222"</code> to its corresponding float value, <code>545.2222</code>? Or parse the string <code>"31"</code> to an integer, <code>31</code>?</p>
<p>I just want to know how to parse a <em>float</em> <code>str</code> to a <code>float</code>, and (separately) an <em>int</em> <code>str</code> to an <code>int</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; a = "545.2222"
&gt;&gt;&gt; float(a)
545.22220000000004
&gt;&gt;&gt; int(float(a))
545
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def num(s):
    try:
        return int(s)
    except ValueError:
        return float(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Python method to check if a string is a float:</h2>
<pre><code>def is_float(value):
  try:
    float(value)
    return True
  except:
    return False
</code></pre>
<p>A longer and more accurate name for this function could be: <code>is_convertible_to_float(value)</code></p>
<h2>What is, and is not a float in <a href="http://en.wikipedia.org/wiki/Python_%28programming_language%29" rel="noreferrer">Python</a> may surprise you:</h2>
<pre><code>val                   is_float(val) Note
--------------------  ----------   --------------------------------
""                    False        Blank string
"127"                 True         Passed string
True                  True         Pure sweet Truth
"True"                False        Vile contemptible lie
False                 True         So false it becomes true
"123.456"             True         Decimal
"      -127    "      True         Spaces trimmed
"\t\n12\r\n"          True         whitespace ignored
"NaN"                 True         Not a number
"NaNanananaBATMAN"    False        I am Batman
"-iNF"                True         Negative infinity
"123.E4"              True         Exponential notation
".1"                  True         mantissa only
"1,234"               False        Commas gtfo
u'\x30'               True         Unicode is fine.
"NULL"                False        Null is not special
0x3fade               True         Hexadecimal
"6e7777777777777"     True         Shrunk to infinity
"1.797693e+308"       True         This is max value
"infinity"            True         Same as inf
"infinityandBEYOND"   False        Extra characters wreck it
"12.34.56"            False        Only one dot allowed
u'å››'                 False        Japanese '4' is not a float.
"#56"                 False        Pound sign
"56%"                 False        Percent of what?
"0E0"                 True         Exponential, move dot 0 places
0**0                  True         0___0  Exponentiation
"-5e-5"               True         Raise to a negative number
"+1e1"                True         Plus is OK with exponent
"+1e1^5"              False        Fancy exponent not interpreted
"+1e1.3"              False        No decimals in exponent
"-+1"                 False        Make up your mind
"(1)"                 False        Parenthesis is bad
</code></pre>
<p>You think you know what numbers are? You are not so good as you think! Not big surprise.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is another method which deserves to be mentioned here, <a href="http://docs.python.org/library/ast.html#ast.literal_eval" rel="noreferrer">ast.literal_eval</a>:</p>
<blockquote>
<p>This can be used for safely evaluating strings containing Python expressions from untrusted sources without the need to parse the values oneself.</p>
</blockquote>
<p>That is, a safe 'eval'</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.literal_eval("545.2222")
545.2222
&gt;&gt;&gt; ast.literal_eval("31")
31
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>float(x) if '.' in x else int(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Localization and commas</h2>
<p>You should consider the possibility of commas in the string representation of a number, for cases like  <code>float("545,545.2222")</code> which throws an exception. Instead, use methods in <code>locale</code> to convert the strings to numbers and interpret commas correctly. The <code>locale.atof</code> method converts to a float in one step once the locale has been set for the desired number convention.</p>
<p><strong>Example 1 -- United States number conventions</strong> </p>
<p>In the United States and the UK, commas can be used as a thousands separator.  In this example with American locale, the comma is handled properly as a separator:</p>
<pre><code>&gt;&gt;&gt; import locale
&gt;&gt;&gt; a = u'545,545.2222'
&gt;&gt;&gt; locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')
'en_US.UTF-8'
&gt;&gt;&gt; locale.atof(a)
545545.2222
&gt;&gt;&gt; int(locale.atof(a))
545545
&gt;&gt;&gt;
</code></pre>
<p><strong>Example 2 -- European number conventions</strong></p>
<p>In the <a href="https://en.wikipedia.org/wiki/Decimal_mark">majority of countries of the world</a>,  commas are used for decimal marks instead of periods.  In this example with French locale, the comma is correctly handled as a decimal mark:</p>
<pre><code>&gt;&gt;&gt; import locale
&gt;&gt;&gt; b = u'545,2222'
&gt;&gt;&gt; locale.setlocale(locale.LC_ALL, 'fr_FR')
'fr_FR'
&gt;&gt;&gt; locale.atof(b)
545.2222
</code></pre>
<p>The method <code>locale.atoi</code> is also available, but the argument should be an integer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Users <em>codelogic</em> and <em>harley</em> are correct, but keep in mind if you know the string is an integer (for example, 545) you can call int("545") without first casting to float.</p>
<p>If your strings are in a list, you could use the map function as well. </p>
<pre><code>&gt;&gt;&gt; x = ["545.0", "545.6", "999.2"]
&gt;&gt;&gt; map(float, x)
[545.0, 545.60000000000002, 999.20000000000005]
&gt;&gt;&gt;
</code></pre>
<p>It is only good if they're all the same type.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you aren't averse to third-party modules, you could check out the <a href="https://pypi.org/project/fastnumbers" rel="noreferrer">fastnumbers</a> module. It provides a function called <a href="http://fastnumbers.readthedocs.io/en/master/api.html#fastnumbers.fast_real" rel="noreferrer">fast_real</a> that does exactly what this question is asking for and does it faster than a pure-Python implementation:</p>
<pre><code>&gt;&gt;&gt; from fastnumbers import fast_real
&gt;&gt;&gt; fast_real("545.2222")
545.2222
&gt;&gt;&gt; type(fast_real("545.2222"))
float
&gt;&gt;&gt; fast_real("31")
31
&gt;&gt;&gt; type(fast_real("31"))
int
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The question seems a little bit old. But let me suggest a function, parseStr, which makes something similar, that is, returns integer or float and if a given ASCII string cannot be converted to none of them it returns it untouched. The code of course might be adjusted to do only what you want:</p>
<pre><code>   &gt;&gt;&gt; import string
   &gt;&gt;&gt; parseStr = lambda x: x.isalpha() and x or x.isdigit() and \
   ...                      int(x) or x.isalnum() and x or \
   ...                      len(set(string.punctuation).intersection(x)) == 1 and \
   ...                      x.count('.') == 1 and float(x) or x
   &gt;&gt;&gt; parseStr('123')
   123
   &gt;&gt;&gt; parseStr('123.3')
   123.3
   &gt;&gt;&gt; parseStr('3HC1')
   '3HC1'
   &gt;&gt;&gt; parseStr('12.e5')
   1200000.0
   &gt;&gt;&gt; parseStr('12$5')
   '12$5'
   &gt;&gt;&gt; parseStr('12.2.2')
   '12.2.2'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>In Python, how can I parse a numeric string like "545.2222" to its corresponding float value, 542.2222? Or parse the string "31" to an integer, 31?</strong>
  I just want to know how to parse a float string to a float, and (separately) an int string to an int.</p>
</blockquote>
<p>It's good that you ask to do these separately. If you're mixing them, you may be setting yourself up for problems later. The simple answer is:</p>
<p><strong><code>"545.2222"</code> to float:</strong></p>
<pre><code>&gt;&gt;&gt; float("545.2222")
545.2222
</code></pre>
<p><strong><code>"31"</code> to an integer:</strong></p>
<pre><code>&gt;&gt;&gt; int("31")
31
</code></pre>
<h1>Other conversions, ints to and from strings and literals:</h1>
<p>Conversions from various bases, and you should know the base in advance (10 is the default). Note you can prefix them with what Python expects for its literals (see below) or remove the prefix:</p>
<pre><code>&gt;&gt;&gt; int("0b11111", 2)
31
&gt;&gt;&gt; int("11111", 2)
31
&gt;&gt;&gt; int('0o37', 8)
31
&gt;&gt;&gt; int('37', 8)
31
&gt;&gt;&gt; int('0x1f', 16)
31
&gt;&gt;&gt; int('1f', 16)
31
</code></pre>
<p>If you don't know the base in advance, but you do know they will have the correct prefix, Python can infer this for you if you pass <code>0</code> as the base:</p>
<pre><code>&gt;&gt;&gt; int("0b11111", 0)
31
&gt;&gt;&gt; int('0o37', 0)
31
&gt;&gt;&gt; int('0x1f', 0)
31
</code></pre>
<h3>Non-Decimal (i.e. Integer) Literals from other Bases</h3>
<p>If your motivation is to have your own code clearly represent hard-coded specific values, however, you may not need to convert from the bases - you can let Python do it for you automatically with the correct syntax.</p>
<p>You can use the apropos prefixes to get automatic conversion to integers with <a href="https://docs.python.org/3/reference/lexical_analysis.html#integer-literals" rel="noreferrer">the following literals</a>. These are valid for Python 2 and 3:</p>
<p>Binary, prefix <code>0b</code></p>
<pre><code>&gt;&gt;&gt; 0b11111
31
</code></pre>
<p>Octal, prefix <code>0o</code></p>
<pre><code>&gt;&gt;&gt; 0o37
31
</code></pre>
<p>Hexadecimal, prefix <code>0x</code></p>
<pre><code>&gt;&gt;&gt; 0x1f
31
</code></pre>
<p>This can be useful when describing binary flags, file permissions in code, or hex values for colors - for example, note no quotes:</p>
<pre><code>&gt;&gt;&gt; 0b10101 # binary flags
21
&gt;&gt;&gt; 0o755 # read, write, execute perms for owner, read &amp; ex for group &amp; others
493
&gt;&gt;&gt; 0xffffff # the color, white, max values for red, green, and blue
16777215
</code></pre>
<h3>Making ambiguous Python 2 octals compatible with Python 3</h3>
<p>If you see an integer that starts with a 0, in Python 2, this is (deprecated) octal syntax.</p>
<pre><code>&gt;&gt;&gt; 037
31
</code></pre>
<p>It is bad because it looks like the value should be <code>37</code>. So in Python 3, it now raises a <code>SyntaxError</code>:</p>
<pre><code>&gt;&gt;&gt; 037
  File "&lt;stdin&gt;", line 1
    037
      ^
SyntaxError: invalid token
</code></pre>
<p>Convert your Python 2 octals to octals that work in both 2 and 3 with the <code>0o</code> prefix:</p>
<pre><code>&gt;&gt;&gt; 0o37
31
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>float("545.2222")</code> and <code>int(float("545.2222"))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://en.wikipedia.org/wiki/YAML" rel="noreferrer">YAML</a> parser can help you figure out what datatype your string is. Use <code>yaml.load()</code>, and then you can use <code>type(result)</code> to test for type:</p>
<pre><code>&gt;&gt;&gt; import yaml

&gt;&gt;&gt; a = "545.2222"
&gt;&gt;&gt; result = yaml.load(a)
&gt;&gt;&gt; result
545.22220000000004
&gt;&gt;&gt; type(result)
&lt;type 'float'&gt;

&gt;&gt;&gt; b = "31"
&gt;&gt;&gt; result = yaml.load(b)
&gt;&gt;&gt; result
31
&gt;&gt;&gt; type(result)
&lt;type 'int'&gt;

&gt;&gt;&gt; c = "HI"
&gt;&gt;&gt; result = yaml.load(c)
&gt;&gt;&gt; result
'HI'
&gt;&gt;&gt; type(result)
&lt;type 'str'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I use this function for that</p>
<pre><code>import ast

def parse_str(s):
   try:
      return ast.literal_eval(str(s))
   except:
      return
</code></pre>
<p>It will convert the string to its type</p>
<pre><code>value = parse_str('1')  # Returns Integer
value = parse_str('1.5')  # Returns Float
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def get_int_or_float(v):
    number_as_float = float(v)
    number_as_int = int(number_as_float)
    return number_as_int if number_as_float == number_as_int else number_as_float
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to take into account rounding to do this properly.</p>
<p>I.e. int(5.1) =&gt; 5
     int(5.6) =&gt; 5  -- wrong, should be 6 so we do int(5.6 + 0.5) =&gt; 6</p>
<pre><code>def convert(n):
    try:
        return int(n)
    except ValueError:
        return float(n + 0.5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def num(s):
"""num(s)
num(3),num(3.7)--&gt;3
num('3')--&gt;3, num('3.7')--&gt;3.7
num('3,700')--&gt;ValueError
num('3a'),num('a3'),--&gt;ValueError
num('3e4') --&gt; 30000.0
"""
try:
    return int(s)
except ValueError:
    try:
        return float(s)
    except ValueError:
        raise ValueError('argument is not a string of number')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am surprised nobody mentioned regex because sometimes string must be prepared and normalized before casting to number</p>
<pre><code>import re
def parseNumber(value, as_int=False):
    try:
        number = float(re.sub('[^.\-\d]', '', value))
        if as_int:
            return int(number + 0.5)
        else:
            return number
    except ValueError:
        return float('nan')  # or None if you wish
</code></pre>
<p>usage:</p>
<pre><code>parseNumber('13,345')
&gt; 13345.0

parseNumber('- 123 000')
&gt; -123000.0

parseNumber('99999\n')
&gt; 99999.0
</code></pre>
<p>and by the way, something to verify you have a number:</p>
<pre><code>import numbers
def is_number(value):
    return isinstance(value, numbers.Number)
    # will work with int, float, long, Decimal
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python have this great flexibility of parsing in one liners. </p>
<pre><code>str = "545.2222"
print ("int: ", + int(float(a)))
print ("float: ", +(float(a)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To typecast in python use the constructor funtions of the type, passing the string (or whatever value you are trying to cast) as a parameter.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt;float("23.333")
   23.333
</code></pre>
<p>Behind the scenes, python is calling the objects <code>__float__</code> method, which should return a float representation of the parameter. This is especially powerful, as you can define your own types (using classes) with a <code>__float__</code> method so that it can be casted into a float using float(myobject).</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>This is a corrected version</strong> of 
<a href="https://stackoverflow.com/a/33017514/5973334">https://stackoverflow.com/a/33017514/5973334</a></p>
<p>This will try to parse a string and return either <code>int</code> or <code>float</code> depending on what the string represents.
It might rise parsing exceptions or <a href="https://stackoverflow.com/a/1778381/5973334">have some unexpected behaviour</a>.</p>
<pre><code>  def get_int_or_float(v):
        number_as_float = float(v)
        number_as_int = int(number_as_float)
        return number_as_int if number_as_float == number_as_int else 
        number_as_float
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>str()</code> to convert any variable to string, <code>int()</code> to convert string integers to integers and <code>float()</code> to convert string floating numbers to float value.</p>
<pre><code>str_to_float = float("545.2222")
str_to_int = int("31")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use:</p>
<pre><code>def num(s):
    try:
        for each in s:
            yield int(each)
    except ValueError:
        yield float(each)
a = num(["123.55","345","44"])
print a.next()
print a.next()
</code></pre>
<p>This is the most Pythonic way I could come up with. </p>
</div>
<div class="post-text" itemprop="text">
<p>Use:</p>
<pre><code>&gt;&gt;&gt; str_float = "545.2222"
&gt;&gt;&gt; float(str_float)
545.2222
&gt;&gt;&gt; type(_) # Check its type
&lt;type 'float'&gt;

&gt;&gt;&gt; str_int = "31"
&gt;&gt;&gt; int(str_int)
31
&gt;&gt;&gt; type(_) # Check its type
&lt;type 'int'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you know the str it can be just int or float:</p>
<pre><code>return int(s) if s.isdigit() else float(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another interpretation of your question (hint: it's vague). It's possible you're looking for something like this:</p>
<pre><code>def parseIntOrFloat( aString ):
    return eval( aString )
</code></pre>
<p>It works like this...</p>
<pre><code>&gt;&gt;&gt; parseIntOrFloat("545.2222")
545.22220000000004
&gt;&gt;&gt; parseIntOrFloat("545")
545
</code></pre>
<hr/>
<p>Theoretically, there's an injection vulnerability. The string could, for example be <code>"import os; os.abort()"</code>. Without any background on where the string comes from, however, the possibility is theoretical speculation.  Since the question is vague, it's not at all clear if this vulnerability actually exists or not.</p>
</div>
<span class="comment-copy">As a general rule, if you have an object in Python, and want to convert <i>to</i> that type of object, call <code>type(my_object)</code> on it. The result can usually be called as a function to do the conversion. For instance <code>type(100)</code> results in <code>int</code>, so you can call <code>int(my_object)</code> to try convert <code>my_object</code> to an integer. This doesn't always work, but is a good "first guess" when coding.</span>
<span class="comment-copy">just wondering why there is '04' in the end? why not simply '00'? also my current version of python is not having '04'.</span>
<span class="comment-copy">@MangatRaiModi Floating point numbers are inherently imperfect for representing decimals. For more, see <a href="https://stackoverflow.com/q/21895756/931277">stackoverflow.com/q/21895756/931277</a></span>
<span class="comment-copy">why not simply <code>int(a)</code> but <code>int(float(a))</code> ?</span>
<span class="comment-copy"><code>int(a)</code> will give an error that the string isn't a valid integer: <code>ValueError: invalid literal for int() with base 10: '545.222'</code>, but converting from a float to an int is a supported conversion.</span>
<span class="comment-copy">You should handle <code>ValueError</code> if you want to be safe</span>
<span class="comment-copy"><i>implicit</i> mixing floats/ints might lead to subtle bugs due to possible loss of precision when working with floats or to different results for <code>/</code> operator on floats/ints. Depending on context it might be preferable to return either int or float, not both.</span>
<span class="comment-copy">@J.F.Sebastian You are completely correct, but there are times when you want the input to dictate which one it will be.  Letting the input dictate which one can work nicely with duck-typing.</span>
<span class="comment-copy">You can nest another <code>try</code> to throw an exception when it's not convertible to float.</span>
<span class="comment-copy">Fails with <code>s = u'\u0000'</code></span>
<span class="comment-copy">@iBug Good idea! I recommend throwing <code>ValueError</code> in the corresponding <code>except</code> :P</span>
<span class="comment-copy">Please, consider renaming your function to <code>convertibleToFloat</code> or something similar (current name seems confusing, at least to me).</span>
<span class="comment-copy">So true becomes 1, that is I inherited from C++ i think</span>
<span class="comment-copy">good one, å›› is also chinese (something unrelated :))</span>
<span class="comment-copy">I posted this answer in 2014. That <code>UTF-8</code> glyph for a Chinese <code>4</code> has been transforming over the years depending on how stackoverflow developers change up their character encoding scheme upon their microsoft toolstack.   It's a curiosity to see it flip flop over the years as new conversion schemes assert their new ideologies.  But yes, Any <code>UTF-8</code> glyph for a Eastern oriental numeric is not a Python float.  Bazinga.</span>
<span class="comment-copy">how can this be so upvoted, with such a broad exception?</span>
<span class="comment-copy">this is <i>not</i> a good solution to the problem. It works fine in Python 2, but the following happens in Python 3:  <code>python &gt;&gt;&gt; import ast &gt;&gt;&gt; ast.literal_eval('1-800-555-1212') -2566 &gt;&gt;&gt; </code>  To clarify why this is a problem, if you want it to leave phone numbers alone and not assume they are mathematical expressions, then this approach is not for you.</span>
<span class="comment-copy">@royce3  Yeah, that's a good point and users should beware.  The behaviour was originally modified in order to address some issues with parsing of complex literals.  It's arguably a bug in <code>ast.literal_eval</code>, and has been discussed <a href="https://stackoverflow.com/q/20748202/674039">here</a>.</span>
<span class="comment-copy">Nitpick: doesn't work for extreme cases like float("2e-3")</span>
<span class="comment-copy">Note : be careful when dealing with money amount passed as strings, as some countries use "," as decimal separators</span>
<span class="comment-copy">@Emile: I wouldn't call "2e-3" an "extreme case".  This answer is just broken.</span>
<span class="comment-copy">@BenG DON'T manipulate money as a float. That's asking for trouble. Use decimal for money! (But your comment about ',' is still valid and important)</span>
<span class="comment-copy">Don't forget that "not a number" (NaN) and +/- infinity is also valid float values. So <code>float("nan")</code> is a perfectly valid float value that the above answer wouldn't catch at all</span>
<span class="comment-copy">This seems like an ideal solution when you know if a float or int should be returned, but how can you get this to return an int only if an int was passed? For example, <code>x = '1'; locale.atof(x)</code> returns <code>1.0</code> when I actually want <code>1</code>.</span>
<span class="comment-copy">Using Dino's method, I guess the answer would be to use something like this: <code>locale.atof(x) if locale.localeconv().get('decimal_point') in x else locale.atoi(x)</code></span>
<span class="comment-copy">I would recommend using Javier's method above (wrapping <code>locale.atoi</code> in a try and using <code>locale.atof</code> on exception -- it's probably more readable.</span>
<span class="comment-copy"><code>list(map(float, x))</code> for python 3...</span>
<span class="comment-copy"><code>1e3</code> is a number in python, but a string according to your code.</span>
<span class="comment-copy">This will give you a float object if your string happens to be "0" or "0.0", rather than the int it gives for other valid numbers.</span>
<span class="comment-copy">Why would you raise in your <code>except</code> section if you are doing nothing there? float() would raise for you.</span>
<span class="comment-copy">you are right I guess I copied and paste from a functionality that I was raising a particular exception. will edit. thanks</span>
<span class="comment-copy">This will try to parse a string and return either <code>int</code> or <code>float</code> depending on what the string represents. It might rise parsing exceptions or [have some unexpected behaviour][1].</span>
<span class="comment-copy">Good point. That causes inflation, though, so <a href="http://stackoverflow.com/questions/10825926/python-3-x-rounding-behavior">Python 3</a> and <a href="http://stackoverflow.com/questions/311696/why-does-net-use-bankers-rounding-as-default">other modern languages</a> use banker's rounding.</span>
<span class="comment-copy">This answer is wrong (as originally written). It muddles the two cases of <code>int</code> and <code>float</code>. And it will give an exception, when <code>n</code> is a string, as OP desired. Maybe you meant: <b>When</b> an <code>int</code> result is desired, <code>round</code> should be done AFTER conversion to float. If the function should ALWAYS return an int, then you don't need the except part -- the entire function body can be <code>int(round(float(input)))</code>. If the function should return an int if possible, otherwise a float, then javier's original solution is correct!</span>
<span class="comment-copy">if a string is not a digit, then float won't work either.</span>
<span class="comment-copy">@VigneshT.V. - If a string is '545.2222' so <code>'545.2222'.isdigit()</code> return False so function return 545.2222 else if a string is '31' so <code>'31'.isdigit()</code> return True and function return 31</span>
<span class="comment-copy">Even if his input is 100% safe, <code>eval()</code> is over 3 times as slow as <code>try: int(s) except: float(s)</code>.</span>
<span class="comment-copy">Well, <code>eval</code> is bad practice (you must know because you have 310k reputation)</span>
