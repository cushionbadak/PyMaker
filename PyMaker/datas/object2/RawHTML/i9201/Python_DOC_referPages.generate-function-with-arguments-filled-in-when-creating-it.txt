<div class="post-text" itemprop="text">
<p>My goal is to generate functions dynamically and then save them in a file. For e.g, in my current attempt, On calling <code>create_file</code></p>
<pre><code>import io


def create_file(a_value):
    a_func = make_concrete_func(a_value)
    write_to_file([a_func], '/tmp/code.py')


def make_concrete_func(a_value):
    def concrete_func(b, k):
        return b + k + a_value

    return concrete_func


def write_to_file(code_list, path):
    import inspect
    code_str_list = [inspect.getsource(c) for c in code_list]
    with open(path, 'w') as ofh:
        for c in code_str_list:
            fh = io.StringIO(c)
            ofh.writelines(fh.readlines())
            ofh.write('\n')


create_file('my_value')
</code></pre>
<p>The output I want is (file <code>/tmp/code.py</code>):</p>
<pre><code>def concrete_func(b, k):
    return b + k + 'my_value'
</code></pre>
<p>The output I get is (file <code>'/tmp/code.py'</code>):</p>
<pre><code>def concrete_func(b, k):
    return b + k + a_value
</code></pre>
<p>UPDATE: My solution uses <code>inspect.getsource</code> which returns a string. I wonder if I have limited your options as most solutions below suggest a string replacement. The solution need not use <code>inspect.getsource</code>. You could write it anyhow to get the desired output.</p>
<p>UPDATE 2: The reason I am doing this is because I want to generate a file for Amazon Lambda. Amazon Lambda takes a python file and its virtual environment and will execute it for you(relieving you from worrying about scalability and fault tolerance). You have to tell Lambda which file and which function to call and Lambda will execute it for you. </p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>getsource</code> to convert the function to a string, and replace the variable names with simple string manipulation.</p>
<pre><code>from inspect import getsource

def write_func(fn, path, **kwargs):
    fn_as_string = getsource(fn)
    for var in kwargs:
        fn_as_string = fn_as_string.replace(var, kwargs[var])
    with open(path, 'a') as fp:  # append to file
        fp.write('\n' + fn_as_string)

def base_func(b, k):
    return b + k + VALUE

# add quotes to string literals   
write_func(base_func, '/tmp/code.py', VALUE="'my value'")

# you should replace the function name if you write multiple functions to the file
write_func(base_func, '/tmp/code.py', base_func='another_func', VALUE='5')
</code></pre>
<p>Output is as expected in /tmp/code.py:</p>
<pre><code>def base_func(b, k):
    return b + k + 'my value'

def another_func(b, k):
    return b + k + 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A function definition doesn't look up its free variables (variables that are not defined in the function itself) at time of definition. I.e. <code>concrete_func</code> here:</p>
<pre><code>def make_concrete_func(a_value):
    def concrete_func(b, k):
        return b + k + a_value

    return concrete_func
</code></pre>
<p>doesn't look up <code>a_value</code> when it is defined, instead it will contain code to load <code>a_value</code> from its closure (simplified the enclosing function) at runtime.</p>
<p>You can see this by disassembling the returned function:</p>
<pre><code>f = make_concrete_func(42)

import dis
print dis.dis(f)

  3           0 LOAD_FAST                0 (b)
              3 LOAD_FAST                1 (k)
              6 BINARY_ADD          
              7 LOAD_DEREF               0 (a_value)
             10 BINARY_ADD          
             11 RETURN_VALUE        
None
</code></pre>
<p>You can <em>maybe</em> do what you want by editing the byte code.. it's been done before (<a href="http://bytecodehacks.sourceforge.net/bch-docs/bch/module-bytecodehacks.macro.html" rel="nofollow noreferrer">http://bytecodehacks.sourceforge.net/bch-docs/bch/module-bytecodehacks.macro.html</a> ..shudder).</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this. Note that I have added another parameter to write_to_file</p>
<pre><code>def write_to_file(code_list, path,a_value):
    print "lc",code_list
    code_str_list = [inspect.getsource(c) for c in code_list]
    with open(path, 'w') as ofh:
        for c in code_str_list:
            c= c.replace('a_value','\''+a_value+'\'')
            fh = io.StringIO(c)
            ofh.writelines(fh.readlines())
            ofh.write('\n')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the file doesn't have to be human readable and you trust it won't be manipulated by attackers, combining <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a> and <a href="https://docs.python.org/3.6/library/pickle.html" rel="nofollow noreferrer"><code>pickle</code></a> might be the most pythonic approach. However it comes with disadvantages I don't completely understand: for one thing it doesn't seem to work with locally defined functions (or maybe locally defined variables in general?).</p>
<p>I might just ask my own question about this.</p>
<pre><code>import functools
import pickle


def write_file_not_working():

    def concrete_func_not_working(b, k, a_value):
        return b + k + a_value

    with open('data.pickle', 'wb') as f:
        data = functools.partial(concrete_func_not_working, a_value='my_value')
        pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)


def use_file_not_working():
    with open('data.pickle', 'rb') as f:
        resurrected_data = pickle.load(f)
        print(resurrected_data('hi', 'there'))


def top_level_concrete_func(b, k, a_value):
    return a_value + b + k


def write_file_working():
    with open('working.pickle', 'wb') as f:
        data = functools.partial(top_level_concrete_func, a_value='my_working_value')
        pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)


def use_file_working():
    with open('working.pickle', 'rb') as f:
        resurrected_data = pickle.load(f)
        print(resurrected_data('hi', 'there'))


if __name__ == "__main__":
    write_file_working()
    use_file_working()

    write_file_not_working()
    use_file_not_working()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@Ben made me realize that I didn't need to use a string based approach for code generation and that I could use serialization. Instead of the limited <code>pickle</code> library, I used <code>dill</code> which overcomes the limitation as mentioned by <a href="https://stackoverflow.com/a/41883510/238012">Ben</a></p>
<p>So, I finally did something like.</p>
<pre><code>import dill


def create_file(a_value, path):
    a_func = make_concrete_func(a_value)
    dill.dump(a_func, open(path, "wb"))
    return path


def make_concrete_func(a_value):
    def concrete_func(b, k):
        return b + k + a_value

    return concrete_func


if __name__ == '__main__':
    path = '/tmp/code.dill'
    create_file('Ben', path)
    a_func = dill.load(open(path, "rb"))
    print(a_func('Thank ', 'You '))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if the function you want to create all have a determinate pattern, I would create a template for it and use it to mass produce the functions</p>
<pre><code>&gt;&gt;&gt; def test(*values):
        template="""
def {name}(b,k):
    return b + k + {value}

"""
        for i,v in enumerate(values):
            print( template.format(name="func{}".format(i),value=repr(v)) )


&gt;&gt;&gt; test("my_value",42,[1])

def func0(b,k):
    return b + k + 'my_value'



def func1(b,k):
    return b + k + 42



def func2(b,k):
    return b + k + [1]


&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">You could also use <code>inspect.getclosurevars(f).nonlocals</code> to get the enclosed variables as a dict. <code>{'a_value': 42}</code>. (At least it works in python 3.5 â€“ <code>nonlocals</code> is not available in python 2, I think)</span>
<span class="comment-copy">Sure, but what you need to get this to work the way OP intends is to replace the variable lookup (<code>LOAD_DEREF</code>) with a value load (<code>LOAD_FAST</code>). Just reading the value is not enough.</span>
<span class="comment-copy">This is how I may implement it eventually. It is much cleaner then string replacement. However, I chose the other answer as I may have artificially constrained the question to string replacement strategies by my question. Thanks for thinking outside the question and providing this useful answer!</span>
<span class="comment-copy">If you do consider asking the question, please share the link here!</span>
<span class="comment-copy">I used <code>dill</code> and now I can serialize locally defined functions and lambdas :).</span>
<span class="comment-copy">@RAbraham I didn't know about <code>dill</code> until now. Glad everything worked for you! You should add an answer to this post with what you came up with for posterity :)</span>
<span class="comment-copy">Posted: <a href="http://stackoverflow.com/a/41986106/238012">stackoverflow.com/a/41986106/238012</a></span>
