<div class="post-text" itemprop="text">
<p>Say I have a function</p>
<pre><code>def foo(): return [1, 2, 3]
</code></pre>
<p>I want to interpolate the result of the function into a string to get <code>"001 002 003"</code>. I've tried this:</p>
<pre><code>f"{*foo():03d 03d 03d}"
</code></pre>
<p>But it produced <code>SyntaxError: can't use starred expression here</code>. Can I do this using an f-string?</p>
</div>
<div class="post-text" itemprop="text">
<p>is this what you are looking for?</p>
<pre><code>str_repr = ' '.join(map('{:03d}'.format, foo()))
print(str_repr)  # prints: 001 002 003
</code></pre>
<p>maybe the best thing about this solution is that it works with any list length and with minimal tweaking you can change the output format too.</p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, the <code>*</code>-operator can only unpack iterables in few specific contexts, such as a function call, list display, etc. It can't be used directly in a f-string placeholder. Although, you could use <code>str.format()</code> like this:</p>
<pre><code>"{:03d} {:03d} {:03d}".format(*foo())
</code></pre>
<p>Secondly, you can't generally format/interpolate multiple values in a single placeholder. You'd need to use a separate placeholder for each value:</p>
<pre><code>lst = foo()
f"{lst[0]:03d} {lst[1]:03d} {lst[2]:03d}"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>*</code> operator (similar rules exist for <code>**</code>) can only be used inside:</p>
<ul>
<li>a function call: <code>foo(*bar)</code></li>
<li>a list, tuple, or set literal: <code>['foo', *bar]</code></li>
<li>an assignment: <code>foo, *bar = range(10)</code></li>
</ul>
<p>It is not an <a href="https://docs.python.org/3/reference/expressions.html" rel="nofollow noreferrer">expression</a> and can therefore not be used inside the braces of f-strings.</p>
</div>
<div class="post-text" itemprop="text">
<p>For lists, f-strings do not seem to add much to what was already possible without them. An alternative, slightly simpler, solution <strong>without</strong> f-strings and without <code>.join</code>, which works for any list length, is the following</p>
<pre><code>a = foo()
str_repr = ("{:03d} "*len(a)).format(*a)
print(str_repr)  # prints: 001 002 003
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use the zfill method instead:</p>
<pre><code>s_repr=" ".join([str(x).zfill(3) for x in foo()]) #not very PEP8 =S
</code></pre>
</div>
<span class="comment-copy"><code>f"{' '.join(map('{:03d}'.format, foo()))}"</code>?</span>
<span class="comment-copy">The suggestion works, but the f-string is redundant and the syntax verbose. One can just use the similar answer by @ev-kounis, without f-string. It seems f-strings do not improve the printing of lists.</span>
<span class="comment-copy">This works, but it does <b>not</b> make use of f-strings as requested. It may indeed be the best available Python solution, but it is verbose. I wish something like this <code>f"{foo():03d}"</code> would thread over the list.</span>
