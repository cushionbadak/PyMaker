<div class="post-text" itemprop="text">
<p>First post, also first attempt to code something beyond 99 bottles... </p>
<p>I am working on code which accepts an argument from the cli such as a text file. Expected usage would be:</p>
<p><em>$:myfile.py input.txt</em></p>
<p>I've got that piece going smoothly however if an argument is not supplied, the cli returns an error and i'd like to provide some error response such as a help list or just a simple "Nope - give me a file"</p>
<p>Right now here is the first few lines: </p>
<pre><code>import sys
with open(sys.argv[1], 'r') as f:
    ifile = f.read()
    if len(sys.argv) == 1:
        empty = "Please give me something to do!"
        print empty
</code></pre>
<p>If i supply the expected argument, everything is fine, but if no argument is supplied, I get this:</p>
<pre><code>Traceback (most recent call last):
  File "myfile.py", line 3, in &lt;module&gt;
    with open(sys.argv[1], 'r') as f:
IndexError: list index out of range
</code></pre>
<p>Lets say I just want the variable "Empty" to print if the condition isn't met... what would i do to fix that. </p>
<p>edit: after trying one of the suggestion below with argparse I am getting better results but I notice argparse throwing in a character I am not expecting. The code is now:</p>
<pre><code>   def main(filename):
    # do something with filename
    print('your filename is %s' % filename)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='my program help')
    parser.add_argument('-f', help='specify file path')
</code></pre>
<p>when I run this I expect to see -h and -f as options but I see an extra F in the description. </p>
<pre><code>my program help

optional arguments:
  -h, --help  show this help message and exit
  -f F        specify macro file path
</code></pre>
<p>Can you tell me how to get rid of this extra F. I have tried a few things but it either appears, or I get errors when I run it.</p>
</div>
<div class="post-text" itemprop="text">
<p>use <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer"><code>argparse</code></a> for parsing cli input arguments:</p>
<p>example code for your case:</p>
<pre><code>import argparse


def main(filename):
    # do something with filename
    print('your filename is %s' % filename)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='my program help')
    parser.add_argument('filename', help='your desired filename')

    args = parser.parse_args()
    main(args.filename)
</code></pre>
<p>running from terminal without argument we get:</p>
<pre><code>$ python ans_argparse.py
usage: ans_argparse.py [-h] filename
ans_argparse.py: error: the following arguments are required: filename
</code></pre>
<p>running with arguments:</p>
<pre><code>$ python ans_argparse.py 'myfile.txt'
your filename is 'myfile.txt'
</code></pre>
<p><strong>creating custom parser may take time and is not that straight forward. 
<code>argparse</code> has lots of features and is embedded inside the stdlib so prefer to use it.</strong></p>
<h2>Another Example</h2>
<p>I usually create <code>parse_args()</code> function so testing it or invoking it outside of <code>__main__</code> is easier:</p>
<pre><code>import sys
import argparse


def main(filename):
    # do something with filename
    print('your filename is %s' % filename)


def parse_args(args_lst):
    parser = argparse.ArgumentParser(description='my program help')
    parser.add_argument('filename', help='your desired filename')
    return parser.parse_args(args_lst)


if __name__ == '__main__':
    args = parse_args(sys.argv[1:])                 
    main(args.filename)
</code></pre>
<p>and you can call it like this:</p>
<pre><code>args = parse_args(['another_filename.txt'])
</code></pre>
<h2>Update</h2>
<p>use the <code>metavar</code> optional argument for changing the display name of the variable on the help. I encourage you to read the doc of <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer"><code>argparse</code></a> for more examples and use cases</p>
<p>like this:</p>
<pre><code>parser.add_argument('-f', metavar='FILENAME', required=True, 
                    help='the file path for this program')
</code></pre>
<p>output of <code>python myprog.py --help</code>:</p>
<pre><code>optional arguments:
  -h, --help   show this help message and exit
  -f FILENAME  the file path for this program
</code></pre>
<p><strong>note:</strong> do not forget the <code>required=True</code> argument so you'll get an error message from <code>argparse</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to check for the correctitude of sys.argv before you do something with it, if you do after that is to late obviously.</p>
<p>Like this for example</p>
<pre><code>import sys
if len(sys.argv)&gt;1:
    #do something
else:
    print "Please give me something to do!"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>argparse</code> is great, but you can also keep it simple</p>
<pre><code>import sys

if len(sys.argv) != 2:
    sys.stderr.write("Usage: myfile.py textfile\n")
    exit(1)

with open(sys.argv[1], 'r') as f:
    pass # ...
</code></pre>
</div>
<span class="comment-copy">of course it fail, you need to check the length of sys.argv before you you try to open something, not after</span>
<span class="comment-copy">thanks, I edited my post with the results. It's working great but I have a rogue character and I'm not sure how to get rid of it.</span>
<span class="comment-copy">I edited my post with <code>metavar</code> example for your use case, please update if works with the new changes</span>
