<div class="post-text" itemprop="text">
<p>What is the Pythonic way to make a generator that also produces aggregate results? In meta code, something like this (but not for real, as my Python version does not support mixing yield and return):</p>
<pre><code>def produce():
    total = 0
    for item in find_all():
        total += 1
        yield item

    return total
</code></pre>
<p>As I see it, I could:</p>
<ol>
<li>Not make <code>produce()</code> a generator, but pass it a callback function to call on every <code>item</code>. </li>
<li>With every <code>yield</code>, also <code>yield</code> the aggregate results up until now. I'd rather not calculate the intermediate results with every yield, only when finishing. </li>
<li>Send a <code>dict</code> as argument to <code>produce()</code> that will be populated with the aggregate results. </li>
<li>Use a global to store aggregate results.</li>
</ol>
<p>All of them don't seem very attractive...</p>
<p>NB. <code>total</code> is a simple example, my actual code requires complex aggregations. And I need intermediate results before <code>produce()</code> finishes, hence a generator.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you shouldn't use a generator but an iterator.</p>
<pre><code>def findall():  # no idea what your "find_all" does so I use this instead. :-)
    yield 1
    yield 2
    yield 3

class Produce(object):
    def __init__(self, iterable):
        self._it = iterable
        self.total = 0

    def __iter__(self):
        return self

    def __next__(self):
        self.total += 1
        return next(self._it)

    next = __next__  # only necessary for python2 compatibility
</code></pre>
<p>Maybe better to see this with an example:</p>
<pre><code>&gt;&gt;&gt; it = Produce(findall())
&gt;&gt;&gt; it.total
0
&gt;&gt;&gt; next(it)
1
&gt;&gt;&gt; next(it)
2
&gt;&gt;&gt; it.total
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate</a> to count stuff, for example</p>
<pre><code>i=0
for i,v in enumerate(range(10), 1 ):
    print(v)
print("total",i)
</code></pre>
<p>(notice the start value of the enumerate)</p>
<p>for more complex stuff, you can use the same principle, make produce a generator that yield both values and ignore one in the iteration and use it later when finished.</p>
<p>other alternative is passing a modifiable object, for example</p>
<pre><code>def produce(mem):
    t=0
    for x in range(10):
        t+=1
        yield x
    mem.append(t)

aggregate=[]
for x in produce(aggregate):
    print(x)
print("total",aggregate[0])
</code></pre>
<p>in either case the result is the same for this example</p>
<pre><code>0
1
2
3
4
5
6
7
8
9
total 10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Am I missing something? Why not:</p>
<pre><code>def produce():
   total = 0
   for item in find_all():
       total += 1
       yield item

    yield total
</code></pre>
</div>
<span class="comment-copy">So total is just the equivalent of the length of the iterable returned by <code>find_all</code>? For that you could just use <code>enumerate</code>.</span>
<span class="comment-copy">Thanks, I didn't think of this! It could work, but then the caller would have to figure out whether it got an <code>item</code> object or a <code>total</code> object. Hmm.</span>
