<div class="post-text" itemprop="text">
<p>I'm curious to see how I can create a UDP proxy server using the async module. I tried earlier today with Twisted, but wasn't making much headway. I did find some simple solutions here on stackoverflow using sockets directly, but i'm wondering if this is possible using the async lib.</p>
<p>For clarity, what I'm looking for is:</p>
<p>Step 1: client A (can be many) speaks to proxy B
Step 2: proxy B sends the request along to server C.
Step 3: Server C responds to proxy B
Sep 4: Proxy B responds to client A.</p>
<p>Here's what I have so far:</p>
<pre><code>import asyncio

class EchoServerProtocol(asyncio.DatagramProtocol):
    def connection_made(self, transport):
        self.transport = transport

    def datagram_received(self, data, addr, args=None):
        message = data
        server_addr = ('localhost', 27015)
        print('Received %r from %s' % (message, addr))
        print('Send %r to %s' % (message, server_addr))
        self.transport.sendto(data, server_addr)

loop = asyncio.get_event_loop()
print("Starting UDP server")
# One protocol instance will be created to serve all client requests
listen = loop.create_datagram_endpoint(
    EchoServerProtocol,
    local_addr=('0.0.0.0', 27016),
)
transport, protocol = loop.run_until_complete(listen)

try:
    loop.run_forever()
except KeyboardInterrupt:
    pass

transport.close()
loop.close()
</code></pre>
<p>The above is basically this:</p>
<p><a href="https://docs.python.org/3/library/asyncio-protocol.html#udp-echo-server-protocol" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio-protocol.html#udp-echo-server-protocol</a></p>
<p>What I have will get you to step 3, but of course fails at step 4. It sends it back to server C.</p>
<p>You will note that one of the other protocol examples, <code>EchoServerClientProtocol</code>, creates a new instance for each connection. I assume I need to create a new instance for every connection, I believe, because then I can store the original address in the instance, and return that. I assume this doesn't apply to <code>create_datagram_endpoint</code>, or I can't figure out how to do it.</p>
<p>There might be a better approach though.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need a local endpoint for server B, plus a remote endpoint to server C for each client A. </p>
<p>Here is <a href="https://gist.github.com/vxgmichel/b2cf8536363275e735c231caef35a5df" rel="nofollow noreferrer">a possible implementation</a>.</p>
<p>Also, you might be interested in <a href="https://gist.github.com/vxgmichel/e47bff34b68adb3cf6bd4845c4bed448" rel="nofollow noreferrer">this module providing high-level UDP endpoints for asyncio.</a></p>
</div>
<span class="comment-copy">How is server B supposed to know where to forward the server C replies? Also, UDP does not make much sense for a request/reply pattern, since packets can get lost.</span>
<span class="comment-copy">@Vincent I'm very much a UDP novice, but is it possible to retain the original sender using socks5?</span>
<span class="comment-copy">I don't know much about it, but relaying UDP packets with socks5 requires <a href="http://stackoverflow.com/questions/41967217/why-socks5-requires-to-relay-udp-over-udp">a TCP connection to the proxy and special headers for the datagrams</a>.</span>
