<div class="post-text" itemprop="text">
<p>I have a list of dictionaries like so:</p>
<pre><code>[{'a':'21'},{},{'b':20'},{'c':'89'},{}]
</code></pre>
<p>What's the most efficient way to purge empty dictionaries from this list, end result being:</p>
<pre><code>[{'a':'21'},{'b':'20'},{'c':'89'}]
</code></pre>
<hr/>
<p>I'm trying: </p>
<pre><code>new_list_of_dictionaries = []
for dictionary in list_of_dictionaries:
    if dictionary:
        new_list_of_dictionaries.append(dictionary)
return new_list_of_dictionaries
</code></pre>
<p>I don't suppose this can be done in O(1) or something?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use a list comprehension, and filter on the boolean truth. An empty dictionary is considered <em>false</em>:</p>
<pre><code>return [d for d in list_of_dictionaries if d]
</code></pre>
<p>In Python 2, you could also use the <a href="https://docs.python.org/2/library/functions.html#filter" rel="nofollow noreferrer"><code>filter()</code> function</a>, using <code>None</code> as the filter:</p>
<pre><code>return filter(None, list_of_dictionaries)
</code></pre>
<p>In Python 3 that returns an iterator, not a list, so you'd have to call <code>list()</code> on that (so <code>return list(filter(None, ...))</code>), at which point the list comprehension is simply more readable. Of course, if you don't actually need to have random access to the result (so direct index access to <code>result[whatever]</code>), then an iterator might still be a good idea anyway.</p>
<p>Note that this <em>has</em> to take O(N) time, you have to test each and every dictionary. Even if lists had some kind of automaticly updated map that lets you get the indices of the dictionaries that are empty in O(1) time, removing items from a list requires moving later entries forward.</p>
</div>
<div class="post-text" itemprop="text">
<p>Comprehension or <code>filter</code> (<a href="https://docs.python.org/2/library/functions.html#filter" rel="nofollow noreferrer">Python2</a>, <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer">Python3</a>):</p>
<pre><code>return filter(None, list_of_dictionaries)

# Python3, if you prefer a list over an iterator
return list(filter(None, list_of_dictionaries))  
</code></pre>
<p><code>None</code> as filter function will filter out all non-truthy elements, which in the case of empty collections makes it quite concise.</p>
</div>
<div class="post-text" itemprop="text">
<p>could use a list comprehension?</p>
<pre><code>myList = [{'a':'21'},{},{'b':'20'},{'c':'89'},{}]

result = [x for x in myList if x]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I did it in this way</p>
<pre><code>d = [{'a': '21'}, {}, {'b': 20}, {'c': '89'}, {}]
new_d = []
for item in d:
    check = bool(item)
    if not check:
        del item
    else:
        new_d.append(item)

print(new_d)
</code></pre>
<p>[{'a': '21'}, {'b': 20}, {'c': '89'}]</p>
</div>
<span class="comment-copy">How did you end up with the empty dictionaries there in the first place? Probably you can create the list without them</span>
<span class="comment-copy">I think I've seen this exact question for strings, lists, dictionaries, and tuples now - understandably since people don't google the same problem for a different structure.. I wonder what will be next :)</span>
<span class="comment-copy">@MartijnPietersâ™¦: Correct me if I'm wrong but <code>filter</code> is the same as using a list comprehension in terms of time complexity. It just reads differently. Yes?</span>
<span class="comment-copy">@HassanBaig: yes, a filter tests each object, so is O(N) too.</span>
<span class="comment-copy">@MartijnPieters True, added some clarification.</span>
<span class="comment-copy">The <code>del item</code> is entirely redundant. Building a new list like this is slower than a list comprehension, as you incur the <code>new_d.append</code> lookup cost each time, as well as the frame stacking cost for the method call.</span>
<span class="comment-copy">The <code>bool()</code> call is entirely redundant, because that is what <code>if</code> and <code>not</code> do <i>already</i>. It is simply busywork, extra cycles you could do without.</span>
<span class="comment-copy">yes you are right</span>
