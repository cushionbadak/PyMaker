<div class="post-text" itemprop="text">
<p>A proper Python module will list all its <em>public</em> symbols in <a href="https://stackoverflow.com/q/44834/1468366">a list called <code>__all__</code></a>. Managing that list can be tedious, since you'll have to list each symbol twice. Surely there are better ways, probably <a href="https://stackoverflow.com/q/6206089/1468366">using decorators</a> so one would merely annotate the exported symbols as <strong><code>@export</code></strong>.</p>
<p>How would you write such a decorator? I'm certain there are different ways, so I'd like to see several answers with enough information that users can compare the approaches against one another.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could simply declare the decorator at the module level like this:</p>
<pre><code>__all__ = []

def export(obj):
    __all__.append(obj.__name__)
    return obj
</code></pre>
<p>This is perfect if you only use this in a single module. At 4 lines of code (plus probably some empty lines for typical formatting practices) it's not overly expensive to repeat this in different modules, but it does feel like code duplication in those cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>In <a href="https://stackoverflow.com/q/6206089/1468366">Is it a good practice to add names to __all__ using a decorator?</a>, <a href="https://stackoverflow.com/users/13099/ed-l">Ed L</a> suggests the following, to be included in some utility library:</p>
<pre><code>import sys

def export(f):
    """Use a decorator to avoid retyping function/class names.

    * Based on an idea by Duncan Booth:
      http://groups.google.com/group/comp.lang.python/msg/11cbb03e09611b8a
    * Improved via a suggestion by Dave Angel:
      http://groups.google.com/group/comp.lang.python/msg/3d400fb22d8a42e1
    """
    mod = sys.modules[fn.__module__]
    if hasattr(mod, '__all__'):
        name, all_ = f.__name__, mod.__all__
        if name not in __all__:
            all_.append(name)
    else:
        mod.__all__ = [fn.__name__]
    return f
</code></pre>
<p>We've adapted the name to match the other examples. With this in a local utility library, you'd simply write</p>
<pre><code>from .utility import export
</code></pre>
<p>and then start using <code>@export</code>. Just one line of idiomatic Python, you can't get much simpler than this. On the downside, the module does require access to the module by using the <code>__module__</code> property and the <code>sys.modules</code> cache, both of which <em>may</em> be problematic in some of the more esoteric setups (like custom import machinery, or wrapping functions from another module to create functions in this module).</p>
<p><a href="https://gitlab.com/warsaw/public/blob/master/public/public.py" rel="nofollow noreferrer">The python part</a> of the <a href="https://gitlab.com/warsaw/public" rel="nofollow noreferrer">atpublic</a> <a href="https://pypi.python.org/pypi/atpublic" rel="nofollow noreferrer">package</a> by <a href="https://barry.warsaw.us/" rel="nofollow noreferrer">Barry Warsaw</a> does something similar to this. It offers some keyword-based syntax, too, but the decorator variant relies on the same patterns used above.</p>
<p><a href="https://stackoverflow.com/a/35710527/1468366">This great answer</a> by <a href="https://stackoverflow.com/users/541136/aaron-hall">Aaron Hall</a> suggests something very similar, with two more lines of code as it doesn't use <code>__dict__.setdefault</code>. It might be preferable if manipulating the module <code>__dict__</code> is problematic for some reason.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://github.com/russianidiot/public.py" rel="nofollow noreferrer">https://github.com/russianidiot/public.py</a> has yet another implementation of such a decorator. <a href="https://github.com/russianidiot/public.py/blob/master/py_modules/public.py" rel="nofollow noreferrer">Its core file</a> is currently 160 lines long! The crucial points appear to be the fact that it uses the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code> module</a> to obtain the appropriate module based on the current call stack.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could define the following in some utility library:</p>
<pre><code>def exporter():
    all = []
    def decorator(obj):
        all.append(obj.__name__)
        return obj
    return decorator, all

export, __all__ = exporter()
export(exporter)

# possibly some other utilities, decorated with @export as well
</code></pre>
<p>Then inside your public library you'd do something like this:</p>
<pre><code>from . import utility

export, __all__ = utility.exporter()

# start using @export
</code></pre>
<p>Using the library takes two lines of code here. It combines the definition of <code>__all__</code> and the decorator. So people searching for one of them will find the other, thus helping readers to quickly understand your code. The above will also work in exotic environments, where the module may not be available from the <code>sys.modules</code> cache or where the <code>__module__</code> property has been tampered with or some such.</p>
</div>
<span class="comment-copy">A criticism: <code>__dict__</code> is semantically not part of the public API - I'd prefer to avoid lower level direct modifications in favor of higher-level abstractions - even on code like this. I consider it a little safer, though I'd be hard pressed to think of a scenario in which your code here fails. Also thanks for the reference, cheers!</span>
<span class="comment-copy">Since it's community wiki, I've merged the logic to avoid using <code>__dict__</code> directly. If you agree, you can flag the above comments for deletion. Other things I'd improve are moving the credits from the docstring to the end of your answer, and improving the docstring to illustrate usage such that perhaps doctests would pass. I'm not interested in writing my own answer for this particular question.</span>
