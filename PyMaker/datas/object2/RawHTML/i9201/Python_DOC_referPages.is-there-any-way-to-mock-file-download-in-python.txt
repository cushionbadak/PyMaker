<div class="post-text" itemprop="text">
<p>I'm using Python 2.7 with Mock. I have a method that takes a url and downloads it into a temporary file, then renames file according to business logic rules. I want to test this renaming logic, but first I must mock the file download part. And here is where I'm stuck. I'm using <code>urllib2.urlopen</code> and its <code>read(chunkSize)</code> method in infinite cycle, checking if <code>read(chunkSize)</code> returns some value. While this approach works in real life, and the response is eventually read up to the end where <code>read(chunkSize)</code> does not return anything, I get an infinite cycle when mocking. <code>read(chunkSize)</code> seems to always have a result. How do I get the cycle to stop once the contents of the response has been read? Here's my code:</p>
<pre><code>import urllib2
from contextlib import closing
import unittest
import mock

def Method(url, temppath):
    chunkSize = 16 * 1024
    request = urllib2.Request(url)
    with closing(urllib2.urlopen(request, timeout = 5)) as response:
        with open(temppath, 'wb') as largeFile:
            while True:
                chunk = response.read(chunkSize)
                # print chunk # &lt;- this will endlessly produce '0123456' when tested by test_Method in MyTestCase
                if not chunk:
                    break
                largeFile.write(chunk)
    # rename file from temppath to something new

class MyTestCase(unittest.TestCase):
    @mock.patch('urllib2.urlopen', autospec=True)
    @mock.patch('__main__.open', create=True)
    def test_Method(self, mock_open, mock_urlopen):
        mock_urlopen.return_value.read.return_value = b'0123456'
        Method('http://a.bcd/img.png', 'a:\\b\\1234567890.tmp')

if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assign a <em>list</em> of values to return to the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow noreferrer"><code>side_effect</code> attribute</a>:</p>
<pre><code>mock_urlopen.return_value.read.side_effect = [b'0123456', b'']
</code></pre>
<p>The mock will iterate over the values for each <code>read()</code> call, so the last call returning an empty bytes object terminates your loop.</p>
</div>
<span class="comment-copy">You described <b>two</b> different functionalities (download and renaming) in your question; so why do you think it is appropriate to stuff those <b>two</b> into a single method? In other words: what is the point of making the renaming part 5 times harder to test, when you could have a download and a separate rename method in the first place? then you would not need to mock any download when testing the renaming part!</span>
<span class="comment-copy">@GhostCat Mainly because I need a method that would download a file into a temp location, rename it according to rules and return the resulting file name. I do in fact have a separate method for renaming the file, but I still need a function that calls both downloading AND renaming methods.</span>
