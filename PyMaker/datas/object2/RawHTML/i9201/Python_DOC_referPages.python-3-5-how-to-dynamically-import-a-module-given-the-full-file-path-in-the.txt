<div class="post-text" itemprop="text">
<h1>Question</h1>
<p>The standard library clearly documents <a href="https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly" rel="noreferrer">how to import source files directly</a> (given the absolute file path to the source file), but this approach does not work if that source file uses implicit sibling imports as described in the example below.</p>
<p>How could that example be adapted to work in the presence of implicit sibling imports?</p>
<p>I already checked out <a href="https://stackoverflow.com/a/67692/1490091">this</a> and <a href="https://stackoverflow.com/a/37124336/1490091">this other</a> Stackoverflow questions on the topic, but they do not address implicit sibling imports <em>within</em> the file being imported by hand.</p>
<h1>Setup/Example</h1>
<p>Here's an illustrative example</p>
<p>Directory structure:</p>
<pre><code>root/
  - directory/
    - app.py
  - folder/
    - implicit_sibling_import.py
    - lib.py
</code></pre>
<hr/>
<p><code>app.py</code>:</p>
<pre><code>import os
import importlib.util

# construct absolute paths
root = os.path.abspath(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))
isi_path = os.path.join(root, 'folder', 'implicit_sibling_import.py')

def path_import(absolute_path):
   '''implementation taken from https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly'''
   spec = importlib.util.spec_from_file_location(absolute_path, absolute_path)
   module = importlib.util.module_from_spec(spec)
   spec.loader.exec_module(module)
   return module

isi = path_import(isi_path)
print(isi.hello_wrapper())
</code></pre>
<hr/>
<p><code>lib.py</code>:</p>
<pre><code>def hello():
    return 'world'
</code></pre>
<hr/>
<p><code>implicit_sibling_import.py</code>:</p>
<pre><code>import lib # this is the implicit sibling import. grabs root/folder/lib.py

def hello_wrapper():
    return "ISI says: " + lib.hello()

#if __name__ == '__main__':
#    print(hello_wrapper())
</code></pre>
<hr/>
<p>Running <code>python folder/implicit_sibling_import.py</code> with the <code>if __name__ == '__main__':</code> block commented out yields <code>ISI says: world</code> in Python 3.6.</p>
<p>But running <code>python directory/app.py</code> yields:</p>
<pre><code>Traceback (most recent call last):
  File "directory/app.py", line 10, in &lt;module&gt;
    spec.loader.exec_module(module)
  File "&lt;frozen importlib._bootstrap_external&gt;", line 678, in exec_module
  File "&lt;frozen importlib._bootstrap&gt;", line 205, in _call_with_frames_removed
  File "/Users/pedro/test/folder/implicit_sibling_import.py", line 1, in &lt;module&gt;
    import lib
ModuleNotFoundError: No module named 'lib'
</code></pre>
<h1>Workaround</h1>
<p>If I add <code>import sys; sys.path.insert(0, os.path.dirname(isi_path))</code> to <code>app.py</code>, <code>python app.py</code> yields <code>world</code> as intended, but I would like to avoid munging the <code>sys.path</code> if possible.</p>
<h1>Answer requirements</h1>
<p>I'd like <code>python app.py</code> to print <code>ISI says: world</code> and I'd like to accomplish this by modifying the <code>path_import</code> function.</p>
<p>I'm not sure of the implications of mangling <code>sys.path</code>. Eg. if there was <code>directory/requests.py</code> and I added the path to <code>directory</code> to the <code>sys.path</code>, I wouldn't want <code>import requests</code> to start importing <code>directory/requests.py</code> instead of importing the <a href="http://docs.python-requests.org/en/master/" rel="noreferrer">requests library</a> that I installed with <code>pip install requests</code>.</p>
<p>The solution <strong>MUST</strong> be implemented as a python function that accepts the absolute file path to the desired module and returns the <a href="https://docs.python.org/3.5/library/types.html#types.ModuleType" rel="noreferrer">module object</a>.</p>
<p>Ideally, the solution should not introduce side-effects (eg. if it does modify <code>sys.path</code>, it should return <code>sys.path</code> to its original state). If the solution does introduce side-effects, it should explain why a solution cannot be achieved without introducing side-effects.</p>
<hr/>
<h1><code>PYTHONPATH</code></h1>
<p>If I have multiple projects doing this, I don't want to have to remember to set <code>PYTHONPATH</code> every time I switch between them. The user should just be able to <code>pip install</code> my project and run it without any additional setup.</p>
<h1><code>-m</code></h1>
<p>The <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-m" rel="noreferrer"><code>-m</code> flag</a> is the recommended/pythonic approach, but the standard library also clearly documents <a href="https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly" rel="noreferrer">How to import source files directly</a>. I'd like to know how I can adapt that approach to cope with implicit relative imports. Clearly, Python's internals must do this, so how do the internals differ from the "import source files directly" documentation?</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest solution I could come up with is to temporarily modify <code>sys.path</code> in the function doing the import:</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def add_to_path(p):
    import sys
    old_path = sys.path
    sys.path = sys.path[:]
    sys.path.insert(0, p)
    try:
        yield
    finally:
        sys.path = old_path

def path_import(absolute_path):
   '''implementation taken from https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly'''
   with add_to_path(os.path.dirname(absolute_path)):
       spec = importlib.util.spec_from_file_location(absolute_path, absolute_path)
       module = importlib.util.module_from_spec(spec)
       spec.loader.exec_module(module)
       return module
</code></pre>
<p>This should not cause any problems unless you do imports in another thread concurrently. Otherwise, since <code>sys.path</code> is restored to its previous state, there should be no unwanted side effects.</p>
<p><strong>Edit:</strong></p>
<p>I realize that my answer is somewhat unsatisfactory but, digging into  the code reveals that, the line <code>spec.loader.exec_module(module)</code> basically results in <code>exec(spec.loader.get_code(module.__name__),module.__dict__)</code> getting called. Here <code>spec.loader.get_code(module.__name__)</code> is simply the code contained in lib.py. </p>
<p>Thus a better answer to the question would have to find a way to make the <code>import</code> statement behave differently by simply injecting one or more global variables through the second argument of the exec-statement. However, "whatever you do to make the import machinery look in that file's folder, it'll have to linger beyond the duration of the initial import, since functions from that file might perform further imports when you call them", as stated by @user2357112 in the question comments.</p>
<p>Unfortunately the only way to change the behavior of the <code>import</code> statement seems to be to change <code>sys.path</code> or in a package <code>__path__</code>. <code>module.__dict__</code> already contains <code>__path__</code> so that doesn't seem to work which leaves <code>sys.path</code> (Or trying to figure out why exec does not treat the code as a package even though it has <code>__path__</code> and <code>__package__</code> ... - But I don't know where to start - Maybe it has something to do with having no <code>__init__.py</code> file).</p>
<p>Furthermore this issue does not seem to be specific to <code>importlib</code> but rather a general problem with <a href="https://stackoverflow.com/questions/6323860/sibling-package-imports">sibling imports</a>.</p>
<p><strong>Edit2:</strong> If you don't want the module to end up in <code>sys.modules</code> the following should work (Note that any modules added to <code>sys.modules</code> during the import are <em>removed</em>):</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def add_to_path(p):
    import sys
    old_path = sys.path
    old_modules = sys.modules
    sys.modules = old_modules.copy()
    sys.path = sys.path[:]
    sys.path.insert(0, p)
    try:
        yield
    finally:
        sys.path = old_path
        sys.modules = old_modules
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>add to the <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" rel="noreferrer"><code>PYTHONPATH</code></a> environment variable the path your application is on</p>
<blockquote>
<p>Augment the default search path for module files. The format is the same as the shellâ€™s PATH: one or more directory pathnames
  separated by os.pathsep (e.g. colons on Unix or semicolons on
  Windows). Non-existent directories are silently ignored.</p>
</blockquote>
<p>on bash its like this:</p>
<pre><code>export PYTHONPATH="./folder/:${PYTHONPATH}"
</code></pre>
<p>or run directly:</p>
<pre><code>PYTHONPATH="./folder/:${PYTHONPATH}" python directory/app.py
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>Make sure your root is in a folder that is explicitly searched in the PYTHONPATH</li>
<li><p>Use an absolute import:</p>
<p>from root.folder import implicit_sibling_import #called from app.py</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The OP's idea is great, this work only for this example by adding sibling modules with proper name to the sys.modules, I would say it is the SAME as adding PYTHONPATH. tested and working with version 3.5.1.</p>
<pre><code>import os
import sys
import importlib.util


class PathImport(object):

    def get_module_name(self, absolute_path):
        module_name = os.path.basename(absolute_path)
        module_name = module_name.replace('.py', '')
        return module_name

    def add_sibling_modules(self, sibling_dirname):
        for current, subdir, files in os.walk(sibling_dirname):
            for file_py in files:
                if not file_py.endswith('.py'):
                    continue
                if file_py == '__init__.py':
                    continue
                python_file = os.path.join(current, file_py)
                (module, spec) = self.path_import(python_file)
                sys.modules[spec.name] = module

    def path_import(self, absolute_path):
        module_name = self.get_module_name(absolute_path)
        spec = importlib.util.spec_from_file_location(module_name, absolute_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return (module, spec)

def main():
    pathImport = PathImport()
    root = os.path.abspath(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))
    isi_path = os.path.join(root, 'folder', 'implicit_sibling_import.py')
    sibling_dirname = os.path.dirname(isi_path)
    pathImport.add_sibling_modules(sibling_dirname)
    (lib, spec) = pathImport.path_import(isi_path)
    print (lib.hello())

if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try:</p>
<pre><code>export PYTHONPATH="./folder/:${PYTHONPATH}"
</code></pre>
<p>or run directly:</p>
<pre><code>PYTHONPATH="./folder/:${PYTHONPATH}" python directory/app.py
</code></pre>
<p>Make sure your root is in a folder that is explicitly searched in the <code>PYTHONPATH</code>. Use an absolute import:</p>
<pre><code>from root.folder import implicit_sibling_import #called from app.py
</code></pre>
</div>
<span class="comment-copy">As far as Python is concerned, this "implicit sibling import" is an ordinary absolute import, and most definitely not an implicit relative import. Implicit relative imports are no longer supported in Python 3.</span>
<span class="comment-copy">Altering <code>sys.path</code> is probably your best bet. Whatever you do to make the import machinery look in that file's folder, it'll have to linger beyond the duration of the initial import, since functions from that file might perform further imports when you call them.</span>
<span class="comment-copy">@user2357112 Indeed <a href="https://www.python.org/dev/peps/pep-0008/#imports" rel="nofollow noreferrer">PEP 8</a> does say that relative implicit imports are disabled in Python 3. But I am left wondering: if the above example isn't a relative implicit import, then what is? Do you have an example?</span>
<span class="comment-copy">@user2357112 the <code>import lib</code> line does not specify any package name nor does it use <code>.</code> . So is the only thing that doesn't make that an implicit relative import the fact that it is not done within a package?</span>
<span class="comment-copy">@DarrickHerwehe As stated in the question, modifying <code>sys.path</code> is fine as long as you can justify it. In that case, "an explanation as to why mangling <code>sys.path</code> is the best option" is all that is required.</span>
<span class="comment-copy">I think that sys.modules also gets affected whilst running this... but not sure how to not have that side effect</span>
<span class="comment-copy">That seems to be true - It is however non-obvious to me why this would be undesirable / problematic? - The module is loaded after all.</span>
<span class="comment-copy">maybe they could replace a module in the current namespace by providing a module with the same name</span>
<span class="comment-copy">It doesn't modify the current namespace unless you do something like <code>m = path_import(...)</code> and then I believe it acts like <code>import m</code> which seems reasonable. The way <code>sys.modules</code> works is a lookup-table for future imports <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="nofollow noreferrer">docs.python.org/3/reference/import.html#the-module-cache</a><code>- In any case you should be able to replace </code>sys.modules` with a copy and then restore it (just the way I have done with <code>sys.path</code></span>
<span class="comment-copy">yes :) thats correct, thanks for your input, very helpful</span>
<span class="comment-copy">I've updated my answer with more precise requirements for a solution. Unfortunately, since I want a solution that is pure python, this won't work.</span>
<span class="comment-copy">May I ask you what is the original requirement? And in particular, which aspect makes it so that you can only solve it with a pure python solution.</span>
<span class="comment-copy">As stated in the question, I am looking for a repeatable (without having to reconfigure every time), pure python solution, so this won't work.</span>
<span class="comment-copy">@Pedro Isn't repeating that configuration preferable to the solution you propose (that clearly looks very un-pythonic)?</span>
