<div class="post-text" itemprop="text">
<p>Performance of quicksort implemented with mutlithreading is lower than normal quicksort although my processor is dual core.</p>
<p>Please provide suggestion to improve performance of multithreading.</p>
<p>I am uploading both versions of quicksort and also sample testcase generator written in python3(3.5.2)</p>
<h1>Multithread Quicksort</h1>
<pre><code>#quicksort in multithreading

from queue import Queue 
import threading
import time

n = int(input().strip())
arr = [int(arr_temp) for arr_temp in input().strip().split(' ')]
f = open('results.txt','w')

q = Queue()
q.put([0,n-1])

def aux(i,j):
    if i&lt;j:
        pivot = j
        k = 0
        global arr 
        while k&lt;pivot:
            if arr[k]&gt;arr[pivot]:
                tmp = arr[k]
                itr = k+1
                while itr&lt;=pivot:
                    arr[itr-1]=arr[itr]
                    itr+=1
                arr[pivot]=tmp

                k-=1
                pivot-=1
            else:
                pass
            k+=1
        q.put([i, pivot-1])
        q.put([pivot+1, j])
    else:
        pass



def qsort_threader():
    while  True:
        if q.empty():
            pass
        else:
            indices = q.get()
            aux(indices[0],indices[1])
            q.task_done()


start = time.time()

for i in range (0,15):
    t = threading.Thread(target = lambda: qsort_threader())
    t.daemon = True
    t.start()

q.join()
print(time.time()-start)
f.write(str(arr))
</code></pre>
<p>Here's also the normal version</p>
<h1>Normal Quicksort</h1>
<pre><code>#normal quicksort

import threading
import time

n = int(input().strip())
arr = [int(arr_temp) for arr_temp in input().strip().split(' ')]
f = open('results.txt','w')

def xsort(i=0,j=n-1):
    #print(threading.currentThread().getName())
    if i&lt;j:
        pivot = j
        k = 0
        global arr 
        while k&lt;pivot:
            if arr[k]&gt;arr[pivot]:
                tmp = arr[k]
                itr = k+1
                while itr&lt;=pivot:
                    arr[itr-1]=arr[itr]
                    itr+=1
                arr[pivot]=tmp

                k-=1
                pivot-=1
            else:
                pass
            k+=1

        xsort(i,pivot-1)
        xsort(pivot+1,j)
    else:
        pass



start = time.time()
xsort()
print(time.time()-start)
f.write(str(arr))
f.close()
</code></pre>
<p>Below is the test code generator</p>
<h1>testcase generator</h1>
<pre><code>f = open('testfile.txt','w')
n = int(input("no of integers to generate ? "))
f.write(str(n)+'\n')
from random import randint as r
for i in range(0,n):
    f.write(str(r(-100000,100000))+' ')
f.close()
</code></pre>
<p>I'm also uploading screenshots of CPU performance graphs during running the programs on a testcase of 10000 unsorted random numbers</p>
<h1>CPU graph during normal quicksort</h1>
<p><a href="https://i.stack.imgur.com/Fj3jN.png" rel="nofollow noreferrer">see the 100% usage of CPU-3</a></p>
<h1>CPU graph during multithread quicksort</h1>
<p><a href="https://i.stack.imgur.com/vrIHN.png" rel="nofollow noreferrer">No CPU is utilized properly</a></p>
<p>Normal Quicksort finishes the task in 20.041423797607422 seconds.
Multithread Quicksort finishes it in 27.749499320983887 seconds.</p>
</div>
<div class="post-text" itemprop="text">
<p>You see the famous <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">GIL</a> in action: "mutex that prevents multiple native threads from executing Python bytecodes at once".</p>
<p>Guido's recommendation was to use <a href="https://docs.python.org/3/faq/library.html#can-t-we-get-rid-of-the-global-interpreter-lock" rel="nofollow noreferrer">multiprocessing</a> with IPC messaging instead of threads with shared state.</p>
<p>If there is no special requirements for stability, you can try <a href="http://pypy.org/download.html#pypy-stm-2-5-1" rel="nofollow noreferrer">PyPy-STM</a>, it was the most complete attempt to remove GIL.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python uses a Global Interpreter Lock, which means that at any time only one thread can be running. So you won't be able to fully utilize a multicore machine with threads in Python. The reason it runs slower is likely the added communication overhead in your multithreaded example.</p>
<p>I suggest writing a multithreaded solution in C or another language that allows real multithreading and forking it from your Python program.</p>
</div>
<span class="comment-copy">note that multithreading is <i>not</i> multiprocessing. It only uses 1 CPU no matter what.</span>
<span class="comment-copy">CPython has <a href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" rel="nofollow noreferrer">GIL</a> which ensures that only one thread can execute at a time so you're not going to get any benefit from multithreading in computationally intensive tasks.</span>
<span class="comment-copy">@niemmi I was just wondering about that. So basically threads are useful for non-blocking operations, but not for performance? It works when calling external commands, though.</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre Threading is useful in cases where you have I/O intensive tasks since GIL is released during I/O. Let's say you need to download couple hundred files and save them locally then threading would make sense.</span>
<span class="comment-copy">@niemmi: that too. But I/O becomes the bottleneck then :). It's good when you read AND uncompress for instance.</span>
