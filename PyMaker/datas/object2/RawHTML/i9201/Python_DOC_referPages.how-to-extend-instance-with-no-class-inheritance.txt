<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/41904124/how-to-extend-class-instance">How to extend Class instance</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p><code>MyClass</code> and its instance are defined in <code>myModule.py</code>:</p>
<pre><code>class MyClass(object):
    pass

obj = MyClass()
</code></pre>
<p>Define <code>function</code> as <code>obj</code>'s method:</p>
<pre><code>from myModule import obj
def function(msg):
    print msg 
</code></pre>
<p>How to extend <code>MyClass</code> instance with <code>function</code> as method? 
One way:</p>
<pre><code>obj.function = function
</code></pre>
<p>But this won't be the same as if it would be defined in Class definition, e.g.:</p>
<pre><code>class MyClass(object):
    def __init__(self): 
        self.value = 'Value'

    def function(self, msg):
        print msg, self.value
</code></pre>
<p>After <code>function</code> is defined as <code>MyClass</code> method it can access the Class's attributes such as <code>self.value</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>I have no idea why you're repeating this question as both <a href="https://stackoverflow.com/a/41904233/1636276">wim</a> and <a href="https://stackoverflow.com/a/41904389/1636276">I</a> provided solutions that don't involve subclassing.</p>
<blockquote>
<p>When function() is defined inside of MyClass definition it is able to access the Class's attribute or variables such as self.value here....</p>
</blockquote>
<p>I've expanded on my answer from your other post to demonstrate that this was already possible:</p>
<pre><code>from unittest import mock

# This class would be defined in some third-party library
class MyClass:
    def __init__(self):
        self._private_property = 'foo'

    def method(self, msg):
        print('from method:', msg)


def function(self, msg):
    print('Accessing private property from function:', self._private_property)
    print('from function:', msg)


old_method = MyClass.method


def new_method(self, msg):
    old_method(self, msg)
    function(self, msg)


# The patch is only applied within this scope
with mock.patch.object(MyClass, 'method', new_method):
    foo = MyClass()
    foo.method('message with patched')

# By this point MyClass is "back to normal"
print('---')
foo.method('message with original')
</code></pre>
<p><strong>Output</strong></p>
<pre class="lang-none prettyprint-override"><code>from method: message with patched
Accessing private property from function: foo
from function: message with patched
---
from method: message with original
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class MyClass(object):
    def __init__(self): 
        self.value = 'value'

def function(self, msg):
    print 'msg:', msg, 'value:', self.value 

foo = MyClass()
foo.function = function.__get__(foo)
foo.function(msg = 'hello world')
</code></pre>
</div>
<span class="comment-copy">Why are you unable to extend <code>MyClass</code>? Can you not define a new class that extends <code>MyClass</code>?</span>
<span class="comment-copy">You can get the class of an instance from its <code>__class__</code> attribute.This means you can use it as a base class for your own subclass. i.e. <code>class MyClass(instance.__class__):</code>.</span>
<span class="comment-copy">Sorry, I was not clear enough. I am not able to access the Class definition here at all. I am only given Class instance. But please do not delete your answer since it is still a valuable resource and it is very close to the subject.</span>
<span class="comment-copy">@alphanumeric You can pass a string to <code>mock.patch.object</code> e.g. <code>with mock.patch.object('somemodule.MyClass', 'method', new_method)</code>. See <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer">the docs</a>.</span>
