<div class="post-text" itemprop="text">
<p>I am trying to wrap the constructor for pyspark Pipeline.<strong>init</strong> constructor, and monkey patch in the newly wrapped constructor. However, I am running into an error that seems to have something to do with the way Pipeline.<strong>init</strong> uses decorators</p>
<p>Here is the code that actually does the monkey patch:</p>
<pre><code>    def monkeyPatchPipeline():
      oldInit = Pipeline.__init__

      def newInit(self, **keywordArgs):
        oldInit(self, stages=keywordArgs["stages"])

      Pipeline.__init__ = newInit
</code></pre>
<p>However, when I run a simple program: </p>
<pre><code>import PythonSparkCombinatorLibrary
from pyspark.ml import Pipeline
from pyspark.ml.classification import LogisticRegression
from pyspark.ml.feature import HashingTF, Tokenizer

PythonSparkCombinatorLibrary.TransformWrapper.monkeyPatchPipeline()
tokenizer = Tokenizer(inputCol="text", outputCol="words")
hashingTF = HashingTF(inputCol=tokenizer.getOutputCol(),outputCol="features")
lr = LogisticRegression(maxIter=10, regParam=0.001)

pipeline = Pipeline(stages=[tokenizer, hashingTF, lr])
</code></pre>
<p>I get this error:</p>
<pre><code>Traceback (most recent call last):
  File "C:\&lt;my path&gt;\PythonApplication1\main.py", line 26, in &lt;module&gt;
   pipeline = Pipeline(stages=[tokenizer, hashingTF, lr])
  File "C:&lt;my path&gt;PythonApplication1 \PythonSparkCombinatorLibrary.py", line 36, in newInit
oldInit(self, stages=keywordArgs["stages"])
  File "C:\&lt;pyspark_path&gt;\pyspark\__init__.py", line 98, in wrapper
   return func(*args, **kwargs)
 File "C:\&lt;pyspark_path&gt;\pyspark\ml\pipeline.py", line 63, in __init__
    kwargs = self.__init__._input_kwargs
AttributeError: 'function' object has no attribute '_input_kwargs'
</code></pre>
<p>Looking into the pyspark interface, I see that  Pipeline.<strong>init</strong> looks like this:</p>
<pre><code>@keyword_only
def __init__(self, stages=None):
    """
    __init__(self, stages=None)
    """
    if stages is None:
        stages = []
    super(Pipeline, self).__init__()
    kwargs = self.__init__._input_kwargs
    self.setParams(**kwargs)
</code></pre>
<p>And noting the @keyword_only decorator, I inspected that code as well:</p>
<pre><code>def keyword_only(func):
    """
    A decorator that forces keyword arguments in the wrapped method
    and saves actual input keyword arguments in `_input_kwargs`.
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        if len(args) &gt; 1:
            raise TypeError("Method %s forces keyword arguments." % func.__name__)
        wrapper._input_kwargs = kwargs
        return func(*args, **kwargs)
    return wrapper
</code></pre>
<p>I'm totally confused both about how this code works in the first place, and also why it seems to cause problems with my own wrapper. I see that wrapper is adding a _input_kwargs field to itself, but how is Pipeline.__init__ about to read that field with self.__init__._input_kwargs?  And why doesn't the same thing happen when I wrap Pipeline.__init__ again?</p>
</div>
<div class="post-text" itemprop="text">
<p>Decorator 101. Decorator is a higher-order function which takes a function as its first argument (and typically only), and returns a function. <code>@</code> annotation is just a syntactic sugar for a simple function call, so following </p>
<pre><code>@decorator
def decorated(x):
    ...
</code></pre>
<p>can be rewritten for example as:</p>
<pre><code>def decorated_(x):
    ...

decorated  = decorator(decorated_)
</code></pre>
<p>So <code>Pipeline.__init__</code> is actually a <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wrapped</code></a> <code>wrapper</code> which captures defined <code>__init__</code> (<code>func</code> argument of the <code>keyword_only</code>) as a part of its closure. When it is called, it uses received <code>kwargs</code> as a <a href="https://www.python.org/dev/peps/pep-0232/" rel="nofollow noreferrer">function attribute</a> of itself. Basically what happens here can be simplified to:</p>
<pre><code>def f(**kwargs):
    f._input_kwargs = kwargs  # f is in the current scope

hasattr(f, "_input_kwargs")
</code></pre>
<pre class="lang-none prettyprint-override"><code>False
</code></pre>
<pre class="lang-py prettyprint-override"><code>f(foo=1, bar="x")

hasattr(f, "_input_kwargs")
</code></pre>
<pre class="lang-none prettyprint-override"><code>True
</code></pre>
<p>When you further wrap (decorate) <code>__init__</code> the external function won't have <code>_input_kwargs</code> attached, hence the error. If you want to make it work you have apply the same process, as used by the original <code>__init__</code>, to your own version, for example with the same decorator:</p>
<pre><code>@keyword_only
def newInit(self, **keywordArgs):
    oldInit(self, stages=keywordArgs["stages"])
</code></pre>
<p>but I liked I mentioned in the comments, you should rather consider subclassing. </p>
</div>
