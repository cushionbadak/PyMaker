<div class="post-text" itemprop="text">
<p>I want to provide a method that can be used on a Python 2.7 class object, but does not pollute the attribute namespace of its instances. Is there any way to do this?</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...   @classmethod
...   def ugh(cls):
...     return 33
...
&gt;&gt;&gt; Foo.ugh()
33
&gt;&gt;&gt; foo = Foo()
&gt;&gt;&gt; foo.ugh()
33
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could subclass the classmethod descriptor:</p>
<pre><code>class classonly(classmethod):
    def __get__(self, obj, type):
        if obj: raise AttributeError
        return super(classonly, self).__get__(obj, type)
</code></pre>
<p>This is how it would behave:</p>
<pre><code>class C(object):
    @classonly
    def foo(cls):
        return 42
&gt;&gt;&gt; C.foo()
42
&gt;&gt;&gt; c=C()
&gt;&gt;&gt; c.foo()
AttributeError
</code></pre>
<p>This desugars to the descriptor call (rather, it is invoked by the default implementation of <code>__getattribute__</code>):</p>
<pre><code>&gt;&gt;&gt; C.__dict__['foo'].__get__(None, C)
&lt;bound method C.foo of &lt;class '__main__.C'&gt;&gt;
&gt;&gt;&gt; C.__dict__['foo'].__get__(c, type(c))
AttributeError
</code></pre>
<p>Required reading: <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">Data Model â€” Implementing Descriptors</a> and <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">Descriptor HowTo Guide</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>ugh</code> is not in the namespace:</p>
<pre><code>&gt;&gt;&gt; foo.__dict__
{}
</code></pre>
<p>but the rules for attribute lookup fall back to the type of the instance for missing names. You can override <code>Foo.__getattribute__</code> to prevent this.</p>
<pre><code>class Foo(object):
    @classmethod
    def ugh(cls):
        return 33

    def __getattribute__(self, name):
        if name == 'ugh':
            raise AttributeError("Access to class method 'ugh' block from instance")
        return super(Foo,self).__getattribute__(name)
</code></pre>
<p>This produces:</p>
<pre><code>&gt;&gt;&gt; foo = Foo()
&gt;&gt;&gt; foo.ugh()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "tmp.py", line 8, in __getattribute__
    raise AttributeError("Access to class method 'ugh' block from instance")
AttributeError: Access to class method 'ugh' block from instance
&gt;&gt;&gt; Foo.ugh()
33
</code></pre>
<p>You must use <code>__getattribute__</code>, which is called unconditionally on any attribute access, rather than <code>__getattr__</code>, which is only called after the normal lookup (which includes checking the type's namespace) fails.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can create the method in the metaclass.</p>
<pre><code>class FooMeta(type):
    # No @classmethod here
    def ugh(cls):
        return 33

class Foo(object):
    __metaclass__ = FooMeta

Foo.ugh()  # returns 33
Foo().ugh()  # AttributeError
</code></pre>
<p>Note that metaclasses are a power feature, and their use is discouraged if unnecessary.  In particular, multiple inheritance requires special care if the parent classes have different metaclasses.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow noreferrer">quasi-private variables</a> that use name-munging to reduce accidental access. Methods and object variables of the form <code>__name</code> are converted to <code>_ClassName__name</code>. Python automatically changes the name when compiling methods on the class but doesn't change the name for subclasses.</p>
<p>I can use the private method in a class</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     def __private(self):
...         print('boo')
...     def hello(self):
...         self.__private()
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; A().hello()
boo
</code></pre>
<p>But not outside the class</p>
<pre><code>&gt;&gt;&gt; A().__private()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'A' object has no attribute '__private'
&gt;&gt;&gt; 
</code></pre>
<p>Or in subclasses</p>
<pre><code>&gt;&gt;&gt; class B(A):
...     def hello2(self):
...         self.__private()
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; B().hello()
boo
&gt;&gt;&gt; B().hello2()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in hello2
AttributeError: 'B' object has no attribute '_B__private'
</code></pre>
</div>
<span class="comment-copy">Technically, <code>ugh</code> is <i>not</i> in the namespace of the instance (<code>foo.__dict__</code>); it is simply accessible via the instance due to Python's lookup algorithm.</span>
<span class="comment-copy">so this is baked into Python? (<a href="http://users.rcn.com/python/download/Descriptor.htm" rel="nofollow noreferrer">users.rcn.com/python/download/Descriptor.htm</a> seems to confirm that:  <code>For instance, a.x has a lookup chain starting with a.__dict__['x'], then type(a).__dict__['x'], and continuing through the base classes of type(a) excluding metaclasses</code>) I want to create some special magic stuff available on the class object but I don't want my colleagues who are using my class to accidentally call it from an instance because they are curious. It would be nice if there were a way to inhibit visibility.</span>
<span class="comment-copy">Another power feature is <code>__dir__</code> to control introspection.</span>
<span class="comment-copy"><a href="https://mail.python.org/pipermail/tutor/2003-October/025932.html" rel="nofollow noreferrer">"We're all consenting adults here"</a></span>
<span class="comment-copy">@StephenRauch sure; I don't want to prevent someone who knows what they're doing, but I do want to limit accidental errors. In my case I have colleagues who are Python beginners, and Murphy's law says they will find a way to trip over any possible trip hazard. (and whenever I assume otherwise, it has caused problems that I have to fix.)</span>
<span class="comment-copy">my brain is fuming... could you elaborate? On the surface this seems to be something simple, but I guess I don't understand what <code>@classmethod</code> actually does under the hood.</span>
<span class="comment-copy">Hmm. I tried it and this doesn't seem to work properly in Python 2.7</span>
<span class="comment-copy">Aha, it's the super call.</span>
<span class="comment-copy">which is less evil? descriptors or metaclasses?</span>
<span class="comment-copy">A metaclass can override many things about the class's definition and object creation, and can have complicated side effects with inheritance. A descriptor is a type of object that overrides getattr and setattr, and can't have any side effects on the rest of the class. Near as I can tell, outside of the ABCMeta hierarchy, the stdlib (of py3) only uses two metaclasses (one in enum and one in ctypes), but uses standard @classmethod decorators and custom descriptors generously. I'd follow their lead.</span>
<span class="comment-copy">What is the cost of using metaclasses? This seems to be exactly the feature I'm looking for, and as long as I can keep their functionality simple, it would be something I would like to utilize. I am going to be making potentially thousands of instance objects -- if I use metaclasses, do they cost significant extra memory?</span>
<span class="comment-copy">@JasonS: The main problem is that metaclasses are very powerful and can be used to do a lot of strange things with your classes (for instance, you can override special methods like <code>__add__</code> to make <code>Foo + Foo</code> a meaningful expression).  Many of these will reduce the readability of your code.</span>
<span class="comment-copy">If you use them to override the very meaning of addition or such simple operations it will get confusing but other than that they are just another tool</span>
<span class="comment-copy">Metaclasses do not necessarily play well with each other. The metaclass for <code>A</code> that inherits from <code>B</code> must be "compatible" with the metaclass of <code>B</code>; in practice, it somewhat limits where and when you want to use a metaclass.</span>
<span class="comment-copy">bizarre.... more from the odd corners of the language. :-)</span>
