<div class="post-text" itemprop="text">
<p>In my high school class I have been assigned the task of creating a keyword cipher. However when I run it through a python visualizer I still can not see what it is doing wrong.</p>
<p>Here is my code so far:</p>
<pre><code>n = 0
l = 0
string = ""
message = input("enter your sentence: ")
message = (message.lower())
keyword = input("enter keyword: ")
keyword = (keyword.lower())
listkw = list(keyword)
def change(message,listkw,n,string,l):
    try:
        for letter in message:
            if letter == " ":
                string += " "
            else:
                temp = listkw[n]
                mtemp = ord(letter)
                mtemp -= 96
                ktemp = ord(temp)
                ktemp -= 96
                letterans = mtemp+ktemp
                if letterans &gt;= 27:
                    letterans -= 26
                letterans += 96
                ans = chr(letterans)
                string += ans
                print (string)
                n+=1
                message = message[l:]
                l+=1
    except IndexError:
        n= 0
        change(message,listkw,n,string,l)
change(message,listkw,n,string,l)
print (string)
</code></pre>
<p>When I run it with the following input</p>
<p>enter your sentence: computingisfun
enter keyword: gcse</p>
<p>it should print <code>jrfubwbsnllkbq</code>, because it gets the place in the alphabet for each letter adds them up and print that letter.</p>
<p>For example:</p>
<pre><code>change('a', list('b'), 0, "", 0)
</code></pre>
<p>prints out <code>c</code> because a = 1 and b = 2 and a+b = 3 (which is (c))</p>
<p>But it prints out <code>jrfupqzn</code>, which is not at all what I expected.</p>
</div>
<div class="post-text" itemprop="text">
<p>I understand that you're in high school so I replace some piece of code that you write unnecessarily, you'll do better with experience ;)</p>
<p>First of all, you must know that it isn't a good idea programming based in an exception, is better if you add a condition and you reinitialize your <code>n</code> value so the exception it isn't necessary; <code>n = n + 1 if n + 1 &lt; len(listkw) else 0</code></p>
<p>Then, you have a little problem with the scope of the variables, you set <code>string = ""</code> at the start of your script but when call the function the <code>string</code> inner the function has a different scope so when you <code>print(string)</code> at the end you have an empty string value, so, the values that you use into the function like <code>n</code>, <code>l</code> and <code>string</code> it's better if you define inside the function scope and finally return the desired value (calculated (cipher) string)</p>
<p>So, the code it's something like this:</p>
<p>Read and initialize your required data:</p>
<pre><code>message = input("enter your sentence: ").lower()
keyword = input("enter keyword: ").lower()
listkw = list(keyword)
</code></pre>
<p>Define your function:</p>
<pre><code>def change(message,listkw):
    n = l = 0
    string = ""
    for letter in message:
        if letter == " ":
            string += " "
        else:
            temp = listkw[n]
            mtemp = ord(letter) - 96
            ktemp = ord(temp) - 96
            letterans = mtemp + ktemp
            if letterans &gt;= 27:
                letterans -= 26
            letterans += 96
            string += chr(letterans)
            message = message[l:]
            l+=1
            n = n + 1 if n + 1 &lt; len(listkw) else 0
    return string
</code></pre>
<p>Call and print the return value at the same time ;)</p>
<pre><code>print(change(message,listkw))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You've got quite a few problems with what you're doing here. You're mixing recursion, iteration, and exceptions in a bundle of <strong>don't do that</strong>.</p>
<p>I think you may have had a few ideas about what to do, and you started down one track and then changed to go down a different track. That's not surprising, given the fact that you're a beginner. But you should learn that it's a good idea to be <em>consistent</em>. And you can do this using recursion, iteration, slicing, or driven with exceptions. But combining them all without understanding why you're doing it is a problem.</p>
<h1>Design</h1>
<p>Let's unwind your application into what you actually are trying to do. Without writing any code, how would you describe the steps you're taking? This is what I would say:</p>
<p>For every letter in the message:</p>
<ul>
<li>take the next letter from the keyword</li>
<li>combine the numeric value of the two letters</li>
<li>if the letter is <a href="https://en.wikipedia.org/wiki/On_Beyond_Zebra!" rel="nofollow noreferrer">beyond Z(ebra)</a>, start back at A and keep counting</li>
<li>when we reach the last letter in the keyword, loop back to the beginning</li>
</ul>
<p>This gives us a hint as to how we <em>could</em> write this. Indeed the most straightforward way, and one that you've got partially done.</p>
<h1>Iteratively</h1>
<p>Here's another pointer - rather than starting of with a dynamic problem, let's make it pretty static:</p>
<pre><code> message = 'computing is awesome'

 for letter in message:
     print(letter)
</code></pre>
<p>You'll see that this prints out the message - one character per line. Great! We've got the first part of our problem done. Now the next step is to take letters from the key. Well, let's put a key in there. But how do we iterate over two strings at a time? If we search google for <code>python iterate over two sequences</code>, the very first result for me was <a href="https://stackoverflow.com/q/1663807/344286">How can I iterate through two lists in parallel?</a>. Not bad. It tells us about the handy dandy <code>zip</code> function. If you want to learn about it you can search <code>python3 zip</code> or just run <code>&gt;&gt;&gt; help(zip)</code> in your REPL.</p>
<p>So here's our code:</p>
<pre><code>message = 'computing is awesome'
keyword = 'gcse'

for letter, key in zip(message, keyword):
    print(letter, key)
</code></pre>
<p>Now if we run this... uh oh!</p>
<pre><code>c g
o c
m s
p e
</code></pre>
<p>Where's the rest of our string? It's stopping after we get to the end of the shortest string. If we look at the help for zip, we see:</p>
<blockquote>
<p>continues until the shortest iterable in the argument sequence is exhausted </p>
</blockquote>
<p>So it's only going to go until the shortest thing. Well that's a bummer. That means we need to have a key and message the same length, right? Or does it? What if our key is <em>longer</em> than the message? Hopefully by now you know that you can do something like this:</p>
<pre><code>&gt;&gt;&gt; 'ab'*10
'abababababababababab'
</code></pre>
<p>If we make sure that our key is at least as long as our message, that will work. So we can just multiply the key times the number of letters in our message. I mean, we'll have <em>way</em> more than we need, but that should work, right? Let's try it out:</p>
<pre><code>message = 'computing is awesome'
keyword = 'gcse'*len(message)

for letter, key in zip(message, keyword):
    print(letter, key)
</code></pre>
<p>Sweet! It worked!</p>
<p>So now let's try just adding the <code>ord</code> values and let's see what we get:</p>
<pre><code>for letter, key in zip(message, keyword):
    print(chr(ord(letter)+ord(key)))
</code></pre>
<p>Oh.. dear. Well those aren't ASCII letters. As you've already found out, you need to subtract 96 from each of those. As it turns out because math, you can actually just subtract 96*2 from the sum that we've already got.</p>
<pre><code>for letter, key in zip(message, keyword):
    if letter == ' ':
        print()
    else:
        new_code = (ord(letter)+ord(key)-96*2)
        print(chr(new_code+96))
</code></pre>
<p>But we've still got non-alpha characters here. So if we make sure to just bring that value back around:</p>
<pre><code>for letter, key in zip(message, keyword):
    if letter == ' ':
        print()
    else:
        new_code = (ord(letter)+ord(key)-96*2)
        if new_code &gt; 26:
            new_code -= 26
        print(chr(new_code+96))
</code></pre>
<p>Now we're good. The only thing that we have left to do is combine our message into a string instead of print it out, and stick this code into a function. And then get our input from the user. We're also going to stick our key-length-increasing code into the function:</p>
<pre><code>def change(message, keyword):
    if len(keyword) &lt; len(message):
        keyword = keyword * len(message)
    result = ''
    for letter, key in zip(message, keyword):
        if letter == ' ':
            result += ' '
        else:
            new_code = (ord(letter)+ord(key)-96*2)
            if new_code &gt; 26:
                new_code -= 26
            result += chr(new_code+96)
    return result

message = input('enter your sentence: ')
keyword = input('enter your keyword: ')
print(change(message, keyword))
</code></pre>
<h1>Recursion</h1>
<p>So we've got it working using iteration. What about recursion? You're <em>definitely</em> using recursion in your solution. Well, let's go back to the beginning, and figure out how to print out our message, letter by letter:</p>
<pre><code>message = 'computing is awesome'

def change(message):
    if not message:
        return
    print(message[0])
    change(message[1:])

change(message)
</code></pre>
<p>That works. Now we want to add our key. As it turns out, we can actually do the same thing that we did before - just multiply it:</p>
<pre><code>def change(message, keyword):
    if not message:
        return

    if len(keyword) &lt; len(message):
        keyword = keyword*len(message)

    print(message[0], keyword[0])
    change(message[1:], keyword[1:])
</code></pre>
<p>Well that was surprisingly simple. Now let's print out the converted value:</p>
<pre><code>def change(message, keyword):
    if not message:
        return
    if len(keyword) &lt; len(message):
        keyword = keyword*len(message)
    new_code = (ord(message[0])+ord(keyword[0])-96*2)
    if new_code &gt; 26:
        new_code -= 26
    print(chr(new_code+96))
    change(message[1:], keyword[1:])
</code></pre>
<p>Again we need to handle a space character:</p>
<pre><code>def change(message, keyword):
    if not message:
        return

    if len(keyword) &lt; len(message):
        keyword = keyword*len(message)

    if message[0] == ' ':
        print()
    else:
        new_code = (ord(message[0])+ord(keyword[0])-96*2)
        if new_code &gt; 26:
            new_code -= 26
        print(chr(new_code+96))
    change(message[1:], keyword[1:])
</code></pre>
<p>Now the only thing that's left is to combine the result. In recursion you usually pass some kind of value around, and we're going to do that with our result:</p>
<pre><code>def change(message, keyword, result=''):
    if not message:
        return result

    if len(keyword) &lt; len(message):
        keyword = keyword*len(message)

    if message[0] == ' ':
        result += ' '
    else:
        new_code = (ord(message[0])+ord(keyword[0])-96*2)
        if new_code &gt; 26:
            new_code -= 26
        result += chr(new_code+96)
    return change(message[1:], keyword[1:], result)

print(change(message, keyword))
</code></pre>
<h1>Slicing</h1>
<p>We used some slicing in our recursive approach. We even could have passed in the index, rather than slicing off parts of our string. But now we're going to slice and dice. It's going to be pretty similar to our recursive solution:</p>
<p>def change(message, keyword):
    if len(keyword) &lt; len(message):
        keyword = keyword*len(message)</p>
<pre><code>while message:
    print(message[0], keyword[0])
    message = message[1:]
    keyword = keyword[1:]
</code></pre>
<p>When you see that, it shouldn't be much of a stretch to realize that you can just put in the code from our recursive solution:</p>
<pre><code>while message:
    if message[0] == ' ':
        print()
    else:
        new_code = (ord(message[0])+ord(keyword[0])-96*2)
        if new_code &gt; 26:
            new_code -= 26
        print(chr(new_code+96))
    message = message[1:]
    keyword = keyword[1:]
</code></pre>
<p>And then we just combine the characters into the result:</p>
<pre><code>def change(message, keyword):
    if len(keyword) &lt; len(message):
        keyword = keyword*len(message)

    result = ''
    while message:
        if message[0] == ' ':
            result += ' '
        else:
            new_code = (ord(message[0])+ord(keyword[0])-96*2)
            if new_code &gt; 26:
                new_code -= 26
            result += chr(new_code+96)
        message = message[1:]
        keyword = keyword[1:]
    return result
</code></pre>
<h1>Further Reading</h1>
<p>You can do some nicer things. Rather than the silly multiplication we did with the key, how about <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer">itertools.cycle</a>?</p>
<p>What happens when you use modulo division instead of subtraction?</p>
</div>
<span class="comment-copy">What is your input? What is your expected output? What is your output instead? Please <a href="https://stackoverflow.com/posts/41880546/edit">edit</a> your question to include a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a></span>
<span class="comment-copy">I don't think it's a good idea to change the value of <code>message</code> while you're iterating over it. I also don't think it's a good idea to catch IndexErrors and just run the function a second time if something goes wrong.</span>
<span class="comment-copy">In some languages it's not a good idea, but it's totally fine to use exceptions in Python. (though the OPs usage is a bit suspect here)</span>
<span class="comment-copy">@WayneWerner yeah! of course that it's a good practice use exceptions, I mean that in any language it's better if you control the flow with expected workflow and data, wait for an IndexError and call the function again isn't the best practice, of course it's better if you add exceptions to manage really errors like lost connections, timeout exceptions, and so on but not like a natural workflow</span>
