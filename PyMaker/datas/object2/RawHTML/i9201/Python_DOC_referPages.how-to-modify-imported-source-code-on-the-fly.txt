<div class="post-text" itemprop="text">
<p>Suppose I have a module file like this:</p>
<pre><code># my_module.py
print("hello")
</code></pre>
<p>Then I have a simple script:</p>
<pre><code># my_script.py
import my_module
</code></pre>
<p>This will print <code>"hello"</code>. </p>
<p>Let's say I want to "override" the <code>print()</code> function so it returns <code>"world"</code> instead. How could I do this programmatically (without manually modifying <code>my_module.py</code>)?</p>
<hr/>
<p>What I thought is that I need somehow to modify the source code of <code>my_module</code> before or while importing it. Obvisouly, I cannot do this after importing it so solution using <code>unittest.mock</code> are impossible.</p>
<p>I also thought I could read the file <code>my_module.py</code>, perform modification, then load it. But this is ugly, as it will not work if the module is located somewhere else.</p>
<p>The good solution, I think, is to make use of <a href="https://docs.python.org/3/library/importlib.html" rel="noreferrer"><code>importlib</code></a>.</p>
<p>I read the doc and found a very intersecting method: <code>get_source(fullname)</code>. I thought I could just override it:</p>
<pre><code>def get_source(fullname):
    source = super().get_source(fullname)
    source = source.replace("hello", "world")
    return source
</code></pre>
<p>Unfortunately, I am a bit lost with all these abstract classes and I do not know how to perform this properly.</p>
<p>I tried vainly:</p>
<pre><code>spec = importlib.util.find_spec("my_module")
spec.loader.get_source = mocked_get_source
module = importlib.util.module_from_spec(spec)
</code></pre>
<p>Any help would be welcome, please.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution I hacked together based on the content of <a href="http://www.dabeaz.com/modulepackage/ModulePackage.pdf" rel="nofollow noreferrer">this great talk</a>. It allows any arbitrary modifications to be made to the source before importing the specified module. It should be reasonably correct as long as the slides did not omit anything important. This will only work on Python 3.5+.</p>
<pre><code>import importlib
import sys

def modify_and_import(module_name, package=None, modification_func):
    spec = importlib.util.find_spec(module_name, package)
    source = spec.loader.get_source(module_name)
    new_source = modification_func(source)
    module = importlib.util.module_from_spec(spec)
    codeobj = compile(new_source, module.__spec__.origin, 'exec')
    exec(codeobj, module.__dict__)
    sys.modules[module_name] = module
    return module
</code></pre>
<p>So, using this you can do</p>
<pre><code>my_module = modify_and_import("my_module", None, lambda src: src.replace("hello", "world"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This doesn't answer the general question of dynamically modifying the source code of an imported module, but to "Override" or "monkey-patch" its use of the <code>print()</code> function can be done (since it's a built-in function in PythonÂ 3.x). Here's how:</p>
<pre><code>#!/usr/bin/env python3
# my_script.py

import builtins

_print = builtins.print

def my_print(*args, **kwargs):
    _print('In my_print: ', end='')
    return _print(*args, **kwargs)

builtins.print = my_print

import my_module  # -&gt; In my_print: hello
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If importing the module before the patching it is okay, then a possible solution would be</p>
<pre><code>import inspect

import my_module

source = inspect.getsource(my_module)
new_source = source.replace('"hello"', '"world"')
exec(new_source, my_module.__dict__)
</code></pre>
<p>If you're after a more general solution, then you can also take a look at the approach I used in <a href="https://stackoverflow.com/a/34523645/2997179">another answer</a> a while ago.</p>
</div>
<div class="post-text" itemprop="text">
<p>I first needed to better understand the <code>import</code> operation. Fortunately, this is well explained in <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer">the <code>importlib</code> documentation</a> and scratching through <a href="https://hg.python.org/cpython/file/tip/Lib/importlib/" rel="nofollow noreferrer">the source code</a> helped too.</p>
<p>This <code>import</code> process is actually split in two parts. First, a <a href="https://docs.python.org/3/glossary.html#term-finder" rel="nofollow noreferrer">finder</a> is in charge of parsing the module name (including dot-separated packages) and instantiating an appropriate <a href="https://docs.python.org/3/glossary.html#term-loader" rel="nofollow noreferrer">loader</a>. Indeed, built-in are not imported as local modules for example. Then, the loader is called based on what the finder returned. This loader get the source from a file or from a cache, and executed the code if the module was not previously loaded.</p>
<p>This is very simple. This explains why I actually did not need to use abstract classes from <code>importutil.abc</code>: I do not want to provide my own import process. Instead, I could create a subclass inherited from one of the classes from <code>importuil.machinery</code> and override <code>get_source()</code> from <code>SourceFileLoader</code> for example. However, this is not the way to go because the loader is instantiated by the finder so I do not have the hand on which class is used. I cannot specify that my subclass should be used.</p>
<p>So, the best solution is to let the finder do its job, and then replace the <code>get_source()</code> method of whatever Loader has been instantiated.</p>
<p>Unfortunately, by looking trough the code source I saw that the basic Loaders are not using <code>get_source()</code> (which is only used by the the <code>inspect</code> module). So my whole idea could not work.</p>
<p>In the end, I guess <code>get_source()</code> should be called manually, then the returned source should be modified, and finally the code should be executed. This is what Martin Valgur detailed in <a href="https://stackoverflow.com/a/41863728/2291710">his answer</a>.</p>
<p>If compatibility with Python 2 is needed, I see no other way than reading the source file:</p>
<pre><code>import imp
import sys
import types

module_name = "my_module"

file, pathname, description = imp.find_module(module_name)

with open(pathname) as f:
    source = f.read()

source = source.replace('hello', 'world')

module = types.ModuleType(module_name)
exec(source, module.__dict__)

sys.modules[module_name] = module
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not elegant, but works for me (may have to add a path):</p>
<pre><code>with open ('my_module.py') as aFile:
    exec (aFile.read () .replace (&lt;something&gt;, &lt;something else&gt;))
</code></pre>
</div>
<span class="comment-copy"><code>my_module</code> does not define <code>print()</code> which is a built-in function in Python 3.x.</span>
<span class="comment-copy">@martineau I do not understand what is your point. I use Python 3 so there is no problem using <code>print()</code> without defining it.</span>
<span class="comment-copy">You said you wanted to override the <code>print()</code> function, and I was just pointing out that it's not defined in the module you're importing.</span>
<span class="comment-copy">@martineau I see, thank you, indeed I cannot properly "override" the print function, I should rather say that I want to monkey-patch it.</span>
<span class="comment-copy">Also note that doing it for <code>print()</code> might be different than just a general function because it's a built-in.</span>
<span class="comment-copy">Thank you for taking the time to help me! Your solution is probably the best way to go.</span>
<span class="comment-copy">How could this be useful to me? How would you change the print value using your workaround?</span>
<span class="comment-copy">Sorry, I assumed you wanted a generic method to monkey patch any part of a module. Reading your question again it seems that you wish to avoid importing the module first, in which case I agree, my solution would not be relevant here.</span>
<span class="comment-copy">I rewrote my answer entirely. Is this useful to you? If not, I'll delete it.</span>
<span class="comment-copy">Thank you. This is not useful to me but this could help someone else (who would not have the problem of mocking before importing) so please do not delete your answer. ;)</span>
<span class="comment-copy">I precised I would like to avoid having to specify the module path. Moreover, as you said <code>exec()</code> is not elegant at all, it should exist a better solution.</span>
