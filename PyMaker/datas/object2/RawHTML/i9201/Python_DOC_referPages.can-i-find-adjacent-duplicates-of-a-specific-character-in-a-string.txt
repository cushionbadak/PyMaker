<div class="post-text" itemprop="text">
<p>How can I find adjacent duplicates of a specific character in a string? And then delete some of the duplications but not all.</p>
<p>Let's say I have:</p>
<pre><code>`str= "KKKKKLLLLLLLLLLLLLLLOOOPPPPLLL"`
</code></pre>
<p>The only duplicated letter I'm interested in is <code>L</code>. I would like to reduce <code>L</code> adjacent duplications -&gt; if <code>L</code> is part of a line of 15 adjacent duplications, I want it to lose 5 adjacent duplicates. If it is in a line of 3, I want it to lose 1 <code>L</code></p>
<p>Final output should be:</p>
<p><code>KKKKKLLLLLLLLLLOOOPPPPLL</code></p>
<p>Sorry if this makes very little sense, hopefully you understand what I mean. Any help would be hugely appreciated!!</p>
<p>EDIT: It won't always be reduced by one third, or by the same fraction.</p>
<p>Final note for clarification. My end game: There will be a randomly generated string with a length of a few hundred. The lengths of the duplications will decide how much it needs to reduced by, which is half or less than half. So a line of 50 'L', will need to be reduced by &lt;=25 . A line 64 reduced by &lt;=32. But not reduced by 0. This just seems incredibly complicated toâ€¦</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>original="KKKKKLLLLLLLLLLLLLLLOOOPPPPLLL"
expected="KKKKKLLLLLLLLLLOOOPPPPLL"
original=original.replace("LLL","LL")
print(len(expected))        #24
print(len(original))        #24
print(original==expected)   #True
</code></pre>
<p>New edit:</p>
<pre><code>import math
import re
s="KKKKKLLLLLLLLLLLLLLLOOOPPPPLLL"
expected="KKKKKLLLLLLLLLLOOOPPPPLL"
a=[]
for it in re.finditer("L+",s):
    a.append(it.span())
for p in reversed(a):
        l=p[1]-p[0]
        s=s[:p[0]]+"L"*round(l*2/3)+s[p[1]:]
print(s)
print(expected)
print(s==expected)
</code></pre>
<p>New edit2: as per <a href="https://stackoverflow.com/a/41799235/5033247">@wwii</a></p>
<pre><code>from itertools import groupby as gb
s="KKKKKLLLLLLLLLLLLLLLOOOPPPPLLL"
s="".join("".join(k)*(len(list(g))*2//3) if k=='L' else "".join(g) for k,g in gb(s))
</code></pre>
<p>New edit3:</p>
<pre><code>from itertools import groupby as gb
s1="KKKKKLLLLLLLLLLLLLLLOOOPPPPLLL"
s=""
for k,g in gb(s1):
    if k=='L': 
        s+="".join(k)*(len(list(g))*2//3) 
    else:  
        s+="".join(g)
print(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a> to group the string into contiguous duplicates and iterate over it;</li>
<li>make a list of the group</li>
<li>If the key for the group is <code>'L'</code>, get the length of the list and divide it by 3, use this number to slice the list</li>
<li>add the list to a <code>result</code> container</li>
<li>convert the container to a string</li>
</ul>
</div>
<span class="comment-copy">What if you have 2 or 14 which are not multiples of 3?</span>
<span class="comment-copy">Will the number of Ls always be a multiple of 3?</span>
<span class="comment-copy">So you want to reduce it to two thirds?</span>
<span class="comment-copy">No it won't always be reduced by multiples of 3</span>
<span class="comment-copy">"So a line of 50 'L', will need to be reduced by &lt;=25." 1 &lt;= 25. Does that mean you can reduce it by 1 L? How about by 0?</span>
<span class="comment-copy"><code>str.join</code> will consume a generator expression, no need to make a list.  The process in that list comprehension is probably easier to read if it is <i>unwound</i></span>
<span class="comment-copy">@wwii edited as per ur comments</span>
<span class="comment-copy">@SmartManoj Thanks for your answer. It wasn't totally what I was looking for, but I was able to make a few changes to your 'New edit' and that made it possible. You're awesome</span>
