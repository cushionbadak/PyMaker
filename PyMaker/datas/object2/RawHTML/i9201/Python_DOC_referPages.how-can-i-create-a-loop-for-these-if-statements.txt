<div class="post-text" itemprop="text">
<p>This is what I have achieved without a loop, which is ugly. I'm sure this can be done with a loop without having the repetitive statements:</p>
<pre><code>def my_function(my_list_of_words):
    _digits = re.compile('\d')
    to_return = []

    for i, p in enumerate(my_list_of_words):
        new_list= []
        if 'start' in p:
            if bool(_digits.search(my_list_of_words[i+1])):
                new_list.append(p)
                new_list.append(my_list_of_words[i+1])
                if bool(_digits.search(my_list_of_words[i+2])):
                    new_list.append(my_list_of_words[i+2])
                    if bool(_digits.search(my_list_of_words[i+3])):
                        new_list.append(my_list_of_words[i+3])
                to_return.append(" ".join(new_list))

    return to_return
</code></pre>
<p>This works fine, but I don't know how many strings with numbers there will be after <code>"start"</code>.</p>
<p>I want a loop that will continue looking for numbers in the list of strings, until the next index doesn't have a number.</p>
<p>I tried this:</p>
<pre><code>def my_function(my_list_of_words):
    _digits = re.compile('\d')
    to_return = []

    for i, p in enumerate(my_list_of_words):
        new_list= []
        count = 1
        if 'start' in p:
            new_list.append(p)
            while bool(_digits.search(my_list_of_words[i+count])):
                new_list.append(my_list_of_words[i+count])
                ++count
            to_return.append(" ".join(new_list))

    return to_return
</code></pre>
<p>This doesn't work for some reason, it seems to loop for ever. I have also tried:</p>
<pre><code>while True:
  if bool(_digits.search(my_list_of_words[i+count])):
    //doo things
    ++count
  else:
    break
</code></pre>
<p>This doesn't work for me either, it loops for ever.</p>
<p>Representation of what I'm trying to achieve:</p>
<pre><code>['foo','foo','foo','start', '23', 'a32bc', '43', '332', 'foo', 'start', '23', 'a32bc']
</code></pre>
<p>would produce</p>
<pre><code>['start 23 a32bc 43 332', 'start 23 a32bc']
</code></pre>
<p>Let's say we have the above list, when we reach <code>'start'</code>, I want to check whether the next has a number, in our case <code>23</code>, if yes, then check the next for number (contains <code>32</code> so true again), keep doing this until the next doesn't have a number.</p>
<p>How can I achieve this with a loop?</p>
</div>
<div class="post-text" itemprop="text">
<p>The Pythonic version of a <code>while True: count++</code> loop is an <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer"><em>iterator</em></a>, combined with <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next()</code> function</a> to advance to the next element. When the iterator is exhausted, a <a href="https://docs.python.org/3/library/exceptions.html#StopIteration" rel="nofollow noreferrer"><code>StopIteration</code> exception</a> is raised.</p>
<p>Create an iterator for your list (with the <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter()</code> function</a>, then use nested loops to advance the iterator as you match:</p>
<pre><code>def my_function(my_list_of_words, _digits=re.compile('\d').search):
    word_iter = iter(my_list_of_words)
    digit_words = None
    results = []
    try:
        curr = next(word_iter)
        while True:            
            # scan to the next 'start' value
            while 'start' not in curr:
                curr = next(word_iter)

            # collect digits; curr == start so we advance to the next
            digit_words = [curr]
            while True:
                curr = next(word_iter)
                if not _digits(curr):
                    break
                digit_words.append(curr)
            results.append(' '.join(digit_words))
            digit_words = []

    except StopIteration:
        # out of words, append remaining digit_words if there are any.
        if digit_words:
            results.append(' '.join(digit_words))

    return results
</code></pre>
<p>So this skips elements until <code>'start'</code> is found, then collects entries that have digits, then switches back to finding <code>'start'</code>, etc. until <code>StopIteration</code> is raised by the <code>next()</code> call.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; my_function(['foo','foo','foo','start', '23', 'a32bc', '43', '332', 'foo', 'start', '23', 'a32bc'])
['start 23 a32bc 43 332', 'start 23 a32bc']
</code></pre>
<p>You could replace all the <code>results.append()</code> calls with <code>yield</code> to make this a generator.</p>
<p>Note that I'm assuming there won't be any <em>overlapping</em> sequences; e.g. <code>'start'</code> will never appear in a word with digits in a contiguous digits section.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re

def my_function(my_list_of_words):
    _digits = re.compile('\d')
    to_return = []

    for i, p in enumerate(my_list_of_words):
        new_list= []
        if 'start' in p and i+1 &lt; len(my_list_of_words):
            if bool(_digits.search(my_list_of_words[i+1])):
                new_list.append(p)
                for j in xrange(1,len(my_list_of_words)-i):
                    if bool(_digits.search(my_list_of_words[i+j])):
                        new_list.append(my_list_of_words[i+j])
                    else:
                        break
                to_return.append(" ".join(new_list))

    return to_return

print my_function(['foo','foo','foo','start', '23', 'a32bc', '43', '332', 'foo', "donotmatch66", 'start', '23', 'a32bc', 'start'])
</code></pre>
<p>will return </p>
<pre><code>['start 23 a32bc 43 332', 'start 23 a32bc']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here, a simple program to find prime numbers in python which should cover your <code>for loop</code> in  <code>if</code> condition :</p>
<pre><code>def getPrime(X):
    print("The entered number is ",str(X))
    x=int(X)
    if x==1:
        print("1 is treated as speacial charater")
        return False
    for i in range(2,x):
        if x%i==0:
            print("{} is eual to {}x{}".format(x,i,x//i))
            return False
        else:
            print(x, "is a Prime Number")
            return True


print("Please enter number greater than 1 ")
M =input()
m=int(M)
for i in range(2,m):
    getPrime(i)
</code></pre>
</div>
<span class="comment-copy">I'm pretty sure <code>++count</code> doesn't do anything, try <code>count += 1</code> instead.</span>
<span class="comment-copy">Why do you count your entries? Just iterate over them and break when the condition is false.</span>
<span class="comment-copy">@MSeifert You're right, moving from Java to Python, still trying to get used to some basic concepts. Thanks for that. Also, I'm using "Pythonanywhere" as a testing ground, and in its editor, it did not provide any errors, nor syntax errors, which is not helpful.</span>
<span class="comment-copy">PyCharm might be helpful regarding checking errors / improvements of codes.</span>
<span class="comment-copy">You currently scan ahead, to find all words with digits, then start scanning for the next <code>start</code> value from right after the previous <code>start</code>. This means you can have <i>overlapping sequences</i>, where one word contains both <code>'start'</code> and digits. Is this likely to happen? Is that expected behaviour? In other words, what is the expected return value for <code>['start', '32', '42start', '81', 'foo']</code>?</span>
<span class="comment-copy">Very professional answer. Iterators might be a lot to comprehend for beginners, I fear. Thanks for clarifying comments! :)</span>
<span class="comment-copy">@MKesper: given that the OP already wrote out pseudocode that effectively does the same thing (incrementing a counter until you run out of words), I don't think this is that great a leap.</span>
<span class="comment-copy">This should be included in the official Python tutorial in the chapter about sequences.</span>
<span class="comment-copy">@MSeifert: The sample input won't tickle that edge-case, but I've posted a comment asking about it anyway.</span>
<span class="comment-copy">If I just feed it with <code>my_function(['start'])</code>, there is an infinite loop. Solution is nice though</span>
<span class="comment-copy">Is there a need for range?</span>
<span class="comment-copy">@MKesper : you mean instead of <code>xrange</code> ? nope.</span>
<span class="comment-copy">No, instead of just iterating over the entries.</span>
<span class="comment-copy">This might also run into an IndexError.</span>
<span class="comment-copy">About the iteration: OP seemed to only want <code>'start'</code> when it was followed by a word containing a digit, so it was either an inner loop or a variable to keep track of the state. About the <code>IndexError</code>, I'd like to know which case you're thinking of :)</span>
<span class="comment-copy">Please let me know if i am not able to answer your question.</span>
