<div class="post-text" itemprop="text">
<p>While <code>frozendict</code> <a href="https://www.python.org/dev/peps/pep-0416/#rejection-notice" rel="noreferrer">was rejected</a>, a related class <code>types.MappingProxyType</code> was added to public API in python 3.3.</p>
<p>I understand <code>MappingProxyType</code> is just a wrapper around the underlying <code>dict</code>, but despite that isn't it functionally equivalent to <code>frozendict</code>?</p>
<p>In other words, what's the substantive difference between the original PEP 416 <code>frozendict</code> and this:</p>
<pre><code>from types import MappingProxyType
def frozendict(*args, **kwargs):
  return MappingProxyType(dict(*args, **kwargs))
</code></pre>
<p>Of course <code>MappingProxyType</code> is not hashable as is, but just as <a href="https://www.python.org/dev/peps/pep-0416/#recipe-hashable-dict" rel="noreferrer">the PEP suggested for <code>frozendict</code></a>, it can be made hashable after ensuring that all its values are hashable (MappingProxyType cannot be subclassed, so it would be require composition and forwarding of methods).</p>
</div>
<div class="post-text" itemprop="text">
<h2>TL;DR</h2>
<p><code>MappingProxyType</code> is a read only proxy for mapping (e.g. dict) objects.</p>
<p><code>frozendict</code> is an immutable dict</p>
<h2>Answer</h2>
<p>The proxy pattern is (quoting <a href="https://en.wikipedia.org/wiki/Proxy_pattern" rel="noreferrer">wikipedia</a>):</p>
<blockquote>
<p>A proxy, in its most general form, is a class functioning as an
  interface to something else.</p>
</blockquote>
<p>The <code>MappingProxyType</code> is just a simple proxy (i.e. interface) to access the real object (the real map, which on our example is dict).</p>
<p>the suggested <code>frozendict</code> object is just as set is to frozenset. a read only  (immutable) object which can only be changed upon creation.</p>
<p>So why do we need <code>MappingProxyType</code>? example use case is where you want to pass a dictionary to another function but without it able to change your dictionary, it act as a read only proxy, (quoting <a href="https://docs.python.org/3.5/library/types.html#types.MappingProxyType" rel="noreferrer">python docs</a>):</p>
<blockquote>
<p>Read-only proxy of a mapping. It provides a dynamic view on the
  mappingâ€™s entries, which means that when the mapping changes, the view
  reflects these changes.</p>
</blockquote>
<p>lets see some example usage of the <code>MappingProxyType</code></p>
<pre><code>In [1]: from types import MappingProxyType
In [2]: d = {'a': 1, 'b': 2}
In [3]: m = MappingProxyType(d)
In [4]: m['a']
Out[4]: 1
In [5]: m['a'] = 5
TypeError: 'mappingproxy' object does not support item assignment
In [6]: d['a'] = 42
In [7]: m['a']
Out[7]: 42
In [8]: for i in m.items():
...:     print(i)

('a', 42)
('b', 2)
</code></pre>
<h2>Update:</h2>
<p>because the PEP did not make it into python, we cannot know for sure what the implementation that would be.
by looking at the PEP we see that:</p>
<pre><code>frozendict({'a': {'b': 1}})
</code></pre>
<p>would raise an exception as <code>{'b': 1}</code> is not hashable value, but on your implementation it will create the object. of-course, you can add a validation for the value as noted on the PEP.</p>
<p>I assume part of the PEP was memory optimization and implementation of this kind of frozendict could have benefit from the performance of dict comparison using the <code>__hash__</code> implementation.</p>
</div>
<span class="comment-copy">Yes, but my question was whether there's any substantial difference between the rejected <code>frozendict</code> and the one you can create as a thin wrapper around <code>MappingProxyType</code>. Can you give example of some code that would work with the (rejected) PEP 416 <code>frozendict</code> but would not work with the <code>frozendict</code> that I defined in my question?</span>
<span class="comment-copy">frozendict would enable to use dictionaries as key or make a set of dictionaries. MappingProxyType objects can't be used as dict key or set elements since they could be mutated indirectly during their life cycle, potentially breaking the uniqueness invariant.</span>
<span class="comment-copy">So, the differences so far are 1) MPT isn't hashable, and thus has a wider range of acceptable keyvalues, and 2) MPT isn't subclassable. Why isn't it subclassable?</span>
<span class="comment-copy">@Dubslow. If I had to guess, it's because the C magic that implements it says so. Here is the C interface: <a href="https://docs.python.org/3/c-api/dict.html#c.PyDictProxy_New" rel="nofollow noreferrer">docs.python.org/3/c-api/dict.html#c.PyDictProxy_New</a></span>
