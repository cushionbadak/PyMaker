<div class="post-text" itemprop="text">
<p>We all know that functions are objects as well. But how do function objects compare with functions? What are the differences between function objects and functions? </p>
<p>By function object I mean g so defined:</p>
<pre><code>class G(object):
    def __call__(self, a):
        pass
g = G()
</code></pre>
<p>By function I mean this: </p>
<pre><code>def f(a):
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python creates function objects for you when you use a def statement, or you use a lambda expression:</p>
<pre><code>&gt;&gt;&gt; def foo(): pass
... 
&gt;&gt;&gt; foo
&lt;function foo at 0x106aafd70&gt;
&gt;&gt;&gt; lambda: None
&lt;function &lt;lambda&gt; at 0x106d90668&gt;
</code></pre>
<p>So whenever you are defining a function in python an object like this is created. There is <strong>no plain</strong> way of function definition.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>TL;DR</strong> any object that implements <code>__call__</code> can be called eg: functions, custom classes, etc..</p>
<p><strong>Slightly longer version:</strong> (w<sub>all</sub>o<sub>f</sub>t<sub>ext</sub>)</p>
<p>The full answer to your question on what's the difference sits within the implementation of the python virtual machine, so we must take a look at python under the hood. First comes the concept of a code object. Python parses whatever you throw at it into it's own internal language that is the same across all platforms known as bytecode. A very visual represnetation of this is when you get a .pyc file after importing a custom library you wrote. These are the raw instructions for the python VM. Ignoring how these instructions are created from your source code, they are then executed by <code>PyEval_EvalFrameEx</code> in <em>Python/ceval.c</em>. The source code is a bit of a beast, but ultimately works like a simple processor with some of the complicated bits abstracted away. The bytecode is the assembly language for this processor. In particular one of the "opcodes" for this "processor" is (aptly named) <code>CALL_FUNCTION</code>. The callback goes through a number of calls eventually getting to <code>PyObject_Call()</code>. This function takes a pointer to a <code>PyObject</code> and extracts the <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_call" rel="nofollow noreferrer"><code>tp_call</code></a> attribute from it's type and directly calls it (technically it checks if it's there first): </p>
<pre class="lang-c prettyprint-override"><code>...
call = func-&gt;ob_type-&gt;tp_call //func is an arg of PyObject_Call() and is a pointer to a PyObject
...
result = (*call)(func, arg, kw);
</code></pre>
<p>Any object that implements <code>__call__</code> is given a <code>tp_call</code> attribute with a pointer to the actual function. I believe that is handled by the <code>slotdefs[]</code> difinition from <em>Objects/typeobject.c</em>:</p>
<pre><code>FLSLOT("__call__", tp_call, slot_tp_call, (wrapperfunc)wrap_call,
       "__call__($self, /, *args, **kwargs)\n--\n\nCall self as a function.",
       PyWrapperFlag_KEYWORDS)
</code></pre>
<p>The <code>__call__</code> method itself for functions is defined in the cpython implementation and it defines how the python VM should start executing the bytecode for that function and how data should be returned (if any). When you give an arbitrary class a <code>__call__</code> method, the attribute is a function object that again refers back to the cpython implementation of <code>__call__</code>. Therefore when you call a "normal" function <code>foo.__call__</code> is referenced. when you call a callable class, the <code>self.__call__</code> is equivalent to <code>foo</code> and the actual cpython reference called is <code>self.__call__.im_func.__call__</code>.</p>
<p><strong>disclaimer</strong></p>
<p>This has been a journey into somewhat uncharted waters for me, and it's entirely possible I have misrepresented some of the finer points of the implementation. I mainly took from <a href="http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/" rel="nofollow noreferrer">this</a> blog post on how python callables work under the hood, and some digging of my own through the python <a href="https://www.python.org/downloads/source/" rel="nofollow noreferrer">source code</a></p>
</div>
<span class="comment-copy">What do you mean "plain functions"?</span>
<span class="comment-copy">Please give example what a  function object and function is in your opinion.</span>
<span class="comment-copy">This is like asking what is the difference between a <i>plain <code>int</code></i> and an <i><code>int</code> object</i> in Python... there <i>are no plain <code>int</code>s</i>.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/865963/3220135">"Everything in python is an object"</a></span>
<span class="comment-copy">@MikeMÃ¼ller I edited the question explaining what I meant with function objects and function. Thanks for asking for a clearer question.</span>
<span class="comment-copy">After the OP clarified his question this seems irrelevant.</span>
<span class="comment-copy">Does a 'function' object have attribute '<b>set</b>'? What about attribute '<b>get</b>'? You are not answering my question.</span>
<span class="comment-copy">Thanks for your answer which is interesting. Actually I was wondering more on features of the high level language such as why a 'function' object doesn't have attributes '<b>set</b>' and '<b>get</b>'. But I found interesting the informations you provided in your answer too.</span>
<span class="comment-copy">Functions do implement <code>__get__</code>, It's what returns the text "&lt;function A at 0x00000000064F5208&gt;"</span>
<span class="comment-copy">it is much more common to use getters and setters to apply to an individual property of a class not the class itself. also functions do not inherit from the base object class, with the intent that if you want custom behavior, you can just implement it with classes. technically you could create your own function class, but it would be very slow and rather complicated. by not inheriting from the base object class, python can run it's c code instead to manage the calling of a code objec</span>
