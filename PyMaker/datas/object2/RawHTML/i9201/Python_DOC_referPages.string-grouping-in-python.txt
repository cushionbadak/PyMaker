<div class="post-text" itemprop="text">
<p>I'm working on <a href="http://cryptopals.com/sets/1/challenges/6" rel="nofollow noreferrer">Cryptopals Challenge #6</a></p>
<p>If the string is '11111222223333344444' and I want groups of 5, how do I group and compare the pairs.</p>
<p>For example, I want to group and compare '11111' and '22222', '33333' and '44444'. How could this be done? </p>
<p>I used this code and keep getting extra lines after the 4's...</p>
<pre><code>&gt;&gt;&gt; for i in range(0, int(len(string)/size)):
...     print(string[previous : previous + size])
...     print(string[previous + size : previous + size * 2])
...     previous += size * 2

11111
22222
33333
44444
</code></pre>
<p>What are other ways to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>zip</code> idiom <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">here</a> to group elements into groups of a known size.</p>
<pre><code>s='11111222223333344444'
for i in zip(*[iter(s)]*5):
    print(i)
</code></pre>
<p>Outputs:</p>
<pre><code>('1', '1', '1', '1', '1')
('2', '2', '2', '2', '2')
('3', '3', '3', '3', '3')
('4', '4', '4', '4', '4')
</code></pre>
<p>If you want them as a single string you can use <code>''.join</code></p>
<pre><code>for i in zip(*[iter(s)]*5):
    print(''.join(i))
</code></pre>
<p>Outputs:</p>
<pre><code>11111
22222
33333
44444
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of ways to do this. A classic implementation is via list comprehension:</p>
<pre><code>chunks = [string[i:i + 5] for i in range(0, len(string), 5)]
</code></pre>
<p>Using itertools.zip_longest is my preference:</p>
<pre><code>def chunk(seq, size):
    for ch in itertools.zip_longest(*([iter(seq)] * size)):
        if None in ch:
            ch = ch[:ch.index(None)]
        yield ''.join(ch)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def grouper(i, group_size):
    start = 0
    end = group_size
    while start &lt; len(i):
        yield i[start:end]
        start = end
        end += group_size

groups = [i for i in grouper('11111222223333344444', 5)]

print(groups)
['11111', '22222', '33333', '44444']
</code></pre>
</div>
<span class="comment-copy">compare ? what do you mean? they're different. You mean you can have 10 times <code>1</code> ?</span>
<span class="comment-copy">Compare, in general, but specifically with this project, I need to take the average hamming distance of the string. So I need to take the hamming distance of the first and second strings, third and four strings, and so on, and then compute the average.</span>
<span class="comment-copy">How would I do this with a decoded base 64 string. For example, <code>base64.b64decode(string)</code> @PatrickHaugh</span>
<span class="comment-copy">There are a lot of extraneous copies here <code>while len(i[start:]): yield seq[start:start + group_size]; start += group_size</code> removes the need to keep track of a separate <code>end</code> variable.</span>
