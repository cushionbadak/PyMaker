<div class="post-text" itemprop="text">
<p>I am trying to understand how index operator [] works in some cases involving dictionaries.</p>
<pre><code>&gt;&gt;&gt; {'a': 1, 'b':2}[1]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 1
</code></pre>
<p>However...</p>
<pre><code>&gt;&gt;&gt; {True: 1, False:2, True: 3}[1]
3
</code></pre>
<p>What's going on here?</p>
<p>Also, what's with the below?</p>
<pre><code>&gt;&gt;&gt; {True: 1, False:2, True: 3}
{False: 2, True: 3}
</code></pre>
<p>Why is {True: 1, False:2, True: 3}" evaluating to "{False: 2, True: 3}"?</p>
<p>When searching for answer, I came across <a href="http://I%20came%20across%20this%20https://stackoverflow.com/questions/22275027/using-true-false-as-keys-how-why-does-this-work" rel="nofollow noreferrer">this question</a>, but I couldn't find answers to my questions there.</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>{True: 1, False:2, True: 3}<a href="https://stackoverflow.com/questions/7134984/why-does-1-true-but-2-true-in-python">1</a></p>
<p>What's going on here?</p>
</blockquote>
<p>This is an extremely specific case, which might be really missguiding. In python "1" is True and "0" is False, thus you can use these integers/floats as boolean keys. However, it is not a regular casting operation, so if you try to use "1.1" as a key, it will not be casted to True, even though bool(1.2)==True. So in general - you <strong>have to</strong> index with the actual keys. The fact that True is actually 1 "behind the scenes" and False is 0 is a specific exception and you should not write code depending on this behaviour.</p>
<pre><code>d = {True: 'test', False: 'test'}
print d[True] # works, valid use
print d[False] # works, valid use
print d[1] # works due to Python specifics, do not use
print d[0] # works due to Python specifics, do not use
print d[1.0] # works due to Python specifics, do not use
print d[0.0] # works due to Python specifics, do not use
print d[1.1] # raises exception, as it should
print d[''] # raises exception, as it should
</code></pre>
<p>This is a consequence of how boolean type is defined in Python</p>
<blockquote>
<p>Boolean values are the two constant objects False and True. They are used to represent truth values (although other values can also be considered false or true). In numeric contexts (for example when used as the argument to an arithmetic operator), they behave like the integers 0 and 1, respectively. The built-in function bool() can be used to cast any value to a Boolean, if the value can be interpreted as a truth value (see section Truth Value Testing above).</p>
</blockquote>
<p>Thus <a href="https://stackoverflow.com/questions/7134984/why-does-1-true-but-2-true-in-python">showing why 1==True and 0==False</a>.</p>
<p>More precisely, Python dictionaries are hash tables, so in order to find a given key one computes its hash (through hash(key)), which points to a given "bucket" and then iteratively checks in that bucker whether key equals to what is in that bucket. And since in Python hash(1) == hash(1.0) == hash(True) and also 1 == 1.0 == True, they will work as the same key. On the other hand hash(1.1) != hash(1.0) so it will not be the same. This shows why it is <strong>not</strong> casting, it is about equality and hashing.</p>
<blockquote>
<p>Why is {True: 1, False:2, True: 3}" evaluating to "{False: 2, True: 3}"?</p>
</blockquote>
<p>Its because in a dictionary you can only have <strong>one</strong> value for each key, you tried to assign two different values to a key "True" and only one got assigned.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python dict is a map from key to a value, which maps "hashable" values to arbitrary value objects, you can only have one value per key.</p>
<p>In this case your example</p>
<pre><code>&gt;&gt;&gt; {True: 1, False:2, True: 3}
{False: 2, True: 3}
</code></pre>
<p>Is pretty much the same as this</p>
<pre><code>&gt;&gt;&gt; {"a": 1, "b": 2, "a": 3}
{'a': 3, 'b': 2}
</code></pre>
<p>Where the only one True, or "a" value is kept. </p>
<p>The access via [] is not an index in a dict, it's referencing via the key. I.e. you could write something like this</p>
<pre><code>&gt;&gt;&gt; my_map = {"a": 1, "b": 2}
&gt;&gt;&gt; my_map["b"]
2
</code></pre>
<p>Why 1 works instead of True is because of how booleans have been defined to wkr as the integer values 1 and 0 as @lejlot explains, you should avoid relying on such things whenever possible.</p>
</div>
<span class="comment-copy">Have you tried reading the <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">docs</a>?</span>
<span class="comment-copy">Could it be that you are mixing up keys and values in the dict?</span>
<span class="comment-copy">@tobias_k: Yes, mistook [] for indexing, forgot that it's dictionary in this case (not a sequence). That tripped me.</span>
<span class="comment-copy">Dictionaries are not ordered (prior to Cpython 3.6) but they are evaluated left to right, in this sense it is guaranteed that the last key with <code>True</code> will be the one kept</span>
<span class="comment-copy">@Chris - do you know the language standard specification that describes how these objects are being parsed? Are they always just left to right assignments? I was unable to find the doc thus the note, as it seems to be interpreter specific, not language specific.</span>
<span class="comment-copy">Thank you lejlot and @Chris_Rands.  Totally mistook [] for indexing, without noticing that it's a dictionary. That tripped me.</span>
<span class="comment-copy">The keys are updated left to right, this is guaranteed I'm pretty sure. Although you can't do this with keywords, like <code>dict(a=1,a=2)</code> raises a <code>SyntaxError</code></span>
<span class="comment-copy">Python does not have "automatic casting", this is actually one of the Python mantras/assumptions. No implicit type conversions.</span>
<span class="comment-copy">Thanks @Janne. otally mistook [] for indexing, without noticing that it's a dictionary. That tripped me.</span>
<span class="comment-copy">Yes @lejlot, quite true, Python does not implicitly cast things, however there are a few surprises with that such as in this case. Automatic casting was poorly chosen wording to try and simplify the concept.</span>
