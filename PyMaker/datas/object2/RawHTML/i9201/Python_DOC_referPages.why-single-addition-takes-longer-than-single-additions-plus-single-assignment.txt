<div class="post-text" itemprop="text">
<p>Here is the python code, I use python 3.5.2/Intel(R) Core(TM) i7-4790K CPU @ 4.00GHz :</p>
<pre><code>import time

empty_loop_t = 0.14300823211669922
N = 10000000


def single_addition(n):
    a = 1.0
    b = 0.0
    start_t = time.time()
    for i in range(0, n):
        a + b
    end_t = time.time()
    cost_t = end_t - start_t - empty_loop_t

    print(n,"iterations single additions:", cost_t)
    return cost_t

single_addition(N)


def single_addition_plus_single_assignment(n):
    a = 1.0
    b = 0.0
    c = 0.0
    start_t = time.time()
    for i in range(0, n):
        c = a + b
    end_t = time.time()
    cost_t = end_t - start_t - empty_loop_t

    print(n,"iterations single additions and single assignments:", cost_t)
    return cost_t

single_addition_plus_single_assignment(N)
</code></pre>
<p>The output is:</p>
<pre>
10000000 iterations single additions: 0.19701123237609863
10000000 iterations single additions and single assignments: 0.1890106201171875
</pre>
<p>Normally, to get a more reliable result, it is better to do the test using K-fold. However, since K-fold loop itself has influence on the result, I don't use it in my test. And I'm sure this inequality can be reproduced, at least on my machine. So the question is why this happened? </p>
</div>
<div class="post-text" itemprop="text">
<p>I run it with pypy (had to set empty_loop_t = 0) and got the following results:</p>
<pre><code>(10000000, 'iterations single additions:', 0.014394044876098633)
(10000000, 'iterations single additions and single assignments:', 0.018398046493530273)
</code></pre>
<p>So I guess it's up to what interpreter does with the source code and how interpreter executes it. It might be that deliberate assignment takes less operations and workload than disposing of the result with non-JIT interpreter while JIT-compiler forces the code to perform the actual number of operations.</p>
<p>Furthermore, the use of JIT-interpreter makes your script run ~50 times faster on my configuration. If you general aim is to optimize the running time of your script you are probably to look that way.</p>
</div>
<span class="comment-copy">All measurements below one second are unreliable because too many small things can go wrong during that time. Increase the measurement time so that it lies between 10 and 20 seconds. Also you should have stated how often you measured and how reliable the results are.</span>
<span class="comment-copy">In line with the previous comment, try using <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">timeit</a>, which "avoids a number of common traps for measuring execution times."</span>
