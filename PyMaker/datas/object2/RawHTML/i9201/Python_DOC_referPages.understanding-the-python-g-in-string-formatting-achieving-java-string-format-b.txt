<div class="post-text" itemprop="text">
<p>In Java:</p>
<pre><code>String test1 = String.format("%7.2g", 3e9);
System.out.println(test1);
</code></pre>
<p>This prints <code>3.0e+09</code></p>
<p>In Python 2.7, if I run this code</p>
<pre><code>for num in [3e9, 3.1e9, 3.01e9, 3e2, 3.1e2, 3.01e2]:
   print '%7.2g %7.2f %7.2e' % (num, num, num)
</code></pre>
<p>I get</p>
<pre><code>  3e+09 3000000000.00 3.00e+09
3.1e+09 3100000000.00 3.10e+09
  3e+09 3010000000.00 3.01e+09
  3e+02  300.00 3.00e+02
3.1e+02  310.00 3.10e+02
  3e+02  301.00 3.01e+02
</code></pre>
<p>Huh? It looks like the precision (.2) argument is treated totally differently in Python's <code>%g</code> than in Python's <code>%f</code>, Python's <code>%e</code>, or Java's <code>%g</code>. Here's the <a href="https://docs.python.org/2/library/string.html#format-specification-mini-language" rel="nofollow noreferrer">doc</a> (my emphasis):</p>
<blockquote>
<p>General format. For a given precision p &gt;= 1, this rounds the number to p significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude.</p>
<p>The precise rules are as follows: suppose that the result formatted with presentation type 'e' and precision p-1 would have exponent exp. Then if -4 &lt;= exp &lt; p, the number is formatted with presentation type 'f' and precision p-1-exp. Otherwise, the number is formatted with presentation type 'e' and precision p-1. <strong>In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it.</strong></p>
<p>Positive and negative infinity, positive and negative zero, and nans, are formatted as inf, -inf, 0, -0 and nan respectively, regardless of the precision.</p>
<p>A precision of 0 is treated as equivalent to a precision of 1. The default precision is 6.</p>
</blockquote>
<p>WTF? Is there any way to prevent those trailing zeros from being removed? The whole point of string formatting is to achieve some consistency, e.g. for text alignment.</p>
<p>Is there any way to get the Java behavior (essentially the number of significant digits to the right of the decimal point) without having to rewrite the whole thing from scratch?</p>
</div>
<div class="post-text" itemprop="text">
<p>The formatting that python does is more consistent with C's <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html" rel="nofollow noreferrer"><code>printf</code></a> style formatting, which also drops trailing zeros for the <code>g</code> conversion. Since python's reference implementation is in C, why should it be consistent with Java in this case?</p>
<p>When using the <code>%</code> operator for string formatting, the relevant documentation is <a href="https://docs.python.org/2/library/stdtypes.html#string-formatting-operations" rel="nofollow noreferrer">String Formatting Operations</a>, which has some differences to the one you linked to, notably that it allows the <code>#</code> alternate form for <code>g</code>:</p>
<blockquote>
<p>The alternate form causes the result to always contain a decimal point, and trailing zeroes are not removed as they would otherwise be.</p>
<p>The precision determines the number of significant digits before and after the decimal point and defaults to 6.</p>
</blockquote>
<p>So in your case:</p>
<pre><code>&gt;&gt;&gt; "%#7.2g" % 3e9
3.0e+09
</code></pre>
<p>This is different from what is allowed by <code>str.format()</code>, where <code>#</code> is used to enable prefixes for binary, octal or hexadecimal output (at least in python2, this was changed in python3).</p>
</div>
<div class="post-text" itemprop="text">
<p>With the <code>format</code> method, you can do something like this:</p>
<pre><code>for num in [3e9, 3.1e9, 3.01e9, 3e2, 3.1e2, 3.01e2]:
    print ('{n:7.2{c}} {n:7.2f} {n:7.2e}'.format(n=num, c='e' if num &gt; 1e4 else 'f'))
</code></pre>
<p>Output:</p>
<pre><code>3.00e+09 3000000000.00 3.00e+09
3.10e+09 3100000000.00 3.10e+09
3.01e+09 3010000000.00 3.01e+09
 300.00  300.00 3.00e+02
 310.00  310.00 3.10e+02
 301.00  301.00 3.01e+02
</code></pre>
<p>There are two parts to it that might not be so well known.</p>
<h3>1. Parametrizing the string formatting</h3>
<p>In addition to simple formatting:</p>
<pre><code>&gt;&gt;&gt; '{}'.format(3.5)
'3.5'
</code></pre>
<p>and formatting with more detailed specification of the result:</p>
<pre><code>&gt;&gt;&gt; '{:5.2f}'.format(3.5)
' 3.50'
</code></pre>
<p>you can use keyword arguments in <code>format</code>that you can access in the string :</p>
<pre><code>&gt;&gt;&gt; '{num:5.2f}'.format(num=3.5)
' 3.50'
</code></pre>
<p>You can use these also for the format specification itself:</p>
<pre><code>&gt;&gt;&gt; '{:5.{deci}f}'.format(3.5, deci=3)
'3.500'
</code></pre>
<h3>2. The <code>if</code> expression</h3>
<p>In addition to the <code>if</code> statement there is an <code>if</code> expression, a.k.a. <a href="https://docs.python.org/3/reference/expressions.html#conditional-expressions" rel="nofollow noreferrer">ternary operator</a>.</p>
<p>So, this expression:</p>
<pre><code>a = 1
b = 2
res = 10 if a &lt; b else 20
</code></pre>
<p>is equivalent to this statement:</p>
<pre><code>if a &lt; b:
    res = 10
else:
    res= 20
</code></pre>
<p>Putting both together yields something like this:</p>
<pre><code>'{num:7.2{c}}'.format(num=num, c='e' if num &gt; 1e4 else 'f')
</code></pre>
</div>
<span class="comment-copy">huh... interesting! I think once I grok your answer I will accept it.</span>
<span class="comment-copy">Added some explanation for facilitate the grokking. ;)</span>
<span class="comment-copy">hmmmm... oh, so you're just choosing <code>%7.2e</code> vs <code>%7.2f</code> depending on the magnitude of <code>num</code> (you need <code>abs</code> by the way). That won't do it, there's a fundamental difference here between the languages' string formatting logic.</span>
