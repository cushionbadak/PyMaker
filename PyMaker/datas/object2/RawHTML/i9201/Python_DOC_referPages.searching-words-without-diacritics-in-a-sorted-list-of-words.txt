<div class="post-text" itemprop="text">
<p>I've been trying to come up with an efficient solution for the following problem. I have a sorted list of words that contain diacritics and I want to be able to do a search without using diacritics. So for example I want to match 'kříž' just using 'kriz'. After a bit of brainstorming I came up with the following and I want to ask you, more experienced (or clever) ones, whether it's optimal or there's a better solution. I'm using Python but the problem is language independent.</p>
<p>First I provide a mapping of those characters that have some diacritical siblings. So in case of Czech:</p>
<pre><code>cz_map = {'a' : ('á',), ... 'e' : ('é', 'ě') ... }
</code></pre>
<p>Now I can easily create all variants of a word on the input. So for 'lama' I get: ['lama', 'láma', 'lamá', 'lámá']. I could already use this to search for words that match any of those permutations but when it comes to words like 'nepredvidatelny' (unpredictable) one gets 13824 permutations. Even though my laptop has a shining Intel i5 logo on him, this is to my taste too naive solution.</p>
<p>Here's an improvement I came up with. The dictionary of words I'm using has a variant of binary search for prefix matching (returns a word on the lowest index with a matching prefix) that is very useful in this case. I start with a first character, search for it's prefix existence in a dictionary and if it's there, I stack it up for the next character that will be tested appended to all of these stacked up sequences. This way I'm propagating only those strings that lead to a match. Here's the code:</p>
<pre><code>def dia_search(word, cmap, dictionary):
    prefixes = ['']
    for c in word:
        # each character maps to itself
        subchars = [c]
        # and some diacritical siblings if they exist
        if cmap.has_key(c):
            subchars += cmap[c]
        # build a list of matching prefixes for the next round
        prefixes = [p+s for s in subchars
                        for p in prefixes
                        if dictionary.psearch(p+s)&gt;0]
    return prefixes
</code></pre>
<p>This technique gives very good results but could it be even better? Or is there a technique that doesn't need the character mapping as in this case? I'm not sure this is relevant but the dictionary I'm using isn't sorted by any collate rules so the sequence is 'a', 'z', 'á' not 'a', 'á', 'z' as one could expect.</p>
<p>Thanks for all comments.</p>
<p><strong>EDIT:</strong> I cannot create any auxiliary precomputed database that would be a copy of the original one but without diacritics. Let's say the original database is too big to be replicated.</p>
</div>
<div class="post-text" itemprop="text">
<p>using the standard library only (<a href="https://docs.python.org/3/library/stdtypes.html#str.maketrans" rel="nofollow noreferrer"><code>str.maketrans</code></a>  and <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer"><code>str.translate</code></a>) you could do this:</p>
<pre><code>intab = "řížéě"  # ...add all the other characters
outtab = "rizee" # and the characters you want them translated to
transtab = str.maketrans(intab, outtab)

strg = "abc kříž def ";
print(strg.translate(transtab)) # abc kriz def 
</code></pre>
<p>this is for python3.</p>
<p>for python 2 you'd need to:</p>
<pre><code>from string import maketrans
transtab = maketrans(intab, outtab)
# the rest remains the same
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have a look into <a href="https://pypi.python.org/pypi/Unidecode" rel="nofollow noreferrer">Unidecode</a> using which u can actually convert the diacritics into closest ascii. e.g.:-<code>unidecode(u'kříž')</code></p>
</div>
<div class="post-text" itemprop="text">
<p>As has been suggested, what you want to do is to translate your unicode words (containing diacritics) to the closest standard 24-word alphabet version.</p>
<p>One way of implementing this would be to create a second list of words (of the same size of the original) with the corresponding translations. Then you do the query in the translated list, and once you have a match look up the corresponding location in the original list.</p>
<p>Or in case you can alter the original list, you can translate everything in-place and strip duplicates.  </p>
</div>
<span class="comment-copy">This could be used to create a copy of my word list without diacritics. The thing is I cannot keep two copies, only the original one with diacritics. If you have a database that contains 3 million items then duplicating it is not a way to go.</span>
<span class="comment-copy">at some point you need to do this (or a similar) translation. be it to create an index in a database or something else... <code>translate</code> should be more efficient than just using a <code>dict</code>. (3 million items in a db should be perfectly handleable).</span>
<span class="comment-copy">At which point do you mean? I presented a solution that works with the original copy and my question was - is there anything more efficient? Duplicating a database of a size of hundreds of MB is something I don't see as more efficient. Another flaw about <code>translate</code> is it wouldn't allow me to map German 'ß' to 'ss', or would it? Anyway, <code>translate</code> vs <code>dict</code> isn't really relevant here because it's used only to hold the mapping which is just a few characters in almost every alphabet that uses latin. In case of Czech it's only 15 diacritic characters that need to be mapped.</span>
<span class="comment-copy">you talk about 'database'. maybe you should clarify: what kind of db? would <a href="http://stackoverflow.com/a/3304596/4954037">this answer</a> help? some dbs can take care of your issue. and you are correct: <code>translate</code> can not handle things like 'ß' (one char into two)...</span>
<span class="comment-copy">but you are right: my solution does not exactly do what you like and there is probably no remedy for that...</span>
