<div class="post-text" itemprop="text">
<p>I have this code:</p>
<pre><code>class A(object):
    @staticmethod
    def open():
        return 123
    @staticmethod
    def proccess():
        return 456


    switch = {
        1: open,
        2: proccess,   
        }
obj = A.switch[1]()
</code></pre>
<p>When I run this I keep getting the error:</p>
<pre><code>TypeError: 'staticmethod' object is not callable
</code></pre>
<p>how to resolve it?</p>
<hr/>
</div>
<div class="post-text" itemprop="text">
<p>You are storing <em>unbound</em> <code>staticmethod</code> objects in a dictionary. Such objects (as well as <code>classmethod</code> objects, functions and <code>property</code> objects)  are only bound through the <a href="https://docs.python.org/3/howto/descriptor.html" rel="noreferrer">descriptor protocol</a>, by accessing the name as an attribute on the class or an instance. Directly accessing the <code>staticmethod</code> objects in the class body is not an attribute access.</p>
<p>Either create the dictionary <em>after</em> creating the class (so you access them as attributes), or bind explicitly, or extract the original function before storing them in the dictionary.</p>
<p>Note that 'binding' for <code>staticmethod</code> objects merely means that the context is merely ignored; a bound <code>staticmethod</code> returns the underlying function unchanged.</p>
<p>So your options are to unindent the dictionary and trigger the descriptor protocol by using attributes:</p>
<pre><code>class A(object):
    @staticmethod
    def open():
        return 123
    @staticmethod
    def proccess():
        return 456

A.switch = {
    1: A.open,
    2: A.proccess,   
}
</code></pre>
<p>or to bind explicitly, passing in a dummy context (which will be ignored anyway):</p>
<pre><code>class A(object):
    @staticmethod
    def open():
        return 123
    @staticmethod
    def proccess():
        return 456

    switch = {
        1: open.__get__(object),
        2: proccess.__get__(object),   
    }
</code></pre>
<p>or access the underlying function directly with the <code>__func__</code> attribute:</p>
<pre><code>class A(object):
    @staticmethod
    def open():
        return 123
    @staticmethod
    def proccess():
        return 456

    switch = {
        1: open.__func__,
        2: proccess.__func__,   
    }
</code></pre>
<p>However, if all you are trying to do is provide a <em>namespace</em> for a bunch of functions, then you should not use a class object in the first place. Put the functions in a <em>module</em>. That way you don't have to use <code>staticmethod</code> decorators in the first place and don't have to unwrap them again.</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/3798835/understanding-get-and-set-and-python-descriptors" title="understanding get and set and python descriptors">stackoverflow.com/questions/3798835/â€¦</a></span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/11058686/classmethod-object-is-not-callable">'classmethod' object is not callable</a></span>
<span class="comment-copy">@melpomene: oops, I'm not sure why I missed that.</span>
<span class="comment-copy">@melpomene: not entirely a dupe, you have different (more) options with <code>staticmethod</code> objects.</span>
<span class="comment-copy">@MartijnPieters Oh, I didn't quite realize that the question title doesn't match the error message in the body.</span>
<span class="comment-copy">That '.__func__' was exactly what I needed!</span>
<span class="comment-copy">The note at the end is the most important part, IMO. We can just create a list of all the functions we want from a module, and call them in a loop.</span>
