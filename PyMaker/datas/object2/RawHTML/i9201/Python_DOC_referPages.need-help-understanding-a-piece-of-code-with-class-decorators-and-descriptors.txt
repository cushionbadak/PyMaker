<div class="post-text" itemprop="text">
<p>I am <em>trying</em> to understand what Python's descriptors are and what they can be useful for. However, I am failing at it. I understand how they work, but here are my doubts. Consider the following code:</p>
<pre><code>class Celsius(object):
    def __init__(self, value=0.0):
        self.value = float(value)
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, value):
        self.value = float(value)


class Temperature(object):
    celsius = Celsius()
</code></pre>
<ol>
<li><p>Why do I need the descriptor class?</p></li>
<li><p>What is <code>instance</code> and <code>owner</code> here? (in <code>__get__</code>). What is the purpose of these parameters?</p></li>
<li><p>How would I call/use this example?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The descriptor is how Python's <code>property</code> type is implemented. A descriptor simply implements <code>__get__</code>, <code>__set__</code>, etc. and is then added to another class in its definition (as you did above with the Temperature class). For example:</p>
<pre><code>temp=Temperature()
temp.celsius #calls celsius.__get__
</code></pre>
<p>Accessing the property you assigned the descriptor to (<code>celsius</code> in the above example) calls the appropriate descriptor method.</p>
<p><code>instance</code> in <code>__get__</code> is the instance of the class (so above, <code>__get__</code> would receive <code>temp</code>, while <code>owner</code> is the class with the descriptor (so it would be <code>Temperature</code>).</p>
<p>You need to use a descriptor class to encapsulate the logic that powers it. That way, if the descriptor is used to cache some expensive operation (for example), it could store the value on itself and not its class.</p>
<p>An article about descriptors can be found <a href="http://martyalchin.com/2007/nov/23/python-descriptors-part-1-of-2/" rel="noreferrer">here</a>.</p>
<p>EDIT: As jchl pointed out in the comments, if you simply try <code>Temperature.celsius</code>, <code>instance</code> will be <code>None</code>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why do I need the descriptor class?</p>
</blockquote>
<p>It gives you extra control over how attributes work. If you're used to getters and setters in Java, for example, then it's Python's way of doing that. One advantage is that it looks to users just like an attribute (there's no change in syntax). So you can start with an ordinary attribute and then, when you need to do something fancy, switch to a descriptor.</p>
<p>An attribute is just a mutable value. A descriptor lets you execute arbitrary code when reading or setting (or deleting) a value. So you could imagine using it to map an attribute to a field in a database, for example – a kind of ORM.</p>
<p>Another use might be refusing to accept a new value by throwing an exception in <code>__set__</code> – effectively making the "attribute" read only.</p>
<blockquote>
<p>What is <code>instance</code> and <code>owner</code> here? (in <code>__get__</code>). What is the purpose of these parameters?</p>
</blockquote>
<p>This is pretty subtle (and the reason I am writing a new answer here - I found this question while wondering the same thing and didn't find the existing answer that great).</p>
<p>A descriptor is defined on a class, but is typically called from an instance. When it's called from an instance both <code>instance</code> and <code>owner</code> are set (and you can work out <code>owner</code> from <code>instance</code> so it seems kinda pointless). But when called from a class, only <code>owner</code> is set – which is why it's there.</p>
<p>This is only needed for <code>__get__</code> because it's the only one that can be called on a class. If you set the class value you set the descriptor itself. Similarly for deletion. Which is why the <code>owner</code> isn't needed there.</p>
<blockquote>
<p>How would I call/use this example?</p>
</blockquote>
<p>Well, here's a cool trick using similar classes:</p>
<pre><code>class Celsius:

    def __get__(self, instance, owner):
        return 5 * (instance.fahrenheit - 32) / 9

    def __set__(self, instance, value):
        instance.fahrenheit = 32 + 9 * value / 5


class Temperature:

    celsius = Celsius()

    def __init__(self, initial_f):
        self.fahrenheit = initial_f


t = Temperature(212)
print(t.celsius)
t.celsius = 0
print(t.fahrenheit)
</code></pre>
<p>(I'm using Python 3; for python 2 you need to make sure those divisions are <code>/ 5.0</code> and <code>/ 9.0</code>). That gives:</p>
<pre><code>100.0
32.0
</code></pre>
<p>Now there are other, arguably better ways to achieve the same effect in python (e.g. if celsius were a property, which is the same basic mechanism but places all the source inside the Temperature class), but that shows what can be done...</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>I am trying to understand what Python's descriptors are and what they can be useful for.</h2>
</blockquote>
<p>Descriptors are class attributes (like properties or methods) with any of the following special methods:</p>
<ul>
<li><code>__get__</code> (non-data descriptor method, for example on a method/function)</li>
<li><code>__set__</code> (data descriptor method, for example on a property instance)</li>
<li><code>__delete__</code> (data descriptor method)</li>
</ul>
<p>These descriptor objects can be used as attributes on other object class definitions. (That is, they live in the <code>__dict__</code> of the class object.)</p>
<p>Descriptor objects can be used to programmatically manage the results of a dotted lookup (e.g. <code>foo.descriptor</code>) in a normal expression, an assignment, and even a deletion. </p>
<p>Functions/methods, bound methods, <code>property</code>, <code>classmethod</code>, and <code>staticmethod</code> all use these special methods to control how they are accessed via the dotted lookup.</p>
<p>A <strong>data descriptor</strong>, like <code>property</code>, can allow for lazy evaluation of attributes based on a simpler state of the object, allowing instances to use less memory than if you precomputed each possible attribute. </p>
<p>Another data descriptor, a <code>member_descriptor</code>, created by <a href="https://stackoverflow.com/q/472000/541136"><code>__slots__</code></a>, allow memory savings by allowing the class to store data in a mutable tuple-like datastructure instead of the more flexible but space-consuming <code>__dict__</code>.</p>
<p>Non-data descriptors, usually instance, class, and static methods, get their implicit first arguments (usually named <code>cls</code> and <code>self</code>, respectively) from their non-data descriptor method, <code>__get__</code>.</p>
<p>Most users of Python need to learn only the simple usage, and have no need to learn or understand the implementation of descriptors further.</p>
<h2>In Depth: What Are Descriptors?</h2>
<p>A descriptor is an object with any of the following methods (<code>__get__</code>, <code>__set__</code>, or <code>__delete__</code>), intended to be used via dotted-lookup as if it were a typical attribute of an instance. For an owner-object, <code>obj_instance</code>, with a <code>descriptor</code> object:</p>
<ul>
<li><p><code>obj_instance.descriptor</code> invokes<br/>
<code>descriptor.__get__(self, obj_instance, owner_class)</code> returning a <code>value</code><br/>
This is how all methods and the <code>get</code> on a property work.</p></li>
<li><p><code>obj_instance.descriptor = value</code> invokes<br/>
<code>descriptor.__set__(self, obj_instance, value)</code> returning <code>None</code><br/>
This is how the <code>setter</code> on a property works.</p></li>
<li><p><code>del obj_instance.descriptor</code> invokes<br/>
<code>descriptor.__delete__(self, obj_instance)</code> returning <code>None</code><br/>
This is how the <code>deleter</code> on a property works.</p></li>
</ul>
<p><code>obj_instance</code> is the instance whose class contains the descriptor object's instance. <code>self</code> is the instance of the <em>descriptor</em> (probably just one for the class of the <code>obj_instance</code>)</p>
<p>To define this with code, an object is a descriptor if the set of its attributes intersects with any of the required attributes:</p>
<pre><code>def has_descriptor_attrs(obj):
    return set(['__get__', '__set__', '__delete__']).intersection(dir(obj))

def is_descriptor(obj):
    """obj can be instance of descriptor or the descriptor class"""
    return bool(has_descriptor_attrs(obj))
</code></pre>
<p>A <a href="https://docs.python.org/2/reference/datamodel.html#invoking-descriptors" rel="nofollow noreferrer"><strong>Data Descriptor</strong></a> has a <code>__set__</code> and/or <code>__delete__</code>.<br/>
A <strong>Non-Data-Descriptor</strong> has neither <code>__set__</code> nor <code>__delete__</code>.</p>
<pre><code>def has_data_descriptor_attrs(obj):
    return set(['__set__', '__delete__']) &amp; set(dir(obj))

def is_data_descriptor(obj):
    return bool(has_data_descriptor_attrs(obj))
</code></pre>
<h2>Builtin Descriptor Object Examples:</h2>
<ul>
<li><code>classmethod</code></li>
<li><code>staticmethod</code></li>
<li><code>property</code></li>
<li>functions in general</li>
</ul>
<h3>Non-Data Descriptors</h3>
<p>We can see that <code>classmethod</code> and <code>staticmethod</code> are Non-Data-Descriptors:</p>
<pre><code>&gt;&gt;&gt; is_descriptor(classmethod), is_data_descriptor(classmethod)
(True, False)
&gt;&gt;&gt; is_descriptor(staticmethod), is_data_descriptor(staticmethod)
(True, False)
</code></pre>
<p>Both only have the <code>__get__</code> method:</p>
<pre><code>&gt;&gt;&gt; has_descriptor_attrs(classmethod), has_descriptor_attrs(staticmethod)
(set(['__get__']), set(['__get__']))
</code></pre>
<p>Note that all functions are also Non-Data-Descriptors:</p>
<pre><code>&gt;&gt;&gt; def foo(): pass
... 
&gt;&gt;&gt; is_descriptor(foo), is_data_descriptor(foo)
(True, False)
</code></pre>
<h3>Data Descriptor, <code>property</code></h3>
<p>However, <code>property</code> is a Data-Descriptor:</p>
<pre><code>&gt;&gt;&gt; is_data_descriptor(property)
True
&gt;&gt;&gt; has_descriptor_attrs(property)
set(['__set__', '__get__', '__delete__'])
</code></pre>
<h2>Dotted Lookup Order</h2>
<p>These are important <a href="https://docs.python.org/2/reference/datamodel.html#invoking-descriptors" rel="nofollow noreferrer">distinctions</a>, as they affect the lookup order for a dotted lookup. </p>
<pre><code>obj_instance.attribute
</code></pre>
<ol>
<li>First the above looks to see if the attribute is a Data-Descriptor on the class of the instance, </li>
<li>If not, it looks to see if the attribute is in the <code>obj_instance</code>'s <code>__dict__</code>, then </li>
<li>it finally falls back to a Non-Data-Descriptor. </li>
</ol>
<p>The consequence of this lookup order is that Non-Data-Descriptors like functions/methods can be <a href="https://stackoverflow.com/a/28060251/541136">overridden by instances</a>.</p>
<h2>Recap and Next Steps</h2>
<p>We have learned that descriptors are objects with any of <code>__get__</code>, <code>__set__</code>, or <code>__delete__</code>. These descriptor objects can be used as attributes on other object class definitions. Now we will look at how they are used, using your code as an example.</p>
<hr/>
<h2>Analysis of Code from the Question</h2>
<p>Here's your code, followed by your questions and answers to each:</p>
<pre><code>class Celsius(object):
    def __init__(self, value=0.0):
        self.value = float(value)
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, value):
        self.value = float(value)

class Temperature(object):
    celsius = Celsius()
</code></pre>
<blockquote>
<ol>
<li>Why do I need the descriptor class?</li>
</ol>
</blockquote>
<p>Your descriptor ensures you always have a float for this class attribute of <code>Temperature</code>, and that you can't use <code>del</code> to delete the attribute:</p>
<pre><code>&gt;&gt;&gt; t1 = Temperature()
&gt;&gt;&gt; del t1.celsius
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: __delete__
</code></pre>
<p>Otherwise, your descriptors ignore the owner-class and instances of the owner, instead, storing state in the descriptor. You could just as easily share state across all instances with a simple class attribute (so long as you always set it as a float to the class and never delete it, or are comfortable with users of your code doing so):</p>
<pre><code>class Temperature(object):
    celsius = 0.0
</code></pre>
<p>This gets you exactly the same behavior as your example (see response to question 3 below), but uses a Pythons builtin (<code>property</code>), and would be considered more idiomatic:</p>
<pre><code>class Temperature(object):
    _celsius = 0.0
    @property
    def celsius(self):
        return type(self)._celsius
    @celsius.setter
    def celsius(self, value):
        type(self)._celsius = float(value)
</code></pre>
<blockquote>
<ol start="2">
<li>What is instance and owner here? (in <strong>get</strong>). What is the purpose of these parameters?</li>
</ol>
</blockquote>
<p><code>instance</code> is the instance of the owner that is calling the descriptor. The owner is the class in which the descriptor object is used to manage access to the data point. See the descriptions of the special methods that define descriptors next to the first paragraph of this answer for more descriptive variable names.</p>
<blockquote>
<ol start="3">
<li>How would I call/use this example?</li>
</ol>
</blockquote>
<p>Here's a demonstration:</p>
<pre><code>&gt;&gt;&gt; t1 = Temperature()
&gt;&gt;&gt; t1.celsius
0.0
&gt;&gt;&gt; t1.celsius = 1
&gt;&gt;&gt; 
&gt;&gt;&gt; t1.celsius
1.0
&gt;&gt;&gt; t2 = Temperature()
&gt;&gt;&gt; t2.celsius
1.0
</code></pre>
<p>You can't delete the attribute:</p>
<pre><code>&gt;&gt;&gt; del t2.celsius
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: __delete__
</code></pre>
<p>And you can't assign a variable that can't be converted to a float:</p>
<pre><code>&gt;&gt;&gt; t1.celsius = '0x02'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 7, in __set__
ValueError: invalid literal for float(): 0x02
</code></pre>
<p>Otherwise, what you have here is a global state for all instances, that is managed by assigning to any instance.  </p>
<p>The expected way that most experienced Python programmers would accomplish this outcome would be to use the <code>property</code> decorator, which makes use of the same descriptors under the hood, but brings the behavior into the implementation of the owner class (again, as defined above):</p>
<pre><code>class Temperature(object):
    _celsius = 0.0
    @property
    def celsius(self):
        return type(self)._celsius
    @celsius.setter
    def celsius(self, value):
        type(self)._celsius = float(value)
</code></pre>
<p>Which has the exact same expected behavior of the original piece of code:</p>
<pre><code>&gt;&gt;&gt; t1 = Temperature()
&gt;&gt;&gt; t2 = Temperature()
&gt;&gt;&gt; t1.celsius
0.0
&gt;&gt;&gt; t1.celsius = 1.0
&gt;&gt;&gt; t2.celsius
1.0
&gt;&gt;&gt; del t1.celsius
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: can't delete attribute
&gt;&gt;&gt; t1.celsius = '0x02'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 8, in celsius
ValueError: invalid literal for float(): 0x02
</code></pre>
<h2>Conclusion</h2>
<p>We've covered the attributes that define descriptors, the difference between data- and non-data-descriptors, builtin objects that use them, and specific questions about use.</p>
<p>So again, how would you use the question's example? I hope you wouldn't. I hope you would start with my first suggestion (a simple class attribute) and move on to the second suggestion (the property decorator) if you feel it is necessary. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why do I need the descriptor class?</p>
</blockquote>
<p>Inspired by <em>Fluent Python</em> by Buciano Ramalho</p>
<p>Imaging you have a class like this</p>
<pre><code>class LineItem:
     price = 10.9
     weight = 2.1
     def __init__(self, name, price, weight):
          self.name = name
          self.price = price
          self.weight = weight

item = LineItem("apple", 2.9, 2.1)
item.price = -0.9  # it's price is negative, you need to refund to your customer even you delivered the apple :(
item.weight = -0.8 # negative weight, it doesn't make sense
</code></pre>
<p>We should validate the weight and price in avoid to assign them a negative number, we can write less code if we use descriptor as a proxy as this</p>
<pre><code>class Quantity(object):
    __index = 0

    def __init__(self):
        self.__index = self.__class__.__index
        self._storage_name = "quantity#{}".format(self.__index)
        self.__class__.__index += 1

    def __set__(self, instance, value):
        if value &gt; 0:
            setattr(instance, self._storage_name, value)
        else:
           raise ValueError('value should &gt;0')

   def __get__(self, instance, owner):
        return getattr(instance, self._storage_name)
</code></pre>
<p>then define class LineItem like this:</p>
<pre><code>class LineItem(object):
     weight = Quantity()
     price = Quantity()

     def __init__(self, name, weight, price):
         self.name = name
         self.weight = weight
         self.price = price
</code></pre>
<p>and we can extend the Quantity class to do more common validating</p>
</div>
<div class="post-text" itemprop="text">
<p>Before going into the details of descriptors it may be important to know how attribute lookup in Python works. This assumes that the class has no metaclass and that it uses the default implementation of <code>__getattribute__</code> (both can be used to "customize" the behavior).</p>
<p>The best illustration of attribute lookup (in Python 3.x or for new-style classes in Python 2.x) in this case is from <a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/" rel="nofollow noreferrer">Understanding Python metaclasses (ionel's codelog)</a>. The image uses <code>:</code> as substitute for "non-customizable attribute lookup".</p>
<p>This represents the lookup of an attribute <code>foobar</code> on an <code>instance</code> of <code>Class</code>:</p>
<p><a href="https://i.stack.imgur.com/f5TY5.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/f5TY5.png"/></a></p>
<p>Two conditions are important here:</p>
<ul>
<li>If the class of <code>instance</code> has an entry for the attribute name and it has <code>__get__</code> and <code>__set__</code>.</li>
<li>If the <code>instance</code> has <em>no</em> entry for the attribute name but the class has one and it has <code>__get__</code>.</li>
</ul>
<p>That's where descriptors come into it:</p>
<ul>
<li><strong>Data descriptors</strong> which have both <code>__get__</code> and <code>__set__</code>.</li>
<li><strong>Non-data descriptors</strong> which only have <code>__get__</code>.</li>
</ul>
<p>In both cases the returned value goes through <code>__get__</code> called with the instance as first argument and the class as second argument.</p>
<p>The lookup is even more complicated for class attribute lookup (see for example <a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/#class-attribute-lookup" rel="nofollow noreferrer">Class attribute lookup (in the above mentioned blog)</a>).</p>
<p>Let's move to your specific questions:</p>
<blockquote>
<p>Why do I need the descriptor class?</p>
</blockquote>
<p>In most cases you don't need to write descriptor classes! However you're probably a very regular end user. For example functions. Functions are descriptors, that's how functions can be used as methods with <code>self</code> implicitly passed as first argument.</p>
<pre><code>def test_function(self):
    return self

class TestClass(object):
    def test_method(self):
        ...
</code></pre>
<p>If you look up <code>test_method</code> on an instance you'll get back a "bound method":</p>
<pre><code>&gt;&gt;&gt; instance = TestClass()
&gt;&gt;&gt; instance.test_method
&lt;bound method TestClass.test_method of &lt;__main__.TestClass object at ...&gt;&gt;
</code></pre>
<p>Similarly you could also bind a function by invoking its <code>__get__</code> method manually (not really recommended, just for illustrative purposes):</p>
<pre><code>&gt;&gt;&gt; test_function.__get__(instance, TestClass)
&lt;bound method test_function of &lt;__main__.TestClass object at ...&gt;&gt;
</code></pre>
<p>You can even call this "self-bound method":</p>
<pre><code>&gt;&gt;&gt; test_function.__get__(instance, TestClass)()
&lt;__main__.TestClass at ...&gt;
</code></pre>
<p>Note that I did not provide any arguments and the function did return the instance I had bound!</p>
<p>Functions are <strong>Non-data descriptors</strong>!</p>
<p>Some built-in examples of a data-descriptor would be <code>property</code>. Neglecting <code>getter</code>, <code>setter</code>, and <code>deleter</code> the <code>property</code> descriptor is (from <a href="https://docs.python.org/howto/descriptor.html#properties" rel="nofollow noreferrer">Descriptor HowTo Guide "Properties"</a>):</p>
<pre><code>class Property(object):
    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            doc = fget.__doc__
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError("unreadable attribute")
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError("can't set attribute")
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError("can't delete attribute")
        self.fdel(obj)
</code></pre>
<p>Since it's a data descriptor it's invoked whenever you look up the "name" of the <code>property</code> and it simply delegates to the functions decorated with <code>@property</code>, <code>@name.setter</code>, and <code>@name.deleter</code> (if present).</p>
<p>There are several other descriptors in the standard library, for example <code>staticmethod</code>, <code>classmethod</code>.</p>
<p>The point of descriptors is easy (although you rarely need them): Abstract common code for attribute access. <code>property</code> is an abstraction for instance variable access, <code>function</code> provides an abstraction for methods, <code>staticmethod</code> provides an abstraction for methods that don't need instance access and <code>classmethod</code> provides an abstraction for methods that need class access rather than instance access (this is a bit simplified).</p>
<p>Another example would be a <a href="https://stackoverflow.com/a/5191224/5393381">class property</a>.</p>
<p>One fun example (using <code>__set_name__</code> from Python 3.6) could also be a property that only allows a specific type:</p>
<pre><code>class TypedProperty(object):
    __slots__ = ('_name', '_type')
    def __init__(self, typ):
        self._type = typ

    def __get__(self, instance, klass=None):
        if instance is None:
            return self
        return instance.__dict__[self._name]

    def __set__(self, instance, value):
        if not isinstance(value, self._type):
            raise TypeError(f"Expected class {self._type}, got {type(value)}")
        instance.__dict__[self._name] = value

    def __delete__(self, instance):
        del instance.__dict__[self._name]

    def __set_name__(self, klass, name):
        self._name = name
</code></pre>
<p>Then you can use the descriptor in a class:</p>
<pre><code>class Test(object):
    int_prop = TypedProperty(int)
</code></pre>
<p>And playing a bit with it:</p>
<pre><code>&gt;&gt;&gt; t = Test()
&gt;&gt;&gt; t.int_prop = 10
&gt;&gt;&gt; t.int_prop
10

&gt;&gt;&gt; t.int_prop = 20.0
TypeError: Expected class &lt;class 'int'&gt;, got &lt;class 'float'&gt;
</code></pre>
<p>Or a "lazy property":</p>
<pre><code>class LazyProperty(object):
    __slots__ = ('_fget', '_name')
    def __init__(self, fget):
        self._fget = fget

    def __get__(self, instance, klass=None):
        if instance is None:
            return self
        try:
            return instance.__dict__[self._name]
        except KeyError:
            value = self._fget(instance)
            instance.__dict__[self._name] = value
            return value

    def __set_name__(self, klass, name):
        self._name = name

class Test(object):
    @LazyProperty
    def lazy(self):
        print('calculating')
        return 10

&gt;&gt;&gt; t = Test()
&gt;&gt;&gt; t.lazy
calculating
10
&gt;&gt;&gt; t.lazy
10
</code></pre>
<p>These are cases where moving the logic into a common descriptor might make sense, however one could also solve them (but maybe with repeating some code) with other means.</p>
<blockquote>
<p>What is <code>instance</code> and <code>owner</code> here? (in <code>__get__</code>). What is the purpose of these parameters?</p>
</blockquote>
<p>It depends on how you look up the attribute. If you look up the attribute on an instance then:</p>
<ul>
<li>the second argument is the instance on which you look up the attribute</li>
<li>the third argument is the class of the instance</li>
</ul>
<p>In case you look up the attribute on the class (assuming the descriptor is defined on the class):</p>
<ul>
<li>the second argument is <code>None</code></li>
<li>the third argument is the class where you look up the attribute</li>
</ul>
<p>So basically the third argument is necessary if you want to customize the behavior when you do class-level look-up (because the <code>instance</code> is <code>None</code>).</p>
<blockquote>
<p>How would I call/use this example?</p>
</blockquote>
<p>Your example is basically a property that only allows values that can be converted to <code>float</code> and that is shared between all instances of the class (and on the class - although one can only use "read" access on the class otherwise you would replace the descriptor instance):</p>
<pre><code>&gt;&gt;&gt; t1 = Temperature()
&gt;&gt;&gt; t2 = Temperature()

&gt;&gt;&gt; t1.celsius = 20   # setting it on one instance
&gt;&gt;&gt; t2.celsius        # looking it up on another instance
20.0

&gt;&gt;&gt; Temperature.celsius  # looking it up on the class
20.0
</code></pre>
<p>That's why descriptors generally use the second argument (<code>instance</code>) to store the value to avoid sharing it. However in some cases sharing a value between instances might be desired (although I cannot think of a scenario at this moment). However it makes practically no sense for a celsius property on a temperature class... except maybe as purely academic exercise.</p>
</div>
<div class="post-text" itemprop="text">
<p>I tried (with minor changes as suggested) the code from Andrew Cooke's answer. (I am running python 2.7).</p>
<p>The code:</p>
<pre><code>#!/usr/bin/env python
class Celsius:
    def __get__(self, instance, owner): return 9 * (instance.fahrenheit + 32) / 5.0
    def __set__(self, instance, value): instance.fahrenheit = 32 + 5 * value / 9.0

class Temperature:
    def __init__(self, initial_f): self.fahrenheit = initial_f
    celsius = Celsius()

if __name__ == "__main__":

    t = Temperature(212)
    print(t.celsius)
    t.celsius = 0
    print(t.fahrenheit)
</code></pre>
<p>The result:</p>
<pre><code>C:\Users\gkuhn\Desktop&gt;python test2.py
&lt;__main__.Celsius instance at 0x02E95A80&gt;
212
</code></pre>
<p>With Python prior to 3, make sure you subclass from object which will make the descriptor work correctly as the <strong>get</strong> magic does not work for old style classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>You'd see <a href="https://docs.python.org/3/howto/descriptor.html#properties" rel="nofollow noreferrer">https://docs.python.org/3/howto/descriptor.html#properties</a></p>
<pre class="lang-py prettyprint-override"><code>class Property(object):
    "Emulate PyProperty_Type() in Objects/descrobject.c"

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            doc = fget.__doc__
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError("unreadable attribute")
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError("can't set attribute")
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError("can't delete attribute")
        self.fdel(obj)

    def getter(self, fget):
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__)
</code></pre>
</div>
<span class="comment-copy">What's the difference between <code>self</code> and <code>instance</code>?</span>
<span class="comment-copy">The conversions are wrong: they should be C=5(F−32)/9, F=32+9C/5.</span>
<span class="comment-copy">Make sure that you have one object of Temperature. Doing following messes up the stuff.     t1 = Temperature(190)     print t1.celsius     t1.celsius = 100     print t1.fahrenheit Now when you check t.celcius and t.fahrenheit, they get modified too. t.celcius is 115 and t.fahrenheit is 32. which is clearly wrong. @Eric</span>
<span class="comment-copy">@IshanBhatt: I think that's because of the error pointed out by musiphil above. Also, not this is not my answer</span>
<span class="comment-copy">Nice, I learned the most from this answer (certainly learned from others as well). A question about this statement "The expected way that most experienced Python programmers would accomplish this outcome ...". The Temeperature class you define before and after the statement are identical. Did I miss what you're getting at here?</span>
<span class="comment-copy">@YoloVoe no, that's right, I added some parenthetical verbiage to emphasize that it's a repeat of the above.</span>
<span class="comment-copy">Interesting use case, as it shows how to use the descriptor to interact with multiple instances of users. I initially didn't understand the important point: An attribute with a descriptor <i>must</i> be created in the class namespace (e.g. <code>weight = Quantity()</code>, but values must be set in the instance namespace only using <code>self</code> (e.g. <code>self.weight = 4</code>), else the attribute would be rebound to the new value and the descriptor would be discarded. Nice!</span>
<span class="comment-copy">Descriptors only work with new style classes. For python 2.x this means deriving your class from "object", which is default in Python 3.</span>
