<div class="post-text" itemprop="text">
<p>I read through the main answers on <a href="https://stackoverflow.com/questions/472000/usage-of-slots">usage of slots</a> and it has given me an idea of how and where to use <code>__slots__</code> . </p>
<p>Now, I am porting a code from Python 2 to Python 3 which is similar to as following:</p>
<pre><code>class B(object):
    __slots__ = ('_fields')
    _fields = set()
</code></pre>
<p>But this is giving error Python 3 while working fine on Python 2:</p>
<p><strong><code>ValueError: '_fields' in __slots__ conflicts with class variable</code>.</strong> </p>
<p>I change the code to </p>
<pre><code>class B(object):
    __slots__ = ('_fields')
    def __init__(self):
        _fields = set()
</code></pre>
<p>and it works fine. My query is, is it even the correct change ?</p>
<p>As i got from original code, I guess it is saying that don't use <code>__dict__</code> for saving memory or faster access or whatever reason but at the same time is also trying to specify the type of attribute <code>_field</code> as set(). Can the change above be the right way to say it or it can have some side effects.</p>
<hr/>
<p><strong>Further Experiments</strong>: 
I experimented further with following variants (on Python 3): </p>
<pre><code>import pdb

class A(object):
    a = set()

'''
class B(object):
    __slots__ = ('a')
    a = set()
'''

class C(object):
    __slots__ = ('a')
    def __init__(self):
        a = set()

class D(object):
    def __init__(self):
        __slots__ = ('a')
        a = set()

if __name__ == '__main__':
    #pdb.set_trace()
    x = A(); print(dir(x))
    #y = B()
    z = C(); print(dir(z))
    z1 = D(); print(dir(z1))
</code></pre>
<p>and it gave following output. </p>
<pre><code>['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'a']


['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', 'a']


['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
</code></pre>
<p>We can see that only C object shows correct footprint i.e. no <code>__dict__</code> and only <code>__slots__</code> . Isn't it what ideally we would want ? Any explanation on <code>__weakref__</code> would also be helpful.</p>
<p>Also on Python 2, both B and C object show same footprint. Based on that should C be the right way to put it as it is compiling on both Python 2 and 3 as well.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>But this is giving error Python 3 while working fine on Python 2:</p>
<p><strong><code>ValueError: '_fields' in __slots__ conflicts with class variable</code>.</strong> </p>
</blockquote>
<p>While you didn't get an error in Python2 at class creation/compile time like in Py3k, if you try to actually set the value of <code>_fields</code>, you get <code>AttributeError: 'C' object attribute '_fields' is read-only</code>:</p>
<pre><code>&gt;&gt;&gt; class C(object):
...   __slots__ = ('_fields')
...   _fields = set()
...
&gt;&gt;&gt;
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c._fields
set([])
&gt;&gt;&gt; c._fields = 'foo'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'C' object attribute '_fields' is read-only
&gt;&gt;&gt;
</code></pre>
<p>Also, see the fourth <a href="https://docs.python.org/3/reference/datamodel.html#notes-on-using-slots" rel="nofollow noreferrer">note in the slots documentation</a>:</p>
<blockquote>
<p><em><code>__slots__</code></em> are implemented at the class level by creating descriptors (Implementing Descriptors) for each variable name. As a result, class attributes cannot be used to set default values for instance variables defined by <em><code>__slots__</code></em>; otherwise, the class attribute would overwrite the descriptor assignment.</p>
</blockquote>
<hr/>
<p>Wrt your modification:</p>
<blockquote>
<p>I change the code to </p>
<pre><code>class B(object):
    __slots__ = ('_fields')
    def __init__(self):
        _fields = set()
</code></pre>
</blockquote>
<p>The modified class B has a <code>_fields</code> inside <code>__init__()</code>, not <code>self._fields</code> so it's just a local variable in init, and not accessible anywhere else in the class. Change that to:</p>
<pre><code> class B(object):
    __slots__ = ('_fields')
    def __init__(self):
        self._fields = set()
</code></pre>
<p>To correctly initialise <code>_fields</code>, do this:</p>
<pre><code> class B(object):
     __slots__ = ('_fields')
     def __init__(self, _fields=None):
         if not _fields:
             self._fields = set()
</code></pre>
<hr/>
<p>Wrt further experimentation:</p>
<p>In class D, <code>__slots__</code> is a variable only inside <code>__init()__</code>. It's not the (special) class variable <code>D.__slots__</code>; or even the instance variable <code>self.__slots__</code>. So it has <code>__dict__</code>.</p>
<p>Class A has none, so also has <code>__dict__</code>.</p>
<p>Class C has <code>__slots__</code> correctly.</p>
</div>
<span class="comment-copy">Thanks. But did we want to say the following in <code>__init__</code> instead <code>self._fields = _fields if not None else set()</code></span>
<span class="comment-copy"><code>if not _fields:</code> checks <code>_fields</code> in <a href="http://stackoverflow.com/a/1452500/1431750">boolean context</a>. So if <code>_fields</code> is <code>None</code> then that expression evaluates to <code>True</code> and the line <code>self._fields = set()</code> gets executed. It could also be done as <code>if _fields is None: self._fields = set()</code>. Btw, in the example in your comment, <code>not None</code> is always True. You could put it as <code>self._fields = _fields if _fields is not None else set()</code> or the more Pythonic <code>self._fields = _fields if _fields else set()</code>. <i>Caveat:</i> an empty <code>set()</code> evaluates to False so use an appropriate check...</span>
<span class="comment-copy"><i>Caveat:</i> an empty <code>set()</code> evaluates to False so use an another check if <code>set()</code> is okay but <code>None</code> is not. Also, don't intialise function or methods with <a href="http://stackoverflow.com/q/1132941/1431750">mutable types as default argument values</a>; like <code>set</code>, <code>dict</code>, <code>list</code>, etc. <a href="http://docs.python-guide.org/en/latest/writing/gotchas/#mutable-default-arguments" rel="nofollow noreferrer">Another example here</a>.</span>
