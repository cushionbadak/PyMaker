<div class="post-text" itemprop="text">
<blockquote>
<pre><code>&gt;&gt;from itertools import groupby
&gt;&gt;keyfunc = lambda x : x &gt; 500
&gt;&gt;obj = dict(groupby(range(1000), keyfunc))
&gt;&gt;list(obj[True])
[999]
&gt;&gt;list(obj[False])
[]
</code></pre>
</blockquote>
<p><em>range(1000)</em> is obviously sorted by default for the condition (x &gt; 500).
<br/>I was expecting the numbers from 0 to 999 to be grouped in a <em>dict</em> by the condition (x &gt; 500). But the resulting dictionary had only 999.
<br/>where are the other numbers?.
Can any one explain what is happening here?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>The returned group is itself an iterator that shares the underlying iterable with <code>groupby()</code>. Because the source is shared, when the <code>groupby()</code> object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list[.]</p>
</blockquote>
<p>And you are storing iterators in <code>obj</code> and materializing them later.</p>
<pre><code>In [21]: dict((k, list(g)) for k, g in groupby(range(10), lambda x : x &gt; 5))
Out[21]: {False: [0, 1, 2, 3, 4, 5], True: [6, 7, 8, 9]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>groupby</code> iterator returns tuples of the outcome of the grouping function and a new iterator that is tied to the same "outer" iterator the <code>groupby</code> operator is working on. When you apply <code>dict()</code> to the iterator returned by <code>groupby</code> without consuming this "inner" iterator, <code>groupby</code> will have to advance the "outer" iterator for you. You have to realize that the <code>groupby</code> function does not act on a sequence, it turns any such sequence to an iterator for you.</p>
<p>Perhaps this is better explained with some metaphors and handwaving. Please follow along as we form a bucket line.</p>
<p>Imagine iterators as a person drawing water in buckets from a well. He has an unlimited number of buckets to use, but the well may be finite. Every time you ask this person for a bucket of water, he'll draw a new bucket from the well of water and pass it to you.</p>
<p>In the <code>groupby</code> case, you insert another person into your budding bucket chain. This person doesn't immediately pass buckets at all. He passes you the outcome of instructions you gave it plus <em>another</em> person every time you ask for a bucket, whom will then pass you buckets via the <code>groupby</code> person to whomever is asking, as long as they match the same outcome to the instructions. The <code>groupby</code> bucket passer will stop passing these buckets if the outcome of the instructions changes. So <code>well</code> gives buckets to <code>groupby</code>, who passes this to a per-group person, <code>group A</code>, <code>group B</code>, and so on.</p>
<p>In your example, the water is numbered, but there can only be 1000 buckets drawn from the well. Here is what happens when you then pass the <code>groupby</code> person to the <code>dict()</code> call:</p>
<ol>
<li><p>Your <code>dict()</code> call asks <code>groupby</code> for a bucket. Now, <code>groupby</code> asks for one bucket from the person at the well, remembers the outcome of the instructions given, holding on to the bucket. To <code>dict()</code> he'll pass the outcome of the instructions (<code>False</code>) plus a new person, <code>group A</code>. The outcome is stored as the key, and the <code>group A</code> person, who wants to pull buckets is stored as the value. This person is <em>not</em> yet asking for buckets however, because <em>no-one is asking it to</em>.</p></li>
<li><p>Your <code>dict()</code> call asks <code>groupby</code> for another bucket. <code>groupby</code> has these instructions, and goes looking for the next bucket where the outcome changes. It was still holding on to the first bucket, no-one asked for it, so it <strong>throws away</strong> this bucket. Instead, it asks for the next bucket from the well and uses his instructions. The outcome is the same as before, so it throws this new bucket away too! More water goes over the floor, and so go the next 499 buckets. Only when the bucket with number 501 is passed does the outcome change, so now <code>groupby</code> finds another person to give instructions to (person <code>group B</code>), together with the new outcome, <code>True</code>, passing these two on to <code>dict()</code>.</p></li>
<li><p>Your <code>dict()</code> call stores <code>True</code> as a key, and person <code>group B</code> as the value. <code>group B</code> does nothing, no-one is asking it for water.</p></li>
<li><p>Your <code>dict()</code> asks for another bucket. <code>groupby</code> spills more water, until it holds bucket with the number 999, and the person at the well shrugs his shoulders and states that now the well is empty. <code>groupby</code> tells <code>dict()</code> the well is empty, no more buckets are coming, could he please stop asking. It still holds the bucket with number 999, because it never has to make space for the next bucket from the well.</p></li>
<li><p>Now you come along, asking <code>dict()</code> for the thing associated with the key <code>True</code>, which is person <code>group B</code>. You pass <code>group B</code> to <code>list()</code>, which will therefore ask <code>group B</code> for <em>all</em> the buckets <code>group B</code> can get. <code>group B</code> goes back to <code>groupby</code>, who holds one bucket only, the bucket with number 999, and the outcome of the instructions for this bucket match what <code>group B</code> is looking for. So this one bucket <code>group B</code> gives to <code>list()</code>, then shrugs his shoulders because there are no more buckets, because <code>groupby</code> told him so.</p></li>
<li><p>You then ask <code>dict()</code> for the person associated with the key <code>False</code>, which is person <code>group A</code>. By now, <code>groupby</code> has nothing to give any more, the well is dry and he's standing in a puddle of 999 buckets of water with numbers floating around. Your second <code>list()</code> gets nothing.</p></li>
</ol>
<p>The moral of this story? Immediately ask for all buckets of water when talking to <code>groupby</code>, because he'll spill them all if you do not! Iterators are like the brooms in fantasia, diligently moving water without understanding, and you better hope you run out of water if you do not know how to control them.</p>
<p>Here is code that would do what you expect (with a little bit less water to prevent flooding):</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; keyfunc = lambda x : x &gt; 5
&gt;&gt;&gt; obj = dict((k, list(v)) for k, v in groupby(range(10), keyfunc))
&gt;&gt;&gt; obj(True)
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; obj(False)
[6, 7, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The thing you are missing is, that the groupby-function iterates over your given <code>range(1000)</code>, thus returning 1000 values. You are only saving the last one, in your case <code>999</code>. What you have to do is, is to iterate over the return values and save them to your dictionary:</p>
<pre><code>dictionary = {}
keyfunc = lambda x : x &gt; 500
for k, g in groupby(range(1000), keyfunc):
    dictionary[k] = list(g)
</code></pre>
<p>So the you would get the expected output:</p>
<pre><code>{False: [0, 1, 2, ...], True: [501, 502, 503, ...]}
</code></pre>
<p>For more information, see the Python docs about <a href="http://docs.python.org/library/itertools.html#itertools.groupby" rel="nofollow">itertools groupby</a>.</p>
</div>
<span class="comment-copy">Did you mean "The Sorcerer's Apprentice"? Or maybe Fantasia has brooms carrying water too?</span>
<span class="comment-copy">@ReblochonMasque The Sorcererâ€™s Apprentice <a href="https://en.wikipedia.org/wiki/Fantasia_%281940_film%29#Program" rel="nofollow noreferrer">is one part from Fantasia</a>.</span>
<span class="comment-copy">Ok, thank you @MartijnPieters, I did not know that.</span>
