<div class="post-text" itemprop="text">
<p>I have a startnumber and an endnumber.<br/>
From these numbers I need to pick a sequence of numbers.<br/>
The sequences is not always the same.</p>
<p>Example:</p>
<pre><code>startnumber = 1
endnumber = 32
</code></pre>
<p>I need to create a list of numbers with a certain sequence<br/>
p.e.<br/>
3 numbers yes, 2 numbers no, 3 numbers yes, 2 numbers no.. etc</p>
<p>Expected output:</p>
<pre><code>[[1-3],[6-8],[11-13],[16-18],[21-23],[26-28],[31-32]]
</code></pre>
<p>(at the end there are only 2 numbers remaining (31 and 32))</p>
<p>Is there a simple way in python to select sequences of line from a range of numbers?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>numbers = range(1,33)
take = 3
skip = 2
seq = [list(numbers[idx:idx+take]) for idx in range(0, len(numbers),take+skip)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Extrapolating this out:</p>
<pre><code>def get_data(data, filterfunc=None):
    if filterfunc is None:
        filterfunc = lambda: True  # take every line

    result = []
    sub_ = []
    for line in data:
        if filterfunc():
            sub_.append(line)
        else:
            if sub_:
                result.append(sub_)
                sub_ = []

    return result

# Example filterfunc
def example_filter(take=1, leave=1):
    """example_filter is a less-fancy version of itertools.cycle"""

    while True:
        for _ in range(take):
            yield True
        for _ in range(leave):
            yield False

# Your example
final = get_data(range(1, 33), example_filter(take=3, leave=2))
</code></pre>
<p>As alluded to in the docstring of example_filter, the <code>filterfunc</code> for get_data is really just expecting a <code>True</code> or <code>False</code> based on a call. You could change this easily to be of the signature:</p>
<pre><code>def filterfunc(some_data: object) -&gt; bool:
</code></pre>
<p>So that you can determine whether to take or leave based on the value (or even the index), but it currently takes no arguments and just functions as a less magic <code>itertools.cycle</code> (since it should return its value on call, not on iteration)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import islice
def grouper(iterable, n, min_chunk=1):
    it = iter(iterable)
    while True:
       chunk = list(islice(it, n))
       if len(chunk) &lt; min_chunk:
           return
       yield chunk

def pick_skip_seq(seq, pick, skip, skip_first=False):
    if skip_first:
        ret = [ x[skip:] for x in grouper(seq, pick+skip, skip+1) ]
    else:
        ret = [ x[:pick] for x in grouper(seq, pick+skip) ]
    return ret
</code></pre>
<p><code>pick_skip_seq(range(1,33), 3, 2)</code> gives required list.</p>
<p>In <code>pick_skip_seq(seq, pick, skip, skip_first=False)</code>,
<code>seq</code> is sequence to pick/skip from,
<code>pick</code>/<code>skip</code> are no. of elements to pick/skip,
<code>skip_first</code> is to be set <code>True</code> if
such behavior is desired.</p>
<p><code>grouper</code> returns chunks of n elements, it
ignores last group if it has less
than min_chunk elements.
It is derived from stuff given in
<a href="https://stackoverflow.com/a/8991553/1921546">https://stackoverflow.com/a/8991553/1921546</a>.</p>
<p>Demo:</p>
<pre><code># pick 3 skip 2 
for i in range(30,35):
    print(pick_skip_seq(range(1,i), 3, 2))

# skip 3 pick 2 
for i in range(30,35):
    print(pick_skip_seq(range(1,i), 3, 2, True))
</code></pre>
<p><strong>An alternative implementation of <code>pick_skip_seq</code>:</strong></p>
<pre><code>from itertools import chain,cycle,repeat,compress
def pick_skip_seq(seq, pick, skip, skip_first=False):
    if skip_first:
        c = cycle(chain(repeat(0, skip), repeat(1, pick)))
    else:
        c = cycle(chain(repeat(1, pick), repeat(0, skip)))
    return list(grouper(compress(seq, c), pick))
</code></pre>
<p>All things used are documented here: <a href="https://docs.python.org/3/library/itertools.html#itertools.compress" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#itertools.compress</a></p>
</div>
<span class="comment-copy">I assume by <code>[1-3]</code> you mean <code>[1,2,3]</code></span>
<span class="comment-copy">I don't understand how you've defined the sequence. By 'not always the same' do you mean random? Must the number of sequences drawn each time be the same?</span>
<span class="comment-copy">Who decides the sequence of "Take 3, drop 2, take 3, drop 2, ..."?</span>
<span class="comment-copy">@PatrickHaugh, I mean the numbers from 1 to 3 <code>[1-3]</code></span>
<span class="comment-copy">@yogabonito <code>i%5 not in (0, 4)</code></span>
<span class="comment-copy">that's clever. Just edit it a bit to make the <code>take 3, drop 2</code> pattern visible and customisable and hide the trick converting the 33 to 35 â˜º</span>
<span class="comment-copy">Also this seems to be Python 2. In Python 3 (the one tagged) one would cast the <code>range</code> to <code>list</code>.</span>
<span class="comment-copy">Thanks, this is a great solution. However it gives an output with ranges and tuples <code>[range(1, 4), range(6, 9), range(11, 14), range(16, 19), range(21, 24), range(26, 29), range(31, 33)]</code> and the 2nd value in the range is not the one I expected.</span>
<span class="comment-copy">Sorry. I just saw the <code>python-3.x</code> tag that @Ev.Kounis pointed out above. I've edited the answer to cast the range back to a list.</span>
<span class="comment-copy">@Reman for skip first <code>seq =[list(numbers[idx+skip:idx+take+skip]) for idx in range(0, len(numbers)-skip,take+skip)]</code></span>
