<div class="post-text" itemprop="text">
<p>I am just a beginner to python.And I here just wrote a simple program just to self evaluate myself and try to answer the questions asked in a random order.But the bug here is that the randint function sometimes acquires the same number which was already acquired that I get the same question repeated.I tried my best to fix it but I could n't . Hope I get some help here.`import random</p>
<pre><code>global some
global i
i=0

some=[]
names=['electric charge','permitivity of the medium','permitiovity of free space','relative permitivity of the medium','intensity  of the electric field','electric potential at a point','electric potential energy','dipole moment','torque acting on the dipole','electric flux','linear charge density of the conductor','surface charge density of the conductor','capacitance of a parallel plate capacitor','practical unit of capacitance']
answer=['C','C2N-1m-2','C2N-1m-2','no unit','NC-1 or Vm-1','V','J','Cm','Nm','Nm2C-1','Cm-1','Cm-2','F','uF or pF']
def loop(i):
    for i in range(i,len(names)):
        global qno
        qno=random.randint(0,len(names))
        if i&gt;0:
            for k in range(0,len(some)):
                if str(qno)==some[len(some)-1]:
                    loop(i-1)
        print(names[qno])
        print('Type your answer')
        tell=input()
        if tell==answer[qno]:
            print('Right answer.Move on')
        else:
            print('Wrong answer,.The answer is '+answer[qno])
        for j in range(i+1):
            some.append(str(qno))
i=i+1

loop(i)
`
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>before your function, add an array of booleans that describes which questions have already been answered:</p>
<pre><code>already_asked = [False] * len(names)
</code></pre>
<p>then, where you assign qno to a value, keep generating random numbers until you've hit one you haven't asked before, and mark the newly asked question as asked:</p>
<pre><code>qno = random.randint(0, len(names))
while already_asked[qno]:
    qno = random.randint(0, len(names))
already_asked[qno] = True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/random.html#random.shuffle" rel="nofollow noreferrer">random.shuffle</a> function does exactly what you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you use randomint(0, 14), you're bound to get lots of repeats! 
For example: </p>
<pre><code>import random

names=['electric charge','permitivity of the medium','permitiovity of free space','relative permitivity of the medium','intensity  of the electric field','electric potential at a point','electric potential energy','dipole moment','torque acting on the dipole','electric flux','linear charge density of the conductor','surface charge density of the conductor','capacitance of a parallel plate capacitor','practical unit of capacitance']


for i in range(10):
...     print( random.randint(0,len(names)))
</code></pre>
<p>Here's my output, on my first run: </p>
<pre><code>12
6
6
6
7
14
7
11
4
10
</code></pre>
<p>Notice how I got the number <code>6</code> three times! Obviously repeats will happen less as the range increase, but you'll always run a chance of repeating numbers especially since this is only a pseudo random generated number. </p>
<p>Perhaps you're looking for something like shuffle? For example: </p>
<pre><code>&gt;&gt;&gt; new_order = ([ i for i in range(len(names)) ])
&gt;&gt;&gt; random.shuffle(new_order)
&gt;&gt;&gt; print(new_order)
[9, 10, 7, 8, 4, 13, 0, 2, 3, 6, 12, 5, 1, 11]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>maybe a little advanced, its nice to have options that don't require explicit indexing</p>
<pre><code>import random

names=['electric charge','permitivity of the medium','permitiovity of free space','relative permitivity of the medium','intensity  of the electric field','electric potential at a point','electric potential energy','dipole moment','torque acting on the dipole','electric flux','linear charge density of the conductor','surface charge density of the conductor','capacitance of a parallel plate capacitor','practical unit of capacitance']
answer=['C','C2N-1m-2','C2N-1m-2','no unit','NC-1 or Vm-1','V','J','Cm','Nm','Nm2C-1','Cm-1','Cm-2','F','uF or pF']

# zip, list comprehensions are useful things to learn
# this helps keep things together without explicit index calcs
name_answer_pairs = [(n, a) for n, a in zip(names, answer)]

atest = name_answer_pairs[:] # need a copy, atest gets modified below
random.shuffle(atest)

yes = False

while atest:     # loops until atest is empty, add your UI code to loop
    quest, ansr = atest.pop()   # gets the pair, removes the tuple from the end
    print('Q: ',quest, '\n', 'Ans: ', ansr) # just to show an example

    # do your user Q/A thing here

    # check if atest is empty, to repeat loop with new atest, refresh atest:
    if not atest:
    # ask user to continue?, set 'yes' True or False
        if yes:    
            atest = name_answer_pairs[:]    
            random.shuffle(atest)           # new atest, different order
            continue
        else:
            break

Q:  practical unit of capacitance 
 Ans:  uF or pF
Q:  electric charge 
 Ans:  C
Q:  capacitance of a parallel plate capacitor 
 Ans:  F
Q:  dipole moment 
 Ans:  Cm
Q:  intensity  of the electric field 
 Ans:  NC-1 or Vm-1
Q:  electric potential energy 
 Ans:  J
Q:  permitiovity of free space 
 Ans:  C2N-1m-2
Q:  electric flux 
 Ans:  Nm2C-1
Q:  permitivity of the medium 
 Ans:  C2N-1m-2
Q:  torque acting on the dipole 
 Ans:  Nm
Q:  relative permitivity of the medium 
 Ans:  no unit
Q:  surface charge density of the conductor 
 Ans:  Cm-2
Q:  electric potential at a point 
 Ans:  V
Q:  linear charge density of the conductor 
 Ans:  Cm-1
</code></pre>
<p>could be <code>while True:</code>now that I added the <code>if not atest</code> at end of loop</p>
</div>
<span class="comment-copy">use <code>random.shuffle(list)</code> and you get list with random order - and then you can get elements with <code>for</code> loop.</span>
<span class="comment-copy">This is the correct answer. Deepak, you are prohibiting the <code>randint()</code> function to give you a value that it has given you before. In order to do that however, you need to keep track of values returned so as to not return them again.</span>
<span class="comment-copy">Thanks a lot @AdamVenis.Though I have to spend some time to understand the logic behind,this is what I've been expecting.You answered my first ever question....! &lt;3 &lt;3</span>
