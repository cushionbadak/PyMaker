<div class="post-text" itemprop="text">
<p>I'm writing a custom type <code>Foo</code> and I'd like to achieve the following: when writing</p>
<pre><code>foo = Foo(bar)
</code></pre>
<p>then if <code>bar</code> is already an instance of <code>Foo</code>, then <code>Foo(foo)</code> returns that object unmodified, so <code>foo</code> and <code>bar</code> refer to the same object. Otherwise a new object of type <code>Foo</code> should be created, using information from <code>bar</code> in whatever way <code>Foo.__init__</code> deems appropriate.</p>
<p>How can I do this?</p>
<p>I would assume that <code>Foo.__new__</code> is the key to this. It should be fairly easy to have <code>Foo.__new__</code> return the existing object if the <code>instanceof</code> check succeeds, and to call <code>super().__new__</code> otherwise. But <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">the documentation for <code>__new__</code></a> writes this:</p>
<blockquote>
<p>If <code>__new__()</code> returns an instance of <em>cls</em>, then the new instanceâ€™s <code>__init__()</code> method will be invoked like <code>__init__(self[, ...])</code>, where <em>self</em> is the new instance and the remaining arguments are the same as were passed to <code>__new__()</code>.</p>
</blockquote>
<p>In this case I would be returning an instance of the requested class, albeit not a new one. Can I somehow prevent the call to <code>__init__</code>? Or do I have to add a check inside <code>__init__</code> to detect whether it is being invoked for a newly created instance or for an already existing one? The latter sounds like code duplication which should be avoidable.</p>
</div>
<div class="post-text" itemprop="text">
<p>IMHO, you should directly use <code>__new__</code> and <code>__init__</code>. The test in init to see whether you should init a new object or already have an existing one is so simple that there is no code duplication and the added complexity is IMHO acceptable</p>
<pre><code>class Foo:
    def __new__(cls, obj):
        if isinstance(obj, cls):
            print("New: same object")
            return obj
        else:
            print("New: create object")
            return super(Foo, cls).__new__(cls)
    def __init__(self, obj):
        if self is obj:
            print("init: same object")
        else:
            print("init: brand new object from ", obj)
            # do the actual initialization
</code></pre>
<p>It gives as expected:</p>
<pre><code>&gt;&gt;&gt; foo = Foo("x")
New: create object
init: brand new object from  x
&gt;&gt;&gt; bar = Foo(foo)
New: same object
init: same object
&gt;&gt;&gt; bar is foo
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to achieve this is by moving the required code into a metaclass like this:</p>
<pre><code>class IdempotentCast(type):
    """Metaclass to ensure that Foo(x) is x if isinstance(x, Foo)"""
    def __new__(cls, name, bases, namespace, **kwds):
        res = None
        defineNew = all(i.__new__ is object.__new__ for i in bases)
        if defineNew:
            def n(cls, *args, **kwds):
                if len(args) == 1 and isinstance(args[0], cls) and not kwds:
                    return args[0]
                else:
                    return super(res, cls).__new__(cls)
            namespace["__new__"] = n
        realInit = namespace.get("__init__")
        if realInit is not None or defineNew:
            @functools.wraps(realInit)
            def i(self, *args, **kwds):
                if len(args) != 1 or args[0] is not self:
                    if realInit is None:
                        return super(res, self).__init__(*args, **kwds)
                    else:
                        return realInit(self, *args, **kwds)
            namespace["__init__"] = i
        res = type.__new__(cls, name, bases, namespace)
        return res

class Foo(metaclass=IdempotentCast):
    ...
</code></pre>
<p>That metaclass adds a <code>__new__</code> method unless there exists a base class that already added a <code>__new__</code> method. So for class hierarchies where some such class extends another such class, the <code>__new__</code> method will get added but once. It also wraps the constructor to perform the check whether the first argument is identical to <code>self</code> (thanks to <a href="https://stackoverflow.com/a/41890600/1468366">the answer</a> by <a href="https://stackoverflow.com/users/3545273/serge-ballesta">Serge Ballesta</a> for pointing out this simple check). Otherwise it calls the original constructor, or the base constructor if no constructor had been defined.</p>
<p>Quite a bit of code, but you only need that once, and can use it to introduce these semantics for as many types as you want. If you only need this for a single class, other answers may be more appropriate.</p>
</div>
<span class="comment-copy">Are you not allowed to use factory methods to achieve this?</span>
<span class="comment-copy">@Tagc: I'm kind of used to using constructor names for casts. For example <code>float(x)</code>, <code>str(x)</code> or <code>tuple(x)</code> do return the same object if it already is of the correct type. I am using that notation quite often, so I want it for my own types as well, to be consistent. So it's a question of style, I guess. Functionally a factory method would of course work just as fine.</span>
<span class="comment-copy">The <code>self is arg</code> pattern is neat, hadn't thought about that. I guess I'll still end up writing a metaclass for this, in order to introduce this check automatically into constructors of derived classes.</span>
