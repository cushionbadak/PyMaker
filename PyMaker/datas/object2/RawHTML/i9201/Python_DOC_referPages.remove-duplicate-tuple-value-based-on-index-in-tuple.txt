<div class="post-text" itemprop="text">
<p>Is there a way to remove a duplicate tuple based on the index in the tuple. Say I have </p>
<pre><code>[(0, 4, 1.0), (1, 4, 1.0), (3, 4, 1.0), (0, 3, 2.0), (1, 3, 2.0), (0, 2, 3.0), (1, 2, 3.0), (2, 4, 4.0), (2, 3, 5.0), (0, 1, inf)]
</code></pre>
<p>Can I randomly keep one tuple where each duplicate has the same value at index 2? </p>
<p>So, there are 3 tuples that have value 1.0 at index 2, two tuples that have value 2.0 at index 2, one that has value 3 at index 2, and so on. </p>
<p>So, (0, 4, 1.0) might randomly be selected from the value 1.0 at index 2 and (1, 3, 2.0) might randomly be selected from the value 2.0 at index 2. 
Say, (1, 2, 3.0) was randomly selected from the value 3.0 at index 2.
Then, my list would look like </p>
<pre><code>[(0, 4, 1.0),(1, 3, 2.0), (1, 2, 3.0), (2, 4, 4.0), (2, 3, 5.0), (0, 1, inf)]
</code></pre>
<p>I have never come across a function that does this or at least efficiently. </p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to group the tuples based on value at index 2. Then for each group you can use <a href="https://docs.python.org/3/library/random.html#random.choice" rel="nofollow noreferrer"><code>random.choice</code></a> to pick a tuple:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; import random
&gt;&gt;&gt; l = [(0, 4, 1.0), (1, 4, 1.0), (3, 4, 1.0), (0, 3, 2.0), (1, 3, 2.0), (0, 2, 3.0), (1, 2, 3.0), (2, 4, 4.0), (2, 3, 5.0), (0, 1, float('inf'))]
&gt;&gt;&gt; [random.choice(tuple(g)) for _, g in groupby(l, key=lambda x: x[2])]
[(1, 4, 1.0), (1, 3, 2.0), (1, 2, 3.0), (2, 4, 4.0), (2, 3, 5.0), (0, 1, inf)]
</code></pre>
<p>In above <code>groupby</code> returns iterable <code>(key, group)</code> tuples where key is value returned by second parameter given to <code>groupby</code> and group is iterable of elements within a group:</p>
<pre><code>&gt;&gt;&gt; [(k, tuple(g)) for k, g in groupby(l, key=lambda x: x[2])]
[(1.0, ((0, 4, 1.0), (1, 4, 1.0), (3, 4, 1.0))), (2.0, ((0, 3, 2.0), (1, 3, 2.0))), (3.0, ((0, 2, 3.0), (1, 2, 3.0))), (4.0, ((2, 4, 4.0),)), (5.0, ((2, 3, 5.0),)), (inf, ((0, 1, inf),))]
</code></pre>
<p>Since we don't need the key we can discard it and convert group to sequence that <code>random.choice</code> expects:</p>
<pre><code>&gt;&gt;&gt; [random.choice(tuple(g)) for _, g in groupby(l, key=lambda x: x[2])]
[(1, 4, 1.0), (1, 3, 2.0), (0, 2, 3.0), (2, 4, 4.0), (2, 3, 5.0), (0, 1, inf)]
</code></pre>
<p>Note that above expects that tuples with same value at index 2 are next to each other in the input. If that's not the case you can sort the original list accordingly before passing it to <code>groupby</code>.</p>
<p><strong>Update</strong> In case you just want three first values of the result you can use generator expression instead of list comprehension and pull values out from there with <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>islice</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; gen = (random.choice(tuple(g)) for _, g in groupby(l, key=lambda x: x[2]))
&gt;&gt;&gt; list(islice(gen, 3))
[(0, 4, 1.0), (1, 3, 2.0), (0, 2, 3.0)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would not do this in one operation, though I am sure it's possible.</p>
<p>I would first make one list for each value at index <code>2</code>:</p>
<pre><code>values_at_index_2 = {t[2] for t in data}
groups_by_value = [[t for t in data if t[2] == v] for v in values_at_index_2]
</code></pre>
<p>Then pick one tuple in each of the groups:</p>
<pre><code>import random
new_data = [random.choice(group) for group in groups_by_value]
</code></pre>
</div>
<span class="comment-copy">Are all the tuples with same value at index 2 next to each other in the input? If not what's the correct order of the output?</span>
<span class="comment-copy">I can sort them to be like they are above</span>
<span class="comment-copy">Note: list should be pre-sorted based on index 2 before you use it with <code>groupby</code></span>
<span class="comment-copy">Is there a way to pull out the lowest 2 sorted values in the sorted list so you don't need to go over every value?</span>
<span class="comment-copy">@MikeElJackson I'm not sure I understand what you're asking. Do you mean that only <code>(0, 4, 1.0), (1, 4, 1.0)</code> should be considered from original input (== <code>(3, 4, 1.0)</code> is excluded)? Maybe you could update the original question a bit to provide an example.</span>
<span class="comment-copy">Say there is a huge list of tuples say thousands and I want the 3 lowest tuples from this list randomly chosen if there are duplicates. The code you showed me (which was awesome) had you go through each element and group by it and randomly choose it. Can you do this for the 3 lowest values and not group by the whole list for instance since it is sorted already</span>
<span class="comment-copy">So, if I have a list of one thousand things I only need to use a for loop for the last few items and not go through the whole list</span>
