<div class="post-text" itemprop="text">
<p>I want to create function for every possible permutation of an array. I wrote some code and I don't know what is wrong with it. It return me first possibility = [1,2,3], but then It fails with error : original[i] out of index but it should be originial[1] which equals 2. Maybe del temp erases also from original but that would not make sense for me.</p>
<p>Thank you in advace.</p>
<pre><code>array = [1,2,3]
out = []

def permutacja(original,perm):
    if(len(original) == 0):
        print(perm)
        return perm

    temp = original
    for i in range(0,len(original)):
        perm.append(original[i])
        del temp[0]
        permutacja(temp,perm)
        del perm[len(perm)-1]

permutacja(array,out)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python standard library module <code>itertools</code> provide <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>itertools.permutations</code></a> which yields permutations:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; for xs in itertools.permutations([1,2,3]):
...     print(xs)
...
(1, 2, 3)
(1, 3, 2)
(2, 1, 3)
(2, 3, 1)
(3, 1, 2)
(3, 2, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You better use <code>itertools</code> for this since these are well optimized and tested routines. Nevertheless in case you want to implement it yourself, there are some things that can be improved/corrected:</p>
<ul>
<li>You <code>return</code> a value, but only in the last recursive step you need to <strong>propagate them back</strong>;</li>
<li>you return a <strong>reference</strong> to the list you construct on the fly, as a result you will always return the same list;</li>
<li>you always <code>del</code>ete the <strong>first element</strong>, not the one you picked; and</li>
<li>you do <strong>not restore</strong> the element after deletion.</li>
</ul>
<pre><code>def permutacja(original,perm):
    if(len(original) == 0):
        print(perm)
        <b>yield perm.copy()</b> # emit instead of return for proagation
    <b>else:</b>
        temp = original
        for i in range(0,len(original)):
            perm.append(original[i])
            <b>temp = original[:i]+original[i+1:]</b> #remove the i-th
            <b>for result in permutacja(temp,perm):</b>
                <b>yield result</b> # propagate back
            del perm[len(perm)-1]
            # because we copy original, no need to restore
</code></pre>
<p>Some additonal improvements:</p>
<ul>
<li>use <code>.pop()</code> instead of <code>del</code> on the last element; and</li>
<li>you can simply use <code>if original</code> instead of a comparison on <code>len(..)</code>:</li>
</ul>
<pre><code>def permutacja(original,perm):
    if <b>original</b>:
        print(perm)
        yield perm.copy()
    else:
        temp = original
        for i in range(0,len(original)):
            perm.append(original[i])
            temp = original[:i]+original[i+1:] #remove the i-th
            for result in permutacja(temp,perm):
                yield result # propagate back
            <b>perm.pop()</b>
            # because we copy original, no need to restore
</code></pre>
</div>
<span class="comment-copy">yep, temp erases also from original <code>tmp = array #copies the reference to list</code>  insdead you should use:  <code>tmp = list(array)</code></span>
<span class="comment-copy">thanks, but I need this for more complicate algorithm which includes different type of data, I need to understand a simple way to do it to implicate this then to my algorithm</span>
<span class="comment-copy">@user3541098, Okay, I will give you a hint about your implementation problem. By doing <code>temp = original</code>, <code>temp</code> references the same list (not copying). By doing <code>temp = original[:]</code>, you will get a copy.</span>
<span class="comment-copy">@user3541098: <code>itertools</code> works with all kinds of data: strings, ints, floats, objects, etc.</span>
<span class="comment-copy">oh, ok, that would explain everything, thank you very much</span>
<span class="comment-copy">@user3541098, <code>perm[len(perm)-1]</code> can be expressed as <code>perm[-1]</code></span>
