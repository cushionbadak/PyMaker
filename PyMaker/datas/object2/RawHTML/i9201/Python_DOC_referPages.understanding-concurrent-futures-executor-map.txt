<div class="post-text" itemprop="text">
<p>I'm trying to parallelize some Python code using processes and <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer"><code>concurrent.futures</code></a>. It looks like I can execute a function multiple times in parrallel either by <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.submit" rel="nofollow noreferrer">submitting</a> calls and then calling <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.result" rel="nofollow noreferrer"><code>Future.result()</code></a> on the futures, or by using <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map" rel="nofollow noreferrer"><code>Executor.map()</code></a>.<br/>
I'm wondering if the latter is just a syntactic sugar for the former and if there's any difference performance-wise. It doesn't seem immediately clear from the documentation.</p>
</div>
<div class="post-text" itemprop="text">
<p>It will allow you to execute a function multiple times concurrently instead true parallel execution. </p>
<p>Performance wise, I recently found that the <code>ProcessPoolExecutor.submit()</code> and <code>ProcessPoolExecutor.map()</code> consumed the same amount of compute time to complete the same task. Note: <code>.submit()</code> returns a future object (let's call it f) and you need to use it's <code>f.result</code> option to see it's result. On the other hand, <code>.map()</code> directly returns an iterator.  </p>
<p>When converting their results into an ordered list using the sorted method, I have found that compute time of the entire <code>.map()</code>code can be faster than entire <code>.submit()</code> code in certain scenarios. </p>
<p>When converting their results into an unordered list using the list method, the compute time of the entire <code>.submit()</code> and <code>.map()</code> codes are the same. Also, these codes performed faster than the codes using the sorted method. </p>
<p>You can read the details in my <a href="https://stackoverflow.com/a/42096963/5722359">answer</a>. There, I have also shared my codes where you can see how they work. I hope they can be helpful to you.</p>
<p>I have not used <code>ThreadPoolExecutor</code> so I can't comment in detail. However, I have read that they are implemented the same way as the <code>ProcessPoolExecutor</code> and they are more suited to be used for I/O bound tasks instead of CPU bound tasks. You do need to specify the <em><code>max_workers</code></em> argument, i.e. the max number of threads, whereas in the <code>ProcessPoolExecutor</code> <code>max_workers</code> is an optional argument which defaults to the number of CPUs returned by <code>os.cpu_count()</code>.</p>
</div>
