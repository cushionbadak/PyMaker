<div class="post-text" itemprop="text">
<p>I am using Python 3.5.1. I read the document and the package section here: <a href="https://docs.python.org/3/tutorial/modules.html#packages">https://docs.python.org/3/tutorial/modules.html#packages</a></p>
<p>Now, I have the following structure:</p>
<pre><code>/home/wujek/Playground/a/b/module.py
</code></pre>
<p><code>module.py</code>:</p>
<pre><code>class Foo:
    def __init__(self):
        print('initializing Foo')
</code></pre>
<p>Now, while in <code>/home/wujek/Playground</code>:</p>
<pre><code>~/Playground $ python3
&gt;&gt;&gt; import a.b.module
&gt;&gt;&gt; a.b.module.Foo()
initializing Foo
&lt;a.b.module.Foo object at 0x100a8f0b8&gt;
</code></pre>
<p>Similarly, now in home, superfolder of <code>Playground</code>:</p>
<pre><code>~ $ PYTHONPATH=Playground python3
&gt;&gt;&gt; import a.b.module
&gt;&gt;&gt; a.b.module.Foo()
initializing Foo
&lt;a.b.module.Foo object at 0x10a5fee10&gt;
</code></pre>
<p>Actually, I can do all kinds of stuff:</p>
<pre><code>~ $ PYTHONPATH=Playground python3
&gt;&gt;&gt; import a
&gt;&gt;&gt; import a.b
&gt;&gt;&gt; import Playground.a.b
</code></pre>
<p>Why does this work? I though there needed to be <code>__init__.py</code> files (empty ones would work) in both <code>a</code> and <code>b</code> for <code>module.py</code> to be importable when the Python path points to the <code>Playground</code> folder?</p>
<p>This seems to have changed from Python 2.7:</p>
<pre><code>~ $ PYTHONPATH=Playground python
&gt;&gt;&gt; import a
ImportError: No module named a
&gt;&gt;&gt; import a.b
ImportError: No module named a.b
&gt;&gt;&gt; import a.b.module
ImportError: No module named a.b.module
</code></pre>
<p>With <code>__init__.py</code> in both <code>~/Playground/a</code> and <code>~/Playground/a/b</code> it works fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.3+ has <a href="https://www.python.org/dev/peps/pep-0420/" rel="noreferrer">Implicit Namespace Packages</a> that allow it to create a packages without an <code>__init__.py</code> file.</p>
<blockquote>
<p>Allowing implicit namespace packages means that the requirement to provide an <code>__init__.py</code> file <strong>can be dropped completely</strong>, and affected ... . </p>
</blockquote>
<p>The old way with <code>__init__.py</code> files still works as in Python 2.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>IMPORTANT</strong></p>
<p>@Mike's answer is correct but too imprecise. It is true that Python 3.3+ supports <em>Implicit Namespace Packages</em> that allows it to create a package without an <code>__init__.py</code> file.</p>
<p>This however, ONLY applies to <strong>EMPTY <code>__init__.py</code></strong> files. So <strong>EMPTY <code>__init__.py</code></strong> files are no longer necessary and can be omitted. If you want to run a particular initialization script when the package or any of its modules or sub-packages are imported, you still require an <strong><code>__init__.py</code></strong> file. This is a great <a href="https://stackoverflow.com/a/29509611/3385411">Stack Overflow answer</a> for why you would want to use an <code>__init__.py</code> file to do some further initialization in case you wondering why this is in any way useful.</p>
<p>Directory Structure Example:</p>
<pre><code>  parent_package/
     __init__.py            &lt;- EMPTY, NOT NECESSARY in Python 3.3+
     child_package/
          __init__.py       &lt;- STILL REQUIRED if you want to run an initialization script
          child1.py
          child2.py
          child3.py
</code></pre>
<p><code>parent_package/child_package/__init__.py</code>:</p>
<pre><code>print("from parent")
</code></pre>
<p><strong>EXAMPLES</strong></p>
<p>The below examples demonstrate how the initialization script is executed when the <code>child_package</code> or one of its modules is imported.</p>
<p><strong>Example 1</strong>:</p>
<pre><code>from parent_package import child_package  # prints "from parent"
</code></pre>
<p><strong>Example 2</strong>:</p>
<pre><code>from parent_package.child_package import child1  # prints "from parent"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would say that one should omit the <code>__init__.py</code> only if one wants to have the <a href="https://www.python.org/dev/peps/pep-0420/" rel="nofollow noreferrer">implicit namespace package</a>. If you don't know what it means, you probably don't want it and therefore you should continue to use the <code>__init__.py</code> even in Python 3.</p>
</div>
<span class="comment-copy">I will read the document, but it's a bit long. Is it possible to quickly summarize? Could you just tell me: does it still support <b>init</b>.py, or completely ignores them? If it does support them, what is the difference in functionality and why this duality?</span>
<span class="comment-copy">Yes, it still works. So all your Python 2 packages with <code>__init__.py</code> files will work in terms of imports (other difference between Python 2 and 3 not considered here).</span>
<span class="comment-copy">So the tutorial should be probably updated. Is a documentation bug opened for it?</span>
<span class="comment-copy">@JayRizzo But: "Although practicality beats purity."</span>
<span class="comment-copy">@JayRizzo IMO it is even more explicit. Sometimes it happens to do init stuff in <code>__init__.py</code>, sometimes not. In Python 3 when I need these stuff I create a new <code>__init__.py</code> with specific code, otherwise I don't. This comes handy to know, visually, which packages have custom init. Instead in python 2 I always have to place an <code>__init__.py</code> (often empty), making a great number of them and finally harder to remember where you placed your init code. This should also fit "There should be one-- and preferably only one --obvious way to do it.".</span>
<span class="comment-copy">Suppose I have <code>run_script.py</code> in same dir as <code>parent_package</code> so can I just import like <code>from parent_package.child_package import child1</code> without <code>__init__.py</code> ?</span>
<span class="comment-copy">Is the purpose of this so you can write child_package.some_function even if some_function is defined in childX.py? In another words it avoids requiring the user to know about the different files in child_package? ?</span>
<span class="comment-copy">Yeah, I donâ€™t get why you would make <code>child1.py</code>, <code>child2.py</code> instead of just putting their code together into <code>__init__</code>.py directly.</span>
<span class="comment-copy">Shouldn't the import statements in <code>__init__</code> be relative imports i.e. <code>from . import child1</code>? The absolute import gives me <code>ModuleNotFoundError</code> (in Python 3.6)</span>
<span class="comment-copy">Thanks @HalberdRejoyceth, I edited my answer :)</span>
