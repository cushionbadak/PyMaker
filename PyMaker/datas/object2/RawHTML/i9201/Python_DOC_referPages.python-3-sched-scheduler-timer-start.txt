<div class="post-text" itemprop="text">
<p>Here's what we want to be able to do:</p>
<ol>
<li><p>Schedule many calls, each for a precise number of milliseconds after we start a timer T.</p></li>
<li><p>Set something else up to run in another thread S.</p></li>
<li><p>Start thread S and start the timer T.</p></li>
</ol>
<p>How can we do this?</p>
<p>Here's the <a href="https://docs.python.org/3/library/sched.html" rel="nofollow noreferrer">API reference</a>. We actually expected the "time units" in <code>scheduler.enter</code> to be with respect to the call to <code>scheduler.run</code>, but apparently it's with respect to <strong>that</strong> call to <code>scheduler.enter</code>. With enough events, that introduces a time difference between jobs scheduled at i=0 in our scheduling loop and i=10**6, let alone the time difference that setting up the thread S introduces.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could always implement your own scheduler with <a href="https://docs.python.org/3.6/library/heapq.html" rel="nofollow noreferrer"><code>heapq</code></a>. Here's a simple example of a scheduler where the delay is relative to <code>start</code>:</p>
<pre><code>import heapq
import time

def fun(after, s):
    print('{} after {} seconds: {}'.format(time.time(), after, s))

class Sched:
    def __init__(self):
        self.tasks = []

    def add_task(self, delay_seconds, priority, callback, args):
        task = (delay_seconds, priority, callback, args)
        heapq.heappush(self.tasks, task)

    def start(self):
        self.start_time = time.monotonic()

        while self.tasks:
            now = time.monotonic()
            delta = now - self.start_time
            nxt = self.tasks[0][0]

            if delta &lt; nxt:
                time.sleep(nxt - delta)
            else:
                _, _, callback, args = heapq.heappop(self.tasks)
                callback(*args)

sched = Sched()
sched.add_task(5, 1, fun, (5, 'second'))
sched.add_task(5, 0, fun, (5, 'first'))
sched.add_task(7, 0, fun, (7, 'third'))

print(time.time(), 'start')
sched.start()
print(time.time(), 'end')
</code></pre>
<p>Output:</p>
<pre><code>1485623736.9788322 start
1485623741.9809415 after 5 seconds: first
1485623741.9809415 after 5 seconds: second
1485623743.9846892 after 7 seconds: third
1485623743.9846892 end
</code></pre>
<p>Note that the tasks are not run exactly when requested. This is because of limitations of <a href="https://docs.python.org/3.6/library/time.html#time.sleep" rel="nofollow noreferrer"><code>sleep</code></a> and possibly the time it takes to execute previous task.</p>
</div>
<div class="post-text" itemprop="text">
<p>I just wanted to share the solution we actually used. I graphed a scatter plot of x=scheduled-time and y=actual-time for executions using two methods:</p>
<ul>
<li>using something similar to niemmi's answer, using <code>time.sleep</code></li>
<li><p>using a dedicated thread to poll without sleeping:</p>
<pre><code># where queue is a DeQueue that pops the earliest scheduled time first
r = range(0, len(self._stimulus_list))
t0 = monotonic()
for _ in r:
    nxt = queue.get_nowait()
    while monotonic() - t0 &lt; t_now: pass
    nxt.execute()
</code></pre></li>
</ul>
<p>The second method had a slope closer to 1.0 with an average abs error of about 1Î¼s (though some expected bias). We sacrificed a thread completely and used the second method.</p>
<p>I still find the <code>sched</code> package pretty counter-intuitive.</p>
</div>
<span class="comment-copy">Thanks! This is blocking though. Is sched as well? I always manage to misunderstand Python docs more than any other.</span>
<span class="comment-copy">@DouglasMyers-Turnbull You can <a href="https://docs.python.org/3/library/sched.html#sched.scheduler.run" rel="nofollow noreferrer"><code>run</code></a> it in both modes, default it blocking.</span>
