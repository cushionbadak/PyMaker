<div class="post-text" itemprop="text">
<p>I have</p>
<pre><code> list = [a, b, c, d]
</code></pre>
<p>and</p>
<pre><code>numbers = [2, 4, 3, 1]
</code></pre>
<p>I want to get a list of the type of:</p>
<pre><code>new_list = [a, a, b, b, b, b, c, c, c, d]
</code></pre>
<p>This is what I have so far:</p>
<pre><code>new_list=[] 
for i in numbers: 
    for x in list: 
        for i in range(1,i+1): 
            new_list.append(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way to do it using <code>zip</code>, string multiplication and a <em>list comprehension</em>:</p>
<pre><code>lst = ['a', 'b', 'c', 'd'] 
numbers = [2 , 4, 3, 1]

r = [x for i, j in zip(lst, numbers) for x in i*j]
print(r)
# ['a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'd']
</code></pre>
<p>Pay attention to the choice of names when using Python. A name like <code>list</code> renders the builtin list function unusable.</p>
<p>If the items in <code>lst</code> are not strings you can simply use a nested comprehension on <code>range</code>, to duplicate the items in the list.</p>
</div>
<div class="post-text" itemprop="text">
<p>A nested list comprehension works:</p>
<pre><code>L = ['a','b','c','d']
numbers = [2, 4, 3, 1]

&gt;&gt;&gt; [x for x, number in zip(L, numbers) for _ in range(number)]
['a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'd']
</code></pre>
<p>The "sub-loop" <code>for _ in range(number)</code> repeats the value <code>number</code> times.
Here <code>L</code> can hold any object, not only strings.</p>
<p>Example:</p>
<pre><code>L = [[1, 2, 3],'b','c', 'd']
numbers = [2, 4, 3, 1]
[x for x, number in zip(L, numbers) for _ in range(number)]
[[1, 2, 3], [1, 2, 3], 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'd']
</code></pre>
<p>but this flattens the sub list:</p>
<pre><code>[x for i, j in zip(L, numbers) for x in i*j]
[1, 2, 3, 1, 2, 3, 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'd']
</code></pre>
<p>not exactly the desired result.</p>
</div>
<div class="post-text" itemprop="text">
<p>As a general approach for any object (not only string) you can use  <code>itertools.repeat()</code> within a generator expression:</p>
<pre><code>def repeat_it(lst, numbers):
    return chain.from_iterable(repeat(i, j) for i, j in zip(lst, numbers))
</code></pre>
<p>Demo:</p>
<pre><code>In [13]: from itertools import repeat, chain

In [21]: lst=[5,4,6,0]

In [22]: list(repeat_it(lst, numbers))
Out[22]: [5, 5, 4, 4, 4, 4, 6, 6, 6, 0]

In [23]: lst=['a','b','c','d']

In [24]: list(repeat_it(lst, numbers))
Out[24]: ['a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'd']
</code></pre>
<p>Here is a benchmark on 3 main approaches. Note that the last one onley works for strings:</p>
<pre><code>In [49]: lst = lst * 1000

In [50]: numbers = numbers * 1000

In [51]: %timeit list(chain.from_iterable(repeat(i, j) for i, j in zip(lst, numbers)))
1 loops, best of 3: 8.8 s per loop

In [52]: %timeit [x for x, number in zip(lst, numbers) for _ in range(number)]
1 loops, best of 3: 12.4 s per loop

In [53]: %timeit [x for i, j in zip(lst, numbers) for x in i*j]
1 loops, best of 3: 7.2 s per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>numpy.repeat()</code> as another option:</p>
<pre><code>import numpy as np
np.repeat(lst, numbers).tolist()

# ['a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'd']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way to do it with a loop would be:</p>
<pre><code>new_list = []
for number, item in zip(numbers, l):
    for i in range(number):
        new_list.append(item)
</code></pre>
<p>Now we have:</p>
<pre><code>new_list = ['a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'd']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are unsure of how list comprehensions work,    </p>
<pre><code>myList=['a','b','c','d'] # not a good idea to use list as a name for your variable
numbers=[2,4,3,1]
new_list=[]
for i in range(len(myList)):     
    for j in range(numbers[i]):          
        new_list.append(myList[i])

print(new_list)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will work regardless of whether a, b, c and d are variables or strings:</p>
<pre><code>a = 1
b = 2.0
c = "cheese"
d = ["c", "a", "k", "e"]

lst = [a, b, c, d]
numbers = [2, 4, 3, 1]

# if len(lst) == len(numbers):
new_lst = [i for i, j in zip(lst, numbers) for k in range(j)]
</code></pre>
<p>You might want to uncomment the if statement (and indent the line underneath) to check if the lists have the same length, otherwise new_lst will only contain as many items as the shorter list.</p>
<p><a href="https://stackoverflow.com/questions/406121/flattening-a-shallow-list-in-python">This</a>, <a href="https://stackoverflow.com/questions/11264684/flatten-list-of-lists">this</a> and <a href="https://docs.python.org/3/tutorial/datastructures.html#nested-list-comprehensions" rel="nofollow noreferrer">the documentation section on nested list comprehensions</a> are worth reading.</p>
</div>
<div class="post-text" itemprop="text">
<p>That's my solution, just to add a different one.</p>
<pre><code>l = ['a', 'b', 'c', 'd']
n = [2, 4, 3, 1]
r = []
for i,v in enumerate(l):
    r += list(v*n[i])

&gt;&gt;&gt; r
    ['a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'd']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that both lists are the same length and the second is always a list of numbers, here is a solution without using <code>zip</code> or any imports:</p>
<pre><code>lst = ['a', 'b', 'c', 'd']
numbers = [2,4,3,1]

result = sum([[lst[i]]*numbers[i] for i in range(len(lst))],[])
</code></pre>
</div>
<span class="comment-copy">@Ekaterina edit your question to include that piece of code, not in the comments.</span>
<span class="comment-copy">OP didn't specify that <code>a</code>, <code>b</code>, etc are strings.  Your solution only works based on the assumption that "<code>list</code>" contains a bunch of sequences.</span>
<span class="comment-copy">@mgilson Yep, updated...</span>
<span class="comment-copy">Note that this requires you to install numpy, which is overkill if you are just solving this one problem</span>
<span class="comment-copy">This is a <i>shlemiel the painter</i> algorithm, and one of the worst ways that you can go for solving this problem.</span>
<span class="comment-copy">@Kasramvd How so?</span>
<span class="comment-copy"><a href="https://www.joelonsoftware.com/2001/12/11/back-to-basics/" rel="nofollow noreferrer">joelonsoftware.com/2001/12/11/back-to-basics</a></span>
<span class="comment-copy">@Kasramvd, yes thanks, i've read it, i'm asking how it applies here</span>
