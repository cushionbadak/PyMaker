<div class="post-text" itemprop="text">
<p>I have a number of classes with code like this. Each <code>__init__</code> starts a thread and a logger with the name of the class. How do I get the name of the current class in its own definition, as a string, inside <code>__init__</code>? Note that <code>self</code> may not be an instance of the current class, so the following is not quite foolproof.</p>
<pre><code>from threading import Thread
import logging

def myClassName(myclass):
    myclass._class_name = myclass.__name__
    return myclass

@myClassName
class SomeClass(object):
    def __init__(self):
        class_name = type(self)._class_name
        print "My class name in __init__ is", class_name
        self.thread = Thread(name=class_name)
        self.logger = logging.getLogger(class_name)
</code></pre>
<p>Update:</p>
<p>To clarify:</p>
<ul>
<li>I want the name of the class being defined, not the class of the
object passed in. </li>
<li>I don't want to hard code the name of the class.</li>
<li>I want to make it easy to copy/paste an example from one script to<br/>
another, and the fewer mentions of the unique class name, the better.
(Inheritance isn't really efficient, as there are enough custom
differences to make it awkward. But accidentally leaving in the name
of the wrong class is a hard bug to find.)</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3 this is pretty straight forward, we can use the <a href="https://docs.python.org/3/reference/datamodel.html#creating-the-class-object" rel="nofollow noreferrer"><code>__class__</code></a> cell variable to get the current class.</p>
<p>In Python 2 we can achieve something similar by injecting class's name in functions globals scope using a metaclass and later cleaning it up.</p>
<pre><code>from functools import wraps
from types import FunctionType


def decorate(func, class_name):
    @wraps(func)
    def wrapper(*args, **kwargs):
        sentinel = object()
        actual_value = func.__globals__.get('__class__', sentinel)
        func.__globals__['__class__'] = class_name
        try:
            result = func(*args, **kwargs)
        finally:
            if actual_value is sentinel:
                del func.__globals__['__class__']
            else:
                func.__globals__['__class__'] = actual_value
        return result
    return wrapper


class Meta(type):
    def __new__(cls, name, bases, attrs):
        for k, v in attrs.items():
            if isinstance(v, FunctionType):
                attrs[k] = decorate(v, name)
        return type.__new__(cls, name, bases, attrs)


class A:
    __metaclass__ = Meta
    def func(self):
        print(__class__)
        print('Inside A')


class B(A):
    def func(self):
        print(__class__)
        print('Inside B')
        super(B, self).func()


B().func()
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>B
Inside B
A
Inside A
</code></pre>
<hr/>
<p>To get the <code>__class__</code> variable as the class object itself we can make few changes:</p>
<pre><code>def decorate(func, cls):
    @wraps(func)
    def wrapper(*args, **kwargs):
        sentinel = object()
        actual_value = func.__globals__.get('__class__', sentinel)
        func.__globals__['__class__'] = cls
        try:
            result = func(*args, **kwargs)
        finally:
            if actual_value is sentinel:
                del func.__globals__['__class__']
            else:
                func.__globals__['__class__'] = actual_value
        return result
    return wrapper


class Meta(type):
    def __new__(cls, name, bases, attrs):
        cls = type.__new__(cls, name, bases, attrs)
        for k, v in attrs.items():
            if isinstance(v, FunctionType):
                setattr(cls, k, decorate(v, cls))
        return cls
</code></pre>
<p>Now output would be:</p>
<pre><code>&lt;class '__main__.B'&gt;
Inside B
&lt;class '__main__.A'&gt;
Inside A
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can retrieve the name of the class of an an object thus:</p>
<pre><code>obj.__class__.__name__
</code></pre>
<p>Example:</p>
<pre><code>class SomeClass(object):
    def __init__(self):
        print("I am a %s"%self.__class__.__name__)

class Derived(SomeClass):
    pass

x = SomeClass()
y = Derived()
</code></pre>
<p>Result:</p>
<pre><code>$ python x.py
I am a SomeClass
I am a Derived
</code></pre>
</div>
<span class="comment-copy">In what case would <code>self</code> of the <code>__init__</code> method <i>not</i> be an instance of the current class?</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/510972/getting-the-class-name-of-an-instance-in-python" title="getting the class name of an instance in python">stackoverflow.com/questions/510972/â€¦</a></span>
<span class="comment-copy">@CoryKramer for example, you defined <code>def __init__(potato, self='haha!'):  ...</code></span>
<span class="comment-copy">@wim I think it's fair to assume that <code>self</code> is shorthand for "first argument to the method"</span>
<span class="comment-copy">So, given your comment in Rob's answer, what is the problem with just <i>hard-coding</i> the name in the <code>__init__</code>?</span>
<span class="comment-copy">Nice. Can you explain the reasoning for putting the injection logic in the <code>wrapper</code>?</span>
<span class="comment-copy">Nice. More code than I expected, but it appears to me to solve the problem thoroughly and cleanly.</span>
<span class="comment-copy">Followup: Can this be genericized to take the name of any function? Here it is <code>func</code>, but the target function might vary (<code>__init__</code> comes to mind).</span>
<span class="comment-copy">@QuantumMechanic <code>func</code> is just a variable name I used in the decorator, it will work on any function.</span>
<span class="comment-copy">@juanpa.arrivillaga Was thinking of keeping things similar to Python 3 as much as possible, hence the <code>__class__</code> variable. Added another version where <code>__class__</code> now points to the class itself.</span>
<span class="comment-copy">Is your point that <code>self</code> will always refer to an instance of the current class being executed?</span>
<span class="comment-copy">No. In fact I demonstrate the case where <code>self</code> is <i>not</i> an instance of the current class, but rather an instance of a derived class.</span>
<span class="comment-copy">Well that is what I mean actually when I said "current class". Yes I did word that some oddly.</span>
<span class="comment-copy">Yes. But this fails, because I want the <code>SomeClass</code> name in both cases. That is, I want the name of the class where the code is defined, not the class of the instance passed in.</span>
<span class="comment-copy">@QuantumMechanic you need to disambiguate "the current class being executed" in your actual question, or else people are going to be interpreting it in various different ways.</span>
