<div class="post-text" itemprop="text">
<p>Assume, I have a NumPy-array of integers, as:</p>
<pre><code>[34,2,3,22,22,22,22,22,22,18,90,5,-55,-19,22,6,6,6,6,6,6,6,6,23,53,1,5,-42,82]
</code></pre>
<p>I want to find the start and end indices of the array, where a value is more than x-times (say 5-times) repeated. So in the case above, it is the value 22 and 6. Start index of the repeated 22 is 3 and end-index is 8. Same for the repeatening 6.
Is there a special tool in Python that is helpful? 
Otherwise, I would loop through the array index for index and compare the actual value with the previous. </p>
<p>Regards.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>np.diff</code> and the method given <a href="https://stackoverflow.com/a/24892274/7982275">here</a> by @WarrenWeckesser for finding runs of zeros in an array:</p>
<pre><code>import numpy as np

def zero_runs(a):  # from link
    iszero = np.concatenate(([0], np.equal(a, 0).view(np.int8), [0]))
    absdiff = np.abs(np.diff(iszero))
    ranges = np.where(absdiff == 1)[0].reshape(-1, 2)
    return ranges

a = [34,2,3,22,22,22,22,22,22,18,90,5,-55,-19,22,6,6,6,6,6,6,6,6,23,53,1,5,-42,82]

zero_runs(np.diff(a))
Out[87]: 
array([[ 3,  8],
       [15, 22]], dtype=int32)
</code></pre>
<p>This can then be filtered on the difference between the start &amp; end of the run:</p>
<pre><code>runs = zero_runs(np.diff(a))

runs[runs[:, 1]-runs[:, 0]&gt;5]  # runs of 7 or more, to illustrate filter
Out[96]: array([[15, 22]], dtype=int32)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There really isn't a great short-cut for this.  You can do something like:</p>
<pre><code>mult = 5
for elem in val_list:
    target = [elem] * mult
    found_at = val_list.index(target)
</code></pre>
<p>I leave the not-found exceptions and longer sequence detection to you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution using Python's native <code>itertools</code>.</p>
<p>Code</p>
<pre><code>import itertools as it


def find_ranges(lst, n=2):
    """Return ranges for `n` or more repeated values."""
    groups = ((k, tuple(g)) for k, g in it.groupby(enumerate(lst), lambda x: x[-1]))
    repeated = (idx_g for k, idx_g in groups if len(idx_g) &gt;=n)
    return ((sub[0][0], sub[-1][0]) for sub in repeated)

lst = [34,2,3,22,22,22,22,22,22,18,90,5,-55,-19,22,6,6,6,6,6,6,6,6,23,53,1,5,-42,82]    
list(find_ranges(lst, 5))
# [(3, 8), (15, 22)]
</code></pre>
<p>Tests</p>
<pre><code>import nose.tools as nt


def test_ranges(f):
    """Verify list results identifying ranges."""
    nt.eq_(list(f([])), [])
    nt.eq_(list(f([0, 1,1,1,1,1,1, 2], 5)), [(1, 6)])
    nt.eq_(list(f([1,1,1,1,1,1, 2,2, 1, 3, 1,1,1,1,1,1], 5)), [(0, 5), (10, 15)])
    nt.eq_(list(f([1,1, 2, 1,1,1,1, 2, 1,1,1], 3)), [(3, 6), (8, 10)])    
    nt.eq_(list(f([1,1,1,1, 2, 1,1,1, 2, 1,1,1,1], 3)), [(0, 3), (5, 7), (9, 12)])

test_ranges(find_ranges)
</code></pre>
<p>This example captures (index, element) pairs in <code>lst</code>, and then groups them by element.  Only repeated pairs are retained.  Finally, first and last pairs are sliced, yielding (start, end) indices from each repeated group.  </p>
<p>See also <a href="https://stackoverflow.com/a/30336492/4531270">this post</a> for finding ranges of indices using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you're looking for <code>value</code> repeated <code>n</code> times in list <code>L</code>, you could do something like this:</p>
<pre><code>def find_repeat(value, n, L):
    look_for = [value for _ in range(n)]
    for i in range(len(L)):
        if L[i] == value and L[i:i+n] == look_for:
            return i, i+n
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a relatively quick, errorless solution which also tells you how many copies were in the run. Some of this code was borrowed from KAL's solution.</p>
<pre><code># Return the start and (1-past-the-end) indices of the first instance of
# at least min_count copies of element value in container l 
def find_repeat(value, min_count, l):
  look_for = [value for _ in range(min_count)]
  for i in range(len(l)):
    count = 0
    while l[i + count] == value:
      count += 1
    if count &gt;= min_count:
      return i, i + count
</code></pre>
</div>
<span class="comment-copy">@Evan: I don't think that applies so well: <code>mode</code> works on values anywhere in the array, not necessarily contiguous.</span>
<span class="comment-copy">This question is really relevant to any sort of sequence container in python, not just numpy arrays.</span>
