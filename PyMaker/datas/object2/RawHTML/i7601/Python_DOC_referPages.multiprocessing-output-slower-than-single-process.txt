<div class="post-text" itemprop="text">
<p>I'm running this code, and it seems running the script using multiprocesses is slower than running it via a single process.</p>
<p>Am I doing something wrong?</p>
<pre><code>from time import time
numbers = [(1963309, 2265973), (2030677, 3814172),
           (1551645, 2229620), (2039045, 2020802)]
start = time()
results = list(map(gcd, numbers))
print(results)
end = time()


print('time is %.3f'%(end - start))

from multiprocessing import Pool


if __name__ == '__main__':
    start = time()
    with Pool(4) as p:
      print(p.map(gcd, numbers))
    end = time()
    #print('time is %.3f'%(end - start))
    print('Took %.3f seconds' % (end - start))
</code></pre>
<p>output is </p>
<pre><code>[1, 1, 5, 1]   # single process
time is 0.444
[1, 1, 5, 1]   #multi-processes
Took 0.751 seconds
</code></pre>
<p>Thank you. </p>
</div>
<div class="post-text" itemprop="text">
<p>It's a bad example of multiprocessing advantages. It obvious will be slower because you spent more time on creating and starting each process than on executing your function. Multiprocessing sensible in case you have really big time consuming function so you put it in separate process.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your timing is unfair. <code>list(map(gcd, numbers))</code> is an in-process operation and doesn't start a new process. </p>
<blockquote>
<p>The <code>Pool</code> class represents a pool of worker processes.</p>
</blockquote>
<p>Starting a new process is intuitively slower than simply executing <code>list(map(gcd, numbers))</code>, relative to <code>list(map(...))</code> there's so much going on in <code>Pool</code> to start the processes. It's almost like comparing the speed of elephants and cheetahs.  </p>
</div>
<span class="comment-copy"><code>time.time</code> might behave differently than what  you might expect, use <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow noreferrer">time.perf_counter()</a> instead.</span>
<span class="comment-copy">Thanks. They used a similar example in "Effective Python" (but code seems to be outdated, <code>from concurrent.futures import ProcessPoolExecutor</code>),and the author was getting faster results (almost 2x's) with multiprocessing, so I was confused.</span>
<span class="comment-copy">And why do you create only 3 processes pool if you have 4 elements in the list?</span>
<span class="comment-copy">I was testing out different processes, to see how much on effect it was having. I had tried out 4 as well. I will update.</span>
