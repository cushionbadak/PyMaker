<div class="post-text" itemprop="text">
<p>I have run this list copying experiment and found one of the times to be much quicker than the others, as far as I can tell it does copy the list, unless someone can explain otherwise?</p>
<pre><code>import time

def test(d):
    s = time.time()
    for i in range(20000000):
        d['b'] = d['a'].copy()
    e = time.time()
    print (".copy(): "+str(e-s))

    s = time.time()
    for i in range(20000000):
        d['b'][:] = d['a']
    e = time.time()
    print ("[:] on left: "+str(e-s))

    s = time.time()
    for i in range(20000000):
        d['b'] = d['a'][:]
    e = time.time()
    print ("[:] on right: "+str(e-s))

d = {'a': [1,2,3,4],
     'b': []}
test(d)
</code></pre>
<p>results:</p>
<pre><code>.copy(): 4.150316476821899
[:] on left: 2.535377025604248
[:] on right: 4.140159606933594
</code></pre>
<p>To prove <code>[:]</code> on left is copying?</p>
<pre><code>d['b'][:] = d['a']
del d['a'][1]
d['a'][0] = "testing"
print (d)
</code></pre>
<p>prints:</p>
<pre><code>{'a': ['testing', 3, 4], 'b': [1, 2, 3, 4]}
</code></pre>
<p>Can anyone explain what's going on here?</p>
</div>
<div class="post-text" itemprop="text">
<p>By using <code>[:]</code> in an assignment you have expanded the left-hand side list to have the same number of elements as the right-hand list. The rest of your tests then <strong>re-use</strong> those extra elements; <code>d['b']</code> is no longer empty!</p>
<p>In other words, for everything but the first iteration, that copy operation doesn't have to allocate more indices for the list. That makes it faster.</p>
<p>You need to test with an <strong>empty</strong> list on the left-hand side each time. Use the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code> module</a> to run proper time trials. Use suitably large inputs:</p>
<pre><code>&gt;&gt;&gt; timeit('a = []; a[:] = b', 'from __main__ import testlist as b')
2.430507270000817
&gt;&gt;&gt; timeit('a = b[:]', 'from __main__ import testlist as b')
2.5209442199993646
&gt;&gt;&gt; timeit('a = b.copy()', 'from __main__ import testlist as b')
2.5766620540016447
</code></pre>
<p>Allocating more space doesn't actually take all that much time; you only see the effect for small lists:</p>
<pre><code>&gt;&gt;&gt; timeit('a[:] = b', 'a = [1, 2, 3, 4]; b = a[:]', number=10000000)
0.7304684859991539
&gt;&gt;&gt; timeit('a = []; a[:] = b', 'a = [1, 2, 3, 4]; b = a[:]', number=10000000)
0.9908717719954439
</code></pre>
<p>(note, the iterations have been increased from 1 million to 10 million here).</p>
<p>For large lists, the difference is mostly moot:</p>
<pre><code>&gt;&gt;&gt; timeit('a[:] = b', 'from __main__ import testlist as b; a = b[:]')
2.4996446009972715
&gt;&gt;&gt; timeit('a = []; a[:] = b', 'from __main__ import testlist as b')
2.4407932980029727
</code></pre>
<p>In this specific test run starting with an empty list was actually slightly faster; the difference is mostly noise however, re-running these two tests have the timings trade places regularly.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>d['b'][:] = d['a']</code> does not need to allocate memory for the list <code>d['b']</code>, since it has already been allocated by the previous operation and the existing list object is being reused. The others create a new list.</p>
</div>
