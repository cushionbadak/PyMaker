<div class="post-text" itemprop="text">
<p>I have a dictionary with the following structure:</p>
<pre><code>{
    1: {"names": ["name1_A", "name1_B", ...]},
    2: {"names": ["name2_A", "name2_B", ...]},
    ...
}
</code></pre>
<p>where <code>name1_A</code> and <code>name1_B</code> are synonyms/aliases/different ways to write the same name, whose ID is 1. <code>name2_A</code> and <code>name2_B</code> are aliases of the same name, whose ID is 2, and so on.</p>
<p>I need to write a function which takes a user input and returns the ID of the name whose alias is most similar to the user input.</p>
<p>I know it's not very intuitive to understand what I mean, so here's an example. Let's say this is my dictionary:</p>
<pre><code>{
    1: {"names": ["James", "Jamie"]},
    2: {"names": ["Karen", "Karyn"]}
}
</code></pre>
<p>The user types in the word <code>Jimmy</code>. Since the closest match to <code>Jimmy</code> from the dictionary is <code>Jamie</code>, the function has to return the ID 1.</p>
<p>If the user types in the world <code>Karena</code>, since the closest match is <code>Karen</code>, the function has to return the ID 2.</p>
<p>I think the best way to get the closest math is to use <a href="https://docs.python.org/3/library/difflib.html#difflib.get_close_matches" rel="nofollow noreferrer">difflib</a>'s <code>get_close_matches()</code>. However, that function takes a list of possibilities as argument, and I cannot think of a way to correctly use it in my function. Any help would be appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're interested in 3rd party modules, there's a nice little module I like to use for this sort of thing called <a href="https://github.com/seatgeek/fuzzywuzzy" rel="nofollow noreferrer"><code>fuzzywuzzy</code></a>, for fuzzy string matching in Python. This module uses the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="nofollow noreferrer">Levenshtein Distance</a> metric for computing distances between two strings. Here's an example of how you use it:</p>
<pre><code>&gt;&gt;&gt; from fuzzywuzzy import fuzz
&gt;&gt;&gt; from functools import partial
&gt;&gt;&gt; data_dict = {
...     1: {"names": ["James", "Jamie"]},
...     2: {"names": ["Karen", "Karyn"]}
... }
&gt;&gt;&gt; input_str = 'Karena'
&gt;&gt;&gt; f = partial(fuzz.partial_ratio, input_str)
&gt;&gt;&gt; matches = { k : max(data_dict[k]['names'], key=f) for k in data_dict}
&gt;&gt;&gt; matches
{1: 'James', 2: 'Karen'}
&gt;&gt;&gt; { i : (matches[i], f(matches[i])) for i in matches }
{1: ('James', 40), 2: ('Karen', 100)}
</code></pre>
<p>Now, you can extract <code>Karen</code> since it has the highest score.</p>
<p>I've had to call the function twice for the purpose of this demo, but you should be able to do that just once depending on how you expand upon this example.</p>
<p>Another thing to note is that <code>fuzz.partial_ratio</code> is more lenient with its matches. For a stricter matching scheme, consider using <code>fuzz.ratio</code>.</p>
<p>You can peruse more examples using fuzzy string matching <a href="https://marcobonzanini.com/2015/02/25/fuzzy-string-matching-in-python/" rel="nofollow noreferrer">here</a>.</p>
</div>
<span class="comment-copy">How are you defining "most similar"?</span>
<span class="comment-copy">When you say <code>Jamie</code> is the closet match to <code>Jimmy</code> you're comparing the highest match of each character in both strings or you have another logic behind ?</span>
<span class="comment-copy">Search for "dynamic programming spell checker", perhaps - this is just one set of rules, and not necessarily the best. ie. maybe it would be better to use the phonetic distance?</span>
<span class="comment-copy">@Jedi Exactly, there <i>are</i> indeed other keys apart from <code>names</code>, which are not relevant to the question</span>
<span class="comment-copy">If you want to speed this up, create a separate list of all <code>names</code> and a dict mapping each <code>name</code> to it's id. Then apply <code>fuzzywuzzy</code> or <code>difflib</code> once by checking each name once and find the appropriate key in a single lookup.</span>
