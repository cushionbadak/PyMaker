<div class="post-text" itemprop="text">
<p>I keep getting a TypeError 'Range' object does not support item assignment. I tried to change the code a little as in add iter(...) before the range, aswell as list(...) before range. However, it didn't help and the Error continues.
Here's the code:</p>
<pre><code>def findAnchor(anchors, node):
    start = node                   
    while node != anchors[node]:   
        node = anchors[node]       
    anchors[start] = node          
    return node

def unionFindConnectedComponents(graph):
    anchors = range(len(graph))        
    for node in iter(range(len(graph))):    
        for neighbor in graph[node]:   
            if neighbor &lt; node:        
                continue

            a1 = findAnchor(anchors, node)       
            a2 = findAnchor(anchors, neighbor)   
            if a1 &lt; a2:                          
                anchors[a2] = a1                 
            elif a2 &lt; a1:                        
                anchors[a1] = a2                 

    labels = [None]*len(graph)         
    current_label = 0                  
    for node in range(len(graph)):
        a = findAnchor(anchors, node)  
        if a == node:                  
            labels[a] = current_label  
            current_label += 1         
        else:
            labels[node] = labels[a]   


    return anchors, labels
</code></pre>
<p>Now the TypeError is in the beginning at anchors[start] = node. And node is a given argument from the second function where it says for node in iter(range(len(graph))). I tried it with iter and with list, neither worked. What to do?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>anchors = range(len(graph))</code> generates a <code>list</code> in python 2 so you can assign to it.</p>
<p>But in python 3, the behaviour has changed. <code>range</code> becomes a lazy sequence generation object, which saves memory &amp; CPU time because it is mostly used to count in loops and its usage to generate a contiguous actual <code>list</code> is rather rare.</p>
<p>From <a href="https://docs.python.org/3/library/functions.html#func-range" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>Rather than being a function, range is actually an immutable sequence type</p>
</blockquote>
<p>And such objects don't support slice assignment (<code>[]</code> operation)</p>
<p>Quickfix: force iteration on the <code>range</code> object, you'll get an object you can use slicing assignment to:</p>
<pre><code>anchors = list(range(len(graph)))
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/20484195/typeerror-range-object-does-not-support-item-assignment">TypeError: 'range' object does not support item assignment</a></span>
<span class="comment-copy">Wow amazing, thanks! I kept trying around with the 'node', I thought the error is there because of start = node.</span>
<span class="comment-copy">yes, <code>for node in iter(range(len(graph))): </code> <code>iter</code> is useless here.</span>
<span class="comment-copy">gah! Nitpick, but it does <i>not</i> become a generator function. It is an immutable, constant-memory, sequence type that support lazy generation of it's values. It is not a generator. It isn't even an iterator. If you don't believe me, try <code>r = range(10); next(r)</code>.</span>
<span class="comment-copy">A "range object" is unequivocal terminology. Again, this is all just a nitpick and doesn't detract from your answer really.</span>
<span class="comment-copy">okay but calling <code>range</code> a "range object" seems like a cyclic definition to me :)</span>
