<div class="post-text" itemprop="text">
<p>Let's say we have 100k directories and 1M files whose structure is stored in lists like this:</p>
<pre><code>DIRS = ['C:\\', 'C:\\LAB\\', 'C:\\ABB\\', 'C:\\CDA\\', 'C:\\EABZ\\', 'C:\\CDA\\FOO\\']
FILES = [['a.txt', 2], ['b.txt', 3], ['c.txt', 3], ['r.txt', 1], 
         ['s.txt', 1], ['k.txt', 0], ['m.txt', 4]]   # [filename, dir_index], for 
                                                     # example, a.txt is here: C:\ABB\a.txt
</code></pre>
<p>Now I'd like to <strong>search for files for which their directory name contains <code>AB</code></strong>. The only method I see here is the following.</p>
<ul>
<li><p>(1) First get the index of <code>DIRS</code> which contain <code>AB</code>:</p>
<pre><code>I = [i for i in range(len(DIRS)) if 'AB' in DIRS[i]]          # here [1, 2, 4]
                                                              # but can be of size 1000
</code></pre>
<p>We only loop once on <code>DIRS</code>, which is 100k, <strong>this is ok</strong>.</p></li>
<li><p>(2) Now we need to loop on both <code>I</code> (which can be 1000 for example) and  <code>FILES</code> (which is 1 million), and <strong>this is too much</strong> because 1000 * 1M = 1 billion operations:</p>
<pre><code>FOUND_FILES = []
for i in I:
    for f in FILES:
        if f[1] == i:
            FOUND_FILES.append(f)
</code></pre></li>
</ul>
<p>This is too much operations! <strong>How to have a more efficient research, while keeping the <code>DIRS</code> / <code>FILES</code> data structures?</strong> (If 100% totally impossible, which other structure should I consider?)</p>
<hr/>
<p><em>Note: this alternative for (2) doesn't speed up anything I think:</em></p>
<pre><code>for f in FILES:      # we loop over 1M items
    if f[1] in I:    # to test if f[1] is contained in I, we might loop over 1000 items too
        FOUND_FILES.append(f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The time complexity of the alternative approach can reduce to <em>O</em>(n) (where <em>n</em> is the length of <code>FILES</code>) if you make <code>I</code> a set, as opposed to the original <em>O</em>(n*m) (where <em>m</em> is the length of <code>I</code>):</p>
<pre><code>I = {i for i, x in enumerate(DIRS) if 'AB' in x}
</code></pre>
<p>One of the important uses of a set is fast membership lookup; <em>O</em>(1).</p>
<p>You can also gain some significant CPU time by using a list comprehension to build the final <code>FOUND_FILES</code> list:</p>
<pre><code>FOUND_FILES = [f for f in FILES if f[1] in I]
</code></pre>
<hr/>
<p>If you're building the list of files by reading the entire content of the parent directory, using say <code>os.listdir</code>, you should apply <a href="https://docs.python.org/3/library/glob.html" rel="nofollow noreferrer"><code>glob.glob</code></a> instead, to build a list from your pattern directly.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>DIRS = ['C:\\', 'C:\\LAB\\', 'C:\\ABB\\', 'C:\\CDA\\', 'C:\\EABZ\\', 'C:\\CDA\\FOO\\']
FILES = [['a.txt', 2], ['b.txt', 3], ['c.txt', 3], ['r.txt', 1], ['s.txt', 1], ['k.txt', 0], ['m.txt', 4]]
FOUND_FILES = []

for check_file in FILES:
try:
    if 'AB' in DIRS[check_file[1]]:
        FOUND_FILES.append(check_file)
except (IndexError, TypeError):
    pass
</code></pre>
<p>like this?</p>
</div>
<span class="comment-copy">Hmm, would <code>glob.glob('(*AB*).\1')</code> work?</span>
<span class="comment-copy">@Coldspeed Already had that in-coming :))</span>
<span class="comment-copy">Oh... cool... you have my +1. Cheers.</span>
<span class="comment-copy"><code>One of the important uses of a set is fast membership lookup; O(1)</code> how is this possible? The bigger the set, the slower a membership lookup, no? So there should be proportionality between "set size" and "membership lookup time", don't you think so?</span>
<span class="comment-copy">@Basj Nope, ideally. Sets use hashtables, so they don't need to iterate over the items sequentially. Sufficient to locate the item's index in the table from its hash, an operation that takes O(1).</span>
