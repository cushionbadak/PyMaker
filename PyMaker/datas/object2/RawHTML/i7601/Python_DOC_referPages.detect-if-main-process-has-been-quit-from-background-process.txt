<div class="post-text" itemprop="text">
<p>I have a single background process running alongside the main one, where it uses <code>Queue</code> to communicate (using multiprocessing, not multithreading). The main process runs constantly, and the background thread runs once per queue item so that if it gets backlogged, it can still catch up. Instead of closing with the main script (I've enabled <code>daemon</code> for that), I would prefer it to run until the queue is empty, then save and quit.</p>
<p>It's started like this:</p>
<pre><code>q_send = Queue()
q_recv = Queue()
p1 = Process(target=background_process, args=(q_send, q_recv))
p1.daemon = True
p1.start()
</code></pre>
<p>Here's how the background process currently runs:</p>
<pre><code>while True:

    received_data = q_recv.get()
    #do stuff
</code></pre>
<p>One way I've considered is to switch the loop to run all the time, but check the size of the queue before trying to read it, and wait a few seconds if it's empty before trying again. There are a couple of problems though. The whole point is it'll run once per item, so if there are 1000 queued commands, it seems a little inefficient checking the queue size before each one. Also, there's no real limit on how long the main process can go without sending an update, so I'd have to set the timeout quite high, as opposed to instantly exiting when the connection is broken, and queue emptied. With the background thread using up to 2gb of ram, it could probably do with exiting as soon as possible.</p>
<p>It'd also make it look a lot more messy:</p>
<pre><code>afk_time = 0
while True:

    if afk_time &gt; 300:
        return
    if not q_recv.qsize():
        time.sleep(2)
        afk_time += 2
    else:
        received_data = q_recv.get()
        #do stuff
</code></pre>
<p>I came across <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.is_alive" rel="nofollow noreferrer"><code>is_alive()</code></a>, and thought perhaps getting the main process from <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.current_process" rel="nofollow noreferrer"><code>current_process()</code></a> might work, but it gave a picking error when I tried to send it to the queue.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/queue.html#queue.Queue.get" rel="nofollow noreferrer"><code>Queue.get</code></a> has a keyword argument <code>timeout</code> which determines the time to wait for an item if the queue is empty. If no item is available when the timeout elapses then a <a href="https://docs.python.org/3/library/queue.html#queue.Empty" rel="nofollow noreferrer"><code>Empty</code></a> exception is raised.</p>
<blockquote>
<p>Remove and return an item from the queue. If optional args block is true and timeout is None (the default), block if necessary until an item is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. Otherwise (block is false), return an item if one is immediately available, else raise the Empty exception (timeout is ignored in that case).</p>
</blockquote>
<p>So you can except that error and break out of the loop:</p>
<pre><code>try:
    received_data = q_recv.get(timeout=300)
except queue.Empty:
    return
</code></pre>
</div>
<span class="comment-copy">Thanks, if there's no better solutions I'll probably do this, still doesn't get around the 2nd problem I mentioned but will do for now, I'll have to test how frequently things are sent over to get the timeout as low as I can :)</span>
<span class="comment-copy">@Peter Could you point out your exact goal again? I feel like I missed something (esp. on that 2nd problem). And why do you want to exit the background process at all? What if the main process sends something to the queue later on?</span>
<span class="comment-copy">I'm only wanting it to end after the main process has quit, as that means no more queue items will be added. All I need it to do is finishing processing the queue, so the timeout works as a workaround, but the best case scenario would be it'd instantly know the main process has ended and not need any timeout.</span>
<span class="comment-copy">@Peter In that case you could send a closing command over the queue. Something that - by convention - indicates that the main process finished its work. When the background receives this item it can terminate as well. You just need to come up with a definition of that closing command (for example <code>None</code>).</span>
<span class="comment-copy">I could do that if I could catch the main process closing, but I'm meaning quitting as in the user closes the window. I looked into executing python code on script exit but didn't have any luck with it.</span>
