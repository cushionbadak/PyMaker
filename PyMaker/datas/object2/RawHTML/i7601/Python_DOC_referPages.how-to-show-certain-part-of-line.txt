<div class="post-text" itemprop="text">
<p>I have text "podaci.txt" file like this:</p>
<pre class="lang-none prettyprint-override"><code>Name|Lastname|1-000-1|1234|5000
Name1|Lastname1|1-000-1|4321|15500
</code></pre>
<p>Where <code>1234</code> and <code>4321</code> are pin codes.</p>
<p>And code like this:</p>
<pre><code>def ProveraStanja(self):
    file_data = open("podaci.txt").readlines()
    for i in file_data:
        i=i.strip("\n").split("|")
        account_balance=i[4]
    self.top = Toplevel()
    self.la = Label(self.top,text="Acaunt balance: ")
    self.la.grid()
    self.Results = Label(self.top, text = account_balance)
    self.Results.grid()
    self.bt = Button(self.top,text='Potvrdi', command = self.potvrdiBtn)
    self.bt.grid()
    self.top.resizable(0,0)
</code></pre>
<p>How to show account balance for logged in user?</p>
<p>My problem is that the python always show only accaunt balance of last user.</p>
<p>For example, if I login as <code>1234</code>, it still will show <code>15500</code> as my account</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your code is that you don't keep the data of each line. Instead, you overwrite <code>account_balance</code> with every iteration of your for loop. As a result, only the last value is kept, which corresponds to the last line in your file.</p>
<p>You can do it like so:</p>
<pre><code>def getBalance(myPin):
    with open("podaci.txt", "r") as file:
        for line in file.readlines():
            split_line = line.strip().split("|")
            if split_line[3] == myPin:
                return split_line[4]
    return 0 #Return 0 balance if the PIN does not exist
</code></pre>
<p>What we are doing here is the following:</p>
<ol>
<li>Open the file using a <code>with</code> statement, which you can read about
<a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer">here</a>.</li>
<li>Read all lines in the file and loop through them.</li>
<li>Split each line using the <code>'|'</code> character as our delimiter.</li>
<li><p>Check if the 4th item (index 3) in the list is same as <code>myPin</code>.</p>
<ul>
<li>If so, return the 5th item, which is the balance. If not, return 0.</li>
</ul></li>
</ol>
<p>Of course, this solution is far from ideal. I made it as simple as possible so that it is easy to understand. There are many ways to improve it. For instance, you should add some form of redundancy.</p>
<pre><code>def getBalance(myPin):
    with open("podaci.txt", "r") as file:
        for line in file.readlines():
            split_line = line.strip().split("|")
            if len(split_line) == 5: #Make sure that the line is valid
                if split_line[3] == myPin:
                     return split_line[4]
    return 0 #Return 0 balance if the PIN does not exist
</code></pre>
<p>What I have done here is I have added an extra <code>if</code> statement that makes sure that the line has the number of items that is expected of a valid entry. This way, reading a line that is empty or invalid won't cause an exception.</p>
<p>The absolute best solution however (besides using a proper database) is to use a <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">class</a> to hold our entry data:</p>
<pre><code>class Account:
    def __init__(self, list):
        self.Name = list[0]
        self.LastName = list[1]
        self.AccountNumber = list[2]
        self.Pin = list[3]
        self.Balance = list[4]

accounts = [] #Accounts are all kept here

#Load all accounts from the file
def getAccounts():
    with open("podaci.txt", "r") as file:
        for line in file.readlines():
            split_line = line.strip().split("|")
            if len(split_line) == 5: #Make sure that the line is valid
                accounts.append(Account(split_line))

#Find the account that matches the inputted PIN
def findBalance(myPin):
    for account in accounts:
        if account.Pin == myPin:
            return account.Balance
</code></pre>
<p>This way, our data is much more organized, and adding features is much more simple. For the final example I have also modified the code to read the file and load the accounts only once, which would have been very hard to do without using a class.</p>
<p>Just for fun, you can take it one step further by moving all the string processing to the actual class:</p>
<pre><code>class Account:
    def __init__(self, name, lastName, accountNumber, pin, balance):
        self.Name = name
        self.LastName = lastName
        self.AccountNumber = accountNumber
        self.Pin = pin
        self.Balance = balance

    def Decode(line):
        split_line = line.strip().split("|")
        if len(split_line) == 5: #Make sure that the line is valid
            return Account(split_line[0], split_line[1], split_line[2], split_line[3], split_line[4])

accounts = []

def getAccounts():
    with open("podaci.txt", "r") as file:
        for line in file.readlines():
           accounts.append(Account.Decode(line))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You loop through all lines of your file but always overwrite the account_balance.</p>
<p>create your account_balance as dictionary like:</p>
<pre><code>account_balance = {}
</code></pre>
<p>and in the for loop store the balance in the correct field. </p>
<pre><code>account_balance[i[3]] = i[4]
</code></pre>
<p>to access the value use the key</p>
<pre><code>account_balance[1234]
</code></pre>
</div>
<span class="comment-copy">You're not checking to see when your line has your zip and breaking out.</span>
