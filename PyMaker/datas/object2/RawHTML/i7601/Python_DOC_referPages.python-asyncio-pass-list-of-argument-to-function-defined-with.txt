<div class="post-text" itemprop="text">
<p>Let's consider the following example from the documentation:</p>
<pre><code>import asyncio

async def factorial(name, number):
    f = 1
    for i in range(2, number+1):
        print("Task %s: Compute factorial(%s)..." % (name, i))
        await asyncio.sleep(1)
        f *= i
    print("Task %s: factorial(%s) = %s" % (name, number, f))

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.gather(
    factorial("A", 2),
    factorial("B", 3),
    factorial("C", 4),
))
loop.close()
</code></pre>
<p>The gather function is presented as such in the module:</p>
<pre><code>asyncio.gather(*coros_or_futures, loop=None, return_exceptions=False)
</code></pre>
<p>It works all fine, but for my real life problem I need to pass in the gather function not a multiplicity of functions with hardcoded arguments, but rather a tuple comprehension of some form creating the multiple functions.</p>
<p>I tried:</p>
<pre><code>loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.gather(
    [factorial(str(g),g) for g in range(3)]
))
loop.close()
</code></pre>
<p>but it doesnt work. Anyone knows how to have that gather function to work with a programatically created list of functions?</p>
<p>TO BE CLEAR: the <code>gather</code> function is not defined by me so i cannot remove the * from its definition and simply pass the list of arguments like that. I would need to "unpack" the list but i don't know how.</p>
</div>
<div class="post-text" itemprop="text">
<p>You also can use the <code>itertools.starmap</code> for this task:</p>
<pre><code>import asyncio
import itertools

async def factorial(name, number):
    f = 1
    for i in range(2, number+1):
        print("Task %s: Compute factorial(%s)..." % (name, i))
        await asyncio.sleep(1)
        f *= i
    print("Task %s: factorial(%s) = %s" % (name, number, f))

loop = asyncio.get_event_loop()

args = [(str(g), g) for g in range(3)]
tasks = itertools.starmap(factorial, args)
loop.run_until_complete(asyncio.gather(*tasks))
loop.close()
</code></pre>
<blockquote>
<p>Make an iterator that computes the function using arguments obtained from the iterable. Used instead of map() when argument parameters are already grouped in tuples from a single iterable (the data has been “pre-zipped”).</p>
</blockquote>
<p>For more reading: <a href="https://docs.python.org/3/library/itertools.html#itertools.starmap" rel="nofollow noreferrer">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Found the solution:</p>
<pre><code>loop.run_until_complete(asyncio.gather(*(factorial(str(g),g) for g in range(3)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>List of coroutines can be dynamically generated and passed as follows:</p>
<pre><code>import asyncio

async def factorial(name, number):
    f = 1
    for i in range(2, number + 1):
        print(f"Task {name}: Compute factorial({i})...")
        await asyncio.sleep(1)
        f *= i
    print(f"Task {name}: factorial({number}) = {f}")

async def main():
    a = factorial("A", 2)
    b = factorial("B", 3)
    c = factorial("C", 4)
    #
    # example passing in list of coroutines
    #
    await asyncio.gather(*[a,b,c])

asyncio.run(main())
</code></pre>
</div>
