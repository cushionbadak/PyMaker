<div class="post-text" itemprop="text">
<p>Cython allows to use C and C++ libraries by wrapping their functions and classes. Two of the libraries I would like to use are SFML and Box2D. They define separate Vector2 classes. Would it be possible to write one Vector2 Python wrapper for both of these libraries (and potentially more)? My goal is to have single Python type of Vector2 when interacting with different libraries.</p>
<p>Do someone already did something similar? This would simplify things and unify my Python API. I've already wrapped parts of SFML but other than that I'm new to Cython.</p>
<p>For the reference <a href="https://github.com/SFML/SFML/blob/master/include/SFML/System/Vector2.hpp" rel="nofollow noreferrer">SFML's Vector2</a> looks like this:</p>
<pre><code>template &lt;typename T&gt; class Vector2 {
    public:
        T x;
        T y;
        Vector2();
        Vector2(T X, T Y);
        template &lt;typename U&gt; explicit Vector2(const Vector2&lt;U&gt;&amp; vector);
        ...
};
</code></pre>
<p>And <a href="https://github.com/erincatto/Box2D/blob/master/Box2D/Box2D/Common/b2Math.h" rel="nofollow noreferrer">Box2D vector</a>:</p>
<pre><code>struct b2Vec2 {
    float32 x, y;
    b2Vec2() {}
    b2Vec2(float32 xIn, float32 yIn);
    ...
};
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Overview</strong></p>
<p>The general idea is three steps:</p>
<ol>
<li>Write declarations for your types</li>
<li>Wrap each class individually with an identical interface</li>
<li>Write a generalized vector wrapper</li>
</ol>
<p><strong>Declarations</strong></p>
<p>First you need a Cython declaration for the wrapped types. An example (very minimal) is as follows.</p>
<pre><code># This is the Cython interface for Vector2

cdef float float32 

cdef extern from "Vector2.hpp" nogil:
    # if this was an stl vector, use vector[T, ALLOCATOR=*]
    # you must list every template type, even one with default values
    cdef cppclass Vector2[T]:   
        ctypedef T value_type

        # Add all the overloads, for example, multiplication
        Vector2[T, ALLOCATOR] operator*(const T&amp;) const;


cdef extern from "b2Math.h" nogil:
    cdef cppclass b2Vec2:

        # Add all overloads, for example, multiplication
        void operator*=(float)
</code></pre>
<p><strong>Interface</strong></p>
<p>Next, you need to wrap these into Python wrappers. You need to make sure they have identical interfaces, so one can be used like another. The <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">Python data model</a> is your friend. A very simple example is:</p>
<pre><code>cdef class SfmlVector2_32:
    # This is a definition for a float32 vector from Sfml
    Vector2[float32] c

    def __mul__(self, float32 x):
        # multiple and assign
        B2Vector2_32 copy;
        copy.c = c * x
        return copy;

cdef class B2Vector2_32:
    # This is a definition for a float32 vector from box2
    b2Vec2 c

    def __mul__(self, float32 x):
        # multiple and assign
        B2Vector2_32 copy;
        copy.c = c;
        copy.c *= x
        return copy
</code></pre>
<p><strong>Generalized Vector</strong></p>
<p>Finally, you need a simple wrapper class, which binds one of the many vector types and performs the right operation on the class. Since Python is not statically typed, and since the interfaces for each vector you wrapped are identical, this is easy: just initial the correct vector in <code>__init__</code>.</p>
<pre><code>class Vector2_32:

    def __init__(self, framework = 'SFML'):
        # ideally, perform a dictionary lookup if you have many classes
        # O(1) for dict, if/then is O(n)
        if framework == 'SFML':
            self.vector = SfmlVector2_32()
        elif framework == 'BOX2':
            self.vector = B2Vector2_32()
        else:
            raise TypeError("Unrecognized framework.")

    def __mul__(self, float32 x):
        Vector2_32 copy
        copy.vector = vector * x
        return copy
</code></pre>
<p><strong>Thoughts</strong></p>
<p>This is a pretty bad example, since typically you implement <code>__mul__</code> (multiplication) in terms of <code>__imul__</code> (in-place multiplication), but it gets the general idea across. There are likely typos in this code, I don't have access to a machine to compile it right now.</p>
</div>
<span class="comment-copy">You can easily have both classes present in the same class, however, a quick glance at SFML's Vector2 implementation shows there is no access to a <code>data()</code> member, meaning any data would likely have to be copied over (it's not <code>numpy.ctypeslib.as_array</code> friendly).   You could easily have a wrapper for both, just with a bit of syntactic sugar, but you would have consider copying data over for each to use methods from each individual library.</span>
<span class="comment-copy">Another (very simply option) is you could export both classes separately, and then have a wrapper that enacts a shared subset of methods (like multiplication, division, etc.) storing one of the two exported classes as a data member. If you would like, I can give an example as an answer.</span>
<span class="comment-copy">@AlexanderHuszagh Would be great to see an example.</span>
<span class="comment-copy">From design and maintenance point of view, it's best to have 1 Python class per 1 C++ class. You can have 3rd Python class to just to wrap those 2.</span>
<span class="comment-copy">The usual approach in Python is that it's the interface that is important, rather than the class, and so provided the two classes have the same interface then they should work interchangably</span>
<span class="comment-copy">Great answer. I have one question: what does this <code>ALLOCATOR=*</code> do?</span>
<span class="comment-copy">@PythonFanboy  The STL vector is defined as <code>std::vector&lt;T, std::allocator&lt;T&gt;</code>, meaning it takes two types, not 1. Cython needs to know this, but it cannot use the second type. This notifies Cython that <code>vector</code> takes two types for a template, but the second one is default initialized. In this case, I was wrong and Sfml does not allow you to define an allocator. I'll edit my answer.</span>
<span class="comment-copy">You don't have to tell Cython about the second type. Provided that the text <code>std::vector&lt;T&gt;</code> generates valid C++ code with appropriate substitutions of T (which it does) then Cython really doesn't need to know about the second argument.</span>
