<div class="post-text" itemprop="text">
<p>I have defined a class and need most of its attributes handed over to a function for processing. So I thought instead of creating a huge mess and naming them all I'd do <code>processSomething(vars(self))</code> and hand over a nice dictionary with all attributes and values. </p>
<p>But I found that almost all of the attributes are missing.</p>
<p>I have halted the code in the debugger and ran a few tests:</p>
<pre><code>&gt;&gt;&gt; vars(self).keys()
dict_keys(['date_expire', 'tokenUrl', 'settings', 'requestSession', 'ttlDays'])
</code></pre>
<p>These are 5. While I am expecting about 20 attributes, as per <code>__slots__</code> definition of my class here:</p>
<pre><code>__slots__ = (
    'token',        # the invitation-token to load the username with
    'request',      # the http-request which is currently being serviced
    'inhibit',      
     #... many lines deleted
    'templateObj',  # an instance of myMail.template.Template
    'emailBody',    # what will be sent via SMTP
    'warningsAr',   # messages for the client
)
</code></pre>
<p>I can see the attributes in the debugger window and can access them directly. I have read the <a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow noreferrer">manual of vars()</a> and could not find any switches. Interestingly, <code>dir(self)</code> shows all attribute-names, but no values. So I cannot use that. But I thought vars and dir should show the same?</p>
<p>I guess I'll build a workaround, but I really want to understand what is happening here. Can you please help?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>vars()</code> returns you the <code>__dict__</code> namespace of an instance. But <code>__slots__</code> attributes are <em>not stored in the <code>__dict__</code> namespace</em>. That's their whole point.</p>
<p>Instead, Python creates dedicated pointer slots in the instance memory structure for each value, and uses <em>descriptors</em> on the class object to retrieve those values. So <code>inst.attr</code> is translated to <code>type(inst).attr.__get__(inst)</code> to return that value.</p>
<p>From the <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><code>__slots__</code> documentation</a>:</p>
<blockquote>
<p>The <code>__slots__</code> declaration takes a sequence of instance variables and reserves just enough space in each instance to hold a value for each variable. Space is saved because <code>__dict__</code> is not created for each instance.</p>
<p><em>[...]</em></p>
<ul>
<li><code>__slots__</code> are implemented at the class level by creating descriptors (<a href="https://docs.python.org/3/reference/datamodel.html#descriptors" rel="nofollow noreferrer">Implementing Descriptors</a>) for each variable name. </li>
</ul>
</blockquote>
<p>Note that having a <code>__dict__</code> <em>anyway</em> is usually a sign you forgot to make a subclass use <code>__slots__</code> for their attributes, or you inherited from a base Python class that didn't use <code>__slots__</code> itself. Proper use of <code>__slots__</code> should result in instances with no <code>__dict__</code> namespace; their goal is to reduce memory by avoiding the sparse hash table required for a dict (which can waste space).</p>
<p>From the documentation again:</p>
<blockquote>
<ul>
<li>When inheriting from a class without <code>__slots__</code>, the <code>__dict__</code> attribute of that class will always be accessible, so a <code>__slots__</code> definition in the subclass is meaningless.</li>
</ul>
<p><em>[...]</em></p>
<ul>
<li>The action of a <code>__slots__</code> declaration is limited to the class where it is defined. As a result, subclasses will have a <code>__dict__</code> unless they also define <code>__slots__</code> (which must only contain names of any additional slots).</li>
</ul>
</blockquote>
<p>If you wanted to list all available instance fields, you'd have to include the <code>__slots__</code> enumeration from the class, and not just look at <code>vars()</code>:</p>
<pre><code>from itertools import chain

def slots_for_instance(inst):
    def _slots_for_class(c):
        slots = getattr(c, '__slots__', ())
        if isinstance(slots, str):
            # __slots__ can be a string naming a single attribute
            slots = (slots,)
    return set(chain.from_iterable(
        getattr(_slots_for_class(c) for c in type(inst).__mro__))
</code></pre>
</div>
<span class="comment-copy">Makes sense. Not sure tho why dir() is behaving so differently by giving me all vars. Thank you. ACCEPTED! <i>stamp</i></span>
<span class="comment-copy">@Chris: <code>dir()</code> is a different beast altogether, see <a href="//stackoverflow.com/q/14361256">what's the biggest difference between dir and __dict__ in python</a></span>
