<div class="post-text" itemprop="text">
<p>I'm trying to iterate elif statements over lists with an else statement at the end. Here is my code:</p>
<pre><code>    if clickPoint is None:
        print(clickPoint)
    for each in meal_objects:
        if inside(clickPoint, each._button):
            each._button.setFill('green')
            break
    for each in build_meal_objects:
        if inside(clickPoint, each._button):
            each._button.setFill('green')
            break
    for each in ingredient_objects:
        if inside(clickPoint, each._button):
            each._button.setFill('green')
            break
    else:
        print(clickPoint)
</code></pre>
<p>meal_objects, build_meal_objects, and ingredient_objects are lists.</p>
<p>The problem is that this code is horrible for many reasons. If the first condition is not met, each for loop will run even if one of the for loops conditions have already run, and the final else statement will also be running. Really, if any of the if statements within any of the for loops is met, then the rest of the if block should not execute.</p>
<p>The code should really be something more like this pseudocode:</p>
<pre><code>    if clickPoint is None:
        print(clickPoint)
    elif for each in meal_objects:
        if inside(clickPoint, each._button):
            each._button.setFill('green')
            break
    elif for each in build_meal_objects:
        if inside(clickPoint, each._button):
            each._button.setFill('green')
            break
    elif for each in ingredient_objects:
        if inside(clickPoint, each._button):
            each._button.setFill('green')
            break
    else:
        print(clickPoint)
</code></pre>
<p>I feel like I might be overlooking something really simple, so forgive me if that is the case or if this is a poorly written question. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Probably the simplest (and most flexible way) is to put them in a function and force a <code>return</code>, eg:</p>
<pre><code>def f(clickPoint, *lists):
    if clickPoint is None:
        # or raise an exception instead as seems more an exception than natural
        return (None, None)
    for lst in lists:
        for item in lst:
            if inside(clickPoint, item._button):
                item._button.setFill('green')
                return (lst, item)
    return (None, None)
</code></pre>
<p>Then call it as:</p>
<pre><code>lst, item = f(clickPoint, meal_objects, build_meal_objects, ingredient_objects)
</code></pre>
<p>This means that only the first element of all lists will have a fill set and it returns a reference to the list and the item that was set which you can check later if you want to do the print.</p>
<p>eg:</p>
<pre><code>if (lst, item) == (None, None):
    # handle that nothing was set?
else:
    # you know which button (`item`) in which list (`lst`) had its fill changed 
</code></pre>
<p>I suppose if you really had a need to, you can make use of the <code>for/else</code> syntax that Python has but that requires you to effectively chain the sequences to a single <code>for</code> to issue the <code>break</code> on, eg:</p>
<pre><code>for lst, item in ((lst, item) for lst in (meal_objects, build_meal_objects, ingredient_objects) for item in lst):
    if inside(clickPoint, item._button):
        item._button.setFill('green')
        break
else: # this only enters if `break` was NOT issued in the for-loop
    print('nothing set')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ok this is going to need some explanation. Take a look at this below.</p>
<pre><code>for x in range(5):
    for y in range(5):
        print (x*y)
        if x*y==3:
            break
    else:
        continue  # executed if the loop finished normally (no break)
    break         # executed if 'continue' was skipped (break)
</code></pre>
<p>The above program just prints values till it finds a <code>3</code>. </p>
<p>output:</p>
<pre><code>0
0
0
0
0
0
1
2
3
</code></pre>
<p>What if the last <code>continue</code> and <code>else</code> weren't present?</p>
<pre><code>for x in range(5):
    for y in range(5):
        print (x*y)
        if x*y==3:
            break
</code></pre>
<p>output:</p>
<pre><code>0
0
0
0
0
0
1
2
3
0
2
4
6
8
0
3
0
4
8
12
16
</code></pre>
<p>See it doesn't even stop after finding a <code>3</code> that's because the <code>break</code> only caused to exit out of the inner loop. So the first code can be used to exit out of a nested loop. Even a very deeply nested loop.</p>
<p>So how to apply this in your code? Look at this!</p>
<pre><code>my_objects = {0: meal_objects, 1: build_meal_objects, 2: ingredient_objects}

flag2=True
flag1=True
if clickPoint is None:
        print(clickPoint)

        flag2=False

if flag2:
    for i in range(3):
        temp_obj = my_objects[i]
        for each in temp_obj:
            if inside(clickPoint, each._button):
                each._button.setFill('green')
                flag1=False
                break
        else:
            continue
        break

if flag1 and flag2:
    print(clickPoint)
</code></pre>
<p>Use <strong>flag variables</strong>. Now in the above code first set <code>flag1=True</code> and <code>flag2=True</code>. The first <code>if</code>block gets executed and if <code>clickPoint</code> is None then it is printed. And <strong>flag2 is set to be <code>False</code></strong>.</p>
<p>Why did I do that? To ensure that it fails in the next <code>if</code> statement. Thereby none of your <code>for</code> loops are executed. </p>
<p>The next part if incase <code>clickPoint</code> is not <code>None</code>. The next <code>if</code> is executed and note here is where I did a small change!</p>
<pre><code>my_objects = {0: meal_objects, 1: build_meal_objects, 2: ingredient_objects}
</code></pre>
<p>Create a <code>dict</code> of your objects and get them one by one using <code>range(your_dict_size)</code>. <strong>NOTE</strong> This way you can add even more and more objects.</p>
<p><strong>Remember</strong> I explained about exiting out of nested loops? That's exactly what happens. The moment you get what you wanted <strong>that's it</strong> control exits and no more for loops are run. </p>
<p>and set <strong>flag1</strong> to <code>False</code></p>
<p><strong>NOTE:</strong> The reason for two <strong>flag</strong> variables is because to ensure your <code>else</code> part (Here it is the last <code>if</code>) always executes if the first two <code>if</code>s fail. </p>
</div>
<div class="post-text" itemprop="text">
<p>I think this is what you're trying to do:</p>
<pre><code>if clickPoint is None:
    print(clickPoint)
else:
    called = False
    for each in meal_objects:
        if inside(clickPoint, each._button):
            each._button.setFill('green')
            called = True
            break
    if not called:
        for each in build_meal_objects:
            if inside(clickPoint, each._button):
                each._button.setFill('green')
                called = True
                break
        if not called:
            for each in ingredient_objects:
                if inside(clickPoint, each._button):
                    each._button.setFill('green')
                    called = True
                    break
            if not called:
                print(clickPoint)
</code></pre>
<p>This makes sure that only one of the for loops calls <code>each._button.setFill('green')</code>. If none of them calls it, then the print statement runs.</p>
</div>
<div class="post-text" itemprop="text">
<p>Seems like you might was well use <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools.chain</code></a> to condense the for loops into one block. This way you loop over all the items in your lists and stop as soon as you get to the first one that is "inside".</p>
<pre><code>from itertools import chain

if clickPoint is None:
    print(clickPoint)
for each in chain(meal_objects, build_meal_objects, ingredient_objects):
    if inside(clickPoint, each._button):
        each._button.setFill('green')
        break
else:
    print(clickPoint)
</code></pre>
</div>
<span class="comment-copy">You can't have an <code>elif for</code>. You could use a variable to keep track of whether one of the loops ran, and then only do the next loop if it did.</span>
<span class="comment-copy">By "ran," do you mean it called <code>each._button.setFill("green")</code>?</span>
<span class="comment-copy">Wrap them in a function and instead of <code>break</code> use a <code>return</code> is one way.</span>
