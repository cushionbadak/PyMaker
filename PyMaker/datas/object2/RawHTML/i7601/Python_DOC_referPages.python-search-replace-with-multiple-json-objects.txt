<div class="post-text" itemprop="text">
<p>I wasn't sure how to search for this but I am trying to make a script that dynamically launches programs. I will have a couple of JSON files and I want to be able to do a search replace sort of thing.</p>
<p>So I'll setup an example:</p>
<p>config.json</p>
<pre><code>{
    "global_vars": {
        "BASEDIR": "/app",
        "CONFIG_DIR": "{BASEDIR}/config",
        "LOG_DIR": "{BASEDIR}/log",
        "CONFIG_ARCHIVE_DIR": "{CONFIG_DIR}/archive"
    }
}
</code></pre>
<p>Then process.json</p>
<pre><code>{
    "name": "Dummy_Process",
    "binary": "java",
    "executable": "DummyProcess-0.1.0.jar",
    "launch_args": "-Dspring.config.location={CONFIG_DIR}/application.yml -Dlogging.config={CONFIG_DIR}/logback-spring.xml -jar {executable}",
    "startup_log": "{LOG_DIR}/startup_{name}.out"
}
</code></pre>
<p>Now I want to be able to load both of these JSON objects and be able to use the values there to update. So like "CONFIG_ARCHIVE_DIR": "{CONFIG_DIR}/archive" will become CONFIG_ARCHIVE_DIR": "/app/config/archive"</p>
<p>Does anyone know a good way to do this recursively because I'm running into issues when I'm trying to use something like CONFIG_DIR which requires BASEDIR first.</p>
<p>I have this function that loads all the data:</p>
<pre><code>#Recursive function, loops and loads all values into data
    def _load_data(data,obj):
        for i in obj.keys():
            if isinstance(obj[i],str):
                data[i]=obj[i]
            if isinstance(obj[i],dict):
                data=_load_data(data,obj[i])
        return data
</code></pre>
<p>Then I have this function:</p>
<pre><code>def _update_data(data,data_str=""):
    if not data_str:
        data_str=json.dumps(data)

    for i in data.keys():
        if isinstance(data[i],str):
            data_str=data_str.replace("{"+i+"}",data[i])
        if isinstance(data[i],dict):
            data=_update_data(data,data_str)
    return json.loads(data_str)
</code></pre>
<p>So this works for one level but I don't know if this is the best way to do it. It stops working when I hit a case like the CONFIG_DIR because it would need to loop over the data multiple times. First it needs to update the BASEDIR then once more to update CONFIG_DIR. suggestion welcome.</p>
<p>The end goal of this script is to create a start/stop/status script to manage all of our binaries. They all use different binaries to start and I want one Processes file for multiple servers. Each process will have a servers array to tell the start/stop script what to run on given server. Maybe there's something like this already out there so if there is, please point me in the direction. </p>
<p>I will be running on Linux and prefer to use Python. I want something smart and easy for someone else to pickup and use/modify.</p>
</div>
<div class="post-text" itemprop="text">
<p>I made something that works with the example files you provided. Note that I didn't handle multiple keys or non-dictionaries in the data. This function accepts a list of the dictionaries obtained after JSON parsing your input files. It uses the fact that <code>re.sub</code> can accept a function for the replacement value and calls that function with each match. I am sure there are plenty of improvements that could be made to this, but it should get you started at least.</p>
<pre><code>def make_config(configs):
    replacements = {}

    def find_defs(config):
        # Find leaf nodes of the dictionary.
        defs = {}
        for k, v in config.items():
            if isinstance(v, dict):
                # Nested dictionary so recurse.
                defs.update(find_defs(v))
            else:
                defs[k] = v
        return defs

    for config in configs:
        replacements.update(find_defs(config))

    def make_replacement(m):
        # Construct the replacement string.
        name = m.group(0).strip('{}')
        if name in replacements:
            # Replace replacement strings in the replacement string.
            new = re.sub('\{[^}]+\}', make_replacement, replacements[name])
            # Cache result
            replacements[name] = new
            return new
        raise Exception('Replacement string for {} not found'.format(name))

    finalconfig = {}
    for name, value in replacements.items():
        finalconfig[name] = re.sub('\{[^}]+\}', make_replacement, value)

    return finalconfig
</code></pre>
<p>With this input:</p>
<pre><code>[
    {
        "global_vars": {
            "BASEDIR": "/app",
            "CONFIG_DIR": "{BASEDIR}/config",
            "LOG_DIR": "{BASEDIR}/log",
            "CONFIG_ARCHIVE_DIR": "{CONFIG_DIR}/archive"
        }
    },
    {
        "name": "Dummy_Process",
        "binary": "java",
        "executable": "DummyProcess-0.1.0.jar",
        "launch_args": "-Dspring.config.location={CONFIG_DIR}/application.yml -Dlogging.config={CONFIG_DIR}/logback-spring.xml -jar {executable}",
        "startup_log": "{LOG_DIR}/startup_{name}.out"
    }
]
</code></pre>
<p>It gives this output:</p>
<pre><code>{
    'BASEDIR': '/app',
    'CONFIG_ARCHIVE_DIR': '/app/config/archive',
    'CONFIG_DIR': '/app/config',
    'LOG_DIR': '/app/log',
    'binary': 'java',
    'executable': 'DummyProcess-0.1.0.jar',
    'launch_args': '-Dspring.config.location=/app/config/application.yml -Dlogging.config=/app/config/logback-spring.xml -jar DummyProcess-0.1.0.jar',
    'name': 'Dummy_Process',
    'startup_log': '/app/log/startup_Dummy_Process.out'
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As an alternative to the answer by @FamousJameous and if you don't mind changing to <code>ini</code> format, you can also use the python built-in <a href="https://docs.python.org/3/library/configparser.html" rel="nofollow noreferrer">configparser</a> which already has support to expand variables.</p>
</div>
<div class="post-text" itemprop="text">
<p>I implemented a solution with a class (Config) with a couple of functions:</p>
<ol>
<li>_load: simply convert from JSON to a Python object;</li>
<li>_extract_params: loop over the document (output of _load) and add them to a class object (self.params);</li>
<li>_loop: loop over the object returned from _extract_params and, if the values contains any {param}, call the _transform method;</li>
<li>_transform: replace the {param} in the values with the correct values, if there is any '{' in the value linked to the param that needs to be replaced, call again the function</li>
</ol>
<p>I hope I was clear enough, here is the code:</p>
<pre><code>import json
import re

config = """{
    "global_vars": {
        "BASEDIR": "/app",
        "CONFIG_DIR": "{BASEDIR}/config",
        "LOG_DIR": "{BASEDIR}/log",
        "CONFIG_ARCHIVE_DIR": "{CONFIG_DIR}/archive"
    }
}"""

process = """{
    "name": "Dummy_Process",
    "binary": "java",
    "executable": "DummyProcess-0.1.0.jar",
    "launch_args": "-Dspring.config.location={CONFIG_DIR}/application.yml -Dlogging.config={CONFIG_DIR}/logback-spring.xml -jar {executable}",
    "startup_log": "{LOG_DIR}/startup_{name}.out"
}
"""
class Config(object):
def __init__(self, documents):
    self.documents = documents
    self.params = {}
    self.output = {}

# Loads JSON to dictionary
def _load(self, document):
    obj = json.loads(document)
    return obj

# Extracts the config parameters in a dictionary
def _extract_params(self, document):
    for k, v in document.items():
        if isinstance(v, dict):
            # Recursion for inner dictionaries
            self._extract_params(v)
        else:
            # if not a dict set params[k] as v
            self.params[k] = v
    return self.params

# Loop on the configs dictionary
def _loop(self, params):
    for key, value in params.items():
        # if there is any parameter inside the value
        if len(re.findall(r'{([^}]*)\}', value)) &gt; 0:
            findings = re.findall(r'{([^}]*)\}', value)
            # call the transform function
            self._transform(params, key, findings)
    return self.output

# Replace all the findings with the correct value
def _transform(self, object, key, findings):
    # Iterate over the found params
    for finding in findings:
        # if { -&gt; recursion to set all the needed values right
        if '{' in object[finding]:
            self._transform(object, finding, re.findall(r'{([^}]*)\}', object[finding]))
        # Do de actual replace
        object[key] = object[key].replace('{'+finding+'}', object[finding])

    self.output = object
    return self.output

# Entry point
def process_document(self):
    params = {}
    # _load the documents and extract the params
    for document in self.documents:
        params.update(self._extract_params(self._load(document)))
    # _loop over the params
    return self._loop(params)

    # return self.output

if __name__ == '__main__':
    config = Config([config, process])
    print(config.process_document())
</code></pre>
<p>I am sure there are many other better ways to reach your goal, but I still hope this can bu useful to you.</p>
</div>
<span class="comment-copy">Without looking too much at overall improvements, you can fix the CONFIG_ARCHIVE_DIR issue by changing that line to: <code>"CONFIG_ARCHIVE_DIR": "{BASE_DIR}/config/archive"</code>, since the only part of <code>CONFIG_DIR</code> that is variable is <code>{BASE_DIR}</code>, and then you tack on the fixed string '/config' to it.</span>
<span class="comment-copy">You should probably look at 3rd party packages like xpath or jsonpath.</span>
