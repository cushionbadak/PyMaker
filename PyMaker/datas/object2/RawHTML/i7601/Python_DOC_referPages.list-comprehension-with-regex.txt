<div class="post-text" itemprop="text">
<p>I am learning from Jacob Perkins's book.I do not understand this example</p>
<pre><code>import re
replacement_patterns = [
(r'won\'t', 'will not'),
(r'can\'t', 'cannot'),
(r'i\'m', 'i am'),
(r'ain\'t', 'is not'),
(r'(\w+)\'ll', '\g&lt;1&gt; will'),
(r'(\w+)n\'t', '\g&lt;1&gt; not'),
(r'(\w+)\'ve', '\g&lt;1&gt; have'),
(r'(\w+)\'s', '\g&lt;1&gt; is'),
(r'(\w+)\'re', '\g&lt;1&gt; are'),
(r'(\w+)\'d', '\g&lt;1&gt; would')
]
</code></pre>
<p>Now we have</p>
<pre><code>class RegexpReplacer(object):
    def __init__(self, patterns=replacement_patterns):
        self.patterns = [(re.compile(regex), repl) for (regex, repl) in patterns]
</code></pre>
<p>What does this list comprehension serve for?What does repl stands for?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>repl</code> stands for <code>replacement</code>. It is just a variable name; <code>repl</code> has no special meaning.</p>
<p>The (incomplete) code you have provided is presumably going to make a bunch of replacements on a given string. It will replace <code>won't</code> with <code>will not</code>; <code>can't</code> with <code>cannot</code>; <code>i'm</code> with <code>i am</code>; etc.</p>
<p>The more complex replacements, such as <code>(\w+)'d --&gt; \g&lt;1&gt; would</code> are using <a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow noreferrer">back-references</a> to capture part of the matched pattern, for use in the replacement.</p>
<p>The code: <code>(re.compile(regex), repl) for (regex, repl) in patterns</code> is using <a href="http://www.secnetix.de/olli/Python/list_comprehensions.hawk" rel="nofollow noreferrer"><code>list-comprehension</code></a> to <a href="https://docs.python.org/3/library/re.html#re-objects" rel="nofollow noreferrer">compile</a> the regular expressions.</p>
</div>
<div class="post-text" itemprop="text">
<p>repl is just a variable referring to the 2nd part of the <code>tuple</code> so lets say you have a list with <code>[(1, 2), (3, 4)]</code> and you want to create a <code>list-comprehension</code> to make a new <code>list</code> by adding <code>1</code> to the 2nd number in each tuple, you would do something like: </p>
<pre><code>[(x, y+1) for (x, y) in lst]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I qoute:</p>
<blockquote>
<p>Python supports a concept called "list comprehensions". It can be used to construct lists in a very natural, easy way, like a mathematician is used to do. </p>
</blockquote>
<p>A list comprehension can be with a condition. List comprehensions can have multiple conditions.</p>
<p>The general format for a list comprehension with a if condition is this,</p>
<pre><code>[&lt;expression&gt; for &lt;value&gt; in &lt;iterable&gt; if &lt;condition&gt;]
</code></pre>
<p>You can also have an if..else in the comprehension</p>
<pre><code>[&lt;expression&gt; if &lt;condition&gt; else &lt;expression&gt; for &lt;value&gt; in &lt;iterable&gt; ]
</code></pre>
<p>NOTE: Your iterable can be list,tuple,set,string,...etc</p>
<p>To make things clear consider this simple example,</p>
<pre><code>&gt;&gt;&gt; v = [1,2,3,4]
&gt;&gt;&gt; v
[1, 2, 3, 4]
</code></pre>
<p>v and x are two lists.</p>
<pre><code>&gt;&gt;&gt; x = [1,2]
&gt;&gt;&gt; x
[1, 2]
</code></pre>
<p>Now suddenly you decide I want a list <code>new_list</code> which has items from v but not in x. Hmmm... How to do that? Take a look below.</p>
<pre><code>&gt;&gt;&gt; new_list = [item for item in v if item not in x]
&gt;&gt;&gt; x
[3, 4]
</code></pre>
<p>Notice how I've used <code>item</code>. I just created that inside the list comprehension. Similarly <code>repl</code> just a variable name. Meaning <code>**Replacement_string**</code></p>
<p>Why I told all that? You'll get that in a moment.</p>
<p>And now we come to <code>re</code> </p>
<pre><code>pattern= r'won\'t' #can also be r"won't" \ just to escape the ' (single quotes)

# then, much later in your code you can do

m = re.match(pattern, input)

#Look how I'm using the pattern
</code></pre>
<p>But <code>re.compile()</code></p>
<pre><code>pattern = re.compile(r'won\'t')

# then, later in your code

m = pattern.match(input)
</code></pre>
<p>You see here we compile the <code>regex pattern</code> and then find a match. In the former we are just giving it as a parameter to <code>re.match()</code>.</p>
<p>Note:</p>
<pre><code>def __init__(self, patterns=replacement_patterns):
</code></pre>
<p><strong>replacement_patterns --&gt; patterns</strong></p>
<p>(Now <code>patterns</code> and <code>replacement_patters</code> both are aliases to your <code>list of tuples</code>)</p>
<p>Both does the same however the, So coming to your confusion,</p>
<pre><code>[(re.compile(regex), repl) for (regex, repl) in patterns]
</code></pre>
<p>This list comprehension gets all tuples from your <strong>list of tuples</strong> known as ? <code>patterns</code>
Initially:</p>
<pre><code>(regex, repl)--&gt;(r'won\'t', 'will not')
</code></pre>
<p>and so on  for every tuple items. And  this is converted to:</p>
<pre><code>(r'won\'t', 'will not') --&gt; (re.compile(r'won\'t'),'will not')
</code></pre>
<p>So basically your list comprehension converts the </p>
<p><code>tuple(pattern,replacement_string) to tuple(compiled_re,replacement_string)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Reference:<br/>
<a href="https://www.python.org/dev/peps/pep-0202/" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-0202/</a>
<a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions</a></p>
<p>To help understand:</p>
<pre><code>test = [('a', 1), ('b', 2), ('c', 3)]
for item in test:
    print item
for key, index in test:
    print key, index

print [key + str(index) for key, index in test]
</code></pre>
</div>
<span class="comment-copy">Are you familiar with how list comprehensions work? Inside that comprehension the <code>regex</code> is for the first part of your tuple, and the <code>repl</code> is for that string component, which is the second part of your tuple when iterating over <code>patterns</code>.</span>
<span class="comment-copy">@idjaw So If I change repl with other variable,it does serve for purpose?</span>
<span class="comment-copy">@fabiano.mota <code>repl</code> is just a name. You can change it to anything you want (although it's advisable to avoid built-in names), as long as you change both occurrences.</span>
<span class="comment-copy">I strongly suggest you learn how list comprehensions work. The naming serves no functional purpose. It is simply providing a <i>name</i> to the items you are iterating over. You could have named it "asdfasdfasdf" and it would have not made a single difference other than annoy the other developers having to deal with your random naming conventions :) .</span>
<span class="comment-copy">OK.I understand now.</span>
