<div class="post-text" itemprop="text">
<p>I have a list of lists in Python, and I'd like to corral them into a more coherent ordered dictionary.</p>
<p>The data is of the form:</p>
<pre><code>[
 ['1_1', '2_1', '3_1', '4_1'],
 ['1_1', '2_1', '3_2', '4_1'],
 ['1_1', '2_2', '3_1', '4_1'],
 ['1_1', '2_2', '3_1', '4_2'],
 ['1_1', '2_2', '3_1', '4_3'],
 ['1_1', '2_2', '3_2', '4_1', '5_1'],
 ['1_1', '2_2', '3_2', '4_2', '5_1'],    
 ['1_1', '2_2', '3_2', '4_2', '5_2'],
 and so on...
]
</code></pre>
<p>Ultimately, what I'm looking to get is some sort of dictionary structure by marching through the list and categorizing based off of same items at the first, second, third, and so on levels.</p>
<p>I've been playing around with <code>groupby</code> in order to try this with code like:</p>
<pre><code>_map = OrderedDict()
for key, group in groupby(big_list, lambda x: x[0]):  
    _map[key] = [l[1:] for l in group]
</code></pre>
<p>This works for the first level, but I'm stuck on how to recurse through the structure in order to do the same sort of grouping at progressively deeper levels.</p>
<p>Any thoughts would be appreciated!</p>
<p>EDIT: Judging by the downvotes, I guess this wasn't a good question? I thought the expected output was clear from my description, but to be explicit, I was looking for a tree pretty similar to what Delgan's code produces:</p>
<pre><code>{'1_1': {'2_1': {'3_1': {'4_1': {}}, '3_2': {'4_1': {}}},
         '2_2': {'3_1': {'4_1': {}, '4_2': {}, '4_3': {}},
                 '3_2': {'4_1': {'5_1': {}},
                         '4_2': {'5_1': {},
                                 '5_2': {}}
                        }
                }
        }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You really do not need <a href="https://docs.python.org/3.6/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby()</code></a>.</p>
<p>This can be much simpler: just populate your dictionary iteratively while iterating trough your data.</p>
<p>You may use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault()</code></a> for convenience too. This avoid having to check to see if the key is already present in your nested dictionary.</p>
<pre><code>map_ = {}  # Note the trailing instead of leading underscore here

for sub_list in big_list:
    dct = map_
    for item in sub_list:
        # Retrieve existing sub dict, or create a new one
        dct = dct.setdefault(item, {})

print(map_)
</code></pre>
<p>This is actually creating a <a href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="nofollow noreferrer">tree</a>. The leaf elements are empty dictionaries which can be populated later.</p>
</div>
<span class="comment-copy">You haven't provided your expected output, so it's hard to say...</span>
<span class="comment-copy">It's not at all clear what you mean.  The structure you see in your data isn't clear unless you explain it or give examples of input <i>and</i> output.</span>
<span class="comment-copy">It feels like that the data you have would be better categorized/segmented in a tree-like structure. Your tree root is going to be '1_1'. It'll have two children: '2_1' and '2_2' and so on. For each new list you'll create a node under an appropriate branch. This way you data is going to be hierarchically categorized.</span>
<span class="comment-copy">@StevenRumbalski I do not understand your statement. This code creates a graph of any depth, depending on the input sublists. The output is like <code>{'1_1': {'2_2': {'3_1': {'4_3': {} ...}</code>.</span>
<span class="comment-copy">Fair enough.  I retract my objection.</span>
