<div class="post-text" itemprop="text">
<p>I have a list, from which I would like to iterate over slices of a certain length, overlapping each other by the largest amount possible, for example:</p>
<pre><code>&gt;&gt;&gt; seq = 'ABCDEF'
&gt;&gt;&gt; [''.join(x) for x in zip(seq, seq[1:], seq[2:])]
['ABC', 'BCD', 'CDE', 'DEF']
</code></pre>
<p>In other words, is there a shorthand for <code>zip(seq, seq[1:], seq[2:])</code> where you can specify the length of each sub-sequence?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>[seq[i:i+3] for i in range(len(seq)-2)]</code> is the Python code for something similar.</p>
<p>The far more elegant and recommended version of this is to use the <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a> library from Python (seriously, why do they not just include this function in the library?).</p>
<p>In this case, you would instead use something similar to the <code>pairwise</code> function provided in the documentation.</p>
<pre><code>from itertools import tee
def tripletWise(iterable):
    "s -&gt; (s0,s1,s2), (s1,s2,s3), (s2,s3,s4), ..."
    a, b, c = tee(iterable, 3)
    next(b, None)
    next(c, None)
    next(c, None)
    return zip(a, b)

[''.join(i) for i in tripletWise('ABCDEF')]
&gt; ['ABC', 'BCD', 'CDE', 'DEF']
</code></pre>
<p>You can also create a more general function to chunk the list into however many elements you want to select at a time.</p>
<pre><code>def nWise(iterable, n=2):
    iterableList = tee(iterable, n)
    for i in range(len(iterableList)):
        for j in range(i):
            next(iterableList[i], None)
    return zip(*iterableList)

[''.join(i) for i in nWise('ABCDEF', 4)]
&gt; ['ABCD', 'BCDE', 'CDEF']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not an elegant solution, but this works:</p>
<pre><code>seq = 'ABCDEF'
n=3
[seq[i:i+n] for i in range(0, len(seq)+1-n)]
</code></pre>
</div>
