<div class="post-text" itemprop="text">
<p>Fermi Dirac statistics implies that the number of microstates within a macrostate for distinguishable particles follows an equation of the form:</p>
<p>Combinations = m!/((m-N)!N!</p>
<p>Pretending m is the number of bouncy balls in a container, and N is the number of bouncy balls you're taking out, this tells us how many unique ways you can take out N balls for N &lt; m.</p>
<p>I'm trying to write a code in python to read out each combination, and need some help. So far all I have is the script telling me how many combinations there are. If m = 4 and N = 2, there are 6 combinations. I need to write a code that tells me that those combinations are the first and second, first and third, first and forth, second and third, second and forth, and third and forth. Now for small m this is easy to do by hand but you can see this gets monotonous fast. Can someone help me write a script to do this?</p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>import math
print 'Enter a Value for m'
m = int(raw_input());
print 'Enter a Value for N'
N = int(raw_input());

print math.factorial(m)/(math.factorial(m-N)*math.factorial(N))</code></pre>
</div>
</div>
</p>
</div>
<div class="post-text" itemprop="text">
<p>This is trivial using itertools.combinations</p>
<pre><code>import itertools

M=4
N=2

for combo in itertools.combinations(range(M),N):
    print combo
</code></pre>
<p>Output:</p>
<pre><code>(0, 1)
(0, 2)
(0, 3)
(1, 2)
(1, 3)
(2, 3)
</code></pre>
<p>Itertools docs for Python 2.7: <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow noreferrer">https://docs.python.org/2/library/itertools.html</a>
Itertools docs for Python 3.6: <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a quick sketch of an algorithm that should handle this.</p>
<pre><code>def combinations(currentPosition, maxPosition, numToInclude):
    if numToInclude = 0 or currentPosition &gt; maxPosition:
        return [[]]
    finalList = []
    listOfCombinations = combinations(currentPosition+1,maxPosition,numToInclude-1)
    for i in range(len(listOfCombinations)):
        finalList[2*i] = [1] + listOfCombinations[i]
        finalList[2*i+1] = [0] + listOfCombinations[i]
    return finalList
</code></pre>
</div>
<span class="comment-copy">ps. if you downvote, it be really helpful to know why so that I don't ask poorly worded questions!</span>
<span class="comment-copy">I'd just write some little recursive algorithm if you don't need to really optimize performance</span>
<span class="comment-copy">Or use itertools combinations()</span>
<span class="comment-copy">You changed the question completely. If you have a different question, create a new question.</span>
<span class="comment-copy">My friend thought it would be hilarious to change my question completely. I'm sorry about that everyone</span>
<span class="comment-copy">Wow this is like a cheat code! Thank you!</span>
<span class="comment-copy">Thank you! I'll give it a try!</span>
<span class="comment-copy">Use itertools.combinations. It is in the standard library. There is even pseudocode for it.</span>
<span class="comment-copy">Can you explain this algorithm a little bit? I'm having a hard time incorporating my problem into it.</span>
<span class="comment-copy">That's why you should use itertools.combinations. No coding required by you, therefore no possibility of errors being introduced by you, or by its author (no disrespect intended, Erik).</span>
<span class="comment-copy">No disrespect received barny. If I always wrote perfect code, I'd be making a lot more money then I am.</span>
