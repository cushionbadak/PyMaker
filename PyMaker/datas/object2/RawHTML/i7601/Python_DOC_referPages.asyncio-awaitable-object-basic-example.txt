<div class="post-text" itemprop="text">
<p>I'm trying to understand how to make an awaitable object. The definition from the <a href="https://www.python.org/dev/peps/pep-0492/#await-expression" rel="noreferrer">documentation</a> states:</p>
<blockquote>
<p>An object with an __await__ method returning an iterator.</p>
</blockquote>
<p>Guided by that definition I wrote the sample code:</p>
<pre><code>import asyncio

async def produce_list():
        num = await Customer()
        print(num)

class Customer(object):

    def __await__(self):
        return iter([1, 2, 3, 4])

loop = asyncio.get_event_loop()
loop.run_until_complete(produce_list())
</code></pre>
<p>The flow that I expected was:</p>
<ol>
<li>Event loop gives control to <code>produce_list()</code>. <code>produce_list()</code> gives up execution on <code>num = await Customer()</code>.</li>
<li><code>Customer()</code> is executed and returns an iterator. Which because returns the first value in the iterator. <strong><em>Q1:</em></strong> am not clear here why <code>num</code> isn't becoming the iterator itself. Also what is doing a <code>send</code> here?</li></ol></div>
<div class="post-text" itemprop="text">
<p><code>__await__</code> returns an iterator because the underlying mechanism for coroutines is originally based on the <code>yield from</code> syntax. In practice, <code>__await__</code> returns either <code>iter(some_future)</code> or <code>some_coroutine.__await__()</code>. It can be used to create objects that produce different values every time they are awaited. See this simple example:  </p>
<pre><code>import asyncio
import random

class RandomProducer:

    def __await__(self):
        return self.producer().__await__()

    async def producer(self):
        sleep = random.random()
        value = random.randint(0, 9)
        return await asyncio.sleep(sleep, result=value)

async def main():
    producer = RandomProducer()
    while True:
        print(await producer)

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</code></pre>
<hr/>
<p>To answer your comments:</p>
<blockquote>
<p>Does every coroutine eventually ends up calling <code>asyncio.sleep</code>? </p>
</blockquote>
<p>No, and <code>asyncio.sleep</code> is actually not the end of the chain. At the very bottom, it's always a future that is being yielded: the coroutine chain asks the event loop "please wake me up when this future has a result". In the case of <code>asyncio.sleep</code>, it uses <code>loop.call_later</code> to set the result of the future after a given amount of time. The loop provides more methods for scheduling callbacks: <code>loop.call_at</code>, <code>loop.add_reader</code>, <code>loop.add_writer</code>, <code>loop.add_signal_handler</code>, etc. </p>
<blockquote>
<p>An asyncio library such as aiohttp. I'm assuming there is some code somewhere that doesn't rely on existence of previous coroutines.</p>
</blockquote>
<p>All the IO operations have to end up delegating to the event loop in order to achieve single-threaded concurrency.
For instance, aiohttp relies on the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_connection" rel="nofollow noreferrer">loop.create_connection</a> coroutine to <a href="https://github.com/aio-libs/aiohttp/blob/a05fa9e7f61b6af0170d3a86c9117c5c5baff642/aiohttp/connector.py#L705-L710" rel="nofollow noreferrer">manage the TCP connection</a>.</p>
</div>
<span class="comment-copy">I'm actually trying to get an example that in the end doesn't call an previously defined asyncio lib method. In the end you're passing the <code>await asyncio.sleep(sleep, result=value)</code>. The motivation is to try an understand how would one approach the writing of a new asyncio framework.</span>
<span class="comment-copy">Or perhaps to rephrase it. Does every coroutine eventually ends up calling <code>asyncio.sleep</code>?</span>
<span class="comment-copy">@TheMeaningfulEngineer <code>how would one approach the writing of a new asyncio framework.</code> Do you mean an asyncio library such as <a href="http://aiohttp.readthedocs.io/en/stable/" rel="nofollow noreferrer">aiohttp</a> or an asyncio alternative such as <a href="https://github.com/dabeaz/curio" rel="nofollow noreferrer">curio</a>? Also, see my edit.</span>
<span class="comment-copy">An asyncio library such as aiohttp. I'm assuming there is some code somewhere that doesn't rely on existence of previous coroutines (which was what I was trying to achieve with the <code>Customer</code> example.</span>
<span class="comment-copy">@TheMeaningfulEngineer See my edit.</span>
