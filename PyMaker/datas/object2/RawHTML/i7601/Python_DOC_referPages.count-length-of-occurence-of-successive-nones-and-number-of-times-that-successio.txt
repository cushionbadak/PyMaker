<div class="post-text" itemprop="text">
<p>I have a list <code>r = [1,2,3,None,None,4,None,5]</code> I want to know the number of times the None occur and the length. This should give me:</p>
<ul>
<li>[2, 1] and 2</li>
</ul>
<hr/>
<p>I wrote the following code:</p>
<pre><code>#!/usr/bin/env python
def compute_stats():
    r = [1,2,3,None,None,4,None,5]
    length = []
    counter = 0
    i = 0
    while i &lt; len(r):
        if r[i] == None:
            j = i
            l = 0
            while j &lt; len(r) and r[j] == None:   
                l += 1
                j += 1

            length.append(l)
            counter+= 1
            i = j + 1
        else:
            i += 1
    print str(r) +" length: " + str(length) +" counter " + str(counter)



if __name__ == "__main__":
    compute_stats()
</code></pre>
<hr/>
<p>as output I am getting the following </p>
<pre><code> [1, 2, 3, None, None, 4, None, 5] length: [2, 1] counter 2
</code></pre>
<hr/>
<p>The code works good. But is there a more beautiful way to do it in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code> object</a> to both group the consecutive <code>None</code> values, and to count the group length:</p>
<pre><code>[sum(1 for _ in g) for k, g in groupby(input) if k is None]
</code></pre>
<p>Since <code>g</code> is a iterator of unknown length, I used <code>sum()</code> to avoid materialising that into a list; that could be quite memory intensive otherwise. If you are 100% certain that your groups of consecutive <code>None</code> objects is small (a few hundred at most) it <em>may</em> be faster to just use <code>len(list(g))</code> instead.</p>
<p>The default behaviour for <code>groupby()</code> is to produces groups of <em>identical objects</em>, so consecutive objects for which an <code>is</code> test is true. This is ideally suited for <code>None</code> values. For each group, a <code>k</code> and a dependent iterator are produced, with <code>k</code> set to the common group object; if <code>k</code> is <code>None</code> you know you have a series of consecutive <code>None</code> objects on hand.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to group consecutive similar items, and filter out those whose group key is <code>not None</code>:</p>
<pre><code>from itertools import groupby

lst = [1,2,3,None,None,4,None,5]
cnt = [len(list(g)) for k, g in groupby(lst) if k is None]
print(cnt, len(cnt))
# [2, 1], 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import groupby

r = [1,2,3,None,None,4,None,5]

[len(list(g)) for k, g in groupby(r) if k is None]
</code></pre>
</div>
