<div class="post-text" itemprop="text">
<p>I'm creating a bunch of components in my project, each of them will be running in different threads.<br/>
They will communicate through <code>queue.Queue</code>. I would like to define all the different queues, which is classes that extends <code>queue.Queue</code>. Each of them will be singleton object, so the different components can just import that class, and get the instance.    </p>
<p>I put everything in one file:</p>
<pre><code>from queue import Queue

class QueueAudio(Queue):

    def __new__(cls, *args, **kwargs):
        """
        Singleton Queue
        """
        if '_inst' not in vars(cls):
            cls._inst = object.__new__(cls, *args, **kwargs)
            print('Creating {}'.format(cls.__name__))
        return cls._inst

class AudioInput(object):

    def __init__(self):
        self.queue = QueueAudio()
        print(self.queue)

    def run(self):
        self.queue.put('Input Audio')


class Interpretor(object):

    def __init__(self):
        self.queue = QueueAudio()
        print(self.queue)

    def run(self):
        print(self.queue.get())

audio = AudioInput()
audio.run()
interpretor = Interpretor()
interpretor.run()
</code></pre>
<p>In the constructor of the two components (<code>AudioInput</code> and <code>Interpretor</code>) I print the object, to make sure they are the same.
<code>AudioInput</code> put a string in the queue, and <code>Interpretor</code> reads it. However, the queue in <code>Interpretor</code> is always empty, making the program hangs forever.
Here's the output of the program:  </p>
<pre><code>Creating QueueAudio
&lt;__main__.QueueAudio object at 0x103234c18&gt;
&lt;__main__.QueueAudio object at 0x103234c18&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I solve my problem by using another method to define my class as a singleton : </p>
<pre><code>class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class QueueAudio(Queue, metaclass=Singleton):
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What's happening here is that after your <code>__new__</code> function returns the queue object, python implicitly calls <code>__init__</code> on it. This resets the queue and any items you've previously added are removed.</p>
<p>From the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">docs on <code>__new__</code></a>:</p>
<blockquote>
<p>If <code>__new__()</code> returns an instance of cls, then the new instanceâ€™s
  <code>__init__()</code> method will be invoked [...]</p>
</blockquote>
<p>Step by step, this is what happens:</p>
<pre><code>audio = AudioInput()        # creates an empty queue
audio.run()                 # adds a value to the queue
interpretor = Interpretor() # implicit call to Queue.__init__ resets queue
interpretor.run()           # queue is empty, call blocks
</code></pre>
<hr/>
<p>This is a common problem when implementing singletons with <code>__new__</code>. You can work around this by using a metaclass, or by using a different function to get the queue singleton:</p>
<pre><code>class QueueAudio(Queue):
    @classmethod
    def new(cls):
        if '_inst' not in vars(cls):
            cls._inst = cls()
            print('Creating {}'.format(cls.__name__))
        return cls._inst

# create a queue instance with "QueueAudio.new()"
</code></pre>
</div>
