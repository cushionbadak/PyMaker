<div class="post-text" itemprop="text">
<p>The output of</p>
<pre><code>d = {1: 1}
for k in d.keys():
    d['{}'.format(k)] = d.pop(k)
print(d)
</code></pre>
<p>is <code>{'1': 1}</code>. The output of</p>
<pre><code>d = {1: 1}
for k in d.keys():
    d['i{}'.format(k)] = d.pop(k)
print(d)
</code></pre>
<p>is <code>{'iiiii1': 1}</code>. Is this a bug? I am running <code>Python 3.6.1 :: Anaconda 4.4.0 (x86_64)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, this is not a bug. This is in fact <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="noreferrer">explicitly documented</a>:</p>
<blockquote>
<p>Keys and values are iterated over in an arbitrary order which is non-random, varies across Python implementations, and depends on the dictionaryâ€™s history of insertions and deletions. If keys, values and items views are iterated over with no intervening modifications to the dictionary, the order of items will directly correspond.</p>
<p><em>[...]</em></p>
<p><strong>Iterating views while adding or deleting entries in the dictionary may raise a <code>RuntimeError</code> or fail to iterate over all entries.</strong></p>
</blockquote>
<p>Bold emphasis mine.</p>
<p>You are iterating over the keys, while at the same time both adding and deleting entries in the dictionary. That worked for a few iterations, and then you hit a <em>fail to iterate over all entries</em> case and iteration stopped.</p>
<p>What happens is that you trigger a re-size at 6 additions, and that causes iteration to fail at that point; the 'next' key is now slotted in an 'earlier' slot. This happens for <em>both</em> tests, you just don't realise it iterates 5 times in both cases:</p>
<pre><code>&gt;&gt;&gt; d = {1: 1}
&gt;&gt;&gt; for i, k in enumerate(d):
...     print(i)
...     d['{}'.format(k)] = d.pop(k)
...
0
1
2
3
4
&gt;&gt;&gt; d = {1: 1}
&gt;&gt;&gt; for i, k in enumerate(d):
...     print(i)
...     d['i{}'.format(k)] = d.pop(k)
...
0
1
2
3
4
</code></pre>
<p>It is run 5 times because the current <code>dict</code> implementation starts with a <a href="https://github.com/python/cpython/blob/v3.6.1/Objects/dictobject.c#L103-L110" rel="noreferrer">hash table of size 8</a>, and a resize is triggered <a href="https://github.com/python/cpython/blob/v3.6.1/Objects/dictobject.c#L374-L385" rel="noreferrer">when the table is 2/3s full</a> (your initial dict has 1 entry, 5 insertions make it <code>&gt; (8 * 2/3 == 5.333333)</code>. The table is getting filled with <a href="https://github.com/python/cpython/blob/v3.6.1/Objects/dictobject.c#L76-L81" rel="noreferrer"><code>DKIX_DUMMY</code> entities</a>, entered when you delete a key (needed to handle hash collisions correctly).</p>
<p>Note that this is all highly implementation dependent. In Python 3.5 and before, both snippets iterate just once (even if you use <code>for k in d:</code> to avoid creating a list object for the keys); iteration continues in 3.6 because the implementation changed and iteration now follows insertion order. Future Python versions are free to alter the implementation again.</p>
</div>
<span class="comment-copy">Why would that be a bug? You are removing and adding keys <i>as you iterate</i>. You are lucky you didn't end up in an endless loop.</span>
<span class="comment-copy">Never <i>alter</i> a collection while <i>iterating</i> over it. Especially not dictionaries, since it can lead to weird behavior.</span>
<span class="comment-copy">@user2725109: how do you know that that first loop only ran once? For all you know it ran 1000 times.</span>
<span class="comment-copy">@user2725109: the second can have run 1000s of times: simply replacing the key for an identical one until finally the iteration ends.</span>
<span class="comment-copy">Please don't change the question when there are answers.  It invalidates the answer</span>
