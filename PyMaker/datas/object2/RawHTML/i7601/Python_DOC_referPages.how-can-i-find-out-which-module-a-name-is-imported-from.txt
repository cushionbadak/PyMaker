<div class="post-text" itemprop="text">
<p>In a Python program, if a name exists in the namespace of the program, is it possible to find out if the name is imported from some module, and if yes, which module it is imported from?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can see which module a function has been defined in via the <code>__module__</code> attribute. <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">From the Python Data model documentation on <code>__module__</code></a>:</p>
<blockquote>
<p>The name of the module the function was defined in, or None if unavailable.</p>
</blockquote>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; from re import compile
&gt;&gt;&gt; compile.__module__
're'
&gt;&gt;&gt; def foo():
...     pass
... 
&gt;&gt;&gt; foo.__module__
'__main__'
&gt;&gt;&gt;
</code></pre>
<p><a href="https://docs.python.org/3/reference/datamodel.html#index-48" rel="nofollow noreferrer">The Data model later mentions</a> that classes have the same attribute as well:</p>
<blockquote>
<p><code>__module__</code> is the module name in which the class was defined.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; datetime.__module__
'datetime'
&gt;&gt;&gt; class Foo:
...     pass
... 
&gt;&gt;&gt; Foo.__module__
'__main__'
&gt;&gt;&gt; 
</code></pre>
<p>You can also do this with builtin names such as <code>int</code> and <code>list</code>. You can accesses them from the <code>builtins</code> module.</p>
<pre><code>&gt;&gt;&gt; int.__module__
'builtins'
&gt;&gt;&gt; list.__module__
'builtins'
&gt;&gt;&gt; 
</code></pre>
<hr/>
<blockquote>
<p>I can use <code>int</code> and <code>list</code> without <code>from builtins import int, list</code>. So how do <code>int</code> and <code>list</code> become available in my program?</p>
</blockquote>
<p>That is because <code>int</code> and <code>list</code> are builtin names. You don't have to explicitly import them for Python to be able to find them in the current namespace. You can see this for yourself in the <a href="https://github.com/python/cpython/blob/master/Python/ceval.c#L2294" rel="nofollow noreferrer">CPython virtual machine source code</a>. As @user2357112 mentioned, builtin names are accessed when global lookup fails. Here's the relevant snippet:</p>
<pre><code>if (v == NULL) {
    v = PyDict_GetItem(f-&gt;f_globals, name);
    Py_XINCREF(v);
    if (v == NULL) {
        if (PyDict_CheckExact(f-&gt;f_builtins)) {
            v = PyDict_GetItem(f-&gt;f_builtins, name);
            if (v == NULL) {
                format_exc_check_arg(
                            PyExc_NameError,
                            NAME_ERROR_MSG, name);
                goto error;
            }
            Py_INCREF(v);
        }
        else {
            v = PyObject_GetItem(f-&gt;f_builtins, name);
            if (v == NULL) {
                if (PyErr_ExceptionMatches(PyExc_KeyError))
                    format_exc_check_arg(
                                PyExc_NameError,
                                NAME_ERROR_MSG, name);
                goto error;
            }
        }
    }
}
</code></pre>
<p>In the code above, CPython first searches for a name in the global scope. If that fails, then it falls back and attempts to get the name from a mapping of builtin names in the current frame object its executing. That's what <code>f-&gt;f_builtins</code> is.</p>
<p>You can observe this mapping from the Python level using <a href="https://docs.python.org/3/library/sys.html#sys._getfram" rel="nofollow noreferrer"><code>sys._getframe()</code></a>:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; frame = sys._getframe()
&gt;&gt;&gt; 
&gt;&gt;&gt; frame.f_builtins['int']
&lt;class 'int'&gt;
&gt;&gt;&gt; frame.f_builtins['list']
&lt;class 'list'&gt;
&gt;&gt;&gt; 
</code></pre>
<p><code>sys._getframe()</code> returns the frame at the top of the call stack. In this case, its the frame for the module scope. And as you can see from above, the <code>f_builtins</code> mapping for the frame contains both the <code>int</code> and <code>list</code> classes, so Python has automatically made those names available to you. In other words, it's "built" them into the scope; hence the term <em>"builtins"</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If for some reason the source is unavailable, you could use <a href="https://docs.python.org/3/library/inspect.html#inspect.getmodule" rel="nofollow noreferrer"><code>getmodule</code></a> from <code>inspect</code> which tries its best to find the module by grabbing <code>__module__</code> if it exists and then falling back to other alternatives. </p>
<p>If everything goes o.k, you get back a module <em>object</em>. From that, you can grab the <code>__name__</code> to get the actual name of the module:</p>
<pre><code>from inspect import getmodule
from collections import OrderedDict
from math import sin    

getmodule(getmodule).__name__
'inspect'
getmodule(OrderedDict).__name__
'collections'
getmodule(sin).__name__
'math'
</code></pre>
<p>If it doesn't find anything, it returns <code>None</code> so you'd have to special case this. In general this encapsulates the logic for you so you don't need to write a function yourself to actually grab <code>__module__</code> if it exists.</p>
<p>This doesn't work for objects that don't have this information attached. You can, as a fall-back, try and pass in the type to circumvent it:</p>
<pre><code>o = OrderedDict()
getmodule(o)                # None
getmodule(type(0)).__name__ # 'collections'
</code></pre>
<p>but that won't always yield the correct result:</p>
<pre><code>from math import pi
getmodule(type(pi)).__name__ 
'builtins'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some objects (but far from all) have an attribute <a href="https://docs.python.org/3/reference/datamodel.html" rel="noreferrer">__module__</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unless code is doing something unusual like updating <em>globals</em> directly, the source code should indicate where every variable came from:</p>
<pre><code>x = 10                         # Assigned in the current module
from random import randrange   # Loaded from random
from functools import *        # Loads everything listed in functools.__all__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also look at <a href="https://docs.python.org/3/library/functions.html#globals" rel="nofollow noreferrer"><code>globals()</code></a>, it will output a dict with all the names python uses BUT also the variable, modules and functions you declared inside the namespace.</p>
<pre><code>&gt;&gt;&gt; x = 10
&gt;&gt;&gt; import os
&gt;&gt;&gt; globals() # to big to display here but finish with 
# {... 'x': 10, 'os': &lt;module 'os' from '/usr/local/lib/python2.7/os.py'&gt;}
</code></pre>
<p>Therefore, you can test if variable were declared like this:</p>
<pre><code>if globals()['x']:
  print('x exist')

try:
  print(globals()['y'])
except KeyError:
  print('but y does not')

# x exist
# but y does not
</code></pre>
<p>Works also with modules:</p>
<pre><code>print(globals()['os']) # &lt;module 'os' from '/usr/local/lib/python2.7/os.py'&gt;

try:
  print(globals()['math'])
except KeyError:
  print('but math is not imported')

# &lt;module 'os' from '/usr/local/lib/python2.7/os.py'&gt;
# but math is not imported
</code></pre>
</div>
<span class="comment-copy">Thanks. Is it possible to find out which module the builtin types such as <code>int</code> and <code>list</code> are imported from?</span>
<span class="comment-copy">@Tim Yup. Try <code>int.__module__</code> and <code>list.__module__</code> in your REPL. There defined in the <code>builtins</code> module.</span>
<span class="comment-copy">I can use <code>int</code> and <code>list</code> without <code>from builtins import int,list</code>. So how do <code>int</code> and <code>list</code> become available in my program?</span>
<span class="comment-copy">@Tim Because <code>int</code> and <code>list</code> are builtin names in Python. You don't have to explicitly import them.</span>
<span class="comment-copy">@Tim: They're not imported from anywhere. While there is technically a <code>__builtin__</code> or <code>builtins</code> (version-dependent) module that uses the built-in namespace as its module namespace, the reason built-in names are available to you isn't through any sort of import, and saying that <code>builtins</code> is where those types are defined is questionable.</span>
<span class="comment-copy">Thanks. If your source code have several import statements <code>from ... import *</code>,, how can you tell which module a variable comes from?</span>
<span class="comment-copy">The "from somemod import ** statements lose all tracking of which module the variables came from.  However, you can run your own "import somemod" in addition to the from-imports and proceed as listed above.</span>
<span class="comment-copy">Thanks. Why do you use <code>print(globals())</code> instead of <code>globals()</code>?</span>
<span class="comment-copy">I'm not using a python console while making tests, that's why I need <code>print</code>, but I could remove it if it ease your readability.</span>
