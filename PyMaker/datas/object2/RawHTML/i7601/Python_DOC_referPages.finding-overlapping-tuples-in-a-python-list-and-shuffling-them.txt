<div class="post-text" itemprop="text">
<p>I have the following list of tuples in Python3.x, whereby each tuple consists of two integers in the format <code>(start, end)</code>:</p>
<pre><code>list_tuple = [(20, 35), (125, 145), (156, 178), (211, 233), (220, 321), 
                              (227, 234), (230, 231), (472, 498), (4765, 8971)] 
 ## list already sorted except for last tuple
</code></pre>
<p>This of the tuples as intervals along a real line, e.g. <code>(1,10)</code> is an interval from 1 to 10. </p>
<p>There are three ways I could sort this tuple, either by the first element alone, by the second element alone, or by the first and second element. </p>
<p>Sorting by the first element alone:</p>
<pre><code>sorted_by_first = sorted(list_tuple, key=lambda element: (element[0]) )  ## (first_element, second_element)
</code></pre>
<p>which outputs</p>
<pre><code>print(sorted_by_first)
[(20, 35), (125, 145), (156, 178), (211, 233), (220, 321), (227, 234), (230, 231), (472, 498), (4765, 8971)]
</code></pre>
<p>and for sorting based on the second element:</p>
<pre><code>sorted_by_second = sorted(list_tuple, key=lambda element: (element[1]) )
</code></pre>
<p>which outputs</p>
<pre><code>print(sorted_by_second)
[(20, 35), (125, 145), (156, 178), (230, 231), (211, 233), (227, 234), (220, 321), (472, 498), (4765, 8971)]
</code></pre>
<p>and for both:</p>
<pre><code>sorted_by_both = sorted(list_tuple, key=lambda element: (element[0], element[1]) )
</code></pre>
<p>which outputs</p>
<pre><code>print(sorted_by_both)
[(20, 35), (125, 145), (156, 178), (211, 233), (220, 321), (227, 234), (230, 231), (472, 498), (4765, 8971), ...]
</code></pre>
<p>Notice that each of these sorted outputs are in different order. Those tuples that differ in ordering are "overlapping intervals", e.g. should <code>(227, 234)</code> be placed before or after <code>(230, 231)</code>, as these interval overlap. </p>
<p>My aim is to create a function which (1) searches the sorted output for the "overlapping intervals" and (2) then randomly permutes them amongst themselves. </p>
<p>I can think of a function that outputs all tuples which overlap a given tuple, e.g.</p>
<pre><code>def find_overlaps(input_tuple_list, search_interval):
    results = []
    for tup in input_tuple_list:
        if ((tup[0] &gt;= search_interval[0] and tup[0] &lt;= search_interval[1]) or (tup[1] &gt;= search_interval[0] and tup[1] &lt;= search_interval[1])):
            results.append(tup)
    return results
</code></pre>
<p>which works as follows</p>
<pre><code>foo = (130, 150)
overlapping_foo = find_overlaps(list_tuple, foo)
print(overlapping_foo)
[(125, 145)]
</code></pre>
<p>However, in order to achieve goal (1), I need to write a function which finds all overlapping tuples in <code>list_tuple</code>.</p>
<p>What I've tried: I originally thought I could search the original tuple with itself, e.g. </p>
<pre><code>total_overlaps = []
for tupp in list_tuple:
    total_overlaps.append(find_overlaps(list_tuple, tupp))
</code></pre>
<p>This is obviously wrong, as the output is the original tuple itself. </p>
<p>The bigger problem with is that I cannot see how to execute goal (2). I must only shuffle/re-order tuples which overlap with one another. Let's say I had a list of overlapping tuples found from (1):</p>
<pre><code>overlap_list = [(211, 233), (220, 321), (227, 234), (230, 231), (6491, 7000), (6800, 7200)]
</code></pre>
<p>The following list comprehension fails</p>
<pre><code>from random import shuffle
reordered = [shuffle(tupp) for tupp in overlap_list]
</code></pre>
<p>giving</p>
<pre><code>TypeError: 'tuple' object does not support item assignment
</code></pre>
<p>It's also important I do not shuffle <code>(6491, 7000)</code> with <code>(211, 233)</code>, as these are not related. </p>
<p>How do I find the overlapping intervals in the list of tuples, and then individually shuffle these tuples which overlap with one another. </p>
</div>
<div class="post-text" itemprop="text">
<p>Note quite sure I understand what you are asking for regarding the shuffle. But you can use the <code>itertools</code> recipe <code>pairwise</code> to pair up the elements and then use <code>itertools.groupby()</code>, to group up the sequential overlaps, i.e. split <code>(211, 233)</code> from <code>(6491, 7000)</code>:</p>
<pre><code>import itertools as it

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = it.tee(iterable)
    next(b, None)
    return zip(a, b)

&gt;&gt;&gt; overlap_list = [(211, 233), (220, 321), (227, 234), (230, 231), (6491, 7000), (6800, 7200)]
&gt;&gt;&gt; [list(p) for k, p in it.groupby(pairwise(overlap_list), lambda x: x[0][0] &lt; x[1][0] &lt; x[0][1]) if k]
[[((211, 233), (220, 321)), ((220, 321), (227, 234)), ((227, 234), (230, 231))],
 [((6491, 7000), (6800, 7200))]]
</code></pre>
<p>You could <code>unpairwise</code> these lists with:</p>
<pre><code>def unpairwise(iterable):
    a, b = zip(*iterable)
    yield a[0]
    yield from b
</code></pre>
<p>So:</p>
<pre><code>&gt;&gt;&gt; [list(unpairwise(p)) for k, p in it.groupby(pairwise(overlap_list), lambda x: x[0][0] &lt; x[1][0] &lt; x[0][1]) if k]
[[(211, 233), (220, 321), (227, 234), (230, 231)], [(6491, 7000), (6800, 7200)]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Extending the answer from <a href="https://stackoverflow.com/a/44752136/7675174">@AChampion</a>, it should be easy to shuffle your list of lists of overlapping tuples to get what you want:</p>
<pre><code>&gt;&gt;&gt; overlaps = [[(211, 233), (220, 321), (227, 234), (230, 231)], [(6491, 7000), (6800, 7200)]]
&gt;&gt;&gt; for x in overlaps: 
...     random.shuffle(x)
...
&gt;&gt;&gt; overlaps
[[(227, 234), (230, 231), (220, 321), (211, 233)], [(6491, 7000), (6800, 7200)]]
&gt;&gt;&gt; for x in overlaps:
...     random.shuffle(x)
...
&gt;&gt;&gt; overlaps
[[(220, 321), (227, 234), (230, 231), (211, 233)], [(6491, 7000), (6800, 7200)]]
&gt;&gt;&gt; for x in overlaps:
...     random.shuffle(x)
...
&gt;&gt;&gt; overlaps
[[(227, 234), (211, 233), (220, 321), (230, 231)], [(6800, 7200), (6491, 7000)]]
</code></pre>
<p>Note that <code>random.shuffle</code> is in place.</p>
</div>
<span class="comment-copy">I'm not sure, but something isn't really working: <a href="https://repl.it/JBex/0" rel="nofollow noreferrer">repl.it/JBex/0</a></span>
<span class="comment-copy">You can't <code>random.shuffle()</code> a tuple because tuples are immutable, but you can <code>random.sample(tupp, k=len(tupp))</code> which creates a new object.</span>
<span class="comment-copy">Note, <code>sorted_by_both = sorted(list_tuple, key=lambda element: (element[0], element[1]) )</code> is <i>exactly equivalent</i> to <code>sorted(list_tuple)</code>, as long as there are exactly 2 elements in each tuple.</span>
<span class="comment-copy">@AChampion Thanks! That solves part of my confusing. Now the remaining question is, how to randomly shuffle only the overlapping intervals.</span>
<span class="comment-copy">@CoolqB Are you using <code>shuffle</code>?</span>
<span class="comment-copy">"Note quite sure I understand what you are asking for regarding the shuffle." Sort the two columns. Next, find all intervals which intersect/overlap. For each group of intervals (rows) which overlap, shuffle these rows.</span>
<span class="comment-copy">So, I need a function which finds the tuples you have in <code>overlap_list</code>. Then, randomly re-arrange these tuples. The final output should be the original list of tuples, except (1) it is sorted and (2) if there are intersecting tuples, these have been randomly shuffled with one another.</span>
<span class="comment-copy">Thanks. The part I'm struggling with is how to write a function gives outputs the list of lists of overlapping tuples, <code>overlaps</code></span>
<span class="comment-copy">@ShanZhengYang, you just need to wrap @AChampion's final list comprehension in a function. E.g. <code>def get_overlaps(points): return [list(unpairwise(p)) for k, p in it.groupby(.........</code></span>
<span class="comment-copy">I'm not following what you mean by <code>it.groupby(...</code> what is <code>it</code>?</span>
<span class="comment-copy">That's the start of AChampion's list comprehension statement, the final line in his answer. Further up in his code, you see <code>import itertools as it</code>. For more information on <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">groupby</a></span>
<span class="comment-copy">"That's the start of AChampion's list comprehension statement, the final line in his answer. Further up in his code, you see import itertools as it. For more information on groupby" I understand now. I had missed the <code>import itertools as it</code> statement</span>
