<div class="post-text" itemprop="text">
<p>I am given a sequence of letters and have to produce all the N-length anagrams of the sequence given, where N is the length of the sequence.</p>
<p>I am following a kinda naive approach in python, where I am taking all the permutations in order to achieve that. I have found some similar threads like <a href="https://stackoverflow.com/questions/2565912/code-golf-find-all-anagrams">this one</a> but I would prefer a math-oriented approach in Python. So what would be a more performant alternative to permutations? Is there anything particularly wrong in my attempt below?</p>
<pre><code>from itertools import permutations
def find_all_anagrams(word):

pp = permutations(word)
perm_set = set()
for i in pp:
    perm_set.add(i)
ll = [list(i) for i in perm_set]
ll.sort()
print(ll)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If there are lots of repeated letters, the key will be to produce each anagram only once instead of producing all possible permutations and eliminating duplicates.</p>
<p>Here's one possible algorithm which only produces each anagram once:</p>
<pre><code>from collections import Counter

def perm(unplaced, prefix):
  if unplaced:
    for element in unplaced:
      yield from perm(unplaced - Counter(element), prefix + element)
  else:
    yield prefix

def permutations(iterable):
  yield from perm(Counter(iterable), "")
</code></pre>
<p>That's actually not much different from the classic recursion to produce all permutations; the only difference is that it uses a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collections.Counter</a> (a multiset) to hold the as-yet-unplaced elements instead of just using a list.</p>
<p>The number of <code>Counter</code> objects produced in the course of the iteration is certainly excessive, and there is almost certainly a faster way of writing that; I chose this version for its simplicity and (hopefully) its clarity</p>
</div>
<div class="post-text" itemprop="text">
<p>This is very slow for long words with many similar characters. Slow compared to theoretical maximum performance that is. For example, <code>permutations("mississippi")</code> will produce a much longer list than necessary. It will have a length of 39916800, but but the set has a size of 34650.</p>
<pre><code>&gt;&gt;&gt; len(list(permutations("mississippi")))
39916800
&gt;&gt;&gt; len(set(permutations("mississippi")))
34650
</code></pre>
<p>So the big flaw with your method is that you generate ALL anagrams and then remove the duplicates. Use a method that only generates the unique anagrams.</p>
<p>EDIT:</p>
<p>Here is some working, but extremely ugly and possibly buggy code. I'm making it nicer as you're reading this. It does give 34650 for mississippi, so I assume there aren't any major bugs. Warning again. UGLY!</p>
<pre><code># Returns a dictionary with letter count
# get_letter_list("mississippi") returns 
# {'i':4, 'm':1, 'p': 2, 's':4}
def get_letter_list(word):
    w = sorted(word)
    c = 0
    dd = {}
    dd[w[0]]=1
    for l in range(1,len(w)):
        if w[l]==w[l-1]:
            d[c]=d[c]+1
            dd[w[l]]=dd[w[l]]+1
        else:
            c=c+1
            d.append(1)
            dd[w[l]]=1
    return dd

def sum_dict(d):
    s=0
    for x in d:
        s=s+d[x]
    return s

# Recursively create the anagrams. It takes a letter list
# from the above function as an argument.
def create_anagrams(dd):
    if sum_dict(dd)==1: # If there's only one letter left
        for l in dd:
            return l # Ugly hack, because I'm not used to dics
    a = []
    for l in dd:
        if dd[l] != 0:
            newdd=dict(dd)
            newdd[l]=newdd[l]-1
            if newdd[l]==0:
                newdd.pop(l)
            newl=create(newdd)
        for x in newl:
            a.append(str(l)+str(x))
    return a

&gt;&gt;&gt; print (len(create_anagrams(get_letter_list("mississippi"))))
34650
</code></pre>
<p>It works like this: For every unique letter l, create all unique permutations with one less occurance of the letter l, and then append l to all these permutations.</p>
<p>For "mississippi", this is way faster than set(permutations(word)) and it's far from optimally written. For instance, dictionaries are quite slow and there's probably lots of things to improve in this code, but it shows that the algorithm itself is much faster than your approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe I am missing something, but why don't you just do this:</p>
<pre><code>from itertools import permutations

def find_all_anagrams(word):
    return sorted(set(permutations(word)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could simplify to:</p>
<pre><code>from itertools import permutations

def find_all_anagrams(word):
    word = set(''.join(sorted(word)))
    return list(permutations(word))
</code></pre>
<p>In the doc for <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer">permutations</a> the code is detailled and it seems already optimized.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know python but I want to try to help you: probably there are a lot of other more performant algorithm, but I've thought about this one: it's completely recursive and it should cover all the cases of a permutation. I want to start with a basic example:</p>
<p>permutation of <strong>ABC</strong></p>
<p>Now, this algorithm works in this way: for <code>Length</code> times you shift right the letters, but the last letter will become the first one (you could easily do this with a queue).</p>
<p>Back to the example, we will have:</p>
<ul>
<li><strong>ABC</strong></li>
<li><strong>BCA</strong></li>
<li><strong>CAB</strong></li>
</ul>
<p>Now you repeat the first (and only) step with the substring built from the second letter to the last one.</p>
<p>Unfortunately, with this algorithm you cannot consider permutation with repetition.</p>
</div>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/40752319/algorithm-to-list-unique-permutations-of-string-with-duplicate-letters/40756214#40756214" title="algorithm to list unique permutations of string with duplicate letters">stackoverflow.com/questions/40752319/â€¦</a></span>
<span class="comment-copy">Thanks a lot I will dig the documentation starting from here.</span>
<span class="comment-copy">I've added the missing recursive call to <code>perm()</code>.</span>
<span class="comment-copy">@jfsebastian: thanks. I have no idea how I managed to copy-and-paste so badly.</span>
<span class="comment-copy">Could you give me an example? How will I know if it is a duplicate, if I dont generate it first?</span>
<span class="comment-copy">You don't need to know if there are duplicates. You only need an algorithm that does not create duplicates. Working on a better answer atm.</span>
<span class="comment-copy">Here's a <a href="https://codereview.stackexchange.com/a/52048/6143">simple "all uniq anagrams" algorithm</a> (it excludes duplicates i.e.,  it generates only 34650 variants for <i>"mississippi"</i>). Though the time performance for short sequences may be worse than set(itertools.permutations(..))</span>
<span class="comment-copy">It is not that I am not getting the values I want, it is performance issue. Is there any more performant alternative? This is kinda brute force</span>
<span class="comment-copy">What do you mean? I can only see how the permutations function is implemented not example sof usage? Am I missing something?</span>
<span class="comment-copy">No you are not missing anything; but IMO most of the function implemented by very used library are over optimized and aleady follow mathematical logic. Anyway, if you want a faster alternatives, you will have to benchmark them to be sure.</span>
