<div class="post-text" itemprop="text">
<p>Code:</p>
<pre><code>#!/usr/bin/env python

import os
import sys
import threading

class fifo_buffer(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.dict_buffer = {}

    def run(self):
        path =  "/media/ramdisk/sample.fifo"
        fifo = open(path, "r")
        count = 0
        for line in fifo:
            count = count + 1
            self.dict_buffer[count] = line
            #print str(count) + " -&gt; " + self.dict_buffer[count]
        fifo.close()

    def get_packet(self, index):
        return self.dict_buffer[index]

    def len_dict(self):
        print "Length dict: " + str(len(self.dict_buffer))

def main():
   fb = fifo_buffer()
   fb.start()
   print "get_packet(2): " + fb.get_packet(2)   # Input Error
   fb.len_dict()                                # Length showing zero

if __name__ == "__main__":
   main()
</code></pre>
<ol>
<li><p>run function:</p>
<p>I am trying to read from fifo file and storing data into a dictionary.
This run function will execute almost infinitely.</p></li>
<li><p>get_packet or len_dict function:</p>
<p>I am trying to get the details of the dictionary but unable to do so.</p></li>
</ol>
<p>My doubt is when run function is storing data from fifo file to dictinary, while suppose will go on infinitely, using get_packet or len_dict i want to access this dictionary data structure, but unable to access it</p>
<p>I am new to threading, so any other approach is also appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the problem might be that you did not figure out how multiple threads work. <strong>After calling <code>fb.start()</code>, two threads(the main thread and the <code>run()</code> thread which read from fifo file and store data into a dictionary) work concurrently.</strong> </p>
<p>The KeyError you got while calling <code>print "get_packet(2): " + fb.get_packet(2)</code> is because when the main thread called <code>get_packet(2)</code>, the <code>run()</code> thread has not append data into the dictionary yet.  </p>
<blockquote>
<p>so only after calling the join() , the dictionary data can be accessed ?? </p>
</blockquote>
<p>Not exactly. Please continue reading.</p>
<blockquote>
<p>Is their any way to access the dictionary while the run() thread is executing infinitely ? </p>
</blockquote>
<p>You could process/access the dictionary in <strong><code>run() thread</code></strong> while <code>run() thread</code> is executing, but obviously this dictionary changes over time, and you could only access the lines that <code>run() thread</code> has already processed. You could also process/access the dictionary in <strong>main thread</strong> while <code>run() thread</code> is executing, but as I said before, the <code>run() thread</code> might have not appended data into the dictionary(you could only access the lines that <code>run() thread</code> has already processed as well). </p>
<p>I have tested the code, added a new method and made some modifications. It worked well. The modified code is as follows.</p>
<pre><code>#!/usr/bin/env python

import os
import sys
import threading

class fifo_buffer(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.dict_buffer = {}

    def run(self):
        print("run() starts.")
        path = "./sample.fifo"
        fifo = open(path, "r")
        count = 0
        for line in fifo:
            count = count + 1
            self.dict_buffer[count] = line
            print("in for expression: before show_dict()")
            self.show_dict()    # you could process dict_buffer here, but obviously this dict changes over time, and you could only access the lines that run() thread has already processed.
            #print str(count) + " -&gt; " + self.dict_buffer[count]
        fifo.close()
        print("run() completes.")

    def get_packet(self, index):
        return self.dict_buffer[index]

    def len_dict(self):
        print("Length dict: " + str(len(self.dict_buffer)))

    def show_dict(self):
        print(self.dict_buffer)

def main():
   fb = fifo_buffer()
   fb.start()
   # fb.join()
   # print("get_packet(2): " + fb.get_packet(2))
   # you could process dict_buffer here, but you could only process/access the lines which run() thread has already processed.
   fb.len_dict()
   fb.show_dict()

if __name__ == "__main__":
   main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As I stated in one of my comments, this example (especially the <code>main</code> function) does <strong>not</strong> make much sense from the multithreading's <em>PoV</em>. Here's the code "<em>slightly</em>"  modified:</p>
<pre><code>#!/usr/bin/env python

import os
import sys
import threading


class FifoBufferThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.dict_buffer = {}

    def run(self):
        print("Begin inner thread run...")
        path = "/media/ramdisk/sample.fifo"
        count = 0
        with open(path, "r") as fifo:
            for line in fifo:
                count += 1
                self.dict_buffer[count] = line
                #print str(count) + " -&gt; " + self.dict_buffer[count]
        print("End inner thread run")

    def get_packet(self, index):
        return self.dict_buffer.get(index, None)

    def get_dict_len(self):
        return len(self.dict_buffer)

    def len_dict(self):
        print "Length dict: " + str(self.get_dict_len())


def main():
    print("Main thread starting...")
    fbt = FifoBufferThread()
    fbt.daemon = True
    fbt.start()
    user_selection = None
    while True:
        user_selection = raw_input("Press any key to continue, 'x' (lowercase) to exit: ")
        if user_selection == "x":
            print("Exiting at user's choice.")
            break
        print(fbt.len_dict())
        # Do whatever else you might think is necessary with the dict
    print("Exiting")


if __name__ == "__main__":
    main()
</code></pre>
<p>Now, the <em>main</em> thread can be seen interacting with the inner(<code>FifoBufferThread</code>) thread.</p>
<p><strong>Changes</strong>:</p>
<ul>
<li><code>main</code> function is now a loop (<strong>after</strong> starting the <code>fbt</code> thread) to better illustrate what the thread is doing in the background (and how <code>fbt</code> is affecting the main thread). It involves user interaction (a key needs to be hit), if that key is lower-case <strong>x</strong>, the program will exit.<br/>
<strong><em>Important note</em></strong>: while the program waits for user input, the inner thread <strong>will continue doing its work</strong>, so it will read lines from the file</li>
<li><strong>!!! Important one !!!</strong>: <code>fbt.daemon = True</code>: the thread is marked as <em>daemonic</em>. As <a href="https://docs.python.org/3/library/threading.html#thread-objects" rel="nofollow noreferrer">[Python]: Thread objects</a> states:

<blockquote>
<p>A thread can be flagged as a “daemon thread”. The significance of this flag is that the entire Python program exits when only daemon threads are left.</p>
</blockquote></li>
<li><code>get_packet</code>: I modified it to use <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer">[Python]: dict.get</a> (and return <code>None</code> instead of raising an exception and terminating the program)</li>
<li>Added <code>get_dict_len</code> function (which is now used by <code>len_dict</code>). It's good to get data, and only then, format it for printing purposes</li>
<li><p>I'm not sure of the reading rate from the file, or the other program's rate in terms of writing to it, nor to its initial content, but one of the following will happen (<strong>assuming</strong> that once the file is open for reading, it will "update" its contents as other processes write to it):</p>
<ol>
<li>Your app, will "eat" everything that's in the file and eventually reach <em>EOF</em>, and the the thread will stop (normal case)</li>
<li><p>The other app that reads from <em>TCP</em>, will write fast enough (not very probable) so that your app that reads the file contents (and stores it in the dict: <strong>IN MEMORY</strong>) will eventually run out of memory</p>
<p>2.1. A flavor: <em>RAM</em> won't run out, but disk (<em>/media</em>) will</p></li>
</ol></li>
<li>Note: there are more things that could get improved as well</li>
</ul>
</div>
<span class="comment-copy">First, the indenting is wrong (the code wouldn't run). Second, you start the thread and immediately after, you try to get data. Reading from file (hdd access) takes much more time compared to other operations (e.g. that only involve memory). You have to <i>wait</i> for the data to become available <b>after</b> starting the thread: <code>fb.join()</code> (<a href="https://docs.python.org/3/library/threading.html#threading.Thread.join" rel="nofollow noreferrer">[Python]: Thread.join</a>). But in this example, I fail to see the necessity of threads.</span>
<span class="comment-copy">so only after calling the join() , the dictionary data can be accessed ?? Is their any way to access the dictionary while the run() thread is executing infinitely ?</span>
<span class="comment-copy">Since <code>fb.start()</code>, the thread opens the file and starts reading from it. The problem is that till you call <code>fb.get_packet(2)</code>, it didn't manage to read anything (for the reason that I stated in the previous comment). You could add between the two, a <code>time.sleep(0.01)</code> (play with the value a little bit to see when it makes a difference). <code>run</code> method does <b>not</b> run infinitely, only til it completes reading the file, then the thread "dies". You can add <code>print</code> statements at <code>run</code>'s begin and end, and also in the main thread, to see how they "interact".</span>
<span class="comment-copy">actually their is another code which keeps pushing data into the file(TCP/IP Packets to be exact) which will keep on pushing data infinitely and so the file read will go on infinitely.  So when this file read and storing data into the dict is going on, i want to access the dict to get its elements. So i need to access the dict before join(). Any way to do that ?</span>
<span class="comment-copy">The thread won't run infinitely as at some point you'll run out of disk space (although running out of memory will happen much sooner as all the file contents is also stored there - in the dict). You can only access the data that was already "written" in the dict, you can check that with <code>len_dict</code>. Calling the function multiple times, with <code>time.sleep</code> statements in between, will yield different results (the number returned will be bigger with every call).</span>
<span class="comment-copy">actually their is another code which keeps pushing data into the fifo file(TCP/IP Packets to be exact) which will keep on pushing data infinitely and so the file read will go on infinitely. So when this file read and storing data into the dict is going on, i want to access the dict to get its elements. So i need to access the dict before join(). Any way to do that ? The code works when their is finite data inside the fifo file but not when the file read occurs infinitely.</span>
<span class="comment-copy">Its working ... Thank you so much !!</span>
<span class="comment-copy">You're welcome. So, did this answer your question?</span>
