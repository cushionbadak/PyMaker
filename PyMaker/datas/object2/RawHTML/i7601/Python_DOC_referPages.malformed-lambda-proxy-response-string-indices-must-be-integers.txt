<div class="post-text" itemprop="text">
<p>I am trying to write a serverless back-end for an application with AWS Lambda, and am running into the error in the title. The error occurs when testing with API Gateway proxy integration, but the function works fine when tested in the Lambda console.</p>
<p>Here is the error:</p>
<pre><code>{  
   "errorMessage":"string indices must be integers",
   "errorType":"TypeError",
   "stackTrace":[  
      [  
         "/var/task/auth_login.py",
         17,
         "lambda_handler",
         "response = get_user(payload)"
      ],
      [  
         "/var/task/shifty_utils/__init__.py",
         22,
         "get_user",
         "table = dynamo.Table(user['company'] + '_users')"
      ]
   ]
}
</code></pre>
<p>Here is context for where it occurs:</p>
<pre><code>def lambda_handler(event, context):
    payload = event['body']
    response = get_user(payload)

def get_user(user):
    try:
        table = dynamo.Table(user['company'] + '_users')
        response = table.get_item(
            Key={
                'userId': user['userId'],
                'position': user['position']
            }
        )
    except ClientError as e:
        print(e.response['Error']['Message'])
        return {'message': e.response['Error']['Message']}
    else:
        return response
</code></pre>
<p>Basically proxy integration seems to be reading in the event object as a JSON formatted string, as opposed to a dict, but here's what happens if I adjust my code for that:</p>
<pre><code>{  
   "errorMessage":"the JSON object must be str, bytes or bytearray, not 'dict'",
   "errorType":"TypeError",
   "stackTrace":[  
      [  
         "/var/task/auth_login.py",
         15,
         "lambda_handler",
         "payload = json.loads(event)"
      ],
      [  
         "/var/lang/lib/python3.6/json/__init__.py",
         348,
         "loads",
         "'not {!r}'.format(s.__class__.__name__))"
      ]
   ]
}
</code></pre>
<p>I can't win. Any help is appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You've identified the issue. However you're trying to convert a <code>dict</code> to <code>dict</code>.</p>
<p>This is what you have:</p>
<pre><code>json.loads(event) # event is a dict
</code></pre>
<p>The body part as you have rightly identified is what is getting in as <code>str</code>.</p>
<p>This is what you should have:</p>
<pre><code>json.loads(event['body'])
</code></pre>
<p>One more step is to make it client-agnostic.</p>
<pre><code>if isinstance(event['body'], (unicode, str)):
    body = json.loads(event['body'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is because <code>event['body']</code> is not a <code>dict</code> but a <code>str</code>. (I ran into this problem when decoding an SQS triggered event)</p>
<p>In case if anyone ran into a problem when a value of <code>json.loads(event['body'])</code> is again not <code>dict</code> but <code>str</code>, here is a solution that decodes str to dict recursively.</p>
<pre><code>import json

def to_dict(obj : object) -&gt; dict:
    """ Serialize Object to Dictionary Recursively

    Arguments:
        obj {object} -- string, list, or dictionary to be serialize

    Returns:
        dict -- Serialized Dictionary
    """

    if isinstance(obj, dict):
        data = {}
        for k, v in obj.items():
            data[k] = to_dict(v)
        return data

    elif hasattr(obj, "_ast"):
        return to_dict(obj._ast())

    elif hasattr(obj, "__iter__") and not isinstance(obj, str):
        return [to_dict(v) for v in obj]

    elif hasattr(obj, "__dict__"):
        data = {key : to_dict(value) for key, value in obj.__dict__.items() if 
                  not callable(value) and not key.startswith('_')}

    elif isinstance(obj, str):
        try:
            data = {}
            obj = json.loads(obj)
            for k, v in obj.items():
                data[k] = to_dict(v)
                return data
        except:
            return obj
    else:
        return obj
</code></pre>
<p>Example Usage:</p>
<pre><code>test = {'Records': ['{"s3": "{\\"bucket\\": \\"bucketname\\"}"}', '{"s3": "{\\"bucket\\": \\"bucketname\\"}"}']}

print(to_dict(test)['Records'][0]['s3']['bucket'])
</code></pre>
<p>This should print "bucketname".</p>
</div>
<div class="post-text" itemprop="text">
<p>When dealing with json, python provides 2 std functions:</p>
<p><a href="https://docs.python.org/3/library/json.html#json.dumps" rel="nofollow noreferrer">https://docs.python.org/3/library/json.html#json.dumps</a></p>
<blockquote>
<p>Serialize obj to a JSON formatted str using this conversion table. The
  arguments have the same meaning as in dump().</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/json.html#json.loads" rel="nofollow noreferrer">https://docs.python.org/3/library/json.html#json.loads</a></p>
<blockquote>
<p>Deserialize s (a str, bytes or bytearray instance containing a JSON
  document) to a Python object using this conversion table.</p>
</blockquote>
<p>What you need here is the latest:</p>
<pre><code>import json
payload = json.loads(event['body']
</code></pre>
<p><code>event['body']</code> is probably a json str so for accessing itÂ´s values you fist will need to convert it to a python obj via `json.loads</p>
</div>
