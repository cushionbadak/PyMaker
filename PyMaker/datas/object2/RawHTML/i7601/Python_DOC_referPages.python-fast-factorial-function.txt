<div class="post-text" itemprop="text">
<p>I am trying to write code for a super-fast factorial function. I have experimented a little and have come up with the following three candidates (apart from math.factorial):</p>
<pre><code>def f1():
    return reduce(lambda x,y : x * y, xrange(1,31))

def f2():
    result = 1
    result *= 2
    result *= 3
    result *= 4
    result *= 5
    result *= 6
    result *= 7
    result *= 8
    #and so-on...
    result *= 28
    result *= 29
    result *= 30
    return result

def f3():
    return 1*2*3*4*5*6*7*8*9*10*11*12*13*14*15*16*17*18*19*20*21*22*23*24*25*26*27*28*29*30
</code></pre>
<p>I have timed these functions. These are the results:</p>
<pre><code>In [109]: timeit f1()
100000 loops, best of 3: 11.9 µs per loop

In [110]: timeit f2()
100000 loops, best of 3: 5.05 µs per loop

In [111]: timeit f3()
10000000 loops, best of 3: 143 ns per loop

In [112]: timeit math.factorial(30)
1000000 loops, best of 3: 2.11 µs per loop
</code></pre>
<p>Clearly, f3() takes the cake. I have tried implementing this. To be verbose, I have tried writing code that generates a string like this:
"1*2*3*4*5*6*7*8*9*10*11*12*13*14........" and then using eval to evaluate this string. (Acknowledging that 'eval' is evil). However, this method gave me no gains in time, AT ALL. In fact, it took me nearly 150 microseconds to finish.</p>
<p>Please advise on how to generalize f3().</p>
</div>
<div class="post-text" itemprop="text">
<p><code>f3</code> is only fast because it isn't actually computing anything when you call it. The whole computation gets optimized out at compile time and replaced with the final value, so all you're timing is function call overhead.</p>
<p>This is particularly obvious if we disassemble the function with the <code>dis</code> module:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(f3)
  2           0 LOAD_CONST              59 (265252859812191058636308480000000L)
              3 RETURN_VALUE
</code></pre>
<p>It is impossible to generalize this speedup to a function that takes an argument and returns its factorial.</p>
</div>
<div class="post-text" itemprop="text">
<p>f3() takes the cake because when the function is def'ed Python just optimizes the string of multiplications down to the final result and effective definition of f3() becomes:</p>
<pre><code>def f3():
    return 8222838654177922817725562880000000
</code></pre>
<p>which, because no computation need occur when the function is called, runs really fast!</p>
<p>One way to produce all the effect of placing a * operator between the list of numbers is to use <code>reduce</code> from the <code>functools</code> module.  Is this sometime like what you're looking for?</p>
<pre><code>from functools import reduce
def fact(x):
    return reduce((lambda x, y: x * y), range(1, x+1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would argue that none of these are good factorial functions, since none take a parameter to the function. The reason why the last one works well is because it minimizes the number of interpreter steps, but that's still not a good answer: all of them have the same complexity (linear with the size of the value). We can do better: O(1).</p>
<pre><code>import math
def factorial(x):
    return math.gamma(x+1)
</code></pre>
<p>This scales constantly with the input value, at the sacrifice of some accuracy. Still, way better when performance matters.</p>
<p>We can do a quick benchmark:</p>
<pre><code>import math
def factorial_gamma(x):
    return math.gamma(x+1)

def factorial_linear(x):
    if x == 0 or x == 1:
        return 1
    return x * factorial_linear(x-1)


In [10]: factorial_linear(50)
Out[10]: 30414093201713378043612608166064768844377641568960512000000000000

In [11]: factorial_gamma(50)
Out[11]: 3.0414093201713376e+64

In [12]: %timeit factorial_gamma(50)
537 ns ± 6.84 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)

In [13]: %timeit factorial_linear(50)
17.2 µs ± 120 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p>A 30 fold increase for a factorial of 50. Not bad.</p>
<p><a href="https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.misc.factorial.html" rel="nofollow noreferrer">https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.misc.factorial.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As others have stated <code>f3()</code> isn't actually computing anything that's why you get such fast results. You can't achieve the same by giving it to a function.</p>
<p>Also you maybe wondering why <code>math.factorial()</code> is so fast it's because
the <a href="https://docs.python.org/3/library/math.html" rel="nofollow noreferrer">math module's functions</a> are implemented in C:</p>
<blockquote>
<p>This module is always available. It provides access to the mathematical functions defined by the C standard</p>
</blockquote>
<p>By using an efficient algorithm in C, you get such fast results.</p>
<p>Here your best bet would be would using the below function, but using <code>math.factorial</code> is what I prefer if you're purely in need of <strong>performance</strong></p>
<pre><code>def f3(x):
    ans=1
    for i in range(1,x+1):
        ans=ans*i
    return ans
print(f3(30))
</code></pre>
</div>
<span class="comment-copy">I don't think you can generalise f3. What this exercise shows is that if you want to find the fastest way to do something, you need to test the actual thing. Testing functions that only work for n=30 doesn't help. Anyway, in the end, try using <code>reduce</code> with <code>operator.mul</code>. Or, if you can guarantee that the parameter doesn't get bigger than ~1000, just cache the results in a list.</span>
<span class="comment-copy">@AlexHall I have actually tried reduce(operator.__mul__, ....) However, the results were not in nanosecond range, which is what I was hoping for.</span>
<span class="comment-copy">Could you please explain why it is impossible?</span>
<span class="comment-copy">@NageshEranki: <code>f3</code> is only fast because the result was already computed. You can't precompute every possible output, and if you tried, it wouldn't necessarily even be faster, what with things like increased initialization time. Depending on your use case, there may be ways to get some benefit out of precomputing or saving outputs, but the <code>timeit</code> results you're seeing are a pipe dream.</span>
<span class="comment-copy">There's simply no way to generalize "I already knew the answer" for every possible answer.</span>
<span class="comment-copy">I imagine that the reason OP wants to do eval, is to have an in-argument, though.</span>
<span class="comment-copy">Ah, but accuracy is of great importance for what I'm doing. What do you suggest I do then?</span>
<span class="comment-copy">The accuracy is almost negligible, actually. You're not likely to notice any difference.</span>
<span class="comment-copy">Still not faster than your naive implementation. Python can guarantee much faster time, using a divide-and-conquer approach, and is explained here: <a href="http://www.luschny.de/math/factorial/binarysplitfact.html" rel="nofollow noreferrer">luschny.de/math/factorial/binarysplitfact.html</a></span>
