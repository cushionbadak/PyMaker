<div class="post-text" itemprop="text">
<p>I want to implement a singleton pattern in python, and I liked the pattern described in the <a href="http://www.python-course.eu/python3_metaclasses.php" rel="nofollow noreferrer">http://www.python-course.eu/python3_metaclasses.php</a>.</p>
<pre><code>class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]


class SingletonClass(metaclass=Singleton):
    pass
class RegularClass():
    pass
x = SingletonClass()
y = SingletonClass()
print(x == y)
x = RegularClass()
y = RegularClass()
print(x == y) 
</code></pre>
<p>And the code works perfect. But, the <code>__call__()</code> does not have the <code>self</code>, and it also does not have <code>@classmethod</code> or <code>@staticmethod</code> declaration.</p>
<p>But, in the Python data model <a href="https://docs.python.org/3/reference/datamodel.html#object.__call__" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#object.__call__</a> the <code>__call__()</code> method has a self in the arguments.</p>
<p>The code does not work if I pass <code>self</code>, or declare as <code>@staticmethod</code> or <code>@classmethod</code>. </p>
<p>Can someone please explain the logic of the syntax behind the <code>__call__()</code> method.</p>
</div>
<div class="post-text" itemprop="text">
<p>Naming the first argument of a method <code>cls</code> or <code>self</code> are <em>just a convention</em>. The <code>__call__</code> method <em>does</em> have a self argument, only it is <em>named</em> <code>cls</code> here. That's because for a metaclass, the method is bound to a class object, and the name reflects this.</p>
<p>The same convention is applied to <code>@classmethod</code> methods; the first argument is a class, always, due to the nature of how a <code>classmethod</code> object is bound, so it makes sense to name that first argument <code>cls</code>.</p>
<p>But you are free to name that first argument anything else. It is not the name that makes a classmethod or a regular method or a method on a metatype work. All that using <code>self</code> or <code>cls</code> does is <em>document what type of object this is</em>, making it easier for other developers to mentally track what is going on.</p>
<p>So no, this is not an implicit class method. That first argument is not bound to the <code>Singleton</code> metaclass object, it is bound to the class that was called. That makes sense, because that class object is an instance of the <code>Singleton</code> metatype.</p>
<p>If you want to dive into how <em>binding</em> works (the process that causes that first argument to be passed in, whatever the name), you can read up on the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer"><em>Descriptor HOWTO</em></a>. TLDR: functions, <code>property</code>, <code>classmethod</code> and <code>staticmethod</code> objects are all <em>descriptors</em>, and whenever you access them as an attribute on a supporting object such as an instance or a class, they are bound, often causing a <em>different</em> object to be returned as a result, which when called passes in the bound object to the actual function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Martin's answer says it all. I am adding this so maybe a different wording can throw in more light for different people:</p>
<h1>Python <strong>call</strong>() is this an implicit classmethod?</h1>
<p>No. But all "metaclass" methods are implicit "class methods" for the classes that use that metaclass. </p>
<p>That is implicit when we take in account the fact that classes are simply instances of the metaclass. From the language point of view, a class behave almost exactly like any other instance - and any interactions with a class that would trigger dunder (<code>__magic__</code>) methods in an object - like using the "+, -, *, /" operators, or index retrieval with <code>[ ]</code>, or calling them with <code>(  )</code> trigger the corresponding methods on its class. That is ordinarily <code>type</code>. </p>
<p>And, as put in the other answer, Python does not care what name you ut on the first argument of a method. For metaclasses it makes sense to use  <code>cls</code> there, since the "instances" the methods are dealing with are metaclasses.  As it makes sense that the first argument to a metaclass' <code>__new__</code> method be named <code>metacls</code> (like in the example bellow). Because the new "cls" is the object we get after calling <code>type.__new__</code> - the only call possible in pure Python that will actually create a class object. </p>
<pre><code>class Meta(type):
    def __new__(metacls, name, bases, namespace):
         ...
         cls = super().__new__(metacls, name, bases, namespace)
         ...
         return cls
</code></pre>
<p>(Now, still on the topic of the question: <code>__new__</code> <strong>is</strong> a special case
of an implicit static method (even for ordinary classes that are not intended to be metaclasses) - to which Python specially add the first argument, using a different mechanism than what is done to regular <code>classmethod</code>s. Thats is why the <code>super().__new__</code> call above needs to include the metacls as the first parameter)</p>
</div>
<span class="comment-copy"><i>The code does not work if I pass self</i>: how did you 'pass self' here? If you <i>renamed</i> <code>cls</code> to <code>self</code> (everywhere in the function, not just the parameter), the code would continue to work. Hell, rename it to <code>gabbledygook</code> and it'll work.</span>
