<div class="post-text" itemprop="text">
<p>I’m using Python 3.6.1, mypy, and the typing module. I created two custom types, <code>Foo</code> and <code>Bar</code>, and then used them in a dict I return from a function. The dict is described as mapping <code>str</code> to a <code>Union</code> of <code>Foo</code> and <code>Bar</code>. Then I want to use values from this dict in a function that names only one argument each:</p>
<pre><code>from typing import Dict, Union, NewType

Foo = NewType("Foo", str)
Bar = NewType("Bar", int)

def get_data() -&gt; Dict[str, Union[Foo, Bar]]:
    return {"foo": Foo("one"), "bar": Bar(2)}

def process(foo_value: Foo, bar_value: Bar) -&gt; None:
    pass

d = get_data()
</code></pre>
<p>I tried using the values as-is:</p>
<pre><code>process(d["foo"], d["bar"])
# typing-union.py:15: error: Argument 1 to "process" has incompatible type "Union[Foo, Bar]"; expected "Foo"
# typing-union.py:15: error: Argument 2 to "process" has incompatible type "Union[Foo, Bar]"; expected "Bar"
</code></pre>
<p>Or using the types:</p>
<pre><code>process(Foo(d["foo"]), Bar(d["bar"]))
# typing-union.py:20: error: Argument 1 to "Foo" has incompatible type "Union[Foo, Bar]"; expected "str"
# typing-union.py:20: error: Argument 1 to "Bar" has incompatible type "Union[Foo, Bar]"; expected "int"
</code></pre>
<p>How do I cast the <code>Union</code> to one of its subtypes?</p>
</div>
<div class="post-text" itemprop="text">
<p>You'd have to use <a href="https://docs.python.org/3/library/typing.html#typing.cast" rel="nofollow noreferrer"><code>cast()</code></a>:</p>
<pre><code>process(cast(Foo, d["foo"]), cast(Bar, d["bar"]))
</code></pre>
<p>From the <em>Casts</em> section of PEP 484:</p>
<blockquote>
<p>Occasionally the type checker may need a different kind of hint: the programmer may know that an expression is of a more constrained type than a type checker may be able to infer.</p>
</blockquote>
<p>There is no way to spell what specific types of value go with what specific value of a dictionary key. You may want to consider returning a <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="nofollow noreferrer"><em>named tuple</em></a> instead, which can be typed per key:</p>
<pre><code>from typing import Dict, Union, NewType, NamedTuple

Foo = NewType("Foo", str)
Bar = NewType("Bar", int)

class FooBarData(NamedTuple):
    foo: Foo
    bar: Bar

def get_data() -&gt; FooBarData:
    return FooBarData(foo=Foo("one"), bar=Bar(2))
</code></pre>
<p>Now the type hinter knows <em>exactly</em> what each attribute type is:</p>
<pre><code>d = get_data()
process(d.foo, d.bar)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although I think casts are probably the right option to use in your case, I just briefly want to mention one additional option which might be applicable in similar scenarios, to round things out:</p>
<p>It's actually possible to type your dict more precisely using the new, experimental <a href="http://mypy.readthedocs.io/en/latest/kinds_of_types.html#typeddict" rel="nofollow noreferrer">TypedDict</a> feature, which is available latest versions of mypy (if you clone from the github repo) and will likely be available in the next pypi release.</p>
<p>In order to use TypedDict, you'll need to install the <a href="https://pypi.python.org/pypi/mypy_extensions" rel="nofollow noreferrer"><code>mypy_extensions</code></a> from pypi by running <code>pip install mypy_extensions</code>.</p>
<p>TypedDict lets you assign individual types to each item in your dict:</p>
<pre><code>from mypy_extensions import TypedDict

Foo = NewType("Foo", str)
Bar = NewType("Bar", int)

FooBarData = TypedDict('FooBarData', {
    'foo': Foo,
    'bar': Bar,
})
</code></pre>
<p>You can also define <code>FooBarData</code> using a class-based syntax in Python 3.6+:</p>
<pre><code>from mypy_extensions import TypedDict

Foo = NewType("Foo", str)
Bar = NewType("Bar", int)

class FooBarData(TypedDict):
    foo: Foo
    bar: Bar
</code></pre>
<p>You also mentioned that your dict can have a dynamic number of elements. If it genuinely is dynamic, then TypedDict won't help for the same reasons that NamedTuple won't help, but if your TypedDict will ultimately have a finite and number of elements, and you're just progressively adding items to it instead of all at once, you can try using <a href="http://mypy.readthedocs.io/en/latest/kinds_of_types.html#totality" rel="nofollow noreferrer">non-total TypedDicts</a>, or try constructing TypeDicts that <a href="http://mypy.readthedocs.io/en/latest/kinds_of_types.html#mixing-required-and-non-required-items" rel="nofollow noreferrer">mix required and non-required items</a>.</p>
<p>It's also worth noting that unlike pretty much every other type, TypedDicts are checked using structural typing, rather then nominal typing. This means that if you define a completely unrelated TypedDict named, say, <code>QuxData</code> that also has <code>foo</code> and <code>bar</code> fields with the same type as <code>FooBarData</code>, then <code>QuxData</code> will actually be a valid subtype of <code>FooBarData</code>. This may open up some interesting possibilities with a little bit of cleverness.</p>
</div>
<span class="comment-copy">Thanks! Named tuples won’t work, because (a) the dict is variable length in the real code, and (b) I’m not a fan of namedtuple semantics (mixing dot access and item-based access, for example).</span>
<span class="comment-copy">@ChrisWarrick: sure, if you have a heterogeneous variable-length data structure, a named tuple is not going to cut it.</span>
