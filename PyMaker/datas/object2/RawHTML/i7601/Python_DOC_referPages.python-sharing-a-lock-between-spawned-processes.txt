<div class="post-text" itemprop="text">
<p>The end goal is to execute a method in background, but not in parallel : when multiple objects are calling this method, each should wait for their turn to proceed. To achieve running in background, I have to run the method in a subprocess (not a thread), and I need to start it using spawn (not fork). To prevent parallel executions, the obvious solution is to have a global lock shared between processes.<br/>
When processes are forked, which is the default on Unix, it is easy to achieve, as highlighted in both of the following codes.<br/>
We can share it as a class variable :</p>
<pre><code>import multiprocessing as mp
from time import sleep

class OneAtATime:

    l = mp.Lock()

    def f(self):
        with self.l:
            sleep(1)
        print("Hello")

if __name__ == "__main__":
    a = OneAtATime()
    b = OneAtATime()
    p1 = mp.Process(target = a.f)
    p2 = mp.Process(target = b.f)
    p1.start()
    p2.start()
</code></pre>
<p>Or we can pass it to the method :</p>
<pre><code>import multiprocessing as mp
from time import sleep

class OneAtATime:
    def f(self, l):
        with l:
            sleep(1)
        print("Hello")

if __name__ == "__main__":
    a = OneAtATime()
    b = OneAtATime()
    m = mp.Manager()
    l = mp.Lock()
    p1 = mp.Process(target = a.f, args = (l,))
    p2 = mp.Process(target = b.f, args = (l,))
    p1.start()
    p2.start()
</code></pre>
<p>Both of these codes have the appropriate behaviour of printing "hello" at one second of interval.
However, when changing the <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer">start method</a> to 'spawn', they become broken.<br/>
The first one (1) prints both "hello"s at the same time. This is because <a href="https://stackoverflow.com/questions/29199004/multiprocessing-process-with-spawn-method-which-objects-are-inherited">the internal state of a class is not pickled</a>, so they do not have the same lock.<br/>
The second one (2) fails with FileNotFoundError at runtime. I think it has to do with the fact that locks cannot be pickled : see <a href="https://stackoverflow.com/questions/25557686/python-sharing-a-lock-between-processes">Python sharing a lock between processes</a>.<br/>
In this answer, two fixes are suggested (side note : I cannot use a pool because I want to randomly create an arbitrary number of processes).<br/>
I haven't found a way to adapt the second fix, but I tried to implement the first one :</p>
<pre><code>import multiprocessing as mp
from time import sleep

if __name__ == "__main__":
    mp.set_start_method('spawn')

class OneAtATime:
    def f(self, l):
        with l:
            sleep(1)
        print("Hello")

if __name__ == "__main__":
    a = OneAtATime()
    b = OneAtATime()
    m = mp.Manager()
    l = m.Lock()
    p1 = mp.Process(target = a.f, args = (l,))
    p2 = mp.Process(target = b.f, args = (l,))
    p1.start()
    p2.start()
</code></pre>
<p>This fails with AttributeError and FileNotFoundError (3). In fact it also fails (BrokenPipe) when the fork method is used (4).<br/>
<strong>What is the proper way of sharing a lock between spawned processes ?</strong><br/>
A quick explanation of the four fails I numbered would be nice, too.
I'm running Python 3.6 under Archlinux.</p>
</div>
<div class="post-text" itemprop="text">
<p>Congratulations, you got yourself 90% of the way there.  The last step is actually not very hard to do.</p>
<p>Yes, your final code block fails with an AttributeError, but what specifically is the error?  "Can't get attribute 'OneAtATime' on ".  This is very similar to a problem you've already encountered - it's not pickling the class OneAtATime.</p>
<p>I made the following change and it worked as you'd like:</p>
<blockquote>
<p>file ooat.py:</p>
</blockquote>
<pre><code>from time import sleep

class OneAtATime:
    def f(self, l):
        with l:
            sleep(1)
        print("Hello")
</code></pre>
<blockquote>
<p>interactive shell:</p>
</blockquote>
<pre><code>import multiprocessing as mp
from oaat import OneAtATime
if __name__ == "__main__":
    mp.set_start_method('spawn')
    a = OneAtATime()
    b = OneAtATime()
    m = mp.Manager()
    l = m.Lock()
    p1 = mp.Process(target = a.f, args = (l,))
    p2 = mp.Process(target = b.f, args = (l,))
    p1.start()
    p2.start()
</code></pre>
<p>You may notice, I didn't really do anything - just split your code into two separate files.  Try it out, you'll see it works fine.  (At least, it did for me, using python 3.5 on ubuntu.)</p>
</div>
<div class="post-text" itemprop="text">
<p>The last code snippet works, provided the script does not exit prematurely. Joining processes is enough :</p>
<pre><code>import multiprocessing as mp
from time import sleep

class OneAtATime:
    def f(self, l):
        with l:
            sleep(1)
        print("Hello")

if __name__ == "__main__":
    mp.set_start_method('spawn')
    a = OneAtATime()
    b = OneAtATime()
    m = mp.Manager()
    l = m.Lock()
    p1 = mp.Process(target = a.f, args = (l,))
    p2 = mp.Process(target = b.f, args = (l,))
    p1.start()
    p2.start()
    p1.join()
    p2.join()
</code></pre>
<p>More info on the error it was causing here <a href="https://stackoverflow.com/a/25456494/8194503">https://stackoverflow.com/a/25456494/8194503</a>.</p>
</div>
<span class="comment-copy">It sounds like you've read the documentation pretty carefully.  Have you looked at the solutions in <a href="https://docs.python.org/3.6/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">17.2.1.5</a>?  You should be able to put the lock into shared memory or a manager, right?</span>
<span class="comment-copy">I tried, it's in the third code snippet. It didn't work but there are probably a lot of ways to do this, including one that does the trick.</span>
<span class="comment-copy">Sorry, I should have studied the code further before commenting.  :-)</span>
<span class="comment-copy">I temporarily deleted this answer when I saw that I forgot to test it with the spawn method.  Then when I did test, it said "OneAtATime not defined", but only because I forgot the <code>from ooat import OneAtATime</code> line.  So now I've apparently tested both fork and spawn, and it works fine.</span>
<span class="comment-copy">Answer is in your post, but not your post. It is "interactive shell". In fact the error I was getting was : AttributeError: 'ForkAwareLocal' object has no attribute 'connection'.   There I stopped trying and wrote the question, but I was a googling away from the actual solution : <a href="https://stackoverflow.com/a/25456494/8194503">stackoverflow.com/a/25456494/8194503</a>.     It works perfectly fine in the same file for me, not sure what your error was. I'll edit my question with the fix.   Not sure either what the etiquette is on wether should I accept your answer, my guess it to accept it anyway. Thanks for your time !</span>
<span class="comment-copy">If  you've solved your problem and I didn't, you should actually post your answer, wait whatever period it tells you to, and accept your own answer.  That's perfectly appropriate to do, and over time, you'll get upvotes on your answer.</span>
<span class="comment-copy">Now that you mentioned this, I should have thought of that right away.  Good research, both in the question and the answer.</span>
