<div class="post-text" itemprop="text">
<p>I've tried to always declare class attributes inside the <code>__init__</code> for clarity and organizational reasons. Recently, I've learned that strictly following this practice has extra non-aesthetic benefits too thanks to <a href="https://www.python.org/dev/peps/pep-0412/" rel="noreferrer">PEP 412</a> being added for Python 3.3.  Specifically, if all attributes are defined in the <code>__init__</code>, then the objects can reduce space by sharing their keys and hashes.</p>
<p>My question is, does object key-sharing happen when attributes are declared in a function that is called by <code>__init__</code>?</p>
<p>Here's an example:</p>
<pre><code>class Dog:
    def __init__(self):
        self.height = 5
        self.weight = 25

class Cat:
    def __init__(self):
        self.set_shape()

    def set_shape(self):
        self.height = 2
        self.weight = 10
</code></pre>
<p>In this case, all instances of <code>Dog</code> would share the keys <code>height</code> and <code>weight</code>.  Do instances of <code>Cat</code> also share the keys <code>height</code> and <code>weight</code> (among each other, not with <code>Dog</code>s of course).</p>
<p>As an aside, how would you test this?</p>
<p>Note that Brandon Rhodes said this about key-sharing in his <a href="https://youtu.be/66P5FMkWoVU?t=21m2s" rel="noreferrer"><em>Dictionary Even Mightier</em> talk</a>:</p>
<blockquote>
<p>If a single key is added that is not in the prototypical set of keys, you loose the key sharing</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>does object key-sharing happen when attributes are declared in a function that is called by <code>__init__</code>?</p>
</blockquote>
<p>Yes, regardless of where you set the attributes from, granted that after initialization both have the same set of keys, instance dictionaries use a shared-key dictionary implementation. Both cases presented have a reduced memory footprint. </p>
<p>You can test this by using <code>sys.getsizeof</code> to grab the size of the instance dictionary and then compare it with a similar dict created from it. <code>dict.__sizeof__</code>'s implementation discriminates based on this to return different sizes:</p>
<pre><code># on 64bit version of Python 3.6.1
print(sys.getsizeof(vars(c)))
112
print(getsizeof(dict(vars(c))))
240
</code></pre>
<p>so, to find out, all you need to do is compare these.</p>
<p>As for your edit:</p>
<blockquote>
<p>"If a single key is added that is not in the prototypical set of keys, you loose the key sharing"</p>
</blockquote>
<p>Correct, this is one of the two things I've (currently) found that <em>break</em> the shared-key usage:</p>
<ol>
<li>Using a non-string key in the instance dict. This can only be done in silly ways. (You could do it using <code>vars(inst).update</code>)</li>
<li><p>The contents of the dictionaries of two instances of the same class deviating, this can be done by altering instance dictionaries. (single key added to that is not in the prototypical set of keys) </p>
<p>I'm not certain if this happens when a <em>single</em> key is added, this is an implementation detail that might change. (addendum: see Martijn's comments)</p></li>
</ol>
<p>For a related discussion on this see a Q&amp;A I did here: <a href="https://stackoverflow.com/questions/42419011/why-is-the-dict-of-instances-so-small-in-python-3">Why is the __dict__ of instances so small in Python 3?</a></p>
<p>Both these things will cause CPython to use a 'normal' dictionary instead. This, of course, is an implementation detail that shouldn't be relied upon. You might or might not find it in other implementations of Python and or future versions of CPython.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you are referring to the following paragraph of the PEP (in the <a href="https://www.python.org/dev/peps/pep-0412/#split-table-dictionaries" rel="nofollow noreferrer"><em>Split-Table dictionaries</em> section</a>):</p>
<blockquote>
<p>When resizing a split dictionary it is converted to a combined table. If resizing is as a result of storing an instance attribute, and there is only instance of a class, then the dictionary will be re-split immediately. Since most OO code will set attributes in the <code>__init__</code> method, all attributes will be set before a second instance is created and no more resizing will be necessary as all further instance dictionaries will have the correct size.</p>
</blockquote>
<p>So a dictionary keys will remain shared, no matter what additions are made, <strong>before a second instance can be created</strong>. Doing so in <code>__init__</code> is the most logical method of achieving this.</p>
<p>This does <strong>not</strong> mean that attributes set at a later time are not shared; they <em>can still be shared between instances</em>; so long as you don't cause any of the dictionaries to be combined. So after you create a second instance, the keys stop being shared only if any of the following happens:</p>
<ul>
<li>a new attribute causes the dictionary to be resized</li>
<li>a new attribute is not a string attribute (dictionaries are highly optimised for the common all-keys-are-strings case).</li>
<li>an attribute is inserted in a different order; for example <code>a.foo = None</code> is set first, and then second instance <code>b</code> sets <code>b.bar = None</code> first, here <code>b</code> has an incompatible insertion order, as the shared dictionary has <code>foo</code> first.</li>
<li>an attribute is deleted. This kills sharing <strong>even for one instance</strong>. Don't delete attributes if you care about shared dictionaries.</li>
</ul>
<p>So the moment you have <em>two</em> instances (and two dictionaries sharing keys), the keys won't be re-split as long as you don't trigger any of the above cases, your instances will continue to share keys.</p>
<p>It also means that delegating setting attributes to a helper method called <em>from</em> <code>__init__</code> is not going to affect the above scenario, those attributes are still set before a second instance is created. After all <code>__init__</code> won't be able to return yet before that second method has returned.</p>
<p>In other words, you should not worry too much about where you set your attributes. Setting them in the <code>__init__</code> method lets you avoid combining scenarios more easily, but <em>any attribute set before a second instance is created</em> is guaranteed to be part of the shared keys.</p>
<p>As for how to test this: look at the memory size with the <a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="nofollow noreferrer"><code>sys.getsizeof()</code> function</a>; if creating a <em>copy</em> of the <code>__dict__</code> mapping results in a larger object, the <code>__dict__</code> table was shared:</p>
<pre><code>import sys

def shared(instance):
    return sys.getsizeof(vars(instance)) &lt; sys.getsizeof(dict(vars(instance)))
</code></pre>
<p>A quick demo:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     pass
...
&gt;&gt;&gt; a, b = Foo(), Foo()  # two instances
&gt;&gt;&gt; shared(a), shared(b)  # they both share the keys
(True, True)
&gt;&gt;&gt; a.bar = 'baz'  # adding a single key
&gt;&gt;&gt; shared(a), shared(b)  # no change, the keys are still shared!
(True, True)
&gt;&gt;&gt; a.spam, a.ham, a.monty, a.eric = (
...     'eggs', 'eggs and spam', 'python',
...     'idle')  # more keys still
&gt;&gt;&gt; shared(a), shared(b)  # no change, the keys are still shared!
(True, True)
&gt;&gt;&gt; a.holy, a.bunny, a.life = (
...     'grail', 'of caerbannog',
...     'of brian')  # more keys, resize time
&gt;&gt;&gt; shared(a), shared(b)  # oops, we killed it
(False, False)
</code></pre>
<p>Only when the threshold was reached (for an empty dictionary with 8 spare slots, the resize takes place when you add a 6th key), did the dictionaries loose the shared property.</p>
<p>Dictionaries are resized when they are about 2/3rd full, and a resize generally doubles the table size. So the next resize will take place when the 11th key is added, then at 22, then 43, etc. So for a <em>large</em> instance dictionary, you have a lot more breathing room.</p>
</div>
<span class="comment-copy">Not answering your question directly, but PyCharm has inspections which warn if you create new attributes outside of <code>__init__</code>.  So they, perhaps, consider it a bad practice.</span>
<span class="comment-copy">You do still have to add the attribute in <code>__init__</code> first though, right?</span>
<span class="comment-copy">@NathanielSaul if you want to. Point is, it makes no difference where you add them from as long as they have string keys and the dictionary of two instances doesn't deviate much in content, you get a shared-key dict.</span>
<span class="comment-copy">Thanks for the follow up. Sounds like as long as initialization happens somewhere in the <code>__init__</code>, key-sharing works.  But  if it happens after the <code>__init__</code>, key-sharing breaks.</span>
<span class="comment-copy">@NathanielSaul it all has to do with the contents for two given instances. After <code>__init__</code>, if you don't have any conditional branches that might lead to different attributes getting set, you get a shared-key dict. If you deviate, you'll fall-back to a plain dict (which actually isn't that bad memory wise with <code>3.6</code> that gives us a <a href="https://stackoverflow.com/questions/39980323/dictionaries-are-ordered-in-python-3-6/39980744#39980744">memory efficient implementation</a>)</span>
<span class="comment-copy">It will happen with a single key. What happens is: <i>any mutation</i> to the set of keys for the dictionary will cause it to be 'combined' (separated from the per-type shared keys). But if that dictionary is the <i>only</i> <code>__dict__</code> instance namespace, it'll immediately be re-split. So as long as there is only one instance, it doesn't matter how often you mutate the keys (add or remove), nor does the type of key matter. It'll be re-split each time.</span>
<span class="comment-copy">@NathanielSaul: I've clarified my answer. The point is that the 'cut-off point' is creating a second instance, at which point all keys that already exist in the shared table are seen as the 'low water mark'. Any new keys added to this can cause the shared dictionary to be turned into a regular (combined) dictionary, but only if it is resized.</span>
<span class="comment-copy">Thinking about the 'cut-off point' like that makes it much clearer.  Thank you!</span>
