<div class="post-text" itemprop="text">
<p>So the question regarding the speed of for loops vs while loops has been asked many times before. The for loop is supposed to be faster. <br/>
However, when I tested it in Python 3.5.1 the results were as follows:</p>
<pre><code>timeit.timeit('for i in range(10000): True', number=10000)
&gt;&gt;&gt; 12.697646026868842
timeit.timeit('while i&lt;10000: True; i+=1',setup='i=0', number=10000)
&gt;&gt;&gt; 0.0032265179766799434
</code></pre>
<p>The while loop runs &gt;3000 times faster than the for loop! I've also tried pre-generating a list for the for loop:</p>
<pre><code>timeit.timeit('for i in lis: True',setup='lis = [x for x in range(10000)]', number=10000)
&gt;&gt;&gt; 3.638794646750142
timeit.timeit('while i&lt;10000: True; i+=1',setup='i=0', number=10000)
&gt;&gt;&gt; 0.0032454974941904524
</code></pre>
<p>Which made the for loop 3 times faster, but the difference is still 3 orders of magnitude. <br/></p>
<p>Why does this happen?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are creating 10k <code>range()</code> objects. These take some time to materialise. You then have to create <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer"><em>iterator objects</em></a> for those 10k objects too (for the <code>for</code> loop to iterate over the values). Next, the <code>for</code> loop uses the iterator protocol by calling the <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="nofollow noreferrer"><code>__next__</code> method</a> on the resulting iterator. Those latter two steps also apply to the <code>for</code> loop over a list.</p>
<p>But most of all, you are <em>cheating</em> on the <code>while</code> loop test. The <code>while</code> loop only has to run <em>once</em>, because you never reset <code>i</code> back to <code>0</code> (thanks to <a href="https://stackoverflow.com/a/44777239/100297">Jim Fasarakis Hilliard pointing that out</a>). You are in effect running a <code>while</code> loop through a total of 19999 comparisons; the first test runs 10k comparisons, the remaining 9999 tests run one comparison. And that comparison is fast:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit('while i&lt;10000: True; i+=1',setup='i=0', number=10000)
0.0008302750065922737
&gt;&gt;&gt; (
...     timeit.timeit('while i&lt;10000: True; i+=1', setup='i=0', number=1) +
...     timeit.timeit('10000 &lt; 10000', number=9999)
... )
0.0008467709994874895
</code></pre>
<p>See how close those numbers are?</p>
<p>My machine is a little faster, so lets create a baseline to compare against; this is using 3.6.1 on a Macbook Pro (Retina, 15-inch, Mid 2015) running on OS X 10.12.5. And lets also fix the <code>while</code> loop to set <code>i = 0</code> in the test, not the setup (which is run just once):</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit('for i in range(10000): pass', number=10000)
1.9789885189966299
&gt;&gt;&gt; timeit.timeit('i=0\nwhile i&lt;10000: True; i+=1', number=10000)
5.172155902953818
</code></pre>
<p>Oops, so a correctly running <code>while</code> is actually <strong>slower</strong> here, there goes your premise (and mine!).</p>
<p>I used <code>pass</code> to avoid having to answer question about how fast referencing that object is (it's fast but besides the point). My timings are going to be 6x faster than your machine.</p>
<p>If you wanted to explore why the iteration is faster, you could time the various components of the <code>for</code> loop in Python, starting with creating the <code>range()</code> object:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('range(10000)', number=10000)
0.0036197409499436617
</code></pre>
<p>So creating 10000 <code>range()</code> objects takes more time than running a single <code>while</code> loop that iterates 10k times. <code>range()</code> objects are more expensive to create than integers.</p>
<p>This does involves a global name lookup, which is slower, you could make it faster by using <code>setup='_range = range'</code> then use <code>_range(1000)</code>; this shaves of about 1/3rd of the timings.</p>
<p>Next, create an iterator for this; here I'll use a local name for the <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter()</code> function</a>, as the <code>for</code> loop doesn't have to do a hash-table lookup and just reaches for the C function instead. Hard-coded references to a memory location in a binary is a lot faster, of course:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('_iter(r)', setup='_iter = iter; r = range(10000)', number=10000)
0.0009729859884828329
</code></pre>
<p>Fairly fast, but; it takes the same amount of time as your single <code>while</code> loop iterating 10k times. So creating iterable objects is cheap. The C implementation is faster still. We haven't iterated yet.</p>
<p>Last, we call <code>__next__</code> on the iterator object, 10k times. This is again done in C code, with cached references to internal C implementations, but with a <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial()</code> object</a> we can at least <em>attempt</em> to get a ball-park figure:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('n()', setup='from functools import partial; i = iter(range(10000)); n = partial(i.__next__)', number=10000) * 10000
7.759470026940107
</code></pre>
<p>Boy, 10k times 10k calls to <code>iter(range(1000)).__next__</code> takes almost 4x more time than the <code>for</code> loop managed; this goes to show how efficient the actual C implementation really is.</p>
<p>However, it does illustrate that looping in C code is a lot faster, and this is why the <code>while</code> loop is actually slower when executed correctly; summing integers and making boolean comparisons in bytecode takes more time than iterating over <code>range()</code> in C code (where the CPU does the incrementing and comparisons directly in CPU registers):</p>
<pre><code>&gt;&gt;&gt; (
...     timeit.timeit('9999 + 1', number=10000 ** 2) +
...     timeit.timeit('9999 &lt; 10000', number=10000 ** 2)
... )    
3.695550534990616
</code></pre>
<p>It is those operations that make the <code>while</code> loop about 3 seconds slower.</p>
<hr/>
<p>TLDR: You didn't actually test a <code>while</code> loop correctly. I should have noticed this earlier too.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are timing things incorrectly, <code>setup</code> is only executed <em>once</em> and then the value of <code>i</code> is <code>10000</code> for <em>all consequent runs</em>. See the documentation on <a href="https://docs.python.org/3/library/timeit.html#timeit.Timer.timeit" rel="nofollow noreferrer"><code>timeit</code></a>:</p>
<blockquote>
<p>Time number executions of the main statement. This executes the <code>setup</code> statement once, and then returns the time it takes to execute the main statement a number of times, measured in seconds as a float.</p>
</blockquote>
<p>Additionally verify it by printing <code>i</code> for each repetition:</p>
<pre><code>&gt;&gt;&gt; timeit('print(i)\nwhile i&lt;10000: True; i+=1',setup='i=0', number=5)
0
10000
10000
10000
10000
</code></pre>
<p>As a result, all consequent runs merely perform a comparison (which is <code>True</code>) and finish early.</p>
<p>Time correctly and see how the <code>for</code> loop is actually faster:</p>
<pre><code>&gt;&gt;&gt; timeit('i=0\nwhile i&lt;10000: True; i+=1', number=10000)
8.416439056396484
&gt;&gt;&gt; timeit('for i in range(10000): True', number=10000)
5.589155912399292
</code></pre>
</div>
<span class="comment-copy">I can't quite get the scale of time difference you get; creating a <code>range()</code> object has a cost, just not that large a cost. Even on Python 2 I can't get it to go all the way to 12.7 seconds.</span>
<span class="comment-copy">Ah, my laptop is just 6 times faster, that's all.</span>
<span class="comment-copy">what python are you running? it this a debug build where differences are bigger?</span>
<span class="comment-copy">@Alex Python 3.5.1. My laptop is slow, so I expect large absolute time. But do you get wildly different relative difference?</span>
<span class="comment-copy">I have the almost same laptop as Martijn.</span>
