<div class="post-text" itemprop="text">
<p>I have two following files:</p>
<p><strong>testcase_module.py</strong></p>
<pre><code>import boto3


ec2 = boto3.resource('ec2')


def f():
    return ec2.instances.all()
</code></pre>
<p><strong>testcase_test.py</strong></p>
<pre><code>import testcase_module
import unittest.mock


class MainTest(unittest.TestCase):
    @unittest.mock.patch('testcase_module.ec2', spec_set=['instances'])
    def test_f(self, ec2_mock):
        ec2_mock.instances.spec_set = ['all']
        testcase_module.f()


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>I added <code>spec_test</code> parameter to the patch because I would like to assert if any other function than <code>instances.all()</code> has been called, but changing string <code>'all'</code> to <code>'allx'</code> doesn't make test fail while changing <code>'instances'</code> to <code>'instancesx'</code> does. I tried the following changes (<code>git diff testcase_test.py</code> and <code>python testcase_test.py</code> results below):</p>
<p><strong>Attempt 1:</strong></p>
<pre><code>diff --git a/testcase_test.py b/testcase_test.py
index d6d6e59..ae274c8 100644
--- a/testcase_test.py
+++ b/testcase_test.py
@@ -3,9 +3,8 @@ import unittest.mock


 class MainTest(unittest.TestCase):
-    @unittest.mock.patch('testcase_module.ec2', spec_set=['instances'])
-    def test_f(self, ec2_mock):
-        ec2_mock.instances.spec_set = ['all']
+    @unittest.mock.patch('testcase_module.ec2', spec_set=['instances.all'])
+    def test_f(self, _):
         testcase_module.f()
</code></pre>
<p>Produces:</p>
<pre><code>E
======================================================================
ERROR: test_f (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/usr/lib/python3.5/unittest/mock.py", line 1157, in patched
    return func(*args, **keywargs)
  File "testcase_test.py", line 8, in test_f
    testcase_module.f()
  File "/path/to/project/testcase_module.py", line 8, in f
    return ec2.instances.all()
  File "/usr/lib/python3.5/unittest/mock.py", line 578, in __getattr__
    raise AttributeError("Mock object has no attribute %r" % name)
AttributeError: Mock object has no attribute 'instances'

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (errors=1)
</code></pre>
<p><strong>Attempt 2:</strong></p>
<pre><code>diff --git a/testcase_test.py b/testcase_test.py
index d6d6e59..d93abd1 100644
--- a/testcase_test.py
+++ b/testcase_test.py
@@ -3,9 +3,8 @@ import unittest.mock


 class MainTest(unittest.TestCase):
-    @unittest.mock.patch('testcase_module.ec2', spec_set=['instances'])
-    def test_f(self, ec2_mock):
-        ec2_mock.instances.spec_set = ['all']
+    @unittest.mock.patch('testcase_module.ec2.instances', spec_set=['all'])
+    def test_f(self):
         testcase_module.f()
</code></pre>
<p>Produces:</p>
<pre><code>E
======================================================================
ERROR: test_f (__main__.MainTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/usr/lib/python3.5/unittest/mock.py", line 1149, in patched
    arg = patching.__enter__()
  File "/usr/lib/python3.5/unittest/mock.py", line 1312, in __enter__
    setattr(self.target, self.attribute, new_attr)
AttributeError: can't set attribute

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/lib/python3.5/unittest/mock.py", line 1170, in patched
    patching.__exit__(*exc_info)
  File "/usr/lib/python3.5/unittest/mock.py", line 1334, in __exit__
    delattr(self.target, self.attribute)
AttributeError: can't delete attribute

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (errors=1)
</code></pre>
<p>How can I make it failing when other method than <code>instances.all</code> has been called?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try using <code>mock_add_spec</code>.</p>
<p><code>ec2_mock.instances.mock_add_spec(['all'], spec_set=True)</code></p>
<p>Link: <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.mock_add_spec" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.mock_add_spec</a></p>
</div>
<div class="post-text" itemprop="text">
<p>What about doing it like this:</p>
<pre><code>@unittest.mock.patch('testcase_module.boto3.resource', autospec=True)
def test_f(self, ec2_resource_mock):
    class InstanceStub(object):
        def all(self):
            return [...]
    ec2_resource_mock.return_value = mock.create_autospec(
        EC2InstanceType, instances=InstanceStub())
    testcase_module.f()
</code></pre>
</div>
<span class="comment-copy">What is <code>EC2InstanceType</code>?</span>
<span class="comment-copy">And why it is so important to mock <code>resource</code> function instead of <code>ec2</code> object? I am asking, because you are not the first person suggesting this approach, but I am still not able to understand the difference in practice. Mocking <code>resource</code> seems to be a bit more complicated.</span>
<span class="comment-copy">That's the easiest way since you're really interested in constraining the return value of resource.</span>
<span class="comment-copy">This is not an answer for the question 'why'. Mocking ec2 object sounds easier for me. Why mocking resource is easier for you?</span>
<span class="comment-copy">It's because ec2 is just a name, the return value of reference call is what you are really interested in.</span>
