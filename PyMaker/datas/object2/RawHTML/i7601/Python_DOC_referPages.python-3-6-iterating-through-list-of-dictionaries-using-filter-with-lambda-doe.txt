<div class="post-text" itemprop="text">
<p>There is a list of dictionaries I need to iterate through and filter in dictionaries which meet criterion and then return only values under key1. I'm using filter, as follows:</p>
<pre><code>res = list(filter(lambda x: x["key1"] if ["key2"] == criterion else False, list_of_dicts))
</code></pre>
<p>the iterator works alright returning only those results which meet criterion. But it returns the whole dictionary rather than only <code>x["key1"]</code>.
I'm thinking it's something to do with filter but have no clue. </p>
<p>Q1: Can someone explain why it returns whole dict rather then only value under key1?</p>
<p>Q2: is there a workaround to make filter to return only value under key1?</p>
<p>P.S. there is no problem to do it through list comprehension like that:</p>
<pre><code>res = [i["key1"] for i in list_of_dicts if i["key2"] == criterion]
</code></pre>
<p>But I was just curious why filter doesn't return <code>i["key1"]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Filtering is <em>not the same thing as mapping</em>. Filtering <em>selects</em> based on your criteria, a yes/no decision on wether or not to include one of your values. </p>
<p>In fact, you are filtering on both <code>key2</code> <em>and the truth value of <code>key1</code></em>; if the value for <code>key1</code> is ever set to <code>None</code> or <code>0</code> or another <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">false value</a>, you'd also drop that specific dictionary, which I don't think you really wanted.</p>
<p>You want to filter <em>and map</em>, so extract the right key from dictionaries that passed the filter. That's actually best done with a list comprehension instead:</p>
<pre><code>res = [x["key1"] for x in list_of_dicts if ["key2"] == criterion]
</code></pre>
<p>You can still do it using <code>filter()</code>, if you must, but then you need to add a <code>map()</code> call to this to actually do the mapping:</p>
<pre><code>res = list(map(lambda x: x["key1"], filter(lambda x: ["key2"], list_of_dicts)))
</code></pre>
<p>But as you notice, that gets verbose and unreadale really quickly. You could use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter()</code> objects</a> to replace the <code>lambda</code>s:</p>
<pre><code>from operator import itemgetter

res = list(map(itemgetter("key1"), filter(lambda d: d["key2"] == condition, list_of_dicts)))
</code></pre>
<p>but readability doesn't improve much with that. </p>
</div>
<div class="post-text" itemprop="text">
<p>A filter simply <em>filters</em>: it takes as input an iterable, and produces an interable with the items that satisfy the criterion.</p>
<p>What you want is an additional <em><code>map</code>ping</em>:</p>
<pre><code><b>from operator import itemgetter</b>

<b>key1 = itemgetter('key1')</b>

res = list(<b>map(key1,</b>filter(lambda x: ["key2"] == criterion, list_of_dicts)<b>)</b>)</code></pre>
<p>Mind that you do not need to use <code>x['key1'] if ... else False</code> in the criterion: the <code>filter(..)</code> will simply evaluate the function, and inspect the <em>truthiness</em> of the result. If it is <code>True</code>, it will emit the item, otherwise it will ignore the item.</p>
</div>
<span class="comment-copy">I am not so sure it's faster than the list comprehension, I've done a lot of tests with map vs list comprehension and only when the variable is very large does map edge ahead, although I can't speak for filter and itemgetter ._.</span>
<span class="comment-copy">@new_to_coding: it is faster, because the list comprehension loop is executed entirely as bytecode interpretation steps, including the filter test and extraction expression. It is the combination of <code>itemgetter()</code> and <code>map()</code> and <code>filter()</code> here that is the real speed devil, <i>all of the execution</i> is done entirely in C code, outside of the interpreter loop.</span>
<span class="comment-copy">@new_to_coding: I did make a mistake; the filter has to test for equality against a condition, at which point the performance boost is diminished.</span>
<span class="comment-copy">@MartijnPieters thanks for you response Martjin, it's very clear especially with map function. As Willem noted, filter returns an iterable. So, I was just wondering if iterable is returned why filter can't handle it just like it handles iterable object which it accepts in its constructor?</span>
<span class="comment-copy">@Vlad: I'm not sure what you are asking. <code>filter()</code> is a very specific tool. It filters, it doesn't map as well. If you are asking why it can't return the same type of object that you handed it: because an iterable is an <i>interface</i>, and loads of different types can implement it. Not all of those can be recreated just like that, they all can have a different method of creation.</span>
<span class="comment-copy">Thanks for the threory Willem! it makes sense now.</span>
