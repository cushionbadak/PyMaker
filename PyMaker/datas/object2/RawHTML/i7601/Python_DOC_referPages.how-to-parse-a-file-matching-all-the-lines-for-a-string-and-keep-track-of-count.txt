<div class="post-text" itemprop="text">
<p>We have a file with following lines in it,
we need to find all the lines with "Error" message type..
save the message and its count and print the messages in the descending order of count,can anyone provide guidance on how to do this?</p>
<p>file.txt</p>
<pre><code>&lt;TIMESTAMP&gt;&lt;MESSAGETYPE&gt;&lt;MESSAGE&gt;
&lt;4:02&gt;&lt;ERROR&gt;&lt;Error message1&gt;
&lt;14:13&gt;&lt;Error&gt;&lt;Error message2&gt;
&lt;10:03&gt;&lt;Warning&gt;&lt;Warning message1&gt;
&lt;12:03&gt;&lt;Warning&gt;&lt;Warning message2&gt;
</code></pre>
<p>CODE:-</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>Open the file and read all lines  </li>
</ol>
<p></p>
<pre><code>with open("file.txt") as f:  
    lines = f.read().splitlines()
</code></pre>
<ol start="2">
<li>Make a list of lines that contain the word "Error"  </li>
</ol>
<p> </p>
<pre><code>data = [ line.lstrip('&lt;').rstrip('&gt;').split('&gt;&lt;') for line in lines if 'Error' in line  ]
</code></pre>
<ol start="3">
<li>Get the time and message items from the <code>data</code> list  </li>
</ol>
<p></p>
<pre><code>errors = [ { 'time' : line[0], 'message': line[-1] } for line in data ]  
</code></pre>
<ol start="4">
<li>Sort the <code>errors</code> list by 'time' in descending order  </li>
</ol>
<p> </p>
<pre><code>errors.sort(key=lambda e : e['time'], reverse=True)  
</code></pre>
<p>Note that <code>errors</code> is a list of dictionaries, you can use lists if you like.<br/>
If you want to print the results :  </p>
<pre><code>print '\n'.join( 'Time {:8} Error {}'.format(e['time'], e['message']) for e in errors )
</code></pre>
<p>Output :  </p>
<pre><code>Time: 4:02   Error: Error message1
Time: 14:13  Error: Error message2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For similar task, I used next trick:</p>
<pre><code>fname = "summary.log"
with open(fname) as f:
    content = f.readlines()
content = [x.strip() for x in content]
commits = []

def onHeader(obj):
    date = obj.group(1)
    time = obj.group(2)
    commits.append(CCommitInfo(date, time))

def onFile(obj):
    added = int(obj.group(1))
    removed = int(obj.group(2))
    commits[-1].changed(added, removed)

matchers = []
matchers.append((re.compile(r"(.+?)\s(.+?)\s\+\d+$"), onHeader))
matchers.append((re.compile(r"^(\d+)\t(\d+).+\.(php|pas)"), onFile))

def match(s):
    for x in matchers:
        r = x[0].search(s)
        if r:
            x[1](r)
            break

for x in content:
    match(x)
</code></pre>
<p>Sorry for code "as is". As you can see, I just add to <code>matchers</code> pairs regexp-callback  and match them to each line. Simple and  powerful.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do something like this:</p>
<pre><code>from collections import defaultdict
import operator
import re

def find_error_message(string):
    match = re.search(r"&lt;\d{1,2}:\d{2}&gt;&lt;(ERROR|Error)&gt;&lt;(?P&lt;message&gt;[a-zA-z0-9 ]*)&gt;(\n)?", string)
    if match:
        return match.group("message")

messages = defaultdict(int)
with open(r"log.txt", "r") as fh:
    lines = fh.readlines()

lines.pop(0)
for line in lines:
    message = find_error_message(line)
    if message:
        messages[message] += 1
for message, count in sorted(messages.items(), key=operator.itemgetter(1), reverse=True):
    print("{}: {}".format(message, count))
</code></pre>
<p>The <code>find_error_message</code> function is just checking each line in the file to see if it's an error, and returning the error message if it is.</p>
<p>The file <code>log.txt</code> is opened, and all the lines in it are read into a list. Then we <code>pop</code> the first element, which is the header. Then we go through each line, and check it to see if there's an error message. If there is we increase the count for that particular error message.  </p>
<p>Once we've checked all the lines, we sort the dictionary <code>messages</code>, except that we want to a) sort it by the dictionary values, and b) sort it in reverse. </p>
<p>Finally, we print the sorted elements in order, and the number of times they occurred.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using the <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter</a> class</p>
<pre><code>from re import compile, IGNORECASE
from collections import Counter
from operator import itemgetter

parse = compile(r'&lt;(?P&lt;ts&gt;.*)&gt;&lt;(?P&lt;level&gt;ERROR)&gt;&lt;(?P&lt;message&gt;.*)&gt;', IGNORECASE)

with open('file.txt') as f:
    logs = filter(None, map(parse.match, f))
    counts = Counter(log.group('message') for log in logs)

print sorted(counts.items(), key=itemgetter(1), reverse=True)


&gt;&gt;&gt; [('Error message1', 1), ('Error message2', 1)]
</code></pre>
</div>
<span class="comment-copy">This looks like a computer programming assignment to learn python. If you want to learn python, why are you asking us?</span>
<span class="comment-copy"><code>... guidance on how to do this?</code> - Spend some time with <a href="https://docs.python.org/3/tutorial/index.html" rel="nofollow noreferrer">The Tutorial</a>, practice all the examples given.  After a while you will start to get ideas for solving your problem.  Try one or a few of those ideas out - if you have problems with them, come back and ask a question.</span>
<span class="comment-copy">what is <code>{:8}</code> in final print and why do we need it?what happens if it is nor present</span>
<span class="comment-copy">It's a formatting option that adds some spacing. You don't need to have it, you can just use <code>{}</code> or change it's value, eg: <code>{:12}</code> . It just looks better this way. You can read more about it here <a href="https://docs.python.org/3.4/library/string.html#string-formatting" rel="nofollow noreferrer">string-formatting</a></span>
<span class="comment-copy">It basically adds a value into a string</span>
<span class="comment-copy">Step 2 is a very fragile way to parse a line, <a href="https://docs.python.org/2/library/re.html" rel="nofollow noreferrer">regular expressions</a> are the way to go. Use <a href="https://regex101.com" rel="nofollow noreferrer">Regex101</a> to help refine the incantation you need. Using <code>re</code> you don't need step 3. Step 4 sorts by time, not by error <b>message count</b>, which was the question, also the <code>lambda</code> is <a href="https://docs.python.org/2/library/operator.html#operator.itemgetter" rel="nofollow noreferrer">itemgetter</a>, and finally the print out is missing a trailing '\n'. How about <code>print ''.join(map('Time {0[time]:8} Error {0[message]}\n'), errors)</code></span>
<span class="comment-copy">errata: print example should have been <code>print ''.join(map('Time {0[time]:8} Error {0[message]}\n'.format, errors))</code></span>
<span class="comment-copy">where are you looking for "error" ?need an exact solution</span>
