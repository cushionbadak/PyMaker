<div class="post-text" itemprop="text">
<p>I'm trying to provide a unified interface for retrieving all files from a single directory or a list of directories. </p>
<pre><code>def get_files(dir_or_dirs):
    def helper(indir):
        file_list = glob.glob("*.txt")
        for file in file_list:
            yield file

    if type(dir_or_dirs) is list:
        # a list of source dirs
        for dir in dir_or_dirs:
            yield helper(dir)
    else:
        # a single source dir
        yield helper(dir_or_dirs)

def print_all_files(file_iter):
    for file in file_iter:
        print(file)        # error here!
</code></pre>
<p>Questions:</p>
<ol>
<li>error says 'file' is still a generator regardless of the input being a single dir or a list of it. Why is it still a generator? </li>
<li>is it possible to wrap or embed generators in functions? If so, how to make this work? </li>
</ol>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You are yielding <code>helper()</code> each time:</p>
<pre><code>yield helper(dir)
</code></pre>
<p>but <code>helper()</code> itself is a generator.</p>
<p>In Python 3.3 and newer, use <code>yield from</code> instead:</p>
<pre><code>yield from helper(dir)
</code></pre>
<p>This <em>delegates</em> control to another generator. From the <a href="https://docs.python.org/3/reference/expressions.html#yield-expressions" rel="nofollow noreferrer"><em>Yield expressions</em></a> documentation:</p>
<blockquote>
<p>When <code>yield from &lt;expr&gt;</code> is used, it treats the supplied expression as a subiterator. All values produced by that subiterator are passed directly to the caller of the current generatorâ€™s methods.</p>
</blockquote>
<p>In older Python versions, including Python 2.x, use another loop:</p>
<pre><code>for file in helper(dir):
    yield file
</code></pre>
<p>For more information on what <code>yield from</code> does, see <a href="https://www.python.org/dev/peps/pep-0380/" rel="nofollow noreferrer">PEP 380 -- <em>Syntax for Delegating to a Subgenerator</em></a>.</p>
<p>Not that you really need the helper function, it does little more than just loop over the <code>glob.glob()</code> results, you can do that <em>directly</em>. </p>
<p>You also need to correct your function to actually use <code>indir</code>; currently you are ignoring that argument, so you only get text files from the <em>current working directory</em>.</p>
<p>Next, you want to use <a href="https://docs.python.org/3/library/glob.html#glob.iglob" rel="nofollow noreferrer"><code>glob.iglob()</code></a> instead of <code>glob.glob()</code> to get the lazy evaluation over <code>os.scandir()</code> rather than load all results into memory at once. I'd just turn a non-list <code>dir_or_dirs</code> value into a list, then just use one loop:</p>
<pre><code>import glob
import os.path

def get_files(dirs):
    if not isinstance(dirs, list):
        # make it a list with one element
        dirs = [dirs]

    for dir in dirs:
        pattern = os.path.join(dir, '*.txt')
        yield from glob.iglob(pattern)
</code></pre>
<p>Now, instead of a single argument that is either a string or a list, I'd use a variable number of arguments instead, with the <code>*args</code> parameter syntax:</p>
<pre><code>def get_files(*dirs):
    for dir in dirs:
        pattern = os.path.join(dir, '*.txt')
        yield from glob.iglob(pattern)
</code></pre>
<p>This can be called with 0 or more directories:</p>
<pre><code>for file in get_files('/path/to/foo', '/path/to/bar'):
    # ...
</code></pre>
</div>
<span class="comment-copy">Why are you trying to <code>yield</code> the return value of <code>helper</code>? Helper is a generator function, and it returns a generator iterator. If you want to yield everything the generator yields, that's <code>yield from</code>.</span>
<span class="comment-copy">was trying to get a generator for all files under all dirs. Thanks for the 'yield from' heads-up!</span>
<span class="comment-copy">If you just want to know if you can loop over something, <code>isinstance(dirs, collections.abc.Iterable)</code> is a better check to use, since that works for any iterable, not just list. A more pythonic way might be to take dirs as a vararg: <code>def get_files(*dirs)</code>, then the caller can call with a single argument, varargs, or a list by way of <code>get_dirs(*iterable_argument)</code>.</span>
<span class="comment-copy">@zstewart: no, using <code>collections.abc.Iterable</code> is <i>not</i> a better check, because strings are iterables too. A single directory would then be treated as separate individual characters.</span>
<span class="comment-copy">Thanks! the py2.7 tips worked! I'll try with py3 too. Also thanks for the illustration and further tips for improve the python code quality!</span>
<span class="comment-copy">@MartijnPieters Oh, right. Duh. I would personally still pick a solution which works for any iterable. <code>*dirs</code> might be the best option, since it leave open duck typing of both individual arguments and the iterable argument. Though it does mean that any iterable argument is evaluated eagerly. Another option is to explicitly check for the types of arguments accepted by <code>os.path.join</code> (<code>str</code>, <code>bytes</code>, and in 3.6+ <code>os.PathLike</code>) and only convert those to a new single-element list/tuple. Then <code>get_files</code> would be able to lazily evaluate a lazy iterator passed to it.</span>
<span class="comment-copy">@zstewart: at which point you just put your foot down and have the API only accept a single iterable of directories, and simply avoid ducktyping.</span>
