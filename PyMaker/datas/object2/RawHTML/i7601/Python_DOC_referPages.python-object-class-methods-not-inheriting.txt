<div class="post-text" itemprop="text">
<p>In Python operator overloading is achieved by defining special method in the class. For example, to use <code>+</code> operator, define <code>__add__</code> method. There are many other special methods for different operators. In addition to that, all these special operators comes from <code>object</code> class which is the base class for every other class. That means every class inherits special method like <code>__add__</code>, <code>__ge__</code>, <code>__le__</code> and so on.</p>
<p>Now Consider the following code.</p>
<pre><code>class test_class:
    def ring(self):
        print("ring")

obj = test_class() 
print(obj.__ge__) 
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&lt;method-wrapper '__ge__' of test_class object at 0x0000000002247EF0&gt;
</code></pre>
<p>But when I try to access <code>__add__</code> using <code>obj</code> object, it gives me following error:</p>
<pre><code>AttributeError: 'test_class' object has no attribute '__add__'
</code></pre>
<p>Why is that ? Does that mean <code>__add__</code> method doesn't inherit from the <code>object</code> class ? What's exactly going on ?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__add__</code> function is not an attribute of <code>object</code>. It is a function found in the <a href="https://docs.python.org/3/library/operator.html#operator.add" rel="nofollow noreferrer">operator</a> module. You can provide your own implementation of this by implementing your own version of these methods <em>in</em> your class. </p>
<p>This is also explained in the documentation <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">here</a>. </p>
<p>Observe:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     def __add__(self, x):
...         print("I took over the add with {}".format(x))
...
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f + 100
I took over the add with 100
&gt;&gt;&gt;
</code></pre>
<p>Furthermore, even if you look at what is provided to you from <code>object</code>, you will see: </p>
<pre><code>&gt;&gt;&gt; dir(object)
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
&gt;&gt;&gt;
</code></pre>
<p>There is no implementation of the <code>__add__</code> you are looking to override. These operators are <em>overridable</em> by declaring them yourself in your class.</p>
<p>To provide <em>some</em> context around why operators like <code>__eq__</code> (and other comparison operators) operator might be implemented as part of object and not <code>__add__</code> as an example, is because, per the documentation as well (<a href="https://docs.python.org/3/reference/datamodel.html#object.__ne__" rel="nofollow noreferrer">here</a>), these <em>equality</em> operators are <em>rich-comparison</em> methods and they provide their <em>own</em> implementation in the base object. If you take a look at the implementation of the <code>object</code> class, you will see a docstring mention of what will be returned when you actually use these operators with instance objects:</p>
<pre><code>def __ge__(self, *args, **kwargs): # real signature unknown
    """ Return self&gt;=value. """
    pass
</code></pre>
<p>As an example, you can see it mentions that when you try to perform a "&gt;" with instances that inherit from object, they will use <em>that</em> implementation.  </p>
</div>
<span class="comment-copy">Is it just that object provides a <code>__ge__</code> method, and doesn't provide a <code>__add__</code> method ...?</span>
<span class="comment-copy">As per documentation <code>object</code> class provides <code>__ge__</code> as well as <code>__add__</code>. See <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html</a></span>
<span class="comment-copy">That documentation says "The following methods <b>can be</b> defined to emulate numeric objects"</span>
<span class="comment-copy">So you mean they are not coming from <code>object</code> class ?</span>
<span class="comment-copy">Objects by default have <b>no</b> implementation of <code>__add__</code>. You cannot add two arbitrary objects.</span>
<span class="comment-copy">I am asking for <code>__add__</code> not <code>__iadd__</code></span>
<span class="comment-copy">@Cody Thanks for pointing that, still does not change the answer. I updated it for the right method though.</span>
<span class="comment-copy">Does that mean <code>__ge__</code>  method also comes from operator module ?</span>
<span class="comment-copy">@Cody A good approach to see what is available to you, is if you notice near the bottom of my answer I did a <code>dir(object)</code>. The <a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow noreferrer">dir</a> built-in will give you all those attributes available in that object. You can see what is available to you. Furthermore, the documentation provides very good resources on what functions are and are not available. The links I provided will offer you a good basis of understanding of that. If there is anything that is not clear in my answer, let me know, and I will clarify.</span>
<span class="comment-copy">What I am unable to grasp is that some methods like <code>__ge__</code> inherits from <code>object</code> class while some from the operator module(as you told me). Then what's the point of defining them in the base <code>object</code> class. We are redefining same methods in two places. Why is that  ?</span>
