<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; type(OptimizedRectangle) 
    &lt;class 'type'&gt;    
&gt;&gt;&gt; type(OptimizedRectangle.get_area)
&lt;class 'function'&gt;
</code></pre>
<p>So a method of a class is an instance of class <code>function</code>. </p>
<pre><code>&gt;&gt;&gt; type(function)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'function' is not defined
</code></pre>
<p>Since <code>function</code> is a class and a class is an object, what is the type of <code>function</code>, i.e. what is it an instance of?    </p>
<p>As the comments suggested</p>
<pre><code>&gt;&gt;&gt; type(type(OptimizedRectangle.get_area))
&lt;class 'type'&gt;
</code></pre>
<p>Then why does <code>type(function)</code> not work? Is <code>function</code> a class, of which a class's method is an instance?</p>
<hr/>
<p>Similarly, why does <code>type(module)</code> not work?</p>
<pre><code>&gt;&gt;&gt; type(builtins)
&lt;class 'module'&gt;
&gt;&gt;&gt; type(module)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'module' is not defined
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The built-in module <a href="https://docs.python.org/3/library/types.html" rel="nofollow noreferrer"><code>types</code></a> stores all kind of different types that are used throughout the language. It contains also the <a href="https://docs.python.org/3/library/types.html#types.FunctionType" rel="nofollow noreferrer"><code>FunctionType</code></a> which corresponds to the instance method:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     def bar(self):
...         pass
&gt;&gt;&gt; type(Foo.bar) is types.FunctionType
True
</code></pre>
<p>When calling <code>type(Foo.bar)</code> in the interpreter then the output is <code>&lt;class 'function'&gt;</code> however this does not necessarily mean that the class's name is <code>'function'</code> but it is just the class's representation (<code>__repr__</code>):</p>
<pre><code>&gt;&gt;&gt; type(types.FunctionType).__repr__(type(Foo.bar))
"&lt;class 'function'&gt;"
</code></pre>
<p>As pointed out in the comments <code>types.FunctionType</code> also only holds a reference to the type of functions which is defined at the implementation level.</p>
<p>The type of <code>FunctionType</code> is <code>type</code> again, that is <code>FunctionType</code> is an instance of <code>type</code> (as it is the case for all classes).</p>
<p>Also note the peculiarity</p>
<pre><code>&gt;&gt;&gt; type(type) is type
True
</code></pre>
<p>which means that type is its own class (i.e. <code>type.__class__</code> pointing to itself). This is achieved at the implementation level.</p>
</div>
<div class="post-text" itemprop="text">
<p>A function is the simplest callable object in Python.
<a href="https://en.wikibooks.org/wiki/Python_Programming/Functions" rel="nofollow noreferrer">read more here</a></p>
</div>
<span class="comment-copy">Did you try <code>type(type(OptimizedRectangle.get_area))</code> ?</span>
<span class="comment-copy">That should be obvious. <code>type(...)</code> returns a type. So <code>type(type(...))</code> will be <code>type</code>.</span>
<span class="comment-copy">FunctionType:  <a href="https://docs.python.org/2/library/types.html#types.FunctionType" rel="nofollow noreferrer">docs.python.org/2/library/types.html#types.FunctionType</a> <a href="https://docs.python.org/3.6/library/types.html#types.FunctionType" rel="nofollow noreferrer">docs.python.org/3.6/library/types.html#types.FunctionType</a></span>
<span class="comment-copy"><code>function</code> and <code>module</code> are instances of <code>type</code>. You get <code>NameError</code>s because <code>function</code> and <code>module</code> aren't defined anywhere.</span>
<span class="comment-copy">The fact that the class is named <code>function</code> or <code>module</code> doesn't mean it's actually available through name lookup for the name <code>function</code> or <code>module</code>. Those are two different kinds of names, only linked by convention and by the default behavior of the <code>class</code> statement.</span>
<span class="comment-copy">Be aware that the <code>types</code> module isn't special. It's not where any of the <code>types.Whatever</code> types are implemented, and the names defined there aren't the "real" names or anything. For example, to define <code>types.FunctionType</code>, <code>types.py</code> just defines a function <code>_f</code> and sets <code>FunctionType = type(_f)</code>.</span>
<span class="comment-copy">Thanks. "The built-in module types stores all kind of different types that are used throughout the language. " Since the types defined in the module <code>types</code> are used throughout the language, why are they not defined as builtin types (like <code>list</code>, <code>int</code>) in the language, but in module <code>types</code> in the standard library?</span>
<span class="comment-copy">@Tim All objects that you can use in Python without additional imports are stored in the module <code>__builtins__</code>. Those objects build the "basis" of the language and are likely to be used often (for example conversions to <code>int</code> or <code>list</code>). For the definition of a function however there is the <code>def</code> statement, i.e. no need to refer to the specific type. Also with duck typing users will likely test for <code>callable(...)</code> rather than compare to <code>FunctionType</code>. The objects stored in <code>types</code> rather provide a standard for comparing the specific types of certain objects (whenever that is required).</span>
<span class="comment-copy">Thanks. @a_guest. "All objects that you can use in Python without additional imports are stored in the module <code>__builtins__</code>". Do you mean that in Python 3, all builtin types such as <code>int</code> and <code>dict</code> are  imported from module <code>builtins</code>? Aren't they built-ins of the language, instead of a module?</span>
<span class="comment-copy">@Tim To be precise the name of the module is <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow noreferrer"><code>builtins</code></a> but it is made available by binding it to the name <code>__builtins__</code> (at least for CPython). The built-in types are implemented in the language of the interpreter (C for CPython for example) and are made available through this <code>builtins</code> module. This makes the language more self-contained because those built-ins can be treated just as regular Python objects (the same way as user-defined objects). Otherwise this information about built-ins would have to be stored in the compiler somewhere.</span>
