<div class="post-text" itemprop="text">
<p>I have a single end-to-end Selenium integration test which consists of several steps with each step setting certain state and passing the data over to the next step.</p>
<p>Test scenario:</p>
<pre><code>1. Create item.
2. Assign item to group.
3. Approve item.
...
4. Publish item.
</code></pre>
<p>The steps are not atomic and depend on each other. The test class extends from <code>unittest.TestCase</code> and contains a single <code>test_xyz()</code> method which wraps the methods for each step.</p>
<p>Currently, the final report only includes the pass/fail status for the wrapper <code>test_xyz()</code> method. I would like to have each step being treated as a 'test step' and have a separate entry in the test report.</p>
<p>It feels wrong to convert all the steps into <code>test_step1()</code>, <code>test_step2()</code> etc and then enforcing the execution order and data exchange since the steps are not self-contained tests.</p>
<p>Is there a way to mark certain methods as test steps so that they appear as separate entries in the test report? </p>
<p>Basically, all I want is improving the visual reporting so that it is more obvious from the report at which step the entire integration test failed. Is this achievable with <code>unittest</code>? What would be the best practice in organizing the code so that it fits into the unittest paradigm?</p>
<p>Not sure <code>unittest</code> is the best tool for integration tests, since this is not strictly speaking <em>unit testing</em>. Would switching to something like pytest make more sense for integration testing while still allowing 'free' HTML report generation? (I am currently using <a href="http://nose.readthedocs.io/" rel="nofollow noreferrer">nose</a> to run the test and to generate the HTML report with the corresponding <a href="https://pypi.python.org/pypi/nose-html-reporting" rel="nofollow noreferrer">nose plugin</a>.)</p>
</div>
<div class="post-text" itemprop="text">
<h2><code>pytest</code></h2>
<p>The most flexible option turned out to be switching to <a href="https://doc.pytest.org/" rel="nofollow noreferrer">pytest</a> with <a href="https://docs.pytest.org/en/latest/example/simple.html#incremental-testing-test-steps" rel="nofollow noreferrer">@pytest.mark.incremental</a> and <a href="https://pypi.org/project/pytest-html/" rel="nofollow noreferrer">pytest-html</a> for HTML report generation.</p>
<p>Also planning to look into the <a href="http://pytest-selenium.readthedocs.io" rel="nofollow noreferrer">pytest-selenium plugin</a> as a possibly cleaner way to organize the selenium fixtures.</p>
<p>The following article proved useful in understanding how to maintain shared state between tests steps: <a href="http://computableverse.com/blog/pytest-sharing-class-fixtures" rel="nofollow noreferrer">http://computableverse.com/blog/pytest-sharing-class-fixtures</a></p>
<h2><code>unittest</code></h2>
<p>And if you prefer to stick with <code>unittest</code>, then for simple use cases like iteration you can use <a href="https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests" rel="nofollow noreferrer">unittest.subTest</a> as demonstrated in the example below:</p>
<pre class="lang-python prettyprint-override"><code>#!/usr/bin/env python3
import unittest

import requests

HOST='http://httpbin.org'

class TestEndpoints(unittest.TestCase):

    def test_endpoints(self):

        for endpoint in ('/headers',
                         '/ip',
                         '/user-agent',
                         '/response-headers',
                         '/html',
                         ):
            with self.subTest(path=endpoint):

                url = HOST + endpoint
                response = requests.get(url)
                print(url, response.status_code)
                self.assertEqual(response.status_code, requests.codes.ok, msg=f'expected status code {requests.codes.ok}')


if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<span class="comment-copy">It's kind of hard to say this, since it's my job to review others code written in this, and I really hate it, but... have you considered Robot Framework?</span>
<span class="comment-copy">I had a quick look at the python version of <a href="https://github.com/elliterate/capybara.py" rel="nofollow noreferrer">capybara.py</a> which is being used by dropbox, but found it very poorly documented. Robot seems to be a more established thing, thanks!</span>
<span class="comment-copy"><code>sub-tests</code> in unittest give you some control over sharing state within a test function, but it is not really used for integration testing. I'm using it for data driven testing.</span>
