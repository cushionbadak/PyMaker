<div class="post-text" itemprop="text">
<p>I am interested in the truth value of Python sets like <code>{'a', 'b'}</code>, or the empty set <code>set()</code> (which is not the same as the empty dictionary <code>{}</code>). In particular, I would like to know whether <code>bool(my_set)</code> is <code>False</code> if and only if the set <code>my_set</code> is empty.</p>
<p>Ignoring primitive (such as numerals) as well as user-defined types, <a href="https://docs.python.org/3/library/stdtypes.html#truth" rel="noreferrer">https://docs.python.org/3/library/stdtypes.html#truth</a> says:</p>
<blockquote>
<p>The following values are considered false:</p>
<ul>
<li>[...]</li>
<li>any empty sequence, for example, <code>''</code>, <code>()</code>, <code>[]</code>.</li>
<li>any empty mapping, for example, <code>{}</code>.</li>
<li>[...]</li>
</ul>
<p>All other values are considered true</p>
</blockquote>
<p>According to <a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range" rel="noreferrer">https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range</a>, a set is not a sequence (it is unordered, its elements do not have indices, etc.):</p>
<blockquote>
<p>There are three basic sequence types: lists, tuples, and range objects.</p>
</blockquote>
<p>And, according to <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="noreferrer">https://docs.python.org/3/library/stdtypes.html#mapping-types-dict</a>,</p>
<blockquote>
<p>There is currently only one standard mapping type, the <em>dictionary</em>.</p>
</blockquote>
<p>So, as far as I understand, the set type is not a type that can ever be <code>False</code>. However, when I try, <code>bool(set())</code> evaluates to <code>False</code>.</p>
<p>Questions:</p>
<ul>
<li>Is this a documentation problem, or am I getting something wrong?</li>
<li>Is the empty set the only set whose truth value is <code>False</code>?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>After looking at the source code for CPython, I would guess this is a documentation error, however, it could be implementation dependent and therefore would be a good issue to raise on the Python bug tracker.</p>
<p>Specifically, <a href="https://github.com/python/cpython/blob/a66f9c6bb134561a24374f10e8c35417d356ce14/Objects/object.c#L1313" rel="noreferrer">object.c</a> defines the truth value of an item as follows:</p>
<pre><code>int
PyObject_IsTrue(PyObject *v)
{
    Py_ssize_t res;
    if (v == Py_True)
        return 1;
    if (v == Py_False)
        return 0;
    if (v == Py_None)
        return 0;
    else if (v-&gt;ob_type-&gt;tp_as_number != NULL &amp;&amp;
             v-&gt;ob_type-&gt;tp_as_number-&gt;nb_bool != NULL)
        res = (*v-&gt;ob_type-&gt;tp_as_number-&gt;nb_bool)(v);
    else if (v-&gt;ob_type-&gt;tp_as_mapping != NULL &amp;&amp;
             v-&gt;ob_type-&gt;tp_as_mapping-&gt;mp_length != NULL)
        res = (*v-&gt;ob_type-&gt;tp_as_mapping-&gt;mp_length)(v);
    else if (v-&gt;ob_type-&gt;tp_as_sequence != NULL &amp;&amp;
             v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length != NULL)
        res = (*v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length)(v);
    else
        return 1;
    /* if it is negative, it should be either -1 or -2 */
    return (res &gt; 0) ? 1 : Py_SAFE_DOWNCAST(res, Py_ssize_t, int);
}
</code></pre>
<p>We can clearly see that the value is value would be always true if it is not a boolean type, None, a sequence, or a mapping type, which would require tp_as_sequence or tp_as_mapping to be set.</p>
<p>Fortunately, looking at <a href="https://github.com/python/cpython/blob/master/Objects/setobject.c#L2127" rel="noreferrer">setobject.c</a> shows that sets do implement tp_as_sequence, suggesting the documentation seems to be incorrect.</p>
<pre><code>PyTypeObject PySet_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "set",                              /* tp_name */
    sizeof(PySetObject),                /* tp_basicsize */
    0,                                  /* tp_itemsize */
    /* methods */
    (destructor)set_dealloc,            /* tp_dealloc */
    0,                                  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    0,                                  /* tp_reserved */
    (reprfunc)set_repr,                 /* tp_repr */
    &amp;set_as_number,                     /* tp_as_number */
    &amp;set_as_sequence,                   /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    /* ellipsed lines */
};
</code></pre>
<p><a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c#L3254" rel="noreferrer">Dicts</a> also implement tp_as_sequence, so it seems that although it is not a sequence type, it sequence-like, enough to be truthy.</p>
<p>In my opionion, the documentation should clarify this: mapping-like types, or sequence-like types will be truthy dependent on their length.</p>
<p><strong>Edit</strong> As user2357112 correctly points out, <code>tp_as_sequence</code> and <code>tp_as_mapping</code> do not mean the type is a sequence or a map. For example, dict implements <code>tp_as_sequence</code>, and list implements <code>tp_as_mapping</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The documentation for <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="noreferrer"><code>__bool__</code></a> states that this method is called for truth value testing and if it is not defined then <a href="https://docs.python.org/3/reference/datamodel.html#object.__len__" rel="noreferrer"><code>__len__</code></a> is evaluated:</p>
<blockquote>
<p>Called to implement truth value testing and the built-in operation bool(); [...] When this method is not defined, <code>__len__()</code> is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither <code>__len__()</code> nor <code>__bool__()</code>, all its instances are considered true.</p>
</blockquote>
<p>This holds for any Python object. As we can see <code>set</code> does not define a method <code>__bool__</code>:</p>
<pre><code>&gt;&gt;&gt; set.__bool__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: type object 'set' has no attribute '__bool__'
</code></pre>
<p>so the truth testing falls back on <code>__len__</code>:</p>
<pre><code>&gt;&gt;&gt; set.__len__
&lt;slot wrapper '__len__' of 'set' objects&gt;
</code></pre>
<p>Therefore only an empty set (zero-length) is considered false.</p>
<p>The part for <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="noreferrer">truth value testing</a> in the documentation is not complete with regard to this aspect.</p>
</div>
<div class="post-text" itemprop="text">
<p>That part of the docs is poorly written, or rather, poorly maintained. The following clause:</p>
<blockquote>
<p>instances of user-defined classes, if the class defines a <code>__bool__()</code> or <code>__len__()</code> method, when that method returns the integer zero or bool value False.</p>
</blockquote>
<p>really applies to <em>all</em> classes, user-defined or not, including <code>set</code>, <code>dict</code>, and even the types listed in all the other clauses (all of which define either <code>__bool__</code> or <code>__len__</code>). (In Python 2, <code>None</code> is false despite not having a <code>__len__</code> or Python 2's equivalent of <code>__bool__</code>, but that exception is <a href="http://bugs.python.org/issue12647" rel="nofollow noreferrer">gone since Python 3.3</a>.)</p>
<p>I say poorly maintained because this section has been almost unchanged since at least <a href="https://docs.python.org/release/1.4/lib/node5.html#SECTION00311000000000000000" rel="nofollow noreferrer">Python 1.4</a>, and maybe earlier. It's been updated for the addition of <code>False</code> and the removal of separate int/long types, but not for type/class unification or the introduction of sets.</p>
<p>Back when the quoted clause was written, user-defined classes and built-in types really did behave differently, and I don't think built-in types actually had <code>__bool__</code> or <code>__len__</code> at the time.</p>
</div>
<span class="comment-copy">same behavior for any iterable ? i.e. with dict.items()</span>
<span class="comment-copy">It almost certainly is a mistaken omission: the <code>set</code> built-in type came relatively late to the game (version 2.2 or 2.3). They likely never updated the docs here to add <code>or an empty set</code></span>
<span class="comment-copy">@juanpa.arrivillaga But doesn't the same apply to <code>dict</code>s as well? It's been around pretty much since the beginning, but was omitted.</span>
<span class="comment-copy">@ChristianDean I believe <code>dict</code> was addressed here: "any empty mapping, for example {}"</span>
<span class="comment-copy">@Chris_Rands I created an issue on the Python bug tracker, see <a href="https://bugs.python.org/issue30803" rel="nofollow noreferrer">bugs.python.org/issue30803</a></span>
<span class="comment-copy">Slightly aside -- is the Python language actually defined by the documentation, or by the reference implementation?</span>
<span class="comment-copy">@peterthomassen: There's barely anything that can be considered a spec, really. It's not like C or C++, with a standards body and a mostly-thorough official standard. The docs are often incomplete, and the exact behavior of the interpreter isn't normative for other implementations.</span>
<span class="comment-copy">Note that the presence of <code>tp_as_sequence</code> doesn't mean an object is a sequence and the presence of <code>tp_as_mapping</code> doesn't mean an object is a mapping. The language has evolved since those members were designed and named.</span>
<span class="comment-copy">@shadow: Python-level <code>__bool__</code> corresponds to the <code>v-&gt;ob_type-&gt;tp_as_number-&gt;nb_bool</code> part, which is the C-level counterpart. Depending on whether the type is written in C or Python, either <code>__bool__</code> or <code>nb_bool</code> will be a wrapper for the other.</span>
<span class="comment-copy">@AlexanderHuszagh I raised this on the Python bug tracker, see <a href="https://bugs.python.org/issue30803" rel="nofollow noreferrer">bugs.python.org/issue30803</a></span>
<span class="comment-copy">Just a heads up that magic methods can be implementation-dependent: in Python 2, <code>__bool__</code> does not exist, while <code>__nonzero__</code> provides the same functionality, which I discovered the hard way.</span>
<span class="comment-copy">@AlexanderHuszagh: Yup. The <code>__nonzero__</code> name dates back to before Python had a bool type. Back then, it returned either 0 or 1, and the method was thought of as testing nonzeroness instead of coercing to bool.</span>
