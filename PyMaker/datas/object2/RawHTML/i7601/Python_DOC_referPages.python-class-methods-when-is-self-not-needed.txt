<div class="post-text" itemprop="text">
<p>I'm trying to rewrite some code using classes. At some point what I want is assign a member function a particular definition using a parameter value for each instance of an object.</p>
<p>Coming from other languages (JavaScript, C++, Haskell, Fortran, ...) I am struggling to <em>understand</em> a few things on Python. One thing is the following distinction of <em>self</em> in class methods.</p>
<p>For instance, the following code obviously won't work:</p>
<pre><code>class fdf:
    def f(x):
        return 666

class gdg(fdf):
    def sq():
        return 7*7

hg = gdg()
hf = fdf()
print(hf.f(),hg.f(),hg.sq())
</code></pre>
<p>which gives the error that "<em>sq() takes 0 positional arguments but 1 was given</em>". </p>
<p>The reason, as I understand it, is that at <em>execution time</em> the function is passed a reference to the calling object (the instance calling sq) as first argument before any other parameter/argument we may have defined/called sq with. So the solution is simple: change the code of sq to <code>def sq(self):</code>. Indeed, the <a href="https://docs.python.org/3/tutorial/classes.html#method-objects" rel="nofollow noreferrer">Python tutorial <a href="https://docs.python.org/3/tutorial/classes.html#method-objects" rel="nofollow noreferrer">1</a></a> <em>seems</em> to suggest that object methods should always be defined with <code>self</code> as first parameter. Doing so we get as expected <code>666 666 49</code>. So far so good.</p>
<p><strong>However</strong>, when I try to implement my class like this:</p>
<pre><code>class Activation:
    def nonLinearBipolarStep(self,x,string=None):
        if not string: return (-1 if x&lt;0 else 1 )
        else: return ('-' if x&lt;0 else '1')

    default='bipolar'
    activationFunctions = {
        'bipolar': nonLinearBipolarStep ,
    }
    def _getActivation(self,func=default):
        return self.activationFunctions.get(func,self.activationFunctions.get(self.default))

    def __init__(self,func=None):
        if func == None: func=self.default 
        self.run = self._getActivation(func)


ag = Activation()
print(ag.run(4))
</code></pre>
<p>I get the error</p>
<pre><code>nonLinearBipolarStep() missing 1 required positional argument: 'x'
</code></pre>
<p>Yet, a workaround ( solution??) is defining the the step function without the parameter <code>self</code> (!) as</p>
<pre><code>def nonLinearBipolarStep(x,string=None):
</code></pre>
<p>Then I get the expected behavior (at least for this trivial test) of <code>1</code>. So, not only is <code>self</code> not needed here, <em>but it even is incorrect an use here!</em></p>
<p><strong>But according to the tutorial mentioned above, or to the answers in threads like <a href="https://stackoverflow.com/questions/1984104/how-to-avoid-explicit-self-in-python?rq=1">this <a href="https://stackoverflow.com/questions/1984104/how-to-avoid-explicit-self-in-python?rq=1">2</a></a> or <a href="https://stackoverflow.com/questions/2709821/what-is-the-purpose-of-self?rq=1">this <a href="https://stackoverflow.com/questions/2709821/what-is-the-purpose-of-self?rq=1">3</a></a>, it seems to me this code shouldn't work...or should have some unexpected consequences at some point(?).</strong> Indeed, if I remove all references to <code>self</code> in the definition of <code>_getActivation</code> I get the error message <code>_getActivation() takes from 0 to 1 positional arguments but 2 were given</code> which I can understand according to that rule.</p>
<p><strong>The thread <a href="https://stackoverflow.com/questions/39803950/why-is-self-not-used-in-this-method">"Why is self not used in this method" <a href="https://stackoverflow.com/questions/39803950/why-is-self-not-used-in-this-method">4</a></a> does not provide a clear answer to me: What syntax detail of the code above tells me that <code>self</code> is not needed?</strong> For instance, how is that code different from this tutorial example</p>
<pre><code>class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'
</code></pre>
<p>? Instantiating this class works as expected, but it complains about missing parameter (I know it could be any label) if defined with none. </p>
<p>This makes me question whether my code is not hiding a time bomb somehow: is <code>self</code> passed as the value for <code>x</code>? It works as expected so I'd say no, but then I'm facing this conundrum. </p>
<p>I guess I'm missing some key ideas of the language. I admit I also struggle with the question the OP of reference <a href="https://stackoverflow.com/questions/2709821/what-is-the-purpose-of-self?rq=1">3</a> is asking^.</p>
<p>[^]: In JS one just uses <code>this</code> in the function body, and the function itself is defined either as member of the object's prototype or as an instance member which then gets assigned correctly using...<code>this</code>. </p>
<p><strong>EDIT:</strong> 
The thread is long. For those browsing for some help, if you are new to Python, then you may want to check the selected solution and its comments. However, if you already know about bound/unbound methods in Python, you just want to check directly the use of descriptor as described in Blckknght's answer. I finally opted for this way in my code using <code>__get__</code> in the assignment to run.  </p>
</div>
<div class="post-text" itemprop="text">
<h2>What is <code>self</code>?</h2>
<p>In Python, every <em>normal</em> method is forced to accept a parameter commonly named <code>self</code>. This is an instance of class - an object. This is how Python methods interact with a classes state.</p>
<p>You are allowed to rename this parameter whatever you please. but it will always have the same value:</p>
<pre><code>&gt;&gt;&gt; class Class:
    def method(foo): # 
        print(foo)


&gt;&gt;&gt; cls = Class()
&gt;&gt;&gt; cls.method()
&lt;__main__.F object at 0x03E41D90&gt;
&gt;&gt;&gt; 
</code></pre>
<h2>But then why does my example work?</h2>
<p>However, what you are probably confused about is how this code works differently:</p>
<pre><code>&gt;&gt;&gt; class Class:
    def method(foo):
        print(foo)

    methods = {'method': method}

    def __init__(self):
        self.run = self.methods['method']


&gt;&gt;&gt; cls = Class()
&gt;&gt;&gt; cls.run(3)
3
&gt;&gt;&gt; 
</code></pre>
<p>This is because of the distinction between <strong>bound</strong>, and <strong>unbound</strong> methods in Python.</p>
<p>When we do this in <code>__init__()</code>:</p>
<pre><code>self.run = self.methods['method']
</code></pre>
<p>We are referring to the <em><strong>unbound</strong></em> method <code>method</code>. That means that our reference to <code>method</code> is not bound to any <em>specific</em> instance of <code>Class</code>, and thus, Python will not force <code>method</code> to accept an object instance.  because it does not have one to give.</p>
<p>The above code would be the same as doing this:</p>
<pre><code>&gt;&gt;&gt; class Class:
    def method(foo):
        print(foo)


&gt;&gt;&gt; Class.method(3)
3
&gt;&gt;&gt; 
</code></pre>
<p>In both examples, we are calling the method <code>method</code> of the class object <code>Class</code> , and <em>not</em> an <em>instance</em> of the <code>Class</code> object.</p>
<p>We can further see this distinction by examining the <code>repr</code> for a bound and unbound method:</p>
<pre><code>&gt;&gt;&gt; class Class:
    def method(foo):
        print(foo)


&gt;&gt;&gt; Class.method
&lt;function Class.method at 0x03E43D68&gt;
&gt;&gt;&gt; cls = Class()
&gt;&gt;&gt; cls.method
&lt;bound method Class.method of &lt;__main__.Class object at 0x03BD2FB0&gt;&gt;
&gt;&gt;&gt; 
</code></pre>
<p>As you can see, in the first example when we do <code>Class.method</code>, Python shows:
<code>&lt;function Class.method at 0x03E43D68&gt;</code>. I've lied to you a little bit. When we have an unbound method of a class, Python treats them as plain functions. So <code>method</code> is simply a function that is not bound to any instance of `Class.</p>
<p>However in the second example, when we create an instance of <code>Class</code>, and then access the <code>method</code> object of it, we see printed: <code>&lt;bound method Class.method of &lt;__main__.Class object at 0x03BD2FB0&gt;&gt;</code>.</p>
<p>The key part to notice is <code>bound method Class.method</code>. That means <code>method</code> is <em><strong>bound</strong></em></p></div>
<div class="post-text" itemprop="text">
<p>You're running into one of the more subtle parts of Python's method implementation. It comes down to how the <code>self</code> argument for normal method calls (e.g. <code>some_instance.method()</code>) is bound. It uses the "descriptor" protocol, which is not very well documented (at least, it's not made obvious to new Python programmers).</p>
<p>A descriptor is an object that has a <code>__get__</code> method (and optionally <code>__set__</code> and/or <code>__delete__</code> method, but I'm only going to talk about <code>__get__</code> here). When such an object is stored in a class variable, Python will call its <code>__get__</code> method whenever the corresponding name is looked up on an instance. Note that this special behavior does not happen for descriptor objects stored in instance variables, only those that are class variables.</p>
<p>Functions are descriptors. That means that when you save a function as a class variable, its <code>__get__</code> method will be called when you look it up on an instance. That method will return a "bound method" object which will pass along the <code>self</code> argument to the function automatically.</p>
<p>If you store a function somewhere other than a top-level class variable (such as in a dictionary or in an instance variable), you won't get this binding behavior, since the descriptor protocol won't be invoked when the object is looked up. This usually means you either need to pass <code>self</code> manually, or you should omit the <code>self</code> argument from the function definition in the first place (in which case I'd suggest moving the function out of the class to make it clear it's not intended to be used as a method).</p>
<p>But you can also construct bound methods by hand if you want to. The type is exposed in the <code>types</code> module, as <code>types.MethodType</code>. So you could change your code like this and it should work:</p>
<pre><code>def __init__(self,func=None):
    if func == None: func=self.default 
    self.run = types.MethodType(self._getActivation(func), self) # be sure to import types
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think what has confused you here is that you're accessing the method via the class attribute <code>activationFunctions</code>, rather than (as an instance would normally be accessed) on the instance itself. For example, given:</p>
<pre><code>class Class:

    def method(self, foo, bar):
        print(self, foo, bar)

    methods = {'method': method}
</code></pre>
<p>When we call the method directly from the dictionary:</p>
<pre><code>&gt;&gt;&gt; Class.methods['method'](1, 2, 3)
1 2 3
</code></pre>
<p>You can see that we're passing <code>1</code> as the <code>self</code> parameter; the method isn't being called on an instance, so no instance is being injected. By contrast, when we call it on an instance:</p>
<pre><code>&gt;&gt;&gt; instance = Class()
&gt;&gt;&gt; instance.method(1, 2)
&lt;__main__.Class object at 0x...&gt; 1 2
</code></pre>
<p>Now our arguments are <code>foo</code> and <code>bar</code>, and the instance is <code>self</code>. That's why you think a different number of parameters seem to be required.</p>
<hr/>
<p>In this case, as you don't actually need the instance state in your method, just make it a regular function (note minor revisions for <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP-8</a> compliance):</p>
<pre><code>def non_linear_bipolar_step(x, string=None):
    if string is not None: 
        return -1 if x &lt; 0 else 1
    return '-' if x &lt; 0 else '1'

class Activation:

    activation_functions = {
        'bipolar': non_linear_bipolar_step,
    }

    ...
</code></pre>
<p>This is likely less confusing.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're using unbound method (nonLinearBipolarStep) in this code:</p>
<pre><code>activationFunctions = {
    'bipolar': nonLinearBipolarStep ,
}
</code></pre>
<p>Longer answer: methods are functions defined within class body and always take at least one argument, so called self (unless you use @staticfunction and turn them into normal functions). Self is an object of a given class, on which method is called (like this in C++). In python there's almost nothing special about this argument, it doesnt have to be named self. Now when you call unbound method, then first argument you've given will be interpreted as self and consumed. If you call bound methods, then this consumption doesnt happen (the method already has its self object). For example:</p>
<pre><code>class A:
  def foo(self, x): print(x)
a = A()
a.foo(1) # a.foo is bound method, a is self, prints 1
A.foo(a, 2) # A.foo is unbound method, first argument becomes self, prints 2
</code></pre>
<p>UPDATE:
Why it works at all. Short answer: because dot (.) operator will update unbound method to bound when it can.</p>
<p>Consider, what happens, when you write a.foo(1). First python check object a for foo and finds nothing (foo is not a value assigned to a). So it goes to a class (named A) and lo and behold - foo is there and is used. But here is a trick. Python will bind object a to unbound method A.foo (details escape me now, so imagine dragon did it) and make it into bound method. So a.foo is bound and doesnt need self anymore from arguments, thus 1 goes into argument x and everything works.</p>
<p>Now to your code: you use 'bipolar': nonLinearBipolarStep in map, which is unbound method. Then in constructor (<strong>init</strong>) you set self.run to value returned from _getActivation, which is taken from activationFunctions map. In given example you return nonLinearBipolarStep unbound method and assign it to self.run. Now you call ag.run. Going by the logic from the previous paragraph ag.run is first looked inside ag object. And here is your error - its found. As python found ag.run value inside ag object, it never consulted ag type (Activation) for run object and never had a chance to bind it. So ag.run is unbound method and expect self argument as first.</p>
<p>You've in general two options. Either do ag.run(ag, 4), which will work, but its ugly, or manually bind method to self in constructor. The latter you can do like this:</p>
<pre><code>self.run = self._getActivation(func).__get__(self)
</code></pre>
</div>
<span class="comment-copy">No you can work with <code>@staticmethod</code>.</span>
<span class="comment-copy">@WillemVanOnsem Sorry, what are you saying no to?</span>
<span class="comment-copy">you do not always need a <code>self</code>. If you decorate the function with <code>@staticmethod</code>, you don't use a <code>self</code>.</span>
<span class="comment-copy"><i>" is self passed as the value for x?"</i> - Yes, that is exactly right.</span>
<span class="comment-copy">You don't have to <i>name</i> it <code>self</code>, that's just a convention (but one you should stick to, as anything else would be confusing), but you always have to include that initial parameter that corresponds to the instance for instance methods. Class methods take a parameter that corresponds to the class, conventionally named <code>cls</code>. Static methods have neither. <code>nonLinearBipolarStep</code> in this case simply shouldn't be an instance method; make it a static method or a separate function.</span>
<span class="comment-copy">In what sense is <code>self.run = self.methods['method']</code> a reference to an unbound method? I mean, after all the <i>code itself</i> for method is the same as in the first example. So, what am I missing about the syntax / language in that assignment that make it a reference to an unbound function? -I mean, I would hope to "see the problem" at first glance once I fully understand it...</span>
<span class="comment-copy">As I was in the process of answering to @jonrsharpe, the point of putting it inside is encapsulation. I don't want those function clashing with anything else. It seems then this is more of pythonian style thing, but I still find it cleaner code putting it inside. One could argue on the merits of the language in doing it the way it does.</span>
<span class="comment-copy">@MASL <i>"In what sense is <code>self.run = self.methods['method']</code> a reference to an unbound method?"</i> - <code>self.run</code> is assigned the value of <code>self.methods['method']</code> which is <code>method</code> - or the same as doing <code>Class.method</code>. That means <code>self.run</code> is assigned to <code>Class.method</code>; an unbound function of <code>Class</code>.</span>
<span class="comment-copy">Uff! I get that this is an explanation, but man does it feel so non-evident! Correct me here if I'm wrong, but being unbound is somehow like saying the function doesn't know who is calling it -no instance. So, it seems it's the 'usage', the way I'm using, assigning my function in the code of the class what ultimate determines whether it is/should be bound or unbound... (ignore if you find it meaningless; just trying to create some intuition around this)</span>
<span class="comment-copy">@MASL Yes, you're right. You can think of it like this. Whether Python passes an object instance all depends on how you call <code>method</code>. If you <code>Class.method</code> you are getting the function <code>method</code> that belongs to the <code>Class</code> object. It is not bound to any specific <code>Class</code> instance, but to the <code>Class</code> object itself. If you do <code>cls = Class(); cls.method</code> you are getting the function <code>method</code> that is bound to a specific instance of <code>Class</code>: <code>cls</code>. If you have anymore questions could you tell what exactly they are?</span>
<span class="comment-copy">I oversaw this before. In insight, this might well be the most complete answer -although it wouldn't be as meaningful as it is to me now were it not for jon and christian's answers. Thanks!</span>
<span class="comment-copy">Trying to get the gist of this...meanwhile: (1) you start saying it's related to my use of the class attribute, but your example seems to hinge on whether we call it on the instance or on the object; (2) being functions in python also objects in themselves, I expected I could just pass one to run at runtime, as one can do in JavaScript. So there seems to be a subtle distinction between both languages here (or I miss it); (3) the whole point is <b>encapsulating everything inside a class</b> and not leaving some garbage around -that's what I'd do in JS or C++ anyway.  Feels so wrong otherwise...</span>
<span class="comment-copy">1. <i>"on the instance or on the object"</i> - what distinction are you trying to draw here, what do you think <i>"the object"</i> is? 2. Yes, Python has first class functions. However there is still a difference between one that's bound to an instance and one that isn't. 3. <i>"that's what I'd do in JS or C++"</i> - Python is neither of those languages. If you don't want the function to be used outside that module, consider naming it <code>_non_linear...</code> instead.</span>
<span class="comment-copy">In your example, when you call <code>Class.methods['method'](1, 2, 3)</code> you'll get only <code>2 3</code> printed, not <code>1 2 3</code> (as you've shown). The method isn't printing <code>self</code> with the other arguments.</span>
<span class="comment-copy">@Blckknght fixed, thanks</span>
<span class="comment-copy">I think I get that now. But then, why is my code (ag.run(x) ) working as I expect it to work? After all self is not a different value each time we call ag.run(x)...</span>
<span class="comment-copy">I'll update answer, as it's also slightly complicated. ;)</span>
