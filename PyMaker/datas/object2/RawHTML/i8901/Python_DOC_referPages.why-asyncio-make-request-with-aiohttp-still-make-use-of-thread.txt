<div class="post-text" itemprop="text">
<p>I thought <code>ayncio</code> and the use of <code>coroutine</code> is not related with thread, since <code>coroutine</code> is a type of "thread" running under program's scheduler, so there should be only 1 thread running each process. But when I ran examples in <a href="https://pawelmhm.github.io/asyncio/python/aiohttp/2016/04/22/asyncio-aiohttp.html" rel="nofollow noreferrer">Making 1 million requests with python-aiohttp</a>, the code is like below:</p>
<pre><code># modified fetch function with semaphore
import random
import asyncio
from aiohttp import ClientSession

async def fetch(url, session):
    async with session.get(url) as response:
        delay = response.headers.get("DELAY")
        date = response.headers.get("DATE")
        print("{}:{} with delay {}".format(date, response.url, delay))
        return await response.read()


async def bound_fetch(sem, url, session):
    # Getter function with semaphore.
    async with sem:
        await fetch(url, session)


async def run(r):
    url = "http://localhost:8080/{}"
    tasks = []
    # create instance of Semaphore
    sem = asyncio.Semaphore(1000)

    # Create client session that will ensure we dont open new connection
    # per each request.
    async with ClientSession() as session:
        for i in range(r):
            # pass Semaphore and session to every GET request
            task = asyncio.ensure_future(bound_fetch(sem, url.format(i), session))
            tasks.append(task)

        responses = asyncio.gather(*tasks)
        await responses

number = 10000
loop = asyncio.get_event_loop()

future = asyncio.ensure_future(run(number))
loop.run_until_complete(future)
</code></pre>
<p>With Windows' Resource Monitor, I found that the code create 25 threads in 1 process.</p>
</div>
<div class="post-text" itemprop="text">
<p>The aiohttp library uses threads for concurrent DNS resolving by default in order not to block IO loop, see <a href="https://github.com/aio-libs/aiohttp/blob/master/aiohttp/resolver.py" rel="nofollow noreferrer">aiohttp/resolver.py</a>. If you want asynchronous DNS lookups, you need to install python package <code>aiodns</code>, which in turn uses <code>pycares</code>.</p>
<p>You can then do:</p>
<pre><code>async def fetch(url):
    resolver = aiohttp.AsyncResolver()
    connector = aiohttp.TCPConnector(resolver=resolver, family=socket.AF_INET)
    async with aiohttp.ClientSession(connector=connector) as session:
        async with session.get(url) as resp:
            if resp.status == 200:
                print("success!")
</code></pre>
<p>If you want to set <code>AsyncResolver</code> as a global default, this worked for me with aiohttp 2.2.3:</p>
<pre><code>import aiohttp.resolver
aiohttp.resolver.DefaultResolver = aiohttp.resolver.AsyncResolver
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's standard library includes a module called <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer"><code>threading</code></a> which allows to run python code concurrently by using <code>Thread</code> instances.  <code>asyncio</code> and <code>aiohttp</code> does not use the <code>threading</code> module to operate.</p>
<p>Python itself might use OS (low level) threads as an implementation detail - but this probably changes between different platforms and versions.  For example, the number of OS threads for a simple <code>print('hello world'); s = input()</code> for python 3.6.0 in Windows 10 is 3.</p>
<p>Check out <a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/windows_events.py" rel="nofollow noreferrer">https://github.com/python/cpython/blob/3.6/Lib/asyncio/windows_events.py</a> to find clues for what might start OS threads in windows.</p>
</div>
