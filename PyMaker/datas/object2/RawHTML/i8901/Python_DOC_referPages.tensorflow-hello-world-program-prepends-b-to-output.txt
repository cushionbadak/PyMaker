<div class="post-text" itemprop="text">
<p>Apparently, the following is valid syntax</p>
<pre><code>my_string = b'The string'
</code></pre>
<p>I would like to know:</p>
<ol>
<li>What does this <code>b</code> character in front of the string mean?</li>
<li>What are the effects of using it?</li>
<li>What are appropriate situations to use it?</li>
</ol>
<p>I found a <a href="https://stackoverflow.com/q/4749442/346561">related question</a> right here on SO, but that question is about PHP though, and it states the <code>b</code> is used to indicate the string is binary, as opposed to Unicode, which was needed for code to be compatible from version of PHP &lt; 6, when migrating to PHP 6. I don't think this applies to Python.</p>
<p>I did find <a href="http://docs.python.org/tutorial/introduction.html#unicode-strings" rel="noreferrer">this documentation</a> on the Python site about using a <code>u</code> character in the same syntax to specify a string as Unicode. Unfortunately, it doesn't mention the <strong>b</strong> character anywhere in that document.</p>
<p>Also, just out of curiosity, are there more symbols than the <code>b</code> and <code>u</code> that do other things?</p>
</div>
<div class="post-text" itemprop="text">
<p>To quote <a href="https://docs.python.org/2/reference/lexical_analysis.html#string-literals" rel="noreferrer">the Python 2.x documentation</a>:</p>
<blockquote>
<p>A prefix of 'b' or 'B' is ignored in
  Python 2; it indicates that the
  literal should become a bytes literal
  in Python 3 (e.g. when code is
  automatically converted with 2to3). A
  'u' or 'b' prefix may be followed by
  an 'r' prefix.</p>
</blockquote>
<p>The <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="noreferrer">Python 3 documentation</a> states:</p>
<blockquote>
<p>Bytes literals are always prefixed with 'b' or 'B'; they produce an instance of the bytes type instead of the str type. They may only contain ASCII characters; bytes with a numeric value of 128 or greater must be expressed with escapes.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://www.diveintopython3.net/strings.html" rel="noreferrer">Python 3.x</a> makes a clear distinction between the types:</p>
<ul>
<li><code>str</code> = <code>'...'</code> literals = a sequence of Unicode characters (UTF-16 or UTF-32, depending on how Python was compiled)</li>
<li><code>bytes</code> = <code>b'...'</code> literals = a sequence of octets (integers between 0 and 255)</li>
</ul>
<p>If you're familiar with Java or C#, think of <code>str</code> as <code>String</code> and <code>bytes</code> as <code>byte[]</code>.  If you're familiar with SQL, think of <code>str</code> as <code>NVARCHAR</code> and <code>bytes</code> as <code>BINARY</code> or <code>BLOB</code>.  If you're familiar with the Windows registry, think of <code>str</code> as <code>REG_SZ</code> and <code>bytes</code> as <code>REG_BINARY</code>.  If you're familiar with C(++), then forget everything you've learned about <code>char</code> and strings, because <strong>A CHARACTER IS NOT A BYTE</strong>.  That idea is long obsolete.</p>
<p>You use <code>str</code> when you want to represent text.</p>
<pre><code>print('שלום עולם')
</code></pre>
<p>You use <code>bytes</code> when you want to represent low-level binary data like structs.</p>
<pre><code>NaN = struct.unpack('&gt;d', b'\xff\xf8\x00\x00\x00\x00\x00\x00')[0]
</code></pre>
<p>You can <a href="http://en.wikipedia.org/wiki/Character_encoding" rel="noreferrer">encode</a> a <code>str</code> to a <code>bytes</code> object.</p>
<pre><code>&gt;&gt;&gt; '\uFEFF'.encode('UTF-8')
b'\xef\xbb\xbf'
</code></pre>
<p>And you can decode a <code>bytes</code> into a <code>str</code>.</p>
<pre><code>&gt;&gt;&gt; b'\xE2\x82\xAC'.decode('UTF-8')
'€'
</code></pre>
<p>But you can't freely mix the two types.</p>
<pre><code>&gt;&gt;&gt; b'\xEF\xBB\xBF' + 'Text with a UTF-8 BOM'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't concat bytes to str
</code></pre>
<p>The <code>b'...'</code> notation is somewhat confusing in that it allows the bytes 0x01-0x7F to be specified with ASCII characters instead of hex numbers.</p>
<pre><code>&gt;&gt;&gt; b'A' == b'\x41'
True
</code></pre>
<p>But I must emphasize, <strong>a character is not a byte</strong>.</p>
<pre><code>&gt;&gt;&gt; 'A' == b'A'
False
</code></pre>
<h1>In Python 2.x</h1>
<p>Pre-3.0 versions of Python lacked this kind of distinction between text and binary data.  Instead, there was:</p>
<ul>
<li><code>unicode</code> = <code>u'...'</code> literals = sequence of Unicode characters = 3.x <code>str</code></li>
<li><code>str</code> = <code>'...'</code> literals = sequences of confounded bytes/characters

<ul>
<li>Usually text, encoded in some unspecified encoding.</li>
<li>But also used to represent binary data like <code>struct.pack</code> output.</li>
</ul></li>
</ul>
<p>In order to ease the 2.x-to-3.x transition, the <code>b'...'</code> literal syntax was backported to Python 2.6, in order to allow distinguishing binary strings (which should be <code>bytes</code> in 3.x) from text strings (which should be <code>str</code> in 3.x).  The <code>b</code> prefix does nothing in 2.x, but tells the <code>2to3</code> script not to convert it to a Unicode string in 3.x.</p>
<p>So yes, <code>b'...'</code> literals in Python have the same purpose that they do in PHP.</p>
<blockquote>
<p>Also, just out of curiosity, are there
  more symbols than the b and u that do
  other things?</p>
</blockquote>
<p>The <code>r</code> prefix creates a raw string (e.g., <code>r'\t'</code> is a backslash + <code>t</code> instead of a tab), and triple quotes <code>'''...'''</code> or <code>"""..."""</code> allow multi-line string literals.</p>
</div>
<div class="post-text" itemprop="text">
<p>The b denotes a byte string.</p>
<p>Bytes are the actual data. Strings are an abstraction.</p>
<p>If you had multi-character string object and you took a single character, it would be a string, and it might be more than 1 byte in size depending on encoding.</p>
<p>If took 1 byte with a byte string, you'd get a single 8-bit value from 0-255 and it might not represent a complete character if those characters due to encoding were &gt; 1 byte.</p>
<p>TBH I'd use strings unless I had some specific low level reason to use bytes.</p>
</div>
<div class="post-text" itemprop="text">
<p>It turns it into a <code>bytes</code> literal (or <code>str</code> in 2.x), and is valid for 2.6+.</p>
<p>The <code>r</code> prefix causes backslashes to be "uninterpreted" (not ignored, and the difference <em>does</em> matter).</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an example where the absence of 'b' would throw a TypeError exception in Python 3.x</p>
<pre><code>&gt;&gt;&gt; f=open("new", "wb")
&gt;&gt;&gt; f.write("Hello Python!")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'str' does not support the buffer interface
</code></pre>
<p>Adding a 'b' prefix would fix the problem. </p>
</div>
<div class="post-text" itemprop="text">
<p>From server side,if we send any response it will be sent in the form of byte type.So it will appear in the client as
b'Response from server'</p>
<p>In order get rid of b'....' simply use below code 
 server file</p>
<pre><code>stri="Response from server"    
c.send(stri.encode())
</code></pre>
<p>client file</p>
<pre><code>print(s.recv(1024).decode())
</code></pre>
<p>then it will print</p>
<p>Response from server </p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to what others have said, note that a single character in unicode <strong>can consist of multiple bytes</strong>. </p>
<p>The way unicode works is that it took the old ASCII format (7-bit code that looks like 0xxx xxxx) and added <a href="https://stackoverflow.com/questions/9356169/utf-8-continuation-bytes">multi-bytes sequences</a> where all bytes start with 1 (1xxx xxxx) to represent characters beyond ASCII so that Unicode would be <a href="https://www.youtube.com/watch?v=MijmeoH9LT4" rel="nofollow noreferrer">backwards-compatible</a> with ASCII.</p>
<pre><code>&gt;&gt;&gt; len('Öl')  # German word for 'oil' with 2 characters
2
&gt;&gt;&gt; 'Öl'.encode('UTF-8')  # convert str to bytes 
b'\xc3\x96l'
&gt;&gt;&gt; len('Öl'.encode('UTF-8'))  # 3 bytes encode 2 characters !
3
</code></pre>
</div>
<span class="comment-copy">So it sounds like Python &lt; v3 will just ignore this extra character. What would be a case in v3 where you would need to use a b string as opposed to just a regular string?</span>
<span class="comment-copy">@Gweebz - if you're actually typing out a string in a particular encoding instead of with unicode escapes (eg. b'\xff\xfe\xe12' instead of '\u32e1').</span>
<span class="comment-copy">That makes sense. I will mark this one as the accepted answer but there are other good answers here too!</span>
<span class="comment-copy">Actually, if you've imported <code>unicode_literals</code> from <code>__future__</code>, this will "reverse" the behavior for this particular string (in Python 2.x)</span>
<span class="comment-copy">A little more plain language narrative around the quoted documentation would make this a better answer IMHO</span>
<span class="comment-copy">Thanks! I understood it after reading these sentences: "In order to ease the 2.x-to-3.x transition, the b'...' literal syntax was backported to Python 2.6, in order to allow distinguishing binary strings (which should be bytes in 3.x) from text strings (which should be str in 3.x). The b prefix does nothing in 2.x, but tells the 2to3 script not to convert it to a Unicode string in 3.x."</span>
<span class="comment-copy">The <code>'A' == b'A' --&gt; False</code> check <i>really</i> makes it clear.  The rest of it is excellent, but up to that point I hadn't properly understood that a byte string is <i>not really text.</i></span>
<span class="comment-copy"><code>'שלום עולם' == 'hello world'</code></span>
<span class="comment-copy">This is much more clear than the accepted answer which is just quoting the documentation. The documentation to me didn't make sense so providing further context in the documentation is awesome.  Thanks!</span>
<span class="comment-copy">b"some string".decode('UTF-8'), I believe that's the line many are looking for</span>
<span class="comment-copy">This sounds wrong according to the documentation quoted in aix's answer; the b will be ignored in Python version other than 3.</span>
<span class="comment-copy">It will be a <code>str</code> in 2.x either way, so it could be said that it is ignored. The distinction matters when you import <code>unicode_literals</code> from the <code>__future__</code> module.</span>
<span class="comment-copy">Sorry, I misunderstood your original statement. Your answer is accurate in what it says.</span>
<span class="comment-copy">It doesn't explain the question that Jesse Webb has asked!</span>
<span class="comment-copy">I was saying that without using encode and decode methods, the string output will be prefixed with b' ' as python take it as a byte type instead of string type.If you don't want to get an output like b'...' use the above that's it .What you didn't understand?</span>
