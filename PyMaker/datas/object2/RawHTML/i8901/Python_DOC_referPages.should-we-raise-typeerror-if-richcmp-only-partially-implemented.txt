<div class="post-text" itemprop="text">
<p>I implemented the method <code>__richcmp__</code> for a Cython extension type (<code>cdef class</code>). Some comparison cases are undefined (for example <code>&lt;</code>), so I used to raise an <code>Exception</code> for them, <a href="https://github.com/johnyf/dd/blob/82aba3ab5d01cbd2db420719f7e00b72b2a3f31d/dd/cudd.pyx#L1427" rel="nofollow noreferrer">as follows</a>.</p>
<pre><code>def __richcmp__(Function self, Function other, op):
    if other is None:
        eq = False
    else:
        # guard against mixing managers
        assert self.manager == other.manager
        eq = (self.node == other.node)
    if op == 2:
        return eq
    elif op == 3:
        return not eq
    else:
        raise TypeError('Only `__eq__` and `__ne__` defined.')
</code></pre>
<p>I want to <code>pprint</code> containers of instances of this Cython class. <a href="https://github.com/python/cpython/blob/6a7b3a77b4b2be0badd24ee5f0fdbaa2e0e79c3d/Lib/pprint.py#L89" rel="nofollow noreferrer"><code>pprint</code> attempts to compare</a> them, except for a <code>TypeError</code>. My understanding is that as <code>TypeError</code>, <code>pprint</code> anticipates the case of undefined <code>__lt__</code>, or the case of different types of objects (see also <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">Python docs</a>).</p>
<p>However, <code>__richcmp__</code> <em>is</em> implemented, so Python doesn't raise a <code>TypeError</code>. It calls <code>__richcmp__</code>, I raise an <code>Exception</code>, and that isn't ignored by <code>pprint</code>. Cython <a href="https://github.com/cython/cython/blob/39df7ffd992e98fc8e15acd1741aeee751963fe5/docs/src/userguide/special_methods.rst#rich-comparisons" rel="nofollow noreferrer">requires</a> that <code>__richcmp__</code> be implemented, so I don't have the option of defining only <code>__eq__</code> and <code>__ne__</code>.</p>
<p>I changed my code to raising a <code>TypeError</code>. It seems that if Python communicates the lack of <code>__lt__</code> with a <code>TypeError</code>, then I should do the same, in order to signify that <code>__lt__</code> is absent, despite the presence of an entire <code>__richcmp__</code>, which was a byproduct of using Cython, not the design intent.</p>
<p>Does this reasoning make sense? Should I raise another kind of exception? Did I properly interpret the meaning of <code>TypeError</code> in this context?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes. Cython is using your implementation as the C API <a href="https://docs.python.org/2/c-api/typeobj.html#c.PyTypeObject.tp_richcompare" rel="nofollow noreferrer"><code>tp_richcompare</code></a>. The documentation for that tells you</p>
<blockquote>
<p>If you want to implement a type for which only a limited set of comparisons makes sense (e.g. <code>==</code> and <code>!=</code>, but not <code>&lt;</code> and friends), directly raise <code>TypeError</code> in the rich comparison function.</p>
</blockquote>
<p>That gives you a fairly strong hint that it's the right thing to do.</p>
</div>
<div class="post-text" itemprop="text">
<p>@DavidW provided a very precise and helpful answer, thank you. It points at how to approach similar future questions: by looking at the generated C code. I'm posting this answer as complimentary information for posterity.</p>
<p>Searching within the generated <code>cudd.c</code> file, we find the class signature:</p>
<pre><code>static PyTypeObject __pyx_type_2dd_4cudd_Function = {
    PyVarObject_HEAD_INIT(0, 0)
    "dd.cudd.Function", /*tp_name*/
    sizeof(struct __pyx_obj_2dd_4cudd_Function), /*tp_basicsize*/
    0, /*tp_itemsize*/
    ...
    ...
    __pyx_pw_2dd_4cudd_8Function_13__richcmp__, /*tp_richcompare*/
    ...
    ...
    #if PY_VERSION_HEX &gt;= 0x030400a1
    0, /*tp_finalize*/
    #endif
};
</code></pre>
<p>(The dots abbreviate lines irrelevant to our discussion.) The <code>PyTypeObject</code> is defined by the <a href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" rel="nofollow noreferrer">CPython C API</a>. The function <code>__pyx_pw_2dd</code> is defined later</p>
<pre><code>/* "dd/cudd.pyx":1556
 *         return Cudd_DagSize(self.node)
 * 
 *     def __richcmp__(Function self, Function other, op):             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
 *         if other is None:
 *             eq = False
 */

/* Python wrapper */
static PyObject *__pyx_pw_2dd_4cudd_8Function_13__richcmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_other, int __pyx_arg_op); /*proto*/
static PyObject *__pyx_pw_2dd_4cudd_8Function_13__richcmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_other, int __pyx_arg_op) {
PyObject *__pyx_v_op = 0;
PyObject *__pyx_r = 0;
</code></pre>
<p>The way to find the first excerpt is by first searching the C file for the Python line of interest (here the signature of <code>Function.__richcmp__</code>), and then search for callers of the C function (though guided by this discussion, I found them by searching for <code>tp_richcompare</code>).</p>
<p>To confirm, I believe that Cython generates the first excerpt from <a href="https://github.com/cython/cython/blob/a0bbb940/Cython/Compiler/TypeSlots.py#L827" rel="nofollow noreferrer">Cython/Compiler/TypeSlots.py</a>:</p>
<pre><code># Later -- synthesize a method to split into separate ops?
MethodSlot(richcmpfunc, "tp_richcompare", "__richcmp__", inherited=False), # Py3 checks for __hash__
</code></pre>
<p>Interestingly, the comment there perhaps suggests that in the future users will be able to implement separate comparator methods, thus not encountering themselves directly this question.</p>
</div>
