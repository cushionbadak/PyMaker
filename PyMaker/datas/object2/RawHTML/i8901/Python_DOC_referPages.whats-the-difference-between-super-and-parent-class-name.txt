<div class="post-text" itemprop="text">
<p>Is there a difference between using <code>super()</code> and using the parent class name directly? For example:</p>
<pre><code>class Parent:
    def __init__(self):
        print("In parent")
        self.__a=10

class Child(Parent):
    def __init__(self):
        super().__init__()     # using super()
        Parent.__init__(self)  # using Parent class name

c=Child()
</code></pre>
<p>Is there internally a difference between <code>super().__init__()</code> and <code>Parent.__init__(self)</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Not in <strong>this case</strong>. But <strong>in general</strong>, and especially when you use <em>multiple inheritance</em>, <strong><code>super()</code> delegates to the next object in the <em>Method Resolution Order (MRO)</em></strong> as is specified in the <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p><strong><code>super([type[, object-or-type]])</code></strong></p>
<p>Return a <strong>proxy object</strong> that delegates method calls to a parent or
  sibling class of type. This is useful for accessing inherited methods
  that have been overridden in a class. The search order is same as that
  used by <code>getattr()</code> except that the type itself is skipped.</p>
<p>The <strong><code>__mro__</code> attribute of the type lists the method resolution search order</strong> used by both <code>getattr()</code> and <code>super()</code>. The attribute
  is dynamic and can change whenever the inheritance hierarchy is
  updated.</p>
<p>(...)</p>
</blockquote>
<p>(copied, boldface added)</p>
<p>Say for instance you define classes like (borrowed from <a href="https://stackoverflow.com/q/41877220/67579">this question, where the MRO is discussed in more detail</a>):</p>
<pre><code>class F:
    def __init__(self):
        print('F%s'%super().__init__)
        super().__init__()

class G: 
    def __init__(self):
        print('G%s'%super().__init__)
        super().__init__() 

class H: 
    def __init__(self):
        print('H%s'%super().__init__)
        super().__init__()

class E(G,H):
    def __init__(self):
        print('E%s'%super().__init__)
        super().__init__()

class D(E,F): 
    def __init__(self):
        print('D%s'%super().__init__)
        super().__init__() 

class C(E,G): 
    def __init__(self):
        print('C%s'%super().__init__)
        super().__init__()

class B(C,H): 
    def __init__(self):
        print('B%s'%super().__init__)
        super().__init__()

class A(D,B,E): 
    def __init__(self):
        print('A%s'%super().__init__)
        super().__init__()
</code></pre>
<p>Then the <code>__mro__</code> of <code>A</code> is:</p>
<pre><code>A.__mro__ == (A,D,B,C,E,G,H,F,object)
</code></pre>
<p>Now if we call <code>A()</code>, it prints:</p>
<pre><code>A&lt;bound method D.__init__ of &lt;__main__.A object at 0x7efefd8645c0&gt;&gt;
D&lt;bound method B.__init__ of &lt;__main__.A object at 0x7efefd8645c0&gt;&gt;
B&lt;bound method C.__init__ of &lt;__main__.A object at 0x7efefd8645c0&gt;&gt;
C&lt;bound method E.__init__ of &lt;__main__.A object at 0x7efefd8645c0&gt;&gt;
E&lt;bound method G.__init__ of &lt;__main__.A object at 0x7efefd8645c0&gt;&gt;
G&lt;bound method H.__init__ of &lt;__main__.A object at 0x7efefd8645c0&gt;&gt;
H&lt;bound method F.__init__ of &lt;__main__.A object at 0x7efefd8645c0&gt;&gt;
F&lt;method-wrapper '__init__' of A object at 0x7efefd8645c0&gt;
&lt;__main__.A object at 0x7efefd8645c0&gt;
</code></pre>
<p>so it means that <strong>in the context of <code>A</code></strong> and when trying <strong>to obtain <code>__init__</code></strong> that:</p>
<ul>
<li><code>super().__init__</code> of <code>A</code> is <code>D.__init__</code>;</li>
<li><strong><code>super().__init__</code> of <code>D</code> is <code>B.__init__</code></strong>;</li>
<li><code>super().__init__</code> of <code>B</code> is <code>C.__init__</code>;</li>
<li><code>super().__init__</code> of <code>C</code> is <code>E.__init__</code>;</li>
<li><code>super().__init__</code> of <code>E</code> is <code>G.__init__</code>;</li>
<li><code>super().__init__</code> of <code>G</code> is <code>H.__init__</code>;</li>
<li><code>super().__init__</code> of <code>H</code> is <code>F.__init__</code>; and</li>
<li><code>super().__init__</code> of <code>F</code> is <code>object.__init__</code>.</li>
</ul>
<p>Note thus that <code>super()</code> does <strong>not per se delegates to a parent</strong>. For instance the <code>super()</code> of <code>D</code> is <code>B</code> and <code>B</code> is not a superclass of <code>D</code>, so it really <strong>depends on the type of the object</strong> (not on the class).</p>
<p>Now in case of <code>D</code>, the <code>__mro__</code> is:</p>
<pre><code>D.__mro__ = (D,E,G,H,F,object)
</code></pre>
<p>If we construct a <code>D</code> however we get:</p>
<pre><code>D&lt;bound method E.__init__ of &lt;__main__.D object at 0x7efefd864630&gt;&gt;
E&lt;bound method G.__init__ of &lt;__main__.D object at 0x7efefd864630&gt;&gt;
G&lt;bound method H.__init__ of &lt;__main__.D object at 0x7efefd864630&gt;&gt;
H&lt;bound method F.__init__ of &lt;__main__.D object at 0x7efefd864630&gt;&gt;
F&lt;method-wrapper '__init__' of D object at 0x7efefd864630&gt;
</code></pre>
<p>So <strong>in the context of <code>D</code></strong> it holds that:</p>
<ul>
<li><strong><code>super().__init__</code> of <code>D</code> is <code>E.__init__</code></strong>;</li>
<li><code>super().__init__</code> of <code>E</code> is <code>G.__init__</code>;</li>
<li><code>super().__init__</code> of <code>G</code> is <code>H.__init__</code>;</li>
<li><code>super().__init__</code> of <code>H</code> is <code>F.__init__</code>; and</li>
<li><code>super().__init__</code> of <code>F</code> is <code>object.__init__</code>.</li>
</ul>
<p>So here <strong>the <code>super()</code> of <code>D</code> leads to <code>E</code> (for <code>__init__</code>)</strong> which is <strong>not the same in the context of <code>A</code></strong>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>super().__init__(*args, **kwargs)   
</code></pre>
<p>Perceive you don't pass the "self" - it is inserted automatically.</p>
<p><code>super()</code> was first designed in Python 2 to allow classes to be reused as mixins in a class hierarchy in a way that their immediate superclass may change:</p>
<p>Let's supose at some point in time your code is like:</p>
<pre><code>class A: pass
class B(A): 
    def __init__(self, *args, **kwargs):
          ...
          # Fixed call to A
          A.__init__(self, *args, **kwargs)

class C(A):
    def __init__(self, *args, **kwargs):
          ...
          # Fixed call to A
          A.__init__(self, *args, **kwargs)

class D(C, B): 
    pass
</code></pre>
<p>At this point, correct OOP code should execute <code>C.__init__</code>   which should chain the call to <code>B.__init__</code>: but when the superclass name is hardcoded that does not happen - <code>A</code>'s <code>__init__</code> would always come next. 
And if you hardcode <code>B.__init__</code> in <code>C</code>, you would prevent <code>C</code> from working without <code>B</code>, defeating the purpose of multiple inheritance. </p>
<p>When you use <code>super()</code> instead, Python's perform the method search for the next parent class looking on the class's <code>__mro__</code> attribute (mro = method resolution order. <code>__mro__</code> is a concrete attribute attached to each Python class).  - So, if at some point in time class <code>D</code> above no longer inherits from <code>B</code>, the calls to <code>super().__init__</code>  in <code>C</code> will be automatically re-routed straight to <code>A</code>.</p>
<p>It is also worth noting that in Python 3 the parameterless form of <code>super</code> was introduced to ease its use - prior to that, one had to hardcode a reference to the own class and also insert <code>self</code> in the parameters. This form is one of the few exceptions in Python that is hardcoded in the compiler itself - it do change things internally on methods when <code>super</code> (or <code>__class__</code>) is seen inside a method body (namely, it creates a <code>__class__</code> variable pointing to the class itself which the <code>super</code> call uses)</p>
</div>
<span class="comment-copy"><code>super()</code> resolves the call using the <b>MRO</b>...</span>
<span class="comment-copy">Only different if your subclass has multiple superclasses, or if you might at some point change your subclass to inherit from a different superclass. Btw, "parent class" is not usual terminology for inheritance.</span>
<span class="comment-copy">@khelwood: strictly speaking that is not true: if you subclass a class that has multiple inheritance, your <code>super()</code> can in fact delegate to a slibing, not a parent. It simply returns the next in line of the <code>__mro__</code>.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/21639788/difference-between-super-and-calling-superclass-directly">Difference between super() and calling superclass directly</a></span>
<span class="comment-copy">I think you missed the most important part there by ending your last sentence too soon:  <code>super()</code> in <code>A</code> will delegate to <code>D</code> and the <code>super()</code> call in <code>D</code> will delegate to <code>B</code> whereas if you started with a <code>D</code> instance its <code>super()</code> call would go to <code>E</code>.</span>
<span class="comment-copy">@Duncan: not at all, see updated answer.</span>
<span class="comment-copy">Yes, your edit crossed with my comment. Much better though I still think it would be useful to show that for a direct D instance <code>super()</code> goes somewhere different.</span>
<span class="comment-copy">@Duncan: that is indeed a great idea. Updated it.</span>
