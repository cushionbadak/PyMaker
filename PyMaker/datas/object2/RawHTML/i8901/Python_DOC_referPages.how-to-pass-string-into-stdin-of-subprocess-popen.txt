<div class="post-text" itemprop="text">
<p>I'm trying to write a Python script that starts a subprocess, and writes to the subprocess stdin. I'd also like to be able to determine an action to be taken if the subprocess crashes.</p>
<p>The process I'm trying to start is a program called <code>nuke</code> which has its own built-in version of Python which I'd like to be able to submit commands to, and then tell it to quit after the commands execute. So far I've worked out that if I start Python on the command prompt like and then start <code>nuke</code> as a subprocess then I can type in commands to <code>nuke</code>, but I'd like to be able to put this all in a script so that the master Python program can start <code>nuke</code> and then write to its <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_.28stdin.29" rel="noreferrer">standard input</a> (and thus into its built-in version of Python) and tell it to do snazzy things, so I wrote a script that starts <code>nuke</code> like this:</p>
<pre><code>subprocess.call(["C:/Program Files/Nuke6.3v5/Nuke6.3", "-t", "E:/NukeTest/test.nk"])
</code></pre>
<p>Then nothing happens because <code>nuke</code> is waiting for user input. How would I now write to standard input?</p>
<p>I'm doing this because I'm running a plugin with <code>nuke</code> that causes it to crash intermittently when rendering multiple frames. So I'd like this script to be able to start <code>nuke</code>, tell it to do something and then if it crashes, try again. So if there is a way to catch a crash and still be OK then that'd be great.</p>
</div>
<div class="post-text" itemprop="text">
<p>It might be better to use <a href="http://docs.python.org/library/subprocess.html#subprocess.Popen.communicate" rel="noreferrer"><code>communicate</code></a>:</p>
<pre><code>from subprocess import Popen, PIPE, STDOUT
p = Popen(['myapp'], stdout=PIPE, stdin=PIPE, stderr=PIPE)
stdout_data = p.communicate(input='data_to_write')[0]
</code></pre>
<p>"Better", because of this warning:</p>
<blockquote>
<p>Use communicate() rather than .stdin.write, .stdout.read or .stderr.read to avoid deadlocks due to any of the other OS pipe buffers filling up and blocking the child process.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can provide a file-like object to the <code>stdin</code> argument of <code>subprocess.call()</code>. </p>
<p>The <a href="http://docs.python.org/library/subprocess.html#frequently-used-arguments" rel="nofollow">documentation</a> for the <code>Popen</code> object applies here.</p>
<p>To capture the output, you should instead use <code>subprocess.check_output()</code>, which takes similar arguments. From the documentation:</p>
<pre><code>&gt;&gt;&gt; subprocess.check_output(
...     "ls non_existent_file; exit 0",
...     stderr=subprocess.STDOUT,
...     shell=True)
'ls: non_existent_file: No such file or directory\n'
</code></pre>
</div>
<span class="comment-copy">If you are looking to quickly write a string to a subprocess stdin, use <code>input</code> of <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer"><code>subprocess.run</code></a>; e.g., <code>subprocess.run(['cat'], input='foobar'.encode('utf-8'))</code></span>
<span class="comment-copy">aaah great, thanks fro that, also if i just do an import subprocess will i still need to import popen PIPE etc?</span>
<span class="comment-copy">No, you don't, but then you need to reference them like <code>subprocess.PIPE</code>. This method also imports everything in the subprocess module. The <code>from subprocess import PIPE</code> introduces into the current namespace, so that you can use just <code>PIPE</code>.</span>
<span class="comment-copy">The <code>communicate</code> method reads data until EOF is received. If you want to interact with the process dynamically, access the pipe using <code>p.stdin.write('data')</code>. For the reading, see my previous comment. The warning is about this way of communicating though, so take care you don't fill up the buffers. Easiest way to verify this, is to just try it...</span>
<span class="comment-copy">For python 3.4 you need to do <code>p.communicate(input="data for input".encode())</code></span>
<span class="comment-copy">When you're searching the answer for the question above, for example if you need to execute "ping" command and <code>communicate</code> doesn't do stick, this answer is utterly unhelpful.</span>
