<div class="post-text" itemprop="text">
<p>I have a script that can work with or without command line args. Say something like following "hello.py":</p>
<pre><code>#!/usr/bin/python
# This is hello.py.

import sys

# Define a main() function that prints a little greeting.
def main():

    if len(sys.argv) &gt;= 3:
        print "Incorect usage."

    if len(sys.argv) == 2:
        name = sys.argv[1]
        print "Hi " + name + ", and Hello world!!!"
    else:
        print "Hello World!!!"


# Standard boilerplate that calls the main() function.
if __name__ == '__main__':
    main()
</code></pre>
<p>Now I intend to write a "wrapper.py" that imports "hello.py" and in turn calls hello. I want to call hello and pass arguments to it such that "hello.py" can still use the logic around sys.argv. Say something like following.</p>
<pre><code>#!/usr/bin/python
# This is wrapper.py.

import sys
import hello

# Define a main() function that prints a little greeting.
def main():

    hello.main()        # This prints "Hello World!!!"

    name = "Harry"
    # hello.main?
    # How to print  "Hi Harry, and Hello world!!!?
    # I want to call main from here and pass and name to it that it picks from sys.argv.
    # I don't want to do os.system("python hello.py Harry").
    # I don't want to do subprocess.Popen("python hello.py Harry", shell=True).communicate()
    # I don't want to define a new function in hello.py that accepts variable args.
    # I want to make preferably no changes to hello.py.
    # Thus I want to somehow call hello.main from here such that it still can pick
    # args from sys.argv.

# Standard boilerplate that calls the main() function.
if __name__ == '__main__':
    main()
</code></pre>
<p>How can I achieve this? Is there any correct or clean way to do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Do not use <code>sys.argv</code> in <code>main</code>; pass a name to it instead, like this</p>
<pre><code>def main(name=None):

    if name:
        print "Hi " + name + ", and Hello world!!!"
    else:
        print "Hello World!!!"

if __name__ == '__main__':
    # Put here the logic of checking the input arguments to the program,
    # all your "if len(sys.argv) &gt;= 3 ..." stuff
    if len(sys.argv) == 2:
        main(sys.argv[1])
    else:
        main()
</code></pre>
<p>Then in your wrapper just call <code>hello.main("Harry")</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You have incorrectly identified your problem; perhaps it becomes clearer if we rename the <code>main</code> function to describe what it actually does:</p>
<pre><code>def parse_arguments_and_display_output():
                  # ^ this is a bad sign
</code></pre>
<p>Your function has two unrelated concerns: <em>parsing arguments</em> and <em>displaying output</em>. Instead, we can refactor it to introduce two new functions:</p>
<pre><code>def main():
    name = parse_arguments()
    display_output(name)
</code></pre>
<p>This is more readable and separates out the unrelated functionality, making it easier to test and reuse. Now your other script becomes:</p>
<pre><code>from hello import display_output

if __name__ == '__main__':
    display_output('Harry')
</code></pre>
<p>This makes the other script clearer, too; not only can it use that display function directly, it's clear from the import that it doesn't have an interest in parsing arguments.</p>
<hr/>
<p>Note that you <em>can</em> use <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer">argparse</a> to take a single positional argument, and it's actually not much more code than you're currently writing:</p>
<pre><code>import argparse

def parse_arguments():
    parser = argparse.ArgumentParser(description='Enter your name')
    parser.add_argument('name', nargs='?', help='your name')
    return parser.parse_args().name
</code></pre>
<p>Also you get nice help:</p>
<pre><code>usage: python.py [-h] name

Enter your name

positional arguments:
  name        your name

optional arguments:
  -h, --help  show this help message and exit
</code></pre>
</div>
<span class="comment-copy">Why do you want to do it like that at all? If you refactor <code>hello.py</code> to separate out the argument parsing, you could just <code>import</code> and call the useful function directly. For example, <code>def main(name):</code> and <code>if __name__ == '__main__': main(parse_args())</code></span>
<span class="comment-copy">Can you explain why none of the several straightforward methods are acceptable for your purposes?</span>
<span class="comment-copy">@Tigerhawk: os.system and subprocess.Popen to me looks like workaround for lack of my knowledge. I will be very surprised if args can't be fed to another script through sys.argv. Possibly some context has to be created before call. I don''t want to use a wrapper function in "hello.py" as it will lead to duplicity of code in main and the function with variable args. The code that I produced here is oversimplistic view of what I am writing and captures the question in context in exact. Any duplicity of code doubles the cost of maintaining it is my rational.</span>
<span class="comment-copy">@Jonrsharpe: parse_args didn't work for me. It possibly will need me to introduce some options like "python hello.py -n Harry" which I think is overhead if you expect at the most one or two arguments.</span>
<span class="comment-copy">You have to write something to parse the arguments, is my point; you <b>already have that code</b>, but it's too tightly coupled to the basically unrelated task of printing out the message. You don't have to use <code>argparse</code> (which, by the way, <i>does</i> allow positional arguments; you <i>could</i> rewrite the exact same functionality using it, with a more consistent interface for the user), just refactor your current code to make more sense.</span>
