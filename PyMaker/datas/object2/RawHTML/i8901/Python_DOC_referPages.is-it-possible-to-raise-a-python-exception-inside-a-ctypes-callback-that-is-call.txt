<div class="post-text" itemprop="text">
<p>I have a shared library that I've wrapped using <code>ctypes</code>. The library exposes function pointers that can be used to modify its error-handling behaviour. Rather than simply printing a warning or terminating the process with <code>exit(1)</code>, I'd like to raise a Python exception which could be caught and handled on the Python side.</p>
<p>Here's a sketch of what I'm trying to do:</p>
<pre><code>import ctypes

mylib = ctypes.cdll.LoadLibrary('mylib.so')

error_handler_p = ctypes.c_void_p.in_dll(mylib, 'error_handler')

@ctypes.CFUNCTYPE(None, ctypes.c_char_p)
def custom_error_handler(message):
    raise RuntimeError(message)


error_handler_p.value = ctypes.cast(custom_error_handler, ctypes.c_void_p).value


try:
    mylib.do_something_bad()
except RuntimeError:
    # maybe handle the exception here
</code></pre>
<p>At the moment it seems as though the exception is being raised within the callback, since I see a traceback with the expected error message in my STDERR. However, this exception does not seem to propagate up to the calling Python process, since the exception never gets caught and the calling process terminates normally.</p>
</div>
<div class="post-text" itemprop="text">
<p>You'd have to use the <a href="https://docs.python.org/3/library/ctypes.html#ctypes.PyDLL" rel="nofollow noreferrer"><code>ctypes.PyDLL()</code> class</a> (via the <code>ctypes.pydll</code> loader) to access your library, and your C code would have to use the <a href="https://docs.python.org/3/c-api" rel="nofollow noreferrer">Python C API</a>. 
You 'raise' an exception in C code by calling <a href="https://docs.python.org/3/c-api/exceptions.html#raising-exceptions" rel="nofollow noreferrer">one of the <code>PyErr_*</code> functions</a>, and then returning <code>-1</code> to flag an error from the function. The <code>PyDLL()</code> class will then check for an exception being set.</p>
<p>You can't use any of the other loaders. Note that the <code>PyDLL()</code> loader also doesn't release the GIL; that would be the responsibility of your extension instead (use the <a href="https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock" rel="nofollow noreferrer">macros supplied by the Python API headers</a>).</p>
<p>Note that since you <em>already</em> have to use the Python API just to raise exceptions, you may as well expose your C code as a proper Python extension.</p>
</div>
<span class="comment-copy">That wasn't the answer I was hoping for, but thanks for the explanation!</span>
<span class="comment-copy">@ali_m: yes, the alternative is to create a Python wrapper module for your <code>ctypes</code>-wrapped library, check for error conditions there and raise exceptions as needed.</span>
