<div class="post-text" itemprop="text">
<p>I'm supposed to create a function and test cases for it that returns the point of intersection of a ray and a sphere.  If there are multiple points of intersection (the ray goes in and out of the sphere) then it should return the point closest to the start of the ray. I have to do this using a quadratic equation.  Here's what I have right now.  </p>
<pre><code>import vector_math
import data

def sphere_intersection_point(ray, sphere):
    pnt = data.Point(2*(ray.pt.x - sphere.center.x), 2*(ray.pt.y -    sphere.center.y), 2*(ray.pt.z - sphere.center.z))
    pnt2 = data.Point(ray.pt.x - sphere.center.x, ray.pt.y - sphere.center.y, ray.pt.z - sphere.center.z)
    a = (vector_math.dot_vector(ray.dir, ray.dir))
    b = (pnt.x*ray.dir.x) + (pnt.y*ray.dir.y) + (pnt.z*ray.dir.z)
    c = (vector_math.dot_vector(pnt2, pnt2)-sphere.radius**2)

    discriminant = (b**2 - 4*a*c)

    t1 = (-b+discriminant)/(2*a)
    t2 = (-b-discriminant)/(2*a)

    t = t1 or t2

    (a*(t**2)) + (b*t) + c == 0

   if t1 &gt; 0 and t2 &gt; 0:
        mt = min(t1,t2)
        vec = vector_math.scale_vector(ray.dir, mt)
        return data.Point(ray.pt.x + vec.x, ray.pt.y + vec.y, ray.pt.z + vec.z)

    elif (t1&gt;0 and t2&lt;0) or (t1&lt;0 and t2&gt;0):
        maxt = max(t1, t2)
        vec2 = vector_math.scale_vector(ray.dir, maxt)
        return data.Point(ray.pt.x + vec2.x, ray.pt.y + vec2.y, ray.pt.z + vec2.z)

    elif t1&lt;0 and t2&lt;0:
        return None
</code></pre>
<p>I wrote one test case for this so far but it did not return the right point. Here is my test cases code.  It's just the very last one.  </p>
<pre><code>import unittest
import data
import vector_math
import math
import collisions

class TestData(unittest.TestCase):
    def test_point_1(self):
        self.assertEqual(data.Point(1,2,3).x,1)
        self.assertEqual(data.Point(1,2,3).y,2)
        self.assertEqual(data.Point(1,2,3).z,3)

    def test_point_2(self):
        self.assertEqual(data.Point(3,3,4).x,3)
        self.assertEqual(data.Point(3,3,4).y,3)
        self.assertEqual(data.Point(3,3,4).z,4)

    def test_vector_1(self):
        self.assertEqual(data.Vector(1,2,3).x,1)
        self.assertEqual(data.Vector(1,2,3).y,2)
        self.assertEqual(data.Vector(1,2,3).z,3)

    def test_vector_2(self):
        self.assertEqual(data.Vector(4,5,6).x,4)
        self.assertEqual(data.Vector(4,5,6).y,5)
        self.assertEqual(data.Vector(4,5,6).z,6)

    def test_ray_1(self):
        self.assertEqual(data.Ray(data.Point(0,0,0),data.Vector(1,2,3)).pt.x,0)
        self.assertEqual(data.Ray(data.Point(0,0,0),data.Vector(1,2,3)).pt.y,0)
        self.assertEqual(data.Ray(data.Point(0,0,0),data.Vector(1,2,3)).pt.z,0)
        self.assertEqual(data.Ray(data.Point(0,0,0),data.Vector(1,2,3)).dir.x,1)
        self.assertEqual(data.Ray(data.Point(0,0,0),data.Vector(1,2,3)).dir.y,2)
        self.assertEqual(data.Ray(data.Point(0,0,0),data.Vector(1,2,3)).dir.z,3)

    def test_ray_2(self):
        self.assertEqual(data.Ray(data.Point(1,2,3),data.Vector(2,2,2)).pt.x,1)
        self.assertEqual(data.Ray(data.Point(1,2,3),data.Vector(2,2,2)).pt.y,2)
        self.assertEqual(data.Ray(data.Point(1,2,3),data.Vector(2,2,2)).pt.z,3)
        self.assertEqual(data.Ray(data.Point(1,2,3),data.Vector(2,2,2)).dir.x,2)
        self.assertEqual(data.Ray(data.Point(1,2,3),data.Vector(2,2,2)).dir.y,2)
        self.assertEqual(data.Ray(data.Point(1,2,3),data.Vector(2,2,2)).dir.z,2)

    def test_sphere_1(self):
        self.assertEqual(data.Sphere(data.Point(1,1,1),4.0).center.x,1)
        self.assertEqual(data.Sphere(data.Point(1,1,1),4.0).center.y,1)
        self.assertEqual(data.Sphere(data.Point(1,1,1),4.0).center.z,1)
        self.assertEqual(data.Sphere(data.Point(1,1,1),4.0).radius,4.0)

    def test_sphere_2(self):
        self.assertEqual(data.Sphere(data.Point(1,1,1),3.0).center.x,1)
        self.assertEqual(data.Sphere(data.Point(1,1,1),3.0).center.y,1)
        self.assertEqual(data.Sphere(data.Point(1,1,1),3.0).center.z,1)
        self.assertEqual(data.Sphere(data.Point(1,1,1),3.0).radius,3.0)

    def test_equality(self):
        self.assertTrue(data.Point(1,2,3) == data.Point(1,2,3))
        self.assertTrue(data.Vector(1,2,3) == data.Vector(1,2,3))
        self.assertTrue(data.Ray(data.Point(0,0,0), data.Vector(1,1,1)) == data.Ray(data.Point(0,0,0), data.Vector(1,1,1)))
        self.assertTrue(data.Sphere(data.Point(0,0,0),3.0) == data.Sphere(data.Point(0,0,0),3.0))

    def test_scale_vector(self):
        self.assertEqual(vector_math.scale_vector(data.Vector(1,1,1),3.0), data.Vector(3.0,3.0,3.0))

    def test_dot_product(self):
        self.assertEqual(vector_math.dot_vector(data.Vector(1,1,1), data.Vector(2,2,2)), 6)

    def test_length_vector(self):
        self.assertEqual(vector_math.length_vector(data.Vector(1,2,3)), math.sqrt(1**2+2**2+3**2))

    def test_normalize_vector(self):
        self.assertEqual(vector_math.normalize_vector(data.Vector(2,0,0)), data.Vector(1,0,0))

    def test_difference_point(self):
        self.assertEqual(vector_math.difference_point(data.Point(2,0,0), data.Point(0,0,0)), data.Vector(2,0,0))

    def test_difference_vector(self):
        self.assertEqual(vector_math.difference_vector(data.Vector(3,3,3), data.Vector(1,1,1)), data.Vector(2,2,2))

    def test_translate_point(self):
        self.assertEqual(vector_math.translate_point(data.Point(0,0,0), data.Vector(1,1,1)), data.Point(1,1,1))

    def test_vector_from_to(self):
        self.assertEqual(vector_math.vector_from_to(data.Point(0,0,0), data.Point(2,2,2)), data.Vector(2,2,2))

    def test_sphere_intersection_pt_1(self):
        ray1 = data.Ray(data.Point(0,0,0), data.Vector(3,0,0))
        sphere1 = data.Sphere(data.Point(5,0,0), 1)
        self.assertEqual(collisions.sphere_intersection_point(ray1, sphere1), data.Point(4,0,0))

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>I know some of the indentations are off but they are right in my text editor it just copied and pasted weird.  Here's the error i get. </p>
<pre><code>root@THEO_PC:/mnt/c/Users/Theo/Desktop/cpe101/hw3# python tests.py
.............F....
======================================================================
FAIL: test_sphere_intersection_pt_1 (__main__.TestData)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tests.py", line 89, in test_sphere_intersection_pt_1
    self.assertEqual(collisions.sphere_intersection_point(ray1, sphere1),    data.Point(4,0,0))
AssertionError: &lt;data.Point instance at 0x7f42757cedd0&gt; != &lt;data.Point   instance at 0x7f42757ced88&gt;

----------------------------------------------------------------------
Ran 18 tests in 0.003s

FAILED (failures=1)
</code></pre>
<p>Also here is my vector_math file. </p>
<pre><code>import math
import data

def scale_vector (vector, scalar):
    return data.Vector(vector.x*scalar, vector.y*scalar, vector.z*scalar)

def dot_vector (vector1, vector2):
    return vector1.x*vector2.x + vector1.y*vector2.y + vector1.z*vector2.z

def length_vector (vector):
    return math.sqrt(vector.x**2 + vector.y**2 + vector.z**2)

def normalize_vector (vector):
    return data.Vector(vector.x/length_vector(vector), vector.y/length_vector(vector), vector.z/length_vector(vector))

def difference_point (point1, point2):
     return data.Vector(point1.x - point2.x, point1.y - point2.y, point1.z - point2.z)

def difference_vector (vector1, vector2):
    return data.Vector(vector1.x - vector2.x, vector1.y - vector2.y, vector1.z - vector2.z)

def translate_point (point, vector):
    return data.Point(point.x + vector.x, point.y + vector.y, point.z + vector.z)

def vector_from_to (from_point, to_point):
    return data.Vector(to_point.x - from_point.x, to_point.y - from_point.y, to_point.z - from_point.z)
</code></pre>
<p>And here's my data file. </p>
<pre><code>import utility

class Point:
    def __init__ (self,x,y,z):
        self.x=x
        self.y=y
        self.z=z
    def __eq__ (self, other):
        x = utility.epsilon_equal(self.x, other.x)
        y = utility.epsilon_equal(self.y, other.y)
        z = utility.epsilon_equal(self.z, other.z)
        return x and y and z

class Vector:
    def __init__ (self,x,y,z):
        self.x=x
        self.y=y
        self.z=z

    def __eq__ (self, other):
        x = utility.epsilon_equal(self.x, other.x)
        y = utility.epsilon_equal(self.y, other.y)
        z = utility.epsilon_equal(self.z, other.z)
        return x and y and z

class Ray:
    def __init__ (self,pt,dir):
        self.pt=pt
        self.dir=dir

    def __eq__ (self, other):
        a = utility.epsilon_equal(self.pt.x, other.pt.x)
        b = utility.epsilon_equal(self.pt.y, other.pt.y)
        c = utility.epsilon_equal(self.pt.z, other.pt.z)
        d = utility.epsilon_equal(self.dir.x, other.dir.x)
        e = utility.epsilon_equal(self.dir.y, other.dir.y)
        f = utility.epsilon_equal(self.dir.z, other.dir.z)
        return a and b and c and d and e and f

class Sphere:
    def __init__ (self,center,radius):
        self.center=center
        self.radius=radius

    def __eq__ (self, other):
        a = utility.epsilon_equal(self.center.x, other.center.x)
        b = utility.epsilon_equal(self.center.y, other.center.y)
        c = utility.epsilon_equal(self.center.z, other.center.z)
        d = utility.epsilon_equal(self.radius, other.radius)
        return a and b and c and d
</code></pre>
<p>Again sorry about the indentation.  I know the classes look wrong but it's right in my code.  Also any suggestions for making my code neater and more concise are appreciated.  </p>
</div>
<div class="post-text" itemprop="text">
<p>The assertEqual calls are comparing the objects for equality, not the contents of the objects. Per the documentation of the unittest module, you will have to register the <code>__eq__</code> functions in your geometry types via the  <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.addTypeEqualityFunc" rel="nofollow noreferrer">unittest.addTypeEqualityFunc()</a>.</p>
</div>
<span class="comment-copy">You should implement the <code>__str__</code> method for your classes to include the coordinates. It will make the error message more readable.</span>
<span class="comment-copy">I thought this was done with the <b>eq</b> functions in my data file</span>
<span class="comment-copy">My mistake. Follow Klaus's advice and look for an error in your algorithm. I don't think it is returning the value you expect.</span>
