<div class="post-text" itemprop="text">
<p>I'm trying to create an <code>Enum</code> subclass whose values use their definition order as their natural sort order, like in the example below:</p>
<pre><code>@functools.total_ordering
class SelectionType(enum.Enum):
     character = 'character'
     word = 'word'
     sentence = 'sentence'
     paragraph = 'paragraph'

     def __le__(self, other):
          if not isinstance(other, SelectionType):
                return NotImplemented

          return self._positions[self] &lt; self._positions[other]

SelectionType._positions = {x: i for i, x in enumerate(SelectionType)}
</code></pre>
<p>Is there a more direct way to get the position of an enum value in its definition order or otherwise a better way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could encode the positions as values. Use <code>.name</code> to get the name.</p>
<pre><code>class SelectionType(enum.Enum):
     character = 1
     word = 2
     sentence = 3
     paragraph = 4
     # copy the OrderedEnum recipe from https://docs.python.org/3/library/enum.html#orderedenum
     def __lt__(self, other):
         if self.__class__ is other.__class__:
             return self.value &lt; other.value 
         return NotImplemented

&gt;&gt;&gt; SelectionType.word.name
'word'
&gt;&gt;&gt; SelectionType.word &lt; SelectionType.sentence
True
</code></pre>
<p>On Python 3.6+ you could use <code>enum.auto()</code> to avoid hard-coding the positions.</p>
<pre><code>class SelectionType(enum.Enum):
    character = enum.auto()
    word = enum.auto()
    sentence = enum.auto()
    paragraph = enum.auto()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If this is a pattern you need often, or if the values are important and cannot be replaced by numbers, make a custom Enum you can inherit from:</p>
<pre><code>import enum

class ByDefinitionOrderEnum(enum.Enum):

    def __init__(self, *args):
        try:
            # attempt to initialize other parents in the hierarchy
            super().__init__(*args)
        except TypeError:
            # ignore -- there are no other parents
            pass
        ordered = len(self.__class__.__members__) + 1
        self._order = ordered

    def __ge__(self, other):
        if self.__class__ is other.__class__:
            return self._order &gt;= other._order
        return NotImplemented

    def __gt__(self, other):
        if self.__class__ is other.__class__:
            return self._order &gt; other._order
        return NotImplemented

    def __le__(self, other):
        if self.__class__ is other.__class__:
            return self._order &lt;= other._order
        return NotImplemented

    def __lt__(self, other):
        if self.__class__ is other.__class__:
            return self._order &lt; other._order
        return NotImplemented
</code></pre>
<p>This allows you to keep any other value instead, while still sorting according to definition order.</p>
<pre><code>class SelectionType(ByDefinitionOrderEnum):

     character = 'character'
     word = 'word'
     sentence = 'sentence'
     paragraph = 'paragraph'
</code></pre>
<p>and in use:</p>
<pre><code>&gt;&gt;&gt; SelectionType.word &lt; SelectionType.sentence
True

&gt;&gt;&gt; SelectionType.word.value &lt; SelectionType.sentence.value
False
</code></pre>
</div>
<span class="comment-copy">Careful with aliases</span>
<span class="comment-copy">Personally, I would do a <code>from enum import Enum, auto</code> to avoid the <code>enum.</code> repetition.  Still worth a +1 though.  :)</span>
<span class="comment-copy">@EthanFurman Absolutely. I'm trying to avoid <code>from</code> imports in short examples to to avoid confusion.</span>
<span class="comment-copy">Why is this proposed instead of simply <i>using</i> an <a href="https://docs.python.org/3/library/enum.html#orderedenum" rel="nofollow noreferrer"><code>OrderedEnum</code></a> ?</span>
<span class="comment-copy">@wim: If you use <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer"><code>aenum</code></a> then <code>OrderedEnum</code> is provided.</span>
<span class="comment-copy">@Aran-Fey:  Using <code>IntEnum</code> (an any <code>Enum</code> with a mixed-in type) loses some of the protections of the <code>Enum</code> type.</span>
