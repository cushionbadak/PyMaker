<div class="post-text" itemprop="text">
<pre><code>class Sequence:
    TranscriptionTable = {
        "A":"U",
        "T":"A",
        "C":"G",
        "G":"C"
    }
    def __init__(self, seqstring):
        self.seqstring = seqstring.upper()
    def transcription(self):
        tt = ""
        for x in self.seqstring:
            if x in 'ATGC':
                tt += self.TranscriptionTable[x]
        return tt

DangerousVirus = Sequence('atggagagccttgttcttggtgtcaa')

print(DangerousVirus.transcription())
</code></pre>
<p>Hi,</p>
<p>I just want some clarification as to how data flows through a class. For instance, is the data in () in DangerousVirus = Sequence('atggagagccttgttcttggtgtcaa') self or seqstring?</p>
<p>I'm confused as to how <strong>init</strong> can have 2 variables when theres only 1 in the (). Wouldnt that mean that only self contains the sequence and seqstring is empty?</p>
<p>Thanks for the help! (:</p>
</div>
<div class="post-text" itemprop="text">
<p><code>self</code> is a reference to a Sequence which is being initialized. The data string is passed as <code>seqstring</code>. You can see this by adding a line to print it:</p>
<pre><code>print(seqstring)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__init__</code> method does indeed take two arguments, but once an instance is created the <code>self</code> argument is "bound" to the instance (<code>__init__</code> becomes a so called bound method of the instance), so you don't have to specify the instance itself anymore. If you call the  unbound <code>__init__</code> function from the class like this</p>
<pre><code>Sequence.__init__(instance, seqstring)
</code></pre>
<p>you indeed have to specify the instance explicitly. The name <code>self</code> is just a convention, it could be anything in the definition. Take a look at the <a href="https://docs.python.org/3/tutorial/classes.html#method-objects" rel="nofollow noreferrer">tutorial section on instance methods</a> where this is explained.</p>
</div>
<div class="post-text" itemprop="text">
<p>As the other answers have said, the <code>self</code> arg gets passed automatically to method calls. So you <em>must</em> include it as the first arg in the method definition, but you must <em>not</em> include it in the method call.</p>
<p>However, there's no need to define a class for this, a simple function is sufficient. And you can use the built-in <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer"><code>str.translate</code></a> method to perform the transcription very efficiently. For large sequences, this is <em>much</em> faster than doing it with a Python loop as in your <code>transcription</code> method, since most of the work is done by compiled code, so it runs as fast as if it were written in C, not Python.</p>
<pre><code>trans_table = str.maketrans('ATCG', 'UAGC')

def transcribe(seq):
    seq = seq.upper()
    return seq.translate(trans_table)

seq = 'atggagagccttgttcttggtgtcaa'
print(transcribe(seq))
</code></pre>
<p><strong>output</strong></p>
<pre><code>UACCUCUCGGAACAAGAACCACAGUU
</code></pre>
<hr/>
<p>As mentioned in the docs, any chars that aren't in the translation table will remain unchanged in the output string. Eg,</p>
<pre><code>print('abcdABCD'.translate(trans_table))
</code></pre>
<p><strong>output</strong></p>
<pre><code>abcdUBGD
</code></pre>
</div>
<span class="comment-copy">Have you read the <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">Classes</a> section in the official tutorial?</span>
