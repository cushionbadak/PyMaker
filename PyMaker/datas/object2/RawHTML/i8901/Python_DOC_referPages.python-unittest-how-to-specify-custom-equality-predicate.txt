<div class="post-text" itemprop="text">
<p>This could be an easy question; I'd like to use a custom equality operator in a Python <code>unittest</code> test case. So for instance, supposing I want to test a "number-to-string" function, and I want to perform a case-insensitive string comparison. </p>
<p>Here's what I'd like to write:</p>
<pre><code>class MyTest(unittest.TestCase):
    def testFoo(self):
        self.assertCheck(ci_string_eq,i2s(24),"Twenty-Four")
</code></pre>
<p>The problem is that <code>assertCheck</code> isn't a thing.</p>
<p>Some obvious workarounds:</p>
<ul>
<li>use assertTrue; the problem is that then a test case failure becomes opaque
and unhelpful; "expected True, got False". Bleah.</li>
<li>dig into unittest and extend it myself; well, I'm hoping to avoid that :)</li>
</ul>
<p>I hope I'm missing something obvious?</p>
<p>Many thanks in advance!</p>
<p>EDIT: some have suggested that I override <code>__eq__</code>. This is not what I want. Specifically, the <code>__eq__</code> method is used by clients of my code, to determine
whether two objects should be considered "the same" (cf. "extensional equality").
For the purposes of testing, though, I want to test using a different predicate.
So overriding <code>__eq__</code> does not solve my problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>The good news is that there isn't any complicated wiring to make a custom assertion with your own rules. Just do the comparison, gather any helpful information, then call <a href="https://docs.python.org/2/library/unittest.html#unittest.TestCase.fail" rel="nofollow noreferrer"><code>fail(msg)</code></a> if needed. That will take care of any reporting you need.</p>
<p>Of course, I'm so lazy that I don't even like to gather the helpful information. What I often find useful is to strip out the irrelevant stuff from both the expected and the actual data, then use the regular <code>assertEquals(expected, actual)</code>.</p>
<p>Here's an example of both techniques, plus a bonus one that uses <a href="https://docs.python.org/2/library/unittest.html#unittest.TestCase.longMessage" rel="nofollow noreferrer"><code>longMessage</code></a> to include context:</p>
<pre><code># file scratch.py

from unittest import TestCase
import sys

def convert(i):
    results = 'ONE TOO THREE'.split()
    return results[i-1]


class FooTest(TestCase):
    def assertResultEqual(self, expected, actual):
        expected_lower = expected.lower()
        actual_lower = actual.lower()
        if expected_lower != actual_lower:
            self.fail('Results did not match: {!r}, {!r}, comparing {!r}, {!r}'.format(
                expected,
                actual,
                expected_lower,
                actual_lower))

    def assertLazyResultEqual(self, expected, actual):
        self.assertEqual(expected.lower(), actual.lower())

    def assertLongLazyResultEqual(self, expected, actual):
        self.longMessage = True
        self.assertEqual(expected.lower(),
                         actual.lower(),
                         'originals: {!r}, {!r}'.format(expected, actual))

    def test_good_convert(self):
        expected = 'One'

        s = convert(1)

        self.assertResultEqual(expected, s)
        self.assertLazyResultEqual(expected, s)
        self.assertLongLazyResultEqual(expected, s)

    def test_bad_convert(self):
        expected = 'Two'

        s = convert(2)

        self.assertResultEqual(expected, s)

    def test_lazy_bad_convert(self):
        expected = 'Two'

        s = convert(2)

        self.assertLazyResultEqual(expected, s)

    def test_long_lazy_bad_convert(self):
        expected = 'Two'

        s = convert(2)

        self.assertLongLazyResultEqual(expected, s)
</code></pre>
<p>That generates the following output, including context and reports of pass and failure counts.</p>
<pre><code>$ python -m unittest scratch
F.FF
======================================================================
FAIL: test_bad_convert (scratch.FooTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/don/workspace/scratch/scratch.py", line 43, in test_bad_convert
    self.assertResultEqual(expected, s)
  File "/home/don/workspace/scratch/scratch.py", line 18, in assertResultEqual
    actual_lower))
AssertionError: Results did not match: 'Two', 'TOO', comparing 'two', 'too'

======================================================================
FAIL: test_lazy_bad_convert (scratch.FooTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/don/workspace/scratch/scratch.py", line 50, in test_lazy_bad_convert
    self.assertLazyResultEqual(expected, s)
  File "/home/don/workspace/scratch/scratch.py", line 21, in assertLazyResultEqual
    self.assertEqual(expected.lower(), actual.lower())
AssertionError: 'two' != 'too'
- two
?  ^
+ too
?  ^


======================================================================
FAIL: test_long_lazy_bad_convert (scratch.FooTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/don/workspace/scratch/scratch.py", line 57, in test_long_lazy_bad_convert
    self.assertLongLazyResultEqual(expected, s)
  File "/home/don/workspace/scratch/scratch.py", line 27, in assertLongLazyResultEqual
    'originals: {!r}, {!r}'.format(expected, actual))
AssertionError: 'two' != 'too'
- two
?  ^
+ too
?  ^
 : originals: 'Two', 'TOO'

----------------------------------------------------------------------
Ran 4 tests in 0.002s

FAILED (failures=3)
</code></pre>
<p>If the custom comparison applies to a specific class, then you can <a href="https://docs.python.org/2/library/unittest.html#unittest.TestCase.addTypeEqualityFunc" rel="nofollow noreferrer">add a custom equality operator</a> for that class. If you do that in your <code>setUp()</code> method, then all the test methods can just call <code>assertEquals()</code> with that class, and your custom comparison will be called.</p>
</div>
<div class="post-text" itemprop="text">
<p>The built in unittest module has a specific method for this called <code>addTypeEqualityFunc</code>. You can read about it <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.addTypeEqualityFunc" rel="nofollow noreferrer">here</a>.
You just have to write your equality function and pass it and simply use the <code>assertEqual</code> method as usual.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/unittest.html#assert-methods" rel="nofollow noreferrer">Here's the full list of supported assertions in Python 3.6's <code>unittest</code> module.</a></p>
<p>As you can see, there is no assertion that takes a custom predicate to evaluate, but you can get a more helpful error message by passing a <em>custom error message</em> to your assertion method through the <code>msg</code> argument.</p>
<p>For instance:</p>
<pre><code>class MyTest(unittest.TestCase):
  def testFoo(self):
    self.assertEqual(i2s(24),"Twenty-Four",msg="i2s(24) should be 'Twenty-Four'")
</code></pre>
<p>If that is not enough for you, you don't really need to go around digging into <code>unittest</code>: You could define a class that extends <code>unittest</code>'s TestCase with the methods you need, i.e.:</p>
<pre><code>class CustomTestCase(unittest.TestCase):
  def assertCheck(self):
    ...
</code></pre>
<p>And then you would define your tests as:</p>
<pre><code>class MyTest(CustomTestCase):
  def testFoo(self):
    self.assertCheck(...)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can override <code>__eq__</code> method of return value class without convoluting the original unit by subclassing it.</p>
<pre><code>class Helper(FooReturnValueClass):

  def __init__(self, obj=None, **kwargs):
     self.obj = obj
     # any other attrs
     # probably good idea to skip calling super

  def __eq__(self, other):
    # logic

class MyTest(unittest.TestCase):

    def testFoo(self):
      expect = self.Helper(...)
      actual = ClassUnderTest.foo(...)
      self.assertEqual(expect, foo) # Order is important
</code></pre>
</div>
<span class="comment-copy">You can take an OOP approach and wrap the unit under test into a class and then override the <code>__eq__</code> method to behave like you want. Then you test only the <code>__eq__</code> method. Separate your concerns.</span>
<span class="comment-copy">Sorry, should have specified this; I explicitly <i>don't</i> want that; the <b>eq</b> method is for extensional equality, and I want to test inside the module. Let me edit to clarify that.</span>
<span class="comment-copy">Say, that <i>is</i> good news. In fact, you did the thing that I didn't want to do! Much appreciated.</span>
<span class="comment-copy">Interesting. Part of me is appalled by certain aspects of this solution, but I think that for my use case (teaching first-year students) it might be perfect. Many thanks!</span>
<span class="comment-copy">In re: first solution: the problem with this is that I don't want to use the existing equality predicate; that's the point of my question. In re: second solution: well, sure, but then I need to dig around in the source of unittest to figure how to hook into the success/failure count, print out results, etc. etc. That's what I said I'm hoping to avoid.  Thanks though!</span>
<span class="comment-copy">I believe the Pythonic way to go about this would be to implement custom <code>__eq__</code> and <code>__ne__</code> methods for your class instead of doing it as part of the test. That way, you can make "equality" mean whatever you like.</span>
<span class="comment-copy">No, doesn't work for me. See comment above.</span>
<span class="comment-copy">In that case, just inside your test module you could use a class that extends the class you're trying to test and only overrides <code>__eq__</code> and <code>__ne__</code>. That way, you get module-local behavior without changing your class.  It's not the  most elegant solution ever, but it works.</span>
<span class="comment-copy">How would you coerce the objects of the class-to-be-tested to be objects of the extended class?</span>
