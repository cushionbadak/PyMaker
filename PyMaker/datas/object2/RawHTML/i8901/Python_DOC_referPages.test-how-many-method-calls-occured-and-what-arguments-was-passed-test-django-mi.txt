<div class="post-text" itemprop="text">
<p>I have a django mixin class with several methods coded like in following simple example:</p>
<pre><code>class Mixin(object):
    def method1(self):
        A = self.A # this is dictionary 
        B = self.B
        C = self.C
        D = self.D

        for i,j in self.A.iteritems():
            self.method2(B, C, D, i, j)

   def method2(self, arg1, arg2, arg3, arg4, arg5):
       pass
</code></pre>
<p>Mixin class declaration don't provide any of A,B,C,D arguments. These will be specified in view class.  </p>
<p>I want to test method1 behavior and check how many method2 calls occured and what arguments were passed in every call. </p>
<p>I'll be grateful for any idea how could I handle this problem.  </p>
<p>Thanks in advance!    </p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this fairly simply with the <code>mock</code> library. You can patch your view under test to replace <code>method2</code> with a mock, and then use the <code>calls_list</code> attribute or the various <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_called" rel="nofollow noreferrer"><code>assert_called_</code></a> methods.</p>
<pre><code>@mock.patch('MyViewClass.method2')
def test_method2_calls(self, patched_method):
    ... thing that calls method1 ...
    patched_method.assert_called_with('A') # or whatever
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be done using a decorator. A simplistic example:</p>
<pre><code>from types import MethodType

class MonitorMethod(object):
    def __init__(self, func):
        self.ncalled = 0
        self.whichargs = []
        self.func = func

    def __call__(self, *args, **kwargs):
        self.ncalled += 1
        # This could be done much prettier with inspect.Signature and signature.bind
        self.whichargs.append((args, kwargs))
        return self.func(*args, **kwargs)

    def __get__(self, instance, cls):
        return self if instance is None else MethodType(self, instance)


class MyClass(object):
    # decorate method
    @MonitorMethod
    def mymethod(self, A, B, C, D, E):
        return A + B + C + D + E
</code></pre>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; instance = MyClass()
&gt;&gt;&gt; instance.mymethod(1,2,3,4,5)
&gt;&gt;&gt; instance.mymethod(1,2,E=3,D=4,C=5)
&gt;&gt;&gt; instance.mymethod.ncalled
2
&gt;&gt;&gt; instance.mymethod.whichargs
[((&lt;__main__.MyClass at 0x2da1ea41080&gt;, 1, 2, 3, 4, 5), {}),
 ((&lt;__main__.MyClass at 0x2da1ea41080&gt;, 1, 2), {'C': 5, 'D': 4, 'E': 3})]
</code></pre>
<p>However decorators are shared between instances so you will get the total count of all calls to that method on any instance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">mock</a> method2 in your test and then use mock specific asserts like <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_called_with" rel="nofollow noreferrer">assert_called_with</a>.</p>
</div>
