<div class="post-text" itemprop="text">
<p>The Python 3 docs give an example of a worker thread that uses a queue (<a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">https://docs.python.org/3/library/queue.html</a>):</p>
<pre class="lang-python prettyprint-override"><code>def worker():
    while True:
        item = q.get()
        if item is None:
            break
        do_work(item)
        q.task_done()

q = queue.Queue()
threads = []
for i in range(num_worker_threads):
    t = threading.Thread(target=worker)
    t.start()
    threads.append(t)

for item in source():
    q.put(item)

# block until all tasks are done
q.join()

# stop workers
for i in range(num_worker_threads):
    q.put(None)
for t in threads:
    t.join()
</code></pre>
<p>In this example, why is <code>q.join()</code> necessary? Don't the subsequent <code>q.put(None)</code> and <code>t.join()</code> operations accomplish the same thing of blocking the main thread until the worker threads have completed?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's how I'm understanding the example.</p>
<p>Each worker loops infinitely, always looking for something new from the Queue.  If the item it gets is <code>None</code>, it breaks and returns control to main. </p>
<p>So, first we make the program wait for the Queue to be empty.  Each call to <code>q.task_done()</code> marks a new item as complete.  The code hangs on the following so we make sure every item is marked as done.</p>
<pre><code># block until all tasks are done
q.join()
</code></pre>
<p>Then, below, we add the same number of <code>None</code> items into the queue as there are workers (so we make sure each worker gets one.)</p>
<pre><code>for i in range(num_worker_threads):
    q.put(None)
</code></pre>
<p>Next, we join all the threads.  Since we gave every worker a <code>None</code> item through the Queue, they will all break.  Until they all break and return control, we want to hang here.</p>
<pre><code>for t in threads:
    t.join()
</code></pre>
<p>Doing it this way, we make sure that every item in the Queue is handled, every worker breaks when the Queue is empty, and each worker is shut down before we move on with our code, helping avoid orphan processes.</p>
</div>
<span class="comment-copy">That's pretty much how I interpreted the example too. So, my question is, isn't every item in the queue handled (and all threads cleaned up) even if we remove the <code>q.join()</code> statement? By joining all the worker threads (the last step) we're still waiting for all the items in the queue to get handled.</span>
<span class="comment-copy">Yes, we are still waiting, but I think it's a coded security measure.  What if the addition of <code>None</code> were added miraculously before all the items in the Queue were handled and a worker got one?  I think it's just a tediously programmed example to make sure you understand what's happening without having to understand completely that Queue goes FIFO (First In, First Out).  And besides, this example could be adapted for a LIFO (Last In, First Out) implementation.  But, with this current example, I believe you could take out <code>q.join()</code> and it would be fine.</span>
