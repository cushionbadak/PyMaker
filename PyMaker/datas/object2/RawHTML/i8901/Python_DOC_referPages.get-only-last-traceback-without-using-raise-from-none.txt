<div class="post-text" itemprop="text">
<p>I have a common situation in my projects, where I use custom Exceptions to wrap built in exception scenarios, like:</p>
<pre><code># meaningless here but in other situations its useful...
try:
   5/0
except ZeroDivisionError as e:
   raise MyCustomException(msg=str(e))
</code></pre>
<p>along with a universal exception handler that looks like this:</p>
<pre><code>@app.errorhandler(Exception)   # this decorator is flask related - ignore it
def handle_error(error):
    if isinstance(error, MyCustomException):
        # some code
        # I only want MyCustomException traceback
    else:
        # some other code    
        exc_stack = traceback.format_exc(limit=5)
</code></pre>
<p>The known issue here is that I get both exception tracebacks, whereas in if-case I want only the last one. </p>
<p><strong>There are two solutions in this problem as far as I know.</strong></p>
<p>First workaround (use <code>from None</code>):</p>
<pre><code>try:
   5/0
except ZeroDivisionError as e:
   raise MyCustomException(msg=str(e)) from None   # python3
</code></pre>
<p>Second workaround (call the traceback before raising the second exception)</p>
<pre><code>try:
    5/0
except ZeroDivisionError as e:
   tracb = traceback.format_exc(limit=5)
   raise MyCustomException(msg=str(e), tracb_msg=tracb)
</code></pre>
<p>No need to call <code>traceback.format_exc()</code> in exception handler, just use the <code>tracb_msg</code> passed to the instance. Obviously first workaround is simpler.</p>
<p><strong>My Problem:</strong></p>
<p>Both of these approaches re-appear (repeating code/trick) dozens of times inside the code, <strong>every time</strong> I raise <code>MyCustomException</code>. Has anyone come up with a trick to handle this <strong>once</strong> inside the handler function?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <code>__suppress_context__</code> attribute to disable context printing.</p>
<p>According to the <a href="https://docs.python.org/3/library/exceptions.html" rel="nofollow noreferrer">docs</a>, using <code>raise MyCustomException(foo) from bar</code> sets <code>__cause__</code> to <code>bar</code>, and <code>__context__</code> to the original exception (the implicitly chained exception).</p>
<blockquote>
<p>An implicitly chained exception in <code>__context__</code> is shown only if <code>__cause__</code> is None and <code>__suppress_context__</code> is false.</p>
</blockquote>
<p>Here's an example:</p>
<pre><code># Declare an exception that never shows context.


class MyCustomException(Exception):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.__suppress_context__ = True

try:
    1/0
except ZeroDivisionError as e:
    raise MyCustomException(str(e))
</code></pre>
<p>Here's the output I get:</p>
<pre><code>Traceback (most recent call last):
  File "/home/don/workspace/scratch/scratch.py", line 12, in &lt;module&gt;
    raise MyCustomException(str(e))
MyCustomException: division by zero
</code></pre>
<p>Here's the output if I set <code>__suppress_context__</code> to <code>False</code>:</p>
<pre><code>Traceback (most recent call last):
  File "/home/don/workspace/scratch/scratch.py", line 10, in &lt;module&gt;
    1/0
ZeroDivisionError: division by zero

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/don/workspace/scratch/scratch.py", line 12, in &lt;module&gt;
    raise MyCustomException(str(e))
MyCustomException: division by zero
</code></pre>
</div>
<span class="comment-copy">This is a sensible workaround, thank you</span>
<span class="comment-copy">Could you explain this line: <code>d = list(reversed(sorted(dir(e))))</code>. Actually d isn't used at all probably, but I wondered if its something we could use it somehow</span>
<span class="comment-copy">Sorry, @chefarov, that was just a debugging statement I used to learn what attributes were available on the exception. I left it in by accident.</span>
<span class="comment-copy">Looks like it's better to use an instance attribute than a class attribute, @chefarov. The default error handler's stack trace seems to ignore the class attribute. I switched my example.</span>
