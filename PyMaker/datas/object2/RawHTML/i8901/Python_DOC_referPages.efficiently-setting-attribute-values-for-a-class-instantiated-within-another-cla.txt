<div class="post-text" itemprop="text">
<p><strong>I am trying to set the attribute values of a certain class <code>AuxiliaryClass</code> than is instantiated in a method from <code>MainClass</code> class in the most efficient way possible.</strong></p>
<p><code>AuxiliaryClass</code> is instantiated within a method of <code>MainClass</code> - see below. However, <code>AuxiliaryClass</code> has many different attributes and I need to set the value of those attributes once the class has been instantiated - see the last 3 lines of my code.</p>
<p><strong>Note</strong>: <em>due to design constraints I cannot explain here, my classes only contain methods, meaning that I need to declare attributes as methods (see below)</em>.</p>
<pre><code>class AuxiliaryClass(object):

    def FirstMethod(self):
        return None
    ...
    def NthMethod(self):
        return None


class MainClass(object):

    def Auxiliary(self):
        return AuxiliaryClass()


def main():
    obj = MainClass()
    obj.Auxiliary().FirstMethod = #some_value
    ...
    obj.Auxiliary().NthMethod = #some_other_value
    # ~~&gt; further code
</code></pre>
<p>Basically I want to replace these last 3 lines of code with something neater, more elegant and more efficient. I know I could use a dictionary if I was instantiating <code>AuxiliaryClass</code> directly:</p>
<pre><code>d = {'FirstMethod' : some_value,
     ...
     'NthMethod'   : some_other_value}

obj = AuxiliaryClass(**d)
</code></pre>
<p>But this does not seem to work for the structure of my problem. Finally, I need to set the values of <code>AuxiliaryClass</code>'s attributes <em>once</em> <code>MainClass</code> has been instantiated (so I can't set the attribute's values within method <code>Auxiliary</code>).</p>
<p><strong>Is there a better way to do this than <code>obj.Auxiliary().IthMethod = some_value</code>?</strong></p>
<hr/>
<p><strong>EDIT</strong></p>
<p>A couple of people have said that the following lines:</p>
<pre><code>    obj.Auxiliary().FirstMethod = #some_value
    ...
    obj.Auxiliary().NthMethod = #some_other_value
</code></pre>
<p>will have no effect because they will immediately get garbage collected. I do not really understand what this means, but if I execute the following lines (after the lines above):</p>
<pre><code>    print(obj.Auxiliary().FirstMethod())
    ...
    print(obj.Auxiliary().NthMethod())
</code></pre>
<p>I am getting the values I entered previously.</p>
</div>
<div class="post-text" itemprop="text">
<p>To speed things up, and make the customization somewhat cleaner, you can cache the results of the <code>AuxilliaryClass</code> constructor/singleton/accessor, and loop over a <code>dict</code> calling <a href="https://docs.python.org/3/library/functions.html?highlight=setattr#setattr" rel="nofollow noreferrer"><code>setattr()</code></a>.</p>
<p>Try something like this:</p>
<pre><code>init_values = {
    'FirstMethod' : some_value,
     :
    'NthMethod'   : some_other_value,
}

def main():
    obj = MainClass()
    aux = obj.Auxiliary() # cache the call, only make it once

    for attr,value in init_values.items():  # python3 here, iteritems() in P2
        setattr(aux, attr, value)

    # other stuff below this point
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I understand what is happening here: my code has a series of decorators before all methods which allow memoization. I do not know exactly how they work but when used the problem described above - namely, that lines of type <code>obj.Auxiliary().IthMethod = some_value</code> get immediately garbage collected - <em>does not occur</em>. </p>
<p>Unfortunately I cannot give further details regarding these decorators as 1) I do not understand them very well and 2) I cannot transmit this information outside my company. I think under this circumstances it is difficult to answer my question because I cannot fully disclose all the necessary details.</p>
</div>
<span class="comment-copy">It looks like <code>MainClass</code> is a class factory. Have you looked at <a href="https://docs.python.org/2.7/reference/datamodel.html?highlight=__metaclass__#__metaclass__" rel="nofollow noreferrer">meta classes</a>. <a href="https://www.google.com/search?q=python+metaclasses" rel="nofollow noreferrer">Search Google</a> for examples. Here are a few from <a href="https://jakevdp.github.io/blog/2012/12/01/a-primer-on-python-metaclasses/" rel="nofollow noreferrer">Jake VanderPlus</a>, <a href="http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example" rel="nofollow noreferrer">Eli Bendersky</a> and <a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/" rel="nofollow noreferrer">Ionel</a>. I'll try to make a quick example in minute.</span>
<span class="comment-copy">Wouldn't <code>obj.Auxiliary().FirstMethod = #some_value</code> basically do nothing at all, as soon as that line ends? <code>obj.Auxiliary()</code> returns a new AuxiliaryClass instance, which you modify an attribute of... And then that instance almost immediately gets garbage collected because its refcount drops to zero. Note that reassigning an instance's attribute will have no effect on any other instance of that class, and no effect on the class itself.</span>
<span class="comment-copy">Two other suggestions: (1) consider using the <a href="https://docs.python.org/2/library/functions.html#property" rel="nofollow noreferrer"><code>property</code></a> decorator for your methods so they appear as attributes, that way you won't need to use <code>()</code> to "call" them and (2) instead of using a meta class this might also be an example of inheritance, if the auxiliary class can inherit from the main class, this may solve your dilemna.</span>
<span class="comment-copy">Actually maybe you just want to monkey patch <code>AuxiliaryClass</code></span>
<span class="comment-copy">@Kevin Doesn't seem so. An instance i of <code>AuxiliaryClass</code> is encapsulated within the instance of <code>MainClass</code> so I can simply set the attributes of i as I wish. Anyway, when I run the code what you are describing does not seem to be happening.</span>
<span class="comment-copy">good idea (see setter in my answer), why not embed this as a method inside the <code>MainClass.Auxiliary</code> method? then just <code>aux = obj.Auxiliary(**d)</code> like the OP wanted?</span>
<span class="comment-copy">OP said he can't do that. ("so I can't set the attribute's values within method Auxiliary")</span>
<span class="comment-copy">also, the way the OP has <code>FirstMethod</code> and others defined as methods, using <code>setattr</code> will just overwrite them and they wont be "callable" anymore unless <code>some_value</code> is itself a method definition with the same signature as the original <code>FirstMethod</code>.</span>
<span class="comment-copy">this is not an answer - you should probably put this as an edit or update to your question - expand on what you already put in the section you called "EDIT"</span>
