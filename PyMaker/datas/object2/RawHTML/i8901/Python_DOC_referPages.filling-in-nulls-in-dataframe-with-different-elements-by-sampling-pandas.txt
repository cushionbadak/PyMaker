<div class="post-text" itemprop="text">
<p>Ive created a dataframe <strong>'Pclass'</strong></p>
<pre><code>    class   deck    weight
0   3       C         0.367568
1   3       B         0.259459
2   3       D         0.156757
3   3       E         0.140541
4   3       A         0.070270
5   3       T         0.005405
</code></pre>
<p>my initial dataframe <strong>'df'</strong> looks like</p>
<pre><code>  class deck
0   3   NaN
1   1   C
2   3   NaN
3   1   C
4   3   NaN
5   3   NaN
6   1   E
7   3   NaN
8   3   NaN
9   2   NaN
10  3   G
11  1   C
</code></pre>
<p>I want to fill in the null deck values in df by choosing a sample from the
decks given in Pclass based on the weights. </p>
<p>I've only managed to code the sampling procedure.</p>
<pre><code>np.random.choice(a=Pclass.deck,p=Pclass.weight)
</code></pre>
<p>I'm having trouble implementing a method to fill in the nulls by finding null rows that belong to class 3 and picking a random deck value <strong>for each</strong>(not the same value all the time), so <strong>not</strong> fillna('with just one').</p>
<p><strong>Note</strong>: I have another question similar to this,but broader with a groupby object as well to maximize efficiency but I've gotten no responses. Any help would be greatly appreciated! </p>
<p><strong>edit:</strong> added rows to dataframe Pclass</p>
<pre><code>1       F             0.470588
1       E             0.294118
1       D             0.235294
2       F             0.461538
2       G             0.307692
2       E             0.230769  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This generates a random selection from the <code>deck</code> column from the <code>Pclass</code> dataframe and assigns these to the <code>df</code> dataframe in the <code>deck</code> column (generating the required number).  These commands could be put in a list comprehension if you wanted to do this across different values of the class variable.  I'd recommend avoiding using <code>class</code> as a variable name since it's used to define new <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">classes</a> within Python.  </p>
<pre><code>import numpy as np
import pandas as pd

# Generate data and normalised weights
normweights = np.random.rand(6)
normweights /= normweights.sum()

Pclass = pd.DataFrame({
    "cla": [3, 3, 3, 3, 3, 3],
    "deck": ["C", "B", "D", "E", "A", "T"],
    "weight": normweights
    })

df = pd.DataFrame({
    "cla": [3, 1, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1],
    "deck": [np.nan, "C", np.nan, "C", 
            np.nan, np.nan, "E", np.nan, 
            np.nan, np.nan, "G", "C"]
    })

# Find missing locations
missing_locs = np.where(df.deck.isnull() &amp; (df.cla == 3))[0]

# Generate new values
new_vals =  np.random.choice(a = Pclass.deck.values, 
        p = Pclass.weight.values, size = len(missing_locs))

# Assign the new values to the dataframe
df.set_value(missing_locs, 'deck', new_vals)
</code></pre>
<hr/>
<h3>Running for multiple levels of the categorical variable</h3>
<p>If you wanted to run this on all levels of the class variable you'd need to make sure you're selecting a subset of the data in <code>Pclass</code> (just the class of interest).  One could use a list comprehension to find the missing data for each level of 'class' like so (I've updated the mock data below) ... </p>
<pre><code># Find missing locations
missing_locs = [np.where(df.deck.isnull() &amp; (df.cla == i))[0] for i in [1,2,3]]
</code></pre>
<p>However, I think the code would be easier to read if it was in a loop: </p>
<pre><code># Generate data and normalised weights
normweights3 = np.random.rand(6)
normweights3 /= normweights3.sum()

normweights2 = np.random.rand(3)
normweights2 /= normweights2.sum()

Pclass = pd.DataFrame({
    "cla": [3, 3, 3, 3, 3, 3, 2, 2, 2],
    "deck": ["C", "B", "D", "E", "A", "T", "X", "Y", "Z"],
    "weight": np.concatenate((normweights3, normweights2))
    })

df = pd.DataFrame({
    "cla": [3, 1, 3, 1, 3, 3, 1, 3, 3, 2, 3, 1],
    "deck": [np.nan, "C", np.nan, "C", 
            np.nan, np.nan, "E", np.nan, 
            np.nan, np.nan, "G", "C"]
    })

    class_levels = [1, 2, 3]
    for i in class_levels:

        missing_locs = np.where(df.deck.isnull() &amp; (df.cla == i))[0]

        if len(missing_locs) &gt; 0:
            subset = Pclass[Pclass.cla == i]

            # Generate new values
            new_vals = np.random.choice(a = subset.deck.values, 
                p = subset.weight.values, size = len(missing_locs))

            # Assign the new values to the dataframe
            df.set_value(missing_locs, 'deck', new_vals)
</code></pre>
</div>
<span class="comment-copy">I actually divided the dataset into 3 classes, it originally had these rows as well:(shown above)                                                                                                                             ... I was hoping to do all the classes at once but was unable to, can you please show the list comprehension method? That would really help me learn, thanks a ton!</span>
<span class="comment-copy">Updated the question.  I'd recommend using a loop - most of this could be written as list comprehensions but it'd actually be pretty complicated for anyone to read the code.</span>
