<div class="post-text" itemprop="text">
<p>Working on a new version of the library I change one of the default arguments of several functions. So I'd like to add a temporary warning that occurs when user calls a function without explicitly specified parameters (so function is called with its defaults).</p>
<p>It could be easily done just by adding the warning function and calling it inside each of base functions:</p>
<pre><code>def warning(formatting):
    if formatting is None:
        sys.stderr.write("WARNING: The default format has changed to new_format")
        return 'new_format'
    return formatting

def my_function(arg1, arg2, formatting=None):
    formatting = warning(formatting)
    ...  # the following function code
</code></pre>
<p>However it would be more convenient to do it using decorator (for code readability). So I've implemented something like this:</p>
<pre><code>def check_default_format(fun):
    def warning(*a, **kw):
        if 'formatting' not in kw.keys() or kw['formatting'] is None:
            kw['formatting'] = 'new_format'
            sys.stderr.write("WARNING: The default format has changed to new_format")
        return fun(*a, **kw)
    return warning

@check_default_format
def my_function(arg1, arg2, formatting=None):
    ...  # the function code
</code></pre>
<p>That works as expected when I call <code>my_function</code> without <code>formatting</code> parameter and if <code>formatting</code> is specified as a keyword parameter.
But how to include the possibility that <code>my_function</code> can be called with only positional parameters? Calling decorated <code>my_function('arg1', 'arg2', 'some_format')</code> will produce an <code>TypeError</code> due to duplication of <code>formatting</code> parameter.</p>
<p>Note: I cannot assume that the <code>formatting</code> is always the 3rd parameter as I need to decorate different functions. I also cannot change the parameters order to preserve backward compatibility.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python 3, you can use the inspect module's <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature.bind_partial" rel="nofollow noreferrer"><code>Signature.bind_partial</code></a>:</p>
<pre><code>def check_default_format(fun):
    @wraps(fun)
    def wrapper(*a, **kw):
        sig= inspect.signature(fun)
        args= sig.bind_partial(*a, **kw)

        if 'formatting' not in args.arguments or args.arguments['formatting'] is None:
            kw['formatting'] = 'new_format'
            sys.stderr.write("WARNING: The default format has changed to new_format")
        return fun(*a, **kw)
    return wrapper
</code></pre>
</div>
<span class="comment-copy">Will the default value of <code>formatting</code> always be <code>None</code>?</span>
<span class="comment-copy">The effective default formatting is (always) <code>new_format</code>. It is (also always) set to <code>None</code> in function declarations to allow us to determine if the user has implicitly specified 'new_format' or if function is called with its defaults.</span>
