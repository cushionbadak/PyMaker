<div class="post-text" itemprop="text">
<p>I'm trying to write a simple Python function that sums all values that have the key as <em>likes</em>. I'm working with functional programming for this assignment. Thus, I am required to use either a <em>list-comprehension</em>, <code>map</code>, <code>filter</code>, or <code>reduce</code>. In this case, I see reduce as a reasonable option. </p>
<pre><code>def sum_favorites(msgs):
     num_favorites = reduce(lambda x, y: x["likes"] + y["likes"], msgs)
     return num_favorites


content1 = {"likes": 32, ...}
content2 = {"likes": 8, ...}
content3 = {"likes": 16, ...}
contents = [content1, content2, content3]
print(sum_favorites(contents)) 
</code></pre>
<p>The issue comes to when I actually run the code. I seem to receive something along the lines of: <strong>TypeError: 'int' object is not subscriptable</strong>. To me, this error makes no sense. If <code>reduce</code> is truly iterating through the given parameter, then each item passed into the lambda-function should be a dictionary - and each of them definitely has a <em>likes</em> key in them. What is the issue, and what exactly does this Python error mean?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>To me, this error makes no sense. If reduce is truly iterating through the given parameter, then each item passed into the lambda-function should be a dictionary</p>
</blockquote>
<p>No, the <em>first</em> parameter passed to the lambda (for all calls except the first) is the return value from the previous call to the lambda. Your function returns a number, so it will be called with <code>x</code> being a number, not a dictionary.</p>
<p>There are two ways to deal with this. The probably more straightforward one is:</p>
<pre><code>num_favorites = reduce(lambda x, y: x + y['likes'], msgs, 0)
</code></pre>
<p>The <code>0</code> is the "initializer" argument to reduce, which provides the first value for <code>x</code>. Now in each call, <code>x</code> is the running sum and <code>y</code> is the next dictionary.</p>
<p>Another way, just to show that it can be done, is:</p>
<pre><code>result = reduce(lambda x, y: { 'likes': x['likes'] + y['likes'] }, msgs)
num_favorites = result['likes']
</code></pre>
<p>which makes the return value of the lambda be a dict with a <code>likes</code> key, just like its arguments, so we're working with the same type the whole way through. In this case it's unnecessary and wasteful, but if you were aggregating more than one key, it might be an interesting approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>Depending on how exactly reduce is implemented, on your second iteration of reduce one operand passed to your lambda will not be a dict but the sum computed so far. Which gives you the error you are seeing.</p>
<p>To avoid this you could first do a list or generator comprehension to extract all the values at "likes" from the various dicts and then reduce <code>operator.add</code> on those. Or just use sum.</p>
</div>
<div class="post-text" itemprop="text">
<p>In your code snippet <code>reduce(lambda x, y: x["likes"] + y["likes"], msgs)</code>, <code>x</code> variable at first is the first element of list msgs (<code>dict</code>), but at the second iteration it'll be a sum of <code>"likes"</code> (<code>int</code>). </p>
<p>So, to sum the likes use the <code>initializer</code> argument of <code>reduce</code> function <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer">doc</a>.</p>
<pre><code>def sum_favorites(msgs):
    num_favorites = reduce(lambda x, y: x + y["likes"], msgs, 0)
    return num_favorites
</code></pre>
<p>But I believe, using <code>sum</code> is a more pythonic way:</p>
<pre><code>def sum_favorites(msgs):
    num_favorites = sum(i['likes'] for i in msgs)
    return num_favorites
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Consider how <code>reduce</code> is working. <code>x</code> is the accumulator variable that is set to the return value of the previous function.</p>
<p>1st iteration</p>
<pre><code>lambda x, y: x["likes"] + y["likes"] = 40
</code></pre>
<p>2nd iteration</p>
<pre><code>lambda 40, y: 40["likes"] + y["likes"] = ???
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After reading Paul's response, I realized that to make sure that consistent data-types were always being summed up, I had to initiate <code>reduce</code> to use an int for 'x' and a dictionary for 'y'. Thus,</p>
<pre><code>def average_favorites(tweets):
    num_favorites = reduce(lambda x, y: x + y["favorites"], tweets, 0)
    return num_favorites
</code></pre>
</div>
