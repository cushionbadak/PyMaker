<div class="post-text" itemprop="text">
<p>I am trying to make a text based object oriented card game. Two players draw a card each from a deck of cards, and the player with the strongest card wins. I have four classes for this game: Card, Deck, Player, Game. My question is: How can i compare each players card to each other and determine the strongest one. All other suggestions about the code are welcome. Best regards HWG.</p>
<p>Here is my code:</p>
<p>Card</p>
<pre><code>class Card():

    values = [None, None, 2, 3, 4, 5, 6, 7, 8, 9, 10, "Jack", "Queen", "King",
        "Ace"]
    suits = ["hearts", "spades", "diamond", "clubs"]

    def __init__(self, value, suit):
        self.value = value
        self.suit = suit

    def __repr__(self):
        return str(self.values[self.value]) + " of " + str(self.suits[self.suit])
</code></pre>
<p>Deck</p>
<pre><code>from random import shuffle
from card import Card

class Deck():

    def __init__(self):
        self.cards = []
        for v in range(2, 15):
            for s in range(4):
                self.cards.append(Card(v, s))
        shuffle(self.cards)
</code></pre>
<p>Player</p>
<pre><code>from deck import Deck

class Player():

    def __init__(self, name):
        self.name = name
        self.card = None
        self.wins = 0
</code></pre>
<p>Game</p>
<pre><code>from player import Player
from deck import Deck
import getch

class Game():

    def __init__(self):
        player1_name = input("Player One Name: ")
        player2_name = input("Player Two Name: ")
        self.deck = Deck()
        self.player1 = Player(player1_name)
        self.player2 = Player(player2_name)
        self.cards = self.deck.cards

    def game_loop(self):
        while len(self.cards) &gt;= 2:
            print("\nPress enter to draw")
            getch.getch()
            player1_card = self.cards.pop()
            player2_card = self.cards.pop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a sketch of an approach. You can easily combine this with your own approach, the biggest change being for the <code>Card</code> class. Here, I've used <code>namedtuple</code> to make a <code>Card</code> class, but your current class can simply wrap a <code>tuple</code> value:</p>
<pre><code>import enum
from functools import total_ordering
from collections import namedtuple

@total_ordering
class OrderedEnum(enum.Enum):
    def __lt__(self, other):
        if isinstance(other, type(self)):
            return self.value &lt; other.value
        return NotImplemented

Rank = OrderedEnum('Rank', ['one', 'two', 'three', 'four', 'five', 'six',
                    'seven', 'eight', 'nine', 'jack', 'queen','king', 'ace'])

Suit = OrderedEnum('Suit', ['clubs', 'diamonds', 'hearts', 'spades'])

Card = namedtuple('Card', ['rank', 'suit'])

c1 = Card(Rank.four, Suit.clubs)
c2 = Card(Rank.four, Suit.spades)
c3 = Card(Rank.ace, Suit.diamonds)
</code></pre>
<p>Now, in action:</p>
<pre><code>&gt;&gt;&gt; c1
Card(rank=&lt;Rank.four: 4&gt;, suit=&lt;Suit.clubs: 1&gt;)
&gt;&gt;&gt; c2
Card(rank=&lt;Rank.four: 4&gt;, suit=&lt;Suit.spades: 4&gt;)
&gt;&gt;&gt; c1 &lt; c2
True
&gt;&gt;&gt; c1 &gt; c3
False
</code></pre>
<p>Tuple sorting is lexicographic! Nice!</p>
<pre><code>&gt;&gt;&gt; hand = [c2, c1, c3]
&gt;&gt;&gt; hand
[Card(rank=&lt;Rank.four: 4&gt;, suit=&lt;Suit.spades: 4&gt;), Card(rank=&lt;Rank.four: 4&gt;, suit=&lt;Suit.clubs: 1&gt;), Card(rank=&lt;Rank.ace: 13&gt;, suit=&lt;Suit.diamonds: 2&gt;)]
&gt;&gt;&gt; sorted(hand)
[Card(rank=&lt;Rank.four: 4&gt;, suit=&lt;Suit.clubs: 1&gt;), Card(rank=&lt;Rank.four: 4&gt;, suit=&lt;Suit.spades: 4&gt;), Card(rank=&lt;Rank.ace: 13&gt;, suit=&lt;Suit.diamonds: 2&gt;)]
&gt;&gt;&gt;
</code></pre>
<p>Note, I've used the <code>total_ordering</code> decorator, which is simply a shortcut, and indeed, I think it might be better to simply do the whole class by hand. <a href="https://docs.python.org/3/library/enum.html#orderedenum" rel="nofollow noreferrer">Here's</a> a recipe.</p>
<p><strong>EDIT</strong>
So, to elaborate, here is how I would implement your <code>Card</code> and <code>Deck</code> classes. Notice how much more readable your code becomes when you use the <code>enum</code> and <code>namedtuple</code>. </p>
<pre><code>import enum
from functools import total_ordering
from collections import namedtuple
from random import shuffle 

@total_ordering
class OrderedEnum(enum.Enum):
    def __lt__(self, other):
        if isinstance(other, type(self)):
            return self.value &lt; other.value
        return NotImplemented

Rank = OrderedEnum('Rank', ['one', 'two', 'three', 'four', 'five', 'six',
                    'seven', 'eight', 'nine', 'jack', 'queen','king', 'ace'])
Suit = OrderedEnum('Suit', ['clubs', 'diamonds', 'hearts', 'spades'])
CardValue = namedtuple('CardValue', ['rank', 'suit'])

@total_ordering
class Card(object):
    def __init__(self, rank, suit):
        self.value = CardValue(rank, suit)
    def __repr__(self):
        return "Card({:s}, {:s})".format(self.value.rank, self.value.suit)
    def __lt__(self, other):
        if isinstance(other, type(self)):
            return self.value &lt; other.value
        return NotImplemented
    def __eq__(self, other):
        if isinstance(other, type(self)):
            return self.value == other.value
        return NotImplemented

class Deck(object):
    def __init__(self):
        self.cards = []
        for rank in Rank:
            for suit in Suit:
                self.cards.append(Card(rank, suit))
        shuffle(self.cards)
</code></pre>
<p>Now, in action:</p>
<pre><code>&gt;&gt;&gt; deck = Deck()
&gt;&gt;&gt; c1 = deck.cards.pop()
&gt;&gt;&gt; c2 = deck.cards.pop()
&gt;&gt;&gt; c1
Card(Rank.queen, Suit.hearts)
&gt;&gt;&gt; c2
Card(Rank.king, Suit.clubs)
&gt;&gt;&gt; c1 == c2
False
&gt;&gt;&gt; c1 &gt; c2
False
&gt;&gt;&gt; c1 &lt; c2
True
&gt;&gt;&gt; c1.value
CardValue(rank=&lt;Rank.queen: 11&gt;, suit=&lt;Suit.hearts: 3&gt;)
&gt;&gt;&gt; c2.value
CardValue(rank=&lt;Rank.king: 12&gt;, suit=&lt;Suit.clubs: 1&gt;)
</code></pre>
<p>Also, notice that <code>__repr__</code> should try to <em>represent</em> the object, if you want a pretty message, use <code>__str__</code>. See <a href="https://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python">this question</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could implement operators for your Card class
<code>__gt__(), __lt__(),</code> etc ...</p>
<p>than you can use a number of standard library functions like max() to determine the higher value card or deck and could even use sort() to simply sort a 'hand' for example a list [Card, Card, ...].</p>
</div>
<div class="post-text" itemprop="text">
<p>An enumeration (<a href="https://docs.python.org/3.5/library/enum.html" rel="nofollow noreferrer">https://docs.python.org/3.5/library/enum.html</a>) would be appropriate. For rich comparisons (and ordering) you should also consider implementing some or all of the <code>__eq__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, <code>__ge__</code> methods (from <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html</a>) on the <code>Card</code> class.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would recommend you store the value of each card as an int, so you can compare them, and not to use strings such as "King" or "Ace". You can do this and change <strong>repr</strong>() to print a human readable version using those strings.</p>
<p>The Card class could look like this:</p>
<pre><code>class Card(object):
     suits = ["Clubs", "Diamonds", "Hearts", "Spades"] #list of suits
     values = [None, "Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King"] #list of card values

     def __init__(self, suit= 0, value= 2):
         """
         Initializes card
         :param suit: Suit of card int value 0-3
         :param value: Value of card int value 0-13
         """
         self.suit = suit
         self.value = value

     def __str__(self):
         """
         Returns a readable format of the card
         """
         return "%s of %s" %(Card.values[self.value],
                             Card.suits[self.suit])
</code></pre>
<p>Notice how the value of the card is stored as an int all the time.</p>
<p>In the Game class you could have a function that compares two cards, I'm not sure how you want to do this but it could look something like this:</p>
<pre><code>def compare(card1, card2):
     """
     Compares the value of two cards and returns the greater of the two
     :param card1: A card object
     :param card2: A second card object
     :return: The higher value card, if tie returns 0
     """
     if card1.value &gt; card2.value:
         return card1
     elif card2.value == card1.value:
         return 0
     else:
         return card2
</code></pre>
</div>
<span class="comment-copy">I think you should consider carefully your representation  - values are a mixture of <code>int</code> and <code>str</code> and suits by just <code>str</code>... And actually, the actual instances themselves have attributes which are <code>ints</code> that correspond to indices in the <code>Card</code> class-level variables. Do you see any problems? This is sort of a canonical use case for <code>enum</code></span>
<span class="comment-copy">Can I in some way use the value and suit indexes in the lists (values and suits) to compare two cards?</span>
<span class="comment-copy">Yeah, sure. Seems messy to me. I would definitely use <code>enum</code>s. Your code will be much more readable and nice and tidy. But sure, you can use indices.</span>
<span class="comment-copy">Yeah, but now <code>card1.value &gt; 48</code> will actually be evaluated. Not good. This is a prototypical case for <code>enum</code>. And your <code>compare</code> function is very much not what you would do if you already have a class, instead, you would implement the rich comparison operators.</span>
