<div class="post-text" itemprop="text">
<p>Ok. I'm looking for the smartest and more compact way to do this function</p>
<pre><code>def f():
    [[a,b,c] for a in range(6) for b in range(6) for c in range(6)]
</code></pre>
<p>which should generate all the combinations for the values a,b,c like this:</p>
<pre><code>[0,0,0]
[0,0,1]
[0,0,2]
...
[1,0,0]
[1,0,1]
...
</code></pre>
<p>and so on...</p>
<p>But I want this to be flexible, so I can change the range or iterable, and also the length of the generated arrays. Range is an easy thing:</p>
<pre><code>def f(min, max):
    [[a,b,c] for a in range(min,max) for b in range(min,max) for c in range(min,max)]
</code></pre>
<p>This is ok for 3-length arrays, but I'm thinking now of making 4-length arrays or 7-length arrays and generate all combinations for them in the same range.</p>
<p>It has to exist an easy way, maybe with concatenating arrays or nesting comprehension lists in some way, but my solutions seem to bee too much complex.</p>
<p>Sorry for such a long post. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> which is just a convenience function for nested iterations. It also has a <code>repeat</code>-argument if you want to repeat the same <code>iterable</code> multiple times:</p>
<pre><code>&gt;&gt;&gt; from itertools import product

&gt;&gt;&gt; amin = 0
&gt;&gt;&gt; amax = 2
&gt;&gt;&gt; list(product(range(amin, amax), repeat=3))
[(0, 0, 0), (0, 0, 1), (0, 1, 0),  (0, 1, 1),  (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]
</code></pre>
<p>To get the <code>list</code> of <code>list</code> you could use <code>map</code>:</p>
<pre><code>&gt;&gt;&gt; list(map(list, product(range(amin, amax), repeat=3)))
[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]]
</code></pre>
<p>However <code>product</code> is an iterator so it's really efficient if you just iterate over it instead of casting it to a <code>list</code>. At least if that's possible in your program. For example:</p>
<pre><code>&gt;&gt;&gt; for prod in product(range(amin, amax), repeat=3):
...     print(prod)  # one example
(0, 0, 0)
(0, 0, 1)
(0, 1, 0)
(0, 1, 1)
(1, 0, 0)
(1, 0, 1)
(1, 1, 0)
(1, 1, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="noreferrer"><code>itertools.product</code></a>:</p>
<pre><code>from itertools import product

def f(mn, mx, n):
    return list(product(*[range(mn, mx)]*n)))
</code></pre>
<p>Drop <code>list</code>, to return a generator for memory efficiency.</p>
</div>
<div class="post-text" itemprop="text">
<p><em>itertools</em> has everything you need. <em>combinations_with_replacement</em> will generate combinations of given length with repeating elements from given iterable. Note that returned value will be iterator.</p>
<pre><code>def f(min, max, num):    
    return itertools.combinations_with_replacement(range(min, max), num)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A pure python implementation :</p>
<pre><code>k=2  # k-uples
xmin=2
xmax=5 
n=xmax-xmin

l1 = [x for x in range(n**k)]
l2 = [[ x//n**(k-j-1)%n for x in l1] for j in range(k)]          
l3 = [[ xmin + l2[i][j] for i in range(k)] for j in range(n**k)]
</code></pre>
<p><code>l3</code> is :</p>
<pre><code>[[2 2]
 [2 3]
 [2 4]
 [3 2]
 [3 3]
 [3 4]
 [4 2]
 [4 3]
 [4 4]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you are looking for is the cartesian product of the ranges. Luckily this already exists in itertools</p>
<pre><code>import itertools
print(list(itertools.product(range(0,5), range(0,5), range(0,5))))
</code></pre>
</div>
<span class="comment-copy">The <code>itertools</code> module has a <code>product</code> function that does exactly what you're looking for. <code>from itertools import product; product(range(6), range(6), range(6))</code>. Whatever iterator is placed last cycles the fastest.</span>
<span class="comment-copy">I finally made a one-liner with <code>[list(elem) for elem in product(*repeat(iterable, times))]</code></span>
<span class="comment-copy">Nice for other situations, but I needed [0,0,1] != [1,0,0]. The order does matter. Maybe I should have explained better. I will write this down, though</span>
<span class="comment-copy">Right, then as some other answers stated - itertools.product will be better.</span>
<span class="comment-copy">You should review the code. *// gives a syntax error</span>
<span class="comment-copy">It's '//'. It works OK</span>
<span class="comment-copy">One should rather call it "pure built-in" implementation. I find it non-pythonic because of unreadability and possibly more memory and time overhead than when done with functionality from Python's standard library.</span>
