<div class="post-text" itemprop="text">
<p>Aim: I'd like to get (or be able to work with) a set of all possible permutations obtained from a list of strings.</p>
<p>Example in Python:</p>
<pre><code>import pandas as pd
import itertools

list1 = ['A', 'A', 'B', 'B']

# Get all permutations
list1_perm = list(itertools.permutations(list1))

len(list1_perm)
24

list1_perm
[('A', 'A', 'B', 'B'),
 ('A', 'A', 'B', 'B'),
 ('A', 'B', 'A', 'B'),
 ('A', 'B', 'B', 'A'),
 ('A', 'B', 'A', 'B'),
 ('A', 'B', 'B', 'A'),
 ('A', 'A', 'B', 'B'),
 ('A', 'A', 'B', 'B'),
 ('A', 'B', 'A', 'B'),
 ('A', 'B', 'B', 'A'),
 ('A', 'B', 'A', 'B'),
 ('A', 'B', 'B', 'A'),
 ('B', 'A', 'A', 'B'),
 ('B', 'A', 'B', 'A'),
 ('B', 'A', 'A', 'B'),
 ('B', 'A', 'B', 'A'),
 ('B', 'B', 'A', 'A'),
 ('B', 'B', 'A', 'A'),
 ('B', 'A', 'A', 'B'),
 ('B', 'A', 'B', 'A'),
 ('B', 'A', 'A', 'B'),
 ('B', 'A', 'B', 'A'),
 ('B', 'B', 'A', 'A'),
 ('B', 'B', 'A', 'A')]
</code></pre>
<p>Since for my analysis <code>('A', 'A', 'B', 'B')</code> is the same as <code>('A', 'A', 'B', 'B')</code>, (although the <code>'A'</code> may have changed the position), I do:</p>
<pre><code># Get set of permutations
set1_perm = set(itertools.permutations(list1))

len(set1_perm)
6

set1_perm
{('A', 'A', 'B', 'B'),
 ('A', 'B', 'A', 'B'),
 ('A', 'B', 'B', 'A'),
 ('B', 'A', 'A', 'B'),
 ('B', 'A', 'B', 'A'),
 ('B', 'B', 'A', 'A')}
</code></pre>
<p>Now this is great, but the list I want to work with has 481 strings, with 5 unique strings with different frequencies:</p>
<pre><code>len(real_list)
481

len(set(real_list))
5

# Count number of times each unique value appears
pd.Series(real_list).value_counts()
A  141
B  116
C  80
D  78
E  66
</code></pre>
<p>This is not a problem for <code>itertools.permutations(real_list)</code>, but when I want to get the <code>set</code>, it takes ages. This is because the number of permutations is <code>9.044272819E+1082</code>.</p>
<p>What I want to do is:
First I want to know the number of unique elements in that permutation space, i.e. the length of the set. To get the number of unique elements it might be possible to do it analytically, however since the frequency of each unique element is different I don't how to do that.  </p>
<p>Second I would like to be able to get a sample of those unique elements in the set of permutations.</p>
<p>I'd appreciate any help provided.</p>
<p>Best,
Alejandro</p>
</div>
<div class="post-text" itemprop="text">
<p>Calculating the number of unique permutations is simply a matter of applying a formula - we know that were we to have <code>n</code> distinct elements, we would have <code>n!</code> permutations. Then to account for repeated permutations we must divide by each count of permutations of repeated letters. This is a <em>multinomial coefficient</em>.</p>
<p><a href="https://i.stack.imgur.com/DqwiL.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/DqwiL.png"/></a></p>
<p>So a simple implementation to generate the unique count may look something like </p>
<pre><code>from math import factorial
from functools import reduce
from collections import Counter

def perm_cnt(l):
    denom = reduce(lambda x,y: x*factorial(y), Counter(l).values())
    return factorial(len(l)) // denom
</code></pre>
<p>Then sampling from the unique permutations is probably most simply achieved by just ensuring your sample values remain unique, as opposed to trying to generate all of the unique values and <em>then</em> sampling. There is a <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipe</a> in the itertools module, <code>random_permutation</code>, which could be useful for this. </p>
<pre><code>def random_permutation(iterable, r=None):
    "Random selection from itertools.permutations(iterable, r)"
    pool = tuple(iterable)
    r = len(pool) if r is None else r
    return tuple(random.sample(pool, r))
</code></pre>
<p>So creating a unique sample might look something like </p>
<pre><code>def uniq_sample(l, size):
    s = set()
    perm_size = perm_cnt(l)
    cnt = 0
    while cnt &lt; min(perm_size, size):
        samp = random_permutation(l)
        if samp not in s:
            s.add(samp)
            cnt += 1
    return s
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>&gt;&gt;&gt; perm_cnt(list1)
6

&gt;&gt;&gt; perm_cnt(['a']*3 + ['b']*5 + ['d']*2)
2520

&gt;&gt;&gt; perm_cnt(np.random.randint(10, size=20))
105594705216000

&gt;&gt;&gt; uniq_sample(list1, 4)
{('A', 'A', 'B', 'B'),
 ('B', 'A', 'A', 'B'),
 ('B', 'A', 'B', 'A'),
 ('B', 'B', 'A', 'A')}
</code></pre>
</div>
<span class="comment-copy">This is awesome! Many thanks for all the explanations, code, and demo!</span>
<span class="comment-copy">@AlejandroJimenez-Sanchez You're welcome!</span>
