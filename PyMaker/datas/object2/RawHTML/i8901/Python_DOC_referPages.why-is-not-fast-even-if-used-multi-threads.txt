<div class="post-text" itemprop="text">
<p>I used code as below for multi threads to download images, but I found that not so fast, I am not sure why, does anyone expalin for me?</p>
<p>Normal download:</p>
<pre><code>for imageSecond in imageSeconds:
    urlServer = imageSecond.get("src")
    pathLocal = formatPath(downloadLocationPath, ntpath.basename(urlServer))
    downloadImage(browser, urlServer, pathLocal)    

def downloadImage(browser, urlServer, pathLocal):
</code></pre>
<p>Threads download:</p>
<pre><code>ts = []
for imageSecond in imageSeconds:
    urlServer = imageSecond.get("src")
    pathLocal = formatPath(downloadLocationPath, ntpath.basename(urlServer))
    ts.append(createNewDownloadThread(browser, urlServer, pathLocal))

for t in ts:
    t.join()

def createNewDownloadThread(browser, urlServer, pathLocal):
    download_thread = threading.Thread(target=downloadImage, args=(browser, urlServer, pathLocal))
    download_thread.start()
    return download_thread#.join()

def downloadImage(browser, urlServer, pathLocal):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/threading.html#threading.Thread.join" rel="nofollow noreferrer">Python docs</a>:</p>
<blockquote>
<p><strong>join(timeout=None)</strong>
  Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates – either normally or through an unhandled exception – or until the optional timeout occurs.</p>
</blockquote>
<p>So you're creating a thread, waiting that it completes the download and then create another thread for following download which is basically the same as your original solution.</p>
<p><strong>Update</strong> You could use <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer"><code>concurrent.futures</code></a> which offers simple interface:</p>
<pre><code>import concurrent.futures as cf

def square(x):
    return x*x

with cf.ThreadPoolExecutor(10) as executor:
    futures = [executor.submit(square, i) for i in range(5)]
    cf.wait(futures)

    for f in futures:
        print(f.result())
</code></pre>
<p>Output:</p>
<pre><code>0
1
4
9
16
</code></pre>
<p>With your code it would look something like this:</p>
<pre><code>NUM_THREADS = 10
with cf.ThreadPoolExecutor(NUM_THREADS) as executor:
    futures = []
    for imageSecond in imageSeconds:
        urlServer = imageSecond.get("src")
        pathLocal = formatPath(downloadLocationPath, ntpath.basename(urlServer))
        futures.append(executor.submit(downloadImage, browser, urlServer, pathLocal))

    cf.wait(futures)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use code as below</p>
<pre><code>ts = []

for:
    t = createThread()
    t.start()
    ts.append(t)

for t in ts:
    t.join()
</code></pre>
<p>to instead of code</p>
<pre><code>for:
    t = createThread()
    t.start()
    t.join()
</code></pre>
</div>
<span class="comment-copy">Most likely reason: the bottleneck is your network connection, putting more CPU kernels to use it simultaneosly does nothing to improve that.</span>
<span class="comment-copy">If I don't use join what I found the download images are not what I need, what can I modify my code for parallel download but no errors?</span>
<span class="comment-copy">@mikezang Added simple example with <code>concurrent.futures</code>. If you want to stick with <code>threading</code> create the threads first, store them to list and then <code>join</code> them one by one.</span>
<span class="comment-copy">I just modified my code then speed is faster more than original 2 times, is there anyway to be more fast?</span>
