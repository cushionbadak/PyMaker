<div class="post-text" itemprop="text">
<p>I need to append objects  to one list "L" from different processes using multiprocessing , but it returns empty list.
 How can i let many processes append to list "L"using multiprocessing  ?</p>
<pre><code>    #!/usr/bin/python
from multiprocessing import Process
L=[]
def dothing(i,j):
        L.append("anything")
        print i
if __name__ == "__main__":
        processes=[]
        for i in range(5):
                p=Process(target=dothing,args=(i,None))
                p.start()
                processes.append(p)
        for p in processes:
                p.join()
print L
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Global variables are not shared between processes.</p>
<p>You need to use <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.sharedctypes.multiprocessing.Manager" rel="noreferrer"><code>multiprocessing.Manager.list</code></a>:</p>
<pre><code>from multiprocessing import Process, Manager

def dothing(L, i):  # the managed list `L` passed explicitly.
    L.append("anything")

if __name__ == "__main__":
    with Manager() as manager:
        L = manager.list()  # &lt;-- can be shared between processes.
        processes = []
        for i in range(5):
            p = Process(target=dothing, args=(L,i))  # Passing the list
            p.start()
            processes.append(p)
        for p in processes:
            p.join()
        print L
</code></pre>
<p>See <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="noreferrer">Sharing state between processesÂ¶</a> (<strong>Server process</strong> part).</p>
</div>
<div class="post-text" itemprop="text">
<p>Using the solution provided by <code>@falsetru</code> worked. but still the list was not accessible beyond the "<code>with Manager() as manager:</code>" two changes were needed:
1.) adding "<code>L = []</code>" in front of the "<code>if __name__ == "__main__</code>":" statement</p>
<h1>Must be added as for some reason the last <code>print(L)</code> (the "Outside of IF" one) tries to be executed as many times as there are Processes + 1 ?!?!?</h1>
<p>this returns an error that L is not defined and the code breaks.</p>
<p>2.) adding "<code>L = list(L)</code>" after the "<code>p.join()</code>" statement.</p>
<h1>step needed to change <code>Manager.list</code> to regular <code>Python.list</code> - otherwise calls to the manager.list return errors that object not readable.</h1>
<pre><code>####################
####### CODE: ######
####################

from multiprocessing import Process, Manager

def dothing(L, i):  # the managed list `L` passed explicitly.
    for j in range(5):
        text = "Process " + str(i) + ", Element " + str(j)
        L.append(text)

L = [] 

if __name__ == "__main__":
    with Manager() as manager:
        L = manager.list()  # &lt;-- can be shared between processes.
        processes = []

        for i in range(5):
            p = Process(target=dothing, args=(L,i,))  # Passing the list
            p.start()
            processes.append(p)

        for p in processes:
            p.join()

        L = list(L) 
        print("Within WITH")
        print(L)

    print("Within IF")
    print(L)

print("Outside of IF")
print(L)
</code></pre>
<p>"""<br/>
    ####################
    ###### OUTPUT: #####
    ####################</p>
<pre><code>Outside of IF
[]
Outside of IF
[]
Outside of IF
[]
Outside of IF
[]
Outside of IF
[]
Outside of IF
[]
Within WITH
['Process 2, Element 0', 'Process 2, Element 1', 'Process 2, Element 2',
</code></pre>
<p>'Process 2, Element 3', 'Process 2, Element 4', 'Process 1, Element 0', 
'Process 1, Element 1', 'Process 1, Element 2', 'Process 1, Element 3', 
'Process 1, Element 4', 'Process 0, Element 0', 'Process 0, Element 1', 
'Process 0, Element 2', 'Process 0, Element 3', 'Process 0, Element 4', 
'Process 4, Element 0', 'Process 4, Element 1', 'Process 4, Element 2', 
'Process 4, Element 3', 'Process 4, Element 4', 'Process 3, Element 0', 
'Process 3, Element 1', 'Process 3, Element 2', 'Process 3, Element 3', 
'Process 3, Element 4']</p>
<pre><code>Within IF
['Process 2, Element 0', 'Process 2, Element 1', 'Process 2, Element 2', 
</code></pre>
<p>'Process 2, Element 3', 'Process 2, Element 4', 'Process 1, Element 0', 
'Process 1, Element 1', 'Process 1, Element 2', 'Process 1, Element 3', 
'Process 1, Element 4', 'Process 0, Element 0', 'Process 0, Element 1', 
'Process 0, Element 2', 'Process 0, Element 3', 'Process 0, Element 4', 
'Process 4, Element 0', 'Process 4, Element 1', 'Process 4, Element 2',
 'Process 4, Element 3', 'Process 4, Element 4', 'Process 3, Element 0', 
'Process 3, Element 1', 'Process 3, Element 2', 'Process 3, Element 3', 
'Process 3, Element 4']</p>
<pre><code>Outside of IF
['Process 2, Element 0', 'Process 2, Element 1', 'Process 2, Element 2', 
</code></pre>
<p>'Process 2, Element 3', 'Process 2, Element 4', 'Process 1, Element 0', 
'Process 1, Element 1', 'Process 1, Element 2', 'Process 1, Element 3', 
'Process 1, Element 4', 'Process 0, Element 0', 'Process 0, Element 1', 
'Process 0, Element 2', 'Process 0, Element 3', 'Process 0, Element 4', 
'Process 4, Element 0', 'Process 4, Element 1', 'Process 4, Element 2', 
'Process 4, Element 3', 'Process 4, Element 4', 'Process 3, Element 0', 
'Process 3, Element 1', 'Process 3, Element 2', 'Process 3, Element 3', 
'Process 3, Element 4']</p>
<pre><code>"""
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to @falsetru for suggesting the exact documentation and providing the good code. I need to keep the order for my application and by modifying the @falsetru code, now the below code preserves the order of adding items to the list. </p>
<p>The sleep is helpful to catch the bugs otherwise it is hard to catch the problem with ordering of the list.</p>
<pre><code>from multiprocessing import Process, Manager
from time import sleep

def dothing(L, i):  # the managed list `L` passed explicitly.
    L[i]= i
    sleep(4)

if __name__ == "__main__":
    with Manager() as manager:
        L = manager.list(range(50))  # &lt;-- can be shared between processes.
        processes = []
        for i in range(50):
            p = Process(target=dothing, args=(L,i))  # Passing the list
            p.start()
            processes.append(p)
        for p in processes:
            p.join()
        print(L)
</code></pre>
</div>
<span class="comment-copy">This is printing empty. Something changed with Python 3.?</span>
<span class="comment-copy">@TronaldDump, I tested in Python 2.7 / 3.6 (in Ubuntu 18.04). It just works for me. <a href="https://i.imgur.com/FX2GmRp.png" rel="nofollow noreferrer">i.imgur.com/FX2GmRp.png</a></span>
<span class="comment-copy">I was using Jupyter Notebook and it wasn't working. But worked in Spyder though.</span>
<span class="comment-copy">@TronaldDump, How about post a separated question with <code>jupyter</code> tag?</span>
<span class="comment-copy">@falsetru I modified your code by appending i instead of "anything" and sleep(4) after that inside the dothing function. The results shows the list is not appended in order. I ran it for 50 numbers and the results is like this. [0, 1, 2, 3, 4, 5, 7, 6, 9, 8, 10, 14, 11, 17, 16, 15, 12, 19, 21, 18, 13, 20, 23, 24, 25, 22, 27, 26, 29, 32, 30, 28, 43, 34, 33, 31, 36, 40, 37, 38, 41, 42, 39, 35, 45, 44, 46, 48, 47, 49]. Is there a way to preserve the order?</span>
