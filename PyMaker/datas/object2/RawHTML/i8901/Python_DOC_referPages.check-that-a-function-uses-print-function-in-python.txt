<div class="post-text" itemprop="text">
<p>I want to write a decorator in <code>python</code>: if a called function contains <code>print</code>'s, the decorator prints her name before this function being called. I'm familiar with decorators syntax, but I have a problem with checking if a function has <code>print</code> within itself.</p>
<pre><code>def preceeding_name(func):        
    @wraps(func)
    def wrapper(*args, **kwargs):
        if 'print' in func: 
            print(func.__name__)
        result = func(*args, **kwargs)
        return result
    return wrapper
</code></pre>
<p>It is not necessary to check if the <code>print</code>'s from function will actually be called.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be done by holding the buffer of 'print' from flushing and checking it to see if a print has been done.</p>
<pre><code>class Out(object):
    def write(self,s):
        self.s += s
    def __init__(self)
        self.s = '' 
</code></pre>
<p>Now to check</p>
<pre><code>def wrapper(*args, **kwargs):
        our_out = Out()
        sys.stdout = our_out
        result = func(*args, **kwargs)

        if len(our_out.s)&gt;0:
            sys.stdout = sys.__stdout__
            print func.__name__
            for s in our_out.s.split('\n'):
                print s     

        return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I this case you can redefine print</p>
<pre><code>def preceeding_name(func):
    @wraps(func)
    def wrapper(*args, **kwargs):

        old_print = print

        def print(*arg, **kwarg):
            old_print(func.__name__)
            old_print(*arg, **kwarg)

        result = func(*args, **kwargs)
        return result
    return wrapper
</code></pre>
<p>EDIT:
i test and this work</p>
<pre><code>old_print = print

def preceeding_name(func):

    def print(*arg, **kwarg):
        old_print(func.__name__, end='')
        old_print(*arg, **kwarg)

    def wrapper(*args, **kwargs):
        print('')
        result = func(*args, **kwargs)
        return result
    return wrapper

@preceeding_name
def a():
    print('hi')


a()

@preceeding_name
def b():
    print('hi')


b()
</code></pre>
<p>EDIT2:</p>
<pre><code>old_print = print


def preceeding_name(func):
    global print
    def print(*arg, **kwarg):
        old_print(func.__name__)
        old_print(*arg, **kwarg)

    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result

    return wrapper


@preceeding_name
def a():
    print('hi')


a()


@preceeding_name
def b():
    # print('hi')
    pass

b()
</code></pre>
</div>
<span class="comment-copy">Finding out if a function calls another function is <a href="https://stackoverflow.com/questions/12013399/in-python-determine-if-a-function-calls-another-function">hard</a>. Can I suggest that you use the <a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer"><code>logging</code></a> module instead? You can then easily use something like <code>%(funcName)s</code> when creating a formatter.</span>
<span class="comment-copy">@Josh, thank you, I will look at this functional</span>
<span class="comment-copy">This can be done by overriding sys.stdout</span>
<span class="comment-copy">This decorator doesn't do anything at all. Just because you redefine print in your current scope doesn't mean the decorated function will also use the new print.</span>
<span class="comment-copy">@Rawing new edit of my code work in my computer. i use python 3.4</span>
<span class="comment-copy">This doesn't check if the function ever calls <code>print</code>.</span>
<span class="comment-copy">@Rawing ok you right</span>
<span class="comment-copy">@Rawing EDIT2 will work</span>
