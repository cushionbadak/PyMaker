<div class="post-text" itemprop="text">
<p>I'm working with Python (2.7) and pymongo (3.3), and I need to spawn a child process to run a job asynchronously. Unfortunately pymongo is not fork-safe as described <a href="http://api.mongodb.com/python/current/faq.html#is-pymongo-thread-safe" rel="nofollow noreferrer">here</a> (and I need to interact with the db before spawning the child process).</p>
<p>I ran an experiment using <code>subprocess.Popen</code> (with <code>shell</code> set to <code>True</code> and then <code>False</code>) and <code>multiprocessing.Process</code>. As far as I can tell they both fork the parent process to create the child process, but only <code>multiprocessing.Process</code> causes pymongo to print its warning that it has detected a forked process.</p>
<p>I'm wondering what the pythonic way of doing this is. It seems that perhaps <code>os.system</code> will do it for me but <code>subprocess</code> is described as an intended replacement for <code>os.system</code> so I wonder whether I'm missing something.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you misunderstand; since PyMongo's documentation warns you that a single MongoClient is not fork-safe, you interpret that to mean that PyMongo prohibits your whole program from ever creating subprocesses.</p>
<p>Any single MongoClient is not fork-safe, meaning you must not create it before forking and use the same MongoClient object after forking. Using PyMongo in your program overall, or using one MongoClient before a fork and a different one after, are all safe.</p>
<p>That's why <code>subprocess.Popen</code> is ok: you fork, then exec (to replace your program with a different one in the child process), and therefore you cannot possibly use the same MongoClient in the child afterward.</p>
<p>To quote the <a href="http://api.mongodb.com/python/current/faq.html#using-pymongo-with-multiprocessing" rel="nofollow noreferrer">PyMongo FAQ</a>:</p>
<blockquote>
<p>On Unix systems the multiprocessing module spawns processes using fork(). Care must be taken when using instances of MongoClient with fork(). Specifically, instances of MongoClient must not be copied from a parent process to a child process. Instead, the parent process and each child process must create their own instances of MongoClient. For example:</p>
</blockquote>
<pre><code># Each process creates its own instance of MongoClient.
def func():
    db = pymongo.MongoClient().mydb
    # Do something with db.

proc = multiprocessing.Process(target=func)
proc.start()
</code></pre>
<blockquote>
<p>Never do this:</p>
</blockquote>
<pre><code>client = pymongo.MongoClient()

# Each child process attempts to copy a global MongoClient
# created in the parent process. Never do this.
def func():
  db = client.mydb
  # Do something with db.

proc = multiprocessing.Process(target=func)
proc.start()
</code></pre>
<blockquote>
<p>Instances of MongoClient copied from the parent process have a high probability of deadlock in the child process due to inherent incompatibilities between fork(), threads, and locks. PyMongo will attempt to issue a warning if there is a chance of this deadlock occurring.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Not fork safe does not mean that you cannot call fork... It just mean that the child process should not use any inherited PyMongo instance. When you use <code>subprocess.Popen</code>, the newly forked child almost immediately calls <code>exec</code> to be replaced by a shell instance (shell = True) or the required executable (shell = False). So it is safe from a PyMongo point of view.</p>
<p>At the opposite when you call multiprocessing.Process, the child is indeed a copy of the parent and does keep its PyMongo instances. So it is unsafe to use PyMongo in that context, and the warning message was correctly issued</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're able to move to Python 3.4 or higher, you could, prior to using <code>pymongo</code>, set your <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer"><code>multiprocessing</code> start method</a> to <code>'forkserver'</code>. That forks a fork server process immediately, and all future use of <code>multiprocessing</code> forks that fork server, not your main process. So once the fork server is set up, your main process can use <code>pymongo</code>, the fork server won't have used it, so it won't have issues reforking.</p>
<p>Sadly, start methods were only added in 3.4, so it's not an option for 2.7, but if someone else has this issue, it may be useful to them.</p>
</div>
<span class="comment-copy">Aha makes sense. I was also curious about any potential side-effects from inheriting file descriptors (particularly socket handles) in the child process, but I guess Popen's close_fds argument addresses that too</span>
<span class="comment-copy">PyMongo creates its sockets with FD_CLOEXEC, so those descriptors are closed whether you pass close_fds or not.</span>
<span class="comment-copy">Yes that's exactly the sort of thing I was hoping for. I see now that pymongo will work after fork/exec, but forking some fresh unrelated process feels like a cleaner way to spawn child processes to me (maybe my windows roots are showing). Unfortunately python 2-&gt;3 feels like it's years away for our codebase :(</span>
