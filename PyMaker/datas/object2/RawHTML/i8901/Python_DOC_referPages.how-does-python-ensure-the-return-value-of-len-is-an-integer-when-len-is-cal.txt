<div class="post-text" itemprop="text">
<pre><code>class foo:
    def __init__(self, data):
        self.data = data
    def __len__(self):
        return self.data
</code></pre>
<p>If I run this by passing a string in for <code>data</code> I get an error when calling <code>len</code> on an instance of this class. Specifically I get <code>'str' object cannot be interpreted as an integer</code>.</p>
<p>So does the <code>return</code> statement in <code>__len__</code> have to be an integer? I would think if I am overriding it, it should be able to output whatever I want, so why is this not possible?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>TL;DR</strong></p>
<p>At the C-level, Python inserts <code>__len__</code> into a special slot that catches the output of the call to <code>__len__</code> and does some validation on it to ensure it is correct.</p>
<hr/>
<p>In order to answer this, we have to go a bit down the rabbit hole of what happens under the hood when <a href="https://docs.python.org/3/library/functions.html#len" rel="nofollow noreferrer"><code>len</code></a> is called in Python.</p>
<p>First, let's establish some behavior.</p>
<pre><code>&gt;&gt;&gt; class foo:
...     def __init__(self, data):
...         self.data = data
...     def __len__(self):
...         return self.data
...
&gt;&gt;&gt; len(foo(-1))
Traceback:
...
ValueError: __len__() should return &gt;= 0
&gt;&gt;&gt; len(foo('5'))
Traceback:
...
TypeError: 'str' object cannot be interpreted as an integer
&gt;&gt;&gt; len(foo(5))
5
</code></pre>
<p>When you call <a href="https://docs.python.org/3/library/functions.html#len" rel="nofollow noreferrer"><code>len</code></a>, the C function <a href="https://github.com/python/cpython/blob/v3.6.0/Python/bltinmodule.c#L1477" rel="nofollow noreferrer"><code>builtin_len</code></a> gets called.  Let's take a look at this.</p>
<pre><code>static PyObject *
builtin_len(PyObject *module, PyObject *obj)
/*[clinic end generated code: output=fa7a270d314dfb6c input=bc55598da9e9c9b5]*/
{
    Py_ssize_t res;

    res = PyObject_Size(obj);  // &lt;=== THIS IS WHAT IS IMPORTANT!!!
    if (res &lt; 0 &amp;&amp; PyErr_Occurred())
        return NULL;
    return PyLong_FromSsize_t(res);
}
</code></pre>
<p>You will notice that the <a href="https://github.com/python/cpython/blob/v3.6.0/Objects/abstract.c#L45" rel="nofollow noreferrer"><code>PyObject_Size</code></a> function is being called - this function will return the size of an arbitrary Python object. Let's move further down the rabbit hole.</p>
<pre><code>Py_ssize_t
PyObject_Size(PyObject *o)
{
    PySequenceMethods *m;

    if (o == NULL) {
        null_error();
        return -1;
    }

    m = o-&gt;ob_type-&gt;tp_as_sequence;
    if (m &amp;&amp; m-&gt;sq_length)
        return m-&gt;sq_length(o);  // &lt;==== THIS IS WHAT IS IMPORTANT!!!

    return PyMapping_Size(o);
}
</code></pre>
<p>It checks if the type defines the <code>sq_length</code> function (sequence length), and if so, calls it to get the length. It appears that at the C level, Python categorizes all objects that define <code>__len__</code> as either sequences or mappings (even if that's not how we would think of them at the Python level); in our case, Python thinks of this class a sequence, so it calls <code>sq_length</code>.</p>
<hr/>
<p>Let's take a quick aside: for builtin types (such as <a href="https://docs.python.org/3/library/functions.html#list" rel="nofollow noreferrer"><code>list</code></a>, <a href="https://docs.python.org/3/library/functions.html#set" rel="nofollow noreferrer"><code>set</code></a>, etc.) Python does not actually call a function to calculate the length, but accesses a value stored in a C struct, making this very fast. Each of these builtin types defines how to access this by assigning an accessor method to <code>sq_length</code>.  Let's take a quick peek at <a href="https://github.com/python/cpython/blob/v3.6.0/Objects/listobject.c#L397" rel="nofollow noreferrer">how this is implemented for lists</a>:</p>
<pre><code>static Py_ssize_t
list_length(PyListObject *a)
{
    return Py_SIZE(a);  // &lt;== THIS IS A MACRO for (PyVarObject*) a-&gt;ob_size;
}

static PySequenceMethods list_as_sequence = {
    ...
    (lenfunc)list_length,                       /* sq_length */
    ...
};
</code></pre>
<p><code>ob_size</code> stores the object's size (i.e. number of elements in the list). So, when <code>sq_length</code> is called, it is sent to the <code>list_length</code> function to get the value of <code>ob_size</code>.</p>
<hr/>
<p>OK, so that's how it is done for a builtin type... how does it work for a custom class like our <code>foo</code>?  Since the "dunder methods" (such as <code>__len__</code>) are special, Python detects them in our classes and treats them specially (specifically, inserting them into special slots).</p>
<p>Most of this is handled in <a href="https://github.com/python/cpython/blob/v3.6.0/Objects/typeobject.c" rel="nofollow noreferrer">typeobject.c</a>. The <code>__len__</code> function is intercepted and assigned to the <code>sq_length</code> slot (just like a builtin!) <a href="https://github.com/python/cpython/blob/v3.6.0/Objects/typeobject.c#L6706" rel="nofollow noreferrer">near the bottom of the file</a>.</p>
<pre><code>SQSLOT("__len__", sq_length, slot_sq_length, wrap_lenfunc,
       "__len__($self, /)\n--\n\nReturn len(self)."),
</code></pre>
<p>The <a href="https://github.com/python/cpython/blob/v3.6.0/Objects/typeobject.c#L5827" rel="nofollow noreferrer"><code>slot_sq_length</code></a> function is where we can <strong>finally</strong> answer your question.</p>
<pre><code>static Py_ssize_t
slot_sq_length(PyObject *self)
{
    PyObject *res = call_method(self, &amp;PyId___len__, NULL);
    Py_ssize_t len;

    if (res == NULL)
        return -1;
    len = PyNumber_AsSsize_t(res, PyExc_OverflowError);  // &lt;=== HERE!!!
    Py_DECREF(res);
    if (len &lt; 0) {  // &lt;== AND HERE!!!
        if (!PyErr_Occurred())
            PyErr_SetString(PyExc_ValueError,
                            "__len__() should return &gt;= 0");
        return -1;
    }
    return len;
}
</code></pre>
<p>Two things of note here:</p>
<ol>
<li>If a negative number is returned, a <code>ValueError</code> is raised with the message <code>"__len__() should return &gt;= 0"</code>. This is <em>exactly</em> the error received when I tried to call <code>len(foo(-1))</code>!</li>
<li>Python tries to coerce the return value of <code>__len__</code> to a <code>Py_ssize_t</code> before returning (<code>Py_ssize_t</code> is a <em>signed</em> version of <code>size_t</code>, which is like a special type of integer that is guaranteed to be able to index things in a container).</li>
</ol>
<p>OK, let's look at the implementation of <a href="https://github.com/python/cpython/blob/v3.6.0/Objects/abstract.c#L1255" rel="nofollow noreferrer"><code>PyNumber_AsSsize_t</code></a>.  It's a bit long so I will omit the non-relevant stuff.</p>
<pre><code>Py_ssize_t
PyNumber_AsSsize_t(PyObject *item, PyObject *err)
{
    Py_ssize_t result;
    PyObject *runerr;
    PyObject *value = PyNumber_Index(item);
    if (value == NULL)
        return -1;    
    /* OMITTED FOR BREVITY */
</code></pre>
<p>The relevant bit here is in <a href="https://github.com/python/cpython/blob/v3.6.0/Objects/abstract.c#L1213" rel="nofollow noreferrer"><code>PyNumber_Index</code></a>, which Python uses to convert arbitrary objects to integers suitable for indexing.  <strong>Here is where the actual answer to your question lies.</strong>  I have annotated a bit.</p>
<pre><code>PyObject *
PyNumber_Index(PyObject *item)
{
    PyObject *result = NULL;
    if (item == NULL) {
        return null_error();
    }

    if (PyLong_Check(item)) {  // IS THE OBJECT ALREADY AN int? IF SO, RETURN IT NOW.
        Py_INCREF(item);
        return item;
    }
    if (!PyIndex_Check(item)) {  // DOES THE OBJECT DEFINE __index__? IF NOT, FAIL.
        PyErr_Format(PyExc_TypeError,
                     "'%.200s' object cannot be interpreted "
                     "as an integer", item-&gt;ob_type-&gt;tp_name);
        return NULL;
    }
    result = item-&gt;ob_type-&gt;tp_as_number-&gt;nb_index(item);
    if (!result || PyLong_CheckExact(result))
        return result;
    if (!PyLong_Check(result)) {  // IF __index__ DOES NOT RETURN AN int, FAIL.
        PyErr_Format(PyExc_TypeError,
                     "__index__ returned non-int (type %.200s)",
                     result-&gt;ob_type-&gt;tp_name);
        Py_DECREF(result);
        return NULL;
    }
    /* Issue #17576: warn if 'result' not of exact type int. */
    if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
            "__index__ returned non-int (type %.200s).  "
            "The ability to return an instance of a strict subclass of int "
            "is deprecated, and may be removed in a future version of Python.",
            result-&gt;ob_type-&gt;tp_name)) {
        Py_DECREF(result);
        return NULL;
    }
    return result;
}
</code></pre>
<p>Based on the error that you received, we can see that <code>'5'</code> does not define <code>__index__</code>.  We can verify that for ourselves:</p>
<pre><code>&gt;&gt;&gt; '5'.__index__()
Traceback:
...
AttributeError: 'str' object has no attribute '__index__'
</code></pre>
</div>
<span class="comment-copy">You can return whatever you want from <code>__len__</code>, but that doesn't mean <code>len</code> is going to accept it. <code>len</code> isn't just <code>def len(x): return x.__len__()</code>.</span>
<span class="comment-copy">Would it make sense to have length be a string would it? Length is a integer quantity...</span>
<span class="comment-copy">As per <a href="https://docs.python.org/3/reference/datamodel.html#object.__len__" rel="nofollow noreferrer">the docs</a>, the function <b>should</b> return an integer &gt;= 0. This means that if you don't do that, things are not guaranteed to work.</span>
<span class="comment-copy">@Archimaredes I see, thanks for pointing me here!</span>
<span class="comment-copy">Thanks for the thorough response. Cool to see all the stuff going on behind the scenes to make python work.</span>
