<div class="post-text" itemprop="text">
<p>In Python, how can one print a number that might be an integer or real type, when the latter case would require me to limit my printout to a certain amount of digits?</p>
<p>Long story short, say we have the following example: </p>
<pre><code>print("{0:.3f}".format(num)) # I cannot do print("{}".format(num))
                             # because I don't want all the decimals
</code></pre>
<p>Is there a "Pythy" way to ensure e.g. in case <code>num == 1</code> that I print <code>1</code> instead of <code>1.000</code> (I mean other than cluttering my code with <code>if</code> statements)</p>
</div>
<div class="post-text" itemprop="text">
<p>With Python 3*, you can just use <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer"><code>round()</code></a> because in addition to rounding <code>float</code>s, when applied to an integer it will always return an <code>int</code>:</p>
<pre><code>&gt;&gt;&gt; num = 1.2345
&gt;&gt;&gt; round(num,3)
1.234
&gt;&gt;&gt; num = 1
&gt;&gt;&gt; round(num,3)
1
</code></pre>
<p>This behavior is documented in <code>help(float.__round__)</code>:</p>
<pre><code>Help on method_descriptor:

__round__(...)
    Return the Integral closest to x, rounding half toward even.
    When an argument is passed, work like built-in round(x, ndigits).
</code></pre>
<p>And <code>help(int.__round__)</code>:</p>
<pre><code>Help on method_descriptor:

__round__(...)
    Rounding an Integral returns itself.
    Rounding with an ndigits argument also returns an integer.
</code></pre>
<p>* With Python 2, <code>round()</code> always <code>return</code>s a <code>float</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need to maintain a fixed-width for float values, you could use the <a href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting" rel="nofollow noreferrer">printf-style formatting</a>, like this:</p>
<pre><code>&gt;&gt;&gt; num = 1
&gt;&gt;&gt; print('%0.*f' % (isinstance(num, float) * 3, num))
1
&gt;&gt;&gt; num = 1.2345
&gt;&gt;&gt; print('%0.*f' % (isinstance(num, float) * 3, num))
1.234
&gt;&gt;&gt; num = 1.2
&gt;&gt;&gt; print('%0.*f' % (isinstance(num, float) * 3, num))
1.200
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you use a fix number of floating point, you could just use a replace to remove the extra <code>0</code>. For instance this would do the trick:</p>
<pre><code>print("{:.3f}".format(1).replace(".000", ""))
</code></pre>
</div>
<span class="comment-copy">Part of the problem is that <code>int</code> treats <code>.3</code> the same way as <code>float</code> does, instead of say, ignoring it completely.</span>
<span class="comment-copy">My guess would be no, you would need to at least do a ternary operator somewhere along the way, and I am pretty sure you count that as an <code>if</code>.</span>
<span class="comment-copy">I never knew <code>round</code> was so versatile. It would never have occurred to me to use it on an <code>int</code>.</span>
<span class="comment-copy">Not sure if it matters, but this won't give the same output as the format spec in the question with shorter float values (i.e. <code>1.2</code> vs <code>1.200</code>).</span>
<span class="comment-copy">@ekhumoro Yes, I agree it's not quite clear what the desired behavior is there, I up-voted your solution</span>
<span class="comment-copy">@MarkRansom Thanks, yes in fact when ndigits is a negative integer, <code>round()</code> on integers can be quite useful, for example <code>round(210,-2)</code> <code>return</code>s <code>200</code></span>
<span class="comment-copy">Works great unless the requirement is to display <code>1.0</code> as <code>1.000</code>.</span>
