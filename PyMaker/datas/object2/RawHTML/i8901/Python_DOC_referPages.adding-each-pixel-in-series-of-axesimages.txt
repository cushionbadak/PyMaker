<div class="post-text" itemprop="text">
<p>I am currently attempting to create a color plot of a given data series of images, using python. After using a software called Powderday, I have in storage (in the file entitled "merger.070.new.rtout.image" which I have called in line 18 of my code) a series of approximately 35 images that each contain flux information at a specific wavelength of a certain galaxy merger. I want to loop through each of those images and create a final image that is essentially each of those images added up, so that instead of several single-wavelength images I have a series of wavelengths in one image.</p>
<p>To do this I want to loop through each image, save the wavelength map in a final image, and keep adding subsequent images to this final one. The only issue is that I am getting an AxesImage each time I find the single-wavelength images, which as far as I know does not have a function to just merge with another image. I have found so far online that the best solution to this is to create a numpy array from the image, but I also couldn't find if the get_image function from matplotlib.image would accept an AxesImage parameter in order to turn it into such an array. My code is below. </p>
<p>The important lines are at: 42 - 45 where I am trying to initialize finalImg so that I can "iterate" it within the loop; 47 - 61 where I am iterating through each image.</p>
<p>Also as a side note: the B_Johnson and B_thruput files that I am reading in contain information about which wavelengths I have in my .image file, as well as the corresponding throughputs. This is because I want to multiply the flux that I find at each wavelength by its throughput in order to correctly simulate an actual real-world filter.</p>
<p>Hope this information provides a good background for the issue! I am still very new to python. What is the best way to add up all these images?</p>
<pre><code>import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from hyperion.model import ModelOutput
from astropy.cosmology import Planck13
import astropy.units as u


# ------------------------
# modifiable header
# ------------------------

filters = np.loadtxt('B_Johnson.txt')
thru = np.loadtxt('B_thruput.txt', dtype='double')
</code></pre>
<h1>line 18 below:</h1>
<pre><code>m = ModelOutput('/home/sss274/Work/Outputs/diskMerger/70/merger.070new.rtout.image')
redshift=2
image_width = 200 #kpc

# ------------------------


distance = Planck13.luminosity_distance(redshift).cgs.value


# Extract the image for the first inclination, and scale to 300pc. We
# have to specify group=1 as there is no image in group 0.
image = m.get_image(distance=distance, units='mJy')

# Open figure and create axes
fig = plt.figure()

ax = fig.add_subplot(111)

#calculate image width in kpc
w = image.x_max * u.cm
w = w.to(u.kpc)
</code></pre>
<h1>line 42 below:</h1>
<pre><code>cax = ax.imshow(image.val[0,:,:,(np.argmin(np.abs(3600 - image.wav)))]*0,
                cmap = plt.cm.spectral, origin='lower', extent=[-w.value, w.value, -w.value, w.value])

finalImg = mpimg.imread(cax)
</code></pre>
<h1>lines 47 - 61 in the loop:</h1>
<pre><code>for idx, fil in enumerate(filters):
    wav = fil

    #find nearest wavelength
    iwav = np.argmin(np.abs(wav - image.wav))

    #find the throughput to multiply found flux by throughput
    throughput = thru[idx]

    #plot the beast

    cax = ax.imshow((image.val[0,:, :, iwav])*throughput,
                    cmap = plt.cm.spectral, origin='lower', extent=[-w.value, w.value, -w.value, w.value])

    finalImg += mpimg.imread(cax)

    plt.xlim([-image_width,image_width])
    plt.ylim([-image_width,image_width])


# Finalize the plot
ax.tick_params(axis='both', which='major', labelsize=10)
ax.set_xlabel('x kpc')
ax.set_ylabel('y kpc')

plt.colorbar(cax,label='Flux (mJy)',format='%.0e')

fig.savefig('pd_image_bj.png', bbox_inches='tight',dpi=150)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, you cannot load a Matplotlib AxesImage into a NumPy array. </p>
<p>I am not in your field, but based on the <a href="http://docs.hyperion-rt.org/en/stable/api/hyperion.model.ModelOutput.html?highlight=ModelOutput#hyperion.model.ModelOutput.get_image" rel="nofollow noreferrer">Hyperion documentation</a> for <code>ModelOutput.get_image()</code> I believe <code>get_image()</code> returns image data as a NumPy array in the following line from your code: </p>
<pre><code>image = m.get_image(distance=distance, units='mJy')
</code></pre>
<p>Look at <code>type(image)</code> to verify this. You should see <code>numpy.ndarray</code> if I am correct.</p>
<p>If this is the case, then <code>finalImg = mpimg.imread(cax)</code> is superfluous...you already have your images loaded as a NumPy array in the <code>image</code> variable.</p>
<p>Now if you want your data loaded as separate channels in a single ndarray object then you are done at <code>get_image()</code>. Printing <code>image.ndim</code> should show <code>3</code> (you have a three dimensional image array) with <code>img.shape</code> of <code>(y_axis_length, x_axis_length, number_of_channels)</code>.</p>
<p>Based on how you phrased your question though I think you want to combine these channels into a single intensity value for each pixel by taking the sum of the intensities in each channel. This operation would yield a two-dimensional grayscale image of shape <code>(y_axis_length, x_axis_length)</code>. To see what I mean, please consider the following example I have drawn up for you:</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
from matplotlib.cbook import get_sample_data

# load example image file
image_file = get_sample_data("grace_hopper.png", asfileobj=True)

# read example image file to NumPy array
image_array = plt.imread(image_file)

# show `image_array` as color (RGB) image
fig = plt.figure()
plt.imshow(image_array)
plt.tight_layout()
plt.axis('off') # turns off x and y-axis ticks
plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/NdSC0.png" rel="nofollow noreferrer"><img alt="fig" src="https://i.stack.imgur.com/NdSC0.png"/></a></p>
<pre><code># since the image is color (RGB), slice into individual channels
# to illustrate adding image arrays
c1 = image_array[:, :, 0]
c2 = image_array[:, :, 1]
c3 = image_array[:, :, 2]

# define empty array with same shape as one image slice
# this will become the final image result
new_array = np.zeros_like(c1)

# visualize empty array
fig0 = plt.figure()
plt.imshow(new_array, cmap='gray')
plt.tight_layout()
plt.axis('off')
plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/NdSC0.png" rel="nofollow noreferrer"><img alt="fig0" src="https://i.stack.imgur.com/5dmTY.png"/></a></p>
<pre><code># visualize distinct image slices (RGB image has three color channels)
# one at a time to illustrate differences between images
fig1, ax = plt.subplots(nrows=1, ncols=3)
for img, a in zip([c1, c2, c3], ax):
    a.imshow(img, cmap='gray')
    a.axis('off')

    # iteratively add image slices to `new_array`
    # while we are iterating over the slices
    new_array += img

plt.tight_layout()
plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/5dmTY.png" rel="nofollow noreferrer"><img alt="fig1" src="https://i.stack.imgur.com/I8Riz.png"/></a></p>
<pre><code># visualize end result of iteratively adding image slices to `new_array`
fig2 = plt.figure()
plt.imshow(new_array, cmap='gray')
plt.axis('off')
plt.tight_layout()
plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/I8Riz.png" rel="nofollow noreferrer"><img alt="fig2" src="https://i.stack.imgur.com/8NqEd.png"/></a></p>
</div>
<span class="comment-copy">Thank you! Would there be a way to create an empty array without it holding any color information? Or would I just initialize it with my first image outside the for loop, and add to it within the loop?</span>
<span class="comment-copy">Never mind! I could use np.empty_like, just found it.</span>
<span class="comment-copy">No problem! Yep, np.empty_like will initialize an empty array for you. I used np.zeros_like in this example which returns an array filled with zeros.</span>
<span class="comment-copy">I just checked, and my image object is actually a Hyperion.model.image.Image object. I will try finding a way to convert this to a numpy array.</span>
<span class="comment-copy">So this line <code>image = m.get_image(distance=distance, units='mJy')</code> returns a Hyperion.model.image.Image object? Looking back at the documentation for <code>get_image()</code>, it looks like it should actually return three numpy arrays. I don't understand the terminology for the outputs, but your Hyperion.model.image.Image object might have that data stored in one of its <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">attributes</a>. Does printing <code>type(image.wav)</code> give you a NumPy array?</span>
