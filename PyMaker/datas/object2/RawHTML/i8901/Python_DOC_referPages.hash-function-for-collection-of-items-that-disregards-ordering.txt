<div class="post-text" itemprop="text">
<p>I am using a the <a href="https://docs.python.org/2/library/functions.html#hash" rel="nofollow noreferrer"><code>hash()</code></a> function to get the hash value of my object which contains two integers and two Strings. Moreover, I have a dictionary where I store these objects; the process is that I check if the object exists with the hash value, if yes I update if not I insert the new one. </p>
<p>The thing is that when creating the objects, I do not know the order of the object variables and I want to treat the objects as same no matter the order of these variables.</p>
<p>Is there an alternative function to the <code>hash()</code> function that does not consider the order of the variables?</p>
<pre><code>#Consequently what I want is:
hash((int1,str1,int2,str2)) == hash((int2,str2,int1,str1)) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow noreferrer"><code>frozenset</code></a> instead of a tuple:</p>
<pre><code>&gt;&gt;&gt; hash(frozenset([1, 2, 'a', 'b']))
1190978740469805404
&gt;&gt;&gt;
&gt;&gt;&gt; hash(frozenset([1, 'a', 2, 'b']))
1190978740469805404
&gt;&gt;&gt;
&gt;&gt;&gt; hash(frozenset(['a', 2, 'b', 1]))
1190978740469805404
</code></pre>
<p>However, the removal of duplicates from the iterable presents a subtle problem:</p>
<pre><code>&gt;&gt;&gt; hash(frozenset([1,2,1])) == hash(frozenset([1,2,2]))
True
</code></pre>
<hr/>
<p>You can fix this by creating a counter from the iterable using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>, and calling <code>frozenset</code> on the counter's items, thus preserving the count of each item from the original iterable:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt;
&gt;&gt;&gt; hash(frozenset(Counter([1,2,1]).items())) 
-307001354391131208
&gt;&gt;&gt; hash(frozenset(Counter([1,1,2]).items()))
-307001354391131208
&gt;&gt;&gt; 
&gt;&gt;&gt; hash(frozenset(Counter([1,2,1]).items())) == hash(frozenset(Counter([1,2,2]).items()))
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Usually for things like this it helps immeasurably if you post some sample code, but I'll assume you've got something like this:</p>
<pre><code>class Foo():
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __hash__(self):
        return hash((self.x, self.y))
</code></pre>
<p>You're taking a hash of a tuple there, which does care about order. If you want your hash to not care about the order of the ints, then just use a <a href="https://docs.python.org/2/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">frozenset</a>:</p>
<pre><code>    def __hash__(self):
        return hash(frozenset([self.x, self.y]))
</code></pre>
</div>
<span class="comment-copy">Would you post a small section of your code to make clearer what you are doing? My first thought is to sort the two integers, but I cannot tell whether this would work in your implementation.</span>
<span class="comment-copy">You can always sort the input: <code>hash(tuple(sorted((1, 2))))</code>.</span>
<span class="comment-copy">@TomLynch I showed a toy example, in my code I have also strings so it is difficult to sort.</span>
<span class="comment-copy">Maybe you should modify the question because now it strongly suggest you expect to have there only integers.</span>
<span class="comment-copy">@Eleshar just updated.</span>
<span class="comment-copy">it works because there's the same number of elements in each set, so even if there are duplicates it doesn't matter.</span>
<span class="comment-copy">@Jean-FrançoisFabre Thanks for the observation. It revealed a bug :)</span>
<span class="comment-copy">Not a bug for the OP problem though.</span>
<span class="comment-copy"><code>FrozenMultiset()</code> would also solve this duplicates issue <a href="https://pypi.python.org/pypi/multiset" rel="nofollow noreferrer">pypi.python.org/pypi/multiset</a></span>
<span class="comment-copy">@Chris_Rands Good one! A <code>collections.Counter</code> object is a multiset. I guess their implementation of the <code>FrozenMultiset</code> has some sort of counter underneath. I think you can make the link and some snippet into an answer.</span>
<span class="comment-copy">but sets are not hashable...</span>
<span class="comment-copy">@Jean-FrançoisFabre Whoops! I meant frozen sets.</span>
<span class="comment-copy">Considering the comments about also including strings, I think this is the right answer! Define a class, and use that to specify whatever hash method you want.</span>
<span class="comment-copy">@ymbirtt Just upvoted thank you for the effort as well. Apologies for the confusion of not using Strings.</span>
