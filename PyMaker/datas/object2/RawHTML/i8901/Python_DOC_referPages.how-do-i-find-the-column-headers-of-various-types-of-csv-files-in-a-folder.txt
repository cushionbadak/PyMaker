<div class="post-text" itemprop="text">
<p>I have an issue where I need to intake different files, with different column locations.  One files column might start 4 rows down, whereas another files columns might start on row one.</p>
<p>One file might look like this:</p>
<pre class="lang-none prettyprint-override"><code>This
is
a
column 1, column 2, column 3, column 4
</code></pre>
<p>Another might have columns like this on row 1:</p>
<pre class="lang-none prettyprint-override"><code>column 1, column 2, column 3
</code></pre>
<p>I need to get a list of every files column headers.  I consider a column header a list greater than 3 items.  If I'm using the csv module how can I write this?</p>
<p>I have something like:</p>
<pre><code>temprow = next(csvfile)

for value in temprow:
    if value == '':
        temprow = next(csvfile)
    if len(value) &gt; 3:
        header = temprow
    else:
        header = temprow
</code></pre>
<p>This is not quite working as it is also returning columns that contain 1 string.  </p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>with open('yourfile.csv', 'r') as f:
    for line in f:                        # iterate for each line
        if "," in line:                   # the header line should contain comma     
            header = line          
            break                         # break the loop when header line is found

print(header)
</code></pre>
<p>Output:</p>
<pre><code>column 1, column 2, column 3, column 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to the specifications in your post, this code works. It returns the first row in a .csv file that has 4 or more elements ('greater than 3 items').</p>
<pre><code>headers = []                                        # Column names will be appended to this list
files = ['./test']                                  # Insert files here

for f in files:                                     # Loop over files
    with open(f, 'r') as fh:                        # Open file
        reader = csv.reader(fh, delimiter = ',')    # Create reader
        for row in reader:                          # Loop over rows
            if len(row) &gt;= 4:                       # Criteria for appending to headers
                headers.append(row)
</code></pre>
</div>
<span class="comment-copy">Your <code>if</code> and <code>else</code> statements execute the same code.</span>
<span class="comment-copy">You're not opening the csv files properly for either Python 2 or 3. Check out the examples in the documentation.</span>
<span class="comment-copy">You probably also need a <code>break</code> after the <code>headers.append(row)</code> statement. In addition, since this isn't in a function, the <code>return headers</code> at the end is an error.</span>
<span class="comment-copy">@Martineau The <code>break</code> isn't needed as long as only one line fulfills the criteria for being a headers line, but could be added. The code will achieve the same result under basic assumptions about the types of file OP is working with. In terms of the <code>csv</code> module, I fail to see how this is incorrect. See the first example under <a href="https://docs.python.org/2/library/csv.html#module-contents" rel="nofollow noreferrer">this link</a>. The only immediate thing I notice is the <code>quotechar</code> optional argument. I've edited the <code>return</code> part to print instead, but trust OP knows how to handle this part.</span>
<span class="comment-copy">It's extremely likely that <i>all</i> the lines following the header row will meet the criteriaâ€”think about it. As for opening the file, the Python 2 documentation you linked to show the file being opened for reading in binary mode, <code>'rb'</code>, which is not what's in your answer. In Python 3, the <a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow noreferrer">documentation</a> show the file being opened for reading with the <code>newline=''</code> keyword argument which is need because in that version of Python strings are Unicode by default...continued</span>
<span class="comment-copy">...For generality, hardcoding a length of 4 is also likely not going to work unless all the files have at least that many columns.</span>
