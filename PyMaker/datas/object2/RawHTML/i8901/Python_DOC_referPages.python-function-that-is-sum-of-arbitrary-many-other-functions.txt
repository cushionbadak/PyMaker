<div class="post-text" itemprop="text">
<p>Hej! I'm trying to write a function in Python for a polynomial <em>p</em> that is a linear combination of <em>n</em> basis functions <em>phi_i</em>. How can I define a function that is itself a sum of <em>n</em> other functions?</p>
<p>I know that this works:</p>
<pre><code>phi1 = lambda x: x**2
phi2 = lambda x: x
p = lambda x: phi1(x) + phi2(x)
</code></pre>
<p>But if I try a loop like this:</p>
<pre><code>p = lambda x: 0
for i in range(0,n):
    p = lambda x: p(x)+phi[i](x)
</code></pre>
<p>where <code>phi</code> is a list of my basis functions, I create an infinite loop.</p>
<hr/>
<p>I checked <a href="https://stackoverflow.com/questions/26935061/writing-a-function-that-is-sum-of-functions">Writing a function that is sum of functions</a>, but unfortunately that's not in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this by passing a simple generator expression to <code>sum</code>:</p>
<pre><code>def sigma(funcs, x):
    return sum(f(x) for f in funcs)

phi = [lambda x: x**2, lambda x: x]
y = sigma(phi, x)
</code></pre>
<p>BTW, it's considered bad style to use <code>lambda</code> for named functions, it's supposed to be for anonymous functions. </p>
<hr/>
<p>If you want a function that doesn't need <code>phi</code> to be passed in each time you call it, there are a couple of ways to do that. The easiest way is to simply use <code>phi</code> in the function. Eg,</p>
<pre><code>def sigma(x):
    return sum(f(x) for f in phi)
</code></pre>
<p>However, that has a couple of downsides. It won't work if <code>phi</code> isn't in the scope where you call <code>sigma</code>; you can get around that by making <code>phi</code> global, but that may not be convenient, and it's best to avoid globals when they aren't necessary. The other downside is that it uses the current contents of <code>phi</code>, not the contents it had when <code>sigma</code> was defined, so if you modify the contents of <code>phi</code> those changes will be reflected in <code>sigma</code>, which may or may not be desirable.</p>
<p>Another option is to use a <a href="https://stackoverflow.com/q/13857/4014959">closure</a> to create the function. Then we won't be affected by the scope issue: you can call the resulting summing function inside a scope where the original function list isn't visible. We can also create a copy of the function list, so it won't be affected by changes to the passed-in function list.</p>
<pre><code>def make_adder(funcs):
    # Copy the function list 
    funcs = funcs[:]
    def sigma(x):
        return sum(f(x) for f in funcs)
    return sigma

phi = [lambda x: x**2, lambda x: x]
sigma = make_adder(phi)
y = sigma(x)
</code></pre>
<hr/>
<p>Yet another option is to use my original <code>sigma</code> and pass it and the <code>phi</code> functions to <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a>, eg</p>
<pre><code>from functools import partial
sig = partial(sigma, phi)
y = sig(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Straight answer to OP</h2>
<p>Store your phis in a <code>list</code>:</p>
<pre><code>phis = [
    lambda x: x**2,
    lambda x: x,
]
p = lambda x: sum(phi(x) for phi in phis)
</code></pre>
<h2>Further considerations</h2>
<p>If you want to achieve a polynomial, I would suggest something similar to this:</p>
<pre><code>def poly(c):
    return lambda x: sum(f(x) for f in [lambda x, i=i: c[i]*x**i for i in range(len(c))])
</code></pre>
<p><code>poly</code> function accepts a sequence as the only argument, where its elements need to be <code>int</code> or <code>float</code>. The first element is assigned as the coeficient of x^0, the second to x^1 and so on. So your example (p(x) = x + x^2) would end up being constructed like this: <code>p = poly([0, 1, 1])</code></p>
<p>Another option is to accept any number of arguments where each of them needs to be a <code>int</code> or <code>float</code> instead of the first being a sequence. This would only require to add one <code>*</code> to the function declaration.</p>
<pre><code>def poly(*c):
    return lambda x: sum(f(x) for f in [lambda x, i=i: c[i]*x**i for i in range(len(c))])
</code></pre>
<p>To construct your example with this function you would not require the list: <code>p = poly(0, 1, 1)</code>.</p>
<p>Any of those methods would create a polynomic function that can be called as you would expect: <code>p(1)</code> would return <code>2</code>, <code>p(2)</code> would return <code>6</code> and so on.</p>
<h2>Function explained</h2>
<pre><code>def poly(c):
    # Create a list where we are gonna store the functions for every term in the polynomial
    terms = []
    # Create as many terms as the arguments length
    for i in range(len(c)):
        # Each term is the product of the nth coefficient from c and x to the power of n
        terms.append(lambda x, n=i: c[n]*x**n)
        # The second parameter n is needed because if we pass i directly
        # inside the function algorithm, Python wouldn't check its value
        # inmediately, but when it gets executed, and by then the loop will
        # be finished and i would be constant for every term. This argument
        # is not exposed to the polynomial function as the next lambda only
        # has one argument, so there is no way to wrongly call this function
    # We return a function that adds the result of every term
    return lambda x: sum(f(x) for f in terms)
</code></pre>
</div>
<span class="comment-copy">Check my answer if you want a generic polynomial construction function passing the coeficients for each part, it accepts a sequence of any kinf of number, either integers or floats.</span>
<span class="comment-copy">Using a generator is not needed and may be confusing for newcomers</span>
<span class="comment-copy">@Adirio Huh? So why did you use a generator expression in your answer?</span>
<span class="comment-copy">Fail comment, what I wanted to say is that a factory function is not needed, what you call sigma. It is not either a factory function as it is not returning the lambda, but you get the point. The correct comment should have been that sigma has not the same interface that the lambda he was using.</span>
<span class="comment-copy">@JonathanvonSchroeder That would also imply removing the x argument from <code>sigma</code> function, and turning sigma into a factory function. It would be called <code>p = sigma(phi); y = p(5)</code></span>
<span class="comment-copy">I agree with you, as the returned lambda would have the same interface the OP asked for. But I still not see the benefits of using a factory function unless it needs to be called many times. Factory functions avoid code duplication but if this is not the case they only add an extra layer of abstraction that only makes the code slighlty less efficient and harder to understand.</span>
<span class="comment-copy">The <code>i=i</code> inside the inner lambda is necessary</span>
