<div class="post-text" itemprop="text">
<p>As per my understanding Python user defined class instances are by default immutable. Immutable objects does not change their hash value and they can be used as dictionary keys and set elements.</p>
<p>I have below code snippet.</p>
<pre><code>class Person(object):
    def __init__(self, name, age):
        self.name=name
        self.age=age
</code></pre>
<p>Now, I will instantiate Person class and create an object and print its hash value.</p>
<pre><code>jane = Person('Jane', 29)
print(jane.__hash__())
-9223371933914849101
</code></pre>
<p>Now, I will mutate jane object and print its hash value.</p>
<pre><code>jane.age = 33
print(jane.__hash__())
-9223371933914849101
</code></pre>
<p>My question is even if jane object is mutable why its hash value is not changing? </p>
<p>Also, I can use mutable jane object as dict key and set element.</p>
</div>
<div class="post-text" itemprop="text">
<p>To define a class with immutable instances, you can do something like this:</p>
<pre><code>class Person:
    """Immutable person class"""

    # Using __slots__ reduces memory usage.
    # If __slots__ doesn't include __dict__, new attributes cannot be added.
    # This is not always desirable, e.g. it you want to subclass Person.
    __slots__ = ('name', 'age')

    def __init__(self, name, age):
        """Create a Person instance.

        Arguments:
            name (str): Name of the person.
            age: Age of the person.
        """
        # Parameter validation. This shows how to do this,
        # but you don't always want to be this inflexibe.
        if not isinstance(name, str):
            raise ValueError("'name' must be a string")
        # Use super to set around __setattr__ definition
        super(Person, self).__setattr__('name', name)
        super(Person, self).__setattr__('age', int(age))

    def __setattr__(self, name, value):
        """Prevent modification of attributes."""
        raise AttributeError('Persons cannot be modified')

    def __repr__(self):
        """Create a string representation of the Person.
        You should always have at least __repr__ or __str__
        for interactive use.
        """
        template = "&lt;Person(name='{}', age={})&gt;"
        return template.format(self.name, self.age)
</code></pre>
<p>A test:</p>
<pre><code>In [2]: test = Person('S. Eggs', '42')

In [3]: str(test)
Out[3]: "&lt;Person(name='S. Eggs', age=42)&gt;"

In [4]: test.name
Out[4]: 'S. Eggs'

In [5]: test.age
Out[5]: 42

In [6]: test.name = 'foo'
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-6-1d0482a5f50c&gt; in &lt;module&gt;()
----&gt; 1 test.name = 'foo'

&lt;ipython-input-1-efe979350b7b&gt; in __setattr__(self, name, value)
     24     def __setattr__(self, name, value):
     25         """Prevent modification of attributes."""
---&gt; 26         raise AttributeError('Persons cannot be modified')
     27 
     28     def __repr__(self):

AttributeError: Persons cannot be modified
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The object remains the same, even if you are changing properties of the object.
And no, there are only very few immutable objects in python - frozenset for instance. But classes are not immutable.</p>
<p>If you want immutable objects, you have to make them so. E.g. forbid assigning new values to properties are turning new objects in that case.</p>
<p>To achieve this, you can use the underscore convention: Prepend your fields with a "_" - this indicates to other developers that the value is private and should not be changed from the outside.</p>
<p>If you want a class with an unchangeable "name" field you could use this syntax:</p>
<pre><code>class test(object):
    def __init__(name):
       self._name = name

     @property
     def name(self):
        return self._name
</code></pre>
<p>Of course, _name CAN be changed by an dev, but that breaks the visible contract.</p>
</div>
<div class="post-text" itemprop="text">
<p>That is not the contract Python goes by  From <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">the docs</a>- emphasis added by me on the bolded parts:</p>
<blockquote>
<p><code>object.__hash__(self)</code> Called by built-in function <code>hash()</code> and for
  operations on members of hashed collections including <code>set</code>, <code>frozenset</code>,
  and <code>dict. __hash__()</code> should return an integer. <strong>The only required
  property is that objects which compare equal have the same hash value;</strong>
  it is advised to mix together the hash values of the components of the
  object that also play a part in comparison of objects by packing them
  into a tuple and hashing the tuple. Example:</p>
<pre><code>def __hash__(self):
    return hash((self.name, self.nick, self.color)) Note hash() truncates
</code></pre>
</blockquote>
<p>And some more relevant information:</p>
<blockquote>
<p>If a class does not define an <code>__eq__()</code> method it should not define a <code>__hash__()</code> operation
  either; if it defines <code>__eq__()</code> but not <code>__hash__()</code>, its instances will
  not be usable as items in hashable collections. If a class defines
  mutable objects and implements an <code>__eq__()</code> method, it should not
  implement <code>__hash__()</code>, since the implementation of hashable collections
  requires that a key’s hash value is immutable (if the object’s hash
  value changes, it will be in the wrong hash bucket).</p>
</blockquote>
<p>And, to the core of your question:</p>
<blockquote>
<p>User-defined classes have <code>__eq__()</code> and <code>__hash__()</code> methods by default;
  with them, all objects compare unequal (except with themselves) and
  <code>x.__hash__()</code> returns an appropriate value such that <code>x == y</code> implies
  both that x is y and <code>hash(x) == hash(y)</code>.</p>
<p>A class that overrides <code>__eq__()</code> and does not define <code>__hash__()</code> will
  have its <code>__hash__()</code> implicitly set to <code>None</code>. When the <code>__hash__()</code> method
  of a class is <code>None</code>, instances of the class will raise an appropriate
  <code>TypeError</code> when a program attempts to retrieve their hash value, and
  will also be correctly identified as unhashable when checking
  <code>isinstance(obj, collections.Hashable)</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I will fill in the knowledge gaps in Christian's answer. From Python's official website (<a href="https://docs.python.org/2/reference/datamodel.html" rel="nofollow noreferrer">https://docs.python.org/2/reference/datamodel.html</a>):</p>
<blockquote>
<p>The value of an immutable container object that contains a reference
  to a mutable object can change when the latter’s value is changed;
  however the container is still considered immutable, because the
  collection of objects it contains cannot be changed. So, immutability
  is not strictly the same as having an unchangeable value, it is more
  subtle.</p>
</blockquote>
<p>When I look at an object <code>A</code> whose byte data never change, that is truly immutable. The byte data may contains pointer to other mutable objects, but that doesn't mean the object <code>A</code> is mutable. </p>
<p>In your case, the object resides at a memory location. Python's hash generation is opaque. But if you are looking at things using the same reference, most likely the hash won't change, even when the bytes stored are different.</p>
<p>In a strict sense, mutable objects aren't even hashable, so you shouldn't try to interpret the hash in the first place.</p>
<p>To your question, just use a <code>collections.namedtuple</code> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason is that to make this object hashable, despite the fact that it IS mutable, Python's default __hash__() method calculate the hash value from it's reference ID. </p>
<p>This means that if you change it's content or copy the reference to another name, the hash value won't change, But if you copy it to another place or create another object with the same content, then it's value will be different.</p>
<p>You can change that behaviour by redefining the __hash__() method, but you need to ensure that the object is  not mutable or you will break your « named collections » (dictionnaries, sets &amp; their subclasses).</p>
</div>
<span class="comment-copy">"As per my understanding Python user defined class instances are by default immutable" - on the contrary, instances of user-defined classes are mutable by default, and trying to make them immutable is quite a mess.</span>
<span class="comment-copy">@user2357112 one can monkey-patch a class, so I am quite sure class instances are mutable. See <a href="http://stackoverflow.com/questions/5626193/what-is-a-monkey-patch" title="what is a monkey patch">stackoverflow.com/questions/5626193/what-is-a-monkey-patch</a></span>
<span class="comment-copy">@Mai: You can monkey-patch classes, sure, but whether that counts as mutating their instances is up for debate. In any case, you can get mostly-un-monkey-patchable classes by writing them with Cython or using the C API directly, and you can get mostly-immutable instances even without bringing C into the picture by inheriting from a built-in class with immutable instances and setting <code>__slots__ = ()</code> to disable instance <code>__dict__</code> creation.</span>
