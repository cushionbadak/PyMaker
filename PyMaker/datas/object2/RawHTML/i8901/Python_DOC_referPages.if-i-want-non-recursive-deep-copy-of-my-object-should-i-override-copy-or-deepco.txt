<div class="post-text" itemprop="text">
<p>An object of my class has a list as its attribute. That is,</p>
<pre><code>class T(object):
    def __init__(self, x, y):
        self.arr = [x, y]
</code></pre>
<p>When this object is copied, I want a separate list <code>arr</code>, but a shallow copy of the content of the list (e.g. <code>x</code> and <code>y</code>). Therefore I decide to implement my own copy method, which will recreate the list but not the items in it. But should I call this <code>__copy__()</code> or <code>__deepcopy__()</code>? Which one is the right name for what I do, according to Python semantics?</p>
<p>My guess is <code>__copy__()</code>. If I call <code>deepcopy()</code>, I would expect the clone to be totally decoupled from the original. However, the <a href="https://docs.python.org/3/library/copy.html" rel="noreferrer">documentation</a> says:</p>
<blockquote>
<p>A <em>deep copy</em> constructs a new compound object and then, recursively,
  inserts <em>copies</em> into it of the objects found in the original.</p>
</blockquote>
<p>It is confusing by saying "inserts <em>copies</em> into it" instead of "inserts <em>deep copies</em> into it", especially with the emphasis.</p>
</div>
<div class="post-text" itemprop="text">
<p>The correct magic method for you to implement here is <code>__copy__</code>.  </p>
<p>The behaviour you've described is deeper than what the default behaviour of copy would do (i.e. for an object which hasn't bothered to implement <code>__copy__</code>), but it is not deep enough to be called a deepcopy.  Therefore you should implement <code>__copy__</code> to get the desired behaviour.  </p>
<p>Do not  make the mistake of thinking that simply assigning another name makes a "copy":</p>
<pre><code>t1 = T('google.com', 123)
t2 = t1  # this does *not* use __copy__
</code></pre>
<p>That just binds another name to the same instance.  Rather, the <code>__copy__</code> method is hooked into by a function:</p>
<pre><code>import copy
t2 = copy.copy(t1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It actually depends on the desired behaviour of your class that factor into the decision what to override (<code>__copy__</code> or <code>__deepcopy__</code>). </p>
<p>In general <code>copy.deepcopy</code> works mostly correctly, it just copies everything (recursivly) so you only need to override it if there is some attribute that <strong>must not</strong> be copied (ever!).</p>
<p>On the other hand one should define <code>__copy__</code> only if users (including yourself) wouldn't expect changes to propagate to copied instances. For example if you simply wrap a mutable type (like <code>list</code>) or use mutable types as implementation detail.</p>
<p>Then there is also the case that the minimal set of attributes to copy isn't clearly defined. In that case I would also override <code>__copy__</code> but maybe raise a <code>TypeError</code> in there and possible include one (or several) dedicated public <code>copy</code> methods.</p>
<p>However in my opinion the <code>arr</code> counts as implementation detail and thus I would override <code>__copy__</code>:</p>
<pre><code>class T(object):
    def __init__(self, x, y):
        self.arr = [x, y]

    def __copy__(self):
        new = self.__class__(*self.arr)
        # ... maybe other stuff
        return new
</code></pre>
<p>Just to show it works as expected:</p>
<pre><code>from copy import copy, deepcopy

x = T([2], [3])
y = copy(x)
x.arr is y.arr        # False
x.arr[0] is y.arr[0]  # True
x.arr[1] is y.arr[1]  # True

x = T([2], [3])
y = deepcopy(x)
x.arr is y.arr        # False
x.arr[0] is y.arr[0]  # False
x.arr[1] is y.arr[1]  # False
</code></pre>
<hr/>
<p>Just a quick note about expectations:</p>
<p>Users generally expect that you can pass an instance to the constructor to create a minimal copy (similar or identical to <code>__copy__</code>) as well. For example:</p>
<pre><code>lst1 = [1,2,3,4]
lst2 = list(lst1)
lst1 is lst2        # False
</code></pre>
<p>Some Python types have an explicit <code>copy</code> method, that (if present) should do the same as <code>__copy__</code>. That would allow to explicitly pass in parameters (however I haven't seen this in action yet):</p>
<pre><code>lst3 = lst1.copy()  # python 3.x only (probably)
lst3 is lst1        # False
</code></pre>
<p>If your class should be used by others you probably need to consider these points, however if you only want to make your class work with <code>copy.copy</code> then just overwrite <code>__copy__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think overwriting <code>__copy__</code> is a good idea, as explained by the other answers with great detail. An alternative solution might be to write an explicit copy method to be absolutely clear on what is called:</p>
<pre><code>class T(object):
    def __init__(self, x, y):
        self.arr = [x, y]

    def copy(self):
        return T(*self.arr)
</code></pre>
<p>When any future reader sees <code>t.copy()</code> he then immediately knows that a custom copy method has been implemented. The disadvantage is of course that it might not play well with third-party libraries that use <code>copy.copy(t)</code>.</p>
</div>
<span class="comment-copy">the concept of "deep" comes from the recursive part, otherwise saying "A deep copy constructs a new compound object and then inserts deep copies into it" would be a recursive description.</span>
<span class="comment-copy">Thanks! I thought the same but felt doubtful when I read the Python documentation. Why don't Python make <code>copy</code> a builtin like <code>str</code> and <code>repr</code>?</span>
<span class="comment-copy">Because there are not many use-cases for it.  Python devs generally work in a style which avoids side-effects so they don't really care about where in memory an object lives.</span>
<span class="comment-copy">@user31039 Because most builtins can be easily copied. For example an instance can be passed to the constructor (<code>dict({'a': 1})</code> makes a copy) or have an explicit <code>copy</code> method: <code>{1,2,3}.copy()</code> or have even a slicing syntax to make a copy: <code>[1,2,3][:]</code>. For normal python programs using the builtins you just don't need the copy module. Advertising: I touched some of these points in my answer as well. :)</span>
<span class="comment-copy">so your answer to the question "should I override copy or deepcopy?"  from the title is.... neither and forget about <code>copy.copy</code> all together?</span>
<span class="comment-copy">It's just an alternative idea. I think it has some advantages, but I am also completely aware of the negative implications.</span>
<span class="comment-copy">ok except that if <code>__copy__</code> is defined it is called when you do <code>copy.copy(t)</code>.  It still seems to me you aren't really offering a solution to the question asked. (I assume downvoter was for that reason)</span>
<span class="comment-copy">Fair enough â€“ I will amend my answer. However, I think the other answers to this question go into great detail and give very good reasoning for overwriting <code>__copy__</code> already.</span>
