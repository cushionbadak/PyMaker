<div class="post-text" itemprop="text">
<p>I am stuck with this question, can you solve the challenge? Here we go!</p>
<p>We represent scores of players across a sequence of matches in a two level dictionary as follows:</p>
<pre><code>{'match1':{'player1':57, 'player2':38}, 'match2':{'player3':9, 'player1':42}, 'match3':{'player2':41, 'player4':63, 'player3':91}}
</code></pre>
<p>Each match is identified by a string, as is each player.  The scores are all integers.  The names associated with the matches are not fixed (here they are 'match1','match2','match3'), nor are the names of the players.  A player need not have a score recorded in all matches.</p>
<p>Define a Python function <code>orangecap(d)</code> that reads a dictionary d of this form and identifies the player with the highest total score.  Your function should return a pair (playername,topscore) where playername is a string, the name of the player with the highest score, and topscore is an integer, the total score of playername.</p>
<p>The input will be such that there are never any ties for highest total score.</p>
<p>For instance:</p>
<pre><code>&gt;&gt;&gt; orangecap({'match1':{'player1':57, 'player2':38}, 'match2':{'player3':9, 'player1':42}, 'match3':{'player2':41, 'player4':63, 'player3':91}})
('player3', 100)

&gt;&gt;&gt; orangecap({'test1':{'Ashwin':84, 'Kohli':120}, 'test2':{'ashwin':59, 'Pujara':42}})
('Kohli', 120)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>with <code>pandas</code> it's really easy:</p>
<pre><code>In [78]: d
Out[78]: 
{'match1': {'player1': 57, 'player2': 38},
 'match2': {'player1': 42, 'player3': 9},
 'match3': {'player2': 41, 'player3': 91, 'player4': 63}}

In [79]: pd.DataFrame(d).sum(axis=1).idxmax()
Out[79]: 'player3'

In [80]: pd.DataFrame(d).sum(axis=1).max()
Out[80]: 100.0
</code></pre>
<p>First convert it to a DataFrame, then sum over the columns, and find the max :)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can easily use a running counter to count the scores first:</p>
<pre><code>from collections import Counter

def orangecap(d):
    total = Counter()
    for match_result in d.values():
        total.update(match_result)
    return total.most_common(1)[0]
</code></pre>
<p>Here <a href="https://docs.python.org/3/library/collections.html?highlight=most_common#collections.Counter.update" rel="nofollow noreferrer"><code>Counter.update(iterable)</code></a> will increment the counters for the players mentioned. <a href="https://docs.python.org/3/library/collections.html?highlight=most_common#collections.Counter.most_common" rel="nofollow noreferrer"><code>Counter.most_common(n)</code></a> specifies we want the first most common element. This will return a list and we pick the first tuple.</p>
<pre><code>&gt;&gt;&gt; orangecap(d)
('player3', 100)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest using Willem Van Onsem answer, but if you don't want to import then here is an alternative.</p>
<pre><code>data = {
    'match1': {
        'player1': 57,
        'player2': 38},
    'match2': {
        'player3': 9,
        'player1': 42},
    'match3': {
        'player2': 41,
        'player4': 63,
        'player3': 91}
    }


def orangecap(data):
    totals = {}
    for d in data.values():
        for k, v in d.items():
            totals[k] = totals.setdefault(k, 0) + v

    return max(totals.items(), key = lambda t:t[1])

&gt;&gt;&gt; orangecap(data)
('player3', 100)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import operator

def orangecap(d):
    players = {}    
    for dict in d.values():
        for player in dict:
            if player in players:
               players[player] += dict[player]
            else:
               players[player] = dict[player]

    scores = sorted(players.items(), key = operator.itemgetter(1), reverse = True)
    return scores[0]

#Credits to  Willem Van Onsem for his various suggestions
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some code golfing with <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a>:</p>
<pre><code>from functools import reduce
from collections import Counter

v = reduce(lambda x, y: x.update(y) or x, d.values(), Counter()).most_common(1)[0])
print(v)
# ('player3', 100)
</code></pre>
</div>
<span class="comment-copy"><i>challenge?</i> Is this a (running) programming contest?</span>
<span class="comment-copy">Please be more specific about the issue you are facing. We will not solve the problem for you.</span>
<span class="comment-copy">I just stumbled upon multiple instances of this question on stackoverflow. Is something happening?</span>
<span class="comment-copy">Appears to be an assignment or something o.0 ?</span>
<span class="comment-copy">How do you put ipython code here as an answer? showing the <code>In[]</code> and <code>Out[]</code> stuff?</span>
<span class="comment-copy">I've found that using anaconda and spyder works the best for answering stack overflow questions. Then you can "copy (raw text)" from the ipython console in spyder3</span>
<span class="comment-copy">It looks nicer and cooler as an answer :) I will take a look at spyder3,thanks!</span>
<span class="comment-copy">@AsheKetchum what do you mean? You copy it from the terminal...</span>
<span class="comment-copy">@juanpa.arrivillaga for example on windows that might not be so trivial</span>
<span class="comment-copy">thats perfect Willem!</span>
<span class="comment-copy">I think op wants the total score of that player :P</span>
<span class="comment-copy">Highest <i>total</i> score...</span>
<span class="comment-copy">Ah, failed to see total. Thanks</span>
<span class="comment-copy">Nonetheless it is a beautiful line of code :)</span>
<span class="comment-copy">I've already edited my answer. My previous answer didn't total the scores for each player then find the max.</span>
<span class="comment-copy">you can try <code>collections.defaultdict</code>:)</span>
<span class="comment-copy">Furthermore <code>sorted(..)</code> does <b>not work inline</b> (especially since dictionaries have no order) and you do not have to sort anyway: you can use <code>max</code> for that.</span>
<span class="comment-copy">Uhh well spotted @WillemVanOnsem, this code will never work. You mean <b>inplace</b> rather than <b>inline</b> though. :( You should fix the code or you will get downvoted.</span>
<span class="comment-copy">@SebastianWozny: yeah indeed (English is not my native language).</span>
<span class="comment-copy">my apologies, I thought I wrote something else :P</span>
