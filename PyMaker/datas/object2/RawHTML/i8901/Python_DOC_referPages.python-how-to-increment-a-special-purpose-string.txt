<div class="post-text" itemprop="text">
<p>Consider a special-purpose string of length 8, say "A00000XY". The string has following restrictions.</p>
<ol>
<li>Length = 8.</li>
<li>Last two chars have special meaning and should remain as it is.</li>
<li>A-Z and 0-9 are only valid characters. Thus the regular expression "^[A-Z0-9]{6}XY$" defines the string.</li>
</ol>
<p>How can I implement a function, say increment, that when called increments the string by one. Thus subsequent calls should look like following:</p>
<pre><code>&gt;&gt;&gt; A = "A00000XY"
&gt;&gt;&gt; print increment(A)
"A00000XY"
&gt;&gt;&gt; print increment(A)
"A00001XY"
&gt;&gt;&gt; print increment(A)
"A00002XY"
...
&gt;&gt;&gt; print increment(A)
"A00009XY"
&gt;&gt;&gt; print increment(A)
"A0000AXY"
&gt;&gt;&gt; print increment(A)
"A0000BXY"
...
&gt;&gt;&gt; print increment(A)
"A0000YXY"
&gt;&gt;&gt; print increment(A)
"A0000ZXY"
&gt;&gt;&gt; print increment(A)
"A00010XY"
&gt;&gt;&gt; print increment(A)
"A00011XY"
...
&gt;&gt;&gt; print increment(A)
"ZZZZZZXY"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def digit_helper(num):
    while num &gt; 0:
        yield digits[num % 36]
        num = num / 36

def increment(string):
    incremented = int(string[:-2], base=36) + 1
    return "".join(reversed(list(digit_helper(incremented)))) + "XY"
</code></pre>
<p>Temptation was too high. However, not very suitable as homework answer, I'm afraid :D</p>
<p>Update: it's Python 2. In Python 3 division should be <code>num // 36</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>So what you really want is a base 36 number. You will need to build a class that works similar to how hex to decimal and decimal to hex conversions work. With your 8 character limit, you have values from 0 to 36^8 - 1 values, or 2821109907455. 
9223372036854775807 is the <a href="https://stackoverflow.com/questions/7604966/maximum-and-minimum-values-for-ints">max integer in python</a> , so the good news is that you can represent your value as an integer. </p>
<p>To convert from your string value to the integer:</p>
<ol>
<li>intValue = 0</li>
<li>Loop through each of the first eight characters in the string.</li>
<li>Pass the character to a function that returns an integer equivalent between 0 and 35. We'll call this charValue</li>
<li>intValue += intValue*36 + charValue</li>
</ol>
<p>To convert from the integer to your string value:</p>
<ol>
<li>stringValue = specialCharacters</li>
<li>curDigit = intValue % 36</li>
<li>intValue = intValue / 36</li>
<li>find string equivalent of intValue (0 to Z)</li>
<li>Append to front of stringValue</li>
<li><p>Repeat until intValue &lt; 36. Any remaining characters would be 0</p>
<p>Obviously you would build the increment and decrement methods as well.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Inspired from @avysk response.</p>
<p>The @avysk reply has two issues.</p>
<ol>
<li>Handling for ZZZZZZXY. It should wrap around and return 000000XY. It shouldn't overflow. However I missed covering this part in my question itself.</li>
<li>000000XY isn't handled properly to return 000001XY. It instead
returns 1XY.</li>
</ol>
<p>Fixing these issue in following code that borrows most from @avysk's response.</p>
<pre><code>digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def digit_helper(num):
  while num &gt; 0:
    yield Tape.digits[num % 36]
    num = num / 36


# This function, using the utility digit_helper, increments the string by 1.
# It produces string in following order:
#     "A00000XY", "A00000XY", "A00001XY", "A00002XY", ...,
#     "A00009XY", "A0000AXY", "A0000BXY", ...,
#     "A0000YXY", "A0000ZXY", "A00010XY", "A00011XY", ...,
#     "ZZZZZZXY", "000000XY", "000001XY", ...
# Logic:
# 1. Strip the string of last two chars.
# 2. Convert to base 36 equivalent integer and increment by one.
# 3. Convert back to Base 36 representation of incremented value.
#   3.1. [0:6] handles the overflow. Overflow happens after "ZZZZZZXY" and produces "1000000XY".
#   3.2. [::-1] reverses the string.
#   3.3. zfill(6) handles underflow, like converting integer 1 to "000001XY".
def increment(string):
  incremented = int(string[:-2], base=36) + 1
  return "".join(Tape.digit_helper(incremented))[0:6][::-1].zfill(6) + string[-2:]
</code></pre>
</div>
<span class="comment-copy">Some hints: use <code>ord</code> and <code>chr</code>. Checkout the ASCII table for digits (48-57) and uppercase letters (65-90). Have a list of those to increment over. Do it for each digit from right to left as you increment with numbers. Increment the neighbor if there was overflow from the right. Play around now to see how far you can get, and come back with some concrete questions when you put in more effort.</span>
<span class="comment-copy"><code>How can I implement a function,...?</code> - work your way through <a href="https://docs.python.org/3/tutorial/index.html" rel="nofollow noreferrer">The Tutorial</a> - eventually you will get a handle on the tools that are available and you will start to get Ideas - try some of those ideas out.</span>
<span class="comment-copy">Do you really need to increment a particular string, or you need an algorithm that iterates over all such strings in order? In the former case you can try <code>itertools.product</code>.</span>
<span class="comment-copy">You can use a <a href="https://en.wikipedia.org/wiki/Numeral_system#Positional_systems_in_detail" rel="nofollow noreferrer">numeral system</a> with base 36 to convert the string into a number and back.</span>
<span class="comment-copy"><code>num / 36</code> is a floating-point division. You probably meant the integer-divisor <code>//</code>.</span>
<span class="comment-copy">@Paul Nope, I was just writing Python 2. <code>num / 36</code> is integer division in Python 2.</span>
<span class="comment-copy">Well, I guess I'm just too much used to Python3 :D. Either way, you should clarify this in the answer. Nice answer apart from that</span>
<span class="comment-copy">@Paul you're right, edited the answer.</span>
<span class="comment-copy">The answer is almost correct with exception of two issues. 1. Handling for ZZZZZZXY. It should wrap around and return 000000XY. 2. 000000XY isn't handled properly to return 000001XY. It instead returns 1XY. Fixing the two in my reply. I still accept this reply as best reply.</span>
