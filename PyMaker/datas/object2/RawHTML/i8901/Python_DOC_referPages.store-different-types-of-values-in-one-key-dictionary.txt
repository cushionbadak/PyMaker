<div class="post-text" itemprop="text">
<p>I want to make a "travel" summary that looks like:</p>
<blockquote>
<p>There are <strong>4</strong> starting points to reach <strong>Chicago</strong>. To access this
  city, you can use: <strong>Highway X,</strong> <strong>Highway Z,</strong>
<strong>Highway ZZ.</strong></p>
</blockquote>
<p>The data that I currently have looks something like:</p>
<blockquote>
<p>Highway X, NY, Chicago</p>
<p>Highway Z, LA, Chicago</p>
<p>Highway X, Austin, Chicago</p>
<p>Highway ZZ, Miami, Chicago</p>
</blockquote>
<p>My question: What should I use to store these data properly?</p>
<p>I tried to use a dictionary with a list inside of it. However, it didn't work because I couldn't store the list of Highway. I only managed to get something like </p>
<blockquote>
<p>{Chicago: [NY, LA, Austin]}</p>
</blockquote>
<p><strong>UPDATE!!</strong></p>
<p>I just figured out that there's duplication in my data, and that's not a good news because I want the starting points to be distinct. Right now it looks like this:</p>
<blockquote>
<p>Highway X, NY, Chicago</p>
<p>Highway X, NY, Chicago</p>
<p>Highway Z, LA, Chicago</p>
<p>Highway X, Austin, Chicago</p>
<p>Highway ZZ, Miami, Chicago</p>
<p>Highway X, NY, Chicago</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Use a list of tuples in your dictionary. The first item in each tuple would be the highway, the second the starting point.</p>
<pre><code>routes = {'Chicago': [('Highway X', 'NY'), ('Highway Z', 'LA'), ('Highway AX', 'Austin'), ('Highway ZZ', 'Miami')]}
</code></pre>
<p>Then it's trivial to produce the summary:</p>
<pre><code>for city in routes:
    paths = ', '.join(sorted({route[0] for route in routes[city]}))
    print("There are {} starting points to reach {}. To access this city, you can use: {}".format(len(routes[city]), city, paths))
</code></pre>
<p>The first line uses a set comprehension to remove duplicate highways and then sorts and joins them to make a string. That string as well as the destination city and number of routes is then used to construct the final summary string. The output of the above code would be:</p>
<pre>
There are 4 starting points to reach Chicago. To access this city, you can use: Highway X, Highway Z, Highway ZZ
</pre>
<hr/>
<p>An easy way to construct the <code>routes</code> dict is to use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> of lists. Assuming that your data is coming from a CSV file:</p>
<pre><code>import csv
from collections import defaultdict

routes = defaultdict(list)

with open('data.csv') as f:
    reader = csv.reader(f)
    for highway, start, dest in reader:
        routes[dest].append((highway, start))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best way of organising your  data depends on what you want to do with them.</p>
<p>Do you want to answer questions like "I'm in Austin, which Highway do I have to take to get to Chicago?"</p>
<p>Then your keys should be the departure cities:</p>
<pre><code>lookup = {'Austin': 'Highway X',
          'NY': 'Highway X',
          'LA': 'Highway Z',
          'Miami': 'Highway ZZ'}
</code></pre>
<p>Because then you can answer the question by simply looking up the asker's starting point:</p>
<pre><code>lookup['Austin']
# prints
# Highway X
</code></pre>
<p>But if you want to answer different questions like "Someone travelling on Highway X which city are they more likely to come from?" then you'd organise your data differently.</p>
<p>If you just want to print them, use a 'lil' (list of lists)</p>
<pre><code>table = [["Highway X", "NY", "Chicago"],
         ["Highway Z", "LA", "Chicago"],
         ["Highway X", "Austin", "Chicago"],
         ["Highway ZZ", "Miami", "Chicago"]]
</code></pre>
<p>Then you can easily format</p>
<pre><code>for row in table:
    print("{:12}{:8}{:10}".format(*row))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Nest some dictionaries. This allows you to follow a "route."</p>
<pre><code>{'Highway X': {'Austin': 'Chicago', 'NY': 'Chicago'},
 'Highway Z': {'LA': 'Chicago'},
 'Highway ZZ': {'Miami': 'Chicago'}}
</code></pre>
<p>Alternatively:</p>
<pre><code>{'Austin': {'Highway X': 'Chicago'},
 'LA': {'Highway Z': 'Chicago'},
 'Miami': {'Highway ZZ': 'Chicago'},
 'NY': {'Highway X': 'Chicago'}}
</code></pre>
</div>
<span class="comment-copy">So you're trying to figure out the best way to store the data so that for each city, you can see which other cities you can go to?</span>
<span class="comment-copy">@jlarks32 I'm trying to find a way how to store all these data and print them exactly like the summary.</span>
<span class="comment-copy">Thank you, I've tried this, and it worked! I want to ask a follow-up question. Is it possible to sort the destination cities based on the most starting points? Let's say if my data are Chicago = 4 starting points, Seattle = 12 starting points, and SF = 2 starting points. Then, my code will print Seattle first, then Chicago and SF.</span>
<span class="comment-copy">Hi, I just discovered that there's duplication in my data. Is there a way to eliminate this duplication when I append?</span>
<span class="comment-copy">Re duplicates:: yes, use a set of tuples (instead of a list) and change <code>routes[dest].append()</code> to <code>routes[dest].add()</code>.</span>
<span class="comment-copy">Re: sorting by number of routes, you can sort using a key like this: <code>for city in sorted(routes, key=lambda key: len(routes[key]), reverse=True):</code></span>
<span class="comment-copy">This is a really good alternative. Thanks!</span>
<span class="comment-copy">I will try this out first. Thanks!</span>
