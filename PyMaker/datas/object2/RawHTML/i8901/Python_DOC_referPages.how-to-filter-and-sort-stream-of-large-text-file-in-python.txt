<div class="post-text" itemprop="text">
<p>I have a large text file (&gt;1GB) of three comma-separated values that I want to read into a Pandas DataFrame in chunks.  An example of the DataFrame is below:</p>
<p><img alt="output" src="https://i.stack.imgur.com/2RpEL.png"/></p>
<p>I'd like to filter through this file while reading it in and output a "clean" version.  One issue I have is that some Timestamps are out-of-order, but the problem is usually quite local (usually a tick is out-of-order by a few slots before or below).  Are there any ways to do localized, "sliding window" sorting?</p>
<p>Also, as I'm fairly new to Python, and learning about the I/O methods, I'm unsure of the best class/method to use for filtering large data files.  TextIOBase? </p>
</div>
<div class="post-text" itemprop="text">
<p>This is a really interesting question, as the data's big enough to not fit in memory easily.</p>
<p>First of all, about I/O: if it's a CSV I'd use a standard library <a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow noreferrer"><code>csv.reader()</code></a> object, like so (I'm assuming Python 3):</p>
<pre><code>with open('big.csv', newline='') as f:
    for row in csv.reader(f):
        ...
</code></pre>
<p>Then I'd probably keep a sliding window of rows in a <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque(maxlen=WINDOW_SIZE)</code></a> instance with window size set to maybe 20 based on your description. Read the first <code>WINDOW_SIZE</code> rows into the deque, then enter the main read loop which would output the left-most item (row) in the deque, then append the current row.</p>
<p>After appending each row, if the current row's timestamp comes before the timestamp of the previous rows (<code>window[-2]</code>), then sort the deque. You can't sort a deque directly, but do something like:</p>
<pre><code>window = collections.deque(sorted(window), maxlen=WINDOW_SIZE)
</code></pre>
<p>Python's Timsort algorithm handles already-sorted runs efficiently, so this should be very fast (linear time).</p>
<p>If the window size and the number of out-of-order rows are small (as it sounds like they can be), I believe the overall algorithm will be O(N) where N is the number of rows in the data file, so linear time.</p>
<p>UPDATE: I wrote some demo code to generate a file like this and then sort it using the above technique -- see <a href="https://gist.github.com/benhoyt/fae1d584435a5dcff65c8330fe368a78" rel="nofollow noreferrer">this Gist</a>, tested on Python 3.5. It's much faster than the <code>sort</code> utility on the same data, and also faster than Python's <code>sorted()</code> function after about N = 1,000,000. Incidentally the function that generates a demo CSV is significantly slower than the sorting code. :-) My results timing  <code>process_sliding()</code> for various N (definitely looks linear-ish):</p>
<ul>
<li>N = 1,000,000: 3.5s</li>
<li>N = 2,000,000: 6.6s</li>
<li>N = 10,000,000: 32.9s</li>
</ul>
<p>For reference, here's the code for my version of <code>process_sliding()</code>:</p>
<pre><code>def process_sliding(in_filename, out_filename, window_size=20):
    with (open(in_filename, newline='') as fin,
          open(out_filename, 'w', newline='') as fout):
        reader = csv.reader(fin)
        writer = csv.writer(fout)

        first_window = sorted(next(reader) for _ in range(window_size))
        window = collections.deque(first_window, maxlen=window_size)

        for row in reader:
            writer.writerow(window.popleft())
            window.append(row)
            if row[0] &lt; window[-2][0]:
                window = collections.deque(sorted(window), maxlen=window_size)

        for row in window:
            writer.writerow(row)
</code></pre>
</div>
<span class="comment-copy">I would use iteetools.islice to get a chuck of data</span>
<span class="comment-copy">@Copperfield Can you be more specific? If you mean when fetching that <code>first_window</code> chunk, I thought about that, but I think it's often clearer and simpler to avoid imports and use more basic builtins.</span>
<span class="comment-copy">yes, I mean on <code>first_window</code>. Also your current way have the risk of throwing an StopIteration exception, maybe for this use case that is not a problem, but why leave a easily avoidable problem there?</span>
