<div class="post-text" itemprop="text">
<p>I need to assemble a long text string from xml fields.</p>
<p>XML_FIELD_ONE = "Iamacatthatisoddlyimmunetocatnip"</p>
<p>XML_FILED_TWO = [7,8,24]</p>
<p>FILED_TWO contains the index at which to insert either \n or \r.
If two indexes are 1 apart (like 7, 8), then I need to insert \r\n. If the index is solo (like 24) I need to insert \n.</p>
<p>It takes about 2 minutes to process a 25K line file with this code.
What am I doing wrong?</p>
<pre><code>XML_FIELD_ONE = list("Iamacatthatisoddlyimmunetocatnip")
XML_FILED_TWO = [7,8,24]

idx = 0
while idx &lt;= len(XML_FIELD_ONE):
   for position in XML_FIELD_ONE:
       for space in XML_FIELD_TWO:

             if idx == int(space) and idx+1 == int(space)+1:
               XML_FIELD_ONE[idx] = "\r"

                        try:
                            XML_FIELD_ONE[idx+1] = "\n"
                        except:
                            pass

              elif idx == int(space):
                 XML_FIELD_ONE[idx] = "\n"

    idx += 1


new_text = "".join(XML_FIELD_ONE)
return new_text
</code></pre>
<p>The simple way of doing this is:</p>
<pre><code>for offset in XML_FILED_TWO:
    XML_FILED_ONE[offset] = \n
</code></pre>
<p>But this violates the "if two offsets are together, first one is \r, next one is \n"</p>
</div>
<div class="post-text" itemprop="text">
<p>You wrote a triple loop when you need only one; this is horridly inefficient.  You know exactly where to insert the new items: go directly there, instead of incrementing two counters to find the place.</p>
<p>I'm not sure exactly where you need the insertions, but this should be close.  To keep the original indices correct, you need to insert from the right end and work to the left; that's why I reverse XML_FIELD_TWO.</p>
<p>I left in my debugging print statements.</p>
<pre><code>XML_FIELD_ONE = list("Iamacatthatisoddlyimmunetocatnip")
XML_FIELD_TWO = [7,8,24]

print XML_FIELD_ONE
XML_FIELD_TWO = XML_FIELD_TWO[::-1]
print XML_FIELD_TWO
i = 0
while i &lt; len(XML_FIELD_TWO):
    print i, XML_FIELD_TWO[i]
    if XML_FIELD_TWO[i] - XML_FIELD_TWO[i+1] == 1:
        XML_FIELD_ONE.insert(XML_FIELD_TWO[i], '\r\n')
        i += 2
    else:
        XML_FIELD_ONE.insert(XML_FIELD_TWO[i], '\n')
        i += 1

    print "\n", ''.join(XML_FIELD_ONE)
</code></pre>
<p>Output:</p>
<pre><code>['I', 'a', 'm', 'a', 'c', 'a', 't', 't', 'h', 'a', 't', 'i', 's', 'o', 'd', 'd', 'l', 'y', 'i', 'm', 'm', 'u', 'n', 'e', 't', 'o', 'c', 'a', 't', 'n', 'i', 'p']
[24, 8, 7]
0 24

Iamacatthatisoddlyimmune
tocatnip
1 8

Iamacatt
hatisoddlyimmune
tocatnip
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the python <a href="https://docs.python.org/3/library/functions.html?highlight=enumerate#enumerate" rel="nofollow noreferrer"><code>enumerate()</code></a> function to produce a sequence of index/value pairs in a single loop. You can then use the <a href="https://docs.python.org/3/library/stdtypes.html?highlight=list#typesseq-mutable" rel="nofollow noreferrer"><code>list.insert(pos, val)</code></a> method to insert the character you want.</p>
<pre><code>XML_FIELD_ONE = list("Iamacatthatisoddlyimmunetocatnip")
XML_FIELD_TWO = [7,8,24]

last_i = len(XML_FIELD_TWO) - 1

for i,p in enumerate(XML_FIELD_TWO):
    ch = '\r' if i &lt; last_i and XML_FIELD_TWO[i+1] == p+1 else '\n'
    XML_FIELD_ONE.insert(p, ch)

print(XML_FIELD_ONE)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a linear algorithm to achieve what you are trying to do. Actually, using <code>try-except</code> is perfectly appropriate here, but you should <em>never have a naked except</em>:</p>
<pre><code>&gt;&gt;&gt; XML_FIELD_ONE = list("Iamacatthatisoddlyimmunetocatnip")
&gt;&gt;&gt; XML_FIELD_TWO = [7,8,24]
&gt;&gt;&gt; insertions = 0
&gt;&gt;&gt; for i, e in enumerate(XML_FIELD_TWO):
...     try:
...         cont = e + 1 == XML_FILED_TWO[i+1]
...     except IndexError:
...         cont = False
...     if cont:
...         XML_FI.insert(e+1+insertions, '\r\n')
...         XML_FIELD_ONE.insert(e+1+insertions, '\r\n')
...     else:
...         XML_FIELD_ONE.insert(e + insertions, '\n')
...     insertions += 1
...
&gt;&gt;&gt; print("".join(XML_FIELD_ONE))
Iamacatt

hatisoddlyimmune
tocatnip
&gt;&gt;&gt;
</code></pre>
<p>I keep track of the number of insertions which offsets the index used in <code>.insert</code> to keep the original indices correct.</p>
</div>
<span class="comment-copy">This isn't related, but when will <code>idx == int(space)</code> be True and <code>idx + 1 == int(space) + 1</code> NOT be True? am I missing something? And what's with the naked <code>except</code>? Those are not good. Are you trying to catch an <code>IndexError</code>? Usually, you should try to deal with those explicitly, or correct your code so that won't happen... Honestly, I'm having a hard time grokking your code vis a vis your description of what it does... You aren't <i>inserting</i>, so to speak, but rather, replacing. And 3 nested loops seems totally unnecessary.</span>
<span class="comment-copy">But, to answer your question, your algorithm here is going to be at <i>least</i> quadratic in terms of length of <code>XML_FIELD_ONE</code>, and actually, it is O(m*n^2) as far as I can tell, where <code>n = len(XML_FIELD_ONE)</code> and <code>m = len(XML_FIELD_TWO)</code>... doesn't seem like the right approach at all, given your description of what you are trying to accomplish.</span>
<span class="comment-copy">The space is only 7, 8, 24, meaning it wouldn't be true unless you're at index 7. Meaning index 7 and 8 are replaced by 7, and 8.   The naked except is to catch the last idx error, yes. When you're at MAX index, you cannot look at MAX index + 1.</span>
<span class="comment-copy">You are confused. <code>int(space) + 1</code> will not give you the <i>next item in the list</i>. It is <i>always going to be True</i> if the left side of the <code>and</code> is  True.</span>
<span class="comment-copy">Yes, I understand that, but if <code>idx == int(space)</code> is True, then <code>idx + 1 == int(space) + 1</code> <b>will always be True</b></span>
<span class="comment-copy">Yeah, I used a for-loop and kept track of the number of insertions, but inserting in reverse works great too!</span>
<span class="comment-copy">Nicely shorter than my "level-appropriate" solution.  I hope others learn from this.</span>
<span class="comment-copy">Much thanks for taking the time and helping me think through this!</span>
