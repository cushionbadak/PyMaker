<div class="post-text" itemprop="text">
<p>Suppose I build a class that basically represents a number plus some fancy stuff. Instances of that class should behave like numbers in any arithmetic/mathematical operation.</p>
<p><strong>I could overload all numeric operators in that class, but is there no shorter solution?</strong></p>
<p>The class basically looks like:</p>
<pre><code>class MyFancyNumber:
    def __init__(self, num, info):
        self.num = num # the actual number
        self.info = info # some more info, or other data
    def doFancyStuff(self):
        # does something fancy
    def __add__(self, other):
        return self.num + other # same pattern for all numeric functions
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about this?</p>
<pre><code>class MyFancyNumber(int):
    def __new__(cls, num, info=None):
        return super(MyFancyNumber, cls).__new__(cls, num)
    def __init__(self, num, info=None):
        self.num = num
        self.info = info
&gt;&gt;&gt; MyFancyNumber(5)
5
&gt;&gt;&gt; MyFancyNumber(5) + 2
7
&gt;&gt;&gt; MyFancyNumber(5) / 4
1
&gt;&gt;&gt; MyFancyNumber(5) * 0.5
2.5
&gt;&gt;&gt; MyFancyNumber(5) - 7
-2
&gt;&gt;&gt; MyFancyNumber(5, 'info').info
'info'
</code></pre>
<p>I guess based on the above, you can figure out what you need.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't endorse this as being particularly idiomatic, but...</p>
<p>Assuming all of your function definitions behave identically, like "just invoke the base behavior of the <code>self.num</code> class and apply all the non-self arguments to it", then you can loop through all the function names you want to define, and create each one using <code>setattr</code>. Example:</p>
<pre><code>class MyFancyNumber(object):
    def __init__(self, num, info):
        self.num = num
        self.info = info
    def __repr__(self):
        return "MyFancyNumber({}, {})".format(repr(self.num), repr(self.info))

def make_func(name):
    return lambda self, *args: MyFancyNumber(getattr(self.num, name)(*args), self.info)

for name in ["__add__", "__sub__", "__mul__", "__div__", "__invert__", "__neg__", "__pos__"]:
    setattr(MyFancyNumber, name, make_func(name))

x = MyFancyNumber(50, "hello")
print(x + 10)
print(x - 10)
print(x * 10)
print(x / 10)
print(~x)
print(-x)
print(+x)
</code></pre>
<p>Result:</p>
<pre><code>MyFancyNumber(60, 'hello')
MyFancyNumber(40, 'hello')
MyFancyNumber(500, 'hello')
MyFancyNumber(5, 'hello')
MyFancyNumber(-51, 'hello')
MyFancyNumber(-50, 'hello')
MyFancyNumber(50, 'hello')
</code></pre>
<hr/>
<p>Edit: I wasn't sure whether you wanted the result of arithmetic to be a MyFancyNumber or a regular built-in numerical type, but either way, the implementation is pretty similar:</p>
<pre><code>class MyFancyNumber(object):
    def __init__(self, num, info):
        self.num = num
        self.info = info
    def __repr__(self):
        return "MyFancyNumber({}, {})".format(repr(self.num), repr(self.info))

def make_func(name):
    return lambda self, *args: getattr(self.num, name)(*args)

for name in ["__add__", "__sub__", "__mul__", "__div__", "__invert__", "__neg__", "__pos__"]:
    setattr(MyFancyNumber, name, make_func(name))

x = MyFancyNumber(50, "hello")
print(x + 10)
print(x - 10)
print(x * 10)
print(x / 10)
print(~x)
print(-x)
print(+x)
</code></pre>
<p>Result:</p>
<pre><code>60
40
500
5
-51
-50
50
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, you have to define all the arithmetic operators otherwise how would Python know what to do with them. Don't forget you also need the reverse operators like <code>__radd__</code>.</p>
<p>Also the code you've written returns an <code>int</code> for <code>x+1</code>. Did you mean that or did you want adding a fancy number to return another fancy number?</p>
<p>You could just subclass <code>int</code> or <code>float</code>. Then you don't have to reimplement the operators but you'll still lose the special nature whenever you operate on a value.</p>
<p>A better solution would just be to have the numeric value in an attribute and convert to numbers explicitly when that's what you want. You can use <code>__int__()</code> and <code>__float__()</code> to implement the conversion.</p>
<p>The documentation covers what you need to do if you really do want to emulate a numeric type: for Python 3.x <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__int__#emulating-numeric-types" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html?highlight=<strong>int</strong>#emulating-numeric-types</a> or for Python 2.x <a href="https://docs.python.org/2/reference/datamodel.html?highlight=__int__#emulating-numeric-types" rel="nofollow noreferrer">https://docs.python.org/2/reference/datamodel.html?highlight=<strong>int</strong>#emulating-numeric-types</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This works for me in python 2.7 as long as you pass just one argument in the <strong>init</strong>. Sadly have no idea why it works though.</p>
<pre><code>class MyFancyNumber(int):
    def __init__(self, num):
        self.num = num # the actual number

    def add_info(self,info):
        self.info = info  ## Add the info separately

    def doFancyStuff(self):
        # does something fancy

print MyFancyNumber(5)+5    
</code></pre>
<p>Usage</p>
<pre><code>f = MyFancyNumber(2)
f.add_info(info)
f+4               ## returns 6
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/numbers.html" rel="nofollow noreferrer">docs.python.org/3/library/numbers.html</a> This might help you get started.</span>
<span class="comment-copy">Using <code>__add__</code> this way may not do what you want. <code>MyFancyNumber(1, 'abc') + 1</code> will give you an <code>int</code> object, not a <code>MyFancyNumber</code>.</span>
<span class="comment-copy">As far as I understood, he doesn't want to return a MyFancyNumber, he just wants to have all the functionality as a number in the term of operators.</span>
<span class="comment-copy">@Szabolcs: Yes. Basically, I'd also be happy with an implicit conversion whenever a <code>MyFancyNumber</code> appears in an arithmetic expression.</span>
<span class="comment-copy">Take a look at my suggestion. I also added the <b>init</b> method.</span>
<span class="comment-copy">It would be better if you included the extra parameter in your example. Also this has the same problem as the original that you lose the subclass on any operation which may or may not be what they wanted.</span>
<span class="comment-copy">He wants instances of that class that should behave like numbers in any arithmetic/mathematical operation.</span>
<span class="comment-copy">One advantage that this approach has over my approach, is that you don't have to exhaustively enumerate through every operator you want to define. No waking up in a cold sweat a month later shouting "I forgot to implement <code>__radd__</code>!" ;-)</span>
<span class="comment-copy">it may not have been particularly idiomatic, but is sure was programmatic</span>
