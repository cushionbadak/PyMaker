<div class="post-text" itemprop="text">
<p>Please dont give me minus. I want to ask a better method to solve this problem, because what I am doing now is becoming a huge burden for me. </p>
<p>Hier is my question: I have two lists. I want to make sure that none item from one list is in the other list. </p>
<p>In Python I have been working with the following lines... (Assuming List_s has 3 items.)</p>
<pre><code>if List_s[0] not in List_big and List_s[1] not in List_big and List_s[2] not in List_big:   #none item from List_s should be in List_big
    do something
else:
    pass
</code></pre>
<p>These lines were actually OK for me, till I suddenly realize that I have to work with lists with &gt;200 length. And I have a lot of lists to compare. </p>
<p>So how could I change the code? Thank you very much for your help!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can convert one of the lists to a <code>set</code> and use <a href="https://docs.python.org/3/library/stdtypes.html#set.intersection" rel="nofollow noreferrer"><code>set.intersection</code></a>:</p>
<pre><code>if not set(List_s).intersection(List_big):
    print('no common items between lists')
</code></pre>
<p>Note that the elements in both lists must be <a href="https://stackoverflow.com/a/14535739/353852">hashable</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You will get the same results whether you use:</p>
<pre><code>set(List_s).isdisjoint(List_big)
</code></pre>
<p>or:</p>
<pre><code>not set(List_s).intersection(List_big)
</code></pre>
<p>But <a href="https://docs.python.org/3/library/stdtypes.html#set.isdisjoint" rel="nofollow noreferrer">set.isdisjoint</a> is much faster.  On my computer, <code>isdisjoint</code> takes about 150 nanoseconds to run against test data, while <code>intersection</code> takes 95 microseconds to run against the same data--about 630 times slower!</p>
</div>
<div class="post-text" itemprop="text">
<p>For very large list, </p>
<pre><code>import timeit
import random

L=[random.randrange(2000000) for x in xrange(1000000)]
M=[random.randrange(2000000) for x in xrange(1000000)]

start_time = timeit.default_timer()
print any(x in M for x in L)
#True
print timeit.default_timer() - start_time
#0.00981207940825

start_time = timeit.default_timer()
print not set(L).isdisjoint(M)
#True
print timeit.default_timer() - start_time
#0.164795298542

start_time = timeit.default_timer()
print True if set(L) &amp; set(M) else False
#True
print timeit.default_timer() - start_time
#0.436377859225

start_time = timeit.default_timer()
print True if set(L).intersection(M) else False
#True
print timeit.default_timer() - start_time
#0.368563831022
</code></pre>
<p>Clearly,</p>
<pre><code>print any(x in M for x in L)
</code></pre>
<p>is much more efficient</p>
</div>
<span class="comment-copy"><code>any(x in List_big for x in List_s)</code> That is going to be a polynomial time, though. Probably better to make a <code>set</code> out of <code>List_big</code> so that can be linear time.</span>
<span class="comment-copy">If the elements are hashable.</span>
<span class="comment-copy">thanks @PaulPanzer, updated.</span>
<span class="comment-copy">Thank you! That is way better than mine!</span>
<span class="comment-copy">Thank you for the hint!</span>
<span class="comment-copy">Thank you so much!</span>
