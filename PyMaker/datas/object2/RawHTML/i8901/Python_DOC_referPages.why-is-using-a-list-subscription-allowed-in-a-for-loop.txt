<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/39539606/are-for-loop-name-list-expressions-legal">Are for-loop name list expressions legal?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>How is the following construct accepted in Python:</p>
<pre><code>l = [1, 2, 3, 4]
for i, l[i] in enumerate(l[:]):
    print(l[i])
</code></pre>
<p>There seem to be no complaints and it happily prints out <code>1 2 3 4</code>. How is this allowed and what exactly does it do?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow noreferrer">syntax rule for <code>for</code> loops</a> allows the iteration variables to be any of those specified in <code>target_list</code>:</p>
<pre><code>for_stmt ::=  "for" target_list "in" expression_list ":" suite
              ["else" ":" suite]
</code></pre>
<p>where <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow noreferrer"><code>target_list</code> allows</a> for the following constructs:</p>
<pre><code>target_list     ::=  target ("," target)* [","]
target          ::=  identifier
                     | "(" [target_list] ")"
                     | "[" [target_list] "]"
                     | attributeref
                     | subscription
                     | slicing
                     | "*" target
</code></pre>
<p>This means you can also do other wacky things like assign to slices:</p>
<pre><code>for l[::-1] in [l, l, l]: pass  
</code></pre>
<p>or, subscriptions:</p>
<pre><code>class Foo: a = 20
for Foo.a in range(2): pass
</code></pre>
<p>but I really have no idea why you'd want to do so.</p>
<p>This is a by-product of <code>for-loop</code>s essentially performing an assignment statement for every iteration, as stated in the reference:</p>
<blockquote>
<p>Each item in turn is assigned to the target list <em>using the standard rules for assignments</em> (see Assignment statements), and then the suite is executed.</p>
</blockquote>
<p>So what the loop does is, it gets the iterator from the <code>expression_list</code> and performs an assignment to each of the values in the <code>target_list</code>. Essentially equivalent to the following <code>while</code> loop:</p>
<pre><code>it = enumerate(l[:])
while True:
    try:
        i, l[i] = next(it)
        print(l[i])
    except StopIteration:
        break 
</code></pre>
<p><code>dis</code> can also show this behavior manifesting on the byte-code level. Using a slightly simplified version:</p>
<pre><code>def _():
    for i, l[i] in enumerate(l[:]):
        pass
</code></pre>
<p>you'd get an output of:</p>
<pre><code>dis(_)
  2           0 SETUP_LOOP              40 (to 43)
              3 LOAD_GLOBAL              0 (enumerate)
              6 LOAD_GLOBAL              1 (l)
              9 LOAD_CONST               0 (None)
             12 LOAD_CONST               0 (None)
             15 BUILD_SLICE              2
             18 BINARY_SUBSCR
             19 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             22 GET_ITER
        &gt;&gt;   23 FOR_ITER                16 (to 42)
             26 UNPACK_SEQUENCE          2
             29 STORE_FAST               0 (i)
             32 LOAD_GLOBAL              1 (l)
             35 LOAD_FAST                0 (i)
             38 STORE_SUBSCR

  3          39 JUMP_ABSOLUTE           23
        &gt;&gt;   42 POP_BLOCK
        &gt;&gt;   43 LOAD_CONST               0 (None)
             46 RETURN_VALUE
</code></pre>
<p>where the relevant assignment is performed right after the the <code>FOR_ITER</code> command:</p>
<pre><code>             26 UNPACK_SEQUENCE          2
             29 STORE_FAST               0 (i)
             32 LOAD_GLOBAL              1 (l)
             35 LOAD_FAST                0 (i)
             38 STORE_SUBSCR
</code></pre>
<p>unpacks the sequence and assigns it to <code>i</code> and <code>l[i]</code>. </p>
<p>If you also disassemble <code>dis('i, l[i] = (1, 2)')</code> you'll see that if you ignore the initial loading of the tuple <code>(1, 2)</code> and the returning of the value, the operations are exactly the same.</p>
</div>
<span class="comment-copy">@johnsharpe how on earth did you find it? I was looking for a solid 20 minutes but couldn't find anything! :-)</span>
<span class="comment-copy">I Googled <i>"python subscription in for loop target list"</i>, it was the sixth hit.</span>
<span class="comment-copy">Well I certainly missed it. Ah well, another sign-post it is!</span>
<span class="comment-copy">Isn't the issue here the sequence of interpreted assignment and therefore binding creation? Which makes the while example in itself sort of non-explanatory?</span>
<span class="comment-copy">@pvg no no the issue that I was trying to highlight is the fact that there's an assignment going on ergo anything in <code>target_list</code> is allowed as the iteration variable for a <code>for-loop</code>. The <code>while</code> was written to show a friendly form of the sequence of commands executed and how it contains a hidden assignment.</span>
<span class="comment-copy">Ah, you're right, I see what you're saying. I'm obviously suffering from python binding- and scope- Stockholm syndrome.</span>
<span class="comment-copy">@pvg hah, then you can check out <a href="http://eli.thegreenplace.net/2015/the-scope-of-index-variables-in-pythons-for-loops/" rel="nofollow noreferrer">this nice article</a> that explains the scoping situation in <code>for-loop</code>s nicely :-)</span>
