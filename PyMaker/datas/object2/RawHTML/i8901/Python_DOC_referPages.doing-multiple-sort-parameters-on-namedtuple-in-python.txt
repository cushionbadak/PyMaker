<div class="post-text" itemprop="text">
<p>I was wondering what would be a Pythonic way of sorting a list of tuples by two keys whereby sorting with one (and only one) key would be in a reverse order and sorting with the the other would be case insensitive.
More specifically, I have a list containing tuples like:</p>
<pre><code>myList = [(ele1A, ele2A),(ele1B, ele2B),(ele1C, ele2C)]
</code></pre>
<p>I can use the following code to sort it with two keys:</p>
<pre><code>sortedList = sorted(myList, key = lambda y: (y[0].lower(), y[1]))
</code></pre>
<p>To sort in reverse order I can use </p>
<pre><code>sortedList = sorted(myList, key = lambda y: (y[0].lower(), y[1]), reverse = True)
</code></pre>
<p>but this would sort in a reverse order with two keys. </p>
<p>Any hints greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Two keys will be used when we need to sort a list with two constraints one in ascending order and other in descending in the same list or any
<br/>In your example <br/><code>sortedList = sorted(myList, key = lambda y: (y[0].lower(), y[1]))</code> can sort entire list only in one order
<br/>you can try these and check whats happening<br/></p>
<pre><code>sortedList = sorted(myList, key = lambda y: (y[0].lower(), -y[1]))
sortedList = sorted(myList, key = lambda y: (-y[0].lower(), y[1]))
sortedList = sorted(myList, key = lambda y: (-y[0].lower(), -y[1]))
</code></pre>
<p>hope you will understand after this ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>Sometimes there is little alternative but to use a comparator function. There was a <code>cmp</code> argument to <code>sorted</code> from its introduction to 2.4, but it was removed from Python 3 in favour of the more efficient <code>key</code> function. In 3.2, <code>cmp_to_key</code> was added to <code>functools</code>; it creates keys from the original objects by wrapping them in an object whose comparison function is based on the <code>cmp</code> function. (You can see a simple definition of <code>cmp_to_key</code> at the <a href="https://docs.python.org/3/howto/sorting.html#the-old-way-using-the-cmp-parameter" rel="nofollow">end of the Sorting How-To</a></p>
<p>In your case, since lower-casing is relatively expensive, you might want to do a combination:</p>
<pre><code>class case_insensitive_and_2nd_reversed:
    def __init__(self, obj, *args):
        self.first = obj[0].lower()
        self.second = obj[1]
    def __lt__(self, other):
        return self.first &lt; other.first or self.first == other.first and other.second &lt; self.second
    def __lt__(self, other):
        return self.first &lt; other.first or self.first == other.first and other.second &lt; self.second
    def __gt__(self, other):
        return self.first &gt; other.first or self.first == other.first and other.second &gt; self.second
    def __le__(self, other):
        return self.first &lt; other.first or self.first == other.first and other.second &lt;= self.second
    def __ge__(self, other):
        return self.first &gt; other.first or self.first == other.first and other.second &gt;= self.second
    def __eq__(self, other):
        return self.first == other.first and self.second == other.second
    def __ne__(self, other):
        return self.first != other.first and self.second != other.second

sortedList = sorted(myList, key = case_insensitive_and_2nd_reversed)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Method 1</h1>
<p>A simple solution, but might not be the most efficient is to sort twice: the first time using the second element, the second using the first element:</p>
<pre><code>sortedList = sorted(sorted(myList, key=lambda (a,b):b, reverse=True), key=lambda(a,b):a)
</code></pre>
<p>Or break down:</p>
<pre><code>tempList = sorted(myList, key=lambda (a,b):b, reverse=True)
sortedList = sorted(tempList, key=lambda(a,b):a))
</code></pre>
<h1>Method 2</h1>
<p>If your elements are numbers, you can cheat a little:</p>
<pre><code>sorted(myList, key=lambda(a,b):(a,1.0/b))
</code></pre>
<h1>Method 3</h1>
<p>Another approach is to swap the elements when comparing the elements:</p>
<pre><code>def compare_func(x, y):
    tup1 = (x[0], y[1])
    tup2 = (x[1], y[0])
    if tup1 == tup2:
        return 0
    elif tup1 &gt; tup2:
        return 1
    else:
        return -1

sortedList = sorted(myList, cmp=compare_func)
</code></pre>
<p>Or, using lambda to avoid writing function:</p>
<pre><code>sortedList = sorted(
    myList,
    cmd=lambda (a1, b1), (a2, b2): 0 if (a1, b2) == (a2, b1) else 1 if (a1, b2) &gt; (a2, b1) else -1
    )
</code></pre>
<p>I recommend against this approach as it is messy and the <code>cmd</code> keyword is not available in Python 3</p>
</div>
<span class="comment-copy">Very concise, thanks!</span>
