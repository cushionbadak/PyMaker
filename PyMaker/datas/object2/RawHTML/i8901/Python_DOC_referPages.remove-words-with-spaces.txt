<div class="post-text" itemprop="text">
<p>I want to find all the "phrases" in a list in remove them from the list, so that I have only words (without spaces) left. I'm making a hangman type game and want the computer to choose a random word. I'm new to Python and coding, so I'm happy to hear other suggestions for my code as well.</p>
<pre><code>import random
fhand = open('common_words.txt')

words = []

for line in fhand:
    line = line.strip()
    words.append(line)

for word in words:
    if ' ' in word:
        words.remove(word)

print(words)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sets are more efficient than lists. When lazily constructed like here, you can gain significant performance boost.</p>
<pre><code># Load all words
words = {}
with open('common_words.txt') as file:
    for line in file.readlines():
        line = line.strip()
        if " " not in line:
            words.add(line)
# Can be converted to one-liner using magic of Python
words = set(filter(lambda x: " " in x, map(str.strip, open('common_words.txt').readlines())))

# Get random word
import random
print(random.choice(words))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>str.split()</code>. It separates by both spaces and newlines by default.</p>
<pre><code>&gt;&gt;&gt; 'some words\nsome more'.split()
['some', 'words', 'some', 'more']
&gt;&gt;&gt; 'this is a sentence.'.split()
['this', 'is', 'a', 'sentence.']
&gt;&gt;&gt; 'dfsonf 43 SDFd fe@2'.split()
['dfsonf', '43', 'SDFd', 'fe@2']
</code></pre>
<p>Read the file normally and make a list this way:</p>
<pre><code>words = []
with open('filename.txt','r') as file:
    words = file.read().split()
</code></pre>
<p>That should be good.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>with open( 'common_words.txt', 'r' ) as f:
    words = [ word for word in filter( lambda x: len( x ) &gt; 0 and ' ' not in x, map( lambda x: x.strip(), f.readlines() ) ) ]
</code></pre>
<p><code>with</code> is used because file objects are <a href="http://eigenhombre.com/2013/04/20/introduction-to-context-managers" rel="nofollow noreferrer">content managers</a>. The strange list-like syntax is a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>, so it builds a list from the statements inside of the brackets. <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> is a function with takes in an iterable, applying a provided function to each item in the iterable, placing each transformed result into a new list*. <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer"><code>filter</code></a> is function which takes in an iterable, testing each item against the provided predicate, placing each item which evaluated to <code>True</code> into a new list*. <a href="https://docs.python.org/3.3/reference/expressions.html#lambda" rel="nofollow noreferrer"><code>lambda</code></a> is used to define a function (with a specific signature) in-line.</p>
<p>*: The actual return types are <a href="https://wiki.python.org/moin/Generators" rel="nofollow noreferrer">generators</a>, which function like iterators so they can still be used with <code>for</code> loops.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure if I understand you correctly, but I guess the split() method is something for you, like: </p>
<pre><code>with open('common_words.txt') as f:
    words = [line.split() for line in f]

words = [word for words in words_nested for word in words]  # flatten nested list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned, the
    .split()
Method could be a solution. </p>
<p>Also, the NLTK module might be useful for future language processing tasks. </p>
<p>Hope this helps!</p>
</div>
<span class="comment-copy"><code>if " " not in line:</code> This was the key to what I want to do. I'll have to look into the differences between sets and lists. Thanks!</span>
