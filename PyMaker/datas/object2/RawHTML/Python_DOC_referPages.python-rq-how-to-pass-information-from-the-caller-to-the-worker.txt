<div class="post-text" itemprop="text">
<p>I want to use rq to run tasks on a separate worker to gather data from a measuring instrument. The end of the task will be signaled by a user pressing a button on a dash app.
The problem is that the task itself does not know when to terminate since it doesn't have access to the dash app's context.</p>
<p>I already use <code>meta</code> to pass information from the worker back to the caller but can I pass information from the caller to the worker?</p>
<p>Example task:</p>
<pre class="lang-py prettyprint-override"><code>from rq import get_current_job
from time import time

def mock_measurement():
    job = get_current_job()
    t_start = time()

    # Run the measurement
    t = []
    i = []
    job.meta['should_stop'] = False # I want to use this tag to tell the job to stop
    while not job.meta['should_stop']:
        t.append(time() - t_start)
        i.append(np.random.random())
        job.meta['data'] = (t, i)
        job.save_meta()
        sleep(5)
    print("Job Finished")
</code></pre>
<p>From the console, I can start a job as such</p>
<pre class="lang-py prettyprint-override"><code>queue = rq.Queue('test-app', connection=Redis('localhost', 6379))
job = queue.enqueue('tasks.mock_measurement')
</code></pre>
<p>and I would like to be able to do this from the console to signify to the worker it can stop running:</p>
<pre class="lang-py prettyprint-override"><code>job.meta['should_stop'] = True
job.save_meta()
job.refresh
</code></pre>
<p>However, while the commands above return without an error, they do not actually update the <code>meta</code> dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because you didn't fetch the updated meta. <strong>But, don't do this!!</strong>
Invoking save_meta and refresh in caller and worker will lose data.</p>
<p>Instead, Use <code>job.connection.set(job + ':should_stop', 1, ex=300)</code> to set flag, and use <code>job.connection.get(job + ':should_stop')</code> to check if flag is set.</p>
</div>
<span class="comment-copy">Thank you! Just to clarify if anyone else has the same question, I ended up using <code>queue.connection.set(job.key + b':should_stop', 1, ex=30)</code> on the caller side and <code>connection.get(job.key + b':should_stop')</code> on the worker side.</span>
<span class="comment-copy">@DougP. you're right,  <code>self.connection</code> and <code>self.key()</code> should be <code>job.connectoin</code> and <code>job.key</code>.</span>
