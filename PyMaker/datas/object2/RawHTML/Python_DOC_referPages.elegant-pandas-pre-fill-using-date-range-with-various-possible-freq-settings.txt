<div class="post-text" itemprop="text">
<p>I am trying to prefill a dataframe akin to:</p>
<p><a href="https://i.stack.imgur.com/FHXk9.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/FHXk9.png"/></a></p>
<p>In the sample I am randomly removing some rows to highlight the challenge. I am trying to *elegantly calculate the dti value. The dti value in the first row would be 0 (even if first row is deleted as per script) but as gaps appear in the dti sequence needs to skip the missing rows. A logical approach would be to divide dt/delta to create a unique integer representing the bucket but nothing I tried felt or seemed elegant.</p>
<p>A bit of code to help simulate the problem:</p>
<pre><code>from datetime import datetime, timedelta
import pandas as pd
import numpy as np

start = datetime.now()
nin = 24
delta='4H'

df = pd.date_range( start, periods=nin, freq=deltadf, name ='dt') 

# remove some random data points
frac_points = 8/24                  # Fraction of points to retain
r = np.random.rand(nin)
df = df[r &lt;= frac_points]           # reduce the number of points
df = df.to_frame(index=False)       # reindex

df['dti'] = ...
</code></pre>
<p>Thank you in advance,</p>
</div>
<div class="post-text" itemprop="text">
<p>One solution is to divide the time differences between each row by the timedelta:</p>
<pre><code>from datetime import datetime, timedelta
import pandas as pd
import numpy as np

start = datetime.now()
nin = 24
delta='4H'

df = pd.date_range(start, periods=nin, freq=delta, name='dt')

# Round to nearest ten minutes for better readability
df = df.round('10min')

# Ensure reproducibility
np.random.seed(1)

# remove some random data points
frac_points = 8/24                  # Fraction of points to retain
r = np.random.rand(nin)
df = df[r &lt;= frac_points]           # reduce the number of points
df = df.to_frame(index=False)       # reindex

df['dti'] = df['dt'].diff() / pd.to_timedelta(delta)
df['dti'] = df['dti'].fillna(0).cumsum().astype(int)
df

                   dt  dti
0 2019-03-17 18:10:00    0
1 2019-03-17 22:10:00    1
2 2019-03-18 02:10:00    2
3 2019-03-18 06:10:00    3
4 2019-03-18 10:10:00    4
5 2019-03-19 10:10:00   10
6 2019-03-19 18:10:00   12
7 2019-03-20 10:10:00   16
8 2019-03-20 14:10:00   17
9 2019-03-21 02:10:00   20
</code></pre>
</div>
<span class="comment-copy">Hi Peter, thank you. Absolutely love the elegance of the approach and you got me home 90% of the way. I do seem to get a "TypeError: cannot astype a timedelta from [timedelta64[ns]] to [int32]" error from the very last line. Is that something to do with my installation as it seemed to have worked for you?</span>
<span class="comment-copy">@Luthor, glad to hear this is getting there! I guess your DataFrame has other columns. I've edited in a possible fix: change <code>df['dti'] = df.diff() / pd.to_timedelta(delta)</code> to <code>df['dti'] = df['dt'].diff() / pd.to_timedelta(delta)</code>. (My <code>pd.__version__</code> is 0.24.1)</span>
<span class="comment-copy">Hi @Peter, works a treat - I  did have the problem with the exact code above. However the df['dt'] works a treat. A beautiful and elegant solution. THANK YOU.</span>
<span class="comment-copy">@Luthor, that's awesome!</span>
