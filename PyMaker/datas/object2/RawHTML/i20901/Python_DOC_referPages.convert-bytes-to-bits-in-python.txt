<div class="post-text" itemprop="text">
<p>I am working with Python3.2. I need to take a hex stream as an input and parse it at bit-level. So I used </p>
<p><code>bytes.fromhex(input_str)</code></p>
<p>to convert the string to actual bytes. Now how do I convert these bytes to bits?</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way to do this is by using the <a href="http://packages.python.org/bitstring/index.html#" rel="noreferrer"><code>bitstring</code></a> module:</p>
<pre><code>&gt;&gt;&gt; from bitstring import BitArray
&gt;&gt;&gt; input_str = '0xff'
&gt;&gt;&gt; c = BitArray(hex=input_str)
&gt;&gt;&gt; c.bin
'0b11111111'
</code></pre>
<p>And if you need to strip the leading <code>0b</code>:</p>
<pre><code>&gt;&gt;&gt; c.bin[2:]
'11111111'
</code></pre>
<p>The <code>bitstring</code> module isn't a requirement, as <strong>jcollado</strong>'s answer shows, but it has lots of performant methods for turning input into bits and manipulating them. You might find this handy (or not), for example:</p>
<pre><code>&gt;&gt;&gt; c.uint
255
&gt;&gt;&gt; c.invert()
&gt;&gt;&gt; c.bin[2:]
'00000000'
</code></pre>
<p>etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>Operations are much faster when you work at the integer level. In particular, converting to a string as suggested here is really slow.</p>
<p>If you want bit 7 and 8 only, use e.g.</p>
<pre><code>val = (byte &gt;&gt; 6) &amp; 3
</code></pre>
<p>(this is: shift the byte 6 bits to the right - dropping them. Then keep only the last two bits <code>3</code> is the number with the first two bits set...)</p>
<p>These can easily be translated into simple CPU operations that are super fast.</p>
</div>
<div class="post-text" itemprop="text">
<p>What about something like this?</p>
<pre><code>&gt;&gt;&gt; bin(int('ff', base=16))
'0b11111111'
</code></pre>
<p>This will convert the hexadecimal string you have to an integer and that integer to a string in which each byte is set to 0/1 depending on the bit-value of the integer.</p>
<p>As pointed out by a comment, if you need to get rid of the <code>0b</code> prefix, you can do it this way:</p>
<pre><code>&gt;&gt;&gt; bin(int('ff', base=16)).lstrip('0b')
11111111
</code></pre>
<p>or this way:</p>
<pre><code>&gt;&gt;&gt; bin(int('ff', base=16))[2:]
11111111
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To binary:</p>
<pre><code>bin(byte)[2:].zfill(8)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think simplest would be use <code>numpy</code> here. For example you can read a file as bytes and then expand it to bits easily like this:</p>
<pre><code>Bytes = numpy.fromfile(filename, dtype = "uint8")
Bits = numpy.unpackbits(Bytes)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>ord</code> when reading reading bytes:</p>
<pre><code>byte_binary = bin(ord(f.read(1))) # Add [2:] to remove the "0b" prefix
</code></pre>
<p><strong>Or</strong></p>
<p>Using <code>str.format()</code>:</p>
<pre><code>'{:08b}'.format(ord(f.read(1)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here how to do it using  <code>format()</code> </p>
<pre><code>print "bin_signedDate : ", ''.join(format(x, '08b') for x in bytevector)
</code></pre>
<blockquote>
<p>It is important the <strong>08b</strong> . That means it will be a maximum of 8 leading zeros be appended to complete a byte. If you don't specify this then the format will just have a variable bit length for each converted byte.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The other answers here provide the bits in <a href="https://en.wikipedia.org/wiki/Endianness" rel="nofollow noreferrer">big-endian</a> order (<code>'\x01'</code> becomes <code>'00000001'</code>)</p>
<p>In case you're interested in little-endian order of bits, which is useful in many cases, like common representations of bignums etc -
here's a snippet for that:</p>
<pre><code>def bits_little_endian_from_bytes(s):
    return ''.join(bin(ord(x))[2:].rjust(8,'0')[::-1] for x in s)
</code></pre>
<p>And for the other direction:</p>
<pre><code>def bytes_from_bits_little_endian(s):
    return ''.join(chr(int(s[i:i+8][::-1], 2)) for i in range(0, len(s), 8))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>using python <a href="https://docs.python.org/3/library/string.html#format-string-syntax" rel="nofollow noreferrer" title="format string">format string syntax</a></p>
<pre><code>&gt;&gt;&gt; mybyte = bytes.fromhex("0F") # create my byte using a hex string
&gt;&gt;&gt; binary_string = "{:08b}".format(int(mybyte.hex(),16))
&gt;&gt;&gt; print(binary_string)
00001111
</code></pre>
<p>The second line is where the magic happens. All byte objects have a <code>.hex()</code> function, which returns a hex string. Using this hex string, we convert it to an integer, telling the <code>int()</code> function that it's a base 16 string (because hex is base 16). Then we apply formatting to that integer so it displays as a binary string. The <code>{:08b}</code> is where the real magic happens. It is using the <a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" rel="nofollow noreferrer">Format Specification Mini-Language</a> <code>format_spec</code>. Specifically it's using the <code>width</code> and the <code>type</code> parts of the format_spec syntax. The <code>8</code> sets <code>width</code> to 8, which is how we get the nice 0000 padding, and the <code>b</code> sets the type to binary.</p>
<p>I prefer this method over the <code>bin()</code> method because using a format string gives a lot more flexibility.</p>
</div>
<span class="comment-copy">Bytes are bits, just 8 at a time ;) - The answer depends on what you want to do, please be more specific Also bit-manipulation is mostly done on byte level...</span>
<span class="comment-copy">I want to represent the bytes in the form a bit string so that I can do something like: field1 = bit_string[0:1] field2 = bit_string[1:16] and so on</span>
<span class="comment-copy">+1. And for the latest version of bitstring (3.0) you don't need to strip the leading <code>0b</code>.</span>
<span class="comment-copy">lstrip('-0b') # remove leading zeros and minus sign</span>
<span class="comment-copy">@ahoffer Thanks for your comment. I've updated my answer to let the OP know how to remove the <code>0b</code> prefix.</span>
<span class="comment-copy">Note that <code>lstrip('0b')</code> will also remove, say, <code>00bb</code> since the argument to <code>lstrip</code> is a <i>set</i> of characters to remove. It'll work fine in this case, but I prefer the <code>[2:]</code> solution since it's more explicit.</span>
<span class="comment-copy">@MartinGeisler Yes, <code>bin</code> leading zeros are already removed when converting to an integer, but it's worth to note that <code>lstrip</code> removes a set of characters, not a prefix.</span>
<span class="comment-copy">You can't convert a byte using bin.</span>
