<div class="post-text" itemprop="text">
<p>Is there a short way to call a function twice or more consecutively in  python? For example:</p>
<pre><code>do()
do()
do()
</code></pre>
<p>maybe like :</p>
<pre><code>3*do()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would:</p>
<pre><code>for _ in range(3):
    do()
</code></pre>
<p>The <code>_</code> is convention for a variable whose value you don't care about.</p>
<p>You might also see some people write:</p>
<pre><code>[do() for _ in range(3)]
</code></pre>
<p>however that is slightly more expensive because it creates a list containing the return values of each invocation of <code>do()</code> (even if it's <code>None</code>), and then throws away the resulting list. I wouldn't suggest using this unless you <em>are</em> using the list of return values.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could define a function that repeats the passed function N times. </p>
<pre><code>def repeat_fun(times, f):
    for i in range(times): f()
</code></pre>
<p>If you want to make it even more flexible, you can even pass arguments to the function being repeated:</p>
<pre><code>def repeat_fun(times, f, *args):
    for i in range(times): f(*args)
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; def do():
...   print 'Doing'
... 
&gt;&gt;&gt; def say(s):
...   print s
... 
&gt;&gt;&gt; repeat_fun(3, do)
Doing
Doing
Doing
&gt;&gt;&gt; repeat_fun(4, say, 'Hello!')
Hello!
Hello!
Hello!
Hello!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple for loop?</p>
<pre><code>for i in range(3):
  do()
</code></pre>
<p>Or, if you're interested in the results and want to collect them, with the bonus of being a 1 liner:</p>
<pre><code>vals = [do() for _ in range(3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My two cents:</p>
<pre><code>from itertools import repeat 

list(repeat(f(), x))  # for pure f
[f() for f in repeat(f, x)]  # for impure f
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Three more ways of doing so:</p>
<p>(I) I think using <code>map</code> may also be an option, though is requires generation of an additional list with <code>None</code>s in some cases and always needs a list of arguments:</p>
<pre><code>def do():
    print 'hello world'

l=map(lambda x: do(), range(10))
</code></pre>
<p>(II) <code>itertools</code> contain functions which can be used used to iterate through other functions as well <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow noreferrer">https://docs.python.org/2/library/itertools.html</a></p>
<p>(III) Using lists of functions was not mentioned so far I think (and it is actually the closest in syntax to the one originally discussed) :</p>
<pre><code>it=[do]*10
[f() for f in it]
</code></pre>
<p>Or as a one liner:</p>
<pre><code>[f() for f in [do]*10]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is an approach that doesn't require the use of a <code>for</code> loop or defining an intermediate function or lambda function (and is also a one-liner). The method combines the following two ideas:</p>
<ul>
<li><p>calling the <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter()</code> built-in function</a> with the optional sentinel argument, and</p></li>
<li><p>using the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> recipe</a> for  advancing an iterator <code>n</code> steps (see the recipe for <code>consume()</code>).</p></li>
</ul>
<p>Putting these together, we get:
</p>
<pre><code>next(islice(iter(do, object()), 3, 3), None)
</code></pre>
<p>(The idea to pass <code>object()</code> as the sentinel comes from <a href="https://stackoverflow.com/a/5739258/262819">this</a> accepted Stack Overflow answer.)</p>
<p>And here is what this looks like from the interactive prompt:</p>
<pre><code>&gt;&gt;&gt; def do():
...   print("called")
... 
&gt;&gt;&gt; next(itertools.islice(iter(do, object()), 3, 3), None)
called
called
called
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import repeat, starmap

results = list(starmap(do, repeat((), 3)))
</code></pre>
<p>See the <a href="https://docs.python.org/2.7/library/itertools.html#recipes" rel="nofollow noreferrer">repeatfunc</a> recipe from the itertools module that is actually much more powerful. If you need to just call the method but don't care about the return values you can use it in a for loop:</p>
<pre><code>for _ in starmap(do, repeat((), 3)): pass
</code></pre>
<p>but that's getting ugly.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may try while loop as shown below;</p>
<pre><code>def do1():
    # Do something

def do2(x):
    while x &gt; 0:
        do1()
        x -= 1

do2(5)
</code></pre>
<p>Thus make call the do1 function 5 times.</p>
</div>
<span class="comment-copy">Note that <code>3 * do()</code> is a valid Python expression with a very well defined result: it does multiply the return value of calling <code>do</code> once by 3. It would be possible, however, to write a decorator to enable one to write things such as (3 * do)() - with a variante of the answer at <a href="http://stackoverflow.com/questions/8998997/product-of-two-functions/9001894#9001894" title="product of two functions">stackoverflow.com/questions/8998997/product-of-two-functions/â€¦</a></span>
<span class="comment-copy">I got here because I was wondering if there were a way to do this similar to what you suggested... It is probably not used enough to warrant a new "function calling multiplier operator", though, given that using it instead of a for loop only saves about 17 keystrokes.</span>
<span class="comment-copy">Adding syntactic sugar in a programming language like <code>3*do()</code> is never a good thing. Will cause a lot of problems and issues later, not even mentioning that it has a totally different meaning in this context.</span>
<span class="comment-copy">always interesting to see the different opinions on syntactical sugar..  Some dislike it, others embrace it.   we get the python opinion (well from one voice anyway) above.. meanwhile in ruby you have <code>2.times do {block}</code>  (NOT an attempt to make a 'ruby is better' argument, just noting the differences in how this is viewed by different coding communities)</span>
<span class="comment-copy">I think it's never a good idea to use a list comprehension just to repeat actions</span>
<span class="comment-copy">That's true. I should be more explicit that I'm not actually <i>recommending</i> that.</span>
<span class="comment-copy">Yeah, List Comprehensions are meant to create new lists and should not be used for side-effects.</span>
<span class="comment-copy">If you're interested in an aggregate of the results then a generator comprehension inside the aggregating function (like <code>sum</code> for example) works nicely: <code>sum(do() for _ in range(3))</code> or <code>sum(1 for _ in range(3) if do() &gt; 3)</code> for conditional counting, etc.</span>
<span class="comment-copy">List comprehension has an additional con of creating a list object for nothing.</span>
<span class="comment-copy">for-loop could also be 1 liner: <code>for i in range(3): do()</code></span>
<span class="comment-copy">@julio.alegria one liners are considered bad practice in Python - the style guides clearly recommend against it.</span>
<span class="comment-copy">@Lattyware I know that, I just wanted to show that a for-loop can also have <i>the bonus of being a 1 liner</i></span>
<span class="comment-copy">why are one-liners considered as bad practice?</span>
<span class="comment-copy">@alwbtc They are less clear to the reader - which is one of the primary considerations of python's style guidelines, along with being harder to add to later. See <a href="http://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">python.org/dev/peps/pep-0008</a></span>
<span class="comment-copy">Could you elaborate a bit on the difference between pure and impure in this context ?</span>
<span class="comment-copy">sure -- say you have an 'impure' function that just prints and does nothing else: if you want it to print x times you'd use the second approach; the first would only lead to one printing. On the other hand, if you have a pure function, which executes no side effects, you could use either approach, but the first would only result in one application of the function, which could be significantly cheaper.</span>
<span class="comment-copy">wow that is some modern art right there</span>
