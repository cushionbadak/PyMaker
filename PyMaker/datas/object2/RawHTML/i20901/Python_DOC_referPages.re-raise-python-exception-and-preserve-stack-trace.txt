<div class="post-text" itemprop="text">
<p>I'm trying to catch an exception in a thread and re-raise it in the main thread:</p>
<pre class="lang-py prettyprint-override"><code>import threading
import sys

class FailingThread(threading.Thread):
    def run(self):
        try:
            raise ValueError('x')
        except ValueError:
            self.exc_info = sys.exc_info()

failingThread = FailingThread()
failingThread.start()
failingThread.join()

print failingThread.exc_info
raise failingThread.exc_info[1]
</code></pre>
<p>This basically works and yields the following output:</p>
<pre><code>(&lt;type 'exceptions.ValueError'&gt;, ValueError('x',), &lt;traceback object at 0x1004cc320&gt;)
Traceback (most recent call last):
  File "test.py", line 16, in &lt;module&gt;
    raise failingThread.exc_info[1]
</code></pre>
<p>However, the source of the exception points to line 16, where the re-raise occurred. The original exception comes from line 7. How do I have to modify the <em>main</em> thread so that the output reads:</p>
<pre><code>Traceback (most recent call last):
  File "test.py", line 7, in &lt;module&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2 you need to use all three arguments to raise:</p>
<pre><code>raise failingThread.exc_info[0], failingThread.exc_info[1], failingThread.exc_info[2]
</code></pre>
<p>passing the traceback object in as the third argument preserves the stack.</p>
<p>From <code>help('raise')</code>:</p>
<blockquote>
<p>If a third object is present and not <code>None</code>, it must be a traceback
  object (see section <em>The standard type hierarchy</em>), and it is
  substituted instead of the current location as the place where the
  exception occurred.  If the third object is present and not a
  traceback object or <code>None</code>, a <code>TypeError</code> exception is raised. The
  three-expression form of <code>raise</code> is useful to re-raise an exception
  transparently in an except clause, but <code>raise</code> with no expressions
  should be preferred if the exception to be re-raised was the most
  recently active exception in the current scope.</p>
</blockquote>
<p>In this particular case you cannot use the no expression version.</p>
<p>For Python 3 (as per the comments):</p>
<pre><code>raise failingThread.exc_info[1].with_traceback(failingThread.exc_info[2])
</code></pre>
<p>or you can simply chain the exceptions using <code>raise ... from ...</code> but that raises a chained exception with the original context attached in the <strong>cause</strong> attribute and that may or may not be what you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>This code snippet works in both python 2 &amp; 3:</p>
<pre><code>      1 try:
----&gt; 2     raise KeyError('Default key error message')
      3 except KeyError as e:
      4     e.args = ('Custom message when get re-raised',) #The comma is not a typo, it's there to indicate that we're replacing the tuple that e.args pointing to with another tuple that contain the custom message.
      5     raise
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Could you write it somewhat like this:</p>
<pre><code>try:
    raise ValueError('x')
except ValueError as ex:
    self.exc_info = ex
</code></pre>
<p>and then use the stacktrace from the exception?</p>
</div>
<span class="comment-copy">awesome, I've been re-raising exceptions from other threads too, but never went as far you want to :)</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/1350671/inner-exception-with-traceback-in-python">"Inner exception" (with traceback) in Python?</a></span>
<span class="comment-copy">Note: this doesn't work in python 3.</span>
<span class="comment-copy">@AndyHayden Indeed, in Python 3 <a href="http://docs.python.org/3/reference/simple_stmts.html#the-raise-statement" rel="nofollow noreferrer">raise</a> would have to be called somehow like <code>raise failingThread.exc_info[0](failingThread.exc_info[1]).with_traceback(failingThread.exc_info[2])</code>. Although in Python 3 the <code>raise AnotherError from stored_exception</code> might provide an even better output</span>
<span class="comment-copy">correction, the first one should be <code>raise failingThread.exc_info[1].with_traceback(failingThread.exc_info[2])</code> as per <a href="http://stackoverflow.com/questions/18188563/how-to-re-raise-an-exception-in-nested-try-except-blocks/18188660?noredirect=1#comment26654548_18188660">this comment</a></span>
<span class="comment-copy">@TobiasKienzler Would you mind either extrapolating your highly upvoted comments into a new answer <i>or</i> editing them into the current answer? In the post-Python 2 era, Python 2-only solutions are sadly obsolete.</span>
<span class="comment-copy">@CecilCurry Good suggestion, I updated my answer. Surely though you have enough privilege you could have just edited it directly?</span>
<span class="comment-copy">Why the downvote?</span>
<span class="comment-copy">I can guess why the downvote. This solution is only valid if there wasn't any exception handling. Imagine that upon catching the exception you try to update a status in the db and that fails as well. In that case the exception that will be raised is the last one (db transaction failed) and not the one we initially caught.</span>
