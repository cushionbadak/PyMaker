<div class="post-text" itemprop="text">
<p>I have this <code>try</code> block in my code:</p>
<pre><code>try:
    do_something_that_might_raise_an_exception()
except ValueError as err:
    errmsg = 'My custom error message.'
    raise ValueError(errmsg)
</code></pre>
<p>Strictly speaking, I am actually raising <em>another</em> <code>ValueError</code>, not the <code>ValueError</code> thrown by <code>do_something...()</code>, which is referred to as <code>err</code> in this case. How do I attach a custom message to <code>err</code>? I try the following code but fails due to <code>err</code>, a <code>ValueError</code> <strong>instance</strong>, not being callable:</p>
<pre><code>try:
    do_something_that_might_raise_an_exception()
except ValueError as err:
    errmsg = 'My custom error message.'
    raise err(errmsg)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Update: <strong>For Python 3, check <a href="https://stackoverflow.com/a/29442282/42223">Ben's answer</a></strong></p>
<hr/>
<p>To attach a message to the current exception and re-raise it:
(the outer try/except is just to show the effect)</p>
<p>For python 2.x where x&gt;=6:</p>
<pre><code>try:
    try:
      raise ValueError  # something bad...
    except ValueError as err:
      err.message=err.message+" hello"
      raise              # re-raise current exception
except ValueError as e:
    print(" got error of type "+ str(type(e))+" with message " +e.message)
</code></pre>
<p>This will also do the right thing <strong>if <code>err</code> is <em>derived</em></strong> from <code>ValueError</code>. For example <code>UnicodeDecodeError</code>. </p>
<p>Note that you can add whatever you like to <code>err</code>. For example <code>err.problematic_array=[1,2,3]</code>.</p>
<hr/>
<p><strong>Edit:</strong> @Ducan points in a comment the above does not work with python 3 since <code>.message</code> is not a member of <code>ValueError</code>. Instead you could use this (valid python 2.6 or later or 3.x):</p>
<pre><code>try:
    try:
      raise ValueError
    except ValueError as err:
       if not err.args: 
           err.args=('',)
       err.args = err.args + ("hello",)
       raise 
except ValueError as e:
    print(" error was "+ str(type(e))+str(e.args))
</code></pre>
<p><strong>Edit2:</strong></p>
<p>Depending on what the purpose is, you can also opt for adding the extra information under your own variable name. For both python2 and python3:</p>
<pre><code>try:
    try:
      raise ValueError
    except ValueError as err:
       err.extra_info = "hello"
       raise 
except ValueError as e:
    print(" error was "+ str(type(e))+str(e))
    if 'extra_info' in dir(e):
       print e.extra_info
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I realize this question has been around for awhile, but once you're lucky enough to only support python 3.x, this really becomes a thing of beauty :)</p>
<h3>raise from</h3>
<p>We can chain the exceptions using <a href="https://docs.python.org/3/reference/simple_stmts.html#raise">raise from</a>.</p>
<pre class="lang-python prettyprint-override"><code>try:
    1 / 0
except ZeroDivisionError as e:
    raise Exception('Smelly socks') from e
</code></pre>
<p>In this case, the exception your caller would catch has the line number of the place where we raise our exception.</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "test.py", line 2, in &lt;module&gt;
    1 / 0
ZeroDivisionError: division by zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "test.py", line 4, in &lt;module&gt;
    raise Exception('Smelly socks') from e
Exception: Smelly socks
</code></pre>
<p>Notice the bottom exception only has the stacktrace from where we raised our exception. Your caller could still get the original exception by accessing the <code>__cause__</code> attribute of the exception they catch.</p>
<h3>with_traceback</h3>
<p>Or you can use <a href="https://docs.python.org/3/library/exceptions.html#BaseException.with_traceback">with_traceback</a>.</p>
<pre class="lang-python prettyprint-override"><code>try:
    1 / 0
except ZeroDivisionError as e:
    raise Exception('Smelly socks').with_traceback(e.__traceback__)
</code></pre>
<p>Using this form, the exception your caller would catch has the traceback from where the original error occurred.</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "test.py", line 2, in &lt;module&gt;
    1 / 0
ZeroDivisionError: division by zero

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "test.py", line 4, in &lt;module&gt;
    raise Exception('Smelly socks').with_traceback(e.__traceback__)
  File "test.py", line 2, in &lt;module&gt;
    1 / 0
Exception: Smelly socks
</code></pre>
<p>Notice the bottom exception has the line where we performed the invalid division as well as the line where we reraise the exception.</p>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-python prettyprint-override"><code>try:
    try:
        int('a')
    except ValueError as e:
        raise ValueError('There is a problem: {0}'.format(e))
except ValueError as err:
    print err
</code></pre>
<p>prints:</p>
<pre class="lang-none prettyprint-override"><code>There is a problem: invalid literal for int() with base 10: 'a'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems all the answers are adding info to e.args[0], thereby altering the existing error message.  Is there a downside to extending the args tuple instead?  I think the possible upside is, you can leave the original error message alone for cases where parsing that string is needed; and you could add multiple elements to the tuple if your custom error handling produced several messages or error codes, for cases where the traceback would be parsed programmatically (like via a system monitoring tool).</p>
<pre><code>## Approach #1, if the exception may not be derived from Exception and well-behaved:

def to_int(x):
    try:
        return int(x)
    except Exception as e:
        e.args = (e.args if e.args else tuple()) + ('Custom message',)
        raise

&gt;&gt;&gt; to_int('12')
12

&gt;&gt;&gt; to_int('12 monkeys')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in to_int
ValueError: ("invalid literal for int() with base 10: '12 monkeys'", 'Custom message')
</code></pre>
<p>or</p>
<pre><code>## Approach #2, if the exception is always derived from Exception and well-behaved:

def to_int(x):
    try:
        return int(x)
    except Exception as e:
        e.args += ('Custom message',)
        raise

&gt;&gt;&gt; to_int('12')
12

&gt;&gt;&gt; to_int('12 monkeys')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in to_int
ValueError: ("invalid literal for int() with base 10: '12 monkeys'", 'Custom message')
</code></pre>
<p>Can you see a downside to this approach?</p>
</div>
<div class="post-text" itemprop="text">
<p>This code template should allow you to raise an exception with a custom message.</p>
<pre><code>try:
     raise ValueError
except ValueError as err:
    raise type(err)("my message")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the function I use to modify the exception message in Python 2.7 and 3.x while preserving the original traceback. It requires <a href="https://pypi.python.org/pypi/six" rel="nofollow"><code>six</code></a></p>
<pre><code>def reraise_modify(caught_exc, append_msg, prepend=False):
    """Append message to exception while preserving attributes.

    Preserves exception class, and exception traceback.

    Note:
        This function needs to be called inside an except because
        `sys.exc_info()` requires the exception context.

    Args:
        caught_exc(Exception): The caught exception object
        append_msg(str): The message to append to the caught exception
        prepend(bool): If True prepend the message to args instead of appending

    Returns:
        None

    Side Effects:
        Re-raises the exception with the preserved data / trace but
        modified message
    """
    ExceptClass = type(caught_exc)
    # Keep old traceback
    traceback = sys.exc_info()[2]
    if not caught_exc.args:
        # If no args, create our own tuple
        arg_list = [append_msg]
    else:
        # Take the last arg
        # If it is a string
        # append your message.
        # Otherwise append it to the
        # arg list(Not as pretty)
        arg_list = list(caught_exc.args[:-1])
        last_arg = caught_exc.args[-1]
        if isinstance(last_arg, str):
            if prepend:
                arg_list.append(append_msg + last_arg)
            else:
                arg_list.append(last_arg + append_msg)
        else:
            arg_list += [last_arg, append_msg]
    caught_exc.args = tuple(arg_list)
    six.reraise(ExceptClass,
                caught_exc,
                traceback)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 built-in exceptions have the <code>strerror</code> field:</p>
<pre><code>except ValueError as err:
  err.strerror = "New error message"
  raise err
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Either raise the new exception with your error message using</p>
<pre><code>raise Exception('your error message')
</code></pre>
<p>or</p>
<pre><code>raise ValueError('your error message')
</code></pre>
<p>within the place where you want to raise it OR attach (replace) error message into current exception using 'from':</p>
<pre><code>except ValueError as e:
  raise ValueError('your message') from e
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The current answer did not work good for me, if the exception is not re-caught the appended message is not shown.</p>
<p>But doing like below both keeps the trace and shows the appended message regardless if the exception is re-caught or not.</p>
<pre><code>try:
  raise ValueError("Original message")
except ValueError as err:
  t, v, tb = sys.exc_info()
  raise t, ValueError(err.message + " Appended Info"), tb
</code></pre>
<p>( I used Python 2.7, have not tried it in Python 3 )</p>
</div>
<div class="post-text" itemprop="text">
<p>if you want to custom the error type, a simple thing you can do is to define an error class based on ValueError.</p>
</div>
<span class="comment-copy">@Hamish, attaching additional information and re-raising exceptions can be very helpful when debugging.</span>
<span class="comment-copy">@Johan Absolutely - and that's what a stacktrace is for. Can't quite understand why you'd edit the existing error message instead of raising a new error.</span>
<span class="comment-copy">@Hamish. Sure but you can add other stuff. For your question, have a look at my answer and the example of UnicodeDecodeError. If you have comments on that perhaps comment my answer instead.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/6062576/adding-information-to-an-exception">Adding information to an exception?</a></span>
<span class="comment-copy">Since you've gone to the effort of using Python 3 style exception handling and <code>print</code>, you should probably note that your code doesn't work in Python 3.x as there is no <code>message</code> attribute on exceptions. <code>err.args = (err.args[0] + " hello",) + err.args[1:]</code> may work more reliably (and then just convert to a string to get the message).</span>
<span class="comment-copy">Unfortunately there's no guarantee that args[0] is a string type representing an error message - "The tuple of arguments given to the exception constructor. Some built-in exceptions (like IOError) expect a certain number of arguments and assign a special meaning to the elements of this tuple, while others are usually called only with a single string giving an error message.". So the code won't work arg[0] is not an error message (it could be an int, or it could be a string representing a file name).</span>
<span class="comment-copy">@Taras, Interesting. Do you have a reference on that? Then I would add to a completely new member: err.my_own_extra_info. Or encapsulate it all in my own exception keeping the new and the original information.</span>
<span class="comment-copy">A real example of when args[0] isn't an error message - <a href="http://docs.python.org/2/library/exceptions.html" rel="nofollow noreferrer">docs.python.org/2/library/exceptions.html</a> - "exception EnvironmentError The base class for exceptions that can occur outside the Python system: IOError, OSError. When exceptions of this type are created with a 2-tuple, the first item is available on the instanceâ€™s errno attribute (it is assumed to be an error number), and the second item is available on the strerror attribute (it is usually the associated error message). The tuple itself is also available on the args attribute."</span>
<span class="comment-copy">I don't understand this at all. The only reason setting the <code>.message</code> attribute does anything here is that this attribute is <i>explicitly</i> printed. If you were to raise the exception without catching and printing, you would <i>not</i> see the <code>.message</code> attribute do anything useful.</span>
<span class="comment-copy">Is it possible to add a custom message to an exception without the additional traceback? For example, can <code>raise Exception('Smelly socks') from e</code> be modified to just add "Smelly socks" as a comment to the original traceback rather than introducing a new traceback of its own.</span>
<span class="comment-copy">That's the behavior you'll get from Johan Lundberg's answer</span>
<span class="comment-copy">this is really lovely.  Thank you.</span>
<span class="comment-copy">Re-raising a new exception or chain raising exceptions with new messages creates more confusion than needed in many cases. By itself exceptions are complex to handle. A better strategy is to just append your message to the argument of the original exception if possible as in err.args  += ("message",) and re-raise the exception message. The traceback might not take you to the line numbers where the exception was caught but it will take you to where the exception occurred for sure.</span>
<span class="comment-copy">I was wondering if there was a Python idiom for what I'm trying to do, other than raising <i>another</i> instance.</span>
<span class="comment-copy">@Kit - I would call it 're-raising an exception': <a href="http://docs.python.org/reference/simple_stmts.html#raise" rel="nofollow noreferrer">docs.python.org/reference/simple_stmts.html#raise</a></span>
<span class="comment-copy">@eumiro, No you are making a new exception. See my answer. From your link: "... but raise with no expressions should be preferred if the exception to be re-raised was the most recently active exception in the current scope."</span>
<span class="comment-copy">@JohanLundberg - <code>raise</code> without parameters is re-raising. If OP wants to add a message, he has to raise a new exception and can re-use the message/type of the original exception.</span>
<span class="comment-copy">If you want to <i>add</i> a message you can not create a new message from scratch by throwing "ValueError". By doing so, you destroy the underlying information of what kind of ValueError it is (similar to slicing in C++). By <i>re-throwing</i> the <i>same</i> exception with raise without an argument, you pass the original object with that correct specific type (derived from ValueError).</span>
<span class="comment-copy">My older answer does not alter e.args[0].</span>
<span class="comment-copy">This does not preserve the stack trace.</span>
<span class="comment-copy">The questioner does not specify that the stack trace be preserved.</span>
<span class="comment-copy">Didn't work for me with Python 3.6.1</span>
<span class="comment-copy">how would that help in this case?</span>
