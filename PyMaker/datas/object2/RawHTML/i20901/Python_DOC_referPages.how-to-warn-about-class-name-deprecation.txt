<div class="post-text" itemprop="text">
<p>I have renamed a python class that is part of a library. I am willing to leave a possibility to use its previous name for some time but would like to warn user that it's deprecated and will be removed in the future.</p>
<p>I think that to provide backward compatibility it will be enough to use an alias like that:</p>
<pre><code>class NewClsName:
    pass

OldClsName = NewClsName
</code></pre>
<p>I have no idea how to mark the <code>OldClsName</code> as deprecated in an elegant way. Maybe I could make <code>OldClsName</code> a function which emits a warning (to logs) and constructs the <code>NewClsName</code> object from its parameters (using <code>*args</code> and <code>**kvargs</code>) but it doesn't seem elegant enough (or maybe it is?).</p>
<p>However, I don't know how Python standard library deprecation warnings work. I imagine that there may be some nice magic to deal with deprecation, e.g. allowing treating it as errors or silencing depending on some interpreter's command line option.</p>
<p>The question is: How to warn users about using an obsolete class alias (or obsolete class in general).</p>
<p><strong>EDIT</strong>: The function approach doesn't work for me (I already gave it a try) because the class has some class methods (factory methods) which can't be called when the <code>OldClsName</code> is defined as a function. Following code won't work:</p>
<pre><code>class NewClsName(object):
    @classmethod
    def CreateVariant1( cls, ... ):
        pass

    @classmethod
    def CreateVariant2( cls, ... ):
        pass

def OldClsName(*args, **kwargs):
    warnings.warn("The 'OldClsName' class was renamed [...]",
                  DeprecationWarning )
    return NewClsName(*args, **kwargs)

OldClsName.CreateVariant1( ... )
</code></pre>
<p>Because of:</p>
<pre><code>AttributeError: 'function' object has no attribute 'CreateVariant1'
</code></pre>
<p>Is inheritance my only option? To be honest, it doesn't look very clean to me - it affects class hierarchy through introduction of unnecessary derivation. Additionally, <code>OldClsName is not NewClsName</code> what is not an issue in most cases but may be a problem in case of poorly written code using the library.</p>
<p>I could also create a dummy, unrelated <code>OldClsName</code> class and implement a constructor as well as wrappers for all class methods in it, but it is even worse solution, in my opinion.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Maybe I could make OldClsName a function which emits a warning (to
  logs) and constructs the NewClsName object from its parameters (using
  *args and **kvargs) but it doesn't seem elegant enough (or maybe it is?).</p>
</blockquote>
<p>Yup, I think that's pretty standard practice:</p>
<pre><code>def OldClsName(*args, **kwargs):
    from warnings import warn
    warn("get with the program!")
    return NewClsName(*args, **kwargs)
</code></pre>
<p>The only tricky thing is if you have things that subclass from <code>OldClsName</code> - then we have to get clever. If you just need to keep access to class methods, this should do it:</p>
<pre><code>class DeprecationHelper(object):
    def __init__(self, new_target):
        self.new_target = new_target

    def _warn(self):
        from warnings import warn
        warn("Get with the program!")

    def __call__(self, *args, **kwargs):
        self._warn()
        return self.new_target(*args, **kwargs)

    def __getattr__(self, attr):
        self._warn()
        return getattr(self.new_target, attr)

OldClsName = DeprecationHelper(NewClsName)
</code></pre>
<p>I haven't tested it, but that should give you the idea - <code>__call__</code> will handle the normal-instantation route, <code>__getattr__</code> will capture accesses to the class methods &amp; still generate the warning, without messing with your class heirarchy.</p>
</div>
<div class="post-text" itemprop="text">
<p>Please have a look at <a href="http://docs.python.org/library/warnings.html#warnings.warn"><code>warnings.warn</code></a>.</p>
<p>As you'll see, the example in the documentation is a deprecation warning:</p>
<pre><code>def deprecation(message):
    warnings.warn(message, DeprecationWarning, stacklevel=2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you just sub-class? This way no user code should be broken.</p>
<pre><code>class OldClsName(NewClsName):
    def __init__(self, *args, **kwargs):
        warnings.warn("The 'OldClsName' class was renamed [...]",
                      DeprecationWarning)
        NewClsName.__init__(*args, **kwargs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>inspect</code> module to add placeholder for <code>OldClass</code>, then <code>OldClsName is NewClsName</code> check will pass, and a linter like pylint will inform this as error.</p>
<p>deprecate.py</p>
<pre><code>import inspect
import warnings
from functools import wraps

def renamed(old_name):
    """Return decorator for renamed callable.

    Args:
        old_name (str): This name will still accessible,
            but call it will result a warn.

    Returns:
        decorator: this will do the setting about `old_name`
            in the caller's module namespace.
    """

    def _wrap(obj):
        assert callable(obj)

        def _warn():
            warnings.warn('Renamed: {} -&gt; {}'
                        .format(old_name, obj.__name__),
                        DeprecationWarning, stacklevel=3)

        def _wrap_with_warn(func, is_inspect):
            @wraps(func)
            def _func(*args, **kwargs):
                if is_inspect:
                    # XXX: If use another name to call,
                    # you will not get the warning.
                    frame = inspect.currentframe().f_back
                    code = inspect.getframeinfo(frame).code_context
                    if [line for line in code
                            if old_name in line]:
                        _warn()
                else:
                    _warn()
                return func(*args, **kwargs)
            return _func

        # Make old name available.
        frame = inspect.currentframe().f_back
        assert old_name not in frame.f_globals, (
            'Name already in use.', old_name)

        if inspect.isclass(obj):
            obj.__init__ = _wrap_with_warn(obj.__init__, True)
            placeholder = obj
        else:
            placeholder = _wrap_with_warn(obj, False)

        frame.f_globals[old_name] = placeholder

        return obj

    return _wrap
</code></pre>
<p>test.py</p>
<pre><code>from __future__ import print_function

from deprecate import renamed


@renamed('test1_old')
def test1():
    return 'test1'


@renamed('Test2_old')
class Test2(object):
    pass

    def __init__(self):
        self.data = 'test2_data'

    def method(self):
        return self.data

# pylint: disable=undefined-variable
# If not use this inline pylint option, 
# there will be E0602 for each old name.
assert(test1() == test1_old())
assert(Test2_old is Test2)
print('# Call new name')
print(Test2())
print('# Call old name')
print(Test2_old())
</code></pre>
<p>then run <code>python -W all test.py</code>:</p>
<pre><code>test.py:22: DeprecationWarning: Renamed: test1_old -&gt; test1
# Call new name
&lt;__main__.Test2 object at 0x0000000007A147B8&gt;
# Call old name
test.py:27: DeprecationWarning: Renamed: Test2_old -&gt; Test2
&lt;__main__.Test2 object at 0x0000000007A147B8&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is the list of requirements a solution should satisfy:</p>
<ul>
<li>Instantiation of a deprecated class should raise a warning</li>
<li>Subclassing of a deprecated class should raise a warning</li>
<li>Support <code>isinstance</code> and <code>issubclass</code> checks</li>
</ul>
<hr/>
<h2>Solution</h2>
<p>This can be achieved with a custom metaclass:</p>
<pre><code>class DeprecatedClassMeta(type):
    def __new__(cls, name, bases, classdict, *args, **kwargs):
        alias = classdict.get('_DeprecatedClassMeta__alias')

        if alias is not None:
            def new(cls, *args, **kwargs):
                alias = getattr(cls, '_DeprecatedClassMeta__alias')

                if alias is not None:
                    warn("{} has been renamed to {}, the alias will be "
                         "removed in the future".format(cls.__name__,
                             alias.__name__), DeprecationWarning, stacklevel=2)

                return alias(*args, **kwargs)

            classdict['__new__'] = new
            classdict['_DeprecatedClassMeta__alias'] = alias

        fixed_bases = []

        for b in bases:
            alias = getattr(b, '_DeprecatedClassMeta__alias', None)

            if alias is not None:
                warn("{} has been renamed to {}, the alias will be "
                     "removed in the future".format(b.__name__,
                         alias.__name__), DeprecationWarning, stacklevel=2)

            # Avoid duplicate base classes.
            b = alias or b
            if b not in fixed_bases:
                fixed_bases.append(b)

        fixed_bases = tuple(fixed_bases)

        return super().__new__(cls, name, fixed_bases, classdict,
                               *args, **kwargs)

    def __instancecheck__(cls, instance):
        return any(cls.__subclasscheck__(c)
            for c in {type(instance), instance.__class__})

    def __subclasscheck__(cls, subclass):
        if subclass is cls:
            return True
        else:
            return issubclass(subclass, getattr(cls,
                              '_DeprecatedClassMeta__alias'))
</code></pre>
<hr/>
<h2>Explanation</h2>
<p><code>DeprecatedClassMeta.__new__</code> method is called not only for a class it is a metaclass of but also for every subclass of this class. That gives an opportunity to ensure that no instance of <code>DeprecatedClass</code> will ever be instantiated or subclassed.</p>
<p>Instantiation is simple. The metaclass overrides the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a> method of <code>DeprecatedClass</code> to always return an instance of <code>NewClass</code>.</p>
<p>Subclassing is not much harder. <code>DeprecatedClassMeta.__new__</code> receives a list of base classes and needs to replace instances of <code>DeprecatedClass</code> with <code>NewClass</code>.</p>
<p>Finally, the <code>isinstance</code> and <code>issubclass</code> checks are implemented via <code>__instancecheck__</code> and <code>__subclasscheck__</code> defined in <a href="https://www.python.org/dev/peps/pep-3119/" rel="nofollow noreferrer">PEP 3119</a>.</p>
<hr/>
<h2>Test</h2>
<pre><code>class NewClass:
    foo = 1


class NewClassSubclass(NewClass):
    pass


class DeprecatedClass(metaclass=DeprecatedClassMeta):
    _DeprecatedClassMeta__alias = NewClass


class DeprecatedClassSubclass(DeprecatedClass):
    foo = 2


class DeprecatedClassSubSubclass(DeprecatedClassSubclass):
    foo = 3


assert issubclass(DeprecatedClass, DeprecatedClass)
assert issubclass(DeprecatedClassSubclass, DeprecatedClass)
assert issubclass(DeprecatedClassSubSubclass, DeprecatedClass)
assert issubclass(NewClass, DeprecatedClass)
assert issubclass(NewClassSubclass, DeprecatedClass)

assert issubclass(DeprecatedClassSubclass, NewClass)
assert issubclass(DeprecatedClassSubSubclass, NewClass)

assert isinstance(DeprecatedClass(), DeprecatedClass)
assert isinstance(DeprecatedClassSubclass(), DeprecatedClass)
assert isinstance(DeprecatedClassSubSubclass(), DeprecatedClass)
assert isinstance(NewClass(), DeprecatedClass)
assert isinstance(NewClassSubclass(), DeprecatedClass)

assert isinstance(DeprecatedClassSubclass(), NewClass)
assert isinstance(DeprecatedClassSubSubclass(), NewClass)

assert NewClass().foo == 1
assert DeprecatedClass().foo == 1
assert DeprecatedClassSubclass().foo == 2
assert DeprecatedClassSubSubclass().foo == 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In python &gt;= 3.6 you can easily handle warning on subclassing:</p>
<pre><code>class OldClassName(NewClassName):
    def __init_subclass__(self):
        warn("Class has been renamed NewClassName", DeprecationWarning, 2)
</code></pre>
<p>Overloading <code>__new__</code> should allow you to warn when the old class constructor is called directly, but I haven't tested that since I don't need it right now.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.7, you can provide a customization of module attribute access using <code>__getattr__</code> (and <code>__dir__</code>). Everything is explained in <a href="https://www.python.org/dev/peps/pep-0562/" rel="nofollow noreferrer">PEP 562</a>.
In the bellow example, I implemented <code>__getattr__</code> and <code>__dir__</code> in order to deprecate the “OldClsName” in favor of “NewClsNam”:</p>
<pre class="lang-py prettyprint-override"><code># your_lib.py

import warnings

__all__ = ["NewClsName"]

DEPRECATED_NAMES = [('OldClsName', 'NewClsName')]


class NewClsName:
    @classmethod
    def create_variant1(cls):
        return cls()


def __getattr__(name):
    for old_name, new_name in DEPRECATED_NAMES:
        if name == old_name:
            warnings.warn(f"The '{old_name}' class or function is renamed '{new_name}'",
                          DeprecationWarning,
                          stacklevel=2)
            return globals()[new_name]
    raise AttributeError(f"module {__name__} has no attribute {name}")


def __dir__():
    return sorted(__all__ + [names[0] for names in DEPRECATED_NAMES])
</code></pre>
<p>In the <code>__getattr__</code> function, if a deprecated class or function name is found, a warning message is emitted, showing the source file and line number of the caller (with <code>stacklevel=2</code>).</p>
<p>In the user code, we could have:</p>
<pre class="lang-py prettyprint-override"><code># your_lib_usage.py
from your_lib import NewClsName
from your_lib import OldClsName


def use_new_class():
    obj = NewClsName.create_variant1()
    print(obj.__class__.__name__ + " is created in use_new_class")


def use_old_class():
    obj = OldClsName.create_variant1()
    print(obj.__class__.__name__ + " is created in use_old_class")


if __name__ == '__main__':
    use_new_class()
    use_old_class()
</code></pre>
<p>When the user run his script <code>your_lib_usage.py</code>, it will get something like this:</p>
<pre><code>NewClsName is created in use_new_class
NewClsName is created in use_old_class
/path/to/your_lib_usage.py:3: DeprecationWarning: The 'OldClsName' class or function is renamed 'NewClsName'
  from your_lib import OldClsName
</code></pre>
<p><em>Note:</em> the stack trace is usually written in STDERR.</p>
<p>To see the error warnings, you may need to add a “-W” flag in the Python command line, for instance:</p>
<pre class="lang-sh prettyprint-override"><code>python -W always your_lib_usage.py
</code></pre>
</div>
<span class="comment-copy">Supporting inheritance should be easy as well - just write a <code>class OldClsName(NewClsName): # and overload __new__</code>.</span>
<span class="comment-copy">+1 for confirming that this solution is used and for mentioning the <code>warnings</code> module. Unfortunately the function solution doesn't work for me (see edited question). Maybe you have some other clean solutions? :D</span>
<span class="comment-copy">Updated with an example of using a wrapper object that can proxy both calls &amp; attribute accesses to the new class.</span>
<span class="comment-copy">Ahh, nice, nice. Works perfectly, thank you very much :)</span>
<span class="comment-copy">It will not pass checks sucks as <code>isinstance(NewClsName(), OldClsName)</code> or <code>issubclass(NewClsName, OldClsName)</code>.</span>
<span class="comment-copy">this was about deprecating a class, not deprecating a method/function.</span>
<span class="comment-copy"><code>isinstance()</code> checks ...</span>
<span class="comment-copy"><code>isinstance</code> also checks for subclasses, so this should not break anything if this is what you tried to imply.</span>
<span class="comment-copy"><code>isinstance</code> checks will indeed fail. Consider, you've got legacy code doing <code>isinstance(obj, OldClsName)</code> and new code that instantiates <code>obj = NewClsName()</code> then <code>isinstance(obj, OldClsName) == False</code> and your code breaks: oops.</span>
<span class="comment-copy">@DylanYoung Don't forget <code>issubclass()</code>. You can use <code>__instancecheck__</code> and <code>__subclasscheck__</code> for those.</span>
<span class="comment-copy">this will fail if the bad name is used as a variable name of class instances; eg having <code>self.Test2_old = Test2()</code> in some other class</span>
