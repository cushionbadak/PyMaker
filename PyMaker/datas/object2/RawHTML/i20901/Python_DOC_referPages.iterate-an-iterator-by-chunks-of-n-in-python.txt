<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3992735/python-generator-that-groups-another-iterable-into-groups-of-n">Python generator that groups another iterable into groups of N [duplicate]</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
</ul>
</div>
<p>Can you think of a nice way (maybe with itertools) to split an iterator into chunks of given size?</p>
<p>Therefore <code>l=[1,2,3,4,5,6,7]</code> with <code>chunks(l,3)</code> becomes an iterator <code>[1,2,3], [4,5,6], [7]</code></p>
<p>I can think of a small program to do that but not a nice way with maybe itertools.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>grouper()</code>  recipe from the <code>itertools</code> documentation's <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer">recipes</a> comes close to what you want:</p>
<pre><code>def grouper(n, iterable, fillvalue=None):
    "grouper(3, 'ABCDEFG', 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return izip_longest(fillvalue=fillvalue, *args)
</code></pre>
<p>It will fill up the last chunk with a fill value, though.</p>
<p>A less general solution that only works on sequences but does handle the last chunk as desired is</p>
<pre><code>[my_list[i:i + chunk_size] for i in range(0, len(my_list), chunk_size)]
</code></pre>
<p>Finally, a solution that works on general iterators an behaves as desired is</p>
<pre><code>def grouper(n, iterable):
    it = iter(iterable)
    while True:
       chunk = tuple(itertools.islice(it, n))
       if not chunk:
           return
       yield chunk
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although OP asks function to return chunks as list or tuple, in case you need to return iterators, then <a href="https://stackoverflow.com/users/279627/sven-marnach">Sven Marnach's</a> solution can be modified:</p>
<pre><code>def grouper_it(n, iterable):
    it = iter(iterable)
    while True:
        chunk_it = itertools.islice(it, n)
        try:
            first_el = next(chunk_it)
        except StopIteration:
            return
        yield itertools.chain((first_el,), chunk_it)
</code></pre>
<p>Some benchmarks: <a href="http://pastebin.com/YkKFvm8b" rel="noreferrer">http://pastebin.com/YkKFvm8b</a></p>
<p>It will be slightly more efficient only if your function iterates through elements in every chunk. </p>
</div>
<div class="post-text" itemprop="text">
<p>This will work on any iterable. It returns generator of generators (for full flexibility). I now realize that it's basically the same as @reclosedevs solution, but without the fluff. No need for <code>try...except</code> as the <code>StopIteration</code> propagates up, which is what we want.  </p>
<p>The <code>next(iterable)</code> call is needed to raise the <code>StopIteration</code> when the iterable is empty, since <code>islice</code> will continue spawning empty generators forever if you let it.</p>
<p>It's better because it's only two lines long, yet easy to comprehend. </p>
<pre><code>def grouper(iterable, n):
    while True:
        yield itertools.chain((next(iterable),), itertools.islice(iterable, n-1))
</code></pre>
<p>Note that <code>next(iterable)</code> is put into a tuple. Otherwise, if <code>next(iterable)</code> itself were iterable, then <code>itertools.chain</code> would flatten it out. Thanks to Jeremy Brown for pointing out this issue.</p>
</div>
<div class="post-text" itemprop="text">
<p>I was working on something today and came up with what I think is a simple solution. It is similar to <a href="https://stackoverflow.com/a/8991749/1660046">jsbueno's</a> answer, but I believe his would yield empty <code>group</code>s when the length of <code>iterable</code> is divisible by <code>n</code>. My answer does a simple check when the <code>iterable</code> is exhausted.</p>
<pre><code>def chunk(iterable, chunk_size):
    """Generate sequences of `chunk_size` elements from `iterable`."""
    iterable = iter(iterable)
    while True:
        chunk = []
        try:
            for _ in range(chunk_size):
                chunk.append(iterable.next())
            yield chunk
        except StopIteration:
            if chunk:
                yield chunk
            break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one that returns lazy chunks; use <code>map(list, chunks(...))</code> if you want lists.</p>
<pre><code>from itertools import islice, chain
from collections import deque

def chunks(items, n):
    items = iter(items)
    for first in items:
        chunk = chain((first,), islice(items, n-1))
        yield chunk
        deque(chunk, 0)

if __name__ == "__main__":
    for chunk in map(list, chunks(range(10), 3)):
        print chunk

    for i, chunk in enumerate(chunks(range(10), 3)):
        if i % 2 == 1:
            print "chunk #%d: %s" % (i, list(chunk))
        else:
            print "skipping #%d" % i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A succinct implementation is:</p>
<pre><code>chunker = lambda iterable, n: (ifilterfalse(lambda x: x == (), chunk) for chunk in (izip_longest(*[iter(iterable)]*n, fillvalue=())))
</code></pre>
<p>This works because <code>[iter(iterable)]*n</code> is a list containing the same iterator n times; zipping over that takes one item from each iterator in the list, <em>which is the same iterator</em>, with the result that each zip-element contains a group of <code>n</code> items. </p>
<p><code>izip_longest</code> is needed to fully consume the underlying iterable, rather than iteration stopping when the first exhausted iterator is reached, which chops off any remainder from <code>iterable</code>. This results in the need to filter out the fill-value. A slightly more robust implementation would therefore be:</p>
<pre><code>def chunker(iterable, n):
    class Filler(object): pass
    return (ifilterfalse(lambda x: x is Filler, chunk) for chunk in (izip_longest(*[iter(iterable)]*n, fillvalue=Filler)))
</code></pre>
<p>This guarantees that the fill value is never an item in the underlying iterable. Using the definition above:</p>
<pre><code>iterable = range(1,11)

map(tuple,chunker(iterable, 3))
[(1, 2, 3), (4, 5, 6), (7, 8, 9), (10,)]

map(tuple,chunker(iterable, 2))
[(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]

map(tuple,chunker(iterable, 4))
[(1, 2, 3, 4), (5, 6, 7, 8), (9, 10)]
</code></pre>
<hr/>
<p>This implementation almost does what you want, but it has issues:</p>
<pre><code>def chunks(it, step):
  start = 0
  while True:
    end = start+step
    yield islice(it, start, end)
    start = end
</code></pre>
<p>(The difference is that because <code>islice</code> does not raise StopIteration or anything else on calls that go beyond the end of <code>it</code> this will yield forever; there is also the slightly tricky issue that the <code>islice</code> results must be consumed before this generator is iterated).</p>
<p>To generate the moving window functionally:</p>
<pre><code>izip(count(0, step), count(step, step))
</code></pre>
<p>So this becomes:</p>
<pre><code>(it[start:end] for (start,end) in izip(count(0, step), count(step, step)))
</code></pre>
<p>But, that still creates an infinite iterator. So, you need takewhile (or perhaps something else might be better) to limit it:</p>
<pre><code>chunk = lambda it, step: takewhile((lambda x: len(x) &gt; 0), (it[start:end] for (start,end) in izip(count(0, step), count(step, step))))

g = chunk(range(1,11), 3)

tuple(g)
([1, 2, 3], [4, 5, 6], [7, 8, 9], [10])
</code></pre>
<hr/>
</div>
<div class="post-text" itemprop="text">
<p>"Simpler is better than complex" -
a straightforward generator a few lines long can do the job. Just place it in some utilities module or so:</p>
<pre><code>def grouper (iterable, n):
    iterable = iter(iterable)
    count = 0
    group = []
    while True:
        try:
            group.append(next(iterable))
            count += 1
            if count % n == 0:
                yield group
                group = []
        except StopIteration:
            yield group
            break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I forget where I found the inspiration for this.  I've modified it a little to work with MSI GUID's in the Windows Registry:</p>
<pre><code>def nslice(s, n, truncate=False, reverse=False):
    """Splits s into n-sized chunks, optionally reversing the chunks."""
    assert n &gt; 0
    while len(s) &gt;= n:
        if reverse: yield s[:n][::-1]
        else: yield s[:n]
        s = s[n:]
    if len(s) and not truncate:
        yield s
</code></pre>
<p><code>reverse</code> doesn't apply to your question, but it's something I use extensively with this function.</p>
<pre><code>&gt;&gt;&gt; [i for i in nslice([1,2,3,4,5,6,7], 3)]
[[1, 2, 3], [4, 5, 6], [7]]
&gt;&gt;&gt; [i for i in nslice([1,2,3,4,5,6,7], 3, truncate=True)]
[[1, 2, 3], [4, 5, 6]]
&gt;&gt;&gt; [i for i in nslice([1,2,3,4,5,6,7], 3, truncate=True, reverse=True)]
[[3, 2, 1], [6, 5, 4]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here you go.</p>
<pre><code>def chunksiter(l, chunks):
    i,j,n = 0,0,0
    rl = []
    while n &lt; len(l)/chunks:        
        rl.append(l[i:j+chunks])        
        i+=chunks
        j+=j+chunks        
        n+=1
    return iter(rl)


def chunksiter2(l, chunks):
    i,j,n = 0,0,0
    while n &lt; len(l)/chunks:        
        yield l[i:j+chunks]
        i+=chunks
        j+=j+chunks        
        n+=1
</code></pre>
<h1>Examples:</h1>
<pre><code>for l in chunksiter([1,2,3,4,5,6,7,8],3):
    print(l)

[1, 2, 3]
[4, 5, 6]
[7, 8]

for l in chunksiter2([1,2,3,4,5,6,7,8],3):
    print(l)

[1, 2, 3]
[4, 5, 6]
[7, 8]


for l in chunksiter2([1,2,3,4,5,6,7,8],5):
    print(l)

[1, 2, 3, 4, 5]
[6, 7, 8]
</code></pre>
</div>
<span class="comment-copy">@kindall: This is close, but not the same, due to the handling of the last chunk.</span>
<span class="comment-copy">This is slightly different, as that question was about lists, and this one is more general, iterators.  Although the answer appears to end up being the same.</span>
<span class="comment-copy">@recursive: Yes, after reading the linked thread completely, I found that everything in my answer already appears somwhere in the other thread.</span>
<span class="comment-copy">Thanks for this and all other ideas! Sorry that I missed the numerious threads already discussing this question. I had tried <code>islice</code> but somehow I missed that it indeed soaks up the iterator as desired. Now I'm thinking of defining a custom iterator class which provides all sorts of functionality :)</span>
<span class="comment-copy">Would <code>if chunk: yield chunk</code> be acceptable? it shaves a line off and is as semantic as a single <code>return</code>.</span>
<span class="comment-copy">@barraponto:  No, it wouldn't be acceptable, since you would be left with an infinite loop.</span>
<span class="comment-copy">I am surprised that this is such a highly-voted answer. The recipe works great for small <code>n</code>, but for large groups, is very inefficient. My n, e.g., is 200,000. Creating a temporary list of 200K items is...not ideal.</span>
<span class="comment-copy">@JonathanEunice: In almost all cases, this is what people want (which is the reason why it is included in the Python documentation). Optimising for a particular special case is out of scope for this question, and even with the information you included in your comment, I can't tell what the best approach would be for you. If you want to chunk a list of numbers that fits into memory, you are probably best off using NumPy's <code>.resize()</code> message. If you want to chunk a general iterator, the second approach is already quite good -- it creates temporary tuples of size 200K, but that's not a big deal.</span>
<span class="comment-copy">I arrived at almost exactly this design today, after finding the answer in the documentation (which is the accepted, most-highly-voted answer above) <i>massively</i> inefficient. When you're grouping hundreds of thousands or millions of objects at a time--which is when you need segmentation the most--it has to be pretty efficient. THIS is the right answer.</span>
<span class="comment-copy">This is the best solution.</span>
<span class="comment-copy">Won't this behave wrongly if the caller doesn't exhaust <code>chunk_it</code> (by breaking the inner loop early for example)?</span>
<span class="comment-copy">@TavianBarnes good point, if a first group is not exhausted, a second will start where the first left. But it may be considered as a feature if you want the both to be looped concurrently. Powerful but handle with care.</span>
<span class="comment-copy">While that may answer the question including some part of explanation and description might help understand your approach and enlighten us as to why your answer stands out</span>
<span class="comment-copy">Don't just copy your answer to another question. If you need to do that, then it suggests that one is a duplicate of the other, which they are and I voted to close.</span>
<span class="comment-copy">iterable.next() needs to be contained or yielded by an interator for the chain to work properly - eg. yield itertools.chain([iterable.next()], itertools.islice(iterable, n-1))</span>
<span class="comment-copy"><code>next(iterable)</code>, not <code>iterable.next()</code>.</span>
<span class="comment-copy">It might make sense to prefix the while loop with the line <code>iterable = iter(iterable)</code> to turn your <i>iterable</i> into an <i>iterator</i> first. <a href="https://stackoverflow.com/questions/9884132/what-exactly-are-iterator-iterable-and-iteration"><b><i>Iterables</i> do not have a <code>__next__</code> method.</b></a></span>
<span class="comment-copy">Care to comment on how this works.</span>
<span class="comment-copy">A caveat: This generator yields iterables that remain valid only until the next iterable is requested.  When using e.g. <code>list(chunks(range(10), 3))</code>, all iterables will already have been consumed.</span>
<span class="comment-copy">1. The first code snippet contains the line <code>start = end</code>, which doesn't seem to be doing anything, since the next iteration of the loop will start with <code>start = 0</code>.  Moreover, the loop is infinite -- it's <code>while True</code> without any <code>break</code>. 2. What is <code>len</code> in the second code snippet? 3. All other implementations only work for sequences, not for general iterators. 4. The check <code>x is ()</code> relies on an implementation detail of CPython. As an optimisation, the empty tuple is only created once and reused later. This is not guaranteed by the language specification though, so you should use <code>x == ()</code>.</span>
<span class="comment-copy">5. The combination of <code>count()</code> and <code>takewhile()</code> is much more easily implemented using <code>range()</code>.</span>
<span class="comment-copy">@SvenMarnach: I've edited the code and text in response to some of your points. Much-needed proofing.</span>
<span class="comment-copy">That was fast. :) I still have an issue with the first code snippet:  It only works if the yielded slices are consumed.  If the user does not consume them immediately, strange things may happen.  That's why Peter Otten used <code>deque(chunk, 0)</code> to consume them, but that solution has problems as well -- see my comment to his answer.</span>
<span class="comment-copy">I like the last version of <code>chunker()</code>.  As a side note, a nice way to create a unique sentinel is <code>sentinel = object()</code> -- it is guaranteed to be distinct from any other object.</span>
<span class="comment-copy">This answer is close to the one I started with, but not quite: <a href="http://stackoverflow.com/a/434349/246801">stackoverflow.com/a/434349/246801</a></span>
<span class="comment-copy">This only works for sequences, not for general iterables.</span>
<span class="comment-copy">@SvenMarnach: Hi Sven, yes, thank you, you are absolutely correct.  I saw the OP's example which used a list (sequence) and glossed over the wording of the question, assuming they meant sequence.  Thanks for pointing that out, though.  I didn't immediately understand the difference when I saw your comment, but have since looked it up. <code>:)</code></span>
<span class="comment-copy">This only works for sequences, not for general iterables.</span>
