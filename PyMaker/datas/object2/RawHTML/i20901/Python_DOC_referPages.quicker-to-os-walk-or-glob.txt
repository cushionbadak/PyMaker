<div class="post-text" itemprop="text">
<p>I'm messing around with file lookups in python on a large hard disk.  I've been looking at os.walk and glob.  I usually use os.walk as I find it much neater and seems to be quicker (for usual size directories).</p>
<p>Has anyone got any experience with them both and could say which is more efficient?  As I say, glob seems to be slower, but you can use wildcards etc, were as with walk, you have to filter results.  Here is an example of looking up core dumps.</p>
<pre><code>core = re.compile(r"core\.\d*")
for root, dirs, files in os.walk("/path/to/dir/")
    for file in files:
        if core.search(file):
            path = os.path.join(root,file)
            print "Deleting: " + path
            os.remove(path)
</code></pre>
<p>Or</p>
<pre><code>for file in iglob("/path/to/dir/core.*")
    print "Deleting: " + file
    os.remove(file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I made a research on a small cache of web pages in 1000 dirs. The task was to count a total number of files in dirs. The output is:</p>
<pre><code>os.listdir: 0.7268s, 1326786 files found
os.walk: 3.6592s, 1326787 files found
glob.glob: 2.0133s, 1326786 files found
</code></pre>
<p>As you see, <code>os.listdir</code> is quickest of three. And <code>glog.glob</code> is still quicker than <code>os.walk</code> for this task.</p>
<p>The source:</p>
<pre><code>import os, time, glob

n, t = 0, time.time()
for i in range(1000):
    n += len(os.listdir("./%d" % i))
t = time.time() - t
print "os.listdir: %.4fs, %d files found" % (t, n)

n, t = 0, time.time()
for root, dirs, files in os.walk("./"):
    for file in files:
        n += 1
t = time.time() - t
print "os.walk: %.4fs, %d files found" % (t, n)

n, t = 0, time.time()
for i in range(1000):
    n += len(glob.glob("./%d/*" % i))
t = time.time() - t
print "glob.glob: %.4fs, %d files found" % (t, n)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't waste your time for optimization before measuring/profiling. Focus on making your code simple and easy to maintain. </p>
<p>For example, in your code you precompile RE, which does not give you any speed boost, because re module has internal <code>re._cache</code> of precompiled REs.</p>
<ol>
<li>Keep it simple</li>
<li>if it's slow, then profile</li>
<li>once you know exactly what needs to be optimized do some tweaks and always document it</li>
</ol>
<p>Note, that some optimization done several years prior can make code run slower compared to "non-optimized" code. This applies especially for modern JIT based languages.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use os.walk and still use glob-style matching.</p>
<pre><code>for root, dirs, files in os.walk(DIRECTORY):
    for file in files:
        if glob.fnmatch.fnmatch(file, PATTERN):
            print file
</code></pre>
<p>Not sure about speed, but obviously since os.walk is <em>recursive</em>, they do different things.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>*, ?, and character ranges expressed with [] will be correctly matched. This is done by using the os.listdir() and fnmatch.fnmatch() functions</code></p>
<p>I think even with glob you would still have to <code>os.walk</code>, unless you know directly how deep your subdirectory tree is.</p>
<p>Btw. in the <a href="https://docs.python.org/2/library/glob.html#module-glob" rel="nofollow">glob documentation</a> it says:</p>
<blockquote>
<p>"*, ?, and character ranges expressed with [] will be correctly
  matched. This is done by using the os.listdir() and fnmatch.fnmatch()
  functions "</p>
</blockquote>
<p>I would simply go with a </p>
<pre><code>for path, subdirs, files in os.walk(path):
        for name in fnmatch.filter(files, search_str):
            shutil.copy(os.path.join(path,name), dest)
</code></pre>
</div>
<span class="comment-copy">Sounds like premature optimization to me.  I glanced at the source (<a href="http://hg.python.org/cpython/file/d01208ba482f/Lib/glob.py" rel="nofollow noreferrer">hg.python.org/cpython/file/d01208ba482f/Lib/glob.py</a> and <a href="http://hg.python.org/cpython/file/d01208ba482f/Lib/os.py" rel="nofollow noreferrer">hg.python.org/cpython/file/d01208ba482f/Lib/os.py</a>) and see that both functions rely on <code>os.listdir</code> and <code>os.isdir</code>, so my gut tells me you won't gain much one way or the other.  (However, as pointed out in two of the answers below, the <code>os.walk</code> recurses over subdirectories and <code>glob.iglob</code> doesn't, so it doesn't make sense to compare).  If you do end up with a performance issue, profile a couple of approaches.  Otherwise, just write clear code.</span>
<span class="comment-copy">Isn't <code>os.walk</code> lazy (generator) while <code>glob</code> will create a large list in-memory?</span>
<span class="comment-copy">This does not run through the file tree recursively.</span>
<span class="comment-copy"><code>glob.iglob</code> will return a generator, python 2 <a href="https://docs.python.org/2/library/glob.html#glob.iglob" rel="nofollow noreferrer">docs.python.org/2/library/glob.html#glob.iglob</a>, python 3 <a href="https://docs.python.org/3/library/glob.html#glob.iglob" rel="nofollow noreferrer">docs.python.org/3/library/glob.html#glob.iglob</a></span>
<span class="comment-copy">+1 for good advice about when to optimize.</span>
<span class="comment-copy">-1. OP mentioned a "large disk". Also, the code is obviously simple already. Moreover, OP seems to be at the stage of optimizing.  It's a plague on SO to discard questions related to performance with something like "premature optimizations are root of blabla" (which are actually misquotations of Knuth).</span>
<span class="comment-copy">-1 optimization is important in the real (professional) world, where things are often at a very large scale. don't just blindly diss optimization without any rational reason</span>
<span class="comment-copy">Premature optimization IS stupid. It makes code almost always harder to maintain and sometimes even makes it to perform worse. I don't say this is the case, but it may be.</span>
