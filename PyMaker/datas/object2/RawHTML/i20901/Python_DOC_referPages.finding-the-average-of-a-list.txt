<div class="post-text" itemprop="text">
<p>I have to find the average of a list in Python. This is my code so far</p>
<pre><code>l = [15, 18, 2, 36, 12, 78, 5, 6, 9]
print reduce(lambda x, y: x + y, l)
</code></pre>
<p>I've got it so it adds together the values in the list, but I don't know how to make it divide into them?</p>
</div>
<div class="post-text" itemprop="text">
<p>If your reduce is already returning your sum, then all you have left to do is divide.</p>
<pre><code>l = [15, 18, 2, 36, 12, 78, 5, 6, 9]
print reduce(lambda x, y: x + y, l) / len(l)
</code></pre>
<p>though <code>sum(l)/len(l)</code> would be simpler, as you wouldn't need a lambda.</p>
<p>If you want a more exact float result instead of an int then just use <code>float(len(l))</code> instead of <code>len(l)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>l = [15, 18, 2, 36, 12, 78, 5, 6, 9]
sum(l) / float(len(l))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or you could use <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.mean.html" rel="noreferrer">numpy.mean</a>:</p>
<pre><code>l = [15, 18, 2, 36, 12, 78, 5, 6, 9]

import numpy as np
print np.mean(l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A <a href="http://docs.python.org/dev/library/statistics.html#module-statistics">statistics</a> module has been <a href="http://docs.python.org/dev/whatsnew/3.4.html#statistics">added to python 3.4</a>. It has a function to calculate the average called <a href="http://docs.python.org/dev/library/statistics.html#statistics.mean">mean</a>. An example with the list you provided would be:</p>
<pre><code>from statistics import mean
l = [15, 18, 2, 36, 12, 78, 5, 6, 9]
mean(l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why would you use <code>reduce()</code> for this when Python has a perfectly cromulent <code>sum()</code> function?</p>
<pre><code>print sum(l) / float(len(l))
</code></pre>
<p>(The <code>float()</code> is necessary to force Python to do a floating-point division.)</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a statistics library if you are using python &gt;= 3.4</p>
<p><a href="https://docs.python.org/3/library/statistics.html" rel="noreferrer">https://docs.python.org/3/library/statistics.html</a></p>
<p>You may use it's mean method like this. Let's say you have a list of numbers of which you want to find mean:-</p>
<pre><code>list = [11, 13, 12, 15, 17]
import statistics as s
s.mean(list)
</code></pre>
<p>It has other methods too like stdev, variance, mode, harmonic mean, median etc which are too useful.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of casting to float, you can add 0.0 to the sum:</p>
<pre><code>def avg(l):
    return sum(l, 0.0) / len(l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>sum(l) / float(len(l))</code> is the right answer, but just for completeness you can compute an average with a single reduce:</p>
<pre><code>&gt;&gt;&gt; reduce(lambda x, y: x + y / float(len(l)), l, 0)
20.111111111111114
</code></pre>
<p>Note that this can result in a slight rounding error:</p>
<pre><code>&gt;&gt;&gt; sum(l) / float(len(l))
20.111111111111111
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I tried using the options above but didn't work.
Try this: </p>
<p><code>from statistics import mean</code></p>
<pre><code>n = [11, 13, 15, 17, 19]
print(n)
print(mean(n))
</code></pre>
<p>worked on python 3.5</p>
</div>
<div class="post-text" itemprop="text">
<p>I had a similar question to solve in a Udacity´s problems. Instead of a built-in function i coded:</p>
<pre><code>def list_mean(n):

    summing = float(sum(n))
    count = float(len(n))
    if n == []:
        return False
    return float(summing/count)
</code></pre>
<p>Much more longer than usual but for a beginner its quite challenging.</p>
</div>
<div class="post-text" itemprop="text">
<h3>If you wanted to get more than just the mean (aka average) you might check out scipy stats</h3>
<pre><code>from scipy import stats
l = [15, 18, 2, 36, 12, 78, 5, 6, 9]
print(stats.describe(l))

# DescribeResult(nobs=9, minmax=(2, 78), mean=20.11111111111111, 
# variance=572.3611111111111, skewness=1.7791785448425341, 
# kurtosis=1.9422716419666397)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or use <code>pandas</code>'s <code>Series.mean</code> method:</p>
<pre><code>pd.Series(sequence).mean()
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; l = [15, 18, 2, 36, 12, 78, 5, 6, 9]
&gt;&gt;&gt; pd.Series(l).mean()
20.11111111111111
&gt;&gt;&gt; 
</code></pre>
<p>From the docs:</p>
<blockquote>
<p><code>Series.mean(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)</code>¶</p>
</blockquote>
<p>And here is the docs for this:</p>
<blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.mean.html" rel="nofollow noreferrer">https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.mean.html</a></p>
</blockquote>
<p>And the whole documentation:</p>
<blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/10min.html" rel="nofollow noreferrer">https://pandas.pydata.org/pandas-docs/stable/10min.html</a></p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>In order to use <code>reduce</code> for taking a running average, you'll need to track the total but also the total number of elements seen so far.  since that's not a trivial element in the list, you'll also have to pass <code>reduce</code> an extra argument to fold into.  </p>
<pre><code>&gt;&gt;&gt; l = [15, 18, 2, 36, 12, 78, 5, 6, 9]
&gt;&gt;&gt; running_average = reduce(lambda aggr, elem: (aggr[0] + elem, aggr[1]+1), l, (0.0,0))
&gt;&gt;&gt; running_average[0]
(181.0, 9)
&gt;&gt;&gt; running_average[0]/running_average[1]
20.111111111111111
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Both can give you close to similar values on an integer or at least 10 decimal values. But if you are really considering long floating values both can be different. Approach can vary on what you want to achieve.</p>
<pre><code>&gt;&gt;&gt; l = [15, 18, 2, 36, 12, 78, 5, 6, 9]
&gt;&gt;&gt; print reduce(lambda x, y: x + y, l) / len(l)
20
&gt;&gt;&gt; sum(l)/len(l)
20
</code></pre>
<p>Floating values</p>
<pre><code>&gt;&gt;&gt; print reduce(lambda x, y: x + y, l) / float(len(l))
20.1111111111
&gt;&gt;&gt; print sum(l)/float(len(l))
20.1111111111
</code></pre>
<p>@Andrew Clark was correct on his statement.</p>
</div>
<div class="post-text" itemprop="text">
<p>suppose that</p>
<p><code>x = [[-5.01,-5.43,1.08,0.86,-2.67,4.94,-2.51,-2.25,5.56,1.03],
[-8.12,-3.48,-5.52,-3.78,0.63,3.29,2.09,-2.13,2.86,-3.33],
[-3.68,-3.54,1.66,-4.11,7.39,2.08,-2.59,-6.94,-2.26,4.33]]</code></p>
<p>you can notice that <code>x</code> has dimension 3*10 if you need to get the <code>mean</code> to each row you can type this</p>
<pre><code>theMean = np.mean(x1,axis=1)
</code></pre>
<p>don't forget to <code>import numpy as np</code></p>
</div>
<div class="post-text" itemprop="text">
<p>as a beginner, I just coded this:</p>
<pre><code>L = [15, 18, 2, 36, 12, 78, 5, 6, 9]

total = 0

def average(numbers):
    total = sum(numbers)
    total = float(total)
    return total / len(numbers)

print average(L)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>l = [15, 18, 2, 36, 12, 78, 5, 6, 9]

l = map(float,l)
print '%.2f' %(sum(l)/len(l))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>print reduce(lambda x, y: x + y, l)/(len(l)*1.0)
</code></pre>
<p>or like posted previously</p>
<pre><code>sum(l)/(len(l)*1.0)
</code></pre>
<p>The 1.0 is to make sure you get a floating point division</p>
</div>
<div class="post-text" itemprop="text">
<p>Combining a couple of the above answers, I've come up with the following which works with reduce and doesn't assume you have <code>L</code> available inside the reducing function:</p>
<pre><code>from operator import truediv

L = [15, 18, 2, 36, 12, 78, 5, 6, 9]

def sum_and_count(x, y):
    try:
        return (x[0] + y, x[1] + 1)
    except TypeError:
        return (x + y, 2)

truediv(*reduce(sum_and_count, L))

# prints 
20.11111111111111
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I want to add just another approach</p>
<pre><code>import itertools,operator
list(itertools.accumulate(l,operator.add)).pop(-1) / len(l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>numbers = [0,1,2,3]

numbers[0] = input("Please enter a number")

numbers[1] = input("Please enter a second number")

numbers[2] = input("Please enter a third number")

numbers[3] = input("Please enter a fourth number")

print (numbers)

print ("Finding the Avarage")

avarage = int(numbers[0]) + int(numbers[1]) + int(numbers[2]) + int(numbers [3]) / 4

print (avarage)
</code></pre>
</div>
<span class="comment-copy">numpy.mean if you can afford installing numpy</span>
<span class="comment-copy"><code>sum(L) / float(len(L))</code>. handle empty lists in caller code like <code>if not L: ...</code></span>
<span class="comment-copy">please update your post and remove reduce and lambda because people are copying this from the top for bad use-cases. (well, unless you have pressing reason to use them.)</span>
<span class="comment-copy">@mitch: it's not a matter of whether you can afford installing numpy. numpy is a whole word in itself. It's whether you actually need numpy. Installing numpy, a 16mb C extension, for mean calculating would be, well, very impractical, for someone not using it for other things.</span>
<span class="comment-copy">instead of installing the whole numpy package for just avg/mean if using python 3 we can get this thing done using statistic module just by "from statistic import mean"  or if on python 2.7 or less, the statistic module can be downloaded from src:  <a href="https://hg.python.org/cpython/file/default/Lib/statistics.py" rel="nofollow noreferrer">hg.python.org/cpython/file/default/Lib/statistics.py</a>  doc: <a href="https://docs.python.org/dev/library/statistics.html" rel="nofollow noreferrer">docs.python.org/dev/library/statistics.html</a>     and directly used.</span>
<span class="comment-copy">if the list is composed of ints, the the result under python 2 will be an int</span>
<span class="comment-copy">Well, that might be what they want. :)</span>
<span class="comment-copy">as i said, i'm new to this, i was thinking i'd have to make it with a loop or something to count the amount of numbers in it, i didn't realise i could just use the length. this is the first thing i've done with python..</span>
<span class="comment-copy">what if the sum is a massive number that wont fit in int/float ?</span>
<span class="comment-copy">@FooBarUser then you should calc k = 1.0/len(l), and then reduce: reduce(lambda x, y: x + y * k, l)</span>
<span class="comment-copy">If you use <code>from __future__ import division</code>, you can eliminate that ugly <code>float</code>.</span>
<span class="comment-copy">Agreed. <code>float</code> is ugly as hell, just wanted to keep it simpler.</span>
<span class="comment-copy">Another way of eliminate that 'ugly' float: <code>sum(l, 0.0) / len(l)</code></span>
<span class="comment-copy">As a C++ programmer, that is neat as hell and float is not ugly at all!</span>
<span class="comment-copy">In python3, you can just use <code>sum(l) / len(l)</code></span>
<span class="comment-copy">That's strange.  I would have assumed this would be much more efficient, but it appears to take 8 times as long on a random list of floats than simply <code>sum(l)/len(l)</code></span>
<span class="comment-copy">Oh, but <code>np.array(l).mean()</code> is <i>much</i> faster.</span>
<span class="comment-copy">@L.AmberO'Hearn, I just timed it and <code>np.mean(l)</code> and <code>np.array(l).mean</code> are about the same speed, and <code>sum(l)/len(l)</code> is about twice as fast. I used <code>l = list(np.random.rand(1000))</code>, for course both <code>numpy</code> methods become much faster if <code>l</code> is <code>numpy.array</code>.</span>
<span class="comment-copy">well, unless that's the sole reason for installing numpy. installing a 16mb C package of whatever fame for mean calculation looks very strange on this scale.</span>
<span class="comment-copy">but in my mind.there's not need to care about speed in normal condition..</span>
<span class="comment-copy">This is the most elegant answer because it employs a standard library module which is available since python 3.4.</span>
<span class="comment-copy">And it is numerically stabler</span>
<span class="comment-copy">For those of us new to the word <a href="http://nl.urbandictionary.com/define.php?term=cromulent" rel="nofollow noreferrer">'cromulent'</a></span>
<span class="comment-copy">That's really slick.</span>
<span class="comment-copy">That's really sick</span>
<span class="comment-copy">That's clever, wouldn't have thought of it!</span>
<span class="comment-copy">I get that this is just for fun but returning 0 for an empty list may not be the best thing to do</span>
<span class="comment-copy">@JohanLundberg - You could replace the 0 with False as the last argument to <code>reduce()</code> which would give you False for an empty list, otherwise the average as before.</span>
<span class="comment-copy">@AndrewClark why do you force <code>float</code>on <code>len</code>?</span>
<span class="comment-copy">Good. Every other answer didn't notice the empty list hazard!</span>
<span class="comment-copy">i scored +1 because of this little detail</span>
<span class="comment-copy">Returning <code>False</code> (equivalent to the integer <code>0</code>) is just about the worst possible way to handle this error. Better to catch the <code>ZeroDivisionError</code> and raise something better (perhaps <code>ValueError</code>).</span>
<span class="comment-copy">@kindall how is a <code>ValueError</code> any better than a <code>ZeroDivisionError</code>? The latter is more specific, plus it seems a bit unnecessary to catch an arithmetic error only to re-throw a different one.</span>
<span class="comment-copy">Because <code>ZeroDivisionError</code> is only useful if you know how the calculation is being done (i.e., that a division by the length of the list is involved). If you don't know that, it doesn't tell you what the problem is with the value you passed in. Whereas your new exception can include that more specific information.</span>
<span class="comment-copy">interesting but that's not what he asked for.</span>
<span class="comment-copy">Can you provide a description not just code?</span>
<span class="comment-copy">Inefficient. It converts all elements to float before adding them. It's faster to convert just the length.</span>
<span class="comment-copy">what if the user adds floating point numbers to your array? The results will be super imprecise.</span>
