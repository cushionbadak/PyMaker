<div class="post-text" itemprop="text">
<p>I want to get the attributes of a class, say:</p>
<pre><code>class MyClass():
  a = "12"
  b = "34"

  def myfunc(self):
    return self.a
</code></pre>
<p>using <code>MyClass.__dict__</code> gives me a list of attributes and functions, and even functions like <code>__module__</code> and <code>__doc__</code>. While <code>MyClass().__dict__</code> gives me an empty dict unless I explicitly set an attribute value of that instance.</p>
<p>I just want the attributes, in the example above those would be: <code>a</code> and <code>b</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Try the <a href="http://docs.python.org/library/inspect.html#inspect.getmembers">inspect</a> module. <code>getmembers</code> and the various tests should be helpful.</p>
<p>EDIT:</p>
<p>For example,</p>
<pre><code>class MyClass(object):
    a = '12'
    b = '34'
    def myfunc(self):
        return self.a

&gt;&gt;&gt; import inspect
&gt;&gt;&gt; inspect.getmembers(MyClass, lambda a:not(inspect.isroutine(a)))
[('__class__', type),
 ('__dict__',
  &lt;dictproxy {'__dict__': &lt;attribute '__dict__' of 'MyClass' objects&gt;,
   '__doc__': None,
   '__module__': '__main__',
   '__weakref__': &lt;attribute '__weakref__' of 'MyClass' objects&gt;,
   'a': '34',
   'b': '12',
   'myfunc': &lt;function __main__.myfunc&gt;}&gt;),
 ('__doc__', None),
 ('__module__', '__main__'),
 ('__weakref__', &lt;attribute '__weakref__' of 'MyClass' objects&gt;),
 ('a', '34'),
 ('b', '12')]
</code></pre>
<p>Now, the special methods and attributes get on my nerves- those can be dealt with in a number of ways, the easiest of which is just to filter based on name.</p>
<pre><code>&gt;&gt;&gt; attributes = inspect.getmembers(MyClass, lambda a:not(inspect.isroutine(a)))
&gt;&gt;&gt; [a for a in attributes if not(a[0].startswith('__') and a[0].endswith('__'))]
[('a', '34'), ('b', '12')]
</code></pre>
<p>...and the more complicated of which can include special attribute name checks or even metaclasses ;)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def props(cls):   
  return [i for i in cls.__dict__.keys() if i[:1] != '_']

properties = props(MyClass)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>myfunc</code> <strong>is</strong> an attribute of <code>MyClass</code>. That's how it's found when you run:</p>
<pre><code>myinstance = MyClass()
myinstance.myfunc()
</code></pre>
<p>It looks for an attribute on <code>myinstance</code> named <code>myfunc</code>, doesn't find one, sees that <code>myinstance</code> is an instance of <code>MyClass</code> and looks it up there.</p>
<p>So the <em>complete</em> list of attributes for <code>MyClass</code> is:</p>
<pre><code>&gt;&gt;&gt; dir(MyClass)
['__doc__', '__module__', 'a', 'b', 'myfunc']
</code></pre>
<p>(Note that I'm using dir just as a quick and easy way to list the members of the class: it should only be used in an exploratory fashion,  not in production code)</p>
<p>If you only want particular attributes, you'll need to filter this list using some criteria, because <code>__doc__</code>, <code>__module__</code>, and <code>myfunc</code> aren't special in any way, they're attributes in exactly the same way that <code>a</code> and <code>b</code> are.</p>
<p>I've never used the inspect module referred to by Matt and Borealid, but from a brief link it looks like it has tests to help you do this, but you'll need to write your own predicate function, since it seems what you want is roughly the attributes that <em>don't</em> pass the <code>isroutine</code> test and don't start and end with two underscores.</p>
<p>Also note: by using <code>class MyClass():</code> in Python 2.7 you're using the wildly out of date old-style classes. Unless you're doing so deliberately for compatibility with extremely old libraries, you should be instead defining your class as <code>class MyClass(object):</code>. In Python 3 there are no "old-style" classes, and this behaviour is the default. However, using newstyle classes will get you a <em>lot</em> more automatically defined attributes:</p>
<pre><code>&gt;&gt;&gt; class MyClass(object):
        a = "12"
        b = "34"
        def myfunc(self):
            return self.a
&gt;&gt;&gt; dir(MyClass)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'a', 'b', 'myfunc']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>MyClass().__class__.__dict__</code></p>
<p>However, the "right" was to do this is via the <a href="http://docs.python.org/library/inspect.html" rel="noreferrer">inspect module</a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re

class MyClass:
    a = "12"
    b = "34"

    def myfunc(self):
        return self.a

attributes = [a for a, v in MyClass.__dict__.items()
              if not re.match('&lt;function.*?&gt;', str(v))
              and not (a.startswith('__') and a.endswith('__'))]
</code></pre>
<p>For an instance of MyClass, such as</p>
<pre><code>mc = MyClass()
</code></pre>
<p>use <code>type(mc)</code> in place of <code>MyClass</code> in the list comprehension.  However, if one dynamically adds an attribute to <code>mc</code>, such as <code>mc.c = "42"</code>, the attribute won't show up when using <code>type(mc)</code> in this strategy.  It only gives the attributes of the original class.</p>
<p>To get the complete dictionary for a class instance, you would need to COMBINE the dictionaries of <code>type(mc).__dict__</code> and <code>mc.__dict__</code>.</p>
<pre><code>mc = MyClass()
mc.c = "42"

# Python 3.5
combined_dict = {**type(mc).__dict__, **mc.__dict__}

# Or Python &lt; 3.5
def dict_union(d1, d2):
    z = d1.copy()
    z.update(d2)
    return z

combined_dict = dict_union(type(mc).__dict__, mc.__dict__)

attributes = [a for a, v in combined_dict.items()
              if not re.match('&lt;function.*?&gt;', str(v))
              and not (a.startswith('__') and a.endswith('__'))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't know if something similar has been made by now or not, but I made a nice attribute search function using vars(). vars() creates a dictionary of the attributes of a class you pass through it.</p>
<pre><code>class Player():
    def __init__(self):
        self.name = 'Bob'
        self.age = 36
        self.gender = 'Male'

s = vars(Player())
#From this point if you want to print all the attributes, just do print(s)

#If the class has a lot of attributes and you want to be able to pick 1 to see
#run this function
def play():
    ask = input("What Attribute?&gt;: ")
    for key, value in s.items():
        if key == ask:
            print("self.{} = {}".format(key, value))
            break
    else:
        print("Couldn't find an attribute for self.{}".format(ask))
</code></pre>
<p>I'm developing a pretty massive Text Adventure in Python, my Player class so far has over 100 attributes. I use this to search for specific attributes I need to see.</p>
</div>
<div class="post-text" itemprop="text">
<p>My solution to get all attributes (not methods) of a class (if the class has a properly written docstring that has the attributes clearly spelled out):</p>
<pre><code>def get_class_attrs(cls):
    return re.findall(r'\w+(?=[,\)])', cls.__dict__['__doc__'])
</code></pre>
<p>This piece <code>cls.__dict__['__doc__']</code> extracts the docstring of the class.</p>
</div>
<div class="post-text" itemprop="text">
<p>I recently needed to figure out something similar to this question, so I wanted to post some background info that might be helpful to others facing the same in future.</p>
<p>Here's how it works in Python (from <a href="https://docs.python.org/3.5/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow">https://docs.python.org/3.5/reference/datamodel.html#the-standard-type-hierarchy</a>):</p>
<p><code>MyClass</code> is a class object, <code>MyClass()</code> is an instance of the class object. An instance's <code>__dict__</code> only hold attributes and methods specific to that instance (e.g. <code>self.somethings</code>). If an attribute or method is part of a class, it is in the class's <code>__dict__</code>. When you do <code>MyClass().__dict__</code>, an instance of <code>MyClass</code> is created with no attributes or methods besides the class attributes, thus the empty <code>__dict__</code></p>
<p>So if you say <code>print(MyClass().b)</code>, Python first checks the new instance's dict <code>MyClass().__dict__['b']</code> and fails to find <code>b</code>. It then checks the class <code>MyClass.__dict__['b']</code> and finds <code>b</code>.</p>
<p>That's why you need the <code>inspect</code> module, to emulate that same search process.</p>
</div>
<div class="post-text" itemprop="text">
<p>Getting only the <strong>instance attributes</strong> is easy.<br/>
But getting also the <strong>class attributes</strong> without the functions is a bit more tricky.</p>
<h1>Instance attributes only</h1>
<p>If you only have to list <strong>instance attributes</strong> just use<br/>
<strong><code>for attribute, value in my_instance</code>.<a href="https://docs.python.org/3/library/stdtypes.html#object.__dict__" rel="nofollow noreferrer"><code>__dict__</code></a>.<code>items()</code></strong></p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; from __future__ import (absolute_import, division, print_function)
&gt;&gt;&gt; class MyClass(object):
...   def __init__(self):
...     self.a = 2
...     self.b = 3
...   def print_instance_attributes(self):
...     for attribute, value in self.__dict__.items():
...       print(attribute, '=', value)
...
&gt;&gt;&gt; my_instance = MyClass()
&gt;&gt;&gt; my_instance.print_instance_attributes()
a = 2
b = 3
&gt;&gt;&gt; for attribute, value in my_instance.__dict__.items():
...   print(attribute, '=', value)
...
a = 2
b = 3
</code></pre>
<h1>Instance and class attributes</h1>
<p>To get also the <strong>class attributes</strong> without the functions, the trick is to use <a href="https://docs.python.org/3/library/functions.html?highlight=staticmethod#callable" rel="nofollow noreferrer"><code>callable()</code></a>. </p>
<p><strong>But <a href="https://docs.python.org/3/library/functions.html?highlight=staticmethod#staticmethod" rel="nofollow noreferrer" title="@staticmethod">static methods</a> are <a href="https://stackoverflow.com/q/45375944/938111">not always <code>callable</code></a>!</strong></p>
<p>Therefore, instead of using <code>callable(value)</code> use<br/>
<strong><code>callable</code>(<a href="https://docs.python.org/3/library/functions.html?highlight=staticmethod#getattr" rel="nofollow noreferrer"><code>getattr</code></a>(<code>MyClass, attribute))</code></strong></p>
<h2>Example</h2>
<pre class="lang-py prettyprint-override"><code>from __future__ import (absolute_import, division, print_function)

class MyClass(object):
   a = "12"
   b = "34"               # class attributes

   def __init__(self, c, d):
     self.c = c
     self.d = d           # instance attributes

   @staticmethod
   def mystatic():        # static method
       return MyClass.b

   def myfunc(self):      # non-static method
     return self.a

   def print_instance_attributes(self):
     print('[instance attributes]')
     for attribute, value in self.__dict__.items():
        print(attribute, '=', value)

   def print_class_attributes(self):
     print('[class attributes]')
     for attribute in MyClass.__dict__.keys():
       if attribute[:2] != '__':
         value = getattr(MyClass, attribute)
         if not callable(value):
           print(attribute, '=', value)

v = MyClass(4,2)
v.print_class_attributes()
v.print_instance_attributes()
</code></pre>
<p><strong>Note:</strong> <code>print_class_attributes()</code> should be <a href="https://docs.python.org/3/library/functions.html?highlight=staticmethod#staticmethod" rel="nofollow noreferrer" title="static method"><code>@staticmethod</code></a><br/>
      but not in this <em>stupid and simple</em> example.</p>
<h2>Result for <a class="post-tag" href="/questions/tagged/python2" rel="tag" title="show questions tagged 'python2'">python2</a></h2>
<pre class="lang-py prettyprint-override"><code>$ python2 ./print_attributes.py
[class attributes]
a = 12
b = 34
[instance attributes]
c = 4
d = 2
</code></pre>
<h2>Same result for <a class="post-tag" href="/questions/tagged/python3" rel="tag" title="show questions tagged 'python3'">python3</a></h2>
<pre class="lang-py prettyprint-override"><code>$ python3 ./print_attributes.py
[class attributes]
b = 34
a = 12
[instance attributes]
c = 4
d = 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>dir()</code> in a <em>list comprehension</em> to get the attribute names:</p>
<pre><code>names = [p for p in dir(myobj) if not p.startswith('_')]
</code></pre>
<p>Use <code>getattr()</code> to get the attributes themselves:</p>
<pre><code>attrs = [getattr(myobj, p) for p in dir(myobj) if not p.startswith('_')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be done without inspect, I guess.</p>
<p>Take the following class:</p>
<pre><code> class Test:
   a = 1
   b = 2

   def __init__(self):
     self.c = 42

   @staticmethod
   def toto():
     return "toto"

   def test(self):
     return "test"
</code></pre>
<p>Looking at the members along with their types:</p>
<pre><code>t = Test()
l = [ (x, eval('type(x.%s).__name__' % x)) for x in dir(a) ]
</code></pre>
<p>... gives:</p>
<pre><code>[('__doc__', 'NoneType'),
 ('__init__', 'instancemethod'),
 ('__module__', 'str'),
 ('a', 'int'),
 ('b', 'int'),
 ('c', 'int'),
 ('test', 'instancemethod'),
 ('toto', 'function')]
</code></pre>
<p>So to output only the variables, you just have to filter the results by type, and names not starting with '__'. E.g.</p>
<pre><code>filter(lambda x: x[1] not in ['instancemethod', 'function'] and not x[0].startswith('__'), l)

[('a', 'int'), ('b', 'int'), ('c', 'int')] # actual result
</code></pre>
<p>That's it.</p>
<p><em>Note:</em> if you're using Python 3, convert the iterators to lists.</p>
<p>If you want a more robust way to do it, use <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">inspect</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>two function:</p>
<pre><code>def get_class_attr(Cls) -&gt; []:
    import re
    return [a for a, v in Cls.__dict__.items()
              if not re.match('&lt;function.*?&gt;', str(v))
              and not (a.startswith('__') and a.endswith('__'))]

def get_class_attr_val(cls):
    attr = get_class_attr(type(cls))
    attr_dict = {}
    for a in attr:
        attr_dict[a] = getattr(cls, a)
    return attr_dict
</code></pre>
<p>use:</p>
<pre><code>&gt;&gt;&gt; class MyClass:
    a = "12"
    b = "34"
    def myfunc(self):
        return self.a

&gt;&gt;&gt; m = MyClass()
&gt;&gt;&gt; get_class_attr_val(m)
{'a': '12', 'b': '34'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>MyClass.__attrs__</code>.  It just gives all the attributes of that class. Nothing more.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a <strong>very simple answer</strong>, that should be obvious: getattr</p>
<pre><code>class MyClass(object):
a = '12'
b = '34'
def myfunc(self):
    return self.a

&gt;&gt;&gt; getattr(MyClass, 'a')
'12'

&gt;&gt;&gt; getattr(MyClass, 'myfunc')
&lt;function MyClass.myfunc at 0x10de45378&gt;
</code></pre>
<p>It works dandy both in Python 2.7 and Python 3.x.</p>
<p>If you want a list of these items, you will still need to use inspect.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this was three years ago, but for those who are to come by this question in the future, for me:</p>
<pre><code>class_name.attribute 
</code></pre>
<p>works just fine.</p>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/4241171/inspect-python-class-attributes">Inspect python class attributes</a></span>
<span class="comment-copy">yup this is great! I used this:  <code>attributes = inspect.getmembers(MyClass, lambda a:not(inspect.isroutine(a)))</code> <code>print [a[0] for a in attributes if '_' not in a[0]]</code></span>
<span class="comment-copy">Be careful- that won't include attributes <code>like_this</code>! It'll also avoid "private" attributes, which you might've done on purpose.</span>
<span class="comment-copy">Hi, I loved that too with a slight clarification : in the expression <code>inspect.getmembers(MyClass, ...</code>, <code>MyClass</code> can be replaced by a class or  an object, and if you need the list of the values of your objects, you must replace <code>MyClass</code> by your object variable (or <code>self</code> if you put this expression in a <code>def __repr__()</code> method like me).</span>
<span class="comment-copy">This will include method names</span>
<span class="comment-copy">Woudn't be more clear to check: <code>if not i.startswith('_')</code> instead of <code>if i[:1] != '_'</code>?</span>
<span class="comment-copy">Note: if we talk about child class (inherited), then <code>.__dict__.keys()</code> will not include attributes from parent.</span>
<span class="comment-copy">One cannot depend on <code>dir()</code>: "<i>Because dir() is supplied primarily as a convenience for use at an interactive prompt, <b>it tries to supply an interesting set of names more than it tries to supply a rigorously or consistently defined set of names</b>, and <b>its detailed behavior may change across releases</b>.</i>" (see <a href="http://docs.python.org/library/functions.html#dir" rel="nofollow noreferrer">documentation of <code>dir()</code></a>).</span>
<span class="comment-copy">@Tadeck: Good point. I was using it illustratively rather than suggesting it as a solution, since it wouldn't easily allow you to filter the attributes based on what they refer to. But I should be more explicit about that.</span>
<span class="comment-copy"><code>MyClass().__class__.__dict__</code> == <code>MyClass.__dict__</code></span>
<span class="comment-copy">@yak's comment isn't quite true. See the following about the differences between class and instance attributes. See <a href="http://stackoverflow.com/questions/35805/why-is-my-instance-variable-not-in-dict" title="why is my instance variable not in dict">stackoverflow.com/questions/35805/…</a>.</span>
<span class="comment-copy">Really neat solution.</span>
<span class="comment-copy">Scott - A comment posted as an answer must get deleted, otherwise we'd be drowning in them. However, a partial answer or "helpful nudge" towards a solution is <i>still an answer</i>. You'll see how I reworded your post; hopefully I retained your intent. If not, you can further <a href="https://stackoverflow.com/posts/35899047/edit">edit</a> it into shape. Cheers!</span>
<span class="comment-copy">except when you get an AttributeError.</span>
<span class="comment-copy">You don't always know what <code>attribute</code> is beforehand.</span>
