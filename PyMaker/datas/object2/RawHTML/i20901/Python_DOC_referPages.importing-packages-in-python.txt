<div class="post-text" itemprop="text">
<p>I am probably missing something obvious but anyway:</p>
<p>When you import a package like <code>os</code> in python, you can use any submodules/subpackages off the bat. For example this works:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.abspath(...)
</code></pre>
<p>However I have my own package which is structured as follows:</p>
<pre><code>FooPackage/
  __init__.py
  foo.py
</code></pre>
<p>and here the same logic does not work:</p>
<pre><code>&gt;&gt;&gt; import FooPackage
&gt;&gt;&gt; FooPackage.foo
AttributeError: 'module' object has no attribute 'foo'
</code></pre>
<p>What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to import the submodule:</p>
<pre><code>import FooPackage.foo
</code></pre>
<hr/>
<p>What you're doing is looking for <code>foo</code> in <code>FooPackage/__init__.py</code>. You could solve it by putting <code>import FooPackage.foo as foo</code> (or <code>from . import foo</code>) in <code>FooPackage/__init__.py</code>,  then Python will be able to find <code>foo</code> there. But I recommend using my first suggestion.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you import <code>FooPackage</code>, Python searches the directories on PYTHONPATH until it finds a file called <code>FooPackage.py</code> or a directory called <code>FooPackage</code> containing a file called <code>__init__.py</code>. However, having found the package directory,  it does <em>not</em> then scan that directory and automatically import all .py files.</p>
<p>There are two reasons for this behaviour. The first is that importing a module executes Python code which may take time, memory, or have side effects. So you might want to import <code>a.b.c.d</code> without necessarily importing all of a huge package <code>a</code>. It's up to the package designer to decide whether a's <code>__init__.py</code> explicitly imports its modules and subpackages so that they are always available, or whether or leaves the client program the ability to pick and choose what is loaded.</p>
<p>The second is a bit more subtle, and also a showstopper. Without an explicit import statement (either in <code>FooPackage/__init__.py</code> or in the client program), Python doesn't necessarily know what name it should import <code>foo.py</code> as. On a case insensitive file system (such as used in Windows), this could represent a module named <code>foo</code>, <code>Foo</code>,  <code>FOO</code>, <code>fOo</code>, <code>foO</code>, <code>FoO</code>, <code>FOo</code>, or <code>fOO</code>. All of these are valid, distinct Python identifiers, so Python just doesn't have enough information from the file alone to know what you mean. Therefore, in order to behave consistently on all systems, it requires an explicit import statement somewhere to clarify the name, even on file systems where full case information is available.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to add <code>from . import foo</code> to the <code>__init__.py</code> file in your package. </p>
</div>
<div class="post-text" itemprop="text">
<p>There are some important misconceptions that need to be addressed, specifically with terminology. First, usually, when you think that you are importing  a <code>package</code> in python, what you are actually importing is a <code>module</code>.  You should use the term <code>package</code> when you are thinking in terms of file system substructure that helps you organize your code.  But from the code perspective, whenever you import a <code>package</code>, Python treats it as a module.  All packages are modules.  Not all modules are packages.  A module with the <code>__path__</code> attribute is considered a package.</p>
<p>You can check that <code>os</code> is a module.  To confirm this you can do:</p>
<pre><code>import os
print(type(os)) # will print: &lt;type 'module'&gt;
</code></pre>
<p>In your example, when you do <code>import FooPackage</code>, <code>FooPackage</code> is treated and considered to be a module too, and its attributes (functions, classes, etc.) are supposedly defined in <code>__init__.py</code>. Since your <code>__init__.py</code> is empty, it cannot find <code>foo</code>.</p>
<p>Outside of <code>import</code> statements you cannot use <code>'.'</code> notation to address modules inside of modules.  The only exception happens if a <code>module</code> is imported in the intended parent's package <code>__init__.py</code> file.  To make it clear, let's do some examples here:</p>
<p>Consider your original structure:</p>
<pre><code>FooPackage/
  __init__.py
  foo.py
</code></pre>
<p><strong>Case 1: __init__.py is an empty file</strong></p>
<pre><code>#FooPackage imported as a module
import FooPackage 

#foo is not a name defined in `__init__.py`. Error
FooPackage.foo 

#FooPackage.foo imported as a module
import FooPackage.foo

#Error, foo has not been imported. To be able to use foo like this,
#you need to do: import FooPackage.foo as foo
foo.anything

#Not error, if anything is defined inside foo.py
FooPackage.foo.anything
</code></pre>
<p><strong>Case 2: __init__.py has line <code>import foo</code> in it:</strong></p>
<pre><code>import FooPackage

#Now this is good. `foo` is sort of considered to be an attribute of 
#FooPackage
FooPackage.foo
</code></pre>
<p>Now, suppose that foo is no longer a <code>module</code>, but a <code>function</code> that you define in <code>__init__.py</code>. if you do <code>import FooPackage.foo</code>, it will throw an error saying that <code>foo</code> is not a module.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can import a package from library using import statement. </p>
<blockquote>
<p>syntax :    import module_name</p>
</blockquote>
<pre><code>     ex: import math
</code></pre>
<p>You can import only a specific method form a package by using blow syntax</p>
<blockquote>
<p>syntax :    from module_name import function_name</p>
</blockquote>
<pre><code>     ex: from math import radians
</code></pre>
</div>
<span class="comment-copy">As I understood it the question wasn't how to import a submodule - it was why you could access a submodule of os without importing that submodule, and how to implement something similar. Edit: However, your answer would work</span>
<span class="comment-copy">So you can't import a package as an aggregate. You can only import specific modules of that package.</span>
<span class="comment-copy">@drlolly You can't import a package as an aggregate unless the package author wanted you to, and specifically wrote the sub-imports in their <code>__init__.py</code> files.</span>
<span class="comment-copy">(This information was in the other answers already posted, but you had to read through them a bit. So I've posted it again as a simple answer to the question.)</span>
<span class="comment-copy">Better to use the <code>__all__ =["foo"]</code> instead</span>
<span class="comment-copy">In "Case 2", you may need to use <code>from . import foo</code> instead of <code>import foo</code> in <code>__init__.py</code> file otherwise it could cause import error due to Python treats <code>import foo</code> as "absolute import" (see <i>Intra-package References</i> section in <a href="https://docs.python.org/3/tutorial/modules.html#intra-package-references" rel="nofollow noreferrer">docs.python.org/3/tutorial/â€¦</a>)</span>
<span class="comment-copy">This does not even remotely answer the question asked...</span>
