<div class="post-text" itemprop="text">
<p>I am rather new to python.
I have two datetime objects. I need to calculate the timedelta between them and then show the output in a spcific format.</p>
<pre><code>Alpha_TimeObj = datetime.datetime(int(AlphaTime.strftime('%Y')), int(AlphaTime.strftime('%m')), int(AlphaTime.strftime('%d')), int(AlphaTime.strftime('%H')), int(AlphaTime.strftime('%M')), int(AlphaTime.strftime('%S')))
Beta_TimeObj = datetime.datetime(int(BetaTime.strftime('%Y')), int(BetaTime.strftime('%m')), int(BetaTime.strftime('%d')), int(BetaTime.strftime('%H')), int(BetaTime.strftime('%M')), int(BetaTime.strftime('%S')))
Turnaround_TimeObj = Beta_TimeObj  - Alpha_TimeObj 
</code></pre>
<p>an example of this Turnaround_TimeObj  time delta is "2 days, 22:13:45".
I want to format the output but am unable to do so.</p>
<pre><code>print Turnaround_TimeObj.strftime('%H hrs %M mins %S secs')
</code></pre>
<p>doesn't works.</p>
<p>I know one way of doing this will be to convert it to seconds and then divmodding to get the required formatting.
as in;</p>
<pre><code>totalSeconds = Turnaround_TimeObj.seconds
hours, remainder = divmod(totalSeconds, 3600)
minutes, seconds = divmod(remainder, 60)
print '%s:%s:%s' % (hours, minutes, seconds)
</code></pre>
<p>but i was wondering if I can do it in a single line using any date time function like strftime.</p>
<p>EDIT: actually converting to seconds doesn't works either.
if I convert the time delta "1 day, 3:42:54" to seconds using </p>
<pre><code>totalSeconds = Turnaround_TimeObj.seconds
</code></pre>
<p>totalSeconds value is shown as 13374 instead of 99774. ie. its ignoring the "day" value.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>but i was wondering if I can do it in a single line using any date time function like strftime.</p>
</blockquote>
<p>As far as I can tell, there isn't a built-in method to <code>timedelta</code> that does that. If you're doing it often, you can create your own function, e.g.</p>
<pre><code>def strfdelta(tdelta, fmt):
    d = {"days": tdelta.days}
    d["hours"], rem = divmod(tdelta.seconds, 3600)
    d["minutes"], d["seconds"] = divmod(rem, 60)
    return fmt.format(**d)
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; print strfdelta(delta_obj, "{days} days {hours}:{minutes}:{seconds}")
1 days 20:18:12
&gt;&gt;&gt; print strfdelta(delta_obj, "{hours} hours and {minutes} to go")
20 hours and 18 to go
</code></pre>
<p>If you want to use a string format closer to the one used by <code>strftime</code> we can employ <a href="http://docs.python.org/library/string.html#template-strings"><code>string.Template</code></a>.</p>
<pre><code>from string import Template

class DeltaTemplate(Template):
    delimiter = "%"

def strfdelta(tdelta, fmt):
    d = {"D": tdelta.days}
    d["H"], rem = divmod(tdelta.seconds, 3600)
    d["M"], d["S"] = divmod(rem, 60)
    t = DeltaTemplate(fmt)
    return t.substitute(**d)
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; print strfdelta(delta_obj, "%D days %H:%M:%S")
1 days 20:18:12
&gt;&gt;&gt; print strfdelta(delta_obj, "%H hours and %M to go")
20 hours and 18 to go
</code></pre>
<hr/>
<blockquote>
<p>totalSeconds value is shown as 13374 instead of 99774. ie. its ignoring the "day" value.</p>
</blockquote>
<p>Note in the example above that you can use <code>timedelta.days</code> to get the "day" value.</p>
<p>Alternatively, from Python 2.7 onwards, timedelta has a <a href="http://docs.python.org/library/datetime.html#datetime.timedelta.total_seconds">total_seconds()</a> method which return the total number of seconds contained in the duration.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python2.7 or newer, you could use the <a href="http://docs.python.org/library/datetime.html#datetime.timedelta.total_seconds" rel="noreferrer">total_seconds</a> method:</p>
<pre><code>import datetime as dt

turnaround = dt.timedelta(days = 1, hours = 3, minutes = 42, seconds = 54)

total_seconds = int(turnaround.total_seconds())
hours, remainder = divmod(total_seconds,60*60)
minutes, seconds = divmod(remainder,60)

print('{} hrs {} mins {} secs'.format(hours,minutes,seconds))
</code></pre>
<p>yields</p>
<pre><code>27 hrs 42 mins 54 secs
</code></pre>
<p>In Python2.6 or older, you could compute the <code>total_seconds</code> yourself:</p>
<pre><code>total_seconds = turnaround.seconds + turnaround.days*24*60*60
</code></pre>
<p>(for the more general formula, including microseconds, see the link above).</p>
</div>
<div class="post-text" itemprop="text">
<p>Shawn Chin's answer is a good one, but one problem with it is that if you skip a particular element in your format (as in his second example which only has hours and minutes .. not days or seconds) then that time vanishes from your result.  You can modify it to fix that issue and get more accurate results by only processing the keywords that actually appear in the format string.</p>
<pre><code>class DeltaTemplate(Template):
    delimiter = '%'

def strfdelta(tdelta, fmt):
    d = {}
    l = {'D': 86400, 'H': 3600, 'M': 60, 'S': 1}
    rem = int(tdelta.total_seconds())

    for k in ( 'D', 'H', 'M', 'S' ):
        if "%{}".format(k) in fmt:
            d[k], rem = divmod(rem, l[k])

    t = DeltaTemplate(fmt)
    return t.substitute(**d)
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; print strfdelta(delta_obj, "%D days %H:%M:%S")
1 days 20:18:12
&gt;&gt;&gt; print strfdelta(delta_obj, "%H hours and %M to go")
44 hours and 18 to go
</code></pre>
<p>That's inflexible about formatting though, as you can't apply any conversion strings and wind up with ugly things like this:</p>
<pre><code>&gt;&gt;&gt; delta_obj = timedelta(minutes=5, seconds=2)
&gt;&gt;&gt; print strfdelta(delta_obj, "%H:%M:%S")
0:5:2
</code></pre>
<p>However, you can take the same approach and apply it to string.Formatter instead of string.Template and get something much better.</p>
<pre><code>from string import Formatter

def strfdelta(tdelta, fmt):
    f = Formatter()
    d = {}
    l = {'D': 86400, 'H': 3600, 'M': 60, 'S': 1}
    k = map( lambda x: x[1], list(f.parse(fmt)))
    rem = int(tdelta.total_seconds())

    for i in ('D', 'H', 'M', 'S'):
        if i in k and i in l.keys():
            d[i], rem = divmod(rem, l[i])

    return f.format(fmt, **d)
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; delta_obj = timedelta(days=1, hours=20, minutes=18, seconds=12)
&gt;&gt;&gt; print strfdelta(delta_obj, "{D} days {H}:{M}:{S}")
1 days 20:18:12
&gt;&gt;&gt; print strfdelta(delta_obj, "{H} hours and {M} to go") 
44 hours and 18 to go

&gt;&gt;&gt; delta_obj = timedelta(minutes=5, seconds=2)                     
&gt;&gt;&gt; print strfdelta(delta_obj, "{H:02}h{M:02}m{S:02}s")  
00h05m02s
&gt;&gt;&gt; print strfdelta(delta_obj, "{H:02}:{M:02}:{S:02}")
00:05:02
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A slight variant on <a href="https://stackoverflow.com/users/115845/shawn-chin">Shawn Chin</a>'s <a href="https://stackoverflow.com/questions/8906926/formatting-python-timedelta-objects/8907269#8907269">answer</a> - that also addresses a subsequent <a href="https://stackoverflow.com/questions/8906926/formatting-python-timedelta-objects/17847006#17847006">issue</a> raised by <a href="https://stackoverflow.com/users/951589/mpounsett">mpouncett</a> - pads the hours, minutes and seconds with leading zeros to ensure that all 3 elements use 2 places (more consistent with the specification for these fields in <a href="https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior" rel="noreferrer">strftime</a>):</p>
<pre><code>from string import Template

class DeltaTemplate(Template):
    delimiter = "%"

def strfdelta(tdelta, fmt):
    d = {"D": tdelta.days}
    hours, rem = divmod(tdelta.seconds, 3600)
    minutes, seconds = divmod(rem, 60)
    d["H"] = '{:02d}'.format(hours)
    d["M"] = '{:02d}'.format(minutes)
    d["S"] = '{:02d}'.format(seconds)
    t = DeltaTemplate(fmt)
    return t.substitute(**d)
</code></pre>
<p>Here are is a test for some sample values:</p>
<pre><code>from datetime import timedelta
for seconds in [0, 1, 59, 60, 61, 3599, 3600, 3601]:
    print strfdelta(timedelta(0, seconds), '%H:%M:%S')
</code></pre>
<p>And here is the output:</p>
<pre><code>00:00:00
00:00:01
00:00:59
00:01:00
00:01:01
00:59:59
01:00:00
01:00:01
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the dateutil module which has the friendlier relativedelta object.</p>
<pre><code>import dateutil
import datetime

alpha = datetime.datetime(2012, 1, 16, 6, 0)
beta = datetime.datetime(2012, 1, 18, 10, 42, 57, 230301)
delta = dateutil.relativedelta(beta, alpha)
</code></pre>
<p>this gives you an object delta that looks like</p>
<pre><code>&gt;&gt;&gt; delta
relativedelta(days=+2, hours=+4, minutes=+42, seconds=+57, microseconds=+230301)
</code></pre>
<p>You can then do </p>
<pre><code>print('turnaround %i hrs %i mins %i secs' % (delta.days * 24 + delta.hours, delta.minutes, delta.seconds)
</code></pre>
<p>)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def to_time(seconds):
  delta = datetime.timedelta(seconds=seconds)
  return str(delta.days) + 'd ' + (datetime.datetime.utcfromtimestamp(0) + datetime.timedelta(seconds=delta.seconds)).strftime('%H:%M')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The above answers don’t seem to handle <em>negative</em> timedelta values (as produced e.g. by <a href="https://github.com/stub42/pytz" rel="nofollow noreferrer">pytz</a> for timezones “left” of UTC). As <a href="https://docs.python.org/3/library/datetime.html#timedelta-objects" rel="nofollow noreferrer">per documentation</a>, timedelta objects are normalized, and a negative timedelta is represented by a negative <code>day</code> instance attribute. From the documentation:</p>
<blockquote>
<p>Note that normalization of negative values may be surprising at first. </p>
</blockquote>
<p>and that</p>
<blockquote>
<p>String representations of timedelta objects are normalized similarly to their internal representation. This leads to somewhat unusual results for negative timedeltas.</p>
</blockquote>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; td = timedelta(seconds=-30)
&gt;&gt;&gt; str(td)
'-1 day, 23:59:30'
&gt;&gt;&gt; repr(td)
'datetime.timedelta(-1, 86370)'
</code></pre>
<p>Given this example timedelta, both <a href="https://stackoverflow.com/questions/8906926/formatting-python-timedelta-objects#8907269">Shawn Chin’s accepted answer</a> and <a href="https://stackoverflow.com/questions/8906926/formatting-python-timedelta-objects#30536361">gumption’s answer</a> return <code>'23:59:30'</code>, and <a href="https://stackoverflow.com/questions/8906926/formatting-python-timedelta-objects#17847006">mpounsett’s answer</a> <code>'-1:59:30'</code>.</p>
<p>I think in order to print both negative and positive timedeltas in a more readable manner, we need to handle the sign and absolute value of a timezone object explicitly:</p>
<pre><code>def strfdelta(td, fmt):

    # Get the timedelta’s sign and absolute number of seconds.
    sign = "-" if td.days &lt; 0 else "+"
    secs = abs(td).total_seconds()

    # Break the seconds into more readable quantities.
    days, rem = divmod(secs, 86400)  # seconds per day: 24 * 60 * 60
    hours, rem = divmod(rem, 3600)  # seconds per hour: 60 * 60
    mins, secs = divmod(rem, 60)

    # Format (as per above answers) and return the result string.
    t = DeltaTemplate(fmt)
    return t.substitute(
        s=sign,
        D="{:d}".format(int(days)),
        H="{:02d}".format(int(hours)),
        M="{:02d}".format(int(mins)),
        S="{:02d}".format(int(secs)),
        )
</code></pre>
<p>This function returns a more readable string representation:</p>
<pre><code>&gt;&gt;&gt; strfdelta(td, "%s%H:%M:%S")  # Note that %s refers to the timedelta’s sign.
'-00:00:30'
&gt;&gt;&gt; strfdelta(timedelta(days=-1), "%s%D %H:%M:%S")
'-1 00:00:00'
&gt;&gt;&gt; strfdelta(timedelta(days=-1, minutes=5), "%s%D %H:%M:%S")
'-0 23:55:00'
&gt;&gt;&gt; strfdelta(timedelta(days=-1, minutes=-5), "%s%D %H:%M:%S")
'-1 00:05:00'
</code></pre>
<p>…or in the more practical context of timezones:</p>
<pre><code>&gt;&gt;&gt; import pytz
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; td = pytz.timezone("Canada/Newfoundland").utcoffset(datetime.datetime.now())
&gt;&gt;&gt; td
datetime.timedelta(-1, 77400)
&gt;&gt;&gt; strfdelta(td, fmt="%s%H:%M")
'-02:30'
&gt;&gt;&gt; td = pytz.timezone("Australia/Eucla").utcoffset(datetime.datetime.now())
&gt;&gt;&gt; td
datetime.timedelta(0, 31500)
&gt;&gt;&gt; strfdelta(td, fmt="%s%H:%M")
'+08:45'
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/538666/python-format-timedelta-to-string">Python format timedelta to string</a></span>
<span class="comment-copy">@plaes not really an exact duplicate. OP as indirectly acknowledged that he has seen that question by quoting the answer from that Q. This question seems to be about getting an <code>strftime</code> equivalent, as well as including the "days" value not mentioned in the other question.</span>
<span class="comment-copy">your code is fine if you use <code>.total_seconds()</code> (or its analog on earlier Python versions) instead of <code>.seconds</code>: <a href="http://stackoverflow.com/a/30477047/4279">code example -- notice that <code>02d</code> format is used</a></span>
<span class="comment-copy">I like this solution, except for the lack of zero-padding of the hours, minutes and seconds. I've proposed a slight variant - with zero-padding - in another solution.</span>
<span class="comment-copy">@gumption: your solution as well as this answer do not include <code>.days</code> attribute into the <code>hours</code> value. I don't understand why OP hasn't accepted <a href="http://stackoverflow.com/a/8907407/4279">unutbu's answer</a> instead.</span>
<span class="comment-copy">@J.F.Sebastian: I'm not sure what you mean. Both solutions include the timedelta.days attribute as the value of the "D" key in the dict. I agree that unutbu's solution is also a good one, but preferred the structuring of the solution into a class and method ... and the ability to use this in Python versions preceding 2.7. I generally prefer to show times &amp; elapsed times using zero-padding for %H:%M:%S (consistent with the specification for datetime.strftime) ... which is why I proposed my variant.</span>
<span class="comment-copy">Do you see the difference between  <i>"27 hrs ..."</i> (unutbu's answer)  and <i>"1 day, 3 hours ..."</i>? Why do you think OP was not satisfied with <code>str(timedelta)</code> and posted the question?</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/8906926/formatting-python-timedelta-objects#49226644">my answer</a> regarding <i>negative</i> timedelta values.</span>
<span class="comment-copy">Oddly, this did not work for me as written, I had to change <code>map( lambda x: x[1], list(f.parse(fmt)))</code> to <code>list(map( lambda x: x[1], list(f.parse(fmt))))</code></span>
<span class="comment-copy">Given the amount of time that has passed since that was written (2013), it could be a version incompatibility.  I don't recall for sure now, but I may not have tested those examples in python 3.x</span>
<span class="comment-copy">Perfect ! Thanks</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/8906926/formatting-python-timedelta-objects#49226644">my answer</a> regarding <i>negative</i> timedelta values.</span>
<span class="comment-copy">Great proposition. I just regret that contrary to strftime the %H needs to be separated from other character by a specificly separating character, it does not work with a letter! "%Hh%M" returns an error</span>
<span class="comment-copy">Thanks for noting the shortcomings - and offering an alternative - in formatting negative timedeltas. I have never encountered a scenario involving negative timedeltas, but I agree it would be best to accommodate them correctly.</span>
<span class="comment-copy">@gumption, for example the timezone implementation of the pytz module creates negative timedeltas for timezones “left” of UTC 🤓. I’ve added two examples.</span>
