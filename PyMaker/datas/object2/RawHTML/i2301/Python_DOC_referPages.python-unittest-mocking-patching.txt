<div class="post-text" itemprop="text">
<p>Not wanting to test manually my code, I'm trying to write a test which mocks/patches one of my dependencies (PyInquirer is a pretty neat package which handles the CLI for me - question dicts in, answer dicts out).</p>
<p>However, being very new to Python, I'm having difficulties with mocking that dependency. Here's the code I'm testing:</p>
<pre><code>from PyInquirer import prompt


class Foo:
    def bar(self):
        # this line is asking the user for inpit, and that's what I want to mock.
        a = prompt({'name': 'q',
                    'type': 'input',
                    'message': 'well, foo'})
        print("f is", f)
        return a
</code></pre>
<p>And this is the test:</p>
<pre><code>import unittest
from unittest.mock import patch
from Foo import Foo


class TestFoo(unittest.TestCase):
    @patch('PyInquirer.prompt', return_value=24)
    def test_bar(self):
        f = Foo()
        a = f.bar()
        assert a == 24


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>(the real code is obviously more complicated, but this is the essence of the problem). Which manifests itself as:</p>
<pre><code>Error
Traceback (most recent call last):
  File "/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/unittest/case.py", line 59, in testPartExecutor
    yield
  File "/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/unittest/case.py", line 605, in run
    testMethod()
  File "/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/unittest/mock.py", line 1179, in patched
    return func(*args, **keywargs)
TypeError: test_bar() takes 1 positional argument but 2 were given
</code></pre>
<p>I'm quite confused.</p>
<p>If I omit the patch decorator, the invocation fails with an expected assertion error - the dictionary produced by prompt isn't equal to 24. But if I do provide the decorator, I get the argument mismatch above. And indeed the last line in the stacktrace does show the function "func", which I presume is what the decorator was applied to, is invoked with two arguments... but... why? Can't be the essence of a problem? That only functions with arity of two can be thus patched =)</p>
</div>
<div class="post-text" itemprop="text">
<p>Your class uses the name <code>Foo.prompt</code> (because of how you import it), so <em>that's</em> what you need to patch.</p>
<pre><code>class TestFoo(unittest.TestCase):
    @patch('Foo.prompt', return_value=24)
    def test_bar(self, mock_prompt):
        f = Foo()
        a = f.bar()
        assert a == 24
</code></pre>
<p>You also need to add a parameter to <code>test_bar</code> to receive the patched object, whether or not you plan to use it. If you don't want to do that,
you can move the call to <code>patch</code> inside the method, using it with a <code>with</code> statement.</p>
<pre><code>class TestFoo(unittest.TestCase):
    def test_bar(self):
        with patch('Foo.prompt', return_value=24):
            f = Foo()
            a = f.bar()
            assert a == 24
</code></pre>
</div>
<span class="comment-copy"><code>@patch</code> adds an extra argument, the mock object, to the function it's decorating. Also note that you patch where something is imported <i>to</i>, not <i>from</i>. Both of these things are covered in <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">the docs</a>.</span>
<span class="comment-copy">Thank you sir. My patch is added the test - which is the place  where the code under testing is executed in the context.. of testing. What other place can I place it in?! My code? The third-party code I am trying to mock? Pray tell.</span>
<span class="comment-copy">Oh, thanks a lot! This is very different from the JVM mocking which I am used to; especially the Foo.prompt part.</span>
