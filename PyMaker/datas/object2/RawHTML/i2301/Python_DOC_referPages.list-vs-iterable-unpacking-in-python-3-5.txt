<div class="post-text" itemprop="text">
<p>Is there any practical difference between <code>list(iterable)</code> and <code>[*iterable]</code> in versions of Python that support the latter?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>list(x)</code> is a function, <code>[*x]</code> is an expression. You can reassign <code>list</code>, and make it do something else (but you shouldn't). </p>
<p>Talking about cPython, <code>b = list(a)</code> translates to this sequence of bytecodes:</p>
<pre><code>LOAD_NAME                1 (list)
LOAD_NAME                0 (a)
CALL_FUNCTION            1
STORE_NAME               2 (b)
</code></pre>
<p>Instead, <code>c = [*a]</code> becomes:</p>
<pre><code>LOAD_NAME                0 (a)
BUILD_LIST_UNPACK        1
STORE_NAME               3 (c)
</code></pre>
<p>so you can argue that <code>[*a]</code> <em>might</em> be slightly more efficient, but marginally so.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the standard library module <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> to investigate the byte code generated by a function. In this case:</p>
<pre><code>import dis

def call_list(x):
    return list(x)

def unpacking(x):
    return [*x]

dis.dis(call_list)
#   2           0 LOAD_GLOBAL              0 (list)
#               2 LOAD_FAST                0 (x)
#               4 CALL_FUNCTION            1
#               6 RETURN_VALUE

dis.dis(unpacking)
#   2           0 LOAD_FAST                0 (x)
#               2 BUILD_LIST_UNPACK        1
#               4 RETURN_VALUE
</code></pre>
<p>So there is a difference and it is not only the loading of the globally defined name <code>list</code>, which does not need to happen with the unpacking. So it boils down to how the built-in <code>list</code> function is defined and what exactly <code>BUILD_LIST_UNPACK</code> does.</p>
<p>Note that both are actually a lot less code than writing a standard list comprehension for this:</p>
<pre><code>def list_comp(x):
    return [a for a in x]

dis.dis(list_comp)
#   2           0 LOAD_CONST               1 (&lt;code object &lt;listcomp&gt; at 0x7f65356198a0, file "&lt;ipython-input-46-dd71fb182ec7&gt;", line 2&gt;)
#               2 LOAD_CONST               2 ('list_comp.&lt;locals&gt;.&lt;listcomp&gt;')
#               4 MAKE_FUNCTION            0
#               6 LOAD_FAST                0 (x)
#               8 GET_ITER
#              10 CALL_FUNCTION            1
#              12 RETURN_VALUE
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>[*iterable]</code> is unpacking, it accepts <em>assignment-like</em> syntax, unlike <code>list(iterable)</code>:</p>
<pre><code>&gt;&gt;&gt; [*[]] = []
&gt;&gt;&gt; list([]) = []
  File "&lt;stdin&gt;", line 1
SyntaxError: can't assign to function call
</code></pre>
<p>You can read more about this <a href="https://stackoverflow.com/questions/48446168/and-assignments">here</a> (not useful though).</p>
<p>You can also use <code>list(sequence=iterable)</code>, i.e. with a key-word argument:</p>
<pre><code>&gt;&gt;&gt; list(sequence=[])
[]
</code></pre>
<p>Again <a href="https://bugs.python.org/issue29695" rel="nofollow noreferrer">not useful</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's always going to be some differences between two constructs that do the same thing. Thing is, I wouldn't say the differences in this case are actually <em>practical</em>. Both are expressions that take the iterable, iterate through it and then create a list out of it. </p>
<p>The contract is the same: input is an iterable output is a list populated by the iterables elements. </p>
<p>Yes, <code>list</code> can be rebound to a different name; <code>list(it)</code> is a function call while <code>[*it]</code> is a list display; <code>[*it]</code> is faster with smaller iterables but generally performs the same with larger ones. Heck, one could even throw in the fact that <code>[*it]</code> is three less keystrokes.</p>
<p>Are these practical though? Would I think of them when trying to get a list out of an iterable? Well, maybe the keystrokes in order to stay under 79 characters and get the linter to shut it up.</p>
</div>
<span class="comment-copy">Corner case: it's possible to rebind the name <code>list</code> to something other than the built-in type, but you can't change the meaning of the <code>[*iterable]</code> syntax.</span>
<span class="comment-copy">While one could write <code>[*var] = iterable</code> to mean <code>var = list(iterable)</code>, from readability standpoint it’s too much even to someone who’s no stranger to code golf. Also what an interesting symmetry between <code>[*var] = iterable</code> and <code>var = [*iterable]</code> (though broken in case of <code>(*var,) = iterable</code> and <code>var = (*iterable,)</code>).</span>
<span class="comment-copy">@RomanOdaisky Indeed, <code>*lst, = (1,2,2); print(lst)</code> being the simplest I guess, though still not for recommended use</span>
<span class="comment-copy">Actually, I found a valid use case for this: <code>for keys, [*rows] in itertools.groupby(...):</code>!</span>
