<div class="post-text" itemprop="text">
<p>I'm trying to write something that collates a set of inputs that are sent within some time frame into a single request. My code is similar to:</p>
<pre class="lang-py prettyprint-override"><code>in_dict = defaultdict(list)
out_dict = defaultdict(list)
guard = asyncio.Lock()

async def collate(k, v):
    async with guard:
        in_dict[k].append(v)
    await asyncio.sleep(wait_time)
    async with guard:
        if k in in_dict and in_dict[k]:
            out_dict[k] = out_dict[k] + in_dict.pop(k)
        elif k in out_dict:
            handle_collated(out_dict.pop(k))
</code></pre>
<p>However, there seems to be a race condition somewhere where <code>out_dict[k]</code> still contains elements that have been processed.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p><code>...out_dict[k] still contains elements that have been processed.</code> - It isn't clear what the intent is from your example so a solution won't be possible. On the surface it looks like a logic problem.  </p>
<p>Leaving the async aside:</p>
<pre><code>&gt;&gt;&gt; in_dict = collections.defaultdict(list)
&gt;&gt;&gt; out_dict = collections.defaultdict(list)
</code></pre>
<p>The code  always <em>makes</em> a <code>k:v</code> item in <code>in_dict</code> first</p>
<pre><code>&gt;&gt;&gt; k, v = 1, ''
&gt;&gt;&gt; in_dict[k].append(v)
</code></pre>
<p>So <code>if k in in_dict and in_dict[k]</code> will always be <code>True</code> and the <code>elif</code> suite will never be executed. </p>
<pre><code>&gt;&gt;&gt; k in in_dict
True
&gt;&gt;&gt; bool(in_dict[k])
True
&gt;&gt;&gt;
&gt;&gt;&gt; if k in in_dict and in_dict[k]:
...     out_dict[k] = out_dict[k] + in_dict.pop(k)
... elif k in out_dict:
...     print(f'elif executed: {out_dict.pop(k)}')

&gt;&gt;&gt; in_dict
defaultdict(&lt;class 'list'&gt;, {})
&gt;&gt;&gt; out_dict
defaultdict(&lt;class 'list'&gt;, {1: ['']})
</code></pre>
<p>Next <em>call</em></p>
<pre><code>&gt;&gt;&gt; k,v = 1,'q'
&gt;&gt;&gt; in_dict[k].append(v)
&gt;&gt;&gt;
&gt;&gt;&gt; if k in in_dict and in_dict[k]:
...     out_dict[k] = out_dict[k] + in_dict.pop(k)
... elif k in out_dict:
...     print(f'elif executed: {out_dict.pop(k)}')
&gt;&gt;&gt;
&gt;&gt;&gt; in_dict
defaultdict(&lt;class 'list'&gt;, {})
&gt;&gt;&gt; out_dict
defaultdict(&lt;class 'list'&gt;, {1: ['', 'q']})
&gt;&gt;&gt;
</code></pre>
<hr/>
<p><a href="https://docs.python.org/3/reference/compound_stmts.html#the-if-statement" rel="nofollow noreferrer">The <code>if</code> statement</a></p>
</div>
<span class="comment-copy">Read about <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a></span>
<span class="comment-copy">Sorry, bad copy paste! Should have been in_dict.pop(k). Amended the post. Thanks for the taking the time though, my bad.</span>
<span class="comment-copy">@cosplay-raven - updated: regardless, the <code>elif</code> suite never gets executed.</span>
