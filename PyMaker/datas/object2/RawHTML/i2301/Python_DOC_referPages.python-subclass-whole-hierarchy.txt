<div class="post-text" itemprop="text">
<p><strong>My solution is at the bottom of the question, based on MisterMiyagi's example</strong></p>
<hr/>
<p>I wasn't sure how best to phrase the title. My idea is the following. I have an abstract base class with some implementations. Some of these implementations refer to eachother as part of their logic, simplified as follows:</p>
<pre><code>import abc


# the abstract class
class X(abc.ABC):
    @abc.abstractmethod
    def f(self):
        raise NotImplementedError()

# first implementation
class X1(X):
    def f(self):
        return 'X1'

# second implementation, using instance of first implementation
class X2(X):
    def __init__(self):
        self.x1 = X1()

    def f(self):
        return self.x1.f() + 'X2'

# demonstration
x = X2()
print(x.f())  # X1X2
print(x.x1.f())  # X1
</code></pre>
<p>Now I want to use these classes somewhere, let's say in another module. However I want to add some extra functionality (for example a function <code>g</code>) to all classes in the hierarchy. I could do that by adding it to the base class <code>X</code>, but I want to keep the functionality defined separately. For example I might want to define the new functionality like this:</p>
<pre><code>class Y(X):
    def g(self):
        return self.f() + 'Y1'
</code></pre>
<p>This creates another base class with the new functionality, but of course doesn't add it to the existing implementations <code>X1</code> and  <code>X2</code>. I'd have to use diamond inheritance to get that:</p>
<pre><code>class Y1(X1, Y):
    pass

class Y2(X2, Y):
    pass

# now I can do this:
y = Y2()
print(y.g())  # X1X2Y1
</code></pre>
<p>The above works correctly, but there is still a problem. In <code>X2.__init__</code>, an instance of <code>X1</code> is created. For my idea to work this would have to become <code>Y1</code> in <code>Y2.__init__</code>. But this is of course not the case:</p>
<pre><code>print(y.x1.g())  # AttributeError: 'X1' object has no attribute 'g'
</code></pre>
<p>I think what I might be looking for is a way to turn <code>X</code> into an abstract metaclass, such that its implementations require a 'base' parameter to become classes, which can then be instantiated. This parameter is then used within the class to instantiate other implementations with the correct base.</p>
<p>Creating an instance with the new functionality in the base class would then look something like this:</p>
<pre><code>class Y:
    def g(self):
        return self.f() + 'Y1'

X2(Y)()
</code></pre>
<p>Which would result in an object equivalent to an instance of the following class:</p>
<pre><code>class X2_with_Y:
    def __init__(self):
        self.x1 = X1(Y)()

    def f(self):
        return self.x1.f() + 'X2'

    def g(self):
        return self.f() + 'Y1'
</code></pre>
<p>However I don't know how to create a metaclass that would do this. I'd like to hear whether a metaclass is the right idea and, if so, how to do it.</p>
<hr/>
<p><strong>Solution</strong></p>
<p>Using MisterMiyagi's example I was able to get something that I think will work. The behaviour is close to the metaclass idea that I had.</p>
<pre><code>import abc


class X(abc.ABC):
    base = object  # default base class

    @classmethod
    def __class_getitem__(cls, base):
        if cls.base == base:
            # makes normal use of class possible
            return cls
        else:
            # construct a new type using the given base class and also remember the attribute for future instantiations
            name = f'{cls.__name__}[{base.__name__}]'
            return type(name, (base, cls), {'base': base})


    @abc.abstractmethod
    def f(self):
        raise NotImplementedError()


class X1(X):
    def f(self):
        return 'X1'


class X2(X):
    def __init__(self):
        # use the attribute here to get the right base for the other subclass
        self.x1 = X1[self.base]()

    def f(self):
        return self.x1.f() + 'X2'


# just the wanted new functionality
class Y(X):
    def g(self):
        return self.f() + 'Y1'
</code></pre>
<p>Usage is like this:</p>
<pre><code># demonstration
y = X2[Y]()
print(y.g())  # X1X2Y1
print(y.x1.g())  # X1Y1
print(type(y))  # &lt;class 'abc.X2[Y]'&gt;
# little peeve here: why is it not '__main__.X2[Y]'?

# the existing functionality also still works
x = X2()
print(x.f())  # X1X2
print(x.x1.f())  # X1
print(type(x))  # &lt;class '__main__.X2'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you are looking at a way to customise your classes, the easiest approach is to do just that:</p>
<pre><code>class X2(X):
    component_type = X1

    def __init__(self):
        self.x1 = self.component_type()

class Y2(X2, Y):
    component_type = Y1
</code></pre>
<p>Since <code>component_type</code> is a class attribute, it allows to specialise different variants (read: subclasses) of the same class.</p>
<hr/>
<p>Note that you can of course use other code to construct such classes. Classmethods can be used to create new, derived classes.</p>
<p>Say that for example your classes are capable of picking the correct <a href="https://stackoverflow.com/questions/3862310/how-to-find-all-the-subclasses-of-a-class-given-its-name/3862957">subclasses from their hierarchy</a>.</p>
<pre><code>class X2(X):
    hierarchy = X

    @classmethod
    def specialise(cls, hierarchy_base):
        class Foo(cls, hierarchy_base):
            hierarchy = hierarchy_base
        return Foo

Y2 = X2.specialise(Y)
</code></pre>
<p>Since Python3.7, it is possible to use <a href="https://docs.python.org/3/reference/datamodel.html#object.__class_getitem__" rel="nofollow noreferrer"><code>__class_getitem__</code></a> to write the above as <code>Y2 = X2[Y]</code>, similar to how <code>Tuple</code> can be specialised to <code>Tuple[int]</code>.</p>
<pre><code>class X2(X):
    hierarchy = X

    def __class_getitem__(cls, hierarchy_base):
        class Foo(cls, hierarchy_base):
            hierarchy = hierarchy_base
        return Foo

Y2 = X2[Y]
</code></pre>
<hr/>
<p>Class attributes often serve the functionality of metaclass fields, since they express precisely that. In theory, setting a class attribute is equivalent to adding a metaclass field, then setting it as an attribute for each class. What is exploited here is that Python allows instances to have attributes without classes defining their fields. One can think of class attributes as duck-typing metaclasses.</p>
</div>
<div class="post-text" itemprop="text">
<p>You problem is one that arrives quite often, namely that you want to change the behavior of an existing class.  The one aspect you can achieve by inheriting it and adding your new behavior.  All instances you then create of this subclass have the new behavior.</p>
<p>But you also want that <em>someone else</em> (in this case it's <code>X2</code>) who creates <em>further</em> instances of this class now instead creates instances of your own subclass with the added behavior instead.</p>
<p>This can be considered to be meddling in the affairs of someone else.  I mean, if the class <code>X2</code> wants to create an instance of <code>X1</code>, who are you (a mere user of <code>X2</code>!) to tell it that it shall instead create something else??  Maybe it doesn't work properly with something which is not of type <code>X1</code>!</p>
<p>Butâ€”of course.  Been there.  Done that.  I know that sometimes this need arises.</p>
<p>The straight way to achieve this is to make the class <code>X2</code> cooperate.  That means, instead of creating an instance of the class <code>X1</code> it could instead create an instance of a class passed as parameter:</p>
<pre><code>class X2(X):
    def __init__(self, x1_class=X1):
        self.x1 = x1_class()
</code></pre>
<p>This could also be nicely embedded using method overriding instead of parameter passing:</p>
<pre><code>class X2(X):
    @classmethod
    def my_x1(cls):
         return X1

    def __init__(self):
        self.x1 = self.my_x1()
</code></pre>
<p>and then in the other module:</p>
<pre><code>class Y2(X2, Y):
    @classmethod
    def my_x1(cls):
        return Y1
</code></pre>
<p>But all this just works if you can change the <code>X2</code>, and in some cases you cannot do this (because the module of the <code>X</code> is third-party provided or even a builtin library, so effectively read-only).</p>
<p>In these cases you can consider monkey-patching:</p>
<pre><code>def patched_init(self):
    self.x1 = Y1()

X1.__init__ = patched_init
</code></pre>
<p>Similar solutions can be approached using mocks as known from unit test modules.  but all these have in common that they are applied to intimate details of the current implementations of the used classes.  As soon as these change, the code breaks.</p>
<p>So if you can, it's way better to prepare the base classes (<code>X2</code>) to your project and make it more flexible for your use case.</p>
</div>
<span class="comment-copy">Is it not possible to make <code>X2</code> inherit from <code>X1</code> instead of instantiating it (using <code>super().f() + 'X2'</code>)? That way you could simply augment <code>X1</code> and that's it.</span>
<span class="comment-copy">The behaviour between the different <code>Xi</code> implementations is quite different in reality, so making them inherit from eachother rather than the base class would not make sense I think. Also, as I said I do not want to add this new functionality to the <code>X</code> family. It is new functionality that I want to add on top of it as the <code>Y</code> family while preserving the original <code>X</code> family. I want to do this to separate functionality, and also to have the possibility to have a <code>Z</code> family that also builds on <code>X</code> but has nothing to do with <code>Y</code>.</span>
<span class="comment-copy">Then what about using a metaclass in general which you can pass the family as an argument such as <code>class Y(X, family='Y')</code>. Then you could adjust variables accordingly in the metaclass' <code>__new__</code>.</span>
<span class="comment-copy">I think that may be close to what I'm thinking of, but I don't know how to implement it. For example I don't know where the <code>family</code> parameter goes or why <code>'Y'</code> is a string?</span>
<span class="comment-copy">The way you describe it, there is some <i>heavy</i> coupling between separate class hierarchies. Are you sure you look for a specialisation, i.e. <code>class Y2(Y, X2[Y1])</code>, instead of decoration, i.e. <code>class Y2(Y(X2(Y1)))</code>?</span>
<span class="comment-copy">Thanks! Though the problem with this would be that I actually have classes <code>X1...Xn</code>, which all need their own <code>Y1...Yn</code>, and those all need to know about all of eachother, so each would require attributes<code>component_type_1...component_type_n</code>. I'm hoping for a less manual and verbose solution.</span>
<span class="comment-copy">@Marein That is a very loose description. Where do the <code>X1...Xn</code>'s come from - are they manually defined or generated? Is <code>n</code> always the same? Does <code>Xn</code> need all of <code>Xn-1, Xn-2, ...</code> or just <code>Xn-1</code>? Is the <code>Xn, Xn-1, ...</code> relation inherent to the classes, or more suitable to be handled by an external factory?</span>
<span class="comment-copy">Sorry for being vague. I meant that, in my example, I have just <code>X1</code> and <code>X2</code>, but in my actual use case I have more implementations of <code>X</code>. They are manually defined, currently <code>n=4</code>. My point was that it becomes very verbose to (<code>n^2</code>) to define all the component types.</span>
<span class="comment-copy">I understand that you have more classes, but it is entirely unclear how they relate to each other. For example, if every <code>Xn</code> needs all other <code>X1...Xn</code>, it can fetch those from its baseclass. If instead every <code>Xn</code> needs a specific <code>Xn-1</code> it has to know it.</span>
<span class="comment-copy">I think I was able to do it with the help of your example! I've edited the question to show the result.</span>
<span class="comment-copy">"This can be considered to be meddling in the affairs of someone else." This is why I thought a metaclass with a 'base' parameter might be a good idea, since <code>X</code> would be by itself exposing the possibility of subclassing an outside class. With the parameter passing/method overriding solution I would still need to manually define all the <code>Yi</code> variants of all the <code>Xi</code> implementations. and I would need to pass all of them as parameters. I'm hoping for a less manual/verbose solution.</span>
