<div class="post-text" itemprop="text">
<p>I'm currently trying to get an array of numbers like this one randomly shuffled:</p>
<pre><code>label_array = np.repeat(np.arange(6), 12)
</code></pre>
<p>The only constrain is that no consecutive elements of the shuffle must be the same number. For that I'm currently using this code:</p>
<pre><code># Check if there are any occurrences of two consecutive 
# elements being of the same category (same number)
num_occurrences = np.sum(np.diff(label_array) == 0)

# While there are any occurrences of this...
while num_occurrences != 0:
    # ...shuffle the array...
    np.random.shuffle(label_array)

    # ...create a flag for occurrences...
    flag = np.hstack(([False], np.diff(label_array) == 0))
    flag_array = label_array[flag]

    # ...and shuffle them.
    np.random.shuffle(flag_array)

    # Then re-assign them to the original array...
    label_array[flag] = flag_array

    # ...and check the number of occurrences again.
    num_occurrences = np.sum(np.diff(label_array) == 0)
</code></pre>
<p>Although this works for an array of this size, I don't know if it would work for much bigger arrays. And even so, it may take a lot of time.</p>
<p>So, is there a better way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>May not be technically the best answer, hopefully it suffices for your requirements.</p>
<pre><code>import numpy as np
def generate_random_array(block_length, block_count):
    for blocks in range(0, block_count):
        nums = np.arange(block_length)
        np.random.shuffle(nums)
        try:
            if nums[0] == randoms_array [-1]:
                nums[0], nums[-1] = nums[-1], nums[0]
        except NameError:
            randoms_array = []
        randoms_array.extend(nums)
    return randoms_array


generate_random_array(block_length=1000, block_count=1000)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a way to do it, for Python &gt;= 3.6, using <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer">random.choices</a>, which allows to choose from a population with weights.</p>
<p>The idea is to generate the numbers one by one. Each time we generate a new number, we exclude the previous one by temporarily setting its weight to zero. Then, we decrement the weight of the chosen one. </p>
<p>As @roganjosh duly noted, we have a problem at the end when we are left with more than one instance of the last value - and that can be really frequent, especially with a small number of values and a large number of repeats.</p>
<p>The solution I used is to insert these value back into the list where they don't create a conflict, with the short <code>send_back</code> function.</p>
<pre><code>import random

def send_back(value, number, lst):
    idx = len(lst)-2
    for _ in range(number):
        while lst[idx] == value or lst[idx-1] == value:
            idx -= 1
        lst.insert(idx, value)


def shuffle_without_doubles(nb_values, repeats):
    population = list(range(nb_values))
    weights = [repeats] * nb_values
    out = []
    prev = None
    for i in range(nb_values * repeats):
        if prev is not None:
            # remove prev from the list of possible choices
            # by turning its weight temporarily to zero
            old_weight = weights[prev]
            weights[prev] = 0    

        try:
            chosen = random.choices(population, weights)[0]
        except IndexError:
            # We are here because all of our weights are 0,
            # which means that all is left to choose from
            # is old_weight times the previous value
            send_back(prev, old_weight, out)
            break

        out.append(chosen)
        weights[chosen] -= 1
        if prev is not None:
            # restore weight
            weights[prev] = old_weight
        prev = chosen
    return out
</code></pre>
<hr/>
<pre><code>print(shuffle_without_doubles(6, 12))

[5, 1, 3, 4, 3, 2, 1, 5, 3, 5, 2, 0, 5, 4, 3, 4, 5,
 3, 4, 0, 4, 1, 0, 1, 5, 3, 0, 2, 3, 4, 1, 2, 4, 1,
 0, 2, 0, 2, 5, 0, 2, 1, 0, 5, 2, 0, 5, 0, 3, 2, 1,
 2, 1, 5, 1, 3, 5, 4, 2, 4, 0, 4, 2, 4, 0, 1, 3, 4,
 5, 3, 1, 3]
</code></pre>
<p>Some crude timing: it takes about 30 seconds to generate <code>(shuffle_without_doubles(600, 1200))</code>, so 720000 values.</p>
</div>
<span class="comment-copy">Interesting question. You surely have noted that this is not possible for every array. One possible approach could be picking one element at a time, but restricting it to the set elements that would not lead to a bad solution if they were chosen... however I am not sure whether that is easy to compute.</span>
<span class="comment-copy">See here: <a href="https://stackoverflow.com/questions/25285792/generate-all-permutations-of-a-list-without-adjacent-equal-elements">Is there a way to shuffle an array so that no two consecutive values are the same?</a></span>
<span class="comment-copy">Btw does your array always follow the same structure? That is, does it always have <code>n</code> different elements, each repeated <code>k</code> times? Or is there no rule for the number of repetitions?</span>
<span class="comment-copy">Possible dupe: <a href="https://stackoverflow.com/q/36455104/674039">Create a random order of (x, y) pairs, without repeating/subsequent x's</a></span>
<span class="comment-copy">This is definitely a good idea. The only thing is that the distribution of the samples is going to be contained inside each subset, which can be a problem for some applications of the function.  In my case, this is intended to randomize categories of stimuli for behavioural experiments, so this works wonders, and also runs very fast for very lenghty lists.</span>
<span class="comment-copy">This is very similar to what I am working on, but you can fail on the last couple of selections, no? It's possible that you may have no viable options once you get towards the end</span>
<span class="comment-copy">@roganjosh I don't see why. The total of weights is always equal to the number of values we still have to generate, and only the ones we can choose have non-zero weights. For the final value, for example, the weights would be something like [0, 0, 0, 1, 0, 0], so we are sure that 3 would be chosen. Am I missing something?</span>
<span class="comment-copy">Because in theory, you could have 3 <code>0</code> values left to place towards the end? It's a random distribution so when you come to fill your last index, for example, what is the <i>guarantee</i> that the second to last value is not the same as what you have left to place? Mine is failing occasionally on this.</span>
<span class="comment-copy">Yup, it fails. Just had your function crash on me twice with <code>IndexError</code>. This doesn't work, you need to run it repeatedly.</span>
<span class="comment-copy">You're right, I had missed that one. In that case, all of my weights would be 0, and <code>random.choices</code> would fail with an <code>IndexError</code>. I'll think on how to prevent that...</span>
