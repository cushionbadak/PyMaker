<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/26502775/pycharm-simplify-chained-comparison">PyCharm: “Simplify Chained Comparison”</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/28754726/how-do-chained-comparisons-in-python-actually-work">How do chained comparisons in Python actually work?</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>Probably some of you might think this is duplicate, and yes, I found a lot of examples similar to this:
<a href="https://i.stack.imgur.com/og0TY.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/og0TY.png"/></a></p>
<p>But Pycharm says that I could simply this:</p>
<pre><code>if y &gt; x and x != -1:
    #  do something
</code></pre>
<p>And I did some searching and could not find something similar.
My question is it correct to simplify this function like this:</p>
<pre><code>if y &gt; x != -1:
    #  do something
</code></pre>
<p>And if so, is it safe and is there is any difference at all between this version and not simplified version except that it's shorter?
If it is not correct way to simplify it, what is then?</p>
</div>
<div class="post-text" itemprop="text">
<p>this is functionnaly equivalent, but when this:</p>
<pre><code>10 &lt; x &lt; 40
</code></pre>
<p>is nice to read, mixing different operators to use chained comparisons isn't the best choice.</p>
<p>Is that <em>really</em> the same? let's disassemble to find out:</p>
<pre><code>def f1(x,y):
    if y &gt; x and x != -1:
        return 0

def f2(x,y):
    if y &gt; x != -1:
        return 0

import dis

print("function 1")
dis.dis(f1)
print("function 2")
dis.dis(f2)
</code></pre>
<p>result:</p>
<pre><code>function 1
  2           0 LOAD_FAST                1 (y)
              3 LOAD_FAST                0 (x)
              6 COMPARE_OP               4 (&gt;)
              9 POP_JUMP_IF_FALSE       28
             12 LOAD_FAST                0 (x)
             15 LOAD_CONST               3 (-1)
             18 COMPARE_OP               3 (!=)
             21 POP_JUMP_IF_FALSE       28

  3          24 LOAD_CONST               2 (0)
             27 RETURN_VALUE
        &gt;&gt;   28 LOAD_CONST               0 (None)
             31 RETURN_VALUE
function 2
  6           0 LOAD_FAST                1 (y)
              3 LOAD_FAST                0 (x)
              6 DUP_TOP
              7 ROT_THREE
              8 COMPARE_OP               4 (&gt;)
             11 JUMP_IF_FALSE_OR_POP    23
             14 LOAD_CONST               3 (-1)
             17 COMPARE_OP               3 (!=)
             20 JUMP_FORWARD             2 (to 25)
        &gt;&gt;   23 ROT_TWO
             24 POP_TOP
        &gt;&gt;   25 POP_JUMP_IF_FALSE       32

  7          28 LOAD_CONST               2 (0)
             31 RETURN_VALUE
        &gt;&gt;   32 LOAD_CONST               0 (None)
             35 RETURN_VALUE
&gt;&gt;&gt; 
</code></pre>
<p>Surprisingly they aren't the same, and the chained version has <em>more</em> instructions.</p>
<p>Not sure what's going on here (some took some more time to explain it better: <a href="https://stackoverflow.com/questions/28754726/how-do-chained-comparisons-in-python-actually-work">How do chained comparisons in Python actually work?</a>), but really I'd stick to the <code>and</code> version which shortcuts and is so much readable (think of future maintainers too...).</p>
<p>That said, one interesting thing about chained comparisons would be if the central argument is computed/takes a long time to compute/has a side effect in the computation and you don't want to store it in a variable:</p>
<pre><code>if y &gt; super_long_computation(x) != -1:
</code></pre>
<p>In that case, the central argument is only evaluated once. In the case of <code>and</code>, you'd have to store it beforehand.</p>
</div>
<span class="comment-copy">this is equivalent, but not the most readable...</span>
<span class="comment-copy">Agreed with @Jean-FrançoisFabre. It may be shorter, but readability is one nice thing about Python, and it seems like a shame to throw it away to save a few characters. Particularly if someone else might end up working with your code and having to rehash your own concerns about its safety and correctness.</span>
<span class="comment-copy">What is x and y supposed to be here?</span>
<span class="comment-copy">@Sayse it doesn't matter, it's guaranteed to be equivalent. Here are <a href="https://docs.python.org/3/reference/expressions.html#comparisons" rel="nofollow noreferrer">the docs</a></span>
<span class="comment-copy">The byte code is doing equivalent things, but jumps through some hoops to only evaluate <code>x</code> once, which <i>could</i> be an expression like <code>x**2</code>, which it will only evaluate once</span>
<span class="comment-copy">Here's a <a href="https://stackoverflow.com/questions/28754726/how-do-chained-comparisons-in-python-actually-work">good breakdown</a></span>
<span class="comment-copy">good link, edited the answer</span>
