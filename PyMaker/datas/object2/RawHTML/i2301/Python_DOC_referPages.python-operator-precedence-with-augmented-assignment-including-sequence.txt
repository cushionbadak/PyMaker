<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/52505021/python-operator-precedence-with-augmented-assignment">Python operator precedence with augmented assignment</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>Following up <a href="https://stackoverflow.com/questions/52505021/python-operator-precedence-with-augmented-assignment">my previous question</a> I have the following one. Are these the same in Python?</p>
<pre><code>a += b[1] / 2
</code></pre>
<p>and</p>
<pre><code>a += (b[1] / 2)
</code></pre>
<p>Providing that:</p>
<ul>
<li><code>a</code> has already been defined earlier as float</li>
<li><code>b</code> is a list of tuples</li>
<li><code>b[1]</code> is a tuple with a single element</li>
</ul>
<p>Similarly I would be interested to learn as well the behavior if:</p>
<ul>
<li><code>a</code> has already been defined earlier as float</li>
<li><code>b</code> is a list of floats</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The rules of how Python parses expressions are defined in the <a href="https://docs.python.org/3/reference/grammar.html#full-grammar-specification" rel="nofollow noreferrer"><em>Python grammar</em></a>. Note that the <strong><em>types</em> are irrelevant</strong>. In fact Python is <em>dynamically</em> types, so that means that at the time an expression is parsed and analyzed, the types of the variables is <em>unknown</em>. In fact a variable have different values (with different types) through the process, and a line can be evaluated multiple times, with the variables each time carrying a value of a different type.</p>
<p>If we take a look at the grammar, we see:</p>
<blockquote><pre><code>expr: xor_expr ('|' xor_expr)*
xor_expr: and_expr ('^' and_expr)*
and_expr: shift_expr ('&amp;' shift_expr)*
shift_expr: arith_expr (('&lt;&lt;'|'&gt;&gt;') arith_expr)*
arith_expr: term (('+'|'-') term)*
<b>term: factor (('*'|'@'|'/'|'%'|'//') factor)*</b>
factor: ('+'|'-'|'~') factor | power
power: atom_expr ['**' factor]
atom_expr: ['await'] atom trailer*
atom: ('(' [yield_expr|testlist_comp] ')' |
       '[' [testlist_comp] ']' |
       '{' [dictorsetmaker] '}' |
       NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False')
testlist_comp: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] )
trailer: '(' [arglist] ')' | <b>'[' subscriptlist ']'</b> | '.' NAME</code></pre></blockquote>
<p>The "<em>subscription</em>" (the <code>[1]</code> in <code>b[1]</code> is thus defined in a <em>production rule</em> of <code>trailer</code>, and if we look at the grammar, this can only be the product of a <code>factor</code>, so that means that the <code>/</code> operator takes precedence over the subscription.</p>
<p>So that means that:</p>
<pre><code>a += b[1] / 2
</code></pre>
<p>is equivalent to:</p>
<pre><code>a += ((b[1]) / 2)
</code></pre>
<p>Note that since Python is dynamically typed, the parsing (and analyzing) step will not give any guarantees that the expression is <em>sensical</em>. For example a tuple can not be devided by two. So this will result in a <code>TypeError</code>:</p>
<pre><code>&gt;&gt;&gt; (2.0, 4.0) / 2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for /: 'tuple' and 'int'
</code></pre>
<p>For a <code>numpy</code> array however, this makes sense:</p>
<pre><code>&gt;&gt;&gt; from numpy import array
&gt;&gt;&gt; array([2.0, 4.0])/2
array([1., 2.])
</code></pre>
</div>
<span class="comment-copy">The type is irrelevant for the precedence in parsing.</span>
<span class="comment-copy">I think what you're asking is "since <code>a += expr</code> is more-or-less equivalent to <code>a = a + expr</code>, do I need to worry about the precedence of addition compared to the precedence of the other operators in the expression?" I think the existing answer on your previous question covers that: the addition and the assignment always happen last.</span>
<span class="comment-copy">Yes, those are <b>still the same thing</b>. It doesn't matter what variations of expressions you come up with, the <code>+=</code> augmented assignment still will not be anything more than a statement.</span>
<span class="comment-copy">It's best to think of <code>a += expr</code> as being <i>suggestive</i> of <code>a = a + expr</code>; the actual semantics of an augmented assignment operator are independent of the corresponding binary operator. (That is, <code>a += b</code> doesn't <i>have</i> to mean anything like <code>a = a + b</code>, but it would be very surprising it wasn't as close as possible to it.)</span>
<span class="comment-copy">And if <code>b[1]</code> really is a <code>tuple</code>, then the expression will raise an exception as there is no division operation on tuples.</span>
