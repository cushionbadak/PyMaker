<div class="post-text" itemprop="text">
<p>I have the following code (Its useless, just for performance testing)</p>
<pre><code>class A:
    def __init__(self, i):
        self.i = i

start = datetime.now()
foo = {}
for i in range(10000000):
    foo[i] = A(i)

print('\nSpent: [ {} ] seconds!'.format((datetime.now()-start).total_seconds()))
</code></pre>
<p>The thing is, that when I run it with Python3.7 I get the following results</p>
<pre><code>Spent: [ 7.644764 ] seconds!
</code></pre>
<p>But when I run it with Python3.6</p>
<pre><code>Spent: [ 6.521555 ] seconds!
</code></pre>
<p>So the question is, do I misunderstand something or the older python is faster and I should use the old one?</p>
<p>UPD: As suggested in the comments, I've used <code>timeit</code> module, here the results</p>
<pre><code>python3.7 -m timeit '"-".join(str(n) for n in range(2000000))'
1 loop, best of 5: 499 msec per loop

python3.6 -m timeit '"-".join(str(n) for n in range(2000000))'
10 loops, best of 3: 405 msec per loop
</code></pre>
<p>The results with <code>timeit</code> are still bad for 3.7, is it really slower than 3.6 ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your timing method is flawed. Across 6-7 seconds a modern OS won't give Python exclusive access to the CPU, other things are happening too, as the OS switches between processes, flushes disk buffers for files being written, executes scheduled network events, etc.</p>
<p>You also generate quite a lot of objects that are all loaded into memory, so Python has to ask the OS for additional memory pages to be allocated. It depends on what else your computer was executing at the time how fast that memory can be given. It appears that you ran Python 3.6 second, so it could easily be that the memory freed and re-allocated to the Python 3.7 run is still available for the 3.6 run, and recently released memory is much easier to reallocate for the OS.</p>
<p>Next, you used a rather imprecise wall-clock timer to time your performance. <code>datetime.now()</code> is fine for humans that want to know the current time, it is not fine for measuring performance. There are better, more specialised clocks available to Python for the latter task. Python itself also has a background process called the <em>garbage collector</em> that'll also want to get some time to do its work, affecting how Python performs the tasks you gave it.</p>
<p>Instead, you need to separate out different problems that Python has to solve here into separate tests. Run those separate tests under controlled circumstances, with an accurate clock, and with as many distractions as possible disabled. Run those tests <em>many, many times</em> and then take either an average time (if you only have an aggregate available) or the best time from many repeats.</p>
<p>Python has a library for this, called <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a>. Use that to <em>only</em> create the instances, not store them all in a dictionary too. As stated before, memory allocation is subject to the OS's timings, not Python's. Make sure to keep repeating your tests; if <code>-m timeit</code> runs a test just <em>once</em> you really can't trust the timings, reduce the work done in the benchmark.</p>
<p>Next, if your goal is to compare Python 3.6 vs 3.7 on <em>general performance terms</em> and not a specific microbenchmark, then you'll need to a wide range of tests. Stuff changes all the time from 3.x to 3.x+1 releases. Don't base anything on a single string join or instance creation test. And know that the Python developers will <strong>already</strong> have done all that work. See <a href="https://speed.python.org/" rel="nofollow noreferrer">https://speed.python.org/</a> for a full suite of benchmarks and timings that the core team uses to monitor performance, or see the <a href="https://pyperformance.readthedocs.io/" rel="nofollow noreferrer">PyPerformance suite</a> for another such benchmark.</p>
</div>
<span class="comment-copy">No, it means your timing method is flawed. Did you run both  versions <i>multiple times</i>? Did you eliminate other OS influences, such as disk flushes and garbage collection and networking activity?</span>
<span class="comment-copy">how many times have you repeated this?</span>
<span class="comment-copy">You really want to use the <code>timeit</code> module to make assessments about performance. Let that module handle repetition and time measurements, for example.</span>
<span class="comment-copy">About 5-7 times, the difference is from 0.8 to 1.1 seconds always (with python3.6 being faster), that a huge difference though</span>
<span class="comment-copy">Your additional test ran <b>once</b> on python3.7. With a smaller range, 20000, <code>timeit</code> can actually run the tests many more times and I get <code>5.3 msec</code> vs. <code>5.42</code> msec (3.7 vs 3.6). With 2000 elements, the timings are <code>425 usec</code> and <code>525 usec</code>. Python 3.7 is <i>not slower</i>, your test was still flawed.</span>
<span class="comment-copy">Thank you very much for your time, now I get it</span>
