<div class="post-text" itemprop="text">
<p>I'm trying to solve <a href="https://leetcode.com/problems/longest-palindromic-subsequence/description/" rel="nofollow noreferrer">this problem</a> on LeetCode, which reads:</p>
<p><a href="https://i.stack.imgur.com/xHUrV.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/xHUrV.png"/></a></p>
<p>Following <a href="https://leetcode.com/problems/longest-palindromic-subsequence/discuss/99111/Evolve-from-brute-force-to-dp" rel="nofollow noreferrer">the most upvoted Java solution</a>, I came up with the following memoized solution:</p>
<pre><code>import functools


class Solution:
    def longestPalindromeSubseq(self, s):
        return longest_palindromic_subsequence(s)


@functools.lru_cache(maxsize=None)
def longest_palindromic_subsequence(s):
    if not s:
        return 0
    if len(s) == 1:
        return 1
    if s[0] == s[-1]:
        return 2 + longest_palindromic_subsequence(s[1:-1])
    return max(
        longest_palindromic_subsequence(s[0:-1]),
        longest_palindromic_subsequence(s[1:]))
</code></pre>
<p>The problem is that the time limit is exceeded for an input string which appears to have many repeated characters:</p>
<p><a href="https://i.stack.imgur.com/kAhb1.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/kAhb1.png"/></a></p>
<p>As I understand from the cited discussion, without the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a>, the time complexity of this algorithm is O(2^N) because, at each reduction of the string length by one character, two recursive calls are made.</p>
<p>However, the discussion states that the memoized solution is O(N^2), which shouldn't exceed the time limit. I don't really see how memoization reduces the time complexity, however, and it doesn't seem to be the case here.</p>
<p>What further puzzles me is that if the solution consists of many repeated characters, it should actually run in O(N) time since each time the first and last characters are the same, only one recursive call is made.</p>
<p>Can someone explain to me why this test is failing?</p>
</div>
<div class="post-text" itemprop="text">
<p>String slicing in Python is <code>O(n)</code> (<code>n</code> being the length of the slice) while java's substring is <code>O(1)</code> as it merely creates a view on the same underlying <code>char[]</code>. You can take the slices out of the equation, however, by simply operating on the same string with two moving indexes. Moreover, you can move indexes past blocks of identical letters when first and last are not the same:</p>
<pre><code>@functools.lru_cache(maxsize=None)
def longest_palindromic_subsequence(s, start=None, end=None):
    if start is None:
        start = 0
    if end is None:
        end = len(s) - 1
    if end &lt; start:
        return 0
    if end == start:
        return 1
    if s[start] == s[end]:
        return 2 + longest_palindromic_subsequence(s, start+1, end-1)

    # you can move indexes until you meet a different letter!
    start_ = start
    end_ = end
    while s[start_] == s[start]: 
        start_ += 1
    while s[end_] == s[end]: 
        end_ -= 1

    return max(
        longest_palindromic_subsequence(s, start, end_),
        longest_palindromic_subsequence(s, start_, end))
</code></pre>
<p>Memoizaton should help significantly. Take input <code>"abcde"</code>. In the <code>return max(...)</code> part, eventually two recursive calls will be made for <code>"bcd"</code>, and even more calls for the further embedded substrings.</p>
</div>
<span class="comment-copy">related: <a href="https://codereview.stackexchange.com/questions/109562/longest-palindromic-subsequence-by-memoization" title="longest palindromic subsequence by memoization">codereview.stackexchange.com/questions/109562/â€¦</a></span>
<span class="comment-copy">I actually still get "Time Limit Exceeded" using two moving indices instead of array slicing. I can see that there are significant time savings from the <code>lru_cache</code> (also by using <code>pytest</code> with the <code>--duration</code> option), but can you 'prove' that this fundamentally changes the time complexity?</span>
<span class="comment-copy">@KurtPeek I amended my answer with a significant improvement.</span>
