<div class="post-text" itemprop="text">
<p>I have two list . i want to compare with each other with the list index[1][2][3] of "a" of each list with other list index[1][2][3] of "b" .If its a match then ignore , if not then return the whole list.</p>
<pre><code>a = [['Eth1/1/13', 'Marketing', 'connected', '10', 'full', 'a-1000'], ['Eth1/1/14', 'NETFLOW02', 'connected', '10', 'full', '100']]

b = [['Eth1/1/13', 'NETFLOW02', 'connected', '15', 'full', '100'], ['Eth1/1/14', 'Marketing', 'connected', '10', 'full', 'a-1000']]
</code></pre>
<p>Desired Output :</p>
<pre><code>Diff a:

Eth1/1/14  NETFLOW02   connected    10   full    100

Diff b:

Eth1/1/13  NETFLOW02    connected    15   full    100
</code></pre>
<p>What i am trying :</p>
<pre><code>p = [i for i in a if i not in b]
for item in p: 
      print item[0]
print "\n++++++++++++++++++++++++++++++\n"
q = [i for i in b if i not in a]
for item in q: 
      print item[0]
</code></pre>
<p>tried below but only managed to match index 1 of inner list , index 2 and 3 still need to be matched..</p>
<pre><code>[o for o in a if o[1] not in [n[1] for n in b]
</code></pre>
<p>I am not getting the expected output.Any idea how to do this ?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>for sublista in a:
    if not any(sublista[1:4] == sublistb[1:4] for sublistb in b):
        print(sublista)
</code></pre>
<p>You need an inner loop so that each <em>sub-list</em> from list <code>a</code> can be compared to each <em>sub-list</em> in list <code>b</code>.  The inner loop is accomplished with a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a>. <a href="https://docs.python.org/3/reference/expressions.html#slicings" rel="nofollow noreferrer">Slices</a> are used to to compare only a portion of the <em>sub-lists</em>. The built-in function <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any</code></a> consumes the generator expression; it is <a href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="nofollow noreferrer"><em>lazy</em></a> and will return <code>True</code> with the <strong>first</strong> <code>True</code> equivalency comparison.  This will print each <em>sub-list</em> in <code>a</code> that does not have a match in <code>b</code> - to print each <em>sub-list</em> in <code>b</code> that does not have a match in <code>a</code>, put <code>b</code> in the outer loop and <code>a</code> in the inner loop.</p>
<p>Here is an equivalent Without using a generator expression or <code>any</code>:</p>
<pre><code>for sublista in a:
    equal = False
    for sublistb in b:
        if sublista[1:4] == sublistb[1:4]:
            break
    else:
        print(sublista)
</code></pre>
<p>Sometimes it is nice to use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a> so you can use names for the slices which can make the code more intelligible.:</p>
<pre><code>import operator
good_stuff = operator.itemgetter(1,2,3)
for sublista in a:
    if not any(good_stuff(sublista) == good_stuff(sublistb) for sublistb in b):
        print(sublista)
</code></pre>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> conveniently <em>generates</em> pairs and can be used as a substitute for the nested loops above.  The following uses a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">dictionary (<code>defaultdict</code>)</a> to hold comparison results for each sublist in <code>a</code> and <code>b</code>, then checks to see if there were matches - it does both the <code>a</code> to <code>b</code> and <code>b</code> to <code>a</code> comparisons.</p>
<pre><code>import itertools, collections
pairs = itertools.product(a, b)
results = collections.defaultdict(list)
for sub_one, sub_two in pairs:
    comparison = good_stuff(sub_one) == good_stuff(sub_two)
    results[tuple(sub_one)].append(comparison)
    results[tuple(sub_two)].append(comparison)

for sublist, comparisons in results.items():
    if any(comparisons):
        continue
    print(sublist)

# or
from pprint import pprint
results = [sublist for sublist, comparisons in results.items() if not any(comparisons)]
pprint(results)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>for v in a,b:
    for items in v:
        if 'NETFLOW02' in items:
            print('\t'.join(items))
</code></pre>
<p>I'm not sure this is ok for your purpose but you seems to want to capture the results of a network interface called <code>NETFLOW02</code> from these two lists.</p>
<p>I'm sure there's probably a reason this is unacceptable but you could also expand this to include other keywords in longer lists, well, any length of lists that are nested as far as explained in your question. To do this, you would need to create another list, hypothetically <code>keywords = ['NETFLOW02','ETH01']</code></p>
<p>Then we simply iterate this list also.</p>
<pre><code>results = []
for v in a,b:
    for item in v:
        for kw in keywords:
            if kw in item:
            results.append(item)
            print('\t'.join(item))
print(results)
</code></pre>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/6486450/python-compute-list-difference" title="python compute list difference">stackoverflow.com/questions/6486450/â€¦</a></span>
<span class="comment-copy">What output do you get?</span>
<span class="comment-copy"><i>"I am not getting the expected output."</i> What is the error? What output did you get?</span>
<span class="comment-copy">I doubt you mean <code>a[1][2][3]</code>, which would return <code>'n'</code>, do you mean index 1, 2 and 3?</span>
<span class="comment-copy">You want to compare items one, two, and three of the <b>inner</b> lists? Your solution is comparing <i>complete</i> <b>inner</b> lists, I don't see any any indexing or slices.</span>
<span class="comment-copy">Consider adding a short description of how your code solves the posted question</span>
<span class="comment-copy">@HenryWoody - see edit: thnx i had intended to but got interrupted by work.</span>
