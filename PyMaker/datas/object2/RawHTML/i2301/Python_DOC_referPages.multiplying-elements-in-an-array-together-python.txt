<div class="post-text" itemprop="text">
<p>I'm attempting a question where I need to find the largest product of 2 digits contained within a long number:</p>
<pre><code>Number = 73167176531330624919225119674426574742355349194934

lst = [int(i) for i in str(Number)]
print(lst)

new_lst = []

for i in lst:
    new_lst.append(i*(i+1))
    print(new_lst)
</code></pre>
<p>However, what I am attempting above gives the result 56, how do I multiply 7*3, then 3*1, and so on...</p>
<p>EDIT for H</p>
<pre><code>Number = 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

lst = [int(i) for i in str(Number)]
print(lst)

new_lst = []

for i, value in enumerate(lst):
    new_lst.append(lst[i-13]*(lst[i-12])*(lst[i-11])*(lst[i-10])*(lst[i-9])*(lst[i-8])*(lst[i-7])*(lst[i-6])*(lst[i-5])*(lst[i-4])*(lst[i-3])*(lst[i-2])*(lst[i-1]))
print(max(new_lst))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can iterate over a <code>zip</code> the list and a slice of it with the start differing by 1:</p>
<pre><code>max(a * b for a, b in zip(lst, lst[1:]))
</code></pre>
<p>This returns: <code>54</code> (because of <code>9</code> and <code>6</code> in the number)</p>
</div>
<div class="post-text" itemprop="text">
<p>You are currently multiplying the number i times i + 1. You could use <code>range</code> to do what you want like this:</p>
<pre><code>for i in range(len(lst)-1):
        new_lst.append(lst[i]*(lst[i+1]))
        print(new_lst)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>itertools</code> has a recipe for this called <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><strong><code>pairwise</code></strong></a>.</p>
<pre><code>&gt;&gt;&gt; from itertools import tee
&gt;&gt;&gt; def pairwise(iterable):
...     "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
...     a, b = tee(iterable)
...     next(b, None)
...     return zip(a, b)
... 
&gt;&gt;&gt; [a*b for a,b in pairwise(map(int, '1234'))]
[2, 6, 12]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Number = 73167176531330624919225119674426574742355349194934</p>
<p>lst = [int(i) for i in str(Number)]
print(lst)</p>
<p>new_lst = []</p>
<p>for i in xrange(len(lst)-1):
    new_lst.append(lst[i]*lst[i+1])
    print new_lst</p>
</div>
<div class="post-text" itemprop="text">
<p>You want something like this perhaps:         </p>
<pre><code>Number = 73167176531330624919225119674426574742355349194934

print(max(int(x)*int(y) for x, y in zip(str(Number)[:-1], str(Number)[1:])))
</code></pre>
<p>Answer will be 54 (9*6)</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to create a list to calculate the maximum of an iterable. This will be inefficient. Here is a functional solution using <code>max</code>, <code>map</code> and <code>mul</code>:</p>
<pre><code>from operator import mul

x = '73167176531330624919225119674426574742355349194934'

res = max(map(mul, map(int, x), map(int, x[1:]))) # 54
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>a version strictly using integer arithmetic (as opposed to strings):</p>
<pre><code>Number = 73167176531330624919225119674426574742355349194934

max_prod, a, b = 0, None, None

Number, prev = divmod(Number, 10)
while Number:
    Number, cur = divmod(Number, 10)
    prod = cur * prev
    if prod &gt; max_prod:
        max_prod, a, b = prod, cur, prev
        # if prod == 81:  # prod will never be bigger; can as well stop here.
        #     break
    prev = cur

print(a, b, max_prod)  # 9 6 54
</code></pre>
<hr/>
<p>update to show how this would work for your current question (where you look for the maximum product of 13 adjacent digits):</p>
<pre><code>Number = int('731671765313306249192251196744265747423553491949349698352031277450632623957831801698480186947885184385861'
             '560789112949495459501737958331952853208805511125406987471585238630507156932909632952274430435576689664895'
             '044524452316173185640309871112172238311362229893423380308135336276614282806444486645238749303589072962904'
             '915604407723907138105158593079608667017242712188399879790879227492190169972088809377665727333001053367881'
             '220235421809751254540594752243525849077116705560136048395864467063244157221553975369781797784617406495514'
             '929086256932197846862248283972241375657056057490261407972968652414535100474821663704844031998900088952434'
             '506585412275886668811642717147992444292823086346567481391912316282458617866458359124566529476545682848912'
             '883142607690042242190226710556263211111093705442175069416589604080719840385096245544436298123098787992724'
             '428490918884580156166097919133875499200524063689912560717606058861164671094050775410022569831552000559357'
             '2972571636269561882670428252483600823257530420752963450')

def digit_prod(i):
    '''
    return the product of all the decimal digits in i
    '''
    if i == 0:
        return 0
    prod = 1
    while i:
        i, r = divmod(i, 10)
        if r == 0:
            return 0
        prod *= r
    return prod


max_prod, res = 0, None

mod = 10**13
while Number:
    i = Number % mod
    prod = digit_prod(Number % mod)
    if prod &gt; max_prod:
        max_prod, res = prod, i
        # if prod == 9**13: # prod will never be bigger; can as well stop here.
        #     break
    Number //= 10

print(res, max_prod)  # 5576689664895 23514624000
</code></pre>
</div>
<span class="comment-copy">You iterate over values, not indices. You may want to use <code>for i in range(len(lst))</code> but even better would be <code>for i, v in enumerate(lst)</code>. Have fun.</span>
<span class="comment-copy">Must your "2 digits" be adjacent? Or are you looking for 81 as your end result (as there are multiple 9's).</span>
<span class="comment-copy">@jpp they must be adjacent</span>
<span class="comment-copy"><code>IndexError: list index out of range</code></span>
<span class="comment-copy">Feel free to edit and add checks @timgeb You could add a bunch of exception handling, but this is not the main issue here</span>
<span class="comment-copy">you appear to forget the last number,<code>list index out of range</code></span>
<span class="comment-copy">@hakaishin - see edit, I've adapted your answer to fit in with the question i'm really trying to answer, I'm looking to make a loop with this</span>
<span class="comment-copy">always better to be able to generalise a solution and make it into a function</span>
<span class="comment-copy">Cool! Now I'm going to try and expand this to 13 digits, appreciate it</span>
<span class="comment-copy">define <code>str(Number)</code> once before the <code>max()</code> call</span>
<span class="comment-copy">assuming positive numbers only <code>operator.mul(*map(int, max(zip(str(Number)[:-1], str(Number)[1:]))))</code></span>
<span class="comment-copy">@Chris_Rands similar answer is already <a href="https://stackoverflow.com/a/52495106/5349542">there</a> using functional approach.</span>
