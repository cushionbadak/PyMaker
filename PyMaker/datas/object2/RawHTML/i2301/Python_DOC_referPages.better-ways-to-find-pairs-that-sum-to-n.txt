<div class="post-text" itemprop="text">
<p>Is there a faster way to write this, the function takes a list and a value to find the pairs of numeric values in that list that sum to N without duplicates I tried to make it faster by using sets instead of using the list itself (however I used count() which I know is is linear time) any suggestions I know there is probably a way</p>
<pre><code>def pairsum_n(list1, value):

    set1 = set(list1)
    solution = {(min(i, value - i) , max(i, value - i)) for i in set1 if value - i in set1}
    solution.remove((value/2,value/2)) if list1.count(value/2) &lt; 2 else None           
    return solution
"""
    Example: value = 10, list1 = [1,2,3,4,5,6,7,8,9]
    pairsum_n = { (1,9), (2,8), (3,7), (4,6) }
    Example: value = 10,  list2 = [5,6,7,5,7,5,3]
    pairsum_n = { (5,5), (3,7) }
"""
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your approach is quite good, it just needs a few tweaks to make it more efficient. <code>itertools</code> is convenient, but it's not really suitable for this task because it produces so many unwanted pairs. It's ok if the input list is small, but it's too slow if the input list is large.</p>
<p>We can avoid producing duplicates by looping over the numbers in order, stopping when <code>i &gt;= value/2</code>, after using a set to get rid of dupes.</p>
<pre><code>def pairsum_n(list1, value): 
    set1 = set(list1)
    list1 = sorted(set1)
    solution = []
    maxi = value / 2
    for i in list1:
        if i &gt;= maxi:
            break
        j = value - i
        if j in set1:
            solution.append((i, j))
    return solution
</code></pre>
<p>Note that the original <code>list1</code> is not modified. The assignment in this function creates a new local <code>list1</code>. If you do actually want <code>(value/2, value/2)</code> in the output, just change the <code>break</code> condition.</p>
<hr/>
<p>Here's a slightly more compact version.</p>
<pre><code>def pairsum_n(list1, value): 
    set1 = set(list1)
    solution = []
    for i in sorted(set1):
        j = value - i
        if i &gt;= j:
            break
        if j in set1:
            solution.append((i, j))
    return solution
</code></pre>
<p>It's possible to condense this further, eg using <code>itertools.takewhile</code>, but it will be harder to read and there won't be any improvement in efficiency.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this, running time O(nlogn):</p>
<pre><code>v = [1, 2, 3, 4, 5, 6, 7, 8, 9]
l = 0
r = len(v)-1

def myFunc(v, value):

    ans = []

    % this block search for the pair (value//2, value//2)
    if value % 2 == 0:
        c = [i for i in v if i == value // 2]
        if len(c) &gt;= 2:
            ans.append((c[0], c[1]))

    v = list(set(v))
    l = 0
    r = len(v)-1
    v.sort()
    while l&lt;len(v) and r &gt;= 0 and l &lt; r:
        if v[l] + v[r] == value:
            ans.append((v[l], v[r]))
            l += 1
            r -= 1
        elif v[l] + v[r] &lt; value:
            l += 1
        else:
            r -= 1

    return list(set(ans))
</code></pre>
<p>It is called the <code>Two pointers technique</code> and it works as follows. First of all, sort the array. This imposes a minimum running time of O(nlogn). Then set two pointers, one pointing at the start of the array <code>l</code> and other pointing at its last element <code>r</code> (pointers name are for left and right). </p>
<p>Now, look at the list. If the sum of the values returned at position l and r is lower than the value we are looking for, then we need to increment <code>l</code>. If it's greater, we need to decrement <code>r</code>.</p>
<p>If <code>v[l] + v[r] == value</code> than we can increment/decrement both <code>l</code> or <code>r</code> since in any   case we want to skip the combination of values <code>(v[l], v[r])</code> as we don't want duplicates.</p>
</div>
<div class="post-text" itemprop="text">
<p>Timings: this is actually slower then the other 2 solutions. Due to the amount of combinations produced but not actually needed it gets worse the bigger the lists are. </p>
<hr/>
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">itertools.combinations</a> to produce the 2-tuple-combinations for you. </p>
<p>Put them into a set if they match your <code>value</code>, then return as set/list: </p>
<pre><code>from itertools import combinations 

def pairsum_n(list1, value): 
    """Returns the unique list of pairs of combinations of numbers from 
    list1 that sum up `value`. Reorders the values to (min_value,max_value)."""
    result = set()
    for n in combinations(list1, 2):
        if sum(n) == value:
            result.add( (min(n),max(n)) )
    return list(result)

    # more ugly one-liner:
    # return list(set(((min(n),max(n)) for n in combinations(list1,2) if sum(n)==value)))

data = [1,2,3,4,5,6,6,5,4,3,2,1]

print(pairsum_n(data,7))
</code></pre>
<p>Output:</p>
<pre><code>[(1, 6), (2, 5), (3, 4)]
</code></pre>
<hr/>
<p>Fun little thing, with some sorting overhead you can get all at once:</p>
<pre><code>def pairsum_n2(data, count_nums=2):
    """Generate a dict with all count_nums-tuples from data. Key into the
    dict is the sum of all tuple-values."""
    d = {}
    for n in (tuple(sorted(p)) for p in combinations(data,count_nums)):
        d.setdefault(sum(n),set()).add(n)
    return d

get_all =  pairsum_n2(data,2) # 2 == number of numbers to combine
for k in get_all:
    print(k," -&gt; ", get_all[k])
</code></pre>
<p>Output:</p>
<pre><code> 3  -&gt;  {(1, 2)}
 4  -&gt;  {(1, 3), (2, 2)}
 5  -&gt;  {(2, 3), (1, 4)}
 6  -&gt;  {(1, 5), (2, 4), (3, 3)}
 7  -&gt;  {(3, 4), (2, 5), (1, 6)}
 2  -&gt;  {(1, 1)}
 8  -&gt;  {(2, 6), (4, 4), (3, 5)}
 9  -&gt;  {(4, 5), (3, 6)}
10  -&gt;  {(5, 5), (4, 6)}
11  -&gt;  {(5, 6)}
12  -&gt;  {(6, 6)}
</code></pre>
<p>And then just access the one you need via: </p>
<pre><code>print(get_all.get(7,"Not possible"))    #  {(3, 4), (2, 5), (1, 6)}
print(get_all.get(17,"Not possible"))   #  Not possible
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have another solution, it's alot faster then the one I just wrote, not as fast as @PM 2Ring's answer:</p>
<pre><code>def pairsum_n(list1, value):
    set1 = set(list1)
    if list1.count(value/2) &lt; 2:
        set1.remove(value/2)
    return set((min(x, value - x) , max(x, value - x)) for x in filterfalse(lambda x: (value - x) not in set1, set1))
</code></pre>
</div>
<span class="comment-copy">Do you need the numbers themselves, or the indices?</span>
<span class="comment-copy">Numbers themselves hold on im gunna edit and give an example</span>
<span class="comment-copy">That <code>solution.remove</code> line is a bit weird. You should just use a normal <code>if</code> statement, don't use a conditional expression like that. But with a minor adjustment to your algorithm you can get rid of it completely, and produce the other results in half the time.</span>
<span class="comment-copy">Do you want a fast way to get the pairs that sum to a single value? Or do you really want something that gives you the pairs for all values, like Patrick's second solution?</span>
<span class="comment-copy">Using the list <code>[1,2,3,4,5,5,6,7,8,9]</code> and a value of <code>10</code>, your algorithm does not return the couple <code>(5,5)</code></span>
<span class="comment-copy">@Neb True, but I think the OP doesn't want pairs with both numbers the same, although I might have misunderstood that. However, as I said above, that's easy to fix by adjusting the <code>break</code> condition.</span>
<span class="comment-copy">I don't think it is easy to fix. You have removed all duplicates when you instantiated the set.</span>
<span class="comment-copy">Sorry @Neb , I don't get it. The OP used a set  themself to remove duplicates from the input list, and they don't include (5, 5) in their sample output. But if you change my break condition from <code>i &gt;= maxi</code> to <code>i &gt; maxi</code> then my code will produce (5, 5) with their data, or with yours.</span>
<span class="comment-copy">I edited my question to clear the air a bit, sorry for the ambiguity</span>
<span class="comment-copy">This is awesome I like this solution as well as the other! This kind of has the same principles of a binary search at least to me that's what it appears to be like! Thanks this is cool</span>
<span class="comment-copy">The running time is O(nlogn) since the sorting takes O(nlogn) and the rest of the code runs in linear time</span>
<span class="comment-copy">@Neb, so I'm a novice at timing my functions. I'm using time.time() with very large lists generated from a loop to test how fast everything is, according to this my filter false method is half as fast as yours however if I only search half the list as suggested do you think they will be on par? Also are my functions "good" in the python sense or are they hard to read? Thanks much!</span>
<span class="comment-copy">@Neb, actually I increased the number of elements in my list to 100,000 and mine is actually alot faster, am I doing it right? What do your tests say</span>
<span class="comment-copy">Thanks for the feedback! And yea that's exactly how im using time(), and I like how I can make the solutions shorter by implementing itertools so I guess that's my preference! Your solution is an awesome idea and I learned a lot from it, actually all of your answers have great implementations!</span>
<span class="comment-copy">Ahh the power of itertools I love it thank you for the example this is probably faster however I haven't checked yet</span>
<span class="comment-copy">@Anonymous3.1415 added a more general approach - due to sorting that one takes up more computing power though</span>
<span class="comment-copy">What is the running time of this solution?</span>
<span class="comment-copy">@Neb probably worse then yours - combination overproduces tuples that are later filtered - but for all the sum is calculated. its more readable I think - and the speed heavily depends on the generator-optimisations done. The first one does not need to sort any list beforehand and min() and max() of 2 elements should be <i>fast</i>. One would probably have to time it to make sure whats "better". I would probably go for a more readable version, after half a year I can look at this and groke it, for yours I'd hate to think. :)</span>
<span class="comment-copy">I agree with you that readability is always a crucial point. However, the OP asked for a  faster way to get what he wants so I think that readability might be sacrificed this time :)</span>
