<div class="post-text" itemprop="text">
<p>I understand that Python source code is compiled into bytecode which is then interpreted by the Python VM (let's say CPython). If I understand correctly, this mean that the VM parses the bytecode instructions and decides (at runtime) what CPU instructions should be executed accordingly.</p>
<p><strong>My questions:</strong></p>
<ul>
<li>Is it possible to log the actual CPU instructions executed on your machine as a result of the interpretation of a particular Python file (.py)? I understand it might not be simple (or even feasible) to get a 1-1 correspondence between a .py file and CPU instructions, but what is the closest you can get?</li>
<li><strong>Going a step further:</strong> Is it even possible to log the instructions executed that correspond to a particular process?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>use <code>strace</code> on linux, it will show you every system call made by any program (including python). On windows you have to use something like <a href="https://blogs.msdn.microsoft.com/debuggingtoolbox/2009/10/12/special-commandtracing-applications-using-wt/" rel="nofollow noreferrer">wt</a> or maybe <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/logger-and-logviewer" rel="nofollow noreferrer">Logger.exe</a> which traces all library calls (not just system).</p>
<p>You can use a debugger like <code>gdb</code> to look at the machine code in realtime, and since you have CPython source code, a better alternative is to just compile it with debugging symbols then run it in a C debugger, that can give you a high-level call stack, which will be a lot easier to understand.</p>
</div>
<span class="comment-copy">I probably don't understand what it is that you want to see but in the off chance that it's along these lines and you don't know the module: does <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> get you closer to what you're looking for? Obviously it's not logging in real time.</span>
<span class="comment-copy">Disclaimer: My question is mostly curiosity-driven. I suspect looking at CPU actual instructions might be impractical for interpreted code. I just wonder if it's possible.</span>
<span class="comment-copy">feel free to ask reverse engineering questions on <a href="https://reverseengineering.stackexchange.com/">reverseengineering.stackexchange.com</a></span>
<span class="comment-copy">Is <i>just</i> getting the system calls the best you can do? Is it not possible to observe the CPU instructions in more detail?</span>
<span class="comment-copy">@81rect I thought you asked for system calls. Edited my answer. <code>gdb</code> is what you want</span>
<span class="comment-copy"><code>gdb</code> is a wonderful piece of software. It can generate a log of instructions. Heck, it can record and replay execution, with rewinding support!</span>
<span class="comment-copy">This old wiki page <a href="https://wiki.python.org/moin/DebuggingWithGdb" rel="nofollow noreferrer">wiki.python.org/moin/DebuggingWithGdb</a> specifically deals with using gdb to debug python. Can give you some pointers in the right direction maybe?</span>
<span class="comment-copy">@81rect: You're <i>not</i> using <code>gdb</code> <i>on python code</i>, you're using it on the x86 machine code of the python <i>interpreter</i>, which is itself a program.  Interpreting a Python <code>+</code> operator involves running boatloads of instructions, not just an <code>add rax, rcx</code>.  You'd only get that from a JIT compiler.  But yes, you can debug any user-space process, everything is just machine code at the lowest level.</span>
