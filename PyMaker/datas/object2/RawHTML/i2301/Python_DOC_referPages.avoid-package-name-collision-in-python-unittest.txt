<div class="post-text" itemprop="text">
<p>Here is my project layout:</p>
<pre><code>project
+-- package_1
|   +-- __init__.py
|   +-- module_1.py tests
+-- package_2
|   +-- __init__.py
|   +-- module_2.py tests
+-- tests
    +-- package_1
    |   +-- __init__.py
    |   +-- test_module_1.py
    +-- package_2
        +-- __init__.py
        +-- test_module_2.py
</code></pre>
<p>test_module_1.py starts with:</p>
<pre><code>import package_1.module_1
</code></pre>
<p>test_module_2.py starts with:</p>
<pre><code>import package_2.module_2
</code></pre>
<p>Running <code>python -m unittest discover tests</code> from the project directory gives errors:</p>
<pre><code>EE
======================================================================
ERROR: package_1.test_module_1 (unittest.loader._FailedTest)
----------------------------------------------------------------------
ImportError: Failed to import test module: package_1.test_module_1
Traceback (most recent call last):
  File "/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/loader.py", line 434, in _find_test_path
    module = self._get_module_from_name(name)
  File "/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/loader.py", line 375, in _get_module_from_name
    __import__(name)
  File "/Users/maggyero/project/tests/package_1/test_module_1.py", line 1, in &lt;module&gt;
    import package_1.module_1
ModuleNotFoundError: No module named 'package_1.module_1'


======================================================================
ERROR: package_2.test_module_2 (unittest.loader._FailedTest)
----------------------------------------------------------------------
ImportError: Failed to import test module: package_2.test_module_2
Traceback (most recent call last):
  File "/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/loader.py", line 434, in _find_test_path
    module = self._get_module_from_name(name)
  File "/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/loader.py", line 375, in _get_module_from_name
    __import__(name)
  File "/Users/maggyero/project/tests/package_2/test_module_2.py", line 1, in &lt;module&gt;
    import package_2.module_2
ModuleNotFoundError: No module named 'package_2.module_2'


----------------------------------------------------------------------
Ran 2 tests in 0.000s

FAILED (errors=2)
</code></pre>
<p>Adding <code>import sys; print(sys.modules['package_1'])</code> at the beginning of test_module_1.py and <code>import sys; print(sys.modules['package_2'])</code> at the beginning of test_module_2.py to see what is in the <code>sys.modules</code> <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="nofollow noreferrer">cache</a> shows that package_1 and package_2 from the tests directory have been already imported during the test discovery:</p>
<pre><code>&lt;module 'package_1' from '/Users/maggyero/project/tests/package_1/__init__.py'&gt;
&lt;module 'package_2' from '/Users/maggyero/project/tests/package_2/__init__.py'&gt;
</code></pre>
<p>Importing a previously imported package reuse the same cached package from <code>sys.modules</code>, even if <code>sys.path</code> have since been updated. So when <code>import package_1.module_1</code> and <code>import package_2.module_2</code> are executed, first package_1 and package_2 from the tests directory (which contain test_module_1 and test_module_2) are reimported instead of package_1 and package_2 from the project directory (which contain module_1 and module_2), then module_1 and module_2 are imported, raising a <code>ModuleNotFoundError</code>.</p>
<p>Is there a workaround to avoid that the packages from the tests directory shadow those of the project directory, besides renaming?</p>
<h1>Update (post answer)</h1>
<p>An alternative solution to Laurent Laporte's below (his avoids having <code>'package_1'</code> and <code>'package_2'</code> already in <code>sys.modules</code> when executing <code>import package_1.module_1</code> and <code>import package_2.module_2</code>, by having <code>'tests.package_1'</code> and <code>'tests.package_2'</code> instead, thanks to a change of the top-level directory) is to update <code>sys.path</code> and reload the packages in test_module_1.py:</p>
<pre><code>import importlib
import pathlib
import sys
sys.path.insert(0, pathlib.Path(__file__).resolve().parents[2])

import package_1
importlib.reload(package_1)
import package_1.module_1
</code></pre>
<p>and test_module_2.py:</p>
<pre><code>import importlib
import pathlib
import sys
sys.path.insert(0, pathlib.Path(__file__).resolve().parents[2])

import package_2
importlib.reload(package_2)
import package_2.module_2
</code></pre>
<p>The only advantage of this solution is that the tests directory does not need to be a regular package (that is having an __init__.py file). So there won't be any advantage when Unittest allows recursive namespace package discovery (for the moment the ticket is still open: <a href="https://bugs.python.org/issue23882" rel="nofollow noreferrer">https://bugs.python.org/issue23882</a>).</p>
<p>Laurent Laporte's solution should be preferred, as <em>package qualification</em> is better to distinguish packages with the same names than <em>package reloading</em>. Another good solution is <em>package renaming</em> (for instance renaming package_1 and package_2 from the tests directory to test_package_1 and test_package_2).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can solve your problem by using the flag <strong>-t</strong>, <strong>--top-level-directory</strong> <em>directory</em> to set the top level directory of your project (defaults to start directory)</p>
<p>For instance:</p>
<pre><code>python -m unittest discover tests -t .
</code></pre>
<p>But, in order for <em>discover</em> to import your test modules you need to turn your <code>tests</code> directory into a package by inserting a <code>__init__.py</code> in it.</p>
<p>See the documentation about <a href="https://docs.python.org/3/library/unittest.html#test-discovery" rel="nofollow noreferrer">tests discovery</a>.</p>
<p><strong>NOTES:</strong></p>
<ul>
<li><p>I encounter the same problem with PyTest. See my <a href="https://github.com/laurent-laporte-pro/stackoverflow-q52562454" rel="nofollow noreferrer">study</a> on GitHub.</p></li>
<li><p>In other open source projects, there is only one root package (only <code>package_1</code> for instance), and there is no <code>tests/package_1</code> directory, only <code>tests</code> with all the <code>test_*.py</code> modules (and possibly with sub-packages). So, the problem doesn't appear.</p></li>
</ul>
</div>
<span class="comment-copy">Rename <code>package1</code> to <code>test_package1</code>.</span>
<span class="comment-copy">Compared to renaming package_1 and package_2 to test_package_1 and test_package_1 as suggested by  Bakuriu, what it the best practice?</span>
<span class="comment-copy">Actually you don’t need to rename your test packages. A lot of open source projects don’t. Eventually you can create a <code>src</code> directory to put your main package appart from the <code>tests</code> directory.</span>
<span class="comment-copy">I don't like the fact that I have to turn the tests directory into a package. I wonder why discovery does not search into directories without __init__.py files (that is to say namespace packages), any idea? And finally renaming package_1 to test_package_1 makes sense as module_1 is already called test_module_1 in tests. It's even more consistent that way, plus one does not need to add a command-line argument to unittest. But I accepted your answer as it perfectly answers the question within the constraints. Thank you!</span>
<span class="comment-copy">This open ticket (since 2015) would make unittest discovery find <i>namespace</i> packages recursively: <a href="https://bugs.python.org/issue23882" rel="nofollow noreferrer">bugs.python.org/issue23882</a>. That way running <code>python -m unittest</code> (or equivalently<code>python -m unittest discover</code> without the <code>--start-directory</code> or <code>--top-level-directory</code> arguments) from the project directory would find all the tests, without having to create __init__.py files all the way down to the tests to turn namespace packages into regular packages. Maybe you could finalize the proposed patch to close the issue so that we have this feature in the next Python release.</span>
<span class="comment-copy">I've found an alternative solution to yours (see the update above), even if yours should be preferred. By the way, in your solution changing the top-level directory is enough, the start directory does not even need to be tests, it can be the same as the top-level directory. The important point is to add an __init__.py file in the tests directory to turn it into a regular package for package discovery. So running <code>python -m unittest</code>, or equivalently <code>python -m unittest discover</code>, from the project directory solves the package name collision problem.</span>
