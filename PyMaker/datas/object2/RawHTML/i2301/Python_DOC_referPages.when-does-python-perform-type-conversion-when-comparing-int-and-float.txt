<div class="post-text" itemprop="text">
<p>Why does Python return <code>True</code> when I compare <code>int</code> and <code>float</code> objects which have the same value?</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; 5*2 == 5.0*2.0
&gt;&gt;&gt; True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Objects of different types, <strong>except different numeric types,</strong> never compare equal. </p>
</blockquote>
<p>And:</p>
<blockquote>
<p>Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. <strong>Comparisons between numbers of mixed type use the same rule.</strong></p>
<p><sub><a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex</a></sub></p>
</blockquote>
<p>The comparison logic is implemented by each type's <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer"><code>__eq__</code> method</a>. And the standard numeric types are implemented in a way that they support comparisons (and arithmetic operations) among each other. Python as a language never does implicit type conversion (like Javascript's <code>==</code> operator would do implicit type juggling).</p>
</div>
<div class="post-text" itemprop="text">
<p><code>10 == 10.0</code> translates to a call to <code>(10).__eq__(10.0)</code> (or even more formally, <code>int.__eq__(10, 10.0)</code>). The implementation of <code>int.__eq__</code> can handle comparisons to other types, but there is no type conversion at the language level.</p>
</div>
<div class="post-text" itemprop="text">
<p>The simple answer is that the langue is designed this way. Here is an excerpt from the documentation supporting this:</p>
<p><a href="https://docs.python.org/3/reference/expressions.html#value-comparisons" rel="nofollow noreferrer">6.10.1 Value Comparisons</a></p>
<blockquote>
<p>Numbers of built-in numeric types (Numeric Types — int, float, complex) and of the standard library types fractions.Fraction and decimal.Decimal can be compared within and across their types, with the restriction that complex numbers do not support order comparison.</p>
</blockquote>
<p>In other words, we want different numeric types with the same value to be equal.</p>
<p><a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">PEP 20</a></p>
<blockquote>
<p>Special cases aren't special enough to break the rules.</p>
<p>Although practicality beats purity.</p>
</blockquote>
<p>What benefit is there to making numeric types not comparable, besides making life difficult in most common cases?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can have a look at <a href="https://github.com/python/cpython/blob/master/Objects/floatobject.c#L332" rel="nofollow noreferrer">the source code</a> for the CPython implementation.</p>
<p>The function is preceded by this comment explaining how the conversion is attempted:</p>
<blockquote>
<pre><code>/* Comparison is pretty much a nightmare.  When comparing float to float,
 * we do it as straightforwardly (and long-windedly) as conceivable, so
 * that, e.g., Python x == y delivers the same result as the platform
 * C x == y when x and/or y is a NaN.
 * When mixing float with an integer type, there's no good *uniform* approach.
 * Converting the double to an integer obviously doesn't work, since we
 * may lose info from fractional bits.  Converting the integer to a double
 * also has two failure modes:  (1) an int may trigger overflow (too
 * large to fit in the dynamic range of a C double); (2) even a C long may have
 * more bits than fit in a C double (e.g., on a 64-bit box long may have
 * 63 bits of precision, but a C double probably has only 53), and then
 * we can falsely claim equality when low-order integer bits are lost by
 * coercion to double.  So this part is painful too.
 */
</code></pre>
</blockquote>
<p>Other implementations are not guaranteed to follow the same logic.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/2.7/library/stdtypes.html#numeric-types-int-float-long-complex" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>Python fully supports mixed arithmetic: when a binary arithmetic
  operator has operands of different numeric types, the operand with the
  “narrower” type is widened to that of the other, where plain integer
  is narrower than long integer is narrower than floating point is
  narrower than complex. Comparisons between numbers of mixed type use
  the same rule.</p>
</blockquote>
<p>According to this 5*2 is widened to 10.0 and which is equal to 10.0
If you are comparing the mixed data types then the result will be considered on the basics of data type which is having long range, so in your case float range is more then int 
float max number can be  --&gt; 1.7976931348623157e+308
int max number can be --&gt; 9223372036854775807</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>The == operator compares only the values but not the types. You can use the 'is' keyword to achieve the same effect as using === in other languages. For instance</p>
<pre><code>5 is 5.0
</code></pre>
<p>returns
    False</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>== 
</code></pre>
<p>is a comparison operator</p>
<p>You are actually asking the interpreter if both sides of your expression are equal or not.</p>
<p>In other words you are asking for it to return a Boolean value, not to convert data types. If you want to convert the data types you will have to do so implicitly in your code.</p>
</div>
<span class="comment-copy">To answer the title: <i>virtually never</i>. This has little to do with type conversion, but with comparison logic.</span>
<span class="comment-copy">You may find <a href="https://stackoverflow.com/a/30100743/9209546">this answer on CPython comparison between <code>int</code> and <code>float</code></a> helpful. While not guaranteed, I wouldn't be surprised if other implementations are similar.</span>
<span class="comment-copy"><code>==</code> is not a binary arithmetic operator, as described by Python documentation. Per the page you link to, it is a comparison operation.</span>
<span class="comment-copy">True, but <i>"Comparisons between numbers of mixed type use the same rule."</i> I've added a more apropos quote to the top nonetheless.</span>
<span class="comment-copy">The next question is, I guess, does "the implementation of <code>int.__eq__</code>" require type conversion? Agree at Python level there's no conversion, but I'm not sure there's no conversion <i>anywhere</i>.</span>
<span class="comment-copy">That is, by definition, an implementation detail. CPython, PyPy, and Jython, for instance, may all do different things. But the <i>language</i> does not specify that <code>int.__eq__(10, 10.0)</code> be turned into <code>float.__eq__(10.0, 10.0)</code>.</span>
<span class="comment-copy">Since this SO and we don't want to have half-truths on SO, I have to well-actually you: <code>a == b</code> is <b>not</b> equivalent to <code>a.__eq__(b)</code>. The comparison mechanism is more elaborate than that. For example, if <code>a</code> doesn't support comparison with <code>b</code>, <code>b.__eq__(a)</code> is used instead. More details <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">@Aran-Fey At the language level, they're equivalent. You still have to <i>run</i> <code>a.__eq__(b)</code> before you can find out if a call to <code>b.__eq__(a)</code> is required. Lexically, the translation is sound. Semantically, it's up to the implementation. (I could imagine an implementation where <code>int.__eq__</code> compares the two values itself, and I can also imagine an implementation where <code>int.__eq__</code> raises an exception and delegates the comparison to <code>float.__eq__</code>.)</span>
<span class="comment-copy">@jpp <i>Python</i> doesn't do type conversions. Any particular <i>implementation</i> of Python might.</span>
<span class="comment-copy">This comment is rather about the specific implementation details and nightmares therein needed to get the desired behaviour. It does not explain why that behaviour is desired in the first place.</span>
<span class="comment-copy"><code>==</code> is not a binary arithmetic operator, as described by Python documentation. Per <a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex" rel="nofollow noreferrer">this page</a>, it is a comparison operation.</span>
<span class="comment-copy">Hi Eric, Thanks for the correction but it will follows the same rule with comparison operator  also. eg:- suppose binary operator 4.0/2 will give you 2.0 and comparison operator 4.0 == 4 will give you true, but the only difference here is you can see the o/p of 4.0/2 is converted to float but in 4.0 == 4  you can not see at o/p (as you get the Boolean result) but internally it is doing he same.</span>
<span class="comment-copy">Another answer pointed to <a href="https://github.com/python/cpython/blob/master/Objects/floatobject.c#L332" rel="nofollow noreferrer">source code</a> that shows us the approach of simply converting one type to another does not fulfill the specified requirements for comparison. Converting floating-point to wider integer cannot work because <code>3.25 == 3</code> would falsely return true because the conversion would drop the .25. Converting integer to floating-point has failures due to loss of precision. What is your basis (<i>e.g.</i>, documentation) for asserting that Python actually implements <code>==</code> by performing the “widening” you state?</span>
<span class="comment-copy">The "Comparisons between numbers of mixed type use the same rule." line from the docs is unfortunate and misleading, as the other answers explain. There's a (very) long-standing issue open to fix it: <a href="https://bugs.python.org/issue12067" rel="nofollow noreferrer">bugs.python.org/issue12067</a></span>
<span class="comment-copy">Hi Eric Thanks for the correction.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/q/306313/476"><code>is</code> is not equivalent to <code>===</code>!</a> <code>a = 12345; a is 12345  # false</code></span>
<span class="comment-copy">Why the downvotes? Per <a href="https://docs.python.org/3/reference/expressions.html#value-comparisons" rel="nofollow noreferrer">Python documentation</a>, “Numbers … can be compared within <b>and across</b> their types… they compare mathematically (algorithmically) correct…” Thus <code>==</code> is defined in terms of the mathematics—are both sides equal. That documentation does not say types are converted. It specifies the behavior in terms of mathematical comparison.</span>
<span class="comment-copy">I didn't down vote, but you are answering (correctly) the question stated in the body while ignoring the title.</span>
