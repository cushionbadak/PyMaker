<div class="post-text" itemprop="text">
<p>When I handle some code exception code, I wander why python didn't include what exception will the function raise in its introspect system.For example,when I have to use a function refer to many other function that will raise different exceptions,I have to consider all that happen in my business logic.
Like this:</p>
<pre><code>def a():
    raise Exception('exception1')

def b():
    a()
    raise Exception('exception2')

def c():
    b()
    raise Exception('exception3')

def business():
    try:
        c()
    except Exception as e:
        pass
</code></pre>
<p>I have to keep digging in the function calls between them that I can know what maybe raise in this code block.And introspect system does not have information of exception.</p>
<p>And as I know, Java will explicitly annotated 'Throw' in function definition,and IDE and programmer can easily know what kinds of exception should I handle.</p>
<p>It will be better if I can know all the exception with object itself,for example:</p>
<pre><code>all_exception = obj.__exceptions__()
</code></pre>
<p>So,my question is,why python not include exception introspect in function object.<br/>
Who can explain python's design?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python is a dynamic language, and you can't know, up front, what exceptions a function could throw.</p>
<p>Take this example:</p>
<pre><code>def throw(exception):
    raise exception
</code></pre>
<p>What exception will that function raise? I can use <code>throw(ValueError)</code> or <code>throw(TypeError('foobar'))</code>, and both would work and are valid Python:</p>
<pre><code>&gt;&gt;&gt; throw(ValueError)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in throw
ValueError
&gt;&gt;&gt; throw(TypeError('foobar'))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in throw
TypeError: foobar
</code></pre>
<p>Exceptions are <em>just classes and instances</em>. Current versions of Python require that the exception class must derive from <code>BaseException</code>, but in old Python versions you could even use strings for exceptions (<code>raise "Your mother was a hamster"</code>).</p>
<p>And because they are looked up as globals and are not reserved names, you can <em>assign different exceptions to names</em>. The following is legal Python syntax too:</p>
<pre><code>&gt;&gt;&gt; def oops():
...     raise ValueError('Oops')
...
&gt;&gt;&gt; ValueError = TypeError
&gt;&gt;&gt; oops()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in oops
TypeError: Oops
</code></pre>
<p>That's why Python functions can't expose what exceptions they raise.</p>
<p>Note that there is never a good reason to use plain <code>Exception</code>. Use one of the standard exceptions where they make sense (<code>ValueError</code>, <code>TypeError</code>, <code>IndexError</code>, <code>KeyError</code>, etc.) or create your own API-specific exceptions by subclassing from <code>Exception</code> or a more specific exception subclass.</p>
<p>Then <em>document</em> your API properly. State what exceptions a developer should expect, where needed. The standard exceptions don't need to be spelled out; it is reasonably obvious that a function that only works on strings will throw <code>TypeError</code> if you pass in a file object instead.</p>
<p>You can use a exception class hierarchy in your business application if you need to catch multiple types:</p>
<pre><code>class BusinessException(Exception):
    """The base exception for all of Business APIs"""

class SpecificBusinessException(BusinessException):
    """Exception that indicates a specific problem occurred"""

class DifferenBusinessException(BusinessException):
    """Exception that indicates a different specific problem occurred"""
</code></pre>
<p>then raise the subclassed exceptions and catch <code>BusinessException</code> to handle all, or catch only specific subclasses to customise handling.</p>
<p>If you <strong>must</strong> figure out what exceptions code raise and accept the risks involved with a dynamic language being able to change the names, then you could use <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer">abstract syntax tree (AST) analysis</a> to at least find <em>some</em> information on exceptions. For straight <code>raise Name</code> and <code>raise Name(args..)</code> statements, extracting those names or calls by walking the AST is at least relatively straightforward:</p>
<pre><code>import builtins
import inspect
import ast

class ExceptionExtractor(ast.NodeVisitor):
    def __init__(self):
        self.exceptions = []
    def visit_Raise(self, node):
        if node.exc is None:
            # plain re-raise
            return
        exc_name = node.exc
        if isinstance(exc_name, ast.Call):
            exc_name = exc_name.func
        if not (isinstance(exc_name, ast.Name) and
                isinstance(exc_name.ctx, ast.Load)):
            # not a raise Name or raise Name(...)
            return
        self.exceptions.append(exc_name.id)

def global_exceptions_raised(func):
    """Extract the expressions used in raise statements

    Only supports raise Name and raise Name(...) forms, and
    only if the source can be accessed. No checks are made for the
    scope of the name.

    returns references to those exception names that can be loaded from
    the function globals.

    """
    source = inspect.getsource(func)
    tree = ast.parse(source)
    extractor = ExceptionExtractor()
    extractor.visit(tree)
    fglobals = {**func.__globals__, **vars(builtins)}
    return [fglobals[name] for name in extractor.exceptions if name in fglobals]
</code></pre>
</div>
<span class="comment-copy">possibly related: <a href="https://stackoverflow.com/questions/32560116/how-to-list-all-exceptions-a-function-could-raise-in-python-3" title="how to list all exceptions a function could raise in python 3">stackoverflow.com/questions/32560116/â€¦</a></span>
<span class="comment-copy">Guido van Rossum, probably?</span>
<span class="comment-copy">What do you mean you don't have information about the exception? You've stored the exception in the variable <code>e</code>, and you can do whatever you want with it.</span>
<span class="comment-copy">To understand pythonic design simply enter <code>import this</code> in a python shell.(and repeat it every time you ask yourself something about python.) When you do this it should give you a sense of why you wouldn't want to write exceptions like this in python(or any other languange).</span>
<span class="comment-copy">a) In the generic sense, Python can't know, which imported routines raise which exceptions, since there is no declaration of it as e.g. in Java. b) Your code raising generic <code>Exception</code> instances will not win any beauty prices.</span>
