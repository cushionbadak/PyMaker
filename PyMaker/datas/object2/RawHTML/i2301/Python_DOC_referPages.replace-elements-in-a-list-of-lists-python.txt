<div class="post-text" itemprop="text">
<p>I have a list of lists as follows:</p>
<pre><code>     list=[]
     *some code to append elements to list*

     list=[['a','bob'],['a','bob'],['a','john']]
</code></pre>
<p>I want to go through this list and change all instances of 'bob to 'b' and leave others unchanged.</p>
<pre><code>    for x in list:
       for a in x:
          if "bob" in a:
             a.replace("bob", 'b')
</code></pre>
<p>After printing out x it is still the same as list, but not as follows:</p>
<pre><code>    list=[['a','b'],['a','b'],['a','john']]
</code></pre>
<p>Why is the change not being reflected in list?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>str.replace</code> doesn't work <em>in-place</em>, it <a href="https://docs.python.org/3/library/stdtypes.html#str.replace" rel="nofollow noreferrer">returns a copy</a>. As immutable objects, you need to <em>assign</em> the strings to elements in your list of lists.</p>
<p>You can assign directly to your list of lists if you extract indexing integers via <code>enumerate</code>:</p>
<pre><code>L = [['a','bob'],['a','bob'],['a','john']]

for i, x in enumerate(L):
    for j, a in enumerate(x):
        if 'bob' in a:
            L[i][j] = a.replace('bob', 'b')
</code></pre>
<p>Result:</p>
<pre><code>[['a', 'b'], ['a', 'b'], ['a', 'john']]
</code></pre>
<p>More Pythonic would be to use a list comprehension to create a new list. For example, if only the second of two values contains names which need checking:</p>
<pre><code>L = [[i, j if j != 'bob' else 'b'] for i, j in L]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm going to use a simple example, but basically <code>x</code> is another variable and isn't linked to the list element. You have to change the list element directly in order to alter the list.</p>
<pre><code>l=[1,2,3,4]
for x in l:
    x=x+1
</code></pre>
<p>This doesn't change the list</p>
<pre><code>l=[1,2,3,4]
for i,x in enumerate(l):
    l[i]=x+1
</code></pre>
<p>this changes the list</p>
</div>
<div class="post-text" itemprop="text">
<p>This is the case because you are only changing the temporary variable a.
list = [1,2,3]
for i in list:
   i+=1</p>
<p>list will still be [1,2,3]</p>
<p>you have to edit the string based on its index in the list</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try using a dictionary object of python</p>
<pre><code>import numpy as np
L = [['a','bob'],['a','bob'],['a','john']]
dic = {'bob':'b'} # you can specify more changes here
new_list = [dic.get(n, n) for n in np.concatenate(L)]
print(np.reshape(new_list,[-1,2]).tolist())
</code></pre>
<p>Result is</p>
<pre><code>[['a', 'b'], ['a', 'b'], ['a', 'john']]
</code></pre>
</div>
<span class="comment-copy">you are making a copy of things in list by <code>for a in x</code>, and not directly pointing to the element of <code>x</code>.</span>
<span class="comment-copy">Side note: never shadow built-ins. Use <code>list_</code> or <code>L</code> instead of <code>list</code> for your variable name.</span>
<span class="comment-copy">@jpp or preferably something less generic that describes the contents... <code>names</code> or <code>letter_and_name</code> or something... :)</span>
<span class="comment-copy">The "more pythonic" part isn't really a generic one considering the fact that <code>bob</code> can come anywhere in the sublist.</span>
<span class="comment-copy">@Austin, Possibly. Given the example input, I'm happy to wait a little longer before making it more generic :)</span>
<span class="comment-copy">@jpp don't forget poor "bobby" :)</span>
<span class="comment-copy">Lol. If you think so, use <code>if a == 'bob':</code> instead of <code>if 'bob' in a:</code>.</span>
<span class="comment-copy">or bobaganoush hahah</span>
