<div class="post-text" itemprop="text">
<p>I can't work out why it's so much faster to parse this file in Python 2.7 than in Python 3.6. I've found this pattern both on macOS and Arch-Linux independently. Can others replicate it? Any explanation?</p>
<p>Warning: the code snippet writes a ~2GB file</p>
<p>Timings:</p>
<pre><code>$ python2 test.py 
5.01580309868
$ python3 test.py 
10.664075019994925
</code></pre>
<p>Code for <code>test.py</code>:</p>
<pre><code>import os

SEQ_LINE = 'ATCGN'* 80 + '\n'

if not os.path.isfile('many_medium.fa'):
    with open('many_medium.fa', 'w') as out_f:
        for i in range(1000000):
            out_f.write('&gt;{}\n'.format(i))
            for _ in range(5):
                out_f.write(SEQ_LINE)

from timeit import timeit

def f():
    with open('many_medium.fa') as f:
        for line in f:
            pass

print(timeit('f()', setup='from __main__ import f', number=5))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because in Python 2, the standard <code>open()</code> call creates a far simpler file object than the Python 3 <code>open()</code> call does.  The Python 3 <code>open</code> call is the same thing as <a href="https://docs.python.org/3/library/io.html#io.open" rel="nofollow noreferrer"><code>io.open()</code></a>, and the same framework is <a href="https://docs.python.org/2/library/io.html#io.open" rel="nofollow noreferrer">available on Python 2</a>.</p>
<p>To make this a <strong>fair</strong> comparison, you'd have to add the following line to the top of your test:</p>
<pre><code>from io import open
</code></pre>
<p>With that change, the timings on Python 2 go from 5.5 seconds, to <strong>37</strong> seconds. Compared to that figure, the 11 seconds Python 3 takes on my system to run the test really is <em>much, much faster</em>.</p>
<p>So what is happening here? The <code>io</code> library offers much more functionality than the old Python 2 <code>file</code> object:</p>
<ul>
<li>File objects returned by <code>open()</code> consist of up to 3 layers of composed functionality, allowing you to control buffering and text handling.</li>
<li>Support for non-blocking I/O streams</li>
<li>A consistent interface across a wide range of streams</li>
<li>Much more control over the <a href="https://docs.python.org/3/glossary.html#term-universal-newlines" rel="nofollow noreferrer"><em>universal newline</em> translation feature</a>.</li>
<li>Full Unicode support.</li>
</ul>
<p>That extra functionality comes at a performance price. </p>
<p>But your Python 2 test reads <em>byte strings</em>, newlines are always translated to <code>\n</code>, and the file object the code is working with is pretty close to the OS-supplied file primitive, with <a href="https://stackoverflow.com/questions/405058/line-reading-chokes-on-0x1a">all the downsides</a>. In Python 3, you usually want to process data from files as text, so opening a file in text mode gives you a file object that decodes the binary data to Unicode <code>str</code> objects.</p>
<p>So how can you make things go 'faster' on Python 3? That depends on your specific use case, but you have some options:</p>
<ul>
<li>For text-mode files,  disable universal newline handling, especially when handling a file that uses line endings that differ from the platform standard. Set the <code>newline</code> parameter to the expected newline character sequence, like <code>\n</code>. Binary mode only supports <code>\n</code> as line separator.</li>
<li>Process the file as <em>binary data</em>, and don't decode to <code>str</code>. Alternatively, decode to Latin-1, a straight one-on-one mapping from byte to codepoint. This is an option when your data is ASCII-only too, where Latin-1 omits an error check on the bytes being in the range 0-127 rather than 0-255.</li>
</ul>
<p>When using <code>mode='rb'</code>, Python 3 can easily match the Python 2 timings, the test only takes 5.05 seconds on my system, using Python 3.7.</p>
<p>Using <code>latin-1</code> as the codec vs. UTF-8 (the usual default) makes only a small difference; UTF-8 can be decoded very efficiently. But it could make a difference for other codecs. You generally want to set the <code>encoding</code> parameter explicitly, and not rely on the <a href="https://stackoverflow.com/questions/23917729/switching-to-python-3-causing-unicodedecodeerror/23917799#23917799">default encoding used</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Did some research and came across <a href="https://nelsonslog.wordpress.com/2015/02/26/python-file-reading-benchmarks/" rel="noreferrer">this</a> article by Nelson Minar that explains what the difference is between python2 and python3 file reading.</p>
<blockquote>
<ul>
<li><p>Python 3 is ~1.7x little slower reading bytes line by line than Python 2</p></li>
<li><p>In Python 2, reading lines with Unicode is hella slow. About 7x slower than reading Unicode all at once. And Unicode lines are 70x slower than byte lines!</p></li>
<li><p>In Python 3, reading lines with Unicode is quite fast. About as fast as reading the file all at once. But only if you use the built-in open, not codecs.</p></li>
<li><p>In Python 3, codecs is really slow for reading line by line. Avoid.</p></li>
</ul>
</blockquote>
<p>And continues to say:</p>
<blockquote>
<p>Python 3 UTF-8 decoding is significantly faster than Python 2. And it’s probably best to stick with the stock open() call in Py3, not codecs. It may be slower in some circumstances but it’s the recommended option going further and the difference isn’t enormous.</p>
</blockquote>
<p>According to the <a href="https://stackoverflow.com/questions/46415568/why-is-it-faster-to-read-a-file-without-line-breaks">SO answer</a> that <a href="https://stackoverflow.com/users/2357112/user2357112">@user2357112</a> linked:</p>
<blockquote>
<p>When you open a file in Python in text mode (the default), it uses what it calls "universal newlines" (introduced with PEP 278, but somewhat changed later with the release of Python 3). What universal newlines means is that regardless of what kind of newline characters are used in the file, you'll see only \n in Python. So a file containing foo\nbar would appear the same as a file containing foo\r\nbar or foo\rbar (since \n, \r\n and \r are all line ending conventions used on some operating systems at some time).</p>
</blockquote>
<p>The solution mentioned in this answer is to open the file in byte mode to avoid the conversion:</p>
<pre><code>open('many_medium.fa', "r+b")
</code></pre>
<p>My tests indicated a massive difference in the speed, but python2 still seemed to be slightly faster. There does not seem to be a way to avoid this, as it's handled by python's interpreter.</p>
</div>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/46415568/why-is-it-faster-to-read-a-file-without-line-breaks" title="why is it faster to read a file without line breaks">stackoverflow.com/questions/46415568/…</a></span>
<span class="comment-copy">(It's not quite the same, since you're not on Windows, but it's closely related.)</span>
<span class="comment-copy">Aside from newline handling, the big obvious thing is that Python 3 is doing Unicode decoding. That's pretty expensive.</span>
<span class="comment-copy">Skip decoding entirely by opening the file in <code>'rb'</code> mode, but everything that uses the data will have to be able to handle bytestrings on Python 3.</span>
<span class="comment-copy">@user2357112 Thanks opening with <code>rb</code> does indeed account for the majority of the time difference!</span>
