<div class="post-text" itemprop="text">
<p>Now to flatten Counter element i'm using the code</p>
<pre><code>import operator
from collections import Counter
from functools import reduce

p = Counter({'a': 2, 'p': 1})
n_p = [[e] * p[e] for e in p]
f_p = reduce(operator.add, n_p)

# result: ['a', 'a', 'p']
</code></pre>
<p>So i'm wonder, if it could be done more directly. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is <a href="https://docs.python.org/3/library/collections.html?highlight=counter#collections.Counter.elements" rel="nofollow noreferrer"><code>Counter.elements</code></a></p>
<pre><code>p = Counter({'a': 2, 'p': 1})
p.elements()  # iter(['a', 'a', 'p'])
list(p.elements())  # ['a', 'a', 'p']
''.join(p.elements())  # 'aap'
</code></pre>
<p>Note that (per the docs)</p>
<blockquote>
<p>Elements are returned in arbitrary order</p>
</blockquote>
<p>So you may want to sort the result to get a stable order.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a nested list comprehension:</p>
<pre><code>[i for a, b in p.items() for i in [a]*b]
</code></pre>
<p>Output:</p>
<pre><code>['a', 'a', 'p']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With just for loop:</p>
<pre><code>from collections import Counter

p = Counter({'a': 2, 'p': 1})
plist = []
for tup in p.items():
    for n in range(tup[1]):         
        plist.append(tup[0])
print(plist)
</code></pre>
<p>output:</p>
<pre><code>['a', 'a', 'p']
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">Nice way to do !</span>
<span class="comment-copy">@user3483203 Edited to reflect that.</span>
