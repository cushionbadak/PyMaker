<div class="post-text" itemprop="text">
<p>I'm trying to find all the index numbers of a character in a python string using a very basic skill set. For example if I have the string "Apples are totally awesome" and I want to find the places where 'a' is in the string.
My ideal output would be:</p>
<pre><code>0
7
14
19
</code></pre>
<p>These are all the places in the string that an 'a' appears (I think)</p>
<p>This is the code I have so far:</p>
<pre><code>sentence = input("Input a string: ")
for ch in sentence:
    x = sentence.find('o')


print(x)
</code></pre>
<p>Here I'm looking for 'o' instead of a. My thought process is that for each character in the string the find function will return the position of the 'o'. Since I don't know how long the input string will be necessarily I used a for loop. I'm able to find and print out the first instance of an 'o' but not all of them. What should I do? Thanks in advance! </p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>enumerate</code> is the standard way to go. Although, you can take advantage of the speed of <code>str.find</code> for time-critical operations.</p>
<h2>Code</h2>
<pre><code>def find_all(s, c):
    idx = s.find(c)
    while idx != -1:
        yield idx
        idx = s.find(c, idx + 1)

print(*find_all('Apples are totally awesome', 'o')) # 12 23
</code></pre>
<p>I made the above return a generator for elegance and to account for very large strings. Put it can of course be casted to a <code>list</code> if need be.</p>
<h2>Benchmark</h2>
<p>Here is a benchmark against a solution using <code>enumerate</code> and a list-comprehension. Both solutions have linear time-complexity, but <code>str.find</code> is significantly faster.</p>
<pre><code>import timeit

def find_all_enumerate(s, c):
    return [i for i, x in enumerate(s) if c == 'a']

print(
    'find_all:',
    timeit.timeit("list(find_all('Apples are totally awesome', 'o'))",
                  setup="from __main__ import find_all")
)

print(
    'find_all_enumerate:',
    timeit.timeit("find_all_enumerate('Apples are totally awesome', 'o')",
                  setup="from __main__ import find_all_enumerate")
)
</code></pre>
<h2>Output</h2>
<pre><code>find_all: 1.1554179692960915
find_all_enumerate: 1.9171753468076869
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a good spot for <em>enumerate</em>, it allows us to get the <code>index and item</code> when we loop, so if we match the <code>item</code> we can have the corresponding <code>index</code>, also its helpful to use <code>.lower()</code> to avoid issues with matching cases</p>
<pre><code>s = 'Apples are totally awesome'

l = [idx for idx, item in enumerate(s.lower()) if 'o' in item]
</code></pre>
<p>Extended loop:</p>
<pre><code>l = []
for idx, item in enumerate(s.lower()):
    if 'o' in item:
        l.append(idx)
</code></pre>
<blockquote>
<pre><code>/python/stack$ python3.7 sum.py 
[12, 23]
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Use you a list comprehension for great good:</p>
<pre><code>[ind for ind, ch in enumerate(sentence) if ch.lower() == 'a']
</code></pre>
<p>will return a list of all the numbers you want. Print as desired.</p>
<p>And I assumed, based on your example, you don't care about case, hence the lower() function call. Using Python 3's asterisk splat operator (*) you could do all of this as a one liner; but that I will leave as an exercise for the reader.</p>
</div>
<span class="comment-copy">You should iterate over characters using <code>for index, ch in enumerate(sentence)</code>; then a simple equality check will suffice to determine whether to print <code>index</code> or not.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/stdtypes.html#str.find" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#str.find</a></span>
<span class="comment-copy">That is a great solution.</span>
<span class="comment-copy">@StephenRauch Well, you pointed out in that direction in another comment, so you deserve some credit</span>
<span class="comment-copy">Can you provide an actual algorithmic analysis that this will always be more efficient? Do you know how these functions are implemented? A single timeit test doesn't strike me as compelling evidence.</span>
<span class="comment-copy">@udadub Both algorithms do a single traversal for a single characters. It just turns out find is done at the C level. This drops the overhead of assignation of indices and items, making it faster by a constant. Time complexity is the same.</span>
<span class="comment-copy">@ubadub To add to that, str.find uses <a href="https://github.com/python/cpython/blob/master/Objects/stringlib/fastsearch.h#L5" rel="nofollow noreferrer">Boyer-Moore</a> which is O(nm). Thus is linear for m=1, which is the case in this problem.</span>
<span class="comment-copy">You really should consider using <a href="https://docs.python.org/3/library/stdtypes.html#str.find" rel="nofollow noreferrer">find</a>.</span>
<span class="comment-copy">@StephenRauch find only finds the first occurence</span>
<span class="comment-copy">@OlivierMelan√ßon, find has a start, which allows you to find the next one.</span>
<span class="comment-copy">Stephen, can you clarify why you suggest using find instead of enumerate?</span>
<span class="comment-copy">OMG! I'm sorry this is the happiest day I've had in a long time, I have to rant, I just hit 1k rep, I know to some its meaningless, but my life really hit a rut this last couple months, prob worst in my 29 years, I decided to learn programming 33 days ago and I fell in love with Stack and just learning and this was such a goal for me again I know its nothing to you guys but for me its a ray of light, thank you all for everything its been a blessing learning from all of you &lt;3</span>
