<div class="post-text" itemprop="text">
<p>Beginner here. My code should be able to check that a given number is in the form xxx-xx-xxxx. The if statement is wrong somewhere I think. Any tips welcome thank you.</p>
<pre><code>def checkit(a):
    if a is (int[0:2]+"-"+ int[4:5] +"-"+int[7:8]):
        print("True")
    else:
        print("False")

assert checkit(832-38-1847)
assert not checkit(832- 23-  1 847)
print("/n(Good job!)")
</code></pre>
<p>Error message:</p>
<pre><code>Traceback (most recent call last):
  File "nb5a.py", line 19, in &lt;module&gt;
    assert checkit(832-38-1847)
  File "nb5a.py", line 14, in checkit
    if a is (int[1:3]+"-"+ int[5:6] +"-"+int[8:9]):
TypeError: 'type' object is not subscriptable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The error message is telling you that you are trying to subscript the type "int". Based on what I infer you are wanting to do, slice (subscript) you variable "a", and then verify that the slice is an integer (int) which, in it's simplest for could be something like <strong><code>int(a[0:2]) + "-" + int(a[4:5]) + "-" + int(a[7:8])</code></strong>. However, this technique has some major flaws. If any of the slices can't be converted to an type "int", python will throw <code>ValueError: invalid literal for int() with base 10: &lt;whatever value threw the error&gt;</code>. You could improve this a little using a "try" "except" block:</p>
<pre><code>try:
    int(a[0:2]) # etc...
except:
    print("Not the correct format")
</code></pre>
<p>but this is pretty cumbersome, and should you ever need to evaluate something more complicated it can get really cumbersome and lot of lines of code to evaluate properly.</p>
<p>A more concise way to validate the expression would be to use a regular expression. Regular expressions are a very concise, and a consolidated way to check values, match format, and value type (int or string only).</p>
<p>Also, the argument value(s) your are trying to pass into your checkit function would be misinterpreted by python as a mathematical expression. You need to surround your argument values with single-quotes or double-quotes.</p>
<p>Here is one possible way to check your desired format and value type ((Note: this example is a little contrived in order to see the assert statement in action if the assertion fails)):</p>
<pre><code>import re
def checkit(a):
    pattern = r'^([0-9]{3})-{1}([0-9]{2})-{1}([0-9]{4})$'
    match = re.fullmatch(pattern, a)
    if match != None:
        match = match.string
    try:
        assert a == match, "Fail"
        print("True")
        print("\n(Good job!)")
    except:
        assert a == match, "Fail"
        print("False")
        print("Not the correct format or values or both")
</code></pre>
<p>If you don't really need the assert statement, this could be an even shorter way of validating the values:</p>
<pre><code>import re
def checkit(a):
    pattern = r'^([0-9]{3})-{1}([0-9]{2})-{1}([0-9]{4})$'
    match = re.fullmatch(pattern, a)
    if match != None:
        print("True")
        print("\n(Good job!)")
    else:
        print("False")
        print("Not the correct format or values or both")
</code></pre>
<p>To learn more, and get a better understanding about regular expressions, follow this link about <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">regexp</a></p>
<p>This website might be helpful also <a href="http://www.pyregex.com/" rel="nofollow noreferrer">PyRegex</a></p>
<p>By the way, to parse and validate the string as closely to the method you used in your example, you could do something like this:</p>
<pre><code>def checkit(a):
    try:
        slicedVal = str(int(a[0:3])) + '-' + str(int(a[4:6])) + '-' + str(int(a[7:11]))
        print(slicedVal)
        # Caution!
        # If you want to match exactly the number of digits in the last portion of xxx-xx-xxxx variable
        # the slice or the assert statement will not catch this error or fail
        # Slicing a string with a number greater than it's length will pass without errors
        # e.g.
        # &gt;&gt;&gt; print('I will pass'[0:2000])
        # I will pass
        assert slicedVal == a, "FAIL"
        print("True")
        return slicedVal
    except:
        print("False")

success = '832-38-1847'
assert success == checkit(success), "This won't fail this assertion test"
# True

# Should technically fail if formatting match is required
doesNotFail = '832-38-184'
assert doesNotFail == checkit(doesNotFail), "This won't fail this assertion test"
# True

willFail = '832- 23-  1 847'
assert willFail == checkit(willFail), "This one will fail for sure"
# Traceback (most recent call last):
# File "&lt;stdin&gt;", line 1, in &lt;module&gt;
# AssertionError: This one will fail for sure

print("/n(Good job!)")
#
# (Good job!)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try using a regular expression:</p>
<h1></h1>
<pre class="lang-py prettyprint-override"><code>import re
def checkit(a):
    return bool(re.match("^[0-9]{3}-[0-9]{2}-[0-9]{4}$", a))

checkit("832-38-1847")
#&gt; True
checkit("832- 23-  1 847")
#&gt; False
</code></pre>
<p>Created on 2018-09-23 by the <a href="https://github.com/crew102/reprexpy" rel="nofollow noreferrer">reprexpy package</a></p>
<pre class="lang-py prettyprint-override"><code>import reprexpy
print(reprexpy.SessionInfo())
#&gt; Session info --------------------------------------------------------------------
#&gt; Platform: Darwin-17.7.0-x86_64-i386-64bit (64-bit)
#&gt; Python: 3.6
#&gt; Date: 2018-09-23
#&gt; Packages ------------------------------------------------------------------------
#&gt; reprexpy==0.1.1
</code></pre>
</div>
<span class="comment-copy">Ranges are non inclusive <code>i[0:2]</code> is only indexes 0 and 1, should be 0:3 , 3:5, 5:9 sorry on phone</span>
<span class="comment-copy">The whole expression <code>(int[0:2]+"-"+ int[4:5] +"-"+int[7:8])</code> is invalid in Python. <code>int</code> is a type object. You cannot apply slicing to it. Also, <code>832-38-1847</code> is actually <code>-1053</code>. I suggest that you start your Python course with simpler exercises.</span>
<span class="comment-copy">anyone with helpful comments? thank you</span>
<span class="comment-copy">Ranges are non inclusive i[0:2] is only indexes 0 and 1, should be 0:3 , 3:5, 5:9 sorry on phone â€“ vash_the_stampede. thank you vash_the_stampede!</span>
<span class="comment-copy">Just the answer I was looking for. Thank you kind sir.</span>
