<div class="post-text" itemprop="text">
<p>I have a data file that I want to run sed on.
Simplified version of the test.data file is given below</p>
<pre><code>test.data
=============
some text SEARCH_URL = "google.com" some ending text
</code></pre>
<p>I want to extract the SEARCH_URL from this without the quotes. 
Following sed command works well on bash prompt</p>
<pre><code>sed -n 's/^.*SEARCH_URL.*\"\(.*\)\".*/\1/p' ./test.data

Output
=============
google.com
</code></pre>
<p>But the command does not work when invoked from python script with check_output. The only output I get is a cryptic string "\x01\n"</p>
<pre><code>geturl.py
=============
import subprocess
import re

#sed -n 's/^.*SEARCH_URL.*\"\(.*\)\".*/\1/p' test.data #works in bash

res = subprocess.check_output(["sed", "-n", 's/^.*SEARCH_URL.*\"\(.*\)\".*/\1/p', "test.data"]) print("Search URL is : ", res)
</code></pre>
<p>This prints output as</p>
<pre><code>python geturl.py
('Search URL is : ', '\x01\n')
</code></pre>
<p>What am I missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use a <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow noreferrer">raw string</a> when you intend each backslash in a string literal to denote a literal backslash; otherwise the <code>\1</code> in your <code>'s/^.*SEARCH_URL.*\"\(.*\)\".*/\1/p'</code> string would be interpreted as a character of ordinal number 1, which is <code>'\x01</code>.</p>
<p>Change:</p>
<pre><code>res = subprocess.check_output(["sed", "-n", 's/^.*SEARCH_URL.*\"\(.*\)\".*/\1/p', "test.data"])
</code></pre>
<p>to:</p>
<pre><code>res = subprocess.check_output(["sed", "-n", r's/^.*SEARCH_URL.*\"\(.*\)\".*/\1/p', "test.data"])
</code></pre>
</div>
