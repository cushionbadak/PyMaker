<div class="post-text" itemprop="text">
<p>I'm new with oop and python. I've been trying to do a simple thing:
there is class called Foo(),it contains a variable called x which is initially set to zero.</p>
<pre><code>&gt;&gt;&gt;a = Foo()
&gt;&gt;&gt;a.x
&gt;&gt;&gt;0 
</code></pre>
<p>now I want to give a new value to x so:</p>
<pre><code>&gt;&gt;&gt;p.x = 1983
</code></pre>
<p>now a math operation should happen to x, for instance 1 is add to x.now x is 1984,so now when I call x:</p>
<pre><code>&gt;&gt;&gt; p.x
&gt;&gt;&gt; 1984
</code></pre>
<p>also the program should check that whether or not the value given to x is negative or not.If it is negative it should return -1.
I did this but it didn't work:(as I said it should do some mathematical operation on x,the operation itself is not really important)</p>
<pre><code>class Foo():
    x = 0
    if x &gt; 0:
        x %= 100
    elif x &lt; 0:
        x = -1
</code></pre>
<p>I really don't now how should I update a class variable in they I mentioned.
Thank you very much for your attention.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you don't need actual class attributes (you're always constructing an instance of <code>Foo</code> to use the attribute anyway, and it's not common for class attributes to be both public and logically mutable), the correct solution is to make <code>x</code> <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">a <code>property</code></a> that wraps an <em>instance</em> attribute, which has independent values per instance, established in the <code>__init__</code> initializer for the class:</p>
<pre><code>class Foo:
    def __init__(self):
        self._x = 0  # _x is a protected instance attr that the property uses behind the scenes

    @property
    def x(self):  # getter for x is normal
        return self._x

    @x.setter
    def x(self, newx):  # setter for x massages the value before setting it
        if newx &gt;= 0:  # Cheaper to handle 0 on same code path as &gt; 0 so you needn't test &lt; 0
            newx %= 100
        else:
            newx = -1
        self._x = newx
</code></pre>
<p>Usage is pretty simple:</p>
<pre><code>&gt;&gt;&gt; myfoo = Foo()
&gt;&gt;&gt; myfoo.x = 1983
&gt;&gt;&gt; myfoo.x
83
&gt;&gt;&gt; myfoo.x = -3748972983
&gt;&gt;&gt; myfoo.x
-1
</code></pre>
<p>In case it really needs to be a class attribute <em>and</em> it must be accessible on instances, the solution gets ugly, as you need <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow noreferrer">a metaclass</a> to provide <code>property</code>s on classes, and additional properties on the class itself to delegate access on instances to the class itself.</p>
<p>Note: <strong>I <em>strongly</em> discourage actually doing this as anything other than an exercise</strong>:</p>
<pre><code>class FooMeta(type):  # Inheriting from type makes metaclass
    @property
    def x(cls):
        return cls._x
    @x.setter
    def x(cls, newx):
        if newx &gt;= 0:
            newx %= 100
        else:
            newx = -1
        cls._x = newx

class Foo(metaclass=FooMeta):
    _x = 0
    # Must make properties on class if instances are to "benefit" from class property
    @property
    def x(self):
        return type(self).x
    @x.setter
    def x(self, newx):
        type(self).x = newx
</code></pre>
<p>That allows the following to work:</p>
<pre><code>&gt;&gt;&gt; Foo.x  # x exists on Foo itself, not just instances
&gt;&gt;&gt; Foo.x = 1983
&gt;&gt;&gt; Foo.x
83
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.x  # Accessible on instances too
83
&gt;&gt;&gt; f.x = -234789
&gt;&gt;&gt; f.x  # Same behavior on instance
-1
&gt;&gt;&gt; Foo.x  # Changing instance changed class
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It might help. You should refactor your class definition as below    </p>
<pre><code>class Foo():
    def __init__(self):
        self.x=0
    def check_x(self):
        if self.x &gt; 0:
            return (self.x % 100)
        elif self.x &lt; 0:
            return -1
p=Foo()
print(p.x) # 0
p.x=1983
p.check_x() # 83
</code></pre>
<p>Check for negative values</p>
<pre><code>p.x=-100
p.check_x() # -1
</code></pre>
</div>
<span class="comment-copy">Do you know how to increment a regular variable? Have you tried doing the same thing, just with the instance variable?</span>
<span class="comment-copy">Please share the class definition for Foo.</span>
<span class="comment-copy">Are you expected to change the class <code>Foo</code> to get this behavior, or write something that receives a <code>Foo</code> object and updates it in the expected manner? What code have you written so far?</span>
<span class="comment-copy">@FlorianWeimer I edited my post and added my attempt</span>
<span class="comment-copy"><code>p.x</code> is more or less similar to any python variable in terms of operations. p is the instance of class <code>Foo</code> so if you do <code>p.x=p.x+1</code> you should be able to increment the value of THAT instance only.</span>
<span class="comment-copy">This still contains a mix of the usage of class attributes and instance attributes.</span>
<span class="comment-copy">@mad_ thank you for you answer but I didn't want to do something like p.check_c(), what I wanted to do is to set p.x and then automatically the operation happens to it, so the next time I call p.x it returns a changed value.</span>
<span class="comment-copy">@mad_ actually I won't: at first p.x = 0; then I will assign it to: p.x = 1983.Now If I call p.x in idle it still is 1983 and not 83.In order for then operation to take place I have to call p.check_x. What I want is that the check_x function runs in the class itself or something like that so I don't need to call the method from outside.</span>
<span class="comment-copy">@mad_ I want that class to understands that when I changed the value of x ,it should do the operation on the new x by the class itself so I don't need to call that function by my self.It would look something like this: <code>p.x = 1983</code> now the operation has taken place so the next time I say: <code>print(p.x)</code> it gives back 83</span>
<span class="comment-copy">@mad_ I believe you should look at ShadowRangers' answer.</span>
