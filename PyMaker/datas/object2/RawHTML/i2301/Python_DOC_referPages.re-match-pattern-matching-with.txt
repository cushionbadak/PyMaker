<div class="post-text" itemprop="text">
<p>In the code below:</p>
<pre><code>    &gt;&gt;&gt; pattern = re.compile(r'^&lt;HTML&gt;')
    &gt;&gt;&gt; pattern.match("&lt;HTML&gt;")
    &lt;_sre.SRE_Match at 0x1043bc8b8&gt;
    &gt;&gt;&gt; pattern.match("⇢ ⇢ &lt;HTML&gt;", 2) # ⇢ stands for whitespace character.
    None
</code></pre>
<p>When we are using ^ metacharacter and matching pattern then any whitespace character at the beginning as given below doesn't give a match even if the </p>
<blockquote>
<p>'pos' argument is equal to 2, and the reason being given was that the
  metacharacter ^ couldn't be matched in such cases( &lt; is at position 2, and it cannot be matched with ^).</p>
</blockquote>
<pre><code>&gt;&gt;&gt; pattern = re.compile(r'&lt;HTML&gt;$')
&gt;&gt;&gt; pattern.match("&lt;HTML&gt;⇢", 0,6) # ⇢ stands for whitespace character.
&lt;_sre.SRE_Match object at 0x1007033d8&gt;
&gt;&gt;&gt; pattern.match("&lt;HTML&gt;⇢"[:6])
&lt;_sre.SRE_Match object at 0x100703370&gt;
</code></pre>
<p>But, when we are using $ at the end of regular expression and giving the 'end' argument there is a match? Why the difference?</p>
</div>
<div class="post-text" itemprop="text">
<p>You'd have to dig a little into the docs, but the answer lies there. You will find the following information in the docs for <a href="https://docs.python.org/3/library/re.html#re.Pattern.search" rel="nofollow noreferrer"><code>pattern.search</code></a>, the same description applies to <a href="https://docs.python.org/3/library/re.html#re.Pattern.match" rel="nofollow noreferrer"><code>pattern.match</code></a> as well.</p>
<blockquote>
<p>The optional second parameter pos gives an index in the string where
  the search is to start; it defaults to 0. This is not completely
  equivalent to slicing the string; <strong>the <code>'^'</code> pattern character matches at
  the real beginning of the string</strong> and at positions just after a
  newline, <strong>but not necessarily at the index where the search is to
  start.</strong></p>
</blockquote>
<p>So, this means the SOL anchor <code>^</code> will match from the true beginning of the string (and not from the position dictated by <code>pos</code>. OTOH,</p>
<blockquote>
<p>The optional parameter endpos limits how far the string will be
  searched; it will be as if the string is endpos characters long, <strong>so
  only the characters from <code>pos</code> to <code>endpos - 1</code> will be searched for a
  match.</strong></p>
</blockquote>
<p>Emphasis mine. Meaning that a pattern with the EOL anchor <code>^</code> will actually match upto <code>endpos</code> only (unlike <code>pos</code>).</p>
</div>
<span class="comment-copy">In general you should avoid using regex to parse HTML content.  Use an HTML parser instead.</span>
<span class="comment-copy">Just as Tim stated, you should avoid regex for parsing html content. Maybe try BeautifulSoup.</span>
<span class="comment-copy">@TimBiegeleisen: This is just a general question.</span>
<span class="comment-copy"><code>"⇢ ⇢ &lt;HTML&gt;", 2) # ⇢ stands for whitespace character.</code>: the arrows are a little misleading. You have whitespaces and arrows which stands for whitespaces in this line. So is it 4 x whitespace or only 2 times?</span>
<span class="comment-copy">Well, to achieve what OP wants, in this case, just remove the anchor from the regex. <code>match</code> already makes sure the match starts from <code>pos</code> in this case.</span>
