<div class="post-text" itemprop="text">
<p>I have this <code>dictionary (key,list)</code></p>
<pre><code>index={'chair':['one','two','two','two'],'table':['two','three','three']}
</code></pre>
<p>and i want this</p>
<pre><code>#1. number of times each value occurs in each key. ordered descending
indexCalc={'chair':{'two':3,'one':1}, 'table':{'three':2,'two':1}}
#2. value for maximum amount for each key
indexMax={'chair':3,'table':2}
#3. we divide each value in #1 by value in #2 
indexCalcMax={'chair':{'two':3/3,'one':1/3}, 'table':{'three':2/2,'two':1/2}}
</code></pre>
<p>I think I should use lambda expressions, but can't come up with any idea how i can do that. Any help?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, define your values as lists correctly:</p>
<pre><code>index = {'chair': ['one','two','two','two'], 'table': ['two','three','three']}
</code></pre>
<p>Then use <code>collections.Counter</code> with dictionary comprehensions:</p>
<pre><code>from collections import Counter
</code></pre>
<blockquote>
<ol>
<li>number of times each value occurs in each key.</li>
</ol>
</blockquote>
<pre><code>res1 = {k: Counter(v) for k, v in index.items()}
</code></pre>
<blockquote>
<ol start="2">
<li>value for maximum amount for each key</li>
</ol>
</blockquote>
<pre><code>res2 = {k: v.most_common()[0][1] for k, v in res1.items()}
</code></pre>
<blockquote>
<ol start="3">
<li>we divide each value in #1 by value in #2</li>
</ol>
</blockquote>
<pre><code>res3 = {k: {m: n / res2[k] for m, n in v.items()} for k, v in res1.items()}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>index={'chair':{'one','two','two','two'},'table':{'two','three','three'}}
</code></pre>
<p>Problem:  <code>{}</code> is creating a set. So you should consider to  convert it into list.</p>
<p>Now coming to your  solution:</p>
<pre><code>from collections  import Counter


index={'chair': ['one','two','two','two'],'table':['two','three','three']}
updated_index = {'chair': dict(Counter(index['chair'])), 'table': dict(Counter(index['table']))}
updated_index_2 = {'chair': Counter(index['chair']).most_common()[0][1], 'table': Counter(index['table']).most_common()[0][1]}
print(updated_index)
print(updated_index_2)
</code></pre>
<p>You can use python collections library, <code>Counter</code> to find the count without  writing any lambda function.</p>
<blockquote>
<p>{'chair': {'one': 1, 'two': 3}, 'table': {'two': 1, 'three': 2}}</p>
<p>{'chair': 3, 'table': 2}</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, you have a mistake in how you created the <code>index</code> dict. You should have lists as the elements for each dictionary, you currently have sets. Sets are automatically deduplicated, so you will not be able to get a proper count from there.</p>
<p>You should correct index to be:</p>
<pre><code>index={'chair':['one','two','two','two'],'table':['two','three','three']}
</code></pre>
<p>You can use the <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer" title="Counter">Counter module</a> in Python 3, which is a subclass of the <code>dict</code> module, to generate what you want for each entry in <code>indexCalc</code>. A counter will create a dictionary with a key, and the number of times that key exists in a collection.</p>
<pre><code>indexCalc = {k, Counter(v) for k, v in index}
</code></pre>
<p><code>indexCalc</code> looks like this:</p>
<pre><code>{'chair': Counter({'two': 3, 'one': 1}), 'table': Counter({'three': 2, 'two': 1})}
</code></pre>
<p>We can easily find the index that corresponds to the maximum value in each sub-dictionary:</p>
<pre><code>indexMax = {k: max(indexCalc[k].values()) for k in indexCalc}
</code></pre>
<p><code>indexMax</code> looks like this:</p>
<pre><code>{'chair': 3, 'table': 2}
</code></pre>
<p>You can create <code>indexCalcMax</code> with the following comprehension, which is a little ugly:</p>
<pre><code>indexCalcMax = {k: {val: indexCalc[k][val] / indexMax[k] for val in indexCalc[k]} for k in indexCalc}
</code></pre>
<p>which is a dict-comprehension translation of this loop:</p>
<pre><code>for k in indexCalc:
  tmp = {}
  for val in indexCalc[k]:
    tmp[val] = indexCalc[k][val] / float(indexMax[k])
  indexCalcMax[k] = tmp
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I know this is suboptimal, but I had to do it as a thought exercise:</p>
<pre><code>indexCalc = {
    k: {key: len([el for el in index[k] if el == key]) for key in set(index[k])} 
    for k in index
}
</code></pre>
<p>Not exactly lambda, as suggested, but comprehensions... Don't use this code in production :) This answer is only partial, you can use the analogy and come up with the other two structures that you require.</p>
</div>
<span class="comment-copy">You want all 3 or just the final output?</span>
<span class="comment-copy">@vash_the_stampede , i want all 3 dictionaries, indexCalc, indexMax, indexCalcMax.</span>
<span class="comment-copy">Your original index can't contain that data, because the values are sets and sets must be unique. Do you mean to use lists instead?</span>
<span class="comment-copy">@DanielRoseman, I understand that if you put that in that way, that will transfer it to set, but for representation purpose i put it in that way. that is List actually</span>
<span class="comment-copy">Neat. Thanks. Will try to understand how above code works, that will help a lot</span>
<span class="comment-copy">thanks for comment, updated it to be a list. Is there any generic vesion to solve my problem?</span>
<span class="comment-copy">@EricKlaus I have  updated  my answer check</span>
