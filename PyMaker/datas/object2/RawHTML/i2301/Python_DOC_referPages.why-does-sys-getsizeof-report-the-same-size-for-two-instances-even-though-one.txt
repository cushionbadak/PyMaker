<div class="post-text" itemprop="text">
<pre><code>import sys

class MyObject:
    def __init__(self,name,salary):
        self.name = name
        self.salary = salary

obj1 = MyObject("Tushar", 50)
obj2 = MyObject("Tushar", 50)
obj2.age = 20

print(sys.getsizeof(obj1))  # 56
print(sys.getsizeof(obj2))  # 56
</code></pre>
<p>Why is <code>obj2</code> only 56 bytes when it has an extra <code>age</code> attribute?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>sys.getsizeof()</code> only gives you the system memory use for the direct reference. Instance objects don't store attributes <em>directly</em>, by default those are stored in a dictionary object referenced by the <code>__dict__</code> name. And dictionaries store keys and values as references too, <code>sys.getsizeof()</code> would only give you the memory size of the dictionary internal C arrays and other internal bookkeeping attributes, not the keys or values themselves.</p>
<p>From the <a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="nofollow noreferrer"><code>sys.getsizeof()</code> documentation</a>:</p>
<blockquote>
<p>Only the memory consumption directly attributed to the object is accounted for, not the memory consumption of objects it refers to.</p>
</blockquote>
<p>You'd have to <em>recursively</em> collect object sizes until you run out of attributes or key-value pairs, etc. The documentation links to <a href="https://code.activestate.com/recipes/577504/" rel="nofollow noreferrer">this example code</a> to show you how to do this.</p>
<p>That specific recipe has no support for instances but here passing in the <code>__dict__</code> attribute of your objects should suffice:</p>
<pre><code>&gt;&gt;&gt; total_size(obj1.__dict__)
303
&gt;&gt;&gt; total_size(obj2.__dict__)
383
</code></pre>
<p>so the two objects have different total size attribute dictionaries.</p>
<p>Note that there are many places where Python <em>caches or interns objects</em>, so don't take these memory sizes as absolutes. For example, <a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">small integers are interned</a>, so there is only ever a single <code>50</code> integer object in CPython memory, but it was counted separately in the above <code>total_size()</code> output.</p>
<p>And modern CPython versions can also save memory by having the <code>__dict__</code> dictionary objects of those two instances <a href="https://www.python.org/dev/peps/pep-0412/" rel="nofollow noreferrer">share data on the keys</a>, in the assumption that the vast majority of instances of a given class will have the same attributes.</p>
<p>Take this into account when analysing <code>sys.getsizeof()</code> data. If you wanted to profile Python memory use, you'd be much better of learning how to use the <a href="https://docs.python.org/3/library/tracemalloc.html#module-tracemalloc" rel="nofollow noreferrer"><code>tracemalloc</code> tool</a> first.</p>
</div>
<span class="comment-copy">What were you hoping <code>sys.getsizeof()</code> would give you?</span>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python/3373511" title="how do i determine the size of an object in python">stackoverflow.com/questions/449560/…</a> (read through several of the answers).</span>
<span class="comment-copy">Too much Information</span>
<span class="comment-copy">@TusharJajodia well, you didn’t say anything about what you were trying to do, so I covered the spectrum.</span>
