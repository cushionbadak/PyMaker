<div class="post-text" itemprop="text">
<p>I have an algorithm in which I need to work out the signed angle (-180 to 180) between edges in a graph. I've done some research and found plenty of specific answers but can't figure out how to relate them to my situation (e.g. <a href="https://stackoverflow.com/questions/28260962/calculating-angles-between-line-segments-python-with-math-atan2">this</a>  question which uses <code>atan2</code>, however the OP wanted only positive angles)
I've tried implementing a few different ways (using atan2 or arccos) but I'm struggling to relate the examples to my specific problem. I've tried treating the edges as vectors but got strange results.</p>
<p>Given a graph with points (A, B, C, D, E), and the average of those points (avg)... how do I find the signed angle between one of those points (e.g. A) and the other points (e.g. B, C, D, E), taking the angle from the current origin (A) to the 'avg' point as equal to 0 degrees. Example below...</p>
<p><a href="https://i.stack.imgur.com/Hzpyj.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/Hzpyj.png"/></a></p>
<p>...in this example, the anti-clockwise angle from (A, avg) to (A, B) would be positive something (between 0 and 180), and the angle from (A, avg) to (A, E) would be negative something (between 0 and -180).</p>
<p>Ideally I want a formula which I could also apply to defining any of the points as the origin, for example taking point C as the origin.. the 'zero angle' would be (C, avg) and the angle between (C, avg) and (C, A) would be negative (0 to -180) and the angle between (C, avg) and (C, E) would be positive (0 to 180).</p>
<p>I haven't studied math beyond high-school so I find it hard to decipher equations with symbols I don't understand.</p>
<p>UPDATE: Thought I'd clean this up to make it more obvious what the conclusion was.
I made two small changes to the accepted answer, resulting in the below snippet:</p>
<pre><code>def angle(vertex, start, dest):
    AhAB = math.atan2((dest.y - vertex.y), (dest.x - vertex.x))
    AhAO = math.atan2((start.y - vertex.y), (start.x - vertex.x))
    AB = AhAB - AhAO
    # in between 0-math.pi = do nothing, more than math.pi = +(-2 * math.pi), less than zero = do nothing
    AB = math.degrees(AB + (-2 * math.pi if AB &gt; math.pi else (2 * math.pi if AB &lt; 0 - math.pi else 0)))
    return AB
</code></pre>
<p>...the final one-liner may be a bit much to grok after a few months of not working on this, so I turned it into it's own function, taking the result of <code>AB = AhAB - AhAO</code> as it's argument...</p>
<pre><code>def calc(ab):
    if ab &gt; math.pi:
        return ab + (-2 * math.pi)
    else:
        if ab &lt; 0 - math.pi:
            return ab + (2 * math.pi)
        else:
            return ab + 0
</code></pre>
<p>I thought this was a little clearer to read, though more lines.</p>
<p>The final function in full:</p>
<pre><code>def angle(vertex, start, dest):
    """Calculates the signed angle between two edges with the same origin. 
       Origin is the 'vertex' argument, 'start' is the bounding point of the edge to calculate the angle from.
       Positively signed result means anti-clockwise rotation about the vertex."""

    def calc_radians(ab):
        if ab &gt; math.pi:
            return ab + (-2 * math.pi)
        else:
            if ab &lt; 0 - math.pi:
                return ab + (2 * math.pi)
            else:
                return ab + 0

    AhAB = math.atan2((dest.y - vertex.y), (dest.x - vertex.x))
    AhAO = math.atan2((start.y - vertex.y), (start.x - vertex.x))

    res = calc_radians(AhAB - AhAO)

    return math.degrees(res)
</code></pre>
<p><strong>Note</strong>: The function assumes the three arguments will all be instances of a typical <code>Point</code> class with <code>x</code> and <code>y</code> attributes.
Also, the example graph above has only positive values, but I am fairly sure that this works with graphs that involve negative values too.</p>
</div>
<div class="post-text" itemprop="text">
<p>I read your problem statement as follows: given 2 points <em>A</em> and <em>B</em>, and a center <em>O</em>, find the angle <em>A</em> to <em>B</em> as the angle, positive if anticlockwise, between the vectors <em>A→O</em> and <em>A→B</em>.</p>
<p>If my premises are correct, then you can</p>
<ul>
<li>find the angle between <em>A→B</em> and a horizontal, rightward line passing in <em>A</em>,</li>
<li>find the angle between <em>A→O</em> and a horizontal, rightward line passing in <em>A</em>,</li>
<li>find the angle <em>A</em> to <em>B</em> as the difference of said angles,</li>
<li>normalize the result range so that it's between -π and +π.</li>
</ul>
<p>What I've said can be visualized as follows</p>
<p><a href="https://i.stack.imgur.com/OEsLB.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/OEsLB.png"/></a>
or in code (assuming a <code>Point</code> class with attributes <code>x</code> and <code>y</code>)</p>
<pre><code>AhAB = math.atan2((B.y-A.y), (B.x-A.x)) # -π &lt; AhAB ≤ +π
AhAO = math.atan2((O.y-A.y), (O.x-A.x)) # -π &lt; AhA) ≤ +π
AB = AhAB - AhAO                        # -2π &lt; AB ≤ +2π
AB = AB + ( 2*math.pi if AB &lt; math.pi else (-2*math.pi if AB&gt; math.pi else 0))
</code></pre>
<p><em>Addendum</em></p>
<p>Here it is a small code example, the position of the points is just <em>similar</em> to what you can see in the picture</p>
<pre><code>In [18]: from math import atan2, pi
In [21]: class Point():
    ...:     def __init__(self, x, y):
    ...:         self.x, self.y = x, y
    ...:     def __repr__(self):
    ...:         return '(%s, %s)'%(self.x, self.y)
In [22]: A = Point(0.0, 0.0)
In [23]: B = Point(-2.0, 2.0)
In [24]: O = Point(0.0, -3.0)
In [25]: AhAB = atan2((B.y-A.y), (B.x-A.x)) ; print(3/4, AhAB/pi)
0.75 0.75
In [26]: AhAO = atan2((O.y-A.y), (O.x-A.x)) ; print(-1/2, AhAO/pi)
-0.5 -0.5
In [27]: AB = AhAB - AhAO ; print(5/4, AB/pi)
1.25 1.25
In [28]: AB = AB + ( 2*pi if AB &lt; pi else (-2*pi if AB&gt; pi else 0)) ; print(AB/pi)
-0.75
In [29]: 
</code></pre>
<p>The last line normalize your result <code>AB</code> to be in the correct range <code>-π &lt; AB ≤ π</code>, adding or subtracting <code>2π</code> that doesn't change the meaning of the measured angle.</p>
</div>
<div class="post-text" itemprop="text">
<p>The definition of positive and negative angles is heavily depending on the reference system or reference point. Despite of its 'correct' definition, the basic calculation can be pretty much done based on the <a href="https://en.wikipedia.org/wiki/Slope" rel="nofollow noreferrer">slope</a> between two points and the resulting angle of incline which can be calculated by applying the inverse <a href="https://en.wikipedia.org/wiki/Trigonometric_functions#tangent" rel="nofollow noreferrer">tan</a> to the slope.</p>
<p>Applying the <a href="https://en.wikipedia.org/wiki/Arctangent" rel="nofollow noreferrer">inverse tan</a> in programming can be a bit annoying since many programming languages provide two different functions for this:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions" rel="nofollow noreferrer"><code>arctan</code> or <code>atan</code></a> which is implemented in Python's <a href="https://docs.python.org/3/library/math.html#math.atan" rel="nofollow noreferrer"><code>math.atan()</code></a> or <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.arctan.html" rel="nofollow noreferrer"><code>numpy.atan()</code></a></li>
<li><a href="https://en.wikipedia.org/wiki/Atan2" rel="nofollow noreferrer"><code>arctan2</code> or <code>atan2</code></a> which is delivered by <a href="https://docs.python.org/3/library/math.html#math.atan2" rel="nofollow noreferrer"><code>math.atan2()</code></a> or <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.arctan2.html" rel="nofollow noreferrer"><code>numpy.atan2()</code></a></li>
</ul>
<p>Both of these functions, regardless of the implementation in the <code>math</code> module or <code>numpy</code> package, return the calculated angle in radians which is basically based on the number Pi instead of degrees which makes some further conversion necessary. This can either be done manually or by applying a function like <a href="https://docs.scipy.org/doc/numpy-1.10.4/reference/generated/numpy.rad2deg.html" rel="nofollow noreferrer"><code>numpy.rad2deg()</code></a>. To get a basic idea of the data points and to get some eye-balled estimation for the calculated results, I suggest plotting the data point by using <code>matplotlib</code>.</p>
<p>Glueing all the before-mentioned considerations into code can look like this:</p>
<pre><code>import pandas as pd
import matplotlib
import numpy as np

%matplotlib inline
import matplotlib.pyplot as plt


# Define some sample data points
coords = {
'A': (1.5, 3.0),
'B': (3.0, 5.0),
'C': (5.5, 4.5),
'D': (5.8, 2.2),
'E': (2.8, 1.2)
}

# Extract data values from `coords` dict
values = np.array(list(coords.values()))

# Calculate the averaged point of all data points
avg = np.mean(values, axis=0)

# Plot sample data for better overview
for k, v in coords.items():
    plt.plot(*v, marker='o', linestyle='')
    plt.text(*v, k)
plt.plot(*avg, marker='o', linestyle='')
plt.text(*avg, 'avg')
plt.show()

# For further information about slope and angle of incline
# see Wikipedia (https://en.wikipedia.org/wiki/Slope).
# Calculating the angle from `avg` to each point. Please adopt
# to your own needs if needed for other pairs of points.

# Calculate the distance in x- and y-direction from each point to point `avg`
distances_x_y = (values - avg)

# Depending on your definition of the 'reference point' consider using
# distances_x_y = (avg - values)

# For further explanation on `atan` and `atan2` see
# https://stackoverflow.com/q/35749246/3991125 and
# https://en.wikipedia.org/wiki/Atan2 .
# Using a for loop instead of numpy's array/vectors is not very elegant,
# but easy to understand and therefore has potential for improvements.
# Calculate angle from point `avg` to each other point based on distances 
angle_radians = np.array([np.arctan2(element[1], element[0]) for element in distances_x_y])

# since `.arctan2()` or `.arctan()` return the angle in radians,
# we need to convert to degrees
angle_degrees = np.rad2deg(angle_radians)

# print results
print(angle_degrees)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you consider the coordinates <code>x0=xavg-xA</code>, <code>y0=yavg-yA</code> and <code>x=xPoint-xA,y=yPoint-yA</code>, the formula <code>f(x,y)</code> gives the signed angle that is positive as counter clockwise.</p>
<pre><code>f(x,y)=pi()/2*((1+sign(x0))* (1-sign(y0^2))-(1+sign(x))* (1-sign(y^2)))

     +pi()/4*((2+sign(x0))*sign(y0)-(2+sign(x))*sign(y))

     +sign(x0*y0)*atan((abs(x0)-abs(y0))/(abs(x0)+abs(y0)))

    -sign(x*y)*atan((abs(x)-abs(y))/(abs(x)+abs(y)))
</code></pre>
</div>
<span class="comment-copy">Thanks for the diagram, that really helped! One small problem... at the end of the last line of the snippet.. "math.pi or 0)_)" the console is telling me there is a missing else statement (where the underscore is) ?</span>
<span class="comment-copy">Ooops, I've made a syntax error (I wrote <code>or</code> where <code>else</code> was needed)! please see the corrected version that I've just uploaded.  Aside: is my answer on target with your requirements?</span>
<span class="comment-copy">Out of curiosity, how did you create that sick graph of yours?</span>
<span class="comment-copy">@asynts I created the graph using <code>xfig</code>, but to have nicely typeset maths I ① exported the graph to a combination of LaTeX code plus a PDF image ② processed the LaTeX code with a custom script to get a PDF comprising the graphical elements and the rendering of math and text ③ used <code>convert</code> from ImageMagick to have a PNG suitable for uploading <code>convert -density 400 arcs.pdf arcs.png</code> — the time consuming part is to draw the diagram in XFig, the last two parts take say 20".</span>
<span class="comment-copy">@gboffi I'm pretty sure this is on target, I'll be home later on to check it out</span>
