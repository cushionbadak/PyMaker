<div class="post-text" itemprop="text">
<p>I tested the following unicode:</p>
<pre><code>In [34]: snowman = "\u2603"
In [35]: snowman
Out[35]: '☃'
</code></pre>
<p>encode snowman</p>
<pre><code>In [36]: ds = snowman.encode("utf-8")
In [37]: ds
Out[37]: b'\xe2\x98\x83'
</code></pre>
<p>However, when I checked it with ord()</p>
<pre><code>In [38]: ord('☃')
Out[38]: 9731
</code></pre>
<p>It's different with b'\xe2\x98\x83'</p>
<p>How could I understand it?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#ord" rel="nofollow noreferrer"><code>ord</code></a> returns a Unicode codepoint ---
a somewhat arbitrary number that identifies the given character.</p>
<p><a href="https://docs.python.org/3/library/stdtypes.html#str.encode" rel="nofollow noreferrer"><code>encode</code></a>
returns a sequence of bytes that represents the given string in some encoding...
if the string <em>can</em> be represented in that encoding.</p>
<p>The encoding and the codepoint are only related in the sense that they both identify the same character.</p>
<p>An excellent introduction to the difference between <em>bytes</em> and <em>characters</em> is Ned Batchelder's
"<a href="http://nedbatchelder.com/text/unipain.html" rel="nofollow noreferrer">Pragmatic Unicode, or, How Do I Stop the Pain?</a>"
(36 minute <a href="https://www.youtube.com/watch?v=sgHbC6udIqc" rel="nofollow noreferrer">video from PyCon US 2012</a>).
He covers both Python 2 and 3, and the drastically different approaches they take to solving this problem.</p>
</div>
<span class="comment-copy">But why would you expect these to be the same? They do different things.</span>
<span class="comment-copy"><code>hex(9731)</code> equals <code>'0x2603'</code>.</span>
<span class="comment-copy">To echo @unutbu, hex 9731 == unicode 2603 == bytes \xe2\x98\x83</span>
<span class="comment-copy">UTF-8 is designed so that 1) code points 0-127 are represented using single bytes, the same as in ASCII and 2) any multi-byte character is represented using bytes greater than 128. (This allows easy detection of non-ASCII characters and ensures that if you strip all chars &gt; 128, you will not strip partial characters.) It's an <i>encoding</i> of Unicode but <i>it is not itself Unicode.</i> It's a mapping of Unicode to a stream of bytes. There will be differences. If you want an exact mapping of code points to bytes, try UTF-32.</span>
