<div class="post-text" itemprop="text">
<p>Hello i am having a weird issue maybe some one can help, 
I start by running 2 different function with the same argument which is an object that is already instantiated : </p>
<pre><code>iotComponent.connectedSensors=sensorList
iotComponent.connectedHUIs=HUIList

Coap = multiprocessing.Process(target=runCoapSync,args=(iotComponent,))
huis = multiprocessing.Process(target=runHuis,args=(iotComponent,))
huis.start()
Coap.start()
</code></pre>
<p>then here are both functions : </p>
<pre><code>async def runCoap(iotDevice):

    context = await Context.create_client_context()
    sensor=iotDevice.connectedSensors[0]
    while True:
        await asyncio.sleep(1)
        sensor.sense()
        lightMsg = iotDevice.applicationInterface.createMsg( sensor, iotDevice.communicationProtocol.name)
        await iotDevice.communicationProtocol.sendMsg(context,lightMsg,"light")


def runHuis(iotDevice):
    print("----------------1---------------")
    LCD=iotDevice.connectedHUIs[0]
    while True:
        LCD.alertHuman(iotDevice.connectedSensors[0].data.value)
</code></pre>
<p>in the first function when <code>sensor.sense()</code> is called the value attribute inside data attribute of the sensor is updated.</p>
<p>But in the second function, <code>iotDevice.connectedSensors[0].data.value</code> is always equals to Zero. I find this behavior weird because this is the same object. Moreover if i add a line <code>sensor.sense()</code> in the second function the value gets updated but it is not the same as the value printed in first function.</p>
<p>EDIT 0 : 
here is the sense() method :</p>
<pre><code> def sense(self):
        pinMode(self.pinNumber, "INPUT")
        lightSensorValue = analogRead(self.pinNumber)
        self.data.timestamp=str(round(time.time(), 3))
        self.data.value=lightSensorValue
</code></pre>
<p>If someone as an idea that would be great !</p>
<p>SOLUTION : as said in the accepted answer i tried with threading and it worked like a charm : </p>
<pre><code>Coap = threading.Thread(target=runCoapSync,args=(iotComponent,))
huis = threading.Thread(target=runHuis,args=(iotComponent,))
huis.start()
Coap.start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See <a href="https://stackoverflow.com/questions/15857838/modify-object-in-python-multiprocessing">this</a> answer. Essentially what's happening is that your data is "pickled" before being sent to the processes to have work done. When the objects are received, they're unpacked. Therefore, the objects are more cloned than passed around. Therefore, you're actually working with two separate copies of <code>iotComponent</code>, which explains why you can't actually see any change happening on one even though you "know" work is being done. There might be a way to do this, given <a href="https://stackoverflow.com/questions/10721915/shared-memory-objects-in-multiprocessing">this</a>. However, it might be better to not use <code>Process</code>, but use <code>Thread</code> instead, see <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">here</a>. The difference is that, according to <a href="https://timber.io/blog/multiprocessing-vs-multithreading-in-python-what-you-need-to-know/" rel="nofollow noreferrer">this</a>, threads are better for I/O-bound operations, which your sensor certainly is.</p>
</div>
<span class="comment-copy">Seems that your problems are tied to the behavior of <code>sensor.sense()</code>. Do you have documentation you can provide on this method?</span>
<span class="comment-copy">i have edited the post</span>
<span class="comment-copy">thank you very much i'll try this</span>
