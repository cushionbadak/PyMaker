<div class="post-text" itemprop="text">
<p>I was writing a function to remove adjacent equivalent numbers in a list. I wrote remove_adjacent(nums) in honestly less than a minute. However I seem to be stuck in this rut where what I write is not pythonic at all. And also it is not nearly as fast as I would like. The second solution was the intended one written by Google. This is a Google basic coding problem solution doc that I have been working through I forgot where specifically I got it from however it is from Google development.</p>
<pre><code># D. Given a list of numbers, return a list where
# all adjacent == elements have been reduced to a single element,
# so [1, 2, 2, 3] returns [1, 2, 3]. You may create a new list or
# modify the passed in list.

def remove_adjacent(nums):

  index, index_1 = 0, 1
  while index_1 &lt; len(nums):
      if nums[index] == nums[index_1]:
          nums = nums[:index] + nums[index+1:]
      else:
          index = index_1
          index_1 += 1 
  return nums

#Googles solution
def remove_adjacent2(nums):
    result = []
    for num in nums:
        if result == [] or num not in result:
            result.append(num)
    return result
</code></pre>
<p>I feel like my problem stems from my previous experiences with C and C++. Any thoughts on how to improve? Do I just need brute force practice? Continuous reiterations of "I wrote it like this but it is way more python to write it like this"</p>
</div>
<div class="post-text" itemprop="text">
<p>There is an <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools recipe</a> for this, it looks like:</p>
<pre><code>def unique_justseen(iterable, key=None):
    "List unique elements, preserving order. Remember only the element just seen."
    # unique_justseen('AAAABBBCCDAABBB') --&gt; A B C D A B
    # unique_justseen('ABBCcAD', str.lower) --&gt; A B C A D
    return map(next, map(itemgetter(1), groupby(iterable, key)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Perfect for <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>from itertools import groupby

lst = [1, 2, 2, 3]
print([next(x) for _, x in groupby(lst)])
# [1, 2, 3]
</code></pre>
</div>
<span class="comment-copy">Is it just adjacent identical numbers that should be reduced to a single instance, or  all identical numbers? e.g. Is <code>[1, 2, 3, 1]</code> allowed?</span>
<span class="comment-copy">In that case, the Google version is broken: it removes all dupes, not just adjacent ones.</span>
<span class="comment-copy">The Pythonic way is to create a result list and append items to it if they don't match the current last item in result. Your version creates 2 new lists on every loop iteration, which isn't very efficient.</span>
<span class="comment-copy">Google's solution can be reduced to just <code>list(set(nums)</code>, but it doesn't look at adjacent numbers, just dupes</span>
<span class="comment-copy">@Nordle Kind of, but <code>set</code> may not preserve order.</span>
<span class="comment-copy">Since you're using the default "identity" key function with <code>groupby</code>, there's no need to mess around calling <code>next</code> on the group, just use the key directly (the thing you currently assign to <code>_</code>).</span>
<span class="comment-copy">@PM2Ring Correct.  So: <code>[a for a, _ in groupby(lst)]</code>.</span>
