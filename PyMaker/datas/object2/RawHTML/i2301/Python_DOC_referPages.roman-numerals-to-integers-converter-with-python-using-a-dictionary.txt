<div class="post-text" itemprop="text">
<p>I'm learning to code and I had an exercise to make a converter of roman numerals to integers. I realize there are a lot of different ways to write this program, but I would appreciate it if you could help me find my mistake. I'd love to hear suggestions on how to write it better, but what I really could use right now is understanding what I did wrong with this one.</p>
<p>I have a dictionary called <code>roman_numerals</code>. Its <code>keys</code> are the roman numeral values, and its <code>values</code> are their matching integer.</p>
<pre><code>roman_numerals = {"M":1000,"CM":900,"D":500,"CD":400,"C":100,"XC":90,"L":50,"XL":40,"X":10,"V":5,"IV":4,"I":1}

def roman_int(user_choice):
    if user_choice == "1":
        user_roman = input("What numeral would you like to convert?\n").upper()
        resultI = 0
        for k,v in roman_numerals.items():          
            if user_roman == k:
                resultI += roman_numerals.get(user_roman)
            else:
                for i in user_roman:
                    if i in roman_numerals.keys():
                        if i == k:
                            resultI += v
    print(resultI)
</code></pre>
<p>When I run my code,if I use a numeral that is equal to a <code>key</code> of more than one character ("IV" for example) I get a result that is an addition of both "IV" and "V". or "CM" and "M".
I know why it happens, because I asked for an iteration. But, can I ask my program to stop iterating when it returns a value? I feel like I'm really close to the solution, but I'm just confused at this point.</p>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to make sure that you consume all characters that contribute to the sum. Since all the multi-char "atomic" literals begin with the lower valued unit, and otherwise, higher valued units come first, a simple greedy approach is workable:</p>
<ul>
<li>Try to convert the first two chars as a whole, if that's not possible, convert the first single char.  </li>
<li><p>Move forward the appropriate number of steps.</p>
<pre><code>def roman_int(user_roman):
    user_roman = user_roman.upper()
    resultI = 0

    while user_roman:
        # try first two chars
        if user_roman[:2] in roman_numerals:
            resultI += roman_numerals[user_roman[:2]]
            # cut off first two chars
            user_roman = user_roman[2:]
        # try first char
        elif user_roman[:1] in roman_numerals:
            resultI += roman_numerals[user_roman[:1]]
            # cut off first char
            user_roman = user_roman[1:]
        else:
            print('No roman number')
            return
    print(resultI)
</code></pre></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>It might be better to represent the values as a list of tuples, since this allows us to define an <em>order</em> in them, and therefore we can avoid matching <code>'I'</code> in case the string contains at that point <code>'IX'</code>. So we can define the conversion as:</p>
<pre><code>roman_numerals = [
    ('M', 1000),
    ('CM', 900),
    ('D', 500),
    ('CD', 400),
    ('C', 100),
    ('XC', 90),
    ('L', 50),
    ('XL', 40),
    ('X', 10),
    ('IX', 9),
    ('V', 5),
    ('IV', 4),
    ('I', 1)
]
</code></pre>
<p>Note that you forgot to use <code>IX</code>, this makes it to some extent problematic, since it will interpret <code>IX</code> as <code>11</code>.</p>
<p>Now we can process the string by each time performing a <a href="https://docs.python.org/3/library/stdtypes.html#str.startswith" rel="nofollow noreferrer"><strong><code>str.startswith()</code></strong> [Python-doc]</a> check, and from the moment we found a prefix, add the corresponding value, and advance the offset of the string, like:</p>
<pre><code>def roman_int(user_choice):
    ix = 0
    result = 0
    while ix &lt; len(user_choice):
        for k, v in roman_numerals:
            if user_choice.startswith(k, ix):
                result += v
                ix += len(k)
                break
        else:
            raise ValueError('Invalid Roman number.')
    return result
</code></pre>
<p>We thus enumerate through the string, and each time look to match a Roman numeral. For example:</p>
<pre><code>&gt;&gt;&gt; roman_int('MCMXC')
1990
&gt;&gt;&gt; roman_int('MCMXCIII')
1993
&gt;&gt;&gt; roman_int('MMXVIII')
2018
</code></pre>
<p>The system will also error if for example we enter invalid characters:</p>
<pre><code>&gt;&gt;&gt; roman_int('MMXQVIII')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 11, in roman_int
ValueError: Invalid Roman number.
</code></pre>
<p>The above is however not very efficient: each time we enumerate <code>roman_literals</code> until we find the match. But once we are processing the "fifties" (<code>L</code>), then we know that we will never parse "thousands" (<code>M</code>) again. We can boost performance by remembering the index in the <code>roman_numerals</code>:</p>
<pre><code>def roman_int(user_choice):
    ix = 0
    iy = 0
    result = 0
    while ix &lt; len(user_choice):
        while iy &lt; len(roman_numerals) and not user_choice.startswith(roman_numerals[iy][0], ix):
            iy += 1
        if iy &lt; len(roman_numerals):
            result += roman_numerals[iy][1]
            ix += len(roman_numerals[iy][0])
        else:
            raise ValueError('Invalid Roman numeral')
    return result
</code></pre>
<p>This again yields the results we expect:</p>
<pre><code>&gt;&gt;&gt; roman_int('MDCCLXXVI')
1776
&gt;&gt;&gt; roman_int('MCMLIV')
1954
&gt;&gt;&gt; roman_int('MCMXC')
1990
&gt;&gt;&gt; roman_int('MMXIV')
2014
&gt;&gt;&gt; roman_int('MMXVIII')
2018 
</code></pre>
<p>But is also stricter, for example <code>CMM</code> is <em>not</em> a valid Roman numeral, whereas <code>MCM</code> is:</p>
<pre><code>&gt;&gt;&gt; roman_int('CMM')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 12, in roman_int
ValueError: Invalid Roman numeral
&gt;&gt;&gt; roman_int('MCM')
1900
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no need to loop through the dictionary. My code is slightly different but I have tried to keep as much of your code as possible.</p>
<pre><code>roman_numerals =  {"M":1000,"CM":900,"D":500,"CD":400,"C":100,"XC":90,"L":50,"XL":40,"X":10,"V":5,"IV":4,"I":1}

def roman_int(user_choice):
    if user_choice == "1":
        user_roman = input("What numeral would you like to convert?\n").upper()
        result = 0
        values = []

        # return the result if the input is in the dictionary
        try:
            result = roman_numerals[user_roman]
        except KeyError:
            # split up the user input and convert each character into corresponding numeral
            for i in user_roman:
                try:
                    value = roman_numerals[i]
                    values.append(value)
                # if user enters character not used in roman numerals
                except KeyError:
                    print("Not valid input")
            # loop through all values and add them up
            for i, value in enumerate(values):
                try:
                    # if a value is larger than the next value, add it
                    if value &gt; values[i+1]:
                        result += value
                    # else the number is obtained by substracting the smaller value from the larger value
                    else:
                        actual_value = values[i+1] - value
                        result = result + actual_value
                        #set the next number to 0 as it has already been added
                        values[i+1] = 0
                except IndexError:
                    # this try except block catches the IndexError exception caused when i+1 &gt; len(values)
                    pass
        print(result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way to look at it I guess</p>
<pre><code>roman_numerals = {"M":1000,"CM":900,"D":500,"CD":400,"C":100,"XC":90,"L":50,"XL":40,"X":10,"V":5,"IV":4,"I":1}

def roman_int(user_choice):
    if user_choice == "1":
        user_roman = input("What numeral would you like to convert?\n").upper()
        resultI = 0
        pos = 0
        try:
            resultI = roman_numerals[user_roman]
        except:
            try:
                while pos &lt; len(user_roman):
                    resultI += roman_numerals[user_roman[pos]]
                    pos+=1
            except:
                print('Not present in our dictionary')
    print(resultI)    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Count the number of occurences of each numeral in string instead of checking string for occurrences, then just remove the occurrences where double letters such as <code>CM</code> appear so remove nulber of occurrences of <code>CM</code> * value of <code>C</code> and <code>M</code> </p>
<pre><code>roman_numerals = {"M":1000,"CM":900,"D":500,"CD":400,"C":100,"XC":90,"L":50,"XL":40,"X":10,"IX":9, "V":5,"IV":4,"I":1}

def roman_int(user_choice):
    if user_choice == "1":
        result = 0
        user_roman = input("What numeral would you like to convert?\n").upper()
        for k,v in roman_numerals.items():          
            result += v * user_roman.count(k)
            if len(k) == 2:
                result -= roman_numerals[k[0]] * user_roman.count(k)
                result -= roman_numerals[k[1]] * user_roman.count(k)                
    print(result)

roman_int("1")
</code></pre>
</div>
<span class="comment-copy">I beleive my answer should solve your problem</span>
