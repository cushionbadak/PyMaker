<div class="post-text" itemprop="text">
<p>I have a dictionary as follows:</p>
<pre><code>D = {
    'd1': [[a1, a1, a1], [a2, a2, a2], [a3, a3, a3]], 
    'd2': [[b1, b1, b1], [b2, b2, b2], [b3, b3, b3]], 
    'd3': [[c1, c1, c1], [c2, c2, c2], [c3, c3, c3]], 
    'd4': [[d1, d1, d1], [d2, d2, d2], [d3, d3, d3]]
}
</code></pre>
<p>How do I convert it to a dataframe such that </p>
<ul>
<li><p>The columns from the lists for a key are paired up; the nested lists are time values, temperatures and damage values, respectively, and the dataframe needs to have these in separate columns. S for <code>[[a1, a1, a1], [a2, a2, a2], [a3, a3, a3]]</code>, you'd get a row with <code>a1, a2, a3</code> (first column), followed by a row for the 2nd column, etc.</p></li>
<li><p>The dataframe rows are grouped by combining keys with the next key, <code>d1</code> combined with <code>d2</code> make 6 rows (3 from <code>d1</code> and 3 from <code>d2</code>), then <code>d2</code> is combined with <code>d3</code> to make 6 more rows, etc. So for the 4 keys with 3 rows each, you get 3 combinations of 6 rows == 18 rows.</p></li>
</ul>
<p>I tried converting to a dataframe before concatenating:</p>
<pre><code>new_df = pd.DataFrame(list(D.values()), columns=['Time_sec', 'Temperature', 'Damage'])
</code></pre>
<p>but I am still stuck with concatenating part.</p>
<p><img alt="" src="https://i.stack.imgur.com/BnrN4.jpg"/></p>
<p>Sample expected output:</p>
<p><img alt="Expected output DataFrame" src="https://i.stack.imgur.com/iLda8.jpg"/></p>
</div>
<div class="post-text" itemprop="text">
<p>You want to <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> together each sublist for a given key, to form new rows with values from each sublist combined:</p>
<pre><code>&gt;&gt;&gt; list(zip(*D['d1']))
[('a1', 'a2', 'a3'), ('a1', 'a2', 'a3'), ('a1', 'a2', 'a3')]
</code></pre>
<p>then apply this to every value in the dictionary to produce a flattened sequence of rows, where you pick your pairings.</p>
<p>I'm assuming you want to pair up <code>dN</code> with <code>dN+1</code> here, regardless of the number of keys. Note that dictionaries are actually <em>unordered</em> (although Python 3.6 and up insertion order is preserved), so you may want to apply some sorting first:</p>
<pre><code>sorted_keys = sorted(D)
</code></pre>
<p>after which we can pair them up with <code>zip(sorted_keys, sorted_keys[1:])</code>:</p>
<pre><code>&gt;&gt;&gt; sorted_keys = sorted(D)
&gt;&gt;&gt; list(zip(sorted_keys, sorted_keys[1:]))
[('d1', 'd2'), ('d2', 'd3'), ('d3', 'd4')]
</code></pre>
<p>Use this sequence to pair up the rows and flatten the resulting key sequence, then the zipped rows:</p>
<pre><code>sorted_keys = sorted(D)
paired = (k for keys in zip(sorted_keys, sorted_keys[1:]) for k in keys)
df = pd.DataFrame(
    (row for k in paired for row in zip(*D[k])), 
    columns=['Time_sec', 'Temperature', 'Damage']
)
</code></pre>
<p>This produces:</p>
<pre><code>   Time_sec Temperature Damage
0        a1          a2     a3
1        a1          a2     a3
2        a1          a2     a3
3        b1          b2     b3
4        b1          b2     b3
5        b1          b2     b3
6        b1          b2     b3
7        b1          b2     b3
8        b1          b2     b3
9        c1          c2     c3
10       c1          c2     c3
11       c1          c2     c3
12       c1          c2     c3
13       c1          c2     c3
14       c1          c2     c3
15       d1          d2     d3
16       d1          d2     d3
17       d1          d2     d3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using enumerate</p>
<pre><code>l = ['Time', 'Temperature', 'Damage']
d2 = {}

for idx, item in enumerate(l):
    for k, v in d.items():
        if item not in d2:
            d2[item] = v[idx]
        else:
            d2[item] += v[idx]
</code></pre>
<blockquote>
<pre><code>{'Time': ['a1, a1, a1', 'b1, b1, b1', 'c1, c1, c1', 'd1, d1, d1'],
'Temperature': ['a2, a2, a2', 'b2, b2, b2', 'c2, c2, c2', 'd2, d2,
d2'], 'Damage': ['a3, a3, a3', 'b3, b3, b3', 'c3, c3, c3', 'd3, d3,
d3']}
</code></pre>
</blockquote>
<p>Using pseudo values</p>
<pre><code>a1, a2, a3  = 0, 'a', '!'
b1, b2, b3  = 0, 'a', '!'
c1, c2, c3  = 0, 'a', '!'
d1, d2, d3  = 0, 'a', '!'
</code></pre>
<blockquote>
<pre><code>{'Time': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 'Temperature': ['a',
'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a'], 'Damage':
['!', '!', '!', '!', '!', '!', '!', '!', '!', '!', '!', '!']}
</code></pre>
</blockquote>
</div>
<span class="comment-copy">So are those <code>a1</code>, <code>a2</code>, etc references actually floating point numbers?</span>
<span class="comment-copy">Could you edit the post to add an example of what output do you expect?</span>
<span class="comment-copy">Can you give us a small sample of the expected output?</span>
<span class="comment-copy">@MartijnPieters yes they are floating point numbers</span>
<span class="comment-copy">just seen that link</span>
<span class="comment-copy">well done, looks great</span>
<span class="comment-copy">Thanks for sugesstion but the dictionary keys are to be appended first then converted to dataframe. there is a difference between your output and my expected output as you can see my 'b' and 'c' values are repeated in the output</span>
<span class="comment-copy">@RaziurRahman: then your question is entirely unclear. How does the output in my answer differ from your screenshot?</span>
<span class="comment-copy">the key order should be d1 d2 d2 d3 d3 d4</span>
<span class="comment-copy">@RaziurRahman: that's not clear <i>at all</i>. By what rules are the keys repeating?</span>
<span class="comment-copy">No.. Please be see the expected output</span>
<span class="comment-copy">How about this ?</span>
<span class="comment-copy">I had to make your variables strings but you would do this without them being strings</span>
<span class="comment-copy">@RaziurRahman I saw you did not want that an undeleted, is this not suitable will take down if so</span>
