<div class="post-text" itemprop="text">
<p>I am working on a dataset where a columns is named as header. The value are as mentioned.</p>
<pre><code>df = pd.DataFrame(data={"location":["d端sseldorf, nordrhein-westfalen, germany",
                                    "durbanville , cape town, cape town , south africa"]})
</code></pre>
<p>I want to divide this column in <code>['city', 'state', 'country']</code>. Note the second row has duplicates.</p>
<p>I have tried the below but this does not deal with duplicates:</p>
<pre><code>location = df.location.str.split(', ', n=2, expand=True)

location.columns = ['city', 'state', 'country']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>unique_everseen</code> recipe available in the <code>itertools</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">docs</a>, which is also available in 3rd party libraries such as <a href="https://toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.unique" rel="nofollow noreferrer"><code>toolz.unique</code></a>.</p>
<p>The logic can be incorporated in a list comprehension which iterates <code>df['location']</code>. This is likely to be more efficient than Pandas string-based methods, which do not offer vectorised functionality.</p>
<pre><code>from toolz import unique

res = pd.DataFrame([list(unique(map(str.strip, i.split(',')))) for i in df['location']])

res.columns = ['city', 'state', 'country']

print(res)

          city                state       country
0   d端sseldorf  nordrhein-westfalen       germany
1  durbanville            cape town  south africa
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can limit yourself only with <code>pandas</code> to handle this problem:</p>
<pre><code>import pandas as pd

pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None) 

data_all=(['d端sseldorf', 'nordrhein-westfalen', 'germany', 'durbanville', 'cape town', 'south africa'])
dfe = [[], [], []]

i = 0
j = 1
k = 2

while i &lt; len(data_all):
  dfe[0].append(data_all[i])
  i += 3
while j &lt; len(data_all):
  dfe[1].append(data_all[j])
  j += 3
while k &lt; len(data_all):
  dfe[2].append(data_all[k])
  k += 3

d = {'city': dfe[0], 'state': dfe[1], 'country': dfe[2]}
df = pd.DataFrame(data=d)
print(df)
</code></pre>
<p>Result:</p>
<pre><code>          city                state       country
0   d端sseldorf  nordrhein-westfalen       germany
1  durbanville            cape town  south africa
</code></pre>
<p>But actually I did not understand why you want to use duplicates, if you only have 3 columns: city, state and country.</p>
</div>
<span class="comment-copy">What's your desired output? What have you tried?</span>
<span class="comment-copy"><code>location=df.location.str.split(', ', n=2, expand=True)</code> <code>location.columns=['city', 'state', 'country']</code></span>
<span class="comment-copy">but I am not able to deal with dupilcates</span>
