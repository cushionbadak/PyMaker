<div class="post-text" itemprop="text">
<p>My very simple example project contains:</p>
<pre><code>addtest/
  setup.py
  addtest/
    __init__.py
    __main__.py
    app.py
</code></pre>
<p>My <code>app.py</code> is just:</p>
<pre><code>def main():
    raise SystemExit("Command line entry point called.")
</code></pre>
<p>My <code>__main__.py</code> is just:</p>
<pre><code>from addtest.app import main
main()
</code></pre>
<p>My <code>setup.py</code> contains:</p>
<pre><code>from setuptools import setup, find_packages

setup(
    name='AddTest',
    version='1.0',
    packages=find_packages(),

    entry_points={
        'console_scripts': ['addtest = addtest.app:main']
    },
)
</code></pre>
<p>I would expect that running <code>python setup.py test</code> would do nothing, since no unit tests are written. However, running it in a clean virtualenv (Python 3.6.6 on Ubuntu 18.04.1) gives me:</p>
<pre><code>$ python setup.py test
running test
running egg_info
writing AddTest.egg-info/PKG-INFO
writing dependency_links to AddTest.egg-info/dependency_links.txt
writing entry points to AddTest.egg-info/entry_points.txt
writing top-level names to AddTest.egg-info/top_level.txt
reading manifest file 'AddTest.egg-info/SOURCES.txt'
writing manifest file 'AddTest.egg-info/SOURCES.txt'
running build_ext
Command line entry point called.
</code></pre>
<p>Note the <code>Command line entry point called.</code> which means it's invoking the console script it generates from my <code>__main__.py</code> (or maybe just calling <code>python -m addtest</code>).</p>
<p>Why is <code>setup.py</code> calling the console script when I want it to run tests? Further inspection of the script's execution shows that <code>sys.argv</code> is <code>['setup.py','test']</code> - why?</p>
</div>
<div class="post-text" itemprop="text">
<p>The test scanner in setuptools will look for tests in <strong>any</strong> <code>*.py</code> file found in your sub-directories, except for <code>__init__.py</code>. Yes, this includes <code>__main__.py</code>, it will call <code>__import__()</code> on it, causing its main suite to be executed.</p>
<p>If you want to be able to run <code>python -m addtest</code> and have that run your <code>__main__.py</code> code, you may want to add the standard 'run only if this is really main' protection:</p>
<pre><code>if __name__ == "__main__":
   ...
</code></pre>
<p>(then, if you do <code>python -m</code> the code will run, but it won't run if the file is loaded by <code>setup.py test</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html" rel="nofollow noreferrer">setuptools docs</a> explains how setuptools scans for unit tests by default.</p>
<p>Since, as you say, no unit tests are written or specified, <code>setuptools</code> can be using default behavior.</p>
<p>A couple references from the <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html" rel="nofollow noreferrer">setuptools docs</a> that elaborates on this as well as specifies how to set up test suites are below:</p>
<ol>
<li><blockquote>
<p><code>test_loader</code> If you would like to use a
  different way of finding tests to run than what setuptools normally
  uses, you can specify a module name and class name in this argument.
  <br/>...<br/>
  The module name and class name must be separated by a :. The default value of this argument is <code>"setuptools.command.test:ScanningLoader"</code>. If you want to use the default unittest behavior, you can specify <code>"unittest:TestLoader"</code> as your <code>test_loader</code> argument instead. <strong><em>This will prevent automatic scanning of submodules and subpackages.</em></strong></p>
</blockquote></li>
<li><blockquote>
<p>... <code>test_suite</code> A string naming a <code>unittest.TestCase</code> subclass (or a package
  or module containing one or more of them, or a method of such a
  subclass), or naming a function that can be called with no arguments
  and returns a <code>unittest.TestSuite</code>. <br/><br/>If the named suite is a module, and
  the module has an <code>additional_tests()</code> function, it is called and the
  results are added to the tests to be run. If the named suite is a
  package, any submodules and subpackages are recursively added to the
  overall test suite.</p>
<p><strong>Specifying this argument enables use of the <code>test</code> command</strong> to run the
  specified test suite, e.g. via <strong><code>setup.py test</code></strong>. See the section on the
  <code>test</code> command below for more details.
  <br/>...<br/></p>
<pre><code>     setup(
     # ...
     test_suite="my_package.tests.test_all"
 )</code></pre>
</blockquote></li>
</ol>
<p>This, in conjunction with <a href="https://stackoverflow.com/a/52550011/3544399">another answer</a> on this thread leaves you with at least a couple of options to ensure that <code>python setup.py test</code> doesn't run the console script:</p>
<ol>
<li>Configure how <code>setuptools</code> looks for test suites.</li>
<li>Add <code>if __name__ == "__main__":</code> around <code>main()</code></li>
</ol>
<p>Yet another option may be given by the unit testing library you're using. For example, <a href="https://docs.pytest.org/en/latest/" rel="nofollow noreferrer">Pytest</a> has an <a href="https://docs.pytest.org/en/latest/goodpractices.html#integrating-with-setuptools-python-setup-py-test-pytest-runner" rel="nofollow noreferrer">integration guide for <code>setuptools</code></a> that replaces the <code>test</code> command with its own.</p>
<p><br/>
<strong>Regarding the sysargs</strong></p>
<p><code>sys.argv</code> is <code>['setup.py','test']</code> because you invoked <code>python</code> with the args <code>setup.py test</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I think you have to specify the entry point for test in your setup.py. Otherwise it passes it to the main.py.</p>
</div>
<span class="comment-copy">Regarding <code>sys.argv</code> <code>sys.argv[0]</code> gives the name of the script being called, and argv provides a list of all the arguments passed to the script so <code>python setup.py test</code> gives you <code>['setup.py', 'test']</code>. <a href="https://docs.python.org/3/library/sys.html#sys.argv" rel="nofollow noreferrer">docs.python.org/3/library/sys.html#sys.argv</a></span>
<span class="comment-copy">UV'd and referenced in my answer. üëçüèº</span>
<span class="comment-copy">Can you elaborate on "you haven't defined <code>test()</code>"? I'm struggling to find anything resembling this in the Setuptools docs. I was planning to use Py.test rather than the unittest module, and I think they have some configuration tips for this scenario.</span>
<span class="comment-copy">@detly typo, sorry.  I meant you hadn't defined <code>additional_tests()</code> - but I was looking at your question as I wrote it.  Editing answer now with the additional reference</span>
<span class="comment-copy">Thanks for the clarification. Re. sysargs confusion: for some reason I figured the "main" script had been invoked as a subprocess, I couldn't figure out why else <code>main()</code> would be called. Now I see that it was imported, which ran the unguarded <code>main()</code> and, as you say, sysargs is trivially going to be what it is.</span>
<span class="comment-copy">Hope you don't mind, I added a third option that is what I actually went with. However, I'm using Pytest, which I didn't mention in the question ‚Äî so it may not be applicable to everyone who reads this, but I expect it might help a lot of folk who are wondering the same thing.</span>
