<div class="post-text" itemprop="text">
<p>In Python documentation for typing &amp; type hints we have the below <a href="https://docs.python.org/3/library/typing.html#type-aliases" rel="nofollow noreferrer">example</a>:</p>
<pre><code>Vector = List[float]

def scale(scalar: float, vector: Vector) -&gt; Vector:
    return [scalar * num for num in vector]
</code></pre>
<p><code>Vector</code> type alias clearly shows that type aliases are useful for simplifying complex type signatures.</p>
<p><strong>However, what about aliasing primitive data types?</strong></p>
<p>Let's contrast two basic examples of function signatures:</p>
<pre><code>URL = str    

def process_url(url: URL) -&gt; URL:
    pass
</code></pre>
<p>vs. </p>
<pre><code>def process_url(url: str) -&gt; str:
    pass
</code></pre>
<p>Version with type alias <code>URL</code> for primitive type <code>str</code> is:</p>
<ul>
<li>self-documenting (among others, now I can skip documenting returned value, as it should be clearly an url),</li>
<li>resistant to type implementation change (I can switch URL to be <code>Dict</code> or <code>namedtuple</code> later on without changing functions signatures).</li>
</ul>
<p>The problem is I cannot find anyone else following such practice. I am simply afraid that I am unintentionally abusing type hints to implement my own ideas instead of following their intended purpose.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using an alias to mark the meaning of a value can be misleading and dangerous. A <a href="https://docs.python.org/3/library/typing.html#newtype" rel="nofollow noreferrer">NewType</a> should be used instead.</p>
<blockquote>
<p>Recall that the use of a type alias declares two types to be equivalent to one another. Doing <code>Alias = Original</code> will make the static type checker treat <code>Alias</code> as being <strong>exactly equivalent</strong> to <code>Original</code> <strong>in all cases</strong>. This is useful when you want to simplify complex type signatures.</p>
</blockquote>
<p>Simple aliasing works both ways. A <code>List[float]</code> is a <code>vector</code>, and a <code>str</code> is a <code>URL</code> â€“ except that it is not. A URL is a special kind of <code>str</code> and not any can take its place. An alias is a too strong statement of equality, as it cannot express this distinction. In fact, any inspection that does not look at the source code does not see the distinction:</p>
<pre><code>In [1]: def foo(bar: URL):
   ...:     pass
   ...:
In [2]: foo?
Signature: foo(bar: str)
</code></pre>
<p>Consider that you alias <code>Celsius = float</code> in one module, and <code>Fahrenheit = float</code> in another. This signals that it is valid to use <code>Celsius</code> as <code>Fahrenheit</code>, which is wrong.</p>
<p>Unless your types <em>do</em> cary separative meaning, you should just take a <code>url: str</code>. The name signifies the meaning, the type the valid values. That means that your type should be suitable to separate valid and invalid values!</p>
<p>Use aliases to <em>shorten</em> your hints, but use NewType to <em>refine</em> them.</p>
<pre><code>Vector = List[float]        # alias shortens
URL = NewType("URL", str)   # new type separates
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure if this question is opinion based, but I have a feeling the general agreement would be <strong>this is a good idea, in general</strong>. You state the benefits yourself, not to mention the ability to generalize code etc.</p>
<p>I would venture this is not common practice in Python as the language itself is not very restrictive. In addition, the variable is already called <code>url</code> - that is pretty self explanatory. You could argue you might have something called <code>json_response</code> or the like, and you expect it to be a <code>url</code>, and your method would certainly make it clear, but since Python encourages duck typing, the code usage often gives this hint anyway, and using type aliasing will be just extra safety for an inconsiderate user. It really goes down just to common practices, with no good "do that!" explanation.</p>
<p>Final point - type aliasing, in a sense, is the most primitive version of object oriented programming. You are making it clear what properties you are expecting of this object, in this case the string should be a valid URL.</p>
</div>
<div class="post-text" itemprop="text">
<p>I guess the question one could ask oneself is "the purpose".</p>
<p>I strongly believe in Python's readability is all that matters. 
With this in mind type hinting, even for primitives is quite OK. Even better if type is masked by virtual "enum"-like type that does some self documenting. </p>
<p>That being said - personally I'd go with the first:
URL = str<br/>
def process_url(url: URL) -&gt; URL:
    pass</p>
</div>
<span class="comment-copy">No, in some programming languages like Haskell, type aliasses are even very common: if you later change your mind about the <code>URL</code> type, then you can simply change it, and all type checking will change. In Python, I occasionally see a class that is defined with two identifiers.</span>
<span class="comment-copy">Note that the signature of <code>process_url</code> will be the same in either case! Only the source code shows the alias; any usage has no idea which name was used to refer to the basic type. Even in the first case, the actual signature is just <code>process_url(url: str) -&gt; str</code>.</span>
<span class="comment-copy">Well, naturally. We are clearly allowed to pass a wrong type here. On the other hand, Python is dynamically typed language. There is no reasonable way to enforce static typing. That is why the question is about type hints/type annotations, which are rather a helpful tool than Python's paradigm changer. Still, thanks for suggesting NewType. Wasn't aware of this!</span>
<span class="comment-copy">Precisely because Python supports duck typing, type hints should be as meaningful as possible. If any <code>str</code> may be valid, there is nothing wrong in saying so! By not using the base type some special rules are implied, which can be misleading when not actually defined - even if the rule is just "values from a function providing <code>URL</code>s".</span>
<span class="comment-copy">@CapedHero -- you can enforce the static types by using tools like mypy -- it's configurable so you can completely forbid all dynamic typing if you so wish. Anyways, in this case, I agree it's correct to use NewType here -- that way, the type checker can enforce the constraint that not all strings are URLs.</span>
