<div class="post-text" itemprop="text">
<p>Currently I have a list of items someone can buy as follows:</p>
<pre><code>my_list = [
    ('Candy', 1.0, 20.5),
    ('Soda', 3.0, 10.25),
    ('Coffee', 1.2, 20.335),
    ('Soap', 1.2, 11.5),
    ('Spoon', 0.2, 2.32),
    ('Toast', 3.2, 12.335),
    ('Toothpaste', 3, 20.5),
    ('Creamer', .1, 5.5),
    ('Sugar', 2.2, 5.2),
]
</code></pre>
<p>Each item is set up like this: </p>
<pre><code>('Item Name', ItemCost, ItemValue)
</code></pre>
<p>I have the list pulling the items with the top 5 <code>ItemValue</code>.</p>
<pre><code>print nlargest(5, my_list, key=itemgetter(2))
&gt;&gt;&gt; [
        ('Candy', 1.0, 20.5),
        ('Toothpaste', 3, 20.5),
        ('Coffee', 1.2, 20.335),
        ('Toast', 3.2, 12.335),
        ('Soap', 1.2, 11.5),
    ]
</code></pre>
<p>I am trying to retrieve a result where I get the top 5 total <code>ItemValue</code> where the top 5 total <code>ItemCost</code> is equal or less than 6.</p>
<p>Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can filter first, and use all following <code>nlargest</code> on your filtered list.</p>
<pre><code>f = [(a,b,c) for (a,b,c) in my_list if b &lt;= 6]
</code></pre>
<p>But for data manipulation like this, <code>pandas</code> can be very useful. Take, for example</p>
<pre><code>df = pd.DataFrame(my_list, columns=('ItemName', 'ItemCost', 'ItemValue'))

    ItemName    ItemCost    ItemValue
0   Candy       1.0         20.500
1   Soda        3.0         10.250
2   Coffee      1.2         20.335
3   Soap        1.2         11.500
4   Spoon       0.2         2.320
5   Toast       3.2         12.335
6   Toothpaste  3.0         20.500
7   Creamer     0.1         5.500
8   Sugar       2.2         5.200

&gt;&gt;&gt; df[df.ItemCost &lt;= 6]

    ItemName    ItemCost    ItemValue
0   Candy       1.0         20.500
1   Soda        3.0         10.250
2   Coffee      1.2         20.335
3   Soap        1.2         11.500
4   Spoon       0.2         2.320
5   Toast       3.2         12.335
6   Toothpaste  3.0         20.500
7   Creamer     0.1         5.500
8   Sugar       2.2         5.200

&gt;&gt;&gt; df[df.ItemCost &lt;= 6].nlargest(n=5, columns=['ItemValue'])


    ItemName    ItemCost    ItemValue
0   Candy       1.0         20.500
6   Toothpaste  3.0         20.500
2   Coffee      1.2         20.335
5   Toast       3.2         12.335
3   Soap        1.2         11.500
</code></pre>
<hr/>
<p>If you want, you can first get the <code>nsmallest</code> of the <code>ItemCost</code> and <em>just then</em> get the <code>nlargest</code></p>
<pre><code>df.nsmallest(n=5, columns=['ItemCost']).nlargest(n=5, columns=['ItemValue'])    

    ItemName    ItemCost    ItemValue
0   Candy       1.0         20.500
2   Coffee      1.2         20.335
3   Soap        1.2         11.500
7   Creamer     0.1         5.500
4   Spoon       0.2         2.320
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if this is what you asking, </p>
<p>I would first create all possible combinations of 5 elements from my_list</p>
<pre><code>itertools.combinations(my_list, 5)
</code></pre>
<p>Then i would find all possible combinations in result where total item cost would be less than or equal to 6.</p>
<pre><code>f = [element for element in itertools.combinations(my_list, 5) if  sum([e[1] for e in element]) &lt;=6]
</code></pre>
<p>Now, I would find that element where total itemValue is the greatest</p>
<pre><code>h = [sum([g[2] for g in e]) for e in f]
</code></pre>
<p>The index of element with maximum itemValue is</p>
<pre><code>index = h.index(max(h))
</code></pre>
<p>Now, you can find that element in f.</p>
<pre><code>f[index]
</code></pre>
<p>The answer i got is </p>
<pre><code> Candy        1.0  20.5
 Coffee       1.2  20.335
 Spoon        0.2  2.32
 Toothpaste   3    20.5
 Creamer      0.1  5.5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First you want to filter the list by the <code>ItemCost</code>:</p>
<ul>
<li><p>Which can be done by: <code>filtered_generator = filter(lambda x: x[1] &lt;= 6, my_list)</code></p></li>
<li><p>Or in a more python-like way <code>filtered_list = [x for x in my_list if x[1] &lt;=6]</code></p></li>
<li><p>And to keep it a generator to save memory just use parentheses instead of the square brackets.</p></li>
</ul>
<p>Then you want to get the n largest items:</p>
<ul>
<li>You can use <a href="https://docs.python.org/3/library/heapq.html#heapq.nlargest" rel="nofollow noreferrer">heapq.nlargest</a>: <code>nlargest(5, filtered_iter, key=lambda x:x[2])</code></li>
<li>or implement similar function yourself.</li>
</ul>
<p><code>filtered_iter</code> can be the list or one of the generators.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from operator import itemgetter
from itertools import combinations
from beautifultable import BeautifulTable

def pretty_print( lst):
    table = BeautifulTable()
    table.column_headers = ['Item Name','ItemCost','ItemValue']
    if lst:
        for item_specs in lst:
            table.append_row(item_specs)
        print(table)


def get_total_cost( lst):
    return sum(item_specs[1] for item_specs in lst)

def get_total_Value( lst):
    return sum(item_specs[2] for item_specs in lst)



def best_comb( item_list, number_of_items_to_pick, cost_constraint):


    k = number_of_items_to_pick

    item_list.sort(key=itemgetter(2), reverse=True) # sorting list by ItemValue

    k_top_value_item_lst = item_list[:5] # picking top k items from list

    total_cost = get_total_cost(k_top_value_item_lst)


    def generateCombinations( take_default_val_for_best_result = True):
        k_len_combination_list = list(combinations( item_list, k))

        if take_default_val_for_best_result:
            best_result = []# which meets total itemCost &lt;= 6 condition and have highest total of ItemValue 
            best_result_sum = [0,0] # ItemCost, ItemValue    
        else:
            best_result = k_top_value_item_lst
            best_result_sum = [total_cost, get_total_Value(best_result)]


        best_alternative_lst = [] # if there are any other combination which offer same Value for Cost

        # ignore first comb as its been already suggested to user
        for comb in k_len_combination_list:

            temp_sum = [None,None]
            temp_sum[0] = get_total_cost( comb)
            reset_best = False

            if  temp_sum[0] &lt;= cost_constraint:
                temp_sum[1] = get_total_Value( comb)

                if best_result_sum[1] &lt; temp_sum[1]:
                    reset_best = True

                elif best_result_sum[1] == temp_sum[1]:
                    if temp_sum[0] &lt; best_result_sum[0]:
                        reset_best = True
                    elif temp_sum[0] == best_result_sum[0]:
                        # since ItemValue as well as ItemCost are equivalent to best_result this comb is great alternative
                        if comb != tuple(best_result):
                            best_alternative_lst.append(comb)

                if reset_best:
                    best_result = comb
                    best_result_sum[1] = temp_sum[1]
                    best_result_sum[0] = temp_sum[0]

        print('Best Combination:')
        if best_result:
            pretty_print(best_result)
        else:
            print('not found')

        if gen_alternative:
            print('\nBest Alternative Combination:')
            if best_alternative_lst:
                for idx,alter_comb in enumerate( best_alternative_lst):
                    comb_id = idx+1
                    print('combination_id ',comb_id)
                    pretty_print(alter_comb)
            else:
                print('not found')


    if total_cost &gt; cost_constraint:
        generateCombinations()

    else:
        if gen_alternative:
            generateCombinations(take_default_val_for_best_result = False)

        else:
            print('Best Combination:')
            pretty_print(k_top_value_item_lst)



my_list = [
    ('Candy', 2.0, 20.5),
    ('Soda', 1.5, 25.7 ), 
    ('Coffee', 2.4, 25.7 ),
    ('Soap', 1.2,20),
    ('Spoon',1.2,20 ), 
    ('Toast',1.2,22 ),
    ('Toothpaste',0.8, 20 ), 
    ('Creamer',0.8, 22),
    ('Sugar',2.0, 20.5 ),
]

gen_alternative = input('do you want to generate alternative combinations: y/n ')[0].lower() == 'y'

best_comb( my_list, 5, 6)
</code></pre>
<p>Answer to modified list ( to show extra feature)</p>
<pre><code>do you want to generate alternative combinations: y/n Y
Best Combination:
+------------+----------+-----------+
| Item Name  | ItemCost | ItemValue |
+------------+----------+-----------+
|    Soda    |   1.5    |   25.7    |
+------------+----------+-----------+
|   Toast    |   1.2    |    22     |
+------------+----------+-----------+
|  Creamer   |   0.8    |    22     |
+------------+----------+-----------+
|    Soap    |   1.2    |    20     |
+------------+----------+-----------+
| Toothpaste |   0.8    |    20     |
+------------+----------+-----------+

Best Alternative Combination:
combination_id  1
+------------+----------+-----------+
| Item Name  | ItemCost | ItemValue |
+------------+----------+-----------+
|    Soda    |   1.5    |   25.7    |
+------------+----------+-----------+
|   Toast    |   1.2    |    22     |
+------------+----------+-----------+
|  Creamer   |   0.8    |    22     |
+------------+----------+-----------+
|   Spoon    |   1.2    |    20     | &lt;---
+------------+----------+-----------+
| Toothpaste |   0.8    |    20     |
+------------+----------+-----------+      
</code></pre>
<p>Answer to your original list</p>
<pre><code>Best Combination:
+------------+----------+-----------+
| Item Name  | ItemCost | ItemValue |
+------------+----------+-----------+
|   Candy    |   1.0    |   20.5    |
+------------+----------+-----------+
| Toothpaste |    3     |   20.5    |
+------------+----------+-----------+
|   Coffee   |   1.2    |  20.335   |
+------------+----------+-----------+
|  Creamer   |   0.1    |    5.5    |
+------------+----------+-----------+
|   Spoon    |   0.2    |   2.32    |
+------------+----------+-----------+

Best Alternative Combination:
not found
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not totally sure of what you are trying to do, but...<br/>
If you are trying to retrieve the top x (5 or 6) based on <code>itemcost</code> sorted by lowest cost, you can try this.</p>
<pre><code>x=5
sorted(my_list, key=lambda s : s[2])[:x]

This outputs the following:

[('Spoon', 0.2, 2.32),
('Sugar', 2.2, 5.2),
('Creamer', 0.1, 5.5),
('Soda', 3.0, 10.25),
('Soap', 1.2, 11.5)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import combinations

...

total_cost = lambda item: int(sum(c for _, c, _ in item) &lt;= 6) * sum(v for _, _ , v in item)
chosen = max(combinations(my_list, 5), key=total_cost)
</code></pre>
<p>Max can receive a function to specify max criteria.</p>
<p>The total_cost function, has a int(sum(c for _, c, _ in item) &lt;= 6) portion that is 1 if total cost of the combination is less or equal then 6, and its 0 otherwise.</p>
<p>We then multiply this portion with the total sum of values.</p>
<p>combinations(my_list, 5) retrieves all possible combinations of my_list items having 5 items.</p>
<p>Printing chosen elements you have:</p>
<pre><code>('Candy', 1.0, 20.5)
('Coffee', 1.2, 20.335)
('Spoon', 0.2, 2.32)
('Toothpaste', 3, 20.5)
('Creamer', 0.1, 5.5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Filter the list first:</p>
<p><code>print nlargest(5, [item for item in my_list if item[1]&lt;=6], key=itemgetter(2))</code></p>
<p>You can do it with sorted too:</p>
<p><code>sorted([item for item in my_list if item[1]&lt;=6], key=lambda x: x[1], reverse=True)[:5]</code></p>
<p>The above filters out items with <em>ItemCost</em> greater than 6, sorts your list descending based on <em>ItemCost</em>, and then returns the first 5 element</p>
</div>
<div class="post-text" itemprop="text">
<p>First using <code>combinations</code> we can get all possible combinations of 5 from <code>my_list</code>. From here we can use <code>filter</code> and only return combinations whose total <code>ItemCost</code> is less than or equal to <code>6</code>.  Finally we sort by the which group has the highest total <code>ItemValue</code> and we take the greatest one being <code>l2[-1]</code> we could use <code>reverse = True</code> and then it would be <code>l2[0]</code></p>
<p>from itertools import combinations   </p>
<pre><code>l = list(combinations(my_list, 5))
l1 = list(filter(lambda x: sum([i[1] for i in x]) &lt; 6, l))
l2 = sorted(l1, key=lambda x: sum([i[2] for i in x]))
print(l2[-1])
</code></pre>
<blockquote>
<pre><code>(('Candy', 1.0, 20.5), ('Coffee', 1.2, 20.335), ('Spoon', 0.2, 2.32), ('Toothpaste', 3, 20.5), ('Creamer', 0.1, 5.5))
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import combinations
from functools import reduce

def get_valid_combs(lis):
    "find all combinations that cost less than or equal to 6"

    for i in combinations(lis, 5):
        if reduce(lambda acc, x: acc + x[1], list(i), 0) &lt;= 6:
            yield list(i)

my_list = [
    ('Candy', 1.0, 20.5),
    ('Soda', 3.0, 10.25),
    ('Coffee', 1.2, 20.335),
    ('Soap', 1.2, 11.5),
    ('Spoon', 0.2, 2.32),
    ('Toast', 3.2, 12.335),
    ('Toothpaste', 3, 20.5),
    ('Creamer', .1, 5.5),
    ('Sugar', 2.2, 5.2),
]

# find all valid combinations which  cost less than 6
valid_combinations = [i for i in get_valid_combs(my_list)]

#top_combinations_sorted = sorted(valid_combinations, key=lambda y: reduce(lambda acc, x: acc + x[2], [0]+y))

# of the valid combinations get the combination with highest total value
best_combination = max(valid_combinations, key=lambda y: reduce(lambda acc, x: acc + x[2], y, 0))

print(best_combination)
</code></pre>
<p>output:</p>
<pre><code>[('Candy', 1.0, 20.5), ('Coffee', 1.2, 20.335), ('Spoon', 0.2, 2.32), ('Toothpaste', 3, 20.5), ('Creamer', 0.1, 5.5)]
</code></pre>
</div>
<span class="comment-copy">Just add a filter stage before you call <code>nlargest</code>.</span>
<span class="comment-copy">I answered the question but now reading the post again I think I maybe get it wrong. When do you say "the top 5 total ItemCost" with total you mean it sum?</span>
<span class="comment-copy">@PaulRooney if you read the <code>total item cost</code> must be equal to or less than 6, simply filtering wont account for that, you need to have a combination of 5 that has a total less than or equal to <code>6</code></span>
<span class="comment-copy">@vash_the_stampede the question isn't very clear. <code>where the top 5 total ItemCost is equal or less than 6.</code> doesnt make sense to me anyway.</span>
<span class="comment-copy">The op could clarify his question by providing a sample output.</span>
<span class="comment-copy">I'm assuming that the top 5 items item cost combined must be equal to or less than 6</span>
<span class="comment-copy">your total item cost would be 9.4</span>
<span class="comment-copy">This is right now, you win</span>
<span class="comment-copy">@PaulRooney Well Paul, if the <code>nsmallest</code> summed are still greater than <code>6</code>, then there is no solution for the problem. If there are other solutions beyond those of the <code>nsmallest</code>, then I assumed they do not matter since the total cost is not the optimal one (they will be greater than or equal the <code>nsmallest</code> solution)</span>
<span class="comment-copy">@RafaelC the only thing I wonder is if we substitute <code>soda</code> for <code>toothpaste</code> we would still be under <code>6</code> with a greater total item value, OP would have to confirm if this is desired</span>
