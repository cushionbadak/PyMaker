<div class="post-text" itemprop="text">
<p>I have a list with small and big numbers like this:</p>
<pre><code>[234, 454, 123444, 123, 234, 122234, 234, 354, 654, 123231, 234, 342, 1231231]
</code></pre>
<p>The "big numbers" are at least 10 times bigger than the smaller numbers. In total, there are 4 "big numbers" in the list: <code>123444</code>, <code>122234</code>, <code>123231</code> and <code>1231231</code>.</p>
<p>I want to find the indices of the 3rd and 4th "big numbers":</p>
<p><code>values: 234 454 123444 123 234 122234 234 354 654 <strong>123231</strong> 234 342 <strong>1231231</strong>
indices: 0   1   2      3   4   5      6   7   8   <strong>9</strong>      10  11  <strong>12</strong>
</code></p>
<p>As you can see, the 3rd "big number" has the index 9, and the 4th "big number" has the index 12. Therefore the output should be <code>9</code> and <code>12</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sorting is no good here since if a larger value long appears before a smaller value long, then the order is destroyed, as it does in this example(<code>123444 &gt; 123231</code>). Instead using <code>enumerate</code> find items that are greater that 10x of the value of other items  and append their index to a new list in the order of their appearance and then grab the 3rd and 4th items of the new list containing indexes </p>
<pre><code>longs = []
j = min(l)

for idx, item in enumerate(l):
    if item/10 &gt; j:
        longs.append(idx)

print(*longs[2:])
</code></pre>
<p>Or <em>list comprehension</em></p>
<pre><code>longs = [idx for idx, item in enumerate(l) if item/10 &gt; j]
</code></pre>
<blockquote>
<pre><code>9 12
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>One way to achieve this would be to find the inflection point in the values in the list. This can be done by using a threshold factor for the same. </p>
<p>For example:</p>
<pre><code>def inflection_index(a, threshold=10):
    a.sort()

    current = 0
    for next in range(1, len(a)):
        if a[next] &gt;= threshold * a[current]:
            return i
        current += 1

    return None
</code></pre>
<p>More sophisticated methods include finding where the concavity of a curve changes according to the derivative. You can find out more about that <a href="https://stackoverflow.com/questions/20044096/derivative-of-an-array-in-python">here</a>, <a href="https://stackoverflow.com/questions/20618804/how-to-smooth-a-curve-in-the-right-way">here</a> and <a href="https://stackoverflow.com/questions/28092394/find-inflection-and-stationary-points-in-a-numpy-1d-array">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could achieve it by <strong>sorting</strong> the list and then using <strong>reverse slice of index</strong> to find the index of largest values:</p>
<pre><code>num = [234, 454, 123444, 123, 234, 122234, 234, 354, 654, 123231, 234, 342, 1231231]

temp = sorted(num)

for i in temp[::-1][:2]:
    print("Index of", i, "is:", num.index(i))
</code></pre>
<p><strong>Result:</strong></p>
<pre><code>Index of 1231231 is: 12
Index of 123444 is: 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>list = [234, 454, 123444, 123, 234, 122234, 234, 354, 654, 123231, 234, 342, 1231231]
print (list)
list.sort()
print (list)
my_len = len(list)
print (my_len)
print ("The longest ones are at the end")
print (list[my_len-1])
print (list[my_len-2])
# output
# [234, 454, 123444, 123, 234, 122234, 234, 354, 654, 123231, 234, 342, 1231231]
# [123, 234, 234, 234, 234, 342, 354, 454, 654, 122234, 123231, 123444, 1231231]
# 13
# The longest ones are at the end
# 1231231
# 123444

# Ok how about this 

list = [234, 454, 123444, 123, 234, 122234, 234, 354, 654, 123231, 234, 342, 1231231]
print (list)
my_new_list = []
for idx, val in enumerate(list):
    print(idx, val)
    my_new_list.append((idx,val))
    print(my_new_list)
# output
#[234, 454, 123444, 123, 234, 122234, 234, 354, 654, 123231, 234, 
#342, 1231231]
#0 234
#1 454
#2 123444
#3 123
#4 234
#5 122234
#6 234
#7 354
#8 654
#9 123231
#10 234
#11 342
#12 1231231
#[(0, 234), (1, 454), (2, 123444), (3, 123), (4, 234), (5, 122234), 
#(6, 234), (7, 354), (8, 654), (9, 123231), (10, 234), (11, 342), 
#(12, 1231231)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can sort the elements first. Then for each of the largest elements find its index in the original list.
Your should look like this:</p>
<pre><code>original_list = [...]
sorted_list = original_list.sort()
1st_largest_index = original_list.index(sorted_list[-1])
2nd_largest_index = original_list.index(sorted_list[-2])
</code></pre>
</div>
<span class="comment-copy">Check <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer">docs.python.org/3/tutorial/datastructures.html#more-on-lists</a>. (<code>index()</code> method)</span>
<span class="comment-copy">Do you want the bigger values or indexes?</span>
<span class="comment-copy">@YashGhorpade their indexes. I think I have some good questions there already (including yours!) so thanks a lot!</span>
<span class="comment-copy"><code>sort</code> is no good here, if your answer is <code>sort</code>, its incorrect</span>
<span class="comment-copy">@CristiFati indexing is not the problem, the problem is getting the proper item to index of a long sample without destroying its order in the original list as being demonstrated repeatedly via <code>sort</code></span>
<span class="comment-copy">Your indexes should be 9 and 12</span>
<span class="comment-copy">Dude everyone is sorting because the question isn't clear. It doesn't justify the requirements properly. Nobody has an idea what does a long sample mean!</span>
<span class="comment-copy">She has mentioned THE FIRST BIG VALUE and so on, what does big value value mean?</span>
<span class="comment-copy">sorting re arranges the order of the longs in the original list as well</span>
<span class="comment-copy">Yes, the longs are now find-able i was under the impression that was the goal here. I guess not.</span>
