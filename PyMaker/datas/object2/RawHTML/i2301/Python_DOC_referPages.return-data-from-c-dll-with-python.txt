<div class="post-text" itemprop="text">
<p>IÂ´m programig a interface with 3M document scanners.</p>
<p>I try to call a function called <code>MMMReader_GetData</code></p>
<p><code>MMMReaderErrorCode MMMReader_GetData(MMMReaderDataType aDataType,void* DataPtr,int* aDataLen);</code></p>
<p>Description:
After a data item has been read from a document it may be obtained via this API.<br/>
The buffer supplied in the aDataPtr parameter will be written to with the data, and aDataLen updated to be the
length of the data.</p>
<p>The problem is how can create a <code>void* DataPrt</code> and how can get it the data.</p>
<p>I try:</p>
<pre><code>from ctypes import *
lib=cdll.LoadLibrary('MMMReaderHighLevelAPI.dll')
CD_CODELINE = 0
aDataLen = c_int()
aDataPtr = c_void_p()
index= c_int(0)

r = lib.MMMReader_GetData(CD_CODELINE,byref(aDataPtr),byref(aDataLen),index)
</code></pre>
<p><code>aDataLen</code> always return a value but <code>aDataPtr</code> return <code>None</code></p>
<p>TIA</p>
</div>
<div class="post-text" itemprop="text">
<p>What you need to do is allocate a "buffer". The address of the buffer will be passed as the void* parameter, and the size of the buffer in bytes will be passed as the <code>aDataLen</code> parameter. Then the function will put its data in the buffer you gave it, and then you can read the data back out of the buffer.</p>
<p>In C or C++ you would use <code>malloc</code> or something similar to create a buffer. When using <code>ctypes</code>, you can use <a href="https://docs.python.org/3/library/ctypes.html?highlight=create_string_buffer#ctypes.create_string_buffer" rel="nofollow noreferrer">ctypes.create_string_buffer</a> to make a buffer of a certain length, and then pass the buffer and the length to the function. Then once the function fills it in, you can read the data out of the buffer you created, which works like a list of characters with <code>[]</code> and <code>len()</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>With <code>ctypes</code>, it is best to define the argument types and return value for better error checking, and declaring pointer types is especially important on 64-bit systems.</p>
<pre><code>from ctypes import *

MMMReaderErrorCode = c_int  # Set to an appropriate type
MMMReaderDataType = c_int   # ditto...

lib = CDLL('MMMReaderHighLevelAPI')
lib.MMMReader_GetData.argtypes = MMMReaderDataType,c_void_p,POINTER(c_int)
lib.MMMReader_GetData.restype = MMMReaderErrorCode

CD_CODELINE = 0

# Make sure to pass in the original buffer size.
# Assumption: the API should update it on return with the actual size used (or needed)
# and will probably return an error code if the buffer is not large enough.
aDataLen = c_int(256)

# Allocate a writable buffer of the correct size.
aDataPtr = create_string_buffer(aDataLen.value)

# aDataPtr is already a pointer, so no need to pass it by reference,
# but aDataLen is a reference so the value can be updated.
r = lib.MMMReader_GetData(CD_CODELINE,aDataPtr,byref(aDataLen))
</code></pre>
<p>On return you can access just the returned portion of the buffer by string slicing, e.g.:</p>
<pre><code>&gt;&gt;&gt; from ctypes import *
&gt;&gt;&gt; aDataLen = c_int(10)
&gt;&gt;&gt; aDataPtr = create_string_buffer(aDataLen.value)
&gt;&gt;&gt; aDataPtr.raw
'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
&gt;&gt;&gt; aDataLen.value = 5        # Value gets updated
&gt;&gt;&gt; aDataPtr[:aDataLen.value] # Get the valid portion of buffer
'\x00\x00\x00\x00\x00'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are several issues with your code: </p>
<ol>
<li>You need to allocate the buffer pointed to by <code>aDataPtr</code>.</li>
<li>You need to pass the buffer length in <code>aDataLen</code>. According to [1], if the buffer isn't big enough, <code>MMMReader_GetData</code> will reallocate it as needed.</li>
<li>You should pass <code>aDataPtr</code> directly, not <code>byref</code>.</li>
<li>You are passing an extra argument to the method (the <code>index</code> argument) based on the method descriptor of <code>MMMReader_GetData</code> you provided.</li>
</ol>
<p>Try the following: </p>
<pre><code>import ctypes

lib = ctypes.cdll.LoadLibrary('MMMReaderHighLevelAPI.dll')

CD_CODELINE = 0
aDataLen = ctypes.c_int(1024)
aDataPtr = ctypes.create_string_buffer(aDataLen.value)

err = lib.MMMReader_GetData(CD_CODELINE, aDataPtr, ctype.byref(aDataLen))
</code></pre>
<p>Then you can read the content of the buffer as a regular character array. The actual length is returned back for you in <code>aDataLen</code>.</p>
<p>[1] 3M Page Reader Programmers' Guide: <a href="https://wenku.baidu.com/view/1a16b6d97f1922791688e80b.html" rel="nofollow noreferrer">https://wenku.baidu.com/view/1a16b6d97f1922791688e80b.html</a></p>
</div>
