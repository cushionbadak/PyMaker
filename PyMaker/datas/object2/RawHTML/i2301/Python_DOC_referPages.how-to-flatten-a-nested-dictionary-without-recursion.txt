<div class="post-text" itemprop="text">
<p>I came across this function that can flatten a dictionary:</p>
<pre><code>def flatten(dictionnary, container=None):
    if container is None:
        container = []
    for k, v in dictionnary.items():
        container.append(k)
        if v:
            flatten(v, container)
    return container
</code></pre>
<p>to test it I created a dictionnay that is nested <code>n</code> times like so:</p>
<pre><code>nesteddict = {}
for i in range(n, 0, -1):
    emptydict = {}
    emptydict[i] = nesteddict
    nesteddict = emptydict
</code></pre>
<p>the function works while <code>n</code> is less than 999, otherwise it hit recursion limit:</p>
<pre><code>RecursionError: maximum recursion depth exceeded while calling a Python object
</code></pre>
<p>so after a little bit of searching it seems that <a href="https://stackoverflow.com/questions/931762/can-every-recursion-be-converted-into-iteration">any recursive function can rewritten to iteration</a> but I cant see how it could be done for the function I have to produce the same results.</p>
<p>Another weird problem I came across while playing with this is if I try the code below for <code>n &gt;= 998</code>:</p>
<pre><code>nesteddict = {}
for i in range(n, 0, -1):
    emptydict = {}
    emptydict[i] = nesteddict
    nesteddict = emptydict
print(nesteddict)
</code></pre>
<p>I get recursion error:</p>
<pre><code>RecursionError: maximum recursion depth exceeded while getting the repr of an object
</code></pre>
<p>which is weird since I dont see any recursion here.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of saving the dict in the stack, you should save the item's iterator in stack.</p>
<p>This way, you can resume the iterator on command.</p>
<p>Also because you're pausing and resuming the execution of iterators in order, the result will always be according to the order of the dict.</p>
<p>By the way, @iBug, dicts are ordered as per Python's specification from 3.7</p>
<pre><code>def flatten(dictionary, container=None):
    if container is None:
        container = []
    iterators = []
    iterator = iter(dictionary.items())
    while True:
        for k, v in iterator:
            container.append(k)
            if v:
                # Save the current iterator for later
                iterators.append(iterator)
                # Run on the new dict
                iterator = iter(v.items())
                break

        # Current iterator is done, fetch the next one
        else:
            try:
                iterator = iterators.pop()
            except IndexError:
                return container

print(flatten({1: None, 2: {3: None, 4: None}, 5: None}))
[1, 2, 3, 4, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Logically, nested dictionaries (and lists) is a kind of recursion, so if you want to avoid logical recursion, that's impossible.</p>
<p>But, since recursion is just recursion, you can keep a stack of your own and simulate that in a loop:</p>
<pre><code>def flatten(dct, c=None):
    if c is None:
        c = []
    stack = [dct]
    while stack:  # non-empty
        d = stack.pop()
        for k, v in d.items():
            c.append(k)
            if v:
                stack.append(v)
    return c
</code></pre>
<p>This function well emulates the behavior of function recursion, with a custom stack.</p>
<p>There's one <em>potential</em> downside: Theoretically, a dictionary like</p>
<pre><code>{1: None, 2: {3: None, 4: None}, 5: None}
</code></pre>
<p>should be flattened as <code>[1, 2, 3, 4, 5]</code>, while this method would give <code>[1, 2, 5, 3, 4]</code>. This is much like a DFS search vs a BFS search on a graph.</p>
<p><strong>But</strong>, since dictionary is unordered, this shouldn't be a big matter (unless you're using <code>collections.OrderedDict</code>), and that's why I say this is a <em>potential</em> downside.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to do it without recursion, it is impossible.</p>
<p>So Here the solution for the RecursionError.</p>
<p>Based on the <a href="https://docs.python.org/3/library/exceptions.html" rel="nofollow noreferrer">doc of python.</a>
You could use <code>sys.getrecursionlimit()</code> to see the limit of recursion. You could also use <code>sys.setrecursionlimit()</code> to make the limit upper.</p>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/a/953097/941722">stackoverflow.com/a/953097/941722</a> I think you should take a look at this answer, may be an good option.</span>
<span class="comment-copy">Perfect answer, thank you. If you dont mind I have another function and would like your help, the function is called <code>del_key(dictionary, key)</code> and it body is  <code>return {k: del_key(v, key) for k, v in dictionary.items() if k != key}</code>, it takes a dictionary and a key that need to be deleted from that nested dictionary, thanks again.</span>
<span class="comment-copy">The first paragraph looks like the opposite of my answer. Are you sure?</span>
<span class="comment-copy">Plus, it's not recommended to <code>sys.setrecursionlimit</code> to an arbitrarily high value, as it relies heavilybl on system resources.</span>
