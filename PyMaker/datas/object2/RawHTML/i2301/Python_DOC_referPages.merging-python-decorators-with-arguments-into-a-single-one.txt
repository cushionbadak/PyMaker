<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/5409450/can-i-combine-two-decorators-into-a-single-one-in-python">Can I combine two decorators into a single one in Python?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>I'm using two different decorators from two different libraries. Lets say: <code>@decorator1(param1, param2)</code> and <code>@decorator2(param3, param4)</code>. That I often use in many functions as:</p>
<pre><code>from moduleA import decorator1
from moduleB import decorator2

@decorator2(foo='param3', bar='param4')
@decorator1(name='param1', state='param2')
def myfunc(funcpar1, funcpar2):
    ...
</code></pre>
<p>Since it happens every time, I would like to create a <em>custom decorator</em> that handle both of them. Something like:</p>
<pre><code>@mycustomdecorator(name='param1', state='param2',
                   foo='param3', bar='param4')
def myfunc(funcpar1, funcpar2):
    ...
</code></pre>
<p>How do I achieve that?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would argue that you shouldn't - using the original names for the decorators gives much better readability.</p>
<p>However, if you really want to, you can do it like this:</p>
<pre><code>import functools

from moduleA import decorator1
from moduleB import decorator2

def my_decorator(foo, bar, name, state):
    def inner(func):
        @decorator2(foo=foo, bar=bar)
        @decorator1(name=name, state=state)
        @functools.wraps(func)  # Not required, but generally considered good practice
        def newfunc(*args, **kwargs)
            return func(*args, **kwargs)
        return newfunc
    return inner

@my_decorator(foo='param3', bar='param4', name='param1', state='param2')
def myfunc(funcpar1, funcpar2):
    ...
</code></pre>
<p>Based on comments though, here's an alternative method:</p>
<pre><code>def my_decorator(foo, bar, name, state):
    def inner(func):
        # Please note that for the exact same result as in the other one, 
        # the order of decorators has to be reversed compared to normal decorating
        newfunc = decorator1(name=name, state=state)(func)
        newfunc = decorator2(foo=foo, bar=bar)(newfunc)
        # Note that functools.wraps shouldn't be required anymore, as the other decorators should do that themselves
        return newfunc
    return inner
</code></pre>
<p>To some, this might look simpler. However, people experienced with Python are used to decorators being applied with an @ - and even for that reason alone, I like my first option better. I know I'd take three times as long to read this code for the first time and understand what it does. </p>
<p>It's simple really - just write a decorator that returns another decorator which will have it's inner function decorated with the other two decorators ;)</p>
<p>It might also be a good idea to use functools.wraps, for the sake of good habits. It's standard library and helps a lot with debugging and interactive console use: <a href="https://docs.python.org/3.7/library/functools.html" rel="nofollow noreferrer">https://docs.python.org/3.7/library/functools.html</a></p>
<p>In general though, I'd say the one extra line of code is more than worth the clarity of using the decorators separately. You'll thank yourself when you read your own code in 3 more months.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is just simple function composition, where <code>decorator1</code> and <code>decorator2</code> are returning the functions you want to compose. The real work can be abstracted out into a function <code>compose</code>.</p>
<pre><code># In the special case of composing decorators, the lambda expression
# only needs to be defined with a single argument, like
#
#   lambda func: f(g(func))
#
# but I show a more general form.
def compose(f, g):     
    return lambda *args, **kwargs: f(g(*args, **kwargs))

def customdecorator(foo, bar, name, state):
    return compose(decorator2(foo=foo, bar=bar),
                   decorator1(name=name, state=state))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Decorator is nothing more than a syntax sugar to the syntax like <code>func = decorator(func)</code>. </p>
<p>So, you can easily make your own decorator that does whatever you want with the following syntax:</p>
<pre><code>def mycustomdecorator(foo, bar, name, state)
    def innerdecorator(func):
        func = decorator1(foo=foo, bar=bar)(func)
        func = decorator2(name=name, state=state)(func)
        return func
    return innerdecorator
</code></pre>
<p>After that, you should be able to use @mycustomdecorator with no hassle. Let me know if this works, I didn't test it but theoretically it should.</p>
<p>What's the magic there: first, we need to retrieve parameters for our decorators. This way, we are able to pass them on into nested function. Then, we are accepting our function as an argument, and the last, we are getting parameters for our function. We can nest our def-s as much as we need.</p>
</div>
<span class="comment-copy">I don't think is the same, in post you mentioned the <code>@customdecorator</code> is receiving decorators. It will not be this case.</span>
<span class="comment-copy">You can easily extend <a href="https://stackoverflow.com/a/5409491/1222951">this answer</a> to add parameters though.</span>
<span class="comment-copy">can you please instead mark as duplicated, add the extension, since I'm not being able achieve that from that answer.</span>
<span class="comment-copy">I don't think we should have two separate Q&amp;As for merging decorators with and without arguments, so I'm going to post a more complete answer in the other question.</span>
<span class="comment-copy">It will for sure help me that I will know that. But (IMHO) since that question already has a valid and accepted answer the new one (and also correct) will be hard to find.</span>
<span class="comment-copy">You should be using <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps</code></a> though. If you try <code>print(myfunc)</code> you'll get <code>&lt;function my_decorator.&lt;locals&gt;.inner.&lt;locals&gt;.newfunc at 0x7f5ee7bbee18&gt;</code> as output.</span>
<span class="comment-copy">You're right, of course. I was a bit in doubt because this question indicates a certain inexperience with decorators, and I wasn't sure whether to add it. I'll make an edit about it, since it's better to learn it right the first time around, though.</span>
<span class="comment-copy">While I usually agree that saving a line or two is not worth a loss in readability, if I had to apply the same two decorators to more than a couple functions I'd certainly wonder whether it's accidental or not, and in the last case refactor the whole thing to avoid repetitions.</span>
<span class="comment-copy">If they're from two different libraries, it's not accidental. @Aran-Fey: Whoops. That'll teach me from trying to edit to fast.</span>
<span class="comment-copy">@Jacco but then I'd start wondering why I didn't ever see the authors of the libraries in the same room at the same time.</span>
<span class="comment-copy">Can you elaborate, please?</span>
<span class="comment-copy">Yes, I believe this is the way to preserve arguments for both foo() and mycustomdecorator(). Am I wrong?</span>
<span class="comment-copy">The number of functions is fine; <code>decorator1</code> and <code>decorator2</code> are just being called in the wrong place. You want to apply them in <code>innerdecorator</code> <i>before</i> <code>wrapper</code> is defined, so that you aren't repeatedly calling them every time you call <code>func</code>.</span>
<span class="comment-copy">(I should say "inefficient" rather than "wrong".)</span>
<span class="comment-copy">(The wrong part is that <code>wrapper</code> should <i>call</i>, not return, <code>func</code>.)</span>
