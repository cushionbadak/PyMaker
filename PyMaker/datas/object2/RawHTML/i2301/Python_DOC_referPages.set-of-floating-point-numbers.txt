<div class="post-text" itemprop="text">
<p>So I want to create a set of floating point numbers where two numbers are considered equal given a certain tolerance. For example, if I have a set</p>
<pre><code>a =  set([1, 2, 3])
</code></pre>
<p>if I add the element 1.00001 with a tolerance of 1e-4, the resulting set should be </p>
<pre><code>{1, 2, 3}
</code></pre>
<p>and not </p>
<pre><code>{1, 1.00001, 2, 3}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can use a round function to check <code>tolerance of 1e-4</code></p>
<pre><code>a = set([1,2,3])
def add(number):
  if(round(number,4) not in a):
    a.add(number)


add(1)
print(a)
add(1.0000)
print(a)
add(1.0001)
print(a)
add(1.1)
print(a)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems to me you should just be able to check each item already in the set and, if the absolute difference between that item and the one you're trying to add is smaller than the threshold, just don't add it.</p>
<p>Something like this should do the trick:</p>
<pre><code>def AddToSetWithThreshold(pSet, pValue, pThreshold):
    vList = [entry for entry in pSet if abs(pValue - entry) &lt; pThreshold]
    if len(vList) == 0:
        pSet.add(pValue)

a = set([1, 2, 3]) ; print(a)
AddToSetWithThreshold(a, 1.00001, 1e-4) ; print(a)
AddToSetWithThreshold(a, 1.00001, 1e-6) ; print(a)
</code></pre>
<p>Because the first addition is too close to <code>1</code> and the second is <em>not,</em> this will result in the following output:</p>
<pre><code>set([1, 2, 3])
set([1, 2, 3])
set([1, 2, 3, 1.00001])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>import math and use ceil</p>
<pre><code>import math

decimals = 3

v = 1.234566789
print(math.ceil(v*pow(10,decimals))/pow(10,decimals))  
# 1.234
</code></pre>
<p>or if you want an intger like "threshold" just use</p>
<pre><code>print(float(int(v)))
# 1.0
</code></pre>
</div>
<span class="comment-copy">Sounds tricky, if you want it to be efficient, and you don't want the set items to get rounded. Maybe define a subclass of float, with special <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow noreferrer">rich comparison</a> methods, or at least a custom <code>__hash__</code> method.</span>
<span class="comment-copy">This operation is not well defined, as two numbers <code>a</code> and <code>c</code> may be far enough apart that they are not “considered equal” but are close enough that <code>b</code> could be “considered equal” to either of them. Adding the same numbers to sets in different orders could create different results. Mathematically, an equivalence relation should be transitive, and violating that will lead to bad behavior. Creating kludges like this for floating-point numbers is generally bad design.</span>
<span class="comment-copy">That looks pretty complicated, and slower than using <code>round</code>.</span>
