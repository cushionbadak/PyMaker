<div class="post-text" itemprop="text">
<p>What is the difference between add and update operations in python if i just want to add a single value to the set.</p>
<pre><code>a = set()
a.update([1]) #works
a.add(1) #works
a.update([1,2])#works
a.add([1,2])#fails 
</code></pre>
<p>Can someone explain why is this so.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong><a href="https://docs.python.org/3/library/stdtypes.html#set.add" rel="noreferrer"><code>set.add</code></a></strong></p>
<p><code>set.add</code> adds an individual element to the set. So,</p>
<pre><code>&gt;&gt;&gt; a = set()
&gt;&gt;&gt; a.add(1)
&gt;&gt;&gt; a
set([1])
</code></pre>
<p>works, but it cannot work with an iterable, unless it is hashable. That is  the reason why <code>a.add([1, 2])</code> fails.</p>
<pre><code>&gt;&gt;&gt; a.add([1, 2])
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>
<p>Here, <code>[1, 2]</code> is treated as the element being added to the set and as the error message says, <a href="https://stackoverflow.com/q/23268899/1903116">a list cannot be hashed</a> but all the elements of a set are expected to be hashables. Quoting the <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="noreferrer">documentation</a>,</p>
<blockquote>
<p>Return a new <code>set</code> or <code>frozenset</code> object whose elements are taken from iterable. The elements of a set must be <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="noreferrer">hashable</a>.</p>
</blockquote>
<p><strong><a href="https://docs.python.org/3/library/stdtypes.html#set.update" rel="noreferrer"><code>set.update</code></a></strong></p>
<p>In case of <a href="https://docs.python.org/3/library/stdtypes.html#set.update" rel="noreferrer"><code>set.update</code></a>, you can pass multiple iterables to it and it will iterate all iterables and will include the individual elements in the set. <em>Remember:</em> It can accept only iterables. That is why you are getting an error when you try to update it with <code>1</code></p>
<pre><code>&gt;&gt;&gt; a.update(1)
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
TypeError: 'int' object is not iterable
</code></pre>
<p>But, the following would work because the list <code>[1]</code> is iterated and the elements of the list are added to the set.</p>
<pre><code>&gt;&gt;&gt; a.update([1])
&gt;&gt;&gt; a
set([1])
</code></pre>
<p><code>set.update</code> is basically an equivalent of in-place set union operation. Consider the following cases</p>
<pre><code>&gt;&gt;&gt; set([1, 2]) | set([3, 4]) | set([1, 3])
set([1, 2, 3, 4])
&gt;&gt;&gt; set([1, 2]) | set(range(3, 5)) | set(i for i in range(1, 5) if i % 2 == 1)
set([1, 2, 3, 4])
</code></pre>
<p>Here, we explicitly convert all the iterables to sets and then we find the union. There are multiple intermediate sets and unions. In this case, <code>set.update</code> serves as a good helper function. Since it accepts any iterable, you can simply do</p>
<pre><code>&gt;&gt;&gt; a.update([1, 2], range(3, 5), (i for i in range(1, 5) if i % 2 == 1))
&gt;&gt;&gt; a
set([1, 2, 3, 4])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>add</code> is faster for a single element because it is exactly for that purpose, adding a single element:</p>
<pre><code>In [5]: timeit a.update([1])
10000000 loops, best of 3: 191 ns per loop

In [6]: timeit a.add(1) 
10000000 loops, best of 3: 69.9 ns per loop
</code></pre>
<p><code>update</code>  expects an iterable or iterables so  if you have a single hashable element to add then use <code>add</code> if you have an iterable or iterables of hashable elements to add use <code>update</code>.</p>
<blockquote>
<p>s.add(x)       add element x to set s</p>
<p>s.update(t)    s |= t  return set s with elements added from t</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><code>add</code> adds an element, <code>update</code> "adds" another iterable <code>set</code>, <code>list</code> or <code>tuple</code>, for example:</p>
<pre><code>In [2]: my_set = {1,2,3}

In [3]: my_set.add(5)

In [4]: my_set
Out[4]: set([1, 2, 3, 5])

In [5]: my_set.update({6,7})

In [6]: my_set
Out[6]: set([1, 2, 3, 5, 6, 7])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>.add()</code> is intended for a single <code>element</code>, while <code>.update()</code> is for the introduction of other sets.</p>
<p><em>From help():</em></p>
<pre><code>add(...)
    Add an element to a set.

    This has no effect if the element is already present.


update(...)
    Update a set with the union of itself and others.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>add</code> only accepts a hashable type. A list is not hashable.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>a.update(1)</code> in your code won't work. <code>add</code> accepts an element and put it in the set if it is not already there but <code>update</code> takes an iterable and makes a unions of the set with that iterable. It's kind of like <code>append</code> and <code>extend</code> for the lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>I guess no one mentioned about the good resource from Hackerrank. I'd like to paste how Hackerrank mentions the difference between update and add for set in python. </p>
<p>Sets are unordered bag of unique values. A single set contains values of any immutable data type. </p>
<p>CREATING SET </p>
<pre><code>myset = {1, 2} # Directly assigning values to a set

myset = set() # Initializing a set

myset = set(['a', 'b']) # Creating a set from a list

print(myset)  ===&gt; {'a', 'b'}
</code></pre>
<p><strong>MODIFYING SET - add() and update()</strong> </p>
<pre><code>myset.add('c')

myset  ===&gt;{'a', 'c', 'b'}

myset.add('a') # As 'a' already exists in the set, nothing happens

myset.add((5, 4))

print(myset) ===&gt; {'a', 'c', 'b', (5, 4)} 


myset.update([1, 2, 3, 4]) # update() only works for iterable objects

print(myset) ===&gt; {'a', 1, 'c', 'b', 4, 2, (5, 4), 3}

myset.update({1, 7, 8})

print(myset) ===&gt;{'a', 1, 'c', 'b', 4, 7, 8, 2, (5, 4), 3}

myset.update({1, 6}, [5, 13])

print(myset) ===&gt; {'a', 1, 'c', 'b', 4, 5, 6, 7, 8, 2, (5, 4), 13, 3}
</code></pre>
<p>Hope it helps. For more details on Hackerrank, <a href="https://www.hackerrank.com/challenges/sets" rel="nofollow">here is the link.</a></p>
</div>
<div class="post-text" itemprop="text">
<p>add method directly adds elements to the set while the update method converts first argument into set then it adds
the list is hashable therefore we cannot add a hashable list to unhashable set.</p>
</div>
<span class="comment-copy">What version of Python are you using? For <code>a.update(1)</code> I expect <code>TypeError: 'int' object is not iterable</code>, and got it for both versions I tried.</span>
<span class="comment-copy">@thefoutheye, your edit changed the question quite a bit</span>
<span class="comment-copy"><a href="https://github.com/python/cpython/blob/master/Objects/setobject.c" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Objects/setobject.c</a></span>
<span class="comment-copy">@PadraicCunningham We both know that it won't work. Can we agree that its just a copy/paste mistake? If not, please feel free to revert my revision :)</span>
<span class="comment-copy">@thefoureye yes it was a copy paste error on my end</span>
<span class="comment-copy">In case you want to update my_set from the sets in an iterable of iterables you must use <code>my_set.update(*[s for s in iterable])</code>, passing a generator in as in  <code>my_set.update(s for s in iterable)</code> will update the set with the elements of the iterable and will blow if those elements are not hashable</span>
<span class="comment-copy">While this is probably obvious, it should be noted that <code>update</code> is much faster for adding lots of elements at once: <code>timeit a.update( range(10000) ) # =&gt; 1000 loops, best of 3: 431 Âµs per loop</code>, meanwhile <code>timeit for i in range(10000): a.add(i) # =&gt; 1000 loops, best of 3: 1.18 ms per loop</code></span>
<span class="comment-copy">Just a note that this notation is fairly recent. Python 2.7  and Python 3.1, according to <a href="http://stackoverflow.com/a/31072911/1143274">stackoverflow.com/a/31072911/1143274</a></span>
