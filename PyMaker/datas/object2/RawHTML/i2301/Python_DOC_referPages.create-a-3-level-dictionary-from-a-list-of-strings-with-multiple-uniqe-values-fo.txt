<div class="post-text" itemprop="text">
<p>I have a list of text strings from which I need to build a tree and as I understand the proper data structure to achieve this is a dictionary.
The size of each string is fix and the format of all elements is the same so no additional checks are necessary. 
Each record of the list is a date in the format DD/MM/YYYY and the year / years should be on the root of the tree (the keys, no duplicates here), per each year may be multiple months (no duplicate months within same year) as value and per each month multiple days(no duplicate days within same month).</p>
<p>An example of the list of strings:</p>
<blockquote>
<p>data = ['04/02/2018', '05/02/2018', '06/02/2018', '01/03/2018',
  '10/03/2018', '08/09/2017', '09/09/2017', '11/10/2017',
          '11/12/2017', '14/06/2018', '15/06/2018', '24/07/2018', '26/07/2018', '30/08/2018', '31/08/2018', '01/09/2018']</p>
</blockquote>
<p>Beside a solution, if any could provide I would like also an explanation in order to understand.</p>
<p>This is what I wrote so far which is clearly wrong as the result is a dictionary with only last 2 items.</p>
<pre><code>d = {}
for item in data:
    rec = item.split('/')
    d.update({rec[2]:{rec[1]:(rec[0])}})
</code></pre>
<p>The desired output for that data looks like this:</p>
<pre><code>{'2017': {'09': ['08', '09'], '10': ['11'], '12': ['11']},
 '2018': {'02': ['04', '05', '06'],
          '03': ['01', '10'],
          '06': ['14', '15'],
          '07': ['24', '26'],
          '08': ['30', '31'],
          '09': ['01']}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are various way to achieve this. You <em>could</em> use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> from the <code>collections</code> module. But it can also be done use the plain <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault</code></a> method.</p>
<blockquote>
<p><strong><code>setdefault(key[, default])</code></strong></p>
<p>If <em>key</em> is in the dictionary, return its value. If not, insert <em>key</em> with a value of <em>default</em> and return <em>default</em>. <em>default</em> defaults to <em>None</em>.</p>
</blockquote>
<p>We loop over the data, splitting it into day, month, and year strings. Then we look in the base tree for the year key, and if it doesn't exist we create a new empty dict for it. Then we look in that year dict for a month key, creating a new list for it if it doesn't exist. Finally we append the day string to the month list.</p>
<pre><code>from pprint import pprint

data = [
    '04/02/2018', '05/02/2018', '06/02/2018', '01/03/2018', '10/03/2018', '08/09/2017', '09/09/2017',
    '11/10/2017', '11/12/2017', '14/06/2018', '15/06/2018', '24/07/2018', '26/07/2018', '30/08/2018',
    '31/08/2018', '01/09/2018'
]

tree = {}

for s in data:
    day, mon, year = s.split('/')
    ydict = tree.setdefault(year, {})
    mlist = ydict.setdefault(mon, [])
    mlist.append(day)

pprint(tree)
</code></pre>
<p><strong>output</strong></p>
<pre><code>{'2017': {'09': ['08', '09'], '10': ['11'], '12': ['11']},
 '2018': {'02': ['04', '05', '06'],
          '03': ['01', '10'],
          '06': ['14', '15'],
          '07': ['24', '26'],
          '08': ['30', '31'],
          '09': ['01']}}
</code></pre>
<p>We can combine the 3 steps of the main loop into one line, but it's a bit harder to read:</p>
<pre><code>for s in data:
    day, mon, year = s.split('/')
    tree.setdefault(year, {}).setdefault(mon, []).append(day)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need a tree. You can use a dict of dicts, having lists as innermost values. </p>
<p>You can use a <code>defaultdict</code> as your main structure</p>
<pre><code>result = defaultdict(defaultdict(list))

for date in data:
    day, month, year = date.split('/')
    result[year][month].append(day)
</code></pre>
<p>What a <code>defaultdict</code> does is that</p>
<ul>
<li>for the inner dict: you can <code>append</code> directly. If there is not a list, a new empty one is created.</li>
<li>for the outer dict: similarly, you can refer to the key <code>month</code> assuming there is already a dict as its value. If there is not, a new one is created.</li>
</ul>
</div>
<span class="comment-copy">please add your code, where you are facing issue?</span>
<span class="comment-copy">so far I don't have any working code, but I can post my shameful attempt.</span>
<span class="comment-copy">good, that's the way it is, all the best.</span>
<span class="comment-copy">Yes, this is what the final result should be like, sorry I forgot to post that.</span>
<span class="comment-copy">"I need to build a tree and as I understand the proper data structure to achieve this is a dictionary." Not necessarily. Tree's are often implemented using your own, custom data-structures (that may be composed of <code>dict</code> objects as well, but may involve others)</span>
<span class="comment-copy">This works great, easy to read and understand. I know that python one liners are preferred but for my level of python the longer way is simply perfect. Thank you.</span>
<span class="comment-copy">This code got me all excited , beautiful</span>
<span class="comment-copy">I want you to look at this, I'm solving it I was thinking of using a .split(':') and setting up a dict with the uniques of each key preceeding the <code>:</code> and go from there, check it out I think you would be good for this <a href="https://stackoverflow.com/questions/52460092/max-values-for-partial-matching-keys-in-python-dictionary" title="max values for partial matching keys in python dictionary">stackoverflow.com/questions/52460092/â€¦</a></span>
<span class="comment-copy">checking if the value "day" is in the mlist before appending actually gives the final desired outcome. if day not in mlist: mlist.append(day)</span>
<span class="comment-copy">@bit-by-bit Ah. I didn't realise that you need to exclude duplicate days. I thought you were saying that there will never be duplicate days in the data. Your solution is fine, but another option is to store the days in sets instead of lists, which will automatically eliminate duplicates, just like the dict keys eliminate dupe years &amp; months. To do that, you'd use the <code>set.add</code> method, which is equivalent to <code>list.append</code>. OTOH, sets are unordered collections, which might not be suitable for your use case.</span>
<span class="comment-copy">The value should be the 'days'</span>
<span class="comment-copy">@bit-by-bit: edited</span>
<span class="comment-copy">@blue_note did you run this ? because I'm pretty sure you can't split a list object in your for statement</span>
<span class="comment-copy">@vash_the_stampede: of course, mistake. thanks, edited.</span>
<span class="comment-copy">no prob I'm also getting a error running the nested defaultdict that way, its not permitting the inner defaultdict to be an iterable, maybe im missing something</span>
