<div class="post-text" itemprop="text">
<p>There's a function which takes optional arguments.</p>
<pre><code>def alpha(p1="foo", p2="bar"):
     print('{0},{1}'.format(p1, p2))
</code></pre>
<p>Let me iterate over what happens when we use that function in different ways:</p>
<pre><code>&gt;&gt;&gt; alpha()
foo,bar
&gt;&gt;&gt; alpha("FOO")
FOO,bar
&gt;&gt;&gt; alpha(p2="BAR")
foo,BAR
&gt;&gt;&gt; alpha(p1="FOO", p2=None)
FOO,None
</code></pre>
<p>Now consider the case where I want to call it like <code>alpha("FOO", myp2)</code> and <code>myp2</code> will either contain a value to be passed, or be <code>None</code>. But even though the function handles <code>p2=None</code>, I want it to use its default value <code>"bar"</code> instead.<br/>
Maybe that's worded confusingly, so let me reword that:  </p>
<blockquote>
<p>If <code>myp2 is None</code>, call <code>alpha("FOO")</code>.   Else, call <code>alpha("FOO", myp2)</code>.</p>
</blockquote>
<p>The distinction is relevant because <code>alpha("FOO", None)</code> has a different result than <code>alpha("FOO")</code>.  </p>
<p><strong>How can I concisely (but readably) make this distinction?</strong> </p>
<p>One possibility would usually be to <a href="https://stackoverflow.com/questions/16576553/python-only-pass-arguments-if-the-variable-exists">check for None within <code>alpha</code></a>, which would be encouraged because that would make the code safer. But assume that <code>alpha</code> is used in other places where it is actually supposed to handle <code>None</code> as it does.  </p>
<p><strong>I'd like to handle that on the caller-side</strong>.  </p>
<p>One possibility is to do a case distinction:</p>
<pre><code>if myp2 is None:
    alpha("FOO")
else:
    alpha("FOO", myp2)
</code></pre>
<p>But that can quickly become much code when there are multiple such arguments. (exponentially, 2^n)</p>
<p>Another possibility is to simply do <code>alpha("FOO", myp2 or "bar")</code>, but <em>that requires us to know the default value</em>. Usually, I'd probably go with this approach, but I might later change the default values for <code>alpha</code> and this call would then need to be updated manually in order to still call it with the (new) default value.</p>
<p>I am using python 3.4 but it would be best if your answers can provide a good way that works in any python version.</p>
<hr/>
<p>The question is technically finished here, but I reword some requirement again, since the first answer did gloss over that:<br/>
I want the behaviour of <code>alpha</code> with its default values <code>"foo", "bar"</code> preserved in general, so it is (probably) not an option to change <code>alpha</code> itself.<br/>
In yet again other words, assume that <code>alpha</code> is being used somewhere else as <code>alpha("FOO", None)</code> where the output <code>FOO,None</code> is expected behaviour.</p>
</div>
<div class="post-text" itemprop="text">
<p>Pass the arguments as kwargs from a dictionary, from which you filter out the <code>None</code> values:</p>
<pre><code>kwargs = dict(p1='FOO', p2=None)

alpha(**{k: v for k, v in kwargs.items() if v is not None})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>although ** is definitely a language feature, it's surely not created for solving this particular problem. Your suggestion works, so does mine. Which one works better depends on the rest of the OP's code. However, there is still no way to write <code>f(x or dont_pass_it_at_all)</code>
  - <a href="https://stackoverflow.com/questions/52494128/call-function-without-optional-arguments-if-they-are-none/52494369?noredirect=1#comment91929619_52494329">blue_note</a></p>
</blockquote>
<p>Thanks to your great answers, I thought I'd try to do just that:</p>
<pre><code># gen.py
def callWithNonNoneArgs(f, *args, **kwargs):
    kwargsNotNone = {k: v for k, v in kwargs.items() if v is not None}
    return f(*args, **kwargsNotNone)
</code></pre>
<p>Â </p>
<pre><code># python interpreter
&gt;&gt;&gt; import gen
&gt;&gt;&gt; def alpha(p1="foo", p2="bar"):
...     print('{0},{1}'.format(p1,p2))
...
&gt;&gt;&gt; gen.callWithNonNoneArgs(alpha, p1="FOO", p2=None)
FOO,bar
&gt;&gt;&gt; def beta(ree, p1="foo", p2="bar"):
...     print('{0},{1},{2}'.format(ree,p1,p2))
...
&gt;&gt;&gt; beta('hello', p2="world")
hello,foo,world
&gt;&gt;&gt; beta('hello', p2=None)
hello,foo,None
&gt;&gt;&gt; gen.callWithNonNoneArgs(beta, 'hello', p2=None)
hello,foo,bar
</code></pre>
<p>This is probably not perfect, but it seems to work: It's a function that you can call with another function and it's arguments, and it applies <a href="https://stackoverflow.com/a/52494213/2550406">deceze's answer</a> to filter out the arguments that are <code>None</code>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>But assume that alpha is used in other places where it is actually supposed to handle None as it does.</p>
</blockquote>
<p>To respond to this concern, I have been known to have a <code>None</code>-like value which isn't actually <code>None</code> for this exact purpose.</p>
<pre><code>_novalue = object()

def alpha(p1=_novalue, p2=_novalue):
    if p1 is _novalue:
        p1 = "foo"
    if p2 is _novalue:
        p2 = "bar"
    print('{0},{1}'.format(p1, p2))
</code></pre>
<p>Now the arguments are still optional, so you can neglect to pass either of them. And the function handles <code>None</code> correctly. If you ever want to <em>explicitly</em> not pass an argument, you can pass <code>_novalue</code>.</p>
<pre><code>&gt;&gt;&gt; alpha(p1="FOO", p2=None)
FOO,None
&gt;&gt;&gt; alpha(p1="FOO")
FOO,bar
&gt;&gt;&gt; alpha(p1="FOO", p2=_novalue)
FOO,bar
</code></pre>
<p>and since <code>_novalue</code> is a special made-up value created for this <em>express</em> purpose, anyone who passes <code>_novalue</code> is certainly intending the "default argument" behavior, as opposed to someone who passes <code>None</code> who might intend that the value be interpreted as literal <code>None</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately, there's no way to do what you want. Even widely adopted python libraries/frameworks use your first approach. It's an extra line of code, but it is quite readable. </p>
<p><em>Do not</em> use the <code>alpha("FOO", myp2 or "bar")</code> approach, because, as you mention yourself, it creates a terrible kind of coupling, since it requires the caller to know details about the function.</p>
<p>Regarding work-arounds: you could make a decorator for you function (using the <code>inspect</code> module), which checks the arguments passed to it. If one of them is <code>None</code>, it replaces the value with its own default value.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could inspect the default values via <code>alpha.__defaults__</code> and then use them instead of <code>None</code>. That way you circumvent the hard-coding of default values:</p>
<pre><code>&gt;&gt;&gt; args = [None]
&gt;&gt;&gt; alpha('FOO', *[x if x is not None else y for x, y in zip(args, alpha.__defaults__[1:])])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm surprised nobody brought this up</p>
<pre><code>def f(p1="foo", p2=None):
    p2 = "bar" if p2 is None else p2
    print(p1+p2)
</code></pre>
<p>You assign None to p2 as standart (or don't, but this way you have the true standart at one point in your code) and use an inline if. Imo the most pythonic answer. Another thing that comes to mind is using a wrapper, but that would be way less readable.</p>
<p>EDIT:
What I'd probably do is use a dummy as standart value and check for that. So something like this:</p>
<pre><code>class dummy():
    pass

def alpha(p1="foo", p2=dummy()):
    if isinstance(p2, dummy):
        p2 = "bar"
    print("{0},{1}".format(p1, p2))

alpha()
alpha("a","b")
alpha(p2=None)
</code></pre>
<p>produces:</p>
<pre><code>foo,bar
a,b
foo,None
</code></pre>
</div>
<span class="comment-copy">"But assume that alpha is used in other places where it is actually supposed to handle None as it does." -- What do you mean? You still want to be able to pass <code>None</code> as a parameter?</span>
<span class="comment-copy">@cheersmate Does my edit at the end of the question help? (I think deceze's answer is what I was looking for. I have to try it yet though)</span>
<span class="comment-copy">This treats <code>p1 = None</code> the same of course, possibly what is wanted (or irrelevant)   but worth noting perhaps</span>
<span class="comment-copy">This works perfectly! Thanks! Would you mind adding a short explanation or a good link? I think I understand what it does and could google the rest by myself, but it would also be useful for future visitors</span>
<span class="comment-copy">It simply uses <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">argument unpacking</a> and <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">dictionary comprehensions</a>.</span>
<span class="comment-copy">I like this answer better than the highest one because the hairy code is moved into a function rather than being inline.</span>
<span class="comment-copy">+1 , this satisfies all the conditions of OP ! I think some alternate examples of _novalue can be : passing -1 for a positive numeric argument , or passing 0.5 for a boolean argument , or passing "" where "" is an invalid argument.</span>
<span class="comment-copy">Iâ€™ve also done to differentiate None from not-set-yet on properties.  It works well, but you have to be careful to always use the same _novalue.  itâ€™s easy to sprinkle around different â€˜_novalue = object()â€™ and end up w extremely subtle bugs.</span>
<span class="comment-copy"><i>"No way"</i>â€¦? <a href="https://stackoverflow.com/a/52494213/476">Hmmâ€¦ ðŸ¤”</a></span>
<span class="comment-copy">If you just have a single <code>if..else</code>, sure, that is actually shorter. But for functions with more than two or three arguments this longer workaround quickly pays off. And yes, I'd regard <code>**</code> as a language feature to solve this issue.</span>
<span class="comment-copy">@deceze: although <code>**</code> is definitely a language feature, it's surely not created for solving this particular problem. Your suggestion works, so does mine. Which one works better depends on the rest of the OP's code. However, there is still no way to write <code>f(x or dont_pass_it_at_all)</code></span>
<span class="comment-copy">@blue_note I'm fairly certain that the <code>**</code> feature was created for <i>exactly</i> this use case: dynamically building up an argument set. What in the world else can you use <code>dict</code> unpacking for? Nothing else accepts a set of unpacked key-value pairs like methods (including initializers) do.</span>
<span class="comment-copy">It fit the original version, too.</span>
<span class="comment-copy">@jpp Good point, changed the answer.</span>
<span class="comment-copy">Feels ugly and elegant at the same time, but I don't see why not to use this answer. Why do you not recomment this way?</span>
<span class="comment-copy">@lucidbrot Well okay, technically there's nothing wrong with it and when you have many arguments it saves you from explicitly writing down the arguments' names. It's just when you want to use a default value normally you just don't pass the argument. But yes, there might be actually uses cases for that, I think it depends on the judgement of the reader. I'll remove rephrase that statement.</span>
<span class="comment-copy">This does not preserve the original behavior for other calls. (I.e. None should usually print None, just not in this specific call). I am aware that my requirements imply bad code, but I wanted to know how it would be possible. I think your answer is valuable for many future visitors, but is not the answer to my question. I wouldn't delete it though (as the first answerer did, who suggested the same thing and got downvoted to the ninth layer of Baator</span>
<span class="comment-copy">Oops sorry, should've read properly. See edit in original comment.</span>
