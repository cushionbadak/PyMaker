<div class="post-text" itemprop="text">
<p>I'm new to Python and XML and trying to parse through the file below in order to extract several elements. The issue is that some elements are empty (example customer xyz1 does not have any address information). </p>
<pre><code>&lt;CAT&gt;
  &lt;Header&gt;...&lt;/Header&gt;
  &lt;Add&gt;...&lt;/Add&gt;
  &lt;Customer&gt;
    &lt;Id_Customer&gt;xyz1&lt;/Id_Customer&gt;
    &lt;Segment&gt;abc1&lt;/Segment&gt;
    &lt;Event&gt;
      &lt;Nature&gt;info1&lt;/Nature&gt;
      &lt;Extrainfo&gt;info2&lt;/Extrainfo&gt;
    &lt;/Event&gt;
&lt;/Customer&gt;
&lt;Customer&gt;
    &lt;Id_Customer&gt;zzwy&lt;/Id_Customer&gt;
    &lt;Segment&gt;c2&lt;/Segment&gt;
    &lt;Adress&gt;
       &lt;zipcode&gt;77098&lt;/zipcode&gt;
       &lt;street&gt;belaire drive&lt;/street&gt;
       &lt;number&gt;5&lt;/number&gt;
    &lt;/Adress&gt;
&lt;/Customer&gt;
&lt;Customer&gt;...&lt;/Customer&gt;
&lt;/CAT&gt;
</code></pre>
<p>I'm looping through the following elements (Id_Customer, Segment, Extrainfo, zipcode, street) in order to build up a list that I will then export to a .csv file.</p>
<p>My code below generates the following output : [xyz1,abc1,info2,zzwy,c2 ..] while I would like elements not found to be input in the list as "empty" so that my list would contain : [xyz1,abc1,info2,empty,empty, zzwy,c2 ..]</p>
<p>Here is a sample of my code : </p>
<pre><code>from xml.etree import ElementTree
import csv

list_prm = []

tree = ElementTree.parse('file.xml')
root = tree.getroot()

for elem in tree.iter():
    if elem.findall('Id_Customer'):
        list_prm.append(elem.text)
    if elem.tag == 'Segment':
        list_prm.append(elem.text)
    if elem.tag == 'Extrainfo':
        list_prm.append(elem.text)
    if elem.tag == 'street':
        list_prm.append(elem.text)
    if elem.tag == 'zipcode':
        list_prm.append(elem.text)


print(list_prm)
</code></pre>
<p>I would very much appreciate some help. (I can only use standard python library.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Have a look at method <em>findtext</em> of xml.etree (<a href="https://docs.python.org/3.6/library/xml.etree.elementtree.html" rel="nofollow noreferrer">https://docs.python.org/3.6/library/xml.etree.elementtree.html</a>), default value.</p>
<p>I guess something like the following might work (not tested), with each customer in a separate list (as line in csv file), that then gets inserted into the general list_prn list. Of course, you would have to iterate over the lists when building the csv file.</p>
<p>If you really wanted all the elements values in one list, you could skip the creation of cust list and insert the values directly into list_prn.</p>
<p>It all suposes that all the subelements of Customer are there only once.</p>
<pre><code>from xml.etree import ElementTree
import csv

list_prm = []

tree = ElementTree.parse('file.xml')
root = tree.getroot()

for elem in tree.iter('Customer'):
    # only the first customer_id
    customer_id = elem.find('Id_Customer')
    if customer_id is not None:
        # Create a separate list for each Customer,
        # only if there's Customer Id, skip creation otherwise
        cust = []

        cust.append(customer_id.text())
        cust.append(elem.findtext('Segment', default='empty'))
        cust.append(elem.findtext('Extrainfo', default='empty'))
        cust.append(elem.findtext('Address/street', default='empty'))
        cust.append(elem.findtext('Address/zipcode', default='empty'))

        list_prm.append(cust)


print(list_prm)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your main problem is that you're literally just plopping data from the XML into the CSV in pretty much the same state you found it. The elements you are referring to as being "empty" are not empty, they are not present in the XML.</p>
<p>I can think of two approaches you might use to make this work better. The first would be to change your XML such that every <code>&lt;Customer&gt;</code> element contains all the elements in the same order, even if the elements are completely empty. In other words your XML might look like this:</p>
<pre><code>&lt;Customer&gt;
    &lt;Id_Customer&gt;xyz1&lt;/Id_Customer&gt;
    &lt;Segment&gt;abc1&lt;/Segment&gt;
    &lt;Event&gt;
      &lt;Nature&gt;info1&lt;/Nature&gt;
      &lt;Extrainfo&gt;info2&lt;/Extrainfo&gt;
    &lt;/Event&gt;
    &lt;Adress&gt;
       &lt;zipcode&gt;&lt;/zipcode&gt;
       &lt;street&gt;&lt;/street&gt;
       &lt;number&gt;&lt;/number&gt;
    &lt;/Adress&gt;
&lt;/Customer&gt;
&lt;Customer&gt;
    &lt;Id_Customer&gt;zzwy&lt;/Id_Customer&gt;
    &lt;Segment&gt;c2&lt;/Segment&gt;
    &lt;Event&gt;
      &lt;Nature&gt;&lt;/Nature&gt;
      &lt;Extrainfo&gt;&lt;/Extrainfo&gt;
    &lt;/Event&gt;
    &lt;Adress&gt;
       &lt;zipcode&gt;77098&lt;/zipcode&gt;
       &lt;street&gt;belaire drive&lt;/street&gt;
       &lt;number&gt;5&lt;/number&gt;
    &lt;/Adress&gt;
&lt;/Customer&gt;
</code></pre>
<p>If you want you could add a condition in your Python code that would replace the empty string (<code>""</code>) with the word "empty" since you indicated that's what you wanted it to say.</p>
<p>The other approach would make for a lot more complicated Python code but is honestly probably the better approach. That would be to use either a class or a dict to sort the data: one dict or object per <code>&lt;Customer&gt;</code> tag. With what you're doing I'd say creating a class might be overkill, so a dict should be enough. (Using a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a> rather than an ordinary dict would allow you to automatically supply the word "empty" when no value was found, so I'd look into that.)</p>
<p>Basically the flow of the program would go like this:</p>
<ol>
<li>Create an empty list to store your dicts. <code>customers = []</code></li>
<li>Loop through the <code>&lt;Customer&gt;</code> elements in the XML tree. For each customer:

<ol>
<li>Create a new dict and add it to the list. <code>customer={}</code> or <code>customer=defaultdict("empty")</code>, then <code>customers.append(customer)</code></li>
<li>Loop through that element's child elements, and for each one populate the the dict with it's info. Something like <code>customer[elem.tag]=elem.text</code> may be what you're looking for.</li>
</ol></li>
<li>Create a list of all the dict keys you want to grab from, in the same order as the headers in your CSV. For example <code>keys=["Id_Customer", "Segment", etc...]</code></li>
<li>Loop through the list you created in Steps 1 and 2. e.g. <code>for customer in customers:</code> For each iteration:

<ol>
<li>Loop through the list you created in Step 3. e.g. <code>for key in keys:</code></li>
<li>For each key, get the corresponding value from the dict, and add that value to your CSV output. Assuming you have an open file object called "csv", something like this would work: <code>csv.write(customer[key])</code> (Of course you'll want to write the comma to the file as well at this point, unless it's the last iteration of the <code>keys</code> loop, then write a newline instead. You can test that with <code>key == keys[-1]</code>)</li>
</ol></li>
</ol>
</div>
<span class="comment-copy">By 'empty' do you mean <code>None</code>?  Because there's no such thing as "empty". If you want your list to contain a placeholder, you have to decide what you want it to be - lists only contain objects, they don't know how to contain "nothing"</span>
<span class="comment-copy">This looked like a quick win but unfortunately it does not work. I replaced because it would bug :      cust.append(customer_id.text()) by     cust.append(customer_id.text)  But the remaining of the code only captures the customer_ID, but the other values are always set to the defaut value 'empty'.</span>
<span class="comment-copy">added .// in the list_prm.append(elem.findtext('.//xxxxxx', default='empty')) and it works ! Cheers !</span>
<span class="comment-copy">Sorry for the mistake. Sure, if you want everything in one list (no sublists per Customer), that  should work. I'm happy you got it to work.</span>
