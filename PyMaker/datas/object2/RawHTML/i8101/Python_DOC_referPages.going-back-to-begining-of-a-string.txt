<div class="post-text" itemprop="text">
<p>I am coding a Caesar cipher. The key is an integer from 1 to 25. This cipher rotates the letters of the alphabet (A to Z). The encoding replaces each letter
with the 1st to 25th next letter in the alphabet (wrapping Z to A). So key 2 encrypts “HI” to “JK”, but key 20 encrypts “HI” to “BC”.</p>
<p>But If I put in 
"I am super" it will output "k kc oouwrgt" when it should be "k co uwrgt" with a key of 2. It will also not go back to the beginning of the alphabet e.g 'x' will not go to 'a' with a key of 2. I use python 3.4.1</p>
<pre><code>encode = []
a = "abcdefghijklmnopqrstuvwyxz"
a = list(a)
print(a)

e = input("encode or decode ---&gt;")
text = input("Sentence --&gt;").lower()
text = list(text)
print(text)


Key = int(input("Key --&gt;"))
if Key &gt; 25:
    print("Too high")
else:
   print(Key)

if e == "encode":
    for i, item in enumerate(text):
        if item == " ":
            encode.append(letter)
        else:
            num = a.index(item)
            num = num + int(Key)
            letter = a[num]
            encode.append(letter)

for i in range(len(encode)):
    print(encode[i])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you encounter a space, you append the last letter again, instead of <code>item</code>:</p>
<pre><code>if item == " ":
    encode.append(letter)
</code></pre>
<p>This causes <code>k</code> and <code>o</code> to appear twice when the key is <code>2</code>; you re-appended the encoded <code>i</code> -&gt; <code>k</code> and <code>m</code> -&gt; <code>o</code> results.</p>
<p>You need to use the <a href="https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations" rel="nofollow noreferrer"><code>%</code> modulo operator</a> to make your index 'wrap round':</p>
<pre><code>num = (num + Key) % 26
</code></pre>
<p>I removed the <code>int()</code> call, you already turned <code>Key</code> to an integer earlier.</p>
<p>Other tips:</p>
<ul>
<li><p>You don't need to turn <code>a</code> into a list; strings are sequences too and support indexing and the <code>.index()</code>method directly. The same applies to <code>text</code>; just loop over the string itself.</p></li>
<li><p>You are not using <code>i</code> in the <code>for i, item in enumerate(text):</code> loop; drop <code>enumerate</code> altogether: <code>for item in text:</code>.</p></li>
<li><p>You <em>could</em> just print your encoded characters directly in that loop, no need to use an <code>encode</code> list and a separate loop.</p></li>
<li><p>The <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer"><code>str.join()</code> method</a> would let you print your encoded text all on one line:  <code>print(''.join(encode))</code> instead of your last <code>for</code> loop.</p></li>
<li><p>The absolute fastest method of encoding a string is to use a <em>translation table</em>, a dictionary mapping input characters to output characters, and the <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer"><code>str.translate()</code> method</a>. You can use the <a href="https://docs.python.org/3/library/stdtypes.html#str.maketrans" rel="nofollow noreferrer"><code>str.maketrans()</code> function</a> to make that table:</p>
<pre><code>import string

a = string.ascii_lowercase  # why type yourself when the stdlib has these?
text = input("Sentence --&gt;").lower()
Key = int(input("Key --&gt;"))
mapping = str.maketrans(a, a[Key:] + a[:Key])  # letters to rotated letters
print(text.translate(mapping))
</code></pre>
<p>The trick lies in creating the second string for <code>str.maketrans()</code>; using slicing it is easy to create a rotated string, by taking everything from position <code>Key</code> onwards, and the first <code>Key</code> characters at the end:</p>
<pre><code>&gt;&gt;&gt; a[Key:] + a[:Key]
'cdefghijklmnopqrstuvwyxzab'
</code></pre></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>One obvious solution would be to use <a href="https://stackoverflow.com/questions/4432208/how-does-work-in-python">modulo</a> for the alphabet index:</p>
<blockquote>
<p>The % (modulo) operator yields the remainder from the division of the
  first argument by the second.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; 12 % 26
12
&gt;&gt;&gt; 26 % 26
0
&gt;&gt;&gt; 28 % 26
2
</code></pre>
<p>As a bonus, you wouldn't need to check the key is lower than 25, and you'll never get an <code>IndexError: list index out of range</code>.</p>
<pre><code>encode = []
a = "abcdefghijklmnopqrstuvwyxz"

e = input("encode or decode ---&gt;")
text = input("Sentence --&gt;").lower()

key = int(input("Key --&gt;"))

if e == "encode":
    for i, item in enumerate(text):
        if item == " ":
            encode.append(item)
        else:
            num = a.index(item)
            num = num + int(key)
            letter = a[num % 26]
            encode.append(letter)

for letter in encode:
    print(letter)
</code></pre>
<p>A few notes:</p>
<ul>
<li>a string is already an iterable of characters. No need to convert it to a list</li>
<li><code>letter</code> wasn't defined in <code>if item == " "</code></li>
<li>to iterate over a list, you don't need the length or the index.</li>
<li>to decode the message, just change the sign of the key. It should work just like encode, thanks to modulo : <code>-2 % 26 # =&gt; 24</code></li>
</ul>
<p>As an example:</p>
<pre><code>encode or decode ---&gt;encode
Sentence --&gt;i am super
Key --&gt;2
k

c
o

u
w
r
g
t
</code></pre>
<p>and</p>
<pre><code>encode or decode ---&gt;encode
Sentence --&gt;k co uwrgt
Key --&gt;-2
i

a
m

s
u
p
e
r
</code></pre>
</div>
<span class="comment-copy"><code>a[Key:] + a[:Key]</code> is a cool trick, it also works with negative indices for decoding.</span>
<span class="comment-copy">@EricDuminil: or just use <code>str.translate(a[Key:] + a[:Key], a)</code>.</span>
<span class="comment-copy">This is great, thank you for taking the time to explain it :)</span>
<span class="comment-copy">@jennmaurice: Glad to have been of help! Feel free to <a href="http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work">accept my answer</a> if you feel it was useful to you. :-)</span>
