<div class="post-text" itemprop="text">
<p>Can someone explain modifying vs. overwriting object reference in an easy to understand way? Here is an example of what I mean:</p>
<p>By modifying an object reference:</p>
<pre><code>nested_list = [[]]*3
nested

result:
[[], [], []]
# now let me **modify** the object reference
nested[1].append('zzz')

result:
[['zzz'], ['zzz'], ['zzz']]
</code></pre>
<p>By overwriting an object reference:</p>
<pre><code>nested_list = [[]]*3
nested

result:
[[], [], []]
# now let me **modify** the object reference
nested[1] = ['zzz']

result:
[[], ['zzz'], []]
</code></pre>
<p>Does that mean when using "append" we are only modifying the object reference while using assigning values i.e.</p>
<pre><code>nested[1] = ['zzz']
</code></pre>
<p>we are overwriting the value and assigning nested[1] to a new object reference? Is it caused by the underlying difference between the "append" method and assigning values? If so what's the difference?</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's assign the name <code>x</code> to an empty list such that it is easier to reason about the code.</p>
<p>In your first example</p>
<pre><code>&gt;&gt;&gt; x = []
&gt;&gt;&gt; nested = [x]*3
&gt;&gt;&gt; nested
[[], [], []]
</code></pre>
<p>you are creating a list <code>nested</code> with three references to <code>x</code>. Here's proof:</p>
<pre><code>&gt;&gt;&gt; all(e is x for e in nested)
True
</code></pre>
<p>We only ever created one empty list <code>x</code>, that's why </p>
<pre><code>nested[0].append('zzz')
nested[1].append('zzz')
nested[2].append('zzz')
</code></pre>
<p>and</p>
<pre><code>x.append('zzz')
</code></pre>
<p>are all equivalent and appending <em>to the same list in memory</em>:</p>
<pre><code>&gt;&gt;&gt; nested[0].append('zzz')
&gt;&gt;&gt; nested
[['zzz'], ['zzz'], ['zzz']]
&gt;&gt;&gt; nested[1].append('zzz')
&gt;&gt;&gt; nested
[['zzz', 'zzz'], ['zzz', 'zzz'], ['zzz', 'zzz']]
&gt;&gt;&gt; nested[2].append('zzz')
&gt;&gt;&gt; nested
[['zzz', 'zzz', 'zzz'], ['zzz', 'zzz', 'zzz'], ['zzz', 'zzz', 'zzz']]
&gt;&gt;&gt; x.append('zzz')
&gt;&gt;&gt; nested
[['zzz', 'zzz', 'zzz', 'zzz'], ['zzz', 'zzz', 'zzz', 'zzz'], ['zzz', 'zzz', 'zzz', 'zzz']]
</code></pre>
<p>The second example is easy. You create a list <code>nested</code> which initially holds three references to the same empty list.</p>
<p>Then you <em>overwrite</em> what the second element of <code>nested</code> (i.e. <code>nested[1]</code>) refers to by issuesing </p>
<pre><code>&gt;&gt;&gt; x = []
&gt;&gt;&gt; nested = [x]*3
&gt;&gt;&gt; nested[1] = ['zzz']
&gt;&gt;&gt; nested
[[], ['zzz'], []]
</code></pre>
<p>The second element of <code>nested</code> is a new list that has nothing to do with the first and third element of <code>nested</code>.</p>
<pre><code>&gt;&gt;&gt; nested[0] is nested[1]
False
&gt;&gt;&gt; nested[2] is nested[1]
False
&gt;&gt;&gt; nested[0] is nested[2]
True
</code></pre>
<p>Since you did not modify what <code>nested[0]</code> and <code>nested[2]</code> reference, they are still holding the same empty list (which in our example also goes by the name <code>x</code>).</p>
<pre><code>&gt;&gt;&gt; x.append('x')
&gt;&gt;&gt; nested
[['x'], ['zzz'], ['x']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As I wrote in my comment, the <code>*</code> operator on <code>list</code>s just copies the references inside the list:</p>
<pre><code>nested_list = [[]] * 3
</code></pre>
<p>All three elements inside <code>nested_list</code> refer to the same list. This makes sense if you think about what the expression above really says. The evaluation really happen in the following order:</p>
<pre><code>nested_list = [[]]  # first create a list with an empty list.
nested_list = nested_list * 3  # duplicate the references to that empty list
</code></pre>
<p>To the second part of your question. If you replace the second element by a new list:</p>
<pre><code>nested_list[1] = ['zzz']
</code></pre>
<p>The first and third element are referring to the same empty list, but the one just assigned to (<code>['zzz']</code>) is a new list (with one element, <code>'zzz'</code>.)</p>
<p>E.g. if you do the following you will see that the first and third are still referring to the same list:</p>
<pre><code>nested_list[0].append('a')
print(nested_list)
# [['a'], ['zzz'], ['a']]
</code></pre>
<h1>Solution</h1>
<p>To create three distinct empty lists, which is probably what you want, you usually do something like (the following lines are equivalent):</p>
<pre><code>nested_lists = [[] for _ in range(3)]
nested_lists = [[], [], []]
</code></pre>
</div>
<span class="comment-copy">You're assigning to <code>nested_list</code>, but then printing <code>nested</code>. How are these related?</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/240178/list-of-lists-changes-reflected-across-sublists-unexpectedly" title="list of lists changes reflected across sublists unexpectedly">stackoverflow.com/questions/240178/…</a></span>
<span class="comment-copy">The <code>*</code> operator on <code>list</code>s copies the references inside it. So there are three references to the same (empty) mutable list, inside the outer list.</span>
<span class="comment-copy">Thanks for the response. But why does "appending" data to list change them all while assigning values overwrite one of the list instead of all?</span>
<span class="comment-copy">@thatMeow Hmm, I thought I made that crystal clear. Maybe read the answer again? You initially have a list <code>nested</code> which holds references <b>to the same empty list <code>x</code> in memory</b>. When you mutate <code>x</code> by appending to it, of course every reference to <code>x</code> in <code>nested</code> is going to see that change. There are only ever two lists in this case. <code>x</code> and <code>nested</code>. No more. In the second example, you do not mutate <code>x</code>. You create a <b>new</b> list <code>['zzz']</code> and then say that <code>nested[1]</code> must point to that new list. <code>nested[0]</code> and <code>nested[2]</code> still point to <code>x</code>.</span>
<span class="comment-copy">Ah got it, putting it this way make it easier for me to understand. Thanks!</span>
<span class="comment-copy">can you explain <code>[[] for _ in range(3)]</code> ? How is the <code>for</code> loop used here ?</span>
<span class="comment-copy">@IstiaqueAhmed Sure. It is called a list comprehension. Check this link: <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">docs.python.org/3/tutorial/…</a> . Does that answer your question?</span>
<span class="comment-copy">Understood the list comprehension concept</span>
