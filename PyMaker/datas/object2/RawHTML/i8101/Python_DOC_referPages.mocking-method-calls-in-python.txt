<div class="post-text" itemprop="text">
<p>I have been searching stack exchange and around the web for how to do this, but I cannot understand how to mock behaviors for methods. I am trying to mock openpyxl behaviors and behaviors for my custom class. Here is my attempt:</p>
<pre><code>import unittest
from unittest.mock import MagicMock
import openpyxl 
from MyPythonFile import MyClass

class TestMyClass(unittest.TestCase):
  def test_myclass(self):
    myclass = MyClass()
    wb = openpyxl.workbook()
    ws = openpyxl.worksheet()
    wbPath = 'wbPath'

    openpyxl.load_workbook(wbPath, data_only = True) = MagicMock(return_value=wb)
</code></pre>
<p>When I try the final line I get the error "can't assign to function call". Do I need to use <code>patch.object('openpyxl','load_workbook')</code>? I am used to mocking in Java with Groovy and it's pretty straightforward.</p>
<p>*Edit: wanted to add the finalized version of the test based on the response from @alxwrd </p>
<pre><code>import unittest
from unittest.mock import MagicMock
import openpyxl 
import configparser
from MyPythonFile import MyClass

class TestMyClass(unittest.TestCase):
  def test_myclass(self):
    myclass = MyClass()
    wb = openpyxl.workbook()
    ws = openpyxl.worksheet()
    config = configparser.ConfigParser()

    openpyxl.load_workbook = MagicMock(return_value=wb)
    wb.get_sheet_by_name = MagicMock(return_value=ws)

    config.sections() = MagicMock(return_value=['Section1'])
    config.get = MagicMock(side_effect=['Value1','Value2']) 
</code></pre>
<p>Notice that config.get gives multiple returns with the side_effect parameter, so if <code>config.get()</code> is called once in the code it returns <code>'Value1'</code> and when <code>config.get()</code> is called a second time it returns <code>'Value2'</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't override a function <em>call</em>, but you can override the function itself.</p>
<p>From the <a href="https://docs.python.org/3/library/unittest.mock.html#quick-guide" rel="noreferrer">docs</a>:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; from unittest.mock import MagicMock
&gt;&gt;&gt; thing = ProductionClass()
&gt;&gt;&gt; thing.method = MagicMock(return_value=3)
&gt;&gt;&gt; thing.method(3, 4, 5, key='value')
3
&gt;&gt;&gt; thing.method.assert_called_with(3, 4, 5, key='value')
</code></pre>
</blockquote>
<p>So in your case:</p>
<pre><code>openpyxl.load_workbook = MagicMock(return_value=wb)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't have to import the target you want to mock in your unit tests. Use <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer">patch</a> to mock the target. Let's assume your code has this import statement: <code>import openpyxl</code>. Patch then can be used in your test as a <a href="https://wiki.python.org/moin/PythonDecorators" rel="nofollow noreferrer">decorator</a>:</p>
<pre><code>import unittest
from unittest import mock
from MyPythonFile import MyClass

class TestMyClass(unittest.TestCase):

    @mock.patch('MyPythonFile.openpyxl')
    def test_myclass(self, openpyxl_mock):
        wb_dummy = 'foo'
        openpyxl_mock.load_workbook.return_value = wb_dummy

        myclass = MyClass()
        myclass.load_workbook()  # assuming this calls openpyxl.load_workbook()
</code></pre>
<p><em>Note that you have to add an argument to the test method which will get the mock object.</em></p>
<p>Or as a <a href="https://stackoverflow.com/questions/3012488/what-is-the-python-with-statement-designed-for">context manager</a>:</p>
<pre><code>import unittest
from unittest import mock
from MyPythonFile import MyClass

class TestMyClass(unittest.TestCase):

    def test_myclass(self):
        with mock.patch('MyPythonFile.openpyxl') as openpyxl_mock:
            wb_dummy = 'foo'
            openpyxl_mock.load_workbook.return_value = wb_dummy

            myclass = MyClass()
            myclass.load_workbook()  # assuming this calls openpyxl.load_workbook()
</code></pre>
</div>
<span class="comment-copy">Ok, great that works for the loading workbook, but what if I want to mock the same method but with different arguments and have it return different values? For example, if I mock <code>config = configparser.ConfigParser()</code> and then I want to mock <code>config.get('Section1','Value1') = MagicMock(return_value='val1')</code> and  <code>config.get('Section1','Value2') = MagicMock(return_value='val2')</code>?</span>
<span class="comment-copy">You can access what arguments were passed with <code>.call_args</code>, and update what is returned with <code>.return_value</code>.  <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.call_args" rel="nofollow noreferrer">docs.python.org/3/library/…</a> <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">Look up side_effect for a MagicMock object. You set it to a function, vs return_value which is set to an explicit value.  You can define the function with *args as argument and check it in the function body and return based on the args values.</span>
