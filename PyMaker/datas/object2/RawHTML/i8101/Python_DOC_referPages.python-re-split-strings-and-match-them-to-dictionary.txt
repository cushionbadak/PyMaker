<div class="post-text" itemprop="text">
<p>I have some datafile names already formed into strings of the following form:</p>
<pre><code>str = ('6m5.dat','10ext.dat','3m10.dat','3int.dat')
</code></pre>
<p>I want to extract the strings 'int', 'ext', 'm5' or 'm10' from it, to know which data I am working with. I saw it should be possible with a regular expression, which considers an unknown amount of numbers in the beginning and the '.dat' in the end. Someone can help?</p>
<p>Also afterwards I need to match the string with a list of numbers to multiply my values with:</p>
<pre><code>extblade = 5.44852e-5
intblade = 5.44852e-5
m3blade = 1.812e-5
m5blade = 2.25e-5
m10blade = 6e-5
</code></pre>
<p>E.g. when the string matches 'int' it should set x = 5.44852e-5.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the following pattern</p>
<pre><code>'\d+(\w+\d*)'
</code></pre>
<p>To match the string, first I'd add those values to a <code>dict</code></p>
<pre><code>d = {'extblade' : 5.44852e-5,
     'intblade' : 5.44852e-5,
     'm3blade' : 1.812e-5,
     'm5blade' : 2.25e-5,
     'm10blade' : 6e-5}
</code></pre>
<p>So to use your regex pattern</p>
<pre><code>&gt;&gt;&gt; [re.match('\d+(\w+\d*)', i).group(1) for i in s]
['m5', 'ext', 'm10', 'int']
</code></pre>
<p>Then to read the corresponding values from your <code>dict</code></p>
<pre><code>&gt;&gt;&gt; [d[re.match('\d+(\w+\d*)', i).group(1)+'blade'] for i in s]
[2.25e-05, 5.44852e-05, 6e-05, 5.44852e-05]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you didn't define explicitly what is the format of the files, it seems that the only correct solution is using the following pattern:</p>
<pre><code>regexp = r"((int)|(ext)|(m3)|(m5)|(m10))"
</code></pre>
<p>Then match the matched text to a value in a dictionary of blads:</p>
<pre><code>f = '6m5.dat','10ext.dat','3m10.dat','3int.dat'

d = {'ext' : 5.44852e-5,
     'int' : 5.44852e-5,
     'm3' : 1.812e-5,
     'm5' : 2.25e-5,
     'm10' : 6e-5,
    }

import re
rx = re.compile(regexp)
result = [ d[m.group(0)] if m else None for m in (rx.search(s) for s in f)]
</code></pre>
<h1>Output</h1>
<pre><code>[2.25e-05, 5.44852e-05, 6e-05, 5.44852e-05]
</code></pre>
<p>Trying to use a specific pattern for the file names might yield unknown matches that were not defined in the blades you mentioned.</p>
</div>
<span class="comment-copy">Better than my answer.</span>
<span class="comment-copy">He did not mention that this will be the format of the files. Just that they will include the words int, ext, etc...</span>
<span class="comment-copy">This solution works great. Thanks. Just out of curiosity: What effect does the '.group(1)' have? I did not exactly see how it works in the code.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/re.html#re.match" rel="nofollow noreferrer"><code>re.match</code></a> returns a <a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow noreferrer">match object</a> so you can get the actual matched string out by pulling out the group.</span>
<span class="comment-copy">As I wrote: I already have them as strings, so this is just a string matching. Therefore I did not specify the files (they are .txt files btw).</span>
<span class="comment-copy">This is slightly better than string matching since it is done in one pass instead of multiple passes for every string. Could you edit your post to show what is the exact input? Anyway, it is as good as any other regular expression solution (performance wise).</span>
<span class="comment-copy">Not sure what you mean exactly with input? I can agree to the fact that your solution might be computationally faster. My input is a list of strings (see 'str' in the post and my list of assigned values, which I put also in the post). The dictionary for my assigned values is definitely the more elegant input form for my values. The filenames are there as strings, as I take care of the files content at a different part of the code.</span>
<span class="comment-copy">OK. I might have misunderstood your first comment then. Notice that the accepted answer will not work if, for example, the file name is <code>test4-m5d.dat</code>. And will crash if the filename does not contain any of the accepted types.</span>
<span class="comment-copy">Ah ok, now I understand. Actually the full filename would be '20170506_5int.dat'. However as I split them before at the underscore to extract date I am sure that only the last part is left for me to work on. Probably there is the possibility to have a more elegant solution to extract all values (like date, filenumber and bladetype) at once. But as I only deal with some hundred files I am not really concerned about computational power here. Your solution would catch those too and might be superior to what I actually needed.</span>
