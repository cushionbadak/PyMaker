<div class="post-text" itemprop="text">
<p>I am new to python. I am trying to understand <code>super()</code> functionality in python multiple inheritance. </p>
<pre><code>class B():
    def __init__(self):
        print("__init__ of B called")
        self.b = "B"

class C():
    def __init__(self):
        print("__init__ of C called")
        self.c = "C"

class D(B, C):
    def __init__(self):
        print("__init__ of D called")
        super().__init__()

    def output(self):
        print(self.b, self.c)

d = D()
d.output()
</code></pre>
<p>I am getting the following error:</p>
<pre><code>AttributeError: 'D' object has no attribute 'c'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>super()</code> will find the <em>next method in the MRO sequence</em>. This means that only <em>one</em> of the <code>__init__</code> methods in your base classes is going to be called.</p>
<p>You can inspect the MRO (the <em>Method Resolution Order</em>)  by looking at the <a href="https://docs.python.org/3/library/stdtypes.html#class.__mro__" rel="nofollow noreferrer"><code>__mro__</code> attribute</a> of a class:</p>
<pre><code>&gt;&gt;&gt; D.__mro__
(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p>so from <code>D</code>, the next class is <code>B</code>, followed by <code>C</code> and <code>object</code>. From <code>D.__init__()</code>, the <code>super().__init__()</code> expression will only call <code>B.__init__()</code>, and then because <code>C.__init__()</code> is <em>never called</em>, <code>self.c</code> is not set either.</p>
<p>You'll have to add more <code>super()</code> calls to your class implementations; it is safe to call <code>object.__init__()</code> with no arguments, so just use them <em>everywhere</em> here:</p>
<pre><code>class B():
    def __init__(self):
        print("__init__ of B called")
        super().__init__()
        self.b = "B"

class C():
    def __init__(self):
        print("__init__ of C called")
        super().__init__()
        self.c = "C"

class D(B, C):
    def __init__(self):
        print("__init__ of D called")
        super().__init__()

    def output(self):
        print(self.b, self.c)
</code></pre>
<p>Now <code>B.__init__</code> will invoke <code>C.__init__</code>, and <code>C.__init__</code> will call <code>object.__init__</code>, and calling <code>D().output()</code> works:</p>
<pre><code>&gt;&gt;&gt; d = D()
__init__ of D called
__init__ of B called
__init__ of C called
&gt;&gt;&gt; d.output()
B C
</code></pre>
</div>
