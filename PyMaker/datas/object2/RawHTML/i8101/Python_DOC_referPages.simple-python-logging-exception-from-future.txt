<div class="post-text" itemprop="text">
<p>This should be a really simple question, but after googling, reading docs, and several other SO threads, I don't see the answer: How do I log an exception with Python standard logging? One small wrinkle is that I'm getting the exception from a Future. I'm not writing the <code>except</code> exception handler myself. Ideally, I would get the exception message, a stack trace, the extra message sent, and maybe the type of exception. Here's a simple program that shows my issue:</p>
<pre><code>import logging
from concurrent.futures import ThreadPoolExecutor

logger = logging.getLogger(__name__)


def test_f(a, b=-99, c=50):
    logger.info("test_f a={} b={} c={}".format(a, b, c))


def future_callback_error_logger(future):
    e = future.exception()
    if e is not None:
        # This log statement does not seem to do what I want.
        # It logs "Executor Exception" with no information about the exception.
        # I would like to see the exception type, message, and stack trace.
        logger.error("Executor Exception", exc_info=e)


def submit_with_log_on_error(executor, func, *args, **kwargs):
    future = executor.submit(func, *args, **kwargs)
    future.add_done_callback(future_callback_error_logger)


if __name__ == "__main__":
    logging.basicConfig(level="DEBUG")

    logger.info("start")
    executor = ThreadPoolExecutor(max_workers=5)

    # This will work.
    submit_with_log_on_error(executor, test_f, 10, c=20)
    # This will intentionally trigger an error due to too many arguments.
    # I would like that error to be properly logged.
    submit_with_log_on_error(executor, test_f, 10, 20, 30, 40)
    # This will work.
    submit_with_log_on_error(executor, test_f, 50, c=60)

    executor.shutdown(True)
    logger.info("shutdown")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To use <code>logger.exception</code> and get the traceback etc, you need to be inside an except block.  Instead of checking the <code>future.exception()</code>, which <em>returns</em> the exception (if any), use the <code>future.result()</code> which <em>raises</em> the exception (if any).  </p>
<p>So, <code>try</code> this instead (no pun intended):</p>
<pre><code>def future_callback_error_logger(future):
    try:
        future.result()
    except Exception:
        logger.exception("Executor Exception")
</code></pre>
</div>
<span class="comment-copy">Wow, that worked. Thanks!</span>
<span class="comment-copy">In the docs for <code>add_done_callback</code> <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.add_done_callback" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a> it says "if the callable raises an Exception subclass, it will be logged and ignored." I wondered what log level so googling led me here. Is your solution necessary if the exception is already being logged and ignored? confused</span>
<span class="comment-copy">That part of the docs is talking about any exception caused <i>by the callback itself</i> (say you wrote a buggy callback).   It's not talking about exceptions raised by worker code sent to the threadpool.  So, yes, still necessary!</span>
