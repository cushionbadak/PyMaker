<div class="post-text" itemprop="text">
<p>How do I specific a function can take a list of numbers which can be ints or floats? </p>
<p>I tried making a new type using Union like so:</p>
<pre><code>num = Union[int, float]

def quick_sort(arr: List[num]) -&gt; List[num]:
    ...
</code></pre>
<p>However, mypy didn't like this:</p>
<pre><code> quickSortLomutoFirst.py:32: error: Argument 1 to "quickSortOuter" has
 incompatible type List[int]; expected List[Union[int, float]]  
</code></pre>
<p>Is there a Type that encompasses ints and floats?</p>
</div>
<div class="post-text" itemprop="text">
<p>The short answer to your question is you should use either TypeVars or Sequence -- using <code>List[Union[int, float]]</code> would actually potentially introduce a bug into your code!</p>
<p>In short, the problem is that Lists are <em>invariant</em> according to the PEP 484 type system (and in many other typesystems -- e.g. Java, C#...). You're attempting to use that list as if it were <em>covariant</em> instead. You can learn more about covariance and invariance <a href="http://mypy.readthedocs.io/en/latest/generics.html#variance-of-generic-types" rel="noreferrer">here</a> and <a href="http://mypy.readthedocs.io/en/latest/common_issues.html#invariance-vs-covariance" rel="noreferrer">here</a>, but perhaps an example of why your code is potentially un-typesafe might be useful.</p>
<p>Consider the following code:</p>
<pre><code>from typing import Union, List

Num = Union[int, float]

def quick_sort(arr: List[Num]) -&gt; List[Num]:
    arr.append(3.14)  # We deliberately append a float
    return arr

foo = [1, 2, 3, 4]  # type: List[int]

quick_sort(foo)

# Danger!!!
# Previously, `foo` was of type List[int], but now
# it contains a float!? 
</code></pre>
<p>If this code were permitted to typecheck, we just broke our code! Any code that relies on <code>foo</code> being of exactly type <code>List[int]</code> would now break. </p>
<p>Or more precisely, even though <code>int</code> is a legitimate subtype of <code>Union[int, float]</code>, that doesn't mean that <code>List[int]</code> is a subtype of <code>List[Union[int, float]]</code>, or vice versa.</p>
<hr/>
<p>If we're ok with this behavior (we're ok with <code>quick_sort</code> deciding to inject arbitrary ints or floats into the input array), the fix is to manually annotate <code>foo</code> with <code>List[Union[int, float]]</code>:</p>
<pre><code>foo = [1, 2, 3, 4]  # type: List[Union[int, float]]

# Or, in Python 3.6+
foo: List[Union[int, float]] = [1, 2, 3, 4]
</code></pre>
<p>That is, declare up-front that <code>foo</code>, despite only containing ints, is also meant to contain floats as well. This prevents us from incorrectly using the list after <code>quick_sort</code> is called, sidestepping the issue altogether.</p>
<p>In some contexts, this may be what you want to do. For this method though, probably not.</p>
<hr/>
<p>If we're <em>not</em> ok with this behavior, and want <code>quick_sort</code> to preserve whatever types were originally in the list, two solutions come to mind:</p>
<p>The first is to use a <em>covariant</em> type instead of list -- for example, <a href="https://docs.python.org/3/library/typing.html#typing.Sequence" rel="noreferrer"><code>Sequence</code></a>:</p>
<pre><code>from typing import Union, Sequence

Num = Union[int, float]

def quick_sort(arr: Sequence[Num]) -&gt; Sequence[Num]:
    return arr
</code></pre>
<p>It turns out Sequence is more or less like List, except that it's immutable (or more precisely, Sequence's API doesn't contain any way of letting you mutate the list). This lets us safely sidestep the bug we had up above.</p>
<p>The second solution is to type your array more precisely, and insist that it <em>must</em> contain either all ints or all floats, disallowing a mixture of the two. We can do so using <a href="http://mypy.readthedocs.io/en/latest/generics.html#type-variables-with-value-restriction" rel="noreferrer">TypeVars with value restrictions</a>:</p>
<pre><code>from typing import Union, List, TypeVar 

# Note: The informal convention is to prefix all typevars with
# either 'T' or '_T' -- so 'TNum' or '_TNum'.
TNum = TypeVar('TNum', int, float)

def quick_sort(arr: List[TNum]) -&gt; List[TNum]:
    return arr

foo = [1, 2, 3, 4]  # type: List[int]
quick_sort(foo)

bar = [1.0, 2.0, 3.0, 4.0]  # type: List[float]
quick_sort(foo)
</code></pre>
<p>This will also prevent us from accidentally "mixing" types like we had up above.</p>
<p>I would recommend using the second approach -- it's a bit more precise, and will prevent you from losing information about the exact type a list contains as you pass it through your quicksort function.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://www.python.org/dev/peps/pep-0484/#id26" rel="nofollow noreferrer">PEP 484</a>, which proposed type hints:</p>
<blockquote>
<p>Rather than requiring that users write import numbers and then use <code>numbers.Float</code> etc., this PEP proposes a straightforward shortcut that is almost as effective: when an argument is annotated as having type <code>float</code>, an argument of type <code>int</code> is acceptable...</p>
</blockquote>
<p>Don't bother with the <code>Union</code>s. Just stick to <code>Sequence[float]</code>.</p>
<p>Edit: Thanks to Michael for catching the difference between <code>List</code> and <code>Sequence</code>.</p>
</div>
<span class="comment-copy">I tried that but mypy gives this error when I input a list of ints: quickSortLomutoFirst.py:32: error: Argument 1 to "quickSortOuter" has incompat ible type List[int]; expected List[float]</span>
<span class="comment-copy">@aryamccarthy -- this is a bit subtle, but it turns out mypy is actually correct and is preventing OP from accidentally introducing a bug into their code -- see my answer below for details.</span>
