<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/4025482/cant-escape-the-backslash-with-regex">Can't escape the backslash with regex?</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/24085680/why-do-backslashes-appear-twice">Why do backslashes appear twice?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I am confused with the backslash in regular expressions. Within a regex a <code>\</code> has a special meaning, e.g. <code>\d</code> means a decimal digit. If you add a backslash in front of the backslash this special meaning gets lost. In the <a href="https://docs.python.org/3/howto/regex.html#regex-howto" rel="noreferrer">regex-howto</a> one can read:</p>
<blockquote>
<p>Perhaps the most important metacharacter is the backslash, <code>\</code>. As in Python string literals, the backslash can be followed by various characters to signal various special sequences. It’s also used to escape all the metacharacters so you can still match them in patterns; for example, if you need to match a <code>[</code> or <code>\</code>, you can precede them with a backslash to remove their special meaning: <code>\[</code> or <code>\\</code>.</p>
</blockquote>
<p>So <code>print(re.search('\d', '\d'))</code> gives <code>None</code> because <code>\d</code> matches any decimal digit but there is none in <code>\d</code>.  </p>
<p>I now would expect <code>print(re.search('\\d', '\d'))</code> to match <code>\d</code> but the answer is still <code>None</code>.  </p>
<p>Only <code>print(re.search('\\\d', '\d'))</code> gives as output <code>&lt;_sre.SRE_Match object; span=(0, 2), match='\\d'&gt;</code>.</p>
<p>Does someone have an explanation?</p>
</div>
<div class="post-text" itemprop="text">
<p>The confusion is due to the fact that the backslash character <code>\</code> is used as an escape at two different levels.  First, the Python interpreter itself performs substitutions for <code>\</code> before the <code>re</code> module ever sees your string.  For instance, <code>\n</code> is converted to a newline character, <code>\t</code> is converted to a tab character, etc.  To get an actual <code>\</code> character, you can escape it as well, so <code>\\</code> gives a single <code>\</code> character.  If the character following the <code>\</code> isn't a recognized escape character, then the <code>\</code> is treated like any other character and passed through, but I don't recommend depending on this.  Instead, always escape your <code>\</code> characters by doubling them, i.e. <code>\\</code>.</p>
<p>If you want to see how Python is expanding your string escapes, just print out the string.  For example:</p>
<pre><code>s = 'a\\b\tc'
print s
</code></pre>
<p>If <code>s</code> is part of an aggregate data type, e.g. a list or a tuple, and if you print that aggregate, Python will enclose the string in single quotes and will include the <code>\</code> escapes (in a canonical form), so be aware of how your string is being printed.  If you just type a quoted string into the interpreter, it will also display it enclosed in quotes with '\' escapes.</p>
<p>Once you know how your string is being encoded, you can then think about what the <code>re</code> module will do with it.  For instance, if you want to escape <code>\</code> in a string you pass to the <code>re</code> module, you will need to pass <code>\\</code> to <code>re</code>, which means you will need to use <code>\\\\</code> in your quoted Python string.  The Python string will end up with <code>\\</code> and the <code>re</code> module will treat this as a single literal <code>\</code> character.</p>
<p>An alternative way to include <code>\</code> characters in Python strings is to use raw strings, e.g. <code>r'a\b'</code> is equivalent to <code>"a\\b"</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>An r character before the regular expression in a call to search() specifies that the regular expression is a raw string.  This allows backslashes to be used in the regular expression as regular characters rather than in an escape sequence of characters.  Let me explain ...</p>
<p>Before the re module's search method processes the strings that are passed to it, the Python interpreter takes an initial pass over the string.  If there are backslashes present in a string, the Python interpreter must decide if each is part of a Python escape sequence (e.g. \n or \t) or not.</p>
<p>Note:  at this point Python does not care whether or not '\' is a regular expression meta-character.</p>
<p>If the '\' is followed by a recognized Python escape character (t,n, etc.), then the backslash and the escape character are replaced with the actual Unicode or 8-bit character.  For example, '\t' would be replaced with the ASCII character for tab.  Otherwise it is passed by and interpreted as a '\' character.</p>
<p>Consider the following.</p>
<pre><code>&gt;&gt;&gt; s = '\t'
&gt;&gt;&gt; print ("[" + s  + "]")
&gt;&gt;&gt; [       ]           // an actual tab character after preprocessing

&gt;&gt;&gt; s = '\d'
&gt;&gt;&gt; print ("[" + s  + "]")
&gt;&gt;&gt; [\d]                // '\d' after preprocessing
</code></pre>
<p>Sometimes we want to include in a string a character sequence that includes '\' without it being interpreted by Python as an escape sequence.  To do this we escape the '\' with a '\'.   Now when Python sees '\' it replaces the two backslashes with a single '\' character.</p>
<pre><code>&gt;&gt;&gt; s = '\\t'
&gt;&gt;&gt; print ("[" + s  + "]")
&gt;&gt;&gt; [\t]                // '\t' after preprocessing
</code></pre>
<p>After the Python interpreter take a pass on both strings, they are passed to the re module's search method.  The search method parses the regular expression string to identify the regular expression's meta-characters.</p>
<p>Now '\' is also a special regular expression meta-character and is interpreted as one UNLESS it is escaped at the time that the re search() method is executed.</p>
<p>Consider the following call.</p>
<pre><code>&gt;&gt;&gt; match = re.search('a\\t','a\\t')        //Match is None
</code></pre>
<p>Here, match is None.  Why?  Lets look at the strings after the Python interpreter makes its pass.  </p>
<pre><code>String 1: 'a\t'
String 2: 'a\t' 
</code></pre>
<p>So why is match equal to None?  When search() interprets String 1, since it is a regular expression, the backslash is interpreted as a meta-character, not an ordinary character.  The backslash in String 2 however is not in a regular expression and has already been processed by the Python interpreter, so it is interpreted as an ordinary character.</p>
<p>So the search() method is looking for 'a escape-t' in the string 'a\t' which are not a match.</p>
<p>To fix this we can tell the search() method to not interpret the '\' as a meta-character.  We can do this by escaping it.</p>
<p>Consider the following call.</p>
<pre><code>&gt;&gt;&gt; match = re.search('a\\\\t','a\\t')          // Match contains 'a\t'
</code></pre>
<p>Again, lets look at the strings after the Python interpreter has made its pass.</p>
<pre><code>String 1: 'a\\t'
String 2: 'a\t'
</code></pre>
<p>Now when the search() method processes the regular expression, it sees that the second backslash is escaped by the first and should not be considered a meta-character.  It therefore interprets the string as 'a\t', which matches String 2.</p>
<p>An alternate way to have search() consider '\' as a character is to place an r before the regular expression.  This tells the Python interpreter to NOT preprocess the string.</p>
<p>Consider this.</p>
<pre><code>&gt;&gt;&gt; match = re.search(r'a\\t','a\\t')           // match contains 'a\t'
</code></pre>
<p>Here the Python interpreter does not modify the first string but does process the second string.  The strings passed to search() are:</p>
<pre><code>String 1: 'a\\t'
String 2: 'a\t'
</code></pre>
<p>As in the previous example, search interprets the '\' as the single character '\' and not a meta-character, thus matches with String 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's own string parsing (partially) comes in your way.</p>
<p>If you want to see what <code>re</code> sees, type</p>
<pre><code>print '\d'
print '\\d'
print '\\\d'
</code></pre>
<p>on the Python command prompt. You see that <code>\d</code> and <code>\\d</code> both result in <code>\d</code>, the latter one being taken care by the Python string parser.</p>
<p>If you want to avoid any hassle with these, use raw strings as suggested by the <a href="http://docs.python.org/2/library/re.html" rel="nofollow">re module documentation</a>: <code>r'\\d'</code> will result in <code>\\d</code> seen by the RE module.</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/24085680/why-do-backslashes-appear-twice" title="why do backslashes appear twice">stackoverflow.com/questions/24085680/…</a></span>
<span class="comment-copy">Thank's a lot for all answers.I was aware of the r'...' and also went through the documentation of re but I did not get the point. Now things are better. '\b' is special for the python interpreter because it finds a '\'. '\\b' overcomes the interpretation of the python interpreter ending up with a '\b' string. This is recognized by the re module to be shortcut for a decimal digit. '\\\b' also overcomes the interpretation of the re module and we end up with the string '\b'.</span>
<span class="comment-copy">Thank you! 4 backslashes, how nice. So there are no literal strings in python? I mean in PHP, for example, if you use single quotes then no substitutions are made.</span>
<span class="comment-copy">Very good point on unrecognised escape character, actually it will raise syntax error in future version of python, see <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow noreferrer">docs.python.org/3/reference/…</a></span>
<span class="comment-copy">@Rolf yes there is raw string literal for that purpose, see <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow noreferrer">docs.python.org/3/reference/…</a>  cheers</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/re.html" rel="nofollow noreferrer">docs.python.org/2/library/re.html</a> see the '\' section</span>
<span class="comment-copy">@Alex Thanks, added the link to the answer.</span>
