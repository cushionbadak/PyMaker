<div class="post-text" itemprop="text">
<p>I am in the process of shifting from Perl to Python, and I am struggling with what was a hash of hashes of arrays.
I have this data structure return from a REST service:</p>
<pre><code>[
    {
      "gene": "ENSG00000270076", 
      "minus_log10_p_value": 0.0271298550085406, 
      "tissue": "Thyroid", 
      "value": 0.939442373223424
    },
    {
      "gene": "ENSG00000104643", 
      "minus_log10_p_value": 0.255628260060896, 
      "tissue": "Thyroid", 
      "value": 0.555100655197016
    }
]
</code></pre>
<p>Speaking in Perl, I'd like to parse it and have the Python equivalent of</p>
<pre><code>${$tissue}{$value} = [$gene]
${Throid}{0.5555} = [ENSG1, ENSG2, ENSG3]
</code></pre>
<p>In Python I tried things along the line:</p>
<pre><code>d={}
d[hit['tissue']][hit['value']].append(hit[gene])
</code></pre>
<p>but encountered various errors.</p>
<p>In the end, I want <code>d</code> to look like:</p>
<pre><code>{
    'Thyroid': {
        0.939442373223424: ['ENSG00000270076'],
        0.555100655197016: ['ENSG00000104643']
    }
}
</code></pre>
<p>so grouping by tissue, then by value, and for each value have a list of genes.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use list comprehension to get output of your desired format!</p>
<pre><code>&gt;&gt;&gt; l = [{'minus_log10_p_value': 0.0271298550085406, 'gene': 'ENSG00000270076', 'tissue': 'Thyroid', 'value': 0.939442373223424}, {'minus_log10_p_value': 0.255628260060896, 'gene': 'ENSG00000104643', 'tissue': 'Thyroid', 'value': 0.555100655197016}]
&gt;&gt;&gt; for each in l:
...     if each['tissue'] not in res:
...             res[each['tissue']]={each['value']:each['gene']}
...     else:
...             res[each['tissue']][each['value']]=each['gene']
... 
&gt;&gt;&gt; res
{'Thyroid': {0.555100655197016: 'ENSG00000104643', 0.939442373223424: 'ENSG00000270076'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault()</code> method</a> to insert nested data structures for keys that are missing. Because that method returns either the already existing key, or the newly-inserted default value, you can <em>chain</em> these calls:</p>
<pre><code>d = {}
for hit in list_of_hits:
    tissue, value, gene = hit['tissue'], hit['value'], hit['gene']
    d.setdefault(tissue, {}).setdefault(value, []).append(gene)
</code></pre>
<p>So for each <code>d[tissue]</code> key, ensure that there is a nested dictionary. For each <code>d[tissue][value]</code> pair of keys, ensure that there is a nested list value, and append the gene to that.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; list_of_hits = [
...     {
...       "gene": "ENSG00000270076",
...       "minus_log10_p_value": 0.0271298550085406,
...       "tissue": "Thyroid",
...       "value": 0.939442373223424
...     },
...     {
...       "gene": "ENSG00000104643",
...       "minus_log10_p_value": 0.255628260060896,
...       "tissue": "Thyroid",
...       "value": 0.555100655197016
...     }
... ]
&gt;&gt;&gt; d = {}
&gt;&gt;&gt; for hit in list_of_hits:
...     tissue, value, gene = hit['tissue'], hit['value'], hit['gene']
...     d.setdefault(tissue, {}).setdefault(value, []).append(gene)
...
&gt;&gt;&gt; d
{'Thyroid': {0.939442373223424: ['ENSG00000270076'], 0.555100655197016: ['ENSG00000104643']}}
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(d)
{'Thyroid': {0.555100655197016: ['ENSG00000104643'],
             0.939442373223424: ['ENSG00000270076']}}
</code></pre>
<p>Do realise that floating point values can be imprecise. You may want to apply some <em>rounding</em> to normalise the values. <code>0.555100655197016</code> and <code>0.555100655197017</code> are very close together, for example, but <em>not equal</em>:</p>
<pre><code>&gt;&gt;&gt; 0.555100655197016 == 0.555100655197017
False
</code></pre>
<p>You could simply use the <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer"><code>round()</code> function</a> on <code>value</code>, to a number of digits that still makes sense for your application:</p>
<pre><code>d = {}
for hit in list_of_hits:
    tissue, value, gene = hit['tissue'], hit['value'], hit['gene']
    value = round(value, 4)
    d.setdefault(tissue, {}).setdefault(value, []).append(gene)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would personally use a mix of list comprehensions and default dicts, but I wanted to illustrate what the most simple / introductory approach would be as you're transitioning to Python:</p>
<pre><code>output = {}
for a_dict in results:
    tissue = a_dict['tissue']
    value = a_dict['value']
    gene = a_dict['gene']
    # the `tissue` is a nested dict
    if tissue not in output:
        output[tissue] = {}
    # the genes should be an array
    if value not in output[tissue]:
        output[tissue][value] = []
    output[tissue][value].append(gene)
</code></pre>
<p>the reason why this is so verbose (compared to a Perl approach) is that Perl has some conveniences built in for creating data structures of a certain type as needed. In Python you need to use either check for the presence of the correct datastore <strong>or</strong> use one (of several) approaches to a dict that has default values.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this will do the job. In fact you have almost done it</p>
<pre><code>from collections import defaultdict
d= defaultdict(lambda:defaultdict(list))
for value in values:
    d[value["tissue"]][value["value"]].append(value["gene"])
</code></pre>
</div>
<span class="comment-copy">No, <code>{'Thyroid': {0.555100655197016: 'ENSG00000104643', 0.939442373223424: 'ENSG00000270076'}}</code> is what OP is looking for. It states clearly isn't it..</span>
<span class="comment-copy">@KeerthanaPrabhakaran: yet we disagree on what they expect. No, that's not what they want, because they expect to have a list of values per gene, not using the values as keys.</span>
<span class="comment-copy">Not really. I understood it in the first go.</span>
<span class="comment-copy">OP has clearly included <code>${Throid}{0.5555} = [ENSG1, ENSG2, ENSG3]</code>. So its d[tissue][value]=gene is what is expected.</span>
<span class="comment-copy">@KeerthanaPrabhakaran: and they also included <i>conflicting information</i> in the same question.</span>
<span class="comment-copy">Please leave a comment when you down vote stating the reason! :)</span>
<span class="comment-copy">How is this going to produce a single nested dictionary? Whatever we may disagree with in the comments on the question, this is further removed from either format the OP is discussing.</span>
<span class="comment-copy">@MartijnPieters I'm sorry about that. shared the wrong code I've edited the answer!!</span>
<span class="comment-copy">That still doesn't produce lists in the nested dictionary.</span>
<span class="comment-copy">This is the approach that I suggest. Its upto OP to improvise it according to his need!</span>
