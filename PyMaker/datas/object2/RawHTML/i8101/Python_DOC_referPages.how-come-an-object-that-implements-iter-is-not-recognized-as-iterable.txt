<div class="post-text" itemprop="text">
<p>Let's say you work with a wrapper object:</p>
<pre><code>class IterOrNotIter:
    def __init__(self):
        self.f = open('/tmp/toto.txt')
    def __getattr__(self, item):
        try:
            return self.__getattribute__(item)
        except AttributeError:
            return self.f.__getattribute__(item)
</code></pre>
<p>This object implements <code>__iter__</code>, because it passes any call to it to its member <code>f</code>, which implements it. Case in point:</p>
<pre><code>&gt;&gt;&gt; x = IterOrNotIter()
&gt;&gt;&gt; x.__iter__().__next__()
'Whatever was in /tmp/toto.txt\n'
</code></pre>
<p>According to the documentation (<a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#iterator-types</a>), IterOrNotIter should thus be iterable.</p>
<p>However, the Python interpreter does not recognize an <code>IterOrNotIter</code> object as actually being iterable:</p>
<pre><code>&gt;&gt;&gt; x = IterOrNotIter()
&gt;&gt;&gt; for l in x:
...    print(l)
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'IterOrNotIter' object is not iterable
</code></pre>
<p>Whereas this works:</p>
<pre><code>&gt;&gt;&gt; x = IterOrNotIter()
&gt;&gt;&gt; for l in x.f:
...    print(l)
...
Whatever was in /tmp/toto.txt
</code></pre>
<p>I don't understand why.</p>
</div>
<div class="post-text" itemprop="text">
<p>Basically because your class just doesn't have a real <code>__iter__</code> method:</p>
<pre><code>&gt;&gt;&gt; hasattr(IterOrNotIter, '__iter__')
False
</code></pre>
<p>So it doesn't qualify as iterator because the actual check for <code>__iter__</code> checks for the existence instead of assuming it's implemented. So workarounds with <code>__getattr__</code> or <code>__getattribute__</code> (unfortunatly) don't work.</p>
<p>This is actually mentioned in the documentation for <a href="https://docs.python.org/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code></a>:</p>
<blockquote>
<h2>Note</h2>
<p>This method may still be bypassed when looking up special methods as the result of implicit invocation via language syntax or built-in functions. See <a href="https://docs.python.org/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer">Special method lookup</a>. </p>
</blockquote>
<p>The latter section also explains the <strong>why</strong>:</p>
<blockquote>
<p>Bypassing the <code>__getattribute__()</code> machinery in this fashion provides significant scope for speed optimisations within the interpreter, at the cost of some flexibility in the handling of special methods (<strong>the special method must be set on the class object itself in order to be consistently invoked by the interpreter</strong>).</p>
</blockquote>
<p>Emphasis mine.</p>
</div>
<span class="comment-copy">Well, that's a letdown. The fact that the interpreter checks instead of just calling feels unpythonic.</span>
<span class="comment-copy">@user589082 Yeah, it's a bit unpythonic but according to the documentation (I updated the answer) for <b>special methods</b> this makes Python significantly faster - at the cost of flexibility.</span>
