<div class="post-text" itemprop="text">
<p>I'm trying to create an enum that has integer values, but which can also return a display-friendly string for each value. I was thinking that I could just define a dict mapping values to strings and then implement <code>__str__</code> and a static constructor with a string argument, but there's a problem with that...</p>
<p>(Under different circumstances I could have just made the underlying data type for this Enum a string rather than an integer, but this is being used as a mapping for an enum database table, so both the integer value and the string are meaningful, the former being a primary key.)</p>
<pre><code>from enum import Enum

class Fingers(Enum):
    THUMB = 1
    INDEX = 2
    MIDDLE = 3
    RING = 4
    PINKY = 5

    _display_strings = {
        THUMB: "thumb",
        INDEX: "index",
        MIDDLE: "middle",
        RING: "ring",
        PINKY: "pinky"
        }

    def __str__(self):
        return self._display_strings[self.value]

    @classmethod
    def from_string(cls, str1):
        for val, str2 in cls._display_strings.items():
            if str1 == str2:
                return cls(val)
        raise ValueError(cls.__name__ + ' has no value matching "' + str1 + '"')
</code></pre>
<p>When converting to string, I get the following error:</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; str(Fingers.RING)
Traceback (most recent call last):
  File "&lt;pyshell#0&gt;", line 1, in &lt;module&gt;
    str(Fingers.RING)
  File "D:/src/Hacks/PythonEnums/fingers1.py", line 19, in __str__
    return self._display_strings[self.value]
TypeError: 'Fingers' object is not subscriptable
</code></pre>
<p>It seems that the issue is that an Enum will use all class variables as the enum values, which causes them to return objects of the Enum type, rather than their underlying type.</p>
<p>A few workarounds I can think of include:</p>
<ol>
<li>Referring to the dict as <code>Fingers._display_strings.value</code>. (However then <code>Fingers.__display_strings</code> becomes a valid enum value!)</li>
<li>Making the dict a module variable instead of a class variable.</li>
<li>Duplicating the dict (possibly also breaking it down into a series of <code>if</code> statements) in the <code>__str__</code> and <code>from_string</code> functions.</li>
<li>Rather than make the dict a class variable, define a static method <code>_get_display_strings</code> to return the dict, so it doesn't become an enum value.</li>
</ol>
<p>Note that the initial code above and workaround <code>1.</code> uses the underlying integer values as the dict keys. The other options all require that the dict (or <code>if</code> tests) are defined somewhere other than directly in the class itself, and so it must qualify these values with the class name. So you could only use, e.g., <code>Fingers.THUMB</code> to get an enum object, or <code>Fingers.THUMB.value</code> to get the underlying integer value, but not just <code>THUMB</code>. If using the underlying integer value as the dict key, then you must also use it to look up the dict, indexing it with, e.g., <code>[Fingers.THUMB.value]</code> rather than just <code>[Fingers.THUMB]</code>.</p>
<p>So, the question is, what is the best or most Pythonic way to implement a string mapping for an Enum, while preserving an underlying integer value?</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be done with the stdlib <code>Enum</code>, but is much easier with <a href="https://pypi.python.org/pypi/aenum" rel="noreferrer"><code>aenum</code></a><sup>1</sup>:</p>
<pre><code>from aenum import Enum

class Fingers(Enum):

    _init_ = 'value string'

    THUMB = 1, 'two thumbs'
    INDEX = 2, 'offset location'
    MIDDLE = 3, 'average is not median'
    RING = 4, 'round or finger'
    PINKY = 5, 'wee wee wee'

    def __str__(self):
        return self.string
</code></pre>
<p>If you want to be able to do look-ups via the string value then implement the new class method <code>_missing_value_</code>  (just <code>_missing_</code> in the stdlib):</p>
<pre><code>from aenum import Enum

class Fingers(Enum):

    _init_ = 'value string'

    THUMB = 1, 'two thumbs'
    INDEX = 2, 'offset location'
    MIDDLE = 3, 'average is not median'
    RING = 4, 'round or finger'
    PINKY = 5, 'wee wee wee'

    def __str__(self):
        return self.string

    @classmethod
    def _missing_value_(cls, value):
        for member in cls:
            if member.string == value:
                return member
</code></pre>
<hr/>
<p><sup>1</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="noreferrer">Advanced Enumeration (<code>aenum</code>)</a>  library.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe I am missing the point here, but if you define </p>
<pre><code>class Fingers(Enum):
    THUMB = 1
    INDEX = 2
    MIDDLE = 3
    RING = 4
    PINKY = 5
</code></pre>
<p>then in Python 3.6 you can do </p>
<pre><code>print (Fingers.THUMB.name.lower())
</code></pre>
<p>which I think is what you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another solution I came up with is, since both the integers and the strings are meaningful, was to make the Enum values <code>(int, str)</code> tuples, as follows.</p>
<pre><code>from enum import Enum

class Fingers(Enum):
    THUMB = (1, 'thumb')
    INDEX = (2, 'index')
    MIDDLE = (3, 'middle')
    RING = (4, 'ring')
    PINKY = (5, 'pinky')

    def __str__(self):
        return self.value[1]

    @classmethod
    def from_string(cls, s):
        for finger in cls:
            if finger.value[1] == s:
                return finger
        raise ValueError(cls.__name__ + ' has no value matching "' + s + '"')
</code></pre>
<p>However, this means that a <code>Fingers</code> object's repr will display the tuple rather than just the int, and the complete tuple must be used to create <code>Fingers</code> objects, not just the int. I.e. You can do <code>f = Fingers((1, 'thumb'))</code>, but not <code>f = Fingers(1)</code>.</p>
<pre><code>&gt;&gt;&gt; Fingers.THUMB
&lt;Fingers.THUMB: (1, 'thumb')&gt;
&gt;&gt;&gt; Fingers((1,'thumb'))
&lt;Fingers.THUMB: (1, 'thumb')&gt;
&gt;&gt;&gt; Fingers(1)
Traceback (most recent call last):
  File "&lt;pyshell#25&gt;", line 1, in &lt;module&gt;
    Fingers(1)
  File "C:\Python\Python35\lib\enum.py", line 241, in __call__
    return cls.__new__(cls, value)
  File "C:\Python\Python35\lib\enum.py", line 476, in __new__
    raise ValueError("%r is not a valid %s" % (value, cls.__name__))
ValueError: 1 is not a valid Fingers
</code></pre>
<p>An even more complex workaround for that involves subclassing <code>Enum</code>'s metaclass to implement a custom <code>__call__</code>. (At least overriding <code>__repr__</code> is much simpler!)</p>
<pre><code>from enum import Enum, EnumMeta

class IntStrTupleEnumMeta(EnumMeta):
    def __call__(cls, value, names=None, *args, **kwargs):
        if names is None and isinstance(value, int):
            for e in cls:
                if e.value[0] == value:
                    return e

        return super().__call__(value, names, **kwargs)

class IntStrTupleEnum(Enum, metaclass=IntStrTupleEnumMeta):
    pass

class Fingers(IntStrTupleEnum):
    THUMB = (1, 'thumb')
    INDEX = (2, 'index')
    MIDDLE = (3, 'middle')
    RING = (4, 'ring')
    PINKY = (5, 'pinky')

    def __str__(self):
        return self.value[1]

    @classmethod
    def from_string(cls, s):
        for finger in cls:
            if finger.value[1] == s:
                return finger
        raise ValueError(cls.__name__ + ' has no value matching "' + s + '"')

    def __repr__(self):
        return '&lt;%s.%s %s&gt;' % (self.__class__.__name__, self.name, self.value[0])
</code></pre>
<p>One difference between this implementation and a plain int Enum is that values with the same integer value but a different string (e.g. <code>INDEX = (2, 'index')</code> and <code>POINTER = (2, 'pointer')</code>) would not evaluate as the same <code>Finger</code> object, whereas with a plain int Enum, <code>Finger.POINTER is Finger.INDEX</code> would evaluate to <code>True</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>good question However, this means that a Fingers object's repr will display the tuple rather than just the int, and the complete tuple must be used to create Fingers objects, not just the int. I.e. You can do </p>
<pre><code>f = Fingers((1, 'thumb')) 
</code></pre>
<p>but not </p>
<pre><code>f = Fingers(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had same issue where I wanted display strings for a GUI ComboBox (in PyGTK).
I dun't know about the Pythonicity (is that even a word?) of the solution but I used this:</p>
<pre><code>from enum import IntEnum
class Finger(IntEnum):
    THUMB = 1
    INDEX = 2
    MIDDLE = 3
    RING = 4
    PINKY = 5

    @classmethod
    def names(cls):
        return ["Thumb", "Index", "Middle", "Ring", "Pinky"]

    @classmethod
    def tostr(cls, value):
        return cls.names()[value - cls.THUMB]

    @classmethod
    def toint(cls, s):
        return cls.names().index(s) + cls.THUMB
</code></pre>
<p>Using them from your code:</p>
<pre><code>&gt;&gt;&gt; print(Finger.INDEX)
Finger.INDEX
&gt;&gt;&gt; print(Finger.tostr(Finger.THUMB))
Thumb
&gt;&gt;&gt; print(Finger.toint("Ring"))
4
</code></pre>
</div>
<span class="comment-copy">Isn't using an enum to hold any meaningful data completely break the fundamental property of an enum?  That it's value is completely arbitrary?  If it's being used to form part of a key, it ceases to be an enum and be, well, part of a key, not an enum.</span>
<span class="comment-copy">@MikeyB you seem to be confusing the computer science concept of an <i>enumerated type</i> with the Python data type <code>enum.Enum</code>. The Python data type <i>does</i> allow the storage of meaningful data, as do similar "enum" types in the majority of other programming languages, and the use of this capability is a very common practice. If you dislike the association between the concept and the data type due to their similar naming, you could just read the title of the question as "a data type" rather than "an Enum".</span>
<span class="comment-copy">Thanks for this answer :). I was wondering, how are you supposed to use this missing value method? I mean, I can do <code>MyEnum._missing_value_("value")</code> but I'm not sure if that's the intended way of using it. Using <code>MyEnum['value']</code> raises an exception</span>
<span class="comment-copy">@TomDT:  The <code>Enum</code> machinery will automatically call <code>_missing_value_</code> when an unknown value is looked up.  You need to create your own <code>_missing_value_</code> method to provide any extra search functionality.  In the above example, the OP wanted to  use <code>Fingers('thumb')</code> to get <code>Fingers.THUMB</code>, which ordinarily wouldn't work since <code>Fingers.THUMB</code> is <code>1</code>.</span>
<span class="comment-copy">Oohhh I see, I was using the brackets [] to access it, but I was supposed to use the parens. Thank you !</span>
<span class="comment-copy">@Melvin:  Absolutely.  <code>Enum</code>s are meant to give names to constant values, whether those values are strings, integers, etc..</span>
<span class="comment-copy">@Edityouprofile: Without extra work, <code>Fingers.THUMB</code> is not <code>1</code> -- it is <code>(1, 'two thumbs')</code>.</span>
<span class="comment-copy">Well spotted, but that's just an accident in the example I have here. In my intended use the strings are longer and not just a lowercase version of the enum names!</span>
<span class="comment-copy">So I did miss the point.</span>
