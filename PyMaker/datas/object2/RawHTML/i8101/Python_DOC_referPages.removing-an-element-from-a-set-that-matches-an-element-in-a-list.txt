<div class="post-text" itemprop="text">
<p>I'm having trouble removing entries from a set.</p>
<pre><code># Remove all out-of-stock items from our list
# This is O(n^3), unfortunately.
for x in oos:
    for asin in asins:
        if x == asin[0]:
            del asin
</code></pre>
<p>'asins' is a set of tuples, created like this:</p>
<pre><code>asins.add(tuple((asin, c, s)))
</code></pre>
<p>oos is a list.  I'm trying to remove every entry in 'asins' that exists also in 'oos'.  Unfortunately, the "del asin" doesn't actually work, as it doesn't delete the entry from 'asins'.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this readily with a generator expression. It shouldn't be that inefficient, but I wouldn't call it efficient either.</p>
<pre><code>asins = {t for t in asins if t[0] not in set(oos)}
</code></pre>
<p>Note that this creates a <em>new</em> set. This is probably for the best as you cannot iterate over a set and change it in place. For example, changing <code>del asin</code> to <code>asins.remove(asin)</code> will raise a <code>RuntimeError</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>del asin</code> used like that will just delete the local variable <code>asin</code> but not the actually referenced object, and especially not the object that is contained in the set.</p>
<p>Instead, you would need to call <a href="https://docs.python.org/3/library/stdtypes.html#set.remove" rel="nofollow noreferrer"><code>set.remove</code></a> to remove the element:</p>
<pre><code>asins.remove(asin)
</code></pre>
<p>However, you don’t actually need to loop through the set to remove an item from it. The whole benefits of sets is that you have constant time access, so you can check membership in constant time, making looping over it rarely useful.</p>
<p>Since you’re storing complex tuples though, and you only identify an element by the first tuple element, you cannot do that here. What you should do is switch to a more appropriate collection. In your case, you want a dictionary:</p>
<pre><code># convert your set of tuples to a dictionary
# ideally, you would store the data like this in the first place
asins = { asin[0]: asin for asin in asins }
</code></pre>
<p>Then you can just do the following:</p>
<pre><code>for x in oos:
    del asins[x] # here, you can use del
</code></pre>
<p>That would be O(n) in the average case.</p>
</div>
<span class="comment-copy">This doesn't work if there are duplicate first elements that <i>aren't</i> going to be deleted. You'd need something like a <code>defaultdict</code> that builds lists using the first element as the key.</span>
<span class="comment-copy">If OP deletes items based solely on the first tuple value, then <i>all</i> those would be deleted anyway.</span>
<span class="comment-copy">I'm talking about that values that <i>aren't</i> going to be deleted. Duplicate keys are going to override the previous tuple.</span>
