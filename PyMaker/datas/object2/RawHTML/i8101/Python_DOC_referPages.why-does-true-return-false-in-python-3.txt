<div class="post-text" itemprop="text">
<p>I am learning python, but I'm a bit confused by the following result.</p>
<pre><code>In [41]: 1 == True
Out[41]: True

In [42]: if(1):
    ...:     print('111')
    ...:     
111

In [43]: ... == True
Out[43]: False &lt;===== why this is False while '1 == True' is True in previous sample

In [44]: if (...): &lt;==== here ... just behaves like True
    ...:     print('...')
    ...:     
...
</code></pre>
<p>According to <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="noreferrer">the documentation</a>, <code>...</code> has a truth value of True.</p>
<p>But I still feel the above code a bit inconsistent.</p>
<p>...And something more interesting:</p>
<pre><code>In [48]: 2==True
Out[48]: False &lt;===== why 1==True returns True while 2==True returns False?

In [49]: if(2):
    ...:     print('222')
    ...:     
222
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're mixing two concepts: equality testing and truth-value testing. They are not the same in Python.</p>
<p>I think what triggered the question is that Python <strong>does</strong> an implicit casting when you do <code>if something</code> (it casts the something to <code>bool</code>) but it <strong>does not</strong> do implicit casting when you do <code>something1 == something2</code>.</p>
<p>Pythons data model actually explains how these operations are done:</p>
<h3><a href="https://docs.python.org/library/stdtypes.html#truth-value-testing" rel="noreferrer">Truth-value testing</a></h3>
<ul>
<li>It starts by checking if the object implements the <code>__bool__</code> method and if it does it uses the returned boolean. </li>
<li>If it doesn't define a <code>__bool__</code> method it looks at the <code>__len__</code> method. If it's implemented it will use the result of <code>len(obj) != 0</code>. </li>
<li>If it doesn't have either the object is considered <code>True</code>.</li>
</ul>
<p>For integers the <a href="https://github.com/python/cpython/blob/v3.6.1/Objects/longobject.c#L4279-L4283" rel="noreferrer"><code>__bool__</code> method</a> returns <code>True</code> except when the integer value is <code>0</code> (then it's <code>False</code>).</p>
<p>The Ellipsis object (<a href="https://docs.python.org/library/constants.html#Ellipsis" rel="noreferrer"><code>...</code> is the Ellipsis object</a>) on the other hand <a href="https://github.com/python/cpython/blob/v3.6.1/Objects/sliceobject.c#L58-L59" rel="noreferrer">doesn't implement <code>__bool__</code> or <code>__len__</code></a> so it's always <code>True</code>.</p>
<h3><a href="https://docs.python.org/reference/datamodel.html#object.__eq__" rel="noreferrer">Equality testing</a></h3>
<p>Equality testing relies on the <code>__eq__</code> method of <strong>both</strong> arguments. It's more a chain of operations:</p>
<ul>
<li>It checks if the first operand implements <code>__eq__</code> when the second operand is passed as argument.</li>
<li>If it doesn't then it checks if the second operand implements <code>__eq__</code> when the first operand is passed as argument.</li>
<li>If it doesn't then Python checks for object identity (if they are the same object - similar to pointer comparisons in C-like languages)</li>
</ul>
<p>The order of these operations may vary.<sup>1</sup> </p>
<p>For built-in Python types these operations are explicitly implemented. For example <a href="https://github.com/python/cpython/blob/v3.6.1/Objects/longobject.c#L2914-L2950" rel="noreferrer"><code>int</code>egers implement <code>__eq__</code></a> but the <a href="https://github.com/python/cpython/blob/v3.6.1/Objects/longobject.c#L1413-L1417" rel="noreferrer"><code>CHECK_BINOP</code></a> makes sure that it returns <code>NotImplemented</code> if the other one isn't an <code>int</code>eger.</p>
<p>The <code>Ellipsis</code> object <a href="https://github.com/python/cpython/blob/v3.6.1/Objects/sliceobject.c#L71" rel="noreferrer">doesn't implement <code>__eq__</code></a> at all.</p>
<p>So when you compare integers and Ellipsis Python will always fallback to object identity and so it will always return <code>False</code>.</p>
<p>On the other hand <code>bool</code>eans are a subclass of <code>int</code>egers so they actually compare with <code>int</code> (they are another <code>int</code> after all). The booleans are implemented as <code>1</code> (<code>True</code>) and <code>0</code> (<code>False</code>). So they compare equal:</p>
<pre><code>&gt;&gt;&gt; 1 == True
True
&gt;&gt;&gt; 0 == False
True

&gt;&gt;&gt; 1 == False
False
&gt;&gt;&gt; 0 == True
False
</code></pre>
<hr/>
<p>Even though the source code is probably hard to understand I hope I explained the concepts well enough (the source code is for the CPython implementation, the implementation in other Python implementations like PyPy, IronPython may differ!). The important take-away message should be that Python doesn't do implicit conversions in equality checks and equality testing is not related to truth value testing at all. The built-in types are implemented that they almost always give senseable results:</p>
<ul>
<li>all number-types implement equality in some way (floats compare to integers, complex compare to integers and floats) </li>
<li>and everything not-zero and not-empty is <code>truthy</code>. </li>
</ul>
<p>However if you create your own classes you can override equality and truth value testing as you like (and then you can spread a lot of confusion)!</p>
<hr/>
<p><sup>1</sup> In some cases the order is changed:</p>
<ol>
<li>If the second operand is a subclass of the first operand the first two steps are reversed. </li>
<li>For some <strong>implicit equality checks</strong> the object identity is checked before any <code>__eq__</code> methods are called. For example when checking if some item is in a list, i.e. <code>1 in [1,2,3]</code>.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Any object can be tested for <a href="https://docs.python.org/library/stdtypes.html#truth-value-testing" rel="noreferrer">"truthiness"</a>:</p>
<blockquote>
<p>Any object can be tested for truth value, for use in an if or while condition or as operand of the Boolean operations below. The following values are considered false:</p>
<ul>
<li><p>None</p></li>
<li><p>False</p></li>
<li><p>zero of any numeric type, for example, 0, 0.0, 0j.</p></li>
<li><p>any empty sequence, for example, '', (), [].</p></li>
<li><p>any empty mapping, for example, {}.</p></li>
<li><p>instances of user-defined classes, if the class defines a <strong>bool</strong>() or <strong>len</strong>() method, when that method returns the integer zero or bool value False. [1]</p></li>
</ul>
<p>All other values are considered true â€” so objects of many types are always true.</p>
<p>Operations and built-in functions that have a Boolean result always return 0 or False for false and 1 or True for true, unless otherwise stated. (Important exception: the Boolean operations or and and always return one of their operands.)</p>
</blockquote>
<p>So it's not hard to see that <code>if ...</code> will enter the branch. The <code>Ellipsis</code> object is considered <code>true</code>. However that doesn't mean it has to be equal to <code>True</code>. Just the <code>bool(...) == True</code>!</p>
<p>The <code>if</code> will implicitly call <code>bool</code> on the condition, so:</p>
<pre><code>if ...:
    # something
</code></pre>
<p>will be evaluated as if you had written:</p>
<pre><code>if bool(...):
    # something
</code></pre>
<p>and:</p>
<pre><code>&gt;&gt;&gt; bool(...)
True
&gt;&gt;&gt; bool(1)
True
&gt;&gt;&gt; bool(2)
True
</code></pre>
<p>However there's one catch here. <code>True</code> is equal to <code>1</code> and <code>False</code> equal to <code>0</code>, but that's just because <code>bool</code> subclasses <code>int</code>eger in python.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python most (all?) objects have a <code>bool</code> value. The meaning behind "has a truth value of True" means that <code>bool(obj)</code> evaluates to True.</p>
<p>On the other hand, <code>True</code> is treated as <code>1</code> in many cases (and <code>False</code> as <code>0</code>) which you can see when you do stuff like:</p>
<pre><code>sum([True, True, False])
# (1 + 1 + 0) -&gt; 2
</code></pre>
<p>That is why you get <code>1 == True</code> --&gt; <code>True</code> </p>
<p>There is a more explicit <a href="https://docs.python.org/3/library/stdtypes.html#boolean-values" rel="nofollow noreferrer">explanation</a> in the documentation:</p>
<blockquote>
<p>Boolean values are the two constant objects False and True. They are used to represent truth values (although other values can also be considered false or true). <strong>In numeric contexts (for example when used as the argument to an arithmetic operator), they behave like the integers 0 and 1, respectively</strong></p>
</blockquote>
<p>From the <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow noreferrer">type-hierarchy</a> itself in the docs:</p>
<blockquote>
<p>These represent the truth values False and True. The two objects representing the values False and True are the only Boolean objects. The Boolean type is a subtype of the integer type, and <strong>Boolean values behave like the values 0 and 1, respectively, in almost all contexts</strong>, the exception being that when converted to a string, the strings "False" or "True" are returned, respectively.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I believe it's <code>1 == True</code> here is that's weird, not that <code>... != True</code>.</p>
<p><code>1</code> equals with <code>True</code> because in Python booleans are subclass of integers (because of <a href="https://www.python.org/dev/peps/pep-0285/" rel="nofollow noreferrer">PEP-285</a>). See yourself:</p>
<pre><code>&gt;&gt;&gt; issubclass(bool, int)
True
</code></pre>
</div>
<span class="comment-copy"><code>bool(...) == True</code> --&gt; <code>True</code></span>
<span class="comment-copy">FWIW, <code>bool(...)</code> returns <code>True</code></span>
<span class="comment-copy">@ReutSharabani Thanks but that still can't resolve my unrest about my experiment result.</span>
<span class="comment-copy">"Has a truth value of true" doesn't mean "== True".</span>
<span class="comment-copy">You are confusing <i>evaluating to <code>True</code></i> with <i>being equal to <code>True</code></i>. Python booleans are <code>ints</code>, <code>1 == True</code> and <code>0 == False</code>, but any(?) non-empty non-zero object evaluates to <code>True</code>, as you can see with <code>bool()</code></span>
<span class="comment-copy">@Claudio Well, that's kind of the point I was trying to make: The casting isn't implicit it has to be implemented <b>explicitly</b> in either operands <code>__eq__</code> method. And the built-in types don't do explicit casting, they hard-code the comparison between different types (or return <code>False</code> if incomparable). You might want to take a look at how complicated that get's for <a href="https://github.com/python/cpython/blob/3.6/Objects/floatobject.c#L328-L528" rel="nofollow noreferrer"><code>float == int</code></a>.</span>
<span class="comment-copy">Clearest answer, I upvoted. Interesting that although <code>if ...:</code> always gives the same output as <code>if bool(...):</code>, the CPython implementation seems different, at least from a quick comparison with <code>dis.dis()</code></span>
<span class="comment-copy">@Chris_Rands It's not identical because <code>if ...</code> will check the truth-value of <code>...</code> (which is True) in the other case it will first convert <code>...</code> to a boolean object (<code>True</code>) and then check the truth value of <code>True</code> (which is also <code>True</code>). But the result will be the same.</span>
<span class="comment-copy">How does it "check the truth-value" though? That doesn't involve some kind of boolean conversion but instead some kind of look-up?</span>
<span class="comment-copy">@Chris_Rands It either uses <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_IsTrue" rel="nofollow noreferrer"><code>PyObject_IsTrue</code></a> or <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_Not" rel="nofollow noreferrer"><code>PyObject_Not</code></a>. These will call the <code>__bool__</code> (and <code>__len__</code>) method or the C equivalents. <code>bool()</code> also uses the same special methods <i>but</i> besides checking for the truth value it will explicitly return a boolean object. So when you have <code>if bool(...)</code> you actually call <code>(...).__bool__().__bool__()</code> and with <code>if ...</code> you call <code>(...).__bool__()</code>. That's not 100% correct because we're dealing with C functions and types.</span>
<span class="comment-copy">Just a minor point: <code>hash</code>es don't matter when testing for equality (except in <code>dict</code> and <code>set</code>).</span>
<span class="comment-copy">Ah, right. I thought still matters a little because of CPython treats <code>small_ints</code> (-5...+257) specially, always allocating the same instance, but it seems that <code>1 is not True</code></span>
