<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3.7/whatsnew/3.7.html" rel="noreferrer">What’s New In Python 3.7</a>
 we can see that there is new <a href="https://docs.python.org/3.7/whatsnew/3.7.html#math" rel="noreferrer"><code>math.remainder</code></a>. It says </p>
<blockquote>
<p>Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference <code>x - n*y</code>, where n is the closest integer to the exact value of the quotient <code>x / y</code>. If <code>x / y</code> is exactly halfway between two consecutive integers, the nearest even integer is used for <code>n</code>. The remainder <code>r = remainder(x, y)</code> thus always satisfies <code>abs(r) &lt;= 0.5 * abs(y)</code>.</p>
<p>Special cases follow IEEE 754: in particular, <code>remainder(x, math.inf)</code> is x for any finite x, and <code>remainder(x, 0)</code> and <code>remainder(math.inf, x)</code> raise <code>ValueError</code> for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x.</p>
<p>On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced.</p>
</blockquote>
<p>But we also remember that there is <a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex" rel="noreferrer"><code>%</code></a> symbol which is </p>
<blockquote>
<p>remainder of <code>x / y</code></p>
</blockquote>
<p>We also see that there is a note to operator:</p>
<blockquote>
<p>Not for complex numbers. Instead convert to floats using <code>abs()</code> if appropriate.</p>
</blockquote>
<p>I haven't tried to run Python 3.7 if it's even possible.</p>
<p>But i tried </p>
<pre><code>Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import math
&gt;&gt;&gt; 100 % math.inf
100.0
&gt;&gt;&gt; math.inf % 100
nan
&gt;&gt;&gt; 100 % 0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: integer division or modulo by zero
</code></pre>
<p>So difference would be, instead of <code>nan</code> and <code>ZeroDivisionError</code> we would get <code>ValueError</code> as it says in docs.</p>
<p>So the question is what is the difference between <code>%</code> and <code>math.remainder</code>? Would <code>math.remainder</code> also work with complex numbers(<code>%</code> lacks from it)? What is the main advantage?</p>
<p>Here is the <a href="https://github.com/python/cpython/blob/master/Modules/mathmodule.c#L608-L696" rel="noreferrer"><strong>source</strong> of <code>math.remainder</code></a> from official CPython github repo.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Return the IEEE 754-style remainder of x with respect to y. For finite
  x and finite nonzero y, this is the difference <code>x - n*y</code>, where n is the
  closest integer to the exact value of the quotient <code>x / y</code>. If <code>x / y</code> is
  exactly halfway between two consecutive integers, the nearest even
  integer is used for n. The remainder <code>r = remainder(x, y)</code> thus always
  satisfies <code>abs(r) &lt;= 0.5 * abs(y)</code>.</p>
</blockquote>
<p>for the modulo this is <code>m = x - n*y</code> where <code>n</code> is the <code>floor(x/y)</code>, so <code>0 &lt;= m &lt; y</code> instead of <code>abs(r) &lt;= 0.5 * abs(y)</code> for the remainder.</p>
<p>so</p>
<pre><code>modulo(2.7, 1) = 0.7
remainder(2.7, 1) = -0.3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to @MaartenFabré, I wasn't being attentive to details: </p>
<blockquote>
<h3><code>math.remainder()</code> is the difference <code>x - n*y</code>, where <code>n</code> is the closest integer to the exact value of the quotient <code>x / y</code></h3>
</blockquote>
<p>I built Python 3.7:</p>
<pre><code>Python 3.7.0a0 (heads/master:f34c685020, May  8 2017, 15:35:30)
[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import math
</code></pre>
<p>And here are differences:</p>
<p>Zero as divisor:</p>
<pre><code>&gt;&gt;&gt; math.remainder(1, 0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: math domain error
&gt;&gt;&gt; 1 % 0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: integer division or modulo by zero
</code></pre>
<p>Basic numbers, where <code>math.remainder(x, y) &lt; x % y</code></p>
<pre><code>&gt;&gt;&gt; math.remainder(5, 3)
-1.0
&gt;&gt;&gt; 5 % 3
2
</code></pre>
<p>Complex numbers:</p>
<pre><code>&gt;&gt;&gt; math.remainder(3j + 2, 4)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't convert complex to float
&gt;&gt;&gt; (3j + 2) % 4
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't mod complex numbers.
</code></pre>
<p>Infinity(<code>math.inf</code>)</p>
<pre><code>&gt;&gt;&gt; math.remainder(3, math.inf)
3.0
&gt;&gt;&gt; 3 % math.inf
3.0
&gt;&gt;&gt; math.remainder(math.inf, 3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: math domain error
&gt;&gt;&gt; math.inf % 3
nan
</code></pre>
</div>
<span class="comment-copy">Actually it's <code>-0.3</code> for <code>remainder(2.7, 1)</code>.</span>
