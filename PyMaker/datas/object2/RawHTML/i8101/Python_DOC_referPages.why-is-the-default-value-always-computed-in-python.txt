<div class="post-text" itemprop="text">
<p>Let's say I have a dictionary <code>d</code> that has either a key 0 or a key 1. I want to assign to <code>x</code> the value <code>d[0]</code> if it exists and <code>d[1]</code> otherwise. I also want to destroy key 0 if it exists. I would write:</p>
<pre><code>    x = d.pop(0,d[1])
</code></pre>
<p>But then running this for <code>d = {0:'a'}</code> raises an error.</p>
<p>Similarly, let's say I have a function that takes a keyword argument <code>x</code>. If <code>x</code> is computed already, then I want to use the value that is given. Otherwise, I need to compute it.</p>
<pre><code>    import time
    def long_calculation():
        time.sleep(10)
        return 'waited'

    def func(**kwargs):
        x = kwargs.pop('x',long_calculation())
        return x
</code></pre>
<p>Running <code>f(x='test')</code> takes 10 seconds.</p>
<p>I could do something like </p>
<pre><code>    x = kwargs.pop('x',None)
    if x is None:
        x = long_calculation()
</code></pre>
<p>but this is a bit cumbersome. Do you have any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>For caching function results, have a look at <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer">functools.lru_cache</a>. Example: </p>
<pre><code>from functools import lru_cache
@lru_cache(maxsize=32)
def long_calculation():
    time.sleep(10)
    return 'waited'
</code></pre>
<p>The second call returns the cached value:</p>
<pre><code>print(long_calculation()) # 10 seconds
print(long_calculation()) # instant
</code></pre>
<p>If you just want to short circuit <code>dict.pop()</code> I think it's more straight forward to just put it in nested <code>try</code> blocks. Like: </p>
<pre><code>try: 
    d.pop(0)
except KeyError:
    try:
        d[1]
    except KeyError:
        &lt;expensive value&gt;
</code></pre>
</div>
<span class="comment-copy"><i>"Why is it always computed?"</i> - Because it's a regular value passed into a regular function; you would expect <code>baz</code> to be evaluated in <code>foo(bar, baz)</code> before the function is called, right?</span>
<span class="comment-copy">I don't understand. What value would you expect to get by doing <code>d[1]</code> when <code>1</code> does not appear in <code>d.keys()</code>...? If you want a default value, then  you need to specify it- like <code>x = pop(0,d.get(1,&lt;default&gt;))</code></span>
<span class="comment-copy">possible dupe of <a href="http://stackoverflow.com/questions/10747751/how-to-pass-lazy-variables-to-a-functions-parameters-without-them-being-evaluate" title="how to pass lazy variables to a functions parameters without them being evaluate">stackoverflow.com/questions/10747751/â€¦</a> ?</span>
<span class="comment-copy">@deceze Absolutely! I just thought there could be some kind of lazy evaluation implemented in pop. Any idea how to circumvent it?</span>
<span class="comment-copy">As for the second problem: you can just cache the calculation. Have a look at <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer"><code>functools.lru_cache</code></a>.</span>
