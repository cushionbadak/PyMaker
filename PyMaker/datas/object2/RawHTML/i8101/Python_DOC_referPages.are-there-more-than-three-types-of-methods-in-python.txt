<div class="post-text" itemprop="text">
<p>I understand there are at least 3 kinds of methods in Python having different first arguments:</p>
<ol>
<li>instance method - instance, i.e. <code>self</code></li>
<li>class method - class, i.e. <code>cls</code></li>
<li>static method - nothing</li>
</ol>
<p>These classic methods are implemented in the <code>Test</code> class below including an usual method:</p>
<pre><code>class Test():

    def __init__(self):
        pass

    def instance_mthd(self):
        print("Instance method.")

    @classmethod
    def class_mthd(cls):
        print("Class method.")

    @staticmethod
    def static_mthd():
        print("Static method.")

    def unknown_mthd():
        # No decoration --&gt; instance method, but
        # No self (or cls) --&gt; static method, so ... (?)
        print("Unknown method.")
</code></pre>
<p>In Python 3, the <code>unknown_mthd</code> can be called safely, yet it raises an error in Python 2: </p>
<pre><code>&gt;&gt;&gt; t = Test()

&gt;&gt;&gt; # Python 3
&gt;&gt;&gt; t.instance_mthd()
&gt;&gt;&gt; Test.class_mthd()
&gt;&gt;&gt; t.static_mthd()
&gt;&gt;&gt; Test.unknown_mthd()

Instance method.
Class method.
Static method.
Unknown method.

&gt;&gt;&gt; # Python 2
&gt;&gt;&gt; Test.unknown_mthd()    
TypeError: unbound method unknown_mthd() must be called with Test instance as first argument (got nothing instead)
</code></pre>
<p>This error suggests such a method was not intended in Python 2.  Perhaps its allowance now is due to the elimination of unbound methods in Python 3 (REF 001). Moreover, <code>unknown_mthd</code> does not accept args, and it can be <s>bound to</s> called by a class like a staticmethod, <code>Test.unknown_mthd()</code>.  However, it is not an explicit staticmethod (no decorator).</p>
<p>Questions</p>
<ol>
<li>Was making a method this way (without args while not explicitly decorated as staticmethods) intentional in Python 3's design?  UPDATED</li>
<li>Among the classic method types, what type of method is <code>unknown_mthd</code>?</li>
<li>Why can <code>unknown_mthd</code> be called by the class without passing an argument?</li>
</ol>
<hr/>
<p>Some preliminary inspection yields inconclusive results:</p>
<pre><code>&gt;&gt;&gt; # Types
&gt;&gt;&gt; print("i", type(t.instance_mthd))
&gt;&gt;&gt; print("c", type(Test.class_mthd))
&gt;&gt;&gt; print("s", type(t.static_mthd))
&gt;&gt;&gt; print("u", type(Test.unknown_mthd))                             
&gt;&gt;&gt; print()

&gt;&gt;&gt; # __dict__ Types, REF 002
&gt;&gt;&gt; print("i", type(t.__class__.__dict__["instance_mthd"]))
&gt;&gt;&gt; print("c", type(t.__class__.__dict__["class_mthd"]))
&gt;&gt;&gt; print("s", type(t.__class__.__dict__["static_mthd"]))
&gt;&gt;&gt; print("u", type(t.__class__.__dict__["unknown_mthd"]))          
&gt;&gt;&gt; print()

i &lt;class 'method'&gt;
c &lt;class 'method'&gt;
s &lt;class 'function'&gt;
u &lt;class 'function'&gt;

i &lt;class 'function'&gt;
c &lt;class 'classmethod'&gt;
s &lt;class 'staticmethod'&gt;
u &lt;class 'function'&gt;
</code></pre>
<p>The first set of type inspections suggests <code>unknown_mthd</code> is something similar to a staticmethod. The second suggests it resembles an instance method.  I'm not sure what this method is or why it should be used over the classic ones.  I would appreciate some advice on how to inspect and understand it better.  Thanks.</p>
<ul>
<li>REF 001: <a href="https://docs.python.org/3.0/whatsnew/3.0.html#operators-and-special-methods" rel="nofollow noreferrer">What's New in Python 3: “unbound methods” has been removed</a> </li>
<li>REF 002: <a href="https://stackoverflow.com/questions/19947151/how-to-distinguish-an-instance-method-a-class-method-a-static-method-or-a-func">How to distinguish an instance method, a class method, a static method or a function in Python 3?</a></li>
<li>REF 003: <a href="https://stackoverflow.com/questions/40834145/whats-the-point-of-staticmethod-in-python/40834179#40834179">What's the point of @staticmethod in Python?</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Some background: In Python 2, "regular" instance methods could give rise to two kinds of method objects, depending on whether you accessed them via an instance or the class.  If you did <code>inst.meth</code> (where <code>inst</code> is an instance of the class), you got a bound method object, which keeps track of which instance it is attached to, and passes it as <code>self</code>.  If you did <code>Class.meth</code> (where <code>Class</code> is the class), you got an unbound method object, which had no fixed value of <code>self</code>, but still did a check to make sure a <code>self</code> of the appropriate class was passed when you called it.</p>
<p>In Python 3, unbound methods were removed.  Doing <code>Class.meth</code> now just gives you the "plain" function object, with no argument checking at all.</p>
<blockquote>
<p>Was making a method this way intentional in Python 3's design?</p>
</blockquote>
<p>If you mean, was removal of unbound methods intentional, the answer is yes.  You can see discussion from Guido <a href="https://mail.python.org/pipermail/python-dev/2005-January/050625.html" rel="nofollow noreferrer">on the mailing list</a>.  Basically it was decided that unbound methods add complexity for little gain.</p>
<blockquote>
<p>Among the classic method types, what type of method is unknown_mthd?</p>
</blockquote>
<p>It is an instance method, but a broken one.  When you access it, a bound method object is created, but since it accepts no arguments, it's unable to accept the <code>self</code> argument and can't be successfully called.</p>
<blockquote>
<p>Why can unknown_mthd be called by the class without passing an argument?</p>
</blockquote>
<p>In Python 3, unbound methods were removed, so <code>Test.unkown_mthd</code> is just a plain function.  No wrapping takes place to handle the <code>self</code> argument, so you can call it as a plain function that accepts no arguments.  In Python 2, <code>Test.unknown_mthd</code> is an unbound method object, which has a check that enforces passing a <code>self</code> argument of the appropriate class; since, again, the method accepts no arguments, this check fails.</p>
</div>
<div class="post-text" itemprop="text">
<p>@BrenBarn did a great job answering your question. This answer however, adds a plethora of details: </p>
<p>First of all, this change in bound and unbound method is version-specific, and it doesn't relate to new-style or classic classes:</p>
<p>2.X classic classes by default</p>
<pre><code>&gt;&gt;&gt; class A:
...     def meth(self): pass
... 
&gt;&gt;&gt; A.meth
&lt;unbound method A.meth&gt;

&gt;&gt;&gt; class A(object):
...     def meth(self): pass
... 
&gt;&gt;&gt; A.meth
&lt;unbound method A.meth&gt;
</code></pre>
<p>3.X new-style classes by default </p>
<pre><code>&gt;&gt;&gt; class A:
...     def meth(self): pass
... 
&gt;&gt;&gt; A.meth
&lt;function A.meth at 0x7efd07ea0a60&gt;
</code></pre>
<p>You've already mentioned this in your question, it doesn't hurt to mention it twice as a reminder. </p>
<hr/>
<pre><code>&gt;&gt;&gt; # Python 2
&gt;&gt;&gt; Test.unknown_mthd()    
TypeError: unbound method unknown_mthd() must be called with Test instance as first argument (got nothing instead)
</code></pre>
<blockquote>
<p>Moreover, <code>unknown_mthd</code> does not accept args, and it can be bound to a class like a <code>staticmethod</code>, <code>Test.unknown_mthd()</code>. However, it is not an explicit <code>staticmethod</code> (no decorator)</p>
</blockquote>
<p><code>unknown_meth</code> doesn't accept args, normally because you've defined the function without so that it does not take any parameter. Be careful and cautious, static methods as well as your coded <code>unknown_meth</code> method will not be magically bound to a class when you reference them through the class name (e.g, <code>Test.unknown_meth</code>). Under Python 3.X <code>Test.unknow_meth</code> returns a simple function object in 3.X, not a method bound to a class.  </p>
<blockquote>
<p>1 - Was making a method this way (without args while not explicitly decorated as staticmethods) intentional in Python 3's design? UPDATED</p>
</blockquote>
<p>I cannot speak for CPython developers nor do I claim to be their representative, but from my experience as a Python programmer, it seems like they wanted to get rid of a bad restriction, especially given the fact that Python is extremely dynamic, not a language of restrictions; why would you test the type of objects passed to class methods and hence restrict the method to specific instances of classes? Type testing eliminates polymorphism. It would be decent if you just return a simple function when a method is fetched through the class which functionally behaves like a static method, you can think of <code>unknown_meth</code> to be static method under 3.X so long as you're careful not to fetch it through an instance of <code>Test</code> you're good to go. </p>
<blockquote>
<p>2- Among the classic method types, what type of method is <code>unknown_mthd</code>?</p>
</blockquote>
<p>Under 3.X: </p>
<pre><code>&gt;&gt;&gt; from types import *
&gt;&gt;&gt; class Test:
...     def unknown_mthd(): pass
... 
&gt;&gt;&gt; type(Test.unknown_mthd) is FunctionType 
True
</code></pre>
<p>It's simply a function in 3.X as you could see. Continuing the previous session under 2.X:</p>
<pre><code>&gt;&gt;&gt; type(Test.__dict__['unknown_mthd']) is FunctionType
True
&gt;&gt;&gt; type(Test.unknown_mthd) is MethodType
True
</code></pre>
<p><code>unknown_mthd</code> is a simple function that lives inside <code>Test__dict__</code>, really just a simple function which lives inside the namespace dictionary of <code>Test</code>. Then, when does it become an instance of <code>MethodType</code>? Well, it becomes an instance of <code>MethodType</code> when you fetch the method attribute either from the class itself which returns an <em>unbound</em> method or its instances which returns a <em>bound method</em>. In 3.X, <code>Test.unknown_mthd</code> is a simple function--instance of <code>FunctionType</code>, and <code>Test().unknown_mthd</code> is an instance of <code>MethodType</code> that retains the original instance of class <code>Test</code> and adds it as the first argument implicitly on function calls. </p>
<blockquote>
<p>3- Why can <code>unknown_mthd</code> be called by the class without passing an argument?</p>
</blockquote>
<p>Again, because <code>Test.unknown_mthd</code> is just a simple function under 3.X. Whereas in 2.X, <code>unknown_mthd</code> not a simple function and must be called be passed an instance of <code>Test</code> when called. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Are there more than three types of methods in Python?</p>
</blockquote>
<p><strong>Yes</strong>. There are the three built-in kinds that you mention (instance method, class method, static method), four if you count <code>@property</code>, and anyone can define new method types.</p>
<p>Once you understand the mechanism for doing this, it's easy to explain why <code>unknown_mthd</code> is callable from the class in Python 3.</p>
<h1>A new kind of method</h1>
<p>Suppose we wanted to create a new type of method, call it <code>optionalselfmethod</code> so that we could do something like this:</p>
<pre><code>class Test(object):
    @optionalselfmethod
    def optionalself_mthd(self, *args):
        print('Optional-Self Method:', self, *args)
</code></pre>
<p>The usage is like this:</p>
<pre><code>In [3]: Test.optionalself_mthd(1, 2)
Optional-Self Method: None 1 2

In [4]: x = Test()

In [5]: x.optionalself_mthd(1, 2)
Optional-Self Method: &lt;test.Test object at 0x7fe80049d748&gt; 1 2

In [6]: Test.instance_mthd(1, 2)
Instance method: 1 2
</code></pre>
<p><code>optionalselfmethod</code> works like a normal instance method when called on an instance, but when called on the class, it always receives <code>None</code> for the first parameter. If it were a normal instance method, you would always have to pass an explicit value for the <code>self</code> parameter in order for it to work.</p>
<p>So how does this work? How you can you create a new method type like this?</p>
<h1>The Descriptor Protocol</h1>
<p>When Python looks up a field of an instance, i.e. when you do <code>x.whatever</code>, it check in several places. It checks the instance's <code>__dict__</code> of course, but it also checks the <code>__dict__</code> of the object's class, and base classes thereof. In the instance dict, Python is just looking for the value, so if <code>x.__dict__['whatever']</code> exists, that's the value. However, in the class dict, Python is looking for an object which implements <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">the Descriptor Protocol</a>.</p>
<p>The Descriptor Protocol is how all three built-in kinds of methods work, it's how <code>@property</code> works, and it's how our special <code>optionalselfmethod</code> will work.</p>
<p>Basically, if the class dict has a value with the correct name<sup>1</sup>, Python checks if it has an <code>__get__</code> method, and calls it like <code>type(x).whatever.__get__(x, type(x))</code> Then, the value returned from <code>__get__</code> is used as the field value.</p>
<p>So for example, a trivial descriptor which always returns 3:</p>
<pre><code>class GetExample:
    def __get__(self, instance, cls):
        print("__get__", instance, cls)
        return 3

class Test:
   get_test = GetExample()
</code></pre>
<p>Usage is like this:</p>
<pre><code>In[22]: x = Test()

In[23]: x.get_test
__get__ &lt;__main__.Test object at 0x7fe8003fc470&gt; &lt;class '__main__.Test'&gt;
Out[23]: 3
</code></pre>
<p>Notice that the descriptor is called with both the instance and the class type. It can also be used on the class:</p>
<pre><code>In [29]: Test.get_test
__get__ None &lt;class '__main__.Test'&gt;
Out[29]: 3
</code></pre>
<p>When a descriptor is used on a class rather than an instance, the <code>__get__</code> method gets None for self, but still gets the class argument.</p>
<p>This allows a simple implementation of methods: functions simply implement the descriptor protocol. When you call <code>__get__</code> on a function, it returns a bound method of instance. If the instance is <code>None</code>, it returns the original function. You can actually call <code>__get__</code> yourself to see this:</p>
<pre><code>In [30]: x = object()

In [31]: def test(self, *args):
    ...:     print(f'Not really a method: self&lt;{self}&gt;, args: {args}')
    ...:     

In [32]: test
Out[32]: &lt;function __main__.test&gt;

In [33]: test.__get__(None, object)
Out[33]: &lt;function __main__.test&gt;

In [34]: test.__get__(x, object)
Out[34]: &lt;bound method test of &lt;object object at 0x7fe7ff92d890&gt;&gt;
</code></pre>
<p><code>@classmethod</code> and <code>@staticmethod</code> are similar. These decorators create proxy objects with <code>__get__</code> methods which provide different binding. Class method's <code>__get__</code> binds the method to the instance, and static method's <code>__get__</code> doesn't bind to anything, even when called on an instance.</p>
<h1>The Optional-Self Method Implementation</h1>
<p>We can do something similar to create a new method which <em>optionally</em> binds to an instance.</p>
<pre><code>import functools

class optionalselfmethod:

  def __init__(self, function):
    self.function = function
    functools.update_wrapper(self, function)

  def __get__(self, instance, cls):
    return boundoptionalselfmethod(self.function, instance)

class boundoptionalselfmethod:

  def __init__(self, function, instance):
    self.function = function
    self.instance = instance
    functools.update_wrapper(self, function)

  def __call__(self, *args, **kwargs):
    return self.function(self.instance, *args, **kwargs)

  def __repr__(self):
    return f'&lt;bound optionalselfmethod {self.__name__} of {self.instance}&gt;'
</code></pre>
<p>When you decorate a function with <code>optionalselfmethod</code>, the function is replaced with our proxy. This proxy saves the original method and supplies a <code>__get__</code> method which returns a <code>boudnoptionalselfmethod</code>. When we create a <code>boundoptionalselfmethod</code>, we tell it both the function to call and the value to pass as <code>self</code>. Finally, calling the <code>boundoptionalselfmethod</code> calls the original function, but with the instance or <code>None</code> inserted into the first parameter.</p>
<h1>Specific Questions</h1>
<blockquote>
<p>Was making a method this way (without args while not explicitly
  decorated as staticmethods) intentional in Python 3's design? UPDATED</p>
</blockquote>
<p>I believe this was intentional; however the intent would have been to eliminate unbound methods. In both Python 2 and Python 3, <code>def</code> <em>always</em> creates a function (you can see this by checking a type's <code>__dict__</code>: even though <code>Test.instance_mthd</code> comes back as <code>&lt;unbound method Test.instance_mthd&gt;</code>, <code>Test.__dict__['instance_mthd']</code> is still <code>&lt;function instance_mthd at 0x...&gt;</code>).</p>
<p>In Python 2, <code>function</code>'s <code>__get__</code> method always returns a <code>instancemethod</code>, even when accessed through the class. When accessed through an instance, the method is bound to that instance. When accessed through the class, the method is unbound, and includes a mechanism which checks that the first argument is an instance of the correct class.</p>
<p>In Python 3, <code>function</code>'s <code>__get__</code> method will return the original function unchanged when accessed through the class, and a <code>method</code> when accessed through the instance.</p>
<p>I don't know the exact rationale but I would guess that type-checking of the first argument to a class-level function was deemed unnecessary, maybe even harmful; Python allows duck-typing after all.</p>
<blockquote>
<p>Among the classic method types, what type of method is unknown_mthd?</p>
</blockquote>
<p><code>unknown_mthd</code> is a plain function, just like any normal instance method. It only fails when called through the instance because when <code>method.__call__</code> attempts to call the <code>function</code> <code>unknown_mthd</code> with the bound instance, it doesn't accept enough parameters to receive the <code>instance</code> argument.</p>
<blockquote>
<p>Why can unknown_mthd be called by the class without passing an
  argument?</p>
</blockquote>
<p>Because it's just a plain <code>function</code>, same as any other <code>function</code>. I just doesn't take enough arguments to work correctly when used as an instance method.</p>
<p>You may note that both <code>classmethod</code> and <code>staticmethod</code> work the same whether they're called through an instance or a class, whereas <code>unknown_mthd</code> will only work correctly when when called through the class and fail when called through an instance.</p>
<p><sub>1. If a particular name has both a value in the instance dict and a descriptor in the class dict, which one is used depends on what kind of descriptor it is. If the descriptor only defines <code>__get__</code>, the value in the instance dict is used. If the descriptor also defines <code>__set__</code>, then it's a data-descriptor and the descriptor always wins. This is why you can assign over top of a method but not a <code>@property</code>; method only define <code>__get__</code>, so you can put things in the same-named slot in the instance dict, while <code>@properties</code> define <code>__set__</code>, so even if they're read-only, you'll never get a value from the instance <code>__dict__</code> even if you've previously bypassed property lookup and stuck a value in the dict with e.g. <code>x.__dict__['whatever'] = 3</code>.</sub></p>
</div>
<span class="comment-copy">I find this answer to be a nice explanation: <a href="http://stackoverflow.com/questions/11788195/module-function-vs-staticmethod-vs-classmethod-vs-no-decorators-which-idiom-is" title="module function vs staticmethod vs classmethod vs no decorators which idiom is">stackoverflow.com/questions/11788195/…</a></span>
<span class="comment-copy">Thanks @Taras. The OP in your link describes "regular method" the way is define <code>unknown_mthd</code> here, but the accepted answer actually refers to an instance method.  However, <code>t.unknown_mthd()</code>  raises an error.</span>
<span class="comment-copy">Thank you.  To your first answer, no I mean was the creation of methods without args while not explicitly decorated as staticmethods intended.  I am aware of the removal of unbound methods.</span>
<span class="comment-copy">@pylang: That wasn't specifically a goal, but it was intentional to remove the kinds of checks that prevented you from doing that.  So basically they didn't specifically want to make that possible, but they felt the existing mechanisms that made it impossible weren't worth the complexity they introduced.</span>
<span class="comment-copy">Yes, I can confirm that regular functions work on the class.  For example, if the unknown method accepted arguments <code>def unknown_mthd(foo): pass</code>, then <code>Test.unknown_mthd("bar")</code> works.  Without accepting <code>self</code>, I'm not convinced this can be called an instance method though.</span>
<span class="comment-copy">@pylang: I guess it depends on whether you define "instance method" in terms of how it is defined, or how it is accessed.  It is an instance method in how it's defined.  If you access it on an instance, it won't work.  However, you can access it on the class, in which case it acts similar to a static method.  But it's not really a staticmethod, because a real staticmethod can also be called on an instance.</span>
<span class="comment-copy">You clarify a good point - <code>Test.method</code> does not imply <code>method</code> is bound to a class.  This is seen using <code>inspect.getmembers()</code>.  Perhaps it is more clear to say it is accessible from the class.</span>
<span class="comment-copy">In the class <code>unknown_mthd</code> is a function and seems to remain a function, apparently a byproduct of removing unbound methods.  This raises the question, if they weren't usable in Python 2, is there a utility for such static-like methods (or self-less instance methods)?  You can simply use staticmethods.  Many thanks.</span>
<span class="comment-copy">@pylang  You can assume these simple methods to be static methods indeed, but instances won't be able to call them (sometimes), in class <code>Test</code>: ` def unknown_mthd(*args): ...` works for both <code>Test.unknown_mthd()</code> as well as <code>Test(). unknown_mthd()</code>. I understand your confusion, why litter Python with redundancies? This is the case today for Python,  just see how many string formatting ways do we have! I don't mean this specific feature or the removal of unbound  of 2.X, the removal of unbound methods removed unnecessary restriction.</span>
<span class="comment-copy">I cannot reason the utility of such method other than to introduce intended side effects.  Unlike string formatting where each iteration of the string format was an improvement, these "limited static methods" that do not work on instances seem to be a regression.  If you know of an application, I'd appreciate your thoughts.  Thanks.</span>
<span class="comment-copy">At this moment I can imagine using this feature to implement a class method that's both static and instance method or simply as a static method, but be careful not to call it with instances, and this is something that cannot be guaranteed all the time of course: see <a href="https://gist.github.com/anonymous/ea5021dac0ce49270a5c7d646ceb5f44" rel="nofollow noreferrer">file.py</a></span>
<span class="comment-copy">Your explanation with descriptors is the depth i'm looking for.  I see how descriptors play a part, but I am trying to reason why not use a regular staticmethod?  FYI: I fixed the typo in the title.  You may wish to edit your first line to reflect this change.</span>
<span class="comment-copy">@pylang what do you mean by why not use a regular staticmethod? For what purpose?</span>
<span class="comment-copy">I do not see the utility of a function such as <code>unknown_mthd</code>.  An instance or static method should suffice.</span>
<span class="comment-copy">@pylang I don't think I said that it would be useful. It's just <i>possible</i> to create such a function because of the way method definitions work (methods are just wrappers around functions that insert a particular value as the first argument, and you can do this yourself if you want). There's no particular use for doing such a thing, but preventing you from creating zero-argument functions in class bodies would require the language to have special case logic rather than letting <code>def</code> always just create a <code>function</code>.</span>
