<div class="post-text" itemprop="text">
<p>Say I have a class to create Redshift object dependencies.  I want to create a single connection, and then re-use it for many different transactions.  </p>
<p>Should I create it in the <code>__init__</code> function, and then set the <code>self.conn.close()</code> in the <code>__del__</code> statement to mimic the <code>with</code> or <code>try/finally</code> model?</p>
<p>EDIT:
Here is what I came up with:</p>
<pre><code>class DatabaseConn:
    def __init__(self, env: DBEnvironment = DBEnvironment.PROD):
        """
        A database connection that can be safely instantiated once, and then 
        passed around inside a class or between functions.

        :param env: The environment to connect to, choices are `DEV` and 
         `PROD`. 
        """
        self._conn = ppg2.connect(**env.value)

    def __del__(self):
        self._conn.close()

    def execute(
            self,
            query_or_stmt: str,
            has_res: bool = True) -&gt; Optional[List[Tuple[Any]]]:
        """
        Creates a new cursor object, and executes the query/statement.  If 
        `has_res` is `True`, then it returns the list of tuple results.

        :param query_or_stmt: The query or statement to run.
        :param has_res: Whether or not results should be returned.

        :return: If `has_res` is `True`, then a list of tuples. 
        """
        cur = self._conn.cursor()
        cur.execute(query_or_stmt)
        if has_res:
            return cur.fetchall()

    def return_cursor(self):
        """
        :return: A psycopg2 cursor. 
        """
        return self._conn.cursor()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would recommend avoiding <strong>del</strong> as a destructor since it's calling pattern is nondeterministic and it is not guaranteed to be called at all.</p>
<p>If you want to get a <code>with</code> resource <code>as</code> bounded var behaviour, you can do that by using the <code>contextlib</code> module. </p>
<pre><code>from contextlib import contextmanager

@contextmanager
def tag(name):
    print("&lt;%s&gt;" % name)
    yield
    print("&lt;/%s&gt;" % name)

&gt;&gt;&gt; with tag("h1"):
...    print("foo")
...
&lt;h1&gt;
foo
&lt;/h1&gt;
</code></pre>
<p>this example come from the python docs at: <a href="https://docs.python.org/3/library/contextlib.html" rel="nofollow noreferrer">https://docs.python.org/3/library/contextlib.html</a></p>
<p>The disadvantage of this method is that the context of your resource needs to be coded. </p>
<p>An alternative is to write a real destructor that will be called when the connections reference counter hits 0. This is pretty similar to your original idea of using <code>__del__</code> but to avoid the many of the issues with using <code>__del__</code> directly, use <a href="https://docs.python.org/3/library/weakref.html#" rel="nofollow noreferrer">weakref.finalize</a>.</p>
</div>
<span class="comment-copy">I added the code I came up with.  The <code>weakref.finalize</code> function can't take a bounded method of the object, so I have no way to pass in the connection itself to have its <code>close</code> method invoked.  Any way around this you can see?</span>
