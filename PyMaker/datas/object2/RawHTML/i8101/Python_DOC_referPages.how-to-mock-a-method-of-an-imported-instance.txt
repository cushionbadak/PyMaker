<div class="post-text" itemprop="text">
<p>I am writing unit test for some python modules. However, I cannot work out a way to mock a method of an imported instance. Below is the python modules that I want to test.</p>
<p>--bar.py--</p>
<pre><code>class A():
    @classmethod
    def method_1(self):
        ...    
a = A()
</code></pre>
<p>--foo.py--</p>
<pre><code>from bar import a
class B():
    @classmethod
    def b(cls):
        if a.method_1():
            return True
        else:
            return False
</code></pre>
<p>--test_foo.py--</p>
<pre><code>from foo import B

class TestB(TestCase):
    @patch('foo.a.method_1')
    def test_b(self, mock_method_1):
          mock_method_1.return_value = True
          test_b = B.b()
          ...
</code></pre>
<p>This does not work. My test case is still calling original <code>method_1</code> instead of the one I mocked.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/unittest.mock.html#patch-object" rel="nofollow noreferrer"><code>patch.object</code> decorator</a> instead. It patches an object's attributes instead of patching a global method.</p>
<p>If that doesn't work, try patching <code>bar.a</code> instead of <code>foo.a</code>, but I don't think that's your problem here.</p>
<h2>Update</h2>
<p>The question changed to a class method, so I think this will work:</p>
<p>--test_foo.py--</p>
<pre><code>from foo import B

class TestB(TestCase):
    @patch('bar.A.method_1')
    def test_b(self, mock_method_1):
          mock_method_1.return_value = True
          test_b = B.b()
          ...
</code></pre>
</div>
<span class="comment-copy">I forgot to add the <code>@classmethod</code> to <code>method_1</code> in <code>class A</code> at first time. So now I updated the post.</span>
<span class="comment-copy">I tested your case in my desktop, seems it works as expected. What Python version are you using? Perhaps the <code>mock</code> package version?</span>
<span class="comment-copy">python==2.7, mock==2.0.0 . What's yours?</span>
<span class="comment-copy">strange. Same here with <code>python==2.7.12</code> and <code>mock==2.0.0</code>.  I make <code>a.method_1()</code> returns <code>False</code>, and  <code>assert test_b == True</code> . And the test case passes, which means it calls mocked method.</span>
<span class="comment-copy">Did you try the above example as in your question? Or are you working with your origin-complete codebase? Maybe I'm missing something. But here is something you can try: in <code>test_foo.py</code>, instead of using <code>from foo import B</code>, use <code>import foo</code> and <code>foo.B()</code> instead.</span>
<span class="comment-copy">Thanks for the suggestion about <code>patch.object</code>. But I think that the only difference between <code>patch.object</code> and <code>patch</code> is that <code>patch.object</code> allows you to use an imported stuff instead of writing the full path. I have tried it anyway but it still didn't work.</span>
<span class="comment-copy">Yes, patching <code>bar.a</code> does not help either. :( But thanks still for your help.</span>
<span class="comment-copy">@MarineLu, I updated the answer to match your updated question.</span>
