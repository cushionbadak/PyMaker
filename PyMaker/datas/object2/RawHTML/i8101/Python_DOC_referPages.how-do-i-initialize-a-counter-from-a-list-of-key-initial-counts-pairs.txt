<div class="post-text" itemprop="text">
<p>If I have a sequence of <code>(key, value)</code> pairs, I can quickly initialize a dictionary like this:</p>
<pre><code>&gt;&gt;&gt; data = [ ('a', 1), ('b', 2) ]
&gt;&gt;&gt; dict(data) 
{'a': 1, 'b': 2} 
</code></pre>
<p>I would like to do the same with a <code>Counter</code> dictionary; but how? Both the constructor and the <code>update()</code> method treat the ordered pairs as keys, not key-value pairs:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; Counter(data)
Counter({('a', 1): 1, ('b', 2): 1})
</code></pre>
<p>The best I could manage was to use a temporary dictionary, which is ugly and needlessly circuitous:</p>
<pre><code>&gt;&gt;&gt; Counter(dict(data))
Counter({'b': 2, 'a': 1})
</code></pre>
<p>Is there a proper way to directly initialize a <code>Counter</code> from a list  of <code>(key, count)</code> pairs? My use case involves reading lots of saved counts from files (with unique keys).</p>
</div>
<div class="post-text" itemprop="text">
<p>I would just do a loop:</p>
<pre><code>for obj, cnt in [ ('a', 1), ('b', 2) ]:
    counter[obj] = cnt
</code></pre>
<p>You could also just call the parent <code>dict.update</code> method:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; data = [ ('a', 1), ('b', 2) ]
&gt;&gt;&gt; c = Counter()
&gt;&gt;&gt; dict.update(c, data)
&gt;&gt;&gt; c
Counter({'b': 2, 'a': 1})
</code></pre>
<p>Lastly, there isn't anything wrong with your original solution:</p>
<pre><code>Counter(dict(list_of_pairs))
</code></pre>
<p>The expensive part of creating dictionaries or counters is hashing all of the keys and doing periodic resizes.  Once the dictionary is made, converting it to a Counter is very cheap about as fast as a dict.copy().  The hash values are reused and the final Counter hash table is pre-sized (no need for resizing).</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>Elements are counted from an iterable or initialized from another mapping (or counter)</p>
</blockquote>
<p>So it's a <em>No</em>, you need to convert it to mapping and then initialize <code>Counter</code>. And <em>Yes</em> when you initialized with <code>dict</code> it was the right move.</p>
<p><strong>UPDATE</strong></p>
<p>I agree that @RaymondHettinger code looks good, and actually it's faster</p>
<pre><code>from collections import Counter
from random import choice
from string import ascii_letters
a=[(choice(ascii_letters), i) for i in range(100)]
</code></pre>
<p>Tested with Python 3.6.1 and IPython 6</p>
<p>Initialization with <code>dict</code>:</p>
<pre><code>%%timeit
c1=Counter(dict(a))
</code></pre>
<p>Output</p>
<pre><code>12.1 µs ± 342 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p>Update with <code>dict.update()</code></p>
<pre><code>%%timeit    
c2=Counter()
dict.update(c2, a)
</code></pre>
<p>Output:</p>
<pre><code>7.21 µs ± 236 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your list of keys in the <code>(key, value)</code> pairs are already unique -- no duplicates -- you can use Raymond Hettinger's <a href="https://stackoverflow.com/a/43825040/298607">great solution</a>.</p>
<p>Beware though you only get the last value for any given key if there are duplicate keys:</p>
<pre><code>&gt;&gt;&gt; data=[ ('a', 1), ('b', 2), ('a', 3), ('b', 4) ]
&gt;&gt;&gt; c=Counter()
&gt;&gt;&gt; dict.update(c, data)
&gt;&gt;&gt; c
Counter({'b': 4, 'a': 3})      # note 'a' and 'b' are only the last value...
</code></pre>
<p>Same with <code>dict</code>:</p>
<pre><code>&gt;&gt;&gt; Counter(dict(data))
Counter({'b': 4, 'a': 3})
</code></pre>
<p>But <a href="https://docs.python.org/3.6/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counters</a> are most often used to count totals including of duplicates. If you want the sum of 'a' and 'b' entries, you need to loop over all the pairs:</p>
<pre><code>&gt;&gt;&gt; c=Counter()
&gt;&gt;&gt; for k, v in data:
...    c[k]+=v
... 
&gt;&gt;&gt; c
Counter({'b': 6, 'a': 4})        # the sum of the 'k' entries given 'v'
</code></pre>
</div>
<span class="comment-copy">"Explicit is better than implicit." Why should your list be treated differently from other iterables just because it is in a form that <i>could</i> be converted to a <code>dict</code>?</span>
<span class="comment-copy">I don't want special treatment, I want a different initialization path.</span>
<span class="comment-copy">If you are really processing "lots of saved counts from files" you probably should go <code>pandas</code> or <code>numpy</code> (structured arrays). I don't know what sizes we're talking here but at some point the memory benefits (and dtype-specific implementation of operations) of homogeneous arrays will come in handy.</span>
<span class="comment-copy">Note: Great solutions but only work for a list of keys are already unique. If you have something like <code>[ ('a', 1), ('b', 2), ('a', 3), ('b', 4) ]</code> you need to loop over all the pairs to get the totals I think, no? The OP does note qualify that the keys in the list are, in fact, unique or not.</span>
<span class="comment-copy">@dawg The first solution is easily adapted to duplicate keys with <code>counter[obj] += cnt</code>.</span>
<span class="comment-copy">Yes, that is my point: If you want totals you must loop. Thanks!</span>
<span class="comment-copy">Hmm, indeed that does not look encouraging. Thanks.</span>
