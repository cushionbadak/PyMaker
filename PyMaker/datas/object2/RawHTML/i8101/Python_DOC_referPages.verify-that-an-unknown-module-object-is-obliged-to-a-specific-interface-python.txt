<div class="post-text" itemprop="text">
<p>I'd like to check at runtime, for example, that a given object has methods <code>foo()</code> and <code>bar()</code>.</p>
<p>My research system, built in python 3.6, is highly parameterized and can/should accept any kind of object as a replacement of its build in modules. This functionality is very useful because many different students who use this system can easily research different behavior without changing the source code of my system.</p>
<p>The problem is that if they built the module wrong, they might discover this only after their entire experiment is ended (might be hours).</p>
<p>I am looking for a way to check at a very early stage of the runtime that their input module matches a specific interface. Verifying it even before it was instantiated is even better (when the input is only the type, not the instance).
For example <code>some_interface.verify(MyClass)</code>.</p>
<h1>Solutions</h1>
<p>I have seen many solutions on the internet (such as <a href="https://stackoverflow.com/questions/13919772/in-python-is-there-a-way-to-know-if-an-object-implements-an-interface-before-i">this</a>), but none of them is suitable:</p>
<ol>
<li><p>The most common solution (<code>try/catch</code>) will only fail during runtime and is not applicable in a multi-daemon system because it is hard to shut down when only one of the daemons fail.</p></li>
<li><p>Checking <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer"><code>isinstance()</code></a> doesn't verify anything. It might be even worse because the developer might forget to implement a function and use base class implementation, which might not fit its current implementation.</p></li>
<li><p>Using <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">ABC</a> (Abstract Base Classes) requires the developer to inherit from the base class. If she/he fail to do so, no warning or error will be issued when instantiating the class. On the other hand, if the developer did implement the interface but did not inherit from <code>base</code>, then <code>issubclass()</code> will return False.</p></li>
<li><p>Using <a href="https://zopeinterface.readthedocs.io/en/latest/" rel="nofollow noreferrer">zope interfaces</a> was my goto, but it has a few shortcomings:</p>
<ul>
<li>It requires the developer to explicitly mention that it is implementing the interface. Failing to specify this will result in an error, although the actual implementation is correct.</li>
<li>It cannot verify a module before it was instantiated. The <code>implementedBy()</code> method will only check if the module declared it is implementing the interface, but to actually verify it, you should call <code>verifyObject()</code> on the actual instance.</li>
<li>It does not support the new typing feature that was added since python 3.5</li>
</ul></li>
</ol>
<p>EDIT: Apparently, zope also supports implicit implementation by calling <code>verifyObject(YourInterface, obj, tentative=True)</code> which does not force the developer to explicitly defining the class as an implementer of the interface.</p>
</div>
<div class="post-text" itemprop="text">
<p>To my mind, the problem is not a problem of tools. The main problem is that even if some interface is supported, no one can be sure the module really works. What would I do is creating a test for modules and running it when initializing plugins. The test should verify not just types and interfaces (<code>isinstance</code>, <code>hasattr</code> and so on are just tools for the task), but (if possible) minimal correctness of the module's functioning. E.g. it would be fine to perform some basic task that does not require much time to complete and verify the results. If a plugin fails during such a test task, then the plugin is not valid.</p>
</div>
<div class="post-text" itemprop="text">
<p>A recent PEP finally partially solves this issue.
<a href="https://www.python.org/dev/peps/pep-0544/" rel="nofollow noreferrer">PEP-0544</a> introduce <code>typing.Protocol</code> which allows defining an interface that can be validated on runtime.
This is currently available via a non-official extension to the <code>typing</code> module called <a href="https://pypi.org/project/typing-extensions/" rel="nofollow noreferrer">typing-extensions</a>.</p>
<p>It can be used, for example, as follows:</p>
<pre class="lang-py prettyprint-override"><code>from typing_extensions import Protocol, runtime
from typing import Any

@runtime
class IMyProtocol(Protocol):
    member: int

    def foo(self, parameter1: Any, parameter2: Any) -&gt; Any:
        pass

    def bar(self, parameter1: Any) -&gt; Any:
        pass
</code></pre>
<p>Then, if we define a class, we could check if it follows the protocol:</p>
<pre class="lang-py prettyprint-override"><code>class MyClass:
    def __init__(self):
        self.member = 5

    def foo(self, a, b):
        return a,b

    def bar(self, c):
        return c

isinstance(MyClass(), IMyProtocol)  # Returns True
</code></pre>
<p>If we define it wrong, it will return false:</p>
<pre class="lang-py prettyprint-override"><code>class MyOtherClass:
    def __init__(self):
        self.member = 5

    def bar(self, c):
        return c

isinstance(MyOtherClass(), IMyProtocol)  # Returns False
</code></pre>
<p>The shortcoming of this solution is that it does not verify the arguments of the methods. Not that the implementation has the correct number of arguments and not the arguments' typing.</p>
</div>
<span class="comment-copy">I guess there several steps to verifying a plugin. One of which is unit-testing the implementation. I'm looking for a minimum effort tool for the <b>first</b> step. I could write a unit test script that does exactly what I am looking for, but I wouldn't do that unless I know for sure that there isn't anything else that does it.</span>
<span class="comment-copy">You may require plugins to inherit certain class (isinstance, or just checking if that class is in mro(pluginclass)) that can not be instantiated unless the abstract methods are imlemented. You may even iterate through the plugin class members and check if all the abstract methods are reimlemented by user class.</span>
<span class="comment-copy">Thanks. I forgot to mention ABC in my question. This will require the developer do inherit from <code>Abstract()</code>. If he/she will not do that, then no error/warning will be invoked.</span>
<span class="comment-copy">If the code author decides not to use your base class, probably that is already a good reason for at least a warning.</span>
