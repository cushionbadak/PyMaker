<div class="post-text" itemprop="text">
<p><strong>Note</strong> <em>This question is not about the Python 3 <code>Enum</code> data type, it's just the example I'm using.</em></p>
<p>With <a href="https://www.python.org/dev/peps/pep-3115/" rel="nofollow noreferrer">PEP 3115</a> Python 3 added the <a href="https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace" rel="nofollow noreferrer"><code>__prepare__</code></a><sup>1</sup> method to <code>type</code> for the purpose of allowing a custom namespace to be used when creating classes.  For example, the new <code>Enum</code> data type uses <code>__prepare__</code> to return an instance of the private <code>_EnumDict</code> for use as the new <code>Enum</code> class' namespace.</p>
<p>However, I have seen several examples on SO<sup>2</sup> of <code>EnumMeta</code> being subclassed, creating a new namespace for the class in the metaclass <code>__new__</code> method, but instead of calling the <code>__prepare__</code> method to acquire that new namespace, <code>type(clsdict)()</code> is used instead.  Are there any risks to doing it this way?</p>
<hr/>
<p><sup>1</sup>  The signature for <code>__prepare__</code>:</p>
<pre><code>@classmethod
def __prepare__(metacls, cls, bases, **kwds):
</code></pre>
<p>and for <code>__new__</code>:</p>
<pre><code>def __new__(metacls, cls, bases, clsdict, **kwds):
</code></pre>
<hr/>
<p><sup>2</sup>  Example using <code>type(clsdict)</code>:</p>
<p>from <a href="https://stackoverflow.com/a/43100224/208880">this answer</a></p>
<pre><code>class CountryCodeMeta(enum.EnumMeta):
    def __new__(metacls, cls, bases, classdict):
        data = classdict['data']
        names = [(country['alpha-2'], int(country['country-code'])) for country in data]

  --&gt;   temp = type(classdict)()
        for name, value in names:
            temp[name] = value

        excluded = set(temp) | set(('data',))
        temp.update(item for item in classdict.items() if item[0] not in excluded)

        return super(CountryCodeMeta, metacls).__new__(metacls, cls, bases, temp)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, there are risks.</p>
<p>At least two reasons exist for getting the new namespace by calling <code>__prepare__</code> instead of doing <code>type(clsdict)()</code>:</p>
<ul>
<li><p>When running on Python 2 <code>clsdict</code> is a <code>dict</code>, and the original <code>__prepare__</code> never ran to begin with (<code>__prepare__</code> is Python 3 only) -- in other words, if <code>__prepare__</code> is returning something besides a normal dict, <code>type(clsdict)()</code> is not going to get it.</p></li>
<li><p>Any attributes set by <code>__prepare__</code> on the <code>clsdict</code> would not be set when using <code>type(clsdict)()</code>; i.e. if <code>__prepare__</code> does <code>clsdict.spam = 'eggs'</code> then <code>type(clsdict)()</code> will not have a <code>spam</code> attribute.  Note that these attributes are on the namespace itself for use by the metaclass and are not visible in the namespace.</p></li>
</ul>
<p>To summarize: there are good reasons to use <code>__prepare__()</code> to obtain the proper class dictionary, and none for the <code>type(clsdict)()</code> shortcut.</p>
</div>
