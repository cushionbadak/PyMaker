<div class="post-text" itemprop="text">
<p>I have a dictionary where some of the keys are Enum instances (subclasses of enum.Enum). I am attempting to encode the dictionary into a JSON string using a custom JSON Encoder class as per the <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder" rel="nofollow noreferrer">documentation</a>. All I want is to have the keys in the outputted JSON be the strings of the Enum names. For example <code>{ TestEnum.one : somevalue }</code> would be encoded to <code>{ "one" : somevalue }</code>.</p>
<p>I have written a simple test case, shown below, which I have tested in a clean virtualenv:</p>
<pre><code>import json

from enum import Enum

class TestEnum(Enum):
    one = "first"
    two = "second"
    three = "third"

class TestEncoder(json.JSONEncoder):
    """ Custom encoder class """

    def default(self, obj):

        print("Default method called!")

        if isinstance(obj, TestEnum):
            print("Seen TestEnum!")
            return obj.name

        return json.JSONEncoder.default(self, obj)

def encode_enum(obj):
    """ Custom encoder method """

    if isinstance(obj, TestEnum):
        return obj.name
    else:
        raise TypeError("Don't know how to decode this")

if __name__ == "__main__":

    test = {TestEnum.one : "This",
            TestEnum.two : "should",
            TestEnum.three : "work!"}

    # Test dumps with Encoder method
    #print("Test with encoder method:")
    #result = json.dumps(test, default=encode_enum)
    #print(result)

    # Test dumps with Encoder Class
    print("Test with encoder class:")
    result = json.dumps(test, cls=TestEncoder)
    print(result)
</code></pre>
<p>I cannot successfully encode the dictionary (using Python 3.6.1). I continually get <code>TypeError: keys must be a string</code> errors and the default method of my custom encoder instance (supplied via the <code>cls</code> argument of the <code>json.dumps</code> method) never seems to be called? I have also attempted to supply a custom encoding method via the <code>default</code> argument of the <code>json.dumps</code> method, but again this is never triggered.</p>
<p>I have seen solutions involving the IntEnum class, but I need the values of the Enum to be strings. I have also seen <a href="https://stackoverflow.com/questions/21606049/json-encode-decode-gtk-enums">this answer</a> which discusses an issue related to an Enum which inherits from another class. However, my enums inherit from the base enum.Enum class only and correctly respond to <code>isinstance</code> calls? </p>
<p>Both the custom class and the method produce a <code>TypeError</code> when supplied to the <code>json.dumps</code> method. Typical output is shown below: </p>
<pre><code>$ python3 enum_test.py

Test with encoder class
Traceback (most recent call last):
  File "enum_test.py", line 59, in &lt;module&gt;
    result = json.dumps(test, cls=TestEncoder)
  File "/usr/lib64/python3.6/json/__init__.py", line 238, in dumps
    **kw).encode(obj)
  File "/usr/lib64/python3.6/json/encoder.py", line 199, in encode
    chunks = self.iterencode(o, _one_shot=True)
  File "/usr/lib64/python3.6/json/encoder.py", line 257, in iterencode
    return _iterencode(o, 0)
TypeError: keys must be a string
</code></pre>
<p>I presume the issue is that the <code>encode</code> method of the JSONEncoder class assumes that it knows how to serialise the Enum class (because one of the if statements in the <code>iterencode</code> method is triggered) and so never calls the custom default methods and ends failing to serialise the Enum? </p>
<p>Any help would be greatly appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't use anything but <em>strings</em> as keys in dictionaries you want to convert to JSON. The encoder doesn't give you any other options; the <code>default</code> hook is only called for values of unknown type, never for keys.</p>
<p>Convert your keys to strings up front:</p>
<pre><code>def convert_keys(obj, convert=str):
    if isinstance(obj, list):
        return [convert_keys(i, convert) for i in obj]
    if not isinstance(obj, dict):
        return obj
    return {convert(k): convert_keys(v, convert) for k, v in obj.items()}

json.dumps(convert_keys(test))
</code></pre>
<p>This recursively handles your dictionary keys. Note that I included a hook; you can then choose how to convert enumeration values to strings:</p>
<pre><code>def enum_names(key):
    if isinstance(key, TestEnum):
        return key.name
    return str(key)

json.dumps(convert_keys(test, enum_names))
</code></pre>
<p>You can use the same function to reverse the process when loading from JSON:</p>
<pre><code>def names_to_enum(key):
    try:
        return TestEnum[key]
    except KeyError:
        return key

convert_keys(json.loads(json_data), names_to_enum)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; def enum_names(key):
...     if isinstance(key, TestEnum):
...         return key.name
...     return str(key)
...
&gt;&gt;&gt; json_data = json.dumps(convert_keys(test, enum_names))
&gt;&gt;&gt; json_data
'{"one": "This", "two": "should", "three": "work!"}'
&gt;&gt;&gt; def names_to_enum(key):
...     try:
...         return TestEnum[key]
...     except KeyError:
...         return key
...
&gt;&gt;&gt; convert_keys(json.loads(json_data), names_to_enum)
{&lt;TestEnum.one: 'first'&gt;: 'This', &lt;TestEnum.two: 'second'&gt;: 'should', &lt;TestEnum.three: 'third'&gt;: 'work!'}
</code></pre>
</div>
<span class="comment-copy">Related:  <a href="http://stackoverflow.com/a/43730306/674039">stackoverflow.com/a/43730306/674039</a></span>
<span class="comment-copy">You can't use anything other than strings for keys. The encoder doesn't get to intercede there, it's a hard rule.</span>
<span class="comment-copy">Well that worked brilliantly! Thank you. It is shame there is not a way to do this via the Encoder and the docs are not as clear as they could be about this.</span>
