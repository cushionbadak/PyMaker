<div class="post-text" itemprop="text">
<p>I am writing a class that has many functionalities(therefore methods), but I require this class to run inside a thread(class opens a subprocess). I want to use the common way of declaring thread based classes of,</p>
<pre><code>class HiStackOverflow(threading.Thread):
     # Somethings...
</code></pre>
<p>However, as I said, this class of mine has many pseudo-private, regular and static methods. And as I declare them, I want to avoid overriding some necessary <code>threading.Thread</code> method by mistake.</p>
<p>Well I can always check the directory of <code>threading.Thread</code> and see if there are any method names that overlap, however this seemed like a inappropriate way to handle this.  It may be impractical as the method count increases.</p>
<p>My question is, is this kind of implementation feasible ? If not, how should I handle this ? Should I write some wrapper class as the Thread handler.</p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're worried about namespace clashes between your class and <code>threading.Thread</code>, I would definitely suggest that you use composition rather than inheritance (or keep the two functionalities separate entirely).  There shouldn't be significant overhead to just wrapping the couple threading methods that you need and then name clashes become a non-issue.</p>
<p>It also more cleanly will separate the functionality of your class from the functionality provided by threading.  That's likely to be a win in the long run for understanding your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>There isn't much benefit from inheriting from <code>Thread</code>. You could have a factory method that creates the thread or even have its <code>__init__</code> do it. </p>
<pre><code>import threading
import time

class MyClass:

    def __init__(self):
        self._thread = threading.Thread(target=self.run)
        self._thread.start()

    def run(self):
        for i in range(5):
            print('worker thread', i)
            time.sleep(.5)

    def join(self):
        self._thread.join()

my_obj = MyClass()
for i in range(3):
    print('main thread', i)
    time.sleep(.5)
my_obj.join()
print('done')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There seem to be some ideas conflated in this phrase:</p>
<blockquote>
<p>but I require this class to run inside a thread(class opens a subprocess)</p>
</blockquote>
<ol>
<li><p>Classes don't "run". You can start a new thread which executes some class method, or an instance method. That class doesn't have to inherit from <code>Thread</code>. It doesn't even need a reference to the running thread. You just start to execute some function in a new thread and you're done.</p></li>
<li><p>Subprocesses are unrelated to threads. You don't need one to do the other.</p></li>
</ol>
<p>If you're worried about overriding something, check the documentation (<a href="https://docs.python.org/3/library/threading.html#thread-objects" rel="nofollow noreferrer">https://docs.python.org/3/library/threading.html#thread-objects</a>). Otherwise, if you want to keep the reference to the thread, you can always do:</p>
<pre><code>class HiStackoverflow:
    def run(self):
        self.thread = Thread(target=self.entry_point)
        self.thread.start()

    def entry_point(self):
        ...
</code></pre>
</div>
<span class="comment-copy">You mean like a solution in other answers ?</span>
<span class="comment-copy">@Rockybilly -- Yes, that's precisely what I mean :-) -- Although, I would probably suggest that you keep the class functionality and the threading separate entirely.  <code>m = MyClass(...); thread = Thread(target=m.run); thread.start()</code> doesn't seem too bad and it simplifies the logic and clarifies the purpose of  <code>MyClass</code>.</span>
<span class="comment-copy">What I meant was, class opens a continuous subprocess, I needed the subprocess to run inside a thread, sorry for the misconception, and thanks for the information.</span>
<span class="comment-copy">@Rockybilly Subprocesses don't run inside threads. They run completely outside of the current process.</span>
<span class="comment-copy">It took me a while to realise that, thank you.</span>
