<div class="post-text" itemprop="text">
<p>The scenario is the following:
I have a database where I store users and I want to keep the data (database) and the logic (bussiness) layers completely isolated.</p>
<p>I've created several specific exceptions to display the correct message in the interface (Flask) layer. Such as UserNotFound, UserEmailUsed, UserNameTaken</p>
<p>All the code is in a single file cruduser.py</p>
<p>Conection to the database:</p>
<pre><code>def connect():
    '''Connect to the database'''

    return MySQLdb.connect(
        "localhost",
        "root",
        "****",
        "myflaskapp",
        cursorclass=MySQLdb.cursors.DictCursor
        )
</code></pre>
<p>Get users by email and/or username (Returns a User object):</p>
<pre><code>def get_user_by_email(user):
    '''Receive a user object, check whether email is used, if not raise
    UserNotFound else creates a user object and returns'''

    with connect() as cursor:
        cursor.execute(
            '''SELECT * FROM users WHERE email = %s''',
            [user.email]
            )
        user = cursor.fetchone()
    if user is None:
        raise UserNotFound
    return User(**user)

def get_user_by_username(user):
    '''Receive a user object, check whether username is used, if not raise
    UserNotFound else creates a user object and returns'''

    with connect() as cursor:
        cursor.execute(
            '''SELECT * FROM users WHERE username = %s''',
            [user.username]
            )
        user = cursor.fetchone()
    if user is None:
        raise UserNotFound
    return User(**user)
</code></pre>
<p>Now to check duplicates I created the following code when a new user signs up:</p>
<pre><code>def create_user(user):
    '''Receive a user object, check if it is available and creates a new user
    and inserts it into the database'''

    available_user(user)
    with connect() as cursor:
        cursor.execute(
            """INSERT INTO users(email, username, password) VALUES(%s,%s,%s)""",
            (user.email, user.username, user.password)
            )

def available_user(user):
    '''Receive a user object, check email and username, if email is used, raise
    UserEmailUsed if username is used raise UserNameTaken else returns True'''

    try:
        get_user_by_email(user)
        raise UserEmailUsed
    except UserNotFound:
        pass
    try:
        get_user_by_username(user)
        raise UserNameTaken
    except UserNotFound:
        pass
    return True
</code></pre>
<p>My questions are:</p>
<ol>
<li><p>Is this approach pythonic?</p></li>
<li><p>Is there a better way to write the available_user function?</p></li>
<li><p>Is it appropriate to use exceptions in this way?</p></li>
</ol>
<p>Note: This is a learning project so I would like to keep as pure as possible, no flask plugins at this point.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not too experienced with custom Exceptions but it looks like both of them are raised in any case, in contrast to your comment (if). So I'd put this condition into the code, and maybe catch <em>UserNotFound</em> in a common <em>except</em>.</p>
<pre><code>try:
    if get_user_by_email(user) :
        raise UserEmailUsed
    if get_user_by_username(user) :
        raise UserNameTaken
except UserNotFound:
    pass # handled elsewhere?
</code></pre>
<p><a href="https://docs.python.org/3/tutorial/errors.html#handling-exceptions" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/errors.html#handling-exceptions</a></p>
</div>
<div class="post-text" itemprop="text">
<p>After think and try several solutions I came to this:</p>
<p>First, DB logic and Business Logic should be separated so there is a dbconnect.py file with the following code:</p>
<pre><code>def connect():
    '''Connect to the database'''
    return psycopg2.pool.SimpleConnectionPool(
        1,
        30,
        host='ec2-23-23-223-2.compute-1.amazonaws.com',
        user='wmowxsiematqzx',
        password='d46dff42de4d8af492900f33d322caa13a0e05174b2310eec2e3549295438ab1',
        dbname='dfciqalcgr98ah'
        )

@contextmanager
def get_cursor():
    a = connect()
    con = a.getconn()
    con.autocommit = True
    try:
        yield con.cursor()
    finally:
        a.putconn(con)

def execute_query_void(query):
    with get_cursor() as cursor:
        cursor.execute(*query)

def execute_query_one(query):
    with get_cursor() as cursor:
        cursor.execute(*query)
        result = cursor.fetchone()
    return result

def execute_query_many(query):
    with get_cursor() as cursor:
        cursor.execute(*query)
        result = cursor.fetchall()
    return result
</code></pre>
<p>All possible scenarios are covered there.</p>
<p>Now the cruduser.py</p>
<pre><code>def get_user_by_email(email):
    '''Receive a user object, look for a user with the given email and
    returns a user object or None'''
    query = ('''SELECT email, username, password_hash, rolename FROM users
                INNER JOIN roles ON users.idroles=roles.idroles
                WHERE email = %s''',
             [email])
    user = execute_query_one(query)
    if user is None:
        return None
    return User(**user)

def get_user_by_username(user):
    '''Receive a user object, look for a user with the given username and
    returns a user object or None'''
    query = ('''SELECT email, username, password_hash, rolename FROM users
                INNER JOIN roles ON users.idroles=roles.idroles
                WHERE username = %s''',
             [user.username])
    user = execute_query_one(query)
    if user is None:
        return None
    return User(**user)
</code></pre>
<p>And the available functionality is achieved with two functions:</p>
<pre><code>def available_user(user):
    '''Receive a user object, check email and username, if email is used, raise
    UserEmailUsed if username is used raise UserNameTaken else returns True'''
    users = get_users(user)
    if len(users) == 0:
        return True

    for user_ in users:
        if user.email == user_.email:
            raise UserEmailUsed
        if user.username == user_.username:
            raise UserNameTaken

def get_users(user):
    '''Receive a article object, check whether articlename is used, if not raise
    articleNotFound else creates a article object and returns'''
    query = ('''SELECT email, username
                FROM users
                WHERE username=%s OR email=%s;''',
             (user.username, user.email))
    users = execute_query_many(query)
    return [User(**user) for user in users]
</code></pre>
<p>The reason why I switch between using get_user_by_email and get_user_by_username to get_users is for performance, the latter just uses two columns while the former returns a whole object after performing a Join. </p>
<p>Additionally the exception where renamed to a more explicit name and where moved from DB Logic to Business Logic file</p>
</div>
<span class="comment-copy">Why don't you use one of the several Python ORMs, rather than writing your own?</span>
<span class="comment-copy">@DanielRoseman Because it's a learning project, first bare SQL and then ORMs.</span>
<span class="comment-copy">Though I am not sure if using Exceptions for status messages is pythonic..</span>
<span class="comment-copy">I've already try this, if the new user has an unused email but a taken username, it will pass. That shouldn't happen.  It should pass when both functions raise UserNotFound</span>
