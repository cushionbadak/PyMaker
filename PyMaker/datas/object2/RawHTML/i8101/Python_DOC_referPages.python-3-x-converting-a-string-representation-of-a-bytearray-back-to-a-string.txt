<div class="post-text" itemprop="text">
<p>The back-story here is a little verbose, but basically I want to take a string like <code>b'\x04\x0e\x1d'</code> and cast it back into a bytearray.</p>
<p>I am working on a basic implementation of a one time pad, where I take a plaintext <code>A</code> and shared key <code>B</code> to generate a ciphertext <code>C</code> accoring to the equation <code>A⊕B=C</code>. Then I reverse the process with the equation <code>C⊕B=A</code>.</p>
<p>I've already found plenty of python3 functions to encode strings as bytes and then xor the bytes, such as the following:</p>
<pre><code>def xor_strings(xs, ys):
    return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys)).encode()
</code></pre>
<p>A call to <code>xor_strings()</code> then returns a bytearray:</p>
<pre><code>print( xor_strings("foo", "bar"))
</code></pre>
<p>But when I print it to the screen, what I'm shown is actually a string. So I'm assuming that python is just calling some <code>str()</code> function on the bytearray, and I get something that looks like the following:</p>
<p><code>b'\x04\x0e\x1d'</code></p>
<p>Herein lies the problem. I want to create a new bytearray from that string. Normally I would just call <code>decode()</code> on the bytearray. But if I enter `b'\x04\x0e\x1d' as input, python sees it as a string, not a bytearray!</p>
<p>How can I take a string like <code>b'\x04\x0e\x1d'</code> as user input and cast it back into a bytearray?</p>
</div>
<div class="post-text" itemprop="text">
<p>As discussed in the comments, use base64 to send binary data in text form.</p>
<pre><code>import base64

def xor_strings(xs, ys):
    return "".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys)).encode()

# ciphertext is bytes
ciphertext = xor_strings("foo", "bar")
# &gt;&gt;&gt; b'\x04\x0e\x1d'

# ciphertext_b64 is *still* bytes, but only "safe" ones (in the printable ASCII range)
ciphertext_b64 = base64.encodebytes(ciphertext)
# &gt;&gt;&gt; b'BA4d\n'
</code></pre>
<p>Now we can transfer the bytes:</p>
<pre><code># ...we could interpret them as ASCII and print them somewhere
safe_string = ciphertext_b64.decode('ascii')
# &gt;&gt;&gt; BA4d

# ...or write them to a file (or a network socket)
with open('/tmp/output', 'wb') as f:
    f.write(ciphertext_b64)
</code></pre>
<p>And the recipient can retrieve the original message by:</p>
<pre><code># ...reading bytes from a file (or a network socket)
with open('/tmp/output', 'rb') as f:
    ciphertext_b64_2 = f.read()

# ...or by reading bytes from a string
ciphertext_b64_2 = safe_string.encode('ascii')
# &gt;&gt;&gt; b'BA4d\n'

# and finally decoding them into the original nessage
ciphertext_2 = base64.decodestring(ciphertext_b64_2)
# &gt;&gt;&gt; b'\x04\x0e\x1d'
</code></pre>
<p>Of course when it comes to writing bytes to a file or to the network, encoding them as base64 first is superfluous. You can write/read the ciphertext directly if it's the only file content. Only if the ciphertext it is part of a higher structure (JSON, XML, a config file...) encoding it as base64 becomes necessary again.</p>
<p>A note on the use of the words "decode" and "encode". </p>
<ul>
<li><p>To <em>encode</em> a string means to turn it from its abstract meaning ("a list of characters") into a storable representation ("a list of bytes"). The exact result of this operation depends on the byte encoding that is being used. For example:</p>
<ul>
<li>ASCII encoding maps one character to one byte (as a trade-off it can't map all characters that can exist in a Python string). </li>
<li>UTF-8 encoding maps one character to 1-5 bytes, depending on the character.</li>
</ul></li>
<li><p>To <em>decode</em> a byte array means turning it from "a list of bytes" back into "a list of characters" again. This of course requires prior knowledge of what the byte encoding originally was.</p></li>
</ul>
<p><code>ciphertext_b64</code> above is a list of bytes and is represented as <code>b'BA4d\n'</code> on the Python console. </p>
<p>Its string equivalent, <code>safe_string</code>, looks very similar <code>'BA4d\n'</code> when printed to the console due to the fact that base64 is a sub-set of ASCII.</p>
<p>The data <em>types</em> however are still fundamentally different. Don't let the console output deceive you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Responding to that final question only.</p>
<pre><code>&gt;&gt;&gt; type(b'\x04\x0e\x1d')
&lt;class 'bytes'&gt;
&gt;&gt;&gt; bytearray(b'\x04\x0e\x1d')
bytearray(b'\x04\x0e\x1d')
&gt;&gt;&gt; type(bytearray(b'\x04\x0e\x1d'))
&lt;class 'bytearray'&gt;
</code></pre>
</div>
<span class="comment-copy">I'm a bit confused. <code>b'\x04\x0e\x1d'</code> is not a string, it's a byte array. Or do you want the user to enter "b'\x04\x0e\x1d'" into a textbox?</span>
<span class="comment-copy">That's not how you would send bytes to a friend, at least I strongly discourage it. Use a common transfer encoding like base64 for such a task.</span>
<span class="comment-copy">Nope. Send base64; the recipient can copy and paste that easily. It's a resilient format that virtually every environment on the planet can decode back into bytes. Python has the <a href="https://docs.python.org/3/library/base64.html" rel="nofollow noreferrer">base64 module</a> for this purpose.</span>
<span class="comment-copy">@Tomalak well, I'm now convinced that you are correct and that base64 is the way to go. But even if the question is a weird one, I'm still curious as to how you'd take "b'\x04\x0e\x1d'" from a textbox and convert it to a bytearray. Is there an easy/built in way? Or would you basically have to parse the string and convert each byte</span>
<span class="comment-copy">Yes, I would write a loop that steps through the string four characters at a time and then convert each part into a number, building a byte array as I go. It's fundamentally the same thing that a base64 decoder does, but base64 has been made for this exact purpose, it solves many problems that you did not even think of and as a built-in module it's basically free.</span>
