<div class="post-text" itemprop="text">
<pre><code>xs = [
        [1,2,3,4],
        [5,6,7,8],
        [9,0,0,1],
        [2,3],
        [0],
        [5,8,3,2,5,1],
        [6,4],
        [1,6,9,9,2,9]
]

""" expected output:

    xs_dict = {
        1: [[0]]
        2: [[2,3],[6,4]]
        4: [[1,2,3,4],[5,6,7,8],[9,0,0,1]]
        6: [[5,8,3,2,5,1],[1,6,9,9,2,9]]
    }
"""
</code></pre>
<p>I can do this, for example, by </p>
<pre><code>xs_dict = {}
for x in xs:
    aux = xs_dict.get(len(x),[])
    aux.append(x)
    xs_dict[len(x)] = aux

print(xs_dict)
</code></pre>
<p>But I can't help feeling there should be a more pythonic way to achieve this.</p>
<p>What is it?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import groupby

xs_dict = {
    key: list(value)
    for (key, value) in groupby(sorted(xs, key=len), len)
}
</code></pre>
<p>As discussed in the comments below, the necessary sorting of the input is a step which is unnecessary costly.  For large input this will slow down this algorithm way more than necessary.  Consider using @hiroprotagonist's solution instead then, or replace the <code>groupby(sorted(…), …)</code> by a <code>groupby()</code> which can handle unsorted input.</p>
</div>
<div class="post-text" itemprop="text">
<p>you could use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>:</p>
<pre><code>from collections import defaultdict

xs_dict = defaultdict(list)
for item in xs:
    xs_dict[len(item)].append(item)
</code></pre>
<p>python <code>dict</code>s also have a nice method called <a href="https://docs.python.org/3/library/stdtypes.html?highlight=setdefault#dict.setdefault" rel="nofollow noreferrer"><code>setdefault</code></a> (that way you do not need to import anything):</p>
<pre><code>xs_dict = {}
for item in xs:
    xs_dict.setdefault(len(item), []).append(item)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>1 liner:</p>
<pre><code>res = {len(s): [d for d in xs if len(d) == len(s)] for s in xs}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import pprint
from collections import defaultdict
from itertools import groupby

xs = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 0, 0, 1],
    [2, 3],
    [0],
    [5, 8, 3, 2, 5, 1],
    [6, 4],
    [1, 6, 9, 9, 2, 9]
]

data = defaultdict(list)

for result, group in groupby(sorted(xs, key=len), len):
    for item in group:
        data[result].append(item)

pprint.pprint(dict(data))
</code></pre>
<p>Gives me</p>
<pre><code>{1: [[0]],
 2: [[2, 3], [6, 4]],
 4: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 0, 0, 1]],
 6: [[5, 8, 3, 2, 5, 1], [1, 6, 9, 9, 2, 9]]}
</code></pre>
</div>
<span class="comment-copy">Yeah, actually I find it is a <i>wart</i> that <code>groupby()</code> needs sorted input.  Sorting is unnecessary expensive in general.  There should at least be a version which doesn't work like this but which collects actively.</span>
<span class="comment-copy">damn! that is nice! +1</span>
<span class="comment-copy">@hiroprotagonist Isn't this less efficient than your solution?</span>
<span class="comment-copy">Yah I think we agree but <code>groupbyOfUnsorted()</code> is basically the <code>defaultdict</code> solution or would you implement it another way? @hiroprotagonist</span>
<span class="comment-copy">What a rare treat that we all agree, how civilized, thanks anyway both</span>
<span class="comment-copy">This does several thing twice.</span>
<span class="comment-copy">never said it is efficient :P</span>
<span class="comment-copy">@afifit You also never said it wasn't xD. It simply scales badly</span>
<span class="comment-copy">I guess you can optimize it a bit by changing the <code>xs</code> into a set of length, still no perfect though</span>
