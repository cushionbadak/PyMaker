<div class="post-text" itemprop="text">
<p>I've been writing some code to list the Gaussian integer divisors of rational integers in Python. (Relating to Project Euler problem 153)</p>
<p>I seem to have reached some trouble with certain numbers and I believe it's to do with Python approximating the division of complex numbers.</p>
<p>Here is my code for the function:</p>
<pre><code>def IsGaussian(z):
    #returns True if the complex number is a Gaussian integer
    return complex(int(z.real), int(z.imag)) == z

def Divisors(n):
    divisors = []

    #Firstly, append the rational integer divisors
    for x in range(1, int(n / 2 + 1)):
        if n % x == 0:
            divisors.append(x)

    #Secondly, two for loops are used to append the complex Guassian integer divisors
    for x in range(1, int(n / 2 + 1)):
        for y in range(1, int(n / 2 + 1)):
            if IsGaussian(n / complex(x, y)) == n:
                divisors.append(complex(x, y))
                divisors.append(complex(x, -y))

    divisors.append(n)

    return divisors
</code></pre>
<p>When I run <code>Divisors(29)</code> I get <code>[1, 29]</code>, but this is missing out four other divisors, one of which being (5 + 2j), which can clearly be seen to divide into 29.</p>
<p>On running <code>29 / complex(5, 2)</code>, Python gives <code>(5 - 2.0000000000000004j)</code></p>
<p>This result is incorrect, as it should be <code>(5 - 2j)</code>. Is there any way to somehow bypass Python's approximation? And why is it that this problem has not risen for many other rational integers under 100?</p>
<p>Thanks in advance for your help.</p>
</div>
<div class="post-text" itemprop="text">
<p>Internally, CPython uses a pair of double-precision floats for complex numbers. The behavior of numerical solutions in general is too complicated to summarize here, but some error is unavoidable in numerical calculations.</p>
<p>EG:</p>
<pre><code>&gt;&gt;&gt;print(.3/3)
0.09999999999999999
</code></pre>
<p>As such, it is often correct to use approximate equality rather than actual equality when testing solutions of this kind.</p>
<p>The <a href="https://docs.python.org/3/library/cmath.html" rel="nofollow noreferrer">isclose function in the  cmath module</a> is available for this exact reason. </p>
<pre><code>&gt;&gt;&gt;print(.3/3 == .1)
False
&gt;&gt;&gt;print(isclose(.3/3, .1))
True
</code></pre>
<p>This kind of question is the domain of <a href="https://en.wikipedia.org/wiki/Numerical_analysis" rel="nofollow noreferrer">Numerical Analysis</a>; this may be a useful tag for further questions on this subject.</p>
<p>Note that it is considered 'pythonic' for function identifiers to be in snake_case.</p>
<pre><code>from cmath import isclose
def is_gaussian(z):
    #returns True if the complex number is a Gaussian integer
    rounded = complex(round(z.real), round(z.imag))
    return isclose(rounded, z)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could define an epsilon, by using <code>round</code> to round to the desired number of decimal places/precision (e.g. 10):</p>
<pre><code>def IsGaussian(z, prec=10):
    # returns True if the complex number is a Gaussian integer
    # rounds the input number to the `prec` number of digits
    z = complex(round(z.real,prec), round(z.imag,prec))
    return complex(int(z.real), int(z.imag)) == z
</code></pre>
<p>Your code has another issue though:</p>
<pre><code>if IsGaussian(n / complex(x, y)) == n:
</code></pre>
<p>This will only give results for <code>n = 0</code> or <code>n = 1</code>. You probably want to remove the check for equality.     </p>
</div>
<span class="comment-copy">This probably stems from the fact that <code>complex</code> uses two double precision numbers internally for the real and imag part. You could implement your own complex numbers using <a href="https://docs.python.org/2/library/decimal.html" rel="nofollow noreferrer"><code>decimal</code></a>, or <code>round</code> your result to an appropriate number of decimal places.</span>
<span class="comment-copy">Ugh, what is <code>if IsGaussian(n / complex(x, y)) == n:</code> supposed to do? It <i>can</i> only be True for n = 0 or n = 1. You probably want to get rid of the <code>== n</code>.</span>
<span class="comment-copy">You could add the relevant changes to <code>IsGaussian</code> to your answer, to make it complete. :-)</span>
<span class="comment-copy">Edited as suggested.</span>
<span class="comment-copy">If you use <code>cmath.isclose</code> you don't need to round. That's the actual point of <code>cmath.isclose</code>.</span>
<span class="comment-copy">You're misunderstanding the point of is_gaussian.</span>
<span class="comment-copy">Oh, yes, I now see you replaced the conversion to <code>int</code> part with the rounding. My bad.</span>
<span class="comment-copy">Seeing the answer by @EfronLicht, it's obviously better to test with <code>cmath.isclose</code>.</span>
