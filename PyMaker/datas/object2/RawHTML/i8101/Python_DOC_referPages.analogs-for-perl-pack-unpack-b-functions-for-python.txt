<div class="post-text" itemprop="text">
<p>I need to port code from perl that <a href="http://perldoc.perl.org/functions/pack.html" rel="nofollow noreferrer">packs byte string</a>. In perl it looks like the following:</p>
<pre><code>pack 'B*', '0100001000111110010100101101000010010001'
</code></pre>
<p>I don't see <code>B*</code> format analog in <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">python struct module</a>. Perhaps there are ready solutions not to invent a bicycle?</p>
<p>Honestly, <a href="http://perldoc.perl.org/functions/pack.html" rel="nofollow noreferrer">description is not clear for me, so i even can't imagine how it works</a> to implement it by myself:</p>
<blockquote>
<p>Likewise, the b and B formats pack a string that's that many bits
  long. Each such format generates 1 bit of the result. These are
  typically followed by a repeat count like B8 or B64 . </p>
<p>Each result bit
  is based on the least-significant bit of the corresponding input
  character, i.e., on ord($char)%2. In particular, characters "0" and
  "1" generate bits 0 and 1, as do characters "\000" and "\001" .</p>
<p>Starting from the beginning of the input string, each 8-tuple of
  characters is converted to 1 character of output. </p>
<p>With format b , the
  first character of the 8-tuple determines the least-significant bit of
  a character; with format B , it determines the most-significant bit of
  a character. </p>
<p>If the length of the input string is not evenly divisible
  by 8, the remainder is packed as if the input string were padded by
  null characters at the end. Similarly during unpacking, "extra" bits
  are ignored. </p>
<p>If the input string is longer than needed, remaining
  characters are ignored. </p>
<p>A * for the repeat count uses all characters
  of the input field. On unpacking, bits are converted to a string of 0
  s and 1 s.</p>
</blockquote>
<p>So, string is divided in chunks for 8 symbols. If last chunk is less 8 symbols, it is padded with null characters in the end to be 8 symbols. Then, each chunk becomes a byte.</p>
<p>But i can't understand, what are resulting bits? What is meant under B8 and B64 here?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>int</code>-object has a <code>to_bytes</code>-method:</p>
<pre><code>binary = '0100001000111110010100101101000010010001'
number = int(binary, 2)
print(number.to_bytes((number.bit_length()+7)//8, 'big'))
# b'B&gt;R\xd0\x91'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure of the exact perl semantics, but here's my guess at them:</p>
<pre><code>def pack_bit_string(bs):
    ret = b''
    while bs:
        chunk, bs = bs[:8], bs[8:]
        # convert to an integer so we can pack it
        i = int(chunk, 2)
        # Handle trailing chunks that are not 8 bits
        # Note this as an augmented assignment, perhaps also read as
        # i = i &lt;&lt; (8 - len(chunk))
        i &lt;&lt;= 8 - len(chunk)
        ret += struct.pack('B', i)
    return ret
</code></pre>
<p>Comments are inline.  If you know things like "the input is less than 64 bits" you can avoid the loop and use <code>Q</code> for struct.pack</p>
</div>
