<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/23130399/python-threads-and-atomic-operations">Python threads and atomic operations</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I saw examples <a href="https://stackoverflow.com/a/325528/4653485">e.g. here</a> of using an <a href="https://docs.python.org/3/library/threading.html#event-objects" rel="noreferrer"><code>Event</code></a> to stop a thread where I think a boolean flag would do the job.</p>
<h3> Event</h3>
<pre><code>class MyThread(threading.Thread):

    def __init__(self):
        self._please_stop = threading.Event()

    def run(self):
        while not self._please_stop.is_set():
        [...]

    def stop(self):
        self._please_stop.set()
</code></pre>
<h3> Flag</h3>
<pre><code>class MyThread(threading.Thread):

    def __init__(self):
        self._please_stop = False

    def run(self):
        while not self._please_stop:
        [...]

    def stop(self):
        self._please_stop = True
</code></pre>
<p>What is the benefit of using an <code>Event</code>, here? Its <code>wait</code> method is not used. What makes it better than a boolean flag?</p>
<p>I can see the point if the same <code>Event</code> is shared among several threads, but otherwise, I don't get it.</p>
<p><a href="https://bytes.com/topic/python/answers/609036-boolean-flag-vs-threading-event" rel="noreferrer">This mailing list thread</a> suggests that <code>Event</code> would be safer, but it's unclear to me why.</p>
<p>More precisely, I don't understand those two paragraphs:</p>
<blockquote>
<p>If I understand the GIL correctly, it synchronizes all access to
  Python data structures (such as my boolean 'terminated' flag). If that
  is the case, why bother using threading.Event for this purpose?</p>
<p>The GIL is an implementation detail and relying on it to synchronize
  things for you isn't futureproof. You're likely to have lots of
  warning, but using threading.Event() isn't any harder, and it's more
  correct and safer in the long term.</p>
</blockquote>
<p>I agree that using an <code>Event</code> adds close to no overhead, so I can stick to that, but I'd like to understand the limits of the flag approach.</p>
<p>(I'm using Python3, so I'm not concerned by Python2 limitations, if any, although those would be totally worth mentioning here.)</p>
</div>
<div class="post-text" itemprop="text">
<p>I think that the implication in the thread you quote is that setting a boolean is not necessarily an <a href="https://stackoverflow.com/q/15054086/2988730">atomic</a> operation in Python. While having a global lock on all Python objects (the GIL) makes all operations that set an attribute <em>appear</em> atomic for the moment, such a lock may not exist in the future. Using <code>Event</code> makes the operation atomic because it uses its own lock for access.</p>
<p>The link for atomic is to a Java  question, but it is no less relevant because of that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Programming is often not just about getting the code to work today, it's about keeping it working through changes that will be made in the future.</p>
<ul>
<li>Other Python implementations don't have the GIL. Will I want to run it on <a href="http://pypy.org/" rel="nofollow noreferrer">pypy</a> tomorrow?</li>
<li>Actually, I need to spread the work across several processes. Swap in <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer"><code>multiprocessing</code></a>... which implements <code>Event()</code> but will fail if you're just using a local variable.</li>
<li>Turns out the code should stop only if several other threads think it should. Well, use <code>Semaphore()</code> instead of <code>Event()</code>... but would be easy to implement incorrectly with variables.</li>
</ul>
<p>So, it's likely you can write multithreaded programs perfectly correctly in Python relying on how the bytecode gets interrupted and when the GIL can be released... but if I am reading and changing your code later, I'd be much happier if you used the standard synchronization primitives.</p>
</div>
<span class="comment-copy">Rather than write your own thread loop, why not use ThreadPoolExecutor or something similar?</span>
<span class="comment-copy">@clay. That has nothing to do with the point of the question. It is useful to understand how abstractions work for those cases when they break down.</span>
<span class="comment-copy">@MadPhysicist Python <code>ThreadPoolExecutor</code> has this exact behavior and functionality. I would presume that the official standard library has the best practices way to stop a thread.</span>
<span class="comment-copy">Actually neither is great. Imagine that your thread code needs to delay (a.k.a. <code>time.sleep()</code>) how will the thread be terminated in a timely manner?</span>
<span class="comment-copy">The missing part was the fact that setting the boolean is not necessarily atomic. I always assumed it was. I shall read more about the GIL. This explains the Lock in Event. Searching with the right terms, I found <a href="http://stackoverflow.com/questions/23130399/python-threads-and-atomic-operations#23130849">another question</a> that my question duplicates.</span>
<span class="comment-copy">I believe that the standard operating procedure would be to close your question as a duplicate now that you found that other question.</span>
<span class="comment-copy">It actually is atomic in your context, where you know what Python you're using. So, it's more of a code style issue rather than a code correctness one.</span>
<span class="comment-copy">@mad-physicist But technically correct is the best kind of correct! Until your code implodes. :)</span>
<span class="comment-copy">@gz. You can always create a contractual obligation by putting a big notice for your project saying something like "This code has only been verified to run correctly with interpreter X".</span>
<span class="comment-copy">Thanks. As I wrote in reply to <a href="http://stackoverflow.com/a/43879450/4653485">Mad Physicist's answer</a>, the problem here was that I always assumed setting a boolean was atomic, so I didn't get the GIL issue. I totally agree relying on a single implementation is not ideal, especially if doing otherwise is that cheap. And I also agree about futureproofing code (hence my question).</span>
