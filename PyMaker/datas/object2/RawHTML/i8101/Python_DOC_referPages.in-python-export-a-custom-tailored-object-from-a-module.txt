<div class="post-text" itemprop="text">
<p>In <strong>JavaScript</strong>, specifically in <strong>node.js</strong> setting, one can spell <code>module.exports = 13;</code> in <code>module.js</code>, then <code>x = import ("module.js");</code> elsewhere and have 13 assigned to <em>x</em> directly.</p>
<p>This saves some code when a module exports a single function, and I notice a lot of widely used packages (such as <em>through2</em>) make use of it.</p>
<p>Is there a way to do the same in <strong>Python</strong>? With some black magic, maybe?</p>
<p>I do have heard of a thing called <em>loader</em> that's, I guess, supposed to do some manipulations with a module before making it available. In particular, I think <em>SaltStack</em> makes use of something like that in <code>salt.loader</code>, but the code is too hard for me to follow. I imagine we could write a function similar to this:</p>
<pre><code>def loader(module):
    m = __import__(module)
    return m["__exports__"]
</code></pre>
<p>â€” Then define <code>__exports__</code> somewhere in a module we want to import and enjoy functionality very similar to <strong>JavaScript</strong>'s <code>module.exports</code> mechanics. But unfortunately <code>TypeError: 'module' object has no attribute '__getitem__'</code> prevents us from doing that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has importing built in to the language at a more basic level than Javascript does, almost all use cases are covered by a simple <a href="https://docs.python.org/3/reference/simple_stmts.html#import" rel="nofollow noreferrer">import statement</a>.</p>
<p>For your example, all it really boils down to is:</p>
<pre class="lang-py prettyprint-override"><code>from module import exports as x
</code></pre>
<p>So, there's not need to look for code savings by changing <code>module</code>.</p>
<p>The other part of the question is how, as a module author, would you restrict people to seeing only a single symbol.</p>
<p>Generally this is not required except to help users know what are public functions vs implementation details. Python has a few common idioms for this:</p>
<ul>
<li>Any names that start with a leading underscore, such as <code>_helper</code>, are considered <em>private</em>. They can be accessed as normal, but the implication is you should not.</li>
<li>If a module level variable <code>__all__ = [...]</code> exists, only the strings it contains are considered <em>public</em>. The names must seperatedly be declared in the module.</li>
</ul>
<p>As well as being documentation, both of these do affect one aspect of the module import:</p>
<pre class="lang-py prettyprint-override"><code>from module import *
</code></pre>
<p>Using a star import is generally discouraged, but only <em>public names</em> will be brought in to the local namespace.</p>
</div>
<div class="post-text" itemprop="text">
<p>After some thinking I understood that, while we can't say <code>m["__exports__"]</code> due to module object's class not having <code>__getitem__</code> method, we can still access some of the module's elements with <em>"dot"</em> notation: <code>m.__exports__</code> works.</p>
<p>Another way: screen all module level names off with an underscore and assign the object to be exported to a variable named after the module, then <code>from module import *</code>.</p>
<p><em>loader.py:</em></p>
<pre><code>def loader(module):
    m = __import__(module)
    return m.__exports__
</code></pre>
<p><em>exports.py:</em></p>
<pre><code>def _f():
    return 13

_a = 31

exports = {"p6": _f, "p8": _a}

__exports__ = exports
</code></pre>
<p><em>Python 2.7:</em></p>
<pre><code>&gt;&gt;&gt; import loader
&gt;&gt;&gt; e = loader.load ("exports")
&gt;&gt;&gt; e
{'p8': 31, 'p6': &lt;function _f at 0x7fb79d494cf8&gt;}
&gt;&gt;&gt; from exports import *
&gt;&gt;&gt; exports
{'p8': 31, 'p6': &lt;function _f at 0x7fb79d494cf8&gt;}
</code></pre>
<p><em>Python 3:</em></p>
<pre><code>&gt;&gt;&gt; import loader
&gt;&gt;&gt; e = loader.load ("exports")
&gt;&gt;&gt; e
{'p6': &lt;function _f at 0x7f88ae229ae8&gt;, 'p8': 31}
&gt;&gt;&gt; from exports import *
&gt;&gt;&gt; exports
{'p6': &lt;function _f at 0x7f88ae229ae8&gt;, 'p8': 31}
</code></pre>
<p>In the first way proposed, I unfortunately cannot use <code>__all__</code> in <code>loader.load</code> to filter only listed names from a module being loaded since <code>__getitem__</code> is not defined for module object.</p>
<p>In the second way proposed I don't get so much control (in that a malicious module can export arbitrary names and manipulate my namespace) and flexibility (in that I cannot assign the module's exported object to arbitrary name anywhere in my code).</p>
<p>So, there is still a bit left to be desired here.</p>
</div>
