<div class="post-text" itemprop="text">
<p>I want to define a class containing <code>read</code> and <code>write</code> methode, which can be called as follows:</p>
<pre><code>instance.read
instance.write
instance.device.read
instance.device.write
</code></pre>
<p>To not use interlaced classes, my idea was to overwrite the <code>__getattr__</code> and <code>__setattr__</code> methods and to check, if the given name is <code>device</code> to redirect the return to <code>self</code>. But I encountered a problem giving infinite recursions. The example code is as follows:</p>
<pre><code>class MyTest(object):
    def __init__(self, x):
        self.x = x

    def __setattr__(self, name, value):
        if name=="device":
            print "device test"
        else:
            setattr(self, name, value)

test = MyTest(1)
</code></pre>
<p>As in <code>__init__</code> the code tried to create a new attribute <code>x</code>, it calls <code>__setattr__</code>, which again calls <code>__setattr__</code> and so on. How do I need to change this code, that, in this case, a new attribute <code>x</code> of <code>self</code> is created, holding the value <code>1</code>? </p>
<p>Or is there any better way to handle calls like <code>instance.device.read</code> to be 'mapped' to <code>instance.read</code>? </p>
<p>As there are always questions about the why: I need to create abstractions of <code>xmlrpc</code> calls, for which very easy methods like <code>myxmlrpc.instance,device.read</code> and similar can be created. I need to 'mock' this up to mimic such multi-dot-method calls.</p>
</div>
<div class="post-text" itemprop="text">
<p>You must call the parent class <code>__setattr__</code> method:</p>
<pre><code>class MyTest(object):

    def __init__(self, x):
        self.x = x

    def __setattr__(self, name, value):
        if name=="device":
            print "device test"
        else:
            super(MyTest, self).__setattr__(name, value)
            # in python3+ you can omit the arguments to super:
            #super().__setattr__(name, value)
</code></pre>
<p>Regarding the best-practice, since you plan to use this via <code>xml-rpc</code> I think this is probably better done inside the <a href="http://docs.python.org/2/library/simplexmlrpcserver.html#SimpleXMLRPCServer.SimpleXMLRPCServer.register_instance" rel="noreferrer"><code>_dispatch</code></a> method.</p>
<p>A quick and dirty way is to simply do:</p>
<pre><code>class My(object):
    def __init__(self):
        self.device = self
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or you can modify <code>self.__dict__</code> from inside <code>__setattr__()</code>:</p>
<pre><code>class SomeClass(object):

    def __setattr__(self, name, value):
        print(name, value)
        self.__dict__[name] = value

    def __init__(self, attr1, attr2):
        self.attr1 = attr1
        self.attr2 = attr2


sc = SomeClass(attr1=1, attr2=2)

sc.attr1 = 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <strong>object</strong>.</p>
<pre><code>class TestClass:
    def __init__(self):
            self.data = 'data'
    def __setattr__(self, name, value):
            print("Attempt to edit the attribute %s" %(name))
            object.__setattr__(self, name, value)
</code></pre>
</div>
<span class="comment-copy">I like the quick-and-dirty way: Just one line to get the desired behaviour! Thanks</span>
<span class="comment-copy">This is also mentioned in the <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer">Python docs</a>.</span>
