<div class="post-text" itemprop="text">
<p>I am trying to subclass <code>json.JSONEncoder</code> such that named tuples (defined using the new Python 3.6+ syntax, but it probably still applies to the output of <code>collections.namedtuple</code>) are serialised to JSON objects, where the tuple fields correspond to object keys.</p>
<p>For example:</p>
<pre><code>from typing import NamedTuple

class MyModel(NamedTuple):
    foo:int
    bar:str = "Hello, World!"

a = MyModel(123)           # Expected JSON: {"foo": 123, "bar": "Hello, World!"}
b = MyModel(456, "xyzzy")  # Expected JSON: {"foo": 456, "bar": "xyzzy"}
</code></pre>
<p>My understanding is that I subclass <code>json.JSONEncoder</code> and override its <code>default</code> method to provide serialisations for new types. The rest of the class will then do the right thing with respect to recursion, etc. I thus came up with the following:</p>
<pre><code>class MyJSONEncoder(json.JSONEncoder):
    def default(self, o):
        to_encode = None

        if isinstance(o, tuple) and hasattr(o, "_asdict"):
            # Dictionary representation of a named tuple
            to_encode = o._asdict()

        if isinstance(o, datetime):
            # String representation of a datetime
            to_encode = o.strftime("%Y-%m-%dT%H:%M:%S")

        # Why not super().default(to_encode or o)??
        return to_encode or o
</code></pre>
<p>This works when it tries to serialise (i.e., as the <code>cls</code> parameter to <code>json.dumps</code>) a <code>datetime</code> value -- to at least partially prove my hypothesis -- but the check for named tuples is never hit and it defaults to serialising it as a tuple (i.e., to a JSON array). Weirdly, I had presumed that I should call the superclass' <code>default</code> method on my transformed object, but this then raises an exception when it tries to serialise a <code>datetime</code>: "TypeError: Object of type 'str' is not JSON serializable", which frankly makes no sense!</p>
<p>I get the same behaviour if I make the named tuple type check more specific (e.g., <code>isinstance(o, MyModel)</code>). I did find, however, that I can <em>almost</em> get the behaviour I'm looking for if I also override the <code>encode</code> method, by moving the named tuple check to there:</p>
<pre><code>class AlmostWorkingJSONEncoder(json.JSONEncoder):
    def default(self, o):
        to_encode = None

        if isinstance(o, datetime):
            # String representation of a datetime
            to_encode = o.strftime("%Y-%m-%dT%H:%M:%S")

        return to_encode or o

    def encode(self, o):
        to_encode = None

        if isinstance(o, tuple) and hasattr(o, "_asdict"):
            # Dictionary representation of a named tuple
            to_encode = o._asdict()

        # Here we *do* need to call the superclass' encode method??
        return super().encode(to_encode or o)
</code></pre>
<p>This works, but not recursively: It successfully serialises top-level named tuples into JSON objects, per my requirement, but any named tuples that exist within that named tuple will be serialised with the default behaviour (JSON array). This is also the behaviour if I put the named tuple type check in both the <code>default</code> <em>and</em> <code>encode</code> methods.</p>
<p>The documentation implies that only the <code>default</code> method should be changed in subclasses. I presume, for example, that overriding <code>encode</code> in <code>AlmostWorkingJSONEncoder</code> will cause it to break when it's doing chunked encoding. However, no amount of hackery has so far yielded what I want (or expect to happen, given the scant documentation).</p>
<p>Where is my misunderstanding?</p>
<hr/>
<p><strong>EDIT</strong> Reading the code for <code>json.JSONEncoder</code> explains why the <code>default</code> method raises a type error when you pass it a string: It's not clear (at least to me) from the documentation, but the <code>default</code> method is meant to transform values of some unsupported type into a serialisable type, which is then returned; if the unsupported type is not transformed into anything in your overridden method, then you <em>should</em> call <code>super().default(o)</code> at the end to invoke a type error. So something like this:</p>
<pre><code>class SubJSONEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, Foo):
            return SerialisableFoo(o)

        if isinstance(o, Bar):
            return SerialisableBar(o)

        # etc., etc.

        # No more serialisation options available, so raise a type error
        super().default(o)
</code></pre>
<p>I believe the problem I'm experiencing is that the <code>default</code> method is only called by the encoder when it can't match any supported types. A named tuple is still a tuple -- which <em>is</em> supported -- so it matches that first before delegating to my overridden <code>default</code> method. In Python 2.7, the functions that did this matching are part of the <code>JSONEncoder</code> object, but in Python 3, they seem to have been moved outside into the module namespace (and, thus, not accessible to userland). I thus believe it is not possible to subclass <code>JSONEncoder</code> to serialise named tuples in a generic way without doing a lot of rewriting and hard-coupling to your own implementation :(</p>
<p><strong>EDIT 2</strong> I submitted this as a <a href="http://bugs.python.org/issue30343" rel="noreferrer">bug</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>What are you doing wrong is this this</p>
<pre><code> if isinstance(o, tuple) and hasattr(o, "_asdict"):
</code></pre>
<p>Your object <code>o</code> is not of type <code>tuple</code>. Not even <code>NamedTuple</code>. It is of type <code>MyModel</code> or whatever definitions you have of <code>class MySomething(NamedTuple)</code>.</p>
<p>So, in order to do what you want, you have to change that <code>if</code> into</p>
<pre><code>if isinstance(o, MyModel):
</code></pre>
<p>Or, if you have multiple models/classes defined from <code>NamedTuple</code></p>
<pre><code>if isinstance(o, (MyModel1, MyModel2, MyModel3, ...)):
</code></pre>
<p>Also, don't forget about the "super" <code>default</code>. Like in <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder.default" rel="nofollow noreferrer">the docs</a>.</p>
<p>Complete code:</p>
<pre><code>class MyJSONEncoder(json.JSONEncoder):
def default(self, o):
    to_encode = None

    if isinstance(o, MyModel):
        # Dictionary representation of a named tuple
        to_encode = o._asdict()

    if isinstance(o, datetime):
        # String representation of a datetime
        to_encode = o.strftime("%Y-%m-%dT%H:%M:%S")

   return json.JSONEncoder.default(self, o)
</code></pre>
</div>
<span class="comment-copy">Note that <a href="http://stackoverflow.com/a/5913148/876937">this answer</a> exhibits the expected behaviour, but it relies upon Python 2.7 API calls which no longer exist in Python 3. Overriding the new <code>iterencode</code> method doesn't seem to work any better than overriding <code>encode</code>.</span>
<span class="comment-copy">You may want to look at this<a href="https://stackoverflow.com/a/17684652/6065971">answeer</a> as an approach to solve your problem.</span>
<span class="comment-copy">Actually <code>isinstance()</code> does return True for superclasses, and <i>tuple</i> is a superclass of the MyModel class (I checked; oddly enough it's not a superclass of NamedTuple; I don't even want to know what strange magic is responsible).</span>
<span class="comment-copy">So <code>isinstance(o, tuple)</code> was completely fine.</span>
<span class="comment-copy"><code>isinstance(o, tuple)</code> is fine if <code>o</code> is an actual tuple, not <code>NamedTuple</code> or <code>namedtuples</code>. Those are just "factories" that generates the given class structure.</span>
<span class="comment-copy">Check it in the interpreter. It's a tuple.</span>
<span class="comment-copy">Strange, I know that I checked at the time of writing and it was <code>False</code>. Checked again and it's <code>True</code>.</span>
