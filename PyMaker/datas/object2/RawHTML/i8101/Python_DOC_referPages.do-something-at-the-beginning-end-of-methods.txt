<div class="post-text" itemprop="text">
<p>Is there an easy way to do something at the beginning and end of each function in a class? I've looked into <code>__getattribute__</code>, but I don't think that I can use it in this situation?</p>
<p>Here's a simplified version of what I'm trying to do:</p>
<pre><code>class Thing():
    def __init__(self):
        self.busy = False

    def func_1(self):
        if self.busy: 
            return None
        self.busy = True
          ...
        self.busy = False

    def func_2(self):
        if self.busy: 
            return None
        self.busy = True
          ...
        self.busy = False
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use decorators (if you don't know them you can refer to <a href="https://www.python.org/dev/peps/pep-0318" rel="noreferrer">PEP-318</a>):</p>
<pre><code>def decorator(method):
    def decorated_method(self, *args, **kwargs):
        # before the method call
        if self.busy:
            return None
        self.busy = True

        # the actual method call
        result = method(self, *args, **kwargs)  

        # after the method call
        self.busy = False

        return result

    return decorated_method

class Thing():
    def __init__(self):
        self.busy = False

    @decorator
    def func_1(self):
        ...

    @decorator
    def func_2(self):
        ...
</code></pre>
<p>You might want to use <a href="https://docs.python.org/library/functools.html#functools.wraps" rel="noreferrer"><code>functools.wraps</code></a> if you want the decorated method to "look like" the original method. The <code>@decorator</code> is just syntactic sugar, you could also apply the decorator explicitly:</p>
<pre><code>class Thing():
    def __init__(self):
        self.busy = False

    def func_1(self):
        ...

    func_1 = decorator(func_1)  # replace "func_1" with the decorated "func_1"
</code></pre>
<p>In case you really want to apply it to all methods you can additionally use a class decorator:</p>
<pre><code>def decorate_all_methods(cls):
    for name, method in cls.__dict__.items():
        if name.startswith('_'):  # don't decorate private functions
            continue 
        setattr(cls, name, decorator(method))
    return cls

@decorate_all_methods
class Thing():
    def __init__(self):
        self.busy = False

    def func_1(self):
        ...

    def func_2(self):
        ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As an alternative to the accepted answer, if you want this decoration to only be applicable for instance methods, you could use <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code></a>.</p>
<pre><code>class Thing(object):
    def __init__(self):
        self.busy = False

    def __getattribute__(self, name):
        attr = object.__getattribute__(self, name)
        if callable(attr) and not name.startswith('_') and attr.__self__ == self:
            attr = decorator(attr)

        return attr

    def func_1(self):
        # instance method will be wrapped by `decorator`
        ...

    @classmethod
    def class_func(cls):
        # class method will not be wrapped by `decorator`
        # when called using `self.`, `cls.` or `Thing.`.
        ...

    @staticmethod
    def static_func():
        # static method will not be wrapped by `decorator`
        # when called using `Thing.`.
        ...
</code></pre>
<ul>
<li>This requires <code>object</code> and will not work for old-style classes in Python 2.</li>
<li><a href="https://docs.python.org/3/library/functions.html#callable" rel="nofollow noreferrer"><code>callable</code></a> was removed in Python 3.0, but returned in 3.2. Alternatively, <code>isinstance(obj, collections.Callable)</code> can be used.</li>
</ul>
<p>If you'd like to wrap class methods and static methods differently, you could inherit from a custom <code>type</code> <code>metaclass</code>:</p>
<pre><code>class Meta(type):
    def __getattribute__(*args):
        print("staticmethod or classmethod invoked")
        return type.__getattribute__(*args)


class Thing(object, metaclass=Meta):
    ...
    def __getattribute__(self, name):
        attr = object.__getattribute__(self, name)
        if callable(attr) and not name.startswith('_'):
            if attr.__self__ == self:
                attr = decorator(attr)
            else:
                attr = Meta.__getattribute__(Thing, name)

        return attr
</code></pre>
<p>The above <code>metaclass=Meta</code> is Python 3 syntax. In Python 2, it must be defined as:</p>
<pre><code>class Thing(object):
    __metaclass__ = Meta
</code></pre>
</div>
<span class="comment-copy">Just wondering, why would you want to do that?</span>
<span class="comment-copy">@abccd Do you mean why he would want to use <code>self.busy</code> like that?</span>
<span class="comment-copy">Yes, that's what I meant</span>
<span class="comment-copy">I'm making things in <code>tkinter</code>, and I don't want mouse or keyboard input to interrupt anything</span>
<span class="comment-copy">Shoot!, Beat me to it ;-)</span>
<span class="comment-copy">This works perfectly! Thank you! Also, does it have to be called <code>decorator</code>, or can it be called anything?</span>
<span class="comment-copy">@diligar You can call it whatever you want. Just make sure the name you give it is meaningful.</span>
<span class="comment-copy">No, it doesn't have to be called <code>decorator</code>. I just named it like that because I wasn't very imaginative.</span>
<span class="comment-copy">I would only add that the decorator syntax is syntactic sugar for <code>some_fun = decorator(some_fun)</code></span>
