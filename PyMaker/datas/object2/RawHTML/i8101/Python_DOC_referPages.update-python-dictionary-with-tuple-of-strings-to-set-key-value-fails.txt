<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow noreferrer"><code>dict.update([other])</code></a> says</p>
<blockquote>
<p>Update the dictionary with the key/value pairs from <em>other</em>, overwriting existing keys. Return <em>None</em>.</p>
<p>update() accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: d.update(red=1, blue=2).</p>
</blockquote>
<p>But </p>
<pre><code>&gt;&gt;&gt; {}.update( ("key", "value") )
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: dictionary update sequence element #0 has length 3; 2 is required
</code></pre>
<p>So why does Python apparently try to use the first string of the tuple?</p>
</div>
<div class="post-text" itemprop="text">
<p>The immediate solution is this: the only argument <code>other</code> is <em>optional</em> and an <strong>iterable</strong> of tuples (or other iterables of length two).</p>
<p>No argument (it's optional, for when you don't need it :-):</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d.update()
&gt;&gt;&gt; d
{}
</code></pre>
<p>List with the tuple (don't confuse this with the square brackets enclosing optional arguments!):</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d.update([("key", "value")])
&gt;&gt;&gt; d
{'key': 'value'}
</code></pre>
<p>According to the <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow noreferrer">Python glossary on iterables</a>, a tuple (as all sequence types) is also an iterable, however this fails:</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d.update((("key", "value")))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: dictionary update sequence element #0 has length 3; 2 is required
</code></pre>
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="nofollow noreferrer">Python documentation on <code>tuple</code></a> again solves this mystery:</p>
<blockquote>
<p>Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity.</p>
</blockquote>
<p>I.e. <code>(None)</code> is not a tuple at all, but <code>(None,)</code> is:</p>
<pre><code>&gt;&gt;&gt; type( (None,) )
&lt;class 'tuple'&gt;
</code></pre>
<p>So this works:</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d.update((("key", "value"),))
&gt;&gt;&gt; d
{'key': 'value'}
&gt;&gt;&gt;
</code></pre>
<p>but this doesn't </p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d.update(("key", "value"),)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: dictionary update sequence element #0 has length 3; 2 is required
</code></pre>
<p>because of said <em>syntactic ambiguity</em> (comma is function argument separator).</p>
</div>
