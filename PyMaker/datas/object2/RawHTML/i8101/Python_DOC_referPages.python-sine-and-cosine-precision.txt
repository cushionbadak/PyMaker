<div class="post-text" itemprop="text">
<p>How to improve python sine and cosine precision? For example I want to use follow code (just calculate y = cos(acos(x)) for a random complex vector x):</p>
<pre><code>import numpy as np
N = 100000
x = np.zeros(N)+1j*np.zeros(N)
for k in range(0,N):
    x[k] = np.random.normal(0,500)+1j*np.random.normal(0,500)    
y = np.cos(np.arccos(x))

m= np.max(np.abs(x))

print np.max(np.abs(x-y)/m)
</code></pre>
<p><strong>y</strong> must be equal <strong>x</strong>. But my difference is approx <strong>1E-9</strong>. I think is too big. For example matlab returns <strong>less than 1E-15</strong> for the same test. There is some way to improve python precision? Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Before reading this: this may not be a correct answer, because it is extremely unefficient, but if you need extra precission, this could be the best solution.</p>
<p>You can use a <code>Decimal</code> class, where you can calculate with any precition you want (it calculates using string objects, not integers).</p>
<pre><code>&gt;&gt;&gt; from decimal import *
&gt;&gt;&gt; getcontext().prec = 30
&gt;&gt;&gt; Decimal(1) / Decimal(7)
Decimal('0.142857142857142857142857142857')
</code></pre>
<p>But the problem is that you will have to implement your own trinogometry functions. Luckily python website has provided examples:</p>
<p><a href="https://docs.python.org/3/library/decimal.html#recipes" rel="nofollow noreferrer">https://docs.python.org/3/library/decimal.html#recipes</a></p>
<pre><code>def cos(x):
    """Return the cosine of x as measured in radians.

    The Taylor series approximation works best for a small value of x.
    For larger values, first compute x = x % (2 * pi).

    &gt;&gt;&gt; print(cos(Decimal('0.5')))
    0.8775825618903727161162815826
    &gt;&gt;&gt; print(cos(0.5))
    0.87758256189
    &gt;&gt;&gt; print(cos(0.5+0j))
    (0.87758256189+0j)

    """
    getcontext().prec += 2
    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1
    while s != lasts:
        lasts = s
        i += 2
        fact *= i * (i-1)
        num *= x * x
        sign *= -1
        s += num / fact * sign
    getcontext().prec -= 2
    return +s
</code></pre>
<p>Note that this will affect execution time of your program, because calculating with strings is obviously much slower than with floats.</p>
</div>
<div class="post-text" itemprop="text">
<p>Problem is disappear after  python reinstall. Thanks for comments</p>
</div>
<span class="comment-copy">What version of python are you using because I tried your example on 3.5 and 2.7 and both returned a E-16 level of precision</span>
<span class="comment-copy">using ver 3.5, I get 1.2... E -15.  Also, (not criticizing, just curious) why do you need that much precision?</span>
<span class="comment-copy">I'm using python 2.7.10 32 bits (Spyder 2.3.5.2). I need good precision because I plan to use trigonometric function in some iterative algorithms. As result error can be accumulated from iteration to iteration.</span>
<span class="comment-copy">accounting for accumulating error (in any language) could be a week-long CS course; for now, I'll point you to the decimal class in python, which may help you out <a href="https://docs.python.org/2/library/decimal.html" rel="nofollow noreferrer">docs.python.org/2/library/decimal.html</a></span>
<span class="comment-copy">Also 9.83356475295e-16 for me. I don't think this is an issue with Python, but with compiled libraries (Numpy would be my first guess) in your case.</span>
<span class="comment-copy">There are packages like <a href="https://pypi.python.org/pypi/bigfloat/" rel="nofollow noreferrer">pypi.python.org/pypi/bigfloat</a>. I would not recommend implementing your own trigonometry as these packages wrap efficient C libraries and custom Python implementations will be slow.</span>
<span class="comment-copy">I think OP's main problem is that his Python behaves somewhat weird in that he gets e-9 errors. I wouldn't expect any issues working with errors in the e-16 range.</span>
