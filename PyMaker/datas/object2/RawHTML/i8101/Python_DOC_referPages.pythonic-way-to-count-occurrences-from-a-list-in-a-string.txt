<div class="post-text" itemprop="text">
<p>What's the best way to find the count of occurrences of strings from a list in a target string? Specifically, I have a list :</p>
<pre><code>string_list = [
    "foo",
    "bar",
    "baz"
]

target_string = "foo bar baz bar"

# Trying to write this function!
count = occurrence_counter(target_string) # should return 4
</code></pre>
<p>I'd like to optimize to minimize speed and memory usage, if that makes a difference. In terms of size, I would expect that <code>string_list</code> may end up containing several hundred substrings.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works!</p>
<pre><code>def occurrence_counter(target_string):
    return sum(map(lambda x: x in string_list, target_string.split(' ')))
</code></pre>
<p>The string gets split into tokens, then each token gets transformed into a 1 if it is in the list, a 0 otherwise. The sum function, at last, sums those values.</p>
<p>EDIT: also:</p>
<pre><code>def occurrence_counter(target_string):
    return len(list(filter(lambda x: x in string_list, target_string.split(' '))))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collelctions.Counter</a>:</p>
<pre><code>from collections import Counter
word_counts = Counter(target_string.split(' '))
total = sum(word_counts.get(w, 0)) for w in string_list)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This Python3 should work:</p>
<pre><code>In [4]: string_list = [
   ...:     "foo",
   ...:     "bar",
   ...:     "baz"
   ...: ]
   ...: 
   ...: set_of_counted_word = set(string_list)
   ...: 
   ...: def occurrence_counter(target_str, words_to_count=set_of_counted_word):
   ...:     return sum(1 for word in target_str.strip().split()
   ...:                if word in words_to_count)
   ...: 
   ...: 
   ...: for target_string in ("foo bar baz bar", " bip foo bap foo dib baz   "):
   ...:     print("Input: %r -&gt; Count: %i" % (target_string, occurrence_counter(target_string)))
   ...: 
   ...: 
Input: 'foo bar baz bar' -&gt; Count: 4
Input: ' bip foo bap foo dib baz   ' -&gt; Count: 3

In [5]:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a variable to store a running count is you iterate through the list like so:</p>
<pre><code>def occurence_counter(x):
    count = 0
    for y in x:
        count +=1
    return count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another solution:</p>
<pre><code>def occurrence_counter(target_string, string_list):
    target_list = target_string.split(' ')
    return len([w for w in target_list if w in string_list])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Combo of <code>sum</code> and <code>string.count</code>:</p>
<pre><code>def counter(s, lst)
    return sum(s.count(sub) for sub in lst)
</code></pre>
<p>This will not count overlapping occurrences of the same pattern.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://en.wikipedia.org/wiki/Trie" rel="nofollow noreferrer">Trie</a> to convert your substrings to a regex pattern (e.g. <code>(?:ba[rz]|foo)</code>) and parse your <code>target_string</code>:</p>
<pre><code>import re
from trie import Trie

trie = Trie()

substrings = [
    "foo",
    "bar",
    "baz"
]
for substring in substrings:
    trie.add(substring)
print(trie.pattern())
# (?:ba[rz]|foo)

target_string = "foo bar baz bar"
print(len(re.findall(trie.pattern(), target_string)))
# 4
</code></pre>
<p>The required library is here : <a href="https://gist.github.com/EricDuminil/8faabc2f3de82b24e5a371b6dc0fd1e0" rel="nofollow noreferrer"><code>trie.py</code></a></p>
<p>It should be much faster than parsing the whole <code>target_string</code> for each <code>substring</code>, but it might not return the desired result for overlapping substrings. It returns <code>2</code> for <code>["foo", "bar", "foobar"]</code> and <code>"foobar"</code>.</p>
<p>A related question was : "<a href="https://stackoverflow.com/questions/42742810/speed-up-millions-of-regex-replacements-in-python-3/42789508#42789508">Speed up millions of regex replacements in Python 3</a>" : here's an <a href="https://stackoverflow.com/a/42747503/6419007">answer with sets</a> and <a href="https://stackoverflow.com/a/42789508/6419007">one with a trie regex</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure this is the most pythonic way, but you can try it:</p>
<pre><code>string_list_B = target_string.split(" ")
commonalities = set(string_list) - (set(string_list) - set(string_list_B))
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/15375093/python-get-number-of-items-from-listsequence-with-certain-condition">python: get number of items from list(sequence) with certain condition</a></span>
<span class="comment-copy">Use suffix tries. Create a trie with your patterns and then iterate over the text while exploring the tree for occurences. Imagine that one of your patterns is <code>aaa</code> and your text is <code>aaaaa</code>. Solution should be 3 which you can achieve using suffix tries.</span>
<span class="comment-copy">Are you strings always space separated words?</span>
<span class="comment-copy">Also, what should be the result for <code>["foo", "bar", "foobar"]</code> and <code>"foobar"</code>?</span>
<span class="comment-copy">Thanks for the good questions - my use case today is a list of space-delimited words where the entire word needs to be matched (i.e., no 'foobar'-like issues)</span>
<span class="comment-copy">In this case <code>1 if x if string_list else 0</code> is the same as <code>x in string_list</code>. But anyway, that does not count number of occurrences.</span>
<span class="comment-copy">You're right, edited. Why should it not count the occurrences?</span>
<span class="comment-copy">If a string appears in the target list few times, the OP wants it to be counted each time (so the expected result in the example is 4, though the <code>string_list</code> contains only 3 elements).</span>
<span class="comment-copy">It does return 4 :) each token will be 1 if it is in the <code>string_list</code>. In the example it would be <code>[1, 1, 1, 1]</code> so sum is 4</span>
<span class="comment-copy">Ah right, you map over the <code>target_string</code>, sorry!</span>
<span class="comment-copy">Exactly. It's fast, it's efficient and readable.</span>
<span class="comment-copy">Does not answer the question, though! It says nowhere to only consider complete space-separated tokens. Occurrences in a string seems a more complex problem.</span>
<span class="comment-copy">@schwobaseggl The OP also didn't say anything about complexity :) It answers what was asked in the question.</span>
<span class="comment-copy">Nice handling of extra spaces and padding.</span>
<span class="comment-copy">string.count will not work for overlapping patters.</span>
<span class="comment-copy">@SembeiNorimaki: It's not yet clear what the desired result is with overlapping patterns.</span>
<span class="comment-copy">@SembeiNorimaki True. That feels like an edge-case, though. It is however pythonic, built-in, concise, and probably more performant than the other suggestions that suffer from the same problem to an even higher degree ;)</span>
<span class="comment-copy">Why should it be more performant than other solutions? There's no optimization, so it's <code>O(m*n)</code> with <code>n</code> characters and <code>m</code> elements in lst. If the elements are separated by spaces, the <code>Counter</code> solution is much faster. If not, a Trie solution would be much faster.</span>
<span class="comment-copy">@EricDuminil True, however, a trie solution is not suggested (as an answer) and the token <code>Counter</code> does not take nearly as many substrings into consideration. In fact, there are no solutions here that do a true substring occurrrences count.</span>
<span class="comment-copy">Would this make sense if <code>substrings</code> contained 2-300 words?</span>
<span class="comment-copy">@KevinBedell: With 2 words, surely not. With many dozens or a few hundreds, yes. The linked answers had many thousands, and the trie regex was 1000 faster than the regex union.</span>
<span class="comment-copy">@KevinBedell: The accepted answer isn't efficient, and only works with complete words, separated by spaces.</span>
<span class="comment-copy">My current need is only to work with complete words that are separated by spaces. It has the advantage of not requiring anything but builtin functions,  is concise and took almost no time to adapt to my needs.  After I finished coding my work, I chose the answer that was most useful in solving my problem. I upvoted this answer as I felt it was a solid answer as well.</span>
<span class="comment-copy">@KevinBedell: Sorry, I didn't want to sound rude. I understand your needs better now. In this case, you might want to use the <code>Counter</code> solution, which should be the fastest and cleanest one.</span>
<span class="comment-copy">I don't think this counts occurrences, but it does find the words that are in the list.</span>
<span class="comment-copy">@Kevin Bedell I agree, I guess one can find the "unique" occurrences by the length of the set</span>
