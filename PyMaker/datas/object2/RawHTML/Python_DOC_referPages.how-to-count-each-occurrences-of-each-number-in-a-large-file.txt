<div class="post-text" itemprop="text">
<p>I'm quite a beginner in Python and I was wondering if anyone could help me resolve this problem.</p>
<p>I have a large text file with more than 6 million line but each line has only one couple of "x,y" with x and y relatively small numbers.</p>
<p>What I have to do is count, in Python, every occurences of every couple of "x,y" there is in my file and write them on an excel document with each line representing de "y" and each column, the "x".</p>
<p>I have a program that works but the file is so large that it would literally take more than a year to complete.</p>
<p>So I was wondering if there were a way faster method or not.</p>
<p>Keep in mind that I am really not that good in programming, as I just started.</p>
<p>Thanks a lot for potential answers.</p>
<p>Here is my code so far:</p>
<pre><code>import xlsxwriter

book = xlsxwriter.Workbook("MyCount.xlsx")

sheet1 = book.add_worksheet('Sheet 1')

sheet1.write(0,0,'y\x')

for i in range (0,1441):
    sheet1.write(0,i+1,i)

for i in range (1,118):
    sheet1.write(i,0,i)

file1=open("Data.txt","r")

count=0

for x in range (0, 1441):
    for y in range (1, 118):
        count=0
        number=f'{x}'+','+f'{y}'+'\n'
        for line in file1.readlines():
            if line == number:
                count+=1
        sheet1.write(y, x+1, count)
        file1.seek(0)

file1.close()
book.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an (untested...) improved version of Alexandru's solution (nb: I was already writing this answer when Alexendru posted it's own, but since he posted first please give him credit if it helps solving your problem).</p>
<p>The general idea is to only do one single pass on the file instead of 170038 (=&gt;1441 * 118) successive sequential scans, and reduce the number of <code>sheet.write()</code> calls to the number of rows found instead of rewriting the same cells over and over and over again.</p>
<p>Also using functions will contribute to a faster execution since local variable access is faster than with globals.</p>
<p>Can't tell if this is going to be fast enought to solve your problem but it should at least be <em>much</em> faster than your current implementation. </p>
<p>NB : a 6M <code>{(int,int):int}</code> dict easily fits in most modern computers memory (just tried on mine which is already quite busy) so it's not an issue (and you were already reading the whole file in memory anyway, which is probably much heavier wrt/ memory...)</p>
<pre><code>from collections import defaultdict

def parse_file():
    counts = defaultdict(int)
    with open("Data.txt") as f:
        for lineno, line in enumerate(f):
            line = line.strip()
            if not line:
                continue
            try:
                xy = tuple(int(i) for i in line.split(","))
            except (TypeError, ValueError) as e:
                print("oops, line {} is broken ? (found '{}')".format(lineno, line))
                continue
            counts[xy] += 1
    return counts


def write_counts(counts):
    book = xlsxwriter.Workbook("MyCount.xlsx")
    sheet1 = book.add_worksheet('Sheet 1')
    sheet1.write(0,0,'y\x')
    for i in range (0,1441):
       sheet1.write(0,i+1,i)
    for i in range (1,118):
        sheet1.write(i,0,i)

    for (x, y), count in counts.items():
        sheet1.write(y, x+1, count)


def main():
    counts = parse_file()
    write_counts(counts)

if __name__ == "__main__":
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So take a look at this:</p>
<pre><code>counts = {}

for line in open("data.txt", "r"):
    line = line.split(',')

    number_1 = None
    number_2 = None

    for line_element in line:

        try:
            number = int(line_element)
            if number_1 is None:
                number_1 = number
            else:
                number_2 = number
        except Exception:
            pass

    if number_1 and number_2:
        numbers_couple = '{},{}'.format(number_1, number_2)

        if numbers_couple in counts:
            counts[numbers_couple] += 1
        else:
            counts[numbers_couple] = 1

print(counts)
</code></pre>
<p>My data.txt contents:</p>
<pre><code>a,b,c,20,30,dad,glaas
fdls,cafd,erer,fdesf,2,4534
fdls,cafd,erer,fdesf,2,11
</code></pre>
<p>And the result:</p>
<pre><code>{
   '20,30': 1, 
   '2,4534': 1, 
   '2,11': 1
}
</code></pre>
<p>You ca used this result to write it to you new file as you mentioned by splitting the keys of the dictionary to obtain x and y.</p>
<p>So like this i have count the pairs of numbers in a file as you described. Is this what you are looking for? Please let me know.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this would be more elegant solution for you. Read the file into pandas dataframe and group by and count the pairs.</p>
<pre><code>import pandas as pd
d = [(1,2,3),(1,2,4),(1,2,1),(1,1,5),(1,4,5),(1,1,8)]

cntdt = pd.DataFrame(d,columns=['x','y','cnt'])
cntdt.head()

s = cntdt.groupby(['y','x']).size()

#to get the dataframe
s.to_frame('count').reset_index()

#to get the dictionary
s.to_dict()
</code></pre>
<p>dictionary output: {(1, 1): 2, (2, 1): 3, (4, 1): 1}
Dataframe output: </p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;table border="1" class="dataframe"&gt; &lt;thead&gt;   &lt;tr style="text-align: right;"&gt;     &lt;th&gt;&lt;/th&gt;     &lt;th&gt;y&lt;/th&gt;     &lt;th&gt;x&lt;/th&gt;     &lt;th&gt;count&lt;/th&gt;   &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;   &lt;tr&gt;     &lt;th&gt;0&lt;/th&gt;     &lt;td&gt;1&lt;/td&gt;     &lt;td&gt;1&lt;/td&gt;     &lt;td&gt;2&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;1&lt;/th&gt;     &lt;td&gt;2&lt;/td&gt;     &lt;td&gt;1&lt;/td&gt;     &lt;td&gt;3&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;th&gt;2&lt;/th&gt;     &lt;td&gt;4&lt;/td&gt;     &lt;td&gt;1&lt;/td&gt;     &lt;td&gt;1&lt;/td&gt;   &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;</code></pre>
</div>
</div>
</p>
</div>
<span class="comment-copy">Sample data of your file?</span>
<span class="comment-copy">What do you mean? My file is something like:     120,52      50,30     ...  where each line has two numbers written as seen above, and each line is not unique.</span>
<span class="comment-copy">You have shown 4 numbers and you say "two numbers written as seen above"</span>
<span class="comment-copy">Does each line have different pair of numbers? Are these numbers always in pairs? Are these numbers represented as integers or strings?</span>
<span class="comment-copy">show sample of e.g. row1 and row2</span>
<span class="comment-copy">Alexandry's solution worked fine, I just need to write different count in an excel document. For information, your solution got me this error: write_counts     for (x, y), count in counts.items():  AttributeError: 'NoneType' object has no attribute 'items'  ; Still, thank you for your time</span>
<span class="comment-copy">@Peter my bad, I forgot to return <code>counts</code> from <code>parse</code> indeed (fixed).</span>
<span class="comment-copy">It works! A thousand time thank you</span>
<span class="comment-copy">@Peter so, is it significantly faster ?-)</span>
<span class="comment-copy">infinitely more: 30 seconds</span>
<span class="comment-copy">The general idea is probably the right one (was writing my own answer based on the exact same principle when this was posted), but the implementation could be improved (cf my own answer).</span>
<span class="comment-copy">Indeed your implementation looks better, good job.</span>
<span class="comment-copy">Your solution worked fine, I just need to write the different count in an excel document which I will try to find myself. I'm so grateful. Thanks a lot for your time.</span>
<span class="comment-copy">@Peter you may want to at least upvote Alexandru's answer</span>
<span class="comment-copy">I did, but don't have enough reputation</span>
