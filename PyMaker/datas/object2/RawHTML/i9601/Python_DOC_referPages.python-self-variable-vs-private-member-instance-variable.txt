<div class="post-text" itemprop="text">
<p>I just started programming in Python, and there's something OOP-related that I'm not quite clear on. So in Python, you can create and assign value to a new variable without needing to first declare it. So with that, is there any difference between creating and assigning a new variable for self (eg. <code>self.variable = 5</code>) inside a function (eg. <code>__init__()</code>) vs. creating and assigning a new private member variable? It seems to me like there is no difference at all.</p>
<pre><code>class Foo:

    __var_A = 5;

    def __init__(self):
        self.__var_B = 5;
        self.printVars()

    def printVars(self):
        print(self.__var_A)
        print(self.__var_B)


foo = Foo()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is in fact a difference between those two variables:</p>
<p>Since <code>__var_A</code> is defined in <code>class Foo</code> instead of an individual member-function like <code>__init__</code>, you can change it for all instances at once like this:</p>
<pre><code>Foo._Foo__var_A = 2
</code></pre>
<p>This will not work for <code>__var_B</code> since you define it individually per instance.</p>
<p>Note though, that changing <code>__var_A</code> on an instance will not change it for everyone else, it will instead put a local override into the object itself:</p>
<pre><code>foo2 = Foo()
foo2._Foo__var_A = 1
Foo._Foo__var_A = 2
(foo2._Foo__var_A, foo._Foo__var_A) # Returns: (1, 2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>It seems to me like there is no difference at all.</p>
</blockquote>
<p>That is correct.</p>
<p>But remember that Python does not have 'private' members. That is only a convention.</p>
</div>
<div class="post-text" itemprop="text">
<p>The difference between <code>protected</code> and <code>public</code> is a matter of convention. And class or member variable prefixed by <strong><em>one</em></strong> <code>_</code> indicates to a developer "don't use this unless you know what you're doing." Private is a <em><strong>SLIGHTLY</strong></em> different case, however: they require two <code>_</code> and they cannot be suffixed by more than one <code>_</code>. <a href="https://docs.python.org/2/tutorial/classes.html" rel="nofollow noreferrer">Here are the docs</a>:</p>
<blockquote>
<p>“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice.</p>
</blockquote>
<p>Name mangling is an important part of Python inheritence. It allows classes to protect API calls from accidental manipulation of descendants (see above docs). However, if necessary you can still access them via <code>_&lt;class-name&gt;&lt;var name&gt;</code>. Eg:</p>
<pre><code>class Foo:
   def __init__(self):
      self.__bar = 1

print(Foo()._Foo__bar)
# 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no difference if the variable is declared under <code>class foo:</code> of within the <code>__init__(self)</code>.  Both methods accomplish the same thing.  </p>
<p>However, this is slight a twist if the variable (e.g. <code>self.bar</code>) is declared from a method other than <code>__init__</code>.  Using</p>
<pre><code>def bar(self):
    self.bar = 'test'
</code></pre>
<p>creates a variable within the object that is not part of the default class.  You can do this, but it is not good programming practice for python.  </p>
</div>
<div class="post-text" itemprop="text">
<p>There is a difference. Consider following example:</p>
<pre><code>foo = Foo()
foo.__dict__
</code></pre>
<p>This will return:</p>
<pre><code>{'_Foo__var_B': 5}
</code></pre>
<p>But, following code:</p>
<pre><code>bar = Foo
bar.__dict__
</code></pre>
<p>will return</p>
<pre><code>{'_Foo__var_A': 5,
 '__doc__': None,
 '__init__': &lt;function __main__.__init__&gt;,
 '__module__': '__main__',
 'printVars': &lt;function __main__.printVars&gt;}
</code></pre>
<p>This leads to conclusion that <code>__var_A</code> will be accessible even if <code>Foo</code> is not instantiated, while <code>__var_B</code> will not be.</p>
</div>
<span class="comment-copy">There are no private variables in python. <code>__var_A</code> is going to be "mangled" to <code>foo.__Foo_var_A</code> if you are going to access that</span>
<span class="comment-copy">It's <code>_Foo__var_A</code>, i.e. <code>"_{classname}"</code> prepended.</span>
<span class="comment-copy">@filmor Oops, right. Anyways, documentation for reference - <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow noreferrer">docs.python.org/3/tutorial/classes.html#private-variables</a></span>
<span class="comment-copy">I would also like to warn about using <a href="https://docs.python.org/3.5/tutorial/classes.html#class-and-instance-variables" rel="nofollow noreferrer">mutable objects as class variables</a>.</span>
<span class="comment-copy">There is a slight difference, though. varA is a class variable. varB is an instance variable</span>
<span class="comment-copy">Yes, in the code. But the text of the question is asking about a situation ('assigning a new private member variable') that is different from the code.</span>
<span class="comment-copy">What cricket_007 said, except (to be pedantic) they're attributes, not variables.</span>
<span class="comment-copy">@PM2Ring ACK to that.</span>
<span class="comment-copy">@PM2Ring Why attributes? <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables" rel="nofollow noreferrer">docs.python.org/3/tutorial/…</a></span>
<span class="comment-copy">I agree that it's a good idea to create all instance attributes in <code>__init__</code>, but that doesn't mean that such attributes are "part of the default class". Technically, the attributes of the class itself are 1) those it inherits from its parent class(es), and 2) attributes defined at the class level. Instance attributes don't exist in the class itself, only in the <i>instances</i> of the class, and they only come into existence when the method creating them is executed, or when some code external to the class definition explicitly adds them.</span>
