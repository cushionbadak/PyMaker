<div class="post-text" itemprop="text">
<p>I have the following array <code>[1, 4, 7, 9, 2, 10, 5, 8]</code> and I need to separate the array in 3 different arrays: one for values between 0 and 3, anther for 3 to 6 and anther for 6 and 25.The result must be something like that:</p>
<pre><code>array1 = [1, 2]
array2 = [4, 5]
array3 = [7, 9, 10, 8]
</code></pre>
<p>Any idea about how to do it simple?</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>First, define your "pole" numbers</li>
<li>Second, generate your intervals from those "pole" numbers</li>
<li>Third, define as many lists as there are intervals.</li>
<li>Then for each interval, scan the list and appends items in the relevant list if they belong to the interval</li>
</ul>
<p>code:</p>
<pre><code>source = [1, 4, 7, 9, 2, 10, 5, 8]

poles = (0,3,6,25)
intervals = [(poles[i],poles[i+1]) for i in range(len(poles)-1)]

# will generate: intervals = [(0,3),(3,6),(6,25)]

output = [list() for _ in range(len(intervals))]

for out,(start,stop) in zip(output,intervals):
    for s in source:
        if start &lt;= s &lt;stop:
            out.append(s)

print(output)
</code></pre>
<p>result:</p>
<pre><code>[[1, 2], [4, 5], [7, 9, 10, 8]]
</code></pre>
<p>This solution has the advantage of being adaptable to more than 3 lists/intervals by adding more "pole" numbers.</p>
<p>EDIT: There's a nice &amp; fast solution (<code>O(log(N)*N)</code>) if the output lists order don't matter:</p>
<ul>
<li>first sort the input list</li>
<li>then generate the sliced sub-lists using <code>bisect</code> which returns insertion position of the provided numbers (left &amp; right)</li>
</ul>
<p>like this:</p>
<pre><code>import bisect

source = sorted([1, 4, 7, 9, 2, 10, 5, 8])

poles = (0,3,6,25)

output = [source[bisect.bisect_left(source,poles[i]):bisect.bisect_right(source,poles[i+1])] for i in range(len(poles)-1)]

print(output)
</code></pre>
<p>result:</p>
<pre><code>[[1, 2], [4, 5], [7, 8, 9, 10]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do that in a very simple way using a combination of a for loop and range functions:</p>
<pre><code>lists = ([], [], [])

for element in [1, 4, 7, 9, 2, 10, 5, 8]:
    if element in range(0, 3):
        lists[0].append(element)

    elif element in range(3, 6):
        lists[1].append(element)


    elif element in range(6, 25):
        lists[2].append(element)



array1, array2, array3 = lists
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>"One-line"</em> solution using <code>set.intersection(*others)</code> and <code>range(start, stop[, step])</code> functions:</p>
<pre><code>l = [1, 4, 7, 9, 2, 10, 5, 8]
l1, l2, l3 = (list(set(l).intersection(range(3))), list(set(l).intersection(range(3,6))), list(set(l).intersection(range(6,25))))

print(l1)
print(l2)
print(l3)
</code></pre>
<p>The output:</p>
<pre><code>[1, 2]
[4, 5]
[8, 9, 10, 7]
</code></pre>
<p><a href="https://docs.python.org/3/library/stdtypes.html?highlight=intersection#set.intersection" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html?highlight=intersection#set.intersection</a></p>
</div>
<span class="comment-copy">it does sound simple. What have you tried?</span>
<span class="comment-copy">simple and elegant, thanks! works perfect!</span>
<span class="comment-copy">good. Did your output lists needed to be issued in the same order? BTW <a href="http://stackoverflow.com/help/someone-answers">stackoverflow.com/help/someone-answers</a></span>
<span class="comment-copy">not necessarily, most important is to count the number of elements per range, again thanks for your help!</span>
<span class="comment-copy">the yes, <code>bisect</code> is the way. Elegant and fast!</span>
