<div class="post-text" itemprop="text">
<pre><code>import random

class player():
    def __init__(self, deck):
        self.deck = deck 
        self.hand = []
        self.results = []

    def draw(self,draws):
        for counter in range(0, draws, 1):
            card = random.randrange(0, len(self.deck), 1)
            self.hand.append(self.deck[card])
            del self.deck[card]

    def return_hand(self):
        for returncounter in range(0, len(self.hand), 1):
            self.deck.append(self.hand[returncounter]) 
        for returncounter in range(0, len(self.hand), 1):
            del self.hand[0]

    def simple_function(self):
        for counter in range(0, 3, 1):
            print("Loop", counter)
            self.draw(3)
            print("Hand", simple_cards.hand)
            self.results.extend(self.hand)
            print("Results before return", simple_cards.results)
            self.return_hand()
            print("Results after return", simple_cards.results)
            print("")

simple_cards = player(["A1", "A2", "A3", "B1", "B2", "B3", "C1", "C2", "C3"])

simple_cards.simple_function()
print("Results after function", simple_cards.results)
</code></pre>
<p>An Example result from this code would be </p>
<pre><code>Loop 0
Hand ['B3', 'B2', 'C3']
Results before return ['B3', 'B2', 'C3']
Results after return ['B3', 'B2', 'C3']

Loop 1
Hand ['C2', 'B3', 'A1']
Results before return ['B3', 'B2', 'C3', 'C2', 'B3', 'A1']
Results after return ['B3', 'B2', 'C3', 'C2', 'B3', 'A1']

Loop 2
Hand ['C2', 'B2', 'C1']
Results before return ['B3', 'B2', 'C3', 'C2', 'B3', 'A1', 'C2', 'B2', 'C1']
Results after return ['B3', 'B2', 'C3', 'C2', 'B3', 'A1', 'C2', 'B2', 'C1']

Results after function ['B3', 'B2', 'C3', 'C2', 'B3', 'A1', 'C2', 'B2', 'C1']
</code></pre>
<p>How do I make the result 3 nested lists like [['B3', 'B2', 'C3'], ['C2', 'B3', 'A1'], ['C2', 'B2', 'C1']]</p>
<p>I feel like there is a pretty fundamental thing I'm not understanding here and that this question has certainly already been answered but I don't know how to frame the question better to find it by searching myself.</p>
<p>I tried append(self.hand) and extend([self.hand]) but both created more problems than they solved resulting in an example output of</p>
<pre><code>Loop 0
Hand ['B3', 'A2', 'B2']
Results before return [['B3', 'A2', 'B2']]
Results after return [[]]

Loop 1
Hand ['B2', 'B3', 'C3']
Results before return [['B2', 'B3', 'C3'], ['B2', 'B3', 'C3']]
Results after return [[], []]

Loop 2
Hand ['C2', 'B3', 'A2']
Results before return [['C2', 'B3', 'A2'], ['C2', 'B3', 'A2'], ['C2', 'B3', 'A2']]
Results after return [[], [], []]

Results after function [[], [], []]
</code></pre>
<p>Thanks for any help.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>append</code> to add the <strong>copy</strong> of the <code>hand</code> to <code>results</code>. The problem with just appending the <code>hand</code> is that you're modifying it later with <code>del</code> which will be reflected to the printed results as your example shows. </p>
<p>If you change <code>self.results.extend(self.hand)</code> to <code>self.results.append(self.hand[:])</code> you get following output:</p>
<pre><code>Loop 0
Hand ['A1', 'C2', 'B3']
Results before return [['A1', 'C2', 'B3']]
Results after return [['A1', 'C2', 'B3']]

Loop 1
Hand ['B1', 'B3', 'A1']
Results before return [['A1', 'C2', 'B3'], ['B1', 'B3', 'A1']]
Results after return [['A1', 'C2', 'B3'], ['B1', 'B3', 'A1']]

Loop 2
Hand ['C2', 'B1', 'C1']
Results before return [['A1', 'C2', 'B3'], ['B1', 'B3', 'A1'], ['C2', 'B1', 'C1']]
Results after return [['A1', 'C2', 'B3'], ['B1', 'B3', 'A1'], ['C2', 'B1', 'C1']]

Results after function [['A1', 'C2', 'B3'], ['B1', 'B3', 'A1'], ['C2', 'B1', 'C1']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also keep your code like what it is right now, and split only the results.</p>
<p>For example, i assume that your output is:</p>
<pre><code>output = ['B3', 'B2', 'C3', 'C2', 'B3', 'A1', 'C2', 'B2', 'C1']
</code></pre>
<p>So, you can do something like this:</p>
<pre><code>expected_output = [output[i:i+3] for i in range(0, len(output), 3)]
print(expected_output)
</code></pre>
<p>Output:</p>
<pre><code>[['B3', 'B2', 'C3'], ['C2', 'B3', 'A1'], ['C2', 'B2', 'C1']]
</code></pre>
<p>So, in order to edit your code, you have only to edit one line:</p>
<p><code>self.results.extend(self.hand)</code> to <code>self.results.extend(self.hand[i:i+3] for i in range(0, len(self.hand), 3))</code></p>
<p>So your <code>simple_function()</code> will be:</p>
<pre><code>def simple_function(self):
        for counter in range(0, 3, 1):
            print("Loop", counter)
            self.draw(3)
            print("Hand", simple_cards.hand)
            # The edited line
            self.results.extend(self.hand[i:i+3] for i in range(0, len(self.hand), 3))
            print("Results before return", simple_cards.results)
            self.return_hand()
            print("Results after return", simple_cards.results)
            print("")
</code></pre>
<p>Output after the edit:</p>
<pre><code>Loop 0
Hand ['B1', 'C1', 'C3']
Results before return [['B1', 'C1', 'C3']]
Results after return [['B1', 'C1', 'C3']]

Loop 1
Hand ['C1', 'C3', 'A3']
Results before return [['B1', 'C1', 'C3'], ['C1', 'C3', 'A3']]
Results after return [['B1', 'C1', 'C3'], ['C1', 'C3', 'A3']]

Loop 2
Hand ['C2', 'A3', 'B3']
Results before return [['B1', 'C1', 'C3'], ['C1', 'C3', 'A3'], ['C2', 'A3', 'B3']]
Results after return [['B1', 'C1', 'C3'], ['C1', 'C3', 'A3'], ['C2', 'A3', 'B3']]

Results after function [['B1', 'C1', 'C3'], ['C1', 'C3', 'A3'], ['C2', 'A3', 'B3']]
</code></pre>
</div>
<span class="comment-copy">Thanks thats exactly the sort of solution I was looking for :).  Is there any specific part of python documentation/tutorials I could look at that might help make it clear when I am making something point to another variable versus creating an entirely new value?  I think I learn through trial and error too much because I only partially understand the terminology used in python documentation so reading it doesn't make things as clear as it should.</span>
<span class="comment-copy">@Diofsi You can check <a href="https://docs.python.org/3/glossary.html" rel="nofollow noreferrer">glossary</a> for various terms used in documentation. You could try to read <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">Data model</a> from Python reference for explanation on immutable vs mutable objects. In short you can always refer the documentation when calling a method to see if it mutates the object or not.</span>
<span class="comment-copy">Thanks :). The line of code itself seems more complex than niemmis example but it allows more intricate slicing of the results which is useful if I don't want the entire self.hand</span>
<span class="comment-copy">Yes, you can split your list within the steps you like. So you can undernstand it like this <code>[output[i:i+step] for i in range(0, len(output), step)]</code> and this line mean: return a list of slices which are from output from the range i to step for every i in the range between 0 and length of output but with a step. For example <code>for k in range(0,7,3)</code> , k will be: 0,3 and 6.</span>
<span class="comment-copy">Also, be sure that you can respond to any question within different manners. You have the choice to use any method you want that you can easly understand.</span>
