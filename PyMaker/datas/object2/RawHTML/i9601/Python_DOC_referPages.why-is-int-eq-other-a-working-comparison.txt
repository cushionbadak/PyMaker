<div class="post-text" itemprop="text">
<p>The following code works with Python 2.7:</p>
<pre><code>&gt;&gt;&gt; class Derived(int):
...     def __eq__(self, other):
...         return int.__eq__(other)
...
&gt;&gt;&gt; Derived(12) == 12.0
True
&gt;&gt;&gt; Derived(12) == 13
False
</code></pre>
<p>I do not understand, why it works, given that the <code>self</code> attribute is not explicitly given to <code>int.__eq__()</code> method call.</p>
<p>[EDIT]</p>
<p>Answers so far suggested, that it is about returning <code>NotImplemented</code> by <code>self.__eq__(other)</code> and thus calling <code>other.__eq__(self)</code>. Then <code>Derived(12) == Derived(12)</code> I expect to be an infinitive recursion, which is not the case:</p>
<pre><code>&gt;&gt;&gt; Derived(12) == Derived(12)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It works because <code>int.__eq__(&lt;something&gt;)</code> returns <code>NotImplemented</code> and when that happens it results in a call to <code>other.__eq__(self)</code> and that's what is returning <code>True</code> and <code>False</code> here.</p>
<p><strong>Demo:</strong></p>
<pre><code>class Derived(int):
     def __eq__(self, other):
         print self, other
         print int.__eq__(other)
         print other.__eq__(self)
         return int.__eq__(other)

&gt;&gt;&gt; Derived(12) == 12.0
12 12.0
NotImplemented
True
True
&gt;&gt;&gt; Derived(12) == 13.0
12 13.0
NotImplemented
False
False
</code></pre>
<p>From <a href="https://docs.python.org/3/library/constants.html#NotImplemented" rel="nofollow noreferrer"><code>NotImplemented</code></a>
's docs:</p>
<blockquote>
<p>Special value which should be returned by the binary special methods
  (e.g. <code>__eq__()</code>, <code>__lt__()</code>, <code>__add__()</code>, <code>__rsub__()</code>, etc.) to
  indicate that the operation is not implemented with respect to the
  other type; may be returned by the in-place binary special methods
  (e.g. <code>__imul__()</code>, <code>__iand__()</code>, etc.) for the same purpose. Its
  truth value is true.</p>
<p>Note When <code>NotImplemented</code> is returned, the interpreter will then try
  the reflected operation on the other type, or some other fallback,
  depending on the operator. If all attempted operations return
  NotImplemented, the interpreter will raise an appropriate exception.</p>
</blockquote>
<hr/>
<p><strong>What happens when both <code>__eq__</code> return <code>NotImplemented</code>?</strong></p>
<p>The behaviour is different in Python 2 and 3.</p>
<p>In Python 2 it falls back to <code>__cmp__</code> method first and integers have <a href="https://hg.python.org/cpython/file/tip/Objects/longobject.c#l2886" rel="nofollow noreferrer"><code>__cmp__</code> method in Python 2</a>. It has been removed in Python 3.</p>
<p>As per Python 2 docs if nothing is found it ultimately falls back to identity comparison:</p>
<blockquote>
<p>If no <code>__cmp__()</code>, <code>__eq__()</code> or <code>__ne__()</code> operation is defined, class
  instances are compared by object identity (“address”)</p>
</blockquote>
<pre><code>class Derived(int):
    def __eq__(self, other):
        print ("Inside  __eq__")
        return NotImplemented

    def __cmp__(self, other):
        print ("Inside __cmp__ finally")
        return True

&gt;&gt;&gt; Derived(12) == Derived(12)
Inside  __eq__
Inside  __eq__
Inside __cmp__ finally
False
</code></pre>
<p>Not let's define a class with no method defined:</p>
<pre><code>class Derived(object):
    pass

&gt;&gt;&gt; Derived() == Derived()  
False
&gt;&gt;&gt; d = Derived()
&gt;&gt;&gt; d == d  # Same objects.
True
</code></pre>
<p>Python 3 doesn't have <code>__cmp__</code> method anymore but it seems to be falling back to identity now. And it seems it is not documented either.</p>
<pre><code>#  Python 3.5
&gt;&gt;&gt; Derived() == Derived()
False
&gt;&gt;&gt; d = Derived()
&gt;&gt;&gt; d == d
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>When mixing float with an integer type, there's no good <em>uniform</em> approach.
  <a href="https://github.com/python/cpython/blob/2.7/Objects/floatobject.c#L401-L417" rel="nofollow noreferrer">https://github.com/python/cpython/blob/2.7/Objects/floatobject.c#L401-L417</a></p>
</blockquote>
<p>P.S.
<a href="https://stackoverflow.com/questions/36921558/how-int-object-using-operator-without-eq-method-in-python2/36922306#36922306">How int() object using "==" operator without __eq__() method in python2?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.7, if you call <code>int.__eq__</code> it always returns <code>NotImplemented</code>.  Example:</p>
<pre><code>&gt;&gt;&gt; int.__eq__(12.0)
NotImplemented
</code></pre>
<p>When you use the <code>==</code> operator it will attempt to run the <code>__eq__</code> method on the left argument, and if it gets <code>NotImplemented</code> it will return the result of the <code>__eq__</code> method from the argument on the right.</p>
<p>In your example for <code>Derived(12) == 12.0</code>, the interpreter first tries <code>Derived(12).__eq__(12.0)</code>, and gets <code>NotImplemented</code>.  It then runs the <code>__eq__</code> method on the <code>float</code> number <code>12.0</code> and gets <code>True</code>.</p>
<p>In the case of your <code>Derived(12) == Derived(12)</code> example, what's likely happening is that since both objects return <code>NotImplemented</code> for their <code>__eq__</code> methods, and since <code>Derived</code> inherits from <code>int</code>, the interpreter falls back to using the <code>cmp</code> builtin behavior for <code>int</code> (according to <a href="https://stackoverflow.com/a/36922306/7007605">this answer</a>, which is linked-to in another answer to your question).</p>
<p>Here's an example that illustrates your case:</p>
<pre><code>class Derived(int):
    def __eq__(self, other):
        print 'Doing eq'
        return NotImplemented
    def __cmp__(self, other):
        print 'doing cmp'
        return 0  # contrived example - don't do this

&gt;&gt;&gt; Derived(12) == Derived(12)
doing eq
doing eq
doing cmp
True
</code></pre>
</div>
<span class="comment-copy">Oh, come on, 12 is not even overflowing half-precision float. It converts perfectly fine to a double.</span>
<span class="comment-copy">Edited to take into account all args for <code>int.__eq__</code></span>
<span class="comment-copy">Updated the question to include <code>Derived(12) == Derived(12)</code> case</span>
