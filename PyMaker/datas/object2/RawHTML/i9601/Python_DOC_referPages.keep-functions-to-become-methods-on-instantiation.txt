<div class="post-text" itemprop="text">
<p>When a function is assigned to an attribute during class definition, this attribute stays an ordinary function with its original signature:</p>
<pre><code>&gt;&gt;&gt; def f(x):
    return x**2
&gt;&gt;&gt; class A:
    ff = f
&gt;&gt;&gt; A.ff
&lt;function f at 0x037D6ED0&gt;
</code></pre>
<p>When the class is instantiated, this attribute becomes a bound method and its signature changes:</p>
<pre><code>&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.ff
&lt;bound method A.f of &lt;__main__.A object at 0x03A726B0&gt;&gt;
</code></pre>
<p>I need to define a class that I can later customize by changing some attributes <strong>before</strong> instantiating. One of these attributes is a function and I need it to keep it's signature.</p>
<p>Using <code>@staticmethod</code> is obviously not an option, since no function is defined on  class definition/customization, and decorations dont apply to attributes.</p>
<p>Is there any way to keep a function to be transformed into a bound method on instantiation? </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Using @staticmethod is obviously not an option, since no function is defined on class definition/customization, and decorations dont apply to attributes.</p>
</blockquote>
<p>No, <code>staticmethod</code> <em>is</em> the option, just call it directly to produce an instance:</p>
<pre><code>class A:
    ff = staticmethod(f)
</code></pre>
<p><code>@decorator</code> syntax is only syntactic sugar to produce the exact same assignment after a function object has been created.</p>
<p>This works fine:</p>
<pre><code>&gt;&gt;&gt; def f(x):
...     return x**2
...
&gt;&gt;&gt; class A:
...     f_unchanged = f
...     f_static = staticmethod(f)
...
&gt;&gt;&gt; A().f_unchanged
&lt;bound method f of &lt;__main__.A object at 0x10cf7b2e8&gt;&gt;
&gt;&gt;&gt; A().f_static
&lt;function f at 0x10cfb6510&gt;
&gt;&gt;&gt; A().f_static(4)
16
</code></pre>
<p>It doesn't matter where a function is defined, a <code>def</code> statement produces a function object <em>regardless where it is used</em>. <code>def name</code> is two things: creating the function object and an assignment of that function object no a name. Wether or not this takes place in a <code>class</code> statement or elsewhere <em>doesn't actually matter</em>.</p>
<p>What turns functions into bound methods is <em>accessing them on an instance</em>, as then the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a> kicks in. For example,  accessing <code>A().ff</code> is turned into <code>A.__dict__['ff'].__get__(A())</code>, and it is the <code>__get__</code> method on a function that produces the bound method. The bound method is only a proxy for the actual function, passing in the instance as a first argument when called.</p>
<p>A <code>staticmethod</code> defines a different <code>__get__</code>, one that just returns the original function, unbound. You can play with those <code>__get__</code> methods directly:</p>
<pre><code>&gt;&gt;&gt; f.__get__(A())   # bind f to an instance
&lt;bound method f of &lt;__main__.A object at 0x10cf9f630&gt;&gt;
&gt;&gt;&gt; A.__dict__['f_unchanged']  # bypass the protocol
&lt;function f at 0x10cfb6510&gt;
&gt;&gt;&gt; A.__dict__['f_static']     # bypass the protocol
&lt;staticmethod object at 0x10cf60f28&gt;
&gt;&gt;&gt; A.__dict__['f_static'].__get__(A())  # activate the protocol
&lt;function f at 0x10cfb6510&gt;
</code></pre>
</div>
<span class="comment-copy"><i>When a function is assigned to an attribute during class definition</i>. Note that using <code>def</code> inside a class definition is <i>also</i> assigning an attribute. That's because functions are <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a> and only accessing the attribute on an instance does the binding action (producing a bound method).</span>
<span class="comment-copy">This question has received 2 downvotes, with no explanation. I find this quite rude, and, frankly, not deserved. It would be apreciated if the downvoters could comment on their votes. Thx in advance.</span>
<span class="comment-copy">Well that's a big surprise. I guess I should have dug into the definition of the <code>@staticmethod</code> descriptor. Thx so much !</span>
