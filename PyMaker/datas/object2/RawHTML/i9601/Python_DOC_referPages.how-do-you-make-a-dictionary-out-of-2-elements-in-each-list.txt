<div class="post-text" itemprop="text">
<p>I have a list of lists that I want to make into a dictionary.  Basically it's a list of births based on date (year/month/day/day of week/births).  I want to tally the total births for each day to see in total how many births on each day of the week.</p>
<p>List example:</p>
<pre><code>[2000,12,3,2,12000],[2000,12,4,3,34000]...  


days_counts = {1: 23000, 2: 43000, ..., 7: 11943} 
</code></pre>
<p>Here's the code so far:</p>
<pre><code>f = open('births.csv', 'r')
text = f.read()
text = text.split("\n")
header = text[0]
data = text[1:]
for d in data:
    split_data = d.split(",")
    print(split_data)
</code></pre>
<p>So basically I want to iterate over each day and add the birth from duplicate days into the same key (obviusly).</p>
<p>EDIT:  I have to do this with an if statement that looks for the day of week as a key in the dict.  if its found, assign the corresponding births as value.  If its not in dict then add key and value.  I can't import anything or use lambda functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code> object</a> to track the counts per day-of-the-week. You also want to use the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code> module</a> to handle the file parsing:</p>
<pre><code>import csv
from collections import Counter

per_dow = Counter()

with open('births.csv', 'r') as f:
    reader = csv.reader(f)
    header = next(reader)
    for row in reader:
        dow, births = map(int, row[-2:])
        per_dow[dow] += births
</code></pre>
<p>I've used a <code>with</code> statement to manage the file object; Python auto-closes the file for you when the <code>with</code> block ends.</p>
<p>Now that you have a <code>Counter</code> object (which is a dictionary with some extra powers), you can now find the day of the week with the most births; the following loop prints out days of the week in order from most to least:</p>
<pre><code>for day, births in per_dow.most_common():
    print(day, births)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without using external libraries or if statements, you can use exception handling</p>
<pre><code>birth_dict = {}
birth_list = [[2000,12,3,2,12000],[2000,12,4,3,34000]]
for birth in birth_list:
    try:
        birth_dict[birth[3]]+=birth[4]
    except KeyError:
        birth_dict[birth[3]]=birth[4]
print birth_dict
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ok, after playing around with the code and using print statements where I need them for tests, I finally did it without using any external libraries.  A very special thanks to Tobey and the others.</p>
<p>Here's the code with tests:</p>
<pre><code>f = open('births.csv', 'r')
text = f.read()
text = text.split("\n")
header = text[0]
data = text[1:-1]
days_counts = {}
for d in data:
    r = d.split(",")
    print(r) #&lt;--- used to test
    k = r[3]
    print(k)#&lt;--- used to test
    v = int(r[4])
    print(v)#&lt;--- used to test
    if k in days_counts:
        days_counts[k] += v
        print("If : " , days_counts)#&lt;--- used to test
    else:
        days_counts[k] = v
        print("Else : ", days_counts)#&lt;--- used to test


print(days_counts)      
</code></pre>
<p>Code without tests:</p>
<pre><code>f = open('births.csv', 'r')
text = f.read()
text = text.split("\n")
header = text[0]
data = text[1:-1]
days_counts = {}
for d in data:
    r = d.split(",")
    k = r[3]
    v = int(r[4])
    if k in days_counts:
        days_counts[k] += v 
    else:
        days_counts[k] = v

print(days_counts)      
</code></pre>
</div>
<span class="comment-copy">You should read about the <a href="https://www.python.org/dev/peps/pep-0343/" rel="nofollow noreferrer"><code>with</code> statement</a></span>
<span class="comment-copy"><code>map(int, row[-2:])</code> is returning a tuple?</span>
<span class="comment-copy">@pylang: no, but iterable assignment doesn't require a tuple, it requires an iterable.</span>
<span class="comment-copy">I see, your slice unpacks into two variables.  Thanks.</span>
<span class="comment-copy">This one helped a lot..Thanks Tobey :)</span>
<span class="comment-copy">Cool. You should accept the answer you used.</span>
