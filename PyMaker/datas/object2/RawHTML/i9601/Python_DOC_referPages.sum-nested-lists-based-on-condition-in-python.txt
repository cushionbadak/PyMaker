<div class="post-text" itemprop="text">
<p>I have a nested list looking like this:</p>
<pre><code>[['Vienna','2012', 890,503,70],['London','2014', 5400, 879,78],
 ['London','2014',4800,70,90],['Bern','2013',300,450,678], 
 ['Vienna','2013', 700,850,90], ['Bern','2013',500,700,90]]
</code></pre>
<p>What I want to do is summing every integervalue in the sublist with another sublist if city and year are equal. I first thought of a dictionary with city and year as key, but it caused problems sorting it.</p>
<p>Then I had: <code>{('Vienna','2012'):[890,503,70],('Bern','2013'):[800,1150,768],...}</code></p>
<p>I also tried something like this:</p>
<p><code>[sum(x) for x in zip(*list) if x[0] == x[0]]</code> but of course it did not work.</p>
<p>Can I do something like this with a nested list to so sorting it by city and year would be easier? </p>
</div>
<div class="post-text" itemprop="text">
<p>You could construct a result <code>dict</code> where key is tuple of first two items in the original lists and value is <code>list</code> of numbers. Every time you add value to <code>dict</code> you could use <a href="https://docs.python.org/3.5/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><code>get</code></a> to either return existing element or given default value, in this case empty list. </p>
<p>Once you have the existing list and list to add you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>zip_longest</code></a> with <code>fillvalue</code> to get numbers to sum from both lists. <code>zip_longest</code> returns tuples of length 2 containing one number from each list. In case one list is longer than other <code>fillvalue</code> is used as default so this will also work in case lists have different lengths. Finally list comprehension could used to sum each item for a new value:</p>
<pre><code>from itertools import zip_longest

l = [
    ['Vienna','2012', 890,503,70],['London','2014', 5400, 879,78],
    ['London','2014',4800,70,90],['Bern','2013',300,450,678],
    ['Vienna','2013', 700,850,90], ['Bern','2013',500,700,90]
]

res = {}
for x in l:
    key = tuple(x[:2])
    res[key] = [i + j for i, j in zip_longest(res.get(key, []), x[2:], fillvalue=0)]

print(res)
</code></pre>
<p>Output:</p>
<pre><code>{('Vienna', '2013'): [700, 850, 90], ('London', '2014'): [10200, 949, 168], 
 ('Vienna', '2012'): [890, 503, 70], ('Bern', '2013'): [800, 1150, 768]}  
</code></pre>
<p>If you want to sort the cities alphabetically and years latest first you could pass custom <code>key</code> to <code>sorted</code>:</p>
<pre><code>for item in sorted(res.items(), key=lambda x: (x[0][0], -int(x[0][1]))):
    print(item)
</code></pre>
<p>Output:</p>
<pre><code>(('Bern', '2013'), [800, 1150, 768])
(('London', '2014'), [10200, 949, 168])
(('Vienna', '2013'), [700, 850, 90])
(('Vienna', '2012'), [890, 503, 70])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should maintain a dictionary as you have outlined in the question. Something like this will help,</p>
<pre><code>cities = {}
for a in list:
    city_key = a[:1]
    if city_key in cities:
        cities[city_key] = [a + b for a, b in zip(a[2:], cities[city_key])]
    else:
        cities[city_tuple] = a[2:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way is to split the list of lists into a dict by the key you want (the city and year). Also the <code>defaultdict</code> helps squashing all distances into a flat list</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; dct = defaultdict(list)
&gt;&gt;&gt; for item in lst:
...    dct[(item[0], item[1])].extend(item[2:])
</code></pre>
<p>Now <code>dct</code> has the integers grouped by the city and year:</p>
<pre><code>&gt;&gt;&gt; dct
defaultdict(&lt;type 'list'&gt;, {('Vienna', '2013'): [700, 850, 90], ('London', '2014'): [5400, 879, 78, 4800, 70, 90], ('Vienna', '2012'): [890, 503, 70], ('Bern', '2013'): [300, 450, 678, 500, 700, 90]})
</code></pre>
<p>And you can just sum them:</p>
<pre><code>&gt;&gt;&gt; for key in dct:
...    print(key, sum(dct[key]))
... 
(('Vienna', '2013'), 1640)
(('London', '2014'), 11317)
(('Vienna', '2012'), 1463)
(('Bern', '2013'), 2718)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The solution using <code>itertools.groupby</code> and <code>operator.itemgetter</code> functions:</p>
<pre><code>import itertools, operator

l = [['Vienna','2012', 890,503,70],['London','2014', 5400, 879,78],
 ['London','2014',4800,70,90],['Bern','2013',300,450,678],
 ['Vienna','2013', 700,850,90], ['Bern','2013',500,700,90]]

getter = operator.itemgetter(0, 1)  # the sequence to be grouped(first two items)
summed = [[k[0],k[1],sum(sum(d[2:]) for d in list(group))]
          for k, group in itertools.groupby(sorted(l, key=getter), getter)]

print(summed)
</code></pre>
<p>The output:</p>
<pre><code>[['Bern', '2013', 2718], ['London', '2014', 11317], ['Vienna', '2012', 1463], ['Vienna', '2013', 1640]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>nl = [['Vienna','2012', 890,503,70],['London','2014', 5400, 879,78],
      ['London','2014',4800,70,90],['Bern','2013',300,450,678],
      ['Vienna','2013', 700,850,90], ['Bern','2013',500,700,90]]
d = {}
for l in nl:
    key = l[0] , l[1]
    value = l[2:]
    if key not in d:
        d[key] = value
    else:
        d[key] = [sum(i)for i in zip(d[key], value)]
print(d)
</code></pre>
<p>out: </p>
<pre><code>{('Vienna', '2012'): [890, 503, 70], ('London', '2014'): [10200, 949, 168], ('Bern', '2013'): [800, 1150, 768], ('Vienna', '2013'): [700, 850, 90]}
</code></pre>
</div>
<span class="comment-copy">This looks very good.  Use <code>res = collections.OrderedDict()</code> to improve.</span>
<span class="comment-copy">Also with  <code>defaultdict(list)</code>  you can just write <code>res[key]</code> instead of <code>res.get(key, [])</code></span>
<span class="comment-copy">Thanks sooo much, the sorting was mainly the part I didn't manage with a dict! Thanks a lot!</span>
<span class="comment-copy">@Gribouillis: This depends entirely on the ordering of expected output. If items are needed in the same order as in original list then it would be useful.</span>
<span class="comment-copy">Ok i already did it nearly the way you did. the Problem is that I need to sort the output. It should look like this:  Vienna  2014 ....  2013 ....  what would the easiest way to do this?</span>
<span class="comment-copy">You can easily sort the keys <a href="http://stackoverflow.com/questions/9001509/how-can-i-sort-a-dictionary-by-key" title="how can i sort a dictionary by key">stackoverflow.com/questions/9001509/â€¦</a></span>
