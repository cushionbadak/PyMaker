<div class="post-text" itemprop="text">
<pre><code>s =['Hello','World','Hello','World']
l = list()
for x,y in enumerate(s):
    l.append((y,x))
</code></pre>
<p>The output I got is <code>[('Hello', 0), ('World', 1), ('Hello', 2), ('World', 3)]</code></p>
<p>But I want</p>
<pre><code>Hello-[0,2]
World-[1,3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a dictionary:</p>
<pre><code>d = {}
for i, v in enumerate(s):
    if v in d:
        d[v].append(i)
    else:
        d[v] = [i]

d
# {'Hello': [0, 2], 'World': [1, 3]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems like <a href="https://docs.python.org/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> is a perfect fit for this case (see also the answer of @mhawke) :</p>
<pre><code>from collections import defaultdict

dd = defaultdict(list)
for idx, item in enumerate(s):
    dd[item].append(idx)
</code></pre>
<p>Then convert this to a plain dictionary again:</p>
<pre><code>&gt;&gt;&gt; dict(dd)
{'Hello': [0, 2], 'World': [1, 3]}
</code></pre>
<hr/>
<p>I recently created a package containing a function that could be used as alternative <a href="https://iteration-utilities.readthedocs.io/en/latest/generated/groupedby.html" rel="nofollow noreferrer"><code>iteration_utilities.groupedby</code></a>:</p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import groupedby
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; s =['Hello','World','Hello','World']
&gt;&gt;&gt; groupedby(enumerate(s), key=itemgetter(1), keep=itemgetter(0))
{'Hello': [0, 2], 'World': [1, 3]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="https://docs.python.org/3/library/collections.html?highlight=defaultdict#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> of lists:</p>
<pre><code>from collections import defaultdict

d = defaultdict(list)
s = ['Hello','World','Hello','World']
for index, key in enumerate(s):
    d[key].append(index)

&gt;&gt;&gt; print(d)
defaultdict(&lt;type 'list'&gt;, {'World': [1, 3], 'Hello': [0, 2]})
&gt;&gt;&gt; print(dict(d))    # convert to a std dictionary
{'World': [1, 3], 'Hello': [0, 2]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can also be done using a fairly simple dictionary comprehension:</p>
<pre><code>&gt;&gt;&gt; s =['Hello','World','Hello','World']
&gt;&gt;&gt; d = {k: [pos for pos, el in enumerate(s) if el == k] for k in set(s)}
&gt;&gt;&gt; d
{'World': [1, 3], 'Hello': [0, 2]}
&gt;&gt;&gt; 
</code></pre>
<p>This works by making keys using each <em>unique</em> element in the list <code>s</code>(which <code>set(s)</code> does), and getting the index of each of the unique elements(which the list comprehension does).</p>
</div>
<span class="comment-copy">Do you mean you want a <code>dict</code> containing <code>{'Hello': [0, 2], 'World': [1, 3]}</code>?</span>
<span class="comment-copy">Basically want to convert this into dictionary where Hello and World are my keys and their corresponding values are 0,2 and 1,3</span>
<span class="comment-copy">Yes you are right</span>
<span class="comment-copy">Here d[v] =[i] that means that [] is for list right?</span>
<span class="comment-copy">Correct. if the word is first met, then create a list containing the corresponding index for the key.</span>
