<div class="post-text" itemprop="text">
<pre><code>class A_old:
    def __getattr__(self, attr):
        print 'getattr', attr
        return super(A_old, self).__getattr__(attr)  # &lt;-- note: don't do this!
    def __trunc__(self):
        return 3

class A_new(object):
    def __getattr__(self, attr):
        print 'getattr', attr
        return super(A_new, self).__getattr__(attr)
    def __trunc__(self):
        return 3
</code></pre>
<p>The old-style class works, but the new-style class doesn't.  </p>
<pre><code>&gt;&gt;&gt; range(A_old())
getattr __int__
[0, 1, 2]
&gt;&gt;&gt; range(A_new())
TypeError: range() integer end argument expected, got A_new.
</code></pre>
<p>Why?</p>
<hr/>
<p><sub>
<strong>Note</strong>:  I'm using 2.7 above.  None of this applies in Python 3, where <code>range</code> is documented as responding to <code>__index__</code> and old-style classes have gone the way of the Norwegian Blue.  </sub></p>
</div>
<div class="post-text" itemprop="text">
<p>Old-style classes implement a different method to test if you can convert to a number, one that supports using <code>__trunc__</code> if <code>__int__</code> doesn't exist.</p>
<p><code>range()</code> (Python 2), <a href="https://hg.python.org/cpython/file/2.7/Python/bltinmodule.c#l1770" rel="nofollow noreferrer">uses <code>Py_TYPE(arg)-&gt;tp_as_number-&gt;nb_int()</code></a> to convert the value to an integer, which is <em>roughly</em>, but not quite, like using <code>int()</code>. So we have to look at the <code>nb_int()</code> slot for both old and new-style classes here.</p>
<p>Old-style classes <a href="https://hg.python.org/cpython/file/2.7/Objects/classobject.c#l2180" rel="nofollow noreferrer">implement the <code>nb_int</code> slot</a> as <a href="https://hg.python.org/cpython/file/2.7/Objects/classobject.c#l1859" rel="nofollow noreferrer"><code>instance_int()</code></a>, which uses <em><code>hasattr()</code></em> (or rather, the <a href="https://docs.python.org/2/c-api/object.html#c.PyObject_HasAttr" rel="nofollow noreferrer">C equivalent</a>) to test for <code>__int__</code>:</p>
<pre><code>if (PyObject_HasAttr((PyObject*)self, int_name))
    return generic_unary_op(self, int_name);
</code></pre>
<p><code>hasattr()</code> swallows <strong>all</strong> exceptions, including the <code>TypeError</code> your old-style class throws:</p>
<pre><code>&gt;&gt;&gt; A_old().__int__
getattr __int__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 4, in __getattr__
TypeError: super() argument 1 must be type, not classobj
</code></pre>
<p>Because <code>hasattr()</code> swallows the exception, <code>hasattr()</code> returns <code>False</code>:</p>
<pre><code>&gt;&gt;&gt; hasattr(A_old(), '__int__')
getattr __int__
False
</code></pre>
<p>and the next line in <code>instance_int()</code> then uses <code>__trunc__</code>:</p>
<pre><code>truncated = _instance_trunc(self);
</code></pre>
<p>New-style classes never also use <code>__trunc__</code> when you ask for <code>nb_int</code>; they want <code>__int__</code> or bust. That's because they support slots directly; <code>tp_as_number-&gt;nb_int()</code> <em>directly</em> calls <code>__int__</code> if available (bypassing <code>__getattribute__</code> altogether).</p>
<p>Note that when explicitly using <code>int()</code> to convert, then the underlying C code will look for a <code>__trunc__</code> attribute explicitly (using it only if no <code>tp_as_number-&gt;nb_int()</code> slot is available), but at least it won't use <code>hasattr()</code> for this. This means using <code>int()</code> on your new-style class still works:</p>
<pre><code>&gt;&gt;&gt; int(A_new())
3
</code></pre>
<p>In Python 3, all use of <code>__trunc__</code> treats it as a proper <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">special method</a>.</p>
</div>
<span class="comment-copy">Something in <code>range()</code> catches the <code>TypeError()</code> that using <code>super()</code> in <code>A_old.__getattr__()</code> raises.</span>
<span class="comment-copy">Ah.  Heh, funny.</span>
<span class="comment-copy">Why isn't <code>__trunc__</code> mentioned anywhere in <a href="https://docs.python.org/2/reference/datamodel.html" rel="nofollow noreferrer">the datamodel</a>?</span>
<span class="comment-copy">Why isn't <code>__deepcopy__</code> or <code>__copy__</code> or <code>__getstate__</code>? <i>shrug</i>. <code>__trunc__</code> is really specific to <code>math.trunc()</code>.</span>
<span class="comment-copy">OK, why does it catch a <code>TypeError</code> instead of catching an <code>AttributeError</code>?</span>
<span class="comment-copy">Ah, that old <a href="http://stackoverflow.com/q/35566680/674039"><code>hasattr</code> bug</a>.</span>
