<div class="post-text" itemprop="text">
<p>I have a <code>Set</code> which stores IP addresses. The IP address could be a unique IP or a subnet. I have overloaded the <code>__hash__</code> and <code>__eq__</code> methods. The <code>Set</code> works fine.</p>
<p><strong>Question is : When I am trying to add a duplicate element, is there a way to show the original element?</strong></p>
<p>I cannot use the <code>in</code> operation because it will take a long time since there are about 100,000 IP addresses and I could create only like 5 different buckets for the <code>Set</code>. </p>
<p><strong>An example</strong></p>
<p>I added the subnet 10.0.0.0/8 to the <code>Set</code>.</p>
<p>I then tried to add the unique IP 10.10.10.10 to the <code>Set</code>.</p>
<p>The <code>Set</code> won't add the unique IP because it is a duplicate of the subset 10.0.0.0/8. At such a situation I want to show the user:</p>
<blockquote>
<p>10.10.10.10 duplicate of 10.0.0.0/8</p>
</blockquote>
<p>P.S : I just went through the definition of <code>in</code> operation. It just shows if the element is already present or not. It won't show the original element. (I am not a python developer).</p>
<p>P.P.S : I am reading a firewall ACL list. I am adding lot more than just add IP address to the set. That is why I can't show the code here. The code works.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could look at the intersection of the IP address set and a new set containing just the item you want to add to the set.</p>
<pre><code>class MyClass:

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return 'MyClass({})'.format(self.name)

    def __eq__(self, other):
        return isinstance(other, MyClass)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return 0

existing_set = {MyClass('existing')}
new_item = MyClass('new')
intersection = {new_item}.intersection(existing_set)

if intersection:
    print('{} duplicate of {}'.format(new_item, intersection.pop()))
    # MyClass(new) duplicate of MyClass(existing)
else:
    existing_set.add(new_item)
print(existing_set)
# {MyClass(existing)}
</code></pre>
<p>In the case of a new item not being in the set you will do two lookups.</p>
<p>Edit: Intersection will always return the member of the smaller set see <a href="https://stackoverflow.com/questions/20100003/whats-the-algorithm-of-set-intersection-in-python">here</a>. Therefore you could use this method instead:</p>
<pre><code>def isolate(new_item, existing_set):
    for item in existing_set:
        if item == new_item:
            return item
</code></pre>
</div>
<span class="comment-copy">Could you add a snippet?</span>
<span class="comment-copy">I didn't add a code snippet because, its a big code and the code reads a file line by line, does lot of stuff on each line, gets the IP addresses and then just adds them to a set - <code>ip_address_set.add(each_ip)</code></span>
<span class="comment-copy">At least the <code>__eq__</code> method?</span>
<span class="comment-copy">It's hard to give you useful help if you don't post a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> that illustrates your problem.</span>
<span class="comment-copy">You may use the ipaddress module, see <a href="https://docs.python.org/3/howto/ipaddress.html#ipaddress-howto" rel="nofollow noreferrer">docs.python.org/3/howto/ipaddress.html#ipaddress-howto</a></span>
<span class="comment-copy">Great Idea. I never thought of using intersection. I don't have time to check this code now. I will try it out after weekend and if it works I will accept your answer. I have upvoted your answer.</span>
<span class="comment-copy">My doubt is : will <code>intersection</code> have the element from <code>existing_set</code> or from <code>new_item</code>? Even though both are same according to my <code>eq</code> method, the values in both the elements will be different. I want <code>intersection</code> to have the element from <code>existing_set</code></span>
<span class="comment-copy">You're right - the intersection always returns the item from the smaller set: <a href="http://stackoverflow.com/questions/20100003/whats-the-algorithm-of-set-intersection-in-python" title="whats the algorithm of set intersection in python">stackoverflow.com/questions/20100003/â€¦</a></span>
<span class="comment-copy">I don't want values from the smaller set and I don't want to use <code>in</code> because it will take a long time. I will come up with a different logic. I will accept your answer as you told me there is no good way for me to get the original element</span>
