<div class="post-text" itemprop="text">
<p>I have this code:</p>
<pre><code>class Singleton(type):

  def __call__(cls,*args,**kwargs):
    if cls.created is None :
      print('called')
      cls.created = super().__call__(*args,**kwargs)
      return cls.created
    else:
      return cls.created
  def __new__(cls,name,base,attr,**kwargs):
    return super().__new__(cls,name,base,attr,**kwargs)


class OnlyOne(metaclass=Singleton):
  created = None
  def __init__(self,val):
      self.val = val

class OnlyOneTwo(OnlyOne):
  pass


k = OnlyOne(1)
a = OnlyOneTwo(2)



print(a.val)
print(k.val)
print('a.created: {0} - b.created: {1}'.format(id(a.created),id(k.created)))
</code></pre>
<p>I'm new to Python 3 so I decided to do some little experiment and playing around Python's metaclasses. </p>
<p>Here, I attempted to make a metaclass that will strict a class to a single instance when set.</p>
<p>I'm not sure yet if this works but whenever I try to do:</p>
<pre><code>k = OnlyOne(1)
a = OnlyOneTwo(2)
</code></pre>
<p>the output will be:</p>
<pre><code>called
1
1
</code></pre>
<p>which means that <code>OnlyOneTwo</code> wasn't set but when I try to do:</p>
<pre><code>a = OnlyOneTwo(2)
k = OnlyOne(1)
</code></pre>
<p>the output will be:</p>
<pre><code>called
called
2
1
</code></pre>
<p>Can someone help me traceback? I'm somehow confused but here are my initial questions/thoughts:</p>
<ol>
<li><p>Does <code>OnlyOneTwo</code>'s <code>created</code> property the same as <code>OnlyOne</code>'s ? because I get different results through <code>id()</code> depending on which one I defined first. It's different if it's <code>OnlyOneTwo</code> first but it's the same if it's <code>OnlyOne</code> first.</p></li>
<li><p>How come <code>created</code> is still <code>None</code> if I will run <code>a = OnlyOneTwo(2)
print(OnlyOne.created)</code> ?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>I'll give this a shot.  I think the symptom is due to the assignment, <code>cls.created = ...</code> in <code>__call__</code>.</p>
<p>When the class objects are first created <code>OnlyOneTwo.created</code> <em>points to</em> <code>OnlyOne.created</code>.  They both have the same <code>id</code>, which is the same as <code>None</code>.</p>
<pre><code>&gt;&gt;&gt; id(None)
506773144
&gt;&gt;&gt; id(OnlyOne.created), id(OnlyOneTwo.created)
(506773144, 506773144)
</code></pre>
<p>If you make an instance of <code>OnlyOne</code> first, the instance is assigned to <code>OnlyOne.created</code> (it no longer <em>points to</em> <code>None</code>) but <code>OnlyOneTwo.created</code> still points to <code>OnlyOne.created</code> - they are still the same thing so that when <code>OnlyOneTwo</code> is called, the else clause of the conditional is executed.</p>
<pre><code>&gt;&gt;&gt; a = OnlyOne('a')
called
&gt;&gt;&gt; id(OnlyOne.created), id(OnlyOneTwo.created)
(54522152, 54522152)
&gt;&gt;&gt; z = OnlyOneTwo('z')
&gt;&gt;&gt; id(OnlyOne.created), id(OnlyOneTwo.created)
(54522152, 54522152)
&gt;&gt;&gt; id(a)
54522152
</code></pre>
<p>When you make an instance of <code>OnlyOneTwo</code> first, that instance is assigned to <code>OnlyOneTwo.created</code>, it no longer <em>points to</em> <code>OnlyOne.created</code>.  <code>OnlyOne.created</code> still <em>points to</em> <code>None</code>.</p>
<pre><code>&gt;&gt;&gt; id(None)
506773144
&gt;&gt;&gt; id(OnlyOne.created), id(OnlyOneTwo.created)
(506773144, 506773144)
&gt;&gt;&gt; z = OnlyOneTwo('z')
called
&gt;&gt;&gt; id(OnlyOne.created), id(OnlyOneTwo.created)
(506773144, 54837544)
&gt;&gt;&gt; id(z)
54837544
</code></pre>
<p>Now when you make an instance of <code>OnlyOne</code> the if condition is True and the instance is assigned to <code>OnlyOne.created</code></p>
<pre><code>&gt;&gt;&gt; a = OnlyOne('a')
called
&gt;&gt;&gt; id(OnlyOne.created), id(OnlyOneTwo.created)
(54352752, 54837544)
&gt;&gt;&gt; id(a)
54352752
</code></pre>
<p>I often find myself re-reading <a href="https://docs.python.org/3/reference/executionmodel.html#binding-of-names" rel="nofollow noreferrer">Binding of Names</a> and <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">Resolution of Names</a> - also <a href="https://docs.python.org/3/tutorial/classes.html#a-word-about-names-and-objects" rel="nofollow noreferrer">A Word About Names and Objects</a> and <a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow noreferrer">Python Scopes and Namespaces</a></p>
<hr/>
<p>I feel that I haven't actually explained the mechanism - I don't really understand how the <em>child</em> class attribute <strong><em>points to</em></strong> the base class attribute - it is something different than <code>a = b = None</code>.</p>
<p>Maybe:</p>
<ul>
<li>Initially the child class doesn't actually <em>have</em> the attribute, the <em>points to</em> mechanism is how inheritance is implemented, since  it doesn't <em>have</em> the attribute, the attribute is searched for in its parent(s).</li>
<li>Even though the parent class attribute <em>changes</em> with instantiation, the child class still doesn't <em>have</em> the attribute and has to search for it and it finds the <em>new</em> thing.</li>
<li>If the child class is instantiated first the assignment in the metaclass <em>gives</em> the attribute to the child class - now it <em>has</em> it and it doesn't have to search for it.</li>
</ul>
<p>Re-reading the Custom Classes section of the <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow noreferrer">Standard Type Hierarchy</a> in the docs triggered that brain dump.</p>
<p>I feel like I've been here before, maybe even in SO.  Hope I remember it this time and don't have to figure it out again.</p>
<hr/>
<p>If you want to fix your Singleton there are numerous options if you search for them.  Using a metaclass it seems the instance is held in the metaclass, not the the class itself. <a href="https://stackoverflow.com/q/6760685/2823755">Creating a singleton in Python</a>, SO Q&amp;A, is a good start.</p>
</div>
<span class="comment-copy">Maybe start by adding <code>print('__new__\tcls:{}\n\tname:{}\n\tbase:{}\n\tattr:{}'.format(cls,name,base,attr))</code> as the first line of <code>__new__</code>.</span>
