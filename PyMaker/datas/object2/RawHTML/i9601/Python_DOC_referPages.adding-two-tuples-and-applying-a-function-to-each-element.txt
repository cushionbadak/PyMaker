<div class="post-text" itemprop="text">
<p>I want to add a tuple (called pointer) to another tuple, then apply a clamp function I created to each of its elements, then finally return the new tuple.
I am sure there is a better way to do this:</p>
<pre><code>from operator import add

pointer = (1, 1)
tuple2 = (1, 5)

pointer = map(add, pointer, tuple2)
x, y = pointer
x, y = clamp(x, 0, 3), clamp(y, 0, 3) # min = 0, max = 3
pointer = (x, y)
</code></pre>
<p><b>[OUTPUT] pointer: (2, 3)</b></p>
</div>
<div class="post-text" itemprop="text">
<p>One way would be to use <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer"><code>functools.partial</code></a> to create a clamping function with mixed limits, and then map that over the map object you get after the adding operation.</p>
<pre><code>from operator import add
from functools import partial

def clamp(x, lo, hi):
    return max(lo, min(x, hi)) 

pointer = (1, 1)
tuple2 = (1, 5)
pointer = tuple(map(partial(clamp, lo=0, hi=3), map(add, pointer, tuple2)))
print(pointer)
</code></pre>
<p><strong>output</strong></p>
<pre><code>(2, 3)
</code></pre>
<hr/>
<p>Another way would be to combine the adding and clamping into a single function. In the code below I use a function <code>make_add_clamp</code> which returns a function that does the adding and clamping using the limits passed to <code>make_add_clamp</code>.</p>
<pre><code>from operator import add

def clamp(x, lo, hi):
    return max(lo, min(x, hi)) 

def make_add_clamp(lo, hi):
    def func(x, y):
        return clamp(x + y, lo, hi)
    return func

pointer = (1, 1)
tuple2 = (1, 5)

pointer = tuple(map(make_add_clamp(0, 3), pointer, tuple2))
print(pointer)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can partially apply <code>clamp</code> manually:</p>
<pre><code>&gt;&gt;&gt; def clamp(a, m, M):
...   return min(max(a, m),M)
...
&gt;&gt;&gt; clamp(2, 0, 3)
2
&gt;&gt;&gt; clamp(6, 0, 3)
3
</code></pre>
<p>So define a new function...</p>
<pre><code>&gt;&gt;&gt; def clamp_partial(n):
...   return clamp(n,0,3)
...
</code></pre>
<p>And finally</p>
<pre><code>&gt;&gt;&gt; tuple(map(clamp_partial, map(add, pointer, tuple2)))
(2, 3)
&gt;&gt;&gt;
</code></pre>
<p>Some people find comprehensions/generator expressions more readable, though. And there is no need to define a new function.</p>
<pre><code>&gt;&gt;&gt; pointer = (1, 1)
&gt;&gt;&gt; tuple2 = (1, 5)
&gt;&gt;&gt; pointer = (t1 + t2 for t1, t2 in zip(pointer, tuple2))
&gt;&gt;&gt; pointer
&lt;generator object &lt;genexpr&gt; at 0x10218a780&gt;
&gt;&gt;&gt; pointer = tuple(clamp(p, 0, 3) for p in pointer)
&gt;&gt;&gt; pointer
(2, 3)
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use itertools.chain, The itertools.chain() method can be used to simplify this task. It takes a list of iterables as input, and returns an iterator that effectively masks the fact that youâ€™re really acting on multiple containers. To illustrate, consider this example:</p>
<pre><code>&gt;&gt;&gt;from itertools import chain
&gt;&gt;&gt;a = [1, 2, 3, 4]
&gt;&gt;&gt;b = ['x', 'y', 'z']
&gt;&gt;&gt;for x in chain(a, b):
...
 print(x)
...
1
2
3
4
x
y
z
</code></pre>
</div>
<span class="comment-copy">what does add do in map?</span>
<span class="comment-copy">provide full code and ask here: codereview.stackexchange.com</span>
<span class="comment-copy">I updated the code to include the import, it adds the elements of the tuples together.</span>
<span class="comment-copy">In its current state your answer doesn't address the OP's question. You should show how <code>chain</code> can be applied to the OP's problem.</span>
