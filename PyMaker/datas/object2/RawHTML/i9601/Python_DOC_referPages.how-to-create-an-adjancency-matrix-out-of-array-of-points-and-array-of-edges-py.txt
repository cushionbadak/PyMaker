<div class="post-text" itemprop="text">
<p>I have an image, and I collected some points that represent the centroids of areas that represent vertices in my graph.
My list of points looks like this:</p>
<pre><code>[(455, 472), (343, 472), (208, 471), (478, 456), (460, 441), (428, 439), 
 (413, 458), (48, 439), (107, 460), (130, 413), (179, 385), (250, 396), 
 (20, 373), (431, 381), (483, 355), (342, 390), (441, 343), (312, 344), 
 (283, 336), (259, 342), (409, 329),..............................]
</code></pre>
<p>Now I look for some edges, and doing some manipulation in my code generates this type of list of (p1,p2) where p1 ---- p2 is an edge:</p>
<pre><code>[((343, 472), (342, 390)), ((343, 472), (312, 344)), 
 ((343, 472), (337, 302)), ((478, 456), (460, 441)),...................]
</code></pre>
<p>Now I want to implement some algorithm, like Dijksra or BFS.
Looking in other SO questions and implementations, I notice that most of that graphs are represented as adjacency matrices.
I thought about just instead of adding the edges like I did, to add them directly into hash table or dictionary object. The problem is - what name do I give a vertex? lets say I have <code>(343,472)</code>, I do not understand how to go about and turn into a dict that looks like this: <code>{A : [p1,p2...], B: [p3,....], ... }</code></p>
<p>What would be a good method to do this? I add a code that shows how I create the edges representation at the moment:</p>
<pre><code>def makeEdgesFromSpots(centroids, imageForEdges):
edges = []
for c1 in centroids:
    for c2 in centroids:
        if(c1[0] == c2[0] and c1[1] == c2[1]):
            continue
        else:
            //checkPointsForPath does some testing, 
           //  to check if I want these points as an edge.
            isLine = checkPointsForPath(c1,c2,imageForEdges)
            if isLine == True:
                edges.append((c1,c2))
return edges
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your graph is unweighted and doesn't have multiedges you could just use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>defaultdict</code></a> with <code>set</code> values:</p>
<pre><code>from collections import defaultdict
import pprint

edges = [((343, 472), (342, 390)), ((343, 472), (312, 344)),
         ((343, 472), (337, 302)), ((478, 456), (460, 441))]
adj_matrix = defaultdict(set)

for x, y in edges:
    adj_matrix[x].add(y)
    adj_matrix[y].add(x) # Assuming undirected graph

pprint.pprint(adj_matrix)
</code></pre>
<p>Output:</p>
<pre><code>defaultdict(&lt;class 'set'&gt;,
            {(312, 344): {(343, 472)},
             (337, 302): {(343, 472)},
             (342, 390): {(343, 472)},
             (343, 472): {(312, 344), (337, 302), (342, 390)},
             (460, 441): {(478, 456)},
             (478, 456): {(460, 441)}})
</code></pre>
<p>There's no need to name the vertices unless you explicitly need name for some specific purpose.</p>
</div>
<span class="comment-copy">I don't think I understand your objective. Are you trying to get an adjacency matrix or a dictionary of neighbour sets per node? Nodes need no name in adjacency matrices.</span>
<span class="comment-copy">Sorry I wasn't too accurate in the question, a dict works fine, like the answer given by @niemmi</span>
<span class="comment-copy">Perfect, exactly what I was looking to achieve, in terms of smoothness and result. Thanks a lot!</span>
<span class="comment-copy">def drawEdges(edges, original_image):     for k,v in edges.items():         img = cv2.line(original_image, k, v, (255,0,0), 3)    I am trying to iterate this data structure, but it fails with SystemError: new style getargs format but argument is not a tuple any idea why? I thought the key and value of each is a tuple</span>
<span class="comment-copy">OK v is {(tuples)...} so I need to double for loop. got it</span>
