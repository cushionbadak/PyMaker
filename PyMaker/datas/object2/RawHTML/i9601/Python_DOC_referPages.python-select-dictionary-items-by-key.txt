<div class="post-text" itemprop="text">
<p>I have this dictionary:</p>
<pre><code>a = { 
    'car1': ('high cp', 'low fd', 'safe'),
    'car2': ('med cp', 'med fd', 'safe'), 
    'car3': ('low cp', 'high fd', 'safe'), 
    'taxi1': ('high cp', 'low fd', 'safe', 'med wt'), 
    'taxi2': ('high cp', 'low fd', 'safe', 'high wt'), 
    'taxi3': ('high cp', 'low fd', 'safe', 'high wt')
}
</code></pre>
<p>From the above dictionary, I want to create a new dictionary that consists only 'car%s'</p>
<p>I'm using this <a href="https://stackoverflow.com/questions/3545331/how-can-i-get-dictionary-key-as-variable-directly-in-python-not-by-searching-fr">code snippet</a> (from another question)</p>
<pre><code>b = {}
for key in a:
    if key == 'car%s'% (range (4)):
        print (" %s : %s" % (key, a[key]))
print(b)
</code></pre>
<p>It returns {}</p>
<p>I expect to get:</p>
<pre><code>a = { 
    'car1': ('high cp', 'low fd', 'safe'),
    'car2': ('med cp', 'med fd', 'safe'), 
    'car3': ('low cp', 'high fd', 'safe'), 
}
</code></pre>
<p>What am I missing here?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to add keys which contain word <code>car</code> in it, then it will work:</p>
<pre><code>a = { 
    'car1': ('high cp', 'low fd', 'safe'),
    'car2': ('med cp', 'med fd', 'safe'), 
    'car3': ('low cp', 'high fd', 'safe'), 
    'taxi1': ('high cp', 'low fd', 'safe', 'med wt'), 
    'taxi2': ('high cp', 'low fd', 'safe', 'high wt'), 
    'taxi3': ('high cp', 'low fd', 'safe', 'high wt')
}

b = {}
for key in a:
    if 'car' in key:
        print (key, a[key])
        b[key] = a[key]
print(b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're checking the prefix the wrong way and you're not storing the result. You could use <a href="https://docs.python.org/3/library/stdtypes.html#str.startswith" rel="nofollow noreferrer"><code>str.startswith</code></a> and dict comprehension to generate the result:</p>
<pre><code>&gt;&gt;&gt; a = { 
... 'car1': ('high cp', 'low fd', 'safe'),
... 'car2': ('med cp', 'med fd', 'safe'), 
... 'car3': ('low cp', 'high fd', 'safe'), 
... 'taxi1': ('high cp', 'low fd', 'safe', 'med wt'), 
... 'taxi2': ('high cp', 'low fd', 'safe', 'high wt'), 
... 'taxi3': ('high cp', 'low fd', 'safe', 'high wt')
... }
&gt;&gt;&gt; res = {k: v for k, v in a.items() if k.startswith('car')}
&gt;&gt;&gt; res
{'car2': ('med cp', 'med fd', 'safe'), 'car3': ('low cp', 'high fd', 'safe'), 'car1': ('high cp', 'low fd', 'safe')}
</code></pre>
<p>Instead of inserting a number to the format string your current check inserts the <code>range</code> object there which probably isn't the result you expect:</p>
<pre><code>&gt;&gt;&gt; 'car%s'% (range (4))
'carrange(0, 4)'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This works:</p>
<pre><code>new_dict = {}

for k in a.keys():
    if 'car' in k:
        new_dict[k] = a[k]
</code></pre>
<p>result:</p>
<pre><code>&gt;&gt;new_dict
{'car1': ('high cp', 'low fd', 'safe'),
 'car2': ('med cp', 'med fd', 'safe'),
 'car3': ('low cp', 'high fd', 'safe')}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You never do anything with the keys you validate but <code>print</code> them. You need to add them to your new dictionary:</p>
<pre><code>b ={}
for key, val in a.items(): # .iteritems() for Python 2.x users
   if key == 'car%s' % (range (4)):
       b[key] = val
print(b)
</code></pre>
<p>Your code is would still be broken however. You need to make some changes:</p>
<ul>
<li>The only prefix you need to check is <code>"car"</code>. Forget trying to match the whole string.</li>
<li><p>This entire for loop could be made into a very simple dictionary comprehension:</p>
<pre><code>&gt;&gt;&gt; a = { 
... 'car1': ('high cp', 'low fd', 'safe'),
... 'car2': ('med cp', 'med fd', 'safe'), 
... 'car3': ('low cp', 'high fd', 'safe'), 
... 'taxi1': ('high cp', 'low fd', 'safe', 'med wt'), 
... 'taxi2': ('high cp', 'low fd', 'safe', 'high wt'), 
... 'taxi3': ('high cp', 'low fd', 'safe', 'high wt')
... }
&gt;&gt;&gt; {k: v for k, v in a.items() if k[0:3] == 'car'}
{'car2': ('med cp', 'med fd', 'safe'), 
 'car3': ('low cp', 'high fd', 'safe'), 
 'car1': ('high cp', 'low fd', 'safe')}
&gt;&gt;&gt; 
</code></pre></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>what do you expect from range(4)?
It returns <code>[0, 1, 2, 3]</code></p>
<pre><code>b = {}
for key in range(4):
    new_key = "car%s" % key # generate new_key
    item = a.get(new_key)
    if item is not None:
        b[new_key] = item
print (b)
</code></pre>
<p>OR you want to get items only starts with <code>car</code>,
read this link
<a href="https://docs.python.org/3/library/stdtypes.html#str.startswith" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#str.startswith</a></p>
<pre><code>b = {}
for key, value in a.items():
    if key.startswith("car"):
        b[key] = a[key]
print (b)
</code></pre>
<p>output</p>
<pre><code>{'car2': ('med cp', 'med fd', 'safe'), 
'car3': ('low cp', 'high fd', 'safe'), 
'car1': ('high cp', 'low fd', 'safe')}
</code></pre>
</div>
<span class="comment-copy">You are just printing keys with <code>car</code> in them, not adding them to another dictionary.</span>
<span class="comment-copy">you beat me by 17 seconds :)</span>
