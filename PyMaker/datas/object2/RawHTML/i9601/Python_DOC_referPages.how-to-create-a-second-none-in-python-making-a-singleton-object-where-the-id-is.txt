<div class="post-text" itemprop="text">
<p>WARNING: The following question is asking for information concerning poor practices and dirty code. Developer discretion is advised. </p>
<p>Note: This is different than the <a href="https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python">Creating a singleton in Python</a> question because we want to address pickling and copying as well as normal object creation. </p>
<p>Goal: I want to create a value (called <code>NoParam</code>) that simulates the behavior of <code>None</code>. Specifically I want any instance of <code>NoParamType</code> to be the same value --- i.e. have the same <code>id</code> --- so that the <code>is</code> operator always returns <code>True</code> between two of these values. </p>
<p>Why: I have configuration classes that holds onto values of parameters. Some of these parameters can take <code>None</code> as a valid type. However, I want these parameters to take particular default values if no type is specified. Therefore I need some sentinel that <code>is not None</code> to specify that no parameter was specified. This sentinel needs to be something that 
 could never be used as a valid parameter value.  I would prefer to have a special type for this sentinel instead of using some unlikely to be used string.</p>
<p>For instance:</p>
<pre><code>def add_param(name, value=NoParam):
    if value is NoParam:
        # do some something
    else:
        # do something else 
</code></pre>
<p>But lets not worry so much about the why. Lets focus on the how. </p>
<hr/>
<p>What I have so far: </p>
<p>I can achieve most of this behavior pretty easily. I have created a special module called <code>util_const.py</code>. This contains a class that creates a NoParamType and then a singleton instance of the class. </p>
<pre><code>class _NoParamType(object):
    def __init__(self):
        pass

NoParam = _NoParamType()
</code></pre>
<p>I'm simply assuming that a second instance of this class will never be created. Whenever I want to use the value I <code>import util_const</code> and use <code>util_const.NoParam</code>.</p>
<p>This works well for most cases. However, I just encountered a case where 
a <code>NoParam</code> value was set as an object value. The object was deep copied using <code>copy.deepcopy</code> and thus a second NoParam instance was created. </p>
<p>I found a very simple workaround for this by defining the <code>__copy__</code> and <code>__deepcopy__</code> methods</p>
<pre><code>class _NoParamType(object):
    def __init__(self):
        pass
    def __copy__(self):
        return NoParam
    def __deepcopy__(self, memo):
        return NoParam

NoParam = _NoParamType()
</code></pre>
<p>Now, if <code>deepcopy</code> is ever called no <code>NoParam</code> it simply returns the existing <code>NoParam</code> instance. </p>
<hr/>
<p>Now for the question: </p>
<p>Is there anything I can do to achieve this same behavior with pickling? Initially I thought I could define <code>__getstate__</code> but the second instance has already been created at that point. Essentially I want <code>pickle.loads(pickle.dumps(NoParam)) is NoParam</code> to return True. Is there a way to do this (perhaps with metaclasses)?</p>
<p>To take it even further: is there anything I can do to ensure that only one instance of NoParam is ever created?</p>
<hr/>
<p><strong>Solution</strong></p>
<p>Big thanks to @user2357112 for answering the question about pickling. 
I've also figured out how to make this class robust to module reloading as well. Here is what I've learned all put together</p>
<pre><code># -*- coding: utf-8 -*-
# util_const.py    

class _NoParamType(object):
    """
    Class used to define `NoParam`, a setinal that acts like None when None
    might be a valid value. The value of `NoParam` is robust to reloading,
    pickling, and copying.  

    Example:
        &gt;&gt;&gt; import util_const
        &gt;&gt;&gt; from util_const import _NoParamType, NoParam
        &gt;&gt;&gt; from six.moves import cPickle as pickle
        &gt;&gt;&gt; import copy
        &gt;&gt;&gt; versions = {
        ... 'util_const.NoParam': util_const.NoParam,
        ... 'NoParam': NoParam,
        ... '_NoParamType()': _NoParamType(),
        ... 'copy': copy.copy(NoParam),
        ... 'deepcopy': copy.deepcopy(NoParam),
        ... 'pickle': pickle.loads(pickle.dumps(NoParam))
        ... }
        &gt;&gt;&gt; print(versions)
        &gt;&gt;&gt; assert all(id(v) == id_ for v in versions.values())
        &gt;&gt;&gt; import imp
        &gt;&gt;&gt; imp.reload(util_const)
        &gt;&gt;&gt; assert id(NoParam) == id(util_const.NoParam)
    """
    def __new__(cls):
        return NoParam
    def __reduce__(self):
        return (_NoParamType, ())
    def __copy__(self):
        return NoParam
    def __deepcopy__(self, memo):
        return NoParam
    def __call__(self, default):
        pass

# Create the only instance of _NoParamType that should ever exist
# When the module is first loaded, globals() will not contain NoParam. A
# NameError will be thrown, causing the first instance of NoParam to be
# instanciated.
# If the module is reloaded (via imp.reload), globals() will contain
# NoParam. This skips the code that would instantiate a second object
# Note: it is possible to hack around this via
# &gt;&gt;&gt; del util_const.NoParam
# &gt;&gt;&gt; imp.reload(util_const)

try:
    NoParam
except NameError:
    NoParam = object.__new__(_NoParamType)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there anything I can do to achieve this same behavior with pickling?</p>
</blockquote>
<p>Yes.</p>
<pre><code>class _NoParamType(object):
    def __new__(cls):
        return NoParam
    def __reduce__(self):
        return (_NoParamType, ())

NoParam = object.__new__(_NoParamType)
</code></pre>
<blockquote>
<p>To take it even further: is there anything I can do to ensure that only one instance of NoParam is ever created?</p>
</blockquote>
<p>Not without writing <code>NoParam</code> in C. Unless you write it in C and take advantage of C API-only capabilities, it'll always be possible to do <code>object.__new__(type(NoParam))</code> to get another instance.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm going to answer <a href="https://meta.stackexchange.com/q/66377/255187">part X, not part Y</a>:</p>
<blockquote>
<p>I have configuration classes that holds onto values of parameters. Some of these parameters can take <code>None</code> as a valid type. However, I want these parameters to take particular default values if no type is specified.</p>
<p>...</p>
<p>For instance:</p>
<pre><code>def add_param(name, value=NoParam):
    if value is NoParam:
        # do some something
    else:
        # do something else
</code></pre>
</blockquote>
<p>The proper way to test whether or not <code>value</code> was defined by the caller is to <em>eliminate the default value completely</em>:</p>
<pre><code>def add_param(name, **kwargs):
    if 'value' not in kwargs:
        # do some something
    else:
        # do something else
</code></pre>
<p>True, this breaks some introspection-based features, like linters that check whether you're passing the right arguments to functions, but that headache should be much, much less than trying to bend the identity system over backwards.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/6760685/creating-a-singleton-in-python">Creating a singleton in Python</a></span>
<span class="comment-copy">@lxop: Those singletons aren't singleton-y enough. (Really, they're not.)</span>
<span class="comment-copy">True, they don't handle the pickling aspect.</span>
<span class="comment-copy">This is perfect. There has to be some degree of trust that this object will be used as intended. Adding the ability to pickle and copy the value while preserving the <code>is</code> operation is enough robustness that I'm comfortable with using it. I understand the <code>__new__</code> method, but do you mind explaining what the purpose of the <code>__reduce__</code> method is?</span>
<span class="comment-copy">@Erotemic: It's <a href="https://docs.python.org/2/library/pickle.html#object.__reduce__" rel="nofollow noreferrer">one of the ways</a> to customize pickling, necessary because without it, pickle protocol 0 actually would end up trying to do <code>object.__new__(_NoParamType)</code> when unpickling <code>NoParam</code>.</span>
<span class="comment-copy">Overriding <code>__new__</code> is overkill.  You can just return <code>'NoParam'</code> from <code>__reduce__</code> and <a href="https://docs.python.org/3/library/pickle.html#object.__reduce__" rel="nofollow noreferrer">then the Pickler will look that name up in the module's global scope</a>.  At that point, you can just delete the class after you've used it to construct <code>NoParam</code>, and then you can be reasonably sure nobody will use it to construct a new one without doing some magical <code>type(NoParam)()</code> nonsense, which you can also catch and block if you really want to.</span>
