<div class="post-text" itemprop="text">
<p>Example:</p>
<pre><code>mylist = [['2', '12/12/2016'], ['4', '10/12/2016'], ['5', '08/12/2016'], ['4', '10/12/2016'], ['7', '12/12/2016'], ['10', '12/12/2016'], ['11', '08/12/2016'], ['4', '12/12/2016'], ['10', 'test']]
</code></pre>
<p>The 1st element in the sublist is a string number<br/>
The 2nd element in the sublist can be whatever string</p>
<p>I want to merge the sublists if the first element in a sublist is already in the list (and remove the strings who are double)</p>
<p>Output:</p>
<pre><code>newlist = [['2', '12/12/2016'], ['4', '10/12/2016', '12/12/2016'], ['5', '08/12/2016'], ['7', '12/12/2016'], ['10', '12/12/2016', 'test'], ['11', '08/12/2016']]
</code></pre>
<p>How can I obtain a merged list based on a condition?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to keep both ordering of the sublists and items within the sublists as close to original as possible you could utilize <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a>:</p>
<pre><code>from collections import OrderedDict

mylist = [['2', '12/12/2016'], ['4', '10/12/2016'], ['5', '08/12/2016'],
          ['4', '10/12/2016'], ['7', '12/12/2016'], ['10', '12/12/2016'],
          ['11', '08/12/2016'], ['4', '12/12/2016'], ['10', 'test']]

res = OrderedDict()
for s1, s2 in mylist:
    res.setdefault(s1, OrderedDict())[s2] = True

res = [[k] + list(v) for k, v in res.items()]
print(res)
</code></pre>
<p>Output:</p>
<pre><code>[['2', '12/12/2016'], ['4', '10/12/2016', '12/12/2016'], ['5', '08/12/2016'], 
 ['7', '12/12/2016'], ['10', '12/12/2016', 'test'], ['11', '08/12/2016']]
</code></pre>
<p>Above constructs <code>OrderedDict</code> where keys are first elements from the lists and values are <code>OrderedDict</code> objects. Second level dicts contain the second elements from lists as keys. Second level values are irrelevant, <code>OrderedDict</code> is only used because Python standard library doesn't have <code>OrderedSet</code>.</p>
<p><strong>Update</strong>: Assuming that </p>
<ol>
<li>Sublists have third element which is list of two numbers</li>
<li>Result list should be ordered based on first occurrence of first element</li>
<li>Sublists should contain only unique pairs and be ordered based on the first number of the pair</li>
</ol>
<p>You could use <code>set</code> on second level and sort the pairs when constructing result:</p>
<pre><code>from collections import OrderedDict

mylist = [['1', 'string1', [22,25]], ['4', 'string1', [12,19]], 
          ['4', 'string3', [48,53]], ['8', 'string3', [14,19]],
          ['4', 'string3', [48,53]]]

res = OrderedDict()
for s, _, l in mylist:
    res.setdefault(s, set()).add(tuple(l))

res = [[k] + sorted(v) for k, v in res.items()]
print(res)
</code></pre>
<p>Output:</p>
<pre><code>[['1', (22, 25)], ['4', (12, 19), (48, 53)], ['8', (14, 19)]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you can try this code, but return not oredered list:</p>
<pre><code>result = [[x] + [y[1]
             for y in filter(lambda z: z[0] == x, mylist)]
      for x in set(map(lambda q: q[0], mylist))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As an alternate solution to @niemmi you can use this, which also uses <code>OrderDict</code>:</p>
<pre><code>from collections import OrderedDict

mylist = [['2', '12/12/2016'], ['4', '10/12/2016'], ['5', '08/12/2016'], 
['4', '10/12/2016'], ['7', '12/12/2016'], ['10', '12/12/2016'], 
['11', '08/12/2016'], ['4', '12/12/2016'], ['10', 'test']]

res = OrderedDict((key, []) for key in [tup[0] for tup in mylist])
for tup in mylist:
    if tup[1] not in res[tup[0]]:
        res[tup[0]].append(tup[1])
print(res)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This could probably be made into a generator expression, but written out simply, this approach should work...</p>
<pre><code>new_list = []
for number, date in mylist:
    for index, item in enumerate(new_list):
        if item[0] == number:
            if date not in item:
                new_list[index].append(date)
            break
    else:
        new_list.append([number, date])
</code></pre>
<p>Output:</p>
<pre><code>[['2', '12/12/2016'],
 ['4', '10/12/2016', '12/12/2016'],
 ['5', '08/12/2016'],
 ['7', '12/12/2016'],
 ['10', '12/12/2016', 'test'],
 ['11', '08/12/2016']]
</code></pre>
<p>Though, as mentioned, an OrderedDict, perhaps using the <code>setdefault</code> method may be a more apt solution, since dictionary keys are unique.</p>
<p>edit: tweaked to remove dups</p>
</div>
<div class="post-text" itemprop="text">
<p>Another regular and straight forward and easy to understand example is:</p>
<pre><code>mylist = [['2', '12/12/2016'], ['4', '10/12/2016'], ['5', '08/12/2016'], \
         ['4', '10/12/2016'], ['7', '12/12/2016'], ['10', '12/12/2016'], \
         ['11', '08/12/2016'], ['4', '12/12/2016'], ['10', 'test']]
d = dict()

for sublist in mylist:
    indx = sublist[0]
    if indx in d.keys():
        d[indx].append(sublist[1])
    else:
        d[indx] = sublist

res = []
for key,value in d.iteritems():
    res.append(value)

print sorted(res, key=lambda l: int(l[0]),reverse=False)
</code></pre>
<p>Output:</p>
<pre><code>[['2', '12/12/2016'], ['4', '10/12/2016', '10/12/2016', '12/12/2016'], 
['5', '08/12/2016'], ['7', '12/12/2016'], ['10', '12/12/2016', 'test'], 
['11', '08/12/2016']]
</code></pre>
</div>
<span class="comment-copy">I feel like a dictionary would be handy in this situation</span>
<span class="comment-copy">Does the ordering of the result matter?</span>
<span class="comment-copy">@niemmi, yes the ordering matters</span>
<span class="comment-copy">So what is the correct order?</span>
<span class="comment-copy"><code>defaultdict</code> (but it's not ordered)</span>
<span class="comment-copy">thank you for your answer. The ordering is ascending (by 1st element of sublist), as in your answer.</span>
<span class="comment-copy">niemmi, I still have not totally resolved my problem. If mylist = <code>[['1', 'string1', [22-25]], ['4', 'string1', [12-19]], ['4', 'string3', [48-53]], ['8', 'string3', [14-19]]]</code> - The same as above in my question, what would be the output if I don't want the strings to be added but the stringplaces (stringplaces ordered ascending)? Expected output: <code>[['1', [22-25]], ['4', [12-19], [48-53]], ['8', [14-19]]]</code></span>
<span class="comment-copy">@Reman What is <code>[22-25]</code>? Is it a <code>list</code> containing all the integers in the range as in <code>[22, 23, 24, 25]</code>? Would all the third items in the sublists have the same type?</span>
<span class="comment-copy">Niemmi, [22-25] ==&gt; [startcolumn-endcolumn]</span>
<span class="comment-copy">@Reman Start column and end column of what? Can you give literal example of input and expected out? Unless the input is <code>[['1', 'string1', [-3]],...]</code> and output respectively <code>[['1', [-3]], ...]</code></span>
<span class="comment-copy">You can order <code>result</code> with: <code>ordered_result = sorted(result, key=lambda l: int(l[0]),reverse=False)</code></span>
