<div class="post-text" itemprop="text">
<p>I have a list:</p>
<pre><code>l = [1,2,3]
</code></pre>
<p>I want my output to be:</p>
<pre><code>m = [(1-1, 1-2, 1-3),(2-1, 2-2, 2-3), (3-1, 3-2, 3-3)]
m = [[0, -1, -2], [1,0,-1], [-2,-1,0]]
</code></pre>
<p>I wrote this function and it works fine: </p>
<pre><code>def matrixer(l):
    matrix = []

    for data in l:
        column = []
        column.append(data - l[0])
        column.append(data - l[1])
        column.append(data - l[2])
        matrix.append(column)

    return matrix
</code></pre>
<p>But this doesn't scale well - as my list could have up to 100's of values and I don't want to keep adding the below line of code for each value in my list:</p>
<pre><code>column.append(data - l[n])
</code></pre>
<p>I've never used generators before but it sounds like the solution would involve one. I've always tried a while loop, but it doesn't quite get me there as I run into the same issue.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using two for loops we have to reset the <code>sub_answer</code> every time. This looks messy so maybe another option; can be found below:</p>
<pre><code>l = [1,2,3]
answer = []
for each in l:
  sub_answer = []
  for every in l:
    sub_answer.append(each-every)
  answer.append(sub_answer)
  sub_answer = []
print(answer)
#[[0, -1, -2], [1, 0, -1], [2, 1, 0]]
</code></pre>
<hr/>
<p>Removing a for loop for a list comprehension. Now we don't need <code>sub_answer</code>:</p>
<pre><code>l = [1,2,3]
answer = []
for each in l:
  answer.append([each-x for x in l])
print(answer)
#[[0, -1, -2], [1, 0, -1], [2, 1, 0]]
</code></pre>
<p><code>l</code> is scale able. We are iterating through the list and then appending to a new list that we created using a list comprehension which we are subtracting the <code>each</code> variable by going through the list again. </p>
<p>If we change <code>l</code> to be <code>l = [1,2,3,4,5,6,7]</code> we get:</p>
<pre><code>[[0, -1, -2, -3, -4, -5, -6], [1, 0, -1, -2, -3, -4, -5], [2, 1, 0, -1, -2, -3, -4], [3, 2, 1, 0, -1, -2, -3], [4, 3, 2, 1, 0, -1, -2], [5, 4, 3, 2, 1, 0, -1], [6, 5, 4, 3, 2, 1, 0]]
</code></pre>
<p>As a note <code>(3-1 is not -2... it's 2....)</code></p>
<hr/>
<p>We used one list comprehension why not use two?!?!?!:
If you don't want a for loop and just want to use list comprehension:</p>
<pre><code>l = [1,2,3]
print([[each-x for x in l] for each in l])
#[[0, -1, -2], [1, 0, -1], [2, 1, 0]]
</code></pre>
<p>gives the same result, but I think for loops are more readable if you are learning or on a team.</p>
</div>
<div class="post-text" itemprop="text">
<p>double list comprehension does it in one line:</p>
<pre><code>def matrixer(l):
    return [[e - d for d in l] for e in l]
</code></pre>
<ul>
<li>inner listcomp to create the inner line</li>
<li>outer listcomp to create rows</li>
</ul>
<p>result with your input:</p>
<pre><code>[[0, -1, -2], [1, 0, -1], [2, 1, 0]]
</code></pre>
<p>list comprehensions are highly optimized memory-wise (less reallocations) &amp; CPU-wise (less instructions) so replacing your double loop + append with 2 nested list comprehensions like that will speed up your code a lot.</p>
</div>
<div class="post-text" itemprop="text">
<p>A short answer (shortest so far ^^) would be:</p>
<pre><code>l = [1, 2, 3]

m = [[row - col for row in l] for col in l]
</code></pre>
<p>This uses <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer"><code>list comprehension</code></a> with <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow noreferrer"><code>map()</code></a> and <a href="https://docs.python.org/2/library/operator.html#operator.sub" rel="nofollow noreferrer"><code>operator</code></a> like this:</p>
<pre><code>[map(operator.sub, [item]*len(l), l) for item in l]
</code></pre>
<p>This is equivalent to:</p>
<pre><code>matrix = []

for item in l:
    matrix.append(map(operator.sub, [item]*len(l), l))
</code></pre>
<p><strong>Explanation:</strong></p>
<p>For each <code>item</code> in <code>l</code>, we build a list <code>[item]*len(l)</code> and we use <code>map()</code> and <code>operator</code> to get the subtraction of these two lists. For the first element in <code>l</code> which is 1, we have:</p>
<pre><code>[1]*3  # =&gt; [1, 1, 1]
</code></pre>
<p>Then:</p>
<pre><code>map(operator.sub, [1, 1, 1], [1, 2, 3])  # [1-1, 1-2, 1-3] =&gt; [0, -1, -2]
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt;
&gt;&gt;&gt; l = [1, 2, 3]
&gt;&gt;&gt; [map(operator.sub, [item]*len(l), l) for item in l]
[[0, -1, -2], [1, 0, -1], [2, 1, 0]]
</code></pre>
</div>
