<div class="post-text" itemprop="text">
<p>This is probably a silly question but I was wondering, when we have a container object such as a list or a tuple, and we index it:</p>
<pre><code>l = [2,4,5,6]
l[0]
</code></pre>
<p>in the console we get:</p>
<pre><code>out[#]: 2
</code></pre>
<p>much in the same way we would get if we did:</p>
<pre><code>def ret(num):
    return num
ret(1)
</code></pre>
<p>Is there a hidden function call being made when we index lists or tuples or the like? </p>
</div>
<div class="post-text" itemprop="text">
<p>Your assumption is correct. Python has certain <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">"magic methods"</a> which are called from objects using the corresponding operator(s). The subscript operator(<code>[]</code>) is one of them. The magic method is called <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>__getitem__()</code></a>. The documentation for <code>__getitem__()</code> provides more information:</p>
<blockquote>
<p>Called to implement evaluation of <code>self[key]</code>. For sequence types, the accepted keys should be integers and slice objects. Note that the special interpretation of negative indexes (if the class wishes to emulate a sequence type) is up to the <code>__getitem__()</code> method. If key is of an inappropriate type, <code>TypeError</code> may be raised; if of a value outside the set of indexes for the sequence (after any special interpretation of negative values), <code>IndexError</code> should be raised. For mapping types, if key is missing (not in the container), <code>KeyError</code> should be raised. </p>
</blockquote>
<p>You can observe how <code>__getitem__()</code> works by calling it manually:</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]
&gt;&gt;&gt; lst.__getitem__(0)
1
&gt;&gt;&gt; lst.__getitem__(1)
2
&gt;&gt;&gt; lst.__getitem__(2)
3
&gt;&gt;&gt; # etc...
</code></pre>
<p>There are several other methods similar to <code>__getitem__()</code>;<a href="https://docs.python.org/3/reference/datamodel.html#object.__setitem__" rel="nofollow noreferrer"><code>__setitem__()</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__delitem__" rel="nofollow noreferrer"><code>__delitem__()</code></a>. <code>__setitem__()</code> sets the given index in the list to a given value. The syntactic sugar for calling the method is <code>sequence[index] = value</code>. On the other hand, <code>__delitem__()</code> deletes the value at the given index. It's syntactic sugar is <code>del sequence[index]</code>. Both methods can be called manually and observed:</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]
&gt;&gt;&gt; lst.__setitem__(0, 10)
&gt;&gt;&gt; lst.__getitem__(0)
10
&gt;&gt;&gt; lst.__delitem__(0)
&gt;&gt;&gt; lst.__getitem__(0)
2
&gt;&gt;&gt; 
</code></pre>
<p><strong>Resources</strong></p>
<ul>
<li><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3 documentation</a>. <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">Section 3.3 <em>Special method names</em></a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Yes; pretty all operations on objects map to special methods. In this case it is the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>__getitem__</code></a> method.</p>
</div>
<span class="comment-copy"><code>__get__</code> iirc.</span>
