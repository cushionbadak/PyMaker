<div class="post-text" itemprop="text">
<p><strong>Preamble:</strong>
Python setuptools are used for the package distribution. I have a Python package (let us call it <code>my_package</code>), that has several <code>extra_require</code> packages to it. Everything works just find (installation and build of the package, as well as extras, if were requested), as all <code>extra_require</code> were python packages themselves and pip correctly resolved everything. A simple <code>pip install my_package</code> worked like a charm.</p>
<p><strong>Setup:</strong> 
Now, for one of the extras (let us call it <code>extra1</code>) I need to call a binary of a non-python library <code>X</code>. </p>
<p>Module <code>X</code> itself (source code) was added to the <code>my_package</code> codebase and was included in the distribution <code>my_package</code>. Sadly for me, to be utilized, <code>X</code> needs to be compiled first into a binary on the target machine (C++ implementation; I assume such compilation shall happen on the build stage of <code>my_package</code> installation). There is a <code>Makefile</code> in the <code>X</code> library optimized for different platform compilation, so all that is needed, is to run <code>make</code> in the respective directory of <code>X</code> library in the <code>my_package</code> when the build process is running. </p>
<p><em>Question #1</em>: how to run a terminal command (i.e., <code>make</code> in my case) during the build process of the package, using setuptools/distutils? </p>
<p><em>Question #2</em>: how to ensure, that such terminal command is executed only if the corresponding <code>extra1</code> is specified during the installation process? </p>
<p>Example:</p>
<ol>
<li>If someone runs <code>pip install my_package</code>, no such additional compilation of library <code>X</code> shall happen.</li>
<li>If someone runs <code>pip install my_package [extra1]</code>, module <code>X</code> needs to be compiled, so the corresponding binary would be created and available on the target machine.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>This question came back to haunt me long after I commented on it two years ago! I had almost the same problem myself recently, and I found the documentation VERY scarce, as I think most of you must have experienced. So I tried to research a bit of the source code of <a href="https://github.com/pypa/setuptools/tree/master/setuptools" rel="nofollow noreferrer">setuptools</a> and <a href="https://github.com/python/cpython/tree/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/distutils" rel="nofollow noreferrer">distutils</a> to see if I could find a more or less standard approach to both the questions you asked.</p>
<hr/>
<p>The first question you asked</p>
<blockquote>
<p><em>Question #1</em>: how to run a terminal command (i.e., <code>make</code> in my case) during the build process of the package, using setuptools/distutils?</p>
</blockquote>
<p>has many approaches and all of them involve setting a <code>cmdclass</code> when calling <code>setup</code>. The parameter <code>cmdclass</code> of <code>setup</code> must be a mapping between command names that will execute depending on the build or install needs of the distribution, and classes that inherit from <a href="https://docs.python.org/3/distutils/apiref.html#module-distutils.cmd" rel="nofollow noreferrer"><code>distutils.cmd.Command</code></a> base class (as a side note, the <code>setuptools.command.Command</code> class is derived from <code>distutils</code>' <code>Command</code> class so you can derive directly from <code>setuptools</code> implementation).</p>
<p>The <code>cmdclass</code> allows you to define any command name, like what <a href="https://stackoverflow.com/a/43013234/7253166">ayoon</a> did and then execute it specifically when calling <code>python setup.py --install-option="customcommand"</code> from the command line. The problem with this, is that it is not the standard command that will be executed when trying to install a package through <code>pip</code> or by calling <code>python setup.py install</code>. The standard way to approach this is to check what commands will <code>setup</code> try to execute in a normal install and then overload that particular <code>cmdclass</code>.</p>
<p>From looking into <a href="https://github.com/pypa/setuptools/blob/bb71fd1bed9f5e5e239ef99be82ed57e9f9b1dda/setuptools/__init__.py#L126" rel="nofollow noreferrer"><code>setuptools.setup</code></a> and <a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/distutils/core.py" rel="nofollow noreferrer"><code>distutils.setup</code></a>, <code>setup</code> will run the commands it <a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/distutils/core.py#L145:L148" rel="nofollow noreferrer">found in the command line</a>, which lets assume is just a plain <code>install</code>. In the case of <code>setuptools.setup</code>, this will trigger a series of tests that will see whether to resort to a simple call to the <code>distutils.install</code> command class, and if this does not occur, it will attempt to run <a href="https://github.com/pypa/setuptools/blob/master/setuptools/command/install.py#L109" rel="nofollow noreferrer"><code>bdist_egg</code></a>. In turn, this command does many things but crucially decides on whether to call the <code>build_clib</code>, <code>build_py</code> and/or the <code>build_ext</code> commands. The <code>distutils.install</code> simply runs <code>build</code> if necessary which also runs <a href="https://github.com/pypa/setuptools/blob/master/setuptools/command/build_clib.py" rel="nofollow noreferrer"><code>build_clib</code></a>, <a href="https://github.com/pypa/setuptools/blob/master/setuptools/command/build_py.py" rel="nofollow noreferrer"><code>build_py</code></a> and/or <a href="https://github.com/pypa/setuptools/blob/master/setuptools/command/build_ext.py" rel="nofollow noreferrer"><code>build_ext</code></a>. This means that regardless of whether you use <code>setuptools</code> or <code>distutils</code>, if it is necessary to build from source, the commands <a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/distutils/command/build_clib.py" rel="nofollow noreferrer"><code>build_clib</code></a>, <a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/distutils/command/build_py.py" rel="nofollow noreferrer"><code>build_py</code></a>, and/or <a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/distutils/command/build_ext.py" rel="nofollow noreferrer"><code>build_ext</code></a> will be runned, so these are the ones that we will want to overload with the <code>cmdclass</code> of <code>setup</code>, the question becomes which of the three.</p>
<ul>
<li><code>build_py</code> is used to "build" pure python packages, so we can safely ignore it.</li>
<li><code>build_ext</code> is used to build declared Extension modules that are passed through the <code>ext_modules</code> parameter of the call to the <code>setup</code> function. If we wish to overload this class, the main method that builds each extension is <a href="https://github.com/pypa/setuptools/blob/master/setuptools/command/build_ext.py#L190" rel="nofollow noreferrer"><code>build_extension</code></a> (or <a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/distutils/command/build_ext.py#L485" rel="nofollow noreferrer">here</a> for distutils)</li>
<li><code>build_clib</code> is used to build declared libraries that are passed through the <code>libraries</code> parameter of the call to the <code>setup</code> function. In this case, the main method that we should overload with our derived class is the <a href="https://github.com/pypa/setuptools/blob/master/setuptools/command/build_clib.py#L23" rel="nofollow noreferrer"><code>build_libraries</code></a> method (<a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/distutils/command/build_clib.py#L181" rel="nofollow noreferrer">here</a> for <code>distutils</code>).</li>
</ul>
<p>I'll share an example package that builds a toy c static library through a Makefile by using <code>setuptools</code> <code>build_ext</code> command. The approach can be adapted to using the <code>build_clib</code> command, but you'll have to checkout the source code of <code>build_clib.build_libraries</code>.</p>
<p><strong>setup.py</strong></p>
<pre><code>import os, subprocess
import setuptools
from setuptools.command.build_ext import build_ext
from distutils.errors import DistutilsSetupError
from distutils import log as distutils_logger


extension1 = setuptools.extension.Extension('test_pack_opt.test_ext',
                    sources = ['test_pack_opt/src/test.c'],
                    libraries = [':libtestlib.a'],
                    library_dirs = ['test_pack_opt/lib/'],
                    )

class specialized_build_ext(build_ext, object):
    """
    Specialized builder for testlib library

    """
    special_extension = extension1.name

    def build_extension(self, ext):

        if ext.name!=self.special_extension:
            # Handle unspecial extensions with the parent class' method
            super(specialized_build_ext, self).build_extension(ext)
        else:
            # Handle special extension
            sources = ext.sources
            if sources is None or not isinstance(sources, (list, tuple)):
                raise DistutilsSetupError(
                       "in 'ext_modules' option (extension '%s'), "
                       "'sources' must be present and must be "
                       "a list of source filenames" % ext.name)
            sources = list(sources)

            if len(sources)&gt;1:
                sources_path = os.path.commonpath(sources)
            else:
                sources_path = os.path.dirname(sources[0])
            sources_path = os.path.realpath(sources_path)
            if not sources_path.endswith(os.path.sep):
                sources_path+= os.path.sep

            if not os.path.exists(sources_path) or not os.path.isdir(sources_path):
                raise DistutilsSetupError(
                       "in 'extensions' option (extension '%s'), "
                       "the supplied 'sources' base dir "
                       "must exist" % ext.name)

            output_dir = os.path.realpath(os.path.join(sources_path,'..','lib'))
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)

            output_lib = 'libtestlib.a'

            distutils_logger.info('Will execute the following command in with subprocess.Popen: \n{0}'.format(
                  'make static &amp;&amp; mv {0} {1}'.format(output_lib, os.path.join(output_dir, output_lib))))


            make_process = subprocess.Popen('make static &amp;&amp; mv {0} {1}'.format(output_lib, os.path.join(output_dir, output_lib)),
                                            cwd=sources_path,
                                            stdout=subprocess.PIPE,
                                            stderr=subprocess.PIPE,
                                            shell=True)
            stdout, stderr = make_process.communicate()
            distutils_logger.debug(stdout)
            if stderr:
                raise DistutilsSetupError('An ERROR occured while running the '
                                          'Makefile for the {0} library. '
                                          'Error status: {1}'.format(output_lib, stderr))
            # After making the library build the c library's python interface with the parent build_extension method
            super(specialized_build_ext, self).build_extension(ext)


setuptools.setup(name = 'tester',
       version = '1.0',
       ext_modules = [extension1],
       packages = ['test_pack', 'test_pack_opt'],
       cmdclass = {'build_ext': specialized_build_ext},
       )
</code></pre>
<p><strong>test_pack/__init__.py</strong></p>
<pre><code>from __future__ import absolute_import, print_function

def py_test_fun():
    print('Hello from python test_fun')

try:
    from test_pack_opt.test_ext import test_fun as c_test_fun
    test_fun = c_test_fun
except ImportError:
    test_fun = py_test_fun
</code></pre>
<p><strong>test_pack_opt/__init__.py</strong></p>
<pre><code>from __future__ import absolute_import, print_function
import test_pack_opt.test_ext
</code></pre>
<p><strong>test_pack_opt/src/Makefile</strong></p>
<pre><code>LIBS =  testlib.so testlib.a
SRCS =  testlib.c
OBJS =  testlib.o
CFLAGS = -O3 -fPIC
CC = gcc
LD = gcc
LDFLAGS =

all: shared static

shared: libtestlib.so

static: libtestlib.a

libtestlib.so: $(OBJS)
    $(LD) -pthread -shared $(OBJS) $(LDFLAGS) -o $@

libtestlib.a: $(OBJS)
    ar crs $@ $(OBJS) $(LDFLAGS)

clean: cleantemp
    rm -f $(LIBS)

cleantemp:
    rm -f $(OBJS)  *.mod

.SUFFIXES: $(SUFFIXES) .c

%.o:%.c
    $(CC) $(CFLAGS) -c $&lt;
</code></pre>
<p><strong>test_pack_opt/src/test.c</strong></p>
<pre><code>#include &lt;Python.h&gt;
#include "testlib.h"

static PyObject*
test_ext_mod_test_fun(PyObject* self, PyObject* args, PyObject* keywds){
    testlib_fun();
    return Py_None;
}

static PyMethodDef TestExtMethods[] = {
    {"test_fun", (PyCFunction) test_ext_mod_test_fun, METH_VARARGS | METH_KEYWORDS, "Calls function in shared library"},
    {NULL, NULL, 0, NULL}
};

#if PY_VERSION_HEX &gt;= 0x03000000
    static struct PyModuleDef moduledef = {
        PyModuleDef_HEAD_INIT,
        "test_ext",
        NULL,
        -1,
        TestExtMethods,
        NULL,
        NULL,
        NULL,
        NULL
    };

    PyMODINIT_FUNC
    PyInit_test_ext(void)
    {
        PyObject *m = PyModule_Create(&amp;moduledef);
        if (!m) {
            return NULL;
        }
        return m;
    }
#else
    PyMODINIT_FUNC
    inittest_ext(void)
    {
        PyObject *m = Py_InitModule("test_ext", TestExtMethods);
        if (m == NULL)
        {
            return;
        }
    }
#endif
</code></pre>
<p><strong>test_pack_opt/src/testlib.c</strong></p>
<pre><code>#include "testlib.h"

void testlib_fun(void){
    printf("Hello from testlib_fun!\n");
}
</code></pre>
<p><strong>test_pack_opt/src/testlib.h</strong></p>
<pre><code>#ifndef TESTLIB_H
#define TESTLIB_H

#include &lt;stdio.h&gt;

void testlib_fun(void);

#endif
</code></pre>
<p>In this example, the c library that I want to build using the custom Makefile just has one function which prints <code>"Hello from testlib_fun!\n"</code> to stdout. The <code>test.c</code> script is a simple interface between python and this library's single function. The idea is that I tell <code>setup</code> that I want to build a c extension named <code>test_pack_opt.test_ext</code>, which only has a single source file: the <code>test.c</code> interface script, and I also tell the extension that it must link against the static library <code>libtestlib.a</code>. The main thing is that I overload the <code>build_ext</code> cmdclass using <code>specialized_build_ext(build_ext, object)</code>. The inheritance from <code>object</code> is only necessary if you want to be able to call <code>super</code> to dispatch to parent class methods. The <code>build_extension</code> method takes an <code>Extension</code> instance as its second argument, in order to work nice with other <code>Extension</code> instances that require the default behavior of <code>build_extension</code>, I check if this extension has the name of the special one and if it doesn't I call the <code>super</code>'s <code>build_extension</code> method.</p>
<p>For the special library, I call the Makefile simply with <code>subprocess.Popen('make static ...')</code>. The rest of the command passed to the shell is just to move the static library to a certain default location in which the library should be found to be able to link it to the rest of the compiled extension (which is also just compiled using the <code>super</code>'s <code>build_extension</code> method).</p>
<p>As you can imagine there are just sooo many ways in which you could organize this code differently, it does not make sense to list them all. I hope this example serves to illustrate how to call the Makefile, and which <code>cmdclass</code> and <code>Command</code> derived class you should overload to call <code>make</code> in a standard installation.</p>
<hr/>
<p>Now, onto question 2.</p>
<blockquote>
<p><em>Question #2</em>: how to ensure, that such terminal command is executed only if the corresponding extra1 is specified during the installation process?</p>
</blockquote>
<p>This was possible with the deprecated <code>features</code> parameter of <code>setuptools.setup</code>. The standard way is to try to install the package depending on the requirements that are met. <code>install_requires</code> lists the mandatory requirements, the <code>extras_requires</code> lists the optional requirements. For example from the <a href="http://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-extras-optional-features-with-their-own-dependencies" rel="nofollow noreferrer"><code>setuptools</code> documentation</a></p>
<pre><code>setup(
    name="Project-A",
    ...
    extras_require={
        'PDF':  ["ReportLab&gt;=1.2", "RXP"],
        'reST': ["docutils&gt;=0.3"],
    }
)
</code></pre>
<p>you could force the installation of the optional required packages by calling <code>pip install Project-A[PDF]</code>, but if for some reason the requirements for the <code>'PDF'</code> named extra were satisfied before hand, <code>pip install Project-A</code> would end up with the same <code>"Project-A"</code> functionality. This means that the way in which "Project-A" is installed is not customized for each extra specified at the command line, "Project-A" will always try to install in the same way and may end up with reduced functionality because of unavailable optional requirements.</p>
<p>From what I understood, this means that in order to get your module X to be compiled and installed only if [extra1] is specified, you should ship module X as a separate package and depend on it through an <code>extras_require</code>. Lets imagine module X will be shipped in <code>my_package_opt</code>, your setup for <code>my_package</code> should look like</p>
<pre><code>setup(
    name="my_package",
    ...
    extras_require={
        'extra1':  ["my_package_opt"],
    }
)
</code></pre>
<hr/>
<p>Well, I'm sorry that my answer ended up being so long but I hope it helps. Don't hesitate in pointing out any conceptual or naming error, as I mostly tried to deduce this from the <code>setuptools</code> source code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately, the docs are extremely scarce around the interaction between setup.py and pip, but you should be able to do something like this:</p>
<pre><code>import subprocess

from setuptools import Command
from setuptools import setup


class CustomInstall(Command):

    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        subprocess.call(
            ['touch',
             '/home/{{YOUR_USERNAME}}/'
             'and_thats_why_you_should_never_run_pip_as_sudo']
        )

setup(
    name='hack',
    version='0.1',
    cmdclass={'customcommand': CustomInstall}
)
</code></pre>
<p>This gives you a hook into running arbitrary code with commands, and also supports a variety of custom option parsing (not demonstrated here).</p>
<p>Put this in a <code>setup.py</code> file and try this:</p>
<p><code>pip install --install-option="customcommand" .</code></p>
<p>Note that this command is executed <em>after</em> the main install sequence, so depending on exactly what you're trying to do, it may not work. See the verbose pip install output:</p>
<pre><code>(.venv) ayoon:tmp$ pip install -vvv --install-option="customcommand" .
/home/ayoon/tmp/.venv/lib/python3.6/site-packages/pip/commands/install.py:194: UserWarning: Disabling all use of wheels due to the use of --build-options / -
-global-options / --install-options.                                                                                                                        
  cmdoptions.check_install_build_global(options)
Processing /home/ayoon/tmp
  Running setup.py (path:/tmp/pip-j57ovc7i-build/setup.py) egg_info for package from file:///home/ayoon/tmp
    Running command python setup.py egg_info
    running egg_info
    creating pip-egg-info/hack.egg-info
    writing pip-egg-info/hack.egg-info/PKG-INFO
    writing dependency_links to pip-egg-info/hack.egg-info/dependency_links.txt
    writing top-level names to pip-egg-info/hack.egg-info/top_level.txt
    writing manifest file 'pip-egg-info/hack.egg-info/SOURCES.txt'
    reading manifest file 'pip-egg-info/hack.egg-info/SOURCES.txt'
    writing manifest file 'pip-egg-info/hack.egg-info/SOURCES.txt'
  Source in /tmp/pip-j57ovc7i-build has version 0.1, which satisfies requirement hack==0.1 from file:///home/ayoon/tmp
Could not parse version from link: file:///home/ayoon/tmp
Installing collected packages: hack
  Running setup.py install for hack ...     Running command /home/ayoon/tmp/.venv/bin/python3.6 -u -c "import setuptools, tokenize;__file__='/tmp/pip-j57ovc7
i-build/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))" install --
record /tmp/pip-_8hbltc6-record/install-record.txt --single-version-externally-managed --compile --install-headers /home/ayoon/tmp/.venv/include/site/python3
.6/hack customcommand                                                                                                                                       
    running install
    running build
    running install_egg_info
    running egg_info
    writing hack.egg-info/PKG-INFO
    writing dependency_links to hack.egg-info/dependency_links.txt
    writing top-level names to hack.egg-info/top_level.txt
    reading manifest file 'hack.egg-info/SOURCES.txt'
    writing manifest file 'hack.egg-info/SOURCES.txt'
    Copying hack.egg-info to /home/ayoon/tmp/.venv/lib/python3.6/site-packages/hack-0.1-py3.6.egg-info
    running install_scripts
    writing list of installed files to '/tmp/pip-_8hbltc6-record/install-record.txt'
    running customcommand
done
  Removing source in /tmp/pip-j57ovc7i-build
Successfully installed hack-0.1
</code></pre>
</div>
<span class="comment-copy">Posible duplicate of <a href="http://stackoverflow.com/questions/1754966/how-can-i-run-a-makefile-in-setup-py">How can I run a Makefile in setup.py</a>?</span>
<span class="comment-copy">Not exactly. It a) doesn't have the answer for a situation, when such installation is required, only when the "extra1" is involved. b) It is not really informative/detailed. I would appreciate a more detailed answer, and I believe this is would be very informative for the community if a rather detailed answer was provided.</span>
<span class="comment-copy">Does <code>X</code> have a <code>setup.py</code> and thus is a regular Python package?</span>
<span class="comment-copy">It can be done, but it's hard. I'd recommend handling <code>X</code> as a non-Python dependency, not installable using <code>pip</code>. I.e. you (and your users) would have to install <code>X</code> using the OS package manager or manually. Note that you cannot even hope for a decent <code>make</code> on all platforms.</span>
<span class="comment-copy">Can you compile the binary and distribute a your project as a wheel rather than (or in addition to) the source package?</span>
<span class="comment-copy"><code>sources_path = os.path.commonprefix(sources)</code>  Should this line call <code>os.path.commonpath</code> instead? <code>commonprefix</code> does not necessarily return a valid path, just a string prefix. For example, <code>os.path.commonprefix(["/existing1", "/existing2"]) == "/existing"</code>.</span>
<span class="comment-copy">@dkasak, yes, thanks for catching that</span>
