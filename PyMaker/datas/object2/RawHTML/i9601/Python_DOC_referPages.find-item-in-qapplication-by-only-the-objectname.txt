<div class="post-text" itemprop="text">
<p>i want to find any object by a objectname  string name inside of the QApplication</p>
<p>Something like</p>
<pre><code>QApplication.instance().findByClassName("codeEditor")
</code></pre>
<p>which should return a list of widgets with this classname that i can iterate over if there is more then one</p>
<pre><code>[QPushButton (QPushButton at: 0x0000008EA3B3DD80), QWidget (QWidget at: 0x0000008EA3F33F40)]
</code></pre>
<p>I have read <a href="https://stackoverflow.com/questions/19048657/how-to-find-an-object-by-name-in-pyqt">this</a> but it requires a object and i want something like <code>*</code></p>
<p>This is something i came up with for testing:</p>
<pre><code>def findWidget(name):
    name = name.lower()
    widgets = self.topLevelWidgets()
    widgets = widgets + self.allWidgets()
    ret = dict()
    c = 0
    for x in widgets:
        c += 1
        if name in x.objectName.lower() or name in str(x.__class__).lower():
            ret["class:"+str(x.__class__)+str(c)] = "obj:"+x.objectName;continue
        if hasattr(x, "text"):
            if name in x.text.lower():
                ret["class:"+str(x.__class__)+str(c)] = "obj:"+x.objectName
    return ret
</code></pre>
<p>It doesn't even find the 'InfoFrame' which is clearly there:</p>
<pre><code>&gt;&gt;&gt; widget("info")
</code></pre>
<p>â€©{}</p>
<p><a href="https://i.stack.imgur.com/xmnXb.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/xmnXb.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>I came up with this which works quite well</p>
<pre><code>def getWidgetByClassName(name):
    widgets = QApplication.instance().topLevelWidgets()
    widgets = widgets + QApplication.instance().allWidgets()
    for x in widgets:
        if name in str(x.__class__).replace("&lt;class '","").replace("'&gt;",""):
            return x
def getWidgetByObjectName(name):
    widgets = QApplication.instance().topLevelWidgets()
    widgets = widgets + QApplication.instance().allWidgets()
    for x in widgets:
        if str(x.objectName) == name:
            return x
def getObjects(name, cls=True):
    import gc
    objects = []
    for obj in gc.get_objects():
        if (isinstance(obj, PythonQt.private.QObject) and
            ((cls and obj.inherits(name)) or
             (not cls and obj.objectName() == name))):
            objects.append(obj)
    return objects
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python, this can be done for any class using the <a href="http://docs.python.org/3/library/gc.html#module-gc" rel="nofollow noreferrer">gc module</a>. It provides a method for retrieving the references of all objects tracked by the garbage-collector. This is obviously a quite inefficient approach, but it does (almost) guarantee that any type of object can be found.</p>
<p>Here's a function to get a list of all <code>QObject</code> instances either by class-name or object-name:</p>
<pre><code>def getObjects(name, cls=True):
    objects = []
    for obj in gc.get_objects():
        if (isinstance(obj, QtCore.QObject) and
            ((cls and obj.inherits(name)) or
             (not cls and obj.objectName() == name))):
            objects.append(obj)
    return objects
</code></pre>
<p>This is only really a debugging tool, though - for a large application, there could easily be several hundred thousand objects to check.</p>
<p>If you only need objects which are subclasses of <code>QWidget</code>, use this function:</p>
<pre><code>def getWidgets(name, cls=True):
    widgets = []
    for widget in QtGui.QApplication.allWidgets():
        if ((cls and widget.inherits(name)) or
            (not cls and widget.objectName() == name)):
            widgets.append(widget)
    return widgets
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is not possible to find all <code>QObject</code> instances in general. Qt does not keep track of them since objects can be used in multiple threads and the overhead of tracking them would be unnecessarily high.</p>
<p>Qt does keep track of all widgets, though, since widgets can only exist in the main thread, and they are fairly heavy objects so tracking them has comparably little overhead.</p>
<p>So, you could search all widgets you get from <code>QApp.allWidgets()</code>, and all of their children. You can also look through children of objects you otherwise have access to. But if a given object is parentless, or is not owned by a widget, then you won't find it that way.</p>
</div>
<span class="comment-copy">since (almost) everything is derived from <code>QObject</code> look for that class type</span>
<span class="comment-copy">@SebastianLange What do you mean?</span>
<span class="comment-copy">@SebastianLange <a href="https://snag.gy/md8M7Y.jpg" rel="nofollow noreferrer">snag.gy/md8M7Y.jpg</a></span>
<span class="comment-copy"><code>allWidgets</code> necessarily includes <code>topLevelWidgets</code>. Use one or the other, not both.</span>
<span class="comment-copy">Neither of these functions work. For the first one, <code>str(x.__class__)</code> will return something like <code>"&lt;class 'PyQt4.QtGui.QWidget'&gt;"</code>, so it's obviously never going to match. You need to use <code>x.__class__.__name__</code>, but even then, this won't match subclasses. For the second function, you need to use <code>str(x.objectName())</code>, otherwise it will never match anything. And note that both functions will only return the first object found, not a list of all matching objects (which is what the question asks for).</span>
<span class="comment-copy">The changes you made do not fix any of the problems.</span>
<span class="comment-copy">This is a good approach but it doesn't work for me: <a href="http://i.imgur.com/HreomDd.png" rel="nofollow noreferrer">i.imgur.com/HreomDd.png</a></span>
<span class="comment-copy">@Bluscream. Why would you expect it to work if you don't create any <code>QObject</code> instances? You obviously have to run it in the same python interpreter where the objects were created.</span>
<span class="comment-copy">But i want to search for existing objects, not the ones i've created, obviously...</span>
<span class="comment-copy">@Bluscream. It makes no difference <b>who</b> created them. The objects either exist in the current python interpreter session, or they don't. If you want to know exactly which objects currently exist, just do <code>import gc; for x in gc.get_objects(): print(repr(x))</code> (warning: it could be a very long list).</span>
<span class="comment-copy">@Bluscream. It all works perfectly fine for me. I guess your application must be buggy somehow, or perhaps some third party library you are using is buggy.</span>
<span class="comment-copy">I thought of some selector like if you want to search the dom in jquery <code>$('someElement')</code></span>
<span class="comment-copy">@Bluscream Yes. So? I thought of all sorts of things. Do you have a question, or a comment on this answer? Saying that you thought of something random doesn't help.</span>
<span class="comment-copy">If you think you need a global object search, you're doing it wrong. Keep track of the objects you need: you have the best resources to do a good job. The framework will help you, but it won't do it for you since its design can't foresee your circumstances.</span>
<span class="comment-copy">I'm doing nothing wrong, javascript has a global ui search, too which is something everyone uses quite often.</span>
<span class="comment-copy">@Bluscream Qt has it too. For the Ui objects - i.e. <code>QWidget</code>s. And that's all that you can have, because only widgets live on one thread so searching all of them makes sense. From that thread.</span>
