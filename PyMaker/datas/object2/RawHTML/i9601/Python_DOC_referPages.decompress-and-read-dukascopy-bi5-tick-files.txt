<div class="post-text" itemprop="text">
<p>I need to open a <code>.bi5</code> file and read the contents to cut a long story short. The problem: I have tens of thousands of <code>.bi5</code> files containing time-series data that I need to decompress and process (read, dump into pandas).</p>
<p>I ended up installing Python 3 (I use 2.7 normally) specifically for the <code>lzma</code> library, as I ran into compiling nightmares using the <code>lzma</code> back-ports for Python 2.7, so I conceded and ran with Python 3, but with no success. The problems are too numerous to divulge, no one reads long questions!</p>
<p>I have included one of the <code>.bi5</code> files, if someone could manage to get it into a Pandas Dataframe and show me how they did it, that would be ideal.</p>
<p>ps the fie is only a few kb, it will download in a second. Thanks very much in advance. </p>
<p>(The file)
<a href="http://www.filedropper.com/13hticks" rel="nofollow noreferrer">http://www.filedropper.com/13hticks</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The code below should do the trick. First, it opens a file and decodes it in <a href="https://docs.python.org/3/library/lzma.html" rel="noreferrer">lzma</a> and then uses <a href="https://docs.python.org/3/library/struct.html" rel="noreferrer">struct</a> to unpack the binary data.</p>
<pre><code>import lzma
import struct
import pandas as pd


def bi5_to_df(filename, fmt):
    chunk_size = struct.calcsize(fmt)
    data = []
    with lzma.open(filename) as f:
        while True:
            chunk = f.read(chunk_size)
            if chunk:
                data.append(struct.unpack(fmt, chunk))
            else:
                break
    df = pd.DataFrame(data)
    return df
</code></pre>
<p>The most important thing is to know the right format. I googled around and tried to guess and <code>'&gt;3i2f'</code> (or <code>&gt;3I2f</code>) works quite good. (It's big endian 3 ints 2 floats. What you suggest: <code>'i4f'</code> doesn't produce sensible floats - regardless whether big or little endian.) For <code>struct</code> and format syntax see the <a href="https://docs.python.org/3/library/struct.html" rel="noreferrer">docs</a>.</p>
<pre><code>df = bi5_to_df('13h_ticks.bi5', '&gt;3i2f')
df.head()
Out[177]: 
      0       1       2     3     4
0   210  110218  110216  1.87  1.12
1   362  110219  110216  1.00  5.85
2   875  110220  110217  1.00  1.12
3  1408  110220  110218  1.50  1.00
4  1884  110221  110219  3.94  1.00
</code></pre>
<hr/>
<p><strong>Update</strong></p>
<p>To compare the output of <code>bi5_to_df</code> with <a href="https://github.com/ninety47/dukascopy" rel="noreferrer">https://github.com/ninety47/dukascopy</a>,
I compiled and run <code>test_read_bi5</code> from there. The first lines of the output are:</p>
<pre><code>time, bid, bid_vol, ask, ask_vol
2012-Dec-03 01:00:03.581000, 131.945, 1.5, 131.966, 1.5
2012-Dec-03 01:00:05.142000, 131.943, 1.5, 131.964, 1.5
2012-Dec-03 01:00:05.202000, 131.943, 1.5, 131.964, 2.25
2012-Dec-03 01:00:05.321000, 131.944, 1.5, 131.964, 1.5
2012-Dec-03 01:00:05.441000, 131.944, 1.5, 131.964, 1.5
</code></pre>
<p>And <code>bi5_to_df</code> on the same input file gives:</p>
<pre><code>bi5_to_df('01h_ticks.bi5', '&gt;3I2f').head()
Out[295]: 
      0       1       2     3    4
0  3581  131966  131945  1.50  1.5
1  5142  131964  131943  1.50  1.5
2  5202  131964  131943  2.25  1.5
3  5321  131964  131944  1.50  1.5
4  5441  131964  131944  1.50  1.5
</code></pre>
<p>So everything seems to be fine (ninety47's code reorders columns).</p>
<p>Also, it's probably more accurate to use <code>'&gt;3I2f'</code> instead of <code>'&gt;3i2f'</code> (i.e. <code>unsigned int</code> instead of <code>int</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>Did you try using numpy as to parse the data before transfer it to pandas. Maybe is a long way solution, but I will allow you to manipulate and clean the data before you made the analysis in Panda, also the integration between them are pretty straight forward, </p>
</div>
<span class="comment-copy">Do you know the format of the original data? Is it for example: (int, int, int, float, float) in each line?</span>
<span class="comment-copy">32-bit integer: milliseconds since epoch, 32-bit float: Ask price, 32-bit float: Bid price, 32-bit float: Ask volume, 32-bit float: Bid volume. There is a C++ library out there specifically for this task, but I need to work from Python. You can look at it here <a href="https://github.com/ninety47/dukascopy" rel="nofollow noreferrer">github.com/ninety47/dukascopy</a></span>
<span class="comment-copy">Python 2.7 that is.</span>
<span class="comment-copy">It looks plausible ptrj. The 1st column is supposed to be a timestamp, but if you are correct, and that is a true representation of the data I will have to take the initial timestamp from the dated folder structure and add to it (long story). I will check it out tomorrow just to be sure, but it looks like you banked the bounty. Speak soon.</span>
<span class="comment-copy">The first columns is "miliseconds since epoch". If you run <code>pd.TimedeltaIndex(df[0], 'ms')</code>, you'll see that it covers 1 hour. To get the timestamps, do for example <code>ts + pd.TimedeltaIndex(df[0], 'ms')</code> where <code>ts</code> is your timestamp.</span>
<span class="comment-copy">the first two columns are supposed to be floats though. It's the price of a currency (EURUSD). Would there be any chance that it has been compressed this way, to save space perhaps?</span>
<span class="comment-copy">When I say the first two columns, I mean the first two columns after the milliseconds, so that would be the second and third to be clear. Or <code>1</code> and <code>2</code> this case.</span>
<span class="comment-copy">@RaduS Not sure what you mean. You can simply divide the numbers in both columns by 100, for example <code>df.iloc[:, [1, 2]] = df.iloc[:, [1, 2]] / 100</code>. For this currency pair the factor is 100. It can be different for another pair - it's not encoded in the input file - you have ot know it.</span>
