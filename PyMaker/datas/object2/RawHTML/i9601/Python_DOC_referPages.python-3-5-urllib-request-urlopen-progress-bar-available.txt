<div class="post-text" itemprop="text">
<p>I'm trying to search the world wide web for this answer, but I feel there answer may be no. I'm using Python 3.5 and a library called <code>urllib.request</code> with a method called <code>urllib.request.urlopen(url)</code> to open a link and download a file. </p>
<p>It would be nice to have some kind of measure of progress for this, as the file(s) are over 200MB. I'm looking at the API <a href="https://docs.python.org/3/library/urllib.request.html?highlight=urllib.request.urlopen#urllib.request.urlopen" rel="nofollow noreferrer">here</a>, and don't see any kind of parameter with a hook. </p>
<p>Here's my code: </p>
<pre><code>downloadURL = results[3] #got this from code earlier up
rel_path = account + '/' + eventID + '_' + title + '.mp4'

filename_abs_path = os.path.join(script_dir, rel_path)
print('&gt;&gt;&gt; Downloading &gt;&gt;&gt; ' + title)

# Download .mp4 from a url and save it locally under `file_name`:
with urllib.request.urlopen(downloadURL) as response, open(filename_abs_path, 'wb') as out_file:
    shutil.copyfileobj(response, out_file)
</code></pre>
<p>Can anyone provide insight if they think I can potentially have a progress bar or would the only way be to use a different library? I'm looking to keep the code quite short and simple, I just need some indication of the file being downloaded. Thanks for any help provided!</p>
</div>
<div class="post-text" itemprop="text">
<p>If the response includes a <code>content-length</code> you can read the incoming data in blocks and calculate percent done. Unfortunately, web servers that "chunk" responses don't always provide a content length, so it doesn't always work. Here is an example to test.</p>
<pre><code>import urllib.request
import sys
import io

try:
    url = sys.argv[1]
except IndexError:
    print("usage: test.py url")
    exit(2)

resp = urllib.request.urlopen(url)
length = resp.getheader('content-length')
if length:
    length = int(length)
    blocksize = max(4096, length//100)
else:
    blocksize = 1000000 # just made something up

print(length, blocksize)

buf = io.BytesIO()
size = 0
while True:
    buf1 = resp.read(blocksize)
    if not buf1:
        break
    buf.write(buf1)
    size += len(buf1)
    if length:
        print('{:.2f}\r done'.format(size/length), end='')
print()
</code></pre>
</div>
<span class="comment-copy">This doesn't really pertain to <code>urllib</code>, does it? Rather the problem is that <code>copyfileobj()</code> doesn't provide a progress callback. So <a href="http://stackoverflow.com/questions/29967487/get-progress-back-from-shutil-file-copy-thread">dup</a>?</span>
<span class="comment-copy">I would recommend switching to <a href="http://docs.python-requests.org/" rel="nofollow noreferrer">python requests</a></span>
<span class="comment-copy">In order to build a progress bar, you need to know the total size of the data you're about to download and the current size of its downloaded portion. The first one can be retrieved from the <code>Content-Length</code> header. You can calculate the second one by  <code>read</code>ing hunks of data of a specified size and computing sums of the chunks' lengths. The <code>requests</code> library lets you <code>read</code> chunks of data from a connection.</span>
<span class="comment-copy">Hey, thanks for the response. I tried this in a separate file and the error I'm getting is line 24 <code>TypeError: 'float' object is not iterable</code>.</span>
<span class="comment-copy">I should have done floor division. I've changed the example to <code>blocksize = max(4096, length//100)</code>. (I only tested with a small file!)</span>
<span class="comment-copy">Wonderful, that code is working. Do you know how I can apply it to my download? Would I tweak it and put it under the <code>with urllib.request.urlopen</code>?</span>
<span class="comment-copy">Yes, it replaces the <code>shutil</code> stuff.</span>
<span class="comment-copy">Great, this seems to work now! As a final question, is it possible to instead of print on a new line the new percentage, update the same line? If not, it's okay, I'm very grateful for your help and time.</span>
