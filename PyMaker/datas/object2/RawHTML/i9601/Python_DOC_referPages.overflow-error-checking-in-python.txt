<div class="post-text" itemprop="text">
<pre><code>import math
    if n &lt; 0:
        raise ValueError("n must be &gt;= 0")
    if math.floor(n) != n:
        raise ValueError("n must be exact integer")
    if n+1 == n:  # catch a value like 1e300
        raise OverflowError("n too large")
    result =1;
    factor =2;

    while factor &lt;=n:
        result *= factor
        factor += 1

    return result
</code></pre>
<p>This is a factorial function. I don't understand "if n+1 == n:", then it indicates a 'too large integer' exception. Why is it that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has a limit to the size of a number that it can use. Conceptually, if Python's max number is 10,000 and you enter in the number 10,001, Python will truncate that number to 10,000, thus <code>num == num+1</code>.</p>
<p>Here's a better answer for more details: <a href="https://stackoverflow.com/questions/3477283/what-is-the-maximum-float-in-python">What is the maximum float in Python?</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>First off, I don't know why this program exists, because python has no limit to the highest integer (<a href="https://docs.python.org/3/library/stdtypes.html#typesnumeric" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#typesnumeric</a>). However, as the previous person says, this guards against truncation, with values like "1e300" where the difference between 10^300 and 10^300 + 1 is so small relatively that it ignores small values.</p>
</div>
<span class="comment-copy">The <code>float</code> type has a precision problem.  Python <code>int</code> does not.  <code>1e16==1e16+1</code> is <code>True</code> due to the loss of precision, but <code>10000000000000000==10000000000000001</code> is True, even though they visually are the same.  Python integers are only limited by available memory.  Better to check that the user entered an integer and not a float.</span>
<span class="comment-copy">That truncation is a smart way to indicate a too large number. Java doesn't work this way.</span>
