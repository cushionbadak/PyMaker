<div class="post-text" itemprop="text">
<p>I have few blocking functions <code>foo</code>, <code>bar</code> and I can't change those (Some internal library I don't control. Talks to one or more network services). How do I use it as async?. E.g. I wan't to do the following.</p>
<pre><code>results = []
for inp in inps:
    val = foo(inp)
    result = bar(val)
    results.append(result)
</code></pre>
<p>This will be inefficient as I can call <code>foo</code> for the second input while I am waiting for the first and same for <code>bar</code>. How do I wrap them such that they are usable with asyncio (i.e new <code>async</code>, <code>await</code> syntax)?</p>
<p>Lets assume the functions are re-entrant. i.e it is fine to call <code>foo</code> again when already a previous <code>foo</code> is processing.</p>
<hr/>
<p><strong>Update</strong></p>
<p>Extending answer with reusable decorator. Click <a href="https://stackoverflow.com/a/53719009/">here</a> for example.</p>
<pre><code>def run_in_executor(f):
    @functools.wraps(f)
    def inner(*args, **kwargs):
        loop = asyncio.get_running_loop()
        return loop.run_in_executor(None, functools.partial(f, *args, **kwargs))

    return inner
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are (sort of) two questions here: first, how to run blocking code asynchronously, and second, how to run async code in parallel (asyncio is single-threaded, so the GIL still applies, so it isn't <em>truly</em> concurrent, but I digress).</p>
<p>Parallel tasks can be created using asyncio.ensure_future, as documented <a href="https://docs.python.org/3/library/asyncio-task.html#example-parallel-execution-of-tasks" rel="noreferrer">here</a>.</p>
<p>To run synchronous code, you will need to <a href="https://docs.python.org/3/library/asyncio-eventloop.html#executor" rel="noreferrer">run the blocking code in an executor</a>. Example:</p>
<pre><code>import concurrent.futures
import asyncio
import time

def blocking(delay):
    time.sleep(delay)
    print('Completed.')

async def non_blocking(loop, executor):
    # Run three of the blocking tasks concurrently. asyncio.wait will
    # automatically wrap these in Tasks. If you want explicit access
    # to the tasks themselves, use asyncio.ensure_future, or add a
    # "done, pending = asyncio.wait..." assignment
    await asyncio.wait(
        fs={
            # Returns after delay=12 seconds
            loop.run_in_executor(executor, blocking, 12),

            # Returns after delay=14 seconds
            loop.run_in_executor(executor, blocking, 14),

            # Returns after delay=16 seconds
            loop.run_in_executor(executor, blocking, 16)
        },
        return_when=asyncio.ALL_COMPLETED
    )

loop = asyncio.get_event_loop()
executor = concurrent.futures.ThreadPoolExecutor(max_workers=5)
loop.run_until_complete(non_blocking(loop, executor))
</code></pre>
<p>If you want to schedule these tasks using a for loop (as in your example), you have several different strategies, but the underlying approach is to <em>schedule</em> the tasks using the for loop (or list comprehension, etc),  await them with asyncio.wait, and <em>then</em> retrieve the results. Example:</p>
<pre><code>done, pending = await asyncio.wait(
    fs=[loop.run_in_executor(executor, blocking_foo, *args) for args in inps],
    return_when=asyncio.ALL_COMPLETED
)

# Note that any errors raise during the above will be raised here; to
# handle errors you will need to call task.exception() and check if it
# is not None before calling task.result()
results = [task.result() for task in done]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Extending the accepted answer to actually solve the problem in question.</p>
<p>Note: Requires python 3.7+</p>
<pre><code>import functools

from urllib.request import urlopen
import asyncio


def legacy_blocking_function():  # You cannot change this function
    r = urlopen("https://example.com")
    return r.read().decode()


def run_in_executor(f):
    @functools.wraps(f)
    def inner(*args, **kwargs):
        loop = asyncio.get_running_loop()
        return loop.run_in_executor(None, lambda: f(*args, **kwargs))

    return inner


@run_in_executor
def foo(arg):  # Your wrapper for async use
    resp = legacy_blocking_function()
    return f"{arg}{len(resp)}"


@run_in_executor
def bar(arg):  # Another wrapper
    resp = legacy_blocking_function()
    return f"{len(resp)}{arg}"


async def process_input(inp):  # Modern async function (coroutine)
    res = await foo(inp)
    res = f"XXX{res}XXX"
    return await bar(res)


async def main():
    inputs = ["one", "two", "three"]
    input_tasks = [asyncio.create_task(process_input(inp)) for inp in inputs]
    print([await t for t in asyncio.as_completed(input_tasks)])
    # This doesn't work as expected :(
    # print([await t for t in asyncio.as_completed([process_input(inp) for inp in input_tasks])])


if __name__ == '__main__':
asyncio.run(main())
</code></pre>
<hr/>
<p>Click <a href="https://github.com/balkierode/assortedscripts/blob/master/python/blockex.py" rel="nofollow noreferrer">here</a> for up to date version of this example and to send pull requests.</p>
</div>
<span class="comment-copy">Have you tried looking at <a href="http://stackoverflow.com/documentation/python/1319/asyncio-module#t=201612091515207970271">StackOverflow Documentation on asyncio</a>? Go to Asynchronous Executors.</span>
<span class="comment-copy">stackoverflow documentation has been shutdown</span>
<span class="comment-copy">asyncio.ensure_future is not mandatory in this case as <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait" rel="nofollow noreferrer">asyncio.wait</a> will already wrap coroutines in Tasks.</span>
<span class="comment-copy">Good tip! Though for a less-toy example, ensure_future might still be useful for ex. cancellation (irrespective of pending, complete).</span>
