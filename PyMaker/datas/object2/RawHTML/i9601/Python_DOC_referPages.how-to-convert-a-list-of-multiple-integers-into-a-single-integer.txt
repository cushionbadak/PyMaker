<div class="post-text" itemprop="text">
<p>How do I convert a list in Python 3.5 such as: </p>
<pre><code>x=[1, 3, 5]
</code></pre>
<p>to an int of <code>135</code> (a whole int)?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have a list of <code>int</code>s and you want to join them together, you can use <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> with <a href="https://docs.python.org/3/library/functions.html#func-str" rel="nofollow noreferrer"><code>str</code></a> to convert them to strings, <code>join</code> them on the empty string and then cast back to <code>int</code>s with <a href="https://docs.python.org/3/library/functions.html#int" rel="nofollow noreferrer"><code>int</code></a>.</p>
<p>In code, this looks like this:</p>
<pre><code>r = int("".join(map(str, x)))
</code></pre>
<p>and <code>r</code> now has the wanted value of <code>135</code>.</p>
<p>This, of course, is a limited approach that comes with some conditions. It requires the list in question to contain nothing else but positive <code>int</code>s (as your sample) or strings representing <code>int</code>s, else the steps of conversion to string might fail or the joining of (negative) numbers will be clunky. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a more mathematical way that does not have to convert back and forth to string. Note that it will only work if 0 &lt;= i &lt;= 9.</p>
<pre><code>&gt;&gt;&gt; x = [1, 3, 5]
&gt;&gt;&gt; sum(d * 10**i for i, d in enumerate(x[::-1]))
135
</code></pre>
<p>The idea is to multiply each element in the list by its corresponding power of 10 and then to sum the result.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using only math (no conversions to or from strings), you can use the <code>reduce</code> function (<code>functools.reduce</code> in Python 3)</p>
<pre><code>b = reduce(lambda total, d: 10*total + d, x, 0)
</code></pre>
<p>This makes use of Horner's rule, which factors the polynomial representing the number to reduce the number of multiplications. For example,</p>
<pre><code>1357 = 1*10*10*10 + 3*10*10 + 5*10 + 7     # 6 multiplications
     = ((1*10 + 3)*10 + 5)*10 + 7          # 3 multiplications
</code></pre>
<p>As a result, this is faster than computing powers of 10 or creating a string and converting the result to an integer.</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('reduce(lambda t,d: 10*t+d, x, 0)', 'from functools import reduce; x=[1,3,5,7]')
0.7217515400843695
&gt;&gt;&gt; timeit.timeit('int("".join(map(str, [1,3,5,7])))')
1.425914661027491
&gt;&gt;&gt; timeit.timeit('sum(d * 10**i for i, d in enumerate(x[::-1]))', 'x=[1,3,5,7]')
1.897974518011324
</code></pre>
<hr/>
<p>In fairness, string conversion is faster once the number of digits gets larger.</p>
<pre><code>&gt;&gt;&gt; import timeit

# 30 digits
&gt;&gt;&gt; setup='from functools import reduce; x=[5, 2, 6, 8, 4, 6, 6, 4, 8, 0, 3, 1, 7, 6, 8, 2, 9, 9, 9, 5, 4, 5, 5, 4, 3, 6, 9, 2, 2, 1]' 
&gt;&gt;&gt; print(timeit.timeit('reduce(lambda t,d: 10*t+d, x, 0)', setup))
6.520374411018565
&gt;&gt;&gt; print(timeit.timeit('int("".join(map(str, x)))', setup))
6.797425839002244
&gt;&gt;&gt; print(timeit.timeit('sum(d * 10**i for i, d in enumerate(x[::-1]))', setup))
19.430233853985555

# 60 digits
&gt;&gt;&gt; setup='from functools import reduce; x=2*[5, 2, 6, 8, 4, 6, 6, 4, 8, 0, 3, 1, 7, 6, 8, 2, 9, 9, 9, 5, 4, 5, 5, 4, 3, 6, 9, 2, 2, 1]' 
&gt;&gt;&gt; print(timeit.timeit('reduce(lambda t,d: 10*t+d, x, 0)', setup))
13.648188541992567
&gt;&gt;&gt; print(timeit.timeit('int("".join(map(str, x)))', setup))
12.864593736943789
&gt;&gt;&gt; print(timeit.timeit('sum(d * 10**i for i, d in enumerate(x[::-1]))', setup))
44.141602706047706

# 120 digits!
&gt;&gt;&gt; setup='from functools import reduce; x=4*[5, 2, 6, 8, 4, 6, 6, 4, 8, 0, 3, 1, 7, 6, 8, 2, 9, 9, 9, 5, 4, 5, 5, 4, 3, 6, 9, 2, 2, 1]' 
&gt;&gt;&gt; print(timeit.timeit('reduce(lambda t,d: 10*t+d, x, 0)', setup))
28.364255172084086
&gt;&gt;&gt; print(timeit.timeit('int("".join(map(str, x)))', setup))
25.184791765059344
&gt;&gt;&gt; print(timeit.timeit('sum(d * 10**i for i, d in enumerate(x[::-1]))', setup))
99.88558598596137
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't like map you can always use a list comprehension:</p>
<pre><code>s = [str(i) for i in x]
r = int("".join(s))
</code></pre>
</div>
<span class="comment-copy">The title just says "integers" for the list elements. Which value should be returned for, say, <code>[-3,14,0,-163]</code>, ?</span>
<span class="comment-copy">Output: invalid literal for int() with base 10</span>
<span class="comment-copy">But your description says nothing about that list being invalid, nor about literals (list elements cannot be variables?), nor about base 10. (And it does say the output should be a single integer, not "invalid literal".)</span>
<span class="comment-copy">This is slower than computing the value numerically, but has the benefit of working for bases larger than 10.</span>
<span class="comment-copy">@chepner it will be faster with large numbers and your version is generally faster with smaller number (30 digit and less on my pc).</span>
<span class="comment-copy">Worth noting that this version will fail if the first integer is 0.</span>
<span class="comment-copy">@asmeurer the solution isn't meant to address all possible inputs, just the one OP provided. I'm actually failing to see how a <code>0</code> in the beginning would make it fail though (the <code>int</code> call will drop any leading zeros from the string while converting it).</span>
<span class="comment-copy">@asmeurer <code>int</code> doesn't try to infer the base from the string literal; it uses base 10 unless otherwise specified by the optional second argument.</span>
<span class="comment-copy">If you wanted it to be efficient, would've it be better to do <code>reversed(x)</code> rather than <code>x[::-1]</code>? The latter has to create an entirely new list, but the former just a generator.</span>
<span class="comment-copy">That wouldn't work with [1, 0, 'e', 3] !</span>
<span class="comment-copy">@LoïcFaure-Lacroix The OP specifically asks about an array of integers</span>
<span class="comment-copy">@brianpck yes, I know but generic is sometimes better than not. Btw, the timeit tests are a good way to test things. What the answer doesn't say that the reduce method will get worse with big numbers. It's good with smaller numbers but as soon as it will get numbers with a length of around 30 numbers, the str version will be the fastest solution.</span>
<span class="comment-copy">@LoïcFaure-Lacroix Good point, I tested the two numeric solutions with larger lists, but not the string conversion one. (I was curious about whether the overhead of user-defined functions would lose out, but I guess a linear number of function calls is still better than a quadratic number of multiplications.)</span>
<span class="comment-copy">Thumbs up! That's a quite complete answer! Your solution is probably the best one with integers and "real" world number unless it's used for cryptography.</span>
<span class="comment-copy">...and if you like list comprehensions you can always use a generator expression, and avoid one of the loops: <code>int("".join(str(i) for i in x))</code></span>
