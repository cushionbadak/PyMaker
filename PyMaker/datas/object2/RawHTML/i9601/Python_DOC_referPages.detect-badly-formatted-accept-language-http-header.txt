<div class="post-text" itemprop="text">
<p>I want to parse the <code>Accept-Language</code> header. All answers that I find deal with parsing the string but do not handle the case of a badly formatted input.</p>
<p>For example what if the user is sending this header <code>Accept-Language: en,es;q=0.5;*;q=0.5</code> which is badly formatted because of the second <code>;</code>. Is there any package that can offer easy parsing and appropriate exception raising? </p>
</div>
<div class="post-text" itemprop="text">
<p>First you should start by understanding the proper format of the <code>Accept-Language</code> header: <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4" rel="nofollow noreferrer">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4</a></p>
<p>You can see the definition of the <code>Accept-Language</code> header field is:</p>
<pre><code>Accept-Language = "Accept-Language" ":"
                  1#( language-range [ ";" "q" "=" qvalue ] )
       language-range  = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )
</code></pre>
<p>An example of the properly formatted header is: <code>Accept-Language: da, en-gb;q=0.8, en;q=0.7</code>. You can see that each comma <code>,</code> separates the language tuples, where each language tuple is <code>language-range</code> and <code>quality weight</code> (optional).</p>
<p>Now that you know how is the <code>Accept-Language</code> header defined, the only problem is how to parse it.</p>
<p>You can implement this in many ways depending on the language, but I will write a pseudo-code:</p>
<pre><code>function parseAcceptLanguageHeader(headerValue):
    parsedLanguages = []
    languageStrings = headerValue.split(",")
    foreach languageStrings as S do
        parsedLanguages.add(parse(S))
    return parsedLanguages


// Here we define parse(S)
function parse(S): // expecting format of S to be like: 'language-range [";q=&lt;number&gt;"]'
    vals = S.trim().split(";") // remove leading and trailing spaces and split by ;
    if vals.length == 1: // means 'q=qvalue' part is missing
      return vals[0].trim(), 1.0 // default q is 1.0; you can additionally verify that vals[0] is one of the languages that you support
    else if vals.length == 2:
      return vals[0].trim(), parseQuality(vals[1])
    else raise an error ("Expected two tokens but, got: " + S)


// Implement parse quality
function parseQuality(S):
  // We expect to see 'q=&lt;number&gt;'
  vals = q.split("=")
  if (vals.length != 2):
    raise an error ("Expected exactly two tokens for quality, but got: " + S)
  else if (vals[0] != 'q'):
    raise an error ("Expected quality (q) but got: " + S)
  else 
    return parseInt(vals[1].trim()) // This can also throw an error, but I am not going to write implementation for that function
</code></pre>
<p>Note that depending on the language dealing with errors is different.</p>
</div>
<span class="comment-copy">This certainly depends on what language do you use and what do you mean by "Parse" language. Do you just want to get tokens such as <code>en</code> and <code>es</code>? What do you want to do with <code>q=0.5</code>? Do you want to ignore it or throw an error?</span>
<span class="comment-copy">In the case of a badly formatted header I want to make the user aware, but to detect a badly formatted header I prefer to not hardcode rules myself</span>
<span class="comment-copy">Then the question is what does the "good" header looks like? Someone will have to define the rules for a properly formatted header and you could use that rule to parse the header. If at some point the header doesn't correspond to the rule, then it's badly formatted. <code>q=0.5</code> represents a weight and it should always appear after the language mnemonic. You could use that as a basic rule to follow</span>
<span class="comment-copy">I thought that the language should be followed by a <code>;</code> when there is explicit weight defined like that <code>en;q=0.4</code> and that the second language should be placed after a comma like that <code>en;q=0.4, de;q=0.1</code>, If you notice in the provided example there is a <code>;</code> before the asterisk, which I think is wrong. am I not correct on that? If I am then I think it's quite clear what I am looking for.</span>
<span class="comment-copy">Well, you can have a language range followed by <code>;</code> and then the weight.  You can see the definition here: <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4" rel="nofollow noreferrer">w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4</a> <code>Accept-Language = "Accept-Language" ":" 1#( language-range [ ";" "q" "=" qvalue ] )</code> and  then <code>language-range  = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )</code></span>
<span class="comment-copy">Sorry but the answer does not address my question at all. First I don't see why you assume that I wasn't aware of the proper format since my question does not indicate likewise and second all I am asking is if there is a package that can take care of the parsing of the header and in case it detects a badly formatted header it will let me know, what I want to avoid is implement the detection myself. Since as you also mentioned the format of a header is properly specified in the protocol there could be some kind of protocol validator that could do that job</span>
<span class="comment-copy">Ok, I see. I suppose you should be more explicit to avoid the confusion. Are you looking for a library in the specific language or that is not important to you?</span>
<span class="comment-copy">yes, I am looking for a python package, thnx for taking the time</span>
<span class="comment-copy">Sorry I can't help with that. I'm not a python expert. I've tried searching for some but the only two that I've found are: <a href="https://docs.python.org/3/library/wsgiref.html" rel="nofollow noreferrer">docs.python.org/3/library/wsgiref.html</a> and <a href="https://pypi.python.org/pypi/http-parser" rel="nofollow noreferrer">pypi.python.org/pypi/http-parser</a>, however I don't think they will do what you are asking for.</span>
<span class="comment-copy">very helpful answer, thanks</span>
