<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3462784/check-if-a-string-matches-an-ip-address-pattern-in-python">check if a string matches an IP address pattern in python?</a>
<span class="question-originals-answer-count">
                    18 answers
                </span>
</li>
</ul>
</div>
<p>What's the best way to validate that an IP entered by the user is valid?  It comes in as a string.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't parse it.  Just ask.</p>
<pre><code>import socket

try:
    socket.inet_aton(addr)
    # legal
except socket.error:
    # Not legal
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import socket

def is_valid_ipv4_address(address):
    try:
        socket.inet_pton(socket.AF_INET, address)
    except AttributeError:  # no inet_pton here, sorry
        try:
            socket.inet_aton(address)
        except socket.error:
            return False
        return address.count('.') == 3
    except socket.error:  # not a valid address
        return False

    return True

def is_valid_ipv6_address(address):
    try:
        socket.inet_pton(socket.AF_INET6, address)
    except socket.error:  # not a valid address
        return False
    return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://pypi.python.org/pypi/IPy/" rel="noreferrer">IPy module</a> (a module designed for dealing with IP addresses) will throw a ValueError exception for invalid addresses.</p>
<pre><code>&gt;&gt;&gt; from IPy import IP
&gt;&gt;&gt; IP('127.0.0.1')
IP('127.0.0.1')
&gt;&gt;&gt; IP('277.0.0.1')
Traceback (most recent call last):
 ...
ValueError: '277.0.0.1': single byte must be 0 &lt;= byte &lt; 256
&gt;&gt;&gt; IP('foobar')
Traceback (most recent call last):
 ...
ValueError: invalid literal for long() with base 10: 'foobar'
</code></pre>
<p>However, like Dustin's answer, it will accept things like "4" and "192.168" since, as mentioned, these are valid representations of IP addresses.</p>
<p>If you're using Python 3.3 or later, it now includes the <a href="http://docs.python.org/py3k/library/ipaddress.html" rel="noreferrer">ipaddress module</a>:</p>
<pre><code>&gt;&gt;&gt; import ipaddress
&gt;&gt;&gt; ipaddress.ip_address('127.0.0.1')
IPv4Address('127.0.0.1')
&gt;&gt;&gt; ipaddress.ip_address('277.0.0.1')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.3/ipaddress.py", line 54, in ip_address
    address)
ValueError: '277.0.0.1' does not appear to be an IPv4 or IPv6 address
&gt;&gt;&gt; ipaddress.ip_address('foobar')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.3/ipaddress.py", line 54, in ip_address
    address)
ValueError: 'foobar' does not appear to be an IPv4 or IPv6 address
</code></pre>
<p>For Python 2, you can get the same functionality using ipaddress if you install python-ipaddress:</p>
<pre><code>pip install ipaddress
</code></pre>
<p>This module is compatible with Python 2 and provides a very similar API to that of the ipaddress module included in the Python Standard Library since Python 3.3. More details <a href="https://github.com/HaDiNet/python-ipaddress/blob/master/README.md" rel="noreferrer">here</a>. In Python 2 you will need to explicitly convert the IP address string to unicode: <code>ipaddress.ip_address(u'127.0.0.1')</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def is_valid_ip(ip):
    """Validates IP addresses.
    """
    return is_valid_ipv4(ip) or is_valid_ipv6(ip)
</code></pre>
<p>IPv4:</p>
<pre><code>def is_valid_ipv4(ip):
    """Validates IPv4 addresses.
    """
    pattern = re.compile(r"""
        ^
        (?:
          # Dotted variants:
          (?:
            # Decimal 1-255 (no leading 0's)
            [3-9]\d?|2(?:5[0-5]|[0-4]?\d)?|1\d{0,2}
          |
            0x0*[0-9a-f]{1,2}  # Hexadecimal 0x0 - 0xFF (possible leading 0's)
          |
            0+[1-3]?[0-7]{0,2} # Octal 0 - 0377 (possible leading 0's)
          )
          (?:                  # Repeat 0-3 times, separated by a dot
            \.
            (?:
              [3-9]\d?|2(?:5[0-5]|[0-4]?\d)?|1\d{0,2}
            |
              0x0*[0-9a-f]{1,2}
            |
              0+[1-3]?[0-7]{0,2}
            )
          ){0,3}
        |
          0x0*[0-9a-f]{1,8}    # Hexadecimal notation, 0x0 - 0xffffffff
        |
          0+[0-3]?[0-7]{0,10}  # Octal notation, 0 - 037777777777
        |
          # Decimal notation, 1-4294967295:
          429496729[0-5]|42949672[0-8]\d|4294967[01]\d\d|429496[0-6]\d{3}|
          42949[0-5]\d{4}|4294[0-8]\d{5}|429[0-3]\d{6}|42[0-8]\d{7}|
          4[01]\d{8}|[1-3]\d{0,9}|[4-9]\d{0,8}
        )
        $
    """, re.VERBOSE | re.IGNORECASE)
    return pattern.match(ip) is not None
</code></pre>
<p>IPv6:</p>
<pre><code>def is_valid_ipv6(ip):
    """Validates IPv6 addresses.
    """
    pattern = re.compile(r"""
        ^
        \s*                         # Leading whitespace
        (?!.*::.*::)                # Only a single whildcard allowed
        (?:(?!:)|:(?=:))            # Colon iff it would be part of a wildcard
        (?:                         # Repeat 6 times:
            [0-9a-f]{0,4}           #   A group of at most four hexadecimal digits
            (?:(?&lt;=::)|(?&lt;!::):)    #   Colon unless preceeded by wildcard
        ){6}                        #
        (?:                         # Either
            [0-9a-f]{0,4}           #   Another group
            (?:(?&lt;=::)|(?&lt;!::):)    #   Colon unless preceeded by wildcard
            [0-9a-f]{0,4}           #   Last group
            (?: (?&lt;=::)             #   Colon iff preceeded by exacly one colon
             |  (?&lt;!:)              #
             |  (?&lt;=:) (?&lt;!::) :    #
             )                      # OR
         |                          #   A v4 address with NO leading zeros 
            (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]?\d)
            (?: \.
                (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]?\d)
            ){3}
        )
        \s*                         # Trailing whitespace
        $
    """, re.VERBOSE | re.IGNORECASE | re.DOTALL)
    return pattern.match(ip) is not None
</code></pre>
<p>The IPv6 version uses "<code>(?:(?&lt;=::)|(?&lt;!::):)</code>", which could be replaced with "<code>(?(?&lt;!::):)</code>" on regex engines that support conditionals with look-arounds. (i.e. PCRE, .NET)</p>
<p><strong>Edit:</strong></p>
<ul>
<li>Dropped the native variant.</li>
<li>Expanded the regex to comply with the RFC.</li>
<li>Added another regex for IPv6 addresses.</li>
</ul>
<p><strong>Edit2:</strong></p>
<p>I found some links discussing how to parse IPv6 addresses with regex:</p>
<ul>
<li><a href="http://forums.dartware.com/viewtopic.php?t=452" rel="noreferrer">A Regular Expression for IPv6 Addresses</a> - InterMapper Forums</li>
<li><a href="http://www.vankouteren.eu/blog/2009/05/working-ipv6-regular-expression/" rel="noreferrer">Working IPv6 regular expression</a> - Patrickâ€™s playground blog</li>
<li><a href="http://download.dartware.com/thirdparty/test-ipv6-regex.pl" rel="noreferrer">test-ipv6-regex.pl</a> - Perl script with tons of test-cases. It seems my regex fails on a few of those tests.</li>
</ul>
<p><strong>Edit3:</strong></p>
<p>Finally managed to write a pattern that passes all tests, and that I am also happy with.</p>
</div>
<div class="post-text" itemprop="text">
<p>From Python 3.4 on, the best way to check if an IPv6 or IPv4 address is correct, is to use the Python Standard Library module <code>ipaddress</code> - IPv4/IPv6 manipulation library s.a. <a href="https://docs.python.org/3/library/ipaddress.html" rel="noreferrer">https://docs.python.org/3/library/ipaddress.html</a> for complete documentation.</p>
<p>Example : 
</p>
<pre><code>#!/usr/bin/env python

import ipaddress
import sys

try:
    ip = ipaddress.ip_address(sys.argv[1])
    print('%s is a correct IP%s address.' % (ip, ip.version))
except ValueError:
    print('address/netmask is invalid: %s' % sys.argv[1])
except:
    print('Usage : %s  ip' % sys.argv[0])
</code></pre>
<p>For other versions: Github, phihag / Philipp Hagemeister,"Python 3.3's ipaddress for older Python versions", <a href="https://github.com/phihag/ipaddress" rel="noreferrer">https://github.com/phihag/ipaddress</a></p>
<p>The backport from phihag is available e.g. in Anaconda Python 2.7 &amp; is included in Installer. s.a. <a href="https://docs.continuum.io/anaconda/pkg-docs" rel="noreferrer">https://docs.continuum.io/anaconda/pkg-docs</a></p>
<p>To install with pip:</p>
<pre><code>pip install ipaddress
</code></pre>
<p>s.a.: ipaddress 1.0.17, "IPv4/IPv6 manipulation library", "Port of the 3.3+ ipaddress module", <a href="https://pypi.python.org/pypi/ipaddress/1.0.17" rel="noreferrer">https://pypi.python.org/pypi/ipaddress/1.0.17</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I hope it's simple and pythonic enough:</p>
<pre><code>def is_valid_ip(ip):
    m = re.match(r"^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$", ip)
    return bool(m) and all(map(lambda n: 0 &lt;= int(n) &lt;= 255, m.groups()))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think this would do it...</p>
<pre><code>def validIP(address):
    parts = address.split(".")
    if len(parts) != 4:
        return False
    for item in parts:
        if not 0 &lt;= int(item) &lt;= 255:
            return False
    return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have to give a great deal of credit to Markus Jarderot for his post - the majority of my post is inspired from his.</p>
<p>I found that Markus' answer still fails some of the IPv6 examples in the Perl script referenced by his answer.</p>
<p>Here is my regex that passes all of the examples in that Perl script:</p>
<pre><code>r"""^
     \s* # Leading whitespace
     # Zero-width lookaheads to reject too many quartets
     (?:
        # 6 quartets, ending IPv4 address; no wildcards
        (?:[0-9a-f]{1,4}(?::(?!:))){6}
             (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)
        (?:\.(?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}
      |
        # 0-5 quartets, wildcard, ending IPv4 address
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,4}[0-9a-f]{1,4})?
        (?:::(?!:))
             (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)
        (?:\.(?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}
      |
        # 0-4 quartets, wildcard, 0-1 quartets, ending IPv4 address
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,3}[0-9a-f]{1,4})?
        (?:::(?!:))
        (?:[0-9a-f]{1,4}(?::(?!:)))?
             (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)
        (?:\.(?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}
      |
        # 0-3 quartets, wildcard, 0-2 quartets, ending IPv4 address
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,2}[0-9a-f]{1,4})?
        (?:::(?!:))
        (?:[0-9a-f]{1,4}(?::(?!:))){0,2}
             (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)
        (?:\.(?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}
      |
        # 0-2 quartets, wildcard, 0-3 quartets, ending IPv4 address
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,1}[0-9a-f]{1,4})?
        (?:::(?!:))
        (?:[0-9a-f]{1,4}(?::(?!:))){0,3}
             (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)
        (?:\.(?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}
      |
        # 0-1 quartets, wildcard, 0-4 quartets, ending IPv4 address
        (?:[0-9a-f]{1,4}){0,1}
        (?:::(?!:))
        (?:[0-9a-f]{1,4}(?::(?!:))){0,4}
             (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)
        (?:\.(?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}
      |
        # wildcard, 0-5 quartets, ending IPv4 address
        (?:::(?!:))
        (?:[0-9a-f]{1,4}(?::(?!:))){0,5}
             (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)
        (?:\.(?:25[0-4]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}
      |
        # 8 quartets; no wildcards
        (?:[0-9a-f]{1,4}(?::(?!:))){7}[0-9a-f]{1,4}
      |
        # 0-7 quartets, wildcard
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,6}[0-9a-f]{1,4})?
        (?:::(?!:))
      |
        # 0-6 quartets, wildcard, 0-1 quartets
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,5}[0-9a-f]{1,4})?
        (?:::(?!:))
        (?:[0-9a-f]{1,4})?
      |
        # 0-5 quartets, wildcard, 0-2 quartets
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,4}[0-9a-f]{1,4})?
        (?:::(?!:))
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,1}[0-9a-f]{1,4})?
      |
        # 0-4 quartets, wildcard, 0-3 quartets
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,3}[0-9a-f]{1,4})?
        (?:::(?!:))
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,2}[0-9a-f]{1,4})?
      |
        # 0-3 quartets, wildcard, 0-4 quartets
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,2}[0-9a-f]{1,4})?
        (?:::(?!:))
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,3}[0-9a-f]{1,4})?
      |
        # 0-2 quartets, wildcard, 0-5 quartets
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,1}[0-9a-f]{1,4})?
        (?:::(?!:))
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,4}[0-9a-f]{1,4})?
      |
        # 0-1 quartets, wildcard, 0-6 quartets
        (?:[0-9a-f]{1,4})?
        (?:::(?!:))
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,5}[0-9a-f]{1,4})?
      |
        # wildcard, 0-7 quartets
        (?:::(?!:))
        (?:(?:[0-9a-f]{1,4}(?::(?!:))){0,6}[0-9a-f]{1,4})?
     )
     (?:/(?:1(?:2[0-7]|[01]\d)|\d\d?))? # With an optional CIDR routing prefix (0-128)
     \s* # Trailing whitespace
    $"""
</code></pre>
<p>I also put together a Python script to test all of those IPv6 examples; it's <a href="http://pastebin.com/TKLfQUG0" rel="noreferrer">here on Pastebin</a> because it was too large to post here.</p>
<p>You can run the script with test result and example arguments in the form of "[result]=[example]", so like:</p>
<pre><code>python script.py Fail=::1.2.3.4: pass=::127.0.0.1 false=::: True=::1
</code></pre>
<p>or you can simply run all of the tests by specifying no arguments, so like:</p>
<pre><code>python script.py
</code></pre>
<p>Anyway, I hope this helps somebody else!</p>
</div>
<div class="post-text" itemprop="text">
<p>I came up with this noob simple version </p>
<pre><code>def ip_checkv4(ip):
        parts=ip.split(".")
        if len(parts)&lt;4 or len(parts)&gt;4:
            return "invalid IP length should be 4 not greater or less than 4"
        else:
            while len(parts)== 4:
                a=int(parts[0])
                b=int(parts[1])
                c=int(parts[2])
                d=int(parts[3])
                if a&lt;= 0 or a == 127 :
                    return "invalid IP address"
                elif d == 0:
                    return "host id  should not be 0 or less than zero " 
                elif a&gt;=255:
                    return "should not be 255 or greater than 255 or less than 0 A"
                elif b&gt;=255 or b&lt;0: 
                    return "should not be 255 or greater than 255 or less than 0 B"
                elif c&gt;=255 or c&lt;0:
                    return "should not be 255 or greater than 255 or less than 0 C"
                elif d&gt;=255 or c&lt;0:
                    return "should not be 255 or greater than 255 or less than 0 D"
                else:
                    return "Valid IP address ", ip

    p=raw_input("Enter IP address")
    print ip_checkv4(p)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Consider IPv4 address as "ip".</p>
<pre><code>if re.match(r'^((\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])$', ip):  
    print "Valid IP"  
else:
    print "Invalid IP"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I only needed to parse IP v4 addresses. My solution based on Chills strategy follows:</p>
<pre>
def getIP():<br/>
    valid = False<br/>
    while not valid :<br/>
        octets = raw_input( "Remote Machine IP Address:" ).strip().split(".")<br/>
        try: valid=len( filter( lambda(item):0&lt;=int(item)&lt;256, octets) ) == 4<br/>
        except: valid = False<br/>
    return ".".join( octets )<br/>
</pre>
</div>
<span class="comment-copy">I just want to point out that if a broadcast address is not considered a valid address, then every single one of the solutions suggested so far fail. You have to test against a subnet mask to see if it is a broadcast address.</span>
<span class="comment-copy">Hmm, seems to accept things like "4" and "192.168" and silently pads the rest with zeros.  Technically valid, I'm sure, but not quite what I expected.</span>
<span class="comment-copy">No, does not work with all legal IP addresses:      &gt;&gt;&gt; socket.inet_aton("2001:660::1")       Traceback (most recent call last):         File "&lt;stdin&gt;", line 1, in &lt;module&gt;      socket.error: illegal IP address string passed to inet_aton</span>
<span class="comment-copy">@bortzmeyer: socket.inet_pton(socket_family, address) is what you want if you want to support ip6. You still need to specify the family. inet_aton specifically does not support anything but ip4.</span>
<span class="comment-copy">It looks like Richo's response solves krupan and bortzmeyer's questions. Use socket.inet_pton with socket.AF_INET or socket.AF_INET6 as family to validate ipv4 and ipv6 without incomplete addresses being accepted.</span>
<span class="comment-copy">inet_aton() isn't accepting "invalid" IPs when it accepts "4", "192.168" and "127.1", it is merely using the underlying C behaviour - see the documentation. 127.1 puts 127 in the top octet and parses the 1 as a 24-bit number that it splits across the remaining three octets. The idea is to support /16 ranges that increment IPs, so you can go 172.16.1...172.16.255 and then 172.16.256, rather than having alter your maths to go to 172.16.1.0.</span>
<span class="comment-copy">Why the line: "return address.count('.') == 3" ??  Is that left over from your debugging?</span>
<span class="comment-copy">@quux: no. It's a long discussion, and people don't like the fact that at least on Linux and Windows shortened addresses are considered acceptable. For example, <code>socket.inet_aton('127.1')</code> evaluates to <code>'\x7f\x00\x00\x01'</code> (i.e. exactly like '127.0.0.1' does). I've had this tiresome and lengthy discussion elsewhere on SO, can't bother to remember where, though.</span>
<span class="comment-copy">Thanks. I didn't know that!</span>
<span class="comment-copy">How about on windows?</span>
<span class="comment-copy">Note that this is a unix-only answer</span>
<span class="comment-copy">Excellent idea. The only solution presented until now which works with all IP addresses.  &gt;&gt;&gt; from IPy import IP &gt;&gt;&gt; IP("2001:660::1") IP('2001:660::1')</span>
<span class="comment-copy">For python 2, pip install ipaddress  and you get almost the same API :)</span>
<span class="comment-copy">Regarding <code>import ipaddress</code>, when I passed an IPv4 address, I got output like <code>IPv4Address('127.0.0.1')</code>. But when I tried to convert it to <code>string</code> to check if it contains <code>IPv4</code> or <code>IPv6</code>, I just got the IP. How can I know in code if it is a <code>IPv4</code> or <code>IPv6</code>? Is <code>if "IPv4" in str(type(val)):</code> a good idea?</span>
<span class="comment-copy">Use the exact same steps and got <code>ipaddress.AddressValueError: '127.0.0.1'  does not appear to be a n IPv4 or IPv6 address. Did you pass in a bytes (str in Python 2) instead of a unicode object?</code>. The help presented in the error message helped me fix the issue. You need <code>u'...'</code> in Python 2.</span>
<span class="comment-copy">No, works only with IPv4 addresses.</span>
<span class="comment-copy">test-ipv6-regex.pl is gold +1</span>
<span class="comment-copy">I suggest you edit your answer specifying the version(s) of Python that this module is included in the stdlib.</span>
<span class="comment-copy">@tzot someone should fork Python 2.x and all sorts of nice stuff to it from 3.x libraries and even core. IMHO.</span>
<span class="comment-copy">I'm getting this error  <code>C:\Python\Codes&gt;check_ip.py   File "C:\Python\Codes\check_ip.py", line 8     print '%s is a correct IP%s address.' % (ip, ip.version)                                         ^ SyntaxError: invalid syntax  C:\Python\Codes&gt;</code></span>
<span class="comment-copy">Thanks @Yohann. For Python 3.5, parenthesis is required on print. Else, the code will produce an error.  Since this space is limited, I'll update the code on answer section below. Hope this will helps others too.</span>
<span class="comment-copy">you are repiting the same pattern 3 times...</span>
<span class="comment-copy">;-) ^(\d{1,3}\.){3}\d{1,3}$</span>
<span class="comment-copy">You may want to catch the ValueError exception from int() in case the user types "a.b.c.d" and not integers.</span>
<span class="comment-copy">Wrong code, works only with IPv4 addresses.</span>
<span class="comment-copy">Python's int() coercion is too lax here; for example, it strips spaces.</span>
<span class="comment-copy"><code>192.168.178.0030</code> would be valid.</span>
<span class="comment-copy">doesn't work for ipv6.</span>
<span class="comment-copy">+1 for effort :)</span>
<span class="comment-copy">Although I admire your effort as well, I think there's a huge design flaw in your construct: It's way too big! I would never trust a regex of this size that was not used by thousands of people for years.</span>
<span class="comment-copy">@erikb85: Take a look at the script I posted to Pastebin. It contains 1154 tests of different IPv6 formats, and it passes <b>every single one</b> of them. If you think more tests are necessary, feel free to modify my script, add tests, and post the results.</span>
