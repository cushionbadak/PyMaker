<div class="post-text" itemprop="text">
<p>I have an abstract class <code>ship</code>.  </p>
<pre><code>from abc import ABC, abstractmethod
class ship(ABC):
    def __init__(self):
         ...

    @abstractmethod
    def do_stuff(self,stuff,things):
         pass
</code></pre>
<p>I have multiple classes that inherit from it (<code>destroyer</code>,<code>cruiser</code>,<code>patrol_boat</code>, etc...) </p>
<pre><code>class carrier(ship):
    def __init__(self):
         ....
    def do_stuff(self,stuff,things):
         ....
</code></pre>
<p>Currently, if I were to add, let's say <code>def do_more_stuff(self):</code> to <code>ship</code></p>
<pre><code>class ship(ABC):
    def __init__(self):
         ...

    @abstractmethod
    def do_stuff(self,stuff,things):
         pass

    @abstractmethod
    def do_more_stuff(self,stuff,things):
        pass
</code></pre>
<p>The changes would not affect any of the subclasses until I reentered them into the console.  How do I change this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you actually redefine a class from scratch, it's a different class; the subclasses are still inheriting from the old version of <code>ship</code>. You can't just define a new class named <code>ship</code> and expect the subclasses to find it magically.</p>
<p>Normally, if you wanted to monkey-patch <code>ship</code> after creation to add new methods, you could just do something like:</p>
<pre><code>def do_more_stuff(self,stuff,things):
    pass
ship.do_more_stuff = do_more_stuff
</code></pre>
<p>But unfortunately, <code>abstractmethod</code>s for <code>ABC</code>s <a href="https://docs.python.org/3/library/abc.html#abc.abstractmethod" rel="nofollow noreferrer">are an explicit exception to this rule</a>:</p>
<blockquote>
<p>Dynamically adding abstract methods to a class, or attempting to modify the abstraction status of a method or class once it is created, are not supported.</p>
</blockquote>
<p>You must either define the abstract base class completely up front, or redefine the entire class hierarchy later if you want to add new abstract methods to the base class.</p>
</div>
<span class="comment-copy">You need to give enough code to show what you actually did (<a href="https://stackoverflow.com/help/MCVE">MVCE</a>). Editing the super <i>class</i> to add new methods should work (it's mildly inefficient to do so after the subclasses are defined, but not unreasonably so), but I suspect you're mistakenly editing <i>instances</i>, or not editing the class at all.</span>
<span class="comment-copy">I feel like I'm redefining <code>ship</code> while leaving the remaining classes to inherit from the previous definition of <code>ship</code>.  How could I add functions to <code>ship</code> without reentering the entire block?</span>
<span class="comment-copy">You're correct about redefining the whole class not changing what the subclasses inherit from. My answer covers the details here; there is a way that works for non-abstract methods, but abstract methods cannot use this technique.</span>
<span class="comment-copy">Could I add regular methods to the base abstract class without encountering this problem?</span>
<span class="comment-copy">@David: That should not cause problems. The magic is involved with the combination of the <code>ABCMeta</code> metaclass and the <code>abstractmethod</code> descriptor magic; the metaclass hooks are invoked at the moment you end the class definition block (thus the requirement to define all abstract methods with the class), and <code>ABCMeta</code> is specifically concerned with <code>abstractmethod</code>, not regular methods.  As long as you don't try to replace existing abstract methods or add new ones, it should work just fine; new concrete methods can't change the rules for abstract inheritance.</span>
