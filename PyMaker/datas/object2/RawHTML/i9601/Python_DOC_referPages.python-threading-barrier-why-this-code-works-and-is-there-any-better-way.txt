<div class="post-text" itemprop="text">
<p>I have searched for python barrier but there is very few related issues. I am still confused about barrier.wait(), even my code works. </p>
<p>I utilize python barrier to implement such a function: A main thread and n sub-threads. In each round, the main thread waits for all the sub-threads finishing their current work, and then all the threads go to the next round until some condition we meet. Thus, I found that barrier is proper to implement this function, here is my code for main thread.</p>
<pre><code> def superstep(self):
    workers = []
    barrier = threading.Barrier(self.num_workers+1)
    for vertex in self.vertices:
        worker = Worker(vertex, barrier)
        workers.append(worker)
        worker.start()

    while self.flag:
        barrier.wait()
        self.distributeMessages()
        self.count += 1
        print ("superstep: ", self.count)
        self.flag = self.isTerminated()

    for worker in workers:
        worker.flag = False

    for worker in workers:
        worker.join()
</code></pre>
<ol>
<li>the first 'for' loop creates n threads named worker and stored in a list workers.</li>
<li>the 'while' loop is the main thread that waits for other sub-threads, and breaks when self.flag is False.</li>
<li>the second 'for' loop used for setting flag to False in each worker(sub-threads), telling them to exit loop.</li>
</ol>
<p>here is my Worker class.</p>
<pre><code>class Worker(threading.Thread):
    def __init__(self, vertex, barrier):
        threading.Thread.__init__(self)
        self.vertex = vertex
        self.flag = True
        self.barrier = barrier

    def run(self):
        while self.flag:
            self.barrier.wait()
            do something
</code></pre>
<p>The code works well, all the threads can join(). But as I looked at <a href="https://docs.python.org/3/library/threading.html#barrier-objects" rel="nofollow noreferrer">python barrier</a>, all the threads will release simultaneously when all the threads call wait(). What if the main threads breaks from its while loop and all the other threads are waiting for it just right, in this case, the second 'for' loop is useless and sub-threads will never join().</p>
<p><strong>So how this code works, is there any other way to exit the barrier instead of raising BrokenBarrierError?</strong> In addition, if I add some code in the second 'for' loop, print some information or something else, the procedure is blocked. I guess there must be some sub-threads that are in wait() and have no chance to check flag, so they cannot exit from run() of threads.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to use <code>abort</code> you could have two calls to <code>Barrier.wait</code> in each thread. This would break the operation to two parts. In first part worker threads would do their work and main thread would update the flag status. Then on second part every thread would check the flag status and exit the loop if necessary. </p>
<p>On code level it would look something like this:</p>
<pre><code># Main
def superstep(self):
    workers = []
    barrier = threading.Barrier(self.num_workers+1)
    for vertex in self.vertices:
        worker = Worker(vertex, barrier)
        workers.append(worker)
        worker.start()

    while self.flag:
        barrier.wait()
        self.distributeMessages()
        self.count += 1
        print ("superstep: ", self.count)
        self.flag = self.isTerminated()
        for worker in workers:
            worker.flag = self.flag
        barrier.wait()

    for worker in workers:
        worker.join()

# Worker
def run(self):
    while self.flag:
        self.barrier.wait()
        # do something
        self.barrier.wait() 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can call</p>
<pre><code>self.barrier.abort()
</code></pre>
<p>to release the waiting workers after the second for loop, and catch <code>BrokenBarrierError</code> in the worker's <code>run()</code> method.</p>
</div>
<span class="comment-copy">You could perhaps call <code>barrier.abort()</code> after the second for, to release the waiting workers.</span>
<span class="comment-copy">@Gribouillis Thanks for your reply. barrier.abort() raises a BrokenBarrierError and it pervents my code from executing, so I wonder whether there is a better way.</span>
<span class="comment-copy">You could catch the BrokenBarrierError in the worker threads</span>
<span class="comment-copy">@Gribouillis Thanks. It is the right way. Forgive me for unfamiliar with exception handling before. The question is clear after several minutes studying of this part.</span>
<span class="comment-copy">Ok, I post this as an answer, so you can accept it</span>
<span class="comment-copy">Thanks, this solution works well and I learn a lot from it.</span>
<span class="comment-copy">Thanks again, the answer I accepted before is also very beautiful.</span>
<span class="comment-copy">All right, Great.</span>
