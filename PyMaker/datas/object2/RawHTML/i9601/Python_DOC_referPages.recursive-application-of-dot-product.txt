<div class="post-text" itemprop="text">
<p>I want to apply a function that would generate the result of this in general cases:</p>
<pre><code>np.dot(np.dot(np.dot(D3, theta2), D2), theta1)
</code></pre>
<p>That is, instead of specifying <code>D3</code>, <code>theta2</code>, etc., it would be done in general case like </p>
<pre><code>if n==1:
   answer = np.dot(params['D'+str(n)], params['theta'+str(n - 1)])
else:
   answer = ? 
</code></pre>
<p>Do you have any ideas how I can do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you really want is <code>np.linalg.multi_dot</code>:</p>
<pre><code>np.linalg.multi_dot([D3, theta2, D2, theta1])
</code></pre>
<p>This has the very large advantage of optimizing the contraction order to be the most efficient, rather than simply running through the list. If your matrices are square there is no difference; however, this can be very beneficial if they are not.</p>
</div>
<div class="post-text" itemprop="text">
<p>Like already mentioned by @wwii you can use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a> instead of recursion:</p>
<pre><code>import functools

def dot(a, b):
    return 'dot({}, {})'.format(a, b)

&gt;&gt;&gt; functools.reduce(dot, ['theta2', 'D2', 'theta1'], 'D3')
'dot(dot(dot(D3, theta2), D2), theta1)'
</code></pre>
<p>Just replace the variables with the actual function and variables:</p>
<pre><code>functools.reduce(np.dot, [D3, theta2, D2, theta1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Put your things in a container and use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer">functools.reduce</a></p>
</div>
<div class="post-text" itemprop="text">
<p>An alternative solution to the excellent ones proposed using <code>functools.reduce</code> would be to use numpy's <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.einsum.html" rel="nofollow noreferrer">einsum</a>.</p>
<p><strong>NOTE:</strong> this is not a better solution, just an alternative approach (and a fun one).</p>
<p>For example, for 3 random arrays:</p>
<pre><code>&gt;&gt;&gt; a = np.random.randn(3,3)
&gt;&gt;&gt; b = np.random.randn(3,3)
&gt;&gt;&gt; c = np.random.randn(3,3)
</code></pre>
<p>The recursive dot product can be written as:</p>
<pre><code>&gt;&gt;&gt; result = np.einsum('ij,jk,kl-&gt;il', a, b, c)
&gt;&gt;&gt; np.allclose(result, a.dot(b).dot(c)) # True
</code></pre>
<p>Then a generic function can be written as:</p>
<pre><code>def recdot(*args):
    # Generate the einstring equivalent to all the input matrices
    s='abcdefghijklmnopqrstuvwxyz'
    einstr  = ','.join([s[i:i+2] for i in range(len(args))])
    einstr += '-&gt;{}{}'.format(s[0],s[len(args)]) 
    return np.einsum(einstr, *args)
</code></pre>
<p>And then call it:</p>
<pre><code>&gt;&gt;&gt; np.allclose(recdot(a, b, c), a.dot(b).dot(c)) # True
</code></pre>
<p><strong>NOTE2:</strong> It has the limitation that can only operate in 26 matrices (the number of letters in the above alphabet).</p>
<p>Or if you have an array with the input matrices, change to:</p>
<pre><code>def recdot(*args):  -&gt;   def recdot(args):
</code></pre>
<p>And</p>
<pre><code>&gt;&gt;&gt; recdot([a,b,c])
</code></pre>
</div>
<span class="comment-copy">You really want to be using <code>np.linalg.multi_dot</code>.</span>
<span class="comment-copy">The major downside of this is that <code>np.einsum</code> will be significantly slower than <code>dot</code>. As <code>einsum</code> simply loops over the indices your example scales like <code>N^4</code> instead of <code>N^3</code>. This will change in NumPy 1.12, but something to be aware of.</span>
