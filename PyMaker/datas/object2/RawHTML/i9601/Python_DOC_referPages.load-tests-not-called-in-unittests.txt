<div class="post-text" itemprop="text">
<p>I am trying to use the <a href="https://docs.python.org/3/library/unittest.html#load-tests-protocol" rel="nofollow noreferrer">load_tests protocol</a> to parameterize some test cases. Here is my MCVE:</p>
<pre><code># mytests.py
import unittest

class MyTests(unittest.TestCase):
  def __init__(self, x, y):
    super(MyTests, self).__init__("testMyMethod")
    self.x = x
    self. y = y

  def testMyMethod(self):
    self.assertEqual(self.y, my_method(self.x))

def load_tests(loader, tests, pattern):
  print("load_tests()")
  foobar = zip(range(5), range(5))
  test_suite = unittest.TestSuite()
  for x, y in foobar:
    test_suite.addTest(MyTests(x, y))
  return test_suite

def my_method(x):
  return x

if __name__ == "__main__":
  unittest.main()
</code></pre>
<p>When I run this I get the following output:</p>
<pre><code>myrdraal% python mytests.py 
Traceback (most recent call last):
  File "mytests.py", line 24, in &lt;module&gt;
    unittest.main()
  File "/usr/lib/python3.5/unittest/main.py", line 93, in __init__
    self.parseArgs(argv)
  File "/usr/lib/python3.5/unittest/main.py", line 140, in parseArgs
    self.createTests()
  File "/usr/lib/python3.5/unittest/main.py", line 144, in createTests
    self.test = self.testLoader.loadTestsFromModule(self.module)
  File "/usr/lib/python3.5/unittest/loader.py", line 123, in loadTestsFromModule
    tests.append(self.loadTestsFromTestCase(obj))
  File "/usr/lib/python3.5/unittest/loader.py", line 92, in loadTestsFromTestCase
    loaded_suite = self.suiteClass(map(testCaseClass, testCaseNames))
  File "/usr/lib/python3.5/unittest/suite.py", line 24, in __init__
    self.addTests(tests)
  File "/usr/lib/python3.5/unittest/suite.py", line 57, in addTests
    for test in tests:
TypeError: __init__() missing 1 required positional argument: 'y'
</code></pre>
<p>It appears that my <code>load_tests()</code> is not even being called. What am I doing wrong?</p>
<p>A similar MCVE runs to just fine:</p>
<pre><code># parameterized.py
import unittest

class ParameterizedTest(unittest.TestCase):
  def __init__(self, value):
    super(ParameterizedTest, self).__init__("test")
    self.value = value

  def test(self):
    self.assertEqual(self.value, self.value)

def load_tests(loader, tests, pattern):
  test_suite = unittest.TestSuite()
  for i in range(5):
    test_suite.addTest(ParameterizedTest(i))
  return test_suite

if __name__ == "__main__":
  unittest.main()
</code></pre>
<p>Output 2:</p>
<pre><code>myrdraal% python parameterized.py
.....
----------------------------------------------------------------------
Ran 5 tests in 0.001s

OK
</code></pre>
<p>Apparently I am missing something because these look similar to me.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem appears to be that the <code>unittest</code> framework calls <code>__init__()</code> on each subclass of <code>unittest.TestCase</code> for each method which starts with "test". It passes a single parameter which is a string containing the test method's name. This all occurs before calling <code>load_tests()</code>. One solution is to modify <code>__init__()</code> to allow this mechanism to run:</p>
<pre><code>class MyTests(unittest.TestCase):
  def __init__(self, testName, x=None, y=None):
    super(MyTests, self).__init__(testName)
    self.x = x
    self. y = y

  def testMyMethod(self):
    self.assertEqual(self.y, my_method(self.x))

def load_tests(loader, tests, pattern):
  print("load_tests()")
  foobar = zip(range(5), range(5))
  test_suite = unittest.TestSuite()
  for x, y in foobar:
    test_suite.addTest(MyTests('testMyMethod', x, y))
  return test_suite
</code></pre>
</div>
