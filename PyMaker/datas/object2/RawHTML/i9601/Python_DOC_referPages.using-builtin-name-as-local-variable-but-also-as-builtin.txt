<div class="post-text" itemprop="text">
<p>I have the following function:</p>
<pre><code>def x():
    print(min(0, 1))
    min = 7
    print(min)
</code></pre>
<p>On the face of it (naively), it should print <code>0</code>, then <code>7</code>. In fact it raises an error:</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in x
UnboundLocalError: local variable 'min' referenced before assignment
</code></pre>
<p>How does defining <code>min</code> as a local variable in <code>min = 7</code> prevent it from being used as the builtin before hand? Does Python build a list of local variables (something like <code>__slots__</code> for a class) as it is compiling the function?</p>
</div>
<div class="post-text" itemprop="text">
<p>The compile phase for Python identifies all names that are assigned to within the scope of a function, and marks those names as locals (they're assigned an index in a local variable array in CPython, so using them doesn't involve dictionary lookups at all).</p>
<p>Being a local is all or nothing, for the entire scope of the method. You can't treat a variable as local for part of the method, and global/built-in for the rest. Per <a href="https://docs.python.org/3/reference/executionmodel.html#naming-and-binding" rel="nofollow noreferrer">the language reference on naming and binding</a>:</p>
<blockquote>
<p>A scope defines the visibility of a name within a block. If a local variable is defined in a block, its scope includes that block.</p>
</blockquote>
<p>Like most language standards, that's rather dry, but the important point is that defining a local variable within the block makes it local for the (implied) whole block, not from point of definition.</p>
<p>If you need to do something like this, you can make a local from <a href="https://docs.python.org/3/library/builtins.html#module-builtins" rel="nofollow noreferrer">the qualified name of the builtin</a> initially, then change it later, e.g.:</p>
<pre><code>import builtins  # On Python 2, __builtin__

def x():
    min = builtins.min
    print(min(0, 1))
    min = 7
    print(min)
</code></pre>
<p>Or you can use a cheesy hack based on compile-time default value caching for the same purpose:</p>
<pre><code>def x(min=min): # Caches builtin function as a default value for local min
    print(min(0, 1))
    min = 7
    print(min)
</code></pre>
<p>If you're on Python 3, you'd want to do <code>def x(*, min=min):</code> to make it a keyword only argument, so it can't be overridden by the caller if they accidentally pass too many arguments positionally.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, specifically, if you take a look at the byte code generated, you'll see that Python tries to load it as a local with <code>LOAD_FAST</code>:</p>
<pre><code>&gt;&gt;&gt; dis(x)
  2           0 LOAD_GLOBAL              0 (print)
              3 LOAD_FAST                0 (min)
              6 LOAD_CONST               1 (0)
              9 LOAD_CONST               2 (1)
             12 CALL_FUNCTION            2 (2 positional, 0 keyword pair)
             15 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
</code></pre>
<p>During compilation of the function object (I'm pretty sure it is during the construction of the symbol table), an assignment to <code>min</code> is detected and any look-ups for that name will be resolved in the local scope.</p>
<p>You can actually peek at the symbol table constructed and see how the symbol (name) <code>min</code> is classified:</p>
<pre><code>&gt;&gt;&gt; import symtable
&gt;&gt;&gt; s="""
... def x():
...     print(min(0, 1))
...     min = 7
...     print(min)
... """
&gt;&gt;&gt; t = symtable.symtable(s, '', compile_type='exec')
&gt;&gt;&gt; i = t.get_children()[0].get_symbols()[0]
&gt;&gt;&gt; print(i)
&lt;symbol 'min'&gt;
&gt;&gt;&gt; i.is_local()
True
</code></pre>
<p>Haven't taken a good look into the symtable internals but there just might be some overriding here. Afterwards, during execution, this will flat out fail due to the fact that the assignment happens after the reference and no value can be found.</p>
</div>
<span class="comment-copy">"Does Python build a list of local variables (something like <code>__slots__</code> for a class) as it is compiling the function?" - yup.</span>
<span class="comment-copy">The fact that it is a builtin is a red-herring. Try that with any variable that is in the global scope and the same thing will happen.</span>
<span class="comment-copy">@juanpa.arrivillaga I figured it applied to any global name. <code>min</code> was just the first thing that came to mind for a minimal example. My question is purely about why it happens.</span>
<span class="comment-copy">That's called the <a href="https://www.embrangler.com/2011/01/python-scoping-understading-legb/" rel="nofollow noreferrer"><code>LEGB</code></a> manner.</span>
<span class="comment-copy">@Kasramvd: LEGB defines the order of lookup, but it's not, in itself, describing the fact that "local" is for the entire block, not just from point of definition onward.</span>
<span class="comment-copy">@Kasramvd: True, but that's kind of subtle in itself. If a global that shadows a builtin name is defined at top level on line 2, and you use that name at top level on line 1 and line 3, you get the builtin on line 1 and the shadowing name on line 3. The fact that locals don't work that way while globals do makes references to LEGB less than useful here. Nested scope is even weirder, where calling the nested function in the outer function before locals in the outer scope have been defined and having the inner function print gets a value like <code>&lt;function foo.&lt;locals&gt;.bar at 0x7f5887930d08&gt;</code>.</span>
<span class="comment-copy">@ShadowRanger: I think you just screwed up your test with nested scopes, probably by <a href="http://ideone.com/Vhvhuo" rel="nofollow noreferrer">printing the nested <code>bar</code> function itself</a> instead of printing the unbound closure variable. If you try to access a closure variable before a value is assigned to it, <a href="http://ideone.com/h6Qwnw" rel="nofollow noreferrer">you get a NameError</a>.</span>
<span class="comment-copy">@user2357112: Yeah, you're right. My fault for trying to finish test and comment in a rush before I had to go help with kiddo bedtime rituals. So nested scopes are more like local scopes, while global scope is different. Either way, LEGB is not particularly helpful for understanding it.</span>
