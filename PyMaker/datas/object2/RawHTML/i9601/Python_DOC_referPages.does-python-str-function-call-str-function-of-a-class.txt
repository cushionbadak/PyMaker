<div class="post-text" itemprop="text">
<p>If I define a class with its own <code>__str__()</code> function, is <code>str(a)</code> equivalent to <code>a.__str__()</code>, where <code>a</code> is an instance of my class?</p>
<p>I checked the <a href="https://docs.python.org/2/library/functions.html#str" rel="noreferrer">python doc</a>, it doesn't say explicitly that this is the case.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short answer: <strong>Yes!</strong></p>
<hr/>
<p>According to the <a href="https://docs.python.org/reference/datamodel.html#object.__str__" rel="noreferrer">Python docs</a> (I highlighted the relevant part):</p>
<blockquote>
<p><code>object.__str__(self)</code></p>
<p>Called by <strong>str(object)</strong> and the built-in functions format() and print() to compute the “informal” or nicely printable string representation of an object. The return value must be a string object.</p>
<p>This method differs from <code>object.__repr__()</code> in that there is no expectation that <code>__str__()</code> return a valid Python expression: a more convenient or concise representation can be used.</p>
<p>The default implementation defined by the built-in type object calls <code>object.__repr__()</code>.</p>
</blockquote>
<p>So <code>your_instance.__str__</code> is generally called when you do <code>str(your_instance)</code>.</p>
<hr/>
<p>Longer answer: With "Special Methods" (the methods with two leading underscores and two trailing underscores) there is an exception because these are looked up on the class, not the instance. So <code>str(a)</code> is actually <code>type(a).__str__(a)</code> and not <code>a.__str__()</code>. But in most cases these are the same, because one rarely overrides methods of the class on the instance. Especially not special methods.</p>
<p>See also the <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="noreferrer">relevant documentation on "Special method lookup"</a>:</p>
<blockquote>
<p>For custom classes, <strong>implicit invocations</strong> of special methods are only guaranteed to work correctly if defined on an <strong>object’s type</strong>, not in the <strong>object’s instance dictionary</strong>.</p>
</blockquote>
<p>So like @zzh1996 pointed out in the comments the following code will use the method defined on the class even though the instance has a custom callable <code>__str__</code> attribute:</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     def __str__(self):
...         return 'a'
&gt;&gt;&gt; instance = A()
&gt;&gt;&gt; instance.__str__ = lambda: 'b'
&gt;&gt;&gt; str(instance)
'a'
&gt;&gt;&gt; instance.__str__()
'b'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it does. Take a look at the following example:</p>
<pre><code>&gt;&gt;&gt; class A:
...     def __init__(self, a):
...         self.a = a
...     def __str__(self):
...         print "Inside __str__"
...         return self.a
...
&gt;&gt;&gt;
&gt;&gt;&gt; a = A('obj1')
&gt;&gt;&gt; a
&lt;__main__.A instance at 0x0000000002605548&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; a.__str__()
Inside __str__
'obj1'
&gt;&gt;&gt;
&gt;&gt;&gt; str(a)
Inside __str__
'obj1'
</code></pre>
<p>And, from <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer"><code>__str__()</code> documentation</a>, we have:</p>
<blockquote>
<p><code>object.__str__(self)</code></p>
<p>Called by <code>str(object)</code> and the built-in functions
  <code>format()</code> and <code>print()</code> to compute the “informal” or nicely printable
  string representation of an object. The return value must be a string
  object.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Yes, but also on print. See docs
<a href="https://docs.python.org/2/reference/datamodel.html#object.__str__" rel="nofollow noreferrer">https://docs.python.org/2/reference/datamodel.html#object.<strong>str</strong></a></p>
</div>
<span class="comment-copy">Why not try it out yourself?</span>
<span class="comment-copy">Why don't you test it? Make a new class, and override the <code>__str__</code> method.</span>
<span class="comment-copy">See the <a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow noreferrer">str doc</a></span>
<span class="comment-copy">this is wrong! ``` In [21]: class A:     ...:     def __str__(self):     ...:         return 'a'     ...:     ...:  In [22]: a=A()  In [23]: def f():     ...:     return 'b'     ...:  In [24]: a.__str__=f  In [25]: str(a) Out[25]: 'a' ```</span>
<span class="comment-copy">@zzh1996 Yes, special methods are looked up on the class, not the instance. However I thought that would distract from the actual question which asked if "<code>str()</code> function call <code>__str__()</code> function of a class?" (which is the case) but <code>str(a)</code> is not always equivalent to <code>a.__str__()</code> but to <code>type(a).__str__(a)</code>. But I added further clarification on that point.</span>
<span class="comment-copy">Note that if the class (or its parents) doesn't define <code>.__str__</code> then <code>.__repr__</code> will be called. The latter always exists because it's inherited from <code>object</code>, unless it's overridden by the class (or a parent).</span>
<span class="comment-copy">Yeah that's correct. It is also mentioned in the docs i copied: "The default implementation defined by the built-in type object calls object.__repr__().". Do you that needs to be emphasised?</span>
