<div class="post-text" itemprop="text">
<p>I have an XBee plugged into a Raspberry PI. Here is the Python 3.4 code I am using:</p>
<pre><code>f = os.open("/dev/ttyUSB0", os.O_RDWR | os.O_NONBLOCK)

print("Writing...")
b = bytes("hello","utf-8")
os.write(f,b)

print("Press return to start read")
cmd = input()

print("Reading...")
ret = os.read(f,10)
if ret == None:
        print("ret = None")
else:
        print("ret = {}".format(ret))

 os.close(f)
</code></pre>
<p>Yesterday, this all worked as I expected.  The read command returned immediately, with zero bytes if there wasn't anything to read.</p>
<p>Today I added code to another part of the project that writes to a text file and includes a thread RLock.  Now the above code does something different.  If there are no bytes waiting to be read, or there are bytes waiting to be read but they don't end with an 0x0D, I get an error: </p>
<pre><code>BlockingIOError: [Errno 11] Resource temporarily unavailable
</code></pre>
<p>But is there are bytes waiting to be read that end with an 0x0D, the read function returns those bytes including the 0x0D.</p>
<p>Update: I have reformated the system, and the fault has not gone away, which suggests it wasn't the addition of the file and thread locking code that caused the problem.</p>
<p>I ran minicom and the problem has gone away, so maybe I should be doing something with serial configuration on the device before I open it as a file?</p>
<p>This is the line that returns the os.read to its original behaviour:</p>
<p>minicom -b 9600 -o -D /dev/ttyUSB0</p>
</div>
<div class="post-text" itemprop="text">
<p>I strongly suspect that the two different behaviours are related to the CTS/RTS flow control settings on the serial port. Try turning CTS/RTS on or off to get the behaviour you want.</p>
</div>
<span class="comment-copy">Can you include the code that adds the lock? The newline thing makes it sound like somehow the read is being buffered (I know using a normal file-like object as an iterator will block waiting for the newline or EOF), but afaik <code>os.open</code> returns an unbuffered file handle</span>
<span class="comment-copy">Thanks for the reply.  I have update my question with the locking code.</span>
<span class="comment-copy">Are you closing the handle for the serial port, but still reading from it?  If so, then it's possible that the underlying file handle for your trace.txt file is the same as what it was for the USB port.  Unix operating systems assign file handles in incrementing order and will re-use handles.  Try this and see for yourself: <a href="https://gist.github.com/jszakmeister/e18607a026749956f0bd7a30cd148fa6" rel="nofollow noreferrer">gist.github.com/jszakmeister/e18607a026749956f0bd7a30cd148fa6</a></span>
<span class="comment-copy">For the record, I'd consider returning empty <code>bytes</code> when no data is available to be an error. <code>os.read</code> should only return empty <code>bytes</code> when it's reached end of file. When it's not at end of file, but there is no data available to read on a non-blocking file descriptor, it should raise <a href="https://docs.python.org/3/library/exceptions.html#BlockingIOError" rel="nofollow noreferrer"><code>BlockingIOError</code></a>; that's what that error is for.</span>
<span class="comment-copy">@ShadowRanger <code>BlockingIOError</code> only ever gets raised by <code>io.write()</code>. <code>io.read()</code> returns <code>None</code> and <code>os.read()</code> returns an empty byte object.</span>
