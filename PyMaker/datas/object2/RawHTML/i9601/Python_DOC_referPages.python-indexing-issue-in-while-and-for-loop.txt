<div class="post-text" itemprop="text">
<p>I am adapting Schorsch's answer in <a href="https://stackoverflow.com/questions/18729376/while-loop-inside-for-loop-in-matlab">While loop inside for loop in Matlab</a> to use in Python 3.5 for my problem.</p>
<p>I want to iterate over values in my <code>t</code> array. For each value, if the result of my calculation <code>z</code> converges (or doesn't converge after a maximum no. of iterations) I copy this to an array. Then I plot the results.</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt

maxiter = 100 # max no. iterations in convergence loop
t = 0.05*np.arange(10)
z = 0.1 # initial guess
x = np.zeros(len(t)) # array for results
cvec = np.zeros(len(t)) # does loop converge?

for ii in t:

    print(ii)

    convergence = 0

    while convergence == 0:

        z_old = z
        z = ii*np.random.rand() # perform calculations

        # check convergence

        if abs(z-z_old) &lt; 0.01: # convergence
            # store result
            convergence = 1
            x[ii] = z
            cvec[ii] = convergence

        elif abs(z-z_old) &gt;= 0.01 and ii &lt; maxiter: # no convergence but loop again
            convergence = 0
        else: # no convergence, move on to next value in t array
            convergence = 0
            x[ii] = 1e3
            cvec[ii] = convergence
            break

# plot result
plt.figure()
plt.plot(t[cvec==1],x[cvec==1],'x')
plt.xlabel('t')
plt.ylabel('x')
plt.show()
</code></pre>
<p>I get an error: <code>VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
  lines = """</code></p>
<p>Does this mean I have to change how I index the <code>while</code> or <code>for</code> loops, and if so how should I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue is related with the lines <code>x[ii] =</code> and <code>cvec[ii]</code>. As you are trying to access non-integers indexes.
Those indexes were generated on the following line:</p>
<pre><code>(...)
t = 0.05*np.arange(10) #[ 0.  ,  0.05,  0.1 ,  0.15,  0.2 ,  0.25,  0.3 ,  0.35,  0.4 ,  0.45]
(...)
</code></pre>
<p>To solve the issue, there are several ways to do it, but the easiest is simply to access the same index the value from the <code>t</code> variable is on.</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt

maxiter = 100 # max no. iterations in convergence loop
t = 0.05*np.arange(10)
z = 0.1 # initial guess
x = np.zeros(len(t)) # array for results
cvec = np.zeros(len(t)) # does loop converge?

for idx, ii in enumerate(t):

    print(ii)

    convergence = 0

    while convergence == 0:

        z_old = z
        z = ii*np.random.rand() # perform calculations

        # check convergence

        if abs(z-z_old) &lt; 0.01: # convergence
            # store result
            convergence = 1
            x[idx] = z
            cvec[idx] = convergence

        elif abs(z-z_old) &gt;= 0.01 and ii &lt; maxiter: # no convergence but loop again
            convergence = 0
        else: # no convergence, move on to next value in t array
            convergence = 0
            x[idx] = 1e3
            cvec[idx] = convergence
            break

# plot result
plt.figure()
plt.plot(t[cvec==1],x[cvec==1],'x')
plt.xlabel('t')
plt.ylabel('x')
plt.show()
</code></pre>
<hr/>
<p>Using the while loop to iterate the maximum times a value, while it doesn't converge</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt

maxiter = 100 # max no. iterations in convergence loop
t = 0.05*np.arange(10)
z = 0.1 # initial guess
x = np.zeros(len(t)) # array for results
cvec = np.zeros(len(t)) # does loop converge?

for idx, ii in enumerate(t):

    print(ii)

    # Assume it wont converge
    # So if we loop through all the max iterations and still no convergence, it is already marked
    x[idx] = 1e3
    cvec[idx] = 0

    while iter in range(maxiter):

        z_old = z
        z = ii*np.random.rand() # perform calculations

        if abs(z-z_old) &lt; 0.01: # converge, therefore stop looping
            x[idx] = z
            cvec[idx] = 1
            break

# plot result
plt.figure()
plt.plot(t[cvec==1],x[cvec==1],'x')
plt.xlabel('t')
plt.ylabel('x')
plt.show()
</code></pre>
</div>
<span class="comment-copy">It probably means that you are indexing arrays using <code>x[ii]</code>, and <code>ii</code> is not an integer. Something is wrong with your <code>t</code> array (the one you use in the to iterate the for loop). If it is suppose to be integer array, but somehow is float, you can do something like <code>for ii in np.asarray(t, np.int32)</code>.</span>
<span class="comment-copy">Your question title is misleading.</span>
<span class="comment-copy">Why are you indexing with float values? I would suggest setting <code>x</code> and <code>cvec</code> to an empty list before the loops then just append the values as needed i.e. <code>x.append(z)</code>. Or, you could use a counter to index <code>x</code> and <code>cvec</code> then increment it everytime you set an element. If you need to store the time as well just set something like <code>timestamps = []</code> and append to that as well.</span>
<span class="comment-copy">@pbreach If I have a <code>t</code> array with 1000 elements say, would it be more efficient to use the <code>append</code> function or start with an array of zeros as in my MWE?</span>
<span class="comment-copy">Actually now that I think about it the easiest way would be to just use <code>for idx, ii in enumerate(t):</code> and then just do the indexing with <code>idx</code> no need for a counter or to switch to lists :). Before I didn't realize you were storing the values for <code>x</code> in the case of non-convergence. See <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">here</a> for <code>enumerate</code> function.</span>
<span class="comment-copy">Thanks @AdrianoMartins.  I think there should be a while-loop counter(<a href="https://www.tutorialspoint.com/python/python_while_loop.htm" rel="nofollow noreferrer">tutorialspoint.com/python/python_while_loop.htm</a>). For the line <code>elif abs(z-z_old) &gt;= 0.01 and ii &lt; maxiter: # no convergence but loop again</code>, we change <code>ii</code> to <code>counter</code> using the example notation in the link.</span>
<span class="comment-copy">Updated the answer. If I managed to understand correctly, that new code should do what you're expecting</span>
<span class="comment-copy">OK thanks - is the <code>break</code> command in the second code block meant to be not indented?</span>
<span class="comment-copy">Sorry about it. I had misunderstood the issue - and made some typos. Fixed it. Now it should loop until converge or give up if the max iterations are reached.</span>
