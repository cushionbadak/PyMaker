<div class="post-text" itemprop="text">
<p>I have main thread where I created ThreadPool. Before call function, makes initialization each thread in pool. How wait when all threads will be initialized?</p>
<p>Example:</p>
<pre><code>from multiprocessing.pool import ThreadPool

def main():
    # in main thread
    pool = ThreadPool(processes=5, initializer=init_pool)

    # &gt;&gt;&gt; here it is I want to wait for initialized

    pool.map_async(do_smth).get()

 def init_pool():
    # initialized new thread in pool
    pass

def do_smth():
    # do somethings
    pass
</code></pre>
<p>It is necessary not to cause map_async if initialization of a thread exception occurred</p>
</div>
<div class="post-text" itemprop="text">
<p>I would implement a <a href="https://docs.python.org/3/library/threading.html#barrier-objects" rel="nofollow noreferrer" title="Barrier">barrier</a> in your <code>do_smth()</code>-function and skip the <code>init_pool</code>. But that works only beginning with Python 3.2.</p>
<p>Barriers have a predefined number of parties that have to call the <code>wait</code>-function of the barrier. When the barrier registers the correct number of calls it "drops" and the calling parties return to there their work simultaneously.</p>
<p>Something like that:</p>
<pre><code>from multiprocessing.pool import ThreadPool
from threading import Barrier

b = Barrier(parties=5)

def main():
    # in main thread
    pool = ThreadPool(processes=5)

    pool.map_async(do_smth).get()

def do_smth():
    #initialize here
    b.wait() #call to the barrier
    # do somethings
    pass
</code></pre>
</div>
<span class="comment-copy">I can use Value from multiprocessing for this purpose, but it isn't pretty solution</span>
<span class="comment-copy">Cool, thanks! Despite the fact that I write in Python 2.7, your answer helped me!  I can simulate the barrier like this <a href="http://stackoverflow.com/a/26703365/4181533">stackoverflow.com/a/26703365/4181533</a></span>
