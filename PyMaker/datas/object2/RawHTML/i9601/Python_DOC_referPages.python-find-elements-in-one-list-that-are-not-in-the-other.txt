<div class="post-text" itemprop="text">
<p>I need to compare two lists in order to create a new list of specific elements found in one list but not in the other. For example:</p>
<pre><code>main_list=[]
list_1=["a", "b", "c", "d", "e"]
list_2=["a", "f", "c", "m"] 
</code></pre>
<p>I want to loop through list_1 and append to main_list all the elements from list_2 that are not found in list_1.</p>
<p>The result should be:</p>
<pre><code>main_list=["f", "m"]
</code></pre>
<p>How can I do it with python?</p>
</div>
<div class="post-text" itemprop="text">
<p>(1) You can use NumPy's <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.setdiff1d.html" rel="noreferrer"><code>setdiff1d</code></a>. From the <a href="https://stackoverflow.com/a/41125943/7204790">response of Chinny84</a>, if you are concerned with the <strong>unique</strong> elements, then:</p>
<pre><code>import numpy as np
list_1 = ["a", "b", "c", "d", "e"]
list_2 = ["a", "f", "c", "m"] 
main_list = np.setdiff1d(list_2,list_1)
</code></pre>
<p>(2) Otherwise, use <code>main_list = np.setdiff1d(list_2,list_1, assume_unique=True)</code></p>
<p>Both answers will give you <code>["f", "m"]</code>. However, if <code>list_2 = ["a", "f", "c", "m", "m"]</code>, answer (1) yields <code>["f", "m"]</code> BUT answer (2) gives <code>["f", "m", "m"]</code> (because the uniqueness of each element in <code>list_2</code> is immaterial).</p>
<p><a class="post-tag" href="/questions/tagged/python" rel="tag" title="show questions tagged 'python'">python</a><a class="post-tag" href="/questions/tagged/numpy" rel="tag" title="show questions tagged 'numpy'">numpy</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use sets:</p>
<pre><code>main_list = list(set(list_2) - set(list_1))
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; list_1=["a", "b", "c", "d", "e"]
&gt;&gt;&gt; list_2=["a", "f", "c", "m"]
&gt;&gt;&gt; set(list_2) - set(list_1)
set(['m', 'f'])
&gt;&gt;&gt; list(set(list_2) - set(list_1))
['m', 'f']
</code></pre>
<p>Per @JonClements' comment, here is a tidier version:</p>
<pre><code>&gt;&gt;&gt; list_1=["a", "b", "c", "d", "e"]
&gt;&gt;&gt; list_2=["a", "f", "c", "m"]
&gt;&gt;&gt; list(set(list_2).difference(list_1))
['m', 'f']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure why the above explanations are so complicated when you have native methods available:</p>
<pre><code>main_list = list(set(list_2)-set(list_1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a> like this:</p>
<pre><code>main_list = [item for item in list_2 if item not in list_1]
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt;&gt;&gt; list_1 = ["a", "b", "c", "d", "e"]
&gt;&gt;&gt; list_2 = ["a", "f", "c", "m"] 
&gt;&gt;&gt; 
&gt;&gt;&gt; main_list = [item for item in list_2 if item not in list_1]
&gt;&gt;&gt; main_list
['f', 'm']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want a one-liner solution (ignoring imports) that only requires <code>O(max(n, m))</code> work for inputs of length <code>n</code> and <code>m</code>, not <code>O(n * m)</code> work, you can do so with <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">the <code>itertools</code> module</a>:</p>
<pre><code>from itertools import filterfalse

main_list = list(filterfalse(set(list_1).__contains__, list_2))
</code></pre>
<p>This takes advantage of the functional functions taking a callback function on construction, allowing it to create the callback once and reuse it for every element without needing to store it somewhere (because <code>filterfalse</code> stores it internally); list comprehensions and generator expressions can do this, but it's ugly.†</p>
<p>That gets the same results in a single line as:</p>
<pre><code>main_list = [x for x in list_2 if x not in list_1]
</code></pre>
<p>with the speed of:</p>
<pre><code>set_1 = set(list_1)
main_list = [x for x in list_2 if x not in set_1]
</code></pre>
<p>Of course, if the comparisons are intended to be positional, so:</p>
<pre><code>list_1 = [1, 2, 3]
list_2 = [2, 3, 4]
</code></pre>
<p>should produce:</p>
<pre><code>main_list = [2, 3, 4]
</code></pre>
<p>(because value in <code>list_2</code> has a match at the same index in <code>list_1</code>), you should definitely go with <a href="https://stackoverflow.com/a/41125939/364696">Patrick's answer</a>, which involves no temporary <code>list</code>s or <code>set</code>s (even with <code>set</code>s being roughly <code>O(1)</code>, they have a higher "constant" factor per check than simple equality checks) and involves <code>O(min(n, m))</code> work, less than any other answer, and if your problem is position sensitive, is the only <em>correct</em> solution when matching elements appear at mismatched offsets.</p>
<p>†: The way to do the same thing with a list comprehension as a one-liner would be to abuse nested looping to create and cache value(s) in the "outermost" loop, e.g.:</p>
<pre><code>main_list = [x for set_1 in (set(list_1),) for x in list_2 if x not in set_1]
</code></pre>
<p>which also gives a minor performance benefit on Python 3 (because now <code>set_1</code> is locally scoped in the comprehension code, rather than looked up from nested scope for each check; on Python 2 that doesn't matter, because Python 2 doesn't use closures for list comprehensions; they operate in the same scope they're used in).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>main_list=[]
list_1=["a", "b", "c", "d", "e"]
list_2=["a", "f", "c", "m"]

for i in list_2:
    if i not in list_1:
        main_list.append(i)

print(main_list)
</code></pre>
<p>output:</p>
<pre><code>['f', 'm']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would <code>zip</code> the lists together to compare them element by element.</p>
<pre><code>main_list = [b for a, b in zip(list1, list2) if a!= b]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the number of occurences should be taken into account you probably need to use something like <code>collections.Counter</code>:</p>
<pre><code>list_1=["a", "b", "c", "d", "e"]
list_2=["a", "f", "c", "m"] 
from collections import Counter
cnt1 = Counter(list_1)
cnt2 = Counter(list_2)
final = [key for key, counts in cnt2.items() if cnt1.get(key, 0) != counts]

&gt;&gt;&gt; final
['f', 'm']
</code></pre>
<p>As promised this can also handle differing number of occurences as "difference":</p>
<pre><code>list_1=["a", "b", "c", "d", "e", 'a']
cnt1 = Counter(list_1)
cnt2 = Counter(list_2)
final = [key for key, counts in cnt2.items() if cnt1.get(key, 0) != counts]

&gt;&gt;&gt; final
['a', 'f', 'm']
</code></pre>
</div>
<span class="comment-copy">Are you looking for elements in <code>list_2</code> that appear nowhere in <code>list_1</code> or elements in <code>list_2</code> that are not present at the same index in <code>list_1</code>?</span>
<span class="comment-copy">If your lists are already ordered, this will also return an ordered list. The native solution of converting to sets and then getting the difference (solutions shown below) returns an unordered list which may make it harder to visually examine your results.</span>
<span class="comment-copy">This is good if we only care about <code>unique</code> elements but what if we have multiple <code>m's</code> for example this would not pick it up.</span>
<span class="comment-copy">That's true. I assumed the poster was looking for unique elements. I suppose it depends on what he means by "specific".</span>
<span class="comment-copy">Indeed p.s. I did not down vote your answer, especially for an unclear original question.</span>
<span class="comment-copy">You could write this as <code>list(set(list_2).difference(list_1))</code> which avoids the explicit <code>set</code> conversion...</span>
<span class="comment-copy">No worries! Thanks @leaf for the formatting assist.</span>
<span class="comment-copy">Preserving order might be the reason</span>
<span class="comment-copy">Note: For larger <code>list_1</code>, you'd want to preconvert to a <code>set</code>/<code>frozenset</code>, e.g. <code>set_1 = frozenset(list_1)</code>, then <code>main_list = [item for item in list_2 if item not in set_1]</code>, reducing the check time from <code>O(n)</code> per item to (roughly) <code>O(1)</code>.</span>
<span class="comment-copy">Like <a href="http://stackoverflow.com/a/41125957/364696">the equivalent list comprehension based solution</a>, this will be slow if <code>list_1</code> is large, and <code>list_2</code> is of non-trivial size, because it involves <code>len(list_2)</code> <code>O(n)</code> scans of <code>list_1</code>, making it <code>O(n * m)</code> (where <code>n</code> and <code>m</code> are the lengths of <code>list_2</code> and <code>list_1</code> respectively). If you convert <code>list_1</code> to a <code>set</code>/<code>frozenset</code> up front, the contains checks can be done in <code>O(1)</code>, making the total work <code>O(n)</code> on the length of <code>list_2</code> (technically, <code>O(max(n, m))</code>, since you do <code>O(m)</code> work to make the <code>set</code>).</span>
<span class="comment-copy">If the OP wants to compare element by element (it's unclear, the example could go either way), this is <i>much</i> more efficient than the other answers, since it's a single cheap pass over both <code>list</code>s with a single new <code>list</code> being constructed, no additional temporaries, no expensive containment checks, etc.</span>
<span class="comment-copy">@ShadowRanger this would only work for element-wise difference which is a key point</span>
<span class="comment-copy">@fordprefect: Yup. <a href="https://stackoverflow.com/a/41126821/364696">My own answer</a> covers position-independent differences.</span>
