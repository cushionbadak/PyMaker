<div class="post-text" itemprop="text">
<p>I'm encountering confusing and seemingly contradictory rules regarding raw strings. Consider the following example:</p>
<pre>
&gt;&gt;&gt; text = 'm\n'
&gt;&gt;&gt; match = re.search('m\n', text)
&gt;&gt;&gt; print match.group()
m

&gt;&gt;&gt; print text
m

</pre>
<p>This works, which is fine.</p>
<pre>
&gt;&gt;&gt; text = 'm\n'
&gt;&gt;&gt; match = re.search(r'm\n', text)
&gt;&gt;&gt; print match.group()
m

&gt;&gt;&gt; print text
m

</pre>
<p>Again, this works. But shouldn't this throw an error, because the raw string contains the characters <code>m\n</code> and the actual text contains a newline?</p>
<pre><code>&gt;&gt;&gt; text = r'm\n'
&gt;&gt;&gt; match = re.search(r'm\n', text)
&gt;&gt;&gt; print match.group()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'group'
&gt;&gt;&gt; print text
m\n
</code></pre>
<p>The above, surprisingly, throws an error, even though both are raw strings. This means both contain just the text <code>m\n</code> with no newlines.</p>
<pre><code>&gt;&gt;&gt; text = r'm\n'
&gt;&gt;&gt; match = re.search(r'm\\n', text)
&gt;&gt;&gt; print text
m\n
&gt;&gt;&gt; print match.group()
m\n
</code></pre>
<p>The above works, surprisingly. <strong>Why do I have to escape the backslash in the re.search, but not in the text itself?</strong></p>
<p>Then there's backslash with normal characters that have no special behavior:</p>
<pre><code>&gt;&gt;&gt; text = 'm\&amp;'
&gt;&gt;&gt; match = re.search('m\&amp;', text)
&gt;&gt;&gt; print text
m\&amp;
&gt;&gt;&gt; print match.group()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'group'
</code></pre>
<p>This doesn't match, even though both the pattern and the string lack special characters.</p>
<p>In this situation, no combination of raw strings works (text as a raw string, patterns as a raw string, both or none).</p>
<p>However, consider the last example. Escaping in the text variable, <code>'m\\&amp;'</code>, doesn't work, but escaping in the pattern does. This parallels the behavior above--even stranger, I feel, considering that <code>\&amp;</code> is of no special meaning to either Python or re:</p>
<pre><code>&gt;&gt;&gt; text = 'm\&amp;'
&gt;&gt;&gt; match = re.search(r'm\\&amp;', text)
&gt;&gt;&gt; print text
m\&amp;
&gt;&gt;&gt; print match.group()
m\&amp;
</code></pre>
<p>My understanding of raw strings is that they inhibit the behavior of the backslash in python. For regular expressions, this is important because it allows re.search to apply its own internal backslash behavior, and prevent conflicts with Python. However, in situations like the above, where backslash effectively means nothing, I'm not sure why it seems necessary. Worse yet, I don't understand why I need to backslash for the pattern, but not the text, and when I make both a raw string, it doesn't seem to work.</p>
<p><a href="https://docs.python.org/3/howto/regex.html" rel="nofollow noreferrer">The docs</a> don't provide much guidance in this regard. They focus on examples with obvious problems, such as <code>'\section'</code>, where <code>\s</code> is a meta-character. Looking for a complete answer to prevent unanticipated behavior such as this.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the regular Python string, <code>'m\n'</code>, the <code>\n</code> represents a single newline character, whereas in the raw string <code>r'm\n'</code> the <code>\</code> and <code>n</code> are just themselves. So far, so simple.</p>
<p>If you pass the string <code>'m\n'</code> as a pattern to <code>re.search()</code>, you're passing a two-character string (<code>m</code> followed by newline), and <code>re</code> will happily go and find instances of that two-character string for you.</p>
<p>If you pass the three-character string <code>r'm\n'</code>, <strong>the <code>re</code> module itself</strong> will interpret the two characters <code>\</code> <code>n</code> as having the special meaning "match a newline character", so that the whole pattern means "match an <code>m</code> followed by a newline", just as before.</p>
<p>In your third example, since the string <code>r'm\n'</code> doesn't contain a newline, there's no match:</p>
<pre><code>&gt;&gt;&gt; text = r'm\n'
&gt;&gt;&gt; match = re.search(r'm\n', text)
&gt;&gt;&gt; print(match)
None
</code></pre>
<p>With the pattern <code>r'm\\n'</code>, you're passing two actual backslashes to <code>re.search()</code>, and again, <strong>the <code>re</code> module itself</strong> is interpreting the double backslash as "match a single backslash character".</p>
<p>In the case of <code>'m\&amp;'</code>, something slightly different is going on. Python treats the backslash as a regular character, because it isn't part of an escape sequence. <code>re</code>, on the other hand, simply discards the <code>\</code>, so the pattern is effectively <code>m&amp;</code>. You can see that this is true by testing the pattern against <code>'m&amp;'</code>:</p>
<pre><code>&gt;&gt;&gt; re.search('m\&amp;', 'm&amp;').group()
'm&amp;'
</code></pre>
<p>As before, doubling the backslash tells <code>re</code> to search for an actual backslash character:</p>
<pre><code>&gt;&gt;&gt; re.search(r'm\\&amp;', 'm\&amp;').group()
'm\\&amp;'
</code></pre>
<p>... and just to make things a little more confusing, the single backslash is represented by Python doubled. You can see that it's actually a single backslash by printing it:</p>
<pre><code>&gt;&gt;&gt; print(re.search(r'm\\&amp;', 'm\&amp;').group())
m\&amp;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To explain it in simple terms, <code>\&lt;character&gt;</code> has a special meaning in regular expressions. For example <code>\s</code> for whitespace characters, <code>\d</code> for decimal digits, <code>\n</code> for new-line characters, etc.</p>
<p>When you define a string as</p>
<pre><code>s = 'foo\n'
</code></pre>
<p>This string contains the characters <code>f</code>, <code>o</code>, <code>o</code> and the new-line character (length 4).</p>
<p>However, when defining a raw string:</p>
<pre><code>s = r'foo\n'
</code></pre>
<p>This string contains the characters <code>f</code>, <code>o</code>, <code>o</code>, <code>\</code> and <code>n</code> (length 5).</p>
<p>When you compile a regexp with raw <code>\n</code> (i.e. <code>r'\n'</code>), it'll match all new lines. Similarly, just using the new-line character (i.e. <code>'\n'</code>) it's going to match new-line characters just like <code>a</code> matches <code>a</code> and so on.</p>
<p>Once you understand this concept, you should be able to figure out the rest.</p>
<p>To elaborate a bit further. In order to match the back-slash character <code>\</code> using regex, the valid <strong>regular expression</strong> is <code>\\</code> which in Python would be <code>r'\\'</code> or its equivalent <code>'\\\\'</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>text = r'm\n'
match = re.search(r'm\\n', text)
</code></pre>
<p>First line using <code>r</code> stops python from interpreting <code>\n</code> as single byte.</p>
<p>Second line using <code>r</code> plays the same role as first.Using <code>\</code> prevents regex from interpreting as <code>\n</code> .Regex also uses <code>\</code> like <code>\s</code>, <code>\d</code>.</p>
<blockquote>
<blockquote>
<p>The following characters are the meta characters that give special meaning to the regular expression search syntax:</p>
<p>\ the backslash escape character.
        The backslash gives special meaning to the character following it. For example, the combination "\n" stands for the newline, one of the control characters. The combination "\w" stands for a "word" character, one of the convenience escape sequences while "\1" is one of the substitution special characters. 
            Example: The regex "aa\n" tries to match two consecutive "a"s at the end of a line, inclusive the newline character itself. 
            Example: "a+" matches "a+" and not a series of one or "a"s. </p>
</blockquote>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>In order to understand the internal representation of the strings you're confused about. I'd recommend you using <a href="https://docs.python.org/2/library/repr.html" rel="nofollow noreferrer">repr</a> and <a href="https://docs.python.org/2/library/functions.html#len" rel="nofollow noreferrer">len</a> builtin functions. Using those you'll be able to understand exactly how the strings are and you won't be confused anymore about pattern matching because you'll exactly know the internal representation. For instance, let's say you wanna analize the strings you're having troubles with:</p>
<pre><code>use_cases = [
    'm\n',
    r'm\n',
    'm\\n',
    r'm\\n',
    'm\&amp;',
    r'm\&amp;',
    'm\\&amp;',
    r'm\\&amp;',
]

for u in use_cases:
    print('-' * 10)
    print(u, repr(u), len(u))
</code></pre>
<p>The output would be:</p>
<pre><code>----------
m
 'm\n' 2
----------
m\n 'm\\n' 3
----------
m\n 'm\\n' 3
----------
m\\n 'm\\\\n' 4
----------
m\&amp; 'm\\&amp;' 3
----------
m\&amp; 'm\\&amp;' 3
----------
m\&amp; 'm\\&amp;' 3
----------
m\\&amp; 'm\\\\&amp;' 4
</code></pre>
<p>So you can see exactly the differences between normal/raw strings.</p>
</div>
<span class="comment-copy">There is nothing to be surprised of. <code>r'm\n</code> is of length 3 (<code>m</code>, <code>\</code>, <code>n</code>). The <code>r'm\n'</code> regex matches 2 char string, <code>m</code> + newline.</span>
<span class="comment-copy">This makes your question a dupe of <a href="http://stackoverflow.com/questions/22937618/reference-what-does-this-regex-mean" title="reference what does this regex mean">stackoverflow.com/questions/22937618/â€¦</a>. The <code>r'\n'</code> is an LF matching pattern.</span>
<span class="comment-copy">Thanks for this! I realize now that in Python, a backslash only behaves like a special character when it is in front of certain characters. Thats why <code>pattern = r'm\\&amp;'</code> matches both <code>text = r'm\&amp;'</code> and <code>text = r'm\\&amp;'</code>. However, in regex, backslash is always a special character, regardless of whether its changing the behavior of the following character (like <code>\w</code>) or not (like <code>\&amp;</code>). Therefore, if I want just a normal backspace, I must always escape in regex, although in normal Python this is sometimes optional.</span>
<span class="comment-copy">@GHH <code>\` is en escape character.Is you want to match that u need to use </code>\\`.You cannot define a string `a\` in python</span>
<span class="comment-copy">Thanks, I see the confusion: <code>\n</code> is also has special meaning in regex. But take the following situation: text and pattern = <code>r'm\k'</code>. This also raises an error. What about situations where <code>r\[whatever]</code> is <b>definitely</b> not special in either Python or re? Why do I still need to escape the backslash?</span>
<span class="comment-copy">@GHH because `\` itself is a special character and if u r using it in a literal sense u need to escape it for regex interpreter not python</span>
<span class="comment-copy">@GHH python interprets the string and then later regex also interprets it....hope it makes sense</span>
<span class="comment-copy">Cool trick. I'll definitely use this. Thanks.</span>
