<div class="post-text" itemprop="text">
<p>I'm trying to implement a tcp 'echo server'.
Simple stuff:</p>
<ol>
<li>Client sends a message to the server.</li>
<li>Server receives the message</li>
<li>Server converts message to uppercase</li>
<li>Server sends modified message to client</li>
<li>Client prints the response.</li>
</ol>
<p>It worked well, so I decided to parallelize the server; make it so that it could handle multiple clients at time.
Since most Python interpreters have a GIL, multithreading won't cut it.
I had to use multiproces... And boy, this is where things went downhill.</p>
<p>I'm using Windows 10 x64 and the WinPython suit with Python 3.5.2 x64.</p>
<p>My idea is to create a socket, intialize it (bind and listen), create sub processes and pass the socket to the children.
But for the love of me... I can't make this work, my subprocesses die almost instantly.
Initially I had some issues 'pickling' the socket...
So I googled a bit and thought this was the issue. 
So I tried passing my socket thru a multiprocessing queue, through a pipe and my last attempt was 'forkpickling' and passing it as a bytes object during the processing creating.
Nothing works.</p>
<p>Can someone please shed some light here?
Tell me whats wrong?
<strong>Maybe the whole idea (sharing sockets) is bad... And if so, PLEASE tell me how can I achieve my initial objective: enabling my server to ACTUALLY handle multiple clients at once (on Windows)</strong> (don't tell me about threading, we all know python's threading won't cut it ¬¬)</p>
<p>It also worth noting that no files are create by the debug function.
No process lived long enough to run it, I believe.</p>
<p>The typical output of my server code is (only difference between runs is the process numbers):</p>
<pre><code>Server is running...
Degree of parallelism: 4
Socket created.
Socket bount to: ('', 0)
Process 3604 is alive: True
Process 5188 is alive: True
Process 6800 is alive: True
Process 2844 is alive: True

Press ctrl+c to kill all processes.

Process 3604 is alive: False
Process 3604 exit code: 1
Process 5188 is alive: False
Process 5188 exit code: 1
Process 6800 is alive: False
Process 6800 exit code: 1
Process 2844 is alive: False
Process 2844 exit code: 1
The children died...
Why god?
WHYYyyyyy!!?!?!?
</code></pre>
<p>The server code:</p>
<pre><code># Imports
import socket 
import packet
import sys
import os
from time import sleep
import multiprocessing as mp
import pickle
import io

# Constants
DEGREE_OF_PARALLELISM = 4
DEFAULT_HOST = ""
DEFAULT_PORT = 0

def _parse_cmd_line_args():
    arguments = sys.argv
    if len(arguments) == 1:
        return DEFAULT_HOST, DEFAULT_PORT
    else:
        raise NotImplemented()

def debug(data):
    pid = os.getpid()
    with open('C:\\Users\\Trauer\\Desktop\\debug\\'+str(pid)+'.txt', mode='a',
              encoding='utf8') as file:
        file.write(str(data) + '\n')

def handle_connection(client):
    client_data = client.recv(packet.MAX_PACKET_SIZE_BYTES)
    debug('received data from client: ' + str(len(client_data)))
    response = client_data.upper()
    client.send(response)    
    debug('sent data from client: ' + str(response))

def listen(picklez):    
    debug('started listen function')

    pid = os.getpid()
    server_socket = pickle.loads(picklez)
    debug('acquired socket')

    while True:
        debug('Sub process {0} is waiting for connection...'.format(str(pid)))

        client, address = server_socket.accept()
        debug('Sub process {0} accepted connection {1}'.format(str(pid),
              str(client)))

        handle_connection(client)        
        client.close()
        debug('Sub process {0} finished handling connection {1}'.
              format(str(pid),str(client)))

if __name__ == "__main__":    
#   Since most python interpreters have a GIL, multithreading won't cut
#   it... Oughta bust out some process, yo!
    host_port = _parse_cmd_line_args()
    print('Server is running...')
    print('Degree of parallelism: ' + str(DEGREE_OF_PARALLELISM))

    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print('Socket created.')

    server_socket.bind(host_port)
    server_socket.listen(DEGREE_OF_PARALLELISM)
    print('Socket bount to: ' + str(host_port))        

    buffer = io.BytesIO()
    mp.reduction.ForkingPickler(buffer).dump(server_socket)
    picklez = buffer.getvalue()

    children = []
    for i in range(DEGREE_OF_PARALLELISM):        
        child_process = mp.Process(target=listen, args=(picklez,))
        child_process.daemon = True
        child_process.start()
        children.append(child_process)

        while not child_process.pid:
            sleep(.25)

        print('Process {0} is alive: {1}'.format(str(child_process.pid), 
              str(child_process.is_alive())))     
    print()    

    kids_are_alive = True
    while kids_are_alive:
        print('Press ctrl+c to kill all processes.\n')
        sleep(1) 

        exit_codes = []
        for child_process in children:
            print('Process {0} is alive: {1}'.format(str(child_process.pid), 
              str(child_process.is_alive())))
            print('Process {0} exit code: {1}'.format(str(child_process.pid), 
              str(child_process.exitcode)))
            exit_codes.append(child_process.exitcode)

        if all(exit_codes):
            # Why do they die so young? :(
            print('The children died...')
            print('Why god?')
            print('WHYYyyyyy!!?!?!?')
            kids_are_alive = False
</code></pre>
<p>edit: fixed the signature of "listen". My processes still die instantly.</p>
<p>edit2: User cmidi pointed out that this code does work on Linux; so my question is: <em>How can I 'made this work' on Windows?</em></p>
</div>
<div class="post-text" itemprop="text">
<p>You can directly pass a socket to a child process. multiprocessing registers a reduction for this, for which the Windows implementation uses the following <code>DupSocket</code> class from <code>multiprocessing.resource_sharer</code>:</p>
<pre><code>class DupSocket(object):
    '''Picklable wrapper for a socket.'''
    def __init__(self, sock):
        new_sock = sock.dup()
        def send(conn, pid):
            share = new_sock.share(pid)
            conn.send_bytes(share)
        self._id = _resource_sharer.register(send, new_sock.close)

    def detach(self):
        '''Get the socket.  This should only be called once.'''
        with _resource_sharer.get_connection(self._id) as conn:
            share = conn.recv_bytes()
            return socket.fromshare(share)
</code></pre>
<p>This calls the Windows socket <a href="https://docs.python.org/3/library/socket.html#socket.socket.share" rel="nofollow noreferrer"><code>share</code></a> method, which returns the protocol info buffer from calling <a href="https://msdn.microsoft.com/en-us/library/ms741565" rel="nofollow noreferrer"><code>WSADuplicateSocket</code></a>. It registers with the resource sharer to send this buffer over a connection to the child process. The child in turn calls <code>detach</code>, which receives the protocol info buffer and reconstructs the socket via <code>socket.fromshare</code>.</p>
<p>It's not directly related to your problem, but I recommend that you redesign the server to instead call <code>accept</code> in the main process, which is the way this is normally done (e.g. in Python's <a href="https://docs.python.org/3/library/socketserver.html#socketserver.ForkingTCPServer" rel="nofollow noreferrer"><code>socketserver.ForkingTCPServer</code></a> module). Pass the resulting <code>(conn, address)</code> tuple to the first available worker over a <code>multiprocessing.Queue</code>, which is shared by all of the workers in the process pool. Or consider using a <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool" rel="nofollow noreferrer"><code>multiprocessing.Pool</code></a> with <code>apply_async</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>def listen()</code> the target/start for your child processes does not take any argument but you are providing serialized socket as an argument  <code>args=(picklez,)</code> to the child process this would cause an exception in the child process and exit immediately.</p>
<pre><code>TypeError: listen() takes no arguments (1 given)
</code></pre>
<p><code>def listen(picklez)</code> should solve the problem this will provide one argument to the target of your child processes.</p>
</div>
<span class="comment-copy">multiprocessing handles passing sockets to child processes automatically. The Windows implementation uses the socket <code>share</code> method and <code>fromshare</code> function.</span>
<span class="comment-copy">Call <code>accept()</code> in the main process and pass the resulting <code>(conn, addr)</code> tuple to a worker using a shared <code>multiprocessing.Queue</code>.</span>
<span class="comment-copy">No change, eryksun. My proceses still die instantly.</span>
<span class="comment-copy">FYI, your code works fine with a simple change to use <code>mp.Process(target=listen, args=(server_socket,))</code>, with <code>listen</code> modified to take the socket as a parameter.</span>
<span class="comment-copy">It worked fine for me 5 hours ago, given the changes I mentioned. It loops repeatedly showing all 4 processes are alive, and each log file shows the process is waiting for a connection.</span>
<span class="comment-copy">I see. What about <a href="http://pastebin.com/uRjCBuaD" rel="nofollow noreferrer">this</a> approach, is it legitimate?</span>
<span class="comment-copy">I haven't checked how the backlog is handled when the listening socket is copied to another process. If each copy has its own backlog, then it's probably not what you want.</span>
<span class="comment-copy">I see. Last question and I stop bothering you, hehe. Do you know where can I find some documentation about this?</span>
<span class="comment-copy">Indeed, the function originally posted wasn't complete. I posted an incomplete / incorrect code here. The correct signature is listen(picklez). My point is: sadly this isn't the problem; the original code has the correct signature but my children processes still die instantly, but thank you for the answer.</span>
<span class="comment-copy">strictly speaking <code>accept</code> should be locked between different processes access and the code seems to be working on a linux environment even without serializing the socket</span>
<span class="comment-copy">I was afraid about this... I had a feeling this was a Windows complication. I will add this information to my quesiton. Thank you cmidi.</span>
<span class="comment-copy">what happens if you change <code>debug</code> to just <code>print(data)</code> rather than opening the file</span>
<span class="comment-copy">Nothing happens. I thought it was some sort of io-flushing issue... That's why I decided to create a file.</span>
