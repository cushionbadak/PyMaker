<div class="post-text" itemprop="text">
<p>In the book <em>Python in a Nutshell (2nd Edition)</em> there is an example which uses<br/>
old style classes to demonstrate how methods are resolved in classic resolution order and<br/>
how is it different with the new order. </p>
<p>I tried the same example by rewriting the example in new style but the result is no different than what was obtained with old style classes. The python version I am using to run the example is <strong>2.5.2.</strong> Below is the example: </p>
<pre><code>class Base1(object):  
    def amethod(self): print "Base1"  

class Base2(Base1):  
    pass

class Base3(object):  
    def amethod(self): print "Base3"

class Derived(Base2,Base3):  
    pass

instance = Derived()  
instance.amethod()  
print Derived.__mro__  
</code></pre>
<p>The call <code>instance.amethod()</code> prints <strong><code>Base1</code></strong>, but as per my understanding of the MRO with new style of classes the output should have been <strong><code>Base3</code></strong>. The call <code>Derived.__mro__</code> prints:      </p>
<p><code>(&lt;class '__main__.Derived'&gt;, &lt;class '__main__.Base2'&gt;, &lt;class '__main__.Base1'&gt;, &lt;class '__main__.Base3'&gt;, &lt;type 'object'&gt;)</code></p>
<p>I am not sure if my understanding of MRO with new style classes is incorrect or that I am doing a silly mistake which I am not able to detect. Please help me in better understanding of MRO.</p>
</div>
<div class="post-text" itemprop="text">
<p>The crucial difference between resolution order for legacy vs new-style classes comes when the same ancestor class occurs more than once in the "naive", depth-first approach -- e.g., consider a "diamond inheritance" case:</p>
<pre><code>&gt;&gt;&gt; class A: x = 'a'
... 
&gt;&gt;&gt; class B(A): pass
... 
&gt;&gt;&gt; class C(A): x = 'c'
... 
&gt;&gt;&gt; class D(B, C): pass
... 
&gt;&gt;&gt; D.x
'a'
</code></pre>
<p>here, legacy-style, the resolution order is D - B - A - C - A : so when looking up D.x, A is the first base in resolution order to solve it, thereby hiding the definition in C.  While:</p>
<pre><code>&gt;&gt;&gt; class A(object): x = 'a'
... 
&gt;&gt;&gt; class B(A): pass
... 
&gt;&gt;&gt; class C(A): x = 'c'
... 
&gt;&gt;&gt; class D(B, C): pass
... 
&gt;&gt;&gt; D.x
'c'
&gt;&gt;&gt; 
</code></pre>
<p>here, new-style, the order is:</p>
<pre><code>&gt;&gt;&gt; D.__mro__
(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, 
    &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;)
</code></pre>
<p>with <code>A</code> forced to come in resolution order only once and after all of its subclasses, so that overrides (i.e., C's override of member <code>x</code>) actually work sensibly.</p>
<p>It's one of the reasons that old-style classes should be avoided: multiple inheritance with "diamond-like" patterns just doesn't work sensibly with them, while it does with new-style.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's method resolution order is actually more complex than just understanding the diamond pattern.  To <em>really</em> understand it, take a look at <a href="http://en.wikipedia.org/wiki/C3_linearization">C3 linearization</a>.  I've found it really helps to use print statements when extending methods to track the order.  For example, what do you think the output of this pattern would be? (Note: the 'X' is suppose to be two crossing edges, not a node and ^ signifies methods that call super())</p>
<pre><code>class G():
    def m(self):
        print("G")

class F(G):
    def m(self):
        print("F")
        super().m()

class E(G):
    def m(self):
        print("E")
        super().m()

class D(G):
    def m(self):
        print("D")
        super().m()

class C(E):
    def m(self):
        print("C")
        super().m()

class B(D, E, F):
    def m(self):
        print("B")
        super().m()

class A(B, C):
    def m(self):
        print("A")
        super().m()


#      A^
#     / \
#    B^  C^
#   /| X
# D^ E^ F^
#  \ | /
#    G
</code></pre>
<p>Did you get A B D C E F G?</p>
<pre><code>x = A()
x.m()
</code></pre>
<p>After a lot of trial an error, I came up with an informal graph theory interpretation of C3 linearization as follows:  (Someone please let me know if this is wrong.)</p>
<p>Consider this example:</p>
<pre><code>class I(G):
    def m(self):
        print("I")
        super().m()

class H():
    def m(self):
        print("H")

class G(H):
    def m(self):
        print("G")
        super().m()

class F(H):
    def m(self):
        print("F")
        super().m()

class E(H):
    def m(self):
        print("E")
        super().m()

class D(F):
    def m(self):
        print("D")
        super().m()

class C(E, F, G):
    def m(self):
        print("C")
        super().m()

class B():
    def m(self):
        print("B")
        super().m()

class A(B, C, D):
    def m(self):
        print("A")
        super().m()

# Algorithm:

# 1. Build an inheritance graph such that the children point at the parents (you'll have to imagine the arrows are there) and
#    keeping the correct left to right order. (I've marked methods that call super with ^)

#          A^
#       /  |  \
#     /    |    \
#   B^     C^    D^  I^
#        / | \  /   /
#       /  |  X    /   
#      /   |/  \  /     
#    E^    F^   G^
#     \    |    /
#       \  |  / 
#          H
# (In this example, A is a child of B, so imagine an edge going FROM A TO B)

# 2. Remove all classes that aren't eventually inherited by A

#          A^
#       /  |  \
#     /    |    \
#   B^     C^    D^
#        / | \  /  
#       /  |  X    
#      /   |/  \ 
#    E^    F^   G^
#     \    |    /
#       \  |  / 
#          H

# 3. For each level of the graph from bottom to top
#       For each node in the level from right to left
#           Remove all of the edges coming into the node except for the right-most one
#           Remove all of the edges going out of the node except for the left-most one

# Level {H}
#
#          A^
#       /  |  \
#     /    |    \
#   B^     C^    D^
#        / | \  /  
#       /  |  X    
#      /   |/  \ 
#    E^    F^   G^
#               |
#               |
#               H

# Level {G F E}
#
#         A^
#       / |  \
#     /   |    \
#   B^    C^   D^
#         | \ /  
#         |  X    
#         | | \
#         E^F^ G^
#              |
#              |
#              H

# Level {D C B}
#
#      A^
#     /| \
#    / |  \
#   B^ C^ D^
#      |  |  
#      |  |    
#      |  |  
#      E^ F^ G^
#            |
#            |
#            H

# Level {A}
#
#   A^
#   |
#   |
#   B^  C^  D^
#       |   |
#       |   |
#       |   |
#       E^  F^  G^
#               |
#               |
#               H

# The resolution order can now be determined by reading from top to bottom, left to right.  A B C E D F G H

x = A()
x.m()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The result you get is correct. Try changing base class of <code>Base3</code> to <code>Base1</code> and compare with the same hierarchy for classic classes:</p>
<pre><code>class Base1(object):
    def amethod(self): print "Base1"

class Base2(Base1):
    pass

class Base3(Base1):
    def amethod(self): print "Base3"

class Derived(Base2,Base3):
    pass

instance = Derived()
instance.amethod()


class Base1:
    def amethod(self): print "Base1"

class Base2(Base1):
    pass

class Base3(Base1):
    def amethod(self): print "Base3"

class Derived(Base2,Base3):
    pass

instance = Derived()
instance.amethod()
</code></pre>
<p>Now it outputs:</p>
<pre><code>Base3
Base1
</code></pre>
<p>Read <a href="http://www.python.org/download/releases/2.3/mro/" rel="noreferrer">this explanation</a> for more information.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're seeing that behavior because method resolution is depth-first, not breadth-first.  Dervied's inheritance looks like</p>
<pre><code>         Base2 -&gt; Base1
        /
Derived - Base3
</code></pre>
<p>So <code>instance.amethod()</code></p>
<ol>
<li>Checks Base2, doesn't find amethod.</li>
<li>Sees that Base2 has inherited from Base1, and checks Base1. Base1 has a <code>amethod</code>, so it gets called.</li>
</ol>
<p>This is reflected in <code>Derived.__mro__</code>.  Simply iterate over <code>Derived.__mro__</code> and stop when you find the method being looked for.</p>
</div>
<span class="comment-copy">"[the ancestor class] A [is] forced to come in resolution order only once and after all of its subclasses, so that overrides (i.e., C's override of member x) actually work sensibly." -- <i>Epiphany!</i> Thanks to this sentence, I can do MRO in my head again. \o/ Thank you very much.</span>
<span class="comment-copy">You should correct your second code : you have put class "I" as first line and also used super so it finding the super class "G" but "I" is first class so it will never able to find "G" class because there is no "G" upper "I" . Put class "I" between "G" and "F" :)</span>
<span class="comment-copy">The example code is incorrect. <code>super</code> has required arguments.</span>
<span class="comment-copy">Inside a class definition super() doesn't require arguments.  See <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#super</a></span>
<span class="comment-copy">Your graph theory is needlessly complicated.  After step 1, insert edges from classes on the left to classes on the right (in any inheritance list), and then do a <a href="https://en.wikipedia.org/wiki/Topological_sorting" rel="nofollow noreferrer">topological sort</a> and you're done.</span>
<span class="comment-copy">@Kevin I don't think that's correct.  Following my example, wouldn't A C D B E F G H be a valid topological sort? But that's not the resolution order.</span>
<span class="comment-copy">I doubt that the reason I get "Base1" as answer is because method resolution is depth-first,I think there is more to it than a depth-first approach. See Denis's example, if it were depth first o/p should have been "Base1". Also refer to the first example in the link you have provided, there also the MRO shown indicates that the method resolution is not just determined by traversing  in depth-first order.</span>
<span class="comment-copy">Sorry the link to the document on MRO is provided by Denis. Please check that, I mistook that you provided me the link to python.org.</span>
<span class="comment-copy">It's generally depth-first, but there are smarts to handle diamond-like inheritance as Alex explained.</span>
