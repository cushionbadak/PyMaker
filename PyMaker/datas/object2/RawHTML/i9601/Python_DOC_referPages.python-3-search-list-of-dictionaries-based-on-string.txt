<div class="post-text" itemprop="text">
<p>Say I have the string</p>
<pre><code>"((attr1=25 and attr2=8) or attr3=15)"
</code></pre>
<p>or</p>
<pre><code>"((attr1&gt;25 and attr2&lt;50) or (attr3=10 and attr4=20))"
</code></pre>
<p>or</p>
<pre><code>"(attrXYZ=10)"
</code></pre>
<p>or even</p>
<pre><code>"(attr1=20 and attr2=20 and attr3=20 and attr4=20)"
</code></pre>
<p>And a list that contains dictionarys, where each dictionary may or may not have the specified attribute in the string. Is there an easy way in Python to filter the dictionaries that match this type of string query?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Disclaimer: This is a very lazy and insecure solution that uses two of the most inglorious functions of Python, <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer">eval</a> and <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer">exec</a>, but can work if the output has exactly the same shape as the one that you provided.</h2>
<p>Our strategy is to edit the inputs to look similar to the syntax that Python understands naturally, instead of creating our own parser. Doing that, we will use the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer">dis</a> module (Disassembler for Python bytecode) to get all names in the string.</p>
<pre><code>import dis 

class Number:
    def __init__(self, n, exists=True):
        self.n = n
        self.exists = exists

    def __lt__(self, other):
        return self.n &lt; other if self.exists else False

    def __le__(self, other):
        return self.n &lt;= other if self.exists else False

    def __eq__(self, other):
        return self.n == other if self.exists else False

    def __ne__(self, other):
        return self.n != other if self.exists else False

    def __gt__(self, other):
        return self.n &gt; other if self.exists else False

    def __ge__(self, other):
        return self.n &gt;= other if self.exists else False


def clear_entries(entry):
    entry_output = entry.replace('!=', '&lt;&gt;').replace('=','==').replace('&lt;&gt;','!=')
    return entry_output

def check_condition(dict_, str_):
    str_ = clear_entries(str_)

    for k, v in dict_.items():
        exec("{0} = {1}".format(k, v))

    all_names = dis.Bytecode(str_).codeobj.co_names
    l_ = locals()
    non_defined_names = [v for v in all_names if v not in l_]

    for name in non_defined_names:
        exec("{0} = Number(0, exists=False)".format(name))  # the number value does not matter here (because of the 'exists' flag)

    if eval(str_):
        return True

    return False
</code></pre>
<h2>Testing</h2>
<pre><code>if __name__ == '__main__':
    entries = [
        "((attr1=25 and attr2=8) or attr3=15)",
        "((attr1&gt;25 and attr2&lt;50) or (attr3=10 and attr4=20))",
        "(2&lt;attrXYZ&lt;10)",
        "(attr1=20 and attr2=20 and attr3=20 and attr4=20)",
        "(attr1=20 or (attr2=20 and attr3=20 and attr4=20 and attr1231231=1))"
    ]

    dicts = [
        {'attr1': 25, 'attr2': 8, 'attr3': 123},
        {'attr1': 1, 'attr2': 8, 'attr3': 123},
        {'attr1': 26, 'attr2': 8, 'attr3': 123, 'attr4': 1},
        {'attr1': 1, 'attr2': 50, 'attr3': 1, 'attr4': 20},
        {'attr1': -1, 'attr2': 50, 'attr3': 1, 'attr4': 20},
        {'attrXYZ': 3},
        {'attrXYZ': 10},
        {'attr1': 20}

    ]

    for entry in entries:
        for d in dicts:
            print(check_condition(d, entry), '"{0}"'.format(entry), d)
</code></pre>
<h2>Result</h2>
<pre><code>(True, '"((attr1=25 and attr2=8) or attr3=15)"', {'attr1': 25, 'attr2': 8, 'attr3': 123})
(False, '"((attr1=25 and attr2=8) or attr3=15)"', {'attr1': 1, 'attr2': 8, 'attr3': 123})
(False, '"((attr1=25 and attr2=8) or attr3=15)"', {'attr1': 26, 'attr2': 8, 'attr3': 123, 'attr4': 1})
(False, '"((attr1=25 and attr2=8) or attr3=15)"', {'attr1': 1, 'attr2': 50, 'attr3': 1, 'attr4': 20})
(False, '"((attr1=25 and attr2=8) or attr3=15)"', {'attr1': -1, 'attr2': 50, 'attr3': 1, 'attr4': 20})
(False, '"((attr1=25 and attr2=8) or attr3=15)"', {'attrXYZ': 3})
(False, '"((attr1=25 and attr2=8) or attr3=15)"', {'attrXYZ': 10})
(False, '"((attr1=25 and attr2=8) or attr3=15)"', {'attr1': 20})
(False, '"((attr1&gt;25 and attr2&lt;50) or (attr3=10 and attr4=20))"', {'attr1': 25, 'attr2': 8, 'attr3': 123})
(False, '"((attr1&gt;25 and attr2&lt;50) or (attr3=10 and attr4=20))"', {'attr1': 1, 'attr2': 8, 'attr3': 123})
(True, '"((attr1&gt;25 and attr2&lt;50) or (attr3=10 and attr4=20))"', {'attr1': 26, 'attr2': 8, 'attr3': 123, 'attr4': 1})
(False, '"((attr1&gt;25 and attr2&lt;50) or (attr3=10 and attr4=20))"', {'attr1': 1, 'attr2': 50, 'attr3': 1, 'attr4': 20})
(False, '"((attr1&gt;25 and attr2&lt;50) or (attr3=10 and attr4=20))"', {'attr1': -1, 'attr2': 50, 'attr3': 1, 'attr4': 20})
(False, '"((attr1&gt;25 and attr2&lt;50) or (attr3=10 and attr4=20))"', {'attrXYZ': 3})
(False, '"((attr1&gt;25 and attr2&lt;50) or (attr3=10 and attr4=20))"', {'attrXYZ': 10})
(False, '"((attr1&gt;25 and attr2&lt;50) or (attr3=10 and attr4=20))"', {'attr1': 20})
(False, '"(2&lt;attrXYZ&lt;10)"', {'attr1': 25, 'attr2': 8, 'attr3': 123})
(False, '"(2&lt;attrXYZ&lt;10)"', {'attr1': 1, 'attr2': 8, 'attr3': 123})
(False, '"(2&lt;attrXYZ&lt;10)"', {'attr1': 26, 'attr2': 8, 'attr3': 123, 'attr4': 1})
(False, '"(2&lt;attrXYZ&lt;10)"', {'attr1': 1, 'attr2': 50, 'attr3': 1, 'attr4': 20})
(False, '"(2&lt;attrXYZ&lt;10)"', {'attr1': -1, 'attr2': 50, 'attr3': 1, 'attr4': 20})
(True, '"(2&lt;attrXYZ&lt;10)"', {'attrXYZ': 3})
(False, '"(2&lt;attrXYZ&lt;10)"', {'attrXYZ': 10})
(False, '"(2&lt;attrXYZ&lt;10)"', {'attr1': 20})
(False, '"(attr1=20 and attr2=20 and attr3=20 and attr4=20)"', {'attr1': 25, 'attr2': 8, 'attr3': 123})
(False, '"(attr1=20 and attr2=20 and attr3=20 and attr4=20)"', {'attr1': 1, 'attr2': 8, 'attr3': 123})
(False, '"(attr1=20 and attr2=20 and attr3=20 and attr4=20)"', {'attr1': 26, 'attr2': 8, 'attr3': 123, 'attr4': 1})
(False, '"(attr1=20 and attr2=20 and attr3=20 and attr4=20)"', {'attr1': 1, 'attr2': 50, 'attr3': 1, 'attr4': 20})
(False, '"(attr1=20 and attr2=20 and attr3=20 and attr4=20)"', {'attr1': -1, 'attr2': 50, 'attr3': 1, 'attr4': 20})
(False, '"(attr1=20 and attr2=20 and attr3=20 and attr4=20)"', {'attrXYZ': 3})
(False, '"(attr1=20 and attr2=20 and attr3=20 and attr4=20)"', {'attrXYZ': 10})
(False, '"(attr1=20 and attr2=20 and attr3=20 and attr4=20)"', {'attr1': 20})
(False, '"(attr1=20 or (attr2=20 and attr3=20 and attr4=20 and attr1231231=1))"', {'attr1': 25, 'attr2': 8, 'attr3': 123})
(False, '"(attr1=20 or (attr2=20 and attr3=20 and attr4=20 and attr1231231=1))"', {'attr1': 1, 'attr2': 8, 'attr3': 123})
(False, '"(attr1=20 or (attr2=20 and attr3=20 and attr4=20 and attr1231231=1))"', {'attr1': 26, 'attr2': 8, 'attr3': 123, 'attr4': 1})
(False, '"(attr1=20 or (attr2=20 and attr3=20 and attr4=20 and attr1231231=1))"', {'attr1': 1, 'attr2': 50, 'attr3': 1, 'attr4': 20})
(False, '"(attr1=20 or (attr2=20 and attr3=20 and attr4=20 and attr1231231=1))"', {'attr1': -1, 'attr2': 50, 'attr3': 1, 'attr4': 20})
(False, '"(attr1=20 or (attr2=20 and attr3=20 and attr4=20 and attr1231231=1))"', {'attrXYZ': 3})
(False, '"(attr1=20 or (attr2=20 and attr3=20 and attr4=20 and attr1231231=1))"', {'attrXYZ': 10})
(True, '"(attr1=20 or (attr2=20 and attr3=20 and attr4=20 and attr1231231=1))"', {'attr1': 20})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>ONLY DO THIS IF YOU'RE SURE YOUR QUERY STRING IS SAFE.</h3>
<p>(EDIT: You really should use something like <a href="http://pyparsing.wikispaces.com/" rel="nofollow noreferrer">pyparsing</a> instead of doing something quick and dirty.)</p>
<p>Do <strong>not</strong> use <code>exec</code> on the query string if the source is from untrusted input.</p>
<pre><code>import re

QUERY_EXEC_RE = re.compile('(\w+)=')

def _matches(query_exec, d):
    a = []
    exec('a.append({0})'.format(query_exec), globals(), locals())
    return a[0]

def query_dicts(query, dicts):
    query_exec = QUERY_EXEC_RE.sub(r'd.get("\1") == ', query)
    return [d for d in dicts if _matches(query_exec, d)]
</code></pre>
<p>Example:</p>
<pre><code>query = "((attr1=25 and attr2=8) or attr3=15)"
dicts = [
    dict(attr1=1, attr2=2, attr3=3),
    dict(attr1=25, attr2=7, attr3=12),
    dict(attr1=24, attr2=8, attr3=13),
    dict(attr1=25, attr2=8, attr3=14),
    dict(attr1=5, attr2=1, attr3=15),
    dict(attr3=15),
    dict(attr1=25, attr2=8),
]
answer = query_dicts(query, dicts)
print(answer)

[{'attr1': 25, 'attr2': 8, 'attr3': 14},
 {'attr1': 5, 'attr2': 1, 'attr3': 15},
 {'attr3': 15},
 {'attr1': 25, 'attr2': 8}]
</code></pre>
</div>
<span class="comment-copy">What is generating these strings?</span>
<span class="comment-copy">@juanpa.arrivillaga they are inputted by the user, and don't necessarily have to fit that format. It could be something like <code>"(attr1=25)"</code>, or even something like <code>"((attr1&gt;25 and attr2&lt;50) or (attr3=10 and attr4=20))"</code></span>
<span class="comment-copy">@juanpa.arrivillaga I just dont know if there is some built in way to do this (new to python), or if I will have to resort to string manipulation</span>
<span class="comment-copy">It sounds like you have a specific grammar which can be used to construct filter expressions.  Look into using lexical parser like <code>pyparsing</code> or <code>ply</code>. Here is a quite related post: <a href="http://stackoverflow.com/questions/2371436/evaluating-a-mathematical-expression-in-a-string" title="evaluating a mathematical expression in a string">stackoverflow.com/questions/2371436/â€¦</a>.</span>
<span class="comment-copy"><code>eval()</code> should not be our choice though - it is dangerous especially in your case where you cannot really trust the source of the filter string (here is a working example - but do not use it in practice <a href="https://gist.github.com/alecxe/ee798e21d961c687f040aa0a1e72fa64" rel="nofollow noreferrer">gist.github.com/alecxe/ee798e21d961c687f040aa0a1e72fa64</a>).</span>
<span class="comment-copy">would this method cover operators such as &lt; or &gt;?</span>
<span class="comment-copy">Yes! I tested for  "(2&lt;attrXYZ&lt;10)" and works perfectly too. If you want use "!=', however, you will need to make a small modification because of      entry_output = entry.replace('=', '=='), but it's very simple...</span>
<span class="comment-copy">Hi gustavo. Thank you for the solution - although this seems to be failing for queries such as <code>"(attr1=20 or attr2=25)"</code>, if the current dictionary doesnt have the <code>attr1</code> key. This is because when it cant find <code>attr1</code>, NameError is thrown, and we never get to check and see if <code>attr2=25</code>. How would you go about solving this?</span>
<span class="comment-copy">I edited my answer. Try again, please.</span>
