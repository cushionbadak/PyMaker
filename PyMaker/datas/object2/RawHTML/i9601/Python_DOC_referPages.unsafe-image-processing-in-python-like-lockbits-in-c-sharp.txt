<div class="post-text" itemprop="text">
<p>Is it possible to do Unsafe Image Processing in Python?</p>
<p>As with C# I encountered a hard wall with my pixel processing in Python as getPixel method from Image is simply running too slow.</p>
<p>Is it possible to get a direct access to the image in memory like LockBits in c# does? It will make my program run much faster.</p>
<p>Thanks,</p>
<p>Mark</p>
</div>
<div class="post-text" itemprop="text">
<p>There is nothing "unsafe" about this.</p>
<p>Once you understand how Python works, it becomes patent that calling a method to retrieve information on each pixel is going to be slow.  </p>
<p>First of all, although you give no information on it, I assume you are using "Pillow" - the Python Image Library (PIL)  which is the most well known library for image manipulation using Python. As it is a third party package, nothing obliges you to use that. (PIL does have a <code>getpixel</code> method on images, but not a <code>getPixel</code> one)</p>
<p>One straightforward way to have all data in a manipulable way is to create a bytearray object of the image data - given an image in a <code>img</code> variable you can do:</p>
<pre><code>data = bytearray(img.tobytes())  
</code></pre>
<p>And that is it, you have linear access to all data on your image. To get to an specific Pixel in there, you need to get the image width , heigth and bytes-per-pixel. The later one is not a direct Image attribute in PIL, so you have to compute it given the Image's <code>mode</code>. The most common image types are RGB, RGBA and L.</p>
<p>So, if you want to write out a rectangle at "x, y, width, size" at an image, you can do this:</p>
<pre><code>def rectangle(img, x,y, width, height):
    data = bytearray(img.tobytes())
    blank_data = (255,) * witdh * bpp
    bpp = 3 if data.mode == 'RGB' else 4 if data.mode == 'RGBA' else 1
    stride = img.width * bpp
    for i in range(y, y + height):
         data[i * stride + x * bpp: i * stride + (x + width) * bpp)] = blank_data
    return Image.frombytes(img.mode, (img.width, img.height), bytes(data))
</code></pre>
<p>That is not much used, but for simple manipulation. People needing to apply filters and other more complicated algorithms in images with Python usually access the image using numpy - python high-performance data manipulation package, wich is tightly coupled with a lot of other packages that have things specific for images - usually installed as <code>scipy</code>.</p>
<p>So, to have the image as an ndarray, which already does all of the above coordinate -&gt; bytes conversion for you, you can use:</p>
<pre><code> import scipy.misc
 data = scipy.misc.imread(&lt;filename&gt;)
</code></pre>
<p>(Check the docs at <a href="https://docs.scipy.org/doc/scipy/reference/" rel="nofollow noreferrer">https://docs.scipy.org/doc/scipy/reference/</a>)</p>
</div>
<span class="comment-copy">This might be a question about basics but I have never met this kind of expression before data[i * stride + x * bpp: i * stride + (x + width) * bpp)] What is that " : " doing there? Is this a dictionary? I can't wrap my head around it</span>
<span class="comment-copy">It is a simple sequence with a numeric using a numeric slice index - the expression is just computing the address (in bytes) of the first pixel of the rectangle at an image line (the one at line (x, i)  and the last pixel (the one at (x + width, i)  ) . If you have never seem Python slices indexes, you'td better learn them: <a href="https://docs.python.org/3/tutorial/introduction.html#lists" rel="nofollow noreferrer">docs.python.org/3/tutorial/introduction.html#lists</a></span>
<span class="comment-copy">Oh I see, I wasn't familiar with Python's slicing operator. Now everything makes sense. Thank you!</span>
<span class="comment-copy">Anyway,  if you have any serious work to be done on image-pixels, I'd suggest going the numpy/scipy way.</span>
