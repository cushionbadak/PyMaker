<div class="post-text" itemprop="text">
<p>Consider the following code:</p>
<pre><code>import functools
import inspect

class Foo:
    def foo_fn(self, hello, world):
        print(hello, world)

class FooWrapper:
    def __init__(self, foo_class):
        self._foo = foo_class()
        for key, value in inspect.getmembers(self._foo):
            if inspect.ismethod(value):
                bound_fn = functools.partial(self.foo_wrapper_fn, self, value)
                setattr(self._foo, key, bound_fn)

    def foo_wrapper_fn(self_wrapper, self_foo, bound_method, hello, world):
        bound_method(hello, world)

def make_foo(Foo):
    wrapper = FooWrapper(Foo)
    return wrapper._foo
a = make_foo(Foo)
a.foo_fn("hello", "world")
</code></pre>
<ol>
<li><p>How does this ordering of the function <code>foo_wrapper_fn()</code> parameters like <code>(self_wrapper, self_foo, bound_method, hello, world)</code> come to be?
and not like so: <code>self_wrapper, bound_fn, self_foo, hello, world</code>, since <code>self_wrapper</code> and <code>bound_fn</code> were partially bound first? </p></li>
<li><p>Is it ok for the return of <code>functool.partial</code> <em>(and not <code>functool.partialmethod</code>)</em> to be called by an object (<code>a.foo_fn</code>)?</p></li>
<li><p>If I replace it with <code>functools.partialmethod(self.foo_wrapper_fn, self, value)</code>  why does this error come up?</p>
<pre><code>TypeError: 'partialmethod' object is not callable
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Both first arguments are <em>the same object</em>. <code>self.foo_wrapper_fn</code> is bound to the <code>FooWrapper</code> instance (as it was looked up on <code>self</code>), and then you tell the partial to pass in <code>self</code> <em>again</em>. So really, the signature is just a double confusion, and you can leave off the second argument and simply not pass in a second, explicit <code>self</code>.</p>
<p>Note that you are never passing in <code>self._foo</code> anywhere.</p>
<p>The order is simply set by:</p>
<ol>
<li>The bound method, passing in the bound <code>FooWrapper()</code> instance.</li>
<li>Whatever positional arguments you passed into the <code>partial()</code> call, so 
<code>self, value</code>. That's the <code>FooWrapper()</code> instance <em>again</em>, and the bound <code>Foo</code> method.</li>
<li>any additional arguments you pass in when calling the <code>partial()</code> object.</li>
</ol>
<p>You <em>have</em> to use a <code>partial()</code> object here, not a <code>partialmethod()</code>, because you are setting attributes on an instance. A <code>partialmethod()</code> is intended to be used as a descriptor object, e.g. an attribute on the class.</p>
<p>This is why you get your <code>TypeError</code> too; the <code>partialmethod()</code> was never bound. If it was bound (it's <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer"><code>__get__</code> method</a> was called, passing in the instance to bind to), then a proper callable object would have been returned.</p>
<p>See the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">Python <em>Descriptor Howto</em></a> on how descriptors work (bound methods are created via that protocol, and <code>partialmethod</code> objects, as well as <code>property</code>, <code>classmethod</code> and <code>staticmethod</code> objects, all build on the same principles).</p>
<p>So you could simplify your code with:</p>
<pre><code>class FooWrapper:
    def __init__(self, foo_class):
        self._foo = foo_class()
        for key, value in inspect.getmembers(self._foo):
            if inspect.ismethod(value):
                bound_fn = functools.partial(self.foo_wrapper_fn, value)
                setattr(self._foo, key, bound_fn)

    def foo_wrapper_fn(self, bound_method, hello, world):
        bound_method(hello, world)
</code></pre>
<p>If you must have access to the original <code>Foo()</code> instance, use the <code>__self__</code> attribute on the <code>bound_method</code> variable.</p>
</div>
<span class="comment-copy">No he meant that - he is passing in Foo as a parameter to the constructor.</span>
<span class="comment-copy">@DannyStaple: check, indeed.</span>
<span class="comment-copy">@Danny Staple: passing the class is unrequired noise here. in the actual production code, i use a com wrapper and i can only instantiate later in another thread context where the com functions are supposed to run.</span>
