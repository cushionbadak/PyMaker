<div class="post-text" itemprop="text">
<p>Now, I want to make it clear that I do not want to include the variable <code>b</code> as an argument of the function <code>g</code>. Is there any other way I could go about rewriting this code, given that g is called recursively? Even mentioning b = 0 and calling it as a global does not seem to help with the reference assignment error.</p>
<pre><code>global b
b = 0
def g(x):
    if b &lt; x:
        for i in range(10):
            if u == i:
                b += 1
                g(x)    #g is called recursively
for u in range(20):
    b = 5
    g(7)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code># that is from MSeifert(voted is correct), @Chalid
b = 0
first = []
second = []
def g(x):
    global b  # So python knows you use the global variable!
    first.append(b)
    if b &lt; x:
        for i in range(10):
            if u == i:
                b += 1
                g(x)

for u in range(20):
    b = 5
    g(7)


# my solution is without any global variable
# and the result matching the expectation

def g(x,b):
    second.append(b)
    if b &lt; x:
        for i in range(10):
            if u == i:
                b += 1
                g(x,b)    #g is called recursively
b = 5
for u in range(20):
  g(7,b)

print len(first), len(second)
print first
print second

40 40
[5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
[5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 6, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>global</code> is used when you explicitly want to use and update a <code>global</code> variable. So you need to use <code>global b</code> inside your function instead of outside:</p>
<pre><code>b = 0

def g(x):
    global b  # So python knows you use the global variable!
    if b &lt; x:
        for i in range(10):
            if u == i:
                b += 1
                g(x)

for u in range(20):
    b = 5
    g(7)
</code></pre>
<p>Because you use <code>b += 1</code> inside your <code>g</code> function you need to declare <code>b</code> as <code>global</code>. Otherwise you get a <code>UnboundLocalError</code>:</p>
<blockquote>
<p>UnboundLocalError: local variable 'b' referenced before assignment</p>
</blockquote>
<p>See also the <a href="https://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="nofollow noreferrer">Python FAQ</a>:</p>
<blockquote>
<p><strong>What are the rules for local and global variables in Python?</strong></p>
<p>In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a value anywhere within the function’s body, it’s assumed to be a local unless explicitly declared as global.</p>
<p>Though a bit surprising at first, a moment’s consideration explains this. On one hand, requiring <code>global</code> for assigned variables provides a bar against unintended side-effects. On the other hand, if <code>global</code> was required for all <code>global</code> references, you’d be using <code>global</code> all the time. You’d have to declare as <code>global</code> every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the <code>global</code> declaration for identifying side-effects.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>It might make people's hair stand on end but you could add <code>b</code> as an attribute to <code>g</code>. </p>
<pre><code>def g(x):
    If g.b &gt; x:
        ...

g.b = 5
....
</code></pre>
</div>
<span class="comment-copy">But then every time I run the function <code>g</code>, I'll have to give it some value in place of b right? which might actually mess up the code</span>
<span class="comment-copy">if b is relevant for g yes, i mean you increasing b by one, than you are calling g with the last result of b</span>
