<div class="post-text" itemprop="text">
<p>Basically I have a list of OrderedDicts;</p>
<pre><code>lst = [
    OrderedDict([('type', 'character'), ('letter', 'a')]),
    OrderedDict([('type', 'character'), ('letter', 'b')]),
    OrderedDict([('type', 'character'), ('letter', 'c')]),
    OrderedDict([('type', 'character'), ('letter', 'd')]),
    OrderedDict([('type', 'integer'), ('number', '1')]),
    OrderedDict([('type', 'integer'), ('number', '2')]),
    OrderedDict([('type', 'integer'), ('number', '3')]),
    OrderedDict([('type', 'integer'), ('number', '4')])
]
</code></pre>
<p>I want to change that into</p>
<pre><code>lst = [
    OrderedDict([('type', 'character'), ('letter', ['a', 'b', 'c', 'd'])]),
    OrderedDict([('type', 'integer'), ('number', ['1', '2', '3', '4'])])
]
</code></pre>
<p>I thought of having a list of type values ['character', 'integer'] and go through all the dictionaries to try grouping the letter/number in a list, then creating a new list of dictionaries to be filled in with the data I got.  Not sure whether this is the best approach though</p>
<p>Appreciate the help</p>
</div>
<div class="post-text" itemprop="text">
<p>Considering your list of dictionaries is already <em>sorted</em>, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> directly. A mapping between items and their related strings in the dictionary helps avoid calling <code>d.items</code> multiple times and makes the code extensible to new types:</p>
<pre><code>from collections import OrderedDict
from itertools import groupby

_map = {'character': 'letter', 'integer': 'number'}

l = [OrderedDict([('type', k), (_map[k], [d[_map[k]] for d in g])]) for k, g in groupby(lst, lambda x: x['type'])]
print(l)
# [OrderedDict([('type', 'character'), ('letter', ['a', 'b', 'c', 'd'])]), OrderedDict([('type', 'integer'), ('number', ['1', '2', '3', '4'])])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That should work:</p>
<pre><code>lst = [OrderedDict([('type', t), (kind, [d.items()[1][1] for d in lst if d['type'] == t])]) for (t, kind) in set((d['type'], d.items()[1][0]) for d in lst)]
</code></pre>
<p>outputs:</p>
<pre><code>[OrderedDict([('type', 'integer'), ('number', ['1', '2', '3', '4'])]), OrderedDict([('type', 'character'), ('letter', ['a', 'b', 'c', 'd'])])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For an answer with less list comprehension (which helps with
readability sometimes.) See:</p>
<pre><code>from collections import OrderedDict

lst = [
    OrderedDict([('type', 'character'), ('letter', 'a')]),
    OrderedDict([('type', 'character'), ('letter', 'b')]),
    OrderedDict([('type', 'character'), ('letter', 'c')]),
    OrderedDict([('type', 'character'), ('letter', 'd')]),
    OrderedDict([('type', 'integer'), ('number', '1')]),
    OrderedDict([('type', 'integer'), ('number', '2')]),
    OrderedDict([('type', 'integer'), ('number', '3')]),
    OrderedDict([('type', 'integer'), ('number', '4')])
]

types_found = []  # using a list to maintain original order
types_dict = {}   # using a dict for speed and storage

for entry in lst:
    t = entry.get("type", "unknown")
    if t not in types_dict:
        types_found.append(t)
        types_dict[t] = OrderedDict([("type", t)])
    for k, v in entry.items():
        if k != "type":
            types_dict[t].setdefault(k, []).append(v)

new_list = [types_dict[t] for t in types_found]
# okay, so I did use one list comprehension, but it's a simple one :)
</code></pre>
<p>I'm assuming, for the above, that the following is important:</p>
<ul>
<li>You might have other 'type' entries than 'character' or 'integer'; so you want an open-ended solution.</li>
<li>You want the original order found in <code>lst</code> to be maintained.</li>
<li>Your production code might have missing keys; or more keys than expected.</li>
</ul>
<p>This was written with Python 3.5. For some older versions, you might have to substitute '.items()' with '.iteritems()'.</p>
</div>
<span class="comment-copy">In retrospect, if had set <code>types_dict</code> to an OrderedDict() rather than a plain dictionary, I could have removed the <code>types_found</code> tracking for maintaining order. Ironic in a sense.</span>
