<div class="post-text" itemprop="text">
<p>I am new in Python programming. I am stuck at one point. Let's say I have string "hello-world". I want to replace all the characters of this string with "*" except first &amp; last. so the result will be <code>"h***-****d"</code>.</p>
<p>One way to do this as below:</p>
<pre><code>In [1]: s = "hello-world"

In [2]: s[0] + "*"*(len(s)-2) + s[-1]
Out[2]: 'h*********d'
</code></pre>
<p>If I want to replace all characters with "*" except first &amp; last 2 characters</p>
<pre><code>In [3]: s[:2] + "*"*(len(s)-4) + s[-2:]
Out[3]: 'he*******ld'
</code></pre>
<p>Is there any pretty way to handle these type of problems. Any help would be appreciated. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think what you want to do is this:</p>
<pre><code>def obscure(string, n):
    characters = list(string)
    characters[n:-n] = '*' * len(characters[n:-n])
    obscured = ''.join(characters)
    return obscured
</code></pre>
<p>Turn the string into a list of characters. Replace the ones you want to obscure. Then join the list back into a string.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>str.join</code> (and the <code>string</code> module to check against letters):</p>
<pre><code>s[0] + ''.join(['*' if i in string.ascii_letters else i
                for i in s[1:-1]]) + s[-1]
</code></pre>
<p>Since you said you wanted <code>h****-****d</code> where the hyphen isn't replaced, you would need to test whether the characters are letters or not. You could change <code>string.ascii_letters</code> to:</p>
<pre><code>chars = 'abcdefghijklmnopqrstuvwxyz'
chars = chars + chars.upper() + '0123456789'  # + 'some_other_chars'
</code></pre>
<p>...if you want to include other characters like numbers or punctuation. Or you can write out the letters you want to replace manually. </p>
<p>You may also want to perform a check to see whether the string is 3 characters or more so that no errors are raised. </p>
</div>
<div class="post-text" itemprop="text">
<p>You could define a function to not repeat yourself:</p>
<pre><code>def replace(s, n):
    if len(s) &gt; n*2:
        return s[:n] + '*'*(len(s)-n*2) + s[-n:]
    return s

print(replace('hello-world', 1))  # h*********d
print(replace('hello-world', 2))  # he*******ld
print(replace('hello', 2))  # he*lo
print(replace('hello', 3))  # hello
</code></pre>
<p>You can also use some kind of string formatting instead of concatenation (which should be more efficient), e.g. <a href="https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals" rel="nofollow noreferrer">f-strings</a> available in 3.6+:</p>
<pre><code>def replace(s, n):
    if len(s) &gt; n*2:
        return f"{ s[:n] }{ '*'*(len(s)-n*2) }{ s[-n:] }"
    return s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this.</p>
<pre><code>s="hello-world"

for i in s[1:-1]:
   if i.isalpha():
     s=s.replace(i,"*")
</code></pre>
</div>
<span class="comment-copy">That's about as pretty as it's going to get</span>
<span class="comment-copy">Seems like your code works and you understand the logic- you just need to turn it into a function.</span>
<span class="comment-copy">"Pretty" is a subjective term. Your code works, and it's reasonably performant. Embed it in a method with a reasonable name and you'll be fine.</span>
<span class="comment-copy">Is your expected output <code>h****-****d</code> or <code>h*********d</code>? (The first one leaves the hyphen as it is)</span>
<span class="comment-copy">You have the right idea, but you probably meant <code>list(string)</code> instead of <code>string.split()</code>, and you need the length of the <code>'*'</code> to match the length of what they're replacing in the slice assignment.</span>
<span class="comment-copy"><code>characters[n:-n] = '*'</code> replaces the entire slice with a single <code>*</code>.</span>
<span class="comment-copy">Thanks, you're right. I'll fix the answer.</span>
<span class="comment-copy">With what @JohnGordon  says, you'd need to replace it with <code>'*' * len(characters[n:-n])</code></span>
<span class="comment-copy">Two downvotes without a single comment?</span>
<span class="comment-copy">There's a few things worth negging for here:  1. the slicing can corrupt data (for example <code>s='hello'</code>, <code>n=3</code>), the code from <a href="https://stackoverflow.com/a/52409668/674039">this other</a> answer gives a better result there.  2. binding a lambda to a name is dumb, just use a <code>def</code>.  3. on a stylistic note, this is too much logic to cram into an f-string.</span>
<span class="comment-copy">1. fixed. 2. binding a lambda to a name is totally fine if a function just evaluates an expression. Even Raymond Hettinger <a href="https://pybay.com/site_media/slides/raymond2018-keynote/doctest.html" rel="nofollow noreferrer">does</a> it ;) 3. That's pretty subjective.</span>
<span class="comment-copy">Well, downvotes are also pretty subjective.</span>
<span class="comment-copy">OK but what if the string is <code>"letâ€™s test this</code>"?</span>
<span class="comment-copy">Now, It will accept any string and replace every alphabet with "*" and "-" is not replaced.</span>
<span class="comment-copy">Can you please check now @konrad Rudolph</span>
<span class="comment-copy"><code>str.replace</code> doesn't do what you think it does. But even if it did this would be <i>really</i> inefficient for long strings, since it needs to copy the whole string for each character.</span>
<span class="comment-copy">I will check more effective solution. Thanks @KonradRudolph</span>
