<div class="post-text" itemprop="text">
<p>I am writing a kind of 'universal' json decoder that would convert everything it can using a default json encoder plus sets, and everything else it will convert using <code>str()</code> - which is a bit stupid, but it will allow to just work silently and let users know what kind of data there was initially. </p>
<p>So with the small amendment the following code is taken from <a href="https://stackoverflow.com/a/8230505/1334752">here</a>:</p>
<pre><code>import json
class SetEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        try:
            return json.JSONEncoder.default(self, obj)
        except TypeError:
            return str(obj)
</code></pre>
<p>Then if I try to convert a function using this encoder it will return something like:</p>
<pre><code>'&lt;function a at 0x10ddd8f28&gt;'
</code></pre>
<p>Which is, again a bit stupid but totally fine for my purposes. </p>
<p><strong>The question is:</strong> what if <code>str()</code> fails to convert anything provided as an input argument? What kind of error will be triggered? I looked through <code>str</code> source and didn't get when exactly (if at all?) it captures the possible conversion errors. Or it is assumed to convert any kind of input provided?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can check out the documentation of <a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow noreferrer"><code>str</code></a>:</p>
<blockquote>
<p>If neither encoding nor errors is given, <code>str(object)</code> returns <code>object.__str__()</code>, which is the “informal” or nicely printable string representation of object. For string objects, this is the string itself. If object does not have a <code>__str__()</code> method, then <code>str()</code> falls back to returning <code>repr(object)</code>.</p>
</blockquote>
<p>That said. Besides situations like not being able allocate any more memory (<code>MemoryError</code>) which would not be <code>str</code> conversion specific, the only way I can see this failing is if someone overloaded <code>__str__</code> (or <code>__repr__</code> if there is no <code>__str__</code>) and made it to, for instance:</p>
<pre><code>class C:
    def __str__(self):
        msg = "'{}' instance is not meant to be represented as str."
        raise ValueError(msg.format(self.__class__))
</code></pre>
<p>Which would result in:</p>
<pre><code>&gt;&gt;&gt; c = C()
&gt;&gt;&gt; str(c)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 4, in __str__
ValueError: '&lt;class '__main__.C'&gt;' instance is not meant to be represented as str.
</code></pre>
<p>That said though: There isn't really a generic answer to your question, because it could raise anything anyone programmed it to do.</p>
<p>EDIT: All of above pertains to simple <code>str</code> calls with just an object passed as seen in your example. If you attempt decoding the incoming object by specifying <code>encoding</code> and/or <code>errors</code>. You could run into <code>TypeError</code> for anything other then <a href="https://docs.python.org/3/glossary.html#term-bytes-like-object" rel="nofollow noreferrer">bytes-like</a> input or see decoding related failures: <code>UnicodeDecodeError</code>. This behavior of <code>str</code> is described in the following paragraph of its <a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>If at least one of encoding or errors is given, object should be a bytes-like object (e.g. <code>bytes</code> or <code>bytearray</code>). In this case, if object is a <code>bytes</code> (or <code>bytearray</code>) object, then <code>str(bytes, encoding, errors)</code> is equivalent to <code>bytes.decode(encoding, errors)</code>. Otherwise, the bytes object underlying the buffer object is obtained before calling <code>bytes.decode()</code>.</p>
</blockquote>
</div>
