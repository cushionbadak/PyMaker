<div class="post-text" itemprop="text">
<p>So I'm writing an interface framework that allow people to write a collection of commands. </p>
<p>What I am trying to do here is that, for each subclass of <code>Base</code>, find all of its methods that has a description, then collect all those functions and generate a collective description out of them (plus something else, but its not relevant to this question)</p>
<p>Here is MCVE</p>
<pre><code>import types
class Meta(type):

    def __init__(cls, *args, **kwargs):
        cls._interfaces = {}
        super().__init__(*args, **kwargs)

    def __call__(cls, id, *args, **kwargs):
        if id in cls._interfaces:
            return cls._interfaces[id]
        obj = cls.__new__(cls, *args, **kwargs)
        obj.__init__(*args, **kwargs)
        cls._interfaces[id] = obj
        return obj

class Base(metaclass=Meta):

    @property
    def descriptions(self): # this doesn't work. It gives RecursionError
        res=''
        for name in dir(self):
            attr=getattr(self,name)
            if isinstance(attr, types.FunctionType) and hasattr(attr, 'description'):
                res += f'{name}: {attr.description}\n'
        return res

    @property
    def descriptions(self):
        res=''
        for cls in self.__class__.__mro__:
            for name,attr in cls.__dict__.items():
                if isinstance(attr, types.FunctionType) and hasattr(attr, 'description'):
                    res += f'{name}: {attr.description}\n'
        return res

class A(Base):

    def a(self): pass
    a.description='A.a'

    def b(self): pass
    b.description='A.b'

class B(A):
    def c(self): pass
    c.description='B.c'

    def d(self): pass
    d.description='B.d'

print(B(0).descriptions)
</code></pre>
<p>Now the problem with my current method is that it doesn't detect method overrides. Suppose I add this snippet into the definition of class <code>B</code></p>
<pre><code>def a(self): pass
a.description='B.a'
</code></pre>
<p>Now the generated descriptions will be completely wrong. What I want is that when a method got overridden, it's collected description also got overridden. So the description should always point to the method that Python would normally resolve to if people do it with usual ways (e.g. <code>B.a.description</code>)</p>
<p>So the expected output would then change to </p>
<pre><code>a: B.a
b: A.b
c: B.c
d: B.d
</code></pre>
<p>I suppose I can make a special case out of word <code>descriptions</code> and fix the first <code>description</code> method. </p>
<p>But is there a more elegant and Pythonic way to achieve that? To be honest, <code>self.__class__.__mro__</code> looks pretty horrible. </p>
</div>
<div class="post-text" itemprop="text">
<p>When you iterate over <code>self.__class__.__mro__</code>, you are iterating over the <em>resolution order</em>, which would be <code>&lt;class '__main__.B'&gt; &lt;class '__main__.A'&gt; &lt;class '__main__.Base'&gt; &lt;class 'object'&gt;</code> in your example.</p>
<p>As a result, you are looking at the <code>description</code> properties of each of these classes subsequently. When you declare <code>a.description = 'B.a'</code> inside class <code>B</code>, you are not actually overriding it in the parent class <code>A</code>, you are just overriding it in the child class <code>B</code>.</p>
<p>So, instead, you could do something like this:</p>
<pre><code>import inspect


class Base(metaclass=Meta):
    def descriptions(self):
        res = ''
        for mtd in inspect.getmembers(self, predicate=inspect.ismethod):
            if hasattr(mtd[1], 'description'):
                res += f'{mtd[0]}: {mtd[1].description}\n'

        return res
</code></pre>
<p>That way, you are <em>only</em> inspecting the actual child and not its parents. However, <code>Base.descriptions</code> cannot be a property in this case, because properties get evaluated upon declaration, which would make <code>inspect.getmembers</code> keep inspecting itself infinitely long.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you can fix your first implementation of <code>descriptions</code>, which may be easier than messing with the MRO. The reason you are getting a <code>RecursionError</code> is that <code>"descriptions"</code> will show up in the list of attribute names. When you do <code>getattr(self, name)</code> on it, it recursively calls itself, since it's a property. You can easily avoid that by only looking up the name if it is not <code>"descriptions"</code>. You also have an issue that when you lookup a method by name on an instance, you'll get a bound method object, rather than a function. Perhaps you should be calling <code>getattr</code> on <code>type(self)</code> instead of on <code>self</code>? That would look something like this:</p>
<pre><code>@property
def descriptions(self):
    res=''
    for name in dir(self):
        if name != "descriptions":                    # avoid recursion!
            attr = getattr(type(self), name, None)    # lookup name on class object
            if isinstance(attr, types.FunctionType) and hasattr(attr, 'description'):
                res += f'{name}: {attr.description}\n'
    return res
</code></pre>
<p>Another way to avoid the issue would be to get rid of the <code>property</code> decorator, and leave <code>descriptions</code> as a normal method. That way looking it up won't cause any recursion, it will just get a bound method.</p>
</div>
<div class="post-text" itemprop="text">
<p>We're not quite sure exactly what behavior you would like to have happen, but the <code>inspect</code> module almost certainly has what you need. E.g.</p>
<pre><code>inspect.getmro(type(self))
inspect.getclasstree(inspect.getmro(type(self)))
</code></pre>
</div>
<span class="comment-copy">What do you <i>want</i> to happen with overrides?</span>
<span class="comment-copy">If I'm guessing right, then you should go with your "this doesn't work" version, but examine <code>type(self)</code> instead of <code>self</code>. Without you telling us what you want, it's hard to be sure, though.</span>
<span class="comment-copy">(Or perhaps better, put the property on the <i>metaclass</i> and access it through classes instead of instances.)</span>
<span class="comment-copy">@user2357112 What I want is that when a method got overridden, it's collected description also got overridden. So the description should always point to the method that Python would normally resolve to if people do it with usual ways (e.g. <code>B.a.description</code>).</span>
<span class="comment-copy"><code>__mro__</code> isn't an implementation detail; it's <a href="https://docs.python.org/3/library/stdtypes.html#class.__mro__" rel="nofollow noreferrer">public and documented</a>. <code>inspect.getmro</code> exists mostly because it was useful for compatibility with old-style classes back when those were a thing.</span>
<span class="comment-copy">I was remembering <a href="https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers" rel="nofollow noreferrer">this documentation</a> poorly. Forgot about the "that does not follow explicitly documented use" line.</span>
