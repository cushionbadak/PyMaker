<div class="post-text" itemprop="text">
<p>As you may know, <a href="https://stackoverflow.com/questions/926574/why-does-defining-getitem-on-a-class-make-it-iterable-in-python">implementing a <code>__getitem__</code> method makes a class iterable</a>:</p>
<pre><code>class IterableDemo:
    def __getitem__(self, index):
        if index &gt; 3:
            raise IndexError

        return index

demo = IterableDemo()
print(demo[2])  # 2
print(list(demo))  # [0, 1, 2, 3]
print(hasattr(demo, '__iter__'))  # False
</code></pre>
<p>However, this doesn't hold true for regex match objects:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; match = re.match('(ab)c', 'abc')
&gt;&gt;&gt; match[0]
'abc'
&gt;&gt;&gt; match[1]
'ab'
&gt;&gt;&gt; list(match)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: '_sre.SRE_Match' object is not iterable
</code></pre>
<p>It's worth noting that this exception isn't thrown in the <code>__iter__</code> method, because that method isn't even implemented:</p>
<pre><code>&gt;&gt;&gt; hasattr(match, '__iter__')
False
</code></pre>
<p>So, how is it possible to implement <code>__getitem__</code> without making the class iterable?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are lies, damned lies and then there is Python documentation.</p>
<p>Having <code>__getitem__</code> for a class implemented in <em>C</em> is not enough for it to be iterable. That is because there are actually <em>2</em> places in the <code>PyTypeObject</code> where the <code>__getitem__</code> can be mapped to: <a href="https://docs.python.org/3/c-api/typeobj.html#c.tp_as_sequence" rel="noreferrer"><code>tp_as_sequence</code></a> and <a href="https://docs.python.org/3/c-api/typeobj.html#c.tp_as_mapping" rel="noreferrer"><code>tp_as_mapping</code></a>. Both have a slot for <code>__getitem__</code> (<a href="https://docs.python.org/3/c-api/typeobj.html#c.PySequenceMethods.sq_item" rel="noreferrer">[1]</a>, <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyMappingMethods.mp_subscript" rel="noreferrer">[2]</a>).</p>
<p>Looking at the source of the <a href="https://github.com/python/cpython/blob/7f0d59f3a83cf1a98398b8e5bdfb97c7a71216bd/Modules/_sre.c#L2687" rel="noreferrer"><code>SRE_Match</code></a>, <code>tp_as_sequence</code> is initialized to <code>NULL</code> whereas <code>tp_as_mapping</code> is defined.</p>
<p>The <code>iter()</code> built-in function, if called with one argument, will call the <a href="https://github.com/python/cpython/blob/7f0d59f3a83cf1a98398b8e5bdfb97c7a71216bd/Objects/abstract.c#L2541" rel="noreferrer"><code>PyObject_GetIter</code></a>, which has the following code:</p>
<pre><code>f = t-&gt;tp_iter;
if (f == NULL) {
    if (PySequence_Check(o))
        return PySeqIter_New(o);
    return type_error("'%.200s' object is not iterable", o);
}
</code></pre>
<p>It first checks the <code>tp_iter</code> slot (obviously <code>NULL</code> for <code>_SRE_Match</code> objects); and failing that, then <em>if</em> <code>PySequence_Check</code> returns true, a new sequence iterator, else a <code>TypeError</code> is raised.</p>
<p><a href="https://github.com/python/cpython/blob/7f0d59f3a83cf1a98398b8e5bdfb97c7a71216bd/Objects/abstract.c#L1508" rel="noreferrer"><code>PySequenceCheck</code></a> first checks if the object is a <em><code>dict</code> or a <code>dict</code> subclass</em> - and returns false in that case. Otherwise it returns the value of </p>
<pre><code>s-&gt;ob_type-&gt;tp_as_sequence &amp;&amp;
    s-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_item != NULL;
</code></pre>
<p>and since <code>s-&gt;ob_type-&gt;tp_as_sequence</code> was <code>NULL</code> for a <code>_SRE_Match</code> instance, 0 will be returned, and <code>PyObject_GetIter</code> raises <code>TypeError: '_sre.SRE_Match' object is not iterable</code>.</p>
</div>
<span class="comment-copy">I can't even seem to subscript <code>match</code>...</span>
<span class="comment-copy">@Sweeper <code>Match.__getitem__</code> was added in Python 3.6 <a href="https://docs.python.org/3/library/re.html#re.Match.__getitem__" rel="nofollow noreferrer">docs.python.org/3/library/re.html#re.Match.__getitem__</a></span>
<span class="comment-copy">@DeepSpace Ah... I was using 3.5.</span>
<span class="comment-copy">@PedroLobito But that has no explanation?</span>
<span class="comment-copy">@PedroLobito That's a completely different question, isn't it? My match objects <b>do</b> have a <code>__getitem__</code> method...</span>
