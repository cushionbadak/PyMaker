<div class="post-text" itemprop="text">
<p><strong>EDIT</strong>: Clarifying the allowed character set based on comments</p>
<p>The allowed characters from ASCII character set are <code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, <code>-</code>, <code>_</code>, <code>.</code>, <code>/</code>. Any other character from ASCII set should not be allowed. </p>
<p>Unicode characters apart from the disallowed ASCII set defined above are also allowed.</p>
<p><strong>End of Edit</strong></p>
<p>I am processing some text data where the only allowed ASCII characters are <code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, and <code>-</code>,<code>_</code>,<code>.</code>,<code>/</code>. Apart from these Unicode characters are also allowed. I need to make sure that the incoming data contains only these set of characters.</p>
<p>Checking for the allowed ASCII characters is easy:</p>
<pre><code>from string import ascii_letters, digits
VALID_CHARSET= set(ascii_letters + digits + "-_./")

def is_valid_string(string):
    for c in string:
        if c not in VALID_CHARSET:
            return False
    return True
</code></pre>
<p>But I am wondering about how to allow unicode characters apart from the above. I guess in Python-2.7 I could add a check like so:</p>
<pre><code>if isinstance(c, unicode)
    return True
if c not in VALID_CHARSET:
    return False
</code></pre>
<p>But strings in Python-3 are Unicode by default and there is no separate <code>unicode</code> type, so this would not work there. Any cleaner way of doing this which works in both the versions of Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>As I read the question, you want to allow any non-ASCII character, plus the whitelisted ASCII characters. Since making a set of all valid characters is impractical (it would have over a million entries), the simplest solution is to make a set of invalid characters and verify that your strings contain none of them:</p>
<pre><code>VALID_CHARSET = frozenset(ascii_letters + digits + "-_./")
INVALID_CHARSET = frozenset(map(chr, range(128))) - VALID_CHARSET
</code></pre>
<p>Once you have that, <code>is_valid_string</code> becomes trivial:</p>
<pre><code>def is_valid_string(string):
    return INVALID_CHARSET.isdisjoint(string)
</code></pre>
<p>If you felt like it, you could even avoid defining the Python level function at all, saving a little call overhead (at the expense of not being able to define your own docstring) by just making an alias to the bound <code>isdisjoint</code> method:</p>
<pre><code>is_valid_string = INVALID_CHARSET.isdisjoint
</code></pre>
<p>You're not going to get any faster than that; <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.isdisjoint" rel="nofollow noreferrer"><code>set</code>/<code>frozenset</code>'s <code>isdisjoint</code> method</a> pushes all the work to the C layer (no bytecode processing overhead per character), short-circuits (as soon as an invalid character is seen, it returns immediately), and performs each lookup in ~<code>O(1)</code> (so testing a string is <code>O(n)</code> in the length of the string).</p>
<p>If you aren't concerned with <em>checking</em>, but rather, want to strip out invalid characters, you'd want to use <code>str.translate</code>/<code>unicode.translate</code> to bulk delete the invalid characters, but given the API differs between the types (Py3 <code>str</code> and Py2 <code>unicode</code> use one form, Py3 <code>bytes</code> and Py2 <code>str</code> another), you'd have to go to some trouble to make it work on Py2 and Py3 on the same code base.</p>
</div>
<span class="comment-copy"><i>"Apart from these Unicode characters are also allowed</i>" – Since Unicode encompasses <i>every possible character</i>, that is… rather broad.</span>
<span class="comment-copy">Considering Unicode includes all of ASCII (at the same code points), I'm not clear on what you're trying to accomplish. Do you want to <i>eliminate</i> only characters that are ASCII but not in your whitelist?</span>
<span class="comment-copy">I made an attempt to clarify it</span>
<span class="comment-copy">The easiest approach is probably to make a <code>set</code> of <i>forbidden</i> characters for testing, not <i>valid</i> ones (creating the set of valid ones only to aid with building the invalid set). Define <code>INVALID_CHARSET = frozenset(map(chr, range(128))) - VALID_CHARSET</code>, then your <code>is_valid_string</code> function can simplify to <code>return INVALID_CHARSET.isdisjoint(string)</code> (<code>set</code>/<code>frozenset</code>'s <code>isdisjoint</code> method is by far the most efficient means of checking for the presence of a forbidden character, as it short-circuits, makes no temporaries, and runs entirely at the C layer when the values are built-in types).</span>
<span class="comment-copy">@ShadowRanger Thanks! That looks like it will work. I would accept it if the question was open. Also, thanks for the tip on isdisjoint, wasn't aware of that.</span>
<span class="comment-copy">Thanks. Really appreciate the tips on performance side of it.</span>
