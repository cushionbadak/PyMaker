<div class="post-text" itemprop="text">
<p>Any advice on how to repeat a certain value in an array in Python?
For instance, I want to repeat only 2 in <code>array_a</code>:</p>
<pre><code>array_a = [1, 2, 1, 2, 1, 1, 2]
</code></pre>
<p>Wanted outcome is: I repeat each <code>2</code> and leave the <code>1</code>:</p>
<pre><code>array_a = [1, 2, 2, 1, 2, 2, 1, 1, 2, 2]  # only the `2` should be repeated
</code></pre>
<p>I tried <code>numpy</code> and I could duplicate the <em>entire array</em> but not a certain value.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're interested in a numpy solution, you can repeat an array on itself using <code>np.repeat</code>.</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.repeat(array_a, array_a)
array([1, 2, 2, 1, 2, 2, 1, 1, 2, 2])
</code></pre>
<p>This works only if you haves 1s and 2s in your data. For a generic solution, consider</p>
<pre><code>&gt;&gt;&gt; n_repeats = 2
&gt;&gt;&gt; temp = np.where(np.array(array_a) == 2, n_repeats, 1)
&gt;&gt;&gt; np.repeat(array_a, temp)
array([1, 2, 2, 1, 2, 2, 1, 1, 2, 2])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>May be you can use <code>dictionary</code> to each unique element and number of times it needs to be repeated. Then using <code>list comprehension</code> to create array:</p>
<pre><code>array_a = [1,2,1,2,1,1,2]

repeat_times = {1:1, 2:2} # 1 is 1 time and 2 is repeated two times

result = [i for i in array_a for j in range(repeat_times[i])]
print(result) 
</code></pre>
<p>Output:</p>
<pre><code>[1, 2, 2, 1, 2, 2, 1, 1, 2, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This seems a good use-case for a <a href="https://wiki.python.org/moin/Generators" rel="nofollow noreferrer">generator</a>:</p>
<pre><code>&gt;&gt;&gt; def repeater(iterable, repeat_map):
...     for value in iterable:
...         for i in range(repeat_map.get(value, 1)):
...             yield value
...             
&gt;&gt;&gt; array_a = [1,2,1,2,1,1,2]
&gt;&gt;&gt; list(repeater(array_a, repeat_map={2: 2}))
[1, 2, 2, 1, 2, 2, 1, 1, 2, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you convert this to a list, you can loop through it, and if it matches your criteria, add an extra version. For example:</p>
<pre><code>a = [1,2,1,2,1,1,2]
long_a = []
for x in a:
    long_a.append(x)
    if x == 2:
       long_a.append(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>loop over the array (a 'list' in python)</p></li>
<li><p>find the the number</p></li>
<li><p>get the position of the matched number in the array</p></li>
<li><p>insert another number after each matched position</p></li>
</ol>
<p><a href="https://docs.python.org/3/reference/compound_stmts.html#for" rel="nofollow noreferrer">https://docs.python.org/3/reference/compound_stmts.html#for</a></p>
<p><a href="https://docs.python.org/2/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer">https://docs.python.org/2/tutorial/datastructures.html#more-on-lists</a></p>
</div>
<div class="post-text" itemprop="text">
<p>An attempt using comprehensions.</p>
<pre><code>array = [1, 2, 1, 2, 1, 1, 2]

element_to_repeat = 2

result = [
    repeats_element
    for repeats in
        ((element,)*2 if element == element_to_repeat else (element,) for element in array)
    for repeats_element in repeats
]
</code></pre>
<p>It basically spits out tuples, "repeats", which contain the element once if it's not the element to repeat, or twice if it's the element to repeat. Then all of the elements of these "repeats" tuples are flattened into the answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using a generator.</p>
<pre><code>array = [1, 2, 1, 2, 1, 1, 2]

element_to_repeat = 2

def add_repeats(array, element_to_repeat):
    for element in array:
        if element == element_to_repeat:
            yield element
            yield element
        else:
            yield element

result = list(add_repeats(array, element_to_repeat))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a handy one-liner using <code>itertools</code> and list comprehension with if and else in it. First it makes a nested list (to have the ability to repeat items on a certain position) and then it will simply flatten it at the end using <code>.chain()</code>-method:</p>
<pre><code>from itertools import chain
array_a = [1, 2, 1, 2, 1, 1, 2]

list(chain.from_iterable([[item, item] if item == 2 else [item] for item in array_a]))
[1, 2, 2, 1, 2, 2, 1, 1, 2, 2]  # output
</code></pre>
<p>The specific value to double is inside the if-statement. Using multipliers (instead of <code>[item, item]</code>) and a variable (instead of <code>2</code>) would make this easily more generic, see this for example:</p>
<pre><code>from itertools import chain

def repeat_certain_value(array, val, n):
    return list(chain.from_iterable(([i] * n if i == val else [i] for i in array)))

repeat_certain_value([1, 2, 1, 2, 1, 1, 2], 2, 2)
[1, 2, 2, 1, 2, 2, 1, 1, 2, 2]  # output

repeat_certain_value([0, -3, 1], -3, 5)
[0, -3, -3, -3, -3, -3, 1]  # output
</code></pre>
<p>While this approach is a handy one-liner using builtin libraries, the approach from <a href="https://stackoverflow.com/a/52323480/2648551">coldspeed</a> is faster:</p>
<pre><code>%timeit for x in range(1000): repeat_certain_value([1, 1, 1, 2, 2, 2, 3, 3, 3] * 100, 2, 2)
10 loops, best of 3: 165 ms per loop

%timeit for x in range(1000): coldspeeds_solution([1, 1, 1, 2, 2, 2, 3, 3, 3] * 100, 2, 2)
10 loops, best of 3: 100 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Can try a list comprehension and create a <code>flat</code> function:</p>
<pre><code>array_a = [1, 2, 1, 2, 1, 1, 2]
def flat(l):
   newl=[]
   for i in l:
      if isinstance(i,list):
         newl.extend(i)
      else:
         newl.append(i)
   return newl
print(flat([[i]*2 if i==2 else i for i in array_a]))
</code></pre>
<p>Output:</p>
<pre><code>[1, 2, 2, 1, 2, 2, 1, 1, 2, 2]
</code></pre>
</div>
<span class="comment-copy">I recommend that you choose a tutorial on list manipulation that fits your current learning level.  There are <i>many</i> ways to do this, but the way you ask questions suggests that you would benefit from a wider presentation of the topic.  Tutorial-level education is beyond the range of Stack Overflow.</span>
<span class="comment-copy">Added the numpy tag since OP has used numpy to attempt a solution.</span>
<span class="comment-copy">amazing! as usual</span>
<span class="comment-copy">Nice approach. Style tip: use <code>_</code> for dummy variables like <code>j</code>.</span>
<span class="comment-copy">you're right, thanks. Corrected.</span>
<span class="comment-copy">Nice solution -- the call to <code>list</code> is unnecessary though.</span>
<span class="comment-copy">fixed, thanks for the comment.</span>
<span class="comment-copy">wouldn't this override the number after a matched position? should i increase array size then shift then add element?</span>
<span class="comment-copy">Bizarre downvote, it's the same as an upvoted answer.</span>
