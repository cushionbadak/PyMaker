<div class="post-text" itemprop="text">
<p>I am fairly new to python and I came upon this code to find a single element in a list </p>
<p>Here is the code:</p>
<pre><code>def single_number(arr):
    ones, twos = 0, 0
    for x in arr:
        ones, twos = (ones ^ x) &amp; ~twos, (ones &amp; x) | (twos &amp; ~x)
    assert twos == 0
    return ones
arr1 = [5, 3, 4, 3, 5, 5, 3]
print(single_number(arr1))
</code></pre>
<p>I just can't seem to understand what the line is doing</p>
<pre><code>ones, twos = (ones ^ x) &amp; ~twos, (ones &amp; x) | (twos &amp; ~x)
assert twos==0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You would not want to do it like this, unless you are <em><strong>really</strong></em> memory-space limited - and even then, you probably should not use it.</p>
<p>This is some kind of bit shifting / bit ops "magic" that is </p>
<ul>
<li>not intuitive</li>
<li>dangerous to fiddle with </li>
<li>bad to maintain </li>
<li>difficult to understand</li>
</ul>
<p><a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter</a> works in O(n) - thats about the best you can do to check all elements in a list - it just takes some more constant time (to setup the Counter object) and some space (to maintain inner dict) over this bit-shift thingy you found.</p>
<pre><code>def getSingle(arr):
    from collections import Counter
    c = Counter(arr)

    return c.most_common()[-1]  # return the least common one -&gt; (key,amounts) tuple

arr1 = [5, 3, 4, 3, 5, 5, 3]

counter = getSingle(arr1)

print (f"{counter[0]} occured {counter[1]} time(s)")
</code></pre>
<p>Output:</p>
<pre><code>4 occured 1 time(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The purpose of that line is to implement an operation that returns the original value if applied three times with the input, and retains the input if applied once.</p>
<p>It's easier to understand if we wanted to pick a single value from an array containing pairs instead of triples. Then we could just do...</p>
<pre><code>ones = ones ^ x
</code></pre>
<p>... because y ^ x ^ x == y. So all the pairs cancel out and you're left with the single value.</p>
<p>As others have commented, the three-item case is a pretty nasty obscure hack that should only be used when performance is essential and the problem is very specific.</p>
<p>I think the assert is just an attempt to confirm that the precondition was met, i.e. all numbers are triples except for one. It's not fail-safe.</p>
</div>
<span class="comment-copy">Are you sure that code works? <code>arr1 = [5, 3, 4, 3, 5, 5, 3, 6, 4]</code> returns <code>2</code> but shouldn't it return the only single number i.e. <code>6</code>? Or have I misunderstood the objective?</span>
<span class="comment-copy">@Dan - your 4 is only present 2 times - add a 4 into the mix and it returns 6. Thats the problem of this solution, its has very specific limitations</span>
<span class="comment-copy">@patrick oh so it only works if there are three of every other element. That seems pointless.</span>
