<div class="post-text" itemprop="text">
<p>I have this data</p>
<pre><code>data = [
    {
        'id': 'abcd738asdwe',
        'name': 'John',
        'mail': 'test@test.com',
    },
    {
        'id': 'ieow83janx',
        'name': 'Jane',
        'mail': 'test@foobar.com',
    }
]
</code></pre>
<p>The id's are unique, it's impossible that multiple dictonaries have the same id.</p>
<p>For example I want to get the item with the id "ieow83janx".</p>
<p>My current solution looks like this:</p>
<pre><code>search_id = 'ieow83janx'
item = [x for x in data if x['id'] == search_id][0]
</code></pre>
<p>Do you think that's the be solution or does anyone know an alternative solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since the <code>id</code>s are unique, you can store the items in a dictionary to achieve O(1) lookup.</p>
<pre><code>lookup = {ele['id']: ele for ele in data}
</code></pre>
<p>then you can do</p>
<pre><code>user_info = lookup[user_id]
</code></pre>
<p>to retrieve it</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are going to get this kind of operations more than once on this particular object, I would recommend to translate it into a dictionary with <code>id</code> as a key.</p>
<pre><code>data = [
    {
        'id': 'abcd738asdwe',
        'name': 'John',
        'mail': 'test@test.com',
    },
    {
        'id': 'ieow83janx',
        'name': 'Jane',
        'mail': 'test@foobar.com',
    }
]

data_dict = {item['id']: item for item in data}
#=&gt; {'ieow83janx': {'mail': 'test@foobar.com', 'id': 'ieow83janx', 'name': 'Jane'}, 'abcd738asdwe': {'mail': 'test@test.com', 'id': 'abcd738asdwe', 'name': 'John'}}

data_dict['ieow83janx']
#=&gt; {'mail': 'test@foobar.com', 'id': 'ieow83janx', 'name': 'Jane'}
</code></pre>
<p>In this case, this lookup operation will cost you some constant* <code>O(1)</code> time instead of <code>O(N)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about the <code>next</code> built-in function (<a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer">docs</a>):</p>
<pre><code>&gt;&gt;&gt; data = [
...     {
...         'id': 'abcd738asdwe',
...         'name': 'John',
...         'mail': 'test@test.com',
...     },
...     {
...         'id': 'ieow83janx',
...         'name': 'Jane',
...         'mail': 'test@foobar.com',
...     }
... ]
&gt;&gt;&gt; search_id = 'ieow83janx'
&gt;&gt;&gt; next(x for x in data if x['id'] == search_id)
{'id': 'ieow83janx', 'name': 'Jane', 'mail': 'test@foobar.com'}
</code></pre>
<p>EDIT:</p>
<p>It raises <code>StopIteration</code> if no match is found, which is a beautiful way to handle absence:</p>
<pre><code>&gt;&gt;&gt; search_id = 'does_not_exist'
&gt;&gt;&gt; try:
...     next(x for x in data if x['id'] == search_id)
... except StopIteration:
...     print('Handled absence!')
... 
Handled absence!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without creating a new dictionary or without writing several lines of code, you can simply use the built-in <code>filter</code> function to get the item lazily, not checking after it finds the match. </p>
<p><code>next(filter(lambda d: d['id']==search_id, data))</code></p>
<p>should for just fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>Would this not achieve your goal?   </p>
<pre><code>for i in data:
    if i.get('id') == 'ieow83janx':
        print(i)
</code></pre>
<blockquote>
<pre><code>(xenial)vash@localhost:~/python$ python3.7 split.py 
{'id': 'ieow83janx', 'name': 'Jane', 'mail': 'test@foobar.com'}
</code></pre>
</blockquote>
<p>Using comprehension:</p>
<pre><code>[i for i in data if i.get('id') == 'ieow83janx']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>if any(item['id']=='ieow83janx' for item in data):
   #return item
</code></pre>
<p>As any function returns true if iterable (List of dictionaries in your case) has value present.
While using Generator Expression there will not be need of creating internal List. As there will not be duplicate values for the id in List of dictionaries, any will stop the iteration until the condition returns true. i.e the   generator expression with any will stop iterating on shortcircuiting. Using List comprehension will create a entire List in the memory where as GE creates the element on the fly which will be better if you are having large items as it uses less memory.</p>
</div>
<span class="comment-copy">load the dictionary into a json object and access the content based on id?</span>
<span class="comment-copy">How big is the dataset and how many times do you iterate the list? It might be worth doing a single pass and creating a new dictionary with <code>id</code> as keys</span>
<span class="comment-copy">The size varies but can not be more than 20 items.</span>
<span class="comment-copy">Why check every key if you are only interested in the first match?</span>
<span class="comment-copy">That's a great solution. I didn't think about that. Is it ok if I just write this? item = {item['id']: item for item in data}['ieow83janx']</span>
<span class="comment-copy">It will raise an error in case of absence</span>
<span class="comment-copy">@fl00r Yes and handling the error is, in my opinion, the most Pythonic way to handle any absences.</span>
<span class="comment-copy">I didn't even know the this function exists. Thanks for the answer</span>
<span class="comment-copy">@sascha No problem, check update for how you can handle absences.</span>
<span class="comment-copy"><code>next(entry for entry in data if entry['id'] == search_id)</code></span>
<span class="comment-copy">While this might answer the authors question, it lacks some explaining words and links to documentation. Raw code snippets are not very helpful without some phrases around it. You may also find <a href="https://stackoverflow.com/help/how-to-answer">how to write a good answer</a> very helpful. Please edit your answer.</span>
<span class="comment-copy">Thank @hellow added explanation for the answer.</span>
