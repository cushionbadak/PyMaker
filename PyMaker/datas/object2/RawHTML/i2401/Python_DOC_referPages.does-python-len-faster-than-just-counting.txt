<div class="post-text" itemprop="text">
<p>As per my understanding (but actually didn't test) calculating len of string (for example) with len() func takes less time than simply calculating number of chars in the same string cause len() somehow optimized.
  Is it the case and how it works in simple words?</p>
<p>The follow up practical question probably would be : " If possible is it a good practice in general to use something like len(string) for early false detection in code in terms of O(code) complexity"</p>
<p>Thanks</p>
<p>UPDATED.
Originally I didn't present any code so now just adding it and hope that would be a bit representative if I haven't mess a lot with it.</p>
<pre><code>import timeit


def len_test(arr):
    return len(arr)


def manual_count(num):
    ln = 0
    i = 0
    while i &lt; num:
        ln += 1
        i += 1
    return ln



for i in range(1000, 10000, 1000):
    count = i
    array = [_ for _ in range(i)]

    t1 = timeit.timeit(stmt='len_test(array)', setup='from __main__ import len_test, array', number=count)
    t2 = timeit.timeit(stmt='manual_count(count)', setup='from __main__ import manual_count, count', number=count)

    print('i: {}, len:{:.8}, count: {:.8}'.format(i, t1, t2))

i: 1000, len:0.0001499, count: 0.12168087
i: 2000, len:0.000327363, count: 0.53221788
i: 3000, len:0.000449699, count: 1.167412
i: 4000, len:0.000595823, count: 2.1061223
i: 5000, len:0.000762714, count: 3.2617024
i: 6000, len:0.000937534, count: 4.8079927
i: 7000, len:0.001076862, count: 6.5171025
i: 8000, len:0.001222231, count: 9.3587468
i: 9000, len:0.001398561, count: 11.686714
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from timeit import default_timer as timer

test = [x for x in range(1000)]
count = 0

start = timer()
len(test)
end = timer()
print(end - start)

start = timer()
for i in test:
    count += 1
end = timer()
print(end - start)
</code></pre>
<p><strong>Returns</strong>:</p>
<pre><code>2.643069343567298e-06

213.7110354941546e-06
</code></pre>
<p>If <code>test = "This is a test string."</code></p>
<p><strong>Returns</strong>:</p>
<pre><code>2.2654880087719696e-06

1.0572277374269745e-05
</code></pre>
</div>
<span class="comment-copy">What does the alternative counting code look like…?</span>
<span class="comment-copy">What exactly do you mean by "early false detection"?</span>
<span class="comment-copy">In general: The<code>len()</code> function calls the <code>__len__()</code> method of the object and the implementation there <i>can</i> be and often is more efficient than the trivial counting approach.</span>
<span class="comment-copy">AFAIR for cPython boils it all down to "reading a variable", where some kind of PyObject keeps track of the current length of the sequence. The closest thing I found was <a href="https://docs.python.org/3/c-api/object.html" rel="nofollow noreferrer">docs.python.org/3/c-api/object.html</a> But perhaps others could help, filling the gaps ;)</span>
<span class="comment-copy">Because Python <code>str</code> objects keep track of their length as an internal attribute. It is accesible by calling <code>mystring.__len__()</code> or <code>len(mystring)</code></span>
<span class="comment-copy">The idea behind <code>timeit</code> is that you're supposed to use <code>timeit.timeit</code> to time things, not call the timer manually.</span>
<span class="comment-copy">I've added some tests. Does it serve the purpose? And still it's seems to me the true that len is faster I interesting in knowing why it is so?</span>
<span class="comment-copy">@СергейНиколаевич <code>len()</code> has a time complexity of O(1), whereas counting each element using a loop has a time complexity of O(n).  <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">wiki.python.org/moin/TimeComplexity</a></span>
