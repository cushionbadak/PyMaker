<div class="post-text" itemprop="text">
<p>I have a set consisting of sets of 2 elements, the first element is still the word and the second one is the file from where the word comes from and now I need to append the name of the file to the word if the word is the same
E.G. <code>input([['word1', 'F1.txt'], ['word1', 'F2.txt'], ['word2', 'F1.txt'], ['word2', 'F2.txt'], ['word3', 'F1.txt'], ['word3', 'F2.txt'], ['word4', 'F2.txt']])</code>
should output <code>[['word1', 'F1.txt', 'F2.txt'], ['word2', 'F1.txt', 'F2.txt'], ['word3', 'F1.txt', 'F2.txt'], ['word4', 'F2.txt']]</code>
Can you give me some tips on how to this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Also, you can do as below if you wish not to use defaultdict:</p>
<pre><code>inner=[[]]
count = 0
def loockup(data,i, count):
    for j in range(i+1, len(data)):
        if data[i][0] == data[j][0] and data[j][1] not in inner[count]:
            inner[count].append(data[j][1])
    return inner

for i in range(len(data)):
    if data[i][0] in inner[count]:
        inner=loockup(data,i,count)
    else:
        if i!=0:
            count +=1
            inner.append([])
        inner[count].append(data[i][0])
        inner[count].append(data[i][1])
        loockup(data,i, count)
print (inner)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">set</a> and the <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a>:</p>
<pre><code>from collections import defaultdict


def remove_dups_pairs(lst):
    s = set(map(tuple, lst))
    d = defaultdict(list)
    for word, file in s:
        d[word].append(file)
    return [[key] + values for key, values in d.items()]


print(remove_dups_pairs([["fire", "elem.txt"], ["fire", "things.txt"], ["water", "elem.txt"], ["water", "elem.txt"], ["water", "nature.txt"]]))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[['fire', 'elem.txt', 'things.txt'], ['water', 'elem.txt', 'nature.txt']]
</code></pre>
<p>As @ShmulikA mentioned set does not preserve ordering, if you need to preserve ordering you can do it like this:</p>
<pre><code>def remove_dups_pairs(lst):
    d = defaultdict(list)
    seen = set()
    for word, file in lst:
        if (word, file) not in seen:
            d[word].append(file)
            seen.add((word, file))

    return [[key] + values for key, values in d.items()]


print(remove_dups_pairs([["fire", "elem.txt"], ["fire", "things.txt"], ["water", "elem.txt"], ["water", "elem.txt"],
                         ["water", "nature.txt"]]))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[['water', 'elem.txt', 'nature.txt'], ['fire', 'elem.txt', 'things.txt']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>keeping insertion order using set of seen items:</h1>
<pre><code>from collections import defaultdict

def remove_dups_pairs_ordered(lst):
    d = defaultdict(list)

    # stores word,file pairs we already seen
    seen = set()
    for item in lst:
        word, file = item
        key = (word, file)

        # skip adding word,file we already seen before
        if key in seen:
            continue
        seen.add(key)
        d[word].append(file)

    # convert the dict word -&gt; [f1, f2..] into 
    # a list of lists [[word1, f1,f2, ...], [word2, f1, f2...], ...]
    return [[word] + files for word, files in d.items()]

print(remove_dups_pairs_ordered(lst))
</code></pre>
<p><strong>outputs:</strong></p>
<pre><code>[['fire', 'elem.txt', 'things.txt'], ['water', 'elem.txt', 'nature.txt']]
</code></pre>
<p><br/></p>
<h1>without keeping the order using defaultdict &amp; set:</h1>
<pre><code>from collections import defaultdict

def remove_dups_pairs(lst):
    d = defaultdict(set)

    for item in lst:
        d[item[0]].add(item[1])
    return [[word] + list(files) for word, files in d.items()]

lst = [
    ["fire","elem.txt"], ["fire","things.txt"],
    ["water","elem.txt"], ["water","elem.txt"],
    ["water","nature.txt"]
]

print(remove_dups_pairs(lst))
</code></pre>
<p><strong>outputs:</strong></p>
<pre><code>   [['fire', 'things.txt', 'elem.txt'], ['water', 'nature.txt', 'elem.txt']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to use an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a> to solve this. It is a dictionary that allows iteration in the order by which keys were added.</p>
<pre><code>import collections

def remove_dups_pairs(data):
    word_files = collections.OrderedDict()
    for word, file_name in data:
        if word not in word_files.keys():
            word_files.update({word: [file_name]})
        elif file_name not in word_files[word]:
            word_files[word].append(file_name)
    return [[word] + files for word, files in word_files.items()]


print(remove_dups_pairs([["fire", "elem.txt"], ["fire", "things.txt"],
                         ["water", "elem.txt"], ["water", "elem.txt"],
                         ["water", "nature.txt"]]))
print(remove_dups_pairs([['word1', 'F1.txt'], ['word1', 'F2.txt'],
                         ['word2', 'F1.txt'], ['word2', 'F2.txt'],
                         ['word3', 'F1.txt'], ['word3', 'F2.txt'],
                         ['word4', 'F2.txt']]))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>[['fire', 'elem.txt', 'things.txt'], ['water', 'elem.txt', 'nature.txt']]
[['word1', 'F1.txt', 'F2.txt'], ['word2', 'F1.txt', 'F2.txt'], ['word3', 'F1.txt', 'F2.txt'], ['word4', 'F2.txt']]
</code></pre>
</div>
<span class="comment-copy">Is preserving ordering important?</span>
<span class="comment-copy">yes it is important</span>
<span class="comment-copy">What Python version are you using?</span>
<span class="comment-copy">@MichaelBorne how this new example is different from the first example?</span>
<span class="comment-copy">Welcome to Stack Overflow! Please do not vandalize your posts. If you believe your question is not useful or is no longer useful, it should be deleted instead of editing out all of the data that actually makes it a question. By posting on the Stack Exchange network, you've granted a non-revocable right for SE to distribute that content (under the CC BY-SA 3.0 license). By SE policy, any vandalism will be reverted.</span>
<span class="comment-copy">Thank you very much</span>
<span class="comment-copy"><code>for word, file in s:</code>  does not guarantee insertion order. <code>for x in set('abc'):     print(x)</code> outputs <code>b c a</code></span>
<span class="comment-copy">I changed the condition a bit, now I have a set consisting of sets of 2 elements, the first element is still the word and the second one is the file from where the word comes from and now I need to append the name of the file to the word if the word is the same E.G. <code>input([['word1', 'F1.txt'], ['word1', 'F2.txt'], ['word2', 'F1.txt'], ['word2', 'F2.txt'], ['word3', 'F1.txt'], ['word3', 'F2.txt'], ['word4', 'F2.txt']])</code> should output <code>[['word1', 'F1.txt', 'F2.txt'], ['word2', 'F1.txt', 'F2.txt'], ['word3', 'F1.txt', 'F2.txt'], ['word4', 'F2.txt']]</code> Can you give me some tips on how to this?</span>
<span class="comment-copy">I came up with this code but it's not working well</span>
<span class="comment-copy"><code>def merge_file_dups(data): 	if len(data) != 0: 		i = 0 		word = [] 		filenames = [data[0][1]] 		res = [] 		while i &lt; len(data) - 1: 			if data[i][0] == data[i + 1][0]: 				filenames.append(data[i + 1][1]) 			else: 				filenames.append(data[i+1][1]) 				word.append(data[i][0]) 				word.append(filenames) 				res.append(word) 				word = [] 				filenames = [] 			i += 1 	return res</code></span>
<span class="comment-copy">I changed the condition a bit, now I have a set consisting of sets of 2 elements, the first element is still the word and the second one is the file from where the word comes from and now I need to append the name of the file to the word if the word is the same E.G. <code>input([['word1', 'F1.txt'], ['word1', 'F2.txt'], ['word2', 'F1.txt'], ['word2', 'F2.txt'], ['word3', 'F1.txt'], ['word3', 'F2.txt'], ['word4', 'F2.txt']])</code> should output <code>[['word1', 'F1.txt', 'F2.txt'], ['word2', 'F1.txt', 'F2.txt'], ['word3', 'F1.txt', 'F2.txt'], ['word4', 'F2.txt']]</code> Can you give me some tips on how to this?</span>
<span class="comment-copy">I made a code but it's not working quite well  <code>def merge_file_dups(data): if len(data) != 0:     i = 0     word = []     filenames = [data[0][1]]     res = []     while i &lt; len(data) - 1:         if data[i][0] == data[i + 1][0]:             filenames.append(data[i + 1][1])         else:             filenames.append(data[i+1][1])             word.append(data[i][0])             word.append(filenames)             res.append(word)             word = []             filenames = []         i += 1 return res</code></span>
