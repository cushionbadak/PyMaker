<div class="post-text" itemprop="text">
<p>I am trying to make a cache decorator for functions with numpy array input parameters</p>
<pre><code>from functools import lru_cache
import numpy as np
from time import sleep

a = np.array([1,2,3,4])

@lru_cache()
def square(array):
    sleep(1)
    return array * array

square(a)
</code></pre>
<p>But numpy arrays are not hashable,</p>
<pre><code>TypeError                                 Traceback (most recent call last)
&lt;ipython-input-13-559f69d0dec3&gt; in &lt;module&gt;()
----&gt; 1 square(a)

TypeError: unhashable type: 'numpy.ndarray'
</code></pre>
<p>So they need to be converted to tuples. I have this working and caching correctly:</p>
<pre><code>@lru_cache()
def square(array_hashable):
    sleep(1)
    array = np.array(array_hashable)
    return array * array

square(tuple(a))
</code></pre>
<p>But I wanted to wrap it all up in a decorator, so far I have tried:</p>
<pre><code>def np_cache(function):
    def outter(array):
        array_hashable = tuple(array)

        @lru_cache()
        def inner(array_hashable_inner):
            array_inner = np.array(array_hashable_inner)
            return function(array_inner)

        return inner(array_hashable)

    return outter

@np_cache
def square(array):
    sleep(1)
    return array * array
</code></pre>
<p>But <strong>caching is not working</strong>. Computation is performed but not cached properly, as I am always waiting 1 second.</p>
<p>What am I missing here? I'm guessing <code>lru_cache</code> isn't getting the context right and its being instantiated in each call, but I don't know how to fix it.</p>
<p>I have tried blindly throwing the <code>functools.wraps</code> decorator here and there with no luck.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your wrapper function creates a <strong>new <code>inner()</code> function</strong> each time you call it. And that new function object is decorated at that time, so the end result is that each time <code>outter()</code> is called, a new <code>lru_cache()</code> is created and that'll be empty. An empty cache will always have to re-calculate the value.</p>
<p>You need to create a decorator that attaches the cache to a function created <em>just once</em> per decorated target. If you are going to convert to a tuple before calling the cache, then you'll have to create <strong>two</strong> functions:</p>
<pre><code>from functools import lru_cache, wraps

def np_cache(function):
    @lru_cache()
    def cached_wrapper(hashable_array):
        array = np.array(hashable_array)
        return function(array)

    @wraps(function)
    def wrapper(array):
        return cached_wrapper(tuple(array))

    # copy lru_cache attributes over too
    wrapper.cache_info = cached_wrapper.cache_info
    wrapper.cache_clear = cached_wrapper.cache_clear

    return wrapper
</code></pre>
<p>The <code>cached_wrapper()</code> function is created just once per call to <code>np_cache()</code> and is available to the <code>wrapper()</code> function as a closure. So <code>wrapper()</code> calls <code>cached_wrapper()</code>, which has a <code>@lru_cache()</code> attached to it, caching your tuples.</p>
<p>I also copied across the two function references that <code>lru_cache</code> puts on a decorated function, so they are accessible via the returned wrapper as well.</p>
<p>In addition, I also used the <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>@functools.wraps()</code> decorator</a> to copy across metadata from the original function object to the wrapper, such as the name, annotations and documentation string. This is always a good idea, because that means your decorated function will be clearly identified in tracebacks, when debugging and when you need to access documentation or annotations. The decorator also adds a <code>__wrapped__</code> attribute pointing back to the original function, which would <a href="https://docs.python.org/3/library/inspect.html#inspect.unwrap" rel="nofollow noreferrer">let you unwrap the decorator again if need be</a>.</p>
</div>
<span class="comment-copy">Very neat explaination, thanks a lot. As a side question, what is the purpose of <code>@wraps(function)</code> in your code? It seems to work fine without it</span>
<span class="comment-copy">@Susensio: The decorator copies information over from the original <code>function</code> to the wrapper function, such as the function name, annotations and the documentation. It also adds a <code>__wrapped__</code> attribute that lets you access the original, unwrapped function again. It's very helpful to use, especially if you generate documentation or need to debug the code.</span>
<span class="comment-copy">@Susensio: I added that info to the question (sorry, was out of time before as I am travelling at the moment, had to change trains and was out of network range). Note that I updated the code as well, copying across <code>lru_cache</code> attributes.</span>
