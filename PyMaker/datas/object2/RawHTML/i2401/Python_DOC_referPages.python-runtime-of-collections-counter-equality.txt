<div class="post-text" itemprop="text">
<p>I am wondering what the big-O runtime complexity is for comparing two <code>collections.Counter</code> objects. Here is some code to demonstrate what I mean:</p>
<pre><code>import collections
counter_1 = collections.Counter("abcabcabcabcabcabcdefg")
counter_2 = collections.Counter("xyzxyzxyzabc")
comp = counter_1 == counter_2  # What is the runtime of this comparison statement?
</code></pre>
<p>Is the runtime of the equality comparison in the final statement O(1)? Or is it O(num_of_unique_keys_in_largest_counter)? Or is it something else?</p>
<p>For reference, here is the source code for <code>collections.Counter</code> <a href="https://github.com/python/cpython/blob/0250de48199552cdaed5a4fe44b3f9cdb5325363/Lib/collections/__init__.py#L497" rel="nofollow noreferrer">https://github.com/python/cpython/blob/0250de48199552cdaed5a4fe44b3f9cdb5325363/Lib/collections/<strong>init</strong>.py#L497</a></p>
<p>I do not see the class implementing an <code>__eq()__</code> method.</p>
<p>Bonus points: If the answer to this question changes between python2 and python3, I would love to hear the difference?</p>
</div>
<div class="post-text" itemprop="text">
<p>Counter is a subclass of <code>dict</code>, therefore the big O analysis is the one of dict, with the caveat that <code>Counter</code> objects are specialized to only hold <code>int</code> values (i/e they can not hold collections of values as dicts can); this simplifies the analysis.</p>
<p>Looking at the <a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c" rel="nofollow noreferrer">c code</a> implementation of the equality comparison:</p>
<ul>
<li>There is an early exit if the number of keys is different. (this does not influence big-O).  </li>
<li>Then a loop that iterates over all the keys that exits early if the key is not found, or if the corresponding value is different. (again, this has no bearing on big-O).  </li>
<li>if all keys are found, and the corresponding values are all equal, then the dictionaries are declared equal. The lookup and comparisons of each key-value pair is <code>O(1)</code>; this operation is repeated at most <code>n</code> times (<code>n</code> being the number of keys)</li>
</ul>
<p>In all, <strong>the time complexity is <code>O(n)</code>, with <code>n</code> the number of keys.</strong><br/>
This applies to both python 2 and 3.</p>
<hr/>
<p>from <a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c#L2640" rel="nofollow noreferrer">dictobject.c</a></p>
<pre><code>/* Return 1 if dicts equal, 0 if not, -1 if error.
 * Gets out as soon as any difference is detected.
 * Uses only Py_EQ comparison.
 */
static int
dict_equal(PyDictObject *a, PyDictObject *b)
{
    Py_ssize_t i;

    if (a-&gt;ma_used != b-&gt;ma_used)
        /* can't be equal if # of entries differ */
        return 0;
    /* Same # of entries -- check all of 'em.  Exit early on any diff. */
    for (i = 0; i &lt; a-&gt;ma_keys-&gt;dk_nentries; i++) {
        PyDictKeyEntry *ep = &amp;DK_ENTRIES(a-&gt;ma_keys)[i];
        PyObject *aval;
        if (a-&gt;ma_values)
            aval = a-&gt;ma_values[i];
        else
            aval = ep-&gt;me_value;
        if (aval != NULL) {
            int cmp;
            PyObject *bval;
            PyObject *key = ep-&gt;me_key;
            /* temporarily bump aval's refcount to ensure it stays
               alive until we're done with it */
            Py_INCREF(aval);
            /* ditto for key */
            Py_INCREF(key);
            /* reuse the known hash value */
            b-&gt;ma_keys-&gt;dk_lookup(b, key, ep-&gt;me_hash, &amp;bval);
            if (bval == NULL) {
                Py_DECREF(key);
                Py_DECREF(aval);
                if (PyErr_Occurred())
                    return -1;
                return 0;
            }
            cmp = PyObject_RichCompareBool(aval, bval, Py_EQ);
            Py_DECREF(key);
            Py_DECREF(aval);
            if (cmp &lt;= 0)  /* error or not equal */
                return cmp;
        }
    }
    return 1;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Internally, <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> stores the count as a dictionary (that's why it subclasses <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer"><code>dict</code></a>) so the same rules apply as with comparing dictionaries - namely, it compares each key with each value from both dictionaries to ensure equality. For CPython, that is implemented in <a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c#L2640" rel="nofollow noreferrer"><code>dict_equal()</code></a>, other implementations may vary but, logically, you have to do the each-with-each comparison to ensure equality.</p>
<p>This also means that the complexity is <code>O(N)</code> at its worst (loops through one of the dictionaries, looks if the value is the same in the other). There are no significant changes between Python 2.x and Python 3.x in this regard.</p>
</div>
<span class="comment-copy"><code>Counter</code> subclasses <code>dict</code> so looking at the c code for <code>dict</code> might give you some insights.</span>
