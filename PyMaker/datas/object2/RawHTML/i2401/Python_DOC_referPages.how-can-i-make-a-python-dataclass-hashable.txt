<div class="post-text" itemprop="text">
<p>Say a I have a dataclass in python3. I want to be able to hash and order these objects. </p>
<p>I only want them ordered/hashed on id. </p>
<p>I see in the docs that I can just implement __hash__ and all that but I'd like to get datacalsses to do the work for me because they are intended to handle this.</p>
<pre><code>from dataclasses import dataclass, field

@dataclass(eq=True, order=True)
class Category:
    id: str = field(compare=True)
    name: str = field(default="set this in post_init", compare=False)

a = sorted(list(set([ Category(id='x'), Category(id='y')])))

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'Category'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass" rel="noreferrer">the docs</a>:</p>
<blockquote>
<p>Here are the rules governing implicit creation of a <code>__hash__()</code> method:</p>
<p>[...]</p>
<p>If <code>eq</code> and <code>frozen</code> are both true, by default <code>dataclass()</code> will
  generate a <code>__hash__()</code> method for you. If <code>eq</code> is true and <code>frozen</code>
  is false, <code>__hash__()</code> will be set to <code>None</code>, marking it unhashable
  (which it is, since it is mutable). If <code>eq</code> is false, <code>__hash__()</code>
  will be left untouched meaning the <code>__hash__()</code> method of the
  superclass will be used (if the superclass is object, this means it
  will fall back to id-based hashing).</p>
</blockquote>
<p>Since you set <code>eq=True</code> and left <code>frozen</code> at the default (<code>False</code>), your dataclass is unhashable.</p>
<p>You have 3 options:</p>
<ul>
<li>Set <code>frozen=True</code> (in addition to <code>eq=True</code>), which will make your class immutable and hashable.</li>
<li><p>Set <code>unsafe_hash=True</code>, which will create a <code>__hash__</code> method but leave your class mutable, thus risking problems if an instance of your class is modified while stored in a dict or set:</p>
<pre><code>cat = Category('foo', 'bar')
categories = {cat}
cat.id = 'baz'

print(cat in categories)  # False
</code></pre></li>
<li>Manually implement a <code>__hash__</code> method.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><strong>TL;DR</strong></p>
<p>Use <code>frozen=True</code> in conjunction to <code>eq=True</code> (which will make the instances immutable).</p>
<p><strong>Long Answer</strong></p>
<p>From the <a href="https://docs.python.org/3/library/dataclasses.html#module-level-decorators-classes-and-functions" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p><code>__hash__()</code> is used by built-in <code>hash()</code>, and when objects are added to hashed collections such as dictionaries and sets. Having a <code>__hash__()</code>
  implies that instances of the class are immutable. Mutability is a
  complicated property that depends on the programmerâ€™s intent, the
  existence and behavior of <code>__eq__()</code>, and the values of the eq and
  frozen flags in the <code>dataclass()</code> decorator.</p>
<p>By default, <code>dataclass()</code> will not implicitly add a <code>__hash__()</code> method
  unless it is safe to do so. Neither will it add or change an existing
  explicitly defined <code>__hash__()</code> method. Setting the class attribute
  <code>__hash__ = None</code> has a specific meaning to Python, as described in the <code>__hash__()</code>documentation.</p>
<p>If <code>__hash__()</code> is not explicit defined, or if it is set to None, then
  <code>dataclass()</code> may add an implicit <code>__hash__()</code> method. Although not
  recommended, you can force <code>dataclass()</code> to create a <code>__hash__()</code> method
  with <code>unsafe_hash=True</code>. This might be the case if your class is
  logically immutable but can nonetheless be mutated. This is a
  specialized use case and should be considered carefully.</p>
<p>Here are the rules governing implicit creation of a <code>__hash__()</code> method.
  Note that you cannot both have an explicit <code>__hash__()</code> method in your
  dataclass and set <code>unsafe_hash=True</code>; this will result in a <code>TypeError</code>.</p>
<p>If eq and frozen are both true, by default <code>dataclass()</code> will generate a
  <code>__hash__()</code> method for you. If eq is true and frozen is false, <code>__hash__()</code> will be set to None, marking it unhashable (which it is, since it is mutable). If eq is false, <code>__hash__()</code> will be left
  untouched meaning the <code>__hash__()</code> method of the superclass will be used
  (if the superclass is object, this means it will fall back to id-based
  hashing).</p>
</blockquote>
</div>
<span class="comment-copy">To find examples, see the <i>What you can turn on</i> section in this post <a href="https://stackoverflow.com/a/52283085/4531270">stackoverflow.com/a/52283085/4531270</a>.</span>
