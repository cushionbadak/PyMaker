<div class="post-text" itemprop="text">
<p>I have the following code in two modules.</p>
<p>Module "main":</p>
<pre><code>#!/usr/bin/python

import threading
import b

a = 0

def api_a():
    global a
    print("api_a()")
    a = 1

def main():
    global a

    thread_B = b.B_thread()

    print("a = " + str(a)) 

    thread_B.start()

#    api_a()

    thread_B.join()

    print("a = " + str(a)) 

if __name__ == '__main__':
    main()
</code></pre>
<p>Module "B":</p>
<pre><code>#!/usr/bin/python

import threading
import main

class B_thread (threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
    def run(self):
        print("Starting " + self.name)
        B_process()
        print("Exiting " + self.name)

def B_process():
    main.api_a()
</code></pre>
<p>If I run this code I get:</p>
<pre><code>a = 0
Starting Thread-1
api_a()
Exiting Thread-1
a = 0
</code></pre>
<p>Why is variable "a" not set to "1" ?</p>
<p>If I activate the commented line of code in Module "main" ( api_a() ) the variable "a" will be set to "1". Why is the variable not set when the function api_a() is called via the thread?</p>
<p>In the example code I skipped the use of locks to make the code thread-safe.</p>
<p>Any ideas?</p>
<p>Thanks a lot in advance,</p>
<p>Thomas</p>
</div>
<div class="post-text" itemprop="text">
<p>Such behavior occurs, because you passed <code>main.py</code> as the argument to python (<code>python main.py</code>).</p>
<p>When you execute a script in such way, python interprets <code>main</code> module as <code>__main__</code>, but <code>b</code> module still updates <code>main.a</code> variable instead of <code>__main__.a</code>, because <code>b</code> has re-imported your main.py module as <code>main</code>.</p>
<p>So to make it work, we can either update <code>__main__.a</code> in <code>api_a</code> function from perspective of <code>b</code> module OR print <code>main.a</code> variable instead of <code>__main__.a</code> from perspective of <code>__main__</code> module. </p>
<pre><code>def api_a():
    print("api_a()")
    import sys
    sys.modules['__main__'].a = 1
</code></pre>
<p>or </p>
<pre><code>def main():
    ...
    thread_B.join()
    import sys
    print("a = " + str(sys.modules['main'].a))
</code></pre>
<p><a href="https://docs.python.org/3/library/__main__.html" rel="nofollow noreferrer"><code>__main__</code></a> docs</p>
</div>
<span class="comment-copy">I see the problem but it's subtle and has to do in part with your use of circular imports one of which is both the the <code>"main"</code> module AND the <code>"__main__"</code> module. In other words, your "main" module gets imported twice, once under the name <code>"__main__"</code> and once under the name "main" and each of these copies of the module will have separate globals. It's only the one named "main" whose globals get updated in this case. Will follow up with a better answer later if you'll remind me.</span>
<span class="comment-copy">Also this problem doesn't really have to do with your use of threads. You'll have the exact same problem if in you <code>main()</code> function, instead of starting a thread you just call <code>b.b_process()</code> directly. Also, another edifying demonstration is if you run <code>python -c 'import main; main.main()</code> it will work as expected.</span>
<span class="comment-copy">So, if I understand it correctly the problem only occurs because of the "<b>main</b>". Meaning, that if I move al logic from the main module into a separate one (let's call it "C") and then calling C's functions from "<b>main</b>" and "B" it will work?</span>
<span class="comment-copy">Yes, that's right.  @Artemiy's full answer below is correct.</span>
<span class="comment-copy">I edited your answer to make a few small working corrections but this is otherwise correct.  Though I would not at all recommend going through <code>sys.modules</code>.  Really the OP has a perfect storm of questionable design choices--each of which on its own may be justifiable (using a global variable, using circular imports, using multiple modules without putting them in a package, etc.)--that make this problem more apparent than it is normally.  Point being, they should probably refactor their code instead.</span>
