<div class="post-text" itemprop="text">
<p>I have a list of sentences and a list of queries. The queries have distinct space-separated words, I have to find the sentences having all the queries and print the indexes of the sentences. 
<strong>Example:</strong> </p>
<pre><code>3
hey how are you
how do you do
how are you doing
2
how
how are
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>0 1 2
0 2
</code></pre>
<p>The input structure is something like this:</p>
<pre><code>sentences = ['hey how are you' , 'how do you do' , 'how are you doing']
queries = ['how', 'how are']
</code></pre>
<p>I have been using O(n^3) algorithm but that's very slow and giving me a TLE. Is there a faster way to do it, maybe regex but I haven't been able to figure out how to build the expression? </p>
<p>The input size is limited to 10^4.</p>
<p>My code :</p>
<pre><code>def textQueries(sentences, queries):
def maptoDict(sentence):
    d = {}
    for word in sentence.split():
        if word not in d.keys():
            d[word] = 1
        else:
            d[word] += 1
    return d
s = list(map(maptoDict,sentences))
q = list(set(query.split()) for query in queries)
for query in q:
    res = []
    for i in range(len(s)):
        if query.issubset(set(s[i].keys())):
            res.append(i)
    if not len(res):
        res.append(-1)
    for r in res:
        print(r, end = ' ')
    print()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python supports the data structure called a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">set</a>. You can post-process your sentences to produce a map of words to sets.</p>
<p>That is, a map like:</p>
<pre><code>word_in_sentences["how"] = set(0, 1, 2)
</code></pre>
<p>With that data structure, you can compute the set intersection of all the query words. This would give you a set that contains all the words in the query, with no concern about the order of the words.</p>
<p>Once you filter the sentences down to that smaller group, doing whatever ordering search should be faster.</p>
</div>
<div class="post-text" itemprop="text">
<p>I formatted the output so you could trace the loop to see how each item is retrieved. You can use the elements of this to just print the <code>index</code> if you'd like but I wanted you to see how to get the things you are requesting.</p>
<pre><code>sentences = ['hey how are you', 'how do you do', 'how are you doing']
queries = ['how', 'how are']

for i, items in enumerate(sentences):
   for j in queries:
        if j in items:
            print(f"Query '{j}' is in Sentence {i}")
</code></pre>
<p><strong>Output</strong></p>
<blockquote>
<pre><code>(xenial)vash@localhost:~/python/stack_overflow$ python3.7 sent_find.py 
Query 'how' is in Sentence 0
Query 'how are' is in Sentence 0
Query 'how' is in Sentence 1
Query 'how' is in Sentence 2
Query 'how are' is in Sentence 2
</code></pre>
</blockquote>
<p>This will get that basic output:</p>
<pre><code>sentences = ['hey how are you', 'how do you do', 'how are you doing']
queries = ['how', 'how are']

for i in queries:
    for j, items in enumerate(sentences):
        if i in items:
            print(j, end=' ')
    print()
</code></pre>
<p><strong>Output</strong></p>
<pre><code>(xenial)vash@localhost:~/python/stack_overflow$ python3.7 sent_find.py 
0 1 2 
0 2 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can store each subarray of strings in a <code>map</code>. The <code>value</code> of the <code>key</code> in the <code>map</code> will be a list(of indices of course). Below is the pseudocode- </p>
<p><strong>Pseudocode:</strong></p>
<pre><code>    Map&lt;string,list&gt; map
    for each_sentence in sentence_list:
        words = each_sentence.split("\\s")
           for i = 0 to words.length():
               for j=i to words.length():
                 subword = string from i to j
                 if map.containsKey(subword):
                     map.get(subword).add(each_sentence's index)
                 else:
                    map.put(subword,new list(each_sentence's index))

   for each_query in query_list:
       print map.containsKey(each_query) ? map.get(each_query) : -1
</code></pre>
<p>Time Complexity: O(n^2) where <code>n</code> is the maximum length of a sentence among all sentences. </p>
</div>
<span class="comment-copy">You haven't shown a list in your example. Please don't leave us guessing what the structure is for either list.</span>
<span class="comment-copy">Your example does not show a <code>list</code> or a <code>list of queries</code> it just shows what could be a set of words in a <code>.txt</code> file, Please provide both <code>list</code>s and whatever <code>code</code> you have attempted.</span>
<span class="comment-copy">While we're at it, you don't specify if the query words have to appear in sequence, or in exact order, or just anywhere? That is, does <code>'how are'</code> require the words <code>how</code> and <code>are</code> anywhere in the sentence, or <code>how...are</code> in order but maybe with other words between, or <code>how are</code> exactly?</span>
<span class="comment-copy">Your code formatting seems off, could you edit the question &amp; kindly correct it? See here for more info on formatting code - <a href="https://stackoverflow.com/help/formatting">stackoverflow.com/help/formatting</a></span>
<span class="comment-copy"><code>O(max(n)^2)</code> will be the time complexity at the least where <code>n</code> is max length among individual sentences. You can store all subarrays in a map and then do the rest.</span>
