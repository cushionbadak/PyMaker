<div class="post-text" itemprop="text">
<p>Let's say we have two sets:</p>
<pre><code>t = {('b', 3), ('a', 2)}
r = {('b', 4), ('c', 6)}
</code></pre>
<p>I want a union on 1st element to result in</p>
<pre><code>u = {('b', 3), ('a', 2), ('c', 6)}
</code></pre>
<p>if duplicate symbol is present in both place (example 'b' in the above) then the element of the first list should be retained.
Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just do:</p>
<pre><code>t = {('b', 3), ('a', 2)}
r = {('b', 4), ('c', 6)}
d = dict(r)
d.update(t)
u = set(d.items())
print(u)
</code></pre>
<p>Output:</p>
<pre><code>{('c', 6), ('a', 2), ('b', 3)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A little bit shorter version:
</p>
<pre><code>s = dict((*r, *t))
set(s.items())
</code></pre>
<p>Output:
</p>
<pre><code>{('a', 2), ('b', 3), ('c', 6)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>for el in r:
    if not el[0] in [x[0] for x in t]:
        t.add(el)

t 

{('a', 2), ('b', 3), ('c', 6)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't do that with set intersecion. Two objects are either equal or they are not. Since your objects are tuples, <code>(b, 3)</code> and <code>(b, 4)</code> are not equal, and you don't get to change that. </p>
<p>The obvious way would be to create your own class and redefine equality, something like</p>
<pre><code>class MyTuple:
    def __init__(self, values):
         self.values = values

    def __eq__(self, other):
        return self.values[0] == other[0]
</code></pre>
<p>and create sets of such objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>An alternative using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer">chain</a>:</p>
<pre><code>from itertools import chain

t = {('b', 3), ('a', 2)}
r = {('b', 4), ('c', 6)}

result = set({k: v for k, v in chain(r, t)}.items())
</code></pre>
<p><strong>Output</strong></p>
<pre><code>{('b', 3), ('a', 2), ('c', 6)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my one-line style solution based on comprehensions:  </p>
<pre><code>t = {('b', 3), ('a', 2)}
r = {('b', 4), ('c', 6)}

result = {*t, *{i for i in r if i[0] not in {j[0] for j in t}}}

print(result)  # {('b', 3), ('a', 2), ('c', 6)}
</code></pre>
<p>Using conversion to dictionary to eliminate the duplicates, you can also do that, which is a quite smart solution IMHO:  </p>
<pre><code>t = {('b', 3), ('a', 2)}
r = {('b', 4), ('c', 6)}

result = {(k,v) for k,v in dict((*r,*t)).items()}

print(result)  # {('b', 3), ('a', 2), ('c', 6)}
</code></pre>
</div>
<span class="comment-copy">Why ('b', 3) and not ('b', 4)?</span>
<span class="comment-copy">That's the specification, will edit the question to clarify.</span>
<span class="comment-copy">It appears to me that you want a dict with <code>update</code> in reverse order of appearance.</span>
<span class="comment-copy">this method here is OP underrated move of the day, take my rep</span>
<span class="comment-copy">efficiency is key else the question is very trivial I think</span>
