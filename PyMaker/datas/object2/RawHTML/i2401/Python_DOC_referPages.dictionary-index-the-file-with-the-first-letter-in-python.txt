<div class="post-text" itemprop="text">
<p>Here is what I'm supposed to do:</p>
<p>Write a function, <code>text_dictionary(file_name)</code>, that accepts a file name and returns a dictionary where the key
is a letter and the value is a list of words from the file that begin with that letter. Make sure that the list contains
only unique values, is all lowercased, and contains no punctuation marks.</p>
<p>And here is what I have right now.</p>
<pre><code>import string
string=string.ascii_lowercase
keys=[]
for letter in string:
    keys.append(letter)
def text_dictionary(file_name):
    with open(file_name,'r') as file:
        words=[]
        for line in file:
            words.append(line.rstrip())
            new_list=[]
            for i in words:
                new_list.append(i.lower())
                return new_list
            d={}
            for words in new_list:
                for i in range(25):
                    if word.startwith(new_list[i])==True:
                        d[words[i]]+=words
                return d
        print(d)
</code></pre>
<p>The code became longer and longer and I still didn't get what I wanted. I'm even not sure what I'm doing and if it's useful. I wonder if there is some functions of dictionary that I don't know. Really frustrated here.</p>
</div>
<div class="post-text" itemprop="text">
<p>This seems a little more Pythonic to me.</p>
<pre><code>import re
from collections import defaultdict


NON_LETTER = re.compile("[^\w\s]+")
WHITESPACE = re.compile(r"\s+")


def text_dictionary(filename):
    with open(filename, "r") as infile:
        terms = set(
            WHITESPACE.split(
                NON_LETTER.sub(
                    "", 
                    infile.read().lower()
                )
            )
        )

    if "" in terms:
        terms.remove("")

    d = defaultdict(lambda: [])

    for t in terms:
        d[t[0]].append(t)

    return d
</code></pre>
<p>Removing non-word characters (for non-English, you'll need something more clever) is probably enough for this exercise. Splitting on any combination of whitespace means you skip newlines, tabs, etc. By creating a set from the result, duplicates are automatically removed. Note that if you remove punctuation without adding a space, "don't" remains one word, but "something-else" becomes "somethingelse" and vice versa. So that might be a consideration.</p>
<p>You could do <code>filter(lambda x: x, set(...))</code> instead of the <code>if "" in terms:</code> block, but the result is the same; this method can result in the empty string being in your terms set, which would break the dict creation.</p>
<p><code>defaultdict</code> lets you set a behavior on inserting a key, so there's no need to check for existence or pre-create keys.</p>
<p><em>Yet another edit: I don't think it's totally clear from the phrasing whether the question requires all letters to be present as keys, but if it does, all it means is replacing the initialization of d as a defaultdict with <code>d = {l: [] for l in string.ascii_lowercase}</code>.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>You're making this more complicated than it needs to be, which is where the frustration comes from. The actual solution is much simpler than you think.</p>
<p>A dictionary keeps track of its own keys. You don't need to initialized anything. If a word comes along for a letter not in the dictionary, you add a new key right then. Otherwise, you use the list that's already there.</p>
<p>Another point is that the <a href="https://docs.python.org/3/library/string.html" rel="nofollow noreferrer"><code>string</code></a> module provides you with the tools to split on both <a href="https://docs.python.org/3/library/string.html#string.whitespace" rel="nofollow noreferrer"><code>whitespace</code></a> <em>and</em> <a href="https://docs.python.org/3/library/string.html#string.punctuation" rel="nofollow noreferrer"><code>punctuation</code></a>. The price you pay is having to filter out some empty strings, but that's trivial.</p>
<p>I'd recommend storing the intermediate results in <a href="https://docs.python.org/3/library/functions.html#func-set" rel="nofollow noreferrer"><code>set</code></a>s instead of lists to ensure uniqueness. You can always convert to lists as a final step.</p>
<p>And use return values instead of printouts in your utility functions:</p>
<pre><code>def text_dictionary(file_name):
    map = {}
    with open(file_name,'r') as file:
        for line in file:
            for word in line.split(string.whitespace + string.punctuation):
                if not word:
                    continue
                word = word.lower()
                if word[0] not in map:
                    map[word[0]] = set()
                map[word[0]].add(word)
    for key in map:
        map[key] = list(map[key])
    return map
</code></pre>
<p>Notice that I'm not using any special methods or attributes of a dictionary at all besides the most basic access.</p>
<p><strong>Appendix 1: Dictionary Transformation</strong></p>
<p>The final loop replaces the sets with lists in-place: it doesn't create a new dictionary object. You could do the same thing with a very similar loop:</p>
<pre><code>for key, value in map.items():
    map[key] = list(item)
</code></pre>
<p>In general, you shouldn't modify a dictionary when you iterate over it. However, if you're very careful to only touch the values and not the keys, you won't have any problems because the underlying structure of the hash table won't change.</p>
<p>Creating dictionaries is cheap, so it might be faster to use a dictionary comprehension to make a new mapping instead:</p>
<pre><code>map = {key: list(value) for key, value in map.items()}
</code></pre>
<p><strong>Appendix 2: Word Splitting</strong></p>
<p>The word splitting algorithm shown above is extremely simple. It assumes that your file will contain only very well behaved printable ASCII characters. While this is probably true for your assignment, it irks me to write code that has known potential issues, because there will be so many unknown issues to occupy your time later. To that end, I'll present a couple of alternative ways of searching for words using <a href="https://docs.python.org/3.3/howto/regex.html" rel="nofollow noreferrer">regular expressions</a>.</p>
<ol>
<li><p>The first alternative is to split on anything that isn't a word character. A word character (in a regular string) is matched by the <code>\w</code> pattern, which</p>
<blockquote>
<p>Matches Unicode word characters; this includes most characters that can be part of a word in any language, as well as numbers and the underscore. If the <a href="https://docs.python.org/3/library/re.html#re.ASCII" rel="nofollow noreferrer">ASCII</a> flag is used, only <code>[a-zA-Z0-9_]</code> is matched.</p>
</blockquote>
<p>The inverse of <code>\w</code> is <code>\W</code>, so you can use it with <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow noreferrer"><code>re.split</code></a>:</p>
<pre><code>for word in re.split(r'\W+', line):
</code></pre></li>
<li><p>The second alternative is the complement of the first. Instead of splitting on a pattern, match a pattern and use <a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow noreferrer"><code>re.finditer</code></a> to list the words for you:</p>
<pre><code>for word in re.finditer(r'\w+', line):
</code></pre></li>
</ol>
<p>I'm both cases, it's worth noting that you're better off pre-compiling your pattern of choice using <a href="https://docs.python.org/3/library/re.html#re.compile" rel="nofollow noreferrer"><code>re.compile</code></a> instead of recompiling the pattern every time. The most efficient way to set the pattern is either globally, or in a default argument to the function. That way it will only ever be evaluated once. A second best option is to do it before the <code>with</code> block, so you at least compile once per file instead of once per line. A global or in-function definition, would look like</p>
<pre><code>pattern = re.compile(r'\w')  # or r'\W', as you prefer
</code></pre>
<p>As a default argument:</p>
<pre><code>def text_dictionary(file_name, pattern=re.compile(r'\w')):
</code></pre>
<p>The latter approach gives you flexibility should you ever decide to modify the set of characters you include/split on.</p>
<p>In either case, the loop would then be</p>
<pre><code>for word in pattern.split(line):  # or pattern.finditer(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may be overthinking it a bit. Let's list the necessary steps (following the instructions):</p>
<ol>
<li><p>Create a dictionary with each letter of the alphabet as a key and an empty <code>set</code> as the value. The <code>set</code> is used to ensure uniqueness.</p></li>
<li><p>Open the file, strip punctuation and lowercase the string and split it into a list of words.</p></li>
<li><p>Iterate over the words in the word list and add each one to the corresponding <code>set</code> in the dictionary based on first letter.</p></li>
<li><p>Transform all of the sets back into lists and return the dictionary.</p></li>
</ol>
<p>Here's the code:</p>
<pre><code>import re
import string

def text_dictionary(file_name):
    letters = {x: set() for x in string.ascii_lowercase}

    with open(file_name,'r') as f:
        for word in re.sub(r"\W", " ", f.read().lower()).split():
            letters[word[0]].add(word)

    return {k: list(v) for k, v in letters.items()}


for k, v in sorted(text_dictionary("file.txt").items()):
    print(k, v)
</code></pre>
<p>Sample output (using your question as input):</p>
<pre class="lang-none prettyprint-override"><code>a ['all', 'a', 'accepts', 'and']
b ['begin']
c ['contains']
d ['do', 'dictionary']
e []
f ['file', 'from', 'function']
g []
h ['here']
i ['im', 'is']
j []
k ['key']
l ['lowercased', 'list', 'letter']
m ['marks', 'make']
n ['no', 'name']
o ['of', 'only']
p ['punctuation']
q []
r ['returns']
s ['supposed', 'sure']
t ['text_dictionaryfile_name', 'the', 'to', 'that']
u ['unique']
v ['values', 'value']
w ['what', 'write', 'where', 'words', 'with']
x []
y []
z []
</code></pre>
<p>Note that I've omitted error handling on both the file open and potential <code>KeyErrors</code>; those would be important considerations if you were planning on turning this into a deployable function.</p>
</div>
<span class="comment-copy">Note that in Python 3, <code>{...}</code> (when <code>...</code> actually has values) can be used to create either a dict <i>or</i> a set. While what you're doing here does correctly create a dict, I personally find it a little unnerving to read, and use <code>dict()</code> instead.</span>
<span class="comment-copy">Thank you so much! Your instruction is very helpful! The example of "somethingelse" is really thoughtful and worth-thinking.</span>
<span class="comment-copy">You're welcome! Glad it helped.</span>
<span class="comment-copy"><code>string.whitespace + string.punctuation</code> is only good enough under the most basic assumptions. Use a whitelist instead of a blacklist.</span>
<span class="comment-copy">@Tomalak. You're right that. If you're looking at all the unicode characters, it's hard to say if there are more alphanumeric ones or punctuation, but it's hard to define some of the stuff that's neither and still shouldn't be included. I've written a function that would allow you to count them pretty easily though, should you ever care to do so: <a href="https://stackoverflow.com/a/52285737/2988730">stackoverflow.com/a/52285737/2988730</a></span>
<span class="comment-copy">@Tomalak. I've added an appendix giving regex alternatives to the splitting problem. I think it's much less ugly than the other answer</span>
<span class="comment-copy">Ugliness is in the eye of the beholder, I was more looking at "correct" (or at least conceptually sound) here.</span>
<span class="comment-copy">@Tomalak. Fair point. I generally consider using <code>read</code> to be less preferable to lazy iteration, but that's just me as you say. At the same time, replacing all non word characters with a blank is a bug if I'm not mistaken.</span>
<span class="comment-copy">I love it. We even both have essentially the same opening line.</span>
<span class="comment-copy">Consider using <code>\W</code> for your pattern</span>
<span class="comment-copy">And you probably want to replace with a space, not an empty string</span>
<span class="comment-copy">I'm sorry, but when testing the code with my own file, when it comes to newlines, two words will be combined together. For example, if on the first line, the end is "so." and I start another line with some space left on the first line, the first word on the second will be combined with "so" and regarded as one word.</span>
<span class="comment-copy">You're both correct. Fixed.</span>
