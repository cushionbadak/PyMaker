<div class="post-text" itemprop="text">
<p>I am using <code>aiohttp</code> to create an Async/IO webserver. However, to my understanding, Async/IO means the server can only run on one processing core. Regular, synchronous servers like <code>uwsgi</code>, on the other hand, can fully utilize the computer's computing resources with truly parallel threads and processes. Why, then, is Async/IO new and trendy if it <em>less</em> parallel than multiprocessing? Can async servers like <code>aiohttp</code> be multi-processed?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why, then, is Async/IO new and trendy if it less parallel than multiprocessing?</p>
</blockquote>
<p>The two solve different problems. Asyncio allows writing <strong>asynchronous</strong> code sans the "callback hell". <code>await</code> allows the use of constructs like loops, ifs, try/except, and so on, with automatic suspension and task switching. This enables servicing a large number of connections without needing to spawn a thread per connection, but with maintainable code that <strong>looks</strong> as if it were written for blocking connections. Thus asyncio only helps with the code whose only bottleneck is waiting for external events, such as network IO and timeouts.</p>
<p>Multiprocessing, on the other hand, is about parallelizing execution of <strong>CPU-bound</strong> code, such as scientific calculations. Since OS threads do not help due to <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">the GIL</a>, multiprocessing spawns separate OS processes and distributes the work among them. This comes at the cost of the processes not being able to easily share data - all communication is done either by serialization through pipes, or with dedicated <a href="https://docs.python.org/3/library/multiprocessing.html#proxy-objects" rel="nofollow noreferrer">proxies</a>.</p>
<p>A multi-threaded asyncio-style framework is possible in theory - for example, Rust's <a href="https://tokio.rs/" rel="nofollow noreferrer">tokio</a> is like that - but wouldn't work in Python due to the GIL preventing the use of multiple cores. Combining asyncio and multiprocessing is unlikely to work out either, because both the asyncio implementation and code using asyncio heavily depend on shared state.</p>
</div>
<div class="post-text" itemprop="text">
<p>Gunicorn <a href="http://docs.aiohttp.org/en/stable/deployment.html#start-gunicorn" rel="nofollow noreferrer">can</a> help you:</p>
<p><code>gunicorn module:app --bind 0.0.0.0:8080 --worker-class aiohttp.GunicornWebWorker --workers 4</code></p>
</div>
<span class="comment-copy">The whole point of asynchronous programming is to stuff multiple execution threads in one CPU thread. This allows you to process multiple (like, thousands) I/O requests on one CPU core. However, asynchronous code <i>sucks</i> for parallelizing CPU-bound tasks because everything runs in one thread anyway.</span>
<span class="comment-copy">@ForceBru I tried something like this: <code>from multiprocessing import Pool; pool = Pool(4); pool.map(web.run_app, [app, app, app, app])</code>. Does this make any sense performance-wise?</span>
<span class="comment-copy">Well, if your server can't handle too many requests when run in one process, than it may be. Otherwise <code>asyncio</code> should be fine. And it also won't load your computer too much.</span>
<span class="comment-copy">Re: trendiness -- basically, some of the models for being "more parallel" can, especially if poorly implemented (and historically, they often <i>were</i> poorly implemented), have much more overhead than the async approach. Switching between threads involves context-switching from userspace to kernelspace; jumping between two different call-stack contexts in a single process is much lower overhead than switching threads.</span>
<span class="comment-copy">...often, an ideal solution is somewhere between the two worlds -- ie. using a thread pool, but then doing lightweight application-level context switches <i>within</i> each thread. That said, there are a lot of strong opinions on this topic, and questions where answers are likely to be controversial are a place we try to stay away from here.</span>
<span class="comment-copy">Thanks! I didn't know Gunicorn could run <code>aiohttp</code> apps!</span>
