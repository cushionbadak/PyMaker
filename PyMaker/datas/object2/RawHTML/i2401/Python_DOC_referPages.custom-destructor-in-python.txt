<div class="post-text" itemprop="text">
<p>Let's say I have two classes:</p>
<pre><code>class Container():
   def __init__(self, name):
       self.name = name

class Data():
   def __init__(self):
     self._containers = []

   def add_container(self,name):
     self._containers.append(name)
     setattr(self, name, Container(name))
</code></pre>
<p>Now let's say</p>
<pre><code>myData = Data()
myData.add_container('contA')
</code></pre>
<p>Now, if I do <code>del myData.contA</code> it of course doesn't remove <code>name</code> from <code>myData._containers</code>.</p>
<p>So how would I write a destructor in <code>Container</code> so it deletes the attribute but also removes name from the <code>_containers</code> list?</p>
</div>
<div class="post-text" itemprop="text">
<p>You seem to be used to a language with deterministic object destruction and dedicated methods for performing that destruction. Python doesn't work that way. Python has no destructors, and even if it had destructors, there is no guarantee that <code>del myData.contA</code> would render the Container object eligible for destruction, let alone actually destroy it.</p>
<p>Probably the simplest way is to just define a <code>remove_container</code> paralleling your <code>add_container</code>:</p>
<pre><code>def remove_container(self, name):
    self._containers.remove(name)
    delattr(self, name)
</code></pre>
<p>If you really want the syntax for this operation to be <code>del myData.contA</code>, then hook into attribute deletion, by implementing a <code>__delattr__</code> on <code>Data</code>:</p>
<pre><code>def __delattr__(self, name):
    self._containers.remove(name)
    super().__delattr__(name)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You want to overload the <code>__delattr__</code> special method: <a href="https://docs.python.org/3/reference/datamodel.html#object.__delattr__" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#object.<strong>delattr</strong></a></p>
<pre><code>class Data:
    [...]
    def __delattr__(self, key):
        super().__delattr__(name)
        #find and remove the Container from _containers
</code></pre>
</div>
<span class="comment-copy">When it is complicited, it is often a design problem. Actually you cannot do del myData.contA has Data class has not any attribute called contA. I think you should rethink the object oriented design here</span>
