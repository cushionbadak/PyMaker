<div class="post-text" itemprop="text">
<p>I am building a RESTful API that runs in a docker container and uses Python 3 Flask and is backed by MongoDB through the PyMongo library. I want to add unit tests to the API that I can run when I make a git commit (in a CI/CD pipeline). The API mostly just allows creating, getting, listing, modifying and deleting of objects in the database. I want my tests to call these endpoints and check the responses make sense. What would the recommended pattern be for this?</p>
<p><a href="https://mockupdb.readthedocs.io/" rel="nofollow noreferrer">MockupDB</a> seems like it would allow me to fake a MongoDB server inside my Python container, but programming all responses from MongoDB seems overly complicated.</p>
<p>I could modify my data class to do e.g:</p>
<pre><code>test_dictionary = {}

def get(identifier):
    if is_test:
        return test_dictionary.get(identifier, None)
    return database.find_one({'_id': identifier})
</code></pre>
<p>But that would reduce my coverage.</p>
<p>I could have a separate Dockerfile for testing which includes both a MongoDB server and Python. Then point my PyMongo connection at the local server in the test Dockerfile, and a server outside the container for the normal Dockerfile. Which would mean I'm not testing inside the same environment anymore.</p>
<p>Maybe I can use the Python <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">unittest.mock</a> module?</p>
<p>Or these tests are better suited for running once the container is deployed?</p>
<p>I am think the <a href="http://flask.pocoo.org/docs/1.0/testing/" rel="nofollow noreferrer">Flask test docs</a> get me so far, but don't describe how to deal with database connections.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>docker-compose</code> would allow you to accomplish both.</p>
<p>You could have a flask container to run your Flask app, and then a mongo container with a volume mounted to it as your data directory, and thus have a dev volume mount for your unit tests, and the actual production volume mount elsewhere in your CI/CD pipeline.</p>
<p><code>compose</code> also makes it easier for containers to talk with one another. So for example:</p>
<pre><code>version: "3"
services:
  flask:
    build: .
    image: flask-container
    depends_on:
      - mongodb
    environment:
     - 'MONGO_HOST=mongodb'
     - 'MONGO_PORT=27017'

    volumes:
     - ./conf/dev:/conf
  mongodb:
    image: mongo:latest
    container_name: "mongodb"
    environment:
    - MONGO_DATA_DIR=/data/db
    - MONGO_LOG_DIR=/dev/null
    volumes:
    - ~/unit-tests/data/db:/data/db
    ports:
    - 27017:27017
    command: mongod --smallfiles --logpath=/dev/null # --quiet

networks:
  default:
    external:
      name: cicd
</code></pre>
<p>Then they are on the same network, and Flask can just call <code>mongodb:27017</code> instead of an ip address</p>
</div>
