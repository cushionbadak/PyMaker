<div class="post-text" itemprop="text">
<p>I found something curious about how python tracks objects in <code>locals()</code>.</p>
<p>Considering the following script:</p>
<pre><code>import gc


class T(object):
    pass


def func1():

    t = T()

    #locals()
    del t
    #locals()

    for o in gc.get_objects():
        if type(o) is T:
            print("STILL EXISTS")


func1()
</code></pre>
<p>Running with both <code>locals()</code> calls commented (as above) gives me no messages, indicated that the <code>T()</code> object created was garbage collected.</p>
<p>When I run it with the first <code>locals()</code> command (removing the first comment), it seems to create a dictionary that contains a reference to my <code>t</code> object. This dictionary is not associated to any names, so I wouldn't expect this dict to live as without being garbage collected.</p>
<p>The problem is that, running the code, I get <code>"STILL EXISTS"</code>. Even if I delete <code>t</code> from the function namespace, the object is not garbage collected as the dict returned by <code>locals()</code> is still referring to it.</p>
<p>Funny enough, if I call <code>locals()</code> again (removing the second comment in the code above), then somehow the dictionary gets updated, it does not contain <code>t</code> in it and the object is garbage collected successfully (and I don't get an <code>"STILL EXISTS"</code> message).</p>
<p>I find this behaviour a bit weird.</p>
<p>Questions are:</p>
<ol>
<li>Is it normal that the dictionary returned by <code>locals()</code> is long
lived, even without associating it with any names?</li>
<li>Is it normal or is there any reason that this dictionary does not get updated automatically when deleting names from the current scope?</li>
</ol>
<p>Edit: I am using cpython 3.6</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>locals()</code> is weird. Inside a function, every <code>locals()</code> call copies the current local variable values into a dict associated with the stack frame and returns the dict. The dict is <em>not</em> used for actual local variable lookup, but it <em>is</em> attached to the frame object, and it is not a new dict every time; all <code>locals()</code> calls in the same stack frame reuse the same dict.</p>
<p>When you call <code>locals()</code>, the locals dict now has a reference to all objects currently referred to by local variables. This will keep those objects alive until either the stack frame dies, or a new <code>locals()</code> call is made inside that stack frame with different local variable values. A few other things will also update the locals dict, such as retrieving the <code>f_locals</code> attribute of the stack frame object, but local variable assignment does not update the locals dict by itself.</p>
</div>
<span class="comment-copy">I suspect the answer is highly dependent on the exact Python implementation. If you want an answer for CPython, which version exactly are you using? I also expect that Jython and PyPy would not have this behavior, as they both use true GC implementations, not CPython-style hybrid reference counting.</span>
<span class="comment-copy">Thanks, I updated the question with the information</span>
<span class="comment-copy">Thanks for the great answer! Is there any documentation somewhere on these details you mentioned?</span>
<span class="comment-copy">@SuperGeo: I don't think so. The <a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer"><code>locals()</code> docs</a> sort of vaguely allude to some of it, but the details are undocumented. Reading the <a href="https://github.com/python/cpython/blob/v3.7.0/Python/bltinmodule.c#L1594" rel="nofollow noreferrer">source</a> is frequently the best option.</span>
