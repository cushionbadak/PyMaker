<div class="post-text" itemprop="text">
<p>I have list which has more than 1000 elements</p>
<p>and i have a page where i must add those elements from the list but the thing is the page only accepts 40 entries at a time.</p>
<p>so what i am tring to do is  grab 40 elements from the list then submit those elements to the page using for loop then delete these elements from the list and grab 40 elements again, i need to do this till all the elements from the list are submitted to the page.</p>
<p>this is what i have done so far and failed</p>
<pre><code>mylist1 = ['1','2','3','4','5','6','7','8','9','10','10','11',]

def listget():
    newlistget = [x for x in mylist1]
    return newlistget



while True:
    for x in listget():
        for i in range(0,40):
            #do stuff
            mylist1.remove(mylist1[i])


    if not listget():
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to alter your initial data; instead, you can request successive chunks of a given size from it:</p>
<p>something like this:</p>
<p>In this example, if <code>len(seq)</code> is not a multiple of <code>chunk_size</code>, the last values will be what's left in the sequence.<br/>
The keyword argument <code>start</code> can optionally be set to start the chunks at an arbitrary location.</p>
<pre><code>def chunks(seq, chunk_size, start=0):
    while start &lt; len(seq):
        end = chunk_size + start
        yield(seq[start: end])
        start = end


if __name__ == '__main__':
    mylist = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '10', '11', ]
    for chunk in chunks(mylist, 3):
        print(chunk) 
</code></pre>
<h3>output:</h3>
<pre><code>['1', '2', '3']
['4', '5', '6']
['7', '8', '9']
['10', '10', '11']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why can't you slice the list every time, because remove will be a costly operation</p>
<pre><code>list1=[i for i in range(1234)] #some huge list
print(len(list1)) #1234

j=40
while(j&lt;len(list1)):
    new_list=list1[j-40:j] #slice the list for 40 elements
    print(len(new_list))  
    ''' add your processing here (like submitting)'''
    j+=40
new_list=list1[j-40:] #the last part of the list
print(len(new_list))
</code></pre>
<p>A generalized version to break a list into even sized chunks :</p>
<pre><code>n=40 #In this case
new_list = [my_list[i * n:(i + 1) * n] for i in range((len(my_list) + n - 1) // n )]  
</code></pre>
<p><code>new_list</code> is a list of lists with each list of size 40 (Maybe except the last one)</p>
</div>
<div class="post-text" itemprop="text">
<p>Even tho i don't fully understand the question, but i can do something that creates a list of list containing each forty elemnts, like:</p>
<pre><code>print([mylist1[i:i+40] for i in range(0,len(mylist1),40)])
</code></pre>
<p>Demo:</p>
<pre><code>mylist1 = list(range(1000))
print([mylist1[i:i+40] for i in range(0,len(mylist1),40)])
</code></pre>
</div>
<span class="comment-copy">The idea is similar to the "grouper" recipe in the itertools documentation <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html</a> which works for all iterables but returns tuples instead of lists.</span>
<span class="comment-copy">Yes, @Moberg, good point, itertools... I never think of it, unless it is combinatorics.</span>
<span class="comment-copy">will this also work if my list has words instead of numbers ?   my list has words and numbers</span>
<span class="comment-copy">@elrichbachman Yes it will</span>
<span class="comment-copy">wait let me try and thank you so much &lt;3 god bless ya &lt;3 btw i am also from india , can i get in touch with you bro ? skype ?</span>
<span class="comment-copy">@elrichbachman If it works, can you accept the answer</span>
<span class="comment-copy">your code works and solved my problem but can u help me with one more thing ?  why there is last part new_list=list1[j-40:] #the last part of the list  i dont want anything left in the list</span>
