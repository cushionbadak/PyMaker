<div class="post-text" itemprop="text">
<p>Ok guys, I can't understand this code:</p>
<pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
</code></pre>
<p>What does:</p>
<pre><code>socket.AF_INET
socket.SOCK_STREAM
</code></pre>
<p>do?
I really read everything abount them, but I can't understand what dows they do, could you please explain me, them in simple words?Thanks for read, have a great day!</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>TL;DR</strong></p>
<p><code>socket.AF_INET</code> = <a href="https://en.wikipedia.org/wiki/Network_socket#Socket_addresses" rel="nofollow noreferrer">The type of socket address</a></p>
<p><code>socket.SOCK_STREAM</code> = <a href="https://en.wikipedia.org/wiki/Network_socket#Types" rel="nofollow noreferrer">The type of socket</a></p>
<p><strong>Explanation</strong></p>
<p>Whenever you provide <code>socket.AF_INET</code> to your server you instruct it to listen to an IPv4 address, and to your client to connect to an IPv4 address. This will work. Same for IPv6. However mixing them up doesn't.</p>
<p>That would be the same me waiting for you to talk to me on StackOverflow while you send me messages by email. We are not looking at the same spot, so we won't be able to communicate.</p>
<p>Same for <code>socket.SOCK_STREAM</code> (and the other values). The difference lies in the fact that this tells python's <code>socket</code> <strong>how</strong> we are going to communicate. <code>socket.SOCK_STREAM</code> will be <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" rel="nofollow noreferrer">TCP</a>, while <code>socket.SOCK_DGRAM</code> will be <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" rel="nofollow noreferrer">UDP</a>.</p>
<p>Let's come back to our "<em>real world</em>" example and let's imagine we agreed on communicating by email. I could expect either <em>one</em> email from you (explaining me everything you have to tell) or several (with a part of what you have to say in each email). That's the same as TCP vs UDP.</p>
<p><strong>References</strong></p>
<p>Well, I guess you have read both:</p>
<ul>
<li><a href="https://docs.python.org/2/library/socket.html" rel="nofollow noreferrer">python's socket module</a></li>
<li><a href="https://docs.python.org/2.7/howto/sockets.html" rel="nofollow noreferrer">python's socket How to</a></li>
</ul>
<p>Potentially:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/4976897/what-is-address-family">SO: What is Address Family?</a></li>
<li><a href="https://en.wikipedia.org/wiki/IPv4" rel="nofollow noreferrer">Wikipedia: IPv4</a></li>
</ul>
<p>Also, I guess:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/24769338/difference-between-socket-types">Difference Between Socket Types
</a> (and the references therein)</li>
<li><a href="https://en.wikipedia.org/wiki/Network_socket#Types" rel="nofollow noreferrer">Wikipedia: Network socket - Types</a></li>
</ul>
<p><strong>Super long explanation but mostly testing</strong></p>
<p>So. If after all that you don't understand. Let's try:</p>
<pre class="lang-py prettyprint-override"><code># server.py

import socket

s = socket.socket()
s.bind(('localhost', 5050))
s.listen(5)

while True:
    (clientsocket, address) = s.accept()
    print 'client connected'
</code></pre>
<p>And:</p>
<pre class="lang-py prettyprint-override"><code># client.py

import socket

s = socket.socket(socket.AF_INET)
s.connect(('127.0.0.1', 5050))

print "Yeah! I'm connected :)"
</code></pre>
<p>So far, everything as in the <a href="https://docs.python.org/2.7/howto/sockets.html" rel="nofollow noreferrer">how to</a>.</p>
<p>We launch our server:</p>
<pre class="lang-sh prettyprint-override"><code>$ python server.py
</code></pre>
<p>And then we launch our client:</p>
<pre class="lang-sh prettyprint-override"><code>$ python client.py
Yeah! I'm connected :)
</code></pre>
<p>Everything works fine. That's good.</p>
<p>Now, lets change our client:</p>
<pre class="lang-py prettyprint-override"><code># client.py

import socket

s = socket.socket(socket.AF_INET6)
s.connect(('127.0.0.1', 5050))

print "Yeah! I'm connected :)"
</code></pre>
<p>And relaunch our <em>new</em> client:</p>
<pre class="lang-sh prettyprint-override"><code>$ python client.py
Traceback (most recent call last):
  File "client.py", line 4, in &lt;module&gt;
    s.connect(('127.0.0.1', 5050))
  File "/.../lib/python2.7/socket.py", line 228, in meth
    return getattr(self._sock,name)(*args)
socket.error: [Errno 65] No route to host
</code></pre>
<p>Aie! Everything breaks!</p>
<p><strong>But what happens?</strong> <code>127.0.0.1:5050</code> is an IPv4 address, hence the <code>socket</code> module tells us it's not happy about what we are doing! Indeed, we said our connection will be using an IPv6 address but we are providing it with an IPv4 address.</p>
<p>Okay... <em>But if I use the same address but in IPv6, will it work?</em> Let's try by changing our client (you could check out <a href="https://stackoverflow.com/questions/40189084/what-is-ipv6-for-localhost-and-0-0-0-0">this SO answer</a> for the equivalent of <code>127.0.0.1</code> for IPv6):</p>
<pre class="lang-py prettyprint-override"><code># client.py

import socket

s = socket.socket(socket.AF_INET6)
s.connect(('::1', 5050))

print "Yeah! I'm connected :)"
</code></pre>
<p>and our server:</p>
<pre class="lang-py prettyprint-override"><code># server.py

import socket

s = socket.socket(socket.AF_INET6)
s.bind(('::1', 5050))
s.listen(5)

while True:
    (clientsocket, address) = s.accept()
    print 'client connected'
</code></pre>
<p>We relaunch our server and our client:</p>
<pre class="lang-sh prettyprint-override"><code>$ python client.py
Yeah! I'm connected :)
</code></pre>
<p>Success!</p>
<p>The same procedure could be used to understand/test the <code>socket.SOCK_STREAM</code> parameter (but I think my answer is already long enough).</p>
<p>Hope this helped :).</p>
</div>
<div class="post-text" itemprop="text">
<p><code>socket.STREAM</code> is the kind of socket you want. In this case, you are looking to stream bytes to and from the host you want to connect to, rather than just issue a one-time call. This means that the socket will listen for bytes until it receives an empty byte <code>b''</code>, at which point it will terminate the connection (because the stream is complete). </p>
<p>I would imagine you aren't too worried about the type of socket, so low-level understanding here isn't paramount, nor could I give you a particularly satisfactory answer to that, either.</p>
<p><code>socket.AF_INET</code> is the AddressFamily, ipv4 or ipv6. This tells <code>sockets</code> what kind of address to expect. You will most likely use ipv4, so (host, port) tuple will work just fine.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/1593946/what-is-af-inet-and-why-do-i-need-it">AF_INET</a> is well described in there. It is basically the method you are using for sending data over to the other socket. SOCK_STREAM basically describes that you are sending using TCP and essentially describes rules for the endpoint to which you are sending and recieving data (IP adress and port number). </p>
<p>But since you seem confused over these terms I'd suggest just just think of them as specifications on how you are going to transmit data between your two socket endpoints.</p>
</div>
<span class="comment-copy">If you don't know the purpose of a constant, have a look at the <a href="https://docs.python.org/3/library/socket.html#socket.AF_INET" rel="nofollow noreferrer">docs</a>.</span>
<span class="comment-copy">What a beautiful answer!!!Thanks a lot!!!!Hope that you will have a great day!!!!</span>
<span class="comment-copy">AF_INET means that my socket will use IPV4?</span>
