<div class="post-text" itemprop="text">
<p>I run codes in Jupyter console(Python's version is <code>2.7.14</code>),</p>
<pre><code>type(1)
Out[71]: int

type.__call__(1)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-72-0ed097e2c413&gt; in &lt;module&gt;()
----&gt; 1 type.__call__(1)

TypeError: descriptor '__call__' requires a 'type' object but received a 'int'
</code></pre>
<p>I've guessed <code>type(...)</code> is a equivalent of <code>type.__call__(...)</code> but it seems no. So I wonder:</p>
<ol>
<li>What have been done by the python interpreter when I call <code>type(1)</code> or <code>type(name, base, dict)</code>?</li>
<li>When the <code>type.__call__(...)</code> will be invoked?</li>
</ol>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short version: There are two reasonable things <code>type.__call__</code> could resolve to: a bound method representing the method used for calling <code>type</code> itself, or an unbound method representing the method used for calling instances of <code>type</code>. You're expecting the first result, but what you actually get is the second.</p>
<hr/>
<p>Long version:</p>
<p><code>some_callable(thing)</code> is normally equivalent to <code>some_callable.__call__(thing)</code>. For example, <code>print(1)</code> is equivalent to <code>print.__call__(1)</code> (as long as you have <code>from __future__ import print_function</code> turned on):</p>
<pre><code>&gt;&gt;&gt; print(1)
1
&gt;&gt;&gt; print.__call__(1)
1
</code></pre>
<p><code>type</code> is a callable, and <code>type(thing)</code> <em>would</em> be equivalent to <code>type.__call__(thing)</code>, except that attribute lookup runs into a complication.</p>
<p>During the <code>type.__call__</code> attribute lookup, Python searches <code>type</code> and its superclasses (just <code>object</code>) for a <code>__dict__</code> entry with key <code>'__call__'</code>. Python <em>also</em> searches <code>type</code>'s type and <code>type</code>'s type's superclasses for such a <code>__dict__</code> entry. (You can see the code responsible for invoking these searches in <a href="https://github.com/python/cpython/blob/v2.7.15/Objects/typeobject.c#L2603" rel="nofollow noreferrer"><code>type_getattro</code></a>, the C function that handles attribute lookup for types.) Since <code>type</code> is its own type, both of these searches find <code>type.__dict__['__call__']</code>.</p>
<p>One of these searches takes priority. The way the choice is made, and the reason the choice even matters, is the <a href="https://docs.python.org/3/reference/datamodel.html#descriptors" rel="nofollow noreferrer">descriptor protocol</a>. If the first search wins, then the descriptor protocol is applied as normal for finding a class attribute (<code>descriptor.__get__(None, cls)</code>); if the second search wins, the descriptor protocol is applied as normal for finding an instance attribute (<code>descriptor.__get__(instance, cls)</code>). The second search needs to win for <code>type.__call__(thing)</code> to behave like <code>type(thing)</code>, but it would only win if <code>type.__dict__['__call__']</code> was a <em>data descriptor</em>, and it's not.</p>
<p>The first search wins. The descriptor protocol is applied as normal for finding a class attribute, and the result of looking up <code>type.__call__</code> is an <em>unbound</em> method. It represents the general <code>__call__</code> method of instances of <code>type</code>, rather than the <code>__call__</code> instance method of <code>type</code>-as-an-instance-of-type. It would need to be called as</p>
<pre><code>type.__call__(type, 1)
</code></pre>
<p>to be equivalent to <code>type(1)</code>.</p>
<hr/>
<p>After all that, you might be wondering how <code>type(thing)</code> works without running into all those complications. In terms of language semantics, Python only performs the second search when looking up <code>type</code>'s <code>__call__</code> method to call it, so the first search can't win because it doesn't even happen. In terms of actual implementation, CPython doesn't actually look up the <code>__call__</code> method at all; it looks up <code>type</code>'s type, goes to the C-level slot on <code>type</code>'s type corresponding to <code>__call__</code>, and calls <a href="https://github.com/python/cpython/blob/v2.7.15/Objects/typeobject.c#L737" rel="nofollow noreferrer">the function it finds</a>. For a <code>__call__</code> method implemented in Python, the C slot would contain a function that looks up and calls the Python method, but for a <code>__call__</code> implemented in C, the C slot contains the <code>__call__</code> implementation directly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>type</code> is a class, you need its <code>__new__</code> method:</p>
<pre><code>&gt;&gt;&gt; type.__new__(type, 1)
&lt;type 'int'&gt;
</code></pre>
<p>Usually, <code>cls(*args, **kwargs)</code> is equivalent to <code>cls.__new__(cls, *args, **kwargs)</code> followed by calling <code>.__init__(*args, **kwargs)</code> on the returned object.</p>
<p>Here's one possible implementation of this behavior of <code>type()</code>:</p>
<pre><code>class MyType(object):
    def __new__(cls, obj):
        return obj.__class__

    def __init__(self, hahaha):
        pass
</code></pre>
<p>See <a href="https://stackoverflow.com/a/52397896/5958455">blhsing's answer</a> for question 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer the second half of your question, since @iBug already answered the first half, <code>type.__call__</code> is a method of <code>type</code>, so instead of <code>type.__call__(1)</code>, you should call it as a bound method:</p>
<pre><code>self = type(1)
self.__call__(1)
</code></pre>
<p>or:</p>
<pre><code>type.__call__(type(1), 1)
</code></pre>
<p>both of which returns:</p>
<pre><code>type(1).__new__(type(1), 1)
</code></pre>
<p>which is really <code>int(1)</code> since <code>type(1)</code> returns <code>int</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason, as @user2357112 said, is that <code>type</code> acts as both a built-in function <sub>(which also doubles as a metaclass but that's not important here)</sub> and a class.</p>
<p><code>type(1)</code>, in accordance with <a href="https://docs.python.org/2/library/functions.html?highlight=type#type" rel="nofollow noreferrer">Built-in Functions â€” Python 2.7.15 documentation</a>, acts as a regular function that returns the type of an object or creates a new custom type object.</p>
<pre><code>In [13]: type?
Docstring:
type(object) -&gt; the object's type
type(name, bases, dict) -&gt; a new type
Type:      type
</code></pre>
<ul>
<li>It's implemented by <a href="https://github.com/python/cpython/blob/2.7/Objects/typeobject.c#L738" rel="nofollow noreferrer"><code>typeobject.c:type_call()</code></a> which is <a href="https://github.com/python/cpython/blob/2.7/Objects/typeobject.c#L2894" rel="nofollow noreferrer">specified as <code>PyType_Type.tp_call</code></a>.</li>
</ul>
<p><code>type.__call__</code>, on the other hand, is an implementation of the call for objects of the class <code>type</code> -- i.e. types -- which, as you know, creates an instance of that type. I.e. an unbound method:</p>
<pre><code>In [14]: type.__call__?
Type:        wrapper_descriptor
String form: &lt;slot wrapper '__call__' of 'type' objects&gt;
Namespace:   Python builtin
Docstring:   x.__call__(...) &lt;==&gt; x(...)
</code></pre>
<ul>
<li>It's implemented by <a href="https://github.com/python/cpython/blob/2.7/Objects/typeobject.c#L5600" rel="nofollow noreferrer"><code>typeobject.c:slot_tp_call()</code></a> which is returned on <code>__call__</code> attribute lookup, via <a href="https://github.com/python/cpython/blob/2.7/Objects/typeobject.c#L6037" rel="nofollow noreferrer"><code>typeobject.c:slotdefs[]</code></a> whose contents <code>type.__dict__</code> is filled with during initialization.</li>
</ul>
<hr/>
<p>The reason for the difference in execution paths is that attribute lookup is not done in the first case:</p>
<pre><code>In [16]: dis.dis(compile("type(1)","&lt;stdin&gt;","eval"))
  1           0 LOAD_NAME                0 (type)
              3 LOAD_CONST               0 (1)
              6 CALL_FUNCTION            1
              9 RETURN_VALUE

In [17]: dis.dis(compile("type.__call__(1)","&lt;stdin&gt;","eval"))
  1           0 LOAD_NAME                0 (type)
              3 LOAD_ATTR                1 (__call__)
              6 LOAD_CONST               0 (1)
              9 CALL_FUNCTION            1
             12 RETURN_VALUE
</code></pre>
<p>And <a href="https://github.com/python/cpython/blob/2.7/Objects/abstract.c#L2540" rel="nofollow noreferrer">when calling an object like a function, <code>tp_call</code> takes priority</a>.</p>
</div>
<span class="comment-copy">So how does <code>type(1)</code> work if <code>type</code> is a class?</span>
<span class="comment-copy"><code>cls(*args, **kwargs)</code> is not equivalent to <code>cls.__new__(cls, *args, **kwargs)</code>. Calling a class will normally perform <code>__init__</code> after calling <code>__new__</code>; it doesn't for <code>type(1)</code> because <code>type.__call__</code> specifically special-cases one-argument calls to <code>type</code> and does not call <code>__init__</code> for that case.</span>
<span class="comment-copy">@user2357112 Updated my answer. Thanks.</span>
