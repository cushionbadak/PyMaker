<div class="post-text" itemprop="text">
<p>I want to dynamically add arguments to a function <code>run_func</code> that calls another function.</p>
<p>If I do not copy the <code>__closure__</code> object from <code>run_func</code> to <code>modified_func</code>, Python crashes as soon as I try to call <code>modified_func</code>.</p>
<p>If I try to copy the old closure object to the modified function, it does not fit: "#ValueError: run_func requires closure of length 0, not 1"</p>
<p>How can I do the modification properly so the modified function does not crash?</p>
<pre><code>import types

def make_facade(func, param_names):
    def run_func():
        return func()

    code = run_func.__code__
    modified_code = types.CodeType(
        len(param_names), #code.co_argcount
        code.co_kwonlyargcount,
        len(param_names), #code.co_nlocals
        code.co_stacksize,
        code.co_flags,
        code.co_code,
        code.co_consts,
        code.co_names,
        tuple(param_names), #code.co_varnames
        code.co_filename,
        code.co_name,
        code.co_firstlineno,
        code.co_lnotab
    )

    #modified_func = types.FunctionType(modified_code, run_func.__globals__, closure=run_func.__closure__) #ValueError: run_func requires closure of length 0, not 1
    modified_func = types.FunctionType(modified_code, run_func.__globals__)

    return modified_func

def ffff(dict):
    print(dict)

ffff_facade = make_facade(ffff, ['arg1', 'arg2'])

help(ffff_facade)    #Help on function run_func in module __main__:    run_func(arg1, arg2)

ffff_facade(1, 2) #Crash
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way to add parameters to a function is to replace it with another function that accepts <code>*args</code> and/or <code>**kwargs</code>. You can then also assign a fake <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature" rel="nofollow noreferrer"><code>Signature</code></a> to the new function's <code>__signature__</code> attribute in order to get a nice output from the <a href="https://docs.python.org/3/library/functions.html#help" rel="nofollow noreferrer"><code>help</code></a> function.</p>
<hr/>
<p>Code:</p>
<pre><code>import functools
import inspect


def add_parameters_to_signature(signature, param_names):
    params = list(signature.parameters.values())

    for param_name in param_names:
        param = inspect.Parameter(param_name, inspect.Parameter.POSITIONAL_OR_KEYWORD)
        params.append(param)

    return signature.replace(parameters=params)

def add_parameters(func, param_names):
    signature = inspect.signature(func)
    signature = add_parameters_to_signature(signature, param_names)

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        bound_args = signature.bind(*args, **kwargs)

        # now we can do something with the arguments we received, for example
        # pass them to the wrapped function:
        print('Received positional arguments:', bound_args.args)
        print('Received keyword arguments:', bound_args.kwargs)
        return func(bound_args.arguments['foo'])

    # assign the new signature to the function's __signature__ attribute so that
    # functions like `help` and `inspect.signature` can see it
    wrapper.__signature__ = signature

    return wrapper


def print_foo(foo):
    print('Received foo:', foo)

facade = add_parameters(print_foo, ['arg1', 'arg2'])

facade('foo', 1, 2)
# Output:
# Received positional arguments: ('foo', 1, 2)
# Received keyword arguments: {}
# Received foo: foo
</code></pre>
<p>Function and class reference:</p>
<ul>
<li><a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow noreferrer"><code>inspect.signature</code></a> is used to obtain the wrapped function's signature</li>
<li><a href="https://docs.python.org/3/library/inspect.html#inspect.Parameter" rel="nofollow noreferrer"><code>inspect.Parameter</code></a> instances are created to alter the obtained signature</li>
<li><a href="https://docs.python.org/3/library/inspect.html#inspect.Signature.bind" rel="nofollow noreferrer"><code>Signature.bind</code></a> is used to match the received <code>*args</code> and <code>**kwargs</code> to the function's parameters</li>
</ul>
</div>
<span class="comment-copy">What's the point of this added parameter? How does the function use it? If you add a parameter to your <code>run_func</code> function, the result will still be the same since it never uses it.</span>
<span class="comment-copy">This is proof of concept with minimal code. As usual, the minimal code is useless, but it shows the problem in a succinct way without any distractions and red herrings. If you're curious, my actual function executes <code>return func(locals())</code></span>
<span class="comment-copy">But then isn't it easier to make a copy of the <code>locals</code> dict and add a key:value pair to that dict, rather than adding an actual local variable?</span>
<span class="comment-copy">The end goal is to dynamically create a facade function with proper signature. The facade just needs to pass arguments as a dict.</span>
<span class="comment-copy">@Aran-Fey I'm not sure I understand your comment. If the unmodified <code>run_func</code> is called, <code>locals()</code> returns empty dict. But when you call the modified function, it's non-empty.</span>
<span class="comment-copy">I'm sorry, but this does not answer my question. I know how to work around the problem. I was trying to understand what exactly is <code>__closure__</code> and how to create or modify it. P.S. BTW, one problem with your code is that it happily accepts any arguments and does not give error when there are missing or extra arguments.</span>
