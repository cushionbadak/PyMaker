<div class="post-text" itemprop="text">
<p>I am attempting to call a bash script via the subprocess Popen function passes in a  for loop. My intent is that with each iteration, a new string <strong>commit</strong> from an array <strong>out</strong> is passed as an argument to the Popen command. The command invokes a bash script that outputs a text identified by the variable <strong>commit</strong> and greps certain lines from that particular text. However, I can't get the output to flush out in the Python for loop. Right now, only the grepped data from the final <strong>commit</strong> in <strong>out</strong> is being passed into my final data structure (a pandas dataframe).</p>
<pre><code>accuracy_dictionary = {}
for commit in out:
    accuracy_dictionary.setdefault(commit, {})
    p2 = subprocess.Popen(['~/Desktop/find_accuracies.sh', commit], encoding='utf-8', shell=True, stdout=subprocess.PIPE)
    outputstring = p2.stdout.read()
    # This part below is less critical to the problem at hand
    # I'm putting the data from each file in a dictionary
    for acc_type_line in outputstring.split('\n'):
        accuracy = acc_type_line.split(': ')
        if accuracy != ['']:
            acc_type = accuracy[0]
            value = accuracy[1]
            accuracy_dictionary[commit][acc_type] = float(value)

acc_data = pd.DataFrame.from_dict(accuracy_dictionary).T
</code></pre>
<p>Here is the bash script that is being called:</p>
<p>"find_accuracies.sh":</p>
<pre><code>#!/bin/sh

COMMIT=$1
git show $COMMIT:blahblahfolder/blahblah.txt | grep --line-buffered 'accuracy'
</code></pre>
<p>acc_data returns a dataframe of nrows=len(<strong>out</strong>) populated by unique <strong>commit</strong>s, but the <strong>value</strong> is the exact same for all rows for each <strong>acc_type</strong></p>
<p>For example, my output looks like this:
<a href="https://i.stack.imgur.com/dH4Bc.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/dH4Bc.png"/></a></p>
<p>How can I call the file "find_accuracies.sh" with the subprocess command and have it flush the unique values of each file for each commit?</p>
</div>
<div class="post-text" itemprop="text">
<p>I hope this help addressing the immediate problem you're seeing: Here you should really use <code>communicate</code> with <code>subprocess.PIPE</code> as it waits for the command to finish and give give you all of its output:</p>
<pre><code>outputstring = p2.communicate()[0]
</code></pre>
<p>You can also use convenient method like <code>check_output</code> to the same effect:</p>
<pre><code>outputstring = subprocess.check_output(['~/Desktop/find_accuracies.sh', commit],
                                       encoding='utf-8', shell=True)
</code></pre>
<p>Or also in py3 use <code>run</code> should also do:</p>
<pre><code>p2 = subprocess.run(['~/Desktop/find_accuracies.sh', commit],
                    encoding='utf-8', shell=True, stdout=subprocess.PIPE)
outputstring = p2.stdout
</code></pre>
<p>Now few more comments, hints and suggestions:</p>
<p>I am a little surprised it works for you as using <code>shell=True</code> and list of arguments <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer">should</a> (see the paragraph starting with <em>"On POSIX with <code>shell=True</code>"</em>) make your <code>commit</code> argument of the underlying <code>sh</code> wrapped around your script call and not of the script itself. In any case you can (and I would suggest to) actually drop the <code>shell</code> and leave <code>HOME</code> resolution to python:</p>
<pre><code>from pathlib import Path
executable = Path.home().joinpath('Desktop/find_accuracies.sh')

p2 = subprocess.run([executable, commit],
                    encoding='utf-8', stdout=subprocess.PIPE)
outputstring = p2.stdout
</code></pre>
<p>You can (or must for py &lt;3.5) also use <code>os.path.expanduser('~/Desktop/find_accuracies.sh')</code> instead of <code>Path.home()</code> to get script <code>executable</code>. On the other hand for &gt;=3.7 you could replace <code>stdout=subprocess.PIPE</code> with <code>capture_output=True</code>.</p>
<p>And last but not least. It seems a bit unnecessary to call a bash script (esp. double wrapped in <code>sh</code> call like in the original example) just to run <code>git</code> through <code>grep</code> when we already have a python script to process the information. I would actually try to run the corresponding <code>git</code> command directly getting the bulk of its output and process its output in the python script itself to get the bits of interest.</p>
</div>
<span class="comment-copy">Doesn't help your problem, but note that you are not calling a <code>bash</code> script since the header is <code>#!/bin/sh</code>, so you are calling <code>sh</code>, not <code>bash</code> - yes, there are huge differences, even if <code>sh</code> is linked to <code>bash</code>.</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/107705/disable-output-buffering" title="disable output buffering">stackoverflow.com/questions/107705/disable-output-buffering</a></span>
