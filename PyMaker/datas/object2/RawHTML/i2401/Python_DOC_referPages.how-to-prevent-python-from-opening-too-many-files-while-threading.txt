<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/474528/what-is-the-best-way-to-repeatedly-execute-a-function-every-x-seconds-in-python">What is the best way to repeatedly execute a function every x seconds in Python?</a>
<span class="question-originals-answer-count">
                    15 answers
                </span>
</li>
</ul>
</div>
<p>I need to run a specific function every second. I have searched for a solution and found <a href="https://stackoverflow.com/a/3393759/9982372">this one</a>:</p>
<pre><code>import threading

def printit():
  threading.Timer(5.0, printit).start()
  print "Hello, World!"

printit()
</code></pre>
<p>It seems to be the code I have been searching for. But after running those lines of code for 20 Minutes I have got following error message:</p>
<blockquote>
<p>Exception in thread Thread-1896: Traceback (most recent call last):
  File "/usr/lib/python3.5/threading.py", line 914, in _bootstrap_inner
  File "/usr/lib/python3.5/threading.py", line 1180, in run File
  "/home/pi/scanner/api/brightness.py", line 37, in adjust_brightness
  File "/home/pi/scanner/api/brightness.py", line 14, in get_brightness
  OSError: [Errno 24] Too many open files</p>
</blockquote>
<p>It seems that every time the function is called a new thread starts. Is there a way to stop the previous thread before the new one gets generated? Or are there other solutions where this doesn't happen? </p>
</div>
<div class="post-text" itemprop="text">
<p><em>Note: you can use the <a href="https://docs.python.org/3/library/sched.html" rel="nofollow noreferrer">sched</a> module if you want, refer to <a href="https://stackoverflow.com/a/474543/8746648">this answer</a>.</em></p>
<p>Otherwise, here is a small utility function that only uses one thread:</p>
<pre><code>import threading, time

def schedule(func, timeout):
  """execute 'func' in another thread every 'timeout' seconds"""
  def _schedule():
    while True:
      func()
      time.sleep(timeout)

  threading.Thread(target=_schedule).start()

def printit():
  print("Hello, World!")

schedule(printit, 1.0)
</code></pre>
<p><em>Note: if your function takes some time to execute, e.g. 0.5 seconds then the function would be called every 1.5 seconds instead. This can be avoided by measuring the time of execution and subtracting it from the timeout. For such a simple example this would be overkill. (And would introduce an edge case, when the execution takes longer than the timeout).</em></p>
</div>
<span class="comment-copy">Exactly what I thought. How can my problem be better solved?</span>
<span class="comment-copy">You said "every time the function is called a new thread starts". Indeed! It's a simple auto-repeating timer. A program that uses it is only supposed to call it once, and then it restarts itself every 5 seconds. So you will cause chaos if you try to call it yourself multiple times. Maybe take a look at some of the other solutions on that page, like MestreLion's.</span>
