<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/12200580/numpy-function-for-simultaneous-max-and-min">numpy: function for simultaneous max() and min()</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<p>My question arises from answers posted to <a href="https://stackoverflow.com/questions/52354081/how-to-find-the-missing-numbers-in-an-arbitrary-list-in-python-3">How to find the missing numbers in an arbitrary list in python 3?</a>.</p>
<p>Most solutions suggest using something akin to </p>
<pre><code>a = [10,12,13,8]
# get set of full numbers
allNums = set( (x for x in range(min(a),max(a)+1)))
# do some kind of set operation / symetric difference 
</code></pre>
<p>This needs 2 iterations of <code>a</code> to fetch <code>min(a)</code> and <code>max(a)</code> as values from the list to build the range that entails all numbers between <code>min(a)</code> and <code>max(a)</code>.</p>
<p>It is easy to simplify this to just one pass of <code>a</code>:</p>
<pre><code>def minmax(data):
    """Get the min and max of an iterable in O(n) time and constant space."""
    minValue = data[0]
    maxValue = data[0]
    for d in data[1:]:
        minValue = d if d &lt; minValue else minValue
        maxValue = d if d &gt; maxValue else maxValue
    return (minValue,maxValue)
</code></pre>
<p>that retrieves both in O(n) time and constant space. </p>
<p>Is there some way to do this with built-ins / modules in python?</p>
<p>Edit:
Agreed: min() and max() are both O(n) as well - but used twice (which is constant and reduced to O(n) - yep) - but it is still slower to do it twice then once.</p>
<hr/>
<p>Edit with some benchmarkings:  </p>
<pre><code>import timeit

# 100k random numbers to min/max upon
data = """import random
random.seed(42)
data = random.choices(range(1000000),k=100000)"""
</code></pre>
<p><a href="https://stackoverflow.com/a/52354454/7505395">Functool reduce approach</a>: </p>
<pre><code>t1 = timeit.timeit("""
mi,ma=minmax(data)
""",setup="""
import functools

def minmax(aa):
    return functools.reduce(lambda mm,xx : ( min(mm[0],xx),max(mm[1],xx)) , aa, ( aa[0],aa[0],))
""" + data, number = 1000 )
</code></pre>
<p>Simple min / max usage:</p>
<pre><code>t2 = timeit.timeit("""
mi,ma=min(data),max(data)
""",setup=data, number = 1000)
</code></pre>
<p>One pass try with if/elif to cut on comparisons:</p>
<pre><code>t3 = timeit.timeit("""
mi,ma=minmax(data) 
""",setup="""
def minmax(data):
    minValue = data[0]
    maxValue = data[0]
    for d in data[1:]:
        if d &lt; minValue:     # changed to if / elif: in a vain attempt to make it faster
            minValue = d     # its closer to the proposed solution in the numpy-question 
        elif d &gt; maxValue:   # linked above
            maxValue = d
    return (minValue,maxValue)
""" + data, number = 1000)
</code></pre>
<p>One pass try without if/elif (more comparisons needed):</p>
<pre><code>t4 = timeit.timeit("""
mi,ma=minmax(data) 
""",setup="""
def minmax(data):
    minValue = data[0]
    maxValue = data[0]
    for d in data[1:]:
        minValue = d if d &lt; minValue else minValue 
        maxValue = d if d &gt; maxValue else maxValue 
    return (minValue,maxValue)
""" + data, number = 1000)
</code></pre>
<p>Which lead to:</p>
<pre><code>minmanx-reduce:      148.5929143627707   
default min + max:     3.376458476185718     # ouch .. seems we just use these
minmax1passOptimized: 15.975109436292087   
minmax1pass:          20.29275910515082
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functools.html?highlight=reduce#functools.reduce" rel="nofollow noreferrer">functools.reduce</a></p>
<pre><code>import functools

def minmax(aa):
    return functools.reduce(lambda mm,xx : ( min(mm[0],xx),max(mm[1],xx)) , aa, ( aa[0],aa[0],))

print(minmax([10,25,5,100,12,32])) # print (5, 100)
</code></pre>
</div>
<span class="comment-copy">O(n + n) = O(n)</span>
<span class="comment-copy">Just use <code>min(list)</code> and <code>max(list)</code></span>
<span class="comment-copy">@PatrickArtner, it depends on your overall algorithm complexity and the number of times you need to find min and max. I hardly can think of the problem when this 2n cases a bottleneck.</span>
<span class="comment-copy">@PatrickArtner, you might find answers to <a href="https://stackoverflow.com/questions/12200580/numpy-function-for-simultaneous-max-and-min">this</a> similar question interesting</span>
<span class="comment-copy">First of all, both the solutions you propose take 2n (O(n) asymptotically). If you want an even better approach you could find both min and max in less than 2n comparisons, actually you could find that in 1.5n comparisons, see here for example: <a href="http://www.cs.nthu.edu.tw/~wkhon/algo09/lectures/lecture8.pdf" rel="nofollow noreferrer">cs.nthu.edu.tw/~wkhon/algo09/lectures/lecture8.pdf</a> .Of course asymptotically both ways are O(n) but practically 1.5n is faster than 2n comparisons.</span>
<span class="comment-copy">I think you should time that against just calling <code>min</code> and <code>max</code> once.</span>
<span class="comment-copy">This approach is slower. However it answer the op question ...</span>
