<div class="post-text" itemprop="text">
<p>I have to access the Nth line in a CSV file.</p>
<p>Here's what I did:</p>
<pre><code>import csv

the_file = open('path', 'r')
reader = csv.reader(the_file)

N = input('What line do you need? &gt; ')
i = 0

for row in reader:
    if i == N:
        print("This is the line.")
        print(row)
        break

    i += 1

the_file.close()
</code></pre>
<p>...but this does not feel optimal. Edit for precision: If the file is huge, I do not want to go through all the lines and I do not want to have to load the whole file into memory.</p>
<p>I do hope something like <code>reader[N]</code> exists, but I have not found it.</p>
<p>Edit for answer: This line (coming from chosen answer) is what I was looking for:</p>
<pre><code>next(itertools.islice(csv.reader(f), N, None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It makes little difference but it is slightly cleaner to use <code>enumerate</code> rather than making your own counter variable.</p>
<pre><code>for i, row in enumerate(reader):
    if i == N:
        print("This is the line.")
        print(row)
        break
</code></pre>
<p>You can also use <code>itertools.islice</code> which is designed for this type of scenario - accessing a particular slice of an iterable without reading the whole thing into memory. It should be a bit more efficient than looping through the unwanted rows.</p>
<pre><code>with open(path, 'r') as f:
    N = int(input('What line do you need? &gt; '))
    print("This is the line.")
    print(next(itertools.islice(csv.reader(f), N, None)))
</code></pre>
<p>But if your CSV file is small, just read the entire thing into a list, which you can then access with an index in the normal way. This also has the advantage that you can access several different rows in random order without having to reset the csv reader.</p>
<pre><code>my_csv_data = list(reader)
print(my_csv_data[N])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your solution is actually not that bad.  Advancing the file iterator to the line you want is a good approach and is used in many situations like this.</p>
<p>If you want it more concise though, you can use <a href="https://docs.python.org/3/library/functions.html#next" rel="noreferrer"><code>next</code></a> and <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="noreferrer"><code>enumerate</code></a> with a <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression" rel="noreferrer">generator expression</a>:</p>
<pre><code>import csv

the_file = open('path', 'r')
reader = csv.reader(the_file)

N = int(input('What line do you need? &gt; '))

line = next((x for i, x in enumerate(reader) if i == N), None)
print(line)

the_file.close()
</code></pre>
<p>The <code>None</code> in there is what will be returned if the line is not found (<code>N</code> is too large).  You can pick any other value though.</p>
<hr/>
<p>You could also open the file with a <a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="noreferrer">with-statement</a> to have it be automatically closed:</p>
<pre><code>import csv

with open('path', 'r') as the_file:
    reader = csv.reader(the_file)

    N = int(input('What line do you need? &gt; '))

    line = next((x for i, x in enumerate(reader) if i == N), None)
    print(line)
</code></pre>
<hr/>
<p>If you really want to cut down on size, you could do:</p>
<pre><code>from csv import reader
N = int(input('What line do you need? &gt; '))
with open('path') as f:
    print(next((x for i, x in enumerate(reader(f)) if i == N), None))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply do:</p>
<pre><code>n = 2 # line to print
fd = open('foo.csv', 'r')
lines = fd.readlines()
print lines[n-1] # prints 2nd line
fd.close()
</code></pre>
<p>Or even better to utilize less memory by not loading entire file into memory:</p>
<pre><code>import linecache
n = 2
linecache.getline('foo.csv', n)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The<code>itertools</code>module has a number of functions for creating specialized iterators — and its<a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow"><code>islice()</code></a> function could be used to easily solve this problem:</p>
<pre><code>import csv
import itertools

N = 5  # desired line number

with open('path.csv', newline='') as the_file:
    row = next(csv.reader(itertools.islice(the_file, N, N+1)))

print("This is the line.")
print(row)
</code></pre>
<p>P.S. For the curious, my initial response — which also works (arguably better) — was:</p>
<pre><code>    row = next(itertools.islice(csv.reader(the_file), N, N+1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could minimize your <code>for</code> loop into a comprehension expression, e.g.</p>
<pre><code>row = [row for i,row in enumerate(reader) if i == N][0]  

# or even nicer as seen in iCodez code with next and generator expression

row = next(row for i,row in enumerate(reader) if i == N)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import csv
with open('cvs_file.csv', 'r') as inFile: 
    reader = csv.reader(inFile)
    my_content = list(reader)

line_no = input('What line do you need(line number begins from 0)? &gt; ')
if line_no &lt; len(my_content):
    print(my_content[line_no])
else:
    print('This line does not exists')
</code></pre>
<hr/>
<p>As a <code>result</code> now you can get any line by its <code>index</code> <code>directly</code>:</p>
<pre><code>What line do you need? &gt; 2
['101', '0.19', '1']

What line do you need? &gt; 100
This line does not exists
</code></pre>
</div>
<span class="comment-copy">Is 'optimal' in terms of code compactness? Could do <code>lines = [row for row in reader]</code>, then <code>lines[N]</code>. Note that like some other answers, this requires reading the whole file.</span>
<span class="comment-copy">The question appears to be off-topic because it is about optimization of working code, fits best on //codereview.stackexchange.com</span>
<span class="comment-copy">As Ollie said, no matter what the code looks like, you're starting at position 0 of the document, and going to position x. This isn't like an array where some math can be done to quickly jump to the right location.</span>
<span class="comment-copy">@OllieFord <code>lines = list(reader)</code> would be more idiomatic.</span>
<span class="comment-copy">@Veedrac Nice. <code>list(reader)[N]</code> is probably optimal if compactness of code is the goal.</span>
<span class="comment-copy">To get the line number right using <code>enumerate()</code>, you'd probably want to add the keyword argument <code>start=1</code> to the call.</span>
<span class="comment-copy">@martineau maybe but I've left it as it is to match the OP's code which starts at 0.</span>
<span class="comment-copy">Ah, you're right. Updated my own answer according.</span>
<span class="comment-copy">pythons csv reader has a line_num property so you wouldn't have to use enumerate if you didn't want to.  Something like...  if reader.line_num == N: do something</span>
<span class="comment-copy">Nice use of next! Never seen that before:-) +1</span>
<span class="comment-copy">More compact code, but slower for small <code>n</code>.</span>
<span class="comment-copy">@OllieFord: Thanks for the observation. <code>linecache</code> can be used as an alternative.</span>
<span class="comment-copy">What about multi-line fields in the CSV?</span>
<span class="comment-copy">As I understand that document the CSV format allows line breaks in fields as long as they are within double quotes (section 2, para 6), so if there's any possibility of this it's better to use <code>csv.reader</code></span>
<span class="comment-copy">If you look at the source for the <a href="https://hg.python.org/cpython/file/2.7/Lib/linecache.py" rel="nofollow noreferrer"><code>linecache</code></a>module, you'll see that it reads the entire file into memory using <code>file.readlines()</code>, too, so it wouldn't use less memory. It also additional overhead incurred since it was intended to be used for reading many lines from [other] imported modules, rather than a single one from a data file.</span>
<span class="comment-copy">If you're sure the CSV maps source lines to CSV lines 1:1, do the slicing over the file (<code>islice(infile, ...)</code>) before passing it into <code>csv.reader</code>.</span>
<span class="comment-copy">@Veedrac: Very good point...updated.</span>
<span class="comment-copy">@Veedrac except you gain nothing from that except potential for erroneous data later on... I'd have personally stuck with the original version</span>
<span class="comment-copy">@JonClements For <code>N = 16...4096</code> in factors of two, the speed advantage of my approach is a factor of <code>[2, 3, 5, 7, 10, 12, 12, 15, 16]</code>.</span>
<span class="comment-copy">@Veedrac I'd have gone for a little bit - but certainly wouldn't have figured that large a difference! Many thanks for taking the time to respond with some numbers.</span>
<span class="comment-copy">@Veedrac Thanks, I used dict based on of its O(1) complexity for d[k] but even l[i] has same O(1) complexity.</span>
