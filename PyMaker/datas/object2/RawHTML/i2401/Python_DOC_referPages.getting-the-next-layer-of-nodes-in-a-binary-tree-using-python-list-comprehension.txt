<div class="post-text" itemprop="text">
<p>I'm working on the LeetCode problem <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" rel="nofollow noreferrer">Maximum Depth of Binary Tree</a>, and would like to define a helper function <code>get_next_nodes</code> which, given a list of nodes in one 'layer' of the tree, returns the list of nodes in the next layer. I've tried the following:</p>
<pre><code># Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


def get_next_nodes(nodes):
    return [next_node for next_node in (node.left, node.right) for node in nodes if next_node]


def test_get_next_nodes():
    tree = TreeNode(1)
    tree.left = TreeNode(2)
    assert get_next_nodes([tree]) == [tree.left]
</code></pre>
<p>However, this test fails because <code>node</code> is not defined in the list comprehension:</p>
<pre><code>Kurts-MacBook-Pro:LeetCode kurtpeek$ pytest maximum_depth_of_binary_tree.py::test_get_next_nodes
============================= test session starts ==============================
platform darwin -- Python 3.7.0, pytest-3.6.4, py-1.5.4, pluggy-0.6.0
rootdir: /Users/kurtpeek/GoogleDrive/LeetCode, inifile:
plugins: timeout-1.3.2
collected 1 item                                                               

maximum_depth_of_binary_tree.py F                                        [100%]

=================================== FAILURES ===================================
_____________________________ test_get_next_nodes ______________________________

    def test_get_next_nodes():
        tree = TreeNode(1)
        tree.left = TreeNode(2)
&gt;       assert get_next_nodes([tree]) == [tree.left]

maximum_depth_of_binary_tree.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nodes = [TreeNode(1)]

    def get_next_nodes(nodes):
&gt;       return [next_node for next_node in (node.left, node.right) for node in nodes if next_node]
E       NameError: name 'node' is not defined

maximum_depth_of_binary_tree.py:35: NameError
=========================== 1 failed in 0.04 seconds ===========================
</code></pre>
<p>I've tried to compare with examples in <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions</a> but so far don't see how to refactor the list comprehension to get it to work. How can I fix this helper function?</p>
<p><strong>Update</strong></p>
<p>I got the helper function to work when written as follows:</p>
<pre><code>def get_next_nodes(nodes):
    next_nodes = []
    for node in nodes:
        next_nodes += [child for child in (node.left, node.right) if child]
    return next_nodes
</code></pre>
<p>However, this seems like the type of pattern that could be refactored using list comprehension.</p>
</div>
<div class="post-text" itemprop="text">
<p>You confused the order of clauses in the nested list comprehension. Correct expression:</p>
<pre><code>return [next_node 
            for node in nodes 
                for next_node in (node.left, node.right) 
                    if next_node]
</code></pre>
<p>Think of a nested LC as a nested loop: an iteration of the outer loop (<code>for node in nodes</code>) is executed first.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should write your <code>for</code>s in the list comprehension in another order:</p>
<pre><code>[next_node for node in nodes for next_node in (node.left, node.right) if next_node]
</code></pre>
<p>The <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">docs for list comprehensions</a> have an example on such a multi-level list comprehension with an explanation how it is evaluated.</p>
<p>In your case it would be:</p>
<pre><code>result = []
for node in nodes:
    for next_node in (node.left, node.right):
        if next_node:
            result.append(next_mode)
return result
</code></pre>
<p>Note that changing the order of the two <code>for</code> loops would make no sense, because <code>node</code> would be undefined.  This is exactly what happens in your code.</p>
</div>
