<div class="post-text" itemprop="text">
<p>I am using a function below to run the apriori algorithm and calculate support, confidence for all itemsets. The function uses a dictionary object to store all values of items and their corresponding support, confidence.</p>
<p>After running the if statement to select items having minimum support value of 0.15 and confidence of 0.6, I am getting an error below that dict_items object is not subscriptable. </p>
<pre><code>for key, value in largeSet.items()[1:]:

TypeError: 'dict_items' object is not subscriptable



def runApriori(data_iter, minSupport, minConfidence):
    """
    run the apriori algorithm. data_iter is a record iterator
    Return both:
     - items (tuple, support)
     - rules ((pretuple, posttuple), confidence)
    """
    itemSet, transactionList = getItemSetTransactionList(data_iter)

    freqSet = defaultdict(int)
    largeSet = dict()
    # Global dictionary which stores (key=n-itemSets,value=support)
    # which satisfy minSupport

    assocRules = dict()
    # Dictionary which stores Association Rules

    oneCSet = returnItemsWithMinSupport(itemSet,
                                        transactionList,
                                        minSupport,
                                        freqSet)

    currentLSet = oneCSet
    k = 2
    while(currentLSet != set([])):
        largeSet[k-1] = currentLSet
        currentLSet = joinSet(currentLSet, k)
        currentCSet = returnItemsWithMinSupport(currentLSet,
                                                transactionList,
                                                minSupport,
                                                freqSet)
        currentLSet = currentCSet
        k = k + 1

    def getSupport(item):
            """local function which Returns the support of an item"""
            return float(freqSet[item])/len(transactionList)

    toRetItems = []
    for key, value in largeSet.items():
        toRetItems.extend([(tuple(item), getSupport(item))
                           for item in value])

    toRetRules = []
    for key, value in largeSet.items()[1:]:
        for item in value:
            _subsets = map(frozenset, [x for x in subsets(item)])
            for element in _subsets:
                remain = item.difference(element)
                if len(remain) &gt; 0:
                    confidence = getSupport(item)/getSupport(element)
                    if confidence &gt;= minConfidence:
                        toRetRules.append(((tuple(element), tuple(remain)),
                                           confidence))
    return toRetItems, toRetRules

if __name__ == "__main__":
    inFile = ''
    minSupport = 0.15
    minConfidence = 0.6

    items, rules = runApriori(inFile, minSupport, minConfidence)

    printResults(items, rules) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're not supposed to be relying on dictionaries having a particular order, so python doesn't let you skip the "first" item in a dictionary, since what is "first" depends on there being a particular order. You can cast it as a list: <code>for key, value in list(largeSet.items())[1:]</code>, but that would rely on the dictionary order being what you expect it would be. Better would to just do <code>for key, value in largeSet.items())</code>, then check within the loop whether it's the item you don't want to operate on, and <code>continue</code> if it is. Or use pandas series.</p>
</div>
<div class="post-text" itemprop="text">
<p>Prior to CPython 3.6 (and 3.7 for any Python interpreter), <code>dict</code>s have no reliable ordering, so assuming the first item is the one you want to skip is a <em>bad</em> idea.</p>
<p>That said, if you're on 3.6+, <em>and</em> you know you want to skip the first element, you can <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer">use <code>itertools.islice</code></a> to do this safely, changing:</p>
<pre><code>for key, value in largeSet.items()[1:]:
</code></pre>
<p>to:</p>
<pre><code># At top of file
from itertools import islice

for key, value in islice(largeSet.items(), 1, None):    
</code></pre>
</div>
<span class="comment-copy">Have you tried searching for the error the trace gives you?</span>
