<div class="post-text" itemprop="text">
<p>I have a code that calculates Euclidean distance for me:</p>
<pre><code>class Point:
    """A point in two-dimensional space."""

    def __init__(self, x, y):
        self._x = x
        self._y = y

    def __eq__(self, other):
        return self._x == other._x and self._y == other._y

    def distance(self, other):
        new_x = self._x - other._x
        new_y = self._y - other._y
        print(new_x,'  ',new_y)
        return (new_x ** 2 + new_y ** 2) ** 0.5

p1 = Point(10, 4)
p2 = Point(3, 1)


print('Euclidean distance : 'p1.distance(p2))
</code></pre>
<p>However, now I want to calculate this distance using magic methods in python like <code>__sub__</code> and <code>__pow__</code>. I've managed to implement <code>__sub__</code> but I don't know how to implement for <code>__pow__</code> and square root. This is my code so far:</p>
<pre><code>class Point_1(object):

    def __init__(self, x, y):
        self._x = x
        self._y = y


    def setX(self, x,y):
        self._x = x
        self._y = y

    def getX(self):
        return self._x,self._y


    def __sub__ (self, other ):
        return Point_1(self._x - other._x, self._y - other._y)

    def __pow__(self,p):
        return Point_1(self._x ** p, self._y **p)




p1 = Point_1(10,4)
print(p1.getX())

p2 = Point_1(3,1)
print(p2.getX())

p3 = p1 - p2
</code></pre>
<p>How can I implement the rest of the formula using magic methods. I'm really confused. Help would me appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>As has been mentioned, it may not be a good idea to use a Point class to represent vectors. It's ok in simple programs, but it can get confusing in more complex code. The usual practice is to make points immutable. But anyway...</p>
<p>To do this Euclidean distance operation we can "abuse" the new <a href="https://docs.python.org/3/reference/datamodel.html#object.__matmul__" rel="nofollow noreferrer"><code>__matmul__</code></a> magic method. This method is invoked by the <code>@</code> operator. Here's a short demo based on your code. Notice that I'm using <code>x</code> and <code>y</code> as the attributes, there's no good reason to mark them as private.</p>
<pre><code>class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return "Point({}, {})".format(self.x, self.y)

    def __add__ (self, other ):
        return Point(self.x + other.x, self.y + other.y)

    def __sub__ (self, other ):
        return Point(self.x - other.x, self.y - other.y)

    def __pow__(self, p):
        return Point(self.x ** p, self.y **p)

    def __abs__(self):
        d = self ** 2
        return (d.x + d.y) ** 0.5

    def __matmul__(self, other):
        ''' Euclidean distance between self &amp; other '''
        return abs(self - other)

# Test

a = Point(5, 6)
b = Point(2, 2)
print(a + b)
print(a - b)
print(a @ b)
</code></pre>
<p><strong>output</strong></p>
<pre><code>Point(7, 8)
Point(3, 4)
5.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It does not make sense for the difference of two points to be a point. It seems the object you are trying to implement is in fact a vector.</p>
<p>Then the distance corresponds to the norm of a vector, implemented with <code>__abs__</code>.</p>
<pre><code>class Vector:
    def __init__(self, *args):
        self._coords = args

    def __add__(self, other):
        return Vector(*[x + y for x, y in zip(self._coords, other._coords)])

    def __sub__(self, other):
        return Vector(*[x - y for x, y in zip(self._coords, other._coords)])

    def __abs__(self):
        """Euclidian norm of the vector"""
        return sum(x**2 for x in self._coords) ** (1 / 2)
</code></pre>
<h2>Example</h2>
<pre><code>v1 = Vector(1, 3)
v2 = Vector(4, -1)

print(abs(v2 - v1)) # 5.0

# Also works in higher dimensions
v3 = Vector(1, -1, 0)
v4 = Vector(4, 6, -2)

print(abs(v3 - v4)) # 7.87
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your second class works for me. I do not see any issues with it:</p>
<pre><code>In [9]: class Point_1(object):
   ...:     
   ...:     def __init__(self, x, y):
   ...:         self._x = x
   ...:         self._y = y
   ...:   
   ...:     
   ...:     def setX(self, x,y):
   ...:         self._x = x
   ...:         self._y = y
   ...:  
   ...:     def getX(self):
   ...:         return self._x,self._y
   ...:     
   ...:     
   ...:     def __sub__ (self, other ):
   ...:         return Point_1(self._x - other._x, self._y - other._y)
   ...:     
   ...:     def __pow__(self,p):
   ...:         return Point_1(self._x ** p, self._y **p)
</code></pre>
<p>And then:</p>
<pre><code>In [14]: p1 = Point_1(10,4)
    ...: print(p1.getX())
    ...: 
    ...: p2 = Point_1(3,1)
    ...: print(p2.getX())
    ...: 
    ...: p3 = p1 - p2
    ...: 
    ...: 
(10, 4)
(3, 1)

In [15]: p3.getX()
Out[15]: (7, 3)
</code></pre>
<p>Call it vector or point or whatever, it seems to be doing what you want it to do.</p>
</div>
<div class="post-text" itemprop="text">
<p>Note that your definition of <code>__pow__</code> is a bit nonstandard for vectors.</p>
<p>But as it is, the distance of two points <code>p1</code> and <code>p2</code> could be written as <code>sum((p1 - p2)**2)**.5</code>. So we need your <code>__pow__</code> method, your <code>__sub__</code> method, and the only other addition is an <code>__iter__</code> method which allows <code>sum</code> to work:</p>
<pre><code>class Point:
    """A point in two-dimensional space."""

    def __init__(self, x, y):
        self._x = x
        self._y = y

    def __eq__(self, other):
        return self._x == other._x and self._y == other._y

    def __sub__(self, other):
        return Point(self._x - other._x, self._y - other._y)

    def __pow__(self, power):
        return Point(self._x**power, self._y**power)

    def __iter__(self):
        yield self._x
        yield self._y

    def distance(self, other):
        return sum((self - other)**2)**.5

p1 = Point(2, 3)
p2 = Point(5, -1)

print(p1.distance(p2))
Out: 5.0
</code></pre>
<p>That's the shortest way based on your existing code anyway. You could experiment further by adding a scalar multiplication method and an addition method and then defining sub as <code>p1 + (-1)*p2</code>. You can also make things a bit easier on yourself by implementing a <code>__repr__</code> method.</p>
</div>
<span class="comment-copy">Make sure your code runs properly before posting it. Currently it throws an error due to <code>Point_1</code> not being defined. And the second class doesn't instantiate properly.</span>
<span class="comment-copy">yeah they're instantiating objects with a name that doesn't match the class', starting from there we might go somewhere</span>
<span class="comment-copy">It should be working now.</span>
<span class="comment-copy">It's not clear what you're actually trying to do here. Why do you think that using a magic method here is appropriate? Magic methods allow you to invoke a method when a standard operator (or function) is used with your object. Which standard operator do you intend to use to invoke the Euclidean distance?</span>
<span class="comment-copy">So I am just learning about how I could use magic methods. I agree using them here is not exactly useful but since I made a code with euclidean distance I thought it would be nice to see how these magic methods work in this case. So my code, for now, returns the difference (p3) but now I want to take that and calculate the square of my x and y using magic method pow but I don't know how to do that and then want to take the result of that and compute a square root using magic method and that would be my Euclidean distance</span>
<span class="comment-copy">Can I get an explanation for the downvote?</span>
<span class="comment-copy">Thank you. I think I get it now.</span>
<span class="comment-copy">Although, this mathematically makes no sense to call those Points</span>
<span class="comment-copy">Makes sense to me. Anyway, it's a pedagogical example for OOP. As others have made clear, this is not, in terms of programming, mathematics or optimisation, the best way to write the code.</span>
<span class="comment-copy">In your definition of <code>abs()</code> why do you use non-Euclidean distance? (<code>return self._x**2 + self._y**2</code>)</span>
<span class="comment-copy">@AGNGazer A mistake, thanks. My code was squaring the elements twice. <code>abs</code> should really have been a <code>sum</code>. I will change it accordingly.</span>
