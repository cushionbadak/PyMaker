<div class="post-text" itemprop="text">
<p>I'm trying to compile my code into a Python 3 module. It runs fine when I choose "Run module" in IDLE, but receive the following syntax error when I try to create a distribution:</p>
<pre class="lang-none prettyprint-override"><code>File "/usr/local/lib/python3.2/dist-packages/simpletriple.py", line 9
    def add(self, (sub, pred, obj)):
                  ^
SyntaxError: invalid syntax
</code></pre>
<p>Can anyone help point out what is wrong with the syntax? Here is the complete code:</p>
<pre><code>import csv

class SimpleGraph:
    def __init__(self):
        self._spo = {}
        self._pos = {}
        self._osp = {}

    def add(self, (sub, pred, obj)):
        """
        Adds a triple to the graph.
        """
        self._addToIndex(self._spo, sub, pred, obj)
        self._addToIndex(self._pos, pred, obj, sub)
        self._addToIndex(self._osp, obj, sub, pred)

    def _addToIndex(self, index, a, b, c):
        """
        Adds a triple to a specified index.
        """
        if a not in index: index[a] = {b:set([c])}
        else:
            if b not in index[a]: index[a][b] = set([c])
            else: index[a][b].add(c)

    def remove(self, (sub, pred, obj)):
        """
        Remove a triple pattern from the graph.
        """
        triples = list(self.triples((sub, pred, obj)))
        for (delSub, delPred, delObj) in triples:
            self._removeFromIndex(self._spo, delSub, delPred, delObj)
            self._removeFromIndex(self._pos, delPred, delObj, delSub)
            self._removeFromIndex(self._osp, delObj, delSub, delPred)

    def _removeFromIndex(self, index, a, b, c):
        """
        Removes a triple from an index and clears up empty indermediate structures.
        """
        try:
            bs = index[a]
            cset = bs[b]
            cset.remove(c)
            if len(cset) == 0: del bs[b]
            if len(bs) == 0: del index[a]
        # KeyErrors occur if a term was missing, which means that it wasn't a valid delete:
        except KeyError:
            pass

    def triples(self, (sub, pred, obj)):
        """
        Generator over the triple store.
        Returns triples that match the given triple pattern. 
        """
        # check which terms are present in order to use the correct index:
        try:
            if sub != None: 
                if pred != None:
                    # sub pred obj
                    if obj != None:
                        if obj in self._spo[sub][pred]: yield (sub, pred, obj)
                    # sub pred None
                    else:
                        for retObj in self._spo[sub][pred]: yield (sub, pred, retObj)
                else:
                    # sub None obj
                    if obj != None:
                        for retPred in self._osp[obj][sub]: yield (sub, retPred, obj)
                    # sub None None
                    else:
                        for retPred, objSet in self._spo[sub].items():
                            for retObj in objSet:
                                yield (sub, retPred, retObj)
            else:
                if pred != None:
                    # None pred obj
                    if obj != None:
                        for retSub in self._pos[pred][obj]:
                            yield (retSub, pred, obj)
                    # None pred None
                    else:
                        for retObj, subSet in self._pos[pred].items():
                            for retSub in subSet:
                                yield (retSub, pred, retObj)
                else:
                    # None None obj
                    if obj != None:
                        for retSub, predSet in self._osp[obj].items():
                            for retPred in predSet:
                                yield (retSub, retPred, obj)
                    # None None None
                    else:
                        for retSub, predSet in self._spo.items():
                            for retPred, objSet in predSet.items():
                                for retObj in objSet:
                                    yield (retSub, retPred, retObj)
        # KeyErrors occur if a query term wasn't in the index, so we yield nothing:
        except KeyError:
            pass

    def value(self, sub=None, pred=None, obj=None):
        for retSub, retPred, retObj in self.triples((sub, pred, obj)):
            if sub is None: return retSub
            if pred is None: return retPred
            if obj is None: return retObj
            break
        return None

    def load(self, filename):
        f = open(filename, "rb")
        reader = csv.reader(f)
        for sub, pred, obj in reader:
            sub = unicode(sub, "UTF-8")
            pred = unicode(pred, "UTF-8")
            obj = unicode(obj, "UTF-8")
            self.add((sub, pred, obj))
        f.close()

    def save(self, filename):
        f = open(filename, "wb")
        writer = csv.writer(f)
        for sub, pred, obj in self.triples((None, None, None)):
            writer.writerow([sub.encode("UTF-8"), pred.encode("UTF-8"), obj.encode("UTF-8")])
        f.close()

if __name__ == "__main__":
    g = SimpleGraph()
    g.add(("blade_runner", "name", "Blade Runner"))
    g.add(("blade_runner", "name", "Blade Runner"))
    g.add(("blade_runner", "release_date", "June 25, 1982"))
    g.add(("blade_runner", "directed_by", "Ridley Scott"))

    print list(g.triples((None, None, None)))
    print list(g.triples(("blade_runner", None, None)))
    print list(g.triples(("blade_runner", "name", None)))
    print list(g.triples(("blade_runner", "name", "Blade Runner")))
    print list(g.triples(("blade_runner", None, "Blade Runner")))
    print list(g.triples((None, "name", "Blade Runner")))
    print list(g.triples((None, None, "Blade Runner")))

    print list(g.triples(("foo", "name", "Blade Runner")))
    print list(g.triples(("blade_runner", "foo", "Blade Runner")))
    print list(g.triples(("blade_runner", "name", "foo")))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://www.python.org/dev/peps/pep-3113/" rel="nofollow noreferrer">PEP 3113</a> explains why this feature, "tuple parameter unpacking", was removed in Python 3. It also explains how to port code that uses them. In this case you'd need to change a function like:</p>
<pre><code>def add(self, (sub, pred, obj)):
    self._addToIndex(self._spo, sub, pred, obj)
    self._addToIndex(self._pos, pred, obj, sub)
    self._addToIndex(self._osp, obj, sub, pred)
</code></pre>
<p>to a version which passes the tuple as a single parameter and unpacks it manually:</p>
<pre><code>def add(self, sub_pred_obj):
    sub, pred, obj = sub_pred_obj
    self._addToIndex(self._spo, sub, pred, obj)
    self._addToIndex(self._pos, pred, obj, sub)
    self._addToIndex(self._osp, obj, sub, pred)
</code></pre>
<hr/>
<p>For a <code>lambda</code> function, you can't use assignment to unpack. The best solution there is usually to not unpack. For example, change this:</p>
<pre><code>lambda (x, y): (y, x)
</code></pre>
<p>… to this:</p>
<pre><code>lambda xy: (xy[1], xy[0])
</code></pre>
<p>For complicated functions, this can get ugly—but then for complicated functions, you probably want to <code>def</code> them anyway.</p>
<hr/>
<p>It's worth noting that running your code through <a href="https://docs.python.org/3/library/2to3.html" rel="nofollow noreferrer"><code>2to3</code></a>, <a href="https://pypi.org/project/modernize/" rel="nofollow noreferrer"><code>modernize</code></a>, or <a href="https://pypi.org/project/future/" rel="nofollow noreferrer"><code>futurize</code></a> will find this problem in both <code>def</code> and <code>lambda</code>, and suggest exactly these solutions:</p>
<pre><code>$ echo 'lambda (x,y): (y,x)' | 2to3 -
--- &lt;stdin&gt; (original)
+++ &lt;stdin&gt; (refactored)
@@ -1 +1 @@
-lambda (x,y): (y,x)
+lambda x_y: (x_y[1],x_y[0])

$ echo -e 'def foo((x,y)):\n    return (y,x)\n' | 2to3 -
--- &lt;stdin&gt; (original)
+++ &lt;stdin&gt; (refactored)
@@ -1 +1 @@
-def foo((x,y)):
+def foo(xxx_todo_changeme):
+    (x,y) = xxx_todo_changeme
</code></pre>
<p>If you're trying to port Python 2.x code to 3.x (or to dual-version code) and don't know both languages, you almost certainly want to use one of these tools—or an IDE plugin that wraps them—to help. (Although you may not want to use its output as-is.)</p>
</div>
<span class="comment-copy">Please put your code here, on pastebin or somewhere else, so there is no need to download it.</span>
<span class="comment-copy">@Tadeck: actually, he's given enough context with the traceback, so probably not necessary.</span>
<span class="comment-copy">There has a lot that has changed in the coding since that book (referenced by OP) was published. I'm working on this code and faced the same issue and came across your post. Is there a resource where I can fall back to get more clarifications on how the code has changed since I'm going through all of the codes in the book (eventually)</span>
<span class="comment-copy">How do you code it when the function is a lambda? Use <code>t[0]</code> <code>t[1]</code> and <code>t[2]</code>?</span>
<span class="comment-copy">@abarnert FYI I rolled back your revision because it's not correct. In Python 2.x, tuple unpacking works just fine in lambdas (just like in non-lambdas), see here: <a href="https://gist.github.com/benhoyt/e211858be3786a02b0f93153428effea" rel="nofollow noreferrer">gist.github.com/benhoyt/e211858be3786a02b0f93153428effea</a></span>
<span class="comment-copy">@BenHoyt Of course it works fine in 2.x. But the question is about how to port that code to 3.x, where it doesn't work, and that's the whole point of your answer. And your answer works fine for <code>def</code>, but doesn't work for <code>lambda</code>, because it depends on an assignment statement. Please reread my edit (and the question and your answer) more carefully; I don't think there's anything incorrect there.</span>
<span class="comment-copy">@abarnert I'm sorry, you're dead right! I was hasty and misread your first paragraph as "you can't use tuple unpacking in lambdas". Reverted, and thanks!</span>
