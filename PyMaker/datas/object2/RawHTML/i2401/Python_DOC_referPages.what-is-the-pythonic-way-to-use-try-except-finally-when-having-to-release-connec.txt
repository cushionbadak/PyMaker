<div class="post-text" itemprop="text">
<p>I have a function that connects to a database and fetches some data and returns this data. This entire process is surrounded by a try except finally block. In the finally block, I release the resources if they exist even in case of an error. So what is the pythonic way to do the following:</p>
<pre><code>def fetch_data():
    db_conn = None
    try:
        db_conn = DBConnection()
        data = db_conn.get_data()
    except Exception as ex:
        print(f"Exception occurred when fetching data: {ex}")
    finally:
        if db_conn:
            db_conn.close()
</code></pre>
<p>The initialization of <code>db_conn = None</code> and the <code>finally</code> block don't look elegant or pythonic enough and I was wondering if there was a better way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to use a <em>context manager</em>. Context managers and the <code>with</code> statement were added to the language specifically to handle this pattern.</p>
<p>The code would become:</p>
<pre><code>with DBConnection() as db_conn:
    data = db_conn.get_data()
</code></pre>
<p>See <a href="https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers" rel="nofollow noreferrer"><em>With Statement Context Managers</em></a>. The implementation of <code>DBConnection</code> would need to supply <code>__enter__</code> and <code>__exit__</code> methods to handle this:</p>
<pre><code>class DBConnection:
    def __init__(self):
        # .. initialisation of the instance. **Not** in the context manager

    def close(self):
        # ...

    def get_data(self):
        # ...
        return data_loaded

    def __enter__(self):
        # context is entered, `try:` 'opens' *after* this point.
        # Perhaps you want to actually connect to the database here
        # whatever is returned here is assignable via `with ... as name`
        # this can be a new object or self
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        # The context is exiting, equivalent of except ... and finally ...
        self.close()
        if exc_type:
            print(f"Exception occurred when fetching data: {exc_value}")
        # returning None will allow exceptions to propagate, returning
        # True (or other true value) will clear the exception.
        return True  # exception is cleared
</code></pre>
<p>I used <code>return self</code> in the <code>__enter__</code> handler because that's a good pattern to use for context managers that fits your specific example well, but you could also return something else. Some database adapters return a transaction object or cursor at that point, for example.</p>
<p>Note that exceptions <strong>raised in <code>__enter__</code></strong> are not part of the context and are not handled there! If you need to handle exceptions in opening the database that you don't want to propagate, you'd have to postpone connecting until the first <code>get_data()</code> call.</p>
<p>Context managers <em>encapsulate</em> the <code>try: ... except ...: finally: ...</code> pattern. Also see the <a href="https://www.python.org/dev/peps/pep-0343/" rel="nofollow noreferrer">PEP 343 -- The *with* statement</a> proposal that added this to Python:</p>
<blockquote>
<p>This PEP adds a new statement "with" to the Python language to make it possible to factor out standard uses of try/finally statements.</p>
</blockquote>
<p>Note that it is up to your use cases as to where you handle exceptions. For some context managers that's the <code>__exit__</code> method, for others it is only useful to just clean up the context and not suppress exceptions. For example, files are context managers but they would not clear an exception. At that point you'd <em>add</em> a <code>try: .. except SpecificException:</code> to handle such cases:</p>
<pre><code>try:
    with open(filename) as fobj:
        # ...
except IOError:
    # oops, file failed to open
</code></pre>
<p>or</p>
<pre><code>try:
    open_file = open(filename)
except IOError:
    # oops, file failed to open
else:
    with open_file as fobj:
        # ...
</code></pre>
<p>The point of the context manager there is to ensure that the file object is closed if it had been opened, and nothing else.</p>
</div>
<span class="comment-copy">You're probably looking for context managers.</span>
<span class="comment-copy">The <code>with</code> statement in Python is what you're looking for. And it is a Context Manager as said by @sloth</span>
<span class="comment-copy">I don't think it's a good solution to have the exception handling done in the <code>__exit__</code> method. It's impossible to find out if there was an exception inside the <code>with</code> block or not. It's not flexible. You're basically forced to write <i>all</i> of the function's code inside of the <code>with</code> block.</span>
<span class="comment-copy">Perfect thanks! DBConnection is a class that is in my control and I can make changes to it to be able to use the <code>with</code> statement.</span>
<span class="comment-copy">@Aran-Fey: It depends entirely on the exception that is being handled. This is a simplified example to show <i>what is possible</i> without discussion as to when handling exceptions there is appropriate.</span>
<span class="comment-copy">@Aran-Fey: corrected factual errors in my post (it's <code>True</code> that clears the exception, not <code>None</code>, and added more exception handling context.</span>
