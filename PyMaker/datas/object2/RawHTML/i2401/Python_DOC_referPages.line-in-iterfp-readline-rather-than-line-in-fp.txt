<div class="post-text" itemprop="text">
<p>I read builtin function <code>iter</code> 's example in <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer">Built-in Functions â€” Python 3.7.0 documentation</a></p>
<pre><code>with open('mydata.txt') as fp:
    for line in iter(fp.readline, ''):
        process_line(line)
</code></pre>
<p>I could not figure out what's the advantage over the following:</p>
<pre><code>with open('mydata.txt') as fp:
    for line in fp:
        process_line(line)
</code></pre>
<p>Could you please provide any hints?</p>
</div>
<div class="post-text" itemprop="text">
<p>Both will iterate over a generator, without loading the whole file into memory, but the <code>iter()</code> version is demonstrating the use of the second argument of <code>iter()</code>, "<code>sentinel</code>". </p>
<p>From the docs:</p>
<blockquote>
<p>if the value returned is equal to sentinel, StopIteration will be raised</p>
</blockquote>
<p>So this code will read from the file, until a line equals <code>''</code> and then stop. </p>
<p>This is a strange example, as all lines in the file will have a newline on the end, so this will only trigger at the end of the file anyway (if at all).</p>
</div>
<div class="post-text" itemprop="text">
<p>As wim and I discussed in the comments, there is <em>no advantage</em> for this particular case. For the 2nd code snippet to be equivalent to the first code snippet then it would look something like this:</p>
<pre><code>with open('mydata.txt') as fp:
    for line in fp:
        if line == '':
            break
        process_line(line)
</code></pre>
<p>However, the only case an empty string can be returned by <code>readline</code> is at the end of the file (EOF) so it makes now difference here (other lines contain a newline <code>'\n'</code> character at least).</p>
<p>If rather than an empty string another value was used, then the difference would be meaningful though. Personally, I think the docs should use a better example to illustrate this, like as follows:</p>
<pre><code>&gt;&gt;&gt; f = open('test')
&gt;&gt;&gt; f.read()
'a\nb\nc\n\nd\ne\nf\n\n'
&gt;&gt;&gt; f = open('test')
&gt;&gt;&gt; [line for line in iter(f.readline, 'b\n')]
['a\n']
&gt;&gt;&gt; f = open('test')
&gt;&gt;&gt; [line for line in f]
['a\n', 'b\n', 'c\n', '\n', 'd\n', 'e\n', 'f\n', '\n']
</code></pre>
<p>(Note I should really be closing the file handles)</p>
<p>EDIT: I raised this as a possible documentation bug in <a href="https://bugs.python.org/issue34764" rel="nofollow noreferrer">issue34764</a></p>
</div>
<span class="comment-copy">Actually I think I agree with you, it is useless in this case(?) Since a an empty string is only produced at the EOF I believe. However, if I'm correct, then this is an odd example to use in the docs</span>
<span class="comment-copy">if instead of an empty string, you had <code>'a\n'</code> then it would be similar to adding <code>if line == 'a\n': break</code> for the 2nd snippet</span>
<span class="comment-copy">Why do you suppose there <i>is</i> any advantage?  It's just giving an example of the two-argument form of <code>iter</code> there.</span>
<span class="comment-copy">@wim So they are equivalent right? Isn't it a bad example to put in the docs then as it doesn't demonstrate the utility? Maybe they had in mind something more like this <code>iter(functools.partial(f.read, 1), '')</code></span>
<span class="comment-copy">I don't think the example is necessarily bad ("read lines of a file until a certain line is reached"), but i think using an empty string as the "certain line" was not the best choice.</span>
<span class="comment-copy">You will only get empty string at the end of file. Blank lines would be a '\n' during iteration.</span>
<span class="comment-copy">Thanks, I've updated the answer to be clearer about that.</span>
