<div class="post-text" itemprop="text">
<p>I have a file that may be in a different place on each user's machine. Is there a way to implement a search for the file? A way that I can pass the file's name and the directory tree to search in?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/os.html#os.walk" rel="noreferrer">os.walk</a> is the answer, this will find the first match:</p>
<pre><code>import os

def find(name, path):
    for root, dirs, files in os.walk(path):
        if name in files:
            return os.path.join(root, name)
</code></pre>
<p>And this will find all matches:</p>
<pre><code>def find_all(name, path):
    result = []
    for root, dirs, files in os.walk(path):
        if name in files:
            result.append(os.path.join(root, name))
    return result
</code></pre>
<p>And this will match a pattern:</p>
<pre><code>import os, fnmatch
def find(pattern, path):
    result = []
    for root, dirs, files in os.walk(path):
        for name in files:
            if fnmatch.fnmatch(name, pattern):
                result.append(os.path.join(root, name))
    return result

find('*.txt', '/path/to/dir')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I used a version of <code>os.walk</code> and on a larger directory got times around 3.5 sec. I tried two random solutions with no great improvement, then just did:</p>
<pre><code>paths = [line[2:] for line in subprocess.check_output("find . -iname '*.txt'", shell=True).splitlines()]
</code></pre>
<p>While it's POSIX-only, I got 0.25 sec.</p>
<p>From this, I believe it's entirely possible to optimise whole searching a lot in a platform-independent way, but this is where I stopped the research.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are working with Python 2 you have a problem with infinite recursion on windows caused by self-referring symlinks.</p>
<p>This script will avoid following those. Note that this is <strong>windows-specific</strong>!</p>
<pre><code>import os
from scandir import scandir
import ctypes

def is_sym_link(path):
    # http://stackoverflow.com/a/35915819
    FILE_ATTRIBUTE_REPARSE_POINT = 0x0400
    return os.path.isdir(path) and (ctypes.windll.kernel32.GetFileAttributesW(unicode(path)) &amp; FILE_ATTRIBUTE_REPARSE_POINT)

def find(base, filenames):
    hits = []

    def find_in_dir_subdir(direc):
        content = scandir(direc)
        for entry in content:
            if entry.name in filenames:
                hits.append(os.path.join(direc, entry.name))

            elif entry.is_dir() and not is_sym_link(os.path.join(direc, entry.name)):
                try:
                    find_in_dir_subdir(os.path.join(direc, entry.name))
                except UnicodeDecodeError:
                    print "Could not resolve " + os.path.join(direc, entry.name)
                    continue

    if not os.path.exists(base):
        return
    else:
        find_in_dir_subdir(base)

    return hits
</code></pre>
<p>It returns a list with all paths that point to files in the filenames list.
Usage:</p>
<pre><code>find("C:\\", ["file1.abc", "file2.abc", "file3.abc", "file4.abc", "file5.abc"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are using Python on Ubuntu and you only want it to work on Ubuntu a substantially faster way is the use the terminal's <code>locate</code> program like this.</p>
<pre><code>import subprocess

def find_files(file_name):
    command = ['locate', file_name]

    output = subprocess.Popen(command, stdout=subprocess.PIPE).communicate()[0]
    output = output.decode()

    search_results = output.split('\n')

    return search_results
</code></pre>
<p><code>search_results</code> is a <code>list</code> of the absolute file paths. This is 10,000's of times faster than the methods above and for one search I've done it was ~72,000 times faster.</p>
</div>
<div class="post-text" itemprop="text">
<p>For fast, OS-independent search, use <code>scandir</code></p>
<p><a href="https://github.com/benhoyt/scandir/#readme" rel="nofollow">https://github.com/benhoyt/scandir/#readme</a></p>
<p>Read <a href="http://bugs.python.org/issue11406" rel="nofollow">http://bugs.python.org/issue11406</a> for details why.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.4 or newer you can use pathlib to do recursive globbing:</p>
<pre><code>&gt;&gt;&gt; import pathlib
&gt;&gt;&gt; sorted(pathlib.Path('.').glob('**/*.py'))
[PosixPath('build/lib/pathlib.py'),
 PosixPath('docs/conf.py'),
 PosixPath('pathlib.py'),
 PosixPath('setup.py'),
 PosixPath('test_pathlib.py')]
</code></pre>
<p>Reference: <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob" rel="nofollow noreferrer">https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob</a></p>
<p>In Python 3.5 or newer you can also do recursive globbing like this:</p>
<pre><code>&gt;&gt;&gt; import glob
&gt;&gt;&gt; glob.glob('**/*.txt', recursive=True)
['2.txt', 'sub/3.txt']
</code></pre>
<p>Reference: <a href="https://docs.python.org/3/library/glob.html#glob.glob" rel="nofollow noreferrer">https://docs.python.org/3/library/glob.html#glob.glob</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Below we use a boolean "first" argument to switch between first match and all matches (a default which is equivalent to "find . -name file"):</p>
<pre><code>import  os

def find(root, file, first=False):
    for d, subD, f in os.walk(root):
        if file in f:
            print("{0} : {1}".format(file, d))
            if first == True:
                break 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See the <a href="http://docs.python.org/library/os.html#files-and-directories" rel="nofollow noreferrer">os module</a> for os.walk or os.listdir</p>
<p>See also this question <a href="https://stackoverflow.com/questions/229186/os-walk-without-digging-into-directories-below">os.walk without digging into directories below</a> for sample code</p>
</div>
<span class="comment-copy">Note that these examples will only find files, not directories with the same name. If you want to find <b>any</b> object in the directory with that name you might want to use <code>if name in file or name in dirs</code></span>
<span class="comment-copy">Be careful of case sensitivity. <code>for name in files:</code> will fail looking for <code>super-photo.jpg</code> when it's <code>super-photo.JPG</code> in the file system. (an hour of my life I'd like back ;-) Somewhat messy fix is <code>if str.lower(name) in [x.lower() for x in files]</code></span>
<span class="comment-copy">What about using <b>yield</b> instead of preparing the result list? .....         if fnmatch.fnmatch(name, pattern):           yield os.path.join(root, name)</span>
<span class="comment-copy">Please consider updating your answer to Python 3.x primitives</span>
<span class="comment-copy">While this is the solution for Python, finding a file this way is about 5 times slower for me than forking and exec'ing <code>find</code>. Compare for yourself with: <code>os.popen('find / -name stdio.h').read().strip()</code></span>
<span class="comment-copy">Note that this is windows specific</span>
<span class="comment-copy">@Leliel Have added it to the answer. Thank you for your feedback.</span>
<span class="comment-copy">Specifically, use <code>scandir.walk()</code> per @Nadia's answer. Note that if you're using Python 3.5+, <code>os.walk()</code> has the <code>scandir.walk()</code> speedups already. Also, <a href="https://www.python.org/dev/peps/pep-0471/" rel="nofollow noreferrer">PEP 471</a> is probably a better document to read for info than that issue.</span>
