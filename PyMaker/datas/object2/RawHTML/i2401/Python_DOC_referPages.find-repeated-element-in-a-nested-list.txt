<div class="post-text" itemprop="text">
<p>I have a nested list of elements:</p>
<pre><code>employee_list =  [
    ['Name', '=', 'John'],
    ['Age', '=', '32'],
    ['Weight', '=', '60'],
    ['Name', '=', 'Steve'],
    ['Weight', '=', '85']
]
</code></pre>
<p>I want to create two lists of elements: one which has repeated elements and another with unique elements. But I also wanted the repetition to be maintained </p>
<pre><code>unique_list = [['Age', '=', '32']]

repeated_list = [
    ['Name', '=', 'John'],
    ['Weight', '=', '60'],
    ['Name', '=', 'Steve'],
    ['Weight', '=', '85']
] 
</code></pre>
<p>Uniqueness or repetition is determined by the first element of every sub list. For example: <code>'Name'</code>, <code>'Weight'</code>. If there are two sub lists where the first element is <code>'Name'</code> I consider it as repetition. </p>
<p>Can anyone suggest an easy way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> and comprehend the two lists based on the counts of the significant first elements:</p>
<pre><code>from collections import Counter

c = Counter(l[0] for l in employee_list)
# Counter({'Name': 2, 'Weight': 2, 'Age': 1})

uniq = [l for l in employee_list if c[l[0]] == 1]
# [['Age', '=', '32']]

rept = [l for l in employee_list if c[l[0]] &gt; 1]
# [['Name', '=', 'John'],
#  ['Weight', '=', '60'],
#  ['Name', '=', 'Steve'],
#  ['Weight', '=', '85']]
</code></pre>
<p><strong>Update:</strong> split <code>rept</code> by "key"</p>
<pre><code>d = {}
for l in rept:
    d.setdefault(l[0], []).append(l)
list(d.values())
# [[['Name', '=', 'John'], ['Name', '=', 'John']],
#  [['Weight', '=', '60'], ['Weight', '=', '60']]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can not using list of list to do the <code>Counter</code> , it will return the </p>
<blockquote>
<p>unhashable type: 'list'</p>
</blockquote>
<p>So We need convert to <code>list</code> of <code>tuple</code> </p>
<pre><code>employee_tuple=list(map(tuple,employee_list))
# then we using Counter    
from collections import Counter
d=Counter(employee_tuple)

l=list(map(d.get,employee_tuple))# get the freq of each item
l
Out[372]: [2, 1, 2, 2, 2]

# then we using filter 
from itertools import compress
list(compress(employee_list, map(lambda x: x == 1, l)))
Out[380]: [['Age', '=', '32']]


list(compress(employee_list, map(lambda x: x != 1, l)))
Out[384]: 
[['Name', '=', 'John'],
 ['Weight', '=', '60'],
 ['Name', '=', 'John'],
 ['Weight', '=', '60']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are a variety of solutions you could use including list comprehensions and filters. You can also use sets and list to produce the unique set of elements and convert back into list as shown in the <a href="https://stackoverflow.com/questions/7961363/removing-duplicates-in-lists">link provided by benvc</a>
Then after you get the list of unique elements, you can filter those elements from the original list to get the resulting list of duplicates (if any) </p>
<p>See <a href="http://book.pythontips.com/en/latest/map_filter.html" rel="nofollow noreferrer">python tips on filter</a> </p>
</div>
<div class="post-text" itemprop="text">
<p>If you created a <code>test_list</code> that contains all of the <code>items</code> in <code>employee_list</code> you can use the built in <code>count</code> method and <code>count</code> the appearances of each <code>employee_list[i][0]</code> in that <code>list</code> if the <code>count == 1</code> then we append that entire <code>item</code> to our <code>unique_list</code></p>
<pre><code>employee_list =  [
    ['Name', '=', 'John'],
    ['Age', '=', '32'],
    ['Weight', '=', '60'],
    ['Name', '=', 'Steve'],
    ['Weight', '=', '85']
]

unique_list = []
repeated_list = [] 
test_list = []

for i in employee_list:
    for j in i:
        test_list.append(j)

for i in employee_list:
    if test_list.count(i[0]) == 1:
        unique_list.append(i)
    else:
        repeated_list.append(i)

print(f"Repeated: {repeated_list}")
print(f"Unique: {unique_list}")
</code></pre>
<blockquote>
<pre><code>(xenial)vash@localhost:~/python/stack_overflow$ python3.7 unique.py 
Repeated: [['Name', '=', 'John'], ['Weight', '=', '60'], ['Name', '=', 'Steve'], ['Weight', '=', '85']]
Unique: [['Age', '=', '32']]
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I go with the pure numpy solution (I added one more row to make it more general):</p>
<p>Lets say that this is our data:</p>
<pre><code>data = np.array(data).astype(str)

data: array([['Name', '=', 'John'],
       ['Age', '_', '32'],
       ['Weight', '=', '60'],
       ['Name', '=', 'John'],
       ['Weight', '=', '60'],
       ['TT', '=', 'EE']], dtype='&lt;U6')
</code></pre>
<p>The next step is to grab the unique rows:</p>
<pre><code>uniq = np.unique(data, axis=0)
uniq: array([['Age', '_', '32'],
       ['Name', '=', 'John'],
       ['TT', '=', 'EE'],
       ['Weight', '=', '60']], dtype='&lt;U6')
</code></pre>
<p>Now, we want to see which rows are not repeated more than once:
(The answer for only once rows:)</p>
<pre><code>only_once = np.array([row for row in uniq if sum(np.all(row==data, axis=1)) == 1])
only_once:
array([['Age', '_', '32'],
       ['TT', '=', 'EE']], dtype='&lt;U6')
</code></pre>
<p>In order to get the repeated indices:</p>
<pre><code>idx = []
for row in only_once:
    lst = np.all(data==row, axis=1)
    idx = np.where(lst)[0]
    idx.append(idx)
idx:
[array([1]), array([5])]
</code></pre>
<p>The matrix of the only repeated values:</p>
<pre><code>result = np.delete(data, idx, axis=0)
result:
array([['Name', '=', 'John'],
       ['Weight', '=', '60'],
       ['Name', '=', 'John'],
       ['Weight', '=', '60']], dtype='&lt;U6')
</code></pre>
</div>
<span class="comment-copy">What is the way u tried ?</span>
<span class="comment-copy">@benvc I don't think it is an exact duplicate, the OP does not want to remove duplicates,they want to "partition" the elements. However the first answer already provides a big hint to one possible efficient solution.</span>
<span class="comment-copy">By "repeated" you mean the entire sublist <code>['Weight', '=', '60']</code> is identical or just one of the significant elements (like <code>'Weight'</code>)?</span>
<span class="comment-copy">Do you want to retain original ordering ? How many elements will your list contain ? (I mean like 10, 100, 1000, 1billion ?) And most important: <b>what have you tried that didn't work ?</b></span>
<span class="comment-copy">@schwobaseggl I am sorry I did not make it clear in the question. I am talking about uniqueness or repetition of element like 'Name' , 'Weight' or 'Age'</span>
<span class="comment-copy">thanks for the solution. Just out of curiosity, if I want to create the lists for every set of repeated elements. How can that be achieved. For example:  rept1 = [['Name', '=', 'John'],  ['Name', '=', 'Steve']]   and similarly for the rest</span>
<span class="comment-copy">@Deep I would build a dict using the first elements as keys and the lists of lits as values.</span>
<span class="comment-copy">I meant, the output we are getting in list 'rept'. It further has duplication ('name' and 'weight' both of them twice). If I need to break it down to the list of just 'name' and 'weight' or break it down till the time there are lists of just one type of elements in it.</span>
<span class="comment-copy">@Deep That is exactly how I understood it. I added some code to the answer.</span>
<span class="comment-copy">OP has edited the question after lots of comments clarifying what they are really after, making my initial suggestion referenced here less than helpful in resolving the issue.</span>
