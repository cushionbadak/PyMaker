<div class="post-text" itemprop="text">
<p>If I'm making a module that I would like to run the same in Python 2 as in Python 3, there are a ton of options including <code>six</code>, <code>futures</code>, and <code>2to3</code>. If the number of changes is small though, each of those tools has enough quirks that I tend to prefer to just write a compatibility interface for the few incompatible functions my module actually uses.</p>
<p>A reasonably standard way to accomplish that is with a straightforward version check.</p>
<pre><code>import module_bar

if sys.version_info &gt;= (3,):
    uniformly_named_foo = module_bar.py3_thing
else:
    uniformly_named_foo = module_bar.py2_thing
</code></pre>
<p><strong>Are there any oddball cases where <code>sys.version_info</code> wouldn't be reported correctly</strong> though? I've been bitten enough in the past by malformed paths, configs, installations, modifications, and whatnot that this doesn't feel like a thing I should trust.</p>
<p>When we get right down to it, <strong>what I actually care about is if a particular feature is implemented</strong>. In web development, it's generally recognized as a bad practice to sniff user-agents. Instead, one should do their best to identify if a particular feature is in use or not. Depending on the feature, there are many ways one could accomplish that.</p>
<pre><code>if hasattr(module_bar, 'py3_thing'):
    uniformly_named_foo = module_bar.py3_thing
else:
    uniformly_named_foo = module_bar.py2_thing
</code></pre>
<p>On my machine, the second route is twice as slow (not that an extra few hundred nanoseconds really matter for a one-time operation), but it doesn't seem to have any other major disadvantages. Are there advantages though? <strong>Are there Python installations where the second approach will be successful and the first will fail?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Yes. <code>sys.version_info</code> is a reliable way to determine Python version.</p>
<p>See <a href="https://docs.python.org/3/library/sys.html#sys.version_info" rel="nofollow noreferrer">Python 3 documentation</a> and <a href="https://docs.python.org/2/library/sys.html#sys.version_info" rel="nofollow noreferrer">Python 2 documentation</a>.</p>
<p>Note: <code>sys.version_info</code> is reliable, but not <code>sys.version</code>:</p>
<blockquote>
<h3>sys.version</h3>
<p><strong>A string</strong> containing the version number of the Python interpreter plus additional information on the build number and compiler used. This string is displayed when the interactive interpreter is started. <strong>Do not extract version information out of it</strong>, rather, use <code>version_info</code> and the functions provided by the <code>platform</code> module.</p>
</blockquote>
<p>If you're worried about bad modules changing the values of <code>sys.version_info</code> or something else, you can <strong>force a reload</strong> of <code>&lt;module 'sys' (built-in)&gt;</code>:</p>
<pre><code>import sys
sys.version_info = "boo"
print(sys.version_info)  # boo

sys.modules.pop("sys")
import sys  # reloaded
print(sys.version_info)
# Output: sys.version_info(major=3, minor=6, ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, <code>sys.version_info</code> is <strong>not reliable</strong>, but only in the sense that almost everything in Python is overwriteable and because of how modules are singletons if no voodoo is being done. Consider the following example, which has one tiny typo.</p>
<pre><code># bad_dependency.py
import sys

# is_py3 = sys.version_info &gt;= (3,)
is_py3 = sys.version_info = (3,)
</code></pre>
<p>What happens when we import this? Well...nothing good.</p>
<pre><code># our_module.py
import sys
import bad_dependency

print(sys.version_info)
</code></pre>
<p>When we run this, since <code>sys</code> is the same module everywhere and since we've overwritten the information we care about, we actually get the following behavior:</p>
<pre><code>$ python our_module.py
(3,)
</code></pre>
<p>Of course by this metric almost none of our code is reliable if our imports have bad enough bugs. What's interesting is that it doesn't have to be our code that causes the problem, and the effects certainly don't need to be malicious.</p>
<p>As to the question of whether problems like this exist by default in some reasonably standard Python installations (e.g., micropython, OSX, etc...), I'm still not sure of the answer.</p>
</div>
<span class="comment-copy">Yes it is. Why not?</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/9079036/how-do-i-detect-the-python-version-at-runtime">How do I detect the Python version at runtime?</a></span>
<span class="comment-copy">@iBug The "why not" stems from me not knowing what I don't know here. The question (here)[<a href="https://stackoverflow.com/questions/22236727/mismatch-between-sys-executable-and-sys-version-in-python]" title="mismatch between sys executable and sys version in python%5d">stackoverflow.com/questions/22236727/…</a> indicates that there could be problems.</span>
<span class="comment-copy">Possible dupe of <a href="https://stackoverflow.com/questions/1093322/how-do-i-check-what-version-of-python-is-running-my-script" title="how do i check what version of python is running my script">stackoverflow.com/questions/1093322/…</a></span>
<span class="comment-copy">@Hans See the documentation: <i>Do not extract version information out of it</i> (<code>sys.version</code>), <i>rather, use version_info and the functions provided by the platform module.</i> See my edited answer.</span>
<span class="comment-copy">The "Do not extract version information out of it" warning is mostly because 1) you're likely to get it wrong, and 2) the information is available through more convenient, safer options that don't require you to parse anything.</span>
<span class="comment-copy">@user2357112 Well, that's what Python doc says.</span>
<span class="comment-copy">@user2357112 I'd wager a bet that it's partially also because they're not promising formatting compatibility between minor versions.</span>
<span class="comment-copy">@iBug I like the fact that you fixed the <code>bad_dependency</code> problem, but <code>sys.modules.pop</code> isn't really safe if any other modules in that python instance depend on <code>sys</code>. Using <code>imp.reload</code> is fine for now, but deprecated for 3.4+. Arguably <code>imp.reload</code> will be around for as long as anyone really cares about 2/3 compatibility. Do you think that's a good enough cross-version solution?</span>
<span class="comment-copy">@Hans <code>importlib.reload(sys)</code> doesn't work. I just tested this on Python 3.6.</span>
<span class="comment-copy">See my edited answer for defending against <code>bad_dependency</code>.</span>
<span class="comment-copy">@iBug I like that idea. I'm still holding out for anyone who knows of platforms with an incorrect <code>sys.version_info</code> (proving a negative is hard), but in a day or two I'll otherwise select yours as the best answer.</span>
