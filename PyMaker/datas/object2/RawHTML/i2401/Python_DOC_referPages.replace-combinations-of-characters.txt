<div class="post-text" itemprop="text">
<p>I have a string <code>27AAGCB5913L2ZF</code>. If any of <code>A</code> or <code>J</code> or <code>K</code> appear in the string then it I need to change them to all possible combinations of the three letters. If I pass the above string input to the program then the output should be like this</p>
<pre class="lang-none prettyprint-override"><code>27AAGCB5913L2ZF
27AJGCB5913L2ZF
27AKGCB5913L2ZF
27JAGCB5913L2ZF
27KAGCB5913L2ZF
27KJGCB5913L2ZF
27JKGCB5913L2ZF
27JJGCB5913L2ZF
27KKGCB5913L2ZF
</code></pre>
<p>The letters may be present anywhere in string. If just a single letter is present then it must be replaced by <code>A</code>, <code>J</code> and <code>K</code> in turn. For example the output for the string <code>27ABGCB5913L2ZF</code> should be as follows</p>
<pre class="lang-none prettyprint-override"><code>27ABGCB5913L2ZF
27JBGCB5913L2ZF
27kBGCB5913L2ZF
</code></pre>
<p>I can search for a given character with code like this</p>
<pre class="lang-perl prettyprint-override"><code>while ( $string =~ /(B)/g ) {
    say $1, ' at ', pos $string;
}
</code></pre>
<p>How can I produce all possible strings if there could be any number of <code>A</code>, <code>J</code>, or <code>K</code> in any positions?</p>
</div>
<div class="post-text" itemprop="text">
<p>The collection of combinations that you want of your key letters <code>A</code>, <code>J</code>, and <code>K</code> is called the
<a href="https://en.wikipedia.org/wiki/Cartesian_product" rel="nofollow noreferrer"><em>Cartesian product</em></a>.
In Python, you can use
<a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> to generate them.</p>
<p>Firstly, we need to find the positions of all of the key letters in the input string. The easy way to do that uses the built-in
<a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a>
function. Once I know those positions, and how many key letters the string contains, we can generate each item of the Cartesian product, replace the key letters, and print the new string.</p>
<p>In Python, strings are immutable (they can't be changed), so I convert the string to a list of characters, replace the characters in the key positions, and then build a new string from the list using the
<a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer"><code>str.join</code></a>
method.</p>
<p>The following code will work with both versions 2 and 3 of Python</p>
<h3>Python</h3>
<pre class="lang-python prettyprint-override"><code>from itertools import product

def make_patterns(s):

    keyletters = 'AJK'

    # Convert input string into a list so we can easily substitute letters
    seq = list(s)

    # Find indices of key letters in seq
    indices = [ i for i, c in enumerate(seq) if c in keyletters ]

    # Generate key letter combinations &amp; place them into the list
    for t in product(keyletters, repeat=len(indices)):
        for i, c in zip(indices, t):
            seq[i] = c
        print(''.join(seq))

# Test

data = (
    '1ABC2',
    '27AAGCB5913L2ZF',
    '3A4J',
    '5K67KA',
)

for s in data:
    print('\nInput:', s)
    make_patterns(s)
</code></pre>
<h3>output</h3>
<pre class="lang-none prettyprint-override"><code>Input: 1ABC2
1ABC2
1JBC2
1KBC2

Input: 27AAGCB5913L2ZF
27AAGCB5913L2ZF
27AJGCB5913L2ZF
27AKGCB5913L2ZF
27JAGCB5913L2ZF
27JJGCB5913L2ZF
27JKGCB5913L2ZF
27KAGCB5913L2ZF
27KJGCB5913L2ZF
27KKGCB5913L2ZF

Input: 3A4J
3A4A
3A4J
3A4K
3J4A
3J4J
3J4K
3K4A
3K4J
3K4K

Input: 5K67KA
5A67AA
5A67AJ
5A67AK
5A67JA
5A67JJ
5A67JK
5A67KA
5A67KJ
5A67KK
5J67AA
5J67AJ
5J67AK
5J67JA
5J67JJ
5J67JK
5J67KA
5J67KJ
5J67KK
5K67AA
5K67AJ
5K67AK
5K67JA
5K67JJ
5K67JK
5K67KA
5K67KJ
5K67KK
</code></pre>
<hr/>
<p>With a minor change, we can turn our function into a generator. That lets you loop over the output strings easily, or turn them into a list if you want.</p>
<h3>Python</h3>
<pre class="lang-none prettyprint-override"><code>from itertools import product

def make_patterns(s):

    keyletters = 'AJK'

    # Convert input string into a list so we can easily substitute letters
    seq = list(s)

    # Find indices of key letters in seq
    indices = [i for i, c in enumerate(seq) if c in keyletters]

    # Generate key letter combinations &amp; place them into the list
    for t in product(keyletters, repeat=len(indices)):
        for i, c in zip(indices, t):
            seq[i] = c
        yield ''.join(seq)

# Test

print(list(make_patterns('A12K')))

for s in make_patterns('3KJ4'):
    print(s)
</code></pre>
<h3>output</h3>
<pre class="lang-none prettyprint-override"><code>['A12A', 'A12J', 'A12K', 'J12A', 'J12J', 'J12K', 'K12A', 'K12J', 'K12K']
3AA4
3AJ4
3AK4
3JA4
3JJ4
3JK4
3KA4
3KJ4
3KK4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be done in Perl by using the <code>glob</code> operator. <code>glob</code> is intended for finding matching files, but if no generic wildcard characters (<code>*</code>, <code>?</code> or <code>[...]</code>) are included in the pattern then it will simply return all possible matches, whether they exist as files or not</p>
<p>This Perl code uses a substitution to form a glob pattern by replacing all occurrences of <code>A</code>, <code>J</code>, or <code>K</code> with the multiple pattern <code>{A,J,K}</code>. Submitting the result to <code>glob</code> gives us the required output</p>
<pre class="lang-perl prettyprint-override"><code>use strict;
use warnings 'all';
use feature 'say';

for my $s ( qw/ 27AAGCB5913L2ZF 27KBGCB5913L2ZF / ) {

    (my $patt = $s) =~ s/[AJK]/{A,J,K}/g;

    say for glob $patt;
    say "";
}
</code></pre>
<h3>output</h3>
<pre class="lang-none prettyprint-override"><code>27AAGCB5913L2ZF
27AJGCB5913L2ZF
27AKGCB5913L2ZF
27JAGCB5913L2ZF
27JJGCB5913L2ZF
27JKGCB5913L2ZF
27KAGCB5913L2ZF
27KJGCB5913L2ZF
27KKGCB5913L2ZF

27ABGCB5913L2ZF
27JBGCB5913L2ZF
27KBGCB5913L2ZF
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A short solution:</p>
<p>Start by splitting the string into tuples of characters that may appear at each position</p>
<pre><code>&gt;&gt;&gt; s = "27AAGCB5913L2ZF"
&gt;&gt;&gt; p2 = [("A","J","K") if c in "AJK" else (c,) for c in s]
&gt;&gt;&gt; p2
[('2',), ('7',), ('A', 'J', 'K'), ('A', 'J', 'K'), ('G',), ('C',), ('B',), ('5',), ('9',), ('1',), ('3',), ('L',), ('2',), ('Z',), ('F',)]
</code></pre>
<p>Then this function will assemble the list of tuples back into a string:</p>
<pre><code>def assemble(t, s=''):
    if t:
        for c in t[0]:
            assemble(t[1:], s+c)
    else:
        print(s)

&gt;&gt;&gt; assemble(p2)
27AAGCB5913L2ZF
27AJGCB5913L2ZF
27AKGCB5913L2ZF
27JAGCB5913L2ZF
27JJGCB5913L2ZF
27JKGCB5913L2ZF
27KAGCB5913L2ZF
27KJGCB5913L2ZF
27KKGCB5913L2ZF
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a recursive solution in Perl:</p>
<pre><code>my $str = '27AAGCB5913L2ZF';
my @replace = qw (A J K);
print_string( $str);

sub print_string {
    my ( $str, $replace, $start) = @_;

    if (defined $replace) {
        substr( $str, $start, 1) = $replace;
    }
    else {
        $start = -1;
    }
    pos( $str) = $start +1;
    if ($str =~ /\G.*?(A|J|K)/g) {
        my $cur_start = $-[-1];
        print_string( $str, $_, $cur_start) for @replace;
    }
    else {
        say $str;
    }
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>27AAGCB5913L2ZF
27AJGCB5913L2ZF
27AKGCB5913L2ZF
27JAGCB5913L2ZF
27JJGCB5913L2ZF
27JKGCB5913L2ZF
27KAGCB5913L2ZF
27KJGCB5913L2ZF
27KKGCB5913L2ZF
</code></pre>
</div>
<span class="comment-copy">If single letter K present then it must have to replace A,J &amp; K on their own position. For example 27KBGCB5913L2ZF then Output should be as .. 27ABGCB5913L2ZF 27JBGCB5913L2ZF 27kBGCB5913L2ZF</span>
<span class="comment-copy">Forgive my prejudice, but <b><i>"With a minor change, we can turn our function into a generator"</i></b> (as well as the education about Cartesian products) smacks of someone fresh from college and desperate for points. There is no call for an iterator here: it will always be called to exhaustion and may as well be delivered as a simple list. Let's not turn acrobatic tricks to solve ordinary problems.</span>
<span class="comment-copy">@Borodin In Python 3, many functions that previously returned lists in early versions now return iterators. And for this task, I think an iterator is appropriate, since it doesn't take many key letters in the input string for the output to become quite large. FWIW, I'm not desperate for points, and I left school decades ago. I was just trying to help the OP.</span>
