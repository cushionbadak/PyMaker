<div class="post-text" itemprop="text">
<p>I am willing to concatenate two file on line basis, so that every line of each file is merged consecutively in a third file.</p>
<p>So I have the following code and the following text files:</p>
<pre><code>file1.txt
1
3
5
7

file2.txt
2
4
6
</code></pre>
<p>code:</p>
<pre><code>from ast import literal_eval

def merge_lines():
    with open("file1.txt") as f1, open("file2.txt") as f2:
        with open("file3.txt", "r+") as tfile:
            f1_lists = (literal_eval(line) for line in f1)
            f2_lists = (literal_eval(line) for line in f2)
            for l1, l2 in zip(f1_lists, f2_lists):
                tfile.write(str(l1))
                tfile.write("\n")
                tfile.write(str(l2))
                tfile.write("\n")

combine_hands()
</code></pre>
<p>This works just fine as the output file looks likes:</p>
<pre><code>file3.txt
1
2
3
4
5
6
</code></pre>
<p>My question is why the last line (number 7) of the file1.txt is not being merged? </p>
</div>
<div class="post-text" itemprop="text">
<p>The last line is omitted because <code>zip</code> stops at the end of the shorter iterable.</p>
<p>What you want is probably</p>
<pre><code>from itertools import zip_longest
def merge_lines():
    with open("file1.txt") as f1,\
         open("file2.txt") as f2,\
         open("file3.txt", "w") as tfile:
        for l1, l2 in zip_longest(f1, f2, fillvalue="Empty line"):
            # Or you can place a sentinel value for `fillvalue` 
            # and check it and don't write to file when you see it.                
            tfile.write(l1.strip() + "\n")
            tfile.write(l2.strip() + "\n")
</code></pre>
<p>or if you don't want to write out to file the empty line</p>
<pre><code>for l1, l2 in zip_longest(f1, f2, fillvalue=None):
    if l1:                           
        tfile.write(l1)
    if l2:
        tfile.write(l2)
</code></pre>
<p>And since the default value of <code>fillvalue</code> is <code>None</code>, we can simplify it further to</p>
<pre><code>for l1, l2 in zip_longest(f1, f2):
    if l1:                           
        tfile.write(l1)
    if l2:
        tfile.write(l2)
</code></pre>
<h2>Edit</h2>
<p>The following changes were made after reading the comment and answer from @DYZ:</p>
<ol>
<li>Fixed multi-line "with open" syntax error. Unfortunately we cannot
group multi-line "with" statements using parentheses.</li>
<li>Added second option to check for sentinel value (which I already
mentioned in my original answer).</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>With the function <code>zip_longest</code>, your code could be written in a very compact way:</p>
<pre><code>from itertools import zip_longest
with open("file1.txt") as f1,\
     open("file2.txt") as f2,\
     open("file3.txt", "w") as tfile:
        for l1, l2 in zip_longest(f1, f2, fillvalue=''):
            if l1 != '': tfile.write(l1)
            if l2 != '': tfile.write(l2)
</code></pre>
<p>No explicit reading or type conversion is needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>As others mentioned, it's because you uses normal zip() , the last line of the longest list (file) got omitted.zip will form tuples only up to the length of shorter list</p>
<p>Instead you can use either of the below extended zip which will pad up to longest list</p>
<pre><code>    itertools.zip_longest -- in python 3.x +
    itertools.izip_longest  --in python 2.6+
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The expression <code>zip(f1_lists, f2_lists)</code> returns a list of tuples only as long as the shorter of the provided iterables (in your case lists).
So this behavior is expected per <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip documentation</a>.</p>
<p>If you want to include the last line, try using <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">itertools.ziplongest</a></p>
<pre><code>from ast import literal_eval
from itertools import ziplongest

def merge_lines():
    with open("file1.txt") as f1, open("file2.txt") as f2:
        with open("file3.txt", "r+") as tfile:
            f1_lists = (literal_eval(line) for line in f1)
            f2_lists = (literal_eval(line) for line in f2)
            for l1, l2 in zip_longest(f1_lists, f2_lists, fillvalue='x'):
                tfile.write(str(l1))
                tfile.write("\n")
                tfile.write(str(l2))
                tfile.write("\n")

combine_hands()
</code></pre>
</div>
<span class="comment-copy">You do not need any <code>literal_eval</code>'s or <code>str</code>s.</span>
<span class="comment-copy">because the length of the file texts are not the same, one has 4 entries and the other has only 3. So, the zip and for loop don't work for your last entry of file1. you need to modify your code and check the lengths of each of the file lists before zipping and writing to your output file.</span>
<span class="comment-copy">@DYZ my bad, literal_eval was still there due to the rest of the code! Thank you for the prompt suggestions! It works like a charm</span>
<span class="comment-copy">This will add "Empty line" at the end.</span>
<span class="comment-copy">@DYZ Yes, it will add "Empty line". Op did not specify if he wish to leave a "marker" when the "shorter" file has reached its end, hence my original comment. After seeing your answer, I added in the example and also realized the syntax error in my original answer. Ultimately credit is to you. +1.</span>
