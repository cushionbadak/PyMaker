<div class="post-text" itemprop="text">
<p>so this week my course has me doing a tcp server/client where information is passed over the connection then it is parsed by the server. So I've written the code for both, but I'm getting return errors that I don't understand. I'm supposed to be returning the information of the status byte, partition type, and first section's address. I don't understand why I'm getting the issue with the client, when the message is binary and that's what it's saying I'm not using (I think!), and I don't think I'm using the socket in multiple places for the server. How do I fix this mess? Did I mention I'm just learning Python? Because I am. </p>
<p>Client code:</p>
<pre><code>import socket
import sys

#Create a TCP/IP Socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

#Connect the socket to the port where the server is listening
server_address = ('localhost', 10000)
print(sys.stderr, 'connecting to %s port %s' % server_address)
sock.connect(server_address)

try:

    #Send data
    #filename = 'block.dd'
    message = open('block.dd', 'rb')
    print(sys.stderr, 'sending "%s"' % message)
    message.close()
    sock.sendall(message)


    #Look for the response
    amount_received = 0
    amount_expected = len(message)

    while amount_received &lt; amount_expected:
        data = sock.recv(16)
        amount_received += len(data)
        print(sys.stderr, 'received "%s:' % data)

finally:
    print(sys.stderr, "closing socket")
    sock.close()
</code></pre>
<p>Client issues:</p>
<pre><code>&lt;_io.TextIOWrapper name='&lt;stderr&gt;' mode='w' encoding='UTF-8'&gt; connecting to localhost port 10000
&lt;_io.TextIOWrapper name='&lt;stderr&gt;' mode='w' encoding='UTF-8'&gt; sending "&lt;_io.BufferedReader name='block.dd'&gt;"
Traceback (most recent call last):
&lt;_io.TextIOWrapper name='&lt;stderr&gt;' mode='w' encoding='UTF-8'&gt; closing socket
  File "C:/Users/jesse/PycharmProjects/untitled/CYBR-260-40A/Week 4/KimmelFreeman_Jessica_CYBR260_40A_Week4ProgramminAssignment_Client.py", line 24, in &lt;module&gt;
    sock.sendall(message)
TypeError: a bytes-like object is required, not '_io.BufferedReader'

Process finished with exit code 1
</code></pre>
<p>Server Code:</p>
<pre><code>import struct

#Echo Server
import socket
import sys

#create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

#Bind the socket to the port
server_address = ('localhost', 10000)
print(sys.stderr, 'starting up on %s port %s' % server_address)
sock.bind(server_address)

#Listen for incoming connections
sock.listen(1)

while True:
    #Wait for a connection
    print(sys.stderr, 'waiting for a connection')
    connection, client_address = sock.accept()

    try:
        print(sys.stderr, 'connection from', client_address)

        #Receive the data in small chunks and retransmit it
        while True:
            data = connection.recv(16)
            print(sys.stderr, 'received "%s"' % data)
            if data:
                print(sys.stderr, 'sending data back to client')
                connection.sendall(data)
            else:
                print(sys.stderr, 'no more data from', client_address)
                break

    finally:
        #opening block.dd file
        block_MBR = open('block.dd', 'rb')

        #Going to address 1BE (hex), which is byte 446 according to the Wikipedia MBR page.
        block_MBR.seek(446)

        #Read 1 byte from the position 446 to return the status byte
        status_byte = block_MBR.read(1)

        #print the status byte
        print("The status byte is", status_byte)

        #Go to address 1BE +4 (hex), which is byte 450
        block_MBR.seek(450)

        #Reading 1 byte at the position 450 to find the partition type.
        partition_type = block_MBR.read(1)

        #print the partition type.
        print("The partition type is", partition_type)

        #Go to address 1BE + 8 (hex), which is byte 454.
        block_MBR.seek(454)

        #Read 4 bytes (or 32 bits) at position 454 to find the address of the first sector.
        address_first_sector = struct.unpack('i',block_MBR.read(4))[0]

        #print the address of the first sector in the partition.
        print("The address of the first sector in the partition is", address_first_sector)

        #Clean up the connection
        connection.close()
</code></pre>
<p>Server output:</p>
<pre><code>Traceback (most recent call last):
&lt;_io.TextIOWrapper name='&lt;stderr&gt;' mode='w' encoding='UTF-8'&gt; starting up on localhost port 10000
  File "C:/Users/jesse/PycharmProjects/untitled/CYBR-260-40A/Week 4/KimmelFreeman_Jessica_CYBR260_40A_Week4ProgrammingAssignment.py", line 18, in &lt;module&gt;
    sock.bind(server_address)
OSError: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted

Process finished with exit code 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>On Client,<code>message = open('block.dd', 'rb')</code> is <code>&lt;class '_io.BufferedReader'&gt;</code> instead of bytes.So you need to read file <code>message.read()</code>. I think you need <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" rel="nofollow noreferrer">this</a></p>
<p>Client:</p>
<pre><code>import socket
import sys

#Create a TCP/IP Socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

#Connect the socket to the port where the server is listening
server_address = ('localhost', 10000)
print(sys.stderr, 'connecting to %s port %s' % server_address)
sock.connect(server_address)

try:

    #Send data
    #filename = 'block.dd'
    message = open('block.dd', 'rb')
    sdata = message.read()
    print('sending "%s"' % sdata)
    sock.sendall(sdata)
    message.close()

    #Look for the response

    amount_expected  = len(sdata)

    while amount_expected:
        data = sock.recv(16)
        amount_expected  -= len(data)
        print('received "%s:' % data)


finally:
    print(sys.stderr, "closing socket")
    sock.close()
</code></pre>
</div>
<span class="comment-copy">Thank you so much! :)</span>
