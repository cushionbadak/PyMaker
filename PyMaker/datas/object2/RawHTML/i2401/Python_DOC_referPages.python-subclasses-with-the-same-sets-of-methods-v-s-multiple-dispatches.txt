<div class="post-text" itemprop="text">
<p>I was writing a class with the set of methods that work as expected for both numpy arrays and scipy.sparse matrices. I then realized that all my methods starts with an if-statement to check if the underlying matrix is dense or sparse e.g.</p>
<pre><code>def standardize_columns(self):
    if self.issparse():
        …
    else:
        …

def multiply_by_diagonal_matrix(self, diag_vector, from_='right'):
    if self.issparse():
        …
    else:
        …
</code></pre>
<p>It seems somewhat silly (and not pythonic) to have such if-else statements everywhere. I have so far found two possible ways around this: 1. create an abstract class with pre-specified set of methods and make subclasses (<a href="https://pythonspot.com/polymorphism/" rel="nofollow noreferrer">https://pythonspot.com/polymorphism/</a>, <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">https://docs.python.org/3/library/abc.html</a>), or 2. create a set of functions with multiple dispatch (<a href="https://github.com/mrocklin/multipledispatch" rel="nofollow noreferrer">https://github.com/mrocklin/multipledispatch</a>).</p>
<p>Which of the two approach (or any other) would be better and why?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is more of a long comment than an answer.</p>
<ul>
<li><p>subclassing <code>numpy.ndarray</code> is not a trivial undertaking. </p></li>
<li><p>scipy.sparse formats are already implemented as classes - several different ones; none are subclasses of <code>ndarray</code>. </p></li>
<li><p>the behavior of sparse matrices is modeled on <code>numpy.matrix</code> subclass - always 2d, * is matrix multiplication.  </p></li>
<li><p><code>numpy</code> functions work on sparse matrices ok, IF, they delegate the action of a method.  In other words, if there are identically named sparse and dense methods, you can often get by with that method or a function that uses it.  This the Python duck-typing.</p></li>
<li><p>scikit-learn has a lot of code that accepts both sparse and dense.  It may be worth looking at how it handles that.  I know they have added some utility code, including some faster <code>cython</code> stuff to speed up selected sparse actions.</p></li>
<li><p>sparse.linalg has a concept of linear operator, which just requires that the object have a particular matrix*vector` multiplication.  </p></li>
<li><p>when you do things with sparse matrices, make sure you understand what is produced.  Sometimes the sparse format changes.  Sometimes the result is a <code>np.matrix</code>, or <code>np.ndarray</code>.</p></li>
</ul>
<p>Without more details of your functions, it will be hard to suggest a more systematic approach.</p>
</div>
<span class="comment-copy">looks that you want to create a <code>SparseMatrix</code> subclass to override default behaviour</span>
<span class="comment-copy">I want the methods to work equally well with dense matrices as well.</span>
<span class="comment-copy">What do you do when <code>self.issparse()</code> returns False? Is it another version of the function or it is a similar thing in each method?</span>
<span class="comment-copy">Another version of the function. The output of methods are meant to be mathematically identical whether <code>self.issparse() == True</code> or not, but is represented differently internally depending on whether the underlying matrix is dense or sparse.</span>
<span class="comment-copy">Other than this <code>if/else</code> is there anything in common between these 2 functions (and the others)?  Any common pattern, something that can be generalized across all functions.</span>
