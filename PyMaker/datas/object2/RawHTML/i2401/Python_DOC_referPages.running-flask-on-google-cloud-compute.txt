<div class="post-text" itemprop="text">
<p>I'm trying to use cloud computing to use for flask service in Apache2, what I try like this:
1. install Apache2 and wsgi
2. install Python and other library that I need</p>
<p>code like this:</p>
<pre><code>#!/usr/bin/env python
import timeit
import re
import cgitb, cgi
cgitb.enable()
from keras import backend as K
import requests
import simplejson as json
import base64
import os
import uuid
from PIL import Image
from flask import Flask, jsonify, request
from keras.preprocessing.image import img_to_array
from keras.models import load_model
import numpy as np
from scipy import ndimage, misc
import cv2
import io
from io import BytesIO
from base64 import b64encode

app = Flask(__name__)
app.secret_key = "Top Secret"

ENDPOINT_URL = 'https://vision.googleapis.com/v1/images:annotate'

def make_image_data_list(image_filenames):
    img_requests = []

    with io.open(image_filenames, 'rb') as f:
        ctxt = b64encode(f.read()).decode()

        img_requests.append({
            'image': {'content': ctxt},
            'features': [{
                'type': 'DOCUMENT_TEXT_DETECTION',
                'maxResults': 1
            }],
            'imageContext': {
                'languageHints': ['id']
            }
        })
    return img_requests

def make_image_data(image_filenames):
    """Returns the image data lists as bytes"""
    imgdict = make_image_data_list(image_filenames)
    return json.dumps({"requests": imgdict }).encode()


def request_ocr(api_key, image_filenames):
    response = requests.post(ENDPOINT_URL,
                             data=make_image_data(image_filenames),
                             params={'key': api_key},
                             headers={'Content-Type': 'application/json'})
    return response






def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1] in ALLOWED_EXTENSIONS

@app.errorhandler(500)
def internal_error(error):
    return jsonify(
        classify="Something wrong while process image on matching, cause damage or etc..., make sure clearly capture image",
        response=306
    )

@app.errorhandler(405)
def method_not_allowed(e):
    return jsonify({'response': 305, 'message': 'authentication file required'}), 405

@app.route("/", methods=['POST'])
def index():
    if request.method == 'POST':
        start = timeit.default_timer()
        id = uuid.uuid4().hex

        file = request.form['file']
        ktp = request.form['ktp']

        face_cascade = cv2.CascadeClassifier('/var/www/html/classifier/haarcascade_frontalface_default.xml')

        if(file[:2] == "/9"):
            extentionfile = ".jpg"
        if(file[:2] == "iV"):
            extentionfile = ".png"
        if(ktp[:2] == "/9"):
            extentionktp = ".jpg"
        if(ktp[:2] == "iV"):
            extentionktp = ".png"

        imselfie = Image.open(BytesIO(base64.b64decode(file)))
        imselfie.save("/var/www/html/classifier/upload/face" + id + extentionfile)


        imktp = Image.open(BytesIO(base64.b64decode(ktp)))
        imktp.save("/var/www/html/classifier/ktp/face-" + id + extentionktp)
        nig = 1

        selfiestatus = 0
        ktpstatus = 0
        iter = 0
        status = True
        print("status : checking opening selfie and ktp image")
#        for counter in range (0, 4):
        while status == True:
            iter = iter + 1
            print("checking selfie image")
            image = cv2.imread("/var/www/html/classifier/upload/face" + id + extentionfile, cv2.IMREAD_COLOR)
            print("checking ktp image")
            ktpimage=cv2.imread("/var/www/html/classifier/ktp/face-" + id + extentionktp, cv2.IMREAD_COLOR)
            faces = face_cascade.detectMultiScale(image, 1.3, 5)
            ktpfaces = face_cascade.detectMultiScale(ktpimage, 1.3, 5)

            if(len(faces) &gt;= 1):
                selfiestatus += 1
            if(len(ktpfaces) &gt;= 1):
                ktpstatus += 1
            if(len(faces) != 1):
                try:
                    image_to_rotate = ndimage.imread("/var/www/html/classifier/upload/face" + id + extentionfile)
                    rotated = ndimage.rotate(image_to_rotate, 90)
                    misc.imsave("/var/www/html/classifier/upload/face" + id + extentionfile, rotated)
                    print("rotating selfie photo")
                except KeyError:
                    return jsonify(response=302, classify="Can't open selfie foto cause file is damage or missing, make sure to capture clearly")
            if(len(ktpfaces) != 1):
                try:
                    image_to_rotate = ndimage.imread("/var/www/html/classifier/ktp/face-" + id + extentionktp)
                    rotated = ndimage.rotate(image_to_rotate, 90)
                    misc.imsave("/var/www/html/classifier/ktp/face-" + id + extentionktp, rotated)
                    print("rotating ktp photo")
                except:
                    return jsonify(response=302, classify="Can't open KTP foto cause file is damage or missing, make sure to capture clearly")
            if(iter &gt;= 4 or (ktpstatus &gt;= 1 and selfiestatus &gt;=1)):
                status = False

        if (selfiestatus &lt;= 0):
            print("error image selfie")
            return jsonify(
                response=300,
                classify="No face found on selfie, make sure you have clearly selfie and just you in selfie photo"
            )

        elif (ktpstatus &lt;= 0):
            print("error image ktp")
            return jsonify(
                response=301,
                classify="No face found on KTP, make sure you have clearly capture KTP foto"
            )
        else:
            print("run liveness function")
            image = cv2.imread("/var/www/html/classifier/upload/face" + id + extentionfile, cv2.IMREAD_COLOR)

            image = cv2.resize(image, (28, 28))
            image = image.astype("float") / 255.0
            image = img_to_array(image)
            image = np.expand_dims(image, axis=0)
            model = load_model("/var/www/html/classifier/liveness.model")
            (notSanta, santa) = model.predict(image)[0]
            K.clear_session()
            label = "Live Person" if santa &gt; notSanta else "Fake"
            proba = santa if santa &gt; notSanta else notSanta
            if (label == "Live Person" and proba*100 &lt; 75.00):
                label = "Not Live Person"

            print (label)

            if(label == "Live Person"):
                print("read file ktp")
                ktp = base64.b64encode(open("/var/www/html/classifier/ktp/face-" + id + extentionktp, "rb").read())
                print("sending file selfie")
                selfie = base64.b64encode(open("/var/www/html/classifier/upload/face" + id + extentionfile, "rb").read())

                print("packing to img base64 to json")
                img = {'img1': selfie, 'img2': {'data':[ktp]}}
                jsondata = json.dumps(img)
                jsondataasbytes = jsondata.encode('utf-8')

                convert = 'img=' + jsondataasbytes

                print("sending 2 image in base64 format for matching, waiting...")
                r = requests.post("http://192.168.78.16/classifier/classifier.py", data=convert)
                print(r.text)

                res = r.text.replace("\n", "")
                result = float(res)

                if result &lt;= 0.48:
                    print(result)
                    result = 'true'
                else:
                    print(result)
                    result = 'false'

                response = request_ocr("", "/var/www/html/classifier/ktp/face-" + id + extentionfile)

                if response.status_code != 200 or response.json().get('error'):
                    print(response.text)
                else:
                    for idx, resp in enumerate(response.json()['responses']):
                        try:
                            t = resp['textAnnotations'][0]
                            text = t['description']
                            NIK = re.sub("\D", "", text)[:16]
                        except KeyError:
                            return jsonify(response=307, classify="Error when reading text from KTP with OCR function, make sure you send KTP correctly")
                stop = timeit.default_timer()

                print stop - start 
                return jsonify(
                    response=200,
                    NIK=NIK,
                    fileid=id,
                    liveness='true',
                    match=result,
                    score=r.text.replace("\n", ""))
            else:
                return jsonify(
                    liveness='false',
                    response=304,
                    classify=label,
                    score=proba * 100
                )

if __name__ == '__main__':
    app.run(threaded=True)
</code></pre>
<p>log:</p>
<pre><code>[Mon Sep 17 10:22:09.706774 2018] [core:notice] [pid 12837:tid 139745726404480] AH00094: Command line: '/usr/sbin/apache2'
[Mon Sep 17 10:22:19.648680 2018] [wsgi:error] [pid 12841:tid 139745593399040] [remote 210.210.184.38:17686] mod_wsgi (pid=12841): Target WSGI script '/var/www/html/cl
assifier/class.wsgi' cannot be loaded as Python module.
[Mon Sep 17 10:22:19.648721 2018] [wsgi:error] [pid 12841:tid 139745593399040] [remote 210.210.184.38:17686] mod_wsgi (pid=12841): Exception occurred processing WSGI s
cript '/var/www/html/classifier/class.wsgi'.
[Mon Sep 17 10:22:19.648735 2018] [wsgi:error] [pid 12841:tid 139745593399040] [remote 210.210.184.38:17686] Traceback (most recent call last):
[Mon Sep 17 10:22:19.648769 2018] [wsgi:error] [pid 12841:tid 139745593399040] [remote 210.210.184.38:17686]   File "/var/www/html/classifier/class.wsgi", line 5, in &lt;
module&gt;
[Mon Sep 17 10:22:19.648816 2018] [wsgi:error] [pid 12841:tid 139745593399040] [remote 210.210.184.38:17686]     from index import app as application
[Mon Sep 17 10:22:19.648822 2018] [wsgi:error] [pid 12841:tid 139745593399040] [remote 210.210.184.38:17686]   File "/var/www/html/classifier/index.py", line 4, in &lt;mo
dule&gt;
[Mon Sep 17 10:22:19.648909 2018] [wsgi:error] [pid 12841:tid 139745593399040] [remote 210.210.184.38:17686]     from flask_api import FlaskAPI
[Mon Sep 17 10:22:19.648923 2018] [wsgi:error] [pid 12841:tid 139745593399040] [remote 210.210.184.38:17686] ImportError: No module named flask_api
</code></pre>
<p>But to verify the installation I try this:</p>
<pre><code>(envface) root@nvidia-ngc-image-2-vm:/etc/apache2/sites-enabled# pip install flask_api
Requirement already satisfied: flask_api in /home/mip_mip774/cuda/envface/lib/python2.7/site-packages (1.0)
Requirement already satisfied: Flask&gt;=0.10.1 in /home/mip_mip774/cuda/envface/lib/python2.7/site-packages (from flask_api) (1.0.2)
Requirement already satisfied: Jinja2&gt;=2.10 in /home/mip_mip774/cuda/envface/lib/python2.7/site-packages (from Flask&gt;=0.10.1-&gt;flask_api) (2.10)
Requirement already satisfied: itsdangerous&gt;=0.24 in /home/mip_mip774/cuda/envface/lib/python2.7/site-packages (from Flask&gt;=0.10.1-&gt;flask_api) (0.24)
Requirement already satisfied: Werkzeug&gt;=0.14 in /home/mip_mip774/cuda/envface/lib/python2.7/site-packages (from Flask&gt;=0.10.1-&gt;flask_api) (0.14.1)
Requirement already satisfied: click&gt;=5.1 in /home/mip_mip774/cuda/envface/lib/python2.7/site-packages (from Flask&gt;=0.10.1-&gt;flask_api) (6.7)
Requirement already satisfied: MarkupSafe&gt;=0.23 in /home/mip_mip774/cuda/envface/lib/python2.7/site-packages (from Jinja2&gt;=2.10-&gt;Flask&gt;=0.10.1-&gt;flask_api) (1.0)
</code></pre>
<p>But when I use development flask with running: python main.py where main is flask file (not on apache2), that's successful run without error.</p>
<p>what the problem? any clue?</p>
</div>
<div class="post-text" itemprop="text">
<p>Usually, there are many python interpreters installed in a system and when you run <code>pip install some_lib</code> it's installed not system-wide, but for a single python interpreter, which is quite often is different from the one used by an Apache. Python's best practice is to use virtual environments so I'd advise you to learn <a href="https://docs.python.org/3//tutorial/venv.html" rel="nofollow noreferrer">what it is and how to create it</a> and <a href="https://modwsgi.readthedocs.io/en/develop/user-guides/virtual-environments.html" rel="nofollow noreferrer">how to use it with Apache+mod_wsgi</a>.</p>
</div>
