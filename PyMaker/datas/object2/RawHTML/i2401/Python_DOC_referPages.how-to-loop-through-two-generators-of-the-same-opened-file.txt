<div class="post-text" itemprop="text">
<p>I have a medium-size file (25MB, 1000000 rows), and I want to read every row except every third row.</p>
<p><strong>FIRST QUESTION</strong>: Is it faster to load the whole file into memory and then read the rows (method <code>.read()</code>), or load and read one row at the time (method <code>.readline()</code>)?</p>
<p>Since I'm not an experienced coder I tried the second option with <code>islice</code> method from <code>itertools</code> module.</p>
<pre><code>import intertools

with open(input_file) as inp:
    inp_atomtype = itertools.islice(inp, 0, 40, 3)
    inp_atomdata = itertools.islice(inp, 1, 40, 3)
    for atomtype, atomdata in itertools.zip_longest(inp_atomtype, inp_atomdata):
        print(atomtype + atomdata)
</code></pre>
<p>Although looping through single generator (<code>inp_atomtype</code> or <code>inp_atomdata</code>) prints correct data, looping through both of them simultaneously (as in this code) prints wrong data.</p>
<p><strong>SECOND QUESTION</strong>: How can I reach desired rows using generators?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>yield</code> is perfect for this.</p>
<p>This functions yields pairs from an iterable and skip every third item:</p>
<pre><code>def two_thirds(seq):
    _iter = iter(seq)
    while True:
        yield (next(_iter), next(_iter))
        next(_iter)
</code></pre>
<p>You will lose half pairs, which means that <code>two_thirds(range(2))</code> will stop iterating immediately.</p>
<p><a href="https://repl.it/repls/DullNecessaryCron" rel="nofollow noreferrer">https://repl.it/repls/DullNecessaryCron</a></p>
<p>You can also use the grouper recipe from <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools doc</a> and ignore the third item in each tuple generated:</p>
<pre><code>for atomtype, atomdata, _ in grouper(lines, 3):
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to slice the iterator, a simple line counter should be enough:</p>
<pre><code>with open(input_file) as f:
    current_line = 0
    for line in f:
        current_line += 1
        if current_line % 3:  # ignore every third line
            print(line)  # NOTE: print() will add an additional new line by default
</code></pre>
<p>As for turning it into a generator, just <code>yield</code> the line instead of printing. </p>
<p>When it comes to speed, given that you'll be reading your lines anyway the I/O part will probably take the same but you might benefit a bit (in total processing time) from fast list slicing instead of counting lines if you have enough working memory to keep the file contents and if loading the whole file upfront instead of <em>streaming</em> is acceptable.</p>
</div>
<div class="post-text" itemprop="text">
<p>FIRST QUESTION: I am pretty sure that .readline() is faster than .read(). Plus, the fastest way based my test is to do lopping like: </p>
<pre><code>with open(file, 'r') as f:
    for line in f:
        ...
</code></pre>
<p>SECOND QUESTION: I am not quite sure abut this. you may consider to use yield. </p>
<p>There is a code snippet you may refer:</p>
<pre><code>def myreadlines(f, newline):
    buf = ""
    while True:
        while newline in buf:
            pos = buf.index(newline)
            yield buf[:pos]
            buf = buf[pos + len(newline):]
        chunk = f.read(4096)

        if not chunk:
        # the end of file
            yield buf
            break
        buf += chunk

with open("input.txt") as f:
    for line in myreadlines(f, "{|}"):
        print (line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>q2: here's my generator:</p>
<pre><code>def yield_from_file(input_file):
    with open(input_file) as file:
        yield from file

def read_two_skip_one(gen):
    while True:
        try:
            val1 = next(gen)
            val2 = next(gen)
            yield val1, val2
            _ = next(gen)
        except StopIteration:
            break

if __name__ == '__main__':
    for atomtype, atomdata in read_two_skip_one(yield_from_file('sample.txt')):
        print(atomtype + atomdata)
</code></pre>
<p>sample.txt was generated with a bash shell (it's just lines counting to 100)</p>
<pre><code>for i in {001..100}; do echo $i; done &gt; sample.txt
</code></pre>
<p>regarding q1: if you're reading the file multiple times, you'd be better off to have it in memory. otherwise you're fine reading it line by line.</p>
<p>Regarding the problem you're having with the wrong results:</p>
<p>both <code>itertools.islice(inp, 0, 40, 3)</code> statements will use <code>inp</code> as generator. Both will call <code>next(inp)</code>, to provide you with a value.
Each time you call <code>next()</code> on an iterator, it will change its state, so that's where your problems come from.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a generator expression:</p>
<pre><code>with open(input_file, 'r') as f:
    generator = (line for e, line in enumerate(f, start=1) if e % 3)
</code></pre>
<p><code>enumerate</code> adds line numbers to each line, and the <code>if</code> clause ignores line numbers divisible by 3 (default numbering starts at 0, so you have to specify <code>start=1</code> to get the desired pattern).</p>
<p>Keep in mind that you can only use the generator while the file is still open.</p>
</div>
<span class="comment-copy">Sounds for me like an x y problem, what are you trying to solve?</span>
<span class="comment-copy">According to the value of <code>atomtype</code> I want to treat <code>atomdata</code> variable properly.</span>
<span class="comment-copy">That is a simple solution and I can reach the two variables at the same time.</span>
<span class="comment-copy">You can call <code>next(gen)</code> without assigning it to <code>_</code></span>
<span class="comment-copy">I know, it's a habit :D Some linters complain about not using a value.</span>
