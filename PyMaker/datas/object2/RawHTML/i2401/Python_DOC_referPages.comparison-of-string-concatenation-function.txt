<div class="post-text" itemprop="text">
<p>I'm learning Learn Python the hard way.</p>
<pre><code>w = "This is the left side of..."
e = "a string with a right side."
print w + e
</code></pre>
<p>Explain why adding the two strings <code>w</code> and <code>e</code> with + makes a longer string.</p>
<p>Even I know it can work, but I don't understand why and how? Please help me.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python uses <code>+</code> to concatenate strings because that's how core developers of Python defined that operator.</p>
<p>While it's true that <a href="https://docs.python.org/3/reference/datamodel.html#object.__add__" rel="nofollow"><code>__add__</code></a> special method is normally used to implement the <code>+</code> operator, <code>+</code> (<a href="https://docs.python.org/3/library/dis.html#opcode-BINARY_ADD" rel="nofollow"><code>BINARY_ADD</code> bytecode instruction</a>) does <em>not</em> call <code>str.__add__</code> because <code>+</code> treats strings specially in both Python 2 and Python 3. Python invokes the string concatenation function <em>directly</em> if both operands of <code>+</code> are strings, thus eliminating the need to call special methods.</p>
<p><strong>Python 3</strong> calls <code>unicode_concatenate</code> (<a href="https://hg.python.org/cpython/file/default/Python/ceval.c#l1559" rel="nofollow">source code</a>):</p>
<pre class="lang-c prettyprint-override"><code>TARGET(BINARY_ADD) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *sum;
    if (PyUnicode_CheckExact(left) &amp;&amp;
             PyUnicode_CheckExact(right)) {
        sum = unicode_concatenate(left, right, f, next_instr);
        /* unicode_concatenate consumed the ref to v */
    }
    else {
        sum = PyNumber_Add(left, right);
        Py_DECREF(left);
    }
    ...
</code></pre>
<p><strong>Python 2</strong> calls <code>string_concatenate</code> (<a href="https://hg.python.org/cpython/file/v2.7.9/Python/ceval.c#l1318" rel="nofollow">source code</a>):</p>
<pre class="lang-c prettyprint-override"><code>case BINARY_ADD:
    w = POP();
    v = TOP();
    if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
        /* INLINE: int + int */
        register long a, b, i;
        a = PyInt_AS_LONG(v);
        b = PyInt_AS_LONG(w);
        /* cast to avoid undefined behaviour
           on overflow */
        i = (long)((unsigned long)a + b);
        if ((i^a) &lt; 0 &amp;&amp; (i^b) &lt; 0)
            goto slow_add;
        x = PyInt_FromLong(i);
    }
    else if (PyString_CheckExact(v) &amp;&amp;
             PyString_CheckExact(w)) {
        x = string_concatenate(v, w, f, next_instr);
        /* string_concatenate consumed the ref to v */
        goto skip_decref_vx;
    }
    else {
      slow_add:
        x = PyNumber_Add(v, w);

    ...
</code></pre>
<p>This optimization has been in Python ever since 2004. From the <a href="http://bugs.python.org/issue980695" rel="nofollow">issue980695</a>:</p>
<blockquote>
<p>... in the attached patch <em>ceval.c</em> special-cases addition of two strings (in the same way as it special-cases addition of two integers already)</p>
</blockquote>
<p>But note that the main goal was greater than elimination of special attribute lookup.</p>
<hr/>
<p>For what it's worth, <code>str.__add__</code> still works as expected:</p>
<pre><code>&gt;&gt;&gt; w.__add__(e)
'This is the left side of...a string with a right side.'
</code></pre>
<p>and Python will call <code>__add__</code> methods of subclasses of <code>str</code>, because <code>PyUnicode_CheckExact(left) &amp;&amp; PyUnicode_CheckExact(right)</code> (or <code>PyString_CheckExact(v) &amp;&amp; PyString_CheckExact(w)</code>, in Python 2) from the code snippets above will be false:</p>
<pre><code>&gt;&gt;&gt; class STR(str):
...     def __add__(self, other):
...         print('calling __add__')
...         return super().__add__(other)
... 
&gt;&gt;&gt; STR('abc') + STR('def')
calling __add__
'abcdef'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__add__</code> method of the class <code>str</code> is called when you add (concatenate) two strings in this manner. The <code>__add__</code> method works as such, but the following is not verbatim from the source code:</p>
<pre><code>def __add__(self, str1, str2):
    str3 = [str1] #Convert to list
    str3.append(str2) #Add the second string to the list
    return ''.join(str3) #Return the two joined
</code></pre>
<hr/>
<p>Example:</p>
<pre><code>class MyString:
    def __init__(self, initstr):
        self.string = initstr
    def __add__(str1, str2):
        str3 = [str1.string] #Convert to list
        str3.append(str2.string) #Add the second string to the list
        return MyString(''.join(str3)) #Return the two joined
</code></pre>
<hr/>
<pre><code>&gt;&gt;&gt; a = MyString("Hello")
&gt;&gt;&gt; b = MyString(" World!")
&gt;&gt;&gt; c = a+b
&gt;&gt;&gt; c.string
'Hello World!'
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>+</code>, <code>-</code>, <code>*</code>, and other operators will work on anything that implements the right methods. Since strings implement the <code>__add__(self, other)</code> method, you can add two strings with <code>+</code>.</p>
<p>Try this: define your own string subclass and override its <code>__add__</code> method:</p>
<pre><code>class BadString(str):
    def __add__(self, other):
        # Ignore both input strings and just return this:
        return "Nothing Useful"

s = BadString("hello")

print("hello" + " world")    # "hello world"
print(s + "world")           # "Nothing Useful"
</code></pre>
<p>The same technique, operator overloading, lets you create classes that can use the built-in operators like <code>+</code> or <code>*</code> usefully, like vectors that can be added together.</p>
</div>
<span class="comment-copy">Why does this surprise you any more than the fact that <code>+</code> can add two numbers? That's just how Guido defined Python's <code>+</code> operator.</span>
<span class="comment-copy"><i>Explain why adding the two strings w and e with + makes a longer string.</i> - What else do you expect?</span>
<span class="comment-copy">Wait till you get to <code>'Hello' * 3</code></span>
