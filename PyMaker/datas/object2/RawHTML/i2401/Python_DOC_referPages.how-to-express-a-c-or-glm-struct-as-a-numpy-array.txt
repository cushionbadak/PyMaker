<div class="post-text" itemprop="text">
<p>I want to express the below struct into as numpy array.  </p>
<pre><code>struct UniformBufferObject {
    glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
};
</code></pre>
<p>Thereafter, the numpy array is meant to be read in as a GLSL layout:</p>
<pre><code>layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;
</code></pre>
<p>In the above statements, <code>mat4</code> denotes a 4x4 matrix.</p>
<p>Below, I created a python list which I then converts to a numpy array (w/o copying) with a 4x4 shape where each element is a <code>dtype=float32</code>. </p>
<p><strong>Question:</strong> What should I do next to represent the <code>UniformBufferObject</code> struct as a numpy array? </p>
<pre><code>&gt;&gt;&gt; model = [0.1, 0.1, 0.1, 1, 0.1, 0.1, 0.1, 1, 0.1, 0.1, 0.1, 1, 0.1, 0.1, 0.1, 0,]
&gt;&gt;&gt; view = [0.2, 0.2, 0.2, 1, 0.2, 0.2, 0.2, 1, 0.2, 0.2, 0.2, 1, 0.2, 0.2, 0.2, 0,]
&gt;&gt;&gt; proj = [0.3, 0.3, 0.3, 1, 0.3, 0.3, 0.3, 1, 0.3, 0.3, 0.3, 1, 0.3, 0.3, 0.3, 0,]
&gt;&gt;&gt; modeln = np.asarray(model, dtype= 'f4').reshape(4,4)
&gt;&gt;&gt; viewn = np.asarray(view, dtype= 'f4').reshape(4,4)
&gt;&gt;&gt; projn = np.asarray(proj, dtype= 'f4').reshape(4,4)
&gt;&gt;&gt; modeln
array([[0.1, 0.1, 0.1, 1. ],
       [0.1, 0.1, 0.1, 1. ],
       [0.1, 0.1, 0.1, 1. ],
       [0.1, 0.1, 0.1, 0. ]], dtype=float32)
&gt;&gt;&gt; viewn
array([[0.2, 0.2, 0.2, 1. ],
       [0.2, 0.2, 0.2, 1. ],
       [0.2, 0.2, 0.2, 1. ],
       [0.2, 0.2, 0.2, 0. ]], dtype=float32)
&gt;&gt;&gt; projn
array([[0.3, 0.3, 0.3, 1. ],
       [0.3, 0.3, 0.3, 1. ],
       [0.3, 0.3, 0.3, 1. ],
       [0.3, 0.3, 0.3, 0. ]], dtype=float32)
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If in GLSL a <a href="https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Uniform_blocks" rel="nofollow noreferrer">Uniform block</a> is specified like this</p>
<blockquote>
<pre><code> layout(binding = 0) uniform UniformBufferObject {
     mat4 model;
     mat4 view;
     mat4 proj;
 } ubo;
</code></pre>
</blockquote>
<p>then OpenGL does not guarantee, that the members in th block are stored in consecutive order. OpenGL gives no guarantees about the memory layout, alignment or order of the elements.</p>
<p>To achieve a well defined order and memory layout the <a href="https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout" rel="nofollow noreferrer">memory layout qualifier <code>std140</code></a> ahs to be used. The <code>std140</code> layout is provided since OpenGL 3.1 respectively OpenGL ES 3.0 or the OpenGL extension <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt" rel="nofollow noreferrer"><em>ARB_uniform_buffer_object</em></a>: </p>
<pre class="lang-c prettyprint-override"><code>layout(std140, binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;
</code></pre>
<p>A detailed specification about the layout can be found at:</p>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf" rel="nofollow noreferrer">OpenGL 4.6 API Core Profile Specification; 7.6.2.2 Standard Uniform Block Layout; page 144</a> </li>
<li><a href="https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.compatibility.pdf" rel="nofollow noreferrer">OpenGL 4.6 API Compatibility Profile Specification; 7.6.2.2 Standard Uniform Block Layout; page 145</a></li>
<li><a href="https://www.khronos.org/registry/OpenGL/specs/es/3.2/es_spec_3.2.pdf" rel="nofollow noreferrer">OpenGL ES 3.2 Specification; 7.6.2.2 Standard Uniform Block Layout; page 113</a></li>
</ul>
<p>In case of the above uniform block with <code>std140</code> layout the 3 matrices are tightly packed. The memory layout are 48 (3*4*4) <em><code>float</code>s</em> in a row and has a size of 192 bytes</p>
<pre class="lang-none prettyprint-override"><code>mat4 model     byte offset   0: size in bytes  64 = 4*4*sizeof(float)
mat4 view      byte offset  64: size in bytes  64 = 4*4*sizeof(float)
mat4 proj      byte offset 128: size in bytes  64 = 4*4*sizeof(float)
--------------------------------------------------------------------
                                size in bytes 192 = 3*4*4*sizeof(float)
</code></pre>
<p>To create a buffer which corresponds to this memory layout, a flat <a href="https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.array.html" rel="nofollow noreferrer"><code>numpy.array</code></a> can be used:</p>
<p>e.g.</p>
<blockquote>
<pre><code> model = [0.1, 0.1, 0.1, 1, 0.1, 0.1, 0.1, 1, 0.1, 0.1, 0.1, 1, 0.1, 0.1, 0.1, 0,]
 view = [0.2, 0.2, 0.2, 1, 0.2, 0.2, 0.2, 1, 0.2, 0.2, 0.2, 1, 0.2, 0.2, 0.2, 0,]
 proj = [0.3, 0.3, 0.3, 1, 0.3, 0.3, 0.3, 1, 0.3, 0.3, 0.3, 1, 0.3, 0.3, 0.3, 0,]
</code></pre>
</blockquote>
<pre class="lang-py prettyprint-override"><code>import numpy as np

ubo_data = np.array([model, view, proj], dtype='f4')
</code></pre>
<p>It is not necessary to <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.reshape.html" rel="nofollow noreferrer"><code>reshap()</code></a> the array. But of course you can do so, if you want to access the elements of the model matrix (<code>ubo_data[0]</code>), the view matrix (<code>ubo_data[1]</code>) and the projection matrix (<code>ubo_data[2]</code>) directly:</p>
<pre class="lang-py prettyprint-override"><code>ubo_data = np.array([model, view, proj], dtype='f4').reshape(3, 4, 4)
</code></pre>
<p>Note, it is even not necessary to use <a href="http://www.numpy.org/" rel="nofollow noreferrer">NumPy</a>. A buffer with the same memory layout can be generated by a <a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow noreferrer">ctypes</a> array:</p>
<pre class="lang-py prettyprint-override"><code>import ctypes

ubo_data = (ctypes.c_float * 48)(*model, *view, *proj)
</code></pre>
<p>Using <a href="http://pyopengl.sourceforge.net/" rel="nofollow noreferrer">PyOpenGL</a>, each of the above data arrays can be used to crate and initialize the buffer store of a uniform block buffer by <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml" rel="nofollow noreferrer"><code>glBufferData</code></a> </p>
<pre class="lang-py prettyprint-override"><code>ubo = glGenBuffers( 1 )
glBindBuffer(GL_UNIFORM_BUFFER, ubo)
glBufferData(GL_UNIFORM_BUFFER, ubo_data, GL_STATIC_DRAW)
glBindBufferBase(GL_UNIFORM_BUFFER, 0, ubo)
glBindBuffer(GL_UNIFORM_BUFFER, 0)
</code></pre>
<p>or update the data store of an existing buffer by <code>glBufferSubData</code>:</p>
<pre class="lang-py prettyprint-override"><code>glBindBuffer(GL_UNIFORM_BUFFER, ubo)
glBufferSubData(GL_UNIFORM_BUFFER, 0, ubo_data)
</code></pre>
<p>Note, when using <a href="https://pypi.org/project/PyGLM/" rel="nofollow noreferrer">PyGLM</a>, then the data of a uniform buffer like this can be updated directly: </p>
<p>e.g.:</p>
<pre class="lang-py prettyprint-override"><code>import glm
</code></pre>
<pre class="lang-py prettyprint-override"><code>model = glm.mat4(1)
view  = glm.lookAt(glm.vec3(0,-3,0), glm.vec3(0,0,0), glm.vec3(0,0,1))
proj  = glm.perspective(glm.radians(90), 800.0/600.0, 0.1, 100)

glBufferSubData(GL_SHADER_STORAGE_BUFFER, 0,                      glm.sizeof(glm.mat4), glm.value_ptr(model))
glBufferSubData(GL_SHADER_STORAGE_BUFFER, 1*glm.sizeof(glm.mat4), glm.sizeof(glm.mat4), glm.value_ptr(view))
glBufferSubData(GL_SHADER_STORAGE_BUFFER, 2*glm.sizeof(glm.mat4), glm.sizeof(glm.mat4), glm.value_ptr(proj))
</code></pre>
</div>
<span class="comment-copy"><code>... gglm::mat4 model;</code> That is <b>not</b> C.</span>
<span class="comment-copy">@wildplasser It is glm (based on C or C++?). But I think UniformBufferObject is a C struct that contains the glm objects. Or not? I may have to revise my question, but in essence is it possible to express the struct as a numpy array?</span>
<span class="comment-copy">Add some tags for the non python stuf - c, glm or what ever.</span>
