<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/45319890/how-does-the-asyncio-module-work-why-is-my-updated-sample-running-synchronously">How does the asyncio module work, why is my updated sample running synchronously?</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I have written a basic REST API using <a href="https://aiohttp.readthedocs.io/en/stable/index.html" rel="nofollow noreferrer"><code>aiohttp</code></a>, a simplified version of which is included below to illustrate the problem I am looking to solve.</p>
<p>The API has two endpoints - each of which calls a function that performs some calculations. The difference between the two is that for one of the endpoints, the calculations take 10 seconds, and for the other they take only 1 second.</p>
<p>My code is below (the actual calculations have been replaced with <code>time.sleep()</code> calls).</p>
<pre><code>import time
from aiohttp import web


def simple_calcs():
    time.sleep(1)  # Pretend this is the simple calculations
    return {'test': 123}

def complex_calcs():
    time.sleep(10)  # Pretend this is the complex calculations
    return {'test': 456}


routes = web.RouteTableDef()

@routes.get('/simple_calcs')
async def simple_calcs_handler(request):
    results = simple_calcs()
    return web.json_response(results)

@routes.get('/complex_calcs')
async def complex_calcs_handler(request):
    results = complex_calcs()
    return web.json_response(results)


app = web.Application()
app.add_routes(routes)
web.run_app(app)
</code></pre>
<p><strong>What I would like to happen:</strong></p>
<p>If I send a request to the slower endpoint, then immediately afterwards send a request to the faster endpoint, I would like to receive a response from the faster endpoint first while the slower calculations are still ongoing.</p>
<p><strong>What actually happens:</strong></p>
<p>The calculations being carried out by the slower endpoint are blocking. I receive the response from the slow endpoint after ~10 seconds and from the fast endpoint after ~11 seconds.</p>
<p>I've spent the last few hours going round in circles, reading up on <code>asyncio</code> and <code>multiprocessing</code>, but unable to find anything that could solve my problem. Probably I need to spend a bit longer studying this area to gain a better understanding, but hoping I can get a push in the right direction towards the desired outcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>Any blocking IO calls should be avoided in asyncio.</p>
<p>Essentially <code>time.sleep(10)</code> blocks the whole aiohttp server for 10 seconds.</p>
<p>To solve it please use <a href="https://docs.python.org/3/library/asyncio-eventloop.html?highlight=run_in_executor#asyncio.AbstractEventLoop.run_in_executor" rel="nofollow noreferrer">loop.run_in_executor()</a> call:</p>
<pre><code>async def complex_calcs():
    loop = asyncio.get_event_loop()
    loop.run_in_executor(None, time.sleep, 10)  # Pretend this is the complex calculations
    return {'test': 456}
</code></pre>
</div>
<span class="comment-copy">Asyncio goes really bad with CPU bound tasks, multiprocessing is the way to solve this, <a href="https://github.com/dano/aioprocessing" rel="nofollow noreferrer">aioprocessing</a> does a very good job mixing both</span>
<span class="comment-copy">@yorodm thanks, will have a read.</span>
<span class="comment-copy">Thank you - this got me on the right path, but I should add for anyone else reading that I had to insert <code>None</code> as the first argument: <code>loop.run_in_executor(None, time.sleep, 10)</code>.</span>
<span class="comment-copy">Thanks, updated the answer to add <code>None</code></span>
