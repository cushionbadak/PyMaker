<div class="post-text" itemprop="text">
<p>Is there a way to transform <code>cycle</code> from itertools into <code>list</code>? Applying <code>list(my_cycle)</code> freezes my computer.</p>
<p>I would like to periodically switch between a collection of objects infinitely. They are stored in a cycle. If one of my objects become 'inactive' I would like to delete it from cycle. I solved it with another list with inactive objects but it looks like bad workaround.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your set of all object (active and inactive) never changes, and especially if transitions between active and inactive state are common, the total number of objects isn't outrageous or the set of inactive objects doesn't usually cover most of the total set, <code>cycle</code> would still work fairly well here, by keeping a <code>set</code> of inactive objects around and filtering out currently inactive objects "live":</p>
<pre><code>from itertools import cycle, filterfalse

allobjects = [...]
numuniqueobjects = len(set(allobjects))
inactiveobjects = set()

# Each time we request an item, filterfalse pulls items from the cycle
# until we find one that isn't in our inactive set
for object in filterfalse(inactiveobjects.__contains__, cycle(allobjects)):

    # ... do actual stuff with object ...

    # Any objects that should go active again get removed from the set and will be
    # seen again the next time their turn comes up in the original order
    inactiveobjects -= objects_that_should_become_active()

    # Won't see this object again until it's removed from inactiveobjects
    if object.should_go_inactive():
        inactiveobjects.add(object)
        if len(inactiveobjects) == numuniqueobjects:
            # Nothing is active, continuing loop would cause infinite loop
            break
</code></pre>
<p>Advantages to this design are that:</p>
<ol>
<li>It makes it cheap to activate and deactivate objects</li>
<li>It preserves original iteration order indefinitely (if an object was originally in position 4, when it goes inactive it is skipped, and when it goes active again, it reappears after position 3 and before position 5 the next time you cycle through)</li>
</ol>
<p>The main downside is that it adds a tiny bit more overhead to the "nothing is changing" case, especially if the <code>set</code> of <code>inactiveobjects</code> grows to an appreciable fraction of the total number of objects; you still have to <code>cycle</code> <em>all</em> objects even if filter out <em>many</em> of them.</p>
<p>If that doesn't suit your use case, a custom version of <code>cycle</code> built on a <code>deque</code> as suggested by <a href="https://stackoverflow.com/a/52373731/364696">wim</a> is probably the best general purpose solution:</p>
<pre><code>from collections import deque
from collections.abc import Iterator

class mutablecycle(Iterator):
    def __init__(self, it):
        self.objects = deque(it)
        self.objects.reverse() # rotate defaults to equivalent of appendleft(pop())
                               # reverse so next item always at index -1

    def __next__(self):
        self.objects.rotate() # Moves rightmost element to index 0 efficiently
        try:
            return self.objects[0]
        except IndexError:
            raise StopIteration

    def removecurrent(self):
        # Remove last yielded element
        del self.objects[0]

    def remove(self, obj):
         self.objects.remove(obj)

    def add(self, obj, *, tofront=True):
        if tofront:
            # Putting it on right makes it be yielded on next request
            self.objects.append(obj)
        else:
            # Putting it on left makes it appear after all other elements
            self.objects.appendleft(obj)
</code></pre>
<p>Use would be:</p>
<pre><code>mycycle = mutablecycle(allobjects):
for object in mycycle:
    # ... do stuff with object ...

    if object.should_go_inactive():
        mycycle.removecurrent()  # Implicitly removes object currently being iterated
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, you can not, because a <code>cycle</code> is an infinite sequence.  Your computer "freezes" because Python is trying to iterate a never-ending collection of items (if you left it long enough, the process would run out of memory and crash).</p>
<p>What you can do, is collect a predetermined finite amount of the items into a list:</p>
<pre><code>n = 10  # some fixed size 
results = []
for i in range(n):
    results.append(next(my_cycle))
</code></pre>
<p>There is no general way to know how many items to consume to get one pass through a cycle, because the cycle object does not expose any state about the period of the underlying iteration, i.e. how many items were iterated before repeating. </p>
<p>There is no public way to modify the items returned from a cycle once the first <code>StopIteration</code> from the original iterator has been encountered, they are all buffered to private memory somewhere:</p>
<pre><code>&gt;&gt;&gt; L = [0,1,2]
&gt;&gt;&gt; g = itertools.cycle(L)
&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; L.remove(1)
&gt;&gt;&gt; next(g)
2
&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; L.remove(2)
&gt;&gt;&gt; next(g)
2
</code></pre>
<p>For cycling a mutable sequence, as an alternative design choice you could consider using a <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a> instance as your data structure (the <code>rotate</code> method is efficient).</p>
</div>
<span class="comment-copy"><code>Applying list() freezes my computer.</code> of course it does. <code>cycle</code> never raises <code>StopIteration</code>. Even if it did, how would that list look like?</span>
<span class="comment-copy">What do you expect to be the result? <code>cycle</code> represents an infinite number of items repeating over and over.</span>
<span class="comment-copy">I suppose its internal design is built on <code>list</code>. So it is easy to convert it to list</span>
<span class="comment-copy">@danielleontiev What lead you to assume that?</span>
<span class="comment-copy">@danielleontiev: You might want to ask a (new) question about that actual problem. You've got <a href="https://meta.stackexchange.com/q/66377/322040">an XY problem</a> here, where you're trying to get us to help make a poor approach work, when the real solution is to find a better approach.</span>
<span class="comment-copy">For reference: <a href="https://stackoverflow.com/questions/4152376/how-to-get-the-n-next-values-of-a-generator-in-a-list-python" title="how to get the n next values of a generator in a list python">stackoverflow.com/questions/4152376/â€¦</a></span>
<span class="comment-copy">@DeepSpace: Probably meant to use <code>itertools.islice</code>?</span>
<span class="comment-copy">"There is no public way to modify the items returned from a cycle once the first <code>StopIteration</code> from the original iterator has been encountered." Adding to that, even before the original iterator has been exhausted, any code that tried to modify the cycle by modifying whatever the original iterator was based on would be a maintenance nightmare waiting to happen, and likely break various rules (implicit or explicit) of Python (e.g. don't modify collections while iterating them).</span>
<span class="comment-copy">It's important to understand that this will not work after <code>cycle</code> iterated over the entire iterable once. See this <a href="https://gist.github.com/DeepSpace2/d4043b59bc2c417620175716adacdbd8" rel="nofollow noreferrer">gist</a> This is because <code>cycle</code> uses an internal structure to store "visited" elements which we don't have access to.</span>
<span class="comment-copy">Yes, implementing my own cycle or using another data structure like deque are the best choices to solve this problem</span>
