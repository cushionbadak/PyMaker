<div class="post-text" itemprop="text">
<p>I have a class which represents a mathematical model. Within this class, I have methods to solve the model, methods to print the results, etc.</p>
<p>The model can be solved for different functions. I am wondering what is the best way to pass a method when I initialize a python object.</p>
<p>To give an example, suppose I had the class <code>Foo</code> and the method <code>f1</code>. My goal is that instead of being defined inside the class definition, <code>f1</code> would be passed as a parameter.</p>
<p>So, I know I can do this:</p>
<pre><code>class Foo:
    def __init__(self, x1):
        self.x1 = x1

    def f1(self):
        return self.x1

bar = Foo(10)

print(bar.f1())
# Result: 10
</code></pre>
<p>But is there a way to do this:</p>
<pre><code>class Foo:
    def __init__(self, x1, f1):
        self.x1 = x1
        self.f1 = f1

def f_outside(self):
    return self.x1

bar = Foo(10, f_outside)

print(bar.f1())
# Result: 10
</code></pre>
<p>The last code example does not work. The error is: <code>missing 1 required positional argument: 'self'</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can do that, because methods are just bound functions.</p>
<p>When you look up a method on an instance (such as <code>bar.f1</code>, note, no call yet) and Python finds a function by the name <code>f1</code> on the <em>class</em> (not the instance itself), then the function is bound, resulting in a method object. Python uses the <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer"><code>__get__</code> method</a> for this; functions define that method, and calling it with the right arguments produces a method.</p>
<p>When you store a function on an instance however, that doesn't happen. It's already part of an instance, it doesn't need to be bound, right? So when you use <code>self.f1 = f1</code>, no binding takes place. Calling <code>bar.f1()</code> will then fail to pass in <code>self</code> so you get an error.</p>
<p>But nothing stops you from binding the function yourself:</p>
<pre><code>class Foo:
    def __init__(self, x1, f1):
        self.x1 = x1
        self.f1 = f1.__get__(self)
</code></pre>
<p>Now <code>bar.f1()</code> works, because <code>f1</code> has been bound to <code>bar</code>:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     def __init__(self, x1, f1):
...         self.x1 = x1
...         self.f1 = f1.__get__(self)
...
&gt;&gt;&gt; def f_outside(self):
...     return self.x1
...
&gt;&gt;&gt; bar = Foo(10, f_outside)
&gt;&gt;&gt; bar.f1()
10
</code></pre>
<p>There are other ways of achieving the same thing; you could store a function created with <code>lambda</code> to explicitly pass in <code>self</code>:</p>
<pre><code>self.f1 = lambda: f1(self)
</code></pre>
<p>or you could use a <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial()</code></a> object to have it pass in <code>self</code>:</p>
<pre><code>self.f1 = partial(f1, self)
</code></pre>
<p>or you could create a method instance from by using the type object for methods directly; there is a reference to the type via <a href="https://docs.python.org/3/library/types.html#types.MethodType" rel="nofollow noreferrer"><code>typing.MethodType</code></a>:</p>
<pre><code>self.f1 = MethodType(f1, self)
</code></pre>
<p>but that last one is going to achieve the exact same thing as <code>f1.__get__(self)</code>.</p>
<p>If you want to dive into the deep end and learn more about binding, then you want to read the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor HOWTO</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You hopefully have better names in production code. Also, it'd probably make more sense to pass "x1" to the call, not to the initializer.</p>
<pre><code>…
    def __call__(self):
        return self.f1(self.x1)
…
print(bar())
</code></pre>
<p>You can make your second thing work if you pass <code>self</code> to the callable as in <code>self.f1(self)</code> (again, design wise that'd be possibly on the smelly side).</p>
<p>For a better overall structure, look into the "template method" design pattern.</p>
</div>
<span class="comment-copy">Why do you want to do this? What problem are you trying to solve?</span>
<span class="comment-copy">Yes, you can do that. Just call <code>self.f1(self)</code>. Presto!</span>
<span class="comment-copy">@roganjosh, without getting into the details, the class <code>Foo</code> here represents a dynamic discrete choice model and can be solved for different "utility functions". My goal is to define the class <code>Foo</code> and without changing the code, solving for e.g. a quadratic utility function, a linear utility function, or even functions with different parameters.</span>
