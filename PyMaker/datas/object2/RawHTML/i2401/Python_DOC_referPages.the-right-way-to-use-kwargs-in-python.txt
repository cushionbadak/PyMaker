<div class="post-text" itemprop="text">
<p>I took a look at <a href="https://stackoverflow.com/questions/1098549/proper-way-to-use-kwargs-in-python">this question</a> but it doesn't exactly answer my question.
As an example, I've taken a simple method to print my name.</p>
<pre><code>def call_me_by_name(first_name):
    print("Your name is {}".format(first_name))
</code></pre>
<p>Later on, I realized that optionally, I would also like to be able to print the middle name and last name. I made the following changes to accommodate that using **kwargs fearing that in the future, I might be made to add more fields for the name itself (such as a 3rd, 4th, 5th name etc.)</p>
<p>I decided to use **kwargs</p>
<pre><code>def call_me_by_name(first_name,**kwargs):

    middle_name = kwargs['middle_name'] if kwargs.get('middle_name') else ""
    last_name = kwargs['last_name'] if kwargs.get('last_name') else ""

    print("Your name is {} {} {}".format(first_name,middle_name,last_name))
</code></pre>
<p>My only concern here is that as I continue to implement support for more names, I end up writing one line of code for every single keyword argument that may or may not come my way. I'd like to find a solution that is as pythonic as possible. Is there a better way to achieve this ? </p>
<p><strong>EDIT 1</strong></p>
<p>I want to use keyword arguments since this is just an example program. The actual use case is to parse through a file. The keyword arguments as of now would support parsing a file from </p>
<p>1) A particular byte in the file.<br/>
2) A particular line number in the file. </p>
<p>Only one of these two conditions can be set at any given point in time (since it's not possible to read from a particular byte offset in the file and from a line number at the same time.) but there could be more such conditions in the future such as parse a file from the first occurrence of a character etc. There could be 10-20 different such conditions my method should support BUT only one of those conditions would ever be set at any time by the caller. I don't want to have 20-30 different IF conditions unless there's no other option.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have two separate questions with two separate pythonic ways of answering those questions.</p>
<p>1- Your first concern was that you don't want to keep adding new lines the more arguments you start supporting when formatting a string. The way to work around that is using a <code>defaultdict</code> so you're able to return an empty string when you don't provide a specific keyword argument and <code>str.format_map</code> that accepts a dict as a way to input keyword arguments to format. This way, you only have to update your string and what keyword arguments you want to print:</p>
<pre><code>from collections import defaultdict
def call_me_by_name(**kwargs):
    default_kwargs = defaultdict(str, kwargs)
    print("Your name is {first_name} {second_name} {third_name}".format_map(default_kwargs))
</code></pre>
<p>2- If, on the other hand and answering your second question, you want to provide different behavior depending on the keyword arguments, like changing the way a string looks or providing different file lookup functionalities, without using if statements, you have to add different functions/methods and call them from this common function/method. Here are two ways of doing that:</p>
<p>OOP:</p>
<pre><code>class FileLookup:

    def parse(self, **kwargs):
        return getattr(self, next(iter(kwargs)))(**kwargs)

    def line_number(self, line_number):
        print('parsing with a line number: {}'.format(line_number))

    def byte_position(self, byte_position):
        print('parsing with a byte position: {}'.format(byte_position))

fl = FileLookup()
fl.parse(byte_position=10)
fl.parse(line_number=10)
</code></pre>
<p>Module:</p>
<pre><code>def line_number(line_number):
    print('parsing with a line number: {}'.format(line_number))

def byte_position(byte_position):
    print('parsing with a byte position: {}'.format(byte_position))

def parse(**kwargs):
    return globals()[next(iter(kwargs))](**kwargs)

parse(byte_position=29)
parse(line_number=29)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Seem to me your better off not using kwargs and not even a function, you can simply do something like this:</p>
<pre><code>print("Your name is", " ".join([first_name, middle_name, last_name]))
</code></pre>
<p>Or if you do want a function:</p>
<pre><code>def call_me_by_name(*args):
     print("Your name is", " ".join(args))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your function care so specifically about keyword arguments, this is probably not the right tool. In this case, you can get the same effect with default arguments:</p>
<pre><code>def call_me_by_name(first_name, middle_name="", last_name=""):
    print("Your name is {} {} {}".format(first_name,middle_name,last_name))
</code></pre>
<p>It's better for when you want a sort of "grab-bag" of options. E.g.</p>
<pre><code>def configure(**kwargs):
    if 'color' in kwargs:
        set_color(kwargs['color'])
</code></pre>
<p>etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simplify it by:</p>
<pre><code>middle_name = kwargs.get('middle_name', '')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I will post it as a answer then : </p>
<p>You can instantly unpack the <strong>kwargs</strong> values to the format function like this :</p>
<pre><code>"Your name is {} {} {}".format(first_name , *kwargs)
</code></pre>
<p>But as a User <strong>@PM 2Ring</strong> mentioned You must be aware that doesn't guarantee that the names will be in the correct order. </p>
</div>
<div class="post-text" itemprop="text">
<p>I think that your call_me_by_name is no good example for **kwargs. But if you want to avoid omitting some exotic, unconsidered name fields, call_me_by_name could look like:</p>
<pre><code>def call_me_by_name(first_name, last_name, middle_name='', **kwargs):
    s = "Your name is {} {} {}".format(first_name,middle_name,last_name)
    if kwargs:
        s += " (" + ", ".join(["{}: {}".format(k,v) for k,v in kwargs.items()]) + ")"
    print(s)
</code></pre>
<p>Test:</p>
<pre><code>name = {'first_name': 'Henry', 'last_name': 'Ford', 'ordinal': 'II', 'nickname': 'Hank the Deuce'}
call_me_by_name(**name)
&gt;&gt;&gt; Your name is Henry  Ford (ordinal: II, nickname: Hank the Deuce)
</code></pre>
</div>
<span class="comment-copy">why not unpack dict  with <code>*</code> ? I mean You can directly put kwargs in format <code>...format(*kwargs)</code> , but Your formating string must just have  placeholders</span>
<span class="comment-copy">@Take_Care_ Prior to python 3.6, that doesn't guarantee that the names will be in the correct order. And what happens if names are missing?</span>
<span class="comment-copy">@PM 2Ring Thanks for mentioning. Yea ,user must be aware of this :P</span>
<span class="comment-copy">@PM2Ring, I've edited my question to explain my use case more thoroughly.</span>
<span class="comment-copy">If only one option can ever be set, why not just use an <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">enum</a> or similar?</span>
<span class="comment-copy">You could let <code>print</code> do all the work, eg <code>print("Your name is", *args)</code></span>
<span class="comment-copy">@PM2Ring, even better indeed.</span>
<span class="comment-copy">I've edited my post and explained the actual use case.</span>
<span class="comment-copy">This makes it more pythonic, thanks :).</span>
