<div class="post-text" itemprop="text">
<p>Hello I tried to make a simple server that accept multiple clients simultaneously I'm new to python and I have a difficult to understand it....I try to change my code in multi-thread applications but without positive result...here is the code:</p>
<pre><code>import socket, threading
def message():
    while 1:
        data = connection.recv(1024)
        if not data: break
        #connection.sendall(b'-- Message Received --\n')
        print(data.decode('utf-8'))
    connection.close()

def connection():
    address = input("Insert server ip")
    port = 44444
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((address, port))
    s.listen(1) 
    print("Server started! Waiting for connections...")

def accept connection():
    connection, address = s.accept()
    print('Client connected with address:', address)
    t=thread.Threading(target=message,args=(connection))
    t.run()
</code></pre>
<p>I know that there are many errors but I'm new in python sorry :(</p>
<p>The original non-threaded code is:</p>
<pre><code>import socket

address = input("Insert server ip:")
port = 44444

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((address, port))
s.listen(1)
print("Server started! Waiting for connections...")

connection, address = s.accept()
print('Client connected with address:', address)

while 1:
    data = connection.recv(1024)
    if not data: break

    #connection.sendall(b'-- Message Received --\n')
    print(data.decode('utf-8'))

connection.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your basic design is close, but you've got a whole lot of little problems making it hard to move forward.</p>
<p>First, you have a function name with a space in it, which isn't allowed. And you have an <code>IndentationError</code> because you didn't indent its contents.</p>
<hr/>
<p>Next, inside that <code>accept_connection</code> function, you're using <code>threading</code> wrong.</p>
<p><code>thread.Threading</code> doesn't exist; you probably meant <code>threading.Thread</code>.</p>
<p><code>args</code> has to be a sequence (tuple, list, etc.) of values. You probably expected <code>(connection)</code> to be a tuple of one value, but it's not; tuples are defined by commas, not parentheses, and what you have is just the value <code>connection</code> with superfluous parentheses around it. You wanted <code>(connection,)</code> here.</p>
<p>Also, calling <code>run</code> on a thread object just runs the thread's code in the current thread. You want to call <a href="https://docs.python.org/3/library/threading.html#threading.Thread.start" rel="nofollow"><code>start</code></a>, which will start a new thread and call the <code>run</code> method on that thread.</p>
<hr/>
<p>Meanwhile, you're never actually calling this function anywhere, so of course it can't do anything. Think about where you want to call it. After creating the listener socket, you want to loop around <code>accept</code>, kicking off a new client thread for each accepted connection, right? So, you want to call it in a loop, either inside <code>connection</code>, or at the top level (in which case <code>connection</code> has to <code>return s</code>).</p>
<hr/>
<p>And finally, your <code>accept_connection</code> function can't access local variables from some other function; if you want it to use a socket named <code>s</code>, you have to pass it as a parameter.</p>
<p>So:</p>
<pre><code>def connection():
    address = input("Insert server ip")
    port = 44444
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((address, port))
    s.listen(1) 
    print("Server started! Waiting for connections...")
    while True:
        accept_connection(s)

def accept_connection(s):
    connection, address = s.accept()
    print('Client connected with address:', address)
    t=thread.Threading(target=message, args=(connection,))
    t.start()
</code></pre>
<hr/>
<p>As a side note, be careful with using <code>sock.recv(1024)</code> and assuming you're going to get the whole message that the other side sent with <code>send(msg)</code>. You <em>might</em> get that, or you might get half the message, or the whole message plus half of another message the client sent later. Sockets are just streams of bytes, like files, not streams of separate messages; you need some kind of protocol to separate messages.</p>
<p>The simplest possible protocol is to send each message on its own line. Then you can just do <code>socket.makefile()</code> and <code>for line in f:</code>, just like you would for a real file. Of course this doesn't work if your messages can have newlines, but you can, e.g., backslash-escape them on one side and unescape them on the other.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is some example code I have showing a threaded socket connection. </p>
<pre><code>def sock_connection( sock, host ):
  "Handle socket"
  pass

while 1:
  try:
    newsock = sock.accept()
    thread = Thread( target=sock_connection, args=newsock )
    thread.start()
  except Exception, e:
    print "error on socket connection: " % e)
</code></pre>
</div>
<span class="comment-copy">Please fix the formatting so this at least compiles and demonstrates your problem (indentation, function names with spaces in them, etc.).</span>
