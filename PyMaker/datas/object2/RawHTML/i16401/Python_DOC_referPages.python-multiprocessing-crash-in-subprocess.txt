<div class="post-text" itemprop="text">
<p>What happens when a python script opens subprocesses and one process crashes? </p>
<p><a href="https://stackoverflow.com/a/18216437/311901">https://stackoverflow.com/a/18216437/311901</a></p>
<p>Will the main process crash? </p>
<p>Will the other subprocesses crash? </p>
<p>Is there a signal or other event that's propagated? </p>
</div>
<div class="post-text" itemprop="text">
<p>When using <code>multiprocessing.Pool</code>, if one of the subprocesses in the pool crashes, you will not be notified at all, and a new process will immediately be started to take its place:</p>
<pre><code>&gt;&gt;&gt; import multiprocessing
&gt;&gt;&gt; p = multiprocessing.Pool()
&gt;&gt;&gt; p._processes
4
&gt;&gt;&gt; p._pool
[&lt;Process(PoolWorker-1, started daemon)&gt;, &lt;Process(PoolWorker-2, started daemon)&gt;, &lt;Process(PoolWorker-3, started daemon)&gt;, &lt;Process(PoolWorker-4, started daemon)&gt;]
&gt;&gt;&gt; [proc.pid for proc in p._pool]
[30760, 30761, 30762, 30763]
</code></pre>
<p>Then in another window:</p>
<pre><code>dan@dantop:~$ kill 30763
</code></pre>
<p>Back to the pool:</p>
<pre><code>&gt;&gt;&gt; [proc.pid for proc in p._pool]
[30760, 30761, 30762, 30767]  # New pid for the last process
</code></pre>
<p>You can continue using the pool as if nothing happened. However, any work item that the killed child process was running at the time it died will <strong>not</strong> be completed or restarted. If you were running a blocking <code>map</code> or <code>apply</code> call that was relying on that work item to complete, it will likely hang indefinitely. There is a <a href="http://bugs.python.org/issue9205" rel="nofollow noreferrer">bug filed for this</a>, but the issue was only fixed in <a href="https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor" rel="nofollow noreferrer"><code>concurrent.futures.ProcessPoolExecutor</code></a>, rather than in <code>multiprocessing.Pool</code>. Starting with Python 3.3, <code>ProcessPoolExecutor</code> will raise a <code>BrokenProcessPool</code> exception if a child process is killed, and disallow any further use of the pool. Sadly, <code>multiprocessing</code> didn't get this enhancement. For now, if you want to guard against a pool call blocking forever due to a sub-process crashing, you have to use <a href="https://stackoverflow.com/a/24396655/2073595">ugly workarounds</a>.</p>
<p><strong>Note</strong>: The above only applies to a process in a pool actually <em>crashing</em>, meaning the process completely dies. If a sub-process raises an exception, that will be propagated up the parent process when you try to retrieve the result of the work item:</p>
<pre><code>&gt;&gt;&gt; def f(): raise Exception("Oh no")
... 
&gt;&gt;&gt; pool = multiprocessing.Pool()
&gt;&gt;&gt; result = pool.apply_async(f)
&gt;&gt;&gt; result.get()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python2.7/multiprocessing/pool.py", line 528, in get
    raise self._value
Exception: Oh no
</code></pre>
<p>When using a <code>multiprocessing.Process</code> directly, the process object will show that the process has exited with a non-zero exit code if it crashes:</p>
<pre><code>&gt;&gt;&gt; def f(): time.sleep(30)
... 
&gt;&gt;&gt; p = multiprocessing.Process(target=f)
&gt;&gt;&gt; p.start()
&gt;&gt;&gt; p.join()  # Kill the process while this is blocking, and join immediately ends
&gt;&gt;&gt; p.exitcode
-15
</code></pre>
<p>The behavior is similar if an exception is raised:</p>
<pre><code>from multiprocessing import Process

def f(x):
    raise Exception("Oh no")

if __name__ == '__main__':
    p = Process(target=f)
    p.start()
    p.join()
    print(p.exitcode)
    print("done")
</code></pre>
<p>Output:</p>
<pre><code>Process Process-1:
Traceback (most recent call last):
  File "/usr/lib/python3.2/multiprocessing/process.py", line 267, in _bootstrap
    self.run()
  File "/usr/lib/python3.2/multiprocessing/process.py", line 116, in run
    self._target(*self._args, **self._kwargs)
TypeError: f() takes exactly 1 argument (0 given)
1
done
</code></pre>
<p>As you can see, the traceback from the child is printed, but it doesn't affect exceution of the main process, which is able to show the <code>exitcode</code> of the child was <code>1</code>.</p>
</div>
