<div class="post-text" itemprop="text">
<p>I'm writing a class decorator in python. As part of the decorator I would like to assert that the class does not use the default <code>__eq__</code> and <code>__hash__</code> methods. How can I do this?</p>
<pre><code>@identifer # should throw AssertionError
class X(object):
    pass
</code></pre>
<p>I've explored these (besides googling, and looking in docs):</p>
<pre><code>hasattr(X, '__eq__') # True :(

xeq, oeq = X.__eq__, object.__eq__
xeq is oeq # False :(
xeq == oeq # False :(

'__eq__' in X.__dict__ # False :)?
</code></pre>
<p>Testing the class's <code>__dict__</code> appears to work, but it doesn't seem to work if the class inherits the methods from a super class. So I <em>could</em> traverse the inheritance graph looking for the methods, but I want to know if there is a cleaner implementation first.</p>
<p>This is in 2.7, but would also like it to work in 3.x</p>
</div>
<div class="post-text" itemprop="text">
<p>If the whole class hierarchy needs to count, you could use:</p>
<pre><code>all('__eq__' not in cls.__dict__ for cls in X.mro() if cls is not object)
</code></pre>
<p>This only returns True if there is no <code>__eq__</code> attribute in any of the classes in the MRO, except for <code>object</code>. This won't work for old-style Python 2 classes, as they don't have a <a href="https://docs.python.org/3/library/stdtypes.html#class.mro" rel="nofollow"><code>class.mro()</code> method</a>, however.</p>
</div>
<span class="comment-copy">Presumably, you don't actually care that a function overrides the <b>eq</b> method - only that two semantically-identical instances are considered equal. So why not test the behaviour of an <code>==</code> check?</span>
<span class="comment-copy">Also, are you aware that in Python 2.x, <code>object</code> does not actually implement <code>__eq__</code>? <code>object.__eq__</code> is actually an instance method of the <code>object</code> object itself; it's called for <code>object == whatever</code>, not <code>object() == whatever</code>.</span>
<span class="comment-copy">Also, what is the actual problem you’re trying to solve? Because it is possible that solutions suggested here (such as the one from Martijn Pieters), won’t work for you. If you need e.g. hashabiliy, you also need to chech that <code>__eq__</code> and <code>__hash__</code> are actually callables</span>
<span class="comment-copy">@user2357112: sure, but in Python 3 it does, so if this is to work across both major versions then you need to test for it anyway. :-)</span>
<span class="comment-copy">@JonasWielicki: if <code>__eq__</code> is not callable, then that's an error. Assigning <code>None</code> to <code>__hash__</code> is supported to indicate that an object is not hashable, so it <i>doesn't have to be callable</i>.</span>
<span class="comment-copy">Perfect! Much nicer after adding the <code>mro()</code> part!</span>
