<div class="post-text" itemprop="text">
<p>Apparently I have a problem with my code. When I run the below module with Python 3.3.3 Shell, I get the error <code>SyntaxError: expected an indented block</code>. Then IDLE highlights <code>elif</code> on line 7.</p>
<pre><code>def user_input():
    print('[1]: ASCII to Binary')
    print('[2]: Binary to ASCII')
    user_input = input('Please choose [1] or [2]: ')
    if user_input == ('1', '[1]'):
        #
    elif user_input == ('2', '[2]'):
        #
    else:
        print('Please enter a valid input...')
        user_input()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You <em>must</em> have actual code in each <code>if</code> and <code>elif</code> block, you cannot just use a comment.</p>
<p>Use a <a href="https://docs.python.org/3/reference/simple_stmts.html#pass" rel="nofollow noreferrer"><code>pass</code> statement</a> in such cases:</p>
<pre><code>if user_input == ('1', '[1]'):
    pass
elif user_input == ('2', '[2]'):
    pass
else:
    print('Please enter a valid input...')
    user_input()
</code></pre>
<p>Also, you can’t actually use <code>user_input</code> as a local variable name in your function <em>and</em> still be able to call the function by that name.  Local variables shadow globals, so the <code>user_input()</code> call in the <code>else:</code> suite will raise a <code>TypeError</code> as it is actually the string referenced by the local variable that’ll be called. Use a different name for the local variable; <code>choice</code> would be a good option. </p>
<p>Next, you compared strings to tuples, those two types will never be equal Use <code>in</code> to test if there is a string in the tuple that is equal to the user input:</p>
<pre><code>if choice in ('1', '[1]'):
    pass
</code></pre>
<p>If you used sets (<code>{element1, element2, ...}</code>) that’d even be beter, as testing afwindt a set is faster. </p>
<p>You <em>could</em> just invert and combine the tests, and not need those empty blocks at all: </p>
<pre><code>choice = input('Please choose [1] or [2]: ')
if choice not in {'1', '[1]', '2', '[2]'}:
    print('Please enter a valid input...')
    user_input()
</code></pre>
<p>And finally, use a loop, not recursion, to repeat the question on incorrect input. That’ll let you avoid the mistake you made here if not returning the recursive call result up the call chain and avoid the recursion limits (you can’t call functions without returning indefinitely, and you’d be surprised at how many users will try to see how long they can keep up entering bad options).</p>
<p>A <code>while True</code> loop truly will keep on going:</p>
<pre><code>def user_input():
    print('[1]: ASCII to Binary')
    print('[2]: Binary to ASCII')
    while True:
        choice = input('Please choose [1] or [2]: ')
        if choice in {'1', '[1]', '2', '[2]'}:
            return choice
        print('Please enter a valid input...')
</code></pre>
<p>The <code>return</code> exits the function (and so the loop), otherwise the user forever is told to provide valid input. </p>
</div>
<span class="comment-copy">Replace the <code>#</code>s with <code>pass</code>s.</span>
