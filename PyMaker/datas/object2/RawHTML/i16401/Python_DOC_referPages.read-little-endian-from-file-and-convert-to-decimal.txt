<div class="post-text" itemprop="text">
<p>I have a file containing unsigned 64 bit integers in little endian format shown below</p>
<pre><code>0100 0000 0000 0000 
0200 0000 0000 0000 
0300 0000 0000 0000 
3655 9d80 0f00 0000 
7a64 dae3 0900 0000 
060f fa3f 0600 0000
</code></pre>
<p>I'm looking for a way to read these numbers in and then convert them to their decimal equivilant</p>
<p>The code I have so far is as follows:</p>
<pre><code>filename = "C:\\RainbowTables\\md5_loweralpha-numeric#1-7_0_2x50_0.rt"
blocksize = 8

with open(filename, "rb") as f:
    startpoint = f.read(blocksize)
    string = ""
    for ch in startpoint:
        string += hex(ord(ch))
    print string
</code></pre>
<p>which gives me the following output from the first number</p>
<pre><code>0x10x00x00x00x00x00x00x0
</code></pre>
<p>I've been looking at how to use structs for this as it seems like it is what it was made for but I've been unable to find the correct syntax using them.</p>
<p>Any help would be hugely appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import struct
decoded = []
with open("some_bin_file.rt","rb") as f:
     while True:
          try: 
             decoded.append(struct.unpack_from("&lt;Q",f)[0])
             # `&lt;` means little endian; `Q` means unsigned long long (8 bytes)            
          except struct.error:
             break

print decoded
</code></pre>
<p>should work I think ...</p>
</div>
<div class="post-text" itemprop="text">
<p>The key is the <a href="https://docs.python.org/3/library/struct.html#struct.unpack" rel="nofollow"><code>struct</code></a> module—in particular, <code>struct.unpack</code>—just as Joran Beasley explains.</p>
<p>So, loop over your file, reading 8 bytes at a time until the end:</p>
<pre><code>filename = "C:\\RainbowTables\\md5_loweralpha-numeric#1-7_0_2x50_0.rt"
blocksize = 8

with open(filename, "rb") as f:
    while True:
        buf = f.read(blocksize)
        if not buf:
            break
</code></pre>
<p>… unpacking each 8 bytes as a little-endian 64-bit unsigned int:</p>
<pre><code>        value = struct.unpack('&lt;Q', buf)
</code></pre>
<p>… and doing whatever you want with each number—maybe adding it to a list?… but let's just print it out for now:</p>
<pre><code>        print value
</code></pre>
<p>… and you're done.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to this comment:</p>
<blockquote>
<p>It's working now but I'm not sure it's giving me the correct output (or atleast the output I'm expecting) Assuming the first 8 bytes of the file are code in <code>0100 0000 0000 0000</code> as it's in little endian this should be <code>0000 0000 0000 0001</code> in normal hex I believe. which is 1 in standard decimal. but when I run it using both answers I get the following output instead - <code>3472328296227680560L, 3472328296227680304L</code></p>
</blockquote>
<p>I'm willing to bet you're wrong about your file format. Look at this:</p>
<pre><code>&gt;&gt;&gt; hex(3472328296227680560L)
3030303030303030
</code></pre>
<p>Now, hex <code>30</code> is the ASCII for the character <code>'0'</code>. As you can see by just re-packing the data you unpacked:</p>
<pre><code>&gt;&gt;&gt; struct.pack('&lt;Q', 3472328296227680560L)
'00000000'
</code></pre>
<p>That's enough to tell us that the file is almost certainly a series of 64-bit numbers encoded as ASCII hex. It's not enough to tell us whether they're separated in any way. You'll have to look at the file to see. (If you can't figure out how to do it in an editor or with <code>cat</code>/<code>type</code> or the like, just <code>print f.read(100)</code> and post the result here and someone else can tell you.)</p>
<p>But let's assume the ASCII hex numbers are whitespace-separated. So, what you want is this:</p>
<pre><code>with open(path) as f:
    for line in f:
        hexnumbers = line.split()
        for hexnumber in hexnumbers:
            number = int(hexnumber, 16)
            print number
</code></pre>
<p>That's it.</p>
</div>
<span class="comment-copy">Is the input actually ASCII text as you've shown or bytes with values <code>01</code>, <code>00</code>, etc.?</span>
<span class="comment-copy">Bytes I think. I've only been able to read the file by reading it as binary. With a standard file read I get gibberish characters. How would I go about confirming though? If I open it in a text reader such as notepad it also shows as gibberish characters though it displays fine in sublime text</span>
<span class="comment-copy">This is on the right track, but it will just read the first value then close the file; you need to loop over <code>unpack_from</code> or <code>unpack</code>. +1 for getting right the part the OP didn't even know how to start on.</span>
<span class="comment-copy">oh lol I just assumed that unpack_from would go to the end of buffer(because it returns a tuple) ... now its fixed</span>
<span class="comment-copy">I get an error because it's not using a buffer with the variable f. I'm not sure what it means but I'm looking through the documentation now to see if I can figure it out :)</span>
<span class="comment-copy"><code>unpack</code> already returns a tuple. The <code>_from</code> part is that it lets you unpack the first 8 bytes of a 64-byte buffer (or the second or sixth, with the <code>offset</code> param), while <code>unpack</code> requires you to unpack the entire buffer in one call.</span>
<span class="comment-copy">@Scott: Yeah, you need to read in 8 bytes at a time to <code>unpack</code>, or read a larger buffer and loop over it with <code>unpack_from</code>, or just <code>mmap</code> the file and loop over that with <code>unpack_from</code>. So the simplest change here is just to change <code>f</code> to <code>f.read(8)</code>.</span>
