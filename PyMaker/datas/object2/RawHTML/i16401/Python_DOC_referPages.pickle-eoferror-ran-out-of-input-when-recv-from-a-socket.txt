<div class="post-text" itemprop="text">
<p>I am running a very simple python (3.x) client-server program (both locally on my PC) for a school project (not intended for the real world) which just sends messages back-and-forth (like view customers, add customer, delete customer, etc... real basic).</p>
<p>Sometimes the data can be multiple records which I had stored as namedTuples (just made sense) and then went down the path of using Pickle to transfer then.</p>
<p>So for example on the client I do something like this:</p>
<pre><code>s.send(message.encode('utf-8'))
pickledResponse = s.recv(4096);
response = pickle.loads(pickledResponse)
</code></pre>
<p>Now ever so often I get the following error:</p>
<pre><code>response = pickle.loads(pickledResponse)
EOFError: Ran out of input
</code></pre>
<p>My fear is that this has something to do with my socket (TCP) transfer and maybe somehow I am not getting all the data in time for my pickle.loads - make sense? If not I am really lost as to why this would be happening so inconsistently.</p>
<p>However, even if I am right I am not sure how to fix it (quickly), I was considering dropping pickle and just using strings (but couldn't this suffer from the same fate)? Does anyone have any suggestions?</p>
<p>Really my message are pretty basic - usually just a command and some small data like "1=John" which means command (1) which is FIND command and then "John" and it returns the record (name, age, etc...) of John (as a namedTuple - but honestly this isn't mandatory).</p>
<p>Any suggestions or help would be much appreciated, looking for a quick fix...</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your code is that <code>recv(4096)</code>, when used on a TCP socket, might return different amount of data from what you might have expected, as they are sliced at packet boundaries.</p>
<p>The easy solution is to prefix each message with length; for sending like</p>
<pre><code>import struct
packet = pickle.dumps(foo)
length = struct.pack('!I', len(packet)
packet = length + packet
</code></pre>
<p>then for receiving</p>
<pre><code>import struct

buf = b''
while len(buf) &lt; 4:
    buf += socket.recv(4 - len(buf))

length = struct.unpack('!I', buf)[0]
# now recv until at least length bytes are received,
# then slice length first bytes and decode.
</code></pre>
<hr/>
<p>However, Python standard library already has a support for message oriented pickling socket, namely <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Connection" rel="nofollow">multiprocessing.Connection</a>, that supports sending and receiving pickles with ease using the <code>Connection.send</code> and <code>Connection.recv</code> respectively.</p>
<p>Thus you can code your server as </p>
<pre><code>from multiprocessing.connection import Listener

PORT = 1234
server_sock = Listener(('localhost', PORT))
conn = server_sock.accept()

unpickled_data = conn.recv()
</code></pre>
<p>and client as</p>
<pre><code>from multiprocessing.connection import Client

client = Client(('localhost', 1234))
client.send(['hello', 'world'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For receiving everything the server sends until it closes its side of the connection try this:</p>
<pre><code>import json
import socket
from functools import partial


def main():
    message = 'Test'

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect(('127.0.0.1', 9999))

        sock.sendall(message.encode('utf-8'))
        sock.shutdown(socket.SHUT_WR)

        json_response = b''.join(iter(partial(sock.recv, 4096), b''))

    response = json.loads(json_response.decode('utf-8'))
    print(response)


if __name__ == '__main__':
    main()
</code></pre>
<p>I've used <code>sendall()</code> because <code>send()</code> has the same ”problem” as <code>recv()</code>: It's not guaranteed everything is sent.  <code>send()</code> returns the number of bytes <em>actually</em> sent, and the programmer has to make sure that matches the length of the argument and if not to send the rest until everything is out.  After sending the writing side of the connection is closed (<code>shutdown()</code>) so the server knows there is no more data coming from the client.  After that, all data from the server is received until the server closes its side of the connection, resulting in the empty bytes object returned from the <code>recv()</code> call.</p>
<p>Here is a suitable <code>socketserver.TCPServer</code> for the client:</p>
<pre><code>import json
from socketserver import StreamRequestHandler, TCPServer


class Handler(StreamRequestHandler):

    def handle(self):
        print('Handle request...')
        message = self.rfile.read().decode('utf-8')
        print('Received message:', message)
        self.wfile.write(
            json.dumps(
                {'name': 'John', 'age': 42, 'message': message}
            ).encode('utf-8')
        )
        print('Finished request.')



def main():
    address = ('127.0.0.1', 9999)
    try:
        print('Start server at', address, '...')
        server = TCPServer(address, Handler)
        server.serve_forever()
    except KeyboardInterrupt:
        print('Stopping server...')


if __name__ == '__main__':
    main()
</code></pre>
<p>It reads the complete data from the client and puts it into a JSON encoded response with some other, fixed items.  Instead of the low level socket operations it makes use of the more convenient file like objects the <code>TCPServer</code> offers for reading and writing from/to the connection.  The connection is closed by the <code>TCPServer</code> after the <code>handle()</code> method finished.</p>
</div>
<span class="comment-copy">You should not use pickle if the source is not trusted, and, on a network, do not trust anyone, quoting the doc: "Warning The pickle module is not intended to be secure against erroneous or maliciously constructed data. Never unpickle data received from an untrusted or unauthenticated source."</span>
<span class="comment-copy">You may consider the possibility to not work with socket yourself (using socket yourself mean to take care about message length, what you're not doing right here). I'll advocate the use of HTTP, JSON messages, and as we're here, all of this RESTful.</span>
<span class="comment-copy">@JulienPalard given that this is a school project the idea of "trusted" is not important, and the project requirements are to use sockets (TCP) for communication - sadly I cannot change that</span>
<span class="comment-copy">@JulienPalard knowing that it is all LOCAL (on the same PC) there is no way around the issue of dealing with length? What if I used STRINGS instead of Pickled data? Any other alternatives to avoid this issue?</span>
<span class="comment-copy">You may debug easily using pickle version 1 (human readable), or json, you'll see what went wrong. Closing the connection is OK to not have to care about the length.</span>
<span class="comment-copy">I think using <code>socket</code> directly is part of the restrictions imposed by the assignment. :-)</span>
<span class="comment-copy">Anyhow, for any person wanting to do this outside assignments, this is the way to do it in python ;)</span>
<span class="comment-copy">Or if you are clever, you can copy the stuff from <code>multiprocessing/connection.py</code> :P</span>
<span class="comment-copy">@AnttiHaapala can the same be done when the server is using socketserver somehow?</span>
<span class="comment-copy">For the first one, sure, just send the length of the message succeeded by the actual message.</span>
<span class="comment-copy">To be clear, the SERVER will close the connection established by the client after it has completed .sendall(...)? I am using a SocketServer and all my code is handled within the Handler... how does the server terminate the connection made by the client? and won't the client get an error that their connection was severed?</span>
<span class="comment-copy">@JSchwartz The <code>StreamRequestHandler</code> closes the connection after the request was served.  The client doesn't get an error for reading from a closed connection.  As I said, the <code>recv()</code> returns an empty bytes object then.  Maybe the <a href="https://docs.python.org/2/howto/sockets.html" rel="nofollow noreferrer">Socket Programming HOWTO</a> from the Python documentation is helpful here.</span>
<span class="comment-copy">@JSchwartz I've expanded the example to runnable code and also added code for the server side.</span>
