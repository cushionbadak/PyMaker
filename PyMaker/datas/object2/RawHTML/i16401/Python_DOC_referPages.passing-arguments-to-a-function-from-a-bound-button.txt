<div class="post-text" itemprop="text">
<pre><code>widget.bind('&lt;Button-1&gt;',callback)   # binding 

def callback(self,event)
    #do something
</code></pre>
<p>I need to pass an argument to <code>callback()</code> . The argument is a dictionary object.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="noreferrer"><code>lambda</code></a> to define an anonymous function, such as:</p>
<pre><code>data={"one": 1, "two": 2}

widget.bind("&lt;ButtonPress-1&gt;", lambda event, arg=data: self.on_mouse_down(event, arg))
</code></pre>
<p>Note that the <code>arg</code> passed in becomes just a normal argument that you use just like all other arguments:</p>
<pre><code>def on_mouse_down(self, event, arg):
    print(arg)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about</p>
<pre><code>import functools
def callback(self, event, param):
    pass
arg = 123
widget.bind("", functools.partial(callback, param=arg))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think that in most cases you don't need any argument to a callback because the callback can be an instance method which can access the instance members:</p>
<pre><code>from Tkinter import *

class MyObj:
    def __init__(self, arg):
        self.arg = arg

    def callback(self, event):
        print self.arg

obj = MyObj('I am Obj')
root = Tk()
btn=Button(root, text="Click")
btn.bind('&lt;Button-1&gt;', obj.callback)
btn.pack()
root.mainloop()
</code></pre>
<p>But I think the functools solution proposed by Philipp is also very nice </p>
</div>
<div class="post-text" itemprop="text">
<p>Pass the callback function to the instance and call it from the instance method.</p>
<pre><code>from tkinter import *

class MyClass:

    def __init__(self, my_callback, message):
        self.my_callback = my_callback
        self.message = message

    def callback(self, event):
        self.my_callback(self)

def my_callback(o):
    print(o.message)


obj = MyClass(my_callback, "I am instance of MyClass")

root = Tk()

btn=Button(root, text="Click")
btn.bind('&lt;Button-1&gt;', obj.callback)
btn.pack()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's the simplest and easiest-to-read solution of them all I think:</p>
<pre><code>widget.bind('&lt;Button-1&gt;', callback2)

def callback(self, event, custom_arg=None): #change "None" to whatever you want the default value to be
    #do something

def callback2(self, event):
    callback(event, custom_arg=something_you_set) #set custom_arg to whatever you want it to be when Button-1 is pressed
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also supply arguments to a callback function of a widget, given only that this widget is defined as a part of a <strong><em>class definition</em></strong> ,, i.e. consider this tiny python 2.7 program (without the parts responsible of program's execution):</p>
<pre><code>import Tkinter as tk #To be able to get "tk.Button" safely
from Tkinter import *

class EXAMPLE(Frame):
    def __init__(self,master=None):
        Frame.__init__(self,master)

        #make the widgets appear to a grid of size = 2 X 2
        for row in range(2):
            self.grid_rowconfigure(row,minsize=20)
        for col in range(2):
            self.grid_columnconfigure(col,minsize=20)

        #Call our METHOD OF INTEREST
        self.AnyMethod()

    #This is our method of interest
    def AnyMethod(self):
        #arguments to be supplied
        self.arg1 = 'I am 1st argument'
        self.arg2 = 'I am 2nd argument'
        self.arg3 = 'I am 3rd argument'

        #Draw the widget, &amp; supply its callback method
        self.widgetname=tk.Button(self.master,text="My Button",command=self.method_callback)
        self.widgetname.grid(row=0,column=0)

    #create a so-called 'shell method' to swallow the REAL callback function
    def method_callback(self):
        func_callback(self.arg1,self.arg2,self.arg3)

#Define the REAL callback function in the Module's scope
def func_callback(arg1,arg2,arg3):
    print arg1
    print arg2
    print arg3
</code></pre>
<hr/>
<p><strong>NOTE THAT</strong> the supplied arguments must be proceeded with <code>self.</code> </p>
</div>
<span class="comment-copy">You want to pass it from the binding, or when the callback is done ?</span>
<span class="comment-copy">i should pass an argument when the callback is done</span>
<span class="comment-copy">then how to access that arg in the event handler? what should be the declaration of the handler</span>
<span class="comment-copy">@sag: see my edit. Short answer: you access it like any other argument.</span>
<span class="comment-copy">thank you so much Bryan . it is perfect .</span>
<span class="comment-copy">giving Exception:  leftClickCallback() got an unexpected keyword argument 'param'</span>
<span class="comment-copy">Does your callback as the param argument? This works ok form me.</span>
<span class="comment-copy">self.l.bind("&lt;Button-1&gt;", functools.partial(self.leftClickCallback,param=fi))             this is the bind step.whats wrong here?</span>
<span class="comment-copy">How is the <code>leftClickCallback</code> method declared?</span>
<span class="comment-copy">def leftClickCallback(self,event,param):</span>
<span class="comment-copy">Please explain downvotes. This is a forum to learn.</span>
<span class="comment-copy">Probably because, you did in two steps what you could have done in one. Just my opinion.</span>
