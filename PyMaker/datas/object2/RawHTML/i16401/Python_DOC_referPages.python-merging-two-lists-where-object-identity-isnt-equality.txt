<div class="post-text" itemprop="text">
<p>I'm trying to merge two lists, <code>base</code> and <code>override</code>, where <code>base</code> is supposed to be a larger list and <code>override</code> is a subset of the things in <code>base</code>. Where the elements overlap, I want the object in <code>base</code> to be overwritten by the one in <code>override</code>. The objects in each list are namedtuples with attributes <code>al2000</code> and <code>de2000</code> among them. Moreover I want to treat the objects as being "identical" when they have the same <code>al2000</code> and <code>de2000</code> values. What I have (which seems to work) is below, but this has nested loops, and I'm wondering if there is a better way to do this.</p>
<pre><code># Part of a function
final = []
for i in base:
    if all((i.al2000, i.de2000) != (k.al2000, k.de2000) for k in override):
        final.append(i)
    else:
        for k in override:
            if (i.al2000, i.de2000) == (k.al2000, k.de2000):
                final.append(k)
return final
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>for/else</code> construct.</p>
<pre><code>final = []
for i in base:
    for k in override:
        if (i.al2000, i.de2000) == (k.al2000, k.de2000):
            # found an override
            final.append(k)
            break
    else:
        final.append(i)
</code></pre>
<p>This solution still uses a nested for-loop, but it removes code duplication from your original solution (iterating over <code>overrides</code>, the comparison of <code>i</code> and <code>k</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a dictionary and a couple of dictionary comprehensions.</p>
<pre><code>uniques = {(x.al2000, x.de2000): x for x in base}
uniques.update({(x.al2000, x.de2000): x for x in override})
final = uniques.values()
</code></pre>
<p>Edit to retain original behavior about omitting extra values in <code>override</code>.</p>
<pre><code>uniques = {(x.al2000, x.de2000): x for x in base}
for value in override:
    key = value.al2000, value.de2000
    if key in uniques:
        uniques[key] = value
# here's the comprehension version, although it's a bit rough on the eyes
# uniques.update({(x.al2000, x.de2000): x for x in override if (x.al2000, x.de2000) in uniques})
final = uniques.values()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This answers adopts @acushner's suggestion to use a dict, which might be the most natural approach in your case. To add to it, when dealing with overrides, <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer"><code>ChainMap</code></a> is useful and in many cases the most natural way to represent your data structure.</p>
<pre><code>from collections import ChainMap
base_dct = {(x.al2000, x.de2000): x for x in base}
override_dct = {(x.al2000, x.de2000): x for x in override}
z = ChainMap(base_dct, override_dct)
# then access:
z.values()
# or:
z[(x.al2000, x.de2000)]
</code></pre>
<p>See <a href="https://stackoverflow.com/q/23392976/2096752">this question</a> for more info about ChainMaps.</p>
</div>
<div class="post-text" itemprop="text">
<p>since all you really want to do is look something up in overrides, make a dict out of it:</p>
<pre><code>od = {(x.al2000, x.de2000): x for x in override}
</code></pre>
<p>now, just create the result:</p>
<pre><code>res = [od.get((b.al2000, b.de2000), b) for b in base]
</code></pre>
<p>*not tested, but should be ok
*edited for dirn's suggestion</p>
</div>
<span class="comment-copy">In which case would you actually overwrite an item in base with an item from override? Seems you only want to append missing items.</span>
<span class="comment-copy">This is not equivalent to original code because (1) it does not preserve order (2) elements in <code>override</code> which do not appear in <code>base</code> are included in <code>final</code>. otherwise, a nice elegant solution!</span>
<span class="comment-copy">I made an edit to address the second one. The first one cannot. Plus, depending on the size of <code>base</code>, maintaining a separate structure (i.e., <code>uniques</code>) could be memory intensive.</span>
<span class="comment-copy">You could also pass <code>b</code> to <code>od.get</code>.</span>
<span class="comment-copy">nope, because b has more attributes than just <code>al2000</code> and <code>de2000</code></span>
<span class="comment-copy">I meant <code>od.get((b.al2000, b.de2000), b)</code>.</span>
<span class="comment-copy">yes, good call, will edit.</span>
