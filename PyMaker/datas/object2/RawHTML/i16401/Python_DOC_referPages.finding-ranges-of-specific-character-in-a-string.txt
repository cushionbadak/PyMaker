<div class="post-text" itemprop="text">
<p>I am working with python-3.x on windows 7. I have a string that consists of millions of characters. Consider for example:</p>
<pre><code>ATCGNNNATCGATNNNNNATCGANTCG
</code></pre>
<p>I want to get the ranges that are <code>N</code>. In here, <code>[[4,7], [13,18], [23,24]]</code>.
I can not just take positions of <code>N</code>s and then convert them to ranges because it's a huge data and this method will be too slow.
It seems such an easy problem but actually no good way comes to my mind.
Is there a fast way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure how this scales to a string of millions of characters, but you could try <a href="https://docs.python.org/3/howto/regex.html">regular expressions</a>:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; data = "ATCGNNNATCGATNNNNNATCGANTCG"
&gt;&gt;&gt; spans = (g.span() for g in re.finditer('N+', data))
&gt;&gt;&gt; list(spans)
[(4, 7), (13, 18), (23, 24)]
</code></pre>
<p><em>Update:</em> Tried this with randomly generated strings of A, C, G, T, and N. For 1,000,000 characters, <code>list(spans)</code> takes less than one second, and for 10,000,000 it takes about 10 seconds on my not-at-all-new computer, finding about 1,600,000 groups of Ns.</p>
</div>
<div class="post-text" itemprop="text">
<p>A solution without re:</p>
<pre><code>from itertools import chain

def find_ranges(it, elem):
    start = None
    for i, e in enumerate(chain(it, [None])):
        if not start and e == elem:
            start = i
        elif start and e != elem:
            yield (start, i)
            start = None
</code></pre>
<p>Measuring with ipython's magic %timeit:</p>
<pre><code>In [1]: import random
In [2]: s = [random.choice("ACGTN") for i in range(1000000)]
In [3]: %timeit list(find_ranges(s, "N"))
10 loops, best of 3: 164 ms per loop
</code></pre>
<p><strong>EDIT</strong>: Added a guard to the end with chain, in order to make it work when the last item in the sequence is the searched element.</p>
</div>
<span class="comment-copy">Using <code>g.span()</code> might be marginally faster.</span>
<span class="comment-copy">For millions of characters I would not consume the iterator at once with a comprehension, but other than that great approach +1</span>
<span class="comment-copy">Also, no need for the parethesises around the <code>g.span()</code></span>
<span class="comment-copy">Whole 3.2 billion codes of human genome in less than five minutes! Fantastic. THANKS</span>
<span class="comment-copy">+1 for nice graphic algorithm. Just for comparison: I tested both solutions on my system, and the regex-approach is still about twice as fast. Seems my computer is really not the fastest anymore...</span>
<span class="comment-copy">Thank you. Maybe the regex based solution is faster because the re module is implemented in C while mine is pure python. I beleive the same algorithm implemented in C would beat the one with regex :)</span>
