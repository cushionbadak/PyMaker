<div class="post-text" itemprop="text">
<p>I'm trying to do a Bitcoin payment from within Python. In bash I would normally do this:</p>
<pre><code>bitcoin sendtoaddress &lt;bitcoin address&gt; &lt;amount&gt;
</code></pre>
<p>so for example:</p>
<pre><code>bitcoin sendtoaddress 1HoCUcbK9RbVnuaGQwiyaJGGAG6xrTPC9y 1.4214
</code></pre>
<p>if it is successfull I get a transaction id as output but if I try to transfer an amount larger than my bitcoin balance, I get the following output:</p>
<pre><code>error: {"code":-4,"message":"Insufficient funds"}
</code></pre>
<p>In my Python program I now try to do the payment as follows:</p>
<pre><code>import subprocess

try:
    output = subprocess.check_output(['bitcoin', 'sendtoaddress', address, str(amount)])
except:
    print "Unexpected error:", sys.exc_info()
</code></pre>
<p>If there's enough balance it works fine, but if there's not enough balance <code>sys.exc_info()</code> prints out this:</p>
<pre><code>(&lt;class 'subprocess.CalledProcessError'&gt;, CalledProcessError(), &lt;traceback object at 0x7f339599ac68&gt;)
</code></pre>
<p>It doesn't include the error which I get on the command line though. So my question is; how can I get the outputted  error (<code>{"code":-4,"message":"Insufficient funds"}</code>) from within Python?</p>
<p>All tips are welcome!</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/2/library/subprocess.html#subprocess.check_output"><code>subprocess.check_output()</code> docs</a>, the exception raised on error has an <code>output</code> attribute that you can use to access the error details:</p>
<pre><code>try:
    subprocess.check_output(...)
except subprocess.CalledProcessError as e:
    print e.output
</code></pre>
<p>You should then be able to analyse this string and parse the error details with the <code>json</code> module:</p>
<pre><code>if e.output.startswith('error: {'):
    error = json.loads(e.output[7:]) # Skip "error: "
    print error['code']
    print error['message']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think the accepted solution handles the case where the error text is reported on stderr. From my testing the exception's output attribute did not contain the results from stderr and the docs warn against using stderr=PIPE in check_output().  Instead, I would suggest one small improvement to J.F Sebastian's solution by adding stderr support.  We are, after all, trying to handle errors and stderr is where they are often reported.  </p>
<pre><code>from subprocess import Popen, PIPE

p = Popen(['bitcoin', 'sendtoaddress', ..], stdout=PIPE, stderr=PIPE)
output, error = p.communicate()
if p.returncode != 0: 
   print("bitcoin failed %d %s %s" % (p.returncode, output, error))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Trying to "transfer an amount larger than my bitcoin balance" is not an unexpected error. You could use <code>Popen.communicate()</code> directly instead of <code>check_output()</code> to avoid raising an exception unnecessarily:</p>
<pre><code>from subprocess import Popen, PIPE

p = Popen(['bitcoin', 'sendtoaddress', ..], stdout=PIPE)
output = p.communicate()[0]
if p.returncode != 0: 
   print("bitcoin failed %d %s" % (p.returncode, output))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are good answers here, but in these answers, there has not been an answer that comes up with the text from the stack-trace output, which is the default behavior of an exception.</p>
<p>If you wish to use that formatted traceback information, you might wish to:</p>
<pre><code>import traceback

try:
    check_call( args )
except CalledProcessError:
    tb = traceback.format_exc()
    tb = tb.replace(passwd, "******")
    print(tb)
    exit(1)
</code></pre>
<p>As you might be able to tell, the above is useful in case you have a password in the check_call( args ) that you wish to prevent from displaying.</p>
</div>
<span class="comment-copy">I'm calling a program that outputs something to stdout and then returns 1, but check_output is not capturing it</span>
<span class="comment-copy">@JorgeeFG Then I guess there is something wrong with your program.  Please note that the comments section is not the right place to ask new questions. If you need help with your particular problem, click the big "Ask Question" button on the top-right of the page.</span>
<span class="comment-copy">Note, this will not work with Python 2.6 or below!</span>
<span class="comment-copy">I agree that the <code>stderr</code> output is very relevant here. An alternative solution would be to use the <code>run()</code> function instead (see the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer">check_output docs</a> how to replace). Because then you can use <code>e.stderr</code> from the exception in your error reporting.</span>
<span class="comment-copy">This should be at the top.</span>
<span class="comment-copy">to preserve the apparent order of the output, you could use <code>stderr=STDOUT</code> (to merge both streams).</span>
<span class="comment-copy">Python encourages an EAFP programming style (Easier to ask for forgiveness than permission), preferring exception handling over 'if' checks in situations like these.</span>
<span class="comment-copy">@FerdinandBeyer: EAFP does not apply in this case: you are not making any calls that you wouldn't make otherwise. The code does not have the LBYL structure: <code>if check(): do()</code> that you could have replaced with EAFP <code>try: do() except Error: handle_error()</code>. The code in the answer inlines <code>check_output()</code> function and avoids raising an exception in the <code>if p.returncode</code> branch only to catch it at the same level. Avoid cargo-cult programming, think</span>
<span class="comment-copy">We can also do: <code>p = Popen(['bitcoin', 'sendtoaddress', ..], stdout=PIPE, stderr=PIPE)</code> and capture the error message as: <code>output, error = p.communicate()</code>.</span>
