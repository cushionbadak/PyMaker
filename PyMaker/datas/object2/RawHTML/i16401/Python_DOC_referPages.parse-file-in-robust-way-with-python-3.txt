<div class="post-text" itemprop="text">
<p>I have a log file that I need to go through line by line, and apparently it contains some "bad bytes".  I get an error message along the following lines:</p>
<blockquote>
<p>UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb0 in position 9: invalid start byte</p>
</blockquote>
<p>I have been able to strip down the problem to a file "log.test" containing the following line:</p>
<pre><code>Message: \260
</code></pre>
<p>(At least this is how it shows up in my Emacs.)</p>
<p>I have a file "demo_error.py" which looks like this:</p>
<pre><code>import sys
with open(sys.argv[1], 'r') as lf:
    for i, l in enumerate(lf):
        print(i, l.strip())
</code></pre>
<p>I then run, from the command line:</p>
<blockquote>
<p>$ python3 demo_error.py log.test</p>
</blockquote>
<p>The full traceback is:</p>
<pre><code>Traceback (most recent call last):
  File "demo_error.py", line 5, in &lt;module&gt;
    for i, l in enumerate(lf):
  File     "/usr/local/Cellar/python3/3.4.0/Frameworks/Python.framework/Versions/3.4/lib/python3.4/codecs.py", line 313, in decode
    (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb0 in position 13: invalid start byte
</code></pre>
<p>My hunch is that I have to somehow specify a more general codec ("raw ascii" for instance) - but I'm not quite sure how to do this.</p>
<p>Note that this is not really a problem in Python 2.7.</p>
<p>And just to make my point clear: I don't mind getting an exception for the line in question - then I can simply discard the line.  The problem is that the exception seems to happen on the "for" loop itself, which makes special handling of that particular line impossible.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use the <a href="https://docs.python.org/3.4/library/codecs.html" rel="nofollow">codecs</a> module. When you use the codecs.open() function, you can specify how it handles errors using the <strong>errors</strong> argument:</p>
<pre><code>codecs.open(filename, mode[, encoding[, errors[, buffering]]])
</code></pre>
<p>The <strong>errors</strong> argument can be one of several different keywords that specify how you want Python to behave when it attempts to decode a character that is invalid for the current encoding. You'll probably be most interested in <strong>codecs.ignore_errors</strong> or <strong>codecs.replace_errors</strong>, which cause invalid characters to be either ignored or replaced with a default character, respectively.</p>
<p>This method can be a good alternative when you know you have corrupt data that will cause the UnicodeDecodeError to be raised even when you specify the correct encoding.</p>
<p>Example:</p>
<pre><code>with codecs.open('file.txt', mode='r', errors='ignore'):
    # ...stuff...
    # Even if there is corrupt data and invalid characters for the default
    # encoding, this open() will still succeed
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So apparently your file does not contain valid UTF-8 (which is the default encoding).
If you know, what encoding is used (e.g. iso-8859-1 which was afaik the python2 default), you can specify it when opening by using</p>
<pre><code>open(sys.argv[1], mode='r', encoding='iso-8859-1')
</code></pre>
<p>If the encoding is unknown or not valid as all, you can open the file as binary.</p>
<pre><code>open(sys.argv[1], mode='rb')
</code></pre>
<p>This will make the content accessible as bytes rather than trying to interpret them as characters.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python &lt;=2.7, strings (str) are arrays of 8 bits characters. So when reading a file composed of 8 bits characters or bytes, you get the bytes without problem, no matter what the actual encoding is. Simply, you may read them with a wrong representation, but it will never throw any exception.</p>
<p>In python &gt;=3,strings are unicode strings (16 bits per character). So when reading a file python has to decode the file, and by default it uses system encoding - <strong>not necessarily UTF-8</strong>. In your case, it seems to assume UTF-8 encoding, when your log file is not UTF-8 encoding so the exception.</p>
<p>If not sure of the encoding you may reasonably try to use ISO-8859-1 with</p>
<pre><code>open(sys.argv[1], 'r', encoding='iso-8859-1')
</code></pre>
</div>
<span class="comment-copy">The benefit of using 'codecs' is that the code then can be compatible with Python 2.x.</span>
<span class="comment-copy">Specifying the encoding does the trick, thanks.  Opening as binary could work too, however it makes the post-processing trickier since most of the line contains valid text.  (In fact, I believe it is supposed to contain ascii... however it is corrupted.)</span>
<span class="comment-copy">0x0b is not valid ascii either. It is however valid iso-8859-1, denoting the degree sign (Â°). If the file got in fact corrupted, using binary would be more robust, as some bytes may not be valid iso-8859-1.</span>
<span class="comment-copy">Python default encoding is not necessarily UTF-8. According to <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">Python 3.4 Standard Library documentation</a> : <i>The default encoding is platform dependent (whatever locale.getpreferredencoding() returns)</i></span>
