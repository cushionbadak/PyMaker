<div class="post-text" itemprop="text">
<p>I'm trying to print phrases in a given text. I want to be able to print every phrase in the text, from 2 words up to the maximum number of words the length of the text will allow for. I have written a program below that prints all phrases up to 5 words in length, but I can't work out a more elegant way to get it print all possible phrases.</p>
<p>My definition of phrase = Consecutive words in a string, regardless of meaning.</p>
<pre><code>def phrase_builder(i):
    phrase_length = 4
    phrase_list = []
    for x in range(0, len(i)-phrase_length):
        phrase_list.append(str(i[x]) + " " + str(i[x+1]))
        phrase_list.append(str(i[x]) + " " + str(i[x+1]) + " " + str(i[x+2]))
        phrase_list.append(str(i[x]) + " " + str(i[x+1]) + " " + str(i[x+2]) + " " + str(i[x+3]))
        phrase_list.append(str(i[x]) + " " + str(i[x+1]) + " " + str(i[x+2]) + " " + str(i[x+3]) + " " + str(i[x+4]))
    return phrase_list

text = "the big fat cat sits on the mat eating a rat"

print phrase_builder(text.split())
</code></pre>
<p>The output for this is:</p>
<pre><code>['the big', 'the big fat', 'the big fat cat', 'the big fat cat sits',
'big fat', 'big fat cat', 'big fat cat sits', 'big fat cat sits on',
'fat cat', 'fat cat sits', 'fat cat sits on', 'fat cat sits on the',
'cat sits', 'cat sits on', 'cat sits on the', 'cat sits on the mat',
'sits on', 'sits on the', 'sits on the mat', 'sits on the mat eating',
'on the', 'on the mat', 'on the mat eating', 'on the mat eating a',
'the mat', 'the mat eating', 'the mat eating a', 'the mat eating a rat']
</code></pre>
<p>I want to be able to print phrases such as <code>"the big fat cat sits on the mat eating"</code> and <code>"fat cat sits on the mat eating a rat"</code> etc.</p>
<p>Can anyone offer some advice please?</p>
</div>
<div class="post-text" itemprop="text">
<p>Simply Use <code>itertools.combinations</code></p>
<pre><code>from itertools import combinations
text = "the big fat cat sits on the mat eating a rat"
lst = text.split()
for start, end in combinations(range(len(lst)), 2):
    print lst[start:end+1]
</code></pre>
<p>output:</p>
<pre><code>['the', 'big']
['the', 'big', 'fat']
['the', 'big', 'fat', 'cat']
['the', 'big', 'fat', 'cat', 'sits']
['the', 'big', 'fat', 'cat', 'sits', 'on']
['the', 'big', 'fat', 'cat', 'sits', 'on', 'the']
['the', 'big', 'fat', 'cat', 'sits', 'on', 'the', 'mat']
['the', 'big', 'fat', 'cat', 'sits', 'on', 'the', 'mat', 'eating']
['the', 'big', 'fat', 'cat', 'sits', 'on', 'the', 'mat', 'eating', 'a']
['the', 'big', 'fat', 'cat', 'sits', 'on', 'the', 'mat', 'eating', 'a', 'rat']
['big', 'fat']
['big', 'fat', 'cat']
['big', 'fat', 'cat', 'sits']
['big', 'fat', 'cat', 'sits', 'on']
['big', 'fat', 'cat', 'sits', 'on', 'the']
['big', 'fat', 'cat', 'sits', 'on', 'the', 'mat']
['big', 'fat', 'cat', 'sits', 'on', 'the', 'mat', 'eating']
['big', 'fat', 'cat', 'sits', 'on', 'the', 'mat', 'eating', 'a']
['big', 'fat', 'cat', 'sits', 'on', 'the', 'mat', 'eating', 'a', 'rat']
['fat', 'cat']
['fat', 'cat', 'sits']
['fat', 'cat', 'sits', 'on']
['fat', 'cat', 'sits', 'on', 'the']
['fat', 'cat', 'sits', 'on', 'the', 'mat']
['fat', 'cat', 'sits', 'on', 'the', 'mat', 'eating']
['fat', 'cat', 'sits', 'on', 'the', 'mat', 'eating', 'a']
['fat', 'cat', 'sits', 'on', 'the', 'mat', 'eating', 'a', 'rat']
['cat', 'sits']
['cat', 'sits', 'on']
['cat', 'sits', 'on', 'the']
['cat', 'sits', 'on', 'the', 'mat']
['cat', 'sits', 'on', 'the', 'mat', 'eating']
['cat', 'sits', 'on', 'the', 'mat', 'eating', 'a']
['cat', 'sits', 'on', 'the', 'mat', 'eating', 'a', 'rat']
['sits', 'on']
['sits', 'on', 'the']
['sits', 'on', 'the', 'mat']
['sits', 'on', 'the', 'mat', 'eating']
['sits', 'on', 'the', 'mat', 'eating', 'a']
['sits', 'on', 'the', 'mat', 'eating', 'a', 'rat']
['on', 'the']
['on', 'the', 'mat']
['on', 'the', 'mat', 'eating']
['on', 'the', 'mat', 'eating', 'a']
['on', 'the', 'mat', 'eating', 'a', 'rat']
['the', 'mat']
['the', 'mat', 'eating']
['the', 'mat', 'eating', 'a']
['the', 'mat', 'eating', 'a', 'rat']
['mat', 'eating']
['mat', 'eating', 'a']
['mat', 'eating', 'a', 'rat']
['eating', 'a']
['eating', 'a', 'rat']
['a', 'rat']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, you need to figure out how to write all four of those lines the same way. Instead of concatenating the words and spaces manually, use the <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow"><code>join</code></a> method:</p>
<pre><code>phrase_list.append(" ".join(str(i[x+y]) for y in range(2))
phrase_list.append(" ".join(str(i[x+y]) for y in range(3))
phrase_list.append(" ".join(str(i[x+y]) for y in range(4))
phrase_list.append(" ".join(str(i[x+y]) for y in range(5))
</code></pre>
<p>If the comprehension inside the <code>join</code> method isn't clear, here's how to write it manually:</p>
<pre><code>phrase = []
for y in range(2):
    phrase.append(str(i[x+y]))
phrase_list.append(" ".join(phrase))
</code></pre>
<p>Once you've done that, it's trivial to replace those four lines with a loop:</p>
<pre><code>for length in range(2, phrase_length):
    phrase_list.append(" ".join(str(i[x+y]) for y in range(length))
</code></pre>
<p>You can simplify this in a couple of other ways independently.</p>
<p>First, <code>i[x+y] for y in range(length)</code> can be done much more easily with a slice: <code>i[x:x+length]</code>.</p>
<p>And I'm guessing <code>i</code> is already a list of strings, so you can get rid of the <code>str</code> calls.</p>
<p>Also, <code>range</code> defaults to starting at <code>0</code>, so you can leave that off.</p>
<p>While we're at it, it would be a lot easier to think about your code if you used meaningful variable names, like <code>words</code> instead of <code>i</code>.</p>
<p>So:</p>
<pre><code>def phrase_builder(words):
    phrase_length = 4
    phrase_list = []
    for i in range(len(words) - phrase_length):
        phrase_list.append(" ".join(words[i:i+phrase_length]))
    return phrase_list
</code></pre>
<p>And now your loop is simple enough that you can turn it into a comprehension and the whole thing is a one-liner:</p>
<pre><code>def phrase_builder(words):
    phrase_length = 4
    return [" ".join(words[i:i+phrase_length]) 
            for i in range(len(words) - phrase_length)]
</code></pre>
<p>One last thing: As @SoundDefense asked, are you sure you don't want "eating a rat"? It starts less than 5 words from the end, but it's a 3-word phrase in the text.</p>
<p>If you do want that, just remove the <code>- phrase_length</code> part.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the simplest approach is to iterate over all the possible <code>start</code> and <code>end</code> positions in the list of <code>words</code> and generate the phrases for the respective sub-lists of words:</p>
<pre><code>def phrase_builder(words):
    for start in range(0, len(words)-1):
        for end in range(start+2, len(words)+1):
            yield ' '.join(words[start:end])

text = "the big fat cat sits on the mat eating a rat"
for phrase in phrase_builder(text.split()):
    print phrase
</code></pre>
<p>Output:</p>
<pre><code>the big
the big fat
...
the big fat cat sits on the mat eating a rat
...
sits on the mat eating a
...
eating a rat
a rat
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to have a systematic way of enumerating every possible phrase.</p>
<p>One approach is to start with every word, and then generate all possible phrases that start with that word.</p>
<pre><code>def phrase_builder(my_words):
   phrases = []
   for i, word in enumerate(my_words):
     phrases.append(word)
     for nextword in my_words[i+1:]:
        phrases.append(phrases[-1] + " " + nextword)
     # Remove the one-word phrase.
     phrases.remove(word)
   return phrases



text = "the big fat cat sits on the mat eating a rat"

print phrase_builder(text.split())
</code></pre>
</div>
<span class="comment-copy">Do you not also want phrases such as <code>eating a rat</code>?</span>
<span class="comment-copy">@TheSoundDefense Good point. Yes I do.</span>
<span class="comment-copy">@dvm I don't think there was a maximum length, just that OP only got as far as 5 consecutive words.</span>
<span class="comment-copy">@KirkStrauser My mistake! Really nice approach, btw!</span>
<span class="comment-copy">@KirkStrauser: The fact that he created a variable for the max phrase length (even if he never ended up using it) makes me think maybe there is a maximum.</span>
<span class="comment-copy">@abarnert I don't think so. He says "I want to be able to print every phrase in the text, from 2 words up to the maximum number of words the length of the text will allow for." I think the phrase_length variable is an artifact of the method he'd been trying to implement, not a design principal.</span>
<span class="comment-copy">You beat me to it. Except for the name of the function, that was almost exactly the answer I'd written. I love the itertools version because, well, itertools is excellent. I like this a lot for the explicit readability, though.</span>
<span class="comment-copy">This works, except that it includes phrases of all lengths, not just lengths <code>2</code> through <code>phrase_length</code>. Hopefully he can see how to adapt it himself, so +1.</span>
<span class="comment-copy">@abarnert, Good point. I will update it.</span>
