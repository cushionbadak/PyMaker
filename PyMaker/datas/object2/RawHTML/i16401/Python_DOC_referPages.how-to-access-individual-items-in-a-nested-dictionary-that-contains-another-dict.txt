<div class="post-text" itemprop="text">
<p>I have a dictionary created that looks like the following: </p>
<pre><code>DictItems = {
             'Rule1' : {1 : [S1, S2, S3], 2 : [S4, S5], 3: [S8]},
             'Rule2' : {1 : [S2, S3], 2 : [S2, S4, S5]}
            }
</code></pre>
<p>I tried the following: </p>
<pre><code>for key, value, listval in DictItems.items():
   print key, value, listval
</code></pre>
<p>But it showed the error: "<code>ValueError: need more than 2 values to unpack</code>". </p>
<p>How can I access the individual items to print of Manipulate them</p>
<p>Individual items means: I want to check associative rules. So I want to access individual items such as 'Rule1' in an if condition and then check for the values in the next dictionary such as 1 or 2, and the list items.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you are overcomplicating this.</p>
<p>Given this dict:</p>
<pre><code>&gt;&gt;&gt; DictItems = {
...              'Rule1' : {1 : ['S1', 'S2', 'S3'], 2 : ['S4', 'S5'], 3: ['S8']},
...              'Rule2' : {1 : ['S2', 'S3'], 2 : ['S2', 'S4', 'S5']}
...             }
</code></pre>
<p>You access individual elements using either a key (for a dict) or index (for a sequence) in one or more sets of brackets (paired brackets: <code>[]</code> are AKA <a href="https://docs.python.org/3/reference/expressions.html?highlight=subscriptions#grammar-token-subscription" rel="nofollow">subscriptions</a> or <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow"><code>__getitem__</code> operator</a>):</p>
<pre><code>&gt;&gt;&gt; DictItems['Rule1']
{1: ['S1', 'S2', 'S3'], 2: ['S4', 'S5'], 3: ['S8']}
&gt;&gt;&gt; DictItems['Rule1'][1]
['S1', 'S2', 'S3']
&gt;&gt;&gt; DictItems['Rule1'][1][-1]
'S3'
&gt;&gt;&gt; DictItems['Rule1'][1][-1][0]
'S'
</code></pre>
<p>Dissecting the last one there:</p>
<pre><code> DictItems['Rule1'][1][-1][0]
             ^^^                   key to the top dict
                    ^              key to dict with int key
                       ^^          relative index to a sequence -- last one
                           ^       absolute index to a sequence -- first item
</code></pre>
<p>To print then:</p>
<pre><code>&gt;&gt;&gt; for k, li in DictItems['Rule1'].items():
...    print k, li
... 
1 ['S1', 'S2', 'S3']
2 ['S4', 'S5']
3 ['S8']
</code></pre>
<p>To access and compare for example:</p>
<pre><code>&gt;&gt;&gt; DictItems['Rule1'][1][2]==DictItems['Rule2'][1][-1]
True
</code></pre>
<p>If you want to unpack the example, use nested loops:</p>
<pre><code>&gt;&gt;&gt; for k in DictItems:
...    for sk, li in DictItems[k].items():
...       print k, sk, li
... 
Rule2 1 ['S2', 'S3']
Rule2 2 ['S2', 'S4', 'S5']
Rule1 1 ['S1', 'S2', 'S3']
Rule1 2 ['S4', 'S5']
Rule1 3 ['S8']
</code></pre>
<p>Since dicts are unordered, the items will not necessarily come out in a sorted in as-inserted order. You can sort the keys:</p>
<pre><code>&gt;&gt;&gt; for k in sorted(DictItems):
...    for sk in sorted(DictItems[k]):
...       print k, sk, DictItems[k][sk]
... 
Rule1 1 ['S1', 'S2', 'S3']
Rule1 2 ['S4', 'S5']
Rule1 3 ['S8']
Rule2 1 ['S2', 'S3']
Rule2 2 ['S2', 'S4', 'S5'] 
</code></pre>
<p>You can also use <a href="https://docs.python.org/2/library/json.html" rel="nofollow">json</a> for pretty printing a nested dict:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; print json.dumps(DictItems, sort_keys=True, indent=4)
{
    "Rule1": {
        "1": [
            "S1", 
            "S2", 
            "S3"
        ], 
        "2": [
            "S4", 
            "S5"
        ], 
        "3": [
            "S8"
        ]
    }, 
    "Rule2": {
        "1": [
            "S2", 
            "S3"
        ], 
        "2": [
            "S2", 
            "S4", 
            "S5"
        ]
    }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>dict.items()</code> gives you the <code>(key, value)</code> pairs, and will not further unpack the contained dictionaries.</p>
<p>You can <em>only</em> unpack the key and value, where the value is another dictionary object here. To get to the nested dictionary, iterate over that too, perhaps:</p>
<pre><code>for rule, rule_mapping in DictItems.items():
    print rule
    for rulemap_number, listvalue in rule_mapping.items():
        print '{}: {}'.format(rulemap_number, listvalue)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To answer your question, you could nest another loop within the original loop, like so:</p>
<pre><code>for key, value in DictItems.items():
   print key
   for key2, value2 in value.items():
       print key2, value2
</code></pre>
<p>And so forth, down as many levels as you want. If you want to get fancy, you can get all recursive up in there but for two levels that will suffice.</p>
<p>NB. Disregard the non-existent naming convention I'm using :P</p>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-py prettyprint-override"><code>for rule_num, group in DictItems.items():
    print rule_num
    for index, lst in group.items():
        print "    %s: %s" % (index, lst)

...

Rule2
    1: ['S2', 'S3']
    2: ['S2', 'S4', 'S5']
Rule1
    1: ['S1', 'S2', 'S3']
    2: ['S4', 'S5']
    3: ['S8']
</code></pre>
</div>
<span class="comment-copy">Define 'individual items' here. And what did you expect <code>listval</code> to be bound to? If you have a <code>KeyError</code> on <code>'Rule1'</code>, <i>your <code>DictItems</code> is not the same object you defined in your post</i>.</span>
<span class="comment-copy">DictItems has some syntax errors in it. There is a semi-colon where a single quote should be, and you need a comma at the end of the 'Rule1' line. Does the problem persist when you fix those problems?</span>
<span class="comment-copy">@bearoplane corrected the errors.</span>
<span class="comment-copy">@MartijnPieters I want to check associative rules. So I want to access individual items such as 'Rule1' in an if condition and then check for the values in the next dictionary such as 1 or 2, and the list items.</span>
<span class="comment-copy"><code>DictItems['Rule1']</code> would give you <code>{1 : [S1, S2, S3], 2 : [S4, S5], 3: [S8]}</code> not a <code>keyError</code>, post the actual code you are using</span>
