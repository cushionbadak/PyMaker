<div class="post-text" itemprop="text">
<p>I have csv files among other files, uncompressed or compressed with either gz, bz2, or other format. All compressed files have their original extension preserved in their name. So the compression specific extension is appended to the original filename.
The list of possible compression formats is given through a list, for example:</p>
<pre><code>z_types = [ '.gz', '.bz2' ]  #  could be many more than two types
</code></pre>
<p>I would like to make a list of the cvs files disregarding whether they are compressed or not. I usually do for uncompressed csv files the following:</p>
<pre><code>import os
[ file_ if file_.endswith('.csv') for file_ in os.listdir(path_to_files) ]
</code></pre>
<p>for the case I want even compressed file I would do:</p>
<pre><code>import os
acsv_files_ = []
for file_ in os.listdir(path_to_files):
    for ztype_ in z_types + [ '' ]:
        if file_.endswith('.csv' + ztype_):
            acsv_files_.append(file_)
</code></pre>
<p>though this would work, is there any more concise and efficient way of doing this? for example using an 'or' operator within .endswith()?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, that is possible. See <a href="https://docs.python.org/3/library/stdtypes.html#str.endswith" rel="nofollow"><code>str.endswith</code></a>:</p>
<blockquote>
<p>Return True if the string ends with the specified suffix, otherwise return False. <strong>suffix can also be a tuple of suffixes to look for</strong>. With optional start, test beginning at that position. With optional end, stop comparing at that position.</p>
</blockquote>
<pre><code>In [10]: "foo".endswith(("o", "r"))
Out[10]: True

In [11]: "bar".endswith(("o", "r"))
Out[11]: True

In [12]: "baz".endswith(("o", "r"))
Out[12]: False
</code></pre>
<p>So you could use</p>
<pre><code>[file_ if file_.endswith(tuple(z_types + [""])) for file_ in os.listdir(path_to_files)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your file names all end in '.csv' or '.csv.some_compressed_ext' you could use the following:</p>
<pre><code>import os

csvfiles = [f for f in os.listdir(path) if '.csv' in f]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this in one line as:</p>
<pre><code>import os
exts = ['','.gz','.bz2','.tar'] # includes '' as the null-extenstion

# this creates the list
files_to_process = [_file for _file in os.listdir(path_to_files) if not _file.endswith('.not_to_process') and _file.endswith(tuple('.csv'+ext for ext in exts+['']))]
</code></pre>
<p>Broken down:</p>
<pre><code>files_to_process = [
    _file
    for _file in os.listdir(path_to_files)
    if not _file.endswith('.no') # Checks against files you have marked as bad
    and
    _file.endswith(    # checks if any of the provided entries in the tuple are endings to the _file name
        tuple(   # generates a tuple from the given generator argument
            '.csv'+ext for ext in exts+['']    # Creates a tuple containing all the variations: .csv, .csv.gz, .csv.bz2, etc.
        )
    )
]
</code></pre>
<p><strong>EDIT</strong></p>
<p>For an even more general solution:</p>
<pre><code>import os

def validate_file(f):
    # do any tests on the file that you need to determine whether it is valid
    # for processing
    exts = ['','.gz','bz2']
    if f.endswith('.some_extension_name_you_made_to_mark_bad_files'):
         return False
    else:
         return file.endswith(tuple('.csv'+ext for ext in exts))

exts = [f for f in os.listdir(path_to_files) if validate_file(f)]
</code></pre>
<p>You could of course replace the code in <code>validate_file</code> with whatever testing you wish to do on the file.  You could even use this approach to validate file contents too, i.e.</p>
<pre><code>def validate_file(f):
    content = ''.join(i for i in f)
    if 'apple' in content:
        return True
    else:
        return False
</code></pre>
</div>
<span class="comment-copy">I want to keep control of which files to be processed. Also I usually append '.no' to files which I do not want to be processed.</span>
<span class="comment-copy">I said I usually append '.no', not systematically. Mainly : 'I want to keep control of which file is to be processed.'|</span>
<span class="comment-copy">@user1850133 My answer does not systematically append '.no', it just checks if it has been appended to the file name.   Aside from your rather rude quoting of yourself, you should really take a second to comprehend the code I have provided as it does exactly what you are after I think my response should give you generally the structure of how to do this in a simple one liner, but see my edit for an even more general approach.</span>
<span class="comment-copy">That's right my answer was a bit rude. This is because when I post a question I often get answers disregarding the pecision of some words. Here I just wanted to select files with .csv extension appended with a list of known compression format specific ones, that's really ALL. I might append manually files that I don't want to be processed with whatever that is not in the list of known compression format extensions.</span>
<span class="comment-copy">@user1850133 Firstly, I hope you realize the answer you selected does not do what you specified to me out-of-the-box, it makes no mention of ensuring the <code>.csv</code> extension and will match against any file that has the compression extensions not just <code>.csv</code> files.  Even if you do not choose to select my answer instead you should take a moment to really read it because it does what you asked, and does not do what your comment suggested it does.</span>
<span class="comment-copy">@user1850133 Secondly, I understand the frustration caused by the subtleties of a question being overlooked/misunderstood, but it shows very poor appreciation for the efforts of answerers to demand things of them. This is a friendly environment and we do not answer questions to serve your needs. When clarification is needed it should be added in a polite fashion. We are not as familiar with the problem so if there is a crucial subtle detail to your question you should make that obvious in your question.  Perhaps going back and editing your question to show this.</span>
