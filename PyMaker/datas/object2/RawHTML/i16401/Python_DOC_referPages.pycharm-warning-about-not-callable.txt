<div class="post-text" itemprop="text">
<p>I write a rule engine with a parameter 'matcher',  which could be a string, an Regular expression, or an function.</p>
<p>When I test and use this matcher:</p>
<pre><code>    if hasattr(self.matcher, '__call__'):  # 函数
        match_this_rule = self.matcher(input_msg)
</code></pre>
<p>PyCharm give me an warning on the second line, saying 'matcher is not callable'.</p>
<p>How could i avoid PyCharm showing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>PyCharm cannot know, in general, whether your <code>self.matcher</code> will be callable. As far as PyCharm is converned you are only testing if the object has an attribute, but I doubt that PyCharm will recognize that the attribute name is constant and that the condition implies that the object is callable.</p>
<p>The only solution to change PyCharm behaviour is to disable the inspection for that statement</p>
<pre><code>if hasattr(self.matcher, '__call__'):
    # noinspection PyCallingNonCallable
    match_this_rule = self.matcher(input_msg)
</code></pre>
<p>Instead of your home-made test, you could use the <a href="https://docs.python.org/3/library/functions.html#callable" rel="noreferrer"><code>callable</code></a> built-in function:</p>
<pre><code>if callable(self.matcher):
    match_this_rule = self.matcher(input_msg)
</code></pre>
<p>In fact with PyCharm3.4 the above code doesn't trigger the warning because PyCharm recognizes the built-in <code>callable</code> function.</p>
<hr/>
<p>This said, it would be even better if you avoided to use three different types for your matcher. You can always wrap the non-function matchers into a function, or create a small class to perform the matches in a uniform way. This would also simplify the code, since you wouldn't need to continuously test for the type in order to use <code>self.matcher</code>.</p>
</div>
<span class="comment-copy">+1 for turning <code>matcher</code> into a consistent type as early as possible</span>
