<div class="post-text" itemprop="text">
<p>The following question arose because I was trying to use <code>bytes</code> strings as dictionary keys and bytes values that I understood to be equal weren't being treated as equal.</p>
<p>Why doesn't the following python code compare equal - aren't these two equivalent representations of the same binary data (example knowingly chosen to avoid endianess)?</p>
<pre><code>b'0b11111111' == b'0xff'
</code></pre>
<p>I know the following evaluates true, demonstrating the equivalence:</p>
<pre><code>int(b'0b11111111', 2) == int(b'0xff', 16)
</code></pre>
<p>But why does python force me to know the representation? Is it related to endian-ness? Is there some easy way to force these to compare equivalent other than converting them all to e.g. hex literals? Can anyone suggest a transparent and clear method to move between all representations in a (somewhat) platform independent way (or am I asking too much)?</p>
<p>Edit:</p>
<p>Given the comments below, say I want to actually index a dictionary using 8 bits in the form <code>b'0b11111111'</code>, then why does python expand it to ten bytes and how do I prevent that?</p>
<p>This is a smaller piece of a large tree data structure and expanding my indexing by a factor of 80 seems like a huge waste of memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>Bytes can represent <em>any number of things</em>. Python cannot and will not guess at what your bytes might encode.</p>
<p>For example, <code>int(b'0b11111111', 34)</code> is <em>also</em> a valid interpretation, but that interpretation is not equal to hex FF.</p>
<p>The number of interpretations, in fact, is endless. The bytes could represent a series of ASCII codepoints, or image colors, or musical notes.</p>
<p>Until you explicitly apply an interpretation, the bytes object consists <em>just</em> of the sequence of values in the range 0-255, and the textual representation of those bytes use ASCII if so representable as printable text:</p>
<pre><code>&gt;&gt;&gt; list(bytes(b'0b11111111'))
[48, 98, 49, 49, 49, 49, 49, 49, 49, 49]
&gt;&gt;&gt; list(bytes(b'0xff'))
[48, 120, 102, 102]
</code></pre>
<p>Those byte sequences are not equal.</p>
<p>If you want to interpret these sequences explicitly as integer literals, then use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="noreferrer"><code>ast.literal_eval()</code></a> to interpret <em>decoded</em> text values; always normalise first before comparison:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.literal_eval(b'0b11111111'.decode('utf8'))
255
&gt;&gt;&gt; ast.literal_eval(b'0xff'.decode('utf8'))
255
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>b'0b11111111'</code> consists of 10 bytes:</p>
<pre><code>In [44]: list(b'0b11111111')
Out[44]: ['0', 'b', '1', '1', '1', '1', '1', '1', '1', '1']
</code></pre>
<p>whereas <code>b'0xff'</code> consists of 4 bytes:</p>
<pre><code>In [45]: list(b'0xff')
Out[45]: ['0', 'x', 'f', 'f']
</code></pre>
<p>Clearly, they are not the same objects.</p>
<p>Python values explicitness. (<em>Explicit is better than implicit</em>.) It does not <em>assume</em> that <code>b'0b11111111'</code> is necessarily the binary representation of an integer. It's just a string of bytes. How you choose to interpret it must be explicitly stated.</p>
</div>
<span class="comment-copy">But doesn't the <code>0b</code> indicate that the <code>bytes</code> literal is intended to be a binary representation irregardless of how you interpret it?</span>
<span class="comment-copy">@MatthewHemke: It just means you have a byte value 48 followed by a byte value 98. These <i>happen</i> to be interpretable as ASCII letters <code>0</code> and <code>b</code>.</span>
<span class="comment-copy">If that's the case, how do I make is so that I get the bytes string to be exactly the 1 byte that I mean?</span>
<span class="comment-copy">The actual byte strings yes, but the data they represent is the same right? Or is it that the byte strings themselves become the value when they are interpreted by e.g. an <code>int('', base)</code> evaluation.</span>
<span class="comment-copy">Yes, the byte string is not the same as an integer value. The <code>int</code> function converts the bytes to an <code>int</code> (and the base must be specified).</span>
