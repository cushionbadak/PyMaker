<div class="post-text" itemprop="text">
<p>Simply put, I have a dictionary (<code>dictData[name]=namedTuple</code>) of namedTuples (records) on a server.</p>
<p>Objective: I want to send the entire thing (<code>dictData</code>) or a single instance (<code>dictData[key]</code>) to the client via a SOCKET connection so it can be printed (shown on screen).</p>
<p>To send a single record I have tried to do the following:</p>
<pre><code>response = dictData["John"]
print (response) #ensure it is the correct record
s.send(response)
</code></pre>
<p>However this generates the following error:</p>
<pre><code>"TypeError: 'record' does not support the buffer interface"
</code></pre>
<p>I have tried to encode it and convert it but nothing I do seems to work. I am even open to converting it to a STRING and sending the string but I can't seem to find out how to convert a namedTuple to a string either.</p>
<p>And then, no clue where to start to send the entire dictionary to the client so they can print the entire set?</p>
<p>Any help would be much appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sockets can only send and receive bytes, so you need to serialise your named tuples and dictionary to something else.</p>
<p>You could use JSON to produce a string representation of your tuples and dictionary, for example. The <a href="https://docs.python.org/3/library/json.html" rel="nofollow"><code>json</code> library</a> produces a (unicode) string when encoding, you'll need to encode that to UTF-8 (or similar) to produce bytes:</p>
<pre><code>import json

# sending one tuple
response = json.dumps(dictData["John"])
s.send(response.encode('utf8'))

# sending all of the dictionary
response = json.dumps(dictData)
s.send(response.encode('utf8'))
</code></pre>
<p>This will <em>not</em> preserve the named tuple attribute names; the values are sent over as a JSON array instead (so an ordered list).</p>
<p>Another option is to use the <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow"><code>pickle</code> module</a>; this would require the listener on the other side to also be coded in Python <em>and</em> to have the same <code>record</code> named tuple type importable from the exact same location, however.</p>
<p>When Pickle loads the data, the name of the full qualifying name of the <code>namedtuple</code> type is included, and you must be able to import that type on both ends of the socket. If you have a line in a module at the global level:</p>
<pre><code>record = namedtuple('record', 'field1 field2 field3')
</code></pre>
<p>then <code>from yourmodule import record</code> is possible, but <em>the exact same import</em> should work on the other side too.</p>
<p><code>pickle.dumps()</code> produces a <code>bytes</code> object which can be written to the socket without encoding.</p>
</div>
<span class="comment-copy">Actually, a better encoding in this case would be <a href="https://docs.python.org/2/library/pickle.html" rel="nofollow noreferrer">pickle</a>.</span>
<span class="comment-copy">@whereswalden: that depends on what is listening on the other side.</span>
<span class="comment-copy">@Martijn you mentioned ordered, can this be sorted by name as well?</span>
<span class="comment-copy">@JSchwartz: right, that's because your <code>namedtuple()</code> is called <i><code>name</code></i>, not <code>UserData</code>. Use <code>namedtuple('UserData', 'age address phone')</code>.</span>
<span class="comment-copy">@JSchwartz I see Antti already answered that one. :-)</span>
