<div class="post-text" itemprop="text">
<p>When printing pages from a document, for example, you can specify the specific page numbers you want to print using this shorthand notation:</p>
<pre><code>1, 3, 4-7, 9-
</code></pre>
<p>And in a 12-page document this would print pages</p>
<pre><code>1, 3, 4, 5, 6, 7, 9, 10, 11, 12
</code></pre>
<p>How can I represent such a structure in Python so that I can query whether a specific "page number" (this is not limited to printing; that was an example) is in the range and also loop over the range?</p>
<p>These things would be easy if they were in a flattened list as in the second example (and string processing to convert it to that would be trivial), but the open-ended ranges pose a problem. It must not be flattened until the last minute.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use a generator:</p>
<pre><code>import itertools

def parse_ranges(ranges):
    for chunk in ranges.split(', '):
        if '-' not in chunk:
            chunk = chunk + '-' + chunk  # Turns 7 into 7-7 

        start, end = chunk.split('-')

        if end:
            yield from range(int(start), int(end) + 1)
        else:
            yield from itertools.count(int(start))
</code></pre>
<p>You can enforce a max page number when you iterate over it:</p>
<pre><code>for page in parse_ranges('1, 3, 4-7, 9-'):
    if page &gt; 20:
        break

    print(page)
</code></pre>
<p>Or do that separately:</p>
<pre><code>def cap(iterable, maximum):
    for n in iterable:
        if n &gt; maximum:
            break

        yield n

pages = list(cap(parse_ranges('1, 3, 4-7, 9-'), 20))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understand your problem correctly, you could use a list of tuples. <code>(1,1)</code> means page number 1, <code>(4, 7)</code> means pages 4, 5, 6 and 7. The tricky part is representing "from this page to the end". However, if you have the access to the number of pages, this can be solved by using <code>float("inf")</code>. The flattening function would then look like this:</p>
<pre><code>def flatten_ranges(ranges, number_of_pages):
    flattened_list = []
    for item in ranges:
        page = item[0]
        while page &lt;= item[1] and page &lt;= number_of_pages:
            flattened_list.append(page)
            page += 1
    return flattened_list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Pardon my noobish attempt using list of tuples as the pages</p>
<pre><code>pages=[(1,1),(3,3),(4,7),(8,)]

def find_page(pages,page):
    for p in pages:
        if len(p)==1:
            if page &gt;= p[0]:
                return True
            else:
                break
        if p[0]==p[1]:
            if page==p[0]:
                return True
        elif page &gt;= p[0] and page &lt;= p[1]:
            return True
</code></pre>
</div>
<span class="comment-copy">Does a list of [1, 3, 4,5,6, 9...end of pages] not work? I'm sure you can think of something a little better like a dict for O(1) access, but I don't see your problem.</span>
<span class="comment-copy">@EugeneK: It would, but the "end of pages" can vary, and the range needs to be usable on sets of a different length (so the list can't be precomputed).</span>
<span class="comment-copy">why not just have a <code>numOfPages</code> and a for loop add the elements from the marker to the end? You just change numOfPages when a new 'book' is added. I'm sorry, can you clarify a little bit more in the question what you want. Are you looking for a more elegant answer than that?</span>
<span class="comment-copy">Optimal solution probably uses <a href="https://en.wikipedia.org/wiki/Interval_tree" rel="nofollow noreferrer">interval trees</a> for managing ranges. See <a href="https://pypi.python.org/pypi/intervaltree" rel="nofollow noreferrer"><code>intervaltree</code></a> module.</span>
<span class="comment-copy">Looks good, but membership testing is strange. If I do <code>x in parse_ranges('&lt;any range&gt;')</code>, if <code>x</code> is indeed in the range it returns True, but if not the interpreter just hangs (Python 3.4.0). Am I missing something fundamental about how generators work?</span>
<span class="comment-copy">@rvighne: Membership on generators won't work well if they're not finite. Convert the generator into a list and test membership with that.</span>
<span class="comment-copy">Will I have to do that manually in a loop like the one you provided, or is there a better way? (As expected, the <code>list</code> constructor doesn't work. Can I somehow specify a maximum to the constructor?)</span>
<span class="comment-copy">@rvighne: You can just write a new function. See my edit.</span>
<span class="comment-copy">Awesome. Thank you for your patience.</span>
<span class="comment-copy">Didn't know that <code>float("inf")</code> trick, thanks.</span>
<span class="comment-copy">@rvighne actually, you can use any string. <code>x &gt; y</code> returns true for any string <code>x</code> and number <code>y</code>. But <code>float("inf")</code> is a more clean solution ;)</span>
<span class="comment-copy">So basically all I need is a marker for "and now go until the end." Thanks for showing me that.</span>
<span class="comment-copy">You could also do this with generators and <code>itertools.islice</code>.</span>
<span class="comment-copy">@Blender: Could you please elaborate? <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer">These docs</a> don't show me the value of using that.</span>
