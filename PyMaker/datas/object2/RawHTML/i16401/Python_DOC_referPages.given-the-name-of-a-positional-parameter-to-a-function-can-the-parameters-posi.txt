<div class="post-text" itemprop="text">
<p>I'm working on a toy Python typechecker, using the function annotation feature in Python 3 to define types for function parameters and return values, and I seem to have run into a problem in checking whether one function type is a subtype of another. Take these two functions:</p>
<pre><code>def f(x: int, y: int) -&gt; type(None):
    pass

def g(a: object, b: int) -&gt; type(None):
    pass
</code></pre>
<p>I want to have my code determine that the type of <code>g</code> is a subtype of the type of <code>f</code> (since the type of each of <code>f</code>'s parameters is a subtype of the type of the parameter at the same index in <code>g</code>'s parameter list, and the return type of <code>g</code> is a subtype of the return type of <code>f</code>). However, the <code>__annotations__</code> field is a dictionary:</p>
<pre><code>f.__annotations__ == { 'x': int, 'y': int, 'return': type(None) }
</code></pre>
<p>which means it doesn't provide me with the information about parameter ordering that I think I need. Is there a reliable way to determine that <code>x</code> is the first parameter to <code>f</code>, just from inspecting runtime properties of <code>f</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, Python functions do carry that information.</p>
<p>Easiest would be to use the <a href="https://docs.python.org/3/library/inspect.html#inspect.formatargspec"><code>inspect.getfullargspec()</code></a> function to extract this information, or from Python 3.3 onwards, using the <a href="https://docs.python.org/3/library/inspect.html#inspect-signature-object"><code>Signature</code> objects</a>.</p>
<p>The <code>inspect.getfullargspec()</code> return value has a <code>.args</code> attribute listing the arguments in order:</p>
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; def f(x: int, y: int) -&gt; type(None):
...     pass
... 
&gt;&gt;&gt; def g(a: object, b: int) -&gt; type(None):
...     pass
... 
&gt;&gt;&gt; inspect.getfullargspec(f)
FullArgSpec(args=['x', 'y'], varargs=None, varkw=None, defaults=None, kwonlyargs=[], kwonlydefaults=None, annotations={'x': &lt;class 'int'&gt;, 'y': &lt;class 'int'&gt;, 'return': &lt;class 'NoneType'&gt;})
&gt;&gt;&gt; inspect.getfullargspec(f).args
['x', 'y']
&gt;&gt;&gt; inspect.getfullargspec(g).args
['a', 'b']
</code></pre>
<p>Annotations are included too:</p>
<pre><code>&gt;&gt;&gt; inspect.getfullargspec(f).annotations
{'x': &lt;class 'int'&gt;, 'y': &lt;class 'int'&gt;, 'return': &lt;class 'NoneType'&gt;}
&gt;&gt;&gt; inspect.getfullargspec(g).annotations
{'return': &lt;class 'NoneType'&gt;, 'a': &lt;class 'object'&gt;, 'b': &lt;class 'int'&gt;}
</code></pre>
<p>Signature objects are richer still:</p>
<pre><code>&gt;&gt;&gt; sig_f = inspect.signature(f)
&gt;&gt;&gt; sig_g = inspect.signature(g)
&gt;&gt;&gt; sig_f.parameters
mappingproxy(OrderedDict([('x', &lt;Parameter at 0x1031f1ea8 'x'&gt;), ('y', &lt;Parameter at 0x102e00228 'y'&gt;)]))
&gt;&gt;&gt; sig_f.parameters['x'].annotation
&lt;class 'int'&gt;
&gt;&gt;&gt; sig_g.parameters['b'].annotation
&lt;class 'int'&gt;
&gt;&gt;&gt; sig_f.return_annotation == sig_g.return_annotation
True
</code></pre>
<p>where <code>Signature.parameters</code> uses an ordered dictionary, letting you compare parameters in the correct order.</p>
</div>
<span class="comment-copy">Wonderful, thanks for the quick response! SO won't let me accept it as correct until another 10 minutes have passed, but this totally answers my question.</span>
