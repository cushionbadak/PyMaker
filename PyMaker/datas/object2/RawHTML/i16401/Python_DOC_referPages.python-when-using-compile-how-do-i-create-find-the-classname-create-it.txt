<div class="post-text" itemprop="text">
<p>I have an issue where I need to instantiate a class, but I'm not sure what the most optimal way to go about this is.</p>
<p>Imagine the following code:</p>
<pre><code># loadstuff.py

class LoadSomething:
    def load(self, filename):
        compiled = compile(open(filename).read(), filename, 'exec')

        # The part I am stuck on
        # How do I get the class name, and how do I instantiate it? 
        # This is assuming the file name is the same as the class name, only starting with capital letter, and minus file extension
        module = compiled.  # instantiate class 'Printstuff'

        return module 

loader = LoadSomething()
module = loader.load("printstuff.py")
module.printSomething()  # Should print "Something!"

# printstuff.py

class Printstuff:
    def printSomething(self):
        print("Something!")
</code></pre>
<p>I think the code (and thus the question) speaks mostly for itself, how do I return and instantiate a new class with <code>compile(..)</code> so that I can call its methods?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no need to manually compile. Use <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow"><code>importlib.import_module()</code></a> to dynamically import the module.</p>
<p>You can then use <a href="https://docs.python.org/3/library/inspect.html#inspect.getmembers" rel="nofollow"><code>inspect.getmembers()</code></a> together with the <a href="https://docs.python.org/3/library/inspect.html#inspect.isclass" rel="nofollow"><code>inspect.isclass()</code> predicate</a> to find all classes, including any that might match the module name:</p>
<pre><code>import importlib
import inspect

class LoadSomething:
    def load(self, modulename):
        module = importlib.import_module(modulename)
        modname = modulename.rpartition('.')[-1]  # support packages too
        for clsname, cls in inspect.getmembers(module, inspect.isclass):
            if clsname == modname.title():
                return cls()
</code></pre>
<p>This returns an instance of the first class that has the same name as the module, titlecased.</p>
</div>
<div class="post-text" itemprop="text">
<p>The fundamental problem is that the code object (the thing you've used <code>compile()</code> to produce) can contain <em>any</em> Python code — e.g. it could define multiple classes.  As a result, you're going to have to specify how the file you're loading is supposed to indicate which class to use.</p>
<p>One option, for instance, would be to require it to define a class with a well-known name.  For instance:</p>
<pre><code>codeobj = compile(open(filename).read(), filename, 'exec')
globs = {}
locs = {}
exec(codeobj, globs, locs)
cls = globs['Foobar']
obj = cls()
</code></pre>
<p>You could simplify this quite a bit by using <code>execfile()</code> instead of <code>compile()</code> and <code>exec()</code>:</p>
<pre><code>globals = {}
locals = {}
execfile(filename, globs, locs)
cls = globs['Foobar']
obj = cls()
</code></pre>
<p>It's quite easy to come up with more complex schemes as well.</p>
<p>FWIW, the reason to do this rather than use <code>imp</code>, <code>importlib</code> or <code>__import__</code> is that the import-based options use the module system.  If this is for loading a plug-in, you probably don't want that, so <code>execfile()</code> et al are more appropriate.</p>
</div>
<span class="comment-copy">Are you certain you should be using <code>compile()</code>?  As opposed to, say, <code>__import__</code> or <code>imp.load_module()</code>?</span>
<span class="comment-copy">@alastair I'm not certain, I'm looking for the best way to load a class using it's source code rather than import though. (I don't want people to use <code>from modules import printstuff</code> <code>printstuff.Printstuff().printsomething()</code>) because the system should load these dynamically.</span>
<span class="comment-copy">You don't have to use <code>exec</code>, <code>compile</code> or such to <i>dynamically</i> import a module, that's what the <code>imp</code> module is for (cf <a href="http://stackoverflow.com/questions/67631/how-to-import-a-module-given-the-full-path" title="how to import a module given the full path">stackoverflow.com/questions/67631/…</a>).</span>
<span class="comment-copy">That only allows you to load modules that are in Python's path.  Also, it uses the module system, which is undesirable in some cases because e.g. it means you can't load modules that have the same name.</span>
<span class="comment-copy">Hello, I'm having trouble finding documentation on what <code>importlib(modulename)</code> does, what are it's parameters, what exactly does it call? Could you elaborate on that perhaps?</span>
<span class="comment-copy">@alastair: You can always complicate matters more; the OP should try to work <i>with</i> the import functionality, not against it. Putting all plugins into a namespace would go a long way towards that. The Python 3 <code>importlib</code> contains plenty of functionality to extend on that if so desired (including any number of ways that prevent name clashes with 'regular' modules).</span>
<span class="comment-copy">@Zarthus: I made an error in the answer; the <code>import_module()</code> function name was omitted.</span>
<span class="comment-copy">Please, do <b>not</b> advise peoples to use <code>exec</code> or <code>execfile</code> when there are better solutions. If you don't understand why, read this: <a href="http://lucumr.pocoo.org/2011/2/1/exec-in-python/" rel="nofollow noreferrer">lucumr.pocoo.org/2011/2/1/exec-in-python</a> . In the above case, Python has features to let you dynamically import a module.</span>
<span class="comment-copy">@brunodesthuilliers Disagree.  This isn't about importing a module, it's about loading something that explicitly <i>is not</i> a module.  In that case, <code>imp</code> is <b>not</b> a better solution IMO (not least because you'd have to generate a unique module name each time, which breaks pickle just as much as using <code>execfile()</code> does in the first place).</span>
<span class="comment-copy">The code provided worked, I'm going to dig deeper into the other answer and see what is best for me. As far as this goes however, I would consider it a valid answer. I'll let this question unfold a bit more and educate myself some more, then I'll see what I'll roll with. Nevertheless, it works, and it seems to do as I ask, your contributions are appreciated. :)</span>
