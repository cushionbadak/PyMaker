<div class="post-text" itemprop="text">
<p>I am trying to compile a C program using Python and want to give input using "&lt;" operator but it's not working as expected.
If I compile the C program and run it by giving input though a file it works; for example</p>
<pre><code>./a.out &lt;inp.txt works
</code></pre>
<p>But similarly if I try to do this using a Python script, it did not quite work out as expected.
For example:</p>
<pre><code>import subprocess
subprocess.call(["gcc","a.c","-o","x"])
subprocess.call(["./x"])
</code></pre>
<p>and</p>
<pre><code>import subprocess
subprocess.call(["gcc","a.c","-o","x"])
subprocess.call(["./x","&lt;inp.txt"])
</code></pre>
<p>Both script ask for input though terminal. But I think in the second script it should read from file. why both the programs are working the same?</p>
</div>
<div class="post-text" itemprop="text">
<p>To complement <a href="https://stackoverflow.com/a/24738278/45375">@Jonathan Leffler's</a> and <a href="https://stackoverflow.com/a/24738400/45375">@alastair's</a> helpful answers:</p>
<p>Assuming <em>you</em> control the string you're passing to the shell for execution, I see nothing wrong with using the shell for convenience. [1]</p>
<p><strong><code>subprocess.call()</code> has an optional Boolean <code>shell</code> parameter, which causes the command to be passed to the <em>shell</em></strong>, enabling I/O redirection, referencing environment variables, ...:</p>
<pre><code>subprocess.call("./x &lt;inp.txt", shell = True)
</code></pre>
<p>Note how the <strong>entire command line is passed as a <em>single</em> string</strong> rather than an array of arguments.</p>
<hr/>
<p>[1]
<strong>Avoid use of the shell in the following cases:</strong></p>
<ul>
<li>If your Python code <strong>must run on platforms <em>other</em> than Unix-like ones, such as Windows</strong>.</li>
<li>If performance is paramount.</li>
<li>If you find yourself "outsourcing" tasks better handled on the Python side.</li>
</ul>
<p><strong>If you're concerned about lack of predictability of the shell environment</strong> (as @alastair is):</p>
<ul>
<li><code>subprocess.call</code> with <code>shell = True</code> <strong><em>always</em> creates non-interactive non-login instances of <code>/bin/sh</code></strong> - note that it is NOT the user's default shell that is used.</li>
<li><code>sh</code> <strong>does NOT read initialization files</strong> for non-interactive non-login shells (neither system-wide nor user-specific ones).

<ul>
<li>Note that even on platforms where <code>sh</code> is <code>bash</code> in disguise, <code>bash</code> will act this way when invoked as <code>sh</code>.</li>
</ul></li>
<li>Every shell instance created with <code>subprocess.call</code> with <code>shell = True</code> is its own world, and its environment is neither influenced by previous shell instances nor does it influence later ones.</li>
<li>However, the <strong>shell instances created <em>do</em> inherit the <em>environment of the python process itself</em></strong>:

<ul>
<li>If you started your Python program from an interactive shell, then that shell's environment is inherited. Note that this only <strong>pertains to the <em>current working directory</em> and <em>environment variables</em></strong>, and NOT to aliases, shell functions, and shell variables.</li>
<li><strong>Generally, that's a <em>feature</em></strong>, given that Python (CPython) itself is designed to be controllable via environment variables (for 2.x, see <a href="https://docs.python.org/2/using/cmdline.html#environment-variables" rel="nofollow noreferrer">https://docs.python.org/2/using/cmdline.html#environment-variables</a>; for 3.x, see <a href="https://docs.python.org/3/using/cmdline.html#environment-variables" rel="nofollow noreferrer">https://docs.python.org/3/using/cmdline.html#environment-variables</a>).</li>
<li><strong>If needed, you can <em>supply your own environment</em></strong> to the shell via the <code>env</code> parameter; note, however, that <strong>you'll have to supply the <em>entire</em> environment in that event</strong>, potentially including variables such as <code>USER</code> and <code>HOME</code>, if needed; simple example, defining <code>$PATH</code> explicitly:</li>
<li><code>subprocess.call('echo $PATH', shell = True, \
                 env = { 'PATH': '/sbin:/bin:/usr/bin' })</code></li>
</ul></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The shell does I/O redirection for a process.  Based on what you're saying, the <code>subprocess</code> module does not do I/O redirection like that.  To demonstrate, run:</p>
<pre><code>subprocess.call(["sh","-c", "./x &lt;inp.txt"])
</code></pre>
<p>That runs the shell and should redirect the I/O.  With your code, your program <code>./x</code> is being given an argument <code>&lt;inp.txt</code> which it is ignoring.</p>
<p>NB: the alternative call to <code>subprocess.call</code> is purely for diagnostic purposes, not a recommended solution.  The recommended solution involves reading the (Python 2) <a href="https://docs.python.org/2/library/subprocess.html" rel="nofollow">subprocess</a> module documentation (or the <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow">Python 3</a> documentation for it) to find out how to do the redirection using the module.</p>
<pre><code>import subprocess
i_file = open("inp.txt")
subprocess.call("./x", stdin=i_file)
i_file.close()
</code></pre>
<p>If your script is about to exit so you don't have to worry about wasted file descriptors, you can compress that to:</p>
<pre><code>import subprocess
subprocess.call("./x", stdin=open("inp.txt"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By default, the <code>subprocess</code> module does not pass the arguments to the shell.  Why?  Because running commands via the shell is <em>dangerous</em>; unless they're correctly quoted and escaped (which is complicated), it is often possible to convince programs that do this kind of thing to run unwanted and unexpected shell commands.</p>
<p>Using the shell for this would be wrong anyway.  If you want to take input from a particular file, you can use <code>subprocess.Popen</code>, setting the <code>stdin</code> argument to a file descriptor for the file <code>inp.txt</code> (you can get the file descriptor by calling <code>fileno()</code> a Python file object).</p>
</div>
<span class="comment-copy">Is there “nothing wrong with using the shell for convenience”?  You'd think so, but what happens if e.g. the user sets IFS?  Or, since the calls above to gcc don't specify a full path, PATH?  It really is better not to use the shell to run things if you can possibly avoid it.</span>
<span class="comment-copy">@alastair: <code>$IFS</code> or <code>$PATH</code> could only be changed (temporarily) from the very same shell command you're executing; see my update on how the shell instances are created and let me know if you still have concerns about a modified environment (I may well be missing something). That said, a compelling reason to avoid the shell is if you also need to support Windows (unless you deliberately use only commands simple enough to work on both platform types).</span>
<span class="comment-copy">According to the <code>subprocess</code> docs, unless an environment is explicitly specified, it’s inherited from the Python process.  If someone can manipulate the environment of <i>that</i> process, it could still cause unwanted behaviour.</span>
<span class="comment-copy">@alastair: That is worth noting, but that's more of a <i>feature</i> than a pitfall - see my update.</span>
<span class="comment-copy">Sure. I still think using the shell from code is generally to be discouraged, especially where there's a simple non-shell-based alternative available.  That said, I've up voted your answer because it's now quite comprehensive IMO :-)</span>
