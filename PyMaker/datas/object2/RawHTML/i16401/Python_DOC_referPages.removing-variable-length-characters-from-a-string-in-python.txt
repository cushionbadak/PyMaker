<div class="post-text" itemprop="text">
<p>I have strings that are of the form below:    </p>
<pre><code>&lt;p&gt;The is a string.&lt;/p&gt;
&lt;em&gt;This is another string.&lt;/em&gt;
</code></pre>
<p>They are read in from a text file one line at a time. I want to separate these into words. For that I am just splitting the string using <code>split()</code>.</p>
<p>Now I have a set of words but the first word will be <code>&lt;p&gt;The</code> rather than <code>The</code>. Same for the other words that have <code>&lt;&gt;</code> next to them. I want to remove the <code>&lt;..&gt;</code> from the words. </p>
<p>I'd like to do this in one line. What I mean is I want to pass as a parameter something of the form <code>&lt;*&gt;</code> like I would on the command line. I was thinking of using the <code>replace()</code> function to try to do this, but I am not sure how the <code>replace()</code> function parameter would look like.</p>
<p>For example, how could I change <code>&lt;..&gt;</code> below in a way that it will mean that I want to include anything that is between <code>&lt;</code> and <code>&gt;</code>:</p>
<pre><code>x = x.replace("&lt;..&gt;", "")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately, <code>str.replace</code> does not support Regex patterns. You need to use <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow"><code>re.sub</code></a> for this:</p>
<pre><code>&gt;&gt;&gt; from re import sub
&gt;&gt;&gt; sub("&lt;[^&gt;]*&gt;", "", "&lt;p&gt;The is a string.&lt;/p&gt;")
'The is a string.'
&gt;&gt;&gt; sub("&lt;[^&gt;]*&gt;", "", "&lt;em&gt;This is another string.&lt;/em&gt;")
'This is another string.'
&gt;&gt;&gt;
</code></pre>
<p><code>[^&gt;]*</code> matches zero or more characters that are not <code>&gt;</code>.</p>
</div>
<div class="post-text" itemprop="text">
<h2>No Need for a 2-Step Solution</h2>
<p>You don't need to 1. Split then 2. Replace. The two solutions below show you how to do it with one single step.</p>
<hr/>
<h2>Option 1: Match All Instead of Splitting</h2>
<p><a href="http://www.rexegg.com/regex-style.html#splitvsmatch" rel="nofollow noreferrer">Match All and Split are Two Sides of the Same Coin</a>, and in this case it is safer to match all:</p>
<pre><code>&lt;[^&gt;]+&gt;|(\w+)
</code></pre>
<p>The words will be in Group 1. </p>
<p>Use it like this:</p>
<pre><code>subject = '&lt;p&gt;The is a string.&lt;/p&gt;&lt;em&gt;This is another string.&lt;/em&gt;'
regex = re.compile(r'&lt;[^&gt;]+&gt;|(\w+)')
matches = [group for group in re.findall(regex, subject) if group]
print(matches)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['The', 'is', 'a', 'string', 'This', 'is', 'another', 'string']
</code></pre>
<p><strong>Discussion</strong></p>
<p>This problem is a classic case of the technique explained in this question to <a href="https://stackoverflow.com/q/23589174/">"regex-match a pattern, excluding..."</a> </p>
<p>The left side of the alternation  <code>|</code> matches complete <code>&lt;tags&gt;</code>. We will ignore these matches. The right side matches and captures words to Group 1, and we know they are the right ones because they were not matched by the expression on the left.</p>
<p><strong>Reference</strong> </p>
<ul>
<li><a href="https://stackoverflow.com/q/23589174/">How to match (or replace) a pattern except in situations s1, s2, s3...</a></li>
<li><a href="http://www.rexegg.com/regex-best-trick.html" rel="nofollow noreferrer">Article about matching a pattern unless...</a></li>
</ul>
<h2>Option 2: One Single Split</h2>
<pre><code>&lt;[^&gt;]+&gt;|[ .]
</code></pre>
<p>On the left side of the <code>|</code>, we use <code>&lt;complete tags&gt;</code> as a split delimiter. On the right side, we use a space character or a period.</p>
<p><strong>Output</strong></p>
<pre><code>This
is
a
string
</code></pre>
</div>
<span class="comment-copy">Why don't you just use a parser like <a href="http://www.crummy.com/software/BeautifulSoup/" rel="nofollow noreferrer">BeautifulSoup</a> since these are just tags?</span>
<span class="comment-copy">what is expected output?</span>
<span class="comment-copy">Either <code>BeautifulSoup</code> or <code>re</code> will do the trick.</span>
<span class="comment-copy">@Cyber. Looking to do it without a parser.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/1732454/198633">HTML should not be parsed with regex</a>. Try a parser like Beautiful Soup or etree instead</span>
<span class="comment-copy">It's probably better to use <code>(&lt;[^&gt;]*&gt;)?</code> for the regex.</span>
<span class="comment-copy">He wants to retrieve the words, so this will be a two-step solution, right? Some splitting will need to take place.</span>
<span class="comment-copy">@zx81 - Well, in that case, all he needs to do is <code>sub("&lt;[^&gt;]*&gt;", "", "&lt;p&gt;The is a string.&lt;/p&gt;").split()</code>.  We don't need anything fancy because he said that he is getting the lines one at a time and that they are all of the same format.</span>
<span class="comment-copy">FYI: Added simple code (really two lines) for the Group 1 option, which IMO is more solid than the split option.</span>
<span class="comment-copy">Hey, I gave two solutions that require a SINGLE step: you don't need to 1 split, then 2 replace. Why did you choose a 2-step solution? That makes no sense to me. My Option 1 is ONE step (just match all). My Option 2 is ONE step (just split)</span>
<span class="comment-copy">On top of that, the solution you picked was edited to essentially use my regex <code>&lt;[^&gt;]+&gt;</code>.</span>
<span class="comment-copy">My question was how to remove all <code>&lt;..&gt;</code> from a string. You put removing and splitting together but I was only asking about removing it, which the accepted answer provides. I do want to split also but my question didn't ask how to perform the two in one step.</span>
<span class="comment-copy">But you <b>ARE</b> splitting, and answers on SO always try to give you a better way to do things. If you can do it in one step, that's what we show you. I have nothing against the replacement by @iCodez, but in my view you made an extraordinarily poor choice, and I am sure that even he would agree, as I would if the situation were reversed. I normally don't rant about this kind of thing, it happens a lot, but usually not with someone with over 500 rep.</span>
