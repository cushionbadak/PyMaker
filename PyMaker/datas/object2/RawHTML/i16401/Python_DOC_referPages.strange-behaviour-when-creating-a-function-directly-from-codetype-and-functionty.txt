<div class="post-text" itemprop="text">
<p><strong>DISCLAIMER:</strong> I know that what I'm doing should probably never <em>ever</em> be done in a real program.</p>
<p>I recently just learnt about python's <code>types.CodeType</code> and <code>types.FunctionType</code> and it got me interested in creating functions manually via these classes. So as a small test, I started with a function that looked something like this:</p>
<pre><code>def x(e, a, b=0, *c, d=0, **f):
    print(a, b, c, d, e, f)
</code></pre>
<p>and wanted to see if I could move the parameters around to turn it into this:</p>
<pre><code>def x(a, b=0, *c, d=0, e=0, **f):
    print(a, b, c, d, e, f)
</code></pre>
<p>Essentially I want to make an ordinary parameter into a keyword-only argument. This is the code I used to do such a mutation:</p>
<pre><code>from types import CodeType, FunctionType

def x(e, a, b=0, *c, d=0, **f):
    print(a, b, c, d, e, f)

code = x.__code__
codeobj = CodeType(
    code.co_argcount - 1, code.co_kwonlyargcount + 1, code.co_nlocals, code.co_stacksize,
    code.co_flags, code.co_code, code.co_consts, code.co_names, ('a', 'b', 'd', 'e', 'c', 'f'),
    code.co_filename, code.co_name, code.co_firstlineno, code.co_lnotab, code.co_freevars,
    code.co_cellvars
    )
new_func = FunctionType(codeobj, x.__globals__, x.__name__, x.__defaults__, x.__closure__)
new_func.__kwdefaults__ = {'d': 0, 'e': 0}
</code></pre>
<p>Strangely enough the tooltip seems to show up correctly (the little yellow rectangle of text that shows up in the IDLE interpretter when you begin typing a function call), it displays "a, b=0, *c, d=0, e=0, **f". But the behaviour the function had was interesting to say the least:</p>
<pre><code>&gt;&gt;&gt; new_func(1)
0 0 () 0 1 {}
&gt;&gt;&gt; new_func(1, 2)
2 0 () 0 1 {}
</code></pre>
<p>The first parameter was still getting sent in as <code>e</code>, and the second element is still getting sent in as <code>a</code>.</p>
<p>Is there a way to fix this? If there is, would it require delving into the <code>code.co_code</code> and breaking apart the opcodes, or is there a simpler method?</p>
</div>
<div class="post-text" itemprop="text">
<p>Functions and their code objects are tightly coupled. Arguments are handed in as locals, and locals are looked up <em>by index</em>:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def x(e, a, b=0, *c, d=0, **f):
...     print(a, b, c, d, e, f)
... 
&gt;&gt;&gt; dis.dis(x)
  2           0 LOAD_GLOBAL              0 (print)
              3 LOAD_FAST                1 (a)
              6 LOAD_FAST                2 (b)
              9 LOAD_FAST                4 (c)
             12 LOAD_FAST                3 (d)
             15 LOAD_FAST                0 (e)
             18 LOAD_FAST                5 (f)
             21 CALL_FUNCTION            6 (6 positional, 0 keyword pair)
             24 POP_TOP
             25 LOAD_CONST               0 (None)
             28 RETURN_VALUE
</code></pre>
<p>Note the integers after the <code>LOAD_FAST</code> byte codes, those are indices into the locals array. Reshuffling your arguments did not alter those bytecode indices.</p>
<p>The <code>code.co_varnames</code> list is only used for introspection (such as the <code>dis</code> output), to map indices back to names, not the other way around.</p>
<p>You'd have to apply surgery to the bytecode to alter this; see the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow"><code>dis</code> module</a> for more details.</p>
<p>If you are using Python 3.4 or newer, you can make use of the new <a href="https://docs.python.org/3/library/dis.html#dis.get_instructions" rel="nofollow"><code>dis.get_instructions()</code> function</a> to iterate over an information-rich sequence of <code>Instruction</code> objects, which <em>should</em> make such surgery doable. Look for the <code>LOAD_FAST</code> instructions, and map indices as you produce new bytecode.</p>
<p><code>Instruction</code> objects don't have a method (yet) to convert them back to bytes; adding one is trivial:</p>
<pre><code>from dis import Instruction, HAVE_ARGUMENT

def to_bytes(self):
    res = bytes([self.opcode])
    if self.opcode &gt;= HAVE_ARGUMENT:
        res += (self.arg or 0).to_bytes(2, byteorder='little')
    return res

Instruction.to_bytes = to_bytes
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; [ins.to_bytes() for ins in dis.get_instructions(code)]
[b't\x00\x00', b'|\x01\x00', b'|\x02\x00', b'|\x04\x00', b'|\x03\x00', b'|\x00\x00', b'|\x05\x00', b'\x83\x06\x00', b'\x01', b'd\x00\x00', b'S']
&gt;&gt;&gt; b''.join([ins.to_bytes() for ins in dis.get_instructions(code)]) == code.co_code
True
</code></pre>
<p>Now all you have to do is map the <code>.arg</code> argument of instructions with <code>.opname == 'LOAD_FAST'</code> to a new index.</p>
</div>
<span class="comment-copy">In your example, you are calling <code>x</code>, not <code>new_func</code>.</span>
<span class="comment-copy">Whoops, sorry. It still misbehaves when using <code>new_func</code> though.</span>
<span class="comment-copy">Hmmm, so I assume there would be no easy way of fixing this since I would have to change the integers in the bytecode after every <code>LOAD_FAST</code> to the variable I shuffled?</span>
<span class="comment-copy">@user3002473: exactly, you have do do bytecode surgery here.</span>
<span class="comment-copy">Alright thanks, I'll look into <code>dis.get_instructions</code> to see if what I want to do is plausible for my application :)</span>
<span class="comment-copy">@user3002473: The <code>Instruction</code> objects do not, currently, have any method to produce the corresponding bytecode bytes again, but producing such a method should not be hard.</span>
<span class="comment-copy">@user3002473: added a method to convert <code>Instruction</code> objects back to bytes, so now you can process these objects in a stream.</span>
