<div class="post-text" itemprop="text">
<p>I am trying to work out a good regular expression for a python comment(s) that is located within a long string. So far I have</p>
<p>regex:</p>
<pre><code>#(.?|\n)*
</code></pre>
<p>string:</p>
<pre><code>'### this is a comment\na = \'a string\'.toupper()\nprint a\n\na_var_name = " ${an.injection} "\nanother_var = " ${bn.injection} "\ndtabse_conn = " ${cn.injection} "\n\ndef do_something()\n    # this call outputs an xml stream of the current parameter dictionary.\n    paramtertools.print_header(params)\n\nfor i in xrange(256):    # wow another comment\n    print i**2\n\n'
</code></pre>
<p>I feel like there is a much better way to get all of the individual comments from the string, but I am not an expert in regular expressions. Does anyone have a better solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>Get the comments from matched group at index 1.</p>
<pre><code>(#+[^\\\n]*)
</code></pre>
<p><a href="http://regex101.com/r/eA2dW9/4" rel="nofollow">DEMO</a></p>
<p>Sample code:</p>
<pre><code>import re
p = re.compile(ur'(#+[^\\\n]*)')
test_str = u"..."

re.findall(p, test_str)
</code></pre>
<p>Matches:</p>
<pre><code>1.  ### this is a comment
2.  # this call outputs an xml stream of the current parameter dictionary.
3.  # wow another comment
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since this is a python code in the string, I'd use <a href="https://docs.python.org/2/library/tokenize.html" rel="nofollow"><code>tokenize</code></a> module to parse it and extract comments:</p>
<pre><code>import tokenize
import StringIO

text = '### this is a comment\na = \'a string\'.toupper()\nprint a\n\na_var_name = " ${an.injection} "\nanother_var = " ${bn.injection} "\ndtabse_conn = " ${cn.injection} "\n\ndef do_something():\n    # this call outputs an xml stream of the current parameter dictionary.\n    paramtertools.print_header(params)\n\nfor i in xrange(256):    # wow another comment\n    print i**2\n\n'

tokens = tokenize.generate_tokens(StringIO.StringIO(text).readline)
for toktype, ttext, (slineno, scol), (elineno, ecol), ltext in tokens:
    if toktype == tokenize.COMMENT:
        print ttext
</code></pre>
<p>Prints:</p>
<pre><code>### this is a comment
# this call outputs an xml stream of the current parameter dictionary.
# wow another comment
</code></pre>
<p>Note that the code in the string has a syntax error: missing <code>:</code> after the <code>do_something()</code> function definition.</p>
<p>Also, note that <a href="https://docs.python.org/2/library/ast.html" rel="nofollow"><code>ast</code></a> module would not help here, since it doesn't preserve comments.</p>
</div>
<div class="post-text" itemprop="text">
<p>Regex will work fine if you do two things:</p>
<ol>
<li><p>Remove all string literals (since they can contain <code>#</code> characters).</p></li>
<li><p>Capture everything that starts with a <code>#</code> character and proceeds to the end of the line.</p></li>
</ol>
<p>Below is a demonstration:</p>
<pre><code>&gt;&gt;&gt; from re import findall, sub
&gt;&gt;&gt; string = '### this is a comment\na = \'a string\'.toupper()\nprint a\n\na_var_name = " ${an.injection} "\nanother_var = " ${bn.injection} "\ndtabse_conn = " ${cn.injection} "\n\ndef do_something()\n    # this call outputs an xml stream of the current parameter dictionary.\n    paramtertools.print_header(params)\n\nfor i in xrange(256):    # wow another comment\n    print i**2\n\n'
&gt;&gt;&gt; findall("#.*", sub('(?s)\'.*?\'|".*?"', '', string))
['### this is a comment', '# this call outputs an xml stream of the current parameter dictionary.', '# wow another comment']
&gt;&gt;&gt;
</code></pre>
<p><a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow"><code>re.sub</code></a> removes anything of the form <code>"..."</code> or <code>'...'</code>.  This saves you from having to worry about comments that are inside string literals.</p>
<p><code>(?s)</code> sets the <a href="https://docs.python.org/3/library/re.html#re.DOTALL" rel="nofollow">dot-all flag</a>, which allows <code>.</code> to match newline characters.</p>
<p>Lastly, <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow"><code>re.findall</code></a> gets everything that starts with a <code>#</code> character and proceeds to the end of the line.</p>
<hr/>
<p>For a more complete test, place this sample code in a file named <code>test.py</code>:</p>
<pre><code># Comment 1  
for i in range(10): # Comment 2
    print('#foo')
    print("abc#bar")
    print("""
#hello
abcde#foo
""")  # Comment 3
    print('''#foo
    #foo''')  # Comment 4
</code></pre>
<p>The solution given above still works:</p>
<pre><code>&gt;&gt;&gt; from re import findall, sub
&gt;&gt;&gt; string = open('test.py').read()
&gt;&gt;&gt; findall("#.*", sub('(?s)\'.*?\'|".*?"', '', string))
['# Comment 1', '# Comment 2', '# Comment 3', '# Comment 4']
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">I don't think that this is doable with a python regex, since the # may be into something like a="#foo". Even more complex situations with more opening and closing \" or \' characters are possible, so it would not wonder me, if someone can show that it's not doable with regex alone by the pumping lemma. @alecxe has a better solution.</span>
<span class="comment-copy">Why not just split the string on newlines using <code>str = str.split('\n')</code> and then iterate over the result?</span>
<span class="comment-copy">@RevanProdigalKnight because I have to compare the previous and following <code>n</code> characters to the regex findings so that I can mutate 2 strings into a 3rd string. I have tried that method and when you split lines you increase the complexity. this is all because I am doing code transforms on a file and then after the transform i have to add the comments back in to the appropriate place.</span>
<span class="comment-copy">I haven't tested enough cases yet but so far this is looking like exactly what I needed.</span>
<span class="comment-copy">Go ahead and test all the cases.</span>
<span class="comment-copy">I have tried that the problem is that <code>tokenize.untokenize</code> is not a dependable function since I am using this to transform code.</span>
<span class="comment-copy">if the <code>ast</code> module did preserve comments I would have 3 weeks of my life back.</span>
<span class="comment-copy">@baallezx could you please elaborate a bit more about why you cannot use <code>tokenize</code> here? Thank you.</span>
<span class="comment-copy">@alexce there are many issues with <code>tokenize.untokenize</code> like it will break if it comes across a line continuation character `` plus a few others that i can not think of off the top of my head. I will try to use it again by using the token.start and token.end as references to placements within the string and get back to you. Maybe that will work.</span>
<span class="comment-copy">@baallezx thank you, yeah, give it a try. Probably, it would be better to stick with this approach and solve the issues you would have with it either by yourself, or with the help of SO community by creating separate questions. I'm still pretty sure this is the most robust approach (especially comparing to a regex solution).</span>
