<div class="post-text" itemprop="text">
<p>I'm looking for a way to remove duplicate entries from a Python list but with a twist; The final list has to be case sensitive with a preference of uppercase words. </p>
<p>For example, between <code>cup</code> and <code>Cup</code> I only need to keep <code>Cup</code> and not <code>cup</code>. Unlike other common solutions which suggest using <code>lower()</code> first, I'd prefer to maintain the string's case here and in particular I'd prefer keeping the one with the uppercase letter over the one which is lowercase..</p>
<p>Again, I am trying to turn this list:
<code>[Hello, hello, world, world, poland, Poland]</code></p>
<p>into this:</p>
<p><code>[Hello, world, Poland]</code></p>
<p>How should I do that?</p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>This does not preserve the order of <code>words</code>, but it does produce a list of "unique" words with a preference for capitalized ones.</p>
<pre><code>In [34]: words = ['Hello', 'hello', 'world', 'world', 'poland', 'Poland', ]

In [35]: wordset = set(words)

In [36]: [item for item in wordset if item.istitle() or item.title() not in wordset]
Out[36]: ['world', 'Poland', 'Hello']
</code></pre>
<p>If you wish to preserve the order as they appear in <code>words</code>, then you could use a <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow">collections.OrderedDict</a>:</p>
<pre><code>In [43]: wordset = collections.OrderedDict()

In [44]: wordset = collections.OrderedDict.fromkeys(words)

In [46]: [item for item in wordset if item.istitle() or item.title() not in wordset]
Out[46]: ['Hello', 'world', 'Poland']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/functions.html#func-set" rel="nofollow"><code>set</code></a> to track seen words:</p>
<pre><code>def uniq(words):
    seen = set()
    for word in words:
        l = word.lower()  # Use `word.casefold()` if possible. (3.3+)
        if l in seen:
            continue
        seen.add(l)
        yield word
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; list(uniq(['Hello', 'hello', 'world', 'world', 'Poland', 'poland']))
['Hello', 'world', 'Poland']
</code></pre>
<p><strong>UPDATE</strong></p>
<p>Previous version does not take care of preference of uppercase over lowercase. In the updated version I used the <code>min</code> as @TheSoundDefense did.</p>
<pre><code>import collections

def uniq(words):
    seen = collections.OrderedDict()  # Use {} if the order is not important.
    for word in words:
        l = word.lower()  # Use `word.casefold()` if possible (3.3+)
        seen[l] = min(word, seen.get(l, word))
    return seen.values()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since an uppercase letter is "smaller" than a lowercase letter in a comparison, I think you can do this:</p>
<pre><code>orig_list = ["Hello", "hello", "world", "world", "Poland", "poland"]
unique_list = []
for word in orig_list:
  for i in range(len(unique_list)):
    if unique_list[i].lower() == word.lower():
      unique_list[i] = min(word, unique_list[i])
      break
  else:
    unique_list.append(word)
</code></pre>
<p>The <code>min</code> will have a preference for words with uppercase letters earlier on.</p>
</div>
<div class="post-text" itemprop="text">
<p>Some better answers here, but hopefully something simple, different and useful. This code satisfies the conditions of your test, sequential pairs of matching words, but would fail on anything more complicated; such as non-sequential pairs, non-pairs or non-strings. Anything more complicated and I'd take a different approach. </p>
<pre><code>p1 = ['Hello', 'hello', 'world', 'world', 'Poland', 'poland']
p2 = ['hello', 'Hello', 'world', 'world', 'Poland', 'Poland']

def pref_upper(p):
    q = []
    a = 0
    b = 1

    for x in range(len(p) /2):
            if p[a][0].isupper() and p[b][0].isupper():
                    q.append(p[a])
            if p[a][0].isupper() and p[b][0].islower():
                    q.append(p[a])
            if p[a][0].islower() and p[b][0].isupper():
                    q.append(p[b])
            if p[a][0].islower() and p[b][0].islower():
                    q.append(p[b])
            a +=2
            b +=2
    return q

print pref_upper(p1)
print pref_upper(p2)
</code></pre>
</div>
<span class="comment-copy">which version of python are you using?</span>
<span class="comment-copy"><code>How should I do that?</code> - iterate over the list or look in the list to determine if there are duplicates then see if any of the duplicates are title case <code>str.istitle()</code> , keep the titlecase duplicates.</span>
<span class="comment-copy">@wwi <code>How should I do that</code> was just used as a polite way of asking suggestions on how I should approach my issue. For instance, I had never come across <code>istitle()</code> so thanks for the heads-up.</span>
<span class="comment-copy">@inspectorG4dget Python 2.7.6 64bit on Windows 7</span>
<span class="comment-copy">A compact and very elegant solution. +1 for maintaining the original order!</span>
<span class="comment-copy">How will this have a preference for capitalized words?</span>
<span class="comment-copy">@TheSoundDefense, I updated the answer. Thank you for pointing it. +1 your answer for original idea of using <code>min</code>.</span>
