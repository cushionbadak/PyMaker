<div class="post-text" itemprop="text">
<p>I am getting <code>UnicodeDecodeError</code> with the <code>traceback.print_exc(file=sys.stdout)</code>. I am using Python3.4 and did not get the problem with Python2.7. </p>
<p>Am I missing something here? How can I make sure that <code>sys.stdout</code> passes the correct encoded/decoded to the <code>traceback.print_exc()</code> ?</p>
<p>My code looks something similar to this:</p>
<pre><code>try:
    # do something which might throw an exception
except Exception as e:
    # do something
    traceback.print_exc(file=sys.stdout) # Here I am getting the error
</code></pre>
<p>Error log:</p>
<pre><code>  traceback.print_exc(file=sys.stdout)
  File "C:\Python34\lib\traceback.py", line 252, in print_exc
    print_exception(*sys.exc_info(), limit=limit, file=file, chain=chain)
  File "C:\Python34\lib\traceback.py", line 169, in print_exception
    for line in _format_exception_iter(etype, value, tb, limit, chain):
  File "C:\Python34\lib\traceback.py", line 153, in _format_exception_iter
    yield from _format_list_iter(_extract_tb_iter(tb, limit=limit))
  File "C:\Python34\lib\traceback.py", line 18, in _format_list_iter
    for filename, lineno, name, line in extracted_list:
  File "C:\Python34\lib\traceback.py", line 65, in _extract_tb_or_stack_iter
    line = linecache.getline(filename, lineno, f.f_globals)
  File "C:\Python34\lib\linecache.py", line 15, in getline
    lines = getlines(filename, module_globals)
  File "C:\Python34\lib\linecache.py", line 41, in getlines
    return updatecache(filename, module_globals)
  File "C:\Python34\lib\linecache.py", line 127, in updatecache
    lines = fp.readlines()
  File "C:\Python34\lib\codecs.py", line 313, in decode
    (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe7 in position 5213: invalid continuation byte
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The traceback module wants to include source code lines with the traceback. Normally, a traceback consists only of pointers to source code, not the source code itself, as Python has been executing the compiled bytecode. In the bytecode are hints as to exactly what source code line the bytecode came from.</p>
<p>To then show the sourcecode, the actual source is read from disk, using the <code>linecache</code> module. This also means that Python has to determine the encoding for those files too. The default encoding for a Python 3 source file is UTF-8, but you can set a <a href="http://legacy.python.org/dev/peps/pep-0263/" rel="nofollow">PEP 263 comment</a> to let Python know if you are deviating from that.</p>
<p>Because source code is read <em>after</em> the code is already loaded and a traceback took place, it is possible that you <em>changed</em> the source code after starting the script, <em>or</em> there was a byte cache file (in a <code>__pycache__</code> subdirectory) that appeared to be fresh but was no longer matching your source files.</p>
<p>Either way, when you started the script, Python was able to re-use a bytecache file or read the source code just fine and run your code. But when the traceback was being printed, at least <em>one</em> of the source code files was no longer decodable as UTF-8.</p>
<p>If you can reliably reproduce the traceback (so start the Python script again without encoding problems but printing the traceback fails), it is most likely a stale bytecode file somewhere, one that could even hold pointers to a filename that <em>now</em> contains nothing but binary data, not plain source. </p>
<p>If you know how to use the <a href="https://docs.python.org/3/library/pdb.html" rel="nofollow"><code>pdb</code> module</a>, add a <code>pdb.set_trace()</code> call before the <code>traceback.print_exc()</code> call and trace what filenames are being loaded from by the <code>linecache</code> module.</p>
<p>Otherwise <em>edit</em> your <code>C:\Python34\lib\traceback.py</code> file and insert a <code>print('Loading {} from the linecache'.format(filename))</code> statement just before the <code>linecache.checkcache(filename)</code> line in the <code>_extract_tb_or_stack_iter</code> function.</p>
</div>
<span class="comment-copy">What sourcecode encoding are you using for your modules?</span>
<span class="comment-copy">@MartijnPieters  I assume the default ASCII, as I do not specify any encoding in the sourcecode.</span>
<span class="comment-copy">The default is UTF-8, in Python 3. But one of your source files is (no longer) decodable as such.</span>
<span class="comment-copy">Notepad or so is at fault obviously... "default ASCII" - not.</span>
<span class="comment-copy">Really appreciate your input. Thanks. I will give it a try if I can reproduce the problem. What is also intriguing is that with Python 2.7 this was working well (I recently switched to Python3.4 to run my unittests and already got this problem couple of times).</span>
<span class="comment-copy">@sk11: This can happen in Python 2.7 just as much, really. The default source code encoding is ASCII on Python 2, making it <i>more likely</i> you run into issues.</span>
<span class="comment-copy">@sk11: In fact, the code that reads the files for the <code>linecache</code> module is virtually identical between Python 2.7 and 3.4, with the only difference being the default encoding when no comment is present.</span>
<span class="comment-copy">I was able to reproduce the problem and, as you suggested, put a print in the traceback.py From there I was able to find the culprit file which has a non-compliant character. Thanks.</span>
<span class="comment-copy">@sk11: Glad that worked! Presumably the file had been changed <i>after</i> Python had already loaded the source?</span>
