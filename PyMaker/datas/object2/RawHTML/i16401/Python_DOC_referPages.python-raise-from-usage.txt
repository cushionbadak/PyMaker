<div class="post-text" itemprop="text">
<p>What's the difference between <code>raise</code> and <code>raise from</code> in Python?</p>
<pre><code>try:
    raise ValueError
except Exception as e:
    raise IndexError
</code></pre>
<p>which yields</p>
<pre><code>Traceback (most recent call last):
  File "tmp.py", line 2, in &lt;module&gt;
    raise ValueError
ValueError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "tmp.py", line 4, in &lt;module&gt;
    raise IndexError
IndexError
</code></pre>
<p>and</p>
<pre><code>try:
    raise ValueError
except Exception as e:
    raise IndexError from e
</code></pre>
<p>which yields</p>
<pre><code>Traceback (most recent call last):
  File "tmp.py", line 2, in &lt;module&gt;
    raise ValueError
ValueError

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "tmp.py", line 4, in &lt;module&gt;
    raise IndexError from e
IndexError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The difference is that when you use <code>from</code>, the <em><code>__cause__</code> attribute</em> is set and the message states that the exception was <em>directly caused by</em>. If you omit the <code>from</code> then no <code>__cause__</code> is set, but the <em><code>__context__</code> attribute</em> may be set as well, and the traceback then shows the context as <em>during handling something else happened</em>.</p>
<p>Setting the <code>__context__</code> happens if you used <code>raise</code> in an exception handler; if you used <code>raise</code> anywhere else no <code>__context__</code> is set either.</p>
<p>If a <code>__cause__</code> is set, a <code>__suppress_context__ = True</code> flag is also set on the exception; when <code>__suppress_context__</code> is set to <code>True</code>, the <code>__context__</code> is ignored when printing a traceback.</p>
<p>When raising from a exception handler where you <em>don't</em> want to show the context (don't want a <em>during handling another exception happened</em> message), then use <code>raise ... from None</code> to set <code>__suppress_context__</code> to <code>True</code>.</p>
<p>In other words, Python sets a <em>context</em> on exceptions so you can introspect where an exception was raised, letting you see if another exception was replaced by it. You can also add a <em>cause</em> to an exception, making the traceback explicit about the other exception (use different wording), and the context is ignored (but can still be introspected when debugging). Using <code>raise ... from None</code> lets you suppress the context being printed.</p>
<p>See the <a href="https://docs.python.org/3/reference/simple_stmts.html#raise" rel="noreferrer"><code>raise</code> statement documenation</a>:</p>
<blockquote>
<p>The <code>from</code> clause is used for exception chaining: if given, the second <em>expression</em> must be another exception class or instance, which will then be attached to the raised exception as the <code>__cause__</code> attribute (which is writable). If the raised exception is not handled, both exceptions will be printed:</p>
<pre><code>&gt;&gt;&gt; try:
...     print(1 / 0)
... except Exception as exc:
...     raise RuntimeError("Something bad happened") from exc
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
ZeroDivisionError: int division or modulo by zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 4, in &lt;module&gt;
RuntimeError: Something bad happened
</code></pre>
<p>A similar mechanism works implicitly if an exception is raised inside an exception handler: &gt; the previous exception is then attached as the new exceptionâ€™s <code>__context__</code> attribute:</p>
<pre><code>&gt;&gt;&gt; try:
...     print(1 / 0)
... except:
...     raise RuntimeError("Something bad happened")
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
ZeroDivisionError: int division or modulo by zero

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 4, in &lt;module&gt;
RuntimeError: Something bad happened
</code></pre>
</blockquote>
<p>Also see the <a href="https://docs.python.org/3/library/exceptions.html#built-in-exceptions" rel="noreferrer">Built-in Exceptions documentation</a> for details on the context and cause information attached to exceptions.</p>
</div>
<span class="comment-copy">Have you read <a href="http://legacy.python.org/dev/peps/pep-3134/" rel="nofollow noreferrer">PEP-3134</a>?</span>
<span class="comment-copy">Now use <code>raise IndexError from None</code>, say.</span>
<span class="comment-copy">Heh. <code>raise IndexError from False</code> raises a <code>TypeError</code>, not an <code>IndexError</code>. Made my day.</span>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/11235932/what-is-the-difference-between-cause-and-context">What is the difference between __cause__ and __context__?</a></span>
<span class="comment-copy">Is there any reason to explicitly chain the exceptions using <code>from</code> and <code>__cause__</code> in lieu of the implicit <code>__context__</code>?  Are there any cases where one would attach a different exception than the one caught by the <code>except</code>?</span>
<span class="comment-copy">@darkfeline: Lets say your database API supports opening databases from various sources, including the web and disk. Your API will <i>always</i> raise a <code>DatabaseError</code> if opening the database fails. But if the failure is the result of a <code>IOError</code> because a file failed to open or a <code>HTTPError</code> because a URL failed to work then that is context you want to include explicitly, so the developer using the API can debug why this is. At that moment you use <code>raise DatabaseError from original_exception</code>.</span>
<span class="comment-copy">@darkfeline: If that developer is wrapping the use of the database API in their own API and wanted to pass on that <code>IOError</code> or <code>HTTPError</code> on to <i>their</i> consumers, then they'd have to use <code>raise NewException from databaseexception.__cause__</code>, now using a different exception from the <code>DatabaseException</code> that they just caught.</span>
<span class="comment-copy">@dan3: no, there isn't. Exception chaining is purely a Python 3 feature.</span>
<span class="comment-copy">@laike9m: you mean when you are handling exception <code>foo</code>, and want to raise a <i>new</i> exception <code>bar</code>? Then you can use <code>raise bar from foo</code> and have Python state that <code>foo</code> <i>directly caused <code>bar</code></i>. If you <i>don't</i> use <code>from foo</code>, then Python will still print both, but state that <i>during handling <code>foo</code>, <code>bar</code> was raised</i>, Different message, intended to flag a possible bug in the error handling.</span>
