<div class="post-text" itemprop="text">
<p>Is there a way to force a Python 3 unittest to fail, rather than simply print a warning to stderr, if it causes any ResourceWarning?</p>
<p>I've tried the following:</p>
<pre><code>import warnings
warnings.simplefilter(action='error', category=ResourceWarning)
</code></pre>
<p>Which results in this output from unittest:</p>
<pre><code>my_test (__main__.MyTest) ... Exception ignored in: &lt;socket.socket fd=9, family=AddressFamily.AF_INET, type=SocketType.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 54065), raddr=('127.0.0.1', 27017)&gt;
ResourceWarning: unclosed &lt;socket.socket fd=9, family=AddressFamily.AF_INET, type=SocketType.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 54065), raddr=('127.0.0.1', 27017)&gt;
ok

----------------------------------------------------------------------
Ran 1 test in 0.110s
</code></pre>
<p>Note the "Exception ignored" message. I'd rather the test failed, instead of requiring me to read its output looking for ResourceWarnings.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a unit test that fails if <code>ResourceWarning</code> is generated by the code in <code>with catch_warning()</code> statement:</p>
<pre><code>#!/usr/bin/env python3
import gc
import socket
import unittest
import warnings

class Test(unittest.TestCase):
    def test_resource_warning(self):
        s = socket.socket()
        ####s.close() #XXX uncomment to pass the test

        # generate resource warning when s is deleted
        with warnings.catch_warnings(record=True) as w:
            warnings.resetwarnings() # clear all filters
            warnings.simplefilter('ignore') # ignore all
            warnings.simplefilter('always', ResourceWarning) # add filter
            del s        # remove reference
            gc.collect() # run garbage collection (for pypy3)
            self.assertFalse(w and str(w[-1])) # test fails if there
                                               # are warnings

if __name__=="__main__":
    unittest.main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>
Unfortunately, it doesn't appear to be possible.  That "Exception ignored in:" message is produced by the CPython function <code>PyErr_WriteUnraisable</code> in <code>Python/errors.c</code>.  The comment before that function states:</p>
<pre class="lang-none prettyprint-override"><code>/* Call when an exception has occurred but there is no way for Python
   to handle it.  Examples: exception in __del__ or during GC. */
</code></pre>
<p>The <code>ResourceWarning</code> is indeed being generated during garbage collection, and Python prints a message because it doesn't have a way to raise an exception at that point.  This has to do with the core CPython implementation and there is nothing that unittest can do to override it.</p>
<p><strong>Update:</strong> while the above is a correct technical analysis, there is another approach that will actually solve the OP's problem.  See the <a href="https://stackoverflow.com/a/25067818/3573385">answer</a> by J.F. Sebastian for more details.</p>
</div>
<span class="comment-copy">How about using <code>warnings.catch_warnings</code> context manager described in section <a href="https://docs.python.org/3/library/warnings.html#testing-warnings" rel="nofollow noreferrer">29.5.4. Testing Warnings</a>?</span>
<span class="comment-copy">No, I tried that. Daniel Harding showed below why ResourceWarnings are special and can't be detected the normal ways.</span>
<span class="comment-copy">I had read Daniel's answer before posting yet I'm not sure there's nothing more to the subject. Specifically his answer is based on the analysis of <code>Exception ignored in: (...)</code> which I believe is the result of using <i>simplefilter</i> with <code>action-'error'</code> by you. It doesn't mean there couldn't be another way to get hold on warnings, which wouldn't relay on converting them to exceptions thus avoiding unfortunate behavior of <code>PyErr_WriteUnraisable</code>.</span>
<span class="comment-copy">@PiotrDobrogost - thanks for making me aware of <code>warnings.catch_warnings</code>.  That looks like a great way to solve this problem.</span>
<span class="comment-copy">This looks like a great solution - I was not aware of <code>warnings.catch_warnings</code> when I wrote my answer.</span>
<span class="comment-copy">Nice work, thanks.</span>
<span class="comment-copy">For the sake of context, in case of socket object in Python 3.4.1, <code>PyErr_WriteUnraisable</code> is being called at <a href="http://hg.python.org/cpython/annotate/c0e311e010fc/Modules/socketmodule.c#l3857" rel="nofollow noreferrer">hg.python.org/cpython/annotate/c0e311e010fc/Modules/â€¦</a> and <code>PyErr_WriteUnraisable</code> is defined at <a href="http://hg.python.org/cpython/file/c0e311e010fc/Python/errors.c#l865" rel="nofollow noreferrer">hg.python.org/cpython/file/c0e311e010fc/Python/errors.c#l865</a></span>
