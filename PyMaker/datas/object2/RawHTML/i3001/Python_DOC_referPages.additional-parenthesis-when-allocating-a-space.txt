<div class="post-text" itemprop="text">
<p>I have the following line in a code. I know more or less what it does - allocates some memory for an array of buffers. I am trying to investigate the meaning of the syntax - what are the additional parenthesis used for? The content inside the first parenthesis doesn't look like a function. I saw that the construct of double parentheses is used if one function is embedded in another one, but it still doesn't look like that. Moreover when deleting no_ofBuffers variable (as if it was just 1) does not make a 1 - buffer array, the variable itself is necessary, otherwise in next parts of the code the application crashes.</p>
<pre><code>buffers = (ct.POINTER(ct.c_int8*buf_size)*no_ofBuffers)()
</code></pre>
<p>Does somebody have more experience with constructs like that?</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, here's the official <em>ctypes</em> doc page: <a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer">[Python]: ctypes - A foreign function library for Python</a> (you might want to take a look at the <strong>Arrays</strong> section).<br/></p>
<p>The rule that always applies when dealing a complex expression is: break it in simpler ones. I'm going to start from the inside (pointing all the intermediary steps), and do it in a <em>Python</em> console (also changing some variable names for clarity):</p>
<blockquote>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; "Python {:s} on {:s}".format(sys.version, sys.platform)
'Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32'
&gt;&gt;&gt;
&gt;&gt;&gt; # Dummy values for numeric constants
...
&gt;&gt;&gt; INNER_ARR_SIZE = 8  # Replacement for buf_size
&gt;&gt;&gt; OUTER_ARR_SIZE = 10  # Replacement for no_ofBuffers
&gt;&gt;&gt;
&gt;&gt;&gt; # Declare all intermediary types
...
&gt;&gt;&gt; Int8Arr = ctypes.c_int8 * INNER_ARR_SIZE  # Innermost "()"
&gt;&gt;&gt; Int8ArrPtr = ctypes.POINTER(Int8Arr)  # Pointer
&gt;&gt;&gt; Int8ArrPtrArr = Int8ArrPtr * OUTER_ARR_SIZE  # Outermost "()"
&gt;&gt;&gt;
&gt;&gt;&gt; # Use a human readable name for our final type
...
&gt;&gt;&gt; Buffers = Int8ArrPtrArr
&gt;&gt;&gt;
&gt;&gt;&gt; Buffers
&lt;class '__main__.LP_c_byte_Array_8_Array_10'&gt;
&gt;&gt;&gt; type(Buffers)
&lt;class '_ctypes.PyCArrayType'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; # At the end just instantiate the new type (that's what the "()" at the end do) to a default constructed value
...
&gt;&gt;&gt; buffers = Buffers()  # THIS is the equivalent of your (complex) expression
&gt;&gt;&gt; buffers
&lt;__main__.LP_c_byte_Array_8_Array_10 object at 0x00000235F614A9C8&gt;
&gt;&gt;&gt; type(buffers)
&lt;class '__main__.LP_c_byte_Array_8_Array_10'&gt;
&gt;&gt;&gt; len(buffers)
10
&gt;&gt;&gt;
&gt;&gt;&gt; # It's similar to what the line below does
...
&gt;&gt;&gt; i = ctypes.c_int()
&gt;&gt;&gt; i
c_long(0)
</code></pre>
</blockquote>
</div>
<span class="comment-copy">Thank you, very well explained. The most confusing operation I find multiplication of a type and the magical result - an array out of it. But maybe this is a common trick in python.</span>
<span class="comment-copy">Yes, <i>ctypes</i> types inherit <i>Python</i> sequence types behavior, e.g.: <code>[8] * 3</code> will yield <code>[8, 8, 8]</code>.</span>
<span class="comment-copy"><i>BTW</i>: Could you please mark the answer as a solution, so others are also aware that it solved your problem?</span>
<span class="comment-copy">Ok, thank you once again. I forgot about it, it is my first input into stackoverflow.</span>
<span class="comment-copy">You're welcome! And, thank you! :)</span>
