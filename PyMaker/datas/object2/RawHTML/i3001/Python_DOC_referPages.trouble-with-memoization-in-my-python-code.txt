<div class="post-text" itemprop="text">
<p>I've read many examples of memoization online but have still been unable to successfully apply it to what I'm doing. I tried my best to write the memoization portion of this code using my own logic, but based on my tests as I run it each time, it is not working. Below is an example of a simple version of my code, which I wrote just to test the memoization concept since my actual code takes a while to run.</p>
<pre><code>import numpy as np
import time
good_data = np.array([1, 43, 22, 55, 14, 85, 23, 13, 4, 9, 21])

def image_urls(number):
    img_urls, img_data = [], []
    rows = 40
    for row in range(rows):
        path = '/%d1wxyz' % number
        url = 'http' + path
        img_urls.append(url)
    for obj in img_urls:
        for image in obj:
            data_pts = np.array([[1, 1, 1], [2, 2, 2], [number, number, number]])
            img_data.append(data_pts)
    return img_urls, img_data

cached_urls, cached_data = {}, {}
def images_data_pts(image_urls):
    t1 = time.time()
    print(np.array_equal(np.array([int(n) for n in cached_urls.keys()]), good_data))
    print(np.array_equal(np.array([int(n) for n in cached_data.keys()]), good_data))
    if np.array_equal(np.array([int(n) for n in cached_urls.keys()]), good_data) == False or np.array_equal(np.array([int(n) for n in cached_data.keys()]), good_data) == False:
        for number in good_data:
            cached_urls[str(number)], cached_data[str(number)] = image_urls(number)
    t2 = time.time()
    print('Time elapsed = ' + str(t2-t1))
    return cached_urls, cached_data

complete_urls, complete_data = images_data_pts(image_urls)

print(np.array_equal(np.array([int(n) for n in cached_urls.keys()]), good_data))
print(np.array_equal(np.array([int(n) for n in cached_data.keys()]), good_data))
</code></pre>
<p>The last two <code>print</code> statements are both outputting <code>True</code> after I've already run the script once, but I want the information to be stored in the cache after I just run it once so that I don't have to actually execute what the function is doing each time. I think it might have something to do with the fact that it's redefining <code>cached_urls</code> and <code>cached_data</code> as empty dictionaries each time I run it, perhaps effectively undoing the memoization. But I saw this technique in examples, and I'm not sure how I would structure it otherwise. Please let me know if you have any tips!</p>
</div>
<div class="post-text" itemprop="text">
<p>When a program starts, it starts with a clean slate. That's fundamental to the way both Unix and Windows work.<sup>1</sup> If you want anything to persist from one run to a future run, you need to store it somewhere, and load it back.</p>
<p>This is covered in the official Python tutorial in the <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" rel="nofollow noreferrer">files</a> section.</p>
<p>The basic idea is simple:</p>
<ul>
<li>Right after your program starts, open a file and read your memo cache (and if the file doesn't exist, just start with <code>{}</code>).</li>
<li>Right before your program finishes, open the same file in write mode and write your memo cache.</li>
</ul>
<p>As for how to read it and write it: </p>
<p>I suspect your memo cache is JSON-compatible, based on the names (<code>cached_urls</code> sounds like it would be mapping strings to string…). If so, <a href="https://docs.python.org/3/tutorial/inputoutput.html#saving-structured-data-with-json" rel="nofollow noreferrer">store it as JSON</a>, as shown in the tutorial. If not, see the <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer"><code>pickle</code></a> module, which has the same API but can handle things JSON can't.<sup>2</sup></p>
<hr/>
<p><sub>1. Imagine if that <em>weren't</em> true. Any time you crash a program, when you restart it, it'll come up in exactly the same state as when it crashed, so it's almost certain to immediately crash again… The only way to recover would be to uninstall and reinstall.</sub></p>
<p><sub>2. This flexibility can be a security risk for code you're going to distribute or deploy, but for code you just run yourself with data that only comes from your own computer, it's fine.</sub></p>
</div>
<span class="comment-copy">What is this code trying to accomplish?  The generic variable names don't help me understand the flow.  Also, I get <code>False</code> for all four <code>print</code> outputs.</span>
<span class="comment-copy">Mine prints two False and Two True</span>
