<div class="post-text" itemprop="text">
<p>How does the function <a href="https://docs.python.org/3/library/functions.html#hash" rel="nofollow noreferrer"><code>hash()</code></a> compute the hash value of a tuple? For example:</p>
<pre><code>t = (1,2,3)
print(hash(t))
</code></pre>
<p>Gives an output</p>
<pre><code>-378539185
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can check the <a href="https://github.com/python/cpython/blob/22d25085db2590932b3664ca32ab82c08f2eb2db/Objects/tupleobject.c#L348" rel="nofollow noreferrer">implementation of this function in C</a> if you're familiar with C programming and some advanced math. It seems that algorithm XORs hashes of each element in tuple and adds some magic.</p>
<pre class="lang-c prettyprint-override"><code>static Py_hash_t
tuplehash(PyTupleObject *v)
{
    Py_uhash_t x;  /* Unsigned for defined overflow behavior. */
    Py_hash_t y;
    Py_ssize_t len = Py_SIZE(v);
    PyObject **p;
    Py_uhash_t mult = _PyHASH_MULTIPLIER;
    x = 0x345678UL;
    p = v-&gt;ob_item;
    while (--len &gt;= 0) {
        y = PyObject_Hash(*p++);
        if (y == -1)
            return -1;
        x = (x ^ y) * mult;
        /* the cast might truncate len; that doesn't change hash stability */
        mult += (Py_hash_t)(82520UL + len + len);
    }
    x += 97531UL;
    if (x == (Py_uhash_t)-1)
        x = -2;
    return x;
}
</code></pre>
<p>Note that this is CPython's <em>current</em> implementation. Other Python interpreters and even other versions of CPython may have different hash functions. This particular implementation, called SipHash, has been in use since 2013. See <a href="https://www.python.org/dev/peps/pep-0456/" rel="nofollow noreferrer">PEP 456 -- Secure and interchangeable hash algorithm</a> for a detailed explanation.</p>
<blockquote>
<p>SipHash is a cryptographic pseudo random function with a 128-bit seed and 64-bit output.... SipHash is a family of pseudorandom functions (a.k.a. keyed hash functions) optimized for speed on short messages. Target applications include network traffic authentication and defense against hash-flooding DoS attacks.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/functions.html#hash" rel="nofollow noreferrer">standard library documentation</a> has a little bit of detail.  Hash functions generally have the properties:</p>
<ol>
<li>If two values are equal, they always have the same hash value; and</li>
<li>If two values are different, they probably have different hash values.</li>
</ol>
<p>There are simpler and harder ways to write these, and faster and slower ways, but the important thing is how rarely different values produce the same hash value.  A good one is tricky, but you usually don't care deeply about the implementation.</p>
<p>(In Python you almost never need to directly call <code>hash()</code>; I wouldn't be surprised if it's part of the dictionary implementation for custom types used as keys.  The <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>Object.__hash__()</code> documentation</a> says quite a bit more.)</p>
</div>
<span class="comment-copy">the important part is that Python progressively takes the hash of each element of the tuple and combines that into a rolling hash value that becomes the final result.</span>
<span class="comment-copy">also, the code above is not the core SipHash algorithm.</span>
<span class="comment-copy">The OP asked for specific detail about how the hash of a <i>tuple</i> is calculated, not about hashes in general.</span>
