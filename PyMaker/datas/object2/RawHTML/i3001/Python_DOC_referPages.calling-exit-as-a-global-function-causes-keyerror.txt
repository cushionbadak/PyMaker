<div class="post-text" itemprop="text">
<p>I'm writing a module manager for a program that I am writing now, and I wanted to store the module names in a dictionary then reference them and call them from <code>globals()</code>.</p>
<pre><code>module_number = 5
module_names  = ["", "quiz", "scores", "gender", "help", "exit"]
</code></pre>
<p>I would then expect that I can call</p>
<pre><code>globals()[module_names[module_number]]()
</code></pre>
<p>Which would call <code>exit()</code> and close the script, instead I get the resulting error:</p>
<blockquote>
<p>Traceback (most recent call last): File "a2.py", line 103, in  start() File "a2.py", line 44, in start menu() File "a2.py", line 36, in menu call_module(choice) File "a2.py", line 50, in call_module globals()converter[int(module_number)]</p>
<p><strong>KeyError: 'exit'</strong></p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><code>exit</code> isn't in <code>globals()</code> because it isn't a global, it's a builtin.</p>
<p>In Python, the "global" namespace is per-module, not system-wide. There's a special "builtins" module that holds the things that are truly system-wide, like <a href="https://docs.python.org/3/library/functions.html" rel="nofollow noreferrer">the normal builtin functions</a> and a few special things like <code>exit</code>.</p>
<hr/>
<p>You can access this module with <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow noreferrer"><code>import builtins</code></a>.</p>
<p>The way the interpreter accesses this module is a little funky. Global lookup works roughly like this:</p>
<pre><code>def get_global(global_namespace, name):
    try:
        return global_namespace[name]
    except KeyError:
        pass
    try:
        builtins = global_namespace['__builtins__']
    except KeyError:
        raise NameError(name)
    if isinstance(builtins, types.ModuleType):
        builtins = builtins.__dict__
    try:
        return builtins[name]
    except KeyError:
        raise NameError(name)
</code></pre>
<p>There's special code in places like <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code></a>, and the internal code for building function objects, that makes sure that if you override the normal <code>globals</code> dictionary, <code>__builtins__</code> gets copied over (unless you explicitly tell it not to). When the import system builds a module object out of your module source (or compiled <code>.pyc</code>), it calls <code>exec</code>, so every module's globals ends up with the right <code>__builtins__</code>.</p>
<hr/>
<p>Most things in the <code>builtins</code> module are there because they're compiled into it (as you'd expect from the name); for CPython, you can see the source in <a href="https://github.com/python/cpython/blob/master/Python/bltinmodule.c" rel="nofollow noreferrer"><code>Python/bltinmodule.c</code></a>.</p>
<p>But notice that <code>exit</code> isn't there. In fact, it's injected into the <code>builtins</code> module by the <a href="https://docs.python.org/3/library/site.html" rel="nofollow noreferrer"><code>site</code></a> module, which is imported (unless you disable it) as part of the normal startup sequence. You can see the code that does this in <a href="https://github.com/python/cpython/blob/3.7/Lib/site.py#L353" rel="nofollow noreferrer"><code>Lib/site.py</code></a> and <a href="https://github.com/python/cpython/blob/master/Lib/_sitebuiltins.py#L13" rel="nofollow noreferrer"><code>Lib/_sitebuiltins.py</code></a>. And the <a href="https://docs.python.org/3/library/constants.html#exit" rel="nofollow noreferrer"><code>exit</code></a> constant says it's injected this way.</p>
<hr/>
<p>So, when you type <code>exit</code> in your code, or at the interactive prompt, it's found in <code>globals()['__builtins__']['exit']</code> or <code>globals()['__builtins__'].__dict__['exit']</code>.</p>
<p>But if you want to access it manually, you're better off doing an <code>import builtins</code> and accessed it as <code>builtins.exit</code>.</p>
<p>Although really, you rarely want to access <code>builtins.exit</code> anyway; if you want to exit programmatically, call <a href="https://docs.python.org/3/library/sys.html#sys.exit" rel="nofollow noreferrer"><code>sys.exit</code></a>, which is a normal function. <code>builtins.exit</code> is a special <code>Quitter</code> object that's made specifically for interactive use. (It has a <code>repr</code> that gives a helpful message if you forget the parentheses, and some extra code to make it play nice with IDLE.)</p>
<p>In fact, the docs on the <a href="https://docs.python.org/3/library/constants.html#exit" rel="nofollow noreferrer"><code>exit</code></a> constant explicitly say that it's:</p>
<blockquote>
<p>… useful for the interactive interpreter shell and should not be used in programs.</p>
</blockquote>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/q/6501121/674039">Difference between exit() and sys.exit() in Python</a></span>
<span class="comment-copy">-1 exit is not really in the builtins.  it's injected by site.  if you run <code>python -S</code> to disable site, you'll find that exit is not there..</span>
<span class="comment-copy">@wim It <i>is</i> in <code>builtins</code>. The fact that it's injected there, rather than being part of <code>bltinmodule.c</code>, doesn't change that fact. But if you think my answer isn't long enough, I can always add even more information…</span>
<span class="comment-copy">"it's a builtin" is misleading or glossing over -  it's an instance of <a href="https://github.com/python/cpython/blob/80b762f010097ab8137782e5fbdc89c5c620ed4e/Lib/_sitebuiltins.py#L13-L26" rel="nofollow noreferrer"><code>Quitter</code></a> patched in by site.  Kind of different than being a built-in IMO.</span>
<span class="comment-copy">@wim I don't think it's at all misleading. It's a callable object in <code>builtins</code>. And I already differentiated it from "the normal builtin functions" in the first paragraph, and explained how it's not just a function at the end. But to make you happy, I added a section about how it ends up in <code>builtins</code> (at least in CPython and PyPy).</span>
<span class="comment-copy">@wim Also, would you say that, e.g., <code>SyntaxError</code> isn't built in because in Python 3 the builtin exceptions are injected into <code>builtin</code>, not compiled into the module?</span>
