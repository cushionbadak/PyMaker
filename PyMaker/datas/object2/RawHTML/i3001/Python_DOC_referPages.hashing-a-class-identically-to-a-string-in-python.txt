<div class="post-text" itemprop="text">
<p>I have a helper class to help with string methods. It has a bunch of methods and variables but I want the underlying hash to based on the contents of its 'main' string. So the class looks something similar to this:</p>
<pre><code>class Topic:

    def __init__(self, name):
        self.name = name

    def getName(self):
        return self.name

    def setName(self, newName):
        self.name = newName

    def __str__(self):
        return self.name
</code></pre>
<p>however I want a dictionary to hash this object as a string so when I do the following code:</p>
<pre><code>a = Topic('test')
v = {a : 'oh hey'}

print(v[Topic('test')])
</code></pre>
<p>I want it to print 'oh hey' instead of throwing a key error. I tried doing this to my Topic class:</p>
<pre><code>def __hash__(self):
    return hash(self.name)
</code></pre>
<p>but it didn't work and I can't find online how Python hashes their strings. Is there anyway to make this work the way I intend? Thanks for any information.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you read <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">the documentation on <code>__hash__</code></a>, it explains what's going on, and how to fix it:</p>
<blockquote>
<p>If a class does not define an <code>__eq__()</code> method it should not define a <code>__hash__()</code> operation either…</p>
</blockquote>
<p>If two values hash the same, but aren't equal, they're not the same key as far as a dict is concerned, they're two different values that happened to have a hash collision. So, your <code>Topic</code> values are still keyed by identity (you can only look up a <code>Topic</code> with the exact same instance, not another instance with the same name), you're just making it less efficient.</p>
<p>To fix that, you want to add an <code>__eq__</code> method that makes two <code>Topic</code>s equal if they have the same <code>name</code>.</p>
<pre><code>def __eq__(self, other):
    return self.name == other.name
</code></pre>
<p>But there are two problems with this.</p>
<hr/>
<p>First, your <code>Topic</code> objects will now hash the same as their names—but they won't be equal to them. That probably isn't what you want.</p>
<p>If you want to be able to look up a topic by just using the string as a key, you need to change the <code>__eq__</code> method to handle that:</p>
<pre><code>def __eq__(self, other):
    return self.name == other or self.name == other.name
</code></pre>
<p>Or, if you want two <code>Topic</code>s with the same name to work like the same key, but not the name itself, you need to change <code>__hash__</code> to something like this:</p>
<pre><code>def __hash__(self):
    return hash((type(self), self.name))
</code></pre>
<p>So, two <code>Topic</code> values with the name <code>'spam'</code> will both get hashed as <code>(Topic, "spam")</code>, and will match each other, but won't match the hash of <code>"spam"</code> itself.</p>
<hr/>
<p>The second problem is more serious.</p>
<p>Your <code>Topic</code> objects are mutable. In fact, by using getters and setters (which you usually don't want in Python), you're explicitly calling out that you want people to be able to mutate the <code>name</code> of a <code>Topic</code>.</p>
<p>But if you do that, the same <code>Topic</code> no longer has the same hash value, and no longer equals its original value. This will break any dictionary you'd put it in.</p>
<pre><code>&gt;&gt;&gt; v = {a: 'oh hey'}
&gt;&gt;&gt; a.setName('test2')
&gt;&gt;&gt; v
KeyError: &lt;__main__.Topic object at 0x12370b0b8&gt;
</code></pre>
<p>This is covered in the same docs:</p>
<blockquote>
<p>If a class defines mutable objects and implements an <code>__eq__()</code> method, it should not implement <code>__hash__()</code>, since the implementation of hashable collections requires that a key’s hash value is immutable (if the object’s hash value changes, it will be in the wrong hash bucket).</p>
</blockquote>
<p>This is why the only builtin collections that are hashable are the immutable ones.</p>
<p>Occasionally, this is worth subverting. If you have an type that's mutable in general, but you know you're never going to mutate one of them after it's stored or looked up in a dict, you can, basically, lie to Python and tell it your type is immutable and therefore suitable as a dict key by defining a <code>__hash__</code> and <code>__eq__</code> that <em>would</em> break if you mutated the object, but isn't going to break because you're never going to do that.</p>
<p>But usually, you want to follow the rule that if you want something to be a key, it should be immutable.</p>
<p>Usually it's sufficient to just make it "immutable by convention". For example, if you make <code>name</code> "private by convention" by renaming it to <code>_name</code>, and get rid of the <code>setName</code> method and have only <code>getName</code>, your existing class (with the added <code>__hash__</code> and <code>__eq__</code> methods) is fine. Sure, someone <em>could</em> break your dicts by changing the private attribute's value out from under you, but you can expect your users to be "consenting adults" and not do that unless they have a good reason.</p>
<hr/>
<p>One last thing, while we're at it: You almost always want to define a <code>__repr__</code> for a class like this. Notice the error we got above complained about <code>&lt;__main__.Topic object at 0x12370b0b8&gt;</code>? Likewise, if you just evaluate <code>a</code> at the interactive prompt, or <code>print(v)</code>, even without any problems, the <code>Topic</code> is going to show up like this. That's because <code>__str__</code> only affects <code>str</code>, not <code>repr</code>. The usual pattern is:</p>
<pre><code>def __repr__(self):
    return f"{type(self).__name__}({self.name!r})"
</code></pre>
<p>Now, you'll see something like <code>Topic("spam")</code> instead of <code>&lt;__main__.Topic object at 0x12370b0b8&gt;</code>.</p>
<hr/>
<p>You may want to take a look at <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer"><code>@dataclass</code></a>, <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a>, or a third-party library like <a href="https://pypi.org/project/attrs/" rel="nofollow noreferrer"><code>attrs</code></a> that can automatically write all of these methods—<code>__init__</code>, <code>__hash__</code>, <code>__eq__</code>, <code>__repr__</code>, and others—for you, and ensure that they all work together properly.</p>
<p>For example, this could replace your entire class definition:</p>
<pre><code>@dataclass(frozen=True)
class Topic:
    name: str
</code></pre>
<p>Because it's <code>frozen</code>, it will use a tuple of its attributes—which is just <code>name</code>—for hashing and comparisons.</p>
</div>
<div class="post-text" itemprop="text">
<p>In order to make something in Python custom-made hashable we need to not just give it a custom hash function but also make it able to be compared to another version of its same type so the updated code(that works) is as follows:</p>
<pre><code>class Topic:

    def __init__(self, name):
        self.name = name;

    def getName(self):
        return self.name

    def setName(self, newName):
        self.name = newName

    def __str__(self):
        return self.name;

    def __eq__(self, other):
        return self.name == other.name

    def __hash__(self):
        return hash(self.name)
</code></pre>
<p>EDIT:</p>
<p>@abarnert pointed out something very wrong with this approach. See the comments below(or his very thorough answer) to understand why you SHOULD NOT do this. It will work but it is deceivingly dangerous and should be avoided.</p>
</div>
<span class="comment-copy">I would expect <code>hash(self.name)</code> to work just fine, what's the error? Note you also need to implement <code>__eq__</code> to put something in a dictionary.</span>
<span class="comment-copy">No, there are plenty of examples already. See e.g. <a href="https://stackoverflow.com/q/7560172/3001761">stackoverflow.com/q/7560172/3001761</a>, <a href="https://stackoverflow.com/q/4901815/3001761">stackoverflow.com/q/4901815/3001761</a>.</span>
<span class="comment-copy">This is probably a bad idea. If you use a Topic as a key, then call <code>setName</code> on it, you’ve broken the dictionary. It was bashed under the old name, but it no longer has that hash value. This is why, of the builtin containers, only the immutable ones are hashable. The fact that you have an explicit setter for name (getters and setters are almost never needed, or wanted, in Python) just calls out that you want people to modify these things and break your dictionaries.</span>
<span class="comment-copy">I am hoping I am not too dumb and that this will help a few people. I searched for a little while and couldn't find anything near what I was asking even though I know there are answers out there. This is hugely appreciated and gave me a ton more insight on the situation than I was even hoping to get. Thank you!</span>
<span class="comment-copy">@Luke Yeah, the information is buried in the reference docs, which not many people read for fun. :) But it really is worth reading the docs on the special methods you want to override, because there are a lot of non-obvious things in there.</span>
<span class="comment-copy">This code only works as long as you never call <code>setName</code>. Try inserting some of these into your dict as keys, then calling <code>setName</code> on them, then trying to look them up, iterate the dict, add a new key that has the name the old one used to have, etc.</span>
<span class="comment-copy">Also: your Topic will hash identically to a string that matches its <code>name</code>, but it won’t be equal to that string, only to another Topic with the same name. Is that really want you want? Usually for cases like this you want two Topics with the same name to hash the same as each other, but you don’t want them to hash the same as the name itself. You can do that by hashing something else, like <code>type(self)</code>, together with <code>self.name</code> (just hash a tuple of two things to combine the hashes).</span>
<span class="comment-copy">@abarnert If u want to add all this information to an answer so I can accept it I would gladly do so. This is super eye opening for me as someone coming from Java. I can add your comments to my existing answer but I rather credit to you.</span>
