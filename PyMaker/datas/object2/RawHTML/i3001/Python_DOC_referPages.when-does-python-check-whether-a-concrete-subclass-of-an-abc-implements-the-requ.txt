<div class="post-text" itemprop="text">
<p>While trying to write unittests that check whether a concrete subclass of an Abstract base class really does raise a TypeError upon instantiation if one of the required methods is not implemented, I stumbled upon something which made me wonder when the check if the required methods is defined by the concrete subclass is actually performed.</p>
<p>Until now I would have said: upon instantiation of the object, since this is the time when the Exception is actually raised when running the program.</p>
<p>But look at this snippet:</p>
<pre><code>import abc

class MyABC(abc.ABC):
    @abstractmethod
    def foo(self): pass

MyConcreteSubclass(MyABC):
    pass
</code></pre>
<p>As expected, trying to instantiate MyConcreteSubclass raises a TypeError:</p>
<pre><code>&gt;&gt;&gt; MyConcreteSubclass()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-39-fbfc0708afa6&gt; in &lt;module&gt;()
----&gt; 1 t = MySubclass()

TypeError: Can't instantiate abstract class MySubclass with abstract methods foo
</code></pre>
<p>But what happens if I declare a valid subclass at first and then afterwards delete this method surprises me:</p>
<pre><code>class MyConcreteSubclass(MyABC):
    def foo(self):
        print("bar")

MyConcreteSubclass.foo
--&gt; &lt;function __main__.MyConcreteSubclass.foo(self)&gt;


&gt;&gt;&gt; t = MyConcreteSubclass()
&gt;&gt;&gt; t.foo()
bar

&gt;&gt;&gt; del MyConcreteSubclass.foo
&gt;&gt;&gt; MyConcreteSubclass.foo
&lt;function __main__.MyABC.foo(self)&gt;

&gt;&gt;&gt; t = MyConcreteSubclass()
&gt;&gt;&gt; print(t.foo())
None
</code></pre>
<p>This is certainly not what I expected. When inspecting MyConcreteSubclass.foo after deletion, we see that through the method Resolution order the Abstract method of the base class is retrieved, which is the same behaviour as if we haven't implemented foo in the concrete subclass in the first place.</p>
<p>But after instantiation the TypeError is not raised.
So I wonder, are the checks whether the required methods are implemented already performed when the body of the concrete subclass is evaluated by the Interpreter?
If so, why are the TypeErrors only raised when someone tries to instantiate the subclass?</p>
<p>The Tests shown above were performed using Python 3.6.5.</p>
</div>
<div class="post-text" itemprop="text">
<p>It happens at class creation time. In Python 3.7, it's in C, in <a href="https://github.com/python/cpython/blob/v3.7.0/Modules/_abc.c#L257" rel="noreferrer"><code>compute_abstract_methods</code></a> in <code>Modules/_abc.c</code>, which is called as part of <code>ABCMeta.__new__</code>.</p>
<p>Incidentally, the <a href="https://docs.python.org/3/library/abc.html#abc.abstractmethod" rel="noreferrer">docs</a> do mention that</p>
<blockquote>
<p>Dynamically adding abstract methods to a class, or attempting to modify the abstraction status of a method or class once it is created, are not supported.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/51583480/908494">user2357112's answer</a> covers the main question here, but there's a secondary question:</p>
<blockquote>
<p>why are the TypeErrors only raised when someone tries to instantiate the subclass?</p>
</blockquote>
<p>If a <code>TypeError</code> were raised earlier, at class creation time, it would be impossible to create hierarchies of ABCs:</p>
<pre><code>class MyABC(abc.ABC):
    @abstractmethod
    def foo(self): pass

class MySecondABC(MyABC):
    @abstractmethod
    def bar(self): pass
</code></pre>
<p>You don't want that to raise a <code>TypeError</code> because <code>MySecondABC</code> doesn't define <code>foo</code>, unless someone tries to instantiate <code>MySecondABC</code>.</p>
<p>What if it were legal only for classes that added new abstract methods? Then it would be possible to create ABC hierarchies, but it would be impossible to create intermediate helper classes:</p>
<pre><code>class MyABCHelper(MySecondABC):
    def foo(self):
        return bar(self)*2
</code></pre>
<p>(For a more realistic example, see the classes in <a href="https://docs.python.org/3/library/collections.abc.html" rel="noreferrer"><code>collections.abc</code></a> that allow you to implement the full <code>MutableSequence</code> interface by defining only 7 of the 18 methods.)</p>
<p>You wouldn't want a rule that made such definitions illegal.</p>
</div>
<span class="comment-copy">To add to the confusion, the method is still marking <code>__isabstractmethod__</code> as True. Good catch in the docs.</span>
<span class="comment-copy">I understand the first part and how it explains the behaviour shown above, but the citation of the docs deals with adding / modifying abstracmethods in the ABC itself, not the concrete subclasses, right?</span>
<span class="comment-copy">@AndreasFinkler: By deleting the <code>foo</code> implementation, you're trying to dynamically turn a concrete class abstract. As the docs say, this is not supported.</span>
