<div class="post-text" itemprop="text">
<p>What I want to do:</p>
<ol>
<li>have an asyncio event loop that gets spun up</li>
<li>that loop is passed to various classes in my system for scheduling coroutines on</li>
<li>that loop is also used for handling the responses to events (ie, I have a Queue, some event handling code will place an item on that queue, and separate co-routines that await a get() on that queue to handle those values)</li>
<li>there is a main thread which "owns" the loop and is responsible for creating the loop, and at time of system shutdown will cancel any running tasks on the loop and close &amp; stop the loop (cleanly shutdown)</li>
</ol>
<p>My understanding is because of #3, something needs to call <code>run_forever()</code> on the loop to ensure that tasks get scheduled on the loop.  But if I call <code>run_forever()</code> then my main thread blocks, never to terminate.</p>
<p>What I've tried:</p>
<p>Spawn a thread, passing in the loop, and then call <code>run_forever</code> in the thread.  This means though that my unit tests never finish.  The gist:</p>
<pre><code>def __start_background_loop(loop):
    def run_forever(loop):
        loop.run_forever()

    # because run_forever() will block the current thread, we spawn
    # a subthread to issue that call in.
    thread = Thread(target=run_forever, args=(loop,))
    thread.start()

def __end_background_loop(loop):
    for task in Task.all_tasks(loop):
        task.cancel()
    loop.stop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are two possible approaches: you can run the event loop in the main thread or in a background thread. If you run it in the main thread, you need to <code>run_forever</code> (or <code>run_until_complete(main())</code> or equivalent) as the very last step of the program initialization. In that case the main thread will "block", but that's ok because its event loop will be live and respond to outside events, allowing the program to function. A single "blocking" call to the event loop that dispatches coroutines and callbacks is how asyncio is designed to be run.</p>
<p>In cases where this is impractical, such as programs that contain a large body of synchronous code, or those that already communicate between several threads, it is often a better idea to create a dedicated thread and run the event loop in it. In that case you must be very careful not to communicate with the event loop other than with calls to <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.call_soon_threadsafe" rel="nofollow noreferrer"><code>loop.call_soon_threadsafe()</code></a> and <a href="https://docs.python.org/3/library/asyncio-task.html?highlight=run_coroutine_threadsafe#asyncio.run_coroutine_threadsafe" rel="nofollow noreferrer"><code>asyncio.run_coroutine_threadsafe()</code></a>. For example, <code>__end_background_loop</code> must be invoked using <code>loop.call_soon_threadsafe(__end_background_loop)</code> because it interacts with the tasks and the event loop. This applies to all interactions with the event loop - for example, calling <code>loop.stop()</code> from another thread is not allowed, it must be spelled as <code>loop.call_soon_threadsafe(loop.stop)</code>. Of course, calling loop functions from asyncio callbacks and coroutines is fine because those will always be run in the same thread the event loop runs in.</p>
</div>
<span class="comment-copy">Why not create the event loop in the other thread in the first place? <code>asyncio.new_event_loop()</code></span>
<span class="comment-copy">"It is not even safe to call loop.stop() from another thread" -- how does the loop then get stopped, if not from another thread?  Or do you mean it's safe to call <code>call_soon_threadsafe(loop.stop())</code> from another thread, but not <code>loop.stop()</code> directly?</span>
<span class="comment-copy">@AdamParkin The loop can get stopped from a callback or coroutine in the event loop thread - for example, a coroutine can detect an "exit" command on a socket and call <code>loop.stop()</code>. This is how things work when there is only one thread in the picture, and it only runs the event loop, and that's a perfectly valid (even typical) usage of asyncio. If you do use multiple threads, then all other threads must invoke <code>loop.stop()</code> as <code>loop.call_soon_threadsafe(loop.stop)</code> (note lack of parentheses after <code>loop.stop</code>), and the same for anything else loop-related.</span>
