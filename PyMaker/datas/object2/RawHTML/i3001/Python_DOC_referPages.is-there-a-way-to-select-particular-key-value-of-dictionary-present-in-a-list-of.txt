<div class="post-text" itemprop="text">
<p>I am presently using a for loop to print all the required key value pairs of a dictionary. However is there a simpler way to select the required key value pair?</p>
<pre><code>        for i in (out['elements']):
            out = (i['insights'][0]['details']['socialInfo'])
            out_temp.append(out)
</code></pre>
<p>The content of <strong>out</strong> is actually a JSON with list of dictionaries and each dictionary contains a list of dictionaries.</p>
</div>
<div class="post-text" itemprop="text">
<p>I cannot see an unequivocally <em>simpler</em> way to access the data you require. However, you can apply your logic more efficiently via a list comprehension:</p>
<pre><code>out_temp = [i['insights'][0]['details']['socialInfo'] for i in out['elements']]
</code></pre>
<p>Whether or not this is also simpler is open to debate.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use map to generate the new list as well. But I think what you are doing is fine, it is much easier to read than the alternatives.</p>
<pre><code>out_temp = list(map(lambda x: x['insights'][0]['details']['socialInfo'], out['elements']))
</code></pre>
</div>
<span class="comment-copy">What do you mean the "required" pairs? Can you post an example of the JSON that might be in <code>out</code>, and what your desired output would be?</span>
<span class="comment-copy">What do you mean by asking <code>first key value of dictionary</code>? A dictionary is not a sequence, i.e. no positions are stored. An ordered dictionary can be achived by using an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a></span>
<span class="comment-copy">There are libraries that let you write a “key path” as a single string or tuple apply it to a nested structure all at once, with wildcards, and get back a list (possibly flattened) of results. There are at least three different formats for this, one based on XPath, one on Cocoa KVC, one on JavaScript-like (also Python-like) syntax with lots of square brackets.</span>
<span class="comment-copy">For example, you might write <code>out_temp = path(out, 'elements.*.insights.0.details').flatten()</code> to get this list. If this is something you’re interested in, you should search PyPI for dpath, kvc, and… I forget the other one, but look around and you should find it.</span>
<span class="comment-copy">Personally, I think simple cases are better handled with native comprehensions than with dpath wildcards, and complicated cases usually need some kind of custom logic (at least error handling) within the search, so the window at which these libraries are useful is pretty small. But some people seem to find it much easier to think in terms of nested wildcards than me, or much harder to think in terms of loops, or whatever.</span>
<span class="comment-copy">Using <a href="https://stackoverflow.com/a/51616862/2648551">list comprehensions</a> is more pythonic than using <code>lambda</code> and <code>map</code></span>
