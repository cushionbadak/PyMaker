<div class="post-text" itemprop="text">
<p>I have a list of ~1000 unique items</p>
<pre><code>np.random.seed(0)
unique1 = sorted(list(np.random.choice(np.arange(2000), 1000, False)))
</code></pre>
<p>and a <code>pandas</code> <code>df.column</code> of ~12 mil lines with just integers from this list.</p>
<pre><code>df = pd.DataFrame({'a': np.sort(np.random.choice(unique1[1:], 12000000))})
</code></pre>
<p>What I need to do is create a new column with always the previous element in the list of uniques than the one in my original column.</p>
<p>I have tried doing it with <code>apply</code> but the efficiency is laughable, and with a common loop which is kind of ok (~2 mins on my system), but I am wondering if I could get there more efficiently (smaller numbers used for illustration purposes):</p>
<pre><code>np.random.seed(0)
unique1 = sorted(list((np.random.choice(np.arange(20), 10, False))))
df = pd.DataFrame({'a': np.sort(np.random.choice(unique1[1:], 15))})

unique2 = unique1[1:]
df['b'] = df.a.apply(lambda x: unique1[unique2.index(x)])

newCol = []
for item in list(df.a):
    newCol.append(unique1[unique2.index(item)])
df['c'] = newCol
print(df, unique1)
     a   b   c
0    2   1   1
1    2   1   1
2    4   2   2
3    6   4   4
4    8   6   6
5    8   6   6
6    8   6   6
7   10   8   8
8   13  10  10
9   13  10  10
10  17  13  13
11  18  17  17
12  18  17  17
13  19  18  18
14  19  18  18 [1, 2, 4, 6, 8, 10, 13, 17, 18, 19]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem here is that you're using <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow noreferrer"><code>list.index</code></a>, which does a linear search through all of the unique values.</p>
<p>If you can afford the space to build a dict, you can turn this into a constant-time lookup:</p>
<pre><code>unique2 = {value: index for index, value in enumerate(unique1[1:])}
df['b'] = df.a.apply(lambda x: unique1[unique2[x]])
</code></pre>
<p>If you can't (in which case you should be keeping the values in an array or Slice rather than a list in the first placeâ€¦), as long as you keep them sorted, you can at least search in logarithmic rather than linear time using <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code></a> or <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.searchsorted.html" rel="nofollow noreferrer"><code>np.searchsorted</code></a>:</p>
<pre><code>df['b'] = df.a.apply(lambda x: unique1[np.searchsorted(unique2, x)])
</code></pre>
<p>(This will be faster if <code>unique2</code> is an array rather than a list, but only by a constant factor; it's still logarithmic time with a list.)</p>
</div>
