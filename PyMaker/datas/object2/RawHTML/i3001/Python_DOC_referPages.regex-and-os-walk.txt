<div class="post-text" itemprop="text">
<p>I'm pretty new to python but learning fast.  I'm trying to use regex with os.walk to ignore directories that I don't want processed.  I understand that you must modify the dirs in place and not create a new list.  I have tried it both ways though.  I don't get any errors but it still traverses all the directory's.  Exluding full dir names works fine. I am trying to remove all directories with 'EXP' or '-' or '3.2' in the name. Here is an example I want to ignore 
3.2.2.150-20150424.195805_EXP_manuMain_outOfMemFix</p>
<p>This is what I have:</p>
<pre><code>def runtest(filepath_udu: object) -&gt; object:   
    k = 1
    for root, dirs, files in os.walk(filepath_udu, topdown=True):
        dirs[:] = [item for item in dirs 
                   if item not in ('1node','local','remote')]
        dirs[:] = [dir for dir in dirs 
                   if re.search(r'\bEXP\b', dir) not in dirs \
                   or re.search(r'\b3.2\b', dir) not in dirs \
                   or re.search(r'\w+(?:- \w+)+', dir) not in dirs]
    for file in files:
        do something...
</code></pre>
<p>What am i doing wrong that my 2nd dirs[:] is being ignored?  Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Its not being ignored, it’s just that your condition is always true, so you aren’t filtering anything out.</p>
<p><a href="https://docs.python.org/3/library/re.html#re.search" rel="nofollow noreferrer"><code>re.search</code></a> is going to return a match object if something is found, or <code>None</code> if not. Either way, that’s not going to be an element of <code>dirs</code>, because <code>dirs</code> is just a list of strings. So all of your tests are always true.</p>
<p>Instead of checking that the search is not in <code>dirs</code>, just check that it’s not truthy. (A match object is always truthy, and <code>None</code> is always falsey.)</p>
<p>Also, after you fix that, I’m pretty sure you wanted to keep the values where <em>all</em> of the tests fail—but you’re using <code>or</code> instead of <code>and</code>, which means you’re keeping the values where <em>any</em> of the tests fail.</p>
<p>So:</p>
<pre><code>dirs[:] = [dir for dir in dirs
           if not re.search(r'\bEXP\b', dir)
           and not re.search(r'\b3.2\b', dir) 
           and not re.search(r'\w+(?:-\w+)+', dir)]
</code></pre>
<p>Or, if it’s easier to understand the other way round—instead of keep all values where all the tests fail, keep all values where none of the tests is true:</p>
<pre><code>dirs[:] = [dir for dir in dirs if not (
           re.search(r'\bEXP\b', dir) or
           re.search(r'\b3.2\b', dir) or
           re.search(r'\w+(?:-\w+)+', dir))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of using <code>os.walk</code>, you can avoid the overhead of dealing with list manipulations by recursively traversing the sub-directories on your own with <code>os.scandir</code> after excluding those that match your exclusion criteria:</p>
<pre><code>def runtest(filepath_udu: object) -&gt; object:
    for entry in os.scandir(filepath_udu):
        if entry.is_dir() and entry.name not in ('1node', 'local', 'remote') and not re.search(r'\bEXP\b', entry.name) and not re.search(r'\b3.2\b', entry.name) and not re.search(r'\w+(?:- \w+)+', entry.name):
            runtest(entry.path)
        else:
            do something ...
</code></pre>
</div>
<span class="comment-copy"><code>if re.search(r'\bEXP\b', dir) not in dirs</code> checks if the word "EXP" is not in the list of <code>dirs</code>. Most of the time, it is not. What you want is <code>if not re.search(r'\bEXP\b', dir)</code> (sic). Same with the other two conditions, and change 'or' to 'and'.</span>
<span class="comment-copy">As a side note, you don’t need backslash continuations in an expression that’s inside parens, brackets, or braces; those are automatically continued.</span>
<span class="comment-copy">@DYZ No, the <code>walk</code> iterator explicitly looks at the changes you made. See <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow noreferrer">the docs</a> for details, but the OP is doing that part exactly right: "When <i>topdown</i> is <code>True</code>, the caller can modify the <i>dirnames</i> list in-place (perhaps using <code>del</code> or slice assignment), and <code>walk()</code> will only recurse into the subdirectories whose names remain in <i>dirnames</i>; this can be used to prune the search, impose a specific order of visiting, or even to inform <code>walk()</code> about directories the caller creates or renames before it resumes <code>walk()</code> again."</span>
<span class="comment-copy">To clarify a little bit, I am traversing directories of products collecting performance data from firmware builds to keep track of how performance changes.  I want to ignore experimental fixes, bug fixes, CFI's, etc and all those have EXP or '-' in the name.  I also don't want older firmware like 3.2. Firmware that I want are in a X.X.X.xxx numerical format, the last numbers don't always have 3 digits--it can be 1,2,or 3.</span>
<span class="comment-copy">This worked!  Thanks so much.  I did have to make a minor change though.  using r\bEXP\b wasn't working.  I changed it to a regex (r'\w+(?:EXP\w+)+' and this worked, although a co-worker indicated that if I remove the \b that would have worked to.</span>
<span class="comment-copy">@DB_65 I didn't test your regexes at all; I just assumed they did what you wanted, and you just needed to know how to apply them properly. Glad to know you got it working.</span>
<span class="comment-copy">What overhead? The cost of all of those extra <code>stat</code> syscalls (from calling <code>isdir</code> on every file) is going to be much, much higher than the savings of avoiding a list comprehension.</span>
<span class="comment-copy">Thanks. I've updated my answer with the much more efficent <code>os.scandir</code> instead, which is what <code>os.walk</code> uses internally. The OP can refer to <a href="https://www.python.org/dev/peps/pep-0471/" rel="nofollow noreferrer">PEP 471</a> for details.</span>
