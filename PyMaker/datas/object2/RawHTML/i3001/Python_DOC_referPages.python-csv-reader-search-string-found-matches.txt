<div class="post-text" itemprop="text">
<p>back again with another question.</p>
<p>Preface: built a GUI with Qt Designer, a search button, parsing csv data, and building my TableWidget with the found data.</p>
<p>I have a file that has two results that are similar, for instance, one location is labeled Reddit (North) and Reddit (South). If I search for Reddit, only the first result shows, but when I press the Search button again, it only shows the first find, not the second.</p>
<p><strong>Question:</strong> How do I stop the csv reader at the first match, fill in the table with the data it found from the first hit, then hit the search button again to clear the first hit and display the second hit?</p>
<pre><code>def search(self):
    self.table_search.setRowCount(6)
    self.table_search.setColumnCount(1)
    self.table_search.verticalHeader().setDefaultSectionSize(20)
    self.table_search.verticalHeader().setVisible(True)
    self.table_search.setVerticalHeaderLabels([
                            'Location ID:', 
                            'Location Name:', 
                            'Cost Center:', 
                            'Street Address:', 
                            'City:', 
                            'State:']
    )

    # taking input from a PyQt line edit box
    search = self.lineedit_locsearch.text()
    search_string = search.strip().upper() # stripping white space from the string

    # containers for specific data from the csv file
    locid = ''
    locname = ''
    loccost = ''
    locaddress = ''
    loccity = ''
    locstate = ''

    with open('data/loc.csv', "r") as locdata:
        reader = csv.reader(locdata)

        for row in reader: 
            for field in row: 
                if field == search_string: 
                    locid = row[0]
                    locname = row[1]
                    loccost = row[2]
                    locaddress = row[3]
                    loccity = row[4]
                    locstate = row[5]

    locdata.close()


    self.table_locsearch.setItem(0, 0, QtWidgets.QTableWidgetItem(locid))
    self.table_locsearch.setItem(1, 0, QtWidgets.QTableWidgetItem(locname))
    self.table_locsearch.setItem(2, 0, QtWidgets.QTableWidgetItem(loccost))
    self.table_locsearch.setItem(3, 0, QtWidgets.QTableWidgetItem(locaddress))
    self.table_locsearch.setItem(4, 0, QtWidgets.QTableWidgetItem(loccity))
    self.table_locsearch.setItem(5, 0, QtWidgets.QTableWidgetItem(locstate))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can externalize your CSV reading/searching and make it a generator so it remembers where it left off, i.e.:</p>
<pre><code>@staticmethod
def search_csv(path, search):
    with open(path, "r") as f:
        for row in csv.reader(f):
            if search in row:
                yield row
</code></pre>
<p>You can now use this as a search iterator to go over the search results. The actual utilization may depend on how you're implementing the rest of your system - the best would be to just keep a reference to your current search iterator if available (and the search string didn't change), or to create a new if not. For example, an in-place change to your <code>search()</code> method to enable it would be:</p>
<pre><code>def search(self):
    # you could externalize the table setup as it's always static
    self.table_search.setRowCount(6)
    self.table_search.setColumnCount(1)
    self.table_search.verticalHeader().setDefaultSectionSize(20)
    self.table_search.verticalHeader().setVisible(True)
    self.table_search.setVerticalHeaderLabels([
        'Location ID:',
        'Location Name:',
        'Cost Center:',
        'Street Address:',
        'City:',
        'State:'])

    search = self.lineedit_locsearch.text().strip().upper()  # get the current search string
    search_gen = getattr(self, "_search_gen", None)  # attempt to grab the current search
    if search_gen is None or search_gen["search"] != search:  # we need a new search
        search_gen = {"generator": self.search_csv("data/loc.csv", search), 
                      "search": search}   # store the search string as well
        setattr(self, "_search_gen", search_gen)  # save it to the object
    try:
        result = next(search_gen["generator"])
    except StopIteration:  # no (more) results
        result = []  # alternatively you may show that there are no (more) results

    # to ensure validity, let's force the `result` to have at least 6 fields:
    result += [""] * (6 - len(result))  # fill the non-populated fields with empty strings

    for row in range(6):  # fill the table iteratively
        self.table_locsearch.setItem(row, 0, QtWidgets.QTableWidgetItem(result[row]))
</code></pre>
<p>It essentially checks if there is already a <code>_search_gen</code> dictionary on your current instance and if it contains the same search string as what's in the <code>self.lineedit_locsearch</code> - if yes, then it uses the existing generator to continue searching the CSV, and if not it creates a new one. Either way, the generator is used to fetch the (next) result and then just fills up the table. And as a bonus, we ensure that the result have at least 6 fields so that the table can be properly populated even if the found CSV row didn't have all 6 of them.</p>
<p>I'm not sure, tho, if you need to reconfigure the table all the time - maybe you can create it when you create your search results window/panel/frame/whatever and then just continue to call the <code>search()</code> method to update the results.</p>
<p>Finally, when you want to close your search, make sure you invalidate the generator with <code>delattr(self, "_search_gen")</code>. Beware also that the passed file (<code>data/loc.csv</code>) will remain open in read mode for the duration of the search until there are no more results found or you invalidated the search generator as aforementioned.</p>
</div>
<div class="post-text" itemprop="text">
<p>To break out of the loop try this</p>
<pre><code>breakflag = False
with open('data/loc.csv', "r") as locdata:
    reader = csv.reader(locdata)

    for row in reader:
        if breakflag:
            break
        for field in row: 
            if field == search_string: 
                locid = row[0]
                locname = row[1]
                loccost = row[2]
                locaddress = row[3]
                loccity = row[4]
                locstate = row[5]
                breakflag = True
</code></pre>
</div>
<span class="comment-copy">Hi zwer, thanks a ton for the explanation. Do you by chance have any docs I can read on this in further detail?</span>
<span class="comment-copy">@AQuick - The official docs explain more than enough on <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr()</code></a> and <a href="https://docs.python.org/3/library/functions.html#setattr" rel="nofollow noreferrer"><code>setattr()</code></a>, although in reality you don't really need them if you just initialize <code>self._search_gen</code> as a dictionary in your <code>__init__()</code> method - they are used here just so the code doesn't depend on <i>externalities</i>. As for generators, <a href="https://jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/" rel="nofollow noreferrer"><b>this tutorial</b></a> looks like a good start.</span>
<span class="comment-copy">Much appreciated!</span>
<span class="comment-copy">@AQuick - If the above solves your problem, consider accepting it as an answer.</span>
<span class="comment-copy">zwer, the code you supplied worked. Final question, where do I input the delattr, if I wanted to close the file, and start the search again from the beginning?</span>
