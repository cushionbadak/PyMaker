<div class="post-text" itemprop="text">
<p>It is probably the wrong title, but here is my problem.</p>
<p>I have a system comprised of a <em>microcontroller</em> (MCU), a <em>serial interface</em> (SPI), a <em>DAC</em> (Digital / Analog converter), an <em>electrode</em> (E). Each element is defined as a class in my python modelization.</p>
<p>As a first step, I want to monitor the output on the electrode as I input something in the microcontroller.</p>
<p>Let's consider the following:</p>
<ul>
<li>Input: 2 mA on the electrode during 1 ms.</li>
<li>MCU send the new DAC value via the SPI: 30 us</li>
<li>DAC updates its register and output: 400 us</li>
<li>MCU send a switch on command to the electrode: 1 us</li>
<li>The electrode is now outputting.</li>
<li>1 ms later, send a switch off command to the electrode: 1us</li>
<li>The electrode doesn't output anymore.</li>
</ul>
<p>My 2 biggest issues are 1. How to take into account this time component and 2. How to monitor the SPI line to determine if something has to be done.</p>
<pre><code>class Electrode:
    def __init__(self, id):
        self.id = id
        self.switch = False
        self.value = 0

    def output(self):
        if self.switch:
            return self.value
        else:
            return 0

class SPI:
    def __init__(self):
        self.msg = None

class MCU:
    def __init__(self):
        self.name = "MicroController"

    def send_SPI_msg(self, SPI, msg):
        SPI.msg = msg

class DAC:
    def __init__(id):
        self.id = id
        self.cs = 1
        self.register = None
        self.output = None

    def read_SPI_msg(self, SPI):
        message = SPI.msg
        # update register and output
</code></pre>
<p>My system actually has 16 DACs and electrodes and a field-programmable gate array which are all listening to the same SPI. What I described above is a fairly simplified version.</p>
<p><strong>Question is: How to have the components check the value in <code>SPI.msg</code> regularly and act accordingly?</strong></p>
<p>In reality, each component is doing its life. Thus actions are performed in parallel. Since I'm trying to simulate the timeline and the action performed, I do not mind doing everything serially with a timeline variable (attribute) for each element. I just have issues to figure out how to have my classes interact together.</p>
<p>i.e. I can't do the following in python or I will get stuck:</p>
<pre><code>class DAC:
    def __init__(id):
        # init

    def read_SPI_msg(self, SPI):
        while True:        
            message = SPI.msg
            # update register and output if needed
</code></pre>
<p>Maybe an event triggering could be used... But I don't know how.</p>
<p>Maybe with multithreading, defining one thread / element? </p>
<p><strong>EDIT</strong>: Current state:</p>
<pre><code>class SPI:
    def __init__(self):
        self.attached_dacs = []
        self.attached_fpga = []
        self.attached_mcu = []

    def attach_device(self, device):
        if type(device) == DAC:
            self.attached_dacs.append(device)
        elif type(device) == FPGA:
            self.attached_fpga.append(device)
        elif type(device) == MCU:
            self.attached_mcu.append(device)

    def send_message(self, msg):
        for device in self.attached_dacs + self.attached_fpga:
            device.on_spi_message(self, msg)

class SpiAttachableDevice:
    def on_spi_message(self, SPI, message):
        if self.cs:
            self.execute_SPI_message(message)
        else:
            return None

class DAC(SpiAttachableDevice):
    def __init__(self, id):
        self.id = id
        self.cs = False # Not listening

    def execute_SPI_message(message):
        # Do stuff

class FPGA(SpiAttachableDevice):
    def __init__(self):
        self.electrodes = list()
        self.cs = False # Not listening

    def execute_SPI_message(message):
        # Do stuff

class MCU:
    def __init__(self):
        self.electrodes = list()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming you want to keep it single-threaded and you don't use asyncio. In this case, you might want to employ <em>observer</em> or <em>pub/sub</em> pattern when implementing the SPI:</p>
<pre><code>class SPI:
    def __init__(self):
        self.attached_devices = []

    def attach_device(self, device):
        self.attached_devices.append(device)

    def send_message(self, msg):
        for device in self.attached_devices:
            device.on_spi_message(self, msg)

class SpiAttachableDevice:
    def on_spi_message(self, spi_instance, message):
        raise NotImplementedError('subclass me!')
</code></pre>
<p>So you can use it like this:</p>
<pre><code>spi = SPI()
device_1 = Device()
device_2 = Device()
spi.attach_device(device_1)
spi.attach_device(device_2)
spi.send_message('hello')
</code></pre>
<p>I haven't done anything to be able to send SPI messages from <code>Device</code> objects, but you can update the abstraction accordingly.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could move the <code>while</code> loop simply outside:</p>
<pre><code>class SPI:

    def __init__(self, msg):
        self.msg = msg

class Component:

    def __init__(self, spi):
        self.spi = spi

    def tick(self, t):
        msg = self.spi.msg
        if msg = "...":
            ...
spi = SPI()
components = [Component(spi), ...]

for t in range(TOTAL_TIME):
   for component in components:
       component.tick(t)
</code></pre>
<p>As stated in your comment you want more a timeline view on what is happening. You can have an explicit timeline with which your components interact. External input (state changes) can be set beforehand in the same manner. To order the timemline I'll just run sort each time but it would probably be more performant to use something like a <a href="https://docs.python.org/3/library/heapq.html#priority-queue-implementation-notes" rel="nofollow noreferrer">priority queue</a>.</p>
<p>This mainly differs from Vovanrock2002 answer by not recursing in each timestep and having an explicit timeline. </p>
<pre><code>class Component:
   def __init__(self, timeline):
       self._timeline = timeline
       self._out = [] #all connected components

   def poke(self, changed_object, time):
       return []

class Clock(Component):

    def __init__(self, timeline):
        Component.__init__(self, timeline)
        self._out.append(self)
        self.msg = "tick"
        self._timeline.append((200, self, msg))

   def poke(self, time, changed_object, msg):
       self._timeline.append((time + 200, self, self.msg))

timeline = []
spi = SPI(timeline)
components = [spi, Clock(timeline), ComponentA(timeline), ...]

timeline.append((500, spi, "new DAC value"))

while timeline:
    timeline.sort(key=lambda event: event[0], reverse=True)
    event = timeline.pop()
    time, changed_component, msg:
    for connected_component in changed_component._out:
        connected_component.poke(time, changed_component, msg)
</code></pre>
<p>This way you have an explicit timeline (which you could also "record", just add each popped event to some list) and you can have arbitrarily connected components (e.g. if you want to have multiple SPIs).</p>
</div>
<span class="comment-copy">What math are you using? Do you have continuous time or discrete? I guess the elements are functions that map input to output?</span>
<span class="comment-copy">@syntonym Messages are made of 16 bits. The MCU does not comprise a floating point unit. The elements are the electrical component, i.e. the DACs, Electrodes, ... that I defined as class. The time is discrete, with a clock ticking at 8 Mhz. I do not need to reproduce the timing aspect, I can for instance make the following: <code>ticks = range(8000000)</code> which corresponds to 1 second. Hope it helps :)</span>
<span class="comment-copy">Really interesting, let me try to implement this :)</span>
<span class="comment-copy">So indeed I manage to make it work. Am I correct saying that by replacing the raise statement, actions (for instance <code>print (self.id)</code>) will be performed for each devices? What if an action on one device impact another? i.e. If a DAC value is changing, I need 400 us before I can turn on the electrode.</span>
<span class="comment-copy">@Mathieu Yes, <code>NotImplementedError</code> is just a placeholder. My impression was that modeling SPI is your primary concern, and otherwise you already have a strategy for managing relationships in time.</span>
<span class="comment-copy">Let's say it was one of the primary concerns ^^ The message always goes from the MCU to the devices, so I should not need a method to send SPI messages from Device Objects. Can you check the EDIT with the current implementation to see if I understood your answer correctly?</span>
<span class="comment-copy">@Mathieu looking at the code, yes, this is pretty much what I meant.</span>
<span class="comment-copy">Far too basic and sadly can't work. As stated I have actually 16 DACs, 16 electrodes, and a few other components. My first approach was as yours, checking every tick what has to be done. It's a mess, especially when you start saying: DAC 1 tasks are: This now, this in 300 this in 500. DAC 2 tasks are this in 5, this in 200 and this in 400... And so on...</span>
<span class="comment-copy">I'll have a look, the first question that comes to my mind is what does the <code>_</code> in fornt of timeline, out, etc... If I get it right, Component are initialized when the clock is initialized.</span>
<span class="comment-copy">That's just a python convention to indicate "don't mess with it, it's internal to this class" like private in java, see e.g. <a href="https://stackoverflow.com/questions/1641219/does-python-have-private-variables-in-classes">this SO</a>. The clock was just an example of an component that does something every 200th time cycle. For your case you would probably set some msg on the SPI and then at the same time let it being poked to transmit the msg to all connected devices.</span>
