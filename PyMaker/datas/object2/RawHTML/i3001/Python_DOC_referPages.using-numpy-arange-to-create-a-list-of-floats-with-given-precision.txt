<div class="post-text" itemprop="text">
<p>My aim is to generate a list <code>ls</code> of numbers which starts from <code>1.0</code> and ends at <code>1.499</code> where the step between subsequent numbers is <code>0.001.</code></p>
<p>Ultimately, I am loading a file that has a column of float numbers, e.g., <code>1.293, 1.101, ...</code> all with 3 numbers past floating point, and would like to find where in <code>ls</code> each number read from the file occurs. </p>
<p>My two methods for creating <code>ls</code>:</p>
<h1>1</h1>
<p><code>ls = np.arange(1.,1.5,0.001)</code></p>
<p>and </p>
<h1>2</h1>
<pre><code>ls = []
t = 1.0
dist = int((1.5-1.)/0.001)
for i in range(dist):
    ls.append(t)
    t+=0.001
</code></pre>
<p>According to either method of 1 or 2, one expects for instance to find the number <code>1.293</code> in ls, but it seems not to be the case. For instance when I print <code>ls</code> having been created using the 2nd method, it prints: <code>[1.0, 1.001, 1.0019999999999998, 1.0029999999999997,...</code> as opposed to the desired <code>[1.0, 1.001, 1.002, 1.003, ...].</code></p>
<p>On the other hand, using the 1st method to create <code>ls</code>, and testing if we find again the number <code>1.293</code> as follows: </p>
<pre><code>for i in range(len(ls)):
    print 'here ', i
    if ls[i] == 1.293: print 'Found'
</code></pre>
<p>It never prints 'Found' meaning it does not contain the number 1.293, which by construction it is expected to contain as I gave the step size when using <code>np.arange</code>...</p>
<ul>
<li>How am I supposed to create <code>ls</code> such that I really get all numbers between <code>1.0</code> and <code>1.5</code> with step size <code>0.001</code> and without having to deal with higher precision in floating points. </li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Floating point numbers are not exact real numbers, only the closest numbers that can fit in a 52-bit binary fraction. </p>
<p>For example, you can't fit <code>1.001</code> in a binary fraction; the nearest value is <code>1.000999999999999889865875957184471189976</code>. If you add <code>0.001</code> to that, the nearest value to the result is <code>1.001999999999999779731751914368942379951</code>. But the nearest value to <code>1.002</code> is <code>1.002000000000000001776356839400250464678</code>. Those aren't equal. They only differ by one part in <code>2**52</code>, but they still differ.</p>
<p>And now you're adding <code>.001</code> to a number slightly less than <code>1.002</code>, so the errors can accumulate. Worst case, you can be off by one part in <code>2**52</code> 500 times, so the total error can be as bad as 500 parts in <code>2**52</code>, or roughly one part in <code>2**43</code>.</p>
<p>The way to deal with that is to never check whether two floating point numbers are equal; instead, work out how much error your floating-point math can introduce, and check whether they're within that error, using <code>math.isclose</code> or <code>np.isclose</code>.</p>
<p>In cases like this, where you only wanted 3 digits of precision, and you can be sure the maximum error never gets anywhere near those 3 digits, you can simplify things and just check whether they're within, say, <code>0.0001</code>. Or, even more simply, you can verify that the default tolerances used by <code>isclose</code> are more than good enough, and then just use them.</p>
<p>So, instead of this:</p>
<pre><code>if ls[i] == 1.293:
</code></pre>
<p>… write this:</p>
<pre><code>if math.isclose(ls[i], 1.293)
</code></pre>
<hr/>
<p>An alternative is to use floating point <em>decimal</em> numbers, instead of floating-point <em>binary</em> numbers.</p>
<p>Of course these have the same problem—1/3 can't fit exactly in a decimal fraction any more than it can fit in a binary fraction. But if the only numbers you're dealing with are decimal fractions, like <code>1/1000</code>, that's not a problem.</p>
<p>And, even when it <em>is</em> a problem, being able to choose a precision rather than having to accept the hardcoded one, and choosing it in decimal digits rather than binary digits, can make the error tracking a lot easier to think about.</p>
<p>The only problem is that <code>decimal.Decimal</code> values aren't "native" to your CPU. Decimal math runs roughly an order of magnitude slower, NumPy doesn't know how to deal with Decimal values except as generic Python objects so it can't give you its usual space and speed savings, etc. But if you're only dealing with 500 numbers, who cares?</p>
<p>So:</p>
<pre><code>from decimal import Decimal

ls = []
t = Decimal('1.0')
dist = int((Decimal('1.5')-Decimal('1.'))/Decimal('0.001'))
for i in range(dist):
    ls.append(t)
    t+=Decimal('0.001')
</code></pre>
<p>And if you think about it, it's pretty easily to simplify things to not need all of those <code>Decimal('…')</code> constructors, because many of your numbers are just plain integers:</p>
<pre><code>dist = int((Decimal('1.5')-1) * 1000)
</code></pre>
</div>
<span class="comment-copy">These are just floating point errors. You won't be able to get around that.</span>
<span class="comment-copy">You could try using a list of <code>Decimal</code> objects. You can set arbitrary precision floats using the decimal library. <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer">docs.python.org/3/library/decimal.html</a></span>
<span class="comment-copy">Simply brilliant, thanks a lot for such instructive answer! I will make it work using <code>isclose</code>, which seems to be a very natural workaround. I honestly was confused and asked this question, so I greatly appreciate your answer despite people having downvoted my question.</span>
<span class="comment-copy">@user929304 As a side note, if you’re already using numpy, you should take advantage of it. Don’t convert the array into a list, and don’t loop over it; use array-wide operations on the array. For example, <code>np.isclose(ls, 1.293)</code> compares all of the elements at once (faster than looping over them, as well as shorter to write/read) and gives you are array of bools, so you can do <code>if np.isclose(ls, 1.293).any()</code> to see if any of them match.</span>
