<div class="post-text" itemprop="text">
<p>I have a project laid out like this:</p>
<pre><code>-proj/
    -__init__.py
    -main/
        -__init__.py
        -written_files/
            -__init__.py
    -scripts/
        -create_file.py
</code></pre>
<p>In <code>create_file.py</code>, I want to create a file, <code>train.txt</code>, and put it in <code>proj/main/written_files/</code></p>
<p>I was wondering if I could use the relative package structure. I was thinking of putting something like this in <code>create_file.py</code>:</p>
<pre><code>train_file = open(proj.main.written_files.train.txt, 'w')
</code></pre>
<p>Is there some way to do something like this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Modules loaded from a file will generally have a <a href="https://docs.python.org/3/reference/import.html#__file__" rel="nofollow noreferrer"><code>__file__</code></a> attribute. You can use this as a starting point for getting around your package. You could use the utilties in <a href="https://docs.python.org/3/library/os.path.html" rel="nofollow noreferrer"><code>os.path</code></a> or <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib</code></a> to navigate around the path. Either of the following should work:</p>
<pre><code>from os.path import dirname, join

filename = join(dirname(dirname(__file__)), 'main', 'written_files', 'train.txt')
</code></pre>
<p>OR</p>
<pre><code>from pathlib import Path

filename = Path(__file__).parent.parent / 'main' / 'written_files' / 'train.txt'
</code></pre>
<p>In both cases, use a context manager to make sure your file gets closed no matter what:</p>
<pre><code>with open(filename, 'w') as train_file:
    ...
</code></pre>
<p>Neither of these solutions is super elegant because they involve walking up the directory tree. Instead, you could start with the project root, and walk down:</p>
<pre><code>filename = join(dirname(proj.__file__), 'main', 'written_files', 'train.txt')
</code></pre>
<p>OR</p>
<pre><code>filename = Path(proj.__file__).parent / 'main' / 'written_files' / 'train.txt'
</code></pre>
<p>In both cases, <code>proj.__file__</code> should point to the root level <code>__init__.py</code>.</p>
</div>
<span class="comment-copy">From <code>proj.main.written_files.train.txt</code> you should already guess that that such a syntax is not possible because it is ambiguous. What if the file was called <code>file.some.more.dots.txt</code>? Your approach would assume that the file was somewhere inside a deeply nested directory structure.</span>
<span class="comment-copy">In general, I would recommend to use absolute paths when opening files, because otherwise it depends on from which directory you run the script. Something like <code>with open(os.path.dirname(os.path.realpath(__file__)) + '/file.txt', 'w') as file:</code> should work, if <code>file.txt</code> is in the same directory like the file in which this code is. I guess you should be able to use this code snippet if you adapt it to your directory structure.</span>
<span class="comment-copy">@MichaelH. Relative paths are fine as long as you're careful, but you're right in general, since the current directory can change between generating a relative file name and using it.</span>
