<div class="post-text" itemprop="text">
<p>Building off of the answer to <a href="https://stackoverflow.com/questions/26566799/how-to-wait-until-the-page-is-loaded-with-selenium-for-python#40037216">How to wait until the page is loaded with Selenium for Python?</a> I am attempting to create a method that allows multiple elements to be polled for presence using Expected Conditions. </p>
<p>I receive an error <strong>'bool' object is not callable</strong> on the line containing: wait.until(any(expectations)). </p>
<p>The thought process was to allow an number of Xpaths to be passed as expected conditions, then using <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer">any()</a>, in a similar manner to this java based answer, <a href="https://stackoverflow.com/questions/45166181/trying-to-wait-for-one-of-two-elements-in-the-page-using-selenium-xpath">Trying to wait for one of two elements in the page using selenium xpath</a>, check if any of the conditions are present.</p>
<p><strong>What would be the proper way use any() in this case? Or better yet, what needs to be done for this method to work?</strong></p>
<p>Assume that the Selenium .get('url') has already been executed immediately prior to calling this method.</p>
<pre><code>def wait_with_xpath_expectation(self, search_elements, timeout=6, max_attempts=3):
    """
    Selenium wait for an element(s) designated by Xpath to become available in the DOM. Useful for javascript AJAXy
    loading pages where content may be be rendered dynamically on the client side after page load appears complete.
    search_elements may be one Xpath as a string or many as a list. This allows for any of multiple elements on a
    page or pages to be determined to have loaded based on expectations.
    :param search_elements: string or list (strings converted to lists), Xpath(s)
    :param timeout: int, seconds
    :param max_attempts: int, time to wait before giving up on page loading
    :return: Boolean, True if page has loaded, False if all attempts have failed
    """

    # Page is not loaded yet
    loaded = False

    # Initialize attempt count
    attempt = 0

    # If only one element has been passed, ensure it is encapsulated by a list
    if type(search_elements) is str:
        search_elements = [search_elements]

    # Begin the polling loop
    while attempt &lt; max_attempts:

        try:

            while loaded is False:
                # Create a list of expected elements using list comprehension
                expectations = [EC.presence_of_element_located((By.XPATH, element)) for element in search_elements]

                # Define wait
                wait = WebDriverWait(self.browser, timeout)

                # Execute
                wait.until(any(expectations))

                # Acknowledge load
                loaded = True

                print("Success: Page loaded based on expectations")

                # Exit returning True for load
                return loaded

        except TimeoutException as e:

            # Increment attempts
            attempt += 1

            # Check again if max attempts has not been exceeded
            while attempt &lt; max_attempts:

                # Increase timeout by 20%
                timeout *= .2

                # Try again 
                continue

            # Print an error if max attempts is exceeded
            print("Error: Max load with expectations attempts exceeded,", e)

            # Exit returning False for load
            return loaded
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can have an expected condition class to wait for a combination of expected conditions.  Here is an example of one.</p>
<pre><code>class wait_for_all(object):
    def __init__(self, methods):
        self.methods = methods

    def __call__(self, driver):
        try:
            for method in self.methods:
                if not method(driver):
                    return False
            return True
        except StaleElementReferenceException:
            return False
</code></pre>
<p>This would then be used by building an array of the expected conditions and checking for all of them in the same wait.  (Example lines split for clarity.)</p>
<pre><code>methods = []
methods.append(EC.visibility_of_element_located(BY.ID, "idElem1"))
methods.append(EC.visibility_of_element_located(BY.ID, "idElem2"))
method = wait_for_all(methods)
WebDriverWait(driver, 5).until(method)
</code></pre>
<p>This will perform one five second wait while checking for visibility of two different elements.</p>
<p>I have documented this further in a blog post <a href="https://www.timbutterfield.com/blog/2018/08/03/python-selenium-waiting-for-combinations/" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Once I realized Xpath has the ability for unions, the following method works. I will leave this answer open in case anyone else has a better one.</p>
<pre><code>def wait_with_xpath_expectation(self, search_elements, timeout=6, max_attempts=3):
    """
    Selenium wait for an element designated by Xpath to become available in the DOM. Useful for javascript AJAXy
    loading pages where content may be be rendered dynamically on the client side after page load appears complete.
    search_elements may be one Xpath as a string or many as a list. This allows for any of multiple elements on a
    page or pages to be determined to have loaded based on expectations.
    :param search_elements: string or list (strings converted to lists), Xpath(s)
    :param timeout: int, seconds
    :param max_attempts: int, time to wait before giving up on page loading
    :return: Boolean, True if page has loaded, False if all attempts have failed
    """

    # Page is not loaded yet
    loaded = False

    # Initialize attempt count
    attempt = 0

    # If only one element has been passed, ensure it is encapsulated by a list
    if type(search_elements) is str:
        search_elements = [search_elements]

    # Begin the polling loop
    while attempt &lt; max_attempts:

        try:

            while loaded is False:
                # Decompose the list of Xpaths to a union of nodes
                node_union = " | ".join(search_elements)

                expectation = EC.presence_of_element_located((By.XPATH, node_union))

                # Define wait
                wait = WebDriverWait(self.browser, timeout)

                # Execute
                wait.until(expectation)

                # Acknowledge load
                loaded = True

                print("Success: Page loaded based on expectations")

                # Exit returning True for load
                return loaded

        except TimeoutException as e:

            # Increment attempts
            attempt += 1

            # Check again if max attempts has not been exceeded
            while attempt &lt; max_attempts:

                # Increase timeout by 20%
                timeout *= .2

                # Try again
                continue

            # Print an error if max attempts is exceeded
            print("Error: Max load with expectations attempts exceeded,", e)

            # Exit returning False for load
            return loaded
</code></pre>
</div>
<span class="comment-copy">Additional research turned up the fact that I could perform a union of nodes and combine the Xpath addresses with | into one Xpath. <a href="https://stackoverflow.com/questions/5350666/xpath-or-operator-for-different-nodes" title="xpath or operator for different nodes">stackoverflow.com/questions/5350666/â€¦</a>. Still working on a solution.</span>
<span class="comment-copy">Hi Tim. I like this implementation much better than mine, thank you! Multiple DOM elements can be waited for explicitly instead of a union. On top of that it looks very easy to use. The one item I'd change is BY.ID to BY.XPATH as I've found that some sites do not properly use class and id tags, but XPATH is always present due to the DOM. Accepting answer, thank you.</span>
<span class="comment-copy">Thanks.  I just used By.ID as example element locator type.  Since each expected condition is created separately, you can combine different locator types as appropriate for that element.  One element may be located By.ID, another could use By.XPATH, By.NAME, By.CLASS_NAME, By.TAG_NAME, By.CSS_SELECTOR, etc.</span>
<span class="comment-copy">Accepting answer</span>
