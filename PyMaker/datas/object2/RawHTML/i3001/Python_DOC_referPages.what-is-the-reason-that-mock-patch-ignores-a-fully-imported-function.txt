<div class="post-text" itemprop="text">
<p>Today I realized that it matters for <code>unittest.mock.patch</code> how I import a function. Depending on the used way a <code>mock.patch</code> call worked or was ignored. In Python we typically import a function with:</p>
<ul>
<li>an import statement like <code>import os</code> or</li>
<li>a <code>from ... import ...</code> statement like <code>from os import system</code></li>
</ul>
<p>A <code>mock.patch</code> works like a charm if I use <code>import os</code>, but it 
was ignored if I patch a <code>from os import system</code>. </p>
<p><strong>Example 1: Using import</strong></p>
<pre><code>import os
from unittest import mock


def echo():
    os.system('echo "Hello"')


with mock.patch('os.system') as mocked:
    print(mocked)
    mocked.side_effect = Exception('Patch works!')
    echo()
</code></pre>
<p><strong>Output of example 1</strong></p>
<pre><code>&lt;MagicMock name='system' id='140037358656760'&gt;

Traceback (most recent call last):
  File "/.../config/scratches/scratch_7.py", line 12, in &lt;module&gt;
    echo()
  File "/.../config/scratches/scratch_7.py", line 6, in echo
    os.system('echo "Hello"')
  File "/.../python3.5/unittest/mock.py", line 917, in __call__
    return _mock_self._mock_call(*args, **kwargs)
  File "/.../python3.5/unittest/mock.py", line 973, in _mock_call
    raise effect
Exception: Patch works!
</code></pre>
<p><strong>Example 2: Using a full function import and from-import</strong></p>
<p>When I fully import <code>os.system</code> the <code>mock.patch</code> ignores the <code>mocked.side_effect</code>.</p>
<pre><code>from os import system
from unittest import mock


def echo():
    system('echo "Hello"')


with mock.patch('os.system') as mocked:
    print(mocked)
    mocked.side_effect = Exception('Patching does not work!')
    echo()

    print('Patch was ignored!')
</code></pre>
<p><strong>Output of example 2</strong></p>
<pre><code>&lt;MagicMock name='system' id='139851175427376'&gt;
Hello
Patch was ignored!
</code></pre>
<p>In both cases I don't receive an error and <code>mock</code> could find <code>os.system</code> as a valid path. However, in the second case the function is not properly patched. </p>
<ul>
<li>Why <code>mock.patch</code> does not patch the function in the second example?</li>
<li>Are there any implementation specific reasons why the second patch did not work?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>When you do <code>from os import system</code>, you get a variable named <code>system</code> pointing to <code>os.system</code> function. Later, you <em>assign</em>, via patching, a different function to <code>os.system</code>, but <code>system</code> keeps to point to the old function. This is the same reason why the following works:</p>
<pre><code>tmp = a
a = b
b = tmp
</code></pre>
<p>It doesn't happen in the first example, because you reference <code>os.system</code> before it is mocked. To fix your second example, I'd go with the following:</p>
<pre><code>from os import system
from unittest import mock

def echo():
    system('echo "Hello"')

with mock.patch('__main__.system') as mocked:
    print(mocked)
    mocked.side_effect = Exception('Patching does not work!')
    echo()

    print('Patch was ignored!')
</code></pre>
<p>This way you make sure you patch the right reference. This is a rather common pattern. If <code>echo</code> function were in a file named <code>echo.py</code>, the patch call would look like <code>with mock.patch('echo.system')</code>.</p>
</div>
<span class="comment-copy">Generally you would use <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.object" rel="nofollow noreferrer"><code>patch.object</code></a> when the object is already imported in the current namespace. It likely won't work on <code>system</code> though, since that will be built-in/read only.</span>
