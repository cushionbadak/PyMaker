<div class="post-text" itemprop="text">
<p>I have read the following Unicode from a CSV file: </p>
<pre><code>line = u"{u'There's Still Time': u'foo'}"
</code></pre>
<p>I would like to be able to convert this to a dictionary so I would be able to so I can access it as the following:</p>
<pre><code>line["There's Still Time"] 
Output: 'foo'
</code></pre>
<p>Please help.</p>
</div>
<div class="post-text" itemprop="text">
<p>Given that there is an apostrophe within the string, you'll have to do some pre-processing before you even attempt to parse it into a <code>dict</code>. Assuming that all strings within the target <code>dict</code> are unicode and that closing strings have to be followed immediately by a control character (i.e. <code>}</code>, <code>:</code>, <code>,</code>, <code>}</code>, whitespace...) you can search for all apostrophes that do not match these two categories and escape them. Then you can use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval()</code></a> to parse it into a <code>dict</code>, something like:</p>
<pre><code>import ast
import re

APOSTROPHE_ESCAPE = re.compile(r"(?&lt;!u)'(?![.}:,\s])")

line = u"{u'There's Still Time': u'foo'}"
your_dict = ast.literal_eval(APOSTROPHE_ESCAPE.sub(r"\'", line))

print(your_dict)  # {u"There's Still Time": u'foo'}
</code></pre>
<p>Keep in mind, tho, that just a simple:</p>
<pre><code>line = u"{u'There'}s Still Time': u'foo'}"
</code></pre>
<p>Will throw it off - sure, it would be an illegal dictionary in the source as well, but keep in mind these limitations and adjust your pre-process regex accordingly.</p>
</div>
<span class="comment-copy">Are you using Python 2 or 3? Python 3 supports Unicode by default, you should use it if possible.</span>
<span class="comment-copy">@RobRose that isn't the issue at all. The issue is that the OP dumped the string representation of a dict object to a csv file and now has to deserialize that. The <i>real</i> solution is to use an appropriate serialization format from the beginning. If that isn't possible,they can use one of the approaches in the linked duplicate target.</span>
<span class="comment-copy">You should really choose a better serialization format. Dont just dump the string representations of objects to a file and call it serialization.</span>
<span class="comment-copy">The apostrophe makes it invalid syntax, you're not going to find a solution. The only way to make sense of that text is to make up a rule that apostrophes in the wrong place must be ignored. That's a very custom requirement.</span>
<span class="comment-copy">How was this CSV file created? It can't be parsed without heuristics that will be (a) nontrivial to write and test and (b) probably wrong in some cases, producing garbage. If the CSV file came from code that you wrote, or code that a coworker wrote, or code that a company you're paying or partnered with wrote, then fix that code and generate proper CSV files. It will be much easier, and better, than coming up with, and implementing, the heuristics for trying to repair the broken data.</span>
