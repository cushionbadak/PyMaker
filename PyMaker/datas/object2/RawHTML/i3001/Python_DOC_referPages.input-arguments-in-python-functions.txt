<div class="post-text" itemprop="text">
<p>I'm new with Python language and a I'm a little bit frustrated.
Till today, I thought that passing parameter names in a function call was not mandatory; for example, if you have the following function:</p>
<pre><code>def computeRectangleArea(width=7, height=8):
    return width * height
</code></pre>
<p>I thought that you can call like this <code>computeRectangleArea(width=7,height=8)</code> only to make clearer the meaning of the parameters, but actually keywords of input arguments were not needed, so you can call the same function in this way also: <code>computeRectangleArea(7, 8)</code> </p>
<p>Today, while using '<code>openpyxl.styles.PatternFill()</code>', I realized that 'fill_type' keyword is a necessary when calling this function. Suppose that you call the function in this way: <code>openpyxl.styles.PatternFill('FFFFFF','FFFFFF','solid')</code>, then the interpretation of the input parameter will be wrong.</p>
<p>I have some experience with OOP language (Java, C#) and these thing doesn't exist there. </p>
<p>It seems an inconsistent behaviour to me that some parameter names (like 'start_color' and 'end_color' in the example above) are optional, while others (like 'fill_type') must be specified before their values.</p>
<p>Can someone explain me why this apparently strange policy? In addition, I will be glad if someone can point me out some useful resource to understand the way it is implemented.</p>
</div>
<div class="post-text" itemprop="text">
<p>Positional and keyword parameters work just as they do in the languages you know better.  You need to go to the documentation of the method you're using and look at the signature.  For creating a <code>PatternFill</code> object, go to the class's <code>__init__</code> method.</p>
<pre><code>class PatternFill(Fill):
    def __init__(self, patternType=None, fgColor=Color(), bgColor=Color(),
                 fill_type=None, start_color=None, end_color=None):
</code></pre>
<p>You may specify arguments without the keyword as long as you supply them all in order, without skipping any.  For instance, your failing call can be legally given as:</p>
<pre><code>PatternFill(None, 'FFFFFF', 'FFFFFF', 'solid')
</code></pre>
<p>These will match the first four parameters.  Any time you supply an argument out of order, then you <em>must</em> supply the keyword for that argument and all later arguments in that invocation.  For instance, with the above call, if you want to let they style default to <code>None</code>, then you must supply the keywords for the three arguments you do supply.  If you simply omit the <code>None</code>, then the parser still tries to match them up sequentially from the front:</p>
<pre><code>patternType &lt;= 'FFFFFF'
fgColor &lt;= 'FFFFFF'
bgColor &lt;= 'solid'
</code></pre>
<p>... and your call fails to pass parsing.</p>
<p>Does that clear things up a little?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Can someone explain me why we need this "headache"…</p>
</blockquote>
<p>For your specific example, it doesn't appear that there are any keyword-only parameters. Rather, you're trying to pass arguments for the first, second, and fourth parameters, without having to pass an argument for the one in between that you don't care about.</p>
<p>In other words, it's not a headache at all. It's a convenience (and sanity check) you could quite easily ignore—but probably don't want to.</p>
<p>Instead of this:</p>
<pre><code>PatternFill('FFFFFF', 'FFFFFF', fill_type='solid')
</code></pre>
<p>… you <em>could</em> write this:</p>
<pre><code>PatternFill('FFFFFF', 'FFFFFF', Color(), 'solid')
</code></pre>
<p>… but in order to <em>know</em> that's what you'd need to send, you need to read the source or docs to see the whole parameter list, and see what the default values are for the parameters you want to skip over, and explicitly add them to your call.</p>
<p>I doubt anyone would find that better.</p>
<p>Also, as multiple people pointed out in comments, this is pretty much exactly how named arguments work in C#.</p>
<hr/>
<p>And this class is, accidentally, a great example of why Python actually <em>does</em> allow keyword-only parameters, even though they aren't being used here.</p>
<p>The fact that you can write <code>PatternFill('FFFFFF', 'FFFFFF', 'solid')</code> and not get a <code>TypeError</code> for bad arguments to <code>PatternFill</code>, but instead a mysterious error about <code>'solid'</code> not working as a color, is hardly a good thing. And (at least without type hinting annotations, which this type doesn't have) there's no way your IDE or any other tool could catch that mistake.</p>
<p>And, in fact, by not using keywords, you've even gotten the initial arguments wrong, without realizing it. You almost certainly wanted to do this:</p>
<pre><code>PatternFile(None, 'FFFFFF', 'FFFFFF')
</code></pre>
<p>… but you got away with this without a visible error:</p>
<pre><code>PatternFile('FFFFFF', 'FFFFFF')
</code></pre>
<p>… which means you're passing your foreground color as a pattern type and your background color as a foreground color and leaving the default background color.</p>
<p>That could be solved by making all or most parameters keyword-only. But without keyword-only params, the only option would be <code>**kwargs</code>, and that tradeoff is usually not worth it.</p>
<p>Quoting from the Rationale of <a href="https://www.python.org/dev/peps/pep-3102/" rel="nofollow noreferrer">PEP 3102</a>, the proposal that added keyword-only parameters to the language:</p>
<blockquote>
<p>There are often cases where it is desirable for a function to take a variable number of arguments. The Python language supports this using the 'varargs' syntax (*name), which specifies that any 'left over' arguments be passed into the varargs parameter as a tuple.</p>
<p>One limitation on this is that currently, all of the regular argument slots must be filled before the vararg slot can be.</p>
<p>This is not always desirable. One can easily envision a function which takes a variable number of arguments, but also takes one or more 'options' in the form of keyword arguments. Currently, the only way to do this is to define both a varargs argument, and a 'keywords' argument (<code>**kwargs</code>), and then manually extract the desired keywords from the dictionary.</p>
</blockquote>
<p>If it isn't obvious why using <code>*args</code> and <code>**kwargs</code> isn't good enough:</p>
<ul>
<li>The actual signature of the function is not visible when looking at the function definition in the source, or the inline <code>help</code>, or auto-generated docs.</li>
<li>The signature is also not available to dynamic reflective code using the <code>inspect</code> module or similar.</li>
<li>The signature is also not available to static reflective code—like that used by many IDEs to do completion and suggestions.</li>
<li>The implementation of the function is less clear, because at best it's half boilerplate for extracting and testing the parameters, and at worst the <code>args</code> and <code>kwargs</code> access are scattered throughout the body of the function.</li>
</ul>
<hr/>
<p>For an example of what this feature allows, consider the builtin <a href="https://docs.python.org/3/library/functions.html#print" rel="nofollow noreferrer"><code>print</code></a> function, which you can call like this:</p>
<pre><code>print(x, y, z, sep=', ')
</code></pre>
<p>This works because <code>print</code> is defined like this:</p>
<pre><code>print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False):
</code></pre>
<p>If it weren't for keyword arguments, there'd be no way to pass that <code>sep</code> as something different from the actual values to print.</p>
<p>You could force the user to pass all of the objects in a tuple instead of as separate arguments, but that would be a lot less friendly—and even if you did that, there'd be no way to pass <code>flush</code> without passing values for all of <code>sep</code>, <code>end</code>, and <code>file</code>.</p>
<p>And, even with keyword arguments, if it weren't for keyword-only parameters, the function signature would have to look like this:</p>
<pre><code>print(*objects, **kwargs):
</code></pre>
<p>… which would make it a lot harder to figure out what keyword arguments you could pass.</p>
</div>
<span class="comment-copy">"I have some experience with OOP language (Java, C#) and these thing doesn't exist there." - no, this works pretty much exactly like the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments" rel="nofollow noreferrer">corresponding C# feature</a>.</span>
<span class="comment-copy">Named parameters are often optional, but they don't have to be.</span>
<span class="comment-copy">Keyword-only arguments are relatively new; see <a href="https://www.python.org/dev/peps/pep-3102/" rel="nofollow noreferrer">PEP 3102</a>. Ultimately, you need to read the documentation for a function to know if the keyword is required when calling the function.</span>
<span class="comment-copy">This isn't even a keyword-only thing; it's just passing the wrong arguments.</span>
<span class="comment-copy">@user2357112 My comment was added before the example signature (which looks like a broken copy-paste job, by the way) was added.</span>
<span class="comment-copy">This is true information about a feature that the class in the question isn't actually using.</span>
<span class="comment-copy">@user2357112 Which "this"? It's certainly true that if the class in the question didn't allow keyword arguments, there'd be no way to pass a <code>fill_type</code> without passing 15 other arguments you don't care about.</span>
<span class="comment-copy">The <a href="https://openpyxl.readthedocs.io/en/stable/_modules/openpyxl/styles/fills.html#PatternFill" rel="nofollow noreferrer">class</a> in the question doesn't actually have any keyword-only parameters.</span>
<span class="comment-copy">Also, <code>fill_type</code> isn't the sixteenth argument. <code>Color</code> just has a very confusing <code>__repr__</code> that places a lot of stuff outside the angle brackets, making it look like those are parameters for <code>PatternFill</code>.</span>
<span class="comment-copy">@user2357112 Rewrote it to focus on the actual question rather than what the OP thought he was asking… and now I'll rewrite it to handle the actual signature rather than the one in the original version of the question…</span>
