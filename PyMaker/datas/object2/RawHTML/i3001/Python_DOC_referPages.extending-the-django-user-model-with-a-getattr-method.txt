<div class="post-text" itemprop="text">
<p>In a Django project, I have a module which extends Django's user model, similar to the following:</p>
<pre><code>from django.contrib.auth.models import User

def __str__(self):
    return "%s %s" % (self.first_name, self.last_name)

User.add_to_class('__str__', __str__)
</code></pre>
<p>I've noticed that this works. However, if I try to define a <code>__getattr__</code> method, like so:</p>
<pre><code>def __getattr__(self, attr):
    if self.user_profile:
        return getattr(self.user_profile, attr)
    else:
        raise AttributeError(f"'{self.__class__.__name__}' has no attribute '{attr}'")
</code></pre>
<p>I get the following error upon importing the module:</p>
<pre><code>(lucy-web-CVxkrCFK) bash-3.2$ python manage.py shell
Traceback (most recent call last):
  File "manage.py", line 28, in &lt;module&gt;
    execute_from_command_line(sys.argv)
  File "/Users/kurtpeek/.local/share/virtualenvs/lucy-web-CVxkrCFK/lib/python3.7/site-packages/django/core/management/__init__.py", line 371, in execute_from_command_line
    utility.execute()
  File "/Users/kurtpeek/.local/share/virtualenvs/lucy-web-CVxkrCFK/lib/python3.7/site-packages/django/core/management/__init__.py", line 347, in execute
    django.setup()
  File "/Users/kurtpeek/.local/share/virtualenvs/lucy-web-CVxkrCFK/lib/python3.7/site-packages/django/__init__.py", line 24, in setup
    apps.populate(settings.INSTALLED_APPS)
  File "/Users/kurtpeek/.local/share/virtualenvs/lucy-web-CVxkrCFK/lib/python3.7/site-packages/django/apps/registry.py", line 112, in populate
    app_config.import_models()
  File "/Users/kurtpeek/.local/share/virtualenvs/lucy-web-CVxkrCFK/lib/python3.7/site-packages/django/apps/config.py", line 198, in import_models
    self.models_module = import_module(models_module_name)
  File "/Users/kurtpeek/.local/share/virtualenvs/lucy-web-CVxkrCFK/lib/python3.7/importlib/__init__.py", line 127, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
  File "&lt;frozen importlib._bootstrap&gt;", line 1006, in _gcd_import
  File "&lt;frozen importlib._bootstrap&gt;", line 983, in _find_and_load
  File "&lt;frozen importlib._bootstrap&gt;", line 967, in _find_and_load_unlocked
  File "&lt;frozen importlib._bootstrap&gt;", line 677, in _load_unlocked
  File "&lt;frozen importlib._bootstrap_external&gt;", line 728, in exec_module
  File "&lt;frozen importlib._bootstrap&gt;", line 219, in _call_with_frames_removed
  File "/Users/kurtpeek/Documents/Dev/lucy2/lucy-web/lucy_web/models/__init__.py", line 25, in &lt;module&gt;
    from .user import User
  File "&lt;frozen importlib._bootstrap&gt;", line 1019, in _handle_fromlist
TypeError: __getattr__() missing 1 required positional argument: 'attr'
</code></pre>
<p>Is it not possible to extend the <code>User</code> model with a <code>__getattr__</code> method in this way?</p>
</div>
<div class="post-text" itemprop="text">
<p>In python 3.7, if you define a module level function called <code>__getattr__</code> <a href="https://www.python.org/dev/peps/pep-0562/" rel="nofollow noreferrer">it will be a module level attribute getter function</a>, similar to a class getattr. Seems like you did that unintentionally. The module level <code>__getattr__</code> has a different call signature from the class method.</p>
<blockquote>
<h3>Specification</h3>
<p>The <code>__getattr__</code> function at the module level should
  accept one argument which is the name of an attribute and return the
  computed value or raise an AttributeError:</p>
<pre><code>def __getattr__(name: str) -&gt; Any: ...
</code></pre>
</blockquote>
<p>Try renaming the function to something else, to avoid unintentionally shadowing a reserved function name.</p>
<pre><code>def  user_getattr(self, attr):
    ...

User.add_to_class('__getattr__', user_getattr)
</code></pre>
<p><a href="https://www.python.org/dev/peps/pep-0562/#backwards-compatibility-and-impact-on-performance" rel="nofollow noreferrer">This is mentioned in PEP 562:</a></p>
<blockquote>
<p>This PEP may break code that uses module level (global) names
  <code>__getattr__</code> and <code>__dir__</code>. (But the language reference explicitly reserves all undocumented dunder names, and allows "breakage without
  warning")</p>
</blockquote>
<p><a href="https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers" rel="nofollow noreferrer">And here's what the language reference says:</a></p>
<blockquote>
<p>Any use of <code>__*__</code> names, in any context, that does not follow
  explicitly documented use, is subject to breakage without warning.</p>
</blockquote>
<p>So you should also rename your custom <code>__str__</code> function to avoid potential future breakage.</p>
</div>
<span class="comment-copy">It seems to do something weird and unexpected with cpython's import machinery. <a href="https://github.com/python/cpython/blob/e42b705188271da108de42b55d9344642170aa2b/Lib/importlib/_bootstrap.py#L1017" rel="nofollow noreferrer">There's an interesting code comment in that _handle_fromlist function</a></span>
