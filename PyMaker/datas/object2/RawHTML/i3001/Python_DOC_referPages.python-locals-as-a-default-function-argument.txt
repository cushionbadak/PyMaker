<div class="post-text" itemprop="text">
<p>Suppose I have a module <code>PyFoo.py</code> that has a function <code>bar</code>. I want <code>bar</code> to print all of the local variables associated with the namespace that called it.</p>
<p>For example:</p>
<pre><code>#! /usr/bin/env python
import PyFoo as pf
var1 = 'hi'
print locals()
pf.bar()
</code></pre>
<p>The two last lines would give the same output. So far I've tried defining <code>bar</code> as such:</p>
<pre><code>def bar(x=locals):
    print x()

def bar(x=locals()):
    print x
</code></pre>
<p>But neither works. The first ends up being what's local to <code>bar</code>'s namespace (which I guess is because that's when it's evaluated), and the second is as if I passed in <code>globals</code> (which I assume is because it's evaluated during <code>import</code>).</p>
<p>Is there a way I can have the default value of argument <code>x</code> of <code>bar</code> be all variables in the namespace which called <code>bar</code>?</p>
<p>EDIT 2018-07-29:</p>
<p>As has been pointed out, what was given was an XY Problem; as such, I'll give the specifics.</p>
<p>The module I'm putting together will allow the user to create various objects that represent different aspects of a numerical problem (e.x. various topology definitions, boundary conditions, constitutive models, ect.) and define how any given object interacts with any other object(s). The idea is for the user to import the module, define the various model entities that they need, and then call a function which will take all objects passed to it, make needed adjustments to ensure capability between them, and then write out a file that represents the entire numerical problem as a text file.</p>
<p>The module has a function <code>generate</code> that accepts each of the various types of aspects of the numerical problem. The default value for all arguments is an empty list. If a non-empty list is passed, then <code>generate</code> will use those instances for generating the completed numerical problem. If an argument is an empty list, then I'd like it to take in all instances in the namespace that called <code>generate</code> (which I will then parse out the appropriate instances for the argument).</p>
<p>EDIT 2018-07-29:</p>
<p>Sorry for any lack of understanding on my part (I'm not that strong of a programmer), but I think I <em>might</em> understand what you're saying with respect to an instance being declared or registered.</p>
<p>From my limited understanding, could this be done by creating some sort of registry dataset (like a <code>list</code> or <code>dict</code>) in the module that will be created when the module is imported, and that all module classes take this registry object in by default.  During class initialization <code>self</code> can be appended to said dataset, and then the <code>genereate</code> function will take the registry as a default value for one of the arguments?</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no way you can do what you want directly.</p>
<p><a href="https://docs.python.org/2/library/functions.html#locals" rel="nofollow noreferrer"><code>locals</code></a> just returns the local variables in whatever namespace it's called in. As you've seen, you have access to the namespace the function is defined in at the time of definition, and you have access to the namespace of the function itself from within the function, but you don't have access to any other namespaces.</p>
<p>You <em>can</em> do what you want <em>indirectly</em>… but it's almost certainly a bad idea. At least this smells like an <a href="http://xyproblem.info/" rel="nofollow noreferrer">XY problem</a>, and whatever it is you're actually trying to do, there's probably a better way to do it.</p>
<p>But occasionally it is necessary, so in case you have one of those cases:</p>
<hr/>
<p>The main good reason to want to know the locals of your caller is for some kind of debugging or other introspection function. And the way to do introspection is almost always through the <a href="https://docs.python.org/2/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> library.</p>
<p>In this case, what you want to inspect is <a href="https://docs.python.org/2/library/inspect.html#the-interpreter-stack" rel="nofollow noreferrer">the interpreter call stack</a>. The calling function will be the first frame on the call stack behind your function's own frame.</p>
<p>You can get the raw stack frame:</p>
<pre><code>inspect.currentframe().f_back
</code></pre>
<p>… or you can get a <code>FrameInfo</code> representing it:</p>
<pre><code>inspect.stack()[1]
</code></pre>
<p>As explained at the top of the <code>inspect</code> docs, a frame object's local namespace is available as:</p>
<pre><code>frame.f_locals
</code></pre>
<p>Note that this has all the same caveats that apply to getting your own locals with <code>locals</code>: what you get isn't the live namespace, but a mapping that, even if it is mutable, can't be used to modify the namespace (or, worse in 2.x, one that <em>may or may not</em> modify the namespace, unpredictably), and that has all cell and free variables flattened into their values rather than their cell references.</p>
<p>Also, see the big warning in the docs about not keeping frame objects alive unnecessarily (or calling their <a href="https://docs.python.org/3/reference/datamodel.html#frame.clear" rel="nofollow noreferrer"><code>clear</code></a> method if you need to keep a snapshot but not all of the references, but I think that only exists in 3.x).</p>
</div>
<span class="comment-copy">This isn't good practice. Please refrain from doing things like this.</span>
<span class="comment-copy">You might be able to access the calling scope with <code>inspect.stack</code>. But it doesn't look like a good idea at all. <a href="https://docs.python.org/3/library/inspect.html#inspect.stack" rel="nofollow noreferrer">docs.python.org/3/library/inspect.html#inspect.stack</a></span>
<span class="comment-copy">This smells like an XY problem. What are you actually trying to do?</span>
<span class="comment-copy">I think it might be better to redesign your API so that users declare or register the instances in some way. But this can be done automatically in the objects' constructors. If you need to have multiple contexts with separate objects, rather than relying on the local namespace to double as a context, you can make it explicit (e.g., passed into each object's constructor), but with a default "current context" for simple cases. If you have concurrency going on, that "current" can be thread-local, async-loop-local or, for 3.7, <code>contextvars</code>. Much like like the <code>decimal</code>. module.</span>
<span class="comment-copy">Another option is the one SymPy uses. Mostly you attach things to each other as you build up the thing you want to solve, but often the evaluation function needs some extra bindings or whatever that can't be attached. Normally you pass them in manually, but for interactive exploratory work, sometimes you just want "everything", and if that includes something it shouldn't that you forgot about, you can deal with the error, since this is all interactive—which you do by just passing in <code>locals()</code> manually. You rarely find yourself using <code>locals()</code> often enough that you wish it were automatic.</span>
