<div class="post-text" itemprop="text">
<p>I have been studying very hard to learn OOP. I understand that objects can be an instance of a class. Classes have parameters and methods and are like an 'object constructor' which the object is created from. I am reorganizing the code in my first project to allow whatever possible to be part of a class. Right now I am working on the GUI but I am having trouble understanding the process in constructing the GUI with classes. Particularly having tabs inside the class and adding objects into each tab. </p>
<p>Here is an example of how my code currently looks:</p>
<pre><code>import tkinter
from tkinter import ttk


class Win:

    def __init__(self, master):
        nb = ttk.Notebook(master, width=390, height=470)
        nb.pack()

        tab = ttk.Frame(nb)
        nb.add(tab, text='title')

        tab2 = ttk.Frame(nb)
        nb.add(tab2, text='Graphs')

        tab3 = ttk.Frame(nb)
        nb.add(tab3, text='Messages')

        tab4 = ttk.Frame(nb)
        nb.add(tab4, text='Instructions')

        label = tkinter.Label(tab, text='text')
        label.grid(row=0, column=0, sticky=tkinter.N, pady=10)

        menu = tkinter.Menu(master, tearoff=False)
        master.config(menu=menu)
        subMenu = tkinter.Menu(menu, tearoff=False)
        menu.add_cascade(label="File", menu=subMenu)
        subMenu.add_separator()
        subMenu.add_command(label='Exit', command=master.destroy)

root = tkinter.Tk()
root.title("SC")
root.geometry('400x500')
root.resizable(width=False, height=False)

main_win = Win(root)

root.mainloop()
</code></pre>
<p>To put objects in each tab within <code>main_win</code>, what do I do? I tried putting objects below <code>main_win</code> and then passing the parameter <code>main_win</code> in the object but that does not seem to work. Should I have a class for making tabs then create an object <code>tab</code> and pass new objects into that?</p>
<p>Thanks in advance for the help. Was unable to find this specific answer anywhere.</p>
</div>
<div class="post-text" itemprop="text">
<p>This code shows one way of adding things to the Notebook tabs. It implements some of abarnert's suggestions, plus a few of my own ideas. I've separated the Notebook off into its own class, and moved the Tk root initialization code into the main GUI class.</p>
<p>I don't claim that this is the best way to do these things, I'm just illustrating a few possibilities to inspire you. ;)</p>
<pre><code>import tkinter as tk
from tkinter import ttk

class GUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("SC")
        self.geometry('400x500')
        self.resizable(width=False, height=False)

        names = ['Title', 'Graphs', 'Messages', 'Instructions']
        self.nb = self.create_notebook(names)
        self.menu = self.create_menus()

        # We can also add items to the Notebook here
        tab = self.nb.tabs['Instructions']
        tk.Label(tab, text='You should\nread these\ninstructions').pack()

        self.mainloop()

    def create_notebook(self, names):
        nb = MyNotebook(self, names)
        nb.pack()

        def add_label(parent, text, row, column):
            label = tk.Label(parent, text=text)
            label.grid(row=row, column=column, sticky=tk.N, pady=10)
            return label

        # Add some labels to each tab
        tab = nb.tabs['Title']
        for i in range(3):
            add_label(tab, 't' + str(i), i, 0)

        tab = nb.tabs['Graphs']
        for i in range(3):
            add_label(tab, 'g' + str(i), 0, i)

        tab = nb.tabs['Messages']
        for i in range(3):
            add_label(tab, 'm' + str(i), i, i)

        return nb

    def create_menus(self):
        menu = tk.Menu(self, tearoff=False)
        self.config(menu=menu)
        subMenu = tk.Menu(menu, tearoff=False)
        menu.add_cascade(label="File", menu=subMenu)
        subMenu.add_separator()
        subMenu.add_command(label='Exit', command=self.destroy)
        return menu

class MyNotebook(ttk.Notebook):
    ''' A customised Notebook that remembers its tabs in a dictionary '''
    def __init__(self, master, names):
        super().__init__(master, width=390, height=470)

        # Create tabs &amp; save them by name in a dictionary
        self.tabs = {}
        for name in names:
            self.tabs[name] = tab = ttk.Frame(self)
            self.add(tab, text=name)

GUI()
</code></pre>
<p>I do most of the work of creating the Notebook and the Menu in separate methods of <code>GUI</code>. I could have put that code inside <code>GUI.__init__</code> but it's more modular to do it in separate methods, and it stops the <code>.__init__</code> method from getting huge.</p>
<p>I've saved the Notebook &amp; Menu as instance attributes <code>self.nb</code> and <code>self.menu</code>. That's not really necessary here, they could just be local variables of <code>GUI.__init__</code>, eg, <code>nb</code> and <code>menus</code>. But storing them as attributes makes them accessible from other methods of <code>GUI</code>, which may be necessary when you add more stuff to the class.</p>
<hr/>
<p>When you derive a class from a parent class, like <code>MyNotebook</code> from <code>ttk.Notebook</code> (or <code>GUI</code> from <code>tk.Tk</code>), if the child class <em>doesn't</em> have its own <code>__init__</code> method then the parent's <code>__init__</code> will automatically get called when you create a child instance. But if the child has its own <code>__init__</code> then the parent <code>__init__</code> <em>won't</em> get called automatically. But we need the stuff in the parent <code>__init__</code> to get done to our new instance of <code>MyNotebook</code> in order for the stuff that inherits from <code>ttk.Notebook</code> to be initialized. So the <code>MyNotebook.__init__</code> does the <code>super</code> call to make that happen.</p>
<p>Generally, if a child class doesn't define a method that the parent class defines then when that method is called on a child instance the version from the parent will be called. And if the child <em>does</em> redefine an inherited method you will often want to call the parent method inside the child method at same stage, and it's usual to use <code>super</code> to do that. <code>__init__</code> is a bit special because it normally gets called automatically to initialize the instance after it's been created.</p>
<hr/>
<p>Here's a simpler version that doesn't use child classes. It also has a Button widget on the root window which prints a string when you click it.</p>
<pre><code>import tkinter as tk
from tkinter import ttk

class GUI:
    def __init__(self):
        root = tk.Tk()
        root.title("SC")
        root.geometry('400x500')
        root.resizable(width=False, height=False)

        names = ['Title', 'Graphs', 'Messages', 'Instructions']
        self.nb = self.create_notebook(root, names)
        self.menu = self.create_menus(root)

        # We can also add items to the Notebook here
        tab = self.nb.tabs['Instructions']
        tk.Label(tab, text='You should\nread these\ninstructions').pack()

        btn = tk.Button(root, text='Click', command=self.button_command)
        btn.pack()

        root.mainloop()

    def button_command(self):
        print('The button was clicked')

    def create_notebook(self, root, names):
        nb = ttk.Notebook(root, width=390, height=450)
        nb.pack()

        # Create tabs &amp; save them by name in a dictionary
        nb.tabs = {}
        for name in names:
            nb.tabs[name] = tab = ttk.Frame(root)
            nb.add(tab, text=name)

        def add_label(parent, text, row, column):
            label = tk.Label(parent, text=text)
            label.grid(row=row, column=column, sticky=tk.N, pady=10)
            return label

        # Add some labels to each tab
        tab = nb.tabs['Title']
        for i in range(3):
            add_label(tab, 't' + str(i), i, 0)

        tab = nb.tabs['Graphs']
        for i in range(3):
            add_label(tab, 'g' + str(i), 0, i)

        tab = nb.tabs['Messages']
        for i in range(3):
            add_label(tab, 'm' + str(i), i, i)

        return nb

    def create_menus(self, root):
        menu = tk.Menu(root, tearoff=False)
        root.config(menu=menu)
        subMenu = tk.Menu(menu, tearoff=False)
        menu.add_cascade(label="File", menu=subMenu)
        subMenu.add_separator()
        subMenu.add_command(label='Exit', command=root.destroy)
        return menu

GUI()
</code></pre>
</div>
<span class="comment-copy"><i>I tried putting objects below main_win and then passing the parameter main_win in the object but that does not seem to work</i>  &lt;-  what does this mean? Also right now all your tab vars are local to <code>__init__</code>. Shouldn't they be instance vars?</span>
<span class="comment-copy">Also, are you sure you don't want <code>Win</code> to either be a subclass of <code>Frame</code>, or just be the <code>Notebook</code>? As it is, it isn't really a window, it's just a think that creates (and then forgets about) a window. (You <i>could</i> learn about MVC and turn it into a <code>WinController</code> class that manages a <code>Frame</code> or <code>Notebook</code>, but it's probably better to learn the simple all-views design first and just make <code>Win</code> <i>be</i> the <code>Frame</code> or <code>Notebook</code>.)</span>
<span class="comment-copy">Anyway, if you change it so that <code>Win</code> is a window or other widget, then you <i>can</i> pass <code>main_win</code> as the parent widget to other widgets and it will work. (I'm not <i>sure</i> that's what you're asking, but I <i>think</i> it is.)</span>
<span class="comment-copy">Great explanation.   What does <code>super().__init__()</code> mean?</span>
<span class="comment-copy">@DavidA <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super</code></a> gives us access to the parent of a class without naming it explicitly. So in <code>MyNotebook</code> the call <code>super().__init__(master, width=390, height=470)</code> is equivalent to <code>ttk.Notebook.__init__(master, width=390, height=470)</code>. But there are reasons to prefer <code>super</code>. See <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="nofollow noreferrer">Python’s super() considered super!</a> by Python core developer Raymond Hettinger for a great introduction to the amazing super powers of super. ;)</span>
<span class="comment-copy">Also, I've just added some info about <code>super</code> and related matters to my answer.</span>
<span class="comment-copy">This is a great explanation. One thing that really is confusing me is how your code seems to reiterate the <code>notebook</code> and the <code>tabs</code> several times. Can you explain why it is written like that? Are you trying to give several examples in this one piece of code? Or is this how the code actually looks?</span>
<span class="comment-copy">@DavidA It's just one program that builds a slightly enhanced version of the GUI that your version builds. Classes &amp; objects aren't <i>that</i> hard, but it can be confusing, and it takes time for it to sink in.</span>
