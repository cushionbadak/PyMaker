<div class="post-text" itemprop="text">
<pre><code>Lst = [[1,2,3],[201,202,203],[3,1,4],[591,2019,3.14]]
</code></pre>
<p>What I need is- </p>
<pre><code>a1,b1,c1 = (1,2,3)

a2,b2,c2 = (201,202,203)
</code></pre>
<p>and so on ... </p>
</div>
<div class="post-text" itemprop="text">
<p>You are a looking to map values to coordinates. Well, you <em>can</em> just access directly via <code>L[outer_list_idx][inner_list_idx]</code> with a couple of list operations.</p>
<h3>For non-numeric indexing, use dict</h3>
<p>You can use a dictionary for a variable number of variables. This removes the need to define a large number of variables explicitly.</p>
<p>Using letters has the obvious limitation of allowing a maximum of 26 lists. If this is what you wish, there's no need to define letters explicitly, use <code>string.ascii_lowercase</code>:</p>
<pre><code>from string import ascii_lowercase

L = [[1,2,3],[201,202,203],[3,1,4],[591,2019,3.14]]

m, n = len(L), len(L[0])

d = {(ascii_lowercase[j], i+1): L[i][j] for i in range(m) for j in range(n)}

print(d)

{('a', 1): 1, ('b', 1): 2, ('c', 1): 3,
 ('a', 2): 201, ('b', 2): 202, ('c', 2): 203,
 ('a', 3): 3, ('b', 3): 1, ('c', 3): 4,
 ('a', 4): 591, ('b', 4): 2019, ('c', 4): 3.14}
</code></pre>
<p>Then access via tuple keys. So, to retrieve the 2nd value from the 3rd list, you can use <code>d[('b', 3)]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer">use <code>itertools.chain.from_iterable()</code></a> for this:</p>
<pre><code>t = [[1,2,3],[201,202,203],[3,1,4],[591,2019,3.14]]

from itertools import chain 
a1,b1,c1,a2,b2,c2,a3,b3,c3,a4,b4,c4 = chain.from_iterable(t) # flattens the list of lists

print(a1,b1,c1,a2,b2,c2,a3,b3,c3,a4,b4,c4)
</code></pre>
<p>Output:</p>
<pre><code> 1 2 3 201 202 203 3 1 4 591 2019 3.14
</code></pre>
<p>You need to know the dimensions of the list beforehand and the variablenames. I would probably just use the original list ...</p>
</div>
<div class="post-text" itemprop="text">
<p>Do you just need the values? Then like that:</p>
<pre><code>Lst = [[1,2,3],[201,202,203],[3,1,4],[591,2019,3.14]]

for k in Lst:

    a, b, c = k
    print(a, b, c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The example is can be solved with simple tuple unpacking. You can use <code>zip</code> to pair your values:</p>
<pre><code>lst = [[1,2,3],[201,202,203],[3,1,4],[591,2019,3.14]]

((a1, b1, c1), (a2, b2, c2)), _ = zip(lst[::2], lst[1::2])
print(a1, b1, c1)
print(a2, b2, c2)
</code></pre>
<p>This will print:</p>
<pre><code>1 2 3
201 202 203
</code></pre>
<p>If you want next values, you can do:</p>
<pre><code>_, ((a1, b1, c1), (a2, b2, c2)) = zip(lst[::2], lst[1::2])
print(a1, b1, c1)
print(a2, b2, c2)
</code></pre>
<p>Output:</p>
<pre><code>3 1 4
591 2019 3.14
</code></pre>
</div>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/6967632/unpacking-extended-unpacking-and-nested-extended-unpacking">python - Unpacking, extended unpacking, and nested extended unpacking - Stack Overflow</a></span>
<span class="comment-copy">I suppose that you're thinking that OP has an XY problem and try to solve the X.</span>
<span class="comment-copy">You probably meant "downvoting a <b>good</b> answer for a bad question". Although if it's a duplicate, people should just answer the duplicate target.</span>
<span class="comment-copy">My example wasn't the <i>best</i> because I use numeric coordinates. You can, fairly easily, also use <code>a</code> instead of <code>1</code> etc.</span>
<span class="comment-copy">Downvoter care to comment?</span>
<span class="comment-copy">Thanks @jpp - no idea why/who dv but I'd rather have constructive feedback with a dv as well.</span>
<span class="comment-copy">Not sure what this solves. OP wants different "slices" assigned to different variables.</span>
