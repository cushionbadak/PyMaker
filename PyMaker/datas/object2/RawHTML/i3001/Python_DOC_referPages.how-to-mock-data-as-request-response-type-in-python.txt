<div class="post-text" itemprop="text">
<p>I would like to write some testcase to exercise <em>object_check</em> in isinstance(obj, requests.Response) logic. After I create Mock data as return value for requests.post. The type for mock data is always be Mock class. In that way, how can I rewrite mock data so mock data can be type of requests.Response? so I can exercise line <code>d = obj.json()</code>?</p>
<pre><code>from unittest.mock import patch, Mock
import unittest
import requests
from requests.exceptions import HTTPError
import pytest
def object_check(obj):
    if isinstance(obj, bytes):
        d = ujson.decode(obj.decode())
    elif isinstance(obj, requests.Response):
        d = obj.json()
    else:
        raise ValueError('invalid type')
    return d

def service_post(params):
    """
    trivial function that does a GET request
    against google, checks the status of the
    result and returns the raw content
    """
    url = "https://www.iamdomain.com"
    params = {'number': 1234, 'user_id': 1, 'name': 'john'}
    resp = requests.post(url, data=params)
    return object_check(resp)

@patch.object(requests, 'post')
def test_service_post(mock_request_post):
    data = {'number': 0000, 'user_id': 0, 'name': 'john'}
    def res():
        r = Mock()
        r.status_code.return_value = 200
        r.json.return_value = data
        return r
    mock_request_post.return_value = res()
    assert data == service_post(data)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do this:</p>
<pre><code>@patch.object(requests, 'post')
def test_service_post(mock_request_post):
    data = {'number': 0000, 'user_id': 0, 'name': 'john'}
    def res():
        r = requests.Response()
        r.status_code = 200
        def json_func():
            return data
        r.json = json_func
        return r
    mock_request_post.return_value = res()
    assert data == service_post(data)
</code></pre>
<p>Test then passed for me when I ran it locally. <strong>Be aware that Mock is a mini-smell.</strong></p>
<p>I used to be a big fan of <code>Mock</code>. As I've grown as a dev, though, I really try to avoid it. It can trick you into some really bad design, and they can be really hard to maintain (especially since you're modifying your <code>Mock</code> to hold return values). <code>Mock</code> can also create a false sense of security (your test will continue to pass even if the web services changes dramatically, so you might explode in prod). I don't think you really need it here. Two alternatives:</p>
<ol>
<li>You could hit whatever service you're trying to hit, and serialize (save) that response out with <code>pickle</code>, and store to disk (save it in your test suite). Then have your unit test read it back in and use the actual response object. You'd still have to <code>patch</code> over <code>requests.post</code>, but at least the return values will be lined up for you and you won't have to add or modify them as your needs/application grows.</li>
<li>Just hit the web. Forget the <code>patch</code> entirely: just do the POST in your test and check the response. Of course, this might be slow, and will only work if you have internet. And you'll get goofy purists who will tell you to never to do this in a unit test. Maybe move it to an integration test if you run into one of those puristy people. But seriously, there's no substitute for doing what you're actually going to do in prod. The upside to doing this is that if the web service changes, then you'll know about it right away and can fix your code. Downside is it can slow down your test suite, and it's a potentially unreliable test (if the webservice is down, your test will fail...but it might actually be good to know that).</li>
</ol>
<p>I recommend if the webservice is unstable (i.e liable to change), use option 2. Else, use  option 1. Or do some combination of both (<code>Mock</code> and <code>patch</code> for a unit test, and hit the service on an integration test). Only you can decide!</p>
<p>HTH, good luck!</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock" rel="nofollow noreferrer"><code>spec</code></a> argument when instantiating the mock:</p>
<pre><code>&gt;&gt;&gt; from unittest.mock import Mock
&gt;&gt;&gt; from requests import Response
&gt;&gt;&gt; m = Mock(spec=Response)
&gt;&gt;&gt; m.__class__
requests.models.Response
&gt;&gt;&gt; isinstance(m, Response)
True
</code></pre>
<p>Also note that <code>r.status_code.return_value = 200</code> will not work with speccing; set the value directly instead:</p>
<pre><code>r.status_code = 200
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to mock the <code>text</code> or <code>content</code> @property value use <code>PropertyMock</code> around the <code>text</code></p>
<pre><code>@patch.object(requests, 'post')
def test_service_post(mock_request_post):
    data = {'number': 0000, 'user_id': 0, 'name': 'john'}
    def res():
        r = requests.Response()
        r.status_code = 200
        type(r).text = mock.PropertyMock(return_value=my_text)  # property mock
        def json_func():
            return data
        r.json = json_func
        return r
    mock_request_post.return_value = res()
    assert data == service_post(data)
</code></pre>
</div>
<span class="comment-copy">thank you..it is great suggestion. for option 1, what is the best way for me "serialize (save) that response out with pickle"? like your code example?</span>
<span class="comment-copy"><code>pickle.dump(your_object, your_file_descriptor)</code> and <code>pickle.load("your_filename")</code>. You can see more here: <a href="https://stackoverflow.com/questions/4530611/saving-and-loading-objects-and-using-pickle" title="saving and loading objects and using pickle">stackoverflow.com/questions/4530611/â€¦</a> and the pickle docs are here: <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer">docs.python.org/3/library/pickle.html</a>. You'll want to actually hit the webservice, and then insert the dump logic right after <code>elif isinstance(obj, requests.Response):</code>. Similarly, when you do the test, you read that <code>requests.Response</code> object back in from disk and pass it around everywhere you want to run unit tests that need it as a dependency</span>
<span class="comment-copy">Excellent! Glad to have helped.</span>
<span class="comment-copy">but <code>isinstance(m, request.Response)</code> == False? that is my question</span>
<span class="comment-copy">I'm not sure what your question is. There is no such class <code>requests.Response</code> (apart from <code>request.Response</code> you wrote; I assume this is only a typo). There is a class <code>requests.models.Response</code> which is <b>exported</b> in <code>requests.__init__.py</code> via <code>__all__</code>. So <code>isinstance(m, requests.Response)</code> will return <code>True</code>.</span>
