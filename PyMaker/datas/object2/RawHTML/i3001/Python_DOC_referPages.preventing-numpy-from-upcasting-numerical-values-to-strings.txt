<div class="post-text" itemprop="text">
<p>Normally, I'm happy with the way numpy determines the minimum type required to hold the objects of the sequence in <a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.array.html" rel="nofollow noreferrer"><code>np.array</code></a>:</p>
<pre><code>&gt;&gt;&gt; print(np.array([42, 4.2]))
array([42, 4.2], dtype=float64)
</code></pre>
<p>That is quite intuitive: I need to upcast an integer to a float in order to handle the data.</p>
<p>However, the following case seems to be less intuitive to me:</p>
<pre><code>&gt;&gt;&gt; print(np.array([42, 4.2, 'aa']))
array(['42', '4.2', 'aa'], dtype='&lt;U32')
</code></pre>
<p>I would prefer the resulting array to be of type <code>np.object</code>. I don't want to call</p>
<pre><code>np.array(ma_list, dtype=np.object)
</code></pre>
<p>because I would like to keep the old behavior in the case of <code>my_list=[42, 4.2]</code> and also in case of <code>my_list=['aa']</code> (which would result in type being <code>&lt;U2</code>).</p>
<p>Is it possible to tweak the default behavior in order to prevent the upcasting  of numerical values to a string, or is there any workaround with the same effect?</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like you want to do a bit of pre-processing on your data before you let numpy determine the data type. From what I understood of your criteria, if all the objects in the list are numbers, or all of them are not numbers, you want to let numpy determine the type. If the categories are mixed, you want to use <code>np.object</code>.</p>
<p>Fortunately, all numbers in Python have the abstract base class <a href="https://docs.python.org/3/library/numbers.html#numbers.Number" rel="nofollow noreferrer"><code>numbers.Number</code></a> hooked in:</p>
<pre><code>from numbers import Number

isnum = lambda x: isinstance(x, Number)
isntnum = lambda x: not isinstance(x, Number)
if all(map(isnum, my_list)) or all(map(isntnum, my_list)):
    dtype = None
else:
    dtype = np.object

my_arr = np.array(my_list, dtype=dtype)
</code></pre>
<p>The phrasing here isn't ideal, but it should work, and give you a starting point for something more elegant and efficient.</p>
</div>
<div class="post-text" itemprop="text">
<p>After looking through all of the C code that I could in ~30 minutes, I've concluded there is no great way of doing this.</p>
<p>My best bet would be the following:</p>
<pre><code>a = np.array([4.2,42,'42'])
if str(a.dtype)[:2]=='&lt;U':
    a = np.array([4.2,42,'42'],dtype=np.object)
</code></pre>
<p>I'll admit that this is really hacky, since it relies on the fact that <code>np.array</code> casts these string/float arrays to unicode data types, but it should work well, at least for small arrays.</p>
</div>
<span class="comment-copy"><code>np.array([42, 4.2, '42']).astype(float)</code>?</span>
<span class="comment-copy">@xdze2 that doesn't work. Causes an error or casts the string to a float</span>
<span class="comment-copy">ok, i didn't understood what you want...</span>
<span class="comment-copy">@ead I don't think you have a better option than a try-catch block imo. I don't think your desired behavior can be created any other way</span>
<span class="comment-copy">Got it (That makes things a tad bit more difficult but understood)</span>
<span class="comment-copy">It looks promising, but <code>np.array(['aa'])</code> would end-up being of type <code>np.object</code> and not  <code>&lt;U2</code>. Sorry, I didn't explicitly mention this in question.</span>
<span class="comment-copy">Oof...that's an issue</span>
<span class="comment-copy">I honestly don't know a way to deal with that other than check whether every element in the list is a string</span>
<span class="comment-copy">checking all elements doesn't sound that bad....</span>
<span class="comment-copy">It's inelegant tho...I don't like it, but I've wasted too much time trying to figure this out, so I'm going to move on unsatisfied.</span>
