<div class="post-text" itemprop="text">
<p>Suppose I have a large hex number, 0x1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF</p>
<p>and I wanted to get bytes 10-20, from this hex number easily, how would I accomplish that? I know I can cut the data from bit shifting right by 10*8 times but I still have the significant bytes in my left over hex number.</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way is to use string slices. Since the lowest byte is on the far right and the highest is on the left, we can utilise negative indexes.</p>
<pre><code>def sub_bytes(i, start=0, end=0):
    i_str = hex(i)[2:]  # skip 0x part
    i_sub = i_str[-end * 2: len(i_str) - start * 2]  # get the bytes we need
    return int(i_sub or '0', 16)  # convert to back int
</code></pre>
<p><code>len(i_str)</code> is here for better start=0 handling</p>
<p>Let's try with your value</p>
<pre><code>In [2]: value = 0x1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF

In [3]: sub_bytes(value, 0, 3)
Out[3]: 11259375

In [4]: hex(sub_bytes(value, 0, 3))
Out[4]: '0xabcdef'

In [6]: hex(sub_bytes(value, 10, 20))
Out[6]: '0x90abcdef1234567890ab'

In [7]: hex(sub_bytes(value, 45))
Out[7]: '0x123456'
</code></pre>
<p>If a requested slice is empty or out of range I return 0x0 here, but you may raise <code>IndexError</code> if you like.</p>
<p><strong>UPDATE</strong></p>
<p>In Python 3.2+ there are <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="nofollow noreferrer"><code>to_bytes</code></a> and <a href="https://docs.python.org/3/library/stdtypes.html#int.from_bytes" rel="nofollow noreferrer"><code>from_bytes</code></a> defined on <code>int</code> that are more efficient and more handy for this case</p>
<pre><code>import math

def slice_bytes(value, a=None, b=None, byteorder='little'):
    size = math.ceil(value.bit_length() / 8)
    value_bytes = value.to_bytes(size, byteorder)
    return int.from_bytes(value_bytes[a: b], byteorder)
</code></pre>
<p>And after some performance testing on a number <code>7 ** 7 ** 7</code> which has 288998 bytes, I found <code>slice_bytes</code> to be faster than the direct approach by Karl. <code>sub_bytes</code> is apparently slower.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of messing with strings and substrings I feel like the bit mask approach is a more direct approach to getting the bits you need. In your comment you mentioned the bit mask would be very big and that is true, but that is not an issue for a program.</p>
<p>I have an example function which can make a mask for you depending on how many bytes you want to get from the data. Then you simply <code>AND</code> that mask with the right shifted value to get the value you want.</p>
<p>Say you want to get 4 bytes of data starting from byte index 2:</p>
<pre><code>def get_bytes(value, start, amount):  
    shifted_value = value &gt;&gt; (start * 8) # Multiply by 8 for how much to right shift
    mask = make_mask(amount) 
    return shifted_value &amp; mask

def make_mask(byte_amount):
    if byte_amount &gt; 0:
        bin_string = '1' * (byte_amount * 8)  # Create binary string mask
    else:
        bin_string = '0'  # Make result 0
    return int(bin_string, 2)  # Return integer representation

value = 0x1234567890ABCDEF1234567890ABCDEF
result = get_bytes(value, 2, 4)
</code></pre>
<p>The result ends up being <code>1450741931</code> in the resulting decimal integer which translates to <code>0x567890ab</code> in hex.</p>
</div>
<span class="comment-copy">It's just a string of hex digits?  <a href="https://stackoverflow.com/q/663171">stackoverflow.com/q/663171</a></span>
<span class="comment-copy">It's simple mathematics: <code>index = (pos*2)</code> with base pos = 1. So first byte is <code>pos=1</code> and hence <code>index=2</code> in a zero-based array.</span>
<span class="comment-copy">... and then take 10*2 digits to get the 10 bytes.</span>
<span class="comment-copy">You could use a bit mask to AND the bit shifted value to only get the bits you need.</span>
<span class="comment-copy">but my bit mask will be huge @Karl it would be something like 0xFFFFFFFFFFFFFFFFFFFF. bytes 10-20 is just an example, I'm wanting to d othis with around 40 bytes</span>
<span class="comment-copy">Thanks! This works for now, I wanted to see if there was any more efficient ways from using bit manipulation but I guess not :)</span>
<span class="comment-copy">How would you actually raise the IndexError? right now you're returning 0 by default in your return statement</span>
<span class="comment-copy">I would write <code>if not i_sub: raise IndexError("no bytes in the slice")</code> or something like that right before the return statement</span>
