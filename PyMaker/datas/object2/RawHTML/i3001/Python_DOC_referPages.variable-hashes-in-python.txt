<div class="post-text" itemprop="text">
<p>I've implemented a BloomFilter in python 3.3, and got different results every session. Drilling down this weird behavior got me to the internal hash() function - it returns different hash values for the same string every session.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; hash("235")
-310569535015251310
</code></pre>
<p>----- opening a new python console -----</p>
<pre><code>&gt;&gt;&gt; hash("235")
-1900164331622581997
</code></pre>
<p>Why is this happening?
Why is this useful?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python uses a random hash seed to prevent attackers from tar-pitting your application by sending you keys designed to collide. See the <a href="http://www.ocert.org/advisories/ocert-2011-003.html" rel="noreferrer">original vulnerability disclosure</a>. By offsetting the hash with a random seed (set once at startup) attackers can no longer predict what keys will collide.</p>
<p>You can set a fixed seed or disable the feature by setting the <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED" rel="noreferrer"><code>PYTHONHASHSEED</code> environment variable</a>; the default is <code>random</code> but you can set it to a fixed positive integer value, with <code>0</code> disabling the feature altogether.</p>
<p>Python versions 2.7 and 3.2 have the feature disabled by default (use the <code>-R</code> switch or set <code>PYTHONHASHSEED=random</code> to enable it); it is enabled by default in Python 3.3 and up.</p>
<p>If you were relying on the order of keys in a Python dictionary or set, then don't. Python uses a hash table to implement these types and their order <a href="https://stackoverflow.com/questions/15479928/why-is-the-order-in-python-dictionaries-and-sets-arbitrary/15479974#15479974">depends on the insertion and deletion history</a> as well as the random hash seed.</p>
<p>Also see the <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="noreferrer"><code>object.__hash__()</code> special method documentation</a>:</p>
<blockquote>
<p><strong>Note</strong>: By default, the <code>__hash__()</code> values of str, bytes and datetime objects are “salted” with an unpredictable random value. Although they remain constant within an individual Python process, they are not predictable between repeated invocations of Python.<br/>
  This is intended to provide protection against a denial-of-service caused by carefully-chosen inputs that exploit the worst case performance of a dict insertion, O(n^2) complexity. See <a href="http://www.ocert.org/advisories/ocert-2011-003.html" rel="noreferrer">http://www.ocert.org/advisories/ocert-2011-003.html</a> for details.<br/>
  Changing hash values affects the iteration order of dicts, sets and other mappings. Python has never made guarantees about this ordering (and it typically varies between 32-bit and 64-bit builds).<br/>
  See also <code>PYTHONHASHSEED</code>.</p>
</blockquote>
<p>If you need a stable hash implementation, you probably want to look at the <a href="https://docs.python.org/3/library/hashlib.html" rel="noreferrer"><code>hashlib</code> module</a>; this implements cryptographic hash functions. The <a href="https://github.com/jaybaird/python-bloomfilter/blob/master/pybloom/pybloom.py#L54-L98" rel="noreferrer">pybloom project uses this approach</a>.</p>
<p>Since the offset consists of a prefix and a suffix (start value and final XORed value, respectively)  you cannot just store the offset, unfortunately. On the plus side, this does mean that attackers cannot easily determine the offset with timing attacks either.    </p>
</div>
<div class="post-text" itemprop="text">
<p>Hash randomisation is <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-R" rel="noreferrer">turned on by default in Python 3</a>. This is a security feature:</p>
<blockquote>
<p>Hash randomization is intended to provide protection against a denial-of-service caused by carefully-chosen inputs that exploit the worst case performance of a dict construction</p>
</blockquote>
<p>In previous versions from 2.6.8, you could switch it on at the command line with -R, or the <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED" rel="noreferrer">PYTHONHASHSEED</a> environment option.</p>
<p>You can switch it off by setting <code>PYTHONHASHSEED</code> to zero.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>hash()</strong> is a Python <strong>built-in function</strong> and use it to calculate a hash value for <strong>object</strong>, not for string or num.</p>
<p>You can see the detail in this page: <a href="https://docs.python.org/3.3/library/functions.html#hash" rel="nofollow">https://docs.python.org/3.3/library/functions.html#hash</a>.</p>
<p>and hash() values comes from the object's __hash__ method.
The doc says the followings:</p>
<blockquote>
<p>By default, the <strong>hash</strong>() values of str, bytes and datetime objects are “salted” with an unpredictable random value. Although they remain constant within an individual Python process, they are not predictable between repeated invocations of Python.</p>
</blockquote>
<p>That's why your have diffent hash value for the same string in different console.</p>
<p>What you implement is not a good way.</p>
<p>When you want to calculate a string hash value, just use <a href="https://docs.python.org/3.3/library/hashlib.html" rel="nofollow">hashlib</a></p>
<p>hash() is aim to get a object hash value, not a stirng.</p>
</div>
<span class="comment-copy">This is a security feature.</span>
<span class="comment-copy">I'd expect this to show up in the hash() docs and not only in __hash__().  +1 for a great answer.  p.s. Isn't hashlib an overkill for non-cryptographic uses of hash functions?</span>
<span class="comment-copy">pybloom uses the hashlib functions. But if you want something faster, you could check out <a href="https://github.com/flier/pyfasthash" rel="nofollow noreferrer">pyhash</a>.</span>
<span class="comment-copy">Why does the documentation call it <code>disable</code> when setting it to 0? I don't see the effective difference to setting it to any old stable seed number, unless I'm missing something. What I mean is when I use <code>PYTHONHASHSEED=12345</code> I get the same hash for equal strings even across sessions - the same happens when I use <code>PYTHONHASHSEED=0</code> - the hash for equal strings will be the same across sessions (albeit different to 12345, but that's obvious, that's how seeds work).</span>
<span class="comment-copy">@blubberdiblub: with <code>0</code> there is no seed at all and hashes for objects are equal to those generated in an older Python version without any hashseed support.</span>
<span class="comment-copy">@MartijnPieters what does it mean for the affected hashes to have "no seed at all"? What's the semantic or qualitative difference to having a seed of, say, 12345, apart from the fact that it creates two distinct sets of sessions between which the hash values are different and apart from PYTHONHASHSEED=0 being equal to older versions? Can you link me to a particular piece of source code? I guess my point is that if there is no such difference, I'd call it a seed of 0 and older versions of Python only supporting a seed of 0. The documentation as it stands right now is quite confusing to me.</span>
<span class="comment-copy"><code>hash()</code> is perfectly valid for string or numeric values. You are confusing this with the <code>__hash__</code> custom method, used <b>by <code>hash()</code></b> to provide a custom implementation of the hash value.</span>
