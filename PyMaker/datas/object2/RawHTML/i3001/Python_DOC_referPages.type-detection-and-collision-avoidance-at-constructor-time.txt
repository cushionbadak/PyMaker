<div class="post-text" itemprop="text">
<p>Thanks everyone for your help so far. I've narrowed it down a bit. If you look at HERE in both the script and the class, and run the script, you'll see what is going on. </p>
<p>The ADD line print "789 789"</p>
<p>when it should be printing "456 789" </p>
<p>What appears to be happening, is in <strong>new</strong> the class is detecting the type of the incoming argument. However if the incoming object, has the same type as the constructor it appears to be paging the incoming object, into itself (at the class level) instead of returning the old object. That is the only thing I can think of that would cause 456 to get creamed. </p>
<p>So how do you detect something that is the same type of a class, within a constructor and decide NOT to page that data into the class memory space, but instead return the previously constructed object? </p>
<pre><code>import sys
import math

class Foo(): 

    # class level property

    num = int(0) 

    # 
    # Python Instantiation Customs: 
    # 
    # Processing polymorphic input new() MUST return something or 
    # an object?,  but init() cannot return anything. During runtime 
    # __new__ is running at the class level, while init is running 
    # at the instance level. 
    # 

    def __new__(self,*arg): 

        print ("arg type: ", type(arg[0]).__name__)

###  functionally the same as isinstance() below
#
#       if (type(arg[0]).__name__) == "type": 
#           if arg[0].__name__ == "Foo":
#               print ("\tinput was a Foo")
#               return arg[0] # objects of same type intercede

### HERE &lt;------------------------------------- 
# 
# this creams ALL instances, because since we are a class 
# the properties of the incoming object, seem to overwride 
# the class, rather than exist as a separate data structure. 

        if (isinstance(arg[0], Foo)): 
            print ("\tinput was a Foo")
            return arg[0] # objects of same type intercede

        elif (type(arg[0]).__name__) == "int": 
            print ("\tinput was an int")
            self.inum = int(arg[0]) # integers store
            return self

        elif (type(arg[0]).__name__) == "str": 
            print ("\tinput was a str")
            self.inum = int(arg[0]) # strings become integers
            return self

        return self 

    def __init__(self,*arg):
        pass

    # 
    # because if I can do collision avoidance, I can instantiate 
    # inside overloaded operators: 
    # 

    def __add__(self,*arg): 

        print ("add operator overload")

        # no argument returns self

        if not arg: 
            return self

        # add to None or zero return self

        if not arg[0]: 
            return self

        knowntype = Foo.Foo(arg[0])

        # add to unknown type returns False

        if not knowntype: 
            return knowntype

        # both values are calculable, calculate and return a Foo

        typedresult = (self.inum + knowntype.inum) 

        return Foo.Foo(typedresult) 

    def __str__(self): # return a stringified int or empty string

        # since integers don't have character length, 
        # this tests the value, not the existence of:  

        if self.inum: 
            return str(self.inum)

        # so the property could still be zero and we have to 
        # test again for no reason. 

        elif self.inum == 0:
            return str(self.inum)   

        # return an empty str if nothing is defined. 

        return str("")
</code></pre>
<p>testfoo.py:</p>
<pre><code>#! /usr/bin/python

import sys
import Foo 

# A python class is not transparent like in perl, it is an object 
# with unconditional inheritance forced on all instances that share 
# the same name. 

classhandle = Foo.Foo 

# The distinction between the special class object, and instance 
# objects is implicitly defined by whether there is a passed value at 
# constructor time. The following therefore does not work. 

# classhandle = Foo.Foo() 

# but we can still write and print from the class, and see it propagate, 
# without having any "object" memory allocated.  

print ("\nclasshandle: ", classhandle)
print ("classhandle classname: ", classhandle.__name__) # print the classname
print ("class level num: ", classhandle.num)     # print the default num
classhandle.classstring = "fdsa" # define an involuntary value for all instances

print ("\n")

# so now we can create some instances with passed properties. 

instance1 = Foo.Foo(int(123)) # 

print ("\ninstance1: ", instance1)
print ("involuntary property derived from special class memory space: ", instance1.classstring)
print ("instance property from int: ", instance1.inum)

print ("\n")

instance2 = Foo.Foo(str("456"))
print ("\ninstance2: ", instance2)
print ("instance2 property from int: ", instance2.inum)

# 
# instance3 stands for (shall we assume) some math that happened a 
# thousand lines ago in a class far far away. We REALLY don't 
# want to go chasing around to figure out what type it could possibly 
# be, because it could be polymorphic itself. Providing a black box so 
# that you don't have to do that, is after all, the whole point OOP. 
# 

print ("\npretend instance3 is unknowningly already a Foo")
instance3 = Foo.Foo(str("789"))

## So our class should be able to handle str,int,Foo types at constructor time. 

print ("\ninstance4 should be a handle to the same memory location as instance3")

instance4 = Foo.Foo(instance3) # SHOULD return instance3 on type collision

# because if it does, we should be able to hand all kinds of garbage to 
# overloaded operators, and they should remain type safe.  

# HERE &lt;-----------------------------
# 
# the creation of instance4, changes the instance properties of instance2: 
# below, the instance properties inum, are now both "789". 

print ("ADDING: ", instance2.inum, " ", instance4.inum)

# instance6 = instance2 + instance4 # also should be a Foo object
# instance5 = instance4 + int(549) # instance5 should be a Foo object. 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How do I, at constructor time, return a non-new object?</p>
</blockquote>
<p>By overriding the constructor method, <a href="https://docs.python.org/3/reference/datamodel.html#basic-customization" rel="nofollow noreferrer"><code>__new__</code></a>, not the initializer method, <code>__init__</code>.</p>
<p>The <code>__new__</code> method constructs an instance—normally by calling the super's <code>__new__</code>, which eventually gets up to <code>object.__new__</code>, which does the actual allocation and other under-the-covers stuff, but you can override that to return a pre-existing value.</p>
<p>The <code>__init__</code> method is handed a value that's already been constructed by <code>__new__</code>, so it's too late for it to not construct that value.</p>
<p>Notice that if <code>Foo.__new__</code> returns a <code>Foo</code> instance (whether a newly-created one or an existing one), <code>Foo.__init__</code> will be called on it. So, classes that override <code>__new__</code> to return references to existing objects generally need an idempotent <code>__init__</code>—typically, you just don't override <code>__init__</code> at all, and do all of your initialization inside <code>__new__</code>.</p>
<hr/>
<p>There are lots of examples of trivial <code>__new__</code> methods out there, but let's show one that actually does a simplified version of what you're asking for:</p>
<pre><code>class Spam:
    _instances = {}
    def __new__(cls, value):
        if value not in cls._instances:
            cls._instances[value] = super().__new__(cls)
            cls._instances[value].value = value
        return cls._instances[value]
</code></pre>
<p>Now:</p>
<pre><code>&gt;&gt;&gt; s1 = Spam(1)
&gt;&gt;&gt; s2 = Spam(2)
&gt;&gt;&gt; s3 = Spam(1)
&gt;&gt;&gt; s1 is s2
False
&gt;&gt;&gt; s1 is s3
True
</code></pre>
<p>Notice that I made sure to use <code>super</code> rather than <code>object</code>, and <code>cls._instances</code><sup>1</sup> rather than <code>Spam._instances</code>. So:</p>
<pre><code>&gt;&gt;&gt; class Eggs(Spam):
...     pass
&gt;&gt;&gt; e4 = Eggs(4)
&gt;&gt;&gt; Spam(4)
&lt;__main__.Eggs at 0x12650d208&gt;
&gt;&gt;&gt; Spam(4) is e4
True
&gt;&gt;&gt; class Cheese(Spam):
...     _instances = {}
&gt;&gt;&gt; c5 = Cheese(5)
&gt;&gt;&gt; Spam(5)
&lt;__main__.Spam at 0x126c28748&gt;
&gt;&gt;&gt; Spam(5) is c5
False
</code></pre>
<hr/>
<p>However, it may be a better option to use a classmethod alternate constructor, or even a separate factory function, rather than hiding this inside the <code>__new__</code> method.</p>
<p>For some types—like, say, a simple immutable container like <code>tuple</code>—the user has no reason to care whether <code>tuple(…)</code> returns a new tuple or an existing one, so it makes sense to override the constructor. But for some other types, especially mutable ones, it can lead to confusion. </p>
<p>The best test is to ask yourself whether this (or similar) would be confusing to your users:</p>
<pre><code>&gt;&gt;&gt; f1 = Foo(x)
&gt;&gt;&gt; f2 = Foo(x)
&gt;&gt;&gt; f1.spam = 1
&gt;&gt;&gt; f2.spam = 2
&gt;&gt;&gt; f1.spam
2 
</code></pre>
<ul>
<li>If that can't happen (e.g., because <code>Foo</code> is immutable), override <code>__new__</code>.</li>
<li>If that exactly what users would expect (e.g., because <code>Foo</code> is a proxy to some object that has the actual <code>spam</code>, and two proxies to the same object had better see the same <code>spam</code>), probably override <code>__new__</code>.</li>
<li>If it would be confusing, probably don't override <code>__new__</code>.</li>
</ul>
<p>For example, with a classmethod:</p>
<pre><code>&gt;&gt;&gt; f1 = Foo.from_x(x)
&gt;&gt;&gt; f2 = Foo.from_x(x)
</code></pre>
<p>… it's a lot less likely to be surprising if <code>f1 is f2</code> turns out to be true.</p>
<hr/>
<p><sub>1. Even though you define <code>__new__</code> like an instance method, and its body looks like a class method, it's actually a static method, that gets passed the class you're trying to construct (which will be <code>Spam</code> or a subclass of <code>Spam</code>) as an ordinary first parameter, with the constructor arguments (and keyword arguments) passed after that.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks everyone who helped! This answer was saught out to understand how to refactor an existing program that was already written, but that was having scalability problems. The following is the completed working example. What it demonstrates is: </p>
<p>The ability to test incoming types and avoid unneccessary object duplication at constructor time, given incoming types that are both user-defined and built-in. The ability to construct on the fly from a redefined operator or method. These capabilities are neccessary for writing scalable supportable API code. YMMV.</p>
<p>Foo.py</p>
<pre><code>import sys
import math

class Foo(): 

    # class level property

    num = int(0) 

    # 
    # Python Instantiation Customs: 
    # 
    # Processing polymorphic input new() MUST return something or 
    # an object,  but init() MAYNOT return anything. During runtime 
    # __new__ is running at the class level, while __init__ is 
    # running at the instance level. 
    # 

    def __new__(cls,*arg): 

        print ("arg type: ", type(arg[0]).__name__)

        # since we are functioning at the class level, type() 
        # is reaching down into a non-public namespace, 
        # called "type" which is presumably something that 
        # all objects are ultimately derived from. 

        # functionally this is the same as isinstance() 

        if (type(arg[0]).__name__) == "Foo": 
            fooid = id(arg[0])
            print ("\tinput was a Foo: ", fooid)
            return arg[0] # objects of same type intercede

        # at the class level here, we are calling into super() for 
        # the constructor. This is presumably derived from the type() 
        # namespace, which when handed a classname, makes one of 
        # whatever it was asked for, rather than one of itself.  

        elif (type(arg[0]).__name__) == "int": 
            self = super().__new__(cls)
            self.inum = int(arg[0]) # integers store
            fooid = id(self)
            print ("\tinput was an int: ", fooid)
            return (self)

        elif (type(arg[0]).__name__) == "str": 
            self = super().__new__(cls)
            self.inum = int(arg[0]) # strings become integers
            fooid = id(self)
            print ("\tinput was a str: ", fooid)
            return (self)

#   def __init__(self,*arg):
#       pass

    # 
    # because if I can do collision avoidance, I can instantiate 
    # inside overloaded operators: 
    # 

    def __add__(self,*arg): 

        argtype = type(arg[0]).__name__

        print ("add overload in class:", self.__class__)

        if argtype == "Foo" or argtype == "str" or argtype == "int":   

            print ("\tfrom a supported type")

            # early exit for zero

            if not arg[0]: 
                return self

            # localized = Foo.Foo(arg[0])

            # FAILS: AttributeError: type object 'Foo' has no attribute 'Foo'
            # You can't call a constructor the same way from inside and outside


            localized = Foo(arg[0])

            print ("\tself class: ", self.__class__)
            print ("\tself number: ", self.inum)
            print ()
            print ("\tlocalized class: ", localized.__class__)
            print ("\tlocalized number: ", localized.inum)
            print ()

            answer = (self.inum + localized.inum) 
            answer = Foo(answer)    

            print ("\tanswer class:", answer.__class__)
            print ("\tanswer sum result:", answer.inum)

            return answer

        assert(0), "Foo: cannot add an unsupported type"

    def __str__(self): # return a stringified int or empty string

        # Allow the class to stringify as if it were an int. 

        if self.inum &gt;= 0: 
            return str(self.inum)
</code></pre>
<p>testfoo.py</p>
<pre><code>#! /usr/bin/python

import sys
import Foo 

# A python class is not transparent like in perl, it is an object 
# with unconditional inheritance forced on all instances that share 
# the same name. 

classhandle = Foo.Foo 

# The distinction between the special class object, and instance 
# objects is implicitly defined by whether there is a passed value at 
# constructor time. The following therefore does not work. 

# classhandle = Foo.Foo() 

# but we can still write and print from the class, and see it propagate, 
# without having any "object" memory allocated.  

print ("\nclasshandle: ", classhandle)
print ("classhandle classname: ", classhandle.__name__) # print the classname
print ("class level num: ", classhandle.num)     # print the default num
classhandle.classstring = "fdsa" # define an involuntary value for all instances

print ("\n")

# so now we can create some instances with passed properties. 

instance1 = Foo.Foo(int(123)) # 

print ("\ninstance1: ", instance1)
print ("involuntary property derived from special class memory space: ", instance1.classstring)
print ("instance property from int: ", instance1.inum)

print ("\n")

instance2 = Foo.Foo(str("456"))
print ("\ninstance2: ", instance2)
print ("instance2 property from int: ", instance2.inum)

# 
# instance3 stands for (shall we assume) some math that happened a 
# thousand lines ago in a class far far away. We REALLY don't 
# want to go chasing around to figure out what type it could possibly 
# be, because it could be polymorphic itself. Providing a black box so 
# that you don't have to do that, is after all, the whole point OOP. 
# 

print ("\npretend instance3 is unknowningly already a Foo\n")
instance3 = Foo.Foo(str("789"))

## So our class should be able to handle str,int,Foo types at constructor time. 

print ("\ninstance4 should be a handle to the same memory location as instance3\n")

instance4 = Foo.Foo(instance3) # SHOULD return instance3 on type collision

print ("instance4: ", instance4) 

# because if it does, we should be able to hand all kinds of garbage to 
# overloaded operators, and they should remain type safe.  

# since we are now different instances these are now different:  

print ("\nADDING:_____________________\n", instance2.inum, " ", instance4.inum)

instance5 = instance4 + int(549) # instance5 should be a Foo object. 
print ("\n\tAdd instance4, 549, instance5: ", instance4, " ", int(549), " ", instance5, "\n")

instance6 = instance2 + instance4 # also should be a Foo object
print ("\n\tAdd instance2, instance4, instance6: ", instance2, " ", instance4, " ", instance6, "\n")

print ("stringified instance6: ", str(instance6))
</code></pre>
</div>
<span class="comment-copy">This may be a pedantic point, but I think it's important, "Those input types may be primitives or objects." There are no primitive types in Python. Everything is an object.</span>
<span class="comment-copy">"everything is an object": To me that would appear to be incorrect. WIthin  <b>new</b> (constructor phase?) type() does not find the namespace of the passed structure, but it does in <b>init</b>.  In perl terms this would mean that the data structure is unblessed in <b>new</b>, and not yet an object. This is a compelled custom. There is no reason for it, other than to make a bunch of people look at the code from a common perspective, as far as I can tell.</span>
<span class="comment-copy">I don't understand what you are saying here, and how it relates to <i>everything being an object</i> in Python. Again, there <i>are no primitive types</i>. When you say "type() does not find the namespace of the passed structure" it is unclear what you mean. What passed structure? What namespace? Namespaces are actually just objects in Python, typically (although not always) <code>dict</code> objects. You seem to be trying to apply concepts from Pearl which do not apply to Python, there are no "blessed and unblessed" objects</span>
<span class="comment-copy">In any event, there is a very good answer here describing your mistake vis a vis <code>__new__</code> vs <code>__init__</code>. Moreover, this construction <code>(type(arg[0]).__name__) == "int"</code> is <b>not</b> how you should do type-checking in Python. If you want a specific type, you use <code>type(obj) is int</code>, if you want to handle subclass relationships, use <code>isinstance(obj, int)</code>. Is the <code>__name__</code> attribute what you were referring to as the namespace?</span>
<span class="comment-copy">@JamesAanderson you can do it in <code>__super__</code>, just like abarnart's answer. <code>instance = super().__new__(cls); instance.inum = int(arg[0]); return instance</code>. remember, <code>__new__</code> should be returning an instance, not <code>self</code>, which is actually the class, which is why by convention it will be named <code>cls</code> when implementing <code>__new__</code> just to remind you.</span>
<span class="comment-copy">@martineau Done. I think I came up with the simplest example that's relevant to the OP's intended use.</span>
<span class="comment-copy">@martineau Do you think it also needs a sample <code>from_x</code> alternate constructor implementation, or is the answer already too long and that part is obvious enough?</span>
<span class="comment-copy">In the first code example, this looks like your creating an object registry. I don't need to do that. I'm not looking to validate against a specific previous object, only against the namespace of any object.  I'm trying to normalize different input types, so that my exported interface is type agnostic. To do that, I have to know what my input types are, but I only have to know what they are, not which they are.</span>
<span class="comment-copy">@JamesAanderson you can still do that using this approach, just check <code>type(value)</code> and do the processing you have in your <code>__init__</code> instead, e.g. something to the effect of <code>if isinstance(value, str): return super().__new__(cls, int(value))</code> EDIT rather, you have to add the attribute to what is returned by <code>super().__new__</code> as in the example above</span>
<span class="comment-copy">@JamesAanderson I just needed an example of <i>something</i> that has a reason to not always return a new object in <code>__new__</code>, and a flyweight-registry was the simplest example I could think of, so the logic of my example wouldn't get in the way of the part you need to understand. If that's not good enough for you to understand the idea and build what you need, please let me know what's not clear and I'll update it.</span>
