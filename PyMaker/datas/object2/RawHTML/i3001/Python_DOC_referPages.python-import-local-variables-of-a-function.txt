<div class="post-text" itemprop="text">
<p>I'm trying to make a debugger function, which is called when an error is raised, and let me access a console so I can check what happened in my program.
Here is the basic function:</p>
<pre><code>def DEBUGGER(error):
    print(error)
    print("[DEBUGGER] Your program has failed, here is the debugger. Enter EXIT to end program.")
    while True:
        line = input("&gt;&gt;&gt; ").lower()
        if line == 'exit':
            sys.exit(0)
        else:
            try:
                exec(line)
            except Exception as e:
                print(str(e))
</code></pre>
<p>The problem is that I can't enter something like <code>print(var)</code> because it's referenced in another function.
Globals functions don't help me since I want to be able to call any variable in my program, and I can't globalize them all.. I know I can resolve it by putting all my functions in classes but I can't for many reasons.</p>
<p>Is there a way to get local variables of the running functions ? (When I call <code>DEBUGGER()</code>, the mother function is still running)</p>
<p>If no, can I export the local variables of the current function and pass it as an argument to <code>DEBUGGER()</code> ? </p>
<p>Thanks for your answers.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are basically re-implementing the <a href="https://docs.python.org/3/library/pdb.html" rel="nofollow noreferrer">Python debugger <code>pdb</code></a>. If you want to go this route, you probably want to <a href="https://github.com/python/cpython/tree/3.7/Lib/pdb.py" rel="nofollow noreferrer">study the source code</a>. <code>pdb</code> itself is a user-interface around the lower-level <a href="https://docs.python.org/3/library/bdb.html" rel="nofollow noreferrer"><code>bdb</code> (basic debugger) module</a>, and the <a href="https://github.com/python/cpython/blob/3.7/Lib/bdb.py" rel="nofollow noreferrer">source code for that is also available</a>.</p>
<p>To answer your direct question: when you catch an exception you have access to a <a href="https://docs.python.org/3/reference/datamodel.html#traceback-objects" rel="nofollow noreferrer"><em>traceback</em> object</a> (either via <code>exception.__traceback__</code> or via <a href="https://docs.python.org/3/library/sys.html#sys.exc_info" rel="nofollow noreferrer"><code>sys.exc_info()</code></a>), and tracebacks have access to both the local and global namespace of each frame in the stack, via the <code>tb_frame</code> attribute. That attribute is set to a <a href="https://docs.python.org/3/reference/datamodel.html#frame-objects" rel="nofollow noreferrer">frame object</a>, which has <code>f_locals</code> and <code>f_globals</code> attributes.</p>
<p>The <a href="https://github.com/python/cpython/blob/3.7/Lib/bdb.py#L509-L530" rel="nofollow noreferrer"><code>bdb.Bdb.get_stack()</code> method</a> could be an interesting example on how to treat a traceback, and the <a href="https://github.com/python/cpython/blob/3.7/Lib/pdb.py#L924-L930" rel="nofollow noreferrer">internal <code>pdb.Pdb._select_frame()</code> method</a> then is used to pick a frame from the stack to use the locals and globals from.</p>
<p>If you don't want to re-implement the full debugger, you can use the <a href="https://docs.python.org/3/library/pdb.html#pdb.pm" rel="nofollow noreferrer"><code>pdb.pm()</code></a> or <a href="https://docs.python.org/3/library/pdb.html#pdb.post_mortem" rel="nofollow noreferrer"><code>pdb.port_mortem()</code></a> functions. These take the last traceback raised and let you inspect the stack frame in an interactive environment:</p>
<pre><code>try:
    exec(line)
except Exception as e:
    pdb.post_mortem(e.__traceback__)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The correct way to "write" your "DEBUGGER" function is:</p>
<pre><code>import pdb
DEBUGGER = pdb.set_trace
</code></pre>
<p>Now you can call <code>DEBUGGER()</code> wherever you want, you will be in an interactive environment with access not only to local vars but also to whole call stack, and the ability to execute the remaining code step by step (including stepping into other functions etc), change the control flow to continue executing from another line etc etc etc.</p>
<p>Oh and yes: you can of course just write <code>import pdb; pdb.set_trace()</code> instead ;-)</p>
</div>
<span class="comment-copy">How about <code>locals()</code>?</span>
<span class="comment-copy">Also, python has an entire <code>pdb</code> module for exactly this sort of debugging. Any special reason you don't want to use it?</span>
<span class="comment-copy">You could probably do this using something in the <a href="https://docs.python.org/3/library/traceback.html" rel="nofollow noreferrer"><code>traceback</code> module</a>, but why? There is already a debugger built into Python, <a href="https://docs.python.org/3/library/pdb.html" rel="nofollow noreferrer"><code>pdb</code></a>.</span>
