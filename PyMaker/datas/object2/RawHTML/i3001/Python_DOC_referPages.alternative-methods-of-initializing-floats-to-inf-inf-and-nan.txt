<div class="post-text" itemprop="text">
<p>To initialize float constants to +inf, -inf, nan I always use float() called with a string:</p>
<pre><code>print(float('inf'), float('+inf'), float('-inf'), float('nan'))
</code></pre>
<p>This prints:</p>
<pre><code>[inf, inf, -inf, nan]
</code></pre>
<p>1.) Does there exist in Python an alternative method of initializing these constants (not calling float with a string)?</p>
<p>2.) Can I produce these constants (+/-inf, nan) with some mathematical operation?</p>
<p>E.g. for setting the variable <code>f</code> to <code>+inf</code>, by writing something like <code>f = 1.0 / 0.0</code> (obviously, this is a division by zero error).</p>
</div>
<div class="post-text" itemprop="text">
<p>Technically, yes, there are other ways of initializing such values, but they're all either less obvious, or much less convenient.</p>
<p>If your platform uses IEEE floating point,<sup>1</sup> any <code>float</code> arithmetic  that overflows, without raising any other flags besides overflow, is guaranteed to give you <code>inf</code>. This means <code>1.0 / 0.0</code> probably won't work (Python will detect that this is a division by zero), but the even simpler <code>1e500</code> will.<sup>2</sup></p>
<p>Once you have <code>inf</code>, you can just do <code>-inf</code> and <code>inf/inf</code> to get the negative infinity and NaN values.</p>
<p>But would someone reading your code understand <code>1e500 / 1e500</code> as readily as <code>float('nan')</code>? Probably not.</p>
<p>Meanwhile, you can always do something like <code>struct.unpack('&gt;f', b'\x7f\x80\0\0')[0]</code>, which unpacks the well-defined bit pattern for an IEEE big-endian double <code>inf</code> value as a <code>float</code>, whether your <code>float</code> is that type under the covers or not. But why would you want to write (or read) that?<sup>3</sup></p>
<hr/>
<p>But, if you're using Python 3.5 or later, you don't <em>need</em> to initialize those values; you can just use <a href="https://docs.python.org/3/library/math.html#constants" rel="noreferrer">the constants in the <code>math</code> module</a>:</p>
<pre><code>print(math.inf, +math.inf, -math.inf, math.nan)
</code></pre>
<p>And if you're using Python 2.7 or 3.4 or something, you can always just define your own constants and use them over and over:</p>
<pre><code>inf, nan = float('inf'), float('nan')

print(inf, +inf, -inf, nan)
</code></pre>
<hr/>
<p><sub>1. Technically, Python doesn't require IEEE floating point. In fact, what it requires are something that acts like the platform's C <code>double</code>—which C doesn't require to be an IEEE type, and only if that makes sense for the implementation (e.g., Jython is obviously going to use the relevant Java type without caring what the C compiler used to compile the JVM thinks), and it doesn't clarify exactly what it means to act like a C double. However, the <code>float</code> type—not to mention things like the <code>math</code> module—really isn't going to work unless <code>float</code> is something reasonably close to an IEEE float type, like maybe the pre-IEEE IBM and Intel types or the not-quite-IEEE Motorola compat types. Also, as of 2018, the only supported platforms by any of the three existing Python 3.x implementations all give you either IEEE 754-1985 <code>double</code> or IEEE 754-2008 <code>float64</code>. But, if this is really a potential issue for your code, you should check <a href="https://docs.python.org/3/library/sys.html#sys.float_info" rel="noreferrer"><code>sys.float_info</code></a> to verify whatever assumptions are relevant.</sub></p>
<p><sub>2. It's conceivable that some platform might use an IEEE 754-1985 <code>long double</code> or an IEEE 754-2008 <code>float128</code> or something. If you're worried about that, just use a bigger number. Or, say, <code>1e500 ** 1e500 ** 1e500</code>.</sub></p>
<p><sub>3. Well, if you specifically need a quiet or signaling NaN, or one with a custom bit pattern instead of the default one… but anyone who needs that presumably already knows they need that.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>You can access those mathematical constants from the <code>math</code> module:</p>
<pre><code>&gt;&gt;&gt; from math import inf, nan
&gt;&gt;&gt; inf
inf
&gt;&gt;&gt; nan
nan
&gt;&gt;&gt; inf == float('inf')
True
</code></pre>
<p>Behind the scenes, in the CPython inplementation, <code>math.inf</code> and <code>math.nan</code> are generated using the same technique as that which <code>float('inf')</code> and <code>float('nan')</code> use; both approaches invoke the API functions <code>_Py_dg_infinity</code> and <code>_Py_dg_stdnan</code> respectively.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if this is what you want, but numpy has variables built in for that.</p>
<pre><code>import numpy as np

a = np.inf
b = -np.inf
c = np.nan

print(a, b, c)
[inf, -inf, nan]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>math.inf</code> constant was introduced in python3.5, you can read more about in <a href="https://docs.python.org/3/library/math.html#constants" rel="nofollow noreferrer">https://docs.python.org/3/library/math.html#constants</a>:</p>
<blockquote>
<p>math.inf A floating-point positive infinity. (For negative infinity,
  use -math.inf.) Equivalent to the output of float('inf').</p>
<p>New in version 3.5.</p>
</blockquote>
<p>As you can see below, they're both identical ones:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.inf == float('inf')
True
&gt;&gt;&gt; math.isinf(math.inf)
True
&gt;&gt;&gt;
</code></pre>
<p>In case you're also interested about how infinity is checked under the curtains you can take a look to the <a href="https://github.com/python/cpython/blob/master/Include/pymath.h#L105" rel="nofollow noreferrer">Py_IS_INFINITY</a> macro.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are looking to get these values through mathematical operations:</p>
<pre><code>import numpy as np
a = np.array([-1,0,1],dtype='int8')
a/0
</code></pre>
<p>Output:</p>
<pre><code>array([-inf,  nan,  inf])
</code></pre>
<p>This result is consistent with the <a href="https://en.wikipedia.org/wiki/Division_by_zero#Computer_arithmetic" rel="nofollow noreferrer">IEEE 754 floating point behavior</a>.</p>
<blockquote>
<p>In IEEE 754 arithmetic, a ÷ +0 is positive infinity when a is
  positive, negative infinity when a is negative, and NaN when a = ±0.</p>
</blockquote>
</div>
<span class="comment-copy">Just define <code>inf = float("inf")</code> etc. and use those names.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/2919754/how-do-i-type-a-floating-point-infinity-literal-in-python">How do I type a floating point infinity literal in python - Stack Overflow</a> -</span>
<span class="comment-copy">The <code>math</code> module seems ok. And for the second part? Can I produce these constants with  some mathematical operation?</span>
<span class="comment-copy">@AndrejKesely You <i>can</i> — e.g., <code>1e500</code> is <code>inf</code>, and <code>1e500 / 1e500</code> is <code>nan</code> on most platforms—but I don't think you <i>should</i>.</span>
<span class="comment-copy">@AndrejKesely Updated the answer to get into the gory details a bit more.</span>
<span class="comment-copy">I see, it's quite a rabbit hole ;) But your answer is exhausting for my case, thank you.</span>
<span class="comment-copy">@AndrejKesely Yeah, Python has always been a bit loosely specified around the edges, so questions like this usually involve a rabbit hole, where you get to choose how far you want to go, rather than, say, in Java, where you can just quote from the 1800-page spec. Ultimately, we're just guessing at how future implementors might interpret future versions of the spec based on the hidden assumptions elsewhere in the reference or the past behavior on platforms like 68000 Mac and Amiga or pre-S/390 IBM…</span>
