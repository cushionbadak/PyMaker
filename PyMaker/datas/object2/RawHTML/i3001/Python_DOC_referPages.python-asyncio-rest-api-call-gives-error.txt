<div class="post-text" itemprop="text">
<p>I am trying to call a REST API async using asyncio but i keep getting the error "<code>coroutine was never awaited</code>" which i understand. But i want this behavior, i want my function to end just by posting and not waiting for the result. Here is my code</p>
<pre><code>async def callCoroutine:
    #call a REST API 

def lambda_handler(event, context):   
    loop = asyncio.get_event_loop()
    task = loop.create_task(callCoroutine(data))
    return
</code></pre>
<p>Can someone help?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you just need to call the API, disregarding the result, you can use an Executor in another thread, which will not block the main thread.</p>
<p>To run in an Executor, use <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" rel="nofollow noreferrer">AbstractEventLoop.run_in_executor()</a> with an Executor from <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">concurrent.futures</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>For the current example, you need to have running loop somewhere (e.g. if you have some web-server or worker - <code>loop.run_forever()</code>)</p>
<h3>Fixed code example with running loop</h3>
<pre><code>import asyncio


async def callCoroutine(data):
    print('This is data: %s' % data)


def lambda_handler(event, context):   
    loop = asyncio.get_event_loop()
    task = loop.create_task(callCoroutine(context))
    return

lambda_handler(None, {'a': 1})

loop = asyncio.get_event_loop()
loop.run_forever()
</code></pre>
<h3>Example with <code>run_in_executor()</code></h3>
<pre><code>import asyncio
import requests


def call_rest_api(data):
    print('Triggered REST API in background')
    response = requests.get(data['url'])
    print('Response: %s' % response)


async def main(loop):
    print('Some operations here...')

    data = {'url': 'http://example.com#some_rest_api'}
    loop.run_in_executor(None, call_rest_api, data)

    print('Continue work of main thread...')


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main(loop))
</code></pre>
<h3>Example with simple <code>await</code> (if you need to call API syncronously)</h3>
<p>But it is not necessary to use asyncio if you want to write synchronous code.</p>
<pre><code>import asyncio
import requests


def call_rest_api(data):
    print('Triggered REST API in background')
    response = requests.get(data['url'])
    print('Response: %s' % response)


async def main(loop):
    print('Some operations here...')

    data = {'url': 'http://example.com#some_rest_api'}
    await call_rest_api(data)

    print('Continue work of main thread...')


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main(loop))
</code></pre>
<p>Can you provide more verbose example of what you have and what you want to achive?</p>
</div>
<div class="post-text" itemprop="text">
<p>In your case, the main thread is running synchronously.
So you need to run the asyncio loop in another thread Using <a href="https://docs.python.org/3/library/asyncio-task.html#scheduling-from-other-threads" rel="nofollow noreferrer">asyncio.run_coroutine_threadsafe</a>.</p>
<pre><code>import asyncio
import threading

# Run asyncio loop in other thread
loop = asyncio.new_event_loop()
threading.Thread(target=loop.run_forever).start()


async def call_coroutine(data):
    # call a REST API 
    return


def lambda_handler(event, context):   
    # Run the coroutine on the loop of other thread
    future = asyncio.run_coroutine_threadsafe(call_coroutine(data), loop)
    # If need to get result: 
    result = future.result()  # This will block the main thread

    do_something_else()
    return

# If need to stop the asyncio loop
loop.call_soon_threadsafe(loop.stop)
</code></pre>
</div>
<span class="comment-copy">Are you running the loop somewhere?</span>
<span class="comment-copy">any code or working example?</span>
<span class="comment-copy">@Bhargav The <a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-example" rel="nofollow noreferrer">ThreadPoolExecutor example</a> is easily adapted for your use case</span>
<span class="comment-copy">Thats the issue, if i use loop.run_forever(), that will stall the main thread to wait. Which i dont want to.</span>
<span class="comment-copy">You need to schedule all events (including main thread) in the same loop, or if you have something CPU heavy you'll need to use <code>run_in_executor()</code> instead of <code>create_task()</code>. So you'll don't need threads at all. Or the most preferable way is to move all "lambda_handlers" to separate component/process which will be responsible for callbacks only and the main thread will work on something synchronous.</span>
<span class="comment-copy">can you give an example using run_in_executor() then?</span>
<span class="comment-copy">@Bhargav added.</span>
<span class="comment-copy">This exactly has the same problem i was talking about, this piece of code doesn't finish as long as API call is not finished. Which is not what i want, i want the whole code to stop.</span>
<span class="comment-copy">This is not what i want, my main thread responsibility is only to call the API and go bust.</span>
<span class="comment-copy">If you don't want to use event loop, you shouldn't use asyncio. You can call the api in another thread or process.</span>
<span class="comment-copy">@Bhargav I misunderstood you question beforeðŸ˜“. Maybe the new answer can help you.</span>
