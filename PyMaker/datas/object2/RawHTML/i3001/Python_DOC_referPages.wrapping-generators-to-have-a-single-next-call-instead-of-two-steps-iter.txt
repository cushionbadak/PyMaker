<div class="post-text" itemprop="text">
<p>I'm receiving an unknown number of records for background processing from generators. If there is a more important job, I have to stop to release the process.</p>
<p>The <code>main</code> process is best described as: </p>
<pre><code>def main():
    generator_source = generator_for_test_data()  # 1. contact server to get data.
    uw = UploadWrapper(generator_source)  # 2. wrap the data.
    while not interrupt():  # 3. check for interrupts.
        row = next(uw)
        if row is None:
            return
        print(long_running_job(row))  # 4. do the work.
</code></pre>
<p>Is there a way to get to <code>__next__</code> without having to plug <code>__iter__</code>?
Having two steps - (1) make an iterator, then (2) iterate over it, just seems clumsy.</p>
<p>There are many cases where I'd prefer to submit a function to a function manager (mapreduce style), but in this case I need an instantiated class with some settings. Registering a single function can therefor only work if that function alone is <code>__next__</code></p>
<pre><code>class UploadWrapper(object):
    def __init__(self, generator):
        self.generator = generator
        self._iterator = None

    def __iter__(self):
        for page in self.generator:
            yield from page.data

    def __next__(self):
        if self._iterator is None:                # ugly bit.
            self._iterator = self.__iter__()      # 
        try:
            return next(self._iterator)
        except StopIteration:
            return None
</code></pre>
<p><strong>Q: Is there a simpler way?</strong></p>
<hr/>
<p>Working sample added for completeness:</p>
<pre><code>import time
import random

class Page(object):
    def __init__(self, data):
        self.data = data


def generator_for_test_data():
    for t in range(10):
        page = Page(data=[(t, i) for i in range(100, 110)])
        yield page

def long_running_job(row):
    time.sleep(random.randint(1,10)/100)
    assert len(row) == 2
    assert row[0] in range(10)
    assert row[1] in range(100, 110)
    return row

def interrupt():  # interrupt check
    if random.randint(1,50) == 1:
        print("INTERRUPT SIGNAL!")
        return True
    return False

class UploadWrapper(object):
    def __init__(self, generator):
        self.generator = generator
        self._iterator = None

    def __iter__(self):
        for ft in self.generator:
            yield from ft.data

    def __next__(self):
        if self._iterator is None:
            self._iterator = self.__iter__()
        try:
            return next(self._iterator)
        except StopIteration:
            return None

def main():
    gen = generator_for_test_data()
    uw = UploadWrapper(gen)
    while not interrupt():  # check for job interrupt.
        row = next(uw)
        if row is None:
            return
        print(long_running_job(row))

if __name__ == "__main__":
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>UploadWrapper</code> seems overtly complex, there is more than a single simpler solution.</p>
<p>My first thought is to ditch the class altogether and just use a function instead:</p>
<pre><code>def uploadwrapper(page_gen):
    for page in page_gen:
        yield from page.data
</code></pre>
<p>Just replace <code>uw = UploadWrapper(gen)</code> with <code>uw = uploadwrapper(gen)</code>, and that'll work.</p>
<p>If you insist on the class, you can just get rid of the <code>__next__()</code> and replace <code>uw = UploadWrapper(gen)</code> with <code>uw = iter(UploadWrapper(gen))</code>, and it'll work.</p>
<p>In either case, you must also catch the <code>StopIteration</code> in the caller. <code>__next__()</code> is <em>supposed</em> to raise <code>StopIteration</code> when it's done, and not return <code>None</code>, like yours does. Otherwise, it won't work with things expecting a well-behaving iterator, eg. <code>for</code> loops.</p>
<p>I think you might have some misconceptions about how it all is supposed to fit together, so I'll try my best to explain how it's supposed to work, to the best of my knowledge:</p>
<p>The point of <code>__iter__()</code> is that if you have eg. a list, you can get multiple independent iterators by calling <code>iter()</code>. When you have a <code>for</code> loop, you're essentially first getting an iterator with <code>iter()</code> and then calling <code>next()</code> on it on every loop iteration. If you have two nested loops that use the same list, the iterators and their positions are still separate so there's no conflict. <code>__iter__()</code> is supposed to return an iterator for the container it's on, or if it's called on an iterator, it's supposed to just return <code>self</code>. In that sense, it's kind of wrong for <code>UploadWrapper</code> not to return <code>self</code> in <code>__iter__()</code>, since it wraps a generator and so can't really give independent iterators. As for why leaving out <code>__next__()</code> works, it's because when you define a generator (ie. use <code>yield</code> in a function), the generator has an <code>__iter__()</code> (that returns <code>self</code>, as it should) and <code>__next__()</code> that does what you'd expect. In your original code, you're not really using <code>__iter__()</code> at all for what it's supposed to be used: the code works even if you rename it to something else! This is because you never call <code>iter()</code> on the instance, and just directly call <code>next()</code>.</p>
<p>If you wanted to do it "properly" as a class, I think something like this might suffice:</p>
<pre><code>class UploadWrapper(object):
    def __init__(self, generator):
        self.generator = generator
        self.subgen = iter(next(generator).data)

    def __iter__(self):
        return self

    def __next__(self):
        while True:
            try:
                return next(self.subgen)
            except StopIteration:
                self.subgen = iter(next(self.generator).data)
</code></pre>
</div>
<span class="comment-copy">You should get rid of the <code>__next__</code> method entirely, possibly the whole <code>UploadWrapper</code> class.</span>
<span class="comment-copy">As I need the class the line <code>uw  = iter(....)</code> is the solution. I wish I could have found this in the python documentation.</span>
<span class="comment-copy">@root-11 It's covered quite well, I think, in the <a href="https://docs.python.org/3/tutorial/classes.html#iterators" rel="nofollow noreferrer">official Python tutorial</a> and also briefly in the <a href="https://docs.python.org/3/library/stdtypes.html#typeiter" rel="nofollow noreferrer">documentation for standard types</a>; finding the right documentation can sometimes be surprisingly hard. I personally like to re-read, or at least browse through, the official Python tutorial every few years - I pick up something new every time, either because I simply missed some detail the previous times or because new features were introduced in the meantime.</span>
<span class="comment-copy">(The tutorial can seem a bit basic/simple/slow at the beginning, as it covers simple things like addition and <code>for</code> loops, but it's a pretty in-depth coverage of Python as a whole, and even the simple parts are worth reading, as you might be surprised to learn something new about something that you could've sworn you knew like the back of your hand. For example, not everyone knows that the aforementioned <code>for</code> loops can have an <code>else</code> clause in Python! And I bet most people would think "of course I know everything there is to know about <code>for</code> loops!", even if they didn't know about <code>for-else</code>)</span>
<span class="comment-copy">@root-11: Speaking of not always finding the docs you were looking for; I think I also wanted to link you to the <a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" rel="nofollow noreferrer">data model reference</a>, but didn't remember the page name and ended up not finding it back then. Anyway, I just stumbled upon it again, while looking for something else, and thought I might as well link it now! It's really handy, since it has docs for most <code>__magic__</code> methods in one place. (It also says explicitly what the first link only hints at, eg. that an iterator's <code>__iter__</code> is <i>required</i> to return <code>self</code>.)</span>
