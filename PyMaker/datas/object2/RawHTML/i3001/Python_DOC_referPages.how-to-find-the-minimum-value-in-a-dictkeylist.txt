<div class="post-text" itemprop="text">
<p>I am trying to find the minimum flight price in a dictionary that looks like:</p>
<pre><code>{datetime.date(2018, 12, 16): ['KL', 'AMS', '59.84'],
  datetime.date(2018, 12, 24): ['KL', 'AMS', '59.84'],
  datetime.date(2018, 12, 25): ['KL', 'AMS', '59.84'],
  datetime.date(2018, 12, 27): ['KL', 'AMS', '59.84'],
  datetime.date(2018, 12, 18): ['KL', 'AMS', '59.84'],
  datetime.date(2018, 12, 19): ['KL', 'AMS', '59.84'],
  datetime.date(2018, 12, 20): ['KL', 'AMS', '59.84'],
  datetime.date(2018, 12, 23): ['KL', 'AMS', '59.84'],
  datetime.date(2018, 12, 17): ['AF', 'AMS', '70.24'],
  datetime.date(2018, 12, 21): ['SK', 'AMS', '97.93'],
  datetime.date(2018, 12, 26): ['SK', 'AMS', '97.93'],
  datetime.date(2018, 12, 28): ['SK', 'AMS', '97.93'],
  datetime.date(2019, 1, 2): ['SK', 'AMS', '97.93'],
  datetime.date(2019, 1, 3): ['SK', 'AMS', '97.93'],
  datetime.date(2018, 12, 29): ['AF', 'AMS', '111.64'],
  datetime.date(2018, 12, 31): ['EW', 'AMS', '127.51'],
  datetime.date(2019, 1, 1): ['EW', 'AMS', '127.51'],
  datetime.date(2018, 12, 30): ['EW', 'AMS', '147.51'],
  datetime.date(2018, 12, 22): ['KL', 'AMS', '148.84']}
</code></pre>
<p>The first key is a datetime, and value = list of info.   I'm trying to simply get the max and min price over that time series.  I've tried the following:</p>
<pre><code>_tempPairAndPrices = {}
for item in permutations(destinations[1:],2):    
    #try:
    key_max = max(_fltDictTemp_CachedData[item].keys(),key=(lambda k: _fltDictTemp_CachedData[item][k]))
    key_min = min(_fltDictTemp_CachedData[item].keys(),key=(lambda k: _fltDictTemp_CachedData[item][k]))
    maxPx = _fltDictTemp_CachedData[item][key_max]
    minPx = _fltDictTemp_CachedData[item][key_min]

    _tempPairAndPrices[item] = {'maxPx':maxPx,'minPx':minPx}
</code></pre>
<p>I don't think it's properly accessing the list of information though, as it's not properly assigning max and min values...    (often my min &gt;&gt; max)</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>IIUC, use <a href="https://docs.python.org/3/library/functions.html#min" rel="nofollow noreferrer"><code>min()</code></a> with a <code>key</code></p>
<pre><code>[min(v.values(), key=lambda x: float(x[-1])) for k,v in d.items()]
</code></pre>
<p>Outputs</p>
<pre><code>[['KL', 'AMS', '59.84']]
</code></pre>
<hr/>
<p>For your edited data, just do</p>
<pre><code>min(d.values(), key=lambda x: float(x[-1]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are just interested in getting the minimum flight price, this is one possible solution:</p>
<pre><code>prices = [float(i) for i in np.array(dict.values()[0].values())[:,-1]]
min_price = min(prices)
</code></pre>
<p>where <code>dict</code> is your dictionary. The reason I used <code>np.array()</code> in the list comprehension was in order to use the indexing <code>[:,-1]</code> since the prices are the last element of the list. But I see there are several prices which are equal and the minimum. I don't know how you plan to tackle them. You can of course combine the above two lines into one and write:</p>
<pre><code>min_price = min([float(i) for i in np.array(dict.values()[0].values())[:,-1]])
</code></pre>
</div>
<span class="comment-copy">thanks, it looks like it's close but I'm getting a 'list' object has no attribute 'values' error</span>
<span class="comment-copy">@keynesiancross <code>d</code> is your outter dictionary. Do <code>d.items()</code> should give you a tuple as <code>key</code> and another <code>dict</code> as values. Check if that is what happening :)</span>
<span class="comment-copy">ah, I actually skipped that step because I'm, earlier, setting d = originalDict[tupleKey].  All I'm left with is a key(datetime) and the output list</span>
<span class="comment-copy">@keynesiancross so it gets even simpler</span>
<span class="comment-copy">Thanks, but I'm getting a "dict_values" object does not support indexing error where you use [0]</span>
<span class="comment-copy">Strange. I just copied your first code snippet as dict = {.....} and it worked for me. Well I used Python 2.7.12 so may be that is an issue?</span>
