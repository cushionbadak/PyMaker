<div class="post-text" itemprop="text">
<p>May I get some help on how to combine lines 1-7 so that they appear on a single line inside a csv file?  I tried to put this into a dataframe but the formatting messes up the data in the first column.</p>
<pre><code>1527047244357,'line_A','{}','{
&lt;gpx abcd&gt;
    &lt;rte&gt;
        &lt;name&gt;defg&lt;/name&gt;
    &lt;/rte&gt;
&lt;/gpx&gt;
}'
1527047244358,'line_B'
</code></pre>
<p>There are thousands of lines in each csv files that I'm working with and these lines happen randomly within the file.  I'm thinking that maybe a for loop would work to check if the first char is a number and if not, delete the line break so that I can get what I needed:</p>
<pre><code>1527047244357,'line_A','{}','{&lt;gpx abcd&gt;&lt;rte&gt;&lt;name&gt;defg&lt;/name&gt;&lt;/rte&gt;&lt;/gpx&gt;}'
1527047244358,'line_B'
</code></pre>
<p>How can I accomplish this?  Here's my pseudo code so far:</p>
<pre><code>for row in readerObj:
    if isinstance(row[0], int) == True:
         (delete line break)
    csvWriter.writerow(row)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is one approach.</p>
<p><strong>Demo:</strong></p>
<pre><code>s = """1527047244357,'line_A','{}','{
&lt;gpx abcd&gt;
    &lt;rte&gt;
        &lt;name&gt;defg&lt;/name&gt;
    &lt;/rte&gt;
&lt;/gpx&gt;
}'
1527047244358,'line_B'"""

res = [[]]
checkVal = False
for line in s.splitlines():             #Iterate Each line
    if line.strip().endswith("{"):      #Check if line ends with {
        checkVal = True
    if line.strip().endswith("}'"):     #Check if line ends with }
        checkVal = False
        res[-1].append(line)
        continue

    if checkVal:
        res[-1].append(line)
    else:
        res.append([line])

for i in res:
    print(" ".join(i))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>1527047244357,'line_A','{}','{ &lt;gpx abcd&gt;     &lt;rte&gt;         &lt;name&gt;defg&lt;/name&gt;     &lt;/rte&gt; &lt;/gpx&gt; }'
1527047244358,'line_B'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Most csv data uses <code>"</code> as the quote character.  Yours uses <code>'</code> instead, which can be controlled with the <a href="https://docs.python.org/3/library/csv.html#csv.Dialect.quotechar" rel="nofollow noreferrer"><code>quotechar</code></a> parameter, supported by both <code>csv.reader</code> and <code>pd.read_csv</code>:</p>
<pre><code>In [61]: pd.read_csv("data.csv", quotechar="'", header=None)
Out[61]: 
               0       1    2                                                  3
0  1527047244357  line_A   {}  {\r\n&lt;gpx abcd&gt;\r\n    &lt;rte&gt;\r\n        &lt;name&gt;...
1  1527047244358  line_B  NaN                                                NaN
</code></pre>
<p>Once you've got this, you can strip as appropriate.</p>
</div>
<div class="post-text" itemprop="text">
<p>I tried to make it similar to your code and easy to understand.</p>
<pre><code>readerObj = """1527047244357,'line_A','{}','{
&lt;gpx abcd&gt;
    &lt;rte&gt;
        &lt;name&gt;defg&lt;/name&gt;
    &lt;/rte&gt;
&lt;/gpx&gt;
}'
1527047244358,'line_B'"""

temp_csv = ''

for line in readerObj.splitlines():
    line_splitted = line.split(',')
    dumped_whitespaces = [el.strip(' ') for el in line_splitted]
    first_obj = line_splitted[0]

    # that's the recommended way to check if something is a digit
    if first_obj.isdigit():
        # adds new line
        temp_csv += "\n"

    temp_csv += ','.join(dumped_whitespaces)

with open('yourfile.csv', 'w') as f:
    f.write(temp_csv)
</code></pre>
<p>Results with </p>
<pre><code>1527047244357,'line_A','{}','{&lt;gpx abcd&gt;&lt;rte&gt;&lt;name&gt;defg&lt;/name&gt;&lt;/rte&gt;&lt;/gpx&gt;}'
1527047244358,'line_B'
</code></pre>
<p>If you need to make sure everything looks fine use pandas.</p>
</div>
<div class="post-text" itemprop="text">
<p>Read the original file one line at a time and write the lines to the output file without line breaks, <em>unless</em> a line starts with a number (in which case it is the next row and a line break must be inserted before it):</p>
<pre><code>import re
with open("original.csv") as infile:
    with open("fixed.csv", "w") as outfile:
        for lineno,line in enumerate(infile):
            # The beginning of the next row
            if re.match('\d+,', line) and lineno &gt; 0: 
                outfile.write('\n')
            outfile.write(line.rstrip())
</code></pre>
<p>The variable <code>lineno</code> prevents the code from inserting a line break at the beginning of the file. Using this method, you can process arbitrary long files because you always deal with at most one row.</p>
</div>
<span class="comment-copy">Thanks @Rakesh!  Since iterating over csv.reader changed each row to a list I had to tweak some code using yours as reference.      for row in readerObj:         if "}'" not in row[-1]:             temp_row.extend(row)             continue         elif "}'" in row[-1]:             if temp_row != []:                 temp_row.extend(row)                 temp_row[5] = ''.join(temp_row[5:])                 csvWriter.writerow(temp_row)                 temp_row.clear()                 continue             csvWriter.writerow(row)</span>
<span class="comment-copy">Thanks for the tip on quotechar.  I have added it via:  df = pd.read_csv(output_file, header = None, quotechar = "'")  However, when I use astype('int64') on the first column the code still run in to an error.  I'll dig deeper on this but I don't think my code with quotechar is working as it should.</span>
