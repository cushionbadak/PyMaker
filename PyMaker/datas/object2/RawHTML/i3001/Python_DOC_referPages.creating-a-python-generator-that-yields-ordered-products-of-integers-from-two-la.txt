<div class="post-text" itemprop="text">
<p>So, I have two very large lists of numbers <code>l1</code> and <code>l2</code>.  I'd like to multiply each element of <code>l1</code> with each element of <code>l2</code> <em>without</em> explictly creating a new list of products.  Thus, I'd like a generator.  This part is easy.  I can just do something like</p>
<pre><code>for a in l1:
    for b in l2:
        yield a * b
</code></pre>
<p>However, I also need these products to be ordered by their magnitude.  I am wondering if there is some clever trick to order the yield statements so that this can also be done with a generator.  In Python 3, if possible.  Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'll call the lists <code>xs</code> and <code>ys</code>, and assume they're sorted.  As you noted in a comment, the smallest product is necessarily <code>xs[0] * ys[0]</code> - but only if you're also assuming that all numbers are non-negative, so I'll assume that too.</p>
<p>After the first product, it gets messier - else you already would have solved it ;-)  The next two to consider are <code>xs[0] * ys[1]</code> and <code>xs[1] * ys[0]</code>.  Easy enough, but then the <em>next</em> to consider depends on <em>which</em> of those won.  If <code>xs[0] * ys[1]</code> won, you only need to replace it with <code>xs[0] * ys[2]</code>, but if <code>xs[1] * ys[0]</code> won then both <code>xs[1] * ys[1]</code> and <code>xs[2] * ys[0]</code> come into play.  And so on.</p>
<p>The following keeps track of the growing set of possibilities with a heap.  The heap never holds more than <code>len(xs)</code> items, so the code first arranges to make <code>xs</code> the shorter list:</p>
<pre><code>def upprod(xs, ys):
    # xs and ys must be sorted, and non-negative
    from heapq import heappush, heappop
    # make xs the shorter
    if len(ys) &lt; len(xs):
        xs, ys = ys, xs
    if not xs:
        return
    lenxs = len(xs)
    lenys = len(ys)
    # the heap holds 4-tuples:
    #     (product, xs index, ys index, xs[xs index])
    h = [(xs[0] * ys[0], 0, 0, xs[0])]
    while h:
        prod, xi, yi, x = heappop(h)
        yield prod
        # same x with next y
        yi += 1
        if yi &lt; lenys:
            heappush(h, (x * ys[yi], xi, yi, x))
        # if this is the first time we used x, start
        # the next x going
        if yi == 1:
            xi += 1
            if xi &lt; lenxs:
                x = xs[xi]
                heappush(h, (x * ys[0], xi, 0, x))
</code></pre>
<p>I'd be pleasantly surprised if an essentially more efficient solution existed.  If someone thinks they have one, please try it first using this randomized tester:</p>
<pre><code>from itertools import product
from random import randrange
MAXLEN = 10
UB = 1000
ntest = 0
while True:
    ntest += 1
    lenxs = randrange(MAXLEN + 1)
    lenys = randrange(MAXLEN + 1)
    xs = sorted(randrange(UB) for i in range(lenxs))
    ys = sorted(randrange(UB) for i in range(lenys))
    brute = sorted(a*b for a, b in product(xs, ys))
    got = list(upprod(xs, ys))
    if brute != got:
        print("OUCH!")
        print(xs)
        print(ys)
        print(brute)
        print(got)
        assert False
    if ntest % 10_000 == 0:
        print(f"finished test {ntest:,}")
</code></pre>
<h2>EDIT - THEORETICALLY BETTER IN SOME SENSE ;-)</h2>
<p>The above doesn't fully exploit the partial ordering we can deduce from indices alone:  if</p>
<pre><code>i1 &lt;= i2 and j1 &lt;= j2
</code></pre>
<p>then we know</p>
<pre><code>xs[i1] * ys[j1] &lt;= xs[i2] * ys[j2]
</code></pre>
<p>because sorting implies <code>xs[i1] &lt;= xs[i2]</code> and <code>ys[j1] &lt;= ys[j2]</code>.</p>
<p>So, for example, if the index pairs <code>(0, 1)</code> and <code>(1, 0)</code> are on the heap, and the second one wins, <code>(2, 0)</code> needs to be added to the heap but <code>(1, 1)</code> doesn't:  from the indices alone, we know that the product from the <code>(0, 1)</code> remaining in the heap is no larger than the product from <code>(1, 1)</code>.  It's only when <code>(0, 1)</code> is also removed that <code>(1, 1)</code> needs to be added.</p>
<p>In general, each pair of the form <code>(i, 0)</code> has a single immediate predecessor <code>(i-1, 0)</code>, and <code>(0, j)</code> the single <code>(0, j-1)</code>, and all other <code>(i, j)</code> have two immediate predecessors:  <code>(i-1, j)</code> and <code>(i, j-1)</code>.  There's no need to put a pair on the heap until all its predecessors have been taken off the heap.</p>
<p>Which leads to this code, which is seemingly "more elegant" because more symmetric:</p>
<pre><code>def upprod(xs, ys):
    # xs and ys must be sorted, and non-negative
    from heapq import heappush, heappop
    # make xs the shorter
    if len(ys) &lt; len(xs):
        xs, ys = ys, xs
    if not xs:
        return
    lenxs = len(xs)
    lenys = len(ys)
    # the heap holds 3-tuples:
    #     (product, xs index, ys index)
    h = [(xs[0] * ys[0], 0, 0)]

    # interior points for which only one immediate predecessor has
    # been processed; there's no need to put them in the heap
    # until their second predecessor has been processed too
    pending = set()

    def add(xi, yi):
        if xi &lt; lenxs and yi &lt; lenys:
            if xi and yi: # if either is 0, only one predecessor
                p = xi, yi
                if p in pending:
                    pending.remove(p)
                else:
                    pending.add(p)
                    return
            heappush(h, (xs[xi] * ys[yi], xi, yi))

    while h:
        prod, xi, yi = heappop(h)
        yield prod
        # same x with next y; and same y with next x
        add(xi, yi + 1)
        add(xi + 1, yi)
    assert not pending
</code></pre>
<p>Compared to the first code, it keeps the heap somewhat smaller in many cases.  But heap operations take time logarithmic in the number of heap entries, and the heap can still grow to <code>len(xs)</code> entries, so that's not much of a win.  It's probably lost to the overhead of the two new function calls (while inlining those is too ugly to bear).</p>
</div>
<div class="post-text" itemprop="text">
<p>My solution is to create a list of generators, one generator for each row in the product matrix, and then to use <a href="https://docs.python.org/3/library/heapq.html#heapq.merge" rel="nofollow noreferrer"><code>heapq.merge</code></a> to sort the outputs of those generators. Each generator has a size of 44 bytes on a 32 bit machine, so the whole list of generators only consumes a modest amount of RAM. </p>
<p><code>heapq.merge</code> (when no sorting key function is supplied) works by creating a 3-tuple of each of the iterables you pass it. That tuple contains the next value from the iterable, an index number for the iterable, and a reference to the iterable's <code>__next__</code> method. It places those tuples onto a heap to perform a mergesort of the iterables' values. You can see the details in its Python <a href="https://github.com/python/cpython/blob/3.7/Lib/heapq.py#L314" rel="nofollow noreferrer">source code</a>.</p>
<p>Thus my approach is not quite as frugal as Tim Peters' solutions, but it's not too shabby, IMHO. ;)</p>
<pre><code>def sorted_prod_merge(xs, ys):
    ''' mergesort generators of the rows. '''
    if len(ys) &lt; len(xs):
        xs, ys = ys, xs
    def gen(x):
        for y in ys:
            yield x * y
    yield from merge(*[gen(x) for x in xs])
</code></pre>
<hr/>
<p>Here's some <code>timeit</code> code which shows the running time of <code>sorted_prod_merge</code>, Tim Peters' solutions, plus a few other versions of mine. I've used Tim's variable names to keep the code uniform. It's interesting to note that Tim's 1st version is roughly twice as fast as his more advanced solution. My <code>sorted_prod_row</code> runs quite quickly, but it's a terrible RAM hog.</p>
<p>The <code>timeit</code> code uses a technique given in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> recipes</a> to exhaust an iterator: we feed it to a zero-length deque. The <code>time_test</code> code sorts the 3 results from each <code>Timer</code> run. That's because the <em>minimum</em> result is the important one, the other values just give an indication of the variance in the system at the time the test ran. See the note in the docs for <a href="https://docs.python.org/3/library/timeit.html#timeit.Timer.repeat" rel="nofollow noreferrer"><code>Timer.repeat</code></a> for details.</p>
<pre><code>from heapq import heappush, heappop, merge
from random import seed, randrange
from timeit import Timer
from collections import deque

seed(163)

# Brute force method, as a generator
def sorted_prod_brute(xs, ys):
    yield from sorted(x * y for x in xs for y in ys)

# By Tim Peters
def upprod1(xs, ys):
    # xs and ys must be sorted, and non-negative
    from heapq import heappush, heappop
    # make xs the shorter
    if len(ys) &lt; len(xs):
        xs, ys = ys, xs
    if not xs:
        return
    lenxs = len(xs)
    lenys = len(ys)
    # the heap holds 4-tuples:
    #     (product, xs index, ys index, xs[xs index])
    h = [(xs[0] * ys[0], 0, 0, xs[0])]
    while h:
        prod, xi, yi, x = heappop(h)
        yield prod
        # same x with next y
        yi += 1
        if yi &lt; lenys:
            heappush(h, (x * ys[yi], xi, yi, x))
        # if this is the first time we used x, start
        # the next x going
        if yi == 1:
            xi += 1
            if xi &lt; lenxs:
                x = xs[xi]
                heappush(h, (x * ys[0], xi, 0, x))

# By Tim Peters
def upprod2(xs, ys):
    # xs and ys must be sorted, and non-negative
    from heapq import heappush, heappop
    # make xs the shorter
    if len(ys) &lt; len(xs):
        xs, ys = ys, xs
    if not xs:
        return
    lenxs = len(xs)
    lenys = len(ys)
    # the heap holds 3-tuples:
    #     (product, xs index, ys index)
    h = [(xs[0] * ys[0], 0, 0)]

    # interior points for which only one immediate predecessor has
    # been processed; there's no need to put them in the heap
    # until their second predecessor has been processed too
    pending = set()

    def add(xi, yi):
        if xi &lt; lenxs and yi &lt; lenys:
            doit = True
            if xi and yi: # if either is 0, only one predecessor
                p = xi, yi
                if p in pending:
                    pending.remove(p)
                else:
                    pending.add(p)
                    doit = False
            if doit:
                heappush(h, (xs[xi] * ys[yi], xi, yi))
    while h:
        prod, xi, yi = heappop(h)
        yield prod
        # same x with next y; and same y with next x
        add(xi, yi + 1)
        add(xi + 1, yi)
    assert not pending

def sorted_prod_merge(xs, ys):
    ''' mergesort generators of the rows. '''
    if len(ys) &lt; len(xs):
        xs, ys = ys, xs
    def gen(x):
        for y in ys:
            yield x * y
    yield from merge(*[gen(x) for x in xs])

def sorted_prod_row(xs, ys):
    ''' Heapsort, row by row.
        Fast, but not space-efficient: the maximum 
        heap size grows to almost len(ys) * len(xs)
    '''
    if len(ys) &lt; len(xs):
        xs, ys = ys, xs
    if not xs:
        return
    x, xs = xs[0], xs[1:]
    heap = []
    #big = 0
    for y in ys:
        lo = x * y
        while heap and heap[0] &lt;= lo:
            yield heappop(heap)
        yield lo
        for u in xs:
            heappush(heap, u * y)
        #big = max(big, len(heap))
    #print(big)
    while heap:
        yield heappop(heap)

def sorted_prod_diag(xs, ys):
    ''' Heapsort, going along the diagonals
        50% slower than sorted_prod_row, but more
        space-efficient: the maximum heap size 
        grows to around 0.5 * len(ys) * len(xs)
    '''
    if not (xs and ys):
        return
    lenxs, lenys = len(xs), len(ys)
    heap = []
    #big = 0
    for n in range(lenxs + lenys - 1):
        row = sorted(xs[n - i] * ys[i]
            for i in range(max(0, n + 1 - lenxs), min(lenys, n + 1)))
        lo = row[0]
        while heap and heap[0] &lt;= lo:
            yield heappop(heap)
        yield lo
        for u in row[1:]:
            heappush(heap, u)
        #big = max(big, len(heap))
    #print(big)
    #assert not heap

def sorted_prod_block(xs, ys):
    ''' yield the top left corner, then merge sort
        the top row, the left column and the remaining 
        block. So we end up with max(len(xs), len(ys))
        recursively nested calls to merge(). It's ok
        for small lists, but too slow otherwise.
    '''
    if not (xs and ys):
        return
    x, *xs = xs
    y, *ys = ys
    yield x * y
    row = (y * u for u in xs)
    col = (x * v for v in ys)
    yield from merge(row, col, sorted_prod_block(xs, ys))

def sorted_prod_blockI(xs, ys):
    ''' Similar to sorted_prod_block except we use indexing
        to avoid creating sliced copies of the lists
    '''
    lenxs, lenys = len(xs), len(ys)
    def sorted_block(xi, yi):
        if xi == lenxs or yi == lenys:
            return
        x, y = xs[xi], ys[yi]
        yield x * y
        xi, yi = xi + 1, yi + 1
        row = (xs[i] * y for i in range(xi, lenxs))
        col = (ys[i] * x for i in range(yi, lenys))
        yield from merge(row, col, sorted_block(xi, yi))
    yield from sorted_block(0, 0)

functions = (
    sorted_prod_brute,
    upprod1,
    upprod2,
    sorted_prod_merge,
    #sorted_prod_row,
    sorted_prod_diag,
    #sorted_prod_block,
    #sorted_prod_blockI,
)

UB = 1000

def verify(numtests, maxlen=10):
    print('Verifying. maxlen =', maxlen)
    for k in range(numtests):
        lenxs = randrange(maxlen + 1)
        lenys = randrange(maxlen + 1)
        print(k, ':', lenxs, '*', lenys, '=', lenxs * lenys)
        xs = sorted(randrange(UB) for i in range(lenxs))
        ys = sorted(randrange(UB) for i in range(lenys))
        good = list(sorted_prod_brute(xs, ys))

        for func in functions[1:]:
            result = list(func(xs, ys))
            if result != good:
                print(func.__name__, 'failed!')
    print()

def time_test(loops=20):
    timings = []
    for func in functions:
        # Consume the generator output by feeding it to a zero-length deque
        t = Timer(lambda: deque(func(xs, ys), maxlen=0))
        result = sorted(t.repeat(3, loops))
        timings.append((result, func.__name__))
    timings.sort()
    for result, name in timings:
        print('{:18} : {:.6f}, {:.6f}, {:.6f}'.format(name, *result))
    print()

verify(10, 10)
verify(20, 100)

print('\nTimings')
loops = 8192
minlen = 5
for k in range(6):
    lenxs = randrange(minlen, 2 * minlen)
    lenys = randrange(minlen, 2 * minlen)
    print(k, ':', loops, 'loops.', lenxs, '*', lenys, '=', lenxs * lenys)
    xs = sorted(randrange(UB) for i in range(lenxs))
    ys = sorted(randrange(UB) for i in range(lenys))
    time_test(loops)
    minlen *= 2
    loops //= 4
</code></pre>
<p>Here's the output on my ancient 2GHz 32 bit single core machine, running Python 3.6.0 on an old Debian derivative distro of Linux. YMMV.</p>
<pre class="lang-none prettyprint-override"><code>Verifying. maxlen = 10
0 : 8 * 9 = 72
1 : 9 * 0 = 0
2 : 1 * 7 = 7
3 : 8 * 10 = 80
4 : 10 * 5 = 50
5 : 10 * 0 = 0
6 : 5 * 2 = 10
7 : 5 * 10 = 50
8 : 3 * 0 = 0
9 : 0 * 6 = 0

Verifying. maxlen = 100
0 : 64 * 0 = 0
1 : 77 * 96 = 7392
2 : 24 * 13 = 312
3 : 53 * 39 = 2067
4 : 74 * 39 = 2886
5 : 92 * 97 = 8924
6 : 31 * 48 = 1488
7 : 39 * 17 = 663
8 : 42 * 25 = 1050
9 : 94 * 25 = 2350
10 : 82 * 83 = 6806
11 : 2 * 97 = 194
12 : 90 * 30 = 2700
13 : 93 * 24 = 2232
14 : 91 * 37 = 3367
15 : 24 * 86 = 2064
16 : 70 * 15 = 1050
17 : 2 * 4 = 8
18 : 72 * 58 = 4176
19 : 25 * 84 = 2100


Timings
0 : 8192 loops. 7 * 8 = 56
sorted_prod_brute  : 0.659312, 0.665853, 0.710947
upprod1            : 1.695471, 1.705061, 1.739299
sorted_prod_merge  : 1.990161, 1.991129, 2.001242
sorted_prod_diag   : 3.013945, 3.018927, 3.053115
upprod2            : 3.582396, 3.586332, 3.622949

1 : 2048 loops. 18 * 16 = 288
sorted_prod_brute  : 0.826128, 0.840111, 0.863559
upprod1            : 2.240931, 2.241636, 2.244615
sorted_prod_merge  : 2.301838, 2.304075, 2.306918
sorted_prod_diag   : 3.030672, 3.053302, 3.135322
upprod2            : 4.860378, 4.949804, 4.953891

2 : 512 loops. 39 * 32 = 1248
sorted_prod_brute  : 0.907932, 0.918692, 0.942830
sorted_prod_merge  : 2.559567, 2.561709, 2.604387
upprod1            : 2.700482, 2.701147, 2.757695
sorted_prod_diag   : 2.961776, 2.965271, 2.995747
upprod2            : 5.563303, 5.654425, 5.656695

3 : 128 loops. 68 * 70 = 4760
sorted_prod_brute  : 0.823448, 0.827748, 0.835049
sorted_prod_merge  : 2.591373, 2.592134, 2.685534
upprod1            : 2.760466, 2.763615, 2.795082
sorted_prod_diag   : 2.789673, 2.828662, 2.848498
upprod2            : 5.483504, 5.488450, 5.517847

4 : 32 loops. 122 * 156 = 19032
sorted_prod_brute  : 0.873736, 0.880958, 0.892846
sorted_prod_merge  : 2.701089, 2.742456, 2.818822
upprod1            : 2.875358, 2.881793, 2.922569
sorted_prod_diag   : 2.953450, 2.988184, 3.012430
upprod2            : 5.780552, 5.812967, 5.826775

5 : 8 loops. 173 * 309 = 53457
sorted_prod_brute  : 0.711012, 0.711816, 0.721627
sorted_prod_merge  : 1.997386, 1.999774, 2.033489
upprod1            : 2.137337, 2.172369, 3.335119
sorted_prod_diag   : 2.324447, 2.329552, 2.331095
upprod2            : 4.278704, 4.289019, 4.324436
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't seem like there is any other way to order these outputs without creating a list, because the outputs cannot be sorted without being stored. Here's how you could do that.</p>
<pre><code>myList = []

for i in range(len(l1)):
    for j in range(len(l2)):
        output = l1[i] * l2[j]
        myList.append(output)
myList.sort()
print(myList)
</code></pre>
<p>Hope that helps.</p>
</div>
<span class="comment-copy">Are your original lists sorted?</span>
<span class="comment-copy">@DSM Yes, they can be generated sorted without much issue, if that helps.</span>
<span class="comment-copy">@M.Haurer I may be completely wrong here, but your requirements seems odd in my opinion. You're asking for a way of creating products on the fly without storing them, but at the same time you want them to be ordered somehow. I really don't see how you could possibly sort items that you are not storing together.</span>
<span class="comment-copy">@scharette The requirements are practical and come from memory/computational restrictions.  Intuitively, if the original lists are ordered, it seems possible to start from the smallest entries and move through with some degree of look-ahead that's far shorter than the entire list.  If I asked you to find the smallest product from elements of two sorted lists, you would easily tell me that it must be the product of the first two elements.  I simply want to generalize this method to the n-th smallest element.</span>
<span class="comment-copy">Can a list contain duplicates? Can they contain zero, or negative values? Are the two lists the same length?</span>
<span class="comment-copy">I don't have a more efficient solution, since it puts about 10 times the number of bytes on the heap that your code does. But it does manage to run a little faster on larger lists. ;)</span>
<span class="comment-copy">The size of the generators doesn't account for costs like the suspended stack frame or the iterator over <code>ys</code>.</span>
<span class="comment-copy"><code>sorted_prod_merge()</code> is too obvious ;-)  Seriously, very nice!  My "advanced" version is twice as slow mainly because it creates each "interior" index pair twice, while the first version created each only once.  Your merge gets a major speed advantage because internally <code>merge()</code> uses <code>heapreplace()</code> instead of my code's <code>heappop()</code>+<code>heappush()</code> pairs - these heap operations are the most expensive "primitives" any of these functions use, so cutting the number of calls to them is a real help.</span>
<span class="comment-copy">BTW, in <code>sorted_prod_row</code> it should be much faster to do <code>heap.extend(u * y for u in xs);  heap.sort()</code>, especially because Python's sort is extremely good at sorting lists with long ascending runs (<code>u * y for u in xs</code> is a single ascending run).  And a sorted list <i>is</i> a heap, so the heap property is retained.  To get more gonzo, <code>bisect</code> could then be used to find where the next <code>lo</code> splits that sorted list.  And the tail end of the function     could become <code>yield from sorted(heap)</code>.  In fact, using heaps at all in that function is probably ill-advised ;-)</span>
<span class="comment-copy">@user2357112 Good points. And I can't think of any way to reduce those costs.</span>
<span class="comment-copy">Thanks, @TimPeters! Yes, <code>sorted_prod_merge()</code> is pretty obvious, but I didn't think of trying it until after I'd tried those other variations. :) And thanks for the suggestions regarding <code>sorted_prod_row</code>.Its main problem is that it chews up way too much RAM, but I guess I can apply that suggestion to  <code>sorted_prod_diag</code> too.</span>
<span class="comment-copy">To start with, <code>print(myList.sort())</code> will print <code>None</code></span>
<span class="comment-copy">Sorry about that. please edit the post to improve its accuracy and I'll keep that in mind for future answers.</span>
<span class="comment-copy">Editors tend to be reluctant to change the code in a question or answer, out of worry that it might change the post's intent. It's usually better for the original author to fix it themselves :-)</span>
<span class="comment-copy">I understand. I'll fix the answer soon.</span>
<span class="comment-copy">Yes, this gives the products in order, but it doesn't actually answer the question because the OP specifically said that they want to do it "<i>without</i> explicitly creating a new list of products".</span>
