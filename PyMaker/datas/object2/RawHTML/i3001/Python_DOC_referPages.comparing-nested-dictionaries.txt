<div class="post-text" itemprop="text">
<p>I would like to compare nested dictionaries as following:</p>
<pre><code>d = {'siteA': {'00000000': 3, '11111111': 4, '22222222': 5},
        'siteB': {'00000000': 1, '11111111': 2, '22222222': 5}}

e = {'siteA': {'00000000': 5}}

f = {'siteB': {'33333333': 10}}

g = {'siteC': {'00000000': 8}}
</code></pre>
<p><code>d</code> is the total full dictionaries that will be use to compare with <code>e</code>, <code>f</code> and <code>g</code>.</p>
<p>If <code>e</code> happens to found in <em>siteA-00000000</em>, then I would like both value (in this case 3 and 5) add up to become 8.</p>
<p>If <code>f</code> is not found (in this case, it's true), I would like to append the dictionary into the <code>d['siteB']</code>.</p>
<p>If <code>g</code> is not found, would like to append into <code>d</code>.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> is useful for summing values in dictionaries and adding keys where they do not exist. Since <code>Counter</code> is a subclass of <code>dict</code>, this should not break other operations. Apart from a one-off conversion cost, it is efficient and designed specifically for such tasks.</p>
<pre><code>from collections import Counter

# convert d to dictionary of Counter objects
d = {k: Counter(v) for k, v in d.items()}

# add items from e
for k, v in e.items():
    if k in d:
        d[k] += Counter(e[k])

# add item from f if not found
for k, v in f.items():
    if k not in d:
        d[k] += Counter(f[k])

# add item from g if not found
for k, v in g.items():
    if k not in d:
        d[k] = Counter(v)
</code></pre>
<p>Result:</p>
<pre><code>print(d)

{'siteA': Counter({'00000000': 8, '11111111': 4, '22222222': 5}),
 'siteB': Counter({'00000000': 1, '11111111': 2, '22222222': 5}),
 'siteC': Counter({'00000000': 8})}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> from <code>collections</code> in combination with <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>.</p>
<p>As the name suggests, the counter counts the same elements, and a defaultdict lets you access non-existing keys by providing a default value (an empty <code>Counter</code> in this case). Your code then becomes</p>
<pre><code>from collections import Counter, defaultdict


d = defaultdict(Counter)
d['siteA'] = Counter({'00000000': 3, '11111111': 4, '22222222': 5})
d['siteB'] = Counter({'00000000': 1, '11111111': 2, '22222222': 5})
print(d.items())

&gt; dict_items([('siteA', Counter({'22222222': 5, '11111111': 4, '00000000': 3})), 
&gt;             ('siteB', Counter({'22222222': 5, '11111111': 2, '00000000': 1}))])

# d + e:
d['siteA'].update({'00000000': 5})
print(d.items())

&gt; dict_items([('siteA', Counter({'00000000': 8, '22222222': 5, '11111111': 4})), 
&gt;             ('siteB', Counter({'22222222': 5, '11111111': 2, '00000000': 1}))])

# d + f
d['siteB'].update({'33333333': 10})
print(d.items())

&gt; dict_items([('siteA', Counter({'00000000': 8, '22222222': 5, '11111111': 4})), 
&gt;             ('siteB', Counter({'33333333': 10, '22222222': 5, '11111111': 2, '00000000': 1}))])

# d + g
d['siteC'].update({'00000000': 8})
print(d.items())

&gt; dict_items([('siteA', Counter({'00000000': 8, '22222222': 5, '11111111': 4})), 
&gt;             ('siteB', Counter({'33333333': 10, '22222222': 5, '11111111': 2, '00000000': 1})), 
&gt;.            ('siteC', Counter({'00000000': 8}))])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given the format of your dictionaries dict[site][address], let's say, this merge function will take the values from dictFrom and insert them into dictTo according to your rules.</p>
<pre><code>def merge(dictTo, dictFrom):
    for site in dictFrom:
        if site not in dictTo:
            dictTo[site] = {}

        for address in dictFrom[site]:
            dictTo[site][address] = dictTo[site].get(address, 0) + dictFrom[site][address]

merge(d, e)
merge(d, f)
merge(d, g)
</code></pre>
<p>This may be preferable to jpp's answer because the objects at dict[site] are all still basic dicts.</p>
</div>
<span class="comment-copy">f does not added into siteB..</span>
<span class="comment-copy">@ReverseEngineer, Yes, that's right. Because of this condition: <code>If f is not found (in this case, it's true)</code>. Since it <i>is</i> found, nothing happens.</span>
<span class="comment-copy">Got it. Thanks for the solution!</span>
<span class="comment-copy">weird, i've tried to use a function like this but the return doesn't add into d. def update_dict(source, dest):     source = {k: Counter(v) for k, v in source.items()}      for k, v in dest.items():         if k not in source:             source[k] = Counter(v)         else:             source[k] += Counter(dest[k])      return source</span>
<span class="comment-copy">got it working, thanks all.</span>
<span class="comment-copy">This works, thanks!</span>
<span class="comment-copy">What is the advantage of that <code>basic dicts</code>? Counter is a subclass of dict as mentioned by jpp.</span>
<span class="comment-copy">I think keeping the type the same as in the question is enough for me to think it's worthwhile. However, you can see in the print of jpp's output counters by default are printed as <code>Counter({...</code> instead of <code>{...</code>, which is nicer in my opinion. Furthermore, if all I was trying to do was defend my answer, then I'd say the usage of a function is preferable to writing the same loop three times.</span>
<span class="comment-copy">Also, I forgot to mention that this method does not require you to convert your data in the beginning, as jpp did.</span>
<span class="comment-copy">this is another nice solution too, thank you.</span>
