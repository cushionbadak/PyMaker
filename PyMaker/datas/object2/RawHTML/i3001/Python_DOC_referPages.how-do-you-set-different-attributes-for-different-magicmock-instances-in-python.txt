<div class="post-text" itemprop="text">
<p>I'd like to assert that <code>say_name</code> was called with each value in the list <code>name</code>.</p>
<pre><code>from unittest.mock import patch


class MyClass:
    def __init__(self, name):
        self.name = name


def say_name(name):
    print('My name is ' + name)


def my_func():
    names = ['foo', 'bar', 'baz']
    objects = [MyClass(name) for name in names]
    [say_name(object.name) for object in objects]


@patch('my_test.say_name', spec_set=True)
@patch('my_test.MyClass', spec_set=True)
def test_my_func(mock_my_class, mock_say_name):
    names = ['foo', 'bar', 'baz']
    my_func()
    [mock_my_class.assert_any_call(name) for name in names]
    # [mock_say_name.assert_any_call(x.name) for x in xs]
</code></pre>
<p>If only one instance of <code>MyClass</code> was created, as is usually the case, I could set the attribute by setting <code>mock_my_class.return_value = PropertyMock(name=name)</code>.</p>
<p>However, in this case, multiple different instances of <code>MyClass</code> are created.</p>
<p>Thus, this code will throw an error because <code>my_func</code> is executed by the tester, <code>say_name</code> is being passed a mock with no <code>name</code> attribute.</p>
<p>Therefore, how can I set different attributes for different MagicMock instances?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to use <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow noreferrer"><code>side_effect</code></a> to sequentially return values from a mock:</p>
<pre><code>&gt;&gt;&gt; from unittest.mock import Mock
&gt;&gt;&gt; m = Mock()
&gt;&gt;&gt; m.side_effect = ['spam', 123, 'potato']
&gt;&gt;&gt; m()
'spam'
&gt;&gt;&gt; m()
123
&gt;&gt;&gt; m()
'potato'
</code></pre>
<p>Applying to your use-case:</p>
<pre><code>from types import SimpleNamespace
from unittest.mock import call, patch

from my_lib import my_func


@patch('my_lib.say_name')
@patch('my_lib.MyClass')
def test_my_func(mock_my_class, mock_say_name):

    class FakeObj:
        pass

    obj1 = FakeObj()
    obj1.name = 'foo'
    obj2 = FakeObj()
    obj2.name = 'bar'
    obj3 = FakeObj()
    obj3.name = 'baz'

    mock_my_class.side_effect = [obj1, obj2, obj3]
    my_func()
    assert mock_my_class.call_args_list == [call('foo'), call('bar'), call('baz')]
    assert mock_say_name.call_args_list == [call('foo'), call('bar'), call('baz')]
</code></pre>
</div>
<span class="comment-copy">What test runner are you using?</span>
<span class="comment-copy">@wim I'm using py.test to run the tests.</span>
