<div class="post-text" itemprop="text">
<p>I decided to port some of my Python functions to C, mostly following <a href="https://pgi-jcns.fz-juelich.de/portal/pages/using-c-from-python.html" rel="nofollow noreferrer">this simple tutorial</a>. Problem is that my C function returns a complex float, and there's no corresponding type in ctypes's <a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer">documentation</a>. This is is a problem I couldn't solve myself with my limited knowledge on cross-language coding and C, even extended by Google.</p>
<p>My C function works like this:</p>
<pre><code>#include &lt;tgmath.h&gt;
float _Complex integrand(float _Complex theta1, double r, double z){
    //[code] }
</code></pre>
<p>So, based on the tutorial, the corresponding Python wrapper (probably) should be something like this:</p>
<pre><code>complextype = '??????'

_integr = ctypes.CDLL('libintegrand.so')
_integr.integrand.argtypes = (complextype, ctypes.c_double, ctypes.c_double)

def integrand(theta1, r, z):
    global _integr
    result = _integr.integrand(complextype(theta1), ctypes.c_double(r), ctypes.c_double(z))
    return float(result)
</code></pre>
<p>But what should this type be? How should I do this?  </p>
<p>If the fact that the function also has a complex argument makes it significantly more complicated, please ignore the complex argument.</p>
</div>
<div class="post-text" itemprop="text">
<p>Create a small C wrapper function:</p>
<pre><code>void integrand_wrapper(float *re, float *im, double r, double z)
{
    float _Complex  result;
    float _Complex  theta = (*re) + I*(*im);
    result = integrand(theta, r, z);
    (*re) = creal(result);
    (*im) = cimag(result);
}
</code></pre>
<p>The <code>re</code> and <code>im</code> pointers hold the real and imaginary parts of <code>theta</code> when called, and the real and imaginary parts of the result afterwards.</p>
<p>In your Python code, call <code>integrand_wrapper()</code> using e.g.</p>
<pre><code>def integrand(theta, r, z):
    global _integr
    theta = complex(theta)
    re = c_float(theta.real)
    im = c_float(theta.imag)
    _integr.integrand_wrapper(byref(re), byref(im), c_double(r), c_double(z))
    return complex(float(re), float(im))
</code></pre>
<p>Note that if <code>integrand()</code> is defined in a binary library you cannot modify, you can always create another dynamic library containing only <code>integrand_wrapper</code>, that is dynamically linked (in C) to the original binary library.</p>
<p>Overall, I don't think the added overhead is significant at all. It is certainly worth testing.</p>
</div>
<div class="post-text" itemprop="text">
<p>Naively, perhaps split it into two arguments, <code>Re(z), Im(z)</code>
If that's not an option, perhaps pass the argument to the python function <code>complex()</code>.</p>
<p>These are naive solutions; perhaps they don't work but if you haven't considered it and in lack of better responses, may be worth experimenting with.</p>
<p>Good luck!</p>
</div>
<span class="comment-copy">As an aside, your <code>global _integr</code> statement is unnecessary and the oykd probably cause an experienced Python programmer to assume this function will mutate global state when it does not</span>
<span class="comment-copy">Splitting the values occured to me too, but unfortunately it'd badly damage the purpose (performance improvement), as I'd have to calculate essentially everything twice. And there are some costly functions there. Maybe I could go with putting them in an array though at the end... hmm.</span>
