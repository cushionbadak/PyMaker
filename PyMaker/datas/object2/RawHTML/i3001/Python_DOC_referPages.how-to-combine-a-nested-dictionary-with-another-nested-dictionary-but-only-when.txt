<div class="post-text" itemprop="text">
<p>The best way I can describe what I'd like to achieve is by referring to how the SQL function <code>INNER JOIN</code> works for displaying data from two tables, determined by a matching column name.</p>
<p>I'd like to achieve a similar function, though by using Python (preferably 3.x), and instead of tables with a matching column name, I'd like to combine the entirety of two dictionaries together, based on a matching {k: v} pair.</p>
<p>For example...</p>
<pre><code>lst_1 = [
    {
        'City'      :   'Boston',
        'State'     :   'Massechusets',
        'Name'      :   'Kim Tuttles',
        'Country'   :   'United State'
    },
    {
        'City'      :   'Portland',
        'Name'      :   'Larry Bird',
        'State'     :   'Oregon'
    },
    {
        'City'      :   'Chicago',
        'Name'      :   'John Jacobs',
        'State'     :   'Illinois'
    }
]

lst_2 = [
    {
        'Hobby'     :   'Tennis',
        'Build'     :   'Athletic',
        'Height'    :   'Six Feet, One Inch',
        'Name'      :   'Kim Tuttles',
        'Birthplace':   'Italy'
    },
    {
        'Name'      :   'John Jacobs',
        'Hobby'     :   'Baseball',
        'Build'     :   'Muscular',
        'Height'    :   'Five Feet, Eight Inches'
    }
]
</code></pre>
<p>I'd like to find a way to merge the dictionaries from each list, but only where a matching {Key: Value} pair is found. The result would look like this...</p>
<pre><code>merged_lst = [
    {
        'Hobby'     :   'Tennis',
        'Build'     :   'Athletic',
        'Height'    :   'Six Feet, One Inch',
        'Birthplace':   'Italy'
        'City'      :   'Boston',
        'State'     :   'Massechusets',
        'Name'      :   'Kim Tuttles', # Merge on matching name
        'Country'   :   'United State'
    },
    {
        'Name'      :   'John Jacobs', # Merge on matching name
        'Hobby'     :   'Baseball',
        'Build'     :   'Muscular',
        'Height'    :   'Five Feet, Eight Inches'
        'City'      :   'Chicago',
        'State'     :   'Illinois'
    }
]
</code></pre>
<p>I've managed to find a way to merge the dictionaries using <code>dict.update</code> and <code>zip()</code>, though that's only when dealing with two independent dictionaries and it still wasn't quite right. I appreciate any advice and thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.5+ we can get away with the following, ignoring problems from additional key clashes.</p>
<pre><code>k = 'Name'
merged_lst = [{**a, **b} for a in lst_1 for b in lst_2 if a[k]==b[k]]
</code></pre>
<ul>
<li>The <code>{**a, **b}</code> is a neat way to unpack the two dictionaries being considered into a combined dictionary (I believe on a clash it uses the value from <code>b</code> instead of <code>a</code>). This is the only step that requires 3.5+. In Python 2.x with <strong>string</strong> keys a similar construct is <code>dict(a, **b)</code>, though Guido frowns on it heavily. Other options are more verbose.</li>
<li>Python list comprehensions allow you to easily iterate through what is effectively the cartesian product of <code>lst_1</code> and <code>lst_2</code> by using <code>for</code> twice.</li>
<li>We only care about dictionaries with the same <code>'Name'</code>, hence the <code>a[k]==b[k]</code> bit.</li>
<li>If you are allowed to clobber any of the dictionaries in <code>lst_1</code> or <code>lst_2</code>, approaches involving <code>dict.update()</code> are probably faster. They might be anyway, though the syntax isn't as nice I don't think.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>you can do something like this:</p>
<pre><code>for l2 in lst_2:
   l2.update(next(l1 for l1 in lst_1 if l1["Name"] == l2["Name"]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a function to filter one list on the duplicate names, transfer the dicts over in a result list and update them there:</p>
<p>Function:</p>
<pre><code>def mergeSameNameDicts(l1,l2):

    duplicateNames = set ( p["Name"] for p in l1) &amp; set( p["Name"] for p in l2) 

    import copy 
    rv = []        # collects enriched dicts
    for d in l1:
        if d["Name"] in duplicateNames:
            rv.append(copy.copy(d))           # copy dict over from l1

    for d in l2:                              # enhance with data from l2
        if (d["Name"] in duplicateNames):     # if name is a dupe. enhence all
            for d1 in rv:                     # dicts with that name inside rv
                if (d["Name"] == d1["Name"]): # the values of v2 will overwrite l1 if keys
                    d1.update(d)              # present in dicts of l1 and l2
    return rv

print(mergeSameNameDicts(lst_1,lst_2))
</code></pre>
<p>Output:</p>
<pre><code>[{'City': 'Boston',
  'State': 'Massechusets',
  'Name': 'Kim Tuttles',
  'Country': 'United State',
  'Hobby': 'Tennis',
  'Build': 'Athletic',
  'Height': 'Six Feett, One Inch',
  'Birthplace': 'Italy'},

 {'City': 'Chicago',
  'Name': 'John Jacobs',
  'State': 'Illinois',
  'Hobby': 'Baseball',
  'Build': 'Muscular',
  'Height': 'Five Feet, Eight Inches'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is similar to <a href="https://it.wikipedia.org/wiki/Join_(SQL)" rel="nofollow noreferrer">left join</a> in RDMS like MySQL and the <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/" rel="nofollow noreferrer">$lookup(aggregation)</a> function of MongoDB. You can look into them for further clarification.</p>
</div>
<span class="comment-copy">Do you know the matching key (<code>'Name'</code> here)  in advance?</span>
<span class="comment-copy">Fortunately I do, and it is consistent throughout every dictionary in either list. So in the case above it would be <code>'Name'</code> as you mentioned.</span>
<span class="comment-copy">And other than 'Name', are there any other duplicated keys and if so which one would take precedence in the result?</span>
<span class="comment-copy">No, the only occurrence of a matching {Key: Value} pair would be on <code>'Name'</code>, but the match could be found at any depth within the list, at any position within the dictionary. Sort of a "well, it's in there somewhere" type of thing.</span>
<span class="comment-copy">Is it safe to assume that each list only has one occurrence of each <code>'Name'</code>?</span>
<span class="comment-copy">This is very neat and concise. It should be noted however that the algorithmic complexity is <code>O(m*n)</code> in the nested comprehension when for the problem at hand, <code>O(m+n)</code> is possible.</span>
<span class="comment-copy">@schwobaseggl That could definitely be a problem, but I'm curious how you came up with <code>O(m+n)</code>? Is that average case? In my scratch work the best solution I've found is <code>O(m*log(m)+n*log(n))</code> worst case. What's the best algorithm to use for time complexity here?</span>
<span class="comment-copy">OMG THANK YOU! This worked absolutely perfectly! Been banging my head against the wall for hours!</span>
<span class="comment-copy">@trjv Happy to help :)</span>
<span class="comment-copy">@HansMusgrave No mathematically sound proof, but turning both lists into dicts with name as key, then iterating one of them, checking for key presence in the other one. This, of course, disregards the average size of the dicts to merge which also factors in :)</span>
<span class="comment-copy">Interesting! Can you explain what <code>set</code> does in line #3? I'm not familiar with that function yet.</span>
<span class="comment-copy">@trjv set() is an unordered data structure that has no duplicats in itself. It allows fast set-theory-esc operations like union/differences/subset/superset/... If you had 2 lists of 200 dicts each and only 20 names present in both of them this would return those exact 20 names so the following loops can loop over only 20 ppl and not all 200 as we do not need them. Read more here:  <a href="https://stackoverflow.com/questions/15181867/understanding-the-set-function">SO Post about set()</a> and <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">python set() doku</a></span>
