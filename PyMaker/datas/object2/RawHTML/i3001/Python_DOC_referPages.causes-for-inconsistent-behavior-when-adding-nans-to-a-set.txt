<div class="post-text" itemprop="text">
<p>There is puzzling (at least for me) behavior of Python's set in combination with <code>NaN</code>s (<a href="https://ideone.com/L6XzmM" rel="nofollow noreferrer">here live</a>):</p>
<pre><code>&gt;&gt;&gt; float('nan') in {float('nan')}    # example 1
False
&gt;&gt;&gt; nan = float('nan')                # example 2
&gt;&gt;&gt; nan in {nan}
True
</code></pre>
<p>At first, I wrongly assumed,that this is the behavior of the <code>==</code>-operator, but this is obviously not the case because both cases yield <code>False</code> as expected (<a href="https://ideone.com/svs3Y8" rel="nofollow noreferrer">here live</a>):</p>
<pre><code>&gt;&gt;&gt; float('nan') == float('nan') 
False
&gt;&gt;&gt; nan = float('nan')
&gt;&gt;&gt; nan == nan
False
</code></pre>
<p>I'm mainly interested in the causes for this behavior. But if there is a way to ensure consistent behavior, that would also be nice to know!</p>
</div>
<div class="post-text" itemprop="text">
<p>set membership does an identity check as a short-circuit before considering an equality check (CPython source is in <a href="https://github.com/python/cpython/blob/master/Objects/setobject.c" rel="nofollow noreferrer"><code>setobject.c</code></a>, see also the note below <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool" rel="nofollow noreferrer"><code>PyObject_RichCompareBool</code></a>).</p>
<p>Python core devs are motivated by these invariants:</p>
<pre><code>for a in container:
    assert a in container    # this should ALWAYS be true
</code></pre>
<p>Ergo:</p>
<pre><code>assert a in [a]
assert a in (a,)
assert a in {a}
</code></pre>
<p>It was decided that ensuring these invariants was the most important priority, and as for NaN: oh well.  <em>Special cases aren't special enough to break the rules</em>. For all the gory details, see bpo <strong>issue4296</strong>: </p>
<p><a href="https://bugs.python.org/issue4296#msg75735" rel="nofollow noreferrer">Python assumes identity implies equivalence; contradicts NaN</a>.</p>
</div>
<span class="comment-copy">Python's containers assume that <code>==</code> is an equivalence relation. If it's not, notions of containment fall apart. You shouldn't be putting NaN in a set in the first place.</span>
<span class="comment-copy">Probably relevant: <a href="https://stackoverflow.com/questions/9089400/python-set-in-operator-uses-equality-or-identity" title="python set in operator uses equality or identity">stackoverflow.com/questions/9089400/â€¦</a></span>
<span class="comment-copy">See also <a href="https://stackoverflow.com/questions/20320022/why-in-numpy-nan-nan-is-false-while-nan-in-nan-is-true">here</a>.</span>
