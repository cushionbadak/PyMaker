<div class="post-text" itemprop="text">
<p>When answering <a href="https://stackoverflow.com/q/51600485/7692463">this question</a>, I came across something I never thought about in Python (pointed by a user).</p>
<p>Basically, I already know (here's an interesting <a href="https://stackoverflow.com/q/1207406/7692463">thread</a> about it) that I have to make a copy when iterating while mutating a list in Python in order to avoid strange behaviors.</p>
<p>Now, my question is, is using <code>enumerate</code> overcoming that problem ?</p>
<pre><code>test_list = [1,2,3,4]
for index,item in enumerate(test_list):
    if item == 1:
        test_list.pop(index)
</code></pre>
<p>Would this code be considered safe or I should use,</p>
<pre><code>for index,item in enumerate(test_list[:]):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, let’s answer your direct question:</p>
<p><code>enumerate</code> doesn’t help anything here. It works as if it held an iterator to the underlying iterable (and, at least in CPython, that’s exactly what it does), so anything that wouldn’t be legal or safe to do with a list iterator isn’t legal or safe to do with an enumerate object wrapped around that list iterator.</p>
<hr/>
<p>Your original use case—setting <code>test_list[index] = new_value</code>—is safe in practice—but I’m not sure whether it’s <em>guaranteed</em> to be safe or not.</p>
<p>Your new use case—calling <code>test_list.pop(index)</code>—is probably <em>not</em> safe.</p>
<hr/>
<p>The most obvious implementation of a list iterator is basically just a reference to the list and an index into that list. So, if you insert or delete at the current position, or to the left of that position, you’re definitely breaking the iterator. For example, if you delete <code>lst[i]</code>, that shifts everything from <code>i + 1</code> to the end up one position, so when you move on to <code>i + 1</code>, you’re skipping over the original <code>i + 1</code>th value, because it’s now the <code>i</code>th. But if you insert or delete to the right of the current position, that’s not a problem.</p>
<p>Since <code>test_list.pop(index)</code> deletes at or left of the current position, it's not safe even with this implementation. (Of course if you've carefully written your algorithm so that skipping over the value after a hit never matters, maybe even that's fine. But more algorithms won't handle that.)</p>
<p>It’s conceivable that a Python implementation could instead store a raw pointer to the current position in the array used for the list storage. Which would mean that inserting <em>anywhere</em> could break the iterator, because an insert can cause the whole list to get reallocated to new memory. And so could deleting anywhere, if the implementation sometimes reallocates lists on shrinking. I don't think the Python disallows implementations that do all of this, so if you want to be paranoid, it may be safer to just never insert or delete while iterating.</p>
<p>If you’re just replacing an existing value, it’s hard to imagine how that could break the iterator under any reasonable implementation. But, as far as I'm aware, the language reference and <code>list</code> library reference<sup>1</sup> don't actually make any promises about the implementation of list iterators.<sup>2</sup></p>
<p>So, it's up to you whether you care about "safe in my implementation", "safe in every implementation every written to date", "safe in every conceivable (to me) implementation", or "guaranteed safe by the reference".</p>
<p>I think most people happily replace list items during iteration, but avoid shrinking or growing the list. However, there's definitely production code out there that at least deletes to the right of the iterator.</p>
<hr/>
<p><sup>1. I believe the <em>tutorial</em> just says somewhere to never modify any data structure while iterating over it—but that’s the tutorial. It’s certainly safe to always follow that rule, but it may also be safe to follow a less strict rule.</sup></p>
<p><sup>2. Except that if the <code>key</code> function or anything else tries to access the list in any way in the middle of a <a href="https://docs.python.org/3/library/stdtypes.html#list.sort" rel="nofollow noreferrer"><code>sort</code></a>, the result is undefined.</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>Since it was my <a href="https://stackoverflow.com/questions/51600485/replacing-list-elements-that-satisfy-some-condition-with-items-from-another-list/51600586#comment90168212_51600586">comment</a> which lead to this, I'll add my follow up:</p>
<p>enumerate can be thought of as a generator so it will just take a sequence (any sequence or iterator actually) and just "generate" an incrementing index to be yielded with each item from the passed sequence (so it's not making a copy or mutating the list anyway just using an <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">"enumerate object"</a>).</p>
<p>In the case of the code in that question, you were never changing the length of the list you were iterating over and once the if statement was run the value of the element did not matter. So the copy wasn't needed, it will be needed when an element is removed as the iterator index is shared with the list and does not account for removed elements.</p>
<p><a href="https://stackoverflow.com/questions/38546951/remove-element-from-list-when-using-enumerate-in-python/38547020#38547020">The Python Ninja</a> has a great example of when you should use a copy (or move to list comprehension)</p>
</div>
<span class="comment-copy">But what would be safer? You are modifying original list anyway, right? As long as you don't delete items from list during loop it's fine to not create copy of the list.</span>
<span class="comment-copy">@Shan I guess I've always been wrong. I thought modifying a list while iterating over it was forbidden in python and could leads to strange outputs. For the record, I thought that what would be safer is my second example.</span>
<span class="comment-copy">Mutating the list's size or item ordering can cause unexpected behavior. Changing a single item's value is likely to be harmless.</span>
<span class="comment-copy">@scharette Copying is always safe—unless allocating a new list and copying all the elements causes a <code>MemoryError</code> or takes so long that your algorithm is no longer useful, of course. The question is whether not copying is "safe enough", and that's a trickier question than maybe it should be.</span>
<span class="comment-copy">Yes, I understand. My question was really about mutating a list. I create an oversimplified example for the sake of the question. Should I change the statement for <code>test_list.pop(index)</code> for example. That would be more appropriate.</span>
<span class="comment-copy">Already up-voted. Just so you know though, I edited in order to now mutate the list which is much more logical in the context if this question.</span>
<span class="comment-copy">@scharette OK, edited. What you're doing is probably not safe even in practice.</span>
<span class="comment-copy">Perfect. Thanks for your edit.</span>
<span class="comment-copy">You're right it was a bad use-case. I actually edit my answer which now change the lenght. Logically, this is what I wanted to know.</span>
<span class="comment-copy">Yep, that's why I said "you're not changing the length" :). If you mutate the length it is not good practice to use enumerate without a copy. Even then I may not actually do that in practice but move to list comprehension or a custom generator to avoid lost or incorrect data (or an error). I'll edit this in more directly when I have a minute.</span>
<span class="comment-copy">I understand, i gave an upvote since for my past example you were entirely right.</span>
