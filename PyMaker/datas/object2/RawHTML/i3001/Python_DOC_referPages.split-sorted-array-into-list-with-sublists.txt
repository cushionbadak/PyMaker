<div class="post-text" itemprop="text">
<p>I have a sorted array of float32 Values, I want to split this array into a list of lists containing only the same Values like this:</p>
<pre><code>&gt;&gt;&gt; split_sorted(array) # [1., 1., 1., 2., 2., 3.]
&gt;&gt;&gt; [[1., 1., 1.], [2., 2.], [3.]]
</code></pre>
<p>My current approach is this Function</p>
<pre><code>def split_sorted(array):
    split = [[array[0]]]

    s_index = 0
    a_index = 1
    while a_index &lt; len(array):
        while a_index &lt; len(array) and array[a_index] == split[s_index][0]:
            split[s_index].append(array[a_index])
            a_index += 1
        else:
            if a_index &lt; len(array):
                s_index += 1
                a_index += 1
                split.append([array[a_index]])
</code></pre>
<p>My Question now is, is there a more Pythonic way to do this? maybe even with numpy? And is this the most performant way?</p>
<p>Thanks a lot!</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Approach #1</strong></p>
<p>With <code>a</code> as the array, we can use <code>np.split</code> -</p>
<pre><code>np.split(a,np.flatnonzero(a[:-1] != a[1:])+1)
</code></pre>
<p>Sample run -</p>
<pre><code>In [16]: a
Out[16]: array([1., 1., 1., 2., 2., 3.])

In [17]: np.split(a,np.flatnonzero(a[:-1] != a[1:])+1)
Out[17]: [array([1., 1., 1.]), array([2., 2.]), array([3.])]
</code></pre>
<p><strong>Approach #2</strong></p>
<p>Another more performant way would be to get the <em>splitting</em> indices and then slicing the array and <code>zipping</code> -</p>
<pre><code>idx = np.flatnonzero(np.r_[True, a[:-1] != a[1:], True])
out = [a[i:j] for i,j in zip(idx[:-1],idx[1:])]
</code></pre>
<p><strong>Approach #3</strong></p>
<p>If you have to get a list of sublists as output, we could re-create with list duplication -</p>
<pre><code>mask = np.r_[True, a[:-1] != a[1:], True]
c = np.diff(np.flatnonzero(mask))
out = [[i]*j for i,j in zip(a[mask[:-1]],c)]
</code></pre>
<h3>Benchmarking</h3>
<p>Timings for vectorized approaches on <code>1000000</code> elements with <code>10000</code> unique elements -</p>
<pre><code>In [145]: np.random.seed(0)
     ...: a = np.sort(np.random.randint(1,10000,(1000000)))

In [146]: x = a

# Approach #1 from this post
In [147]: %timeit np.split(a,np.flatnonzero(a[:-1] != a[1:])+1)
100 loops, best of 3: 10.5 ms per loop

# Approach #2 from this post
In [148]: %%timeit
     ...: idx = np.flatnonzero(np.r_[True, a[:-1] != a[1:], True])
     ...: out = [a[i:j] for i,j in zip(idx[:-1],idx[1:])]
100 loops, best of 3: 5.18 ms per loop

# Approach #3 from this post
In [197]: %%timeit
     ...: mask = np.r_[True, a[:-1] != a[1:], True]
     ...: c = np.diff(np.flatnonzero(mask))
     ...: out = [[i]*j for i,j in zip(a[mask[:-1]],c)]
100 loops, best of 3: 11.1 ms per loop

# @RafaelC's soln
In [149]: %%timeit
     ...: v,c = np.unique(x, return_counts=True)
     ...: out = [[a]*b for (a,b) in zip(v,c)]
10 loops, best of 3: 25.6 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.unique.html" rel="nofollow noreferrer"><code>numpy.unique</code></a> and <code>zip</code></p>
<pre><code>v,c = np.unique(x, return_counts=True)
[[a]*b for (a,b) in zip(v,c)]
</code></pre>
<p>Outputs</p>
<pre><code>[[1.0, 1.0, 1.0], [2.0, 2.0], [3.0]]
</code></pre>
<p>Timings for a 6,000,000 sized array</p>
<pre><code>%timeit v,c = np.unique(x, return_counts=True); [[a]*b for (a,b) in zip(v,c)]
18.2 ms ± 236 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

%timeit np.split(x,np.flatnonzero(x[:-1] != x[1:])+1)
424 ms ± 11.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit [list(group) for value, group in itertools.groupby(x)]
180 ms ± 4.42 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The function <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> has this exact behavior.</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; [list(group) for value, group in groupby(array)]
[[1.0, 1.0, 1.0], [2.0, 2.0], [3.0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; a = [1., 1., 1., 2., 2., 3.]
&gt;&gt;&gt; for k, g in groupby(a) :
...     print k, list(g)
... 
1.0 [1.0, 1.0, 1.0]
2.0 [2.0, 2.0]
3.0 [3.0]
</code></pre>
<p>You may join the lists, if you like:</p>
<pre><code>&gt;&gt;&gt; result = []
&gt;&gt;&gt; for k, g in groupby(a) :
...     result.append( list(g) )
... 
&gt;&gt;&gt; result
[[1.0, 1.0, 1.0], [2.0, 2.0], [3.0]]
</code></pre>
</div>
<span class="comment-copy">What's the typical length of the input array and number of unique elements?</span>
<span class="comment-copy">Well, this is something I can work with :) But I'll wait for more answers before I set this Question as solved</span>
<span class="comment-copy">Share the setup for <code>x</code> for the timings?</span>
<span class="comment-copy">@Divakar Had simply <code>x = np.array([1., 1., 1., 2., 2., 3.]*100000)</code>. Timing with <code>np.array([np.random.randint(50) for _ in range(1000000)])</code> yields similar results, but testing with sorted <code>np.array(sorted([np.random.randint(50) for _ in range(1000000)]))</code> your solutions rises to be faster :)</span>
<span class="comment-copy">Well the first two setups are wrong as OP mentioned the inputs are sorted ones and my approaches are specifically leveraging it for performance. Also, whenever you are posting a speedup comparison, please list the setup used. Without the setup, nobody can reproduce it.</span>
<span class="comment-copy">Yep, my solution is my generic and have to consider that there is no necessity for the extra time for the sorting. Forgot to include the setups ;)</span>
