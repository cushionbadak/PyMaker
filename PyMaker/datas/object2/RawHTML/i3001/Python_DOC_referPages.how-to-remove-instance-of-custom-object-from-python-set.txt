<div class="post-text" itemprop="text">
<p>I'm playing around with some basic card/deck manipulations in python. Below you can see my Card class and Deck class. Assume that I know that some cards are dead and would like to remove them from the deck.</p>
<pre><code>import itertools

SUIT_LIST = ("h", "s", "d", "c")
NUMERAL_LIST = ("2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A")

class Card:
    def __init__(self, numeral, suit):
        self.numeral = numeral
        self.suit = suit
        self.card = self.numeral, self.suit
    def __repr__(self):
        return self.numeral + self.suit

class Deck(set):
    def __init__(self):
        for numeral, suit in itertools.product(NUMERAL_LIST, SUIT_LIST):
            self.add(Card(numeral, suit))

deck = Deck()    
dead_card = Card('J','s')
deck.remove(dead_card)
</code></pre>
<p>Raises the following error:</p>
<pre><code>Traceback (most recent call last):

  File "&lt;ipython-input-93-06af62ea1273&gt;", line 23, in &lt;module&gt;
    deck.remove(dead_card)

KeyError: Js
</code></pre>
<p>What is the proper way of removing dead cards from my deck? And why the way I do it does not work?</p>
</div>
<div class="post-text" itemprop="text">
<p>You'll need two new methods on your <code>Card</code> class, for membership in sets and dicts to work sanely:</p>
<pre><code>class Card:
    ...
    def __hash__(self):
        return hash(self.card)
    def __eq__(self, other):
        if isinstance(other, Card):
            return self.card == other.card
        return NotImplemented
</code></pre>
<p>This is because sets are implemented with <a href="https://en.wikipedia.org/wiki/Hash_table" rel="nofollow noreferrer">hash tables</a>, and unless you define how to hash and compare instances of your custom class, a hash based on the <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">identity</a> (memory location in CPython) will be used as a default.  Using <code>id</code> provides a fairly crappy default here - two cards with same number/suit would not be considered "equal" and the membership in a <code>Deck</code> is not recognised.</p>
</div>
<span class="comment-copy">It doesn't work the way you did it because you didn't finish the implementation of items that belong in a <code>set</code>.</span>
<span class="comment-copy">Why not just store the cards as strings or tuples?</span>
<span class="comment-copy">don't you need <code>__ne__</code> as well?</span>
<span class="comment-copy">No, I don't believe you do here.</span>
<span class="comment-copy">@Jean-FrançoisFabre The underlying algorithm uses <code>__hash__</code> to deduce positions in the hash table where an item <i>might</i> be. It then uses <code>__eq__</code> to test if is actually there, or just another object with the same hash. No other special method is used.</span>
<span class="comment-copy">related: <a href="https://stackoverflow.com/questions/4169252/remove-duplicates-in-list-of-object-with-python" title="remove duplicates in list of object with python">stackoverflow.com/questions/4169252/…</a>. Couldn't find a proper duplicate, a lot of q&amp;a are similar, but nothing like this exactly.</span>
