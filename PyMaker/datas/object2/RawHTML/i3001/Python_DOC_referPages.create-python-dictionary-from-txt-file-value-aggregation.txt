<div class="post-text" itemprop="text">
<p>I have a TXT file in the form</p>
<pre><code>22px 31
11px 326
18px 8
13px 41
22px 43
11px 291
</code></pre>
<p>where first column is a font size ("px") and second column is a character count. Is there any way to aggregate (sum) the character count (values) over all font sizes (keys) and divide by total character count by using a python dictionary? The supposed solution should be in the form:</p>
<pre><code>11px    83% # =(326+291)/(31+326+8+41+43+291)
13px    6%
18px    1%
22px    10%
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No need to bother with pandas. Text files are iterable. Just open it, operate on the line (string) and fill a dictionnary.</p>
<pre><code>file = "font.txt"

with open(file, "r") as f:
    dic = dict()
    for line in f:
        x = line.strip("\n").split(" ")

        key = int(x[0].strip("px"))
        value = int(x[1])

        if key not in dic.keys():
            dic[key] = [value]
        else:
            dic[key].append(value)
</code></pre>
<p>Output:</p>
<pre><code>{22: [31, 43], 11: [326, 291], 18: [8], 13: [41]}
</code></pre>
<p>Then it's simple math:</p>
<pre><code>total_number_of_character = sum([sum(x) for x in dic.values()])
percentage = percentage = {key:sum(value)/total_number_of_character*100 for (key, value) in dic.items()}
</code></pre>
<p>Output:</p>
<pre><code>{22: 10.0,
 11: 83.37837837837839,
 18: 1.0810810810810811,
 13: 5.540540540540541}
</code></pre>
</div>
<span class="comment-copy">And your attempt was?</span>
<span class="comment-copy">use pandas , it easy to get it</span>
<span class="comment-copy">Please read <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a> and <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">great many thanks for your solution Mathieu! one last thing: how to order the dictionary by first column (i.e. font size 11px on top)?</span>
<span class="comment-copy">A dictionnary is by definition unordered. You could replace the dictionnary by another datastructure. 1. A list of tuples <code>[(font, [N character 1, N character 2]), ...]</code> then you would order by the first element of the tuple with something like this: <code>sorted(L, key=lambda x:x[0])</code>. 2. You could use an OrderedDict. Read this: <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
