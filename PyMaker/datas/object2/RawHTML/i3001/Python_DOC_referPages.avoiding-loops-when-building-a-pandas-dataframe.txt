<div class="post-text" itemprop="text">
<p>I have an initial Pandas DataFrame with three columns, including one which contains a list of strings. The goal is to split each row into as many elements as there are items in the <code>obj</code> columns, so that for instance this:</p>
<pre><code>from    to      obj
--------------------
abc     xyz     [foo, bar]
def     uvw     [gee]
ghi     rst     [foo, bar, baz]
</code></pre>
<p>becomes this:</p>
<pre><code>from    to      obj
--------------------
abc     xyz     foo
abc     xyz     bar
def     uvw     gee
ghi     rst     foo
ghi     rst     bar
ghi     rst     baz
</code></pre>
<p>Currently I'm doing it like this:</p>
<pre><code>transformed = pd.DataFrame(columns=['from', 'to', 'obj'])

for index, row in origin.iterrows():
    for obj in row['obj']:
        transformed = transformed.append(pd.Series({
            'from':     row['from'],
            'to':       row['to'],
            'obj':      obj
        }), ignore_index=True)
</code></pre>
<p>This works perfectly fine, except it's painfully slow. If <code>origin</code> has 100,000 elements, it can easily take up to one hour to compute <code>transformed</code>.</p>
<p>Is there a vectorised way of getting to the same result, without having to resort to Python loops?</p>
</div>
<div class="post-text" itemprop="text">
<p>In essence, you are <strong>repeating</strong> or <strong>chaining</strong> values according to your column.</p>
<p>So you can use <a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.repeat.html" rel="nofollow noreferrer"><code>np.repeat</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain</code></a> as appropriate. The solution is efficient for a small number of columns, as in your example.</p>
<pre><code>import numpy as np
from itertools import chain

# set up dataframe
df = pd.DataFrame({'from': ['abc', 'def', 'gfhi'],
                   'to': ['xyz', 'uvw', 'rst'],
                   'obj': [['foo', 'bar'], ['gee'], ['foo', 'bar', 'baz']]})

# calculate length of each list in obj
lens = df['obj'].map(len)

# calculate result, repeating or chaining as appropriate
res = pd.DataFrame({'from': np.repeat(df['from'], lens),
                    'to': np.repeat(df['to'], lens),
                    'obj': list(chain.from_iterable(df['obj']))})

print(res)

   from   to  obj
0   abc  xyz  foo
0   abc  xyz  bar
1   def  uvw  gee
2  gfhi  rst  foo
2  gfhi  rst  bar
2  gfhi  rst  baz
</code></pre>
</div>
<span class="comment-copy">Nothing springs to mind. How is the original DF created?</span>
<span class="comment-copy">Half a second compared to one hour. Quite effective.</span>
