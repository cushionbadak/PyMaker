<div class="post-text" itemprop="text">
<p>I want to pass only valid parameters to a function ("read_excel") I tried the following code but getting an error...</p>
<pre><code>import pandas as pd
expected_keys=['io', 'sheet_name','header', 'names', 'index_col', 'usecols', 'squeeze', 'dtype', 'engine', 
               'converters', 'true_values',  'false_values', 'skiprows', 'nrows', 'na_values', 'parse_dates',
               'date_parser', 'thousands', 'comment', 'skipfooter', 'convert_float']

def safe_read_excel(self,  *args, **kwargs):
    if set(kwargs.keys()).difference(set(expected_keys)): 
        raise ValueError('invalid parameter found')
    return self.read_excel(f_name, *args, **kwargs)

pd.safe_read_excel = safe_read_excel
</code></pre>
<p>When I use the default "read_excel" method a dataframe is created...</p>
<pre><code>df= pd.read_excel('sales_summary.xlsx', header=0)
</code></pre>
<p>But my custom method throws an error...</p>
<pre><code>df= pd.safe_read_excel('sales_summary.xlsx', header=0)
</code></pre>
<blockquote>
<p>AttributeError: 'str' object has no attribute 'read_excel'</p>
</blockquote>
<p>How do I assign my function as pandas method?</p>
</div>
<div class="post-text" itemprop="text">
<p>That's because you are writing your <code>safe_read_excel</code> function as a method of a class, while it is a "normal function" (or static method).</p>
<p>In practical words, you do not need <code>self</code>:</p>
<pre><code>def safe_read_excel(f_name,  *args, **kwargs):
    if set(kwargs.keys()).difference(set(expected_keys)): 
        raise ValueError('invalid parameter found')
    return pd.read_excel(f_name, *args, **kwargs)
</code></pre>
<p>I changed the first input of the function from <code>self</code> to <code>f_name</code> and changed the return to <code>pd.read_excel</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You added a new <em>function</em> to the top-level module of the Pandas library. Function attributes of a module object do not get bound and do not get passed the module object as <code>self</code> (modules do not implement <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol access</a>. Just remove the <code>self</code> argument, just access the <code>read_excel</code> function on the <code>pd</code> reference to the module.</p>
<p>The <code>self</code> variable was instead bound to the <code>'sales_summary.xlsx'</code> string, which doesn't have a <code>read_excel</code> attribute.</p>
<p>Note that <code>dict.keys()</code>, in Python 3, is a <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">dictionary view object</a> that can be used as a set <em>directly</em>:</p>
<pre><code>def safe_read_excel(*args, **kwargs):
    if not kwargs.keys() &lt;= expected_keys: 
        raise ValueError('invalid parameter found')
    return pd.read_excel(f_name, *args, **kwargs)
</code></pre>
<p>The <code>&lt;=</code> operation is only true if <code>kwargs.keys()</code> is a subset of or equal to the names in <code>expected_keys</code>. This is more efficient than using <code>set.difference()</code> or <code>set_object - set_object</code>, as no new set object needs to be created. I'd make <code>expected_keys</code> a set object rather than a list, here, to aid set operation performance:</p>
<pre><code>expected_keys = {
    'io', 'sheet_name','header', 'names', 'index_col', 'usecols', 'squeeze',
    'dtype', 'engine', 'converters', 'true_values',  'false_values',
    'skiprows', 'nrows', 'na_values', 'parse_dates', 'date_parser',
    'thousands', 'comment', 'skipfooter', 'convert_float'
}
</code></pre>
<p>In Python 2, you'd use <code>kwargs.viewkeys()</code> instead, to get the same functionality. For a library that needs to support both Python 2 and 3, you can use <a href="https://pythonhosted.org/six/#six.viewkeys" rel="nofollow noreferrer"><code>six.viewkeys()</code></a> or create your own local versions of <a href="https://github.com/benjaminp/six/blob/84d07dd19523a3a41385f23a744a126d00a72c79/six.py#L579-L614" rel="nofollow noreferrer">what the <code>six</code> library does</a>.</p>
<p>Note that you <em>never need to bind to a module</em>; you already need to have access to the module to add your new function to the namespace, and modules are singletons. Your function will always deal with just the one module object, not with multiple instances of the Pandas library, so there is no need to complicate your codebase with binding support here. Methods need binding only because you can have any number of instances for a single class, and your method needs to have access to a specific instance from those to have access to the instance attributes.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can bind a new method to a class by using the <code>types</code> module, which will allow you to do introspection / refer to <code>self</code> inside the new class method:</p>
<pre><code>import pandas as pd
import types

expected_keys=['io', 'sheet_name','header', 'names', 'index_col', 'usecols', 'squeeze', 'dtype', 'engine',
               'converters', 'true_values',  'false_values', 'skiprows', 'nrows', 'na_values', 'parse_dates',
               'date_parser', 'thousands', 'comment', 'skipfooter', 'convert_float']

def safe_read_excel(self,  *args, **kwargs):
    if set(kwargs.keys()).difference(set(expected_keys)):
      raise ValueError('invalid parameter found')
    return self.read_excel(args[0], *args, **kwargs)

pd.safe_read_excel = types.MethodType(safe_read_excel, pd)

df = pd.safe_read_excel('sales_summary.xlsx', header=0)
</code></pre>
</div>
<span class="comment-copy">As far as I can tell, you cannot assign a new function to an imported module, so this is a bad idea to begin with, despite the error.</span>
<span class="comment-copy">And even if you could, <code>pd.read_excel()</code> isn't a class method to begin with, and OP implemented <code>safe_read_excel</code> assuming it is.</span>
<span class="comment-copy">Why would this be better though? You already have access to the <code>pd</code> name right there. This doesn't help readability of the code base.</span>
<span class="comment-copy">I don't think access to <code>self</code> is helpful for the particular problem the user posed, but if the user wanted to gain access to <code>self</code> I wanted to show that it's possible.</span>
<span class="comment-copy">Sure, it's possible, but totally pointless when modules are singletons.</span>
