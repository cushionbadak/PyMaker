<div class="post-text" itemprop="text">
<p>I am currently reviewing <a href="http://norvig.com/sudoku.html" rel="nofollow noreferrer">this post</a> about a sudoku solver in Python. I am trying to deconstruct it line by line, and I went through the following</p>
<pre><code>digits   = '123456789'
rows     = 'ABCDEFGHI'
cols     = digits
#squares will give you all the squares of a Sudoku, from A1-A9 to I1-I9
squares  = cross(rows, cols)
unitlist = ([cross(rows, c) for c in cols] +
            [cross(r, cols) for r in rows] +
            [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')])

#each square has 3 units : the row it is in, the column it is in, and the "block" of 3x3 squares it is in :

units = dict((s, [u for u in unitlist if s in u]) 
             for s in squares)
</code></pre>
<p>That last part is what dumbfounds me. We have, if I am not mistaken, a list comprehension, inside a generator.
But what is the "for s in squares" doing inside the dict function ?
How comes I can't write the following and obtain the same result ?</p>
<pre><code>for s in squares :
    units3 = dict((s, [u for u in unitlist if s in u]))
</code></pre>
<p>This seems pretty obsure to me, unfortunately all my attempts at finding a ressource for this end up with results that point to basic tutorials on dict creation, or looping over dict values...</p>
<p>Could you please either tell me how a for loop inside a dict function works, or point me towards a good tuto on that topic ?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not a list comprehension, but a generator expression. The two are related, but no list is built. A generator expression produces a generator object, something that can be iterated over lazily and each step the loop expression is executed.</p>
<p>For example, you could create such an expression to calculate squares:</p>
<pre><code>&gt;&gt;&gt; squares = (i ** 2 for i in range(10))
&gt;&gt;&gt; squares
&lt;generator object &lt;genexpr&gt; at 0x10c832468&gt;
&gt;&gt;&gt; next(squares)
0
&gt;&gt;&gt; next(squares)
1
&gt;&gt;&gt; next(squares)
4
</code></pre>
<p>The <code>next()</code> function advances the iterator to produce the next value. In between, the generator is paused, the remaining values have yet to be computed.</p>
<p>In the example you found, the generator expression is the only argument to the <code>dict()</code> call, in which case the <code>(...)</code> for the generator expression can be omitted. You could also write <code>dict((...))</code> and it'll produce the exact same results; if a call takes more than one argument those parentheses would be required instead. Nested inside the <code>dict(...)</code> generator expression is a list comprehension for just the dictionary value.</p>
<p>The generator produces <code>(key, value)</code> tuples, which the <code>dict()</code> callable uses to create a dictionary. See the <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="nofollow noreferrer"><code>dict()</code> documentation</a>:</p>
<blockquote>
<p><em>[...]</em> Otherwise, the positional argument must be an iterable object. Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value.</p>
</blockquote>
<p>So the equivalent <code>for</code> loop statement would be:</p>
<pre><code>units = {}
for s in squares:
    units[s] = [u for u in unitlist if s in u]
</code></pre>
<p>Note the <code>[u for u in unitlist if s in u]</code> list comprehension; it is a separate expression independent from the generator expression (but it does use the current value of <code>s</code> each time). The loop sets a value in a dictionary we had to create up front here, but otherwise each iterable step has the same outcome: a key <code>s</code> is set with the list comprehension result as the value.</p>
<p>In Python 2.7 and Python 3, instead of a generator expression, you can use a <em>dictionary comprehension</em> to produce the exact same dictionary:</p>
<pre><code>units = {s: [u for u in unitlist if s in u] for s in squares}
</code></pre>
<p>The pattern for a dictionary comprehension is <code>{&lt;key expression&gt;: &lt;value expression&gt; for ... in ... &lt;optionally more if filters and for loops&gt;}</code>; compare this to the <code>dict((&lt;key expression&gt;, &lt;value expression&gt;) for ... in ... &lt;optionally more if filters and for loops&gt;)</code> pattern used by the code you found. A dictionary comprehension is faster, because the interpreter no longer has to worry about how to stop and start a generator expression each step, nor does it have to locate the <code>dict</code> name and call out to it.</p>
</div>
<span class="comment-copy">It's not inside a dict. The list comprehension is just creating a tuple, which you then use to create a dict.</span>
<span class="comment-copy">"We have, if I am not mistaken, a list comprehension, inside a generator." &lt;= was that statement incorrect ? I understood the generator from the start, I just didn't understand that with dict(), the () usually used for a generator can be omitted. I guess the best statement would be "we have a list comp, inside a tuple, inside a generator". Is that more correct ?</span>
<span class="comment-copy">That was a quick and thorough answer. Thank you very much !</span>
