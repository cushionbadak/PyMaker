<div class="post-text" itemprop="text">
<p>Imagine we have a list of stocks: </p>
<pre><code>stocks = ['AAPL','GOOGL','IBM']
</code></pre>
<p>The specific stocks don't matter, what matters is that we have n items in this list. </p>
<p>Imagine we also have a list of weights, from 0% to 100%:</p>
<pre><code>weights = list(range(101))
</code></pre>
<p>Given n = 3 (or any other number) I need to produce a matrix with every possible combinations of weights that sum to a full 100%. E.g. </p>
<pre><code>0%, 0%, 100%
1%, 0%, 99%
0%, 1%, 99%
etc...
</code></pre>
<p>Is there some method of itertools that can do this? Something in numpy? What is the most efficient way to do this? </p>
</div>
<div class="post-text" itemprop="text">
<p>The way to optimize this isn't to figure out a faster way to generate the permutations, it's to generate as few permutations as possible.</p>
<hr/>
<p>First, how would you do this if you only wanted the combination that were in sorted order?</p>
<p>You don't need to generate all possible combinations of 0 to 100 and then filter that. The first number, <code>a</code>, can be anywhere from 0 to 100. The second number, <code>b</code>, can be anywhere from 0 to (100-a). The third number, <code>c</code>, can only be 100-a-b. So:</p>
<pre><code>for a in range(0, 101):
    for b in range(0, 101-a):
        c = 100-a-b
        yield a, b, c
</code></pre>
<p>Now, instead of generating <code>100*100*100</code> combination to filter them down to <code>100*50*1+1</code>, we're just generating the <code>100*50*1+1</code>, for a 2000x speedup.</p>
<p>However, keep in mind that there are still around <code>X * (X/2)**N</code> answers. So, computing them in <code>X * (X/2)**N</code> time instead of <code>X**N</code> may be optimal—but it's still exponential time. And there's no way around that; you want an exponential number of results, after all.</p>
<p>You can look for ways to make the first part more concise with <code>itertools.product</code> combined with <code>reduce</code> or <code>accumulate</code>, but I think it's going to end up less readable, and you want to be able to extend to any arbitrary <code>N</code>, and also to get all permutations rather than just the sorted ones. So keep it understandable until you do that, and then look for ways to condense it after you're done.</p>
<hr/>
<p>You obviously need to either go through N steps. I think this is easier to understand with recursion than a loop.</p>
<p>When <code>n</code> is 1, the only combination is <code>(x,)</code>.</p>
<p>Otherwise, for each of the values a from 0 to x, you can have that value, together with all of the combinations of n-1 numbers that sum to x-a. So:</p>
<pre><code>def sum_to_x(x, n):
    if n == 1:
        yield (x,)
        return
    for a in range(x+1):
        for result in sum_to_x(x-a, n-1):
            yield (a, *result)
</code></pre>
<hr/>
<p>Now you just need to add in the permutations, and you're done:</p>
<pre><code>def perm_sum_to_x(x, n):
    for combi in sum_to_x(x, n):
        yield from itertools.permutations(combi)
</code></pre>
<p>But there's one problem: <code>permutations</code> permutes <em>positions</em>, not <em>values</em>. So if you have, say, <code>(100, 0, 0)</code>, the six permutations of that are <code>(100, 0, 0)</code>, <code>(100, 0, 0)</code>, <code>(0, 100, 0)</code>, <code>(0, 0, 100)</code>, <code>(0, 100, 0)</code>, <code>(0, 0, 100)</code>.</p>
<hr/>
<p>If N is very small—as it is in your example, with N=3 and X=100—it may be fine to just generate all 6 permutations of each combination and filter them:</p>
<pre><code>def perm_sum_to_x(x, n):
    for combi in sum_to_x(x, n):
        yield from set(itertools.permutations(combi))
</code></pre>
<p>… but if N can grow large, we're talking about a lot of wasted work there as well.</p>
<p>There are plenty of good answers here on how to do permutations without repeated values. See <a href="https://stackoverflow.com/questions/6284396/">this question</a>, for example. Borrowing an implementation from that answer:</p>
<pre><code>def perm_sum_to_x(x, n):
    for combi in sum_to_x(x, n):
        yield from unique_permutations(combi)
</code></pre>
<p>Or, if we can drag in <a href="http://www.sympy.org/en/index.html" rel="nofollow noreferrer">SymPy</a> or <a href="https://github.com/erikrose/more-itertools/" rel="nofollow noreferrer"><code>more-itertools</code></a>:</p>
<pre><code>def perm_sum_to_x(x, n):
    for combi in sum_to_x(x, n):
        yield from sympy.multiset_permutations(combi)

def perm_sum_to_x(x, n):
    for combi in sum_to_x(x, n):
        yield from more_itertools.distinct_permutations(combi)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you are looking for is <code>product</code> from <code>itertools</code> module
you can use it as shown below</p>
<pre><code>from itertools import product

weights = list(range(101))
n = 3
lst_of_weights = [i for i in product(weights,repeat=n) if sum(i)==100]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you need is <code>combinations_with_replacement</code> <em>because</em> in your question you wrote <strong>0, 0, 100</strong> which means you expect repetition, like <strong>20, 20, 60</strong> etc. </p>
<pre><code>from itertools import combinations_with_replacement
weights = range(11)
n = 3
list = [i for i in combinations_with_replacement(weights, n) if sum(i) == 10]
print (list)
</code></pre>
<p>The above code results in 
<code>[(0, 0, 10), (0, 1, 9), (0, 2, 8), (0, 3, 7), (0, 4, 6), (0, 5, 5), (1, 1, 8), (1, 2, 7), (1, 3, 6), (1, 4, 5), (2, 2, 6), (2, 3, 5), (2, 4, 4), (3, 3, 4)]</code></p>
<p>Replace <code>range(10)</code>, <code>n</code> and <code>sum(i) == 10</code> by whatever you need.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a classic <a href="https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics)" rel="nofollow noreferrer">Stars and bars</a> problem, and Python's <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a> module does indeed provide a solution that's both simple and efficient, without any additional filtering needed.</p>
<p>Some explanation first: you want to divide 100 "points" between 3 stocks in all possible ways. For illustration purposes, let's reduce to 10 points instead of 100, with each one worth 10% instead of 1%. Imagine writing those points as a string of ten <code>*</code> characters:</p>
<pre><code>**********
</code></pre>
<p>These are the "stars" of "stars and bars". Now to divide the ten stars amongst the 3 stocks, we insert two <code>|</code> divider characters (the "bars" of "stars and bars"). For example, one such division might look like this::</p>
<pre><code>**|*******|*
</code></pre>
<p>This particular combination of stars and bars would correspond to the division 20% AAPL, 70% GOOGL, 10% IBM. Another division might look like:</p>
<pre><code>******||****
</code></pre>
<p>which would correspond to 60% AAPL, 0% GOOGL, 40% IBM.</p>
<p>It's easy to convince yourself that every string consisting of ten <code>*</code> characters and two <code>|</code> characters corresponds to exactly one possible division of the ten points amongst the three stocks.</p>
<p>So to solve your problem, all we need to do is generate all possible strings containing ten <code>*</code> star characters and two <code>|</code> bar characters. Or, to think of this another way, we want to find all possible pairs of positions that we can place the two bar characters, in a string of total length twelve. Python's <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> function can be used to give us those possible positions, (for example with <code>itertools.combinations(range(12), 2)</code>) and then it's simple to translate each pair of positions back to a division of <code>range(10)</code> into three pieces: insert an extra imaginary divider character at the start and end of the string, then find the number of stars between each pair of dividers. That number of stars is simply one less than the distance between the two dividers.</p>
<p>Here's the code:</p>
<pre><code>import itertools

def all_partitions(n, k):
    """                                                                         
    Generate all partitions of range(n) into k pieces.                          
    """
    for c in itertools.combinations(range(n+k-1), k-1):
        yield tuple(y-x-1 for x, y in zip((-1,) + c, c + (n+k-1,)))
</code></pre>
<p>For the case you give in the question, you want <code>all_partitions(100, 3)</code>. But that yields <code>5151</code> partitions, starting with <code>(0, 0, 100)</code> and ending with <code>(100, 0, 0)</code>, so it's impractical to show the results here. Instead, here are the results in a smaller case:</p>
<pre><code>&gt;&gt;&gt; for partition in all_partitions(5, 3):
...     print(partition)
... 
(0, 0, 5)
(0, 1, 4)
(0, 2, 3)
(0, 3, 2)
(0, 4, 1)
(0, 5, 0)
(1, 0, 4)
(1, 1, 3)
(1, 2, 2)
(1, 3, 1)
(1, 4, 0)
(2, 0, 3)
(2, 1, 2)
(2, 2, 1)
(2, 3, 0)
(3, 0, 2)
(3, 1, 1)
(3, 2, 0)
(4, 0, 1)
(4, 1, 0)
(5, 0, 0)
</code></pre>
</div>
<span class="comment-copy">Do you really need this matrix? If my back-of-the-envelope math is right, there are around 30K values for N=3, 4M for N=4, and it keeps going up from there. What are you going to do with all of those values? Are you sure you don't just need, e.g., a way to generate 1000 possible values distributed nicely among them so you can draw some kind of graph?</span>
<span class="comment-copy">Is <code>weights</code> always the list [0, 1, 2, ..., 100]?</span>
<span class="comment-copy">Outstanding answer, very clear. Thank you for taking the time.</span>
<span class="comment-copy">I think your <code>perm_sum_to_x</code> is unnecessary. The <code>sum_to_x</code> function <i>already</i> generates all desired permutations (not just those in sorted order) exactly once. For example, <code>list(sum_to_x(2, 3))</code> gives <code>[(0, 0, 2), (0, 1, 1), (0, 2, 0), (1, 0, 1), (1, 1, 0), (2, 0, 0)]</code>. So <code>perm_sum_to_x</code> adds unnecessary repetitions of existing permutations.</span>
<span class="comment-copy">The OP asked for the most efficient way. This will calculate millions of values just to produce the few thousand correct ones, which is hardly the most efficient.</span>
<span class="comment-copy">@abarnert, i love your answer, but OP also mentioned "Is there some method of itertools that can do this". So, my answer is pointed towards that</span>
<span class="comment-copy">This doesn't generate all of the answers, because the OP wants permutations like <code>(0, 1, 99)</code> and <code>(1, 0, 99)</code>. And it's as inefficient as <a href="https://stackoverflow.com/a/51584327/908494">InAFlash's answer</a>—it's generating 1000 combinations to filter them to 14; this gets even worse as X or N increases; it's already 1000000 combinations for the OP's example problem.</span>
