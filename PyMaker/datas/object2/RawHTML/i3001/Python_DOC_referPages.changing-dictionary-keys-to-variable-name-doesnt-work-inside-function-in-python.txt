<div class="post-text" itemprop="text">
<p>First of all, let me say that I read the many threads with similar topics on creating dynamically named variables, but they mostly relate to Python 2 or they assume you are working with classes. And yes, I read <a href="https://stackoverflow.com/questions/15086040/behaviour-of-exec-function-in-python-2-and-python-3">Behavior of exec function in Python 2 and Python 3</a>. </p>
<p>I'm also aware that creating dynamically named variables is a bad idea in 99% of time and dictionaries are the way to got, but I just want to know whether it is still possible and how exactly exec and locals work in python 3.</p>
<p>I'd like to show a bit of sample code illustrating my question (fibonacci calculates fibonacci numbers, ListOfLetters provides ["A", "B", ...]):</p>
<pre><code>def functionname():
    for index, buchstabe in enumerate(ListOfLetters.create_list("A", "K"), 1): 
        exec("{} = {}".format(buchstabe, fibonacci(index)) ) #A = 1, B = 1, C = 2, D = 3, E = 5,...
        print(index, buchstabe, eval(buchstabe)) #works nicely, e.g. prints "4 D 3"
    print(locals()) #pritns all locals: {'B': 1, 'A': 1, 'index': 11, 'C': 2, 'H': 21, 'K': 89, ...
    print(locals()['K']) #prints 89 as it should
    print(eval("K")) #prints 89 as it should
    print(K) #NameError: name 'K' is not defined
</code></pre>
<p>So at least at my current understanding, there is some inconsistency in the behaviour of <code>locals()</code>, since it contains the variable names added by <code>exec()</code> but the variables are not available in the function.</p>
<p>I would be greatful if someone could explain this and tell whether this is by design or if it is a real inconsistency in the language. Yes, I know that <a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer"><code>locals</code></a> should not be modified , but I'm not modifying it, I'm calling <code>exec()</code>... </p>
</div>
<div class="post-text" itemprop="text">
<p>When you're not sure why something works the way it does in Python, it often can help to put the behavior that you're confused by in a function and then disassemble it from the Python bytecode with the <code>dis</code> module.</p>
<p>Lets start with a simpler version of your code:</p>
<pre><code>def foo():
    exec("K = 89")
    print(K)
</code></pre>
<p>If you run <code>foo()</code>, you'll get the same exception you're seeing with your more complicated function:</p>
<pre><code>&gt;&gt;&gt; foo()
Traceback (most recent call last):
  File "&lt;pyshell#167&gt;", line 1, in &lt;module&gt;
    foo()
  File "&lt;pyshell#166&gt;", line 3, in foo
    print(K)
NameError: name 'K' is not defined
</code></pre>
<p>Lets disassemble it and see why:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(foo)
  2           0 LOAD_GLOBAL              0 (exec)
              3 LOAD_CONST               1 ('K = 89')
              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
              9 POP_TOP

  3          10 LOAD_GLOBAL              1 (print)
             13 LOAD_GLOBAL              2 (K)
             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             19 POP_TOP
             20 LOAD_CONST               0 (None)
             23 RETURN_VALUE
</code></pre>
<p>The operation that you need to pay attention to is the one labeled "13". This is where the compiler handles looking up <code>K</code> within the last line of the function (<code>print(K)</code>). It is using the <code>LOAD_GLOBAL</code> opcode, which fails because "K" is not a global variable name, rather it's a value in our <code>locals()</code> dict (added by the <code>exec</code> call).</p>
<p>What if we persuaded the compiler to see <code>K</code> as a local variable (by giving it a value before running the <code>exec</code>), so it will know not to look for a global variable that doesn't exist?</p>
<pre><code>def bar():
    K = None
    exec("K = 89")
    print(K)
</code></pre>
<p>This function won't give you an error if you run it, but you won't get the expected value printed out:</p>
<pre><code>&gt;&gt;&gt; bar()
None
</code></pre>
<p>Lets disassemble to see why:</p>
<pre><code>&gt;&gt;&gt; dis.dis(bar)
  2           0 LOAD_CONST               0 (None)
              3 STORE_FAST               0 (K)

  3           6 LOAD_GLOBAL              0 (exec)
              9 LOAD_CONST               1 ('K = 89')
             12 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             15 POP_TOP

  4          16 LOAD_GLOBAL              1 (print)
             19 LOAD_FAST                0 (K)
             22 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             25 POP_TOP
             26 LOAD_CONST               0 (None)
             29 RETURN_VALUE
</code></pre>
<p>Note the opcodes used at "3" and "19". The Python compiler uses <code>STORE_FAST</code> and <code>LOAD_FAST</code> to put the value for the local variable <code>K</code> into slot 0 and later fetch it back out. Using numbered slots is significantly faster than inserting and fetching values from a dictionary like <code>locals()</code>, which is why the Python compiler does it for all local variable access in a function. You can't overwrite a local variable in a slot by modifying the dictionary returned by <code>locals()</code> (as <code>exec</code> does, if you don't pass it a dict to use for its namespace).</p>
<p>Indeed, lets try a third version of our function, where we peek into <code>locals</code> again when we have <code>K</code> defined as a regular local variable:</p>
<pre><code>def baz():
    K = None
    exec("K = 89")
    print(locals())
</code></pre>
<p>You won't see <code>89</code> in the output this time either!</p>
<pre><code>&gt;&gt;&gt; baz()
{"K": None}
</code></pre>
<p>The reason you see the old <code>K</code> value in <code>locals()</code> is explained in <a href="https://docs.python.org/3.5/library/functions.html#locals">the function's documentation</a>:</p>
<blockquote>
<p>Update and return a dictionary representing the current local symbol table.</p>
</blockquote>
<p>The slot that the local variable <code>K</code>'s value is stored in was not changed by the <code>exec</code> statement, which only modifies the <code>locals()</code> dict. When you call <code>locals()</code> again, Python "update[s]" the dictionary with the value from the slot, replacing the value stored there by <code>exec</code>.</p>
<p>This is why the docs go on to say:</p>
<blockquote>
<p><strong>Note:</strong> The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter.</p>
</blockquote>
<p>Your <code>exec</code> call is modifying the <code>locals()</code> dict, and you're finding how its changes are not always seen by your later code.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>On the exec/eval/locals question</strong></p>
<p><em>At least on the CPython implementation</em> modifications to the <code>locals()</code> dictionary do not actually change the names in the local scope, which is why it's meant to be used read-only. You can change it, and you can see your changes in the dictionary object, but the actual local scope is not changed.</p>
<p><code>exec()</code> takes two optional dictionary arguments, a global scope and a local scope. It defaults to <code>globals()</code> and <code>locals()</code>, but since changes to <code>locals()</code> aren't "real" outside of the dictionary, <code>exec()</code> only affects the "real" local scope when <code>globals() is locals()</code>, i.e. in a module outside of any function. (So in your case it's failing because it's inside a function scope).</p>
<p>The "better" way to use <code>exec()</code> in this case is to pass in your own dictionary, then operate on the values in that.</p>
<pre><code>def foo():
    exec_scope = {}
    exec("y = 2", exec_scope)
    print(exec_scope['y'])
foo()
</code></pre>
<p>In this case, <code>exec_scope</code> is used as the global and local scope for the <code>exec</code>, and after the <code>exec</code> it will contain <code>{'y': 2, '__builtins__': __builtins__}</code> (the builtins are inserted for you if not present)</p>
<p>If you want access to more globals you could do <code>exec_scope = dict(globals())</code>.</p>
<p>Passing in different global and local scope dictionaries can produce "interesting" behavior.</p>
<p>If you pass the same dictionary into successive calls to <code>exec</code> or <code>eval</code>, then they have the same scope, which is why your <code>eval</code> worked (it implicitly used the <code>locals()</code> dictionary).</p>
<p><strong>On dynamic variable names</strong></p>
<p>If you set the name from a string, what's so wrong about getting the value as a string (i.e. what a dictionary does)? In other words, why would you <em>want</em> to set <code>locals()['K']</code> and then access <code>K</code>? If <code>K</code> is in your source it's not really a dynamically set name... hence, dictionaries.</p>
</div>
<span class="comment-copy">Answers from <a href="http://stackoverflow.com/questions/8028708/dynamically-set-local-variable-in-python">this topic</a> should really give you better understanding.</span>
<span class="comment-copy">See <a href="http://stackoverflow.com/a/15087355">Behaviour of exec function in Python 2 and Python 3</a>; answering your question directly.</span>
<span class="comment-copy">And note that <code>exec()</code> is modifying <code>locals()</code> on your behalf because you didn't pass in any more specific namespace dictionaries.</span>
<span class="comment-copy">You may find <a href="http://stackoverflow.com/q/7969949/208880">this question/answer</a> useful, as well.</span>
<span class="comment-copy">modifications to locals() is not garuanteed, and does actually occur in other Pythons (I think IronPython and the Jython do this, and CPython 2 does under certain circumstances).</span>
<span class="comment-copy">Yes, I should state that all of the above disassembly is from Python 3.4.0. If you use a different Python version or an interpreter other than cpython you may get somewhat different results. My answer is mostly an exploration of <i>why</i> cpython 3.4 behaves the way it does. You really should not rely upon the specifics in your code.</span>
<span class="comment-copy">Thanks for the disassembly!</span>
<span class="comment-copy">modifications to <code>locals()</code> is not garaunteed, and does actually occur in other Pythons (I think IronPython and the Java Python do this).</span>
<span class="comment-copy">The IronPython and Jython docs both say you shouldn't modify locals() and that it "may" not affect the interpreter state. I take "may not" to mean "doesn't except maybe in weird edge cases," but noting the possibility of differences between implementations is a good point.</span>
<span class="comment-copy">I use neither so I can't say how often it works.  My point was that the effect of modifying <code>locals()</code> is not language specified -- hence the "may not" wording.</span>
<span class="comment-copy">Thanks for the good answer! It was hard for me to decide who should get the +50...</span>
