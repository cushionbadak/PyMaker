<div class="post-text" itemprop="text">
<pre><code>x=5
print(eval('x+1',{'__builtins__': None}))
</code></pre>
<p>Getting Error:    </p>
<pre><code>TypeError: 'NoneType' object is not subscriptable
</code></pre>
<p>Why am I getting above error? </p>
<p>Also, How to specify only a few built-in methods for eval() function? For example, allowing only <code>max</code> and <code>min</code> functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow noreferrer">builtins docs:</a></p>
<blockquote>
<p>The value of <code>__builtins__</code> is normally either this module <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow noreferrer">[builtins]</a> or the value of this module's <code>__dict__</code> attribute</p>
</blockquote>
<p>To fix your error: </p>
<pre><code>&gt;&gt;&gt; print(eval('x+1',{'__builtins__': {'x': x}}))
</code></pre>
<p>To specify a few built-in methods, provide it to <code>__builtins__</code></p>
<pre><code>&gt;&gt;&gt; print(eval('min(1,2)',{'__builtins__': {'min': min}}))
</code></pre>
<p>However, limiting <code>__builtins__</code> is still not safe: see <a href="https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow noreferrer">https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html</a> </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why am I getting above error?</p>
</blockquote>
<p>Python tries to look for the name <code>'x'</code> within the builtins you've provided, and fails like that:</p>
<pre><code>&gt;&gt;&gt; None['x']
TypeError: 'NoneType' object is not subscriptable
</code></pre>
<p>You would need to include <code>x</code> in scope too:</p>
<pre><code>&gt;&gt;&gt; x = 5
&gt;&gt;&gt; eval('x+1', {'__builtins__': None, 'x': x})
6
</code></pre>
<blockquote>
<p>How to specify only a few built-in methods for <code>eval()</code> function? </p>
</blockquote>
<p>You can not sandbox this way.  It's always possible to escape the sandbox, for example via an attribute access on literals.</p>
</div>
<div class="post-text" itemprop="text">
<p>Is the same reason why you don't get defined 'x' if you do:</p>
<pre><code>x=5
print(eval("x+1",{'__builtins__': __builtins__}))
</code></pre>
<p>you get: <code>NameError: name 'x' is not defined</code> because you override all your context.</p>
<p>but if you just do:</p>
<pre><code>x=5
print(eval("x+1"))
</code></pre>
<p>will print '6' but will use ALL the builtins functions, probably you just wanna do:</p>
<pre><code>x=5
print(eval("x+1",{'__builtins__': {'min': min, 'max': max, 'x': x}}))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One of the possible solutions would be to get current globals end clear the builtins</p>
<pre><code>x=5
dictionary = globals()
dictionary['__builtins__'] = None
print(eval('x+1',dictionary))
</code></pre>
</div>
<span class="comment-copy"><code>__builtins__</code> is usually a module.  There is no reason that it "should" be a dictionary.  It's the second argument passed to <code>eval</code> which should be a dictionary.</span>
<span class="comment-copy">thanks for providing clear explanation.</span>
<span class="comment-copy">Crisp and clear explanation, thanks!</span>
