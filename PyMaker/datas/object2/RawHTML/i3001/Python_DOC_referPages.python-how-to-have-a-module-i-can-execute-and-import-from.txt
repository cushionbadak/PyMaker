<div class="post-text" itemprop="text">
<p>I have a Python package <code>mypackage</code> which contains a bunch of modules / classes with this directory structure:</p>
<pre><code>├── interface.py
├── mypackage/
|   └── __init__.py
|   └── classA.py
|   └── classB.py
|   └── ...
</code></pre>
<p><em>The</em> current use case is to use <code>interface.py</code> with a bunch of <code>argparse</code> flags:</p>
<pre><code>python interface.py --foo --bar 
</code></pre>
<p>Inside <code>interface.py</code> it instantiates a bunch of the classes with <code>mypackage</code> and runs their methods. Something like:</p>
<pre><code>from classA import ClassA

def interfaceMethod(foo, bar):
    a = ClassA(foo, ...)
    print(a.classMethod(bar, ...)

if args.foo: interfaceMethod(args.foo, args.bar)
</code></pre>
<p>This works well when getting non-python / programmers to use my code. But I'd like to also be able to import my package within their Python code and run the same methods in <code>interface.py</code>. Something like:</p>
<pre><code>import mypackage
print(mypackage.interfaceMethod(foo, bar)
</code></pre>
<p><strong>Question</strong></p>
<ul>
<li>Is there a standard/best way to do this? </li>
<li><strong>Note</strong>: I don't think users need to see my class structure so I'd rather there be one user facing class which implements all of the methods in <code>interface.py</code></li>
</ul>
<p><em>Solution 1</em> (I don't think this is the preferred solution):</p>
<p>Add methods from <code>interface.py</code> into <code>__init__.py</code>:</p>
<pre><code># in __init__.py
from classA import ClassA

def interfaceMethod():
    a = ClassA(foo)
    print(a.classMethod(bar))
</code></pre>
<p>Then users can do the following in their own code (it would look very similar in <code>interface.py</code> as well):</p>
<pre><code>import mypackage
mypackage.interfaceMethod()
</code></pre>
<p><em>Solution 2</em>:</p>
<p>Create a <code>mypackage</code> class:</p>
<pre><code>class MyPackage():
    self.classA = ClassA(...)
    self.classB = ClassB(...)

    def interfaceMethod():
        a = self.classA()
</code></pre>
<p>If I create this class should I worry about the package and class having the same name? Do I change the hierarchy of the package structure to reflect that <code>MyPackage</code> is the forward facing class? </p>
</div>
<div class="post-text" itemprop="text">
<p>A good way would to use a <code>setup.py</code> and use <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#automatic-script-creation" rel="nofollow noreferrer"><code>console_scripts</code></a></p>
<p>Put you <code>interface.py</code> inside you package and this to your <code>setup.py</code>:</p>
<pre><code>setup(
    # other arguments here...
    entry_points={
        'console_scripts': [
            'script_name = my_package.interface:interfaceMethod',
        ],
    }
)
</code></pre>
<p>Change your <code>interface.py</code> to:</p>
<pre><code>from classA import ClassA

def interfaceMethod(foo, bar):
    a = ClassA(foo, ...)
    print(a.classMethod(bar, ...)

if __name__ == '__main__':
    interfaceMethod(args.foo, args.bar)
</code></pre>
<p>Once you install with <code>Python setup.py install</code>, you can call your program
from the command line:</p>
<pre><code>script_name --foo --bar 
</code></pre>
<p>For details see the <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html" rel="nofollow noreferrer">full documentation</a>.</p>
<p>You can still import it with:</p>
<pre><code>from mypackage import interface
interface.interfaceMethod()
</code></pre>
</div>
<span class="comment-copy">Is this question ultimately: how do I both have a module I can execute and import from?</span>
<span class="comment-copy">I don't like adding code to <code>__init__.py</code>, personal preference. It can make it hard to figure out where things are due to the forwarded imports. It can be nice if you're developing an API that other python devs are going to consume just to shorten names. Other than that, i'd recommend avoiding it. It throws beginners for a loop when they do <code>import mypackage; mypackage.doStuff()</code>, and in reality <code>doStuff()</code> is 700 layers deep in a directory hierarchy instead of in the first layer as expected. They'll eventually come to you bc they cant figure out where the module actually lives on the filesys.</span>
<span class="comment-copy">I'm not sure if it's just part of the abstract, pseudocode-like example you've given here, but I want to make sure you understand that Python modules and classes need not be closely correlated. Unlike Java, you don't need a separate file for each class, nor do you need a class for every module. Use separate modules wherever you want a separate global namespace. Use classes wherever you want to associate data with methods. Don't mix up the two concepts.</span>
<span class="comment-copy">@MatthewStory sure, I think that makes more sense than my current question. Changed the title, thank you.</span>
<span class="comment-copy">@Blckknght I tried to keep my pseudocode as simple as possible but I have reasons for splitting my classes into different files.</span>
<span class="comment-copy">This is very similar to what I have already: <code>setup(scripts='myinterface.py', ...)</code>. The interface script has dozens of methods so I don't want to list each under <code>console_scripts</code>.</span>
<span class="comment-copy">How about making the different methods sub-commands with <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer"><code>argparse</code></a>  or <a href="http://click.pocoo.org/5/" rel="nofollow noreferrer"><code>click</code></a> or  <a href="http://docopt.org" rel="nofollow noreferrer"><code>docopt</code></a>?</span>
