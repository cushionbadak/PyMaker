<div class="post-text" itemprop="text">
<p>I want to sum two different variables in one function, but I want these to be summed based on multiple other items. </p>
<p>If I have the following list of dicts x:</p>
<pre><code>x=[{'id':1, 'var1':'a', 'var2':'left', 'var3':0.1, 'var4':1},
   {'id':2, 'var1':'a', 'var2':'right', 'var3':0.1, 'var4':1},
   {'id':2, 'var1':'a', 'var2':'right', 'var3':0.2, 'var4':3},
   {'id':4, 'var1':'b', 'var2':'left', 'var3':0.4, 'var4':4},
   {'id':5, 'var1':'b', 'var2':'right', 'var3':0.1, 'var4':5},
   {'id':5, 'var1':'b', 'var2':'right', 'var3':0.4, 'var4':2}]
</code></pre>
<p>Then i can use the following function to sum an individual variable ('var3'), based on two other variables ('var1' and 'var2'):</p>
<pre><code>from operator import itemgetter
from itertools import groupby

def aggregate_var3_by_var1_and_var2(data):
    my_data= []
    grouper = itemgetter("id", "var1", "var2")
    for key, grp in groupby(sorted(data, key = grouper), grouper):
        temp_dict = dict(zip(["id", "var1", "var2"], key))
        temp_dict["var3"] = sum(item["var3"] for item in grp)
        my_data.append(temp_dict)
    return my_data

my_output = aggregate_var3_by_var1_and_var2(x)
</code></pre>
<p>However, I want to sum multiple variables ('var3' and 'var4'), across multiple categories ('var1' and 'var2'), so that the output looks like this:</p>
<pre><code> y=[{'id': 1, 'var1': 'a', 'var2': 'left', 'var3': 0.1, 'var4': 1},
    {'id': 2, 'var1': 'a', 'var2': 'right', 'var3': 0.3, 'var4':4},
    {'id': 4, 'var1': 'b', 'var2': 'left', 'var3': 0.4, 'var4':4},
    {'id': 5, 'var1': 'b', 'var2': 'right', 'var3': 0.5, 'var4':7}]
</code></pre>
<p>How do I sum multiple variables at once using this method?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>collections.defaultdict</code> for an O(n) solution. As opposed to <code>itertools.groupby</code>, this does not require sorting beforehand.</p>
<p>The idea is to group by pre-defined <code>group_keys</code>. Then use a list comprehension to combine keys and values of your <code>defaultdict</code>. The syntax <code>{**d1, **d2}</code> is used to combine two dictionaries.</p>
<pre><code>from collections import defaultdict
from operator import itemgetter

d = defaultdict(lambda: defaultdict(int))

group_keys = ['id', 'var1', 'var2']
sum_keys = ['var3', 'var4']

for item in x:
    for key in sum_keys:
        d[itemgetter(*group_keys)(item)][key] += item[key]

res = [{**dict(zip(group_keys, k)), **v} for k, v in d.items()]

print(res)

[{'id': 1, 'var1': 'a', 'var2': 'left', 'var3': 0.1, 'var4': 1},
 {'id': 2, 'var1': 'a', 'var2': 'right', 'var3': 0.3, 'var4': 4},
 {'id': 4, 'var1': 'b', 'var2': 'left', 'var3': 0.4, 'var4': 4},
 {'id': 5, 'var1': 'b', 'var2': 'right', 'var3': 0.5, 'var4': 7}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A straightforward extension of your approach, provide the grouper keys and value keys as arguments:</p>
<pre><code>from operator import itemgetter
from itertools import groupby
from itertools import chain

def reducer(ts):
    return map(sum, zip(*ts))

def agg(data, keys, aggfields):
    my_data = []
    getter = itemgetter(*aggfields)
    grouper = itemgetter(*keys)
    for ks, grp in groupby(sorted(data, key=grouper), grouper):
        vs = map(getter, grp)
        kvs = chain(zip(keys,ks), zip(aggfields, reducer(vs)))
        my_data.append(dict(kvs))
    return my_data
</code></pre>
<p>In the repl:</p>
<pre><code>In [9]: x=[{'id':1, 'var1':'a', 'var2':'left', 'var3':0.1, 'var4':1},
   ...:    {'id':2, 'var1':'a', 'var2':'right', 'var3':0.1, 'var4':1},
   ...:    {'id':2, 'var1':'a', 'var2':'right', 'var3':0.2, 'var4':3},
   ...:    {'id':4, 'var1':'b', 'var2':'left', 'var3':0.4, 'var4':4},
   ...:    {'id':5, 'var1':'b', 'var2':'right', 'var3':0.1, 'var4':5},
   ...:    {'id':5, 'var1':'b', 'var2':'right', 'var3':0.4, 'var4':2}]

In [10]: agg(x, ['var1','var2'], ['var3','var4'])
Out[10]:
[{'var1': 'a', 'var2': 'left', 'var3': 0.1, 'var4': 1},
 {'var1': 'a', 'var2': 'right', 'var3': 0.30000000000000004, 'var4': 4},
 {'var1': 'b', 'var2': 'left', 'var3': 0.4, 'var4': 4},
 {'var1': 'b', 'var2': 'right', 'var3': 0.5, 'var4': 7}]
</code></pre>
<p>Here is an alternative approach that groups using a dictionary (a default dict of Counter dicts...)</p>
<pre><code>from collections import Counter, defaultdict
from itertools import chain
from operator import itemgetter

def agg(data, keys, aggfields):

    grouper = defaultdict(Counter)
    pluck_keys = itemgetter(*keys)
    pluck_vals = itemgetter(*aggfields)

    for d in data:
        ctr = grouper[pluck_keys(d)]
        for k, v in zip(aggfields, pluck_vals(d)):
            ctr[k] += v

    return [
        {k:v for k,v in chain(zip(keys, ks), ctr.items())}
        for ks, ctr in grouper.items()
    ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use Pandas for an efficient, vectorised solution.</p>
<p>The disadvantages of <code>itertools.groupby</code> here are it requires sorting [additional complexity] and does not implement vectorised calculations [inefficient summing].</p>
<p>If you want to go down the loopy route, I recommend <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> to make sure you still have O(n) complexity.</p>
<pre><code>import pandas as pd

df = pd.DataFrame(x)

res = df.groupby(['id', 'var1', 'var2']).agg({'var3': 'sum', 'var4': 'sum'}).reset_index()

print(res.to_dict('records'))

[{'id': 1, 'var1': 'a', 'var2': 'left', 'var3': 0.1, 'var4': 1},
 {'id': 2, 'var1': 'a', 'var2': 'right', 'var3': 0.3, 'var4': 4},
 {'id': 4, 'var1': 'b', 'var2': 'left', 'var3': 0.4, 'var4': 4},
 {'id': 5, 'var1': 'b', 'var2': 'right', 'var3': 0.5, 'var4': 7}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import groupby
x=[{'id':1, 'var1':'a', 'var2':'left', 'var3':0.1, 'var4':1},
   {'id':2, 'var1':'a', 'var2':'right', 'var3':0.1, 'var4':1},
   {'id':2, 'var1':'a', 'var2':'right', 'var3':0.2, 'var4':3},
   {'id':4, 'var1':'b', 'var2':'left', 'var3':0.4, 'var4':4},
   {'id':5, 'var1':'b', 'var2':'right', 'var3':0.1, 'var4':5},
   {'id':5, 'var1':'b', 'var2':'right', 'var3':0.4, 'var4':2}]

res = []

for key, value in groupby(x, lambda x: x["id"]):
    d = None
    for i in value:
        if not d:
            d = i
        else:
            d["var3"] += i["var3"]
            d["var4"] += i["var4"]
    res.append(d)
print(res)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>[{'id': 1, 'var1': 'a', 'var2': 'left', 'var3': 0.1, 'var4': 1},
 {'id': 2,
  'var1': 'a',
  'var2': 'right',
  'var3': 0.30000000000000004,
  'var4': 4},
 {'id': 4, 'var1': 'b', 'var2': 'left', 'var3': 0.4, 'var4': 4},
 {'id': 5, 'var1': 'b', 'var2': 'right', 'var3': 0.5, 'var4': 7}]
</code></pre>
</div>
<span class="comment-copy">Thanks, I used this because I found it easier to identify which keys were being used for grouping and summing.</span>
