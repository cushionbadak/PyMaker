<div class="post-text" itemprop="text">
<p>I need to make <a href="http://docs.python-requests.org/en/v0.10.6/user/advanced/#asynchronous-requests" rel="nofollow noreferrer">asynchronous requests</a> using the Requests library. In Python 3.7 if I try <code>from requests import async</code> I get <code>SyntaxError: invalid syntax</code>.</p>
<p><code>async</code> has become a <a href="https://docs.python.org/3/whatsnew/3.7.html" rel="nofollow noreferrer">reserved with in Python 3.7</a>. How to I get around this situation?</p>
</div>
<div class="post-text" itemprop="text">
<p>Lukasa who is with the requests lib said:</p>
<blockquote>
<p>At the current time there are no plans to support async and await. This is not because they aren't a good idea: they are. It's because to use them requires quite substantial code changes.
  Right now requests is a purely synchronous library that, at the bottom of its stack, uses <code>httplib</code> to send and receive data. We cannot move to an async model unless we replace httplib. The best we could do is provide a shorthand to run a request in a thread, but asyncio already has just such a shorthand, so I don't believe it would be valuable.
  Right now I am quietly looking at whether we can rewrite requests to work just as well in a synchronous environment as in an async one. However, the reality is that doing so will be a lot of work, involving rewriting a lot of our stack, and may not happen for many years, if ever.</p>
</blockquote>
<p>But don't worry <code>aiohttp</code> is very similar to requests.</p>
<p>Here's an example.</p>
<pre><code>import aiohttp
import asyncio

async def fetch(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    async with aiohttp.ClientSession() as session:
        html = await fetch(session, 'http://python.org')
        print(html)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use asyncio to make asynchronous requests. Here is an example:</p>
<pre><code>import asyncio
import requests

async def main():
    loop = asyncio.get_event_loop()
    futures = [
        loop.run_in_executor(
            None, 
            requests.get, 
            'http://example.org/'
        )
        for i in range(20)
    ]
    for response in await asyncio.gather(*futures):
        pass

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</code></pre>
</div>
<span class="comment-copy">There are several ways to import. <code>importlib.import_module(".async", "requests")</code>. But actually I also get <code>ModuleNotFoundError: No module named 'requests.async'</code>.</span>
<span class="comment-copy">The problem also happens with Python 3.6. Apparently <code>requests</code> let go of the <code>async</code> module altogether a long time ago but the docs are not very clear about that.</span>
<span class="comment-copy">Yep, I think so. You can try <code>aiohttp</code> or <code>grequests</code>.</span>
<span class="comment-copy">upvoted! more examples can be found in the following link: <a href="https://stackoverflow.com/questions/22190403/how-could-i-use-requests-in-asyncio" title="how could i use requests in asyncio">stackoverflow.com/questions/22190403/â€¦</a></span>
<span class="comment-copy">This is running sync method in thread pool. Definitely cannot take the advantages of async IO.</span>
<span class="comment-copy">So is this async in nature or blocking?</span>
<span class="comment-copy">it's an async function</span>
