<div class="post-text" itemprop="text">
<p>Here is the code:</p>
<pre><code>import random
import sys
name = input("What is your name:  ")
tri = 0

def rep():
    score = random.randint(1,10)
    total = 0

    print ("score is",score,)
    total = +score

    file = open("1.txt","a")
    file.write(str(name + " = "))
    file.write(str(total))
    file.write("\n")
    file.close()
    tri = +1
rep()

while tri &gt; 2:
    sys.exit
else:
    print(rep())
</code></pre>
<p>So what this code does, is generates a random score for the user 2 times and then that score is saved into a .txt file under the users name which is inputted as 'name'. What I want to do is, if the same person did the game again and another 2 scores where generated it would overwrite the previous 2 results with the new two.</p>
<p>Here is what the text file would look like:</p>
<pre><code>Tom = 2
Tom = 7
Chrissy = 3
Chirssy = 10
John = 4
John = 9
</code></pre>
<p>If the the user 'Tom' did the game again this time getting 5 and 3, the text file should look like the following:</p>
<pre><code>Chrissy = 3
Chirssy = 10
John = 4
John = 9
Tom = 5
Tom = 3
</code></pre>
<p>In this current situation it just keeps adding on the scores like this:</p>
<pre><code>Tom = 2
Tom = 7
Chrissy = 3
Chirssy = 10
John = 4
John = 9
Tom = 5
Tom = 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A first comment, it's a really good idea to use the context managers for file operations, this will ensure that file resources are properly handled. For this reason I use it in the code here, I suggest you do the same.</p>
<p>If you are going to approach this in such a way that you want to use plain text files you have to remove the lines that contained the name then update. A function such as the following is likely going to help here:</p>
<pre><code>def remove_old_names(name, filename):
    """Remove a line containing a specific name"""
    with open(filename, 'r') as old_file:
        lines = old_file.readlines()

    with open(filename, 'w') as new_file:
        for line in lines:
            if name not in line:
                new_file.write(line)
</code></pre>
<p>Then later when you can clear out the old names then <em>append</em> to the text file:</p>
<pre><code>remove_old_names(name, filename)
with open("1.txt","a") as results:
    results.write(str(name + " = "))
    results.write(str(total))
    results.write("\n")
</code></pre>
<p>Note the use of <code>"a"</code> here to open the file in append mode. If you open with <code>"w"</code> you can end up truncating the file.</p>
<p>Now if I was to approach this in a more structured way I would create a dictionary that stores the data:</p>
<pre><code>results = dict()
results["bob"] = 2
</code></pre>
<p>And so forth for the other user names. I would then serialize this dictionary to a file using <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow"><code>pickle</code></a> or the <a href="https://docs.python.org/3/library/json.html#module-json" rel="nofollow">JSON</a> library.</p>
<p>For example with JSON library you get something like this:</p>
<pre><code>import json
test = {
    "bob": 1,
    "joe": 2,
    "jane": 3,
    }
print(json.dumps(test, sort_keys=True, indent=4))
</code></pre>
<p>output:</p>
<pre><code>{
    "bob": 1,
    "jane": 3,
    "joe": 2
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is an easy file format to just do by hand. The one issue is that text files aren't really stored as lines so you can't just modify just one line. Once you've changed a line, everything after that must be rewritten to the file. If the file isn't too big, you just read everything into a list and work off of that.</p>
<pre><code>import random

def rep(name, score1, score2):
    try:
        # read entire file into list
        with open('1.txt') as fp:
            lines = fp.readlines()
    except FileNotFoundError:
        lines = []

    name_lower = name.lower()
    for index, line in enumerate(lines):
        if line.split('=')[0].strip().lower() == name_lower:
            # found our match... next line had better be the same player
            if lines[index+1].split('=')[0].strip().lower() != name_lower:
                raise RuntimeError("File corrupted")
            # replace user in the list
            lines[index] = "{} = {}\n".format(name, score1)
            lines[index + 1] = "{} = {}\n".format(name, score2)
            # no need to process further
            break
    else:
        # add new user
        lines.append("{} = {}\n".format(name, score1))
        lines.append("{} = {}\n".format(name, score2))

    with open('1.txt', 'w') as fp:
        fp.writelines(lines)

name = input("what is your name: ")
rep(name, random.choice(range(100)), random.choice(range(100)))
print(open('1.txt').read()) # debug
</code></pre>
</div>
<span class="comment-copy">Will the file ever be read outside of the program or is it strictly for storing the program's data?</span>
<span class="comment-copy">It will be read outside the program yes.</span>
<span class="comment-copy">Did you consider using xml or json instead of plain text?</span>
<span class="comment-copy">I don't have much experience with python.</span>
<span class="comment-copy">The current situation shouldn't happen. (Which is not to say that it solves your problem, but after each update <i>only</i> the most recent writes should be present.) After Tom's second play, <i>only</i> his scores would be present; his first score would be gone, along with Chrissy's and John's.</span>
<span class="comment-copy">It seems like he only wants to overwrite a portion of the file, not the whole thing.</span>
<span class="comment-copy">The text file does house the results of other users, not only on players results.</span>
<span class="comment-copy">@KryptoModz are you open to using <code>pickle</code>, <code>json</code> or other simlar? These are more capable data serialization options.</span>
<span class="comment-copy">I'm fairly new to programming in python.</span>
<span class="comment-copy">I'm just making a solution with the text files but I'll show you how you can do this with pickle if you are interested.</span>
<span class="comment-copy">That is perfect! However how do I stop it from outputting other users scores in python?</span>
<span class="comment-copy">I'm not sure what you mean... you want to keep all scores but only display one user? You can do the same kind of thing, just print the matching lines instead of updating them.</span>
<span class="comment-copy">Is there a way, I can ask for you help privately?</span>
