<div class="post-text" itemprop="text">
<p>I am working on a problem out of CTCI.</p>
<p>The third problem of chapter 1 has you take a string such as </p>
<p><code>'Mr John Smith    '</code></p>
<p>and asks you to replace the intermediary spaces with <code>%20</code>:</p>
<p><code>'Mr%20John%20Smith'</code></p>
<p>The author offers this solution in Python, calling it O(n):</p>
<pre><code>def urlify(string, length):
    '''function replaces single spaces with %20 and removes trailing spaces'''
    counter = 0
    output = ''
    for char in string:
        counter += 1
        if counter &gt; length:
            return output
        elif char == ' ':
            output = output + '%20'
        elif char != ' ':
            output = output + char
    return output
</code></pre>
<p>My question:</p>
<p>I understand that this is O(n) in terms of scanning through the actual string from left to right. But aren't strings in Python immutable? If I have a string and I add another string to it with the <code>+</code> operator, doesn't it allocate the necessary space, copy over the original, and then copy over the appending string?</p>
<p>If I have a collection of <code>n</code> strings each of length 1, then that takes:</p>
<p><code>1 + 2 + 3 + 4 + 5 + ... + n = n(n+1)/2</code></p>
<p>or O(n^2) time, yes? Or am I mistaken in how Python handles appending?</p>
<p>Alternatively, if you'd be willing to teach me how to fish: How would I go about finding this out for myself? I've been unsuccessful in my attempts to Google an official source. I found <a href="https://wiki.python.org/moin/TimeComplexity">https://wiki.python.org/moin/TimeComplexity</a> but this doesn't have anything on strings.</p>
</div>
<div class="post-text" itemprop="text">
<p>In CPython, the standard implementation of Python, there's an implementation detail that makes this usually O(n), implemented in <a href="https://hg.python.org/cpython/file/2.7/Python/ceval.c#l5109" rel="noreferrer">the code the bytecode evaluation loop calls for <code>+</code> or <code>+=</code> with two string operands</a>. If Python detects that the left argument has no other references, it calls <code>realloc</code> to attempt to avoid a copy by resizing the string in place. This is not something you should ever rely on, because it's an implementation detail and because if <code>realloc</code> ends up needing to move the string frequently, performance degrades to O(n^2) anyway.</p>
<p>Without the weird implementation detail, the algorithm is O(n^2) due to the quadratic amount of copying involved. Code like this would only make sense in a language with mutable strings, like C++, and even in C++ you'd want to use <code>+=</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The author relies on an optimization that happens to be here, but is not explicitly dependable. <code>strA = strB + strC</code> is typically <code>O(n)</code>, making the function <code>O(n^2)</code>. However, it is pretty easy to make sure it the whole process is <code>O(n)</code>, use an array:</p>
<pre><code>output = []
    # ... loop thing
    output.append('%20')
    # ...
    output.append(char)
# ...
return ''.join(output)
</code></pre>
<p>In a nutshell, the <code>append</code> operation is <em>amortized</em> <code>O(1)</code>, (although you can make it strong <code>O(1)</code> by pre-allocating the array to the right size), making the loop <code>O(n)</code>.</p>
<p>And then the <code>join</code> is also <code>O(n)</code>, but that's okay because it is outside the loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>I found this snippet of text on <a href="https://wiki.python.org/moin/PythonSpeed">Python Speed &gt; Use the best algorithms and fastest tools</a>:</p>
<blockquote>
<p>String concatenation is best done with <code>''.join(seq)</code> which is an <code>O(n)</code> process. In contrast, using the <code>'+'</code> or <code>'+='</code> operators can result in an <code>O(n^2)</code> process because new strings may be built for each intermediate step. The CPython 2.4 interpreter mitigates this issue somewhat; however, <code>''.join(seq)</code> remains the best practice</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><strong>For future visitors:</strong> Since it is a CTCI question, any reference to learning <a href="https://docs.python.org/3/library/urllib.html" rel="nofollow noreferrer">urllib</a> package is not required here, specifically as per OP and the book, this question is about Arrays and Strings. </p>
<p>Here's a more complete solution, inspired from @njzk2's pseudo: </p>
<pre><code>text = 'Mr John Smith'#13 
special_str = '%20'
def URLify(text, text_len, special_str):
    url = [] 
    for i in range(text_len): # O(n)
        if text[i] == ' ': # n-s
            url.append(special_str) # append() is O(1)
        else:
            url.append(text[i]) # O(1)

    print(url)
    return ''.join(url) #O(n)


print(URLify(text, 13, '%20'))
</code></pre>
</div>
<span class="comment-copy">Someone should tell the author about <code>urllib.urlencode</code></span>
<span class="comment-copy">@wim It's meant to be a practice problem about arrays and strings</span>
<span class="comment-copy">The purpose of the book is to teach interview questions, which commonly ask you to re-invent the wheel to see the interviewee's thought process.</span>
<span class="comment-copy">Since it is Python, I think doing an <code>rtrim</code> and <code>replace</code> would be more preferred and in the ballpark of <code>O(n)</code>. Copying over strings does seem the least efficient way.</span>
<span class="comment-copy">@RNar Can you explain how a copy can take constant time?</span>
<span class="comment-copy">I am looking at the code you linked... it looks like a big part of that code is cleaning up / removing pointers/references to the string being appended, correct? And then towards the end it performs <code>_PyString_Resize(&amp;v, new_len)</code> to allocate the memory for the concatenated string, and then <code>memcpy(PyString_AS_STRING(v) + v_len, PyString_AS_STRING(w), w_len);</code> which does the copy. If in-place resizing fails, it does <code>PyString_Concat(&amp;v, w);</code> (I assume this means when the contiguous memory at the end of the original string address isn't free). How does this show the speedup?</span>
<span class="comment-copy">I ran out of space in my previous comment, but my question there is whether or not I am understanding that code correctly and how to interpret the memory usage/runtimes of those pieces.</span>
<span class="comment-copy">@user5622964: Whoops, misremembered the weird implementation detail. There's no efficient resize policy; it just calls <code>realloc</code> and hopes for the best.</span>
<span class="comment-copy">How does <code>memcpy(PyString_AS_STRING(v) + v_len, PyString_AS_STRING(w), w_len);</code> work? According to <a href="http://www.cplusplus.com/reference/cstring/memcpy/" rel="nofollow noreferrer">cplusplus.com/reference/cstring/memcpy</a> it has definition <code>void * memcpy ( void * destination, const void * source, size_t num );</code> and description: <code>"Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination."</code> The num in this case is the size of the appending string, and source is the address of the second string, I assume? But then why is the destination (first string) + len(first string)? Double memory?</span>
<span class="comment-copy">@user5622964: That's pointer arithmetic. If you want to understand the CPython source code down to the weird implementation details, you'll need to know C. The super-condensed version is that <code>PyString_AS_STRING(v)</code> is the address of the first string's data, and adding <code>v_len</code> gets you the address right after the string's data ends.</span>
<span class="comment-copy">This answer is good because it tells how to concatenate strings.</span>
