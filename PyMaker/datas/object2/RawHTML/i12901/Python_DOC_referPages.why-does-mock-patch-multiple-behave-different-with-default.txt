<div class="post-text" itemprop="text">
<p>If <code>patch.multiple</code> is used as a method/function decorator it's behaviour is different if the patched object is <code>mock.DEFAULT</code> or not.</p>
<p>Example:</p>
<pre class="lang-py prettyprint-override"><code>from unittest import mock

class A: pass

@mock.patch.multiple('__main__', A=mock.DEFAULT)
def with_default(*args,**kwargs):
    if 'A' not in kwargs:
        print("with_default: A not passed")

@mock.patch.multiple('__main__', A=mock.Mock())
def with_other(*args, **kwargs):
    if 'A' not in kwargs:
        print("with_other: A not passed")

with_default() # nothing
with_other() # -&gt; "with_other: A not passed"
</code></pre>
<p>Is there a reason for this behaviour that I'm not seeing? I can't see a reason why it doesn't pass the new mock into the function in all cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.multiple" rel="nofollow">docs</a> say (emphasis is mine):</p>
<blockquote>
<p>Use <code>DEFAULT</code> as the value if you want <code>patch.multiple()</code> to create mocks
  for you. <strong>In this case the created mocks are passed into a decorated
  function by keyword, and a dictionary is returned when
  patch.multiple() is used as a context manager</strong>.</p>
</blockquote>
<p>So, when you don't use <code>DEFAULT</code> keyword what you use tho set your patched method <strong>isn't</strong> passed to the decorated function.</p>
<p>Your <code>with_other</code>'s decorator case can be rewrited as:</p>
<pre><code>@mock.patch('__main__.A', new=mock.Mock())
def with_other():
    ... bla bla
</code></pre>
<p>Even when you use <code>new</code> attribute the argument isn't passed to decorated function because it supposed that you already know it and you don't need to get it as argument.</p>
<p>General speaking: <code>patch.multiple</code> can be replaced by a stack of simple <code>patch</code> where the path is extend by argument name and use <code>new</code> to set the value:</p>
<pre><code>@patch.mutilple('foo', bar='bar', baz='baz')
</code></pre>
<p>Become</p>
<pre><code>@patch('foo.baz', new='baz')
@patch('foo.bar', new='bar')
</code></pre>
<p>Or more simple by <code>new</code> positional argument:</p>
<pre><code>@patch('foo.baz', 'baz')
@patch('foo.bar', 'bar')
</code></pre>
</div>
<span class="comment-copy">Thank you for your reply. I think I'm still misunderstanding something; what I'm trying to clarify is why the mocked object needs to be passed as an argument at all. Why not patch "globally" all the time? I find it strange that I have to change the signature of the method depending on what I pass as parameters to the decorator.</span>
<span class="comment-copy">Simply because if you patch something often you are interested on have access to the sense point too. If the sense point was created by patch decorator the decorator will give it to you by the decorated function signature. If it bother you you can ignore them by <code>*args,**kwargs</code> but I think you'll find them very useful because you don't need to repeat yourself to get the mocks from the patched instances..</span>
<span class="comment-copy">@Richard I read again your question and I'm little bit puzzled. In your question you ask <i>I can't see a reason why it doesn't pass the new mock into the function in all cases</i>. I'd explain it and now your're asking why pass the mock in the other case? I missed something? I would prefer to have the mocks in both cases but I understand the value of simplify the signature when is possible.</span>
