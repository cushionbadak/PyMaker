<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/logging.html#logging.LogRecord.getMessage" rel="nofollow"><code>logging.LogRecord.getMessage()</code></a> simplifies the manipulation of logging records by providing a factory. I use a module of mine, imported in each piece of code, to homogenize the logging:</p>
<pre><code># this is mylogging.py
import logging
import logging.handlers

def mylogging(name):
    old_factory = logging.getLogRecordFactory()
    def record_factory(*args, **kwargs):
        record = old_factory(*args, **kwargs)
        # send an SMS for critical events (level = 50)
        if args[1] == 50:
            pass  # here is the code which sends an SMS
        return record
    logging.setLogRecordFactory(record_factory)

    # common logging info
    log = logging.getLogger(name)
    log.setLevel(logging.DEBUG)
    (...)
</code></pre>
<p>All my scripts bootstrap logging via a </p>
<pre><code>log = mylogging.mylogging("name_of_the_project")
</code></pre>
<p>This works fine.</p>
<p>I now would like to keep track of the number of SMS sent. For this I would like to set a counter within <code>mylogging.py</code>, common to all scripts which <code>import mylogging</code>. The problem is that such a variable will be local to each script.</p>
<p>On the other hand, <code>logging</code> is peculiar in the sense that when different scripts call <code>logging.getLogger(name)</code> with the same <code>name</code>, the handler is reused - which means that there is some persistence between scripts (even though each of them does an independent <code>import logging</code>). </p>
<p>With this in mind, is there a way to use a variable which would be common to all logging, placed right after the <code>here is the code which sends an SMS</code> line, and which would be incremented no matter what script the logging request comes from?</p>
</div>
<div class="post-text" itemprop="text">
<p>An import such as </p>
<pre><code>from mylogging import mycounter
mycounter += 1
</code></pre>
<p>adds a new reference to <code>mycounter</code> in the local module namespace. For an immutable type such as an integer counter, the addition rebinds the value in the local namespace only - other modules see the value at the point where they imported.</p>
<p>One solution is to keep the original namespace so that the rebinding happens in <code>mylogger</code> itself.</p>
<pre><code>import mylogger
mylogger.mycounter += 1
</code></pre>
<p>This is fragile. Its not very obvious that it only works because of the way the import was done.</p>
<p>A better solution is to use a mutable type. <code>itertools.count</code> is interesting but doesn't let you view the current value of the counter. Here's a simple class that will do it. I've adding locking so that it works in a multithreaded environment also.</p>
<p>Add to mylogger.py</p>
<pre><code>import threading

class MyCounter(object):

    def __init__(self):
        self.val = 0
        self.lock = threading.Lock()

    def inc(self):
        with self.lock:
            self.val += 1
        return self.val

sms_counter = MyCounter()
</code></pre>
<p>Some other module</p>
<pre><code>from mylogger import sms_counter
print('sms count is {}'.format(sms_counter.inc()))
</code></pre>
</div>
<span class="comment-copy">Your use of the term "script" is unclear. Are you executing the Python interpreter multiple times and trying to get the value to persist across runs? Or are you talking about multiple modules used in a single Python program? In a single Python interpreter run, there will only be one <code>mylogging.counter</code>, regardless of how many modules import <code>mylogging</code>.</span>
<span class="comment-copy">Thank you. Your answer not only directly solved my problem but also helped me to understand that I was starting processes and not threads - which impacts on how the variables are scoped.</span>
