<div class="post-text" itemprop="text">
<p>I found similar code somewhere:</p>
<pre><code>USER_CONTROLLED = 'a'
open("settings.py", "w").write("USER_CONTROLLED = %s" % eval(repr(a)))
</code></pre>
<p>And in another file:</p>
<pre><code>import settings
x = settings.USER_CONTROLLED * [0]
</code></pre>
<p>Is this a security vulnerability?</p>
</div>
<div class="post-text" itemprop="text">
<p>In contrast to what you were told on IRC, there definitely is an <code>x</code> that makes <code>eval(repr(x))</code> dangerous, so saying it just like that without any restrictions is wrong too.</p>
<p>Imagine a custom object that implements <code>__repr__</code> differently. The documentation says on <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow"><code>__repr__</code></a> that it <em>“should look like a valid Python expression that could be used to recreate an object with the same value”</em>. But there is simply nothing that can possibly enforce this guideline.</p>
<p>So instead, we could create a class that has a custom <code>__repr__</code> that returns a string which when evaluated runs arbitrary code. For example:</p>
<pre><code>class MyObj:
    def __repr__ (self):
        return "__import__('urllib.request').request.urlopen('http://example.com').read()"
</code></pre>
<p>Calling <code>repr()</code> on an object of that type shows that it returns a string that can surely be evaluated:</p>
<pre><code>&gt;&gt;&gt; repr(MyObj())
"__import__('urllib.request').request.urlopen('http://example.com').read()"
</code></pre>
<p>Here, that would just involve making a request to example.com. But as you can see, we can import arbitrary modules here and run code with them. And that code can have any kind of side effects. So it’s definitely dangerous.</p>
<p>If we however limit that <code>x</code> to known types of which we know what calling <code>repr()</code> on them will do, then we can indeed say when it’s impossible to run arbitrary code with it. For example, if that <code>x</code> is a string, then the implementation of <a href="https://hg.python.org/cpython/file/3.5/Objects/unicodeobject.c#l12309" rel="nofollow"><code>unicode_repr</code></a>  makes sure that everything is properly escaped and that evaluating the <code>repr()</code> of that object will always return a proper string (which even equals <code>x</code>) without any side effects.</p>
<p>So we should check for the type before evaluating it:</p>
<pre><code>if type(a) is not str:
    raise Exception('Only strings are allowed!')

something = eval(repr(a))
</code></pre>
<p>Note that we do not use <code>isinstance</code> here to do an inheritance-aware type check. Because I could absolutely make <code>MyObj</code> above inherit from <code>str</code>:</p>
<pre><code>&gt;&gt;&gt; x = MyObj()
&gt;&gt;&gt; isinstance(x, str)
True
&gt;&gt;&gt; type(x)
&lt;class '__main__.MyObj'&gt;
</code></pre>
<p>So you should really test against concrete types here.</p>
<p>Note that for strings, there is actually no reason to call <code>eval(repr(x))</code> because as mentioned above, this will result in <code>x</code> itself. So you could just assign <code>x</code> directly.</p>
<p>Coming to your actual use case however, you do have a very big security problem here. You want to create a variable assignment and store that code in a Python file to be later run by an actual Python interpreter. So you should absolutely make sure that the right side of the assignment is not arbitrary code but actually the repr of a string:</p>
<pre><code>&gt;&gt;&gt; a = 'runMaliciousCode()'
&gt;&gt;&gt; "USER_CONTROLLED = %s" % eval(repr(a))
'USER_CONTROLLED = runMaliciousCode()'
&gt;&gt;&gt; "USER_CONTROLLED = %s" % repr(a)
"USER_CONTROLLED = 'runMaliciousCode()'"
</code></pre>
<p>As you can see, evaluating the <code>repr()</code> will put the actual content on the right side of the assignment (since it’s equivalent to <code>"…" % a</code>). But that can then lead to malicious code running when you import that file. So you should really just insert the repr of the string there, and completely forget about using <code>eval</code> altogether.</p>
</div>
<span class="comment-copy">Got an answer over IRC: <code>19:33:10      nedbat $ d33tah: there is no x that makes eval(repr(x)) dangerous, but in 3.6 it will be.</code></span>
<span class="comment-copy">Oh crap! I meant <code>eval(repr(a))</code>! Thanks for your answer, but I guess I'll need to ask another question now.</span>
<span class="comment-copy">Then it depends on where the value of <code>a</code> comes from. I could create a custom object which repr only returns that string. If <code>a</code> is a string, then you should be fine since <code>eval(repr(s))</code> should be equal to <code>s</code> for all strings.</span>
<span class="comment-copy">Actually the title and a comment was right, but the code inside wasn't. I decided to edit the question.</span>
<span class="comment-copy">@d33tah Updated my answer.</span>
