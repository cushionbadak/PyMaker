<div class="post-text" itemprop="text">
<p>I'm working on a project with the raspberry pi where I need to have two functions running in parallel both of which need to access the same GPIO pins (they need to turn on/off the same pumps). </p>
<p>The issue is that function1 needs to access these pumps every 40 minutes and use them for 5 mins at a time and function2 needs to access them every 3 hours for 5 mins at time. The way I am keeping the pumps active is by turning on the GPIO pin, using time.sleep(), then turn it off. After the functions use the pumps they will need to dispense chemicals in water and wait for these chemicals to dissolve (function1 waits 30 minutes, function2 waits 3 hours). </p>
<p>I am looking for the best way to run these functions in parallel while taking into account the possible scheduling/timing conflicts between them. I want function1 to be able to utilize the pumps even while function2 is waiting for its chemicals to dissolve. I am thinking to use a global variable to check whether the pump is in use to let the functions know that they need to wait to access those pumps but after some testing I am not sure this works with multiprocessing. </p>
<p>I've set up some test code to simulate the timing of the functions. According to my output, it seems both function1 and function2 are proceeding to dispense their chemicals at the same time. Any ideas or advice is greatly appreciated.</p>
<pre><code>import time
from multiprocessing import Process

pumpInUse = False #used to store the state of the pumps

def function1():
    global pumpInUse
    if pumpInUse is False:
        print "starting function1 test @ " + str((time.strftime("%H:%M:%S")))
        pumpInUse = True #turn pump on
        time.sleep(5)  #simulating 5 minutes of pump use
        print "function1 test complete @ " + str((time.strftime("%H:%M:%S")))
        pumpInUse = False #turn pump off
        function1status = 'bad' #simulating bad chemical level

        if function1status == 'bad':
            print "dispense chemicals @ " + str((time.strftime("%H:%M:%S")))
            time.sleep(10) #simulate wait 30 minutes after chemcials dispensed
            print "checking water @ " + str((time.strftime("%H:%M:%S")))
            pumpInUse = True
            time.sleep(5) #simulating 5 minutes of pump use
            print "function1 complete @ " + str((time.strftime("%H:%M:%S")))
            pumpInUse = False

def function2():
    global pumpInUse
    if pumpInUse is False:
        print "starting function2 test @ " + str((time.strftime("%H:%M:%S")))
        pumpInUse = True
        time.sleep(5) #simulating 5 minutes of pump use
        print "function2 test complete @ " + str((time.strftime("%H:%M:%S")))
        pumpInUse = False
        function2status = 'bad' #simulating bad chemical level

        if function2status == 'bad':
            print "dispense chemicals @ " + str((time.strftime("%H:%M:%S")))
            time.sleep(30) #simulate wait 3 hours after chemicasl dispensed
            print "checking water @ " + str((time.strftime("%H:%M:%S")))
            pumpInUse = True
            time.sleep(5) #simulating 5 minutes of pump use
            print "function2  complete @ " + str((time.strftime("%H:%M:%S")))
            pumpInUse = False

if __name__ == '__main__':
    #while True:
        p1 = Process(target=function1)
        p2 = Process(target=function2)
        p1.start()
        p2.start()
        p1.join()
        p2.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're looking thread (or process) <a href="https://docs.python.org/2/library/multiprocessing.html#synchronization-primitives" rel="nofollow">synchronization primitives</a>, in this case, probably a <code>Lock</code>. <code>function1</code> would acquire a blocking lock and release it when it was done. When <code>function2</code> attempted to acquire the lock, it would automatically wait until the lock was released.</p>
</div>
<span class="comment-copy">Using variables like this to communicate between threads is potentially very risky. You should look into using proper thread-safe ways of communicating between threads: <a href="https://docs.python.org/3/library/asyncio-sync.html" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-sync.html</a>. In your case, a 'lock' is likely to be useful.</span>
<span class="comment-copy">Yes! Using locks was exactly what I needed. Thanks a lot!</span>
