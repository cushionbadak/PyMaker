<div class="post-text" itemprop="text">
<p>I was looking for a way to mock multiple instances of the same class. Tried the solution from <a href="https://stackoverflow.com/questions/18223193/how-to-get-many-instances-of-one-mock-object">How to get many instances of one Mock object</a> and that does work. However, I also want to specify properties and behavior for each new instance of the mocked class in my test case. Didn't find the answer to that yet. </p>
<p>Example:</p>
<pre><code>class A:
    def __init__(self, name):
        self.name = name

    def get_name(self):
        print("hi " + self.name)
        return self.name


class B:
    def __init__(self):
        self.a_map = {}

    def get_all_a_values(self, names):
        for name in names:
            a = A(name)
            self.a_map[a] = a.get_name()


with mock.patch('__main__.A') as mockA:
    b = B()
    mockA.side_effect = mock.Mock
    names = ['person0', 'person1', 'person2', 'person3', 'person4']
    b.get_all_a_values(names)
    print(b.a_map)
    assert len(b.a_map) == 5
</code></pre>
<p>How can I change this code so that when an instance of mockA is created, it also sets the name property of the instance? e.g. I need the output for this code to be something like:</p>
<pre><code>{&lt;Mock id='13609360'&gt;: 'person0', &lt;Mock id='13608720'&gt;: 'person1', &lt;Mock id='13610128'&gt;: 'person2', &lt;Mock id='13609744'&gt;: 'person3', &lt;Mock id='13608976'&gt;: 'person4'}
</code></pre>
<p>Setting mockA.get_name.return_value won't work as it will use the same value for every instance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Note that the name is returned by A's <code>get_name</code>method. As such, you can override that method with a side_effect that returns the name that the method was called with. It seems like what you really want isn't multiple mock instances, but a method within the mock that returns differing values depending on what is passed to it.</p>
<p>The following code works for me:</p>
<pre><code>import mock

class A:
    def __init__(self, name):
        self.name = name

    def get_name(self):
        print("hi " + self.name)
        return self.name


class B:
    def __init__(self):
        self.a_map = {}

    def get_all_a_values(self, names):
        for name in names:
            a = A(name)
            self.a_map[a] = a.get_name()


def side_effect(name):
    mm = mock.MagicMock()
    mm.get_name.return_value = name
    return mm

with mock.patch('__main__.A') as mockA:
    b = B()
    mockA.side_effect = side_effect
    names = ['person0', 'person1', 'person2', 'person3', 'person4']
    b.get_all_a_values(names)
    print(b.a_map)
    assert len(b.a_map) == 5
</code></pre>
<p>When I run this, my output is:</p>
<pre><code>{&lt;MagicMock id='4491688656'&gt;: 'person0', &lt;MagicMock id='4491693264'&gt;: 'person1', &lt;MagicMock id='4491757456'&gt;: 'person4', &lt;MagicMock id='4491722960'&gt;: 'person2', &lt;MagicMock id='4491742224'&gt;: 'person3'}
</code></pre>
<p>I find the mock documentation to be relatively confusing, but the section on <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow">side_effects</a> is worth muddling through, as they're one of the most useful features in mock. </p>
</div>
<span class="comment-copy">Tried your example and it works... and makes sense too.. Thanks</span>
<span class="comment-copy">Agree on the confusing documentation. I've been going through it. And I kept on thinking that the side_effects function examples were for function modules only. Makes me feel like the authors don't want us to use classes and OO if they can be avoided.</span>
<span class="comment-copy">Their examples tend to relate more to showing that it works rather than showing how you can use it, I've found. It's really, really versatile and can do almost anything you want, but figuring out how is often a challenge.</span>
