<div class="post-text" itemprop="text">
<p>I want to pass an instance of TestObj from the C++ code into python. The code posted here produces the error in cout: "No to_python (by-value) converter found for C++ type: class TestObj". If I move the object creation and <code>main_module.attr("obj") = obj;</code> into the BOOST_PYTHON_MODULE macro, the code runs fine.</p>
<p>Similar things happen when I try passing a <code>*TestObj</code> with or without boost::ptr.</p>
<p>testembed.py:</p>
<pre><code>import sfgame

print("old x: " + str(obj.x))
obj.x = 10
print("new x: " + str(obj.x))
</code></pre>
<p>testobj.h</p>
<pre><code>class TestObj{
public:
    TestObj();
    int x;
    int getX();
    void setX(int xv);
};
</code></pre>
<p>testobj.cpp</p>
<pre><code>#include "TestObj.h"
TestObj::TestObj(){
}

int TestObj::getX(){
    return x;
}

void TestObj::setX(int xv){
    x = xv;
}
</code></pre>
<p>main.cpp</p>
<pre><code>#include &lt;boost/python.hpp&gt;
#include "TestObj.h"

using namespace boost::python;

BOOST_PYTHON_MODULE(sfgame){
    class_&lt;TestObj&gt;("TestObj")
        .add_property("x", &amp;TestObj::getX, &amp;TestObj::setX)
        ;
}

int main(){
    Py_Initialize();

    object main_module = import("__main__");
    object main_namespace = main_module.attr("__dict__");

    TestObj obj;

    try{
        obj.setX(5);
        main_module.attr("obj") = obj;

        exec_file("testembed.py", main_namespace);
    }
    catch (const boost::python::error_already_set &amp;){
        PyObject *ptype, *pvalue, *ptraceback;
        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);
        std::string error;
        error = boost::python::extract&lt;std::string&gt;(pvalue);
        std::cout &lt;&lt; error &lt;&lt; std::endl;
    }

    system("PAUSE");
    return 0;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Passing a C++ object to Python via Boost.Python has the same pre-conditions regardless of context in which it is called: a to-Python converter must be registered for the C++ object's type.</p>
<p>When creating an instance of <a href="http://www.boost.org/doc/libs/1_59_0/libs/python/doc/v2/class.html" rel="nofollow noreferrer"><code>boost::python::class_&lt;T&gt;</code></a>, to-Python and from-Python converters are automatically registered for type <code>T</code>.  The <a href="http://www.boost.org/doc/libs/1_59_0/libs/python/doc/v2/module.html" rel="nofollow noreferrer"><code>BOOST_PYTHON_MODULE</code></a> macro only declares a Python module initialization function that Python will invoke when the module gets imported.  In this particular case, the problem can be resolved by performing either of the following before passing a <code>TestObj</code> instance to Python:</p>
<ul>
<li>Expose <code>TestObj</code> via <code>class_</code> after the interpreter has been initialized within <code>main()</code>.</li>
<li>Import the statically linked <code>sfgame</code> module.  This requires explicitly adding the module initialization function tot he Python initialization table via <a href="https://docs.python.org/3/c-api/import.html#c.PyImport_AppendInittab" rel="nofollow noreferrer"><code>PyImport_AppendInittab()</code></a>.  See <a href="https://stackoverflow.com/a/32661611/1053968">this</a> answer for details.</li>
</ul>
<p>Calling the module initialization functions directly is not recommended.  When called directly, the module itself is not created, but the types will be registered with Boost.Python.  Upon importing the module, the module will be created and initialized, causing the types to be registered once more.  In debug builds of Boost.Python, this will fail an assertion, and in release builds it will print a warning.</p>
<hr/>
<p>Here is a complete example <a href="http://coliru.stacked-crooked.com/a/d6298e223fb2f366" rel="nofollow noreferrer">demonstrating</a> passing C++ objects to Python when embedding.  In the example, the <code>spam</code> type if exposed within the statically linked <code>example</code> module, and the <code>egg</code> type is exposed within the <code>__main__</code> scope.</p>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;boost/python.hpp&gt;

// Mockup models.
struct spam {};
struct egg {};

BOOST_PYTHON_MODULE(example)
{
  namespace python = boost::python;
  python::class_&lt;spam&gt;("Spam", python::init&lt;&gt;());
}

int main()
{
  // Explicitly add initializers for staticly linked modules.
  PyImport_AppendInittab("example", &amp;initexample);

  // Initialize Python.
  Py_Initialize();

  namespace python = boost::python;
  try
  {
    // Create the __main__ module.
    python::object main_module = python::import("__main__");
    python::object main_namespace = main_module.attr("__dict__");

    // Import the example module, this will cause the example module's
    // initialization function to be invoked, registering the spam type.
    // &gt;&gt;&gt; import example
    python::import("example");

    // &gt;&gt;&gt; spam = example.Spam()
    spam spam;
    main_namespace["spam"] = spam;

    // Expose egg, defining it within the main module.
    // &gt;&gt;&gt; class Egg: pass
    main_namespace["Egg"] = python::class_&lt;egg&gt;("Egg", python::init&lt;&gt;());
    // &gt;&gt;&gt; egg = Egg()
    egg egg;
    main_namespace["egg"] = egg;

    // Verify variables and their types.
    python::exec(
      "import example\n"
      "assert(isinstance(spam, example.Spam))\n"
      "assert(isinstance(egg, Egg))\n",
      main_namespace);
  }
  catch (const python::error_already_set&amp;)
  {
    PyErr_Print();
    return 1;
  }

  // Do not call Py_Finalize() with Boost.Python.
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the documentation:</p>
<p>"This macro generates two functions in the scope where it is used: extern "C" void initname(), and void init_module_name(), whose body must follow the macro invocation."</p>
<p>You need to call <code>initsfgame();</code>.</p>
</div>
<span class="comment-copy">Fantastic answer, I looked all over for this kind of example.</span>
