<div class="post-text" itemprop="text">
<p>I have some simple code code made with Python 3.4's asyncio using <code>call_later</code>. The code should print, waits 10 seconds, and then print again (but instead raises <code>TypeError</code> when <code>end()</code> should be excecuted, see below):</p>
<pre><code>import asyncio

@asyncio.coroutine
def begin():
    print("Starting to wait.")
    asyncio.get_event_loop().call_later(10, end())

@asyncio.coroutine
def end():
    print("completed")

if __name__ == "__main__":
    try:
        loop = asyncio.get_event_loop()
        loop.create_task(begin())
        loop.run_forever()
    except KeyboardInterrupt:
        print("Goodbye!")
</code></pre>
<p>Gives the error:</p>
<pre><code>Exception in callback &lt;generator object coro at 0x7fc88eeaddc8&gt;()
handle: &lt;TimerHandle when=31677.188005054 &lt;generator object coro at 0x7fc88eeaddc8&gt;()&gt;
Traceback (most recent call last):
  File "/usr/lib64/python3.4/asyncio/events.py", line 119, in _run
    self._callback(*self._args)
TypeError: 'generator' object is not callable
</code></pre>
<p>From what I can tell from the docs (<a href="https://docs.python.org/3/library/asyncio-task.html#coroutine" rel="noreferrer">https://docs.python.org/3/library/asyncio-task.html#coroutine</a>), <code>call_later</code> takes a coroutine object, which is obtained by calling a coroutine function. This appears to be what I've done, but asyncio does not call <code>end()</code> properly.</p>
<p>How is this supposed to be done?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>call_later</code> is designed to take a callback (meaning a regular function object), not a coroutine. Newer versions of Python will actually say this explicitly:</p>
<pre><code>Starting to wait.
Task exception was never retrieved
future: &lt;Task finished coro=&lt;coro() done, defined at /usr/lib/python3.4/asyncio/coroutines.py:139&gt; exception=TypeError('coroutines cannot be used with call_at()',)&gt;
Traceback (most recent call last):
  File "/usr/lib/python3.4/asyncio/tasks.py", line 238, in _step
    result = next(coro)
  File "/usr/lib/python3.4/asyncio/coroutines.py", line 141, in coro
    res = func(*args, **kw)
  File "aio.py", line 6, in begin
    asyncio.get_event_loop().call_later(10, end())
  File "/usr/lib/python3.4/asyncio/base_events.py", line 392, in call_later
    timer = self.call_at(self.time() + delay, callback, *args)
  File "/usr/lib/python3.4/asyncio/base_events.py", line 404, in call_at
    raise TypeError("coroutines cannot be used with call_at()")
TypeError: coroutines cannot be used with call_at()
</code></pre>
<p>To make your code work, <code>end</code> needs to be a regular function, which you then pass to <code>call_later</code>:</p>
<pre><code>import asyncio

@asyncio.coroutine
def begin():
    print("Starting to wait.")
    asyncio.get_event_loop().call_later(10, end)

def end():
    print("completed")

if __name__ == "__main__":
    try:
        loop = asyncio.get_event_loop()
        loop.create_task(begin())
        loop.run_forever()
    except KeyboardInterrupt:
        print("Goodbye!")
</code></pre>
<p>Output:</p>
<pre><code>Starting to wait.
completed
Goodbye!
</code></pre>
<p>If <code>end</code> needs to be a coroutine, a more natural way to call it after a delay would be to use <code>asyncio.sleep</code>:</p>
<pre><code>import asyncio

@asyncio.coroutine
def begin():
    print("Starting to wait.")
    yield from asyncio.sleep(10)
    yield from end()

@asyncio.coroutine
def end():
    print("completed")

if __name__ == "__main__":
    try:
        loop = asyncio.get_event_loop()
        loop.create_task(begin())
        loop.run_forever()
    except KeyboardInterrupt:
        print("Goodbye!")
</code></pre>
<p>Though technically, this does work:</p>
<pre><code>asyncio.get_event_loop().call_later(10, lambda: asyncio.async(end()))
</code></pre>
</div>
<span class="comment-copy">In that case, is there a way to schedule a coroutine to be called later with <code>asyncio</code>? Or is there some reason why this doesn't make sense to do?</span>
<span class="comment-copy">@NathanaelFarley Well, you can use <code>call_later(10, lambda: asyncio.ensure_future(end()))</code>. But it probably makes more sense to just put a <code>yield from asyncio.sleep(10)</code> inside <code>begin</code>, and then call <code>yield from end()</code> right after that. If you don't want to block <code>begin</code>, you could just put the <code>asyncio.sleep</code> and call to <code>end</code> in another coroutine, and just call <code>asyncio.ensure_future(other_coroutine())</code> inside <code>begin</code> instead.</span>
