<div class="post-text" itemprop="text">
<p>When I use Python's argparse or optparse command line argument parser, any unique prefix of an argument is considered valid, e.g.</p>
<pre><code>$ ./buildall.py --help
usage: buildall.py [-h] [-f]

Build all repositories

optional arguments:
  -h, --help   show this help message and exit
  -f, --force  Build dirty repositories
</code></pre>
<p>works with <code>--help</code>, <code>--hel</code>, <code>--he</code> for the help option as well as <code>--forc</code> and <code>--fo</code> for the force option.</p>
<p>Can this behavior  be turned off somehow? I want to get an error message for incomplete arguments.</p>
</div>
<div class="post-text" itemprop="text">
<p>The ability to disable abbreviated long options was only added in Python 3.5. From the <a href="https://docs.python.org/3/library/argparse.html#argument-abbreviations-prefix-matching" rel="noreferrer"><code>argparse</code> documentation</a>:</p>
<blockquote>
<p>The <code>parse_args()</code> method <em>by default</em> allows long options to be abbreviated to a prefix, if the abbreviation is unambiguous (the prefix matches a unique option) ... <strong>This feature can be disabled by setting <em>allow_abbrev</em> to <code>False</code>.</strong></p>
</blockquote>
<p>So if you're on Python 3.5, you can create your parser with <code>allow_abbrev=False</code>:</p>
<pre><code>parser = argparse.ArgumentParser(..., allow_abbrev=False)
</code></pre>
<p>If you're on optparse or pre-3.5 argparse, you just have to live with abbreviated options.</p>
</div>
<div class="post-text" itemprop="text">
<p>Prior to Python 3.5, you would have to monkeypatch an undocumented <code>ArgumentParser</code> method. Don't actually use this; it is untested and may not work with all versions (or any version) of Python. For entertainment purposes only.</p>
<pre><code>import argparse

# This is a copy from argparse.py, with a single change
def _get_option_tuples(self, option_string):
    result = []

    # option strings starting with two prefix characters are only
    # split at the '='
    chars = self.prefix_chars
    if option_string[0] in chars and option_string[1] in chars:
        if '=' in option_string:
            option_prefix, explicit_arg = option_string.split('=', 1)
        else:
            option_prefix = option_string
            explicit_arg = None
        for option_string in self._option_string_actions:
            # === This is the change ===
            # if option_string.startswith(option_prefix):
            if option_string == option_prefix:
                action = self._option_string_actions[option_string]
                tup = action, option_string, explicit_arg
                result.append(tup)

    # single character options can be concatenated with their arguments
    # but multiple character options always have to have their argument
    # separate
    elif option_string[0] in chars and option_string[1] not in chars:
        option_prefix = option_string
        explicit_arg = None
        short_option_prefix = option_string[:2]
        short_explicit_arg = option_string[2:]

        for option_string in self._option_string_actions:
            if option_string == short_option_prefix:
                action = self._option_string_actions[option_string]
                tup = action, option_string, short_explicit_arg
                result.append(tup)
            elif option_string.startswith(option_prefix):
                action = self._option_string_actions[option_string]
                tup = action, option_string, explicit_arg
                result.append(tup)

    # shouldn't ever get here
    else:
        self.error(_('unexpected option string: %s') % option_string)

    # return the collected option tuples
    return result

argparse.ArgumentParser._get_option_tuples = _get_option_tuples
p = argparse.ArgumentParser()
p.add_argument("--foo")
print p.parse_args("--f 5".split())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For those of us still stuck on python2.7 for whatever reason, this is a minimal change to locally disable prefix matching:</p>
<pre><code>class SaneArgumentParser(_argparse.ArgumentParser):
  """Disables prefix matching in ArgumentParser."""
  def _get_option_tuples(self, option_string):
    """Prevent argument parsing from looking for prefix matches."""
    return []
</code></pre>
<p>Now instead of using argparse.ArgumentParser, just use SaneArgumentParser. Unlike chepner's answer, this does not require any modification to the argparse module. It is also a much smaller change. Hopefully other people stuck in python's past will find this useful.</p>
</div>
<span class="comment-copy">Great, do you know of an analogue option for optparse?</span>
<span class="comment-copy">@SimonWarta: Nope. There's a reason it's deprecated.</span>
<span class="comment-copy">Note that <code>allow_abbrev</code> is not available prior to Python 3.5.</span>
<span class="comment-copy">@chepner: Oh dammit, I didn't see that. It doesn't look like there's any way to get the behavior in pre-3.5. That sucks.</span>
<span class="comment-copy">You could grab the <code>argparse.py</code> file from the latest Python release, and put it in your own directories (where it will have load priority).  This module is self contained, so it's a drop-in replacement.   The only Py2/3 incompatibility that I'm aware of is a <code>yield from get_subactions()</code> line in the <code>HelpFormatter</code> code.</span>
<span class="comment-copy">The change isn't very big - if you are willing to modify the guts of your <code>argparse.py</code>.  If you want the behavior to be switchable you'll have make more changes to pass some sort of switch parameter.</span>
<span class="comment-copy">Even simpler approach is to modify the parser instance directly: <code>parser._get_option_tuples = lambda option: []</code>.</span>
