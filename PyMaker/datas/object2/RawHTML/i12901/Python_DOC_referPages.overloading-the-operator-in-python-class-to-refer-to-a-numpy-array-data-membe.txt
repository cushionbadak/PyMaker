<div class="post-text" itemprop="text">
<p>I have written a data container class which essentially contains a numpy ndarray member along with methods to generate time_series masks/cross-sectional masks, fetch the date index (row#) in ring-buffer mode, handle resizing keeping in mind that the data may be a ring buffer, and implement restrictions on the shape/dimensions, etc.</p>
<p>As a result of my class implementation, now that I've to access the data wrapped by this object by explicitly referring to the *.data member. This is cumbersome and I'd like to implement the [] operator in my class such that when called on a instance of my class, it refers to the same operation on the underlying ndarray object. How can I achieve this?</p>
<pre><code>def MyArray(object):
    def __init__(self, shape, fill_value, dtype):
        self.shape = shape
        self.fill_value = fill_value
        self.dtype = dtype
        self.data = numpy.empty(shape, fill_value=fill_value, dtype=dtype)

    def reset(self, fill_value=None):
        self.data.fill(fill_value or self.fill_value)

    def resize(self, shape):
        if self.data.ndim != len(shape): raise Exception("dim error")
        if self.data.shape &lt; shape: raise Exception("sizing down not permitted")
        # do resizing
</code></pre>
<p>Now, if I'd like to use this container elsewhere, I have to use it as such:</p>
<pre><code>arr = MyArray(shape=(10000,20), fill_value=numpy.nan, dtype='float')
arr.data[::10] = numpy.NAN
msk = numpy.random.randn(10000,20)&lt;.5
arr.data[~msk] = -1.
</code></pre>
<p>The fact that I need to explicitly refer to arr.data every time I use this is too cumbersome and error-prone (I'm forgetting the .data suffix in so many places).</p>
<p>Is there any way I can add a few operators such that slicing and indexing on <code>arr</code> actually operates on <code>arr.data</code> <strong><em>implicitly</em></strong>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to implement the <code>__getitem__</code> and <code>__setitem__</code> magic functions.</p>
<p>A complete overview for the magic methods can be found here:
<a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="noreferrer">https://docs.python.org/3/reference/datamodel.html#object.<strong>getitem</strong></a></p>
<pre><code>import numpy as np

class MyArray():
    def __init__(self):
        self.data = np.zeros(10)

    def __getitem__(self, key):
        return self.data[key]

    def __setitem__(self, key, value):
        self.data[key] = value

    def __repr__(self):
        return 'MyArray({})'.format(self.data)


a = MyArray()

print(a[9])
print(a[1:5])
a[:] = np.arange(10)
print(a)
</code></pre>
<p>Which will give you this result:</p>
<pre><code>0.0
[ 0.  0.  0.  0.]
MyArray([ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9.])
</code></pre>
<h1>Inheritance</h1>
<p>If you just want to modify or add behaviour of np.ndarray, you could inherit from it. This is a little more complicated than for normal python classes, but implementing your case should be not that hard:</p>
<pre><code>import numpy as np


class MyArray(np.ndarray):

    def __new__(cls, shape, fill_value=0, dtype=float):
        data = np.full(shape, fill_value, dtype)
        obj = np.asarray(data).view(cls)
        obj.fill_value = fill_value
        return obj

    def reset(self, fill_value=None):
        if fill_value is not None:
            self.fill_value = fill_value

        self.fill(self.fill_value)
</code></pre>
<p>For more info, see this:
<a href="http://docs.scipy.org/doc/numpy/user/basics.subclassing.html" rel="noreferrer">http://docs.scipy.org/doc/numpy/user/basics.subclassing.html</a></p>
</div>
<span class="comment-copy">you have to implement the <a href="http://stackoverflow.com/questions/2936863/python-implementing-slicing-in-getitem"><code>__getitem__</code></a> attribute</span>
<span class="comment-copy">will this work for cases where arr is used on LHS as well as on RHS?</span>
<span class="comment-copy">@Mindstorm if you're assigning to it, that's <code>__setitem__</code>. Just pass the arguments through to <code>self.data</code>.</span>
<span class="comment-copy"><code>self.data.fill(fill_value or self.fill_value)</code> - what if someone wants to fill it with zeros?</span>
<span class="comment-copy">thanks for pointing that out. I overlooked that! :|</span>
<span class="comment-copy">excellent. One question though: would I have to write down every method to fully delegate [] calls on arr to arr.data?  there's one method for a+= b(iadd), one for a*= b(imul). Isn't there a more concise way than enumerating all these methods in my wrapper class?</span>
<span class="comment-copy">You could inherit from array and implement or override methods you need.</span>
<span class="comment-copy">However, this is a little complicated but dealt with in deep here: <a href="http://docs.scipy.org/doc/numpy/user/basics.subclassing.html" rel="nofollow noreferrer">docs.scipy.org/doc/numpy/user/basics.subclassing.html</a></span>
<span class="comment-copy">I added a inheritance solution to my answer.</span>
<span class="comment-copy">My implementation of the class as an ndarray subclass ran into issues when I try to resize:       <code>&gt;&gt;&gt; a.resize((10,2))      Traceback (most recent call last):      File "&lt;stdin&gt;", line 1, in &lt;module&gt;      ValueError: cannot resize an array references or is referenced      by another array in this way.  Use the resize function.       &gt;&gt;&gt; a.view(np.ndarray).resize((10,2))     Traceback (most recent call last):       File "&lt;stdin&gt;", line 1, in &lt;module&gt;     ValueError: cannot resize this array: it does not own its data</code></span>
