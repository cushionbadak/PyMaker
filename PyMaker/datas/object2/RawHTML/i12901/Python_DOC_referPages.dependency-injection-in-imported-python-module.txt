<div class="post-text" itemprop="text">
<p>My python module uses some functions from another module, but I have several implementations of that module interface. How to point out, which one to use?</p>
<p>Simple example:</p>
<p>A.py:</p>
<pre><code>import B
def say_hi()
   print "Message: " + B.greeting()
</code></pre>
<p>main.py:</p>
<pre><code>import A(B=my_B_impl)
A.say_hi()
</code></pre>
<p>my_B_impl.py:</p>
<pre><code>def greeting():
   return "Hallo!"
</code></pre>
<p>output:</p>
<pre><code>Message: Hallo!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In python this could be most elegantly done with inheritance:</p>
<h3>A.py:</h3>
<pre><code>import B
class SayHi(object):
    b = B
    def say_hi(self):
       print "Message: " + self.b.greeting()
</code></pre>
<h3>my_B_impl.py:</h3>
<pre><code>class AlternativeHi(object):
    def greeting(self):
       return "Hallo!"
</code></pre>
<h3>main.py:</h3>
<pre><code>import A
from my_B_impl.py import AlternativeHi
class MyHi(SayHi):
    b=AlternativeHi
a=MyHi()
MyHi.say_hi()
</code></pre>
<h3>output:</h3>
<pre><code>Message: Hallo!
</code></pre>
<p>You can also use the factory pattern to avoid explicit declaration of class <code>AlternativeHi</code> and <code>MyHi</code>:</p>
<h3>A.py</h3>
<pre><code>from B import greeting
class SayHi(object):
    def __init__(self,*args,**kwargs):
        self.greeting = greeting
    def say_hi(self):
       print "Message: " + self.greeting()

def hi_factory(func):
    class CustomHi(SayHi):
        def __init__(self,*args,**kwargs):
            result = super(CustomHi, self).__init__(*args, **kwargs)
            self.greeting = func
    return CustomHi
</code></pre>
<h3>my_B_impl.py:</h3>
<pre><code>def greeting(self):
    return "Hallo!"
</code></pre>
<h3>main.py:</h3>
<pre><code>form A import hi_factory
from my_B_impl import greeting
a = hi_factory(greeting)
a.say_hi()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you ask is not directly possible. There is no parameterisation capability built in to Python's module system. If you think about it, it's not clear how such a proposal ought to work: if modules <code>A</code> and <code>B</code> both import module <code>M</code>, but they supply different parameters, which parameter is used when <code>M</code> is imported? Is it imported twice? What would that mean for module-level configuration (as in <code>logging</code>)? It gets worse if a third module <code>C</code> attempts to import <code>M</code> without parameters. Also, the "open-world" idea that you could override <em>any</em> <code>import</code> statement from the outside violates the language-design principle that "the code you wrote is the code that ran".</p>
<p>Other languages have incorporated parameterised modules in a variety of ways (compare Scala's object model, ML's modules and signatures, and - stretching it - C++'s templates), but it's not clear that such a feature would be a good fit for Python. (That said, you could probably hack something resembling parameterised modules using <code>importlib</code> if you were determined and masochistic enough.)</p>
<hr/>
<p>Python does have very powerful and flexible capabilities for dynamic dispatch, however. Python's standard, day-to-day features like functions, classes, parameters and overriding provide the basis for this support.</p>
<p>There are lots of ways to cut the cake on your example of a function whose behaviour is configurable by its client.</p>
<p>A function parameterised by a value:</p>
<pre><code>def say_hi(greeting):
    print("Message: " + greeting)

def main():
    say_hi("Hello")
</code></pre>
<p>A class parameterised by a value:</p>
<pre><code>class Greeter:
    def __init__(self, greeting):
        self.greeting = greeting
    def say_hi(self):
        print("Message: " + self.greeting)


def main():
    Greeter("Hello").say_hi()
</code></pre>
<p>A class with a virtual method:</p>
<pre><code>class Greeter:
    def say_hi(self):
        print("Message: " + self.msg())

class MyGreeter(Greeter):
    def msg(self):
        return "Hello"
</code></pre>
<p>A function parameterised by a function:</p>
<pre><code>def say_hi(greeting):
    print("Message: " + greeting())

def make_greeting():
    return "Hello"

def main():
    say_hi(make_greeting)
</code></pre>
<p>There are more options (I'm avoiding the Java-y example of objects invoking other objects) but you get the idea. In each of these cases, the selection of the behaviour (the passing of the parameter, the overriding of the method) is decoupled from the code which uses it and could be put in a different file. The right one to choose depends on your situation (though here's a hint: the right one is always the simplest one that works).</p>
<hr/>
<p><strong>Update</strong>: in a comment you mention that you'd like an API which sets up the dependency at the module-level. The main problem with this is that the dependency would be <em>global</em> - modules are singletons, so anyone who imports the module has to use the same implementation of the dependency.</p>
<p>My advice is to provide an object-oriented API with "proper" (per-instance) dependency injection, and provide top-level convenience functions which use a (configurable) "default" set-up of the dependency. Then you have the option of <em>not</em> using the globally-configured version. This is roughly <a href="https://docs.python.org/3/library/asyncio-eventloops.html#event-loop-functions" rel="nofollow">how <code>asyncio</code> does it</a>.</p>
<pre><code># flexible object with dependency injection
class Greeter:
    def __init__(self, msg):
        self.msg = msg
    def say_hi(self):
        print("Message: " + self.msg)

# set up a default configuration of the object to be used by the high-level API
_default_greeter = Greeter("Hello")
def configure(msg):
    global _default_greeter
    _default_greeter = Greeter(msg)

# delegate to whatever default has been configured
def say_hi():
    _default_greeter.say_hi()
</code></pre>
</div>
<span class="comment-copy">Sounds like you want to do <i>parameterised modules</i>. That's not supported by Python directly (well, it probably is if you're into metaprogramming), though you can get 90% of the way there with classes.</span>
<span class="comment-copy">Unfortunately classes aren't suitable for me in that case</span>
<span class="comment-copy">In what respect are they unsuitable?</span>
<span class="comment-copy">Really interesting. What about if it is not a Class ? Just a file with some functions that depends on os and other stuff ?</span>
<span class="comment-copy">Sorry for the late answer. The example above is simplified. I'm actually going to implement several math module and some of them on pure C. Of course it's possible by the use of classes as well, but I'm looking for an elegant and thin solution. As far as I understand, there's no one? May by I could use something like: import B import A A.configure(B)?</span>
<span class="comment-copy">That'd work, but the configuration would be <i>global</i> - everyone that imports <code>A</code> would get the same implementation of <code>B</code>. That may be enough for you, but my advice would be to follow the lead of the standard library's <code>logging</code> or <code>asyncio</code> module - provide a flexible object model and build a simpler layer on top of that, using module-level configuration to set up the defaults. I'll update my answer.</span>
