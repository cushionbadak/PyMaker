<div class="post-text" itemprop="text">
<p>I'm upgrading a bunch of scripts where the ecosystem is a bit of a mess.  The scripts always relied on external modules, and didn't have any package infrastructure of their own (they also didn't do much OOP, as you can imagine).  There's nothing at the top level, but it is the working directory when starting Python and I'd like to keep it that way.  At the top-level, I've just created <code>__init__.py</code> file (based on <a href="https://stackoverflow.com/q/14886143/320399">another question</a>).  As I'm less experienced with Python <code>__init__.py</code> confuses me a bit.  All of the <code>__init__.py</code> files I've created are empty, it's my understanding that this is all that's required.</p>
<p>Assume I have the following directory structure:</p>
<pre><code>__init__.py
dev.properties
prod.properties
F/
  Foo.py
  __init__.py

B/
  bar.py
  __init__.py
</code></pre>
<p>And the code is like this : </p>
<pre><code># Foo.py
    from ..b import bar
    barFunc()
# bar.py
    def barFunc():
        print "Hello, World!"
        sys.stdout.flush()
</code></pre>
<p>I've created <code>__init__.py</code> at the root, in <code>F/</code> and in <code>B/</code>.  However, when I run <code>python F/Foo.py</code>, I get an error:</p>
<pre><code>Traceback (most recent call last):
  File "F/Foo.py", line 3, in &lt;module&gt;
    from ..b import bar
ValueError: Attempted relative import in non-package
</code></pre>
<p>What exactly would I need to do to invoke <code>python F/Foo.py</code> and be able to depend on things defined in sibling directories?</p>
<p><strong><em>Update</em></strong></p>
<p>Thanks to <a href="https://stackoverflow.com/a/34048288/320399">@user2455127</a>, I realized that I forgot to remove the file extension <code>.py</code> and my working directory was wrong.  From the <code>mypackage</code> directory, running <code>python -m mypackage/F/Foo</code>, the error was : <code>myvirtualenv/bin/python: No module named mypackage/B/bar</code>.  </p>
<p>Re-reading <a href="https://stackoverflow.com/a/34048288/320399">@user2455127</a>'s post, I ran from the directory above and get a long Traceback:</p>
<pre><code>Traceback (most recent call last):
  File "/usr/lib/python2.7/runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "/usr/lib/python2.7/runpy.py", line 72, in _run_code
    exec code in run_globals
  File "&lt;full path&gt;/mypackage/foo/Foo.py", line 24, in &lt;module&gt;
    from ..b import bar
ValueError: Attempted relative import in non-package
</code></pre>
<p>I'm not quite sure what needs to be done to fix this, but it seems like the <code>__package__</code> attribute may help.  I'll try and figure that out, and post another update.</p>
</div>
<div class="post-text" itemprop="text">
<p>Have a look to this :
<a href="https://stackoverflow.com/questions/11536764/attempted-relative-import-in-non-package-even-with-init-py">Attempted relative import in non-package even with <strong>init</strong>.py</a> and brenBarn's answer</p>
<p>If you run it from the folder upper than the one with dev.properties and the others files (called lambda in my case), with this command line : </p>
<pre><code>python -m lambda.F.Foo
</code></pre>
<p>it works.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the current working directory is F's and B's parent directory, then F and B are available as modules to all Python code. You should run:</p>
<pre><code>$ F/foo.py
</code></pre>
<p>and then <code>F/foo.py</code> should contain</p>
<pre><code>from B.bar import barFunc
barFunc()
</code></pre>
<p>As for <code>__init__.py</code>, that file's existance simply makes the directory an importable module. If you want to know more about it, check the <a href="https://docs.python.org/3/reference/import.html" rel="nofollow">docs on how imports work</a>. (For most people, reading all of that isn't necessary.)</p>
<p>Relative imports can be pretty messy, so I'd advise shying away from them for now.</p>
</div>
<span class="comment-copy">So, are you saying that in your case, the the directory above <code>F</code> is called <code>lambda</code>?  Mimicking that, I've run <code>python mypackage/F/Foo.py</code>, but I get an error: <code>myvirtualenv/bin/python: Import by filename is not supported.</code></span>
<span class="comment-copy">yes, but read the link, and your command is wrong, look at mine, there is the "-m" option and no ".py" in the end, to call it as a package. Plus I call it from the folder containing "lambda"</span>
<span class="comment-copy">Ah, sorry, I actually did have the <code>-m</code> (command was right, my SO comment was wrong), but didn't realize you removed the <code>.py</code> extension.  Re: calling folder, I guess I've got that part wrong (working dir was <code>mypackage</code>).</span>
<span class="comment-copy">Well, again I recommend you to read the link I gave you ;) I am not sure if what you do is really what you will have in your project, is Foo.py run as the main or imported ? Because relative imports depends on which script you run. I can't answer you here since there's plenty of options, that you will find on the related question that I linked !</span>
<span class="comment-copy">I appreciate it, and I'll keep trying to figure it out.  I did post an update to my question if you're interested.</span>
<span class="comment-copy">Aha!  That solved it for me! :)  It was the line <code>from ..b import bar</code> that tripped me up.  Now using <code>from B.bar import barFunc</code>, I can run both <code>python -m F.Foo</code> and <code>python -m F/Foo</code> from the parent directory of <code>F/</code> and <code>B/</code>.  <i>However</i>, it's unclear to why going up one directory and running <code>python -m mypackage.F.Foo</code> (or <code>python -m mypackage/F/Foo</code>) result in <code>ImportError: No module named b.bar</code>.  I'm happy to go on not knowing, but I am curious :)</span>
<span class="comment-copy">It's all about the <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" rel="nofollow noreferrer">PYTHONPATH</a> - Python looks in those directories for importable things, and the current working directory is one of them.</span>
