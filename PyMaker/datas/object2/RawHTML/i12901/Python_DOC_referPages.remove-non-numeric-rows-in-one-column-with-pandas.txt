<div class="post-text" itemprop="text">
<p>There is a dataframe like the following, and it has one unclean column 'id' which it sholud be numeric column</p>
<pre><code>id, name
1,  A
2,  B
3,  C
tt, D
4,  E
5,  F
de, G
</code></pre>
<p>Is there a concise way to remove the rows because tt and de are not numeric values</p>
<pre><code>tt,D
de,G
</code></pre>
<p>to make the dataframe clean?</p>
<pre><code>id, name
1,  A
2,  B
3,  C
4,  E
5,  F
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use standard  method of strings <a href="https://docs.python.org/3/library/stdtypes.html#str.isnumeric" rel="noreferrer"><code>isnumeric</code></a> and apply it to each value in your <code>id</code> column:</p>
<pre><code>import pandas as pd
from io import StringIO

data = """
id,name
1,A
2,B
3,C
tt,D
4,E
5,F
de,G
"""

df = pd.read_csv(StringIO(data))

In [55]: df
Out[55]: 
   id name
0   1    A
1   2    B
2   3    C
3  tt    D
4   4    E
5   5    F
6  de    G

In [56]: df[df.id.apply(lambda x: x.isnumeric())]
Out[56]: 
  id name
0  1    A
1  2    B
2  3    C
4  4    E
5  5    F
</code></pre>
<p>Or if you want to use <code>id</code> as index you could do:</p>
<pre><code>In [61]: df[df.id.apply(lambda x: x.isnumeric())].set_index('id')
Out[61]: 
   name
id     
1     A
2     B
3     C
4     E
5     F
</code></pre>
<h3>Edit. Add timings</h3>
<p>Although case with <code>pd.to_numeric</code> is not using <code>apply</code> method it is almost two times slower than with applying <code>np.isnumeric</code> for <code>str</code> columns. Also I add option with using pandas <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.str.isnumeric.html" rel="noreferrer"><code>str.isnumeric</code></a> which is less typing and still faster then using <code>pd.to_numeric</code>. But <code>pd.to_numeric</code> is more general because it could work with any data types (not only strings).</p>
<pre><code>df_big = pd.concat([df]*10000)

In [3]: df_big = pd.concat([df]*10000)

In [4]: df_big.shape
Out[4]: (70000, 2)

In [5]: %timeit df_big[df_big.id.apply(lambda x: x.isnumeric())]
15.3 ms ± 2.02 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [6]: %timeit df_big[df_big.id.str.isnumeric()]
20.3 ms ± 171 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [7]: %timeit df_big[pd.to_numeric(df_big['id'], errors='coerce').notnull()]
29.9 ms ± 682 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>pd.to_numeric</code></p>
<pre><code>In [1079]: df[pd.to_numeric(df['id'], errors='coerce').notnull()]
Out[1079]:
  id  name
0  1     A
1  2     B
2  3     C
4  4     E
5  5     F
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given that <code>df</code> is your dataframe, </p>
<pre><code>import numpy as np
df[df['id'].apply(lambda x: isinstance(x, (int, np.int64)))]
</code></pre>
<p>What it does is passing each value in the <code>id</code> column to the <code>isinstance</code> function and checks if it's an <code>int</code>. Then it returns a boolean array, and finally returning only the rows where there is <code>True</code>.</p>
<p>If you also need to account for <code>float</code> values, another option is:</p>
<pre><code>import numpy as np
df[df['id'].apply(lambda x: type(x) in [int, np.int64, float, np.float64])]
</code></pre>
<p>Note that either way is not inplace, so you will need to reassign it to your original df, or create a new one:</p>
<pre><code>df = df[df['id'].apply(lambda x: type(x) in [int, np.int64, float, np.float64])]
# or
new_df = df[df['id'].apply(lambda x: type(x) in [int, np.int64, float, np.float64])]
</code></pre>
</div>
<span class="comment-copy">this is the trick</span>
<span class="comment-copy">If you want to retain the column as a number and not an object, you might need to call <code>pd.to_numeric</code> separately.</span>
<span class="comment-copy">No <code>apply</code> :D !</span>
