<div class="post-text" itemprop="text">
<p>(I think) I know how to read from a pipe. I mean calls on the bash like this</p>
<pre><code>echo BÃ¤hm | ./script.py
</code></pre>
<p>This <em>Python3</em> script work with that.</p>
<pre><code>#!/usr/bin/env python3
import sys

x = sys.stdin.read()

if x:
    print(x)
else:
    print('no pipe')

sys.exit()
</code></pre>
<p>But when I simply do this on the bash</p>
<pre><code>./script.py
</code></pre>
<p>nothing happens because it waits for input.</p>
<p>So I want to check (when starting the script) if there is input from a pipe or not. But I don't know why <code>size</code> or <code>len</code> didn't worked on <code>sys.stdin</code> or <code>sys.stdin.buffer</code>.</p>
<p>Maybe there is a difference in handling that between version 2 and 3 of Python, too?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>nothing happens because it waits for input</p>
</blockquote>
<p>And that's completely <em>fine</em>. You want to fix something that doesn't need any fixing, and as a by-product you're actually creating problems.</p>
<p>Imagine a piping process that does some heavy calculations, and because of that, needs some time to produce the output. You cannot check for data availability in your python script. You don't know when the data is going to be available. You have to be patient.</p>
<blockquote>
<p>So I want to check (when starting the script) if there is input from a
  pipe or not.</p>
</blockquote>
<p>Don't. If, for some reason, your application hasn't meant to be run with a tty (waiting for user input), check for that.</p>
<pre><code>sys.stdin.isatty()
</code></pre>
<p>Only check for data availability if there's some hard-time constraint: e.g.: the user has to respond within 2 seconds.</p>
</div>
<div class="post-text" itemprop="text">
<p>Alternatively to @Cyrbil's answer if you really need to know if the input was piped in, you can use <a href="https://docs.python.org/3/library/os.html#os.isatty" rel="nofollow"><code>isatty</code></a>:</p>
<pre><code>from sys import stdin
from os import isatty

is_pipe = not isatty(stdin.fileno())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can set the input entry file to non-blocking, and catching the <code>IOError: [Errno 11] Resource temporarily unavailable</code> when nothing is piped.</p>
<pre><code>import fcntl
import os
import sys

# make stdin a non-blocking file
fd = sys.stdin.fileno()
fl = fcntl.fcntl(fd, fcntl.F_GETFL)
fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

try:
    print(sys.stdin.read())
except:
    print('No input')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use select, but it doesn't work on Windows:</p>
<pre><code>import sys
import select

# Input: zero or more file-like objects
# Returns: list of objects that can be read 
def can_read_files(*args):
    return select.select(args, [], [], 0.0)[0]

if can_read_files(sys.stdin):
    print(sys.stdin.read())
else:
    print('No input')
</code></pre>
<p>To us it inline:</p>
<pre><code>if select.select([sys.stdin], [], [], 0.0)[0]:
    ...
</code></pre>
</div>
<span class="comment-copy">Is this Python-3.x specific? I'll put in the tag edit to be approved or disapproved.</span>
<span class="comment-copy">I know nothing about Python2. My example is Python3. And there are often relevant differences between them. That is why I try to make my questions as most specific as possible. And a lot of Python-questions on SO mixing things between 2 and 3 and confusing the readers.</span>
<span class="comment-copy">This work for my cases. But I am not sure if I understand the concept behind it correct. Maybe there are cases where it doesn't work as I expected?</span>
<span class="comment-copy">Not that I know of... even checking the tty seems to be an overkill, try any good-citizen unix tool, <code>cat</code>, <code>sed</code>, ... they will all patiently wait for user input. Checking for input availability OTOH, <i>will</i> break the unix pipe black-box abstraction, because expecting immediate input isn't realistic.</span>
<span class="comment-copy">What is about <code>less</code>? You can say <code>less file.txt</code> or <code>cat file.txt | less</code>. Isn't that the same think like I want?</span>
<span class="comment-copy">Typing on the terminal really doesn't make sense when you're paging the output. If there's good reason to prevent running on a tty, go ahead and check it.</span>
<span class="comment-copy">I didn't bring this solution because I had some unexpected behavior with <code>stdin.isatty()</code> but with the <code>os.isatty()</code> this seems to work fine.</span>
<span class="comment-copy">@Cyrbil, I didn't know that you can "ask" stdin directly if it is a TTY. Thanks for the info! I cannot say what is different. Maybe some oddities with a PTY?</span>
<span class="comment-copy">Seems like <code>stdin.isatty()</code> always return <code>True</code>. I cannot produce a case where it returns me False ... So <code>os.isatty()</code> is the best way.</span>
<span class="comment-copy">@Cyrbil <code>$ echo 'No' | python -c 'from sys import stdin; print(stdin.isatty())'</code> prints <code>False</code> for me. Without the <code>echo</code> <code>True</code>.</span>
<span class="comment-copy">minus1. Sounds a really bad idea to me. What if the piping process just needs some time before it can produce some output?</span>
<span class="comment-copy">@KarolyHorvath: That's not what buhtz asked for. He wants to know if there's any input or not. Cyrbil's code is probably the most cross platform way to do it. If you want to wait, put his code in a loop with a timer until time expires or read() returns.</span>
<span class="comment-copy">@Harvey: I think he asked for the wrong thing. <a href="http://xyproblem.info/" rel="nofollow noreferrer">xyproblem.info</a></span>
<span class="comment-copy">I'm not gonna discuss what OP said or not. I think I answered correctly based on the amount of information given. You bring a problem that wasn't evoked and put a -1 after that. That's a strange way of discussing things.</span>
<span class="comment-copy">You basically just create an answer that does not solves the problem. And then edit to include Kay's solution that will be the only one I'm gonna upvote.</span>
