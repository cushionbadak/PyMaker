<div class="post-text" itemprop="text">
<p>If we have <code>x = type(a)</code> and <code>x == y</code>, does it necessarily imply that <code>x is y</code>?</p>
<p>Here is a counter-example, but it's a cheat:</p>
<pre><code>&gt;&gt;&gt; class BrokenEq(type):
...     def __eq__(cls, other):
...         return True
...     
&gt;&gt;&gt; class A(metaclass=BrokenEq):
...     pass
... 
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; x = type(a)
&gt;&gt;&gt; x == A, x is A
(True, True)
&gt;&gt;&gt; x == BrokenEq, x is BrokenEq
(True, False)
</code></pre>
<p>And I could not create a counterexample like this:</p>
<pre><code>&gt;&gt;&gt; A1 = type('A', (), {})
&gt;&gt;&gt; A2 = type('A', (), {})
&gt;&gt;&gt; a = A1()
&gt;&gt;&gt; x = type(a)
&gt;&gt;&gt; x == A1, x is A1
(True, True)
&gt;&gt;&gt; x == A2, x is A2
(False, False)
</code></pre>
<p>To clarify my question - <em>without overriding equality</em> operators to do something insane, is it possible for a class to exist at two different memory locations or does the import system somehow prevent this?  </p>
<p>If so, how can we demonstrate this behavior - for example, doing weird things with <a href="https://docs.python.org/2/library/functions.html#reload" rel="nofollow">reload</a> or <code>__import__</code>? </p>
<p>If not, is that guaranteed by the language or documented anywhere?</p>
<hr/>
<p><strong>Epilogue</strong>:</p>
<pre><code># thing.py
class A:
    pass
</code></pre>
<p>Finally, this is what clarified the real behaviour for me (and it's supporting the claims in Blckknght answer)</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; from thing import A
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; isinstance(a, A), type(a) == A, type(a) is A
(True, True, True)
&gt;&gt;&gt; del sys.modules['thing']
&gt;&gt;&gt; from thing import A
&gt;&gt;&gt; isinstance(a, A), type(a) == A, type(a) is A
(False, False, False)
</code></pre>
<p>So, although code that uses <a href="https://docs.python.org/3/library/importlib.html?highlight=reload#importlib.reload" rel="nofollow"><code>importlib.reload</code></a> could break type checking by class identity, it will also break <code>isinstance</code> anyway.  </p>
</div>
<div class="post-text" itemprop="text">
<p>No, there's no way to create two class objects that compare equal without being identical, except by messing around with metaclass <code>__eq__</code> methods.</p>
<p>This behavior though is not something unique to classes. It's the default behavior for any object without an <code>__eq__</code> method defined in its class. The behavior is inherited from <code>object</code>, which is the base class for all other (new-style) classes. It's only overridden for builtin types that have some other semantic for equality (e.g. container types which compare their contents) and for custom classes that define an <code>__eq__</code> operator of their own.</p>
<p>As for getting two different refernces to the same class at different memory locations, that's not really possible due to Python's object semantics. The memory location of the object <em>is</em> its identity (in cpython at least). Another class with identical contents can exist somewhere else, but like in your <code>A1</code> and <code>A2</code> example, it's going to be seen as a different object by all Python logic.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not aware of any documentation about how <code>==</code> works for types, but it definitely works by identity. You can see that the <a href="https://hg.python.org/cpython/file/2.7/Objects/typeobject.c#l632" rel="nofollow noreferrer">CPython 2.7 implementation</a> is a pointer comparison:</p>
<pre><code>static PyObject*
type_richcompare(PyObject *v, PyObject *w, int op)
{
    ...

    /* Compare addresses */
    vv = (Py_uintptr_t)v;
    ww = (Py_uintptr_t)w;
    switch (op) {
    ...
    case Py_EQ: c = vv == ww; break;
</code></pre>
<p>In <a href="https://hg.python.org/cpython/file/3.5/Objects/typeobject.c#l3294" rel="nofollow noreferrer">CPython 3.5</a>, <code>type</code> doesn't implement its own <code>tp_richcompare</code>, so it inherits the default equality comparison from <code>object</code>, which is a pointer comparison:</p>
<pre><code>PyTypeObject PyType_Type = {
    ...
    0,                                          /* tp_richcompare */
</code></pre>
</div>
<span class="comment-copy">Interesting question! I think they would have to be, simply because an object of any given type would presumably only be created in one consistent way. Can I cite something saying so? Not yet.</span>
<span class="comment-copy">Since everything is an object in python the classes are "just" instances of their metaclass - why couldn't we have other instances of the "same" class?  However, I've failed in finding an example where importing a class or otherwise binding a name to the class doesn't just get another reference to the same object.</span>
<span class="comment-copy">Perhaps it's just one of those things that happens to be true in a given implementation, but isn't addressed in the language spec and isn't guaranteed.</span>
<span class="comment-copy">If you import the same class from different import paths, they will exist at two different memory locations, but they will not evaluate identical (i.e. x = type(a) and x == y --&gt;  x is y still holds).</span>
<span class="comment-copy">Hi!  So the answer seems to be: no, they are not singleton (which would mean the creation of classobjects has to be intercepted).  But their default <code>__eq__</code>, which they get from <code>object</code>, is dumb - even if the classes are generated from identical source code they don't compare equal.  Is it right?</span>
<span class="comment-copy">Right, the class objects are not instances of some singelton class, they're just normal instances of the <code>type</code> metatype. Calling <code>type(obj)</code> doesn't create a new type, it just looks up the type of the instance <code>obj</code> (from obj.__class__`) and returns a reference to that pre-exisiting object.</span>
