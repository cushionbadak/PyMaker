<div class="post-text" itemprop="text">
<p>I was going through an example in this computer-vision <a href="http://programmingcomputervision.com/downloads/ProgrammingComputerVision_CCdraft.pdf" rel="nofollow noreferrer">book</a> and was a bit surprised by the code:</p>
<pre><code>descr = []
descr.append(sift.read_features_from_file(featurefiles[0])[1])
descriptors = descr[0] #stack all features for k-means
for i in arange(1,nbr_images):
  descr.append(sift.read_features_from_file(featurefiles[i])[1])
  descriptors = vstack((descriptors,descr[i]))
</code></pre>
<p>To me it looks like this is copying the array over and over again and a more efficient implementation would be:</p>
<pre><code>descr = []
descr.append(sift.read_features_from_file(featurefiles[0])[1])
for i in arange(1,nbr_images):
  descr.append(sift.read_features_from_file(featurefiles[i])[1])
descriptors = vstack((descr))
</code></pre>
<p>Or am I missing something here and the two codes are not identical. I ran a small test:</p>
<pre><code>print("ATTENTION")
print(descriptors.shape)
print("ATTENTION")
print(descriptors[1:10])
</code></pre>
<p>And it seems the list is different?</p>
<p><a href="https://i.stack.imgur.com/TEQXe.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/TEQXe.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>You're absolutely right - repeatedly concatenating numpy arrays inside a loop is <em>extremely</em> inefficient. Concatenation always generates a copy, which becomes more and more costly as your array gets bigger and bigger inside the loop.</p>
<p>Instead, do one of two things:</p>
<ol>
<li><p>As you have done, store the intermediate values in a regular Python <code>list</code> and convert this to a numpy array outside the loop. Appending to a <code>list</code> is <em>O(1)</em>, whereas concatenating <code>np.ndarray</code>s is <em>O(n+k)</em>.</p></li>
<li><p>If you know how large the final array will be ahead of time, you can pre-allocate it and then fill in the rows inside your <code>for</code> loop, e.g.:</p>
<pre><code>descr = np.empty((nbr_images, nbr_features), dtype=my_dtype)
for i in range(nbr_image):
    descr[i] = sift.read_features_from_file(featurefiles[i])[1]
</code></pre></li>
</ol>
<p>Another variant would be to use <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.fromiter.html" rel="nofollow noreferrer"><code>np.fromiter</code></a> to lazily generate the array from an iterable object, for example in <a href="https://stackoverflow.com/q/34018470/1461210">this recent question</a>.</p>
</div>
<span class="comment-copy">What do the elements of <code>descr</code> list look like?  arrays?  shape?</span>
<span class="comment-copy">By the way, <a href="https://docs.python.org/3/library/functions.html#func-range" rel="nofollow noreferrer"><code>range()</code></a> (or even better, <a href="https://docs.python.org/2/library/functions.html#xrange" rel="nofollow noreferrer"><code>xrange()</code></a> for Python2.x) is much cheaper than <a href="http://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.arange.html" rel="nofollow noreferrer"><code>np.arange</code></a>.</span>
