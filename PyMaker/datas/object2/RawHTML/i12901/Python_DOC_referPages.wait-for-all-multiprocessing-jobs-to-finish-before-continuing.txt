<div class="post-text" itemprop="text">
<p>I want to run a bunch of jobs in parallel and then continue once all the jobs are finished. I've got something like</p>
<pre><code># based on example code from https://pymotw.com/2/multiprocessing/basics.html
import multiprocessing
import random
import time

def worker(num):
    """A job that runs for a random amount of time between 5 and 10 seconds."""
    time.sleep(random.randrange(5,11))
    print('Worker:' + str(num) + ' finished')
    return

if __name__ == '__main__':
    jobs = []
    for i in range(5):
        p = multiprocessing.Process(target=worker, args=(i,))
        jobs.append(p)
        p.start()

    # Iterate through the list of jobs and remove one that are finished, checking every second.
    while len(jobs) &gt; 0:
        jobs = [job for job in jobs if job.is_alive()]
        time.sleep(1)

    print('*** All jobs finished ***')
</code></pre>
<p>it works, but I'm sure there must be a better way to wait for all the jobs to finish than iterating over them again and again until they are done.</p>
</div>
<div class="post-text" itemprop="text">
<p>What about?</p>
<pre><code>for job in jobs:
    job.join()
</code></pre>
<p>This blocks until the first process finishes, then the next one and so on. See more about <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.Process.join"><code>join()</code></a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can make use of <a href="https://docs.python.org/3/library/multiprocessing.html#process-and-exceptions" rel="nofollow">join</a>.
It let you wait for another process to end.</p>
<pre><code>t1 = Process(target=f, args=(x,))
t2 = Process(target=f, args=('bob',))

t1.start()
t2.start()

t1.join()
t2.join()
</code></pre>
<p>You can also use <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Barrier" rel="nofollow">barrier</a> It works as for threads, letting you specify a number of process you want to wait on and once this number is reached the barrier free them. Here client and server are asumed to be spawn as Process.</p>
<pre><code>b = Barrier(2, timeout=5)

def server():
    start_server()
    b.wait()
    while True:
        connection = accept_connection()
        process_server_connection(connection)

def client():
    b.wait()
    while True:
        connection = make_connection()
        process_client_connection(connection)
</code></pre>
<p>And if you want more functionalities like sharing data and more flow control you can use a <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing-managers" rel="nofollow">manager</a>.</p>
</div>
<span class="comment-copy">That's exactly what I was looking for, thanks :)</span>
<span class="comment-copy">Note to future searchers: This usage can be indicative of a task that would benefit from a <a href="https://docs.python.org/2/library/multiprocessing.html#using-a-pool-of-workers" rel="nofollow noreferrer">Pool</a>.</span>
<span class="comment-copy">Banging my head against the wall trying to figure this out. Explanation made it finally click.</span>
