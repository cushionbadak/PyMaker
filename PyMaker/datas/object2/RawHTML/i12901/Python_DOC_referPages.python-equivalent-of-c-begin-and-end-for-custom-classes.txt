<div class="post-text" itemprop="text">
<p>Say you have a dictionary whose keys are integers. The values are also dictionaries whose keys are strings and whose values are numpy arrays.
Something like:</p>
<pre><code>custom = {1: {'a': np.zeros(10), 'b': np.zeros(100)}, 2:{'c': np.zeros(20), 'd': np.zeros(200)}}
</code></pre>
<p>I've been using this custom data structure quite a lot in the code, and every time I need to iterate over each of the rows in the numpy arrays of this structure, I have to do:</p>
<pre><code>for d, delem in custom.items():
    for k, v in delem.items():
        for row in v:
            print(row)
</code></pre>
<p>Is it possible to encapsulate this behavior in functions <em>Ã  la</em> C++ where you can actually implement custom <code>begin()</code> and <code>end()</code>? Also, the iterator should also have information about the keys in their corresponding dictionaries. I envision something like:</p>
<pre><code>for it in custom:
    d, e, row = *it
    # then do something with these
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import numpy as np

custom = {
    1: {'a': np.zeros(10), 'b': np.zeros(100)}, 
    2:{'c': np.zeros(20), 'd': np.zeros(200)}
}

my_gen = (
    (key, subkey, np_array) 
    for (key, a_dict) in custom.items() 
    for subkey, np_array in a_dict.items() 
)

for key, subkey, np_array in my_gen:
    print(key, subkey, np_array)

--output:--
1 b [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
1 a [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
2 d [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.]
2 c [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.  0.]
</code></pre>
<p>Or, you could reconstitute your data structure into something that is more useful for your purposes:</p>
<pre><code>import numpy as np

custom = {
    1: {'a': np.zeros(10), 'b': np.zeros(100)}, 
    2:{'c': np.zeros(20), 'd': np.zeros(200)}
}

#Create a *list* of tuples:
converted_data = [
    (np_array, subkey, key)
    for (key, a_dict) in custom.items() 
    for subkey, np_array in a_dict.items() 
]

for np_array, subkey, key in converted_data:
    print(key, subkey, np_array)
</code></pre>
<p>Creating a custom iterator:</p>
<pre><code>class Dog:
    def __init__(self, data):
        self.data = data
        self.max = len(data)
        self.index_pointer = 0

    def __next__(self):
        index = self.index_pointer

        if index &lt; self.max:
            current_val = self.data[index]
            self.index_pointer += 1
            return current_val
        else:
            raise StopIteration


class MyIter:
    def __iter__(self):
        return Dog([1, 2, 3])


for i in MyIter():
    print(i)

--output:--
1
2
3
</code></pre>
<p><code>__iter__()</code> just needs to return an object that implements a <code>__next__()</code> method, so you can combine those two classes like this:</p>
<pre><code>class MyIter:
    def __init__(self, data):
        self.data = data
        self.max = len(data)
        self.index_pointer = 0

    def __iter__(self):
        return self  #I have a __next__() method, so let's return me!

    def __next__(self):
        index = self.index_pointer

        if index &lt; self.max:
            current_val = self.data[index]
            self.index_pointer += 1
            return current_val
        else:
            raise StopIteration

for i in MyIter([1, 2, 3]):
    print(i)

--output:--
1
2
3
</code></pre>
<p>A more complex <code>__next__()</code> method:</p>
<pre><code>import numpy as np

class CustomIter:
    def __init__(self, data):
        self.data = data
        self.count = 0


    def __iter__(self):
        return self

    def __next__(self):
        count = self.count
        self.count += 1

        if count == 0:  #On first iteration, retun a sum of the keys
            return sum(self.data.keys())

        elif count == 1: #On second iteration, return the subkeys in tuples
            subkeys =  [ 
                a_dict.keys()
                for a_dict in self.data.values()
            ]

            return subkeys

        elif count == 2: #On third iteration, return the count of np arrays
            np_arrays = [
                np_array
                for a_dict in self.data.values()
                for np_array in a_dict.values()
            ]

            return len(np_arrays)

        else:  #Quit after three iterations
            raise StopIteration


custom = {
    1: {'a': np.zeros(10), 'b': np.zeros(100)}, 
    2:{'c': np.zeros(20), 'd': np.zeros(200)}
}

for i in CustomIter(custom):
    print(i)


--output:--
3
[dict_keys(['b', 'a']), dict_keys(['d', 'c'])]
4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are multiple ways to do this. <code>yield</code> may be the simplest as it does the heavy lifting of building an interator class for you.</p>
<pre><code>def custom_dict_iter(custom):
    for d, delem in custom.items():
        for k, v in delem.items():
            for row in v:
                yield d, k, row

for d, k, row in custom_dict_iter(my_custom_dict):
    print(d, k, row)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Look up the <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow">iterator protocol</a> - this is more similar to Java's <code>Iterable</code> or C#'s <code>IEnumerable</code> than C++'s begin/end. You can define it more easily by defining the <code>__iter__</code> method as a <a href="https://docs.python.org/3.5/tutorial/classes.html#generators" rel="nofollow">generator</a>.</p>
<p>The only thing is, you'd need to make your <code>custom</code> have its own class with these methods rather than a plain dictionary, but I assume that's also true in C++.</p>
</div>
<div class="post-text" itemprop="text">
<p>As a more pythonic way you can use a nested list comprehension which performs at C language speed inside the interpreter:</p>
<pre><code>&gt;&gt;&gt; [[(i,key,t) for t in value] for i,j in custom.items() for key,value in j.items()]
</code></pre>
<p>And if you want to get an iterator you can use a generator expression instead of list comprehension.</p>
<pre><code>&gt;&gt;&gt; ([(i,key,t) for t in value] for i,j in custom.items() for key,value in j.items())
</code></pre>
</div>
<span class="comment-copy">Thanks for replying. What is the difference between having <code>my_gen</code> in your solution and <code>custom_dict_iter</code> in @tdelaney's solution?</span>
<span class="comment-copy">@aarogon, You can define generators directly--without defining a function.  However, you can't rewind a generator, so if you want to get another generator later, I would go with  tdelaney's solution</span>
<span class="comment-copy">Doest that mean your solution works only once?</span>
<span class="comment-copy">@aaragon, You could always wrap a function around the direct generator syntax, e.g. <code>get_gen(...): return ( (key, subkey, np_array)...</code>.</span>
<span class="comment-copy">@aaragon, How about converting your data structure into something more friendly?  See the bottom of my answer.</span>
<span class="comment-copy">What you mean is that you would <code>yield d,k,row</code> I assume. Still isn't this too verbose? It's much better than what I have though.</span>
<span class="comment-copy">@aaragon You're right. I was fixated on <code>print(row)</code>. Fixed.</span>
<span class="comment-copy">@aaragon I don't think its too verbose because you want  to track and return the keys as well as the values. And compare it to overloading the C++ iterator, its pretty good.</span>
<span class="comment-copy">Your solution looks interesting. So I guess you mean that I crete a custom class that derives from dictionary, and that overrides the <code>__iter__</code> method, right?</span>
<span class="comment-copy">@aaragon You could do that, I guess. I'd probably just have the dictionary as a field.</span>
<span class="comment-copy">@aaragon, You aren't overriding: you just need to define both <code>__iter__()</code> and <code>__next__()</code> in your custom class.  <code>__iter__()</code> has just one line: <code>return self</code>.  Inside <code>__next__()</code> is where all the action happens. And, inside <code>__next__()</code>, you need to <code>raise StopIteration</code> when you decide that your iterator has hit the end of the data.   A for-in loop applied to an instance of your custom class will automatically catch a StopIteration exception and terminate.  That's how all for-in loops terminate.</span>
<span class="comment-copy">I think that's close to what @7stud did except that you've built it into an outer list. My solution breaks out the loops... and now I'm curious whether its slower.</span>
