<div class="post-text" itemprop="text">
<p>What is the default rounding mode (rounding to nearest, etc) in Python? And how can we specify it?</p>
</div>
<div class="post-text" itemprop="text">
<p>With IEEE754-based platform (as most modern ones do, including x86, ARM, MIPS...), it's default mode "round to nearest, ties to even" is the only mode available in Python standard library. That is "provided" by standardized defaults and absense of library methods to change it. There are more languages that doesn't allow to change rounding mode - e.g. Java - so this isn't an isolated Python whim.</p>
<p>In real, there are too few reasons to change this. Direct rounding modes of IEEE754 are very special in their use. (I don't apologize the approach to stick on the default rounding, but simply comment on it.) For example, multiply of 1e308 by 1e308 with rounding to zero or to minus infinity results in approximately 1.8e308, so, the result is too far both from the exact answer and from <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment" rel="noreferrer">POLA</a>-based one (infinity). If you really need some specific modes for your computations, consider using specific libraries, like MPFR or gmpy2.</p>
<p>If you insist on changing this without external modules specialized on floating-point calculations, try using C-library <code>fesetround</code> via <code>ctypes</code> module or analog, e.g. <a href="https://stackoverflow.com/questions/16000574/">here</a>. Again, it's your choice to use such hacks and become responsible to all consequences. I'd suggest wrapping all pieces with special rounding to C-level code which restores the default mode on function exit.</p>
</div>
<div class="post-text" itemprop="text">
<p>The accepted answer is not really correct. While floats are probably what first comes to mind when someone asks about rounding modes, they are not the place you should look.</p>
<p>The reason is simple: rounding is something you use to make your answer have a smaller number of digits. Whenever you mention digits, you must be sure what base you're talking about. I don't know about you specifically, but when people speak of digits, they usually mean <em>decimal</em> digits. For that purpose, floats are obviously inadequate, since they have <em>binary</em> digits. You cannot round a float <code>0.12</code> to one decimal digit because it doesn't make sense: despite the appearance, it doesn't have that kind of digits. :-)</p>
<p>Of course, what you can do, is try to compensate for the decimal inexactness of floats by rounding them so the overshoots and undershoots cancel each other in the best possible way, and in that context, it has been proven long ago that there is only one right answer, ROUND_HALF_EVEN---and it is provided by float (and by <code>round</code> function, if you need it on some higher decimal place) out of the box. But please note that it's not the same as 'calculating the mean grade' (ROUND_HALF_UP, usually), or 'estimating the mean error' (ROUND_UP), or 'giving you a tax grade (ROUND_FLOOR), or various other specific tasks which need some fixed number of decimal digits (or in case of some now defunct currencies, some other base, but usually not binary).</p>
<p>And in fact, there is a Python standard library module which gives you all the rounding modes you might find useful, and given the above paragraphs, it is the logical place to look: of course, it's the <code>decimal</code> module. It represents floating point numbers not in base 2, but in base 10, and as such, it offers the meaningful possibility to round a number to a given number of decimals, using a rounding method that makes sense for a particular task.</p>
<pre><code>&gt;&gt;&gt; import statistics, decimal
&gt;&gt;&gt; grades = map(decimal.Decimal, [4, 5])
&gt;&gt;&gt; print(statistics.mean(grades).to_integral_exact(decimal.ROUND_HALF_UP))
5
</code></pre>
<p>HTH.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've used these in the past without any negative effects:</p>
<pre><code>from math import floor, ceil

def round_floor(scale, x):
  return floor(x*(10**scale))/(10**scale)

def round_ceiling(scale,x):
  return ceil(x*(10**scale))/(10**scale)
</code></pre>
<p>but I haven't considered the implications for very large or very precise numbers.</p>
<pre><code>&gt;&gt;&gt; round_floor(1,123.456)
123.4
&gt;&gt;&gt; round_floor(-1,123.456)
120.0
&gt;&gt;&gt; round_floor(2,123.456)
123.45

&gt;&gt;&gt; round_ceiling(1,123.456)
123.5
&gt;&gt;&gt; round_ceiling(-1,123.456)
130.0
&gt;&gt;&gt; round_ceiling(-2,123.456)
200.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>round() is the built in fonction for rounding. it works as follows:</p>
<p>round(number[, ndigits])</p>
<p>it returns the float type number you are rounding with ndigits decimals</p>
<p>Values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0, and round(1.5) is 2). The return value is an integer if called with one argument, otherwise of the same type as number.</p>
<p>for limitations:
<a href="https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues" rel="nofollow">https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues</a></p>
<p>sources:
<a href="https://docs.python.org/3/library/functions.html" rel="nofollow">https://docs.python.org/3/library/functions.html</a></p>
</div>
<span class="comment-copy">If you want to be able to change floating-point rounding modes, Python is way higher-level than you should probably be using. I don't think there's even anything in NumPy for doing that.</span>
<span class="comment-copy">What is so "high level" about not having a proper rounding mode?</span>
<span class="comment-copy">I would say that the principle of least astonishment requires the mathematical result 1e616 being rounded to the greatest representable floating-point value below that number, and +inf is definitely not that. I would also be astonished if interval arithmetic did not soundly over-approximate the sets of values that could have been obtained with real computations.</span>
<span class="comment-copy">@PascalCuoq your attitude exposes even more that direct rounding is not for getting an approximate result, but for detecting a possible interval. For an exact value, even with an unusual rounding, making value which is closer to sqrt(x) instead of x and less by ~308 decimal magnitudes isn't ever admissible; but, for interval detecting, it's rather adequate.</span>
<span class="comment-copy">@RudyVelthuis could you please elaborate when this appeared and how the API is named?</span>
<span class="comment-copy">@Netch: When what appeared?</span>
