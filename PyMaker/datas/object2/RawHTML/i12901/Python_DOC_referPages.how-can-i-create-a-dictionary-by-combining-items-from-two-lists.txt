<div class="post-text" itemprop="text">
<pre><code>key_list=['number','alpha']
value_list=[['1','a'],['2','b']]
</code></pre>
<p>I want to collect elements in this pattern:</p>
<pre><code>dict = {}
dict.setdefault(key_list[0],[]).append(value_list[0][0])
dict.setdefault(key_list[0],[]).append(value_list[1][0])
dict.setdefault(key_list[1],[]).append(value_list[0][1])
dict.setdefault(key_list[1],[]).append(value_list[1][1])
</code></pre>
<p>How to do this in loop? </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow"><code>zip()</code></a> comes in very handy for this sort of thing:</p>
<pre><code>key_list=['number','alpha']
value_list=[['1','a'],['2','b']]
d = dict(zip(key_list, zip(*value_list)))
print(d)
</code></pre>
<p>Output</p>
<pre>
{'alpha': ('a', 'b'), 'number': ('1', '2')}
</pre>
<p>Basically this works by unpacking <code>values_list</code> so that the individual items (themselves lists) are passed as arguments to the <code>zip()</code> builtin function. This has the affect of collecting the numbers and alphas together. That new list is then zipped with <code>key_list</code> to produce another list. Finally a dictionary is created by calling <code>dict()</code> on the zipped list.</p>
<p>Note that this code does rely on the order of elements in <code>value_list</code>. It assumes that the numeric value always precedes the alpha value. It also produces a dictionary of <em>tuples</em> not <em>lists</em>. If that is a requirement then using a dict comprehension (as per thefourtheye's answer) allows you to convert the tuples to lists as the dictionary is built:</p>
<pre><code>key_list=['number','alpha']
value_list=[['1','a'],['2','b']]
d = {k: list(v) for k, v in zip(key_list, zip(*value_list))}
&gt;&gt;&gt; print(d)
{'alpha': ['a', 'b'], 'number': ['1', '2']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> the values of the <code>values_list</code> and then <code>zip</code> the result with the <code>key_list</code>, with dictionary comprehension, like this</p>
<pre><code>&gt;&gt;&gt; {k: v for k, v in zip(key_list, zip(*value_list))}
{'alpha': ('a', 'b'), 'number': ('1', '2')}
</code></pre>
<hr/>
<p>You can understand this, step-by-step, like this</p>
<pre><code>&gt;&gt;&gt; list(zip(*value_list))
[('1', '2'), ('a', 'b')]
</code></pre>
<p>Now, <code>zip</code>ping this with <code>key_list</code> will give us</p>
<pre><code>&gt;&gt;&gt; list(zip(key_list, zip(*value_list)))
[('number', ('1', '2')), ('alpha', ('a', 'b'))]
</code></pre>
<p>Now, you can either use <code>dict</code> function to create the dictionary, like shown by mhawke,</p>
<pre><code>&gt;&gt;&gt; dict(zip(key_list, zip(*value_list)))
{'alpha': ('a', 'b'), 'number': ('1', '2')}
</code></pre>
<p>or use the dictionary comprehension, as I have shown above.</p>
</div>
<span class="comment-copy">Thank You! but l don't understand why there is a '*' before value_list</span>
<span class="comment-copy">@Sbioer It <a href="https://docs.python.org/2/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">unpacks</a> the values of <code>value_list</code> and passes all of them as parameters to <code>zip</code> function.</span>
<span class="comment-copy">One more question. How to turn that tuple into a list?</span>
<span class="comment-copy">@Sbioer You can simply use <code>list</code> function to do it. For example: <code>list((1, 2, 3))</code> will give you <code>[1, 2, 3]</code>. But unless you want to keep updating the values in the dictionary, tuples would be better than lists.</span>
