<div class="post-text" itemprop="text">
<p>I would like to iterate cyclically over a list (or any other iterable for that matter), and I know you can do this with the <code>cycle</code> function from <code>itertools</code> (as shown <a href="https://stackoverflow.com/questions/8951020/pythonic-circular-list">here</a>), but this function loops indefinitely. I was wondering if there's a smart way to do this only once (and without using the modulo operator). </p>
<p>What I mean is that I would like to iterate over an iterable in such a way that the last item is the first one. So I would like to start iterating and stop whenever the iterator reaches the beginning of the iterable.</p>
<p>Something like this but less ugly:</p>
<pre><code>points = [1, 2, 3, 4, 5]
start = points[0]
iterator = cycle(points)

p = next(iterator)
while True:
    print(p)
    p = next(iterator)
    if p == start:
        print("quitting at", p)
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Could you explain what you're asking a bit better.
What do you mean with <code>cycle</code> and <code>only once</code>?</p>
<p>Isn't that just a <code>for item in list: do someting with item</code>?</p>
<p>EDIT: what I understood about the problem, was that you want to iterate over all the items starting from any index.
If so, then:</p>
<pre><code>lista = range(10)
idx = 5
for item in lista[idx:]+lista[:idx]:
    print item
</code></pre>
<p>Another Edit: ¿did I get the question right?
If what you're asking is stopping at the first item, then you just have iterate on the iterator for the remaining items (and maybe then rebuild the iterator?).</p>
<pre><code>points = [1,3,5,7,9]
iterator = iter(points)

iterator.next()        #Let's remove a couple of items
iterator.next()        #Let's remove a couple of items

for item in iterator:
    print(item)

iterator = iter(points)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sure, but with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>chain</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer"><code>repeat</code></a> (for <a href="https://docs.python.org/3.5/library/stdtypes.html#sequence-types-list-tuple-range" rel="nofollow noreferrer">sequences</a>) or <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>tee</code></a> (for <a href="https://docs.python.org/3.5/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">iterators</a>):</p>
<pre><code>&gt;&gt;&gt; from itertools import chain, repeat, tee
&gt;&gt;&gt; print(*chain(*repeat([1, 2, 3], 2)))
1 2 3 1 2 3

&gt;&gt;&gt; print(*chain(*tee(i for i in [1,2,3])))
1 2 3 1 2 3
</code></pre>
<p>Asterisk is used to <a href="https://docs.python.org/3.5/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">unpack argument lists</a>.</p>
<p><a href="https://stackoverflow.com/a/33925438/1916449">Answer by Ale</a> (chain without repeat) is even better if the iterable is already assigned to a variable and you need actually two cycles, as opposed to say, eight, or any other finite number.</p>
<h1>Update</h1>
<p>Code equivalent to the one in the updated question:</p>
<pre><code>points = [1, 2, 3, 4, 5]
for x in points:
    print(x)
print("quitting at", points[0])
</code></pre>
<p>Which is basically equivalent to <a href="https://stackoverflow.com/a/33925517/1916449">the original answer by Tomás Glaría</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you chain or concatenate the iterable?</p>
<pre><code>a = [1,2,3]

for x in a + a:
    print x

from itertools import chain, tee
for x in chain(tee(a, 2)):
    print x
</code></pre>
<p>That seems simple enough</p>
</div>
<span class="comment-copy">by once, you mean one copy?</span>
<span class="comment-copy">Can you give an example? If <code>foo</code> implements what you need, what would be the output of <code>for x in foo([1,2,3]): print(x)</code>?</span>
<span class="comment-copy">See updated question.</span>
<span class="comment-copy">See my updated answer and please explain how what you are trying to achieve is different from a basic for-loop. If it is not different, then this question is a possible duplicate of <a href="http://stackoverflow.com/questions/10929724/which-is-the-most-efficient-way-to-iterate-through-a-list-in-python">Which is the most efficient way to iterate through a list in python?</a>.</span>
<span class="comment-copy">If you define <code>points = [1, 2, 1, 4, 5]</code>, then your code outputs only the two first elements and "quitting at 1".  Is that your desired behavior? (mine would output <code>1 2 1 4 5</code> and "quitting at 1", so there's a difference here)</span>
<span class="comment-copy">This does not provide an answer to the question. To critique or request clarification from an author, leave a comment below their post. - <a href="/review/low-quality-posts/10338011">From Review</a></span>
<span class="comment-copy">I couldn't make a comment on the post, but now I can.</span>
<span class="comment-copy">Well he said he needed to cycle only once ;-)</span>
<span class="comment-copy">How is that equivalent? The criterion to break the loop is that you encounter the first node after cyclically iterating through the iterable.</span>
<span class="comment-copy">@aaragon It's equivalent in the sense that the output (the side effect) is the same. You can't complain that the mean to achieve your goal is different, since the better mean is what you are asking for. Instead you should refine your question to show that a for-loop is not a sufficient solution (if that's the case).</span>
<span class="comment-copy">Nonsense. My question states the problem very clearly. Besides, if I was able to write that code it's obvious I can come up with an answer as trivial as yours.</span>
<span class="comment-copy">@aaragon Your last comment is nonconstructive. Not to mention that it comes off as ungrateful and rude. If you came here for help, let us help you and refine your question so it explains why this "trivial" code is not good enough for you. While it is "very clear" to you, it apparently is not as clear to at least 5 other people.</span>
<span class="comment-copy">This will only work if the iterable supports iterating over it more than once.  Otherwise, when <code>chain</code> goes to iterate over it the second time, the iterable will be consumed.  The <i>fix</i> is to use <code>itertools.tee</code>.</span>
<span class="comment-copy">@mgilson I've just edited the answer to usa <code>tee</code>.</span>
