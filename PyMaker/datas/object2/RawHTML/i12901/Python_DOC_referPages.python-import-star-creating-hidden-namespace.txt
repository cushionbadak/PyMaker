<div class="post-text" itemprop="text">
<p>I recently ran into some unusual behavior.</p>
<p>foo.py</p>
<pre><code>a = 0
def bar():
    print (a)
</code></pre>
<p>Console:</p>
<pre><code>&gt;&gt;&gt; import foo
&gt;&gt;&gt; foo.bar()
0
&gt;&gt;&gt; foo.a = 10
&gt;&gt;&gt; foo.bar()
10
</code></pre>
<p>Console:</p>
<pre><code>&gt;&gt;&gt; from foo import *
&gt;&gt;&gt; bar()
0
&gt;&gt;&gt; a
0
&gt;&gt;&gt; a = 10
&gt;&gt;&gt; a
10
&gt;&gt;&gt; bar()
0
</code></pre>
<p>I'm inferring that <code>import *</code> is actually creating two copies of <code>a</code> - one in the global namespace and one inside the <code>foo</code> module which cannot be accessed.  Is this behavior explained/documented anywhere?  I'm having trouble figuring out what to search for.</p>
<p>This seems like a notable and unexpected consequence of <code>import *</code> but for some reason I've never seen it brought up before.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no such thing as a hidden namespace in Python and the described behaviour is the normal and expected one. </p>
<p>You should read <a href="https://docs.python.org/3/tutorial/modules.html#more-on-modules" rel="nofollow">https://docs.python.org/3/tutorial/modules.html#more-on-modules</a> in order to understand better how the globals do do work.</p>
</div>
<span class="comment-copy">This is a well defined behaviour, there's no hidden namespace, it's just that each function has knowledge about its module's globals. Globals in the current module won't affect the globals of an imported module. <a href="https://docs.python.org/3/tutorial/modules.html#more-on-modules" rel="nofollow noreferrer"><i>Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a userâ€™s global variables.</i></a></span>
<span class="comment-copy">There's essentially no such thing as a user-defined global in Python. There's a nasty hack to create true globals, which you should essentially never use, but anything you just define like <code>a = 10</code> is at most module-level.</span>
<span class="comment-copy">The original <code>a</code> from <code>foo</code> is part of that function's closure</span>
<span class="comment-copy">@user65 Exactly, but that doesn't mean if you override <code>a</code> in the current module the output of <code>bar</code> will also change. <code>bar()</code> will still get <code>a</code>'s value from <code>bar.__globals__</code>.</span>
<span class="comment-copy">Thanks, I have a much better understanding of how scope and importing works in Python now.</span>
