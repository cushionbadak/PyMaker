<div class="post-text" itemprop="text">
<p>This is something I think must come up quite often but I haven't been able to find a good solution for it. Say I have a function which may be passed an open resource as an argument (like a file or database connection object) or needs to create one itself. If the function needs to open a file on its own, best practice is usually considered something like:</p>
<pre class="lang-py prettyprint-override"><code>with open(myfile) as fh:
    # do stuff with open file handle...
</code></pre>
<p>to ensure the file is always closed when the <code>with</code> block is exited. However if an existing file handle is passed in the function should probably not close it itself.</p>
<p>Consider the following function which takes either an open file object <em>or</em> a string giving a path to the file as its argument. If it is passed a file path it should probably be written as above. Otherwise the <code>with</code> statement should be omitted. This results in duplicate code:</p>
<pre class="lang-py prettyprint-override"><code>def foo(f):
    if isinstance(f, basestring):
        # Path to file, need to open
        with open(f) as fh:
            # do stuff with fh...
    else:
        # Assume open file
        fh = f
        # do the same stuff...
</code></pre>
<p>This could of course be avoided by defining a helper function and calling it in both places, but this seems inelegant. A better way I thought of was to define a context manager class that wraps an object like so:</p>
<pre class="lang-py prettyprint-override"><code>class ContextWrapper(object):
    def __init__(self, wrapped):
        self.wrapped = wrapped
    def __enter__(self):
        return self.wrapped
    def __exit__(self, *args):
        pass

def foo(f):
    if isinstance(f, basestring):
        cm = open(f)
    else:
        cm = ContextWrapper(f)

    with cm as fh:
        # do stuff with fh...
</code></pre>
<p>This works but unless there's a built-in object that does this (I don't think there is) I either have to copy-paste that object everywhere or always have to import my custom utilities module. I'm feeling like there's a simpler way to do this that I've missed.</p>
</div>
<div class="post-text" itemprop="text">
<p>However, I prefer, I don't know how pythonic it is, but it's straightforward</p>
<pre><code>def foo(f):
    if isinstance(f, basestring):
        f = open(f)
    try:
        # do the stuff
    finally:
        f.close()
</code></pre>
<p>the problem could be solved nicer with <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow">singledispatch</a> from python 3.4 </p>
<pre><code>from functools import singledispatch

@singledispatch
def foo(fd):
    with fd as f:
        # do stuff
        print('file')

@foo.register(str)
def _(arg):
    print('string')
    f = open(arg)
    foo(f)


foo('/tmp/file1')  # at first calls registered func and then foo
foo(open('/tmp/file2', 'r'))  # calls foo
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This solution avoids an explicit boolean value like <code>f_own</code> (that is mentioned in a comment of the answer from @kAlmAcetA), and instead just checks the identity of the input parameter <code>f</code> to the file handle <code>fh</code>. A try/finally clause is the only way to do this without creating a helper class as a context manager.</p>
<pre><code>def foo(f):
    fh = open(f) if isinstance(f, basestring) else f

    try:
        # do stuff...
    finally:
        if fh is not f:
            fh.close()
</code></pre>
<p>If you need to do something like this in more than one function then, yes, you probably <em>should</em> create a utility module with a context manager class to do it, like this:</p>
<pre><code>class ContextWrapper(object):
    def __init__(self, file):
        self.f = file

    def __enter__(self):
        self.fh = open(self.f) if isinstance(self.f, basestring) else self.f
        return self.fh

    def __exit__(self, *args):
        if self.fh is not self.f:
            self.fh.close()
</code></pre>
<p>Then you could unconditionally wrap like this:</p>
<pre><code>def foo(f):
    with ContextManager(f) as fh:
        # do stuff...
</code></pre>
</div>
<span class="comment-copy">I can't think of a good reason to write code that would accept <i>either</i> a path <i>or</i> an open file handle. In that edge case, I'd recommend writing your own wrapper (as you've done)</span>
<span class="comment-copy">I'd argue that a helper function might be <i>more</i> elegant. A lot of the work you're doing in <code>foo</code> is to get the argument into the right type of object -- an open file handle. Factor out the code that does the core work into a helper that assumes an open file handle, and I think the overall result is more clear. Actually, the "helper" might be made a legitimate, public function in its own right, and "foo_from_path" simply calls "foo" after opening a file handler.</span>
<span class="comment-copy">@AdamSmith For what it's worth, this is a common design in, say, numpy. For example, <code>np.load</code> takes either a <a href="http://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.load.html" rel="nofollow noreferrer">string or a fileobj</a>. I suppose it's just there to make some code more concise, and since numpy is often used interactively, it's not unwise.</span>
<span class="comment-copy">@jme thanks for the context! :)</span>
<span class="comment-copy">If an open handle is given as input and an exception is thrown within <code>try:</code>, this will close the handle. That's fine, but a little strange I think -- does the function really have the authority to do that? One way to avoid this -- and this is what numpy does -- is to keep track of whether the function "owns" the file handle via boolean <code>f_own</code>. Then, in the <code>finally:</code> block, only close if <code>f_own</code> is True.</span>
