<div class="post-text" itemprop="text">
<p>I have a Flask view which uses SQLAlchemy to query and display some blog posts.  I am running my app using mod_wsgi.  This view works the first time I go to the page, but returns a 500 error next time.  The traceback shows the error <code>ProgrammingError: SQLite objects created in a thread can only be used in that same thread.</code>  Why am I getting this error and how do I fix it?</p>
<p><code>views.py</code></p>
<pre><code>engine = create_engine('sqlite:////var/www/homepage/blog.db')
Base.metadata.bind = engine
DBSession = sessionmaker(bind = engine)
session = DBSession()

@app.route('/blog')
@app.route('/blog.html')
def blog():
    entrys = session.query(Entry).order_by(desc(Entry.timestamp)).all()
    return render_template('blog.html', blog_entrys = entrys)
</code></pre>
<p><code>models.py</code>:</p>
<pre><code>class Entry(Base):
    __tablename__ = 'entry'

    id = Column(Integer, primary_key = True)

    title = Column(String(100), nullable = False)
    body = Column(String, nullable = False)
    timestamp = Column(DateTime, nullable = False)
    featured = Column(Boolean, nullable = False)

    comments = relationship('Comment')

    def is_featured(self):
        return self.featured


class Comment(Base):
    __tablename__ = 'comment'

    id = Column(Integer, primary_key = True)
    entry_id = Column(Integer, ForeignKey('entry.id'))

    text = Column(String(500), nullable = False)
    name = Column(String(80))


engine = create_engine('sqlite:////var/www/homepage/blog.db')
Base.metadata.create_all(engine)
</code></pre>
<pre><code>Exception on /blog.html [GET]
Traceback (most recent call last):
  File "/usr/lib/python2.6/dist-packages/flask/app.py", line 861, in wsgi_app
    rv = self.dispatch_request()
  File "/usr/lib/python2.6/dist-packages/flask/app.py", line 696, in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
  File "/var/www/homepage/webserver.py", line 38, in blog
    entrys = session.query(Entry).order_by(desc(Entry.timestamp)).all()
  File "/usr/lib/python2.6/dist-packages/sqlalchemy/orm/query.py", line 1453, in all
    return list(self)
  File "/usr/lib/python2.6/dist-packages/sqlalchemy/orm/query.py", line 1565, in __iter__
    return self._execute_and_instances(context)
  File "/usr/lib/python2.6/dist-packages/sqlalchemy/orm/query.py", line 1570, in _execute_and_instances
    mapper=self._mapper_zero_or_none())
  File "/usr/lib/python2.6/dist-packages/sqlalchemy/orm/session.py", line 735, in execute
    clause, params or {})
  File "/usr/lib/python2.6/dist-packages/sqlalchemy/engine/base.py", line 1157, in execute
    params)
  File "/usr/lib/python2.6/dist-packages/sqlalchemy/engine/base.py", line 1235, in _execute_clauseelement
    parameters=params
  File "/usr/lib/python2.6/dist-packages/sqlalchemy/engine/base.py", line 1348, in __create_execution_context
    None, None)
  File "/usr/lib/python2.6/dist-packages/sqlalchemy/engine/base.py", line 1343, in __create_execution_context
    connection=self, **kwargs)
  File "/usr/lib/python2.6/dist-packages/sqlalchemy/engine/default.py", line 381, in __init__
    self.cursor = self.create_cursor()
  File "/usr/lib/python2.6/dist-packages/sqlalchemy/engine/default.py", line 523, in create_cursor
    return self._connection.connection.cursor()
  File "/usr/lib/python2.6/dist-packages/sqlalchemy/pool.py", line 383, in cursor
    c = self.connection.cursor(*args, **kwargs)
ProgrammingError: (ProgrammingError) SQLite objects created in a thread can only be used in that same thread.The object was created in thread id 140244498364160 and this is thread id 140244523542272 None [{}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>SQLAlchemy (and in this case SQLite also) doesn't work if you share a session across threads.  You may not be using threads explicitly, but <code>mod_wsgi</code> is, and you've defined a global <code>session</code> object.  Either use <a href="http://docs.sqlalchemy.org/en/latest/orm/contextual.html" rel="noreferrer"><code>scoped_session</code></a> to handle creating a unique session for each thread.</p>
<pre><code>session = scoped_session(sessionmaker(bind=engine))

@app.teardown_request
def remove_session(ex=None):
    session.remove()

@app.route('/')
def example():
    item = session.query(MyModel).filter(...).all()
    ...
</code></pre>
<p>Preferably, use <a href="http://flask-sqlalchemy.pocoo.org/" rel="noreferrer">Flask-SQLAlchemy</a> which handles this and other things for you.  The SQLAlchemy docs recommend you use the integration library rather than doing this yourself.</p>
<pre><code>db = SQLAlchemy(app)

@app.route('/')
def example():
    item = db.session.query(MyModel).filter(...).all()
    ...
</code></pre>
<p>Also note that you should only be defining the engine, session, etc. once and importing it elsewhere, rather than redefining it in each file like your current code does.</p>
</div>
<div class="post-text" itemprop="text">
<p>Taking a hint from <a href="https://stackoverflow.com/a/39024742/408556">this SO answer</a> I searched SA docs and found out you can do this:</p>
<pre><code>engine = create_engine('sqlite:////var/www/homepage/blog.db?check_same_thread=False')
</code></pre>
<p><code>scoped_session</code> wasn't really suitable in my case since Flask-SQLAlchemy only takes a connection string argument:</p>
<pre><code>from flask import Flask
from flask_sqlalchemy import SQLAlchemy


class Config(object):
    SQLALCHEMY_DATABASE_URI = 'sqlite:///app.db?check_same_thread=False'


db = SQLAlchemy()


def create_app():
    app.config.from_object(Config)
    app = Flask(__name__)
    db.init_app(app)
    ...
</code></pre>
<p>According to <a href="https://docs.python.org/3/library/sqlite3.html#sqlite3.connect" rel="nofollow noreferrer"><code>sqlite3.connect</code></a>:</p>
<blockquote>
<p>By default, <code>check_same_thread</code> is <code>True</code> and only the creating thread may
  use the connection. If set <code>False</code>, the returned connection may be
  shared across multiple threads. <strong>When using multiple threads with the
  same connection writing operations should be serialized by the user to
  avoid data corruption.</strong></p>
</blockquote>
</div>
