<div class="post-text" itemprop="text">
<p>I'm writing a custom backup script in Python. Sometimes the mkdir function or the print function or whatever function are failing for diverse reasons. Such exceptions stop the whole script and halt the backup in the middle, which is very frustrating. So far, I've managed these problems by adding try: ... except: ... statements and properly managing these exceptions. However, one day some other statement or function might raise an exception as well because of some other reason that hasn't been triggered yet.</p>
<p>Is there a way to tell a script to proceed <em>anyway</em>? An equivalent of wrapping every single statement of the code in a try: ... except: pass clause? A log would be better of course.</p>
<p>I've noticed that when programming with GUI toolkits like Tkinter, the application keeps running even if exceptions are raised. Is it possible to accomplish this type of thing with the console?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has no way of doing that, and for good reasons.</p>
<p>It seems you're confused about what does it mean to write "robust" software: a robust program is not a program that is <strong>hard to kill</strong> and that will keep running no matter what, but a program that will handle edge cases properly. Keeping running is NOT enough... keeping running <strong>doing sensible things</strong> is the key point.</p>
<p>Unfortunately there's no way to do reasonable things automatically and you've to think on a case-by-case basis how to handle the error.</p>
<p>Beware that if a program has a lot of <code>catch</code> it's rarely a good program. Exceptions are meant to be raised in a lot of places and caught almost nowhere.</p>
<p>Note also that every <code>catch</code> is potentially a source of bugs... for example:</p>
<pre><code>try:
    print my_dict[foo()]
except KeyError:
    ...
</code></pre>
<p>cannot distinguish if the <code>KeyError</code> is coming for accessing a non-existing key in <code>my_dict</code> or if instead escaped from <code>foo()</code>. Rarely the two cases should be handled the same way...</p>
<p>Better is to write:</p>
<pre><code>key = foo()
if key in my_dict:
    print my_dict[key]
else:
    ...
</code></pre>
<p>so that only the side case of missing key in <code>my_dict</code> is handled and instead a <code>KeyError</code> exception will stop the program (stopping a program when you're not sure of what it's doing is the only reasonable thing to do).</p>
</div>
<div class="post-text" itemprop="text">
<p>There actually is a module that is supposed to do exactly that: <a href="https://github.com/ajalt/fuckitpy" rel="nofollow">https://github.com/ajalt/fuckitpy</a>.</p>
<p>Although it was obviously written as a joke. I cannot imagine a situation where doing something like that is a good idea. God, I can't believe I'm even suggesting that as a solution.</p>
<p>What you should do instead is identify what lines of code can produce what kind of errors, and handle those errors <em>properly</em>. There is only so much places where errors can actually happen - mostly while interfacing with outside systems, including filesystem, network, user input etc. And remember that actually failing is often better than continuing "work" and messing up your data, files and so on. Exceptions are there for a reason, they are not a result of Guido's malice.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has 'BaseException' as the base class for Exception classes. You can catch and ignore the base class Exception and that will cover all exceptions.</p>
<pre><code>try
    ... your code here ...
except BaseException as exp:
    print "A General Exception Occurred"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Normally, this one should catch everything:</p>
<pre><code>try:
   ....
except:
   pass
</code></pre>
<p>Only problem is, that you don't get the exception object with this syntax, but that was not asked for in this case.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can add a general except block like @Kanwar Saad proposed. The question is, can you continue with your program in a valid state after the exception has been raised?</p>
<p>From the Zen of Python:</p>
<pre><code>Errors should never pass silently.
Unless explicitly silenced.
</code></pre>
<p>Trying to catch all exceptions you know is in my opinion is the best way to go here. If you can not explicitly catch an exception you should not try to work around it. You (and your users) should know what exactly went wrong, otherwise your code might become a nightmare to debug.</p>
<p>If you are worried about losing backup data maybe you could do something like this:</p>
<pre><code>def save_unfinished_backup():
    # try to find a graceful exit without losing any data

try:
    # some code
except OSError:
    # handle oS Errors
except Exception:
    save_unfinished_backup()
    raise
</code></pre>
<p>This way you get both: A chance to fend of data loss and the exact error to debug it.</p>
<p>I hope this helps!</p>
<hr/>
<p>On a funny note: You could also use the <a href="https://pypi.python.org/pypi/fuckit" rel="nofollow">fuckit</a> module. Which silences <strong>ALL</strong> errors, including syntax errors. Do not, ever, use this in productive code though.</p>
<p>This should work perfectly. It will not print the "foo", but you will reach the <code>print("bar")</code> without a crash.</p>
<pre><code>import fuckit

with fuckit:
    prnt("foo")

print("bar")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>try:
   # code segment
except:
   pass
</code></pre>
<p><strong>pass</strong> keyword will ignore all the exceptions</p>
</div>
<span class="comment-copy">Instead of wrapping every statement in <code>try...except</code> blocks, you should probably be doing more validation and testing in your code. If a function depends on an input list with 5 items, test that the list <i>has</i> 5 items.</span>
<span class="comment-copy">That's somewhat un-pythonic - as it's directly goes against "Easier to Ask Forgiveness that Permission".</span>
<span class="comment-copy">What you're asking doesn't make any sense. Say the mkdir function failed; if you ignored the exception, what would you expect the code that was intending to use that directory to do?</span>
<span class="comment-copy">@TomDalton: Just what I was thinking! See <a href="https://docs.python.org/2/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a> vs. <a href="https://docs.python.org/2/glossary.html#term-lbyl" rel="nofollow noreferrer">LBYL</a>.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/4990718/python-about-catching-any-exception">Python: about catching ANY exception</a></span>
<span class="comment-copy">"Easier to ask for forgiveness than permission. This common Python coding style assumes the existence of valid keys or attributes and catches exceptions if the assumption proves false. This clean and fast style is characterized by the presence of many try and except statements. The technique contrasts with the LBYL style common to many other languages such as C." ~ python docs</span>
<span class="comment-copy">Except a few special ones like KeyboardInterrupt - see <a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" rel="nofollow noreferrer">docs.python.org/3/library/exceptions.html#exception-hierarchy</a></span>
<span class="comment-copy">But really if you're swallowing keyboard interrupts what ARE you writing? :-)</span>
<span class="comment-copy">BaseException will cover all ... I have updated the answer</span>
