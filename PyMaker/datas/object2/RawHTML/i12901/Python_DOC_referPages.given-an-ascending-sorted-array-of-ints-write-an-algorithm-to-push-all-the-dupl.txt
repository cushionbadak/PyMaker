<div class="post-text" itemprop="text">
<p>I tired doing this in python but my attempted solution is wrong ( it doesn't work for more than 2 duplicates). I'm triyng to avoid using collections or built in modules, becuase I want to understand the logic for a potential interview question. HELP</p>
<pre><code>array=[1,2,2,4,5,5]
sett=list(set(array))      
print(sett+[x for x in sett if array.count(x)&gt;1 ])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This seems a bit brute force but it works without using any imports, etc.</p>
<pre><code># assumes list a is in sorted order
# if not true then sort it first
a=[1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6]
b = []
c = []
for elem in a:
    if b.count(elem) == 0:
        b.append(elem)
    else:
        c.append(elem)
d = b + c
print(d)

[1, 2, 3, 4, 5, 6, 2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6]
</code></pre>
<p>EDIT: I took another look at this and there is a simple change that will make it O(n^1) instead of O(n^2) in time.</p>
<pre><code># slight modification for speed
a=[1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6]
b = []
c = []
for elem in a:
    if elem not in b[-1:]: # change: look at last element in b only
        b.append(elem)
    else:
        c.append(elem)
d = b + c
print(d)

[1, 2, 3, 4, 5, 6, 2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6]
</code></pre>
<p>I ran %timeit comparing the two, summarized in below table.</p>
<pre><code>N = list length
sort_1 = first code
sort_2 = second code
results are in seconds

    N     sort_1      sort_2
  300   0.000409    0.000104
 3000   0.035600    0.001080
30000   3.540000    0.010900
</code></pre>
<p>Results show sort_1 is O(n^2) while sort_2 is O(n^1) with respect to time, with just that minor modification.</p>
</div>
<div class="post-text" itemprop="text">
<p>Ignoring your request to not use builtin modules...</p>
<p>If you borrow the roundrobin implementation from the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">itertools recipes</a>. It's a one liner. </p>
<pre><code>&gt;&gt;&gt; from itertools import groupby, cycle, islice
&gt;&gt;&gt; def roundrobin(*iterables):
...     "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
...     # Recipe credited to George Sakkis
...     pending = len(iterables)
...     nexts = cycle(iter(it).__next__ for it in iterables)
...     while pending:
...         try:
...             for next in nexts:
...                 yield next()
...         except StopIteration:
...             pending -= 1
...             nexts = cycle(islice(nexts, pending))
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; array = [1, 2, 2, 4, 5, 5]
&gt;&gt;&gt; list(roundrobin(*(list(g) for k, g in groupby(array))))
[1, 2, 4, 5, 2, 5]
&gt;&gt;&gt; array = [1, 2, 2, 2, 4, 5, 5]
&gt;&gt;&gt; list(roundrobin(*(list(g) for k, g in groupby(array))))
[1, 2, 4, 5, 2, 5, 2]
</code></pre>
<p>Yay itertools</p>
<p>The intermediate step is to create this data structure that is needed by <code>roundrobin</code></p>
<pre><code>&gt;&gt;&gt; [list(g) for k, g in groupby(array)]
[[1], [2, 2, 2], [4], [5, 5]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edit:</strong> quick summary: because the list is already sorted (ascending or descending doesn't matter, either guarantees that all equal values occur together), at each point in the list we only need to track the previously seen value (prev) and the current value (val).</p>
<ul>
<li><p>if prev and val are the same, then val is a duplicate; it gets appended to the list of duplicate values</p></li>
<li><p>otherwise val is the initial occurence; it gets appended to a list of initial values, and prev gets updated for the next comparison</p></li>
<li><p>when we have processed the entire list, we return (all initial values) + (all duplicates)</p></li>
</ul>
<p>So, </p>
<pre><code>def reorder_duplicates(sorted_lst):
    if sorted_lst:
        prev = sorted_lst[0] - 1
        init, dups = [], []
        for val in sorted_lst:
            if val == prev:
                dups.append(val)
            else:
                init.append(val)
                prev = val
        return init + dups
    else:
        return []
</code></pre>
<p>This is O(n), where your solution is O(n**2) (because <code>list.count()</code> is O(n)).</p>
<p>Also, as John La Rooy points out, <code>x for x in sett</code> fails if values appear more than twice; you would have to use <code>x for x in array</code> instead.</p>
<p>Be aware that the result of  <code>list(set(sorted_lst))</code> is not necessarily in sorted order! You would have to use <code>sorted(set(sorted_lst))</code> instead, which is O(n log n).</p>
<p>If you want to match John La Rooy's output (all first occurrences, then all second occurrences, etc) you can apply this function recursively like <code>return init + reorder_duplicates(dups)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try</p>
<pre><code>import collections
l = [1,2,2,4,5,5]
d = sorted(list(set(l)))
print d+[item for item, count in collections.Counter(l).items() if count &gt; 1]
</code></pre>
<p>Output </p>
<pre><code>[1, 2, 4, 5, 2, 5]
</code></pre>
<p>Or</p>
<pre><code>l = [1,2,2,4,5,5]
d = sorted(list(set(l)))
dup = list(set([x for x in l if l.count(x) &gt; 1]))
print d+dup
</code></pre>
<p>Output-</p>
<pre><code>[1, 2, 4, 5, 2, 5]
</code></pre>
<p>EDIT-</p>
<hr/>
<p>Did not discard the previous-
Just correct and <strong>one liner</strong> but with built-in modules-</p>
<pre><code>&gt;&gt;&gt;from  itertools import  groupby
&gt;&gt;&gt;l = [1,2,2,2,4,5,5,2,44]
&gt;&gt;&gt;print sorted(set(l))+[it for sb in [i[1:] for i in [(list(v)) for k,v in groupby(l)]] for it in sb]
&gt;&gt;&gt;[1, 2, 4, 5, 44, 2, 2, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a straightforward way without importing anything</p>
<pre><code>&gt;&gt;&gt; array = [1, 2, 2, 2, 4, 5, 5]
&gt;&gt;&gt; 
&gt;&gt;&gt; b = []
&gt;&gt;&gt; for item in array:
...     if not b or  b[-1][0] != item:
...         b.append([item])
...     else:
...         b[-1].append(item)
... 
&gt;&gt;&gt; c = []
&gt;&gt;&gt; while b:
...     for item in b:
...         c.append(item.pop())
...     b = [x for x in b if x]
... 
&gt;&gt;&gt; c
[1, 2, 4, 5, 2, 5, 2]
</code></pre>
<p>But worst case is O(n^2) if all the quantities are different</p>
</div>
<span class="comment-copy">What should happen for <code>[1,2,2,2,4,5,5]</code>?</span>
<span class="comment-copy">@JohnLaRooy yeah I realized I totally hard-coded this... lmao. Trying again</span>
<span class="comment-copy">Is the array always in sorted order?</span>
<span class="comment-copy"><code>list(set(array))</code> doesn't guarantee any particular order!</span>
<span class="comment-copy">The list comprehension is O(n^2), so not very good.</span>
<span class="comment-copy">This is also O(n^2) time complexity</span>
<span class="comment-copy">True, but it meets the requirements of the poster...doesn't it?</span>
<span class="comment-copy">@John La Rooy thanks for pointing this out and please see update.</span>
<span class="comment-copy">@SteveMisuta Hey man, can you explain why the modification to the 2nd solution changes it from O(n^2) to O(n).</span>
<span class="comment-copy">@Angular in the 1st solution: for every element in list 'a', we traverse the list again with count() method. So n elements in list 'a' get n operations and that makes n*n or O(n^2). In the 2nd solution, we only look at every element in list 'a' once in the outer loop, and check the most recent element once instead of using the count() method.</span>
<span class="comment-copy">One-liner? I see a lot more than one line there...</span>
<span class="comment-copy">The part <i>I</i> wrote is one line :) And it  has time complexity O(n)</span>
<span class="comment-copy">The OP would have to write all those other lines in the interview, though (and, as you mention, ignoring the fact that this imports a module).</span>
<span class="comment-copy">This is an interesting answer; it gives all first-duplicates, followed by all second-duplicates, followed by all third-duplicates etc. I am not sure that was what he wanted; on the other hand, it may well be what he was actually asked for ;-)</span>
<span class="comment-copy">@HughBothwell, I guess I will see if I get offered the job :)</span>
<span class="comment-copy">ugh, my head hurts aha. Total beginner in python</span>
<span class="comment-copy"><code>NameError: global name 'lst' is not defined</code></span>
<span class="comment-copy">@sislam: sorry, refactoring variable names on my tablet; should be fixed now.</span>
<span class="comment-copy">what does if sorted_lst do? Man I feel so stupid that I can't understand simple problems like these. How am i gonna even pass an interview...</span>
<span class="comment-copy">Oh okay makes sense. Hey man can you like comment or explain the procedure/ logic behind this solution. Like I got lost trying to understand the point of line 3. Sorry I'm a slow learner</span>
<span class="comment-copy">"I'm triyng to avoid using collections or built in modules"</span>
<span class="comment-copy">@TigerhawkT3, but the logic is questionable. Who wants to hire someone that doesn't use any builtin modules?</span>
<span class="comment-copy">So it's fine to use built- in modules in an interview? I know it makes things easier, but I thought they want people to write the code step-by step without making it trival! Idk never really had a software interview before</span>
<span class="comment-copy">@JohnLaRooy - I would guess that the idea is to test the interviewee's grasp of algorithms.</span>
<span class="comment-copy">the d+dup solution doesn't work if l = [1,2,2,2,4,5,5]</span>
