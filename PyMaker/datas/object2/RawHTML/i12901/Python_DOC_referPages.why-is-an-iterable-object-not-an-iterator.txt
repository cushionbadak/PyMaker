<div class="post-text" itemprop="text">
<p>Here is my code:   </p>
<pre><code>from collections import deque

class linehistory:
    def __init__(self, lines, histlen=3):
        self.lines = lines
        self.history = deque(maxlen=histlen)

    def __iter__(self):
        for lineno, line in enumerate(self.lines,1):
            self.history.append((lineno, line))
            yield line

    def clear(self):
        self.history.clear()


f = open('somefile.txt')
lines = linehistory(f)
next(lines)
</code></pre>
<p>Error:</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    TypeError: 'linehistory' object is not an iterator
</code></pre>
<p>I have no idea why the <code>linehistory</code> object is not an iterator since it has already included <code>__iter__</code> method in <code>the</code> class.</p>
</div>
<div class="post-text" itemprop="text">
<p>In short, "iterable" is the object I want to iterate over. It has <code>__iter__()</code>.</p>
<p>However, "iterator" is the object which is used for iteration. It has <code>next()</code> or <code>__next__()</code>. As any iterator is iterable as well (being its own iterator), it has <code>__iter__()</code> as well.</p>
<p>You can get an iterator for any iterable with <code>iter(obj)</code>.</p>
<p>In your example, <code>linehistory</code> (which should be written <code>LineHistory</code>) is iterable as it has an <code>.__iter__()</code>. The generator object created with this is an iterator (as every generator object).</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I have no idea why the linehistory object is not an iterator since it has already included <code>__iter__</code> method in the class.</p>
</blockquote>
<p>Wrong. See <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow">Iterator Types</a>:</p>
<blockquote>
<p>The iterator objects themselves are required to support the following two methods, which together form the iterator protocol:</p>
<p><code>iterator.__iter__()</code><br/>
  Return the iterator object itself. This is required to allow both containers and iterators to be used with the for and in statements. This method corresponds to the tp_iter slot of the type structure for Python objects in the Python/C API.</p>
<p><code>iterator.__next__()</code><br/>
  Return the next item from the container. If there are no further items, raise the StopIteration exception. This method corresponds to the tp_iternext slot of the type structure for Python objects in the Python/C API.</p>
</blockquote>
<p>However you can iterate over <code>lines</code>, that's because your <code>__iter__</code> method is a generator function, see <a href="https://docs.python.org/3/library/stdtypes.html#generator-types" rel="nofollow">Generator Types</a>:</p>
<blockquote>
<p>Python’s generators provide a convenient way to implement the iterator protocol. If a container object’s <code>__iter__()</code> method is implemented as a generator, it will automatically return an iterator object (technically, a generator object) supplying the <code>__iter__()</code> and <code>__next__()</code> methods. More information about generators can be found in the documentation for the yield expression.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Iterator objects need an <code>__iter__</code> method but they also need to have <code>next</code> implemented:</p>
<blockquote>
<p>The iterator objects themselves are required to support the following two methods, which together form the iterator protocol:</p>
<p>iterator.__iter__()<br/>
  Return the iterator object itself. </p>
<p>iterator.next()<br/>
  Return the next item from the container. </p>
</blockquote>
<p><a href="https://docs.python.org/2/library/stdtypes.html#iterator-types" rel="nofollow">Python 2.7 Source</a></p>
<p>In Python 3.x these are the function names:</p>
<blockquote>
<p>iterator.__iter__()  </p>
<p>iterator.__next__()</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow">Python 3.x Source</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Actually,</p>
<p><strong>All these other answers are wrong</strong> (except for @glglgl who has an obtuse style of writing). Your generator function <code>__iter__()</code> would work as is if you called it with a <code>for</code> loop like so</p>
<pre><code>for line in lines:
    print(line)
</code></pre>
<p>But because you used <code>next(lines)</code> you have to first use <code>iter()</code> to get the iterator (I presume it just calls <strong>iter</strong>() on the object) like so</p>
<pre><code>it = iter(lines)
print(next(it))
</code></pre>
<p>as <a href="https://www.safaribooksonline.com/library/view/python-cookbook-3rd/9781449357337/ch04.html#_defining_generator_functions_with_extra_state" rel="nofollow noreferrer">Mr.Beazley points out</a></p>
</div>
<span class="comment-copy">You also need to define a <code>next()</code> method (or <code>__next__()</code> for Python 3).</span>
<span class="comment-copy"><code>__next__</code> method missing: <a href="http://pymbook.readthedocs.org/en/latest/igd.html#iterators" rel="nofollow noreferrer">pymbook.readthedocs.org/en/latest/igd.html#iterators</a></span>
<span class="comment-copy">An <code>__iter__</code> method makes your object an <a href="https://docs.python.org/3.5/library/collections.abc.html#collections.abc.Iterable" rel="nofollow noreferrer">iterable</a>, while a <code>__next__</code> method makes it an <a href="https://docs.python.org/3.5/library/collections.abc.html#collections.abc.Iterator" rel="nofollow noreferrer">iterator</a>. Use <code>lines = iter(linehistory(f))</code> and you'll be fine.</span>
<span class="comment-copy">See also: <a href="http://stackoverflow.com/q/9884132/296974">stackoverflow.com/q/9884132/296974</a></span>
<span class="comment-copy">Yep. works for me.</span>
