<div class="post-text" itemprop="text">
<p>I'm trying to figure out how to simply start a number of long running shell commands in a non-blocking way, and asynchronously handle their output when they finish, <strong>in the order they finish</strong>, even if that is another order than they started, using the asyncio python library available in Python 3.4 and forward.</p>
<p>I couldn't find a simple example of doing this, even in the <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow">asyncio documentation itself</a>, which also seems to be quite low-level.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://stackoverflow.com/a/23616229/4279"><code>get_lines()</code></a> coroutines, to get shell commands output asynchronously and pass the coroutines to <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed" rel="nofollow noreferrer"><code>asyncio.as_completed()</code></a>, to get the results in the order they finish:</p>
<pre><code>#!/usr/bin/env python3.5
import asyncio
import sys
from asyncio.subprocess import PIPE, STDOUT

async def get_lines(shell_command):
    p = await asyncio.create_subprocess_shell(shell_command,
            stdin=PIPE, stdout=PIPE, stderr=STDOUT)
    return (await p.communicate())[0].splitlines()

async def main():
    # get commands output concurrently
    coros = [get_lines('"{e}" -c "print({i:d}); import time; time.sleep({i:d})"'
                       .format(i=i, e=sys.executable))
             for i in reversed(range(5))]
    for f in asyncio.as_completed(coros): # print in the order they finish
        print(await f)


if sys.platform.startswith('win'):
    loop = asyncio.ProactorEventLoop() # for subprocess' pipes on Windows
    asyncio.set_event_loop(loop)
else:
    loop = asyncio.get_event_loop()
loop.run_until_complete(main())
loop.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.create_subprocess_shell" rel="nofollow"><code>create_subprocess_shell</code></a> is what you are looking for. It will return a <code>Process</code> instance, which you can <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.asyncio.subprocess.Process.wait" rel="nofollow"><code>wait()</code></a> on, or <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.asyncio.subprocess.Process.communicate" rel="nofollow"><code>communicate()</code></a> with.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have exactly the same situation as yours. In my case, I am running multiple <code>git fetch</code> command in several repo directories.</p>
<p>In the first trial, the code looks like this (and <code>cmds</code> is <code>['git', 'fetch']</code>):</p>
<pre><code>async def run_async(path: str, cmds: List[str]):
    process = await asyncio.create_subprocess_exec(*cmds, cwd=path)
    await process.wait()
</code></pre>
<p>This function works on one repo, and the caller creates tasks for multiple repos and runs an event <code>loop</code> to complete them.</p>
<p>Although the program runs and the outcome on disk is correct, the <code>fetch</code> outputs from different repos are interleaved. The reason is that <code>await process.wait()</code> could give back control to the caller (the loop scheduler) any time IO blocks (file, network, etc).  </p>
<p>A simple change fixes it:</p>
<pre><code>async def run_async(path: str, cmds: List[str]):
    """
    Run `cmds` asynchronously in `path` directory
    """
    process = await asyncio.create_subprocess_exec(
        *cmds, stdout=asyncio.subprocess.PIPE, cwd=path)
    stdout, _ = await process.communicate()
    stdout and print(stdout.decode())
</code></pre>
<p>Here the rationale is to redirect the <code>stdout</code> so that it's in one place. In my case, I simply print it out. If you need the output, you can return it in the end.</p>
<p>Also, the printing order may not be the same as the start order, which is fine in my case.</p>
<p>The source code is <a href="https://github.com/nosarthur/gita/blob/master/gita/utils.py#L133" rel="nofollow noreferrer">here on github</a>. To give some context, that project is a command line tool to manage multiple git repos, which delegates git command execution from any working directory. There are less than 200 lines of code and it should be an easy read.</p>
</div>
