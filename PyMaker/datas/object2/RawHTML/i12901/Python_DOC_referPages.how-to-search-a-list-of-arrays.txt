<div class="post-text" itemprop="text">
<p>Consider the following list of two arrays:</p>
<pre><code>from numpy import array

a = array([0, 1])
b = array([1, 0])

l = [a,b]
</code></pre>
<p>Then finding the index of <code>a</code> correctly gives</p>
<pre><code>l.index(a)
&gt;&gt;&gt; 0
</code></pre>
<p>while this does not work for <code>b</code>:</p>
<pre><code>l.index(b)
ValueError: The truth value of an array with more than one element is ambiguous. 
Use a.any() or a.all()
</code></pre>
<p>It seems to me, that calling a list's <code>.index</code> function is not working for lists of numpy arrays. </p>
<p>Does anybody know an explanation? 
Up to now, I always solved this problem kind of daggy by converting the arrays to strings. Does someone know a more elegant and fast solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>The good question is in fact how <code>l.index[a]</code> can return a correct value. Because numpy arrays treat equality in a special manner: <code>l[1] == b</code> returns an array and not a boolean, by comparing individual values. Here it gives <code>array([ True,  True], dtype=bool)</code> which cannot be directly converted to a boolean, hence the error.</p>
<p>In fact, Python uses rich comparison and specifically <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool" rel="nofollow">PyObject_RichCompareBool</a> to compare the searched value to every element of the list is sequence, that means that it first test identity (<code>a is b</code>) and next equality (<code>a == b</code>). So for the first element, as <code>a is l[0]</code>, identity is true and index 0 is returned.</p>
<p>But for any other element, identity with first element is false, and the equality test causes the error. (thanks to Ashwini Chaudhary for its nice explaination in comment).</p>
<p>You can confirm it by testing a new copy of an array containing same elements as <code>l[0]</code>:</p>
<pre><code>d = array([0,1])
l.index(d)
</code></pre>
<p>it gives the same error, because identity is false, and the equality test raises the error.</p>
<p>It means that you cannot rely on any list method using comparison (index, in, remove) and must use custom functions such as the one proposed by @orestiss. Alternatively, as a list of numpy arrays seems hard to use, you should considere wrapping the arrays:</p>
<pre><code>&gt;&gt;&gt; class NArray(object):
    def __init__(self, arr):
        self.arr = arr
    def array(self):
        return self.arr
    def __eq__(self, other):
        if (other.arr is self.arr):
            return True
        return (self.arr == other.arr).all()
    def __ne__(self, other):
        return not (self == other)


&gt;&gt;&gt; a = array([0, 1])
&gt;&gt;&gt; b = array([1, 0])
&gt;&gt;&gt; l = [ NArray(a), NArray(b) ]
&gt;&gt;&gt; l.index(NArray(a))
0
&gt;&gt;&gt; l.index(NArray(b))
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This error comes from the way numpy treats comparison between array elements see : <a href="https://stackoverflow.com/questions/10062954/valueerror-the-truth-value-of-an-array-with-more-than-one-element-is-ambiguous">link</a>,</p>
<p>So I am guessing that since the first element is the instance of the search you get the index for it, but trying to compare the first element with the second you get this error.</p>
<p>I think you could use something like: </p>
<p><code>[i for i, temp in enumerate(l) if (temp == b).all()]</code> </p>
<p>to get a list with the indices of equal arrays but since I am no expert in python there could be a better solution (it seems to work...)</p>
</div>
<span class="comment-copy">For a list of identical shaped arrays, you can have a NumPythonic search : <code>np.nonzero((l == b).all(1))[0][0]</code>.</span>
<span class="comment-copy">This happens because <code>.index()</code> first compares identity and then equality, it worked for <code>a</code> because <code>a is l[0]</code> is <code>True</code>, but when it comes to finding <code>b</code> it ends up with <code>b == l[0]</code>, and now Python calls <code>bool()</code> on it: <code>bool(b == l[0])</code>.  So, <code>l.index(array([0, 1]))</code> will also raise the same error. I have explained it here: <a href="http://stackoverflow.com/a/28815970/846892">stackoverflow.com/a/28815970/846892</a></span>
<span class="comment-copy">Hi, this question duplicate has already been answered, <a href="http://stackoverflow.com/a/1156114/4061269">stackoverflow.com/a/1156114/4061269</a></span>
<span class="comment-copy">@LiorDadon I think neither your suggested answer nor its underlying question adresses exactly the present problem. The OP there does not mention arrays, in contradiction to here, she even states that for a list of lists, that <code>['a','b'] in list</code> <i>does</i> work.</span>
<span class="comment-copy">@NotAnAmbiTurner I call <code>.index</code> <i>on</i> <code>l</code>, which is still a list. The point here is that not <code>l</code> but its <i>elements</i> are arrays.</span>
<span class="comment-copy">There's no special case for first element, <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool" rel="nofollow noreferrer">rich comparison</a> always compares identity first.</span>
<span class="comment-copy"><code>PyObject_RichCompareBool </code> is called for each and every item, <code>PyObject_RichCompareBool</code> compares identity first and if they are different objects it will call  <code>PyObject_RichCompare</code> on them. <code>l.index(b)</code> basically fails because after comparing the identity of <code>a</code>(i.e <code>l[0]</code>) and <code>b</code> Python tries <code>==</code> on them and later calls <code>bool()</code> on its result  which fails. So, it never even reaches the second index, otherwise it would've returned 1.</span>
<span class="comment-copy">@AshwiniChaudhary: Thank you for this nice explaination. I've edited my post accordingly.</span>
