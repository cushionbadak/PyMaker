<div class="post-text" itemprop="text">
<p>So I have a program in which I need to create 4 instances of a class with variables imported from an external document. I have a solution and I have placed it below, but I want to know if there's an easier/more efficient way to do it, perhaps with a for loop.</p>
<pre><code>partsLine = partsDoc.readline()
partsList = partsLine.split(' ')
part1 = Parts(partsList[0], partsList[1], partsList[2],)

partsLine = partsDoc.readline()
partsList = partsLine.split(' ')
part2 = Parts(partsList[0], partsList[1], partsList[2],)

partsLine = partsDoc.readline()
partsList = partsLine.split(' ')
part3 = Parts(partsList[0], partsList[1], partsList[2],)

partsLine = partsDoc.readline()
partsList = partsLine.split(' ')
part4 = Parts(partsList[0], partsList[1], partsList[2],)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rule of thumb: if you have multiple variables with the same name except for a number at the end, replace all of them with a list.</p>
<pre><code>my_parts = []
for i in range(4):
    partsLine = partsDoc.readline()
    partsList = partsLine.split(' ')
    my_parts.append(Parts(partsList[0], partsList[1], partsList[2],))
</code></pre>
<p>You can still refer to individual parts using indexing, e.g. <code>my_parts[2]</code>, so you haven't lost any expressiveness by doing so.</p>
</div>
<div class="post-text" itemprop="text">
<p>Produce a <em>list</em> of the parts, don't use individual <code>partN</code> variable names. Limit reading lines from the file to the first four with <a href="https://docs.python.org/2/library/itertools.html#itertools.islice" rel="nofollow"><code>itertools.islice()</code></a>:</p>
<pre><code>from itertools import islice

parts = []
for line in islice(partsDoc, 4):
    part = Parts(*line.split(None, 3)[:3])  # apply the first 3 elements as arguments
    parts.append(part)
</code></pre>
<p>This can be further reduced using a list comprehension:</p>
<pre><code>parts = [Parts(*line.split(None, 3)[:3]) for line in islice(partsDoc, 4)]
</code></pre>
<p>From here on out you can address these four parts with indexing:</p>
<pre><code>parts[2]
</code></pre>
<p>gives you the results of the 3rd line in the file.</p>
<p>Note that I replaced <code>str.split(' ')</code> with <code>str.split(None, 3)</code>; this changes the split behaviour to strip off extra whitespace at the start and end, and to limit the number of splits made to just what you need and no more.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Basic Version</h2>
<p>Using a function to create a new <code>Parts</code>  instance:</p>
<pre><code>def make_part(parts_doc):
    parts_line = parts_doc.readline()
    parts_list = parts_line.split(' ')
    return Parts(parts_list[0], parts_list[1], parts_list[2])
</code></pre>
<p>you can use it in a list comprehension:</p>
<pre><code>parts = [make_part(parts_doc) for _ in range(4)]
</code></pre>
<p>Retrieve the instances through indexing:</p>
<pre><code>parts[0]
</code></pre>
<h2>Incremental Improvement I - Make the function take a line</h2>
<pre><code>def make_part_from_line(parts_line):
    parts_list = parts_line.split(' ')
    return Parts(parts_list[0], parts_list[1], parts_list[2])
</code></pre>
<p>A file object is an iterator that returns the next line using <code>next</code>:</p>
<pre><code>parts = [make_part_from_line(next(parts_doc)) for _ in range(4)]
</code></pre>
<h2>Incremental Improvement II - Shorten the function</h2>
<pre><code>def make_part_from_line(parts_line):
    return Parts(*parts_line.split(' ')[:3])
</code></pre>
<p>The <code>*</code>-syntax unpacks the list into three function arguments.</p>
<h2>Incremental Improvement III - Make it a one-liner</h2>
<p>The function has only one line. Use it directly:</p>
<pre><code>parts = [Parts(*next(parts_doc).split(' ')[:3]) for _ in range(4)]
</code></pre>
</div>
<span class="comment-copy">Have you tried using loops?</span>
<span class="comment-copy">I considered it, but the only solution I thought of would be to make a list of predeclared variables and then iterate through it and set them 1 by 1, but that didn't seem very efficient either.</span>
<span class="comment-copy">FYI, if <code>Parts</code> is a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>collections.namedtuple</code></a> (not unlikely, given usage, and if it isn't you might consider using it, either directly, or by making <code>Parts</code> inherit from a <code>namedtuple</code> to give it immutability and small size), you can replace <code>Parts(partsList[0], partsList[1], partsList[2],)</code> with <code>Parts._make(partsList[:3])</code> for brevity/efficiency. <code>Parts(*partsList[:3])</code> also works, but it's usually slightly slower.</span>
<span class="comment-copy">And even if, for some reason, a <code>list</code> is inappropriate, you can still build it, then unpack into the named variables, e.g. follow up the code you gave outside the loop with <code>part1, part2, part3, part4 = my_parts</code></span>
<span class="comment-copy">you can remove the <code>islice</code> import by using <code>Parts(*next(partsDoc)... for _ in range(4)]</code></span>
<span class="comment-copy">I don't want to accidentally edit war, but you don't need <code>maxsplit</code> of <code>4</code>, only <code>3</code>. It's the max split count, so the number of resulting components is capped one higher; the <code>maxsplit</code> should match the slice endpoint. I agree that in most cases, <code>None</code> (for splitting on whitespace runs, not just single spaces) is probably what is wanted, so I'm not religious about matching the OP's use of <code>' '</code> as the split delimiter.</span>
<span class="comment-copy">@ShadowRanger: yup, you are right. This cold is draining me today, it seems.</span>
<span class="comment-copy">For reusability, I'd probably has <code>make_part</code> accept a <code>str</code>, not a file-like object, and have the <code>readline</code> call (or whatever produces the line) done caller side; taking <code>str</code> instead of requiring a file-like object tends to be much more flexible/safe (file-like objects that are read in different places in the code leads to a lot of "spooky action at a distance").</span>
<span class="comment-copy">@ShadowRanger You are quite right. I just wanted be as close as possible to th OP code. There is lots of room for improvement here.</span>
<span class="comment-copy">@ShadowRanger Reduced the room for improvements a bit.</span>
