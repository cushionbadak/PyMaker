<div class="post-text" itemprop="text">
<p>I have a list of lists of tuples. Each tuple has the form <code>(string,int)</code>, e.g.</p>
<pre><code>lst = list()
lst.append([('a',5),('c',10),('d',3),('b',1)])
lst.append([('c',14),('f',4),('b',1)])
lst.append([('d',22),('f',2)])
</code></pre>
<p>Think of the <code>int</code>'s as counts of each string in different blocks of text.</p>
<p>What I need to do is produce a list of top-<code>N</code> occurring strings together with their cumulative counts. So in the example above, <code>a</code> appears 5 times, <code>b</code> appears twice, <code>c</code> appears 24 times etc. If <code>N=2</code>, then I would have to produce either a pair of parallel lists <code>['d','c']</code> and <code>[25,24]</code> or a list of tuples <code>[('d',25),('c',24)]</code>. I need to do it as quickly as possible. My machine has lots of RAM so memory is not an issue.</p>
<p>I have this implementation:</p>
<pre><code>import numpy as np
def getTopN(lst,N):

    sOut = []
    cOut = []

    for l in lst:
        for tpl in l:
            s = tpl[0]
            c = tpl[1]

            try:
                i = sOut.index(s)
                cOut[i] += c
            except:
                sOut.append(s)
                cOut.append(c)

    sIndAsc = np.argsort(cOut).tolist()
    sIndDes = sIndAsc[::-1]
    cOutDes = [cOut[sir] for sir in sIndDes]
    sOutDes = [sOut[sir] for sir in sIndDes]

    return sOutDes[0:N],cOutDes[0:N]
</code></pre>
<p>There's gotta be a better way, but what would it be?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a>:</p>
<pre><code>import collections
c = collections.Counter()
for x in lst:
    c.update(dict(x))
print(c.most_common(2))
</code></pre>
<p>Output:</p>
<pre><code>[('d', 25), ('c', 24)]
</code></pre>
<p>The <code>Counter</code> is basically a dictionary with some added functionality, so looking up a value and adding to it's current count is really fast. <code>dict(x)</code> will just turn the list of tuples into a regular dict, mapping strings to numbers, then the <code>update</code> method of <code>Counter</code> will add those counts (instead of just overwriting the values, as a regular dict would do).</p>
<p>Alternatively, a more manual approach using a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>defaultdict</code></a>:</p>
<pre><code>c = collections.defaultdict(int)
for x, y in (t for x in lst for t in x):
    c[x] += y
return [(k, c[k]) for k in sorted(c, key=c.get, reverse=True)][:2]
</code></pre>
<p>As pointed out by John in comments, the <code>defaultdict</code> is indeed much faster:</p>
<pre><code>In [2]: %timeit with_counter()
10000 loops, best of 3: 17.3 µs per loop
In [3]: %timeit with_dict()
100000 loops, best of 3: 4.97 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option, using <code>numpy</code>:</p>
<pre><code># make a flattened numpy version of the list
lst_np = np.asarray([item for sublist in lst for item in sublist])

# split into the two columns
chars = lst_np[:,0]
counts = lst_np[:,1].astype('int')

# get unique characters, and compute total counts for each
[unique_chars, unique_inds] = np.unique(chars, return_inverse=True)
unique_counts = np.asarray([np.sum(counts[unique_inds==x])
    for x in range(len(unique_chars))])
</code></pre>
<p>This will get you counts (<code>unique_counts</code>) for each unique character (<code>unique_chars</code>) in the lists, not just the top <code>N</code>. This should be pretty fast, but might be heavy on memory.</p>
</div>
<span class="comment-copy">Is there any reason why the list is of lists of tuples? Does the problem become different if we just change it into a list of 2-tuples?</span>
<span class="comment-copy">collections.Counter</span>
<span class="comment-copy"><i>Think of the int's as counts of each string in different blocks of text.</i> -- why not <code>collections.Counter</code>?</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/11011756/is-there-any-pythonic-way-to-combine-two-dicts-adding-values-for-keys-that-appe">Is there any pythonic way to combine two dicts (adding values for keys that appear in both)?</a></span>
<span class="comment-copy">Are the strings always single characters?</span>
<span class="comment-copy">Counter is neat (and helps avoid bugs), but you will usually find that a dict or defaultdict is faster even though you need a few extra lines of code.</span>
<span class="comment-copy">@JohnLaRooy Thanks for pointing out, did not think it would make such a difference. Added to my answer.</span>
