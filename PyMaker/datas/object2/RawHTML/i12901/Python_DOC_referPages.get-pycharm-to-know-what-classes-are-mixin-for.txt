<div class="post-text" itemprop="text">
<p>Our application has set of complex form wizards. To avoid code duplication I created several mixins.</p>
<p>The problem is that PyCharm highlights mixin methods with <code>Unresolved attribute refference</code> error.<br/>
This is correct as <code>object</code> does not have such methods. But I know that this mixin will be used only with special classes. Is there any way to tell this info to PyCharm?</p>
<p>For now I use such approach:</p>
<pre><code>class MyMixin(object):
    def get_context_data(self, **kwargs):
        assert isinstance(self, (ClassToBeExtended, MyMixin))
        # super.get_context_data is still highlighter, 
        # as super is considered as object
        context = super(MyMixin, self).get_context_data(**kwargs)
        context.update(self.get_preview_context())
        return context

    def get_preview_context(self):
        # without this line PyCharm highlights the self.initial_data
        assert isinstance(self, (ClassToBeExtended, MyMixin))
        return {'needs': (self.initial_data['needs']
                          if 'type' not in self.initial_data
                          else '%(needs)s %(type)s' % self.initial_data)}
</code></pre>
<p>While this works for some cases like autocomplete for <code>self.</code>, it fails for other cases like <code>super</code>. Is there a better approach to achieve the desired behavior?</p>
<p><em>P.S.: I know that I can disable reference check for specific name or whole class, but I don't want to do this as it will not help in typo checks and autocomplete.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>You can <a href="https://www.jetbrains.com/help/pycharm/2016.1/type-hinting-in-pycharm.html" rel="nofollow">type-hint</a> to PyCharm what kind of classes to expect.</p>
<pre><code>class DictMixin(object):
    def megamethod(
        self,  # type: dict
        key
    ):
        return self.get(key)
</code></pre>
<p>It's still not quite comparable to other type handling.
PyCharm is lazy in evaluating it, and only does so when first working on <code>self</code>.
Things are a bit tricky when accessing attributes of the mixin as well - <code>self,  # type: dict | DictMixin</code> works for one of my classes, but not in my test code.
In <a href="https://www.python.org/dev/peps/pep-0484/#stub-files" rel="nofollow">python 3.5</a>, you should be able to use <a href="https://docs.python.org/3/library/typing.html" rel="nofollow"><code># type: typing.Union[dict, DictMixin]</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are creating Mixin, for, let's say ClassSub, which is subclass of ClassSuper, you can implement Mixins this way:</p>
<pre><code>class Mixin1(ClassSuper):
    pass


class Mixin2(ClassSuper):
    pass
</code></pre>
<p>and then use them like:</p>
<pre><code>class ClassSub(Mixin1, Mixin2):
    pass
</code></pre>
<p>That way I use some mixins for models in Django. Also, <a href="https://github.com/django-extensions/django-extensions" rel="nofollow">django-extensions</a> uses similar pattern (gives models that are actually mixins). Basically, this way you don't have to inherit <code>ClassSuper</code>, because it's "included" in every of your mixins.</p>
<p>Most important - PyCharm works like a charm this way.</p>
</div>
<span class="comment-copy">FWIW, if pycharm can't resolve the attribute references I suspect it also won't be able to neither check for typos nor autocomplete (since it has no reference to use)...</span>
<span class="comment-copy"><code>get_context_data(self:ClassToBeExtended)</code> (python3 of course) seems working.</span>
