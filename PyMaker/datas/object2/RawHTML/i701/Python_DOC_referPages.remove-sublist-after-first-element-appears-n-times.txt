<div class="post-text" itemprop="text">
<p>I have a long nested list. Each sublist contains 2 elements. What I would like to do is iterate over the full list and remove sublists once I've found the first element more than 3 times. </p>
<p>Example:</p>
<pre><code>ls = [[1,1], [1,2], [1,3], [1,4], [2,2], [2,3], [3,4], [3,5], [3,6], [3,7]]

desired_result = [[1,1], [1,2], [1,3], [2,2], [2,3], [3,4], [3,5], [3,6]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the input is sorted by the first element, you could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">groupby</a> and <a href="https://docs.python.org/3.7/library/itertools.html#itertools.islice" rel="nofollow noreferrer">islice</a>:</p>
<pre><code>from itertools import groupby, islice
from operator import itemgetter

ls = [[1, 1], [1, 2], [1, 3], [1, 4], [2, 2], [2, 3], [3, 4], [3, 5], [3, 6], [3, 7]]

result = [e for _, group in groupby(ls, key=itemgetter(0)) for e in islice(group, 3)]
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 4], [3, 5], [3, 6]]
</code></pre>
<p>The idea is to group the elements by the first value using <code>groupby</code>, and then fetch the first 3 values, if they exist, using <code>islice</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it like below:</p>
<pre><code>ls = [[1,1], [1,2], [1,3], [1,4], [2,2], [2,3], [3,4], [3,5], [3,6], [3,7]]

val_count = dict.fromkeys(set([i[0] for i in ls]), 0)

new_ls = []
for i in ls:
    if val_count[i[0]] &lt; 3:
        val_count[i[0]] += 1 
        new_ls.append(i)

print(new_ls)
</code></pre>
<p>Output:</p>
<pre><code>[[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 4], [3, 5], [3, 6]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Probably not the shortest answer.</p>
<p>The idea is to count occurrences while you're iterating over <code>ls</code></p>
<pre><code>from collections import defaultdict

filtered_ls = []
counter = defaultdict(int)
for l in ls: 
    counter[l[0]] += 1
    if counter[l[0]] &gt; 3:
        continue
    filtered_ls += [l]
print(filtered_ls)
# [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 4], [3, 5], [3, 6]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> to aggregate by first value in O(<em>n</em>) time. Then use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain</code></a> to construct a list of lists.</p>
<pre><code>from collections import defaultdict
from itertools import chain

dd = defaultdict(list)
for key, val in ls:
    if len(dd[key]) &lt; 3:
        dd[key].append([key, val])

res = list(chain.from_iterable(dd.values()))

print(res)

# [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 4], [3, 5], [3, 6]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ghillas BELHADJ answer is good. But you should consider defaultdict for this task. The idea is taken from Raymond Hettinger who suggested to use defaultdict for grouping and counting tasks</p>
<pre><code>from collections import defaultdict

def remove_sub_lists(a_list, nth_occurence):
    found = defaultdict(int)
    for sublist in a_list:
        first_index = sublist[0]
        print(first_index)
        found[first_index] += 1
        if found[first_index] &lt;= nth_occurence:
            yield sublist

max_3_times_first_index = list(remove_sub_lists(ls, 3)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the list is already sorted, you can use <code>itertools.groupby</code> then just keep the first three items from each group</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; ls = [[1,1], [1,2], [1,3], [1,4], [2,2], [2,3], [3,4], [3,5], [3,6], [3,7]]
&gt;&gt;&gt; list(itertools.chain.from_iterable(list(g)[:3] for _,g in itertools.groupby(ls, key=lambda i: i[0])))
[[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 4], [3, 5], [3, 6]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an option that doesn't use any modules:</p>
<pre><code>countDict = {}

for i in ls:
    if str(i[0]) not in countDict.keys():
        countDict[str(i[0])] = 1
    else:
        countDict[str(i[0])] += 1
        if countDict[str(i[0])] &gt; 3:
            ls.remove(i)
</code></pre>
</div>
<span class="comment-copy">Welcome to SO. Please take the time to read <a href="http://stackoverflow.com/help/how-to-ask">stackoverflow.com/help/how-to-ask</a>. It will help you craft solid questions that will hopefully get useful answers.</span>
<span class="comment-copy">Please include what you have tried (you can edit to include some code), and please explain what failed in your attempts.</span>
<span class="comment-copy">Is the input always sorted by the first element?</span>
