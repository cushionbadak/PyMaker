<div class="post-text" itemprop="text">
<p>I have a list of tuples which look like below</p>
<pre><code>entities = [('tmp', 'warm'), ('loc', 'blr'), ('cap', 'blr'), ('aps', 'yes'), ('date', '12-10-2018')]
</code></pre>
<p>I want to store those tuples which have the same <strong>second</strong> values. As you can see, the tuples <code>('loc', 'blr')</code> and <code>('cap', 'blr')</code> have the same second value.</p>
<p>I want these two tuples to be stored in a list for me to refer.</p>
<p>This is what I tried but it doesn't work as expected</p>
<pre><code>duplicate = []
for i in range(len(entities)):
    for j in range(1, len(entities)):
        if entities[i][1] == entities[j][1]:
            duplicate.append([entities[i][1], entities[j][1]])
            break
</code></pre>
<p>But I get all the tuples as if all tuples have same second value. How can I accomplish this?</p>
<p><strong>Desired output</strong></p>
<pre><code>('loc', 'blr'), ('cap', 'blr')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could group together lists with common second elements in the following way:</p>
<pre><code>s = sorted(entities, key = lambda x: x[1])
[list(v) for k,v in groupby(s, key=lambda x: x[1])]

[[('date', '12-10-2018')],
 [('loc', 'blr'), ('cap', 'blr')],
 [('tmp', 'warm')],
 [('aps', 'yes')]]
</code></pre>
<p>If performance is an issue consider using <a href="https://docs.python.org/2/library/operator.html" rel="nofollow noreferrer"><code>operator.itemgetter</code></a>:</p>
<pre><code>from operator import itemgetter
s = sorted(entities, key = itemgetter(1))
[list(v) for k,v in groupby(s, key = itemgetter(1))]

[[('date', '12-10-2018')],
 [('loc', 'blr'), ('cap', 'blr')],
 [('tmp', 'warm')],
 [('aps', 'yes')]]
</code></pre>
<p>Now, if you only want to keet cases where two tuples had a common second element, you can do:</p>
<pre><code>[i for i in l if len(i)&gt;1]
[[('loc', 'blr'), ('cap', 'blr')]]
</code></pre>
<p>I proposed this answer so that this way you can extend this to <code>n</code> common elements in the second place, as you may have more than 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use O(<em>n</em> log <em>n</em>) <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> (requires pre-sorting your input list), but O(<em>n</em>) <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> is sufficient:</p>
<pre><code>from collections import Counter
from operator import itemgetter

# construct dictionary mapping second value to count
c = Counter(map(itemgetter(1), entities))

# filter for second values with count &gt; 1
dups = {value for value, count in c.items() if count &gt; 1}

# filter entities with second value in dups
res = [entity for entity in entities if entity[1] in dups]

print(res)
# [('loc', 'blr'), ('cap', 'blr')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can group these tuples using dict for a more common case</p>
<pre><code>grouped = {}
for k, v in entities:
    grouped[v].setdefault(k, []).append((k, v))
for _, tuples in grouped.items():
    if len(tuples) &gt; 2:
        print(tuples)
</code></pre>
<p>all pairs with same second value will be grouped under different keys</p>
</div>
<span class="comment-copy">What is the desired output?</span>
<span class="comment-copy">@user5173426 added desired output</span>
<span class="comment-copy">Exacly ! , tip:  instead of lambda the <code>operator.itemgetter(1)</code> could be also used.</span>
<span class="comment-copy">Yes will also add that, as it performs better for large lists. Thx!</span>
