<div class="post-text" itemprop="text">
<p>I would like to combine threading and asyncio with some synchronisation. </p>
<p>For example: A thread write-combines frames from a camera into some variable or buffer. Multiple readers (asyncio or threads) are woken on each write to take the latest available frame.</p>
<p>I have tried deriving from the <code>asyncio.Event</code> to no avail.</p>
<pre><code>class EventThreadSafe(asyncio.Event):
    def set(self):
        self._loop.call_soon_threadsafe(super().set)
</code></pre>
<p>Is there a mechanism that does this already (<a href="https://github.com/aio-libs/janus" rel="nofollow noreferrer">https://github.com/aio-libs/janus</a>?) or how is best to implement it?</p>
</div>
<div class="post-text" itemprop="text">
<p>you can use <a href="https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue" rel="nofollow noreferrer">asyncio.Queue</a>, however it is not thread safe, just task safe.  If you want thread safe use <a href="https://docs.python.org/3/library/queue.html#queue.Queue" rel="nofollow noreferrer">queue.Queue</a>, however this is not task safe as it will block your thread.  Personally for multiprocess I use a <a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/pyzmq/patterns/pushpull.html" rel="nofollow noreferrer">0MQ Push-Pull Pattern</a>, which feeds to/from a <code>asyncio.Queue</code> adapter.</p>
</div>
<span class="comment-copy">Do you have a minimal/runnable example that demonstrates what you'd like to achieve? How exactly did your <code>EventThreadSafe</code> class fail? Also, do you really need <b>both</b> threaded and asyncio consumers? It sounds like it should be one or the other, depending on architecture, but never both. (I'm not saying it's wrong, but it has a definite "design smell".)</span>
<span class="comment-copy">Thanks - <a href="https://pastebin.com/XJ5J1Vn1" rel="nofollow noreferrer">pastebin.com/XJ5J1Vn1</a>  It fails by constantly reading after the event is unset for the first time: although to be honest I didn't expect it to work.  The reason for the writer thread is that the writer thread is slow (IO, processing, etc) I didn't want the aio loop to stall while I waiting for the frames to come in and be processed.  They are then streamed out with multi-part mjpg over http.  I didn't use a separate thread readers as well as the aio ones, but I would still like to know how to do it efficiently should the occasion arise.</span>
<span class="comment-copy">Thanks for the answer. I'm not sure the push/pull pattern is what I want; I think what I am describing is closer to publish/subscribe.  I also want it to be both threadsafe and task safe but able to write-combine the results so not every subscriber need get every frame.  So, one frame that comes in might be read by 2 of 3 asyncio tasks, then the next frame might be read by all 3 asyncio tasks.</span>
<span class="comment-copy">ya push/pull is for multiple publish, one message for subscribe, publish subscribe is multiple publish, everyone gets the same objects. There are various patterns.  See here for using pyzmq: <a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/pyzmq/patterns/patterns.html" rel="nofollow noreferrer">learning-0mq-with-pyzmq.readthedocs.io/en/latest/pyzmq/patterns/â€¦</a>.  If you're inproc make sure to use the <code>inproc</code> socket.  Probably your best bet!</span>
