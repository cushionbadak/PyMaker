<div class="post-text" itemprop="text">
<p>I have a list and a set:</p>
<pre><code>a_list = [['1', 2], ['2', 1], ['1', 1]]

b_list = {'1', '2'}
</code></pre>
<p>I'm looking to correspond the items in b_list and sum their values from a_list so that the output is:</p>
<pre><code>[['1', 3], ['2', 1]]
</code></pre>
<p>What I've tried...</p>
<pre><code>sum = 0

for i in a_list:
        for j in b_list:
            if i[0] in j:
                sum += i[1]
        print(j, sum)
</code></pre>
<p>But this is giving giving me an incorrect output.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are on the right track! All you have to do is flip the order of your loops. For every value in <code>b_list</code>, you want to sum up all matching values in <code>a_list</code>, so <code>b_list</code> should be the external loop and <code>a_list</code> the internal. Also note your <code>sum</code> variable should be inside the first loop as it is different for every value in <code>b_list</code>.</p>
<p>If you make this change your code works as expected: </p>
<pre><code>a_list = [['1', 2], ['2', 1], ['1', 1]]

b_list = {'1', '2'}

for j in b_list:
    sum = 0
    for i in a_list:
        if i[0] == j:
            sum += i[1]
    print(j, sum)
</code></pre>
<p>will give your desired output:</p>
<pre><code>('1', 3)
('2', 1)
</code></pre>
<hr/>
<p><strong>EDIT</strong>: the above solution is a minimal fix to the code posted in the question, however there are more efficient solutions:</p>
<p>Similar to wim's answer, you could use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdictionary</a>, which in this case would be (slightly) more efficient than using the built-in <code>dict</code> class:</p>
<pre><code>from collections import defaultdict
#
a_list = [['1', 2], ['2', 1], ['1', 1]]
b_list = {'1', '2'}

dict = defaultdict(int)

for key, val in a_list:
    if key in b_list:
        dict[key] += val

print([[key, dict[key]] for key in b_list])
</code></pre>
<p>** credit to coldspeed for the idea for this second solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>Accumulate numbers using a dict, and then gather the results using a list comprehension: </p>
<pre><code>&gt;&gt;&gt; d = dict.fromkeys(b_list, 0)
&gt;&gt;&gt; for k, n in a_list: 
...     if k in d: 
...         d[k] += n 
...
&gt;&gt;&gt; [[k, n] for k, n in d.items()]
[['1', 3], ['2', 1]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a dict for grouping:</p>
<pre><code>d = {}
for k, v in a_list:
    d[k] = d.get(k, 0) + v
print([[k, d[k]] for k in b_list])
</code></pre>
<p>prints:</p>
<pre><code>[['2', 1], ['1', 3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This returns sums only for items defined in find.</p>
<pre><code>items = [['1', 2], ['2', 1], ['1', 1], ['3',1]]
find = {'1', '2'}
results = {}

for item in items:
    key = item[0]
    value = item[1]
    if key in find:
        results[key] = results.get(key,0) + value

[[key, value] for key, value in results.items()] 

</code></pre>
<p>Outputs <code>[['2', 1], ['1', 3]]</code></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [1]: a_list = [['1', 2], ['2', 1], ['1', 1]]
   ...:
   ...: b_list = {'1', '2'}

In [2]: out = [[i, sum(j[1] for j in a_list if j[0] == i)] for i in b_list]

In [3]: out
Out[3]: [['1', 3], ['2', 1]]
</code></pre>
<p>You can use sum of list or you can directly call sum. Here is a time performance of both approach:</p>
<pre><code>In [6]: %timeit [[i, sum(j[1] for j in a_list if j[0] == i)] for i in b_list]
1.31 µs ± 2.52 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)

In [7]: %timeit [[i, sum([j[1] for j in a_list if j[0] == i])] for i in b_list]
1.2 µs ± 1.67 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/38647928/sum-list-of-list-elements-in-python-like-sql-group-by">Sum list of list elements in python like sql group by</a></span>
<span class="comment-copy">I reversed the duplicates because two of the answers there used groupby while a third used pandas, all of which I would consider secondary solutions to a dictionary.</span>
<span class="comment-copy">@coldspeed: Please support your comment regarding "secondary solutions" with some explanation for the sake of readers</span>
<span class="comment-copy">@Bazingaa groupby requires the sublists to be sorted by the grouper, so if that's not the case, there itself you lose to a dictionary in terms of time complexity. Pandas groupby is nice but also sorts keys. Dictionaries are the only solution you can use and finish this problem in linear time.</span>
<span class="comment-copy">@user47467 This is inefficient, please don't do this.</span>
<span class="comment-copy">@coldspeed the OP asked why their code wasn't working. This is the minimal fix to the original code that gives the desired output.</span>
<span class="comment-copy">I'm reading the question and I don't see them explicitly ask to "fix my code". If that's the case, I would've said, "sure, this could fix your code, but.... here is a better way". It's always better to write a <i>good</i> answer, rather than a <i>good enough</i> answer.</span>
<span class="comment-copy">To address your comment- adding an edit to the answer.</span>
<span class="comment-copy">Whoops. Slipped out somehow. It's fixed now. Thanks for pointing it out.</span>
<span class="comment-copy">This solution will throw a <code>KeyError</code> if a key is present in <code>b_list</code>, but not in <code>a_list</code>. Although OP does not explain if that can happen.</span>
<span class="comment-copy">True. Thanks for pointing that out</span>
<span class="comment-copy">I don't think all of those <code>sum</code> calls are necessary.</span>
<span class="comment-copy">This has the same problem as the accepted answer, looping over <code>a_list</code> for each key in <code>b_list</code>.</span>
<span class="comment-copy">If we consider time efficiency vs simplicity, I'd prefer this one for small lists. For larger lists, it's alright to add dict or intermediate container to the code to make it more efficient.</span>
<span class="comment-copy">A function being a compact one-liner does not make it simple. If this goes to a utility-function somewhere, it doesn't matter if it is 3 or 1 lines. One-liners are just harder to maintain and understand. For 10000 keys, your solution takes <code>3.82 seconds</code>, as opposed to <code>0.0044</code> for a dictionary-solution.</span>
<span class="comment-copy">That’s what I said for small list like the one op has it’s ok, for large list you need something better. Even the accepted answer says that op doesn’t care about time or maintainability.</span>
