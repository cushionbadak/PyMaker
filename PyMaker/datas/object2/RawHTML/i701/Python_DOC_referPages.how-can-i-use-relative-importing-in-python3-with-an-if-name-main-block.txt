<div class="post-text" itemprop="text">
<p>I am making a package, and the modules within this package have code inside <code>if __name__=='__main__':</code> blocks for testing purposes. But my attempts to use relative imports in these modules causes errors. </p>
<p>I have read this thread and the billion others:
<a href="https://stackoverflow.com/questions/14132789/relative-imports-for-the-billionth-time">Relative imports for the billionth time</a></p>
<p>Before you mark this as a duplicate, if what I want to do is not possible in Python3 then my question is why did it work in Python2 and what motivated the decision to make this such a hassle in Python3?</p>
<hr/>
<p>This is my sample Python project:</p>
<pre><code>mypackage
- module1.py
- module2.py
- __init__.py
</code></pre>
<p><code>__init__.py</code> and <code>module2.py</code> are empty</p>
<p><code>module1.py</code> contains:</p>
<pre><code>import module2

# module1 contents

if __name__=="__main__":
    # Some test cases for the contents of this module
    pass
</code></pre>
<p>This works fine in Python2. I am able to import module1 from other projects anywhere on my computer, and I'm also able to run module1 directly and have the code in the <code>if</code> block run.</p>
<p>However, this structure doesn't work in Python3. If I try import the module somewhere else it fails:</p>
<pre><code>&gt;&gt;&gt; from mypackage import module1
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "C:\_MyFiles\Programming\Python Modules\mypackage\module1.py", line 1, in &lt;module&gt;
    import module2
ModuleNotFoundError: No module named 'module2'
</code></pre>
<p>So I tried changing the first line to <code>from . import module2</code>, and that fixed it so I could import the module from anywhere successfully. But then when I try running module1 directly as a script I get this error:</p>
<pre><code>Traceback (most recent call last):
  File "C:/_MyFiles/Programming/Python Modules/mypackage/module1.py", line 1, in &lt;module&gt;
    from . import module2
ImportError: cannot import name 'module2' from '__main__' (C:/_MyFiles/Programming/Python Projects/pandasgui/mypackage/module1.py)
</code></pre>
<p>I don't want to have to open a console and type <code>python -m myfile</code> every time I'm working on a module and want to run it directly as a script.</p>
<p>I want to be able to work on modules without adding their parent folder to PYTHONPATH by using relative imports like in Python2</p>
<p>Is there any better workaround or solution to these problems?</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/3/tutorial/modules.html#intra-package-references" rel="nofollow noreferrer">Module documentation</a>, for <code>__main__</code> modules, you have to use absolute imports.</p>
<blockquote>
<p>Note that relative imports are based on the name of the current module. Since the name of the main module is always "<strong>main</strong>", modules intended for use as the main module of a Python application must always use absolute imports.</p>
</blockquote>
<p>So just change the import line in <code>module1.py</code> to:</p>
<p><code>from mypackage import module2</code></p>
<p>Everything else remains the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>I ended up in similar scenario and it troubled me a alot until I realised how module and package import is supposed to work.</p>
<p>Consider the following structure</p>
<pre><code>mydir
- project
  - __init__.py
  - module1.py
  - module2.py
</code></pre>
<p>Contents of <code>module1</code> and <code>module2</code> looks like below</p>
<p><strong>module1.py</strong></p>
<pre><code>print("moudule1")
</code></pre>
<p><strong>moudle2.py</strong></p>
<p>from . import module1</p>
<pre><code>print("Module 2")

if __name__ == '__main__':
    print("Executed as script")
</code></pre>
<p>Now if i open a repl outside the package directory and try to make imports it works</p>
<pre><code>Python 3.6.7 (default, Oct 22 2018, 11:32:17) 
[GCC 8.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from package import module2
Module 1
Module 2
&gt;&gt;&gt; sys.path
['', '/usr/lib/python36.zip', '/usr/lib/python3.6', '/usr/lib/python3.6/lib-dynload', '/home/rbhanot/.local/lib/python3.6/site-packages', '/usr/local/lib/python3.6/dist-packages', '/usr/lib/python3/dist-packages']
</code></pre>
<p>Take a note at <code>sys.path</code>, as you can see it contains the current directory I am in as the first item, which means all my imports are going to be first searched in my current directory.</p>
<p>Now if i go into the package directory and then open a repl, and try making same imports see what happens</p>
<pre><code>Python 3.6.7 (default, Oct 22 2018, 11:32:17) 
[GCC 8.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from . import module2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ImportError: cannot import name 'module2'
&gt;&gt;&gt; import module2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/rbhanot/python-dotfiles/python3/modules-packages/mydir/package/module2.py", line 1, in &lt;module&gt;
    from . import module1
ImportError: attempted relative import with no known parent package
&gt;&gt;&gt; import module1
Module 1
&gt;&gt;&gt;
</code></pre>
<p>As you can the imports fail, the reason for failure is that when i try to import module from package python searches in <code>sys.path</code> to find any package with name <code>package</code>, since I could not find any , hence import fails. But importing the module1 works because it is found in the current directory.</p>
<p>Outside the package i can execute the script as </p>
<pre><code>python3 -m package.module2                                                                              2 â†µ
Module 1
Module 2
Executed as script
</code></pre>
<p>Though I can execute the script but this is not how its supposed to used. Remember packages are library of code that needs to shared across and should not have any code that is directly executable via command line. Packages and modules inside packages are meant to be just imported and then after importing you can write your scripts which execute via command line by putting <code>__name__</code> clause in it.</p>
</div>
<div class="post-text" itemprop="text">
<p>A Python package isn't just a folder you stick your code in, and import behavior depends on more than just what folder you've stuck your code in.</p>
<p>When you run your file directly, you're not running it as part of a package. Package-level initialization doesn't run, and Python doesn't even recognize the package's existence. On Python 2, the existence of implicit relative imports meant that a bare <code>import module2</code> would resolve to either an absolute import or an implicit relative import, hiding the problem, but the import structure is still broken. On Python 3, implicit relative imports are gone (for good reason), so the problem is immediately visible.</p>
<p>Running a submodule of a package directly by filename just doesn't work very well. These days, I believe the standard is to either use <code>-m</code>, or use a top-level entry point script that invokes the submodule's functionality.</p>
<p>There's sort of a way to get run-by-filename working anyway, but it's a lot of boilerplate. The designers of <a href="https://www.python.org/dev/peps/pep-0366/" rel="nofollow noreferrer">PEP 366</a> seem to have intended for a <code>__package__ = 'appropriate.value'</code> assignment to make relative imports work properly, but that's not actually enough, even if you fix the import path. You also have to initialize the parent package manually, or you'll get a "SystemError: Parent module 'foo' not loaded, cannot perform relative import" as soon as you try to run a relative import. The full boilerplate looks more like</p>
<pre><code>import os.path
import sys
if __name__ == '__main__' and __package__ is None:
    __package__ = 'mypackage'
    right_import_root = os.path.abspath(__file__)
    for i in range(__package__.count('.') + 2):
        right_import_root = os.path.dirname(right_import_root)

    # sys.path[0] is usually the right sys.path entry to replace, but this
    # may need further refinement in the presence of anything else that messes
    # with sys.path
    sys.path[0] = right_import_root
    __import__(__package__)
</code></pre>
<p>This goes after stuff like future imports, but before any import that depends on your package.</p>
<p>I would wrap this boilerplate in a reusable function (using stack manipulation to access the caller's globals), except that if you try to put that function somewhere in your project, you won't be able to import the function until you've fixed your import situation, which you need the function to do. It might work as an installable dependency.</p>
</div>
<span class="comment-copy">"I don't want to have to open a console and type <code>python -m myfile</code> every time I'm working on a module and want to run it directly as a script." - as opposed to, what, opening a console and typing <code>python myfile.py</code>? How are you running your files currently? (Also it's <code>python -m packagename.modulename</code> for package submodules, not <code>python -m modulename</code>.)</span>
<span class="comment-copy">I guess other peeps will tell you the proper python way, however, you could just use a` try ... except ImportError` to import it the way that works. Dive Into Python has an <a href="https://www.diveinto.org/python3/your-first-python-program.html#importerror" rel="nofollow noreferrer">example</a>.</span>
<span class="comment-copy">@user2357112 Currently I'm running my files through the PyCharm IDE by clicking the run button in the GUI. I realize I could add -m to the configuration, but this seems like a hassle and I would prefer if my code worked when run normally, like in Python2. And I'd like to send this to someone to use without having to warn them and explain how to run it so as to avoid the gotchas of relative imports failing with <b>main</b> blocks with a cryptic error.</span>
<span class="comment-copy">@glumplum Thanks, that seems like a viable workaround if there's no 'proper' way.</span>
<span class="comment-copy">Is there a mistake with your code? <code>module2.py</code> as the first line of <code>__init__.py</code> gives an unresolved reference error. And removing that, I still get the same error as before in Python3.</span>
<span class="comment-copy">Oh yes, I seem to be having the same issue now. I found a solution; will update my answer. Sorry about that.</span>
<span class="comment-copy">Thank you, but this still requires adding the parent folder of the package to PYTHONPATH or it fails. This means when I'm first writing the code I have to use relative imports, and then I have refactor all my import statements to be absolute once I decide to make it a module? It also means my code fails for anyone downloading my package as a zip unless they first add it it to their own PYTHONPATH. So while just not using relative imports does get the code working, it's not an answer to my OP about how to get relative imports working like they did in Python2.</span>
<span class="comment-copy">Is adding the <code>__name__ == "__main__"</code> check only for testing? Ideally, as I see it, you would have just one <code>main</code> module, which would be the starting point for your code. For testing, you could use a different approach. That way you can use relative imports everywhere except in the <code>main</code> module. Also, if you are planning to distribute it as a zip, you don't want multiple entry points for the code (unless there is a specific reason to do so).</span>
<span class="comment-copy">Yes it's just for testing. It's a PyQt5 project with one module for the main GUI and other modules for various other widgets, dialogs and functions that are used in the main GUI. So for each module I have a <code>__name__ == "__main__"</code> block that creates test inputs and instantiates the widget alone so I don't have to open the main GUI and open it manually. What's the proper alternative? Should I just have a separate test file for each one like mydialog_test.py that uses relative imports and has the test code not in a <b>main</b> block?</span>
