<div class="post-text" itemprop="text">
<p>Json object (output):
[424783, [198184], [605], [644], [296], [2048], 424694, [369192], [10139],
[152532], [397538], [1420]]</p>
<p>&lt;&lt;&lt; CODE REmoved &gt;&gt;&gt;</p>
<p>Desired output:</p>
<pre class="lang-none prettyprint-override"><code>424783,198184
424783,605
424783,644
424783,296
424783,2048
424694,369192
424694,10139
424694,152532
424694,397538
424694,1420
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From your data it looks like non-bracketed items should be considered as values of the first column (i.e. a <em>key</em>) and bracketed ones should be considered as values for the second column, using the <em>key</em> that precedes them. You can do this purely in a procedural fashion:</p>
<pre><code>import csv
import json

src = '''[424783, [198184], [605], [644], [296], [2048],
          424694, [369192], [10139], [152532], [397538], [1420]]'''

with open('output.csv', 'w', newline='') as f:  # Python 2.x: open('output.csv', 'wb')
    writer = csv.writer(f)  # create a simple CSV writer
    current_key = None  # a container for the last seen / cached 'key'
    for element in json.loads(src):  # parse the structure and iterate over it
        if isinstance(element, list):  # if the element is a 'list'
            writer.writerow((current_key, element[0]))  # write to csv w/ cached key
        else:
            current_key = element  # cache the element as the key for following entries
</code></pre>
<p>Which should produce an <code>output.csv</code> containing:</p>
<pre>424783,198184
424783,605
424783,644
424783,296
424783,2048
424694,369192
424694,10139
424694,152532
424694,397538
424694,1420</pre>
</div>
<div class="post-text" itemprop="text">
<p><code>itertools.groupby</code> is a little challenging for Python beginners, but is very handy for walking through a collection of items and working with them in groups. In this case, we group by items that are or are not Python lists.</p>
<p>From each group of nested ints, we'll create one or more entries in our accumulator list.</p>
<p>Once the accumulator list is loaded, the code below just prints out the results, easily converted to writing to a file.</p>
<pre><code>import ast
from itertools import groupby
from collections import namedtuple


# this may be JSON, but it's also an ordinary Python nested list of ints, so safely parseable using
# ast.literal_eval()
text = "[424783, [198184], [605], [644], [296], [2048], 424694, [369192], [10139], [152532], [397538], [1420]]"
items = ast.literal_eval(text)

# a namedtuple to hold each record, and a list to accumulate them
DataRow = namedtuple("DataRow", "old_id new_id")
accumulator = []

# use groupby to process the entries in groups, depending on whether the items are lists or not
key = None
for is_data, values in groupby(items, key=lambda x: isinstance(x, list)):
    if not is_data:
        # the sole value the next record key
        key = list(values)[0]
    else:
        # the values are the collection of lists until the next key
        accumulator.extend(DataRow(key, v[0]) for v in values)

# dump out as csv
for item in accumulator:
    print("{old_id},{new_id}".format_map(item._asdict()))
</code></pre>
<p>Prints:</p>
<pre><code>424783,198184
424783,605
424783,644
424783,296
424783,2048
424694,369192
424694,10139
424694,152532
424694,397538
424694,1420
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code></a> would be a good approach since grouping items is main thing that needs to be done to accomplish what you want. </p>
<p>Here's a fairly simple way of using it:</p>
<pre><code>import csv
from itertools import groupby
import json

json_src = '''[424783, [198184], [605], [644], [296], [2048],
               424694, [369192], [10139], [152532], [397538], [1420]]'''

def xyz():
    return json.loads(json_src)

def abc():
    json_processed = xyz()
    output_filename = 'y.csv'

    with open(output_filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        for is_list, items in groupby(json_processed, key=lambda v: isinstance(v, list)):
            if is_list:
                new_ids = [item[0] for item in items]
            else:
                old_id = next(items)
                continue

            for new_id in new_ids:
                writer.writerow([old_id, new_id])

abc()
</code></pre>
<p>Contents of csv file produced:</p>
<pre class="lang-none prettyprint-override"><code>424783,198184
424783,605
424783,644
424783,296
424783,2048
424694,369192
424694,10139
424694,152532
424694,397538
424694,1420
</code></pre>
</div>
<span class="comment-copy">That's not a good JSON structure, if indeed it is valid at all. After that, it's not clear how this output should be generated.</span>
<span class="comment-copy">If you created that structure, you should solve the problem up-stream with a dictionary and an array stored against  the key you want in the first column. If you didn't create it, then the API is very low quality and you might consider looking for another for the same info.</span>
<span class="comment-copy">Hi Scavallaro,  Some points about your question: - The data structure you include above isn't JSON, it's a Python list.  - The list is composed of integers and other lists, also composed of integers. - The DictWriter class is for writing dictionary objects to file. In any case, it will need the input to be normalised (i.e. regular, consistent). See, for instance: <a href="https://docs.python.org/2/library/csv.html#csv.DictWriter" rel="nofollow noreferrer">docs.python.org/2/library/csv.html#csv.DictWriter</a>.</span>
