<div class="post-text" itemprop="text">
<p>I have a list of dates as strings. It looks like this:</p>
<pre><code>[
  "January 29-30 Meeting - 2013",
  "March 19-20 Meeting - 2013",
  "April/May 30-1 Meeting - 2013",
  "June 18-19 Meeting - 2013",
  "July 30-31 Meeting - 2013",
  "September 17-18 Meeting - 2013",
  "October 29-30 Meeting - 2013",
  "December 17-18 Meeting - 2013"
]
</code></pre>
<p>I need to parse these dates to <code>datetime</code> format.</p>
<pre><code>datetime.strptime("January 29-30 Meeting - 2013", "%B %d-[something] - %Y")
datetime.strptime("January 29-30 Meeting - 2013", "%B [something]-%d [something] - %Y")
</code></pre>
<p>Is there any way I can tell strptime, in the format specifier, to ignore the text in <code>[something]</code> since it can be variable? Is there a format specifier for variable text?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can override the <code>_strptime.TimeRE</code> object with an additional directive that lazily matches any sequence of characters:</p>
<pre><code>from datetime import datetime
import _strptime
TimeRE = _strptime.TimeRE()
TimeRE.update({'x': '.*?'})
_strptime._TimeRE_cache = TimeRE
print(datetime.strptime("January 29-30 Meeting - 2013", "%B %d-%x - %Y"))
</code></pre>
<p>This outputs:</p>
<pre><code>2013-01-29 00:00:00
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no wildcard directive for <code>strptime</code>. You can see a list of the directives here <a href="https://docs.python.org/3/library/time.html#time.strftime" rel="nofollow noreferrer">https://docs.python.org/3/library/time.html#time.strftime</a></p>
<p>A sensible way to solve your problem would be to combine a regex with the <code>strptime</code>. I.e. filter out the text with the regex and put the remaining, restricted text into the <code>strptime</code>, or by just passing the matched groups directly into <code>datetime</code>.</p>
<pre><code>import re
from datetime import datetime

ss = [
  "January 29-30 Meeting - 2013",
  "March 19-20 Meeting - 2013",
  "April/May 30-1 Meeting - 2013",
  "June 18-19 Meeting - 2013",
  "July 30-31 Meeting - 2013",
  "September 17-18 Meeting - 2013",
  "October 29-30 Meeting - 2013",
  "December 17-18 Meeting - 2013"
]

FORMAT = '%B %d %Y'

for s in ss:
    match = re.search(r"(\w+)\s(\d+)-(\d+)\s.*\s(\d{4})", s)
    if match:
        dt1 = datetime.strptime(f'{match.group(1)} {match.group(2)} {match.group(4)}', FORMAT)
        dt2 = datetime.strptime(f'{match.group(1)} {match.group(3)} {match.group(4)}', FORMAT)

        print (dt1, dt2)
</code></pre>
<p>Note that you also have the <code>April/May 30-1</code> complication in there, I'm not addressing that, since you are not asking about that.</p>
<p>As a bonus though:</p>
<pre><code>for s in ss:
    match = re.search(r"((\w+)/)?(\w+)\s(\d+)-(\d+)\s.*\s(\d{4})", s)
    if match:
        dt1 = datetime.strptime(
            f'{match.group(2) if match.group(2) else match.group(3)} {match.group(4)} {match.group(6)}', FORMAT)
        dt2 = datetime.strptime(
            f'{match.group(3)} {match.group(5)} {match.group(6)}', FORMAT)

        print (dt1, dt2)
</code></pre>
<p>Also, note the interesting, if a bit hacky solution offered by @blhsing below, involving <code>_strptime.TimeRE</code>. I would not recommend doing anything like that, but it is interesting to know you could actually change the behaviour of <code>strptime</code> itself that way.</p>
</div>
<span class="comment-copy">I assume it's going to be regex and out of my field, but what of <code>"April/May 30-1"</code>?</span>
<span class="comment-copy">You're right. I think I'll manage these exceptions manually... what a pain. Thanks for pointing it out.</span>
<span class="comment-copy">I think your answer is interesting, but not really a recommended way to go about it, since it changes the behaviour globally and could have very unexpected side effects for a larger script. I certainly would not call it Pythonic.</span>
<span class="comment-copy">Note that this is using <code>search</code> instead of <code>match</code> to make the first example work - the second example actually matches the entire string from the start, so you could consider using <code>match</code> instead.</span>
