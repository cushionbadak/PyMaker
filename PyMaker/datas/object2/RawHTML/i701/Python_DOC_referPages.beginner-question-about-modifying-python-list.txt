<div class="post-text" itemprop="text">
<p>I'm a newbie to python. Currently i'm learning about list. I try to add every words from the "words.txt" file to a list. But when I tried <pre>words += word</pre>
every characters becomes an element of the list. I tried <pre> words += [word] </pre> and it worked. But I want to know why the first way makes every characters an element and not words?</p>
<pre><code>fhand = open("words.txt")
words = list()
for line in fhand:
    for word in line.split():
        words += [word]
print(words)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>Word</code> is a string, which is itself a collection of objects(characters), if you used <code>word[0]</code>, you will get the 1st element in the word, by default python lists maintain data types, so a collection of characters remains a collection of characters when you append it to the list and results in a list of characters, in the second case you are explicitly declaring that you want to append <code>[word]</code> to the list, and not it's characters, so it becomes a list of strings. If that is still not clear feel free to comment.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you want to add word into list as an element.</p>
<p>usually use .append() </p>
<pre><code>fhand = open("words.txt")
words = list()
for line in fhand:
    for word in line.split():
        words.append(word)
print(words)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you only can add list to list, so when you add string to list you treat the string as list of characters so it adds the characters as elements, in second way you have declared that you have list and the word is element itself so it adds the whole word as element.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python, a string itself is internally a list of 'unicode' characters, albeit considered a different datatype. So when you do 
<code>words += word</code>
it appends each new character to the empty list. 
But when you do <code>words += [word]</code> , [word] is considered a list of one single string, so it appends only one item to the empty list</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>+=</code> operator on a <code>list</code> is equivalent to calling its <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer">extend</a> method, which takes an iterable as an argument and appends each item to the list. With <code>words += word</code>, the right hand operand of <code>+=</code> is a string, which is an iterable, so would be equivalent  to writing <code>words.extend(word)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Lets go through your code:</p>
<p>Consider <code>words.txt</code> consists of the following text:</p>
<pre><code>hello, I am Solomon
Nice to meet you Solomon
</code></pre>
<p>So, you first open this file with <code>fhand = open("words.txt")</code>, then you initialize a list called <code>words</code>:</p>
<pre><code>fhand = open("words.txt")
words = list()
</code></pre>
<p><strong>Suggestion</strong>: Here its advisable to use the <code>with</code> context manager to open the file. That way, you wouldn't have to close the file explicitly later. If you are just using <code>open()</code> as above, you'd have to close the file in the end with <code>fhand.close()</code>.</p>
<pre><code>with open("words.txt", 'r') as fhand:
    #&lt;--code---&gt;
</code></pre>
<p>In the next line, you iterate over each <code>line in fhand</code>. Lets print <code>line</code> which basically shows each line in the text:</p>
<pre><code>for line in fhand:
    print(line)
#Output:
hello, I am Solomon

Nice to meet you Solomon
</code></pre>
<p>Then you are iterating over <code>line.split()</code> which splits the above lines of text into individual lists of words. If we print <code>line.split()</code>:</p>
<pre><code>for line in fhand:
    print(line.split())
#Output:
['hello,', 'I', 'am', 'Solomon']
['Nice', 'to', 'meet', 'you', 'Solomon']
</code></pre>
<p><strong>Suggestion</strong>: You could also make use of <code>splitlines()</code> to break each line(boundary) into a separate list. This is different from <code>split()</code> as it does not break each line into words. This method also preserves whitespaces, so you will have to get rid of them with <code>strip(' ')</code> if your text has any whitespaces in the end or beginning. This method has no side effects and you can still use it:</p>
<pre><code>for line_str in fhand:
    print(line_str.strip(' ').splitlines())
    #Output:
    ['hello, I am Solomon']
    ['Nice to meet you Solomon']
    for line in line_str.strip(' ').splitlines(): #watch the indentation
        print(line.split())
        #Output:
        ['hello,', 'I', 'am', 'Solomon']
        ['Nice', 'to', 'meet', 'you', 'Solomon']
</code></pre>
<p>In the next piece of code you are iterating over each (word? or rather letter) in <code>line.split()</code> (as you know we received a list of words with this method before) and then incrementing <code>words</code> with the set of letters for each <code>word</code>. So, basically you get a set of letters because you iterated over each word in the lists:</p>
<pre><code>for word in line.split():
    words+=word
#Output:
['h', 'e', 'l', 'l', 'o', ',', 'I', 'a', 'm', 'S', 'o', 'l', 'o', 'm', 'o', 'n', 'N', 'i', 'c', 'e', 't', 'o', 'm', 'e', 'e', 't', 'y', 'o', 'u', 'S', 'o', 'l', 'o', 'm', 'o', 'n']
</code></pre>
<p>But most likely you are expecting a list of words in a single list <code>words</code>. We can achieve this with the <code>append()</code> method as it takes each <code>word</code> in <code>line.split()</code> and simply appends(or adds to the end of the list) to <code>words</code>:</p>
<pre><code>for word in line.split():
    words.append(word)
#Output:
['hello,', 'I', 'am', 'Solomon', 'Nice', 'to', 'meet', 'you', 'Solomon']
</code></pre>
<p>And then when we look at the other variation <code>words += [word]</code>:</p>
<pre><code>for word in line.split():
    words += [word]
print(words)
#Output:
['hello,', 'I', 'am', 'Solomon', 'Nice', 'to', 'meet', 'you', 'Solomon']
</code></pre>
<p>This has the same effect as <code>append()</code>. Why is that so? Lets print <code>[word]</code> which is nothing but a list of each word. This is expected because you are taking each <code>word</code> from <code>line.split()</code> and then concatenating to <code>words</code> :</p>
<pre><code>print([word])
#Output:
['hello,']
['I']
['am']
['Solomon']
['Nice']
['to']
['meet']
['you']
['Solomon']
</code></pre>
<p><code>words += [word]</code> is equivalent to <code>words = words + [word]</code>. To see how this concatenation works, consider the following example which is equivalent to this statement:</p>
<pre><code>words = list()
word = ["Hello"]
concat_words = words + word
print(concat_words)
#['Hello']
another_word = ["World"]
concat_some_more_words = words + another_word
print(concat_some_more_words)
#['World']
final_concatenation = concat_words + concat_some_more_words
print(final_concatenation)
#Output:
['Hello', 'World']
</code></pre>
<p>Lets try <code>append()</code> on this example:</p>
<pre><code>words1 = list()
words_splitted = ["Hello", "World"]
for word in words_splitted:
  words1.append(word)
print(words1)
#['Hello', 'World']
</code></pre>
<p>This shows that concatenation is equivalent to appending but it is recommended practice to use <code>append()</code> for lists:</p>
<pre><code>print(words1==final_concatenation)
#True
</code></pre>
<p>Returning back to the original question, let's make the whole code more compact using list comprehensions:</p>
<pre><code>with open("words.txt", 'r') as fhand:
    words = [word for line in fhand for word in line.split()]
print(words)
#Output:
['hello,', 'I', 'am', 'Solomon', 'Nice', 'to', 'meet', 'you', 'Solomon']
</code></pre>
<p>You will notice I've used the <code>with</code> context manager to leave file open/close to Python after the job is done(exits the context). Next, I've created a list <code>words</code> with the same loops inside. This is also called a list comprehension and is one of the most powerful features in Python. This makes the code more compact, easy to read and <a href="https://stackoverflow.com/questions/30245397/why-is-a-list-comprehension-so-much-faster-than-appending-to-a-list">faster than appending</a>.</p>
<p>Finally, initializing <code>words = []</code> is much more cleaner than <code>words = list()</code>. It is also much <a href="https://stackoverflow.com/questions/30216000/why-is-faster-than-list">faster</a>.</p>
</div>
<span class="comment-copy">List is a mutable object and string is an immutable and iterator object. So you are adding an iterator to a list. Hence, it is obvious that string gets iterated and then added each element to a list.</span>
<span class="comment-copy">It's a good advice but I don't see how it answers the question?</span>
<span class="comment-copy">@anand_v.singh, your answer is more clear than mine, I think. Thanks.</span>
<span class="comment-copy">Thank you for a very clear and constructive answer!!! I really appreciate your time and effort.</span>
<span class="comment-copy">You are welcome!</span>
