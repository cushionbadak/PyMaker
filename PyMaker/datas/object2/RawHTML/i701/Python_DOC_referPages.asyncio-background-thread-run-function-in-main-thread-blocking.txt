<div class="post-text" itemprop="text">
<p>I have two threads (main thread and some background thread), and both have their own asyncio event loop.</p>
<p>Now consider I'm in the background thread and I want to execute something (<code>func_for_main_thread</code>) in the main thread. Doing that async, would be this:</p>
<pre><code>main_thread_loop.call_soon_threadsafe(func_for_main_thread)
</code></pre>
<p>However, how can I do that synced/blocking, i.e. wait until <code>func_for_main_thread</code> executed?</p>
<p>Related is <a href="https://stackoverflow.com/questions/21646467/how-to-execute-a-functor-or-a-lambda-in-a-given-thread-in-qt-gcd-style">this</a> question, which asks the same question for Qt, and describes the same functionality of <a href="https://en.wikipedia.org/wiki/Grand_Central_Dispatch" rel="nofollow noreferrer">Apple GCD</a>, which is basically:</p>
<pre><code>dispatch_async(dispatch_get_main_queue(), ^{ /* do sth */ });
</code></pre>
<p>vs:</p>
<pre><code>dispatch_sync(dispatch_get_main_queue(), ^{ /* do sth */ });
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understood what you want correctly, nothing stops you from passing <a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future" rel="nofollow noreferrer">Future</a> to main thread to set it done once <code>func_for_main_thread</code> done. In background thread you can await for this future.</p>
<p>In other words:</p>
<pre><code>import asyncio
from functools import partial


async def called_threadsafe(loop, func):
    current_loop = asyncio.get_event_loop()
    fut = asyncio.Future()

    def call_and_set():
        try:
            res = func()
        except Exception as exc:
            f = partial(fut.set_exception, exc)
            current_loop.call_soon_threadsafe(f)
        else:
            f = partial(fut.set_result, res)
            current_loop.call_soon_threadsafe(f)
    loop.call_soon_threadsafe(call_and_set)  # submit to execute in other thread

    return await fut  # in current thread await other thread executed func and set future
</code></pre>
<p>Full code that demonstrates how it'll work:</p>
<pre><code>import asyncio
from functools import partial
import threading
import time


async def called_threadsafe(loop, func):
    current_loop = asyncio.get_event_loop()
    fut = asyncio.Future()

    def call_and_set():
        try:
            res = func()
        except Exception as exc:
            f = partial(fut.set_exception, exc)
            current_loop.call_soon_threadsafe(f)
        else:
            f = partial(fut.set_result, res)
            current_loop.call_soon_threadsafe(f)
    loop.call_soon_threadsafe(call_and_set)

    return await fut


# helpers:
_l = threading.Lock()

def info(*args):
    with _l:
        print(*args, threading.get_ident(), flush=True)


def start_bg_loop():
    bg_loop = asyncio.new_event_loop()

    def startup():
        asyncio.set_event_loop(bg_loop)
        bg_loop.run_forever()

    t = threading.Thread(target=startup)
    t.daemon = True
    t.start()

    return bg_loop


# main part:
def func_for_main_thread():
    info('executed in fg thread')
    time.sleep(0.05)
    return 'got result in bg thread'


async def bg_main(fg_loop):
    info('bg_main started')
    await asyncio.sleep(0.1)

    res = await called_threadsafe(fg_loop, func_for_main_thread)
    info(res)

    info('bg_main finished')


async def fg_main(bg_loop):
    info('fg_main started')
    await asyncio.sleep(1)
    info('fg_main finished')


fg_loop = asyncio.get_event_loop()
bg_loop = start_bg_loop()

asyncio.run_coroutine_threadsafe(bg_main(fg_loop), bg_loop)
fg_loop.run_until_complete(fg_main(bg_loop))
</code></pre>
<p>Output:</p>
<pre><code>fg_main started 2252
bg_main started 5568
executed in fg thread 2252
got result in bg thread 5568
bg_main finished 5568
fg_main finished 2252
</code></pre>
</div>
