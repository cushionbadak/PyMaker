<div class="post-text" itemprop="text">
<p>In python 3.3 and later, when we override <code>__new__()</code>, we don't have to pass arguments and keyword arguments to <code>super().__new__()</code> or <code>object.__new__()</code>. But this call to <code>super().__new__()</code> returns an instance of a class.  </p>
<p>How does python pass the rest of the arguments to <code>__init__</code> then?</p>
<pre><code>class Spam(object):
    ''' Hello I am Spam '''

    def __new__(cls, *args, **kwargs):
        print("Creating Instance")
        instance = object.__new__(cls) # Who passed *args and **kwargs to __init__?
        print(instance)
        return instance

    def __init__(self, a, b):
        print("Init Called")
        self.a = a
        self.b = b
</code></pre>
<p>Can someone please explain whats happening here?  </p>
</div>
<div class="post-text" itemprop="text">
<p>You passed <em>cls</em> as an argument to <code>object.__new__</code>, so the interpreter can check whether <em>instance</em> is an instance of <em>cls</em>.</p>
<p>The <em>initializer</em> (<em>__init__</em>) is  automatically called by the <em>allocator</em> (<em>__new__</em>) as <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">[Python 3]: object.<strong>__new__</strong>(<em>cls[, ...]</em>)</a> (<strong>emphases</strong> are mine) states:</p>
<blockquote>
<p>If <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">__new__()</a> returns an instance of <em>cls</em>, <strong>then the new instance’s <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" rel="nofollow noreferrer">__init__()</a> method will be invoked like <code>__init__(self[, ...])</code></strong>, where <em>self</em> is the new instance and <strong>the remaining arguments are the same as were passed to <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">__new__()</a></strong>.</p>
<p>If <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">__new__()</a> does not return an instance of cls, then the new instance’s <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" rel="nofollow noreferrer">__init__()</a> method will <strong>not</strong> be invoked.</p>
</blockquote>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys


class Spam(object):
    ''' Hello I am Spam '''

    def __new__(cls, *args, **kwargs):
        print("Creating Instance")
        instance = object.__new__(cls) # Who passed *args and **kwargs to __init__?
        print(instance)
        #return instance  # If you return anything else (1, object(), or None by commenting the line) here, __init__ won't be called
        if len(sys.argv) == 1:  # DO NOT DO THIS!!! It's just for demo purposes
            return instance


    def __init__(self, a, b):
        print("Init Called")
        self.a = a
        self.b = b


def main():
    spam = Spam(1, 2)
    print(type(spam), dir(spam))


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>e:\Work\Dev\StackOverflow\q054511671&gt;"e:\Work\Dev\VEnvs\py_064_03.06.08_test0\Scripts\python.exe" code.py
Python 3.6.8 (tags/v3.6.8:3c6b436a57, Dec 24 2018, 00:16:47) [MSC v.1916 64 bit (AMD64)] on win32

Creating Instance
&lt;__main__.Spam object at 0x000001F8E24D14E0&gt;
Init Called
&lt;class '__main__.Spam'&gt; ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'a', 'b']

e:\Work\Dev\StackOverflow\q054511671&gt;"e:\Work\Dev\VEnvs\py_064_03.06.08_test0\Scripts\python.exe" code.py arg
Python 3.6.8 (tags/v3.6.8:3c6b436a57, Dec 24 2018, 00:16:47) [MSC v.1916 64 bit (AMD64)] on win32

Creating Instance
&lt;__main__.Spam object at 0x0000020808F71550&gt;
&lt;class 'NoneType'&gt; ['__bool__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
</code></pre>
</blockquote>
<p>Note that this isn't specific  to <em>Python <strong>3</strong></em></p></div>
<div class="post-text" itemprop="text">
<p>What matters here is the initial call, say <code>spam = Spam('x', 1)</code>.</p>
<p>Internally, Python calls <code>__new__</code> as a class method on class <code>Spam</code> <strong>with the passed parameters</strong>. What <code>Spam.__new__</code> actually does is not really important, it is just supposed to return an object.</p>
<p>It does use <code>object.__new__</code> to build a <code>Spam</code> object. As the created object has the correct class, Python calls <code>__init__</code> on it <strong>with the initial parameters</strong>.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new">Why is __init__() always called after __new__()?</a></span>
<span class="comment-copy">This is very helpful, thanks for the response. Though I am not sure what is the intent behind this behavior.</span>
<span class="comment-copy">What do you mean? It's kind of obvious. The syntax is clearer (simpler for the user). Note that the same thing also works in <i>Python <b>2.7.15</b></i></span>
<span class="comment-copy">Thanks Serge. The point mentioned by @ChristiFati is really worth understanding. I am not sure how that "return instance" statement is making a difference. Even if it makes a difference what could have been an intent behind that.</span>
