<div class="post-text" itemprop="text">
<p>I need to create a list of datetime elements every minute from 2007-01-01 00:00 to 2016-01-01 00:00 but without February 29th. My code is the next:</p>
<pre><code>dates = []
date0 = datetime(2007, 1, 1, 0, 0)
delta = td(minutes=1)
while date0 &lt; datetime(2016, 1, 1, 0, 0):
    if date0.date != date(2008, 2, 29) and date0.date != date(2012, 2, 29):
        dates.append(date0)
    date0 = date0 + delta
</code></pre>
<p>I should have a list for 9 years without 29.02. But my list of dates still contains February 29th of 2008 and 2012. I was trying to apply this code:</p>
<pre><code>while date0 &lt; datetime(2016, 1, 1, 0, 0):
    if date0.month != 2 and date0.day != 29:
        dates.append(date0)
    date0 = date0 + delta 
</code></pre>
<p>but as a result I have a list, which does not contain an appropriate number of days, anly 8 years and 14 days.
Do you have any solution or ideas about solving the issue? </p>
</div>
<div class="post-text" itemprop="text">
<p>How about:</p>
<pre><code>if not (date0.month == 2 and date0.day == 29):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this easily with <a href="https://pandas.pydata.org/" rel="nofollow noreferrer"><code>pandas</code></a> a popular external data manipulation package:</p>
<pre><code>In []:
import pandas as pd
dr = pd.date_range(start='1/1/2007', end='1/1/2016', freq='1min')
dates = dr[(dr.day != 29) | (dr.month != 2)]

len(dr), len(dates)

Out[]:
(4733281, 4730401)
</code></pre>
<p>This takes about <code>700ms</code> on my machine.</p>
<pre><code>In []:
dates

Out[]:
DatetimeIndex(['2007-01-01 00:00:00', '2007-01-01 00:01:00', '2007-01-01 00:02:00', '2007-01-01 00:03:00',
               '2007-01-01 00:04:00', '2007-01-01 00:05:00', '2007-01-01 00:06:00', '2007-01-01 00:07:00',
               '2007-01-01 00:08:00', '2007-01-01 00:09:00',
               ...
               '2015-12-31 23:51:00', '2015-12-31 23:52:00', '2015-12-31 23:53:00', '2015-12-31 23:54:00',
               '2015-12-31 23:55:00', '2015-12-31 23:56:00', '2015-12-31 23:57:00', '2015-12-31 23:58:00',
               '2015-12-31 23:59:00', '2016-01-01 00:00:00'],
              dtype='datetime64[ns]', length=4730401, freq=None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a relatively efficient, Pure Pythonâ„¢, way to do it. The way leap days are skipped is simply by <strong>not</strong> including them in the <code>_DAYS_IN_MONTH</code> table (so nothing special is done depending on whether or not the current year being processed is a leap year).</p>
<p>I don't know precisely why you [think] you need this, but it might be better to do it via a <a href="https://docs.python.org/3/howto/functional.html#generators" rel="nofollow noreferrer">generator function</a>, which would eliminate the need of storing so many <code>datatime</code> objects in memory at the same time. </p>
<pre><code>from datetime import datetime

_DAYS_IN_MONTH = [31,28,31,30,31,30,31,31,30,31,30,31]  # Ignores leap days.

start_year, end_year = 2007, 2016
dates = []
for year in range(start_year, end_year):
    for month in range(1, 13):
        for day in range(1, _DAYS_IN_MONTH[month-1]+1):
            for hour in range(0, 24):
                for minute in range(0, 60):
                    dates.append(datetime(year, month, day, hour, minute))


print('len(dates): {:,d}'.format(len(dates)))  # -&gt; len(dates): 4,730,400
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't compare attributes of the datetime object to the object itself, and that is what is causing the problem. </p>
<pre><code>from datetime import datetime, timedelta

dates = []
date0 = datetime(2007, 1, 1, 0, 0)
delta = timedelta(minutes=1)


def get_leaps(startyear, endyear):
    leapyears = []
    for i in range(startyear, endyear):
        if (i%400 == 0)or ((i%4 == 0) and (i%100 != 0)):
            leapyears.append(i)
    for y in leapyears:
        for i in range(24):
            for j in range(60): 
                yield datetime(y, 2, 29, i, j))


while date0 &lt; datetime(2016, 1, 1, 0, 0):
    if date0 not in get_leaps(2007, 2016):
        dates.append(date0)
    date0 += delta 
</code></pre>
<p>This should be the solution. This is by no means optimized and is very unpythonic, but see if you can improve it. I have a chemistry exam tomorrow and I don't have time. Cheers!</p>
</div>
<span class="comment-copy">That's potentially a huge number of <code>datatime</code>s (525K per year) and your overall approach to generating them is <i>very</i> inefficient. Why do you want to do this? I suspect the might be an <a href="http://xyproblem.info/" rel="nofollow noreferrer">XY-Problem</a>.</span>
<span class="comment-copy">Agree with @martineau - but if you do need a date range then you could look into <code>pandas</code> - see answer below.</span>
<span class="comment-copy">Thank you, this is the most simple way</span>
<span class="comment-copy"><code>i % 4 == 0</code> is not a valid leap year test.</span>
<span class="comment-copy">@martineau thanks for pointing that out, I've updated it.</span>
