<div class="post-text" itemprop="text">
<p>I'm using python and I want to create a class that has many variables, some of them will be normal variables and others will need to be updated to a server. I have a loop that runs over all the object's variables but I don't know how to identify which variables need to be updated. <strong>I could have those objects as a class with one variable but I would prefer not to.</strong> Is there an acceptable way to achieve this?</p>
<p>I want something like Unity has in its C# library where you can define a regular int like <code>public int health = 100;</code> but you can also define it as <code>[SyncVar] public int health =100;</code> and then you can use the variable as you normally would except it has that extra data.</p>
<p>The loop that checks the object's variable looks like this:</p>
<pre><code>def send_sync_vars(o):    
    for k, v in o.__dict__.iteritems():
        if isinstance(v, SyncVar):
            update_var(k ,v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no way to add annotations to attributes like in C#. (Newer versions of python <em>do</em> support <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">type annotations</a>, but those are for, well, <em>type</em> annotations. I would advise against abusing them for a different purpose.)</p>
<p>The easiest way label a bunch of attributes as SyncVars is probably to store their names in a class attribute:</p>
<pre><code>class MyClass:
    SYNC_VARS = {'foo', 'bar'}

    def __init__(self, foo, bar, baz):
        self.foo = foo
        self.bar = bar
        self.baz = baz

def send_sync_vars(o):    
    for k, v in vars(o).items():
        if k in o.SYNC_VARS:
            update_var(k, v)
</code></pre>
<p>Another possibility would be to over-engineer the whole thing and implement those attributes as <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>:</p>
<pre><code>class SyncVar(property):
    def __init__(self, fget=None, fset=None, fdel=None, *args, **kwargs):
        if fget is None:
            fget = self.default_getter

        if fset is None:
            fset = self.default_setter

        if fdel is None:
            fdel = self.default_deleter

        super().__init__(fget, fset, fdel, *args, **kwargs)

    @staticmethod
    def default_getter(self):
        return self._value

    @staticmethod
    def default_setter(self, value):
        self._value = value

    @staticmethod
    def default_deleter(self):
        del self._value

class MyClass:
    foo = SyncVar()
    bar = SyncVar()

    def __init__(self, foo, bar, baz):
        self.foo = foo
        self.bar = bar
        self.baz = baz

def send_sync_vars(o):    
    for k, v in vars(type(o)).items():
        if isinstance(v, SyncVar):
            v = getattr(o, k)
            update_var(k, v)
</code></pre>
</div>
<span class="comment-copy">Please, share your code</span>
<span class="comment-copy">Does your solution work?</span>
<span class="comment-copy">It does but then when I use the variable I have to check if it is a SyncVar because I need to write var.value instead of just var. It makes using those variables not comfortable and the code look much denser.</span>
<span class="comment-copy">If you're defining your own variables, you can consider using <code>@property</code> and <code>@SyncVar.setter</code> to help you?</span>
<span class="comment-copy">I've never seen those, could you explain more?</span>
<span class="comment-copy">Thank you for taking the time to write a clear answer, the second possibility is what I'm looking for, I tried to run <code>def send_sync_vars(o):     for k, v in vars(type(o)).items():         if isinstance(v, SyncVar):             print '%s is a sync var' % k   o1 = MyClass('fooVar', 2, [1, 2, 3]) send_sync_vars(o1)</code> but nothing printed, any idea why?</span>
<span class="comment-copy">@Koby27 Not sure, it should work. Did you maybe forget to add the <code>foo = SyncVar()</code> assignment <i>in the class body</i>?</span>
<span class="comment-copy">@Koby27 Actually, I forgot you're using python 2. I think in python 2 descriptors only work in new-style classes, so let <code>MyClass</code> inherit from <code>object</code>: <code>class MyClass(object):</code>.</span>
<span class="comment-copy">It works, thanks!</span>
