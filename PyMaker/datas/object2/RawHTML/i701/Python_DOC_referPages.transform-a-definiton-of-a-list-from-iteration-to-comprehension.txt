<div class="post-text" itemprop="text">
<p>I have a method which takes a list of edges, an edge has this form : <code>(v1,v2,capacity)</code> and returns a dictionary of this form: </p>
<pre><code>dico = {v1:{v2:capacity,v3:capacity} v2:...}
</code></pre>
<p>this <code>dico</code> represent a graph </p>
<p>I want to define this dico by the comprehension way but I'm really blocked and I'm not even sure that we can do that so can someone tell me if it is possible ?
this is my function:</p>
<pre><code>def _init_from_edges(self, edges):
    self._G={}
    for e in edges:
        if e[0] in self._G:
            self._G[e[0]][e[1]]=e[2]
        else:
            self._G[e[0]]={e[1]:e[2]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code can't take advantage of <code>dict</code> comprehensions easily because it's effectively a multidict (where a key doesn't have one value, but many).</p>
<p>You can simplify the code a bit <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">with <code>collections.defaultdict</code></a>:</p>
<pre><code>from collections import defaultdict

def _init_from_edges(self, edges):
    self._G = defaultdict(dict)
    for v1, v2, capacity in edges:
        self._G[v1][v2] = capacity
    # Optional: Remove defaultdict behaviors after building
    self._G = dict(self._G)
</code></pre>
<p>Using <code>defaultdict(dict)</code> means when a key isn't in the dictionary, it's immediately created with a brand new <code>dict</code>, so you don't need to perform membership testing at all.</p>
<p>Note that I also used unpacking to named variables instead of repeated indexing to make the code a bit more self-documenting.</p>
<p>The only way to make this work with an actual <code>dict</code> comprehension would be to either:</p>
<ol>
<li>Rescan the <code>edges</code> once for every input to gather all <code>v2</code>/<code>capacity</code> pairs for a given <code>v1</code> (but that's <code>O(n**2)</code>, so it's a bad idea if <code>edges</code> can be large)</li>
<li>Pack all the values for each <code>v1</code> together ahead of time, so each sub-<code>dict</code> can be constructed all at once.</li>
</ol>
<p>Since option #1 is generally pretty wasteful, the only practical way to do this as a <code>dict</code> comprehension without rescanning <code>edges</code> over and over is option #2, which you <em>can</em> do in <code>O(n log n)</code> with sorting <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">followed by <code>itertools.groupby</code></a>:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

def _init_from_edges(self, edges):
    self._G = {v1: {v2: capacity for _, v2, capacity in grp}
               for v1, grp in groupby(sorted(edges, key=itemgetter(0)),
                                      key=itemgetter(0))}
</code></pre>
<p>That requires <code>O(n log n)</code> work to sort <code>edges</code> (if <code>edges</code> is already sorted, Python's TimSort means it's closer to <code>O(n)</code> work), then <code>O(n)</code> work to group the results. Faster than <code>{v1: {v2: capacity for v, v2, capacity in edges if v == v1} for v1, _, _ in edges}</code>, but still slower than the non-comprehension approach with <code>defaultdict</code> (which is <code>O(n)</code> under all circumstances).</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a little convoluted, but it seems to work:</p>
<pre><code>edges = [(1, 2, 3),
         (1, 3, 4),
         (2, 1, 5),
         (2, 3, 6),
         (2, 2, 7)]
dico = {v1: {v2: cap for v, v2, cap in edges if v == v1} for v1, _, _ in edges}
# {1: {2: 3, 3: 4}, 2: {1: 5, 2: 7, 3: 6}}
</code></pre>
<p>Basically for each <code>v1</code>, it adds every key: value pair in <code>edges</code> with that <code>v1</code>. The outer comprehension doesn't need <code>v2</code> or <code>cap</code>, so it just uses underscores to ignore those values. The inner loop needs to compare <em>its</em> value of <code>v1</code> with the outer loop's value, which is why it uses a different name.</p>
</div>
<span class="comment-copy">Not sure why you are driven to use a comprehension (which is for me one of those features of Python that to me seems more driven by ‘gee-whiz we can do this in a single line’ than by a need for maintainable code) when the code you show is pretty straightforward - although I don’t see where it creates the v3:capacity unless you repeat this in your edges list. Please show some example content you are assuming for the edges list.</span>
<span class="comment-copy">In fact please edit into your question a Minimal Complete Verifiable Example of your current code <a href="https://www.stackoverflow.com/help/mcve">stackoverflow.com/help/mcve</a></span>
<span class="comment-copy">@barny: There is nothing wrong with comprehensions in general. They're (usually) faster, and (usually) more straightforward to read than equivalent loops <i>when they're doing simple stuff</i>. Used correctly (as a side-effect-free functional construct), they're a hint to the maintainer that the code is simple enough to function as a simple filter/transform of one input to another (where normal loop is unrestricted in having side-effects, even by convention). That said, I agree that the OP's particular case wouldn't benefit from a comprehension; it could be made to work, but it shouldn't.</span>
<span class="comment-copy">I have no complaint about the functionailty or speed of comprehensions, it’s their inpenetrability to debugging when they don’t work - i.e. their unmaintainability - that makes them a little-used feature of Python for me. I don’t want to encourage anyone to use them for real code. For fun, for education, fine -  and recursion is of a similar ilk - but not for real code that someone else might have to try to understand and update.</span>
<span class="comment-copy">I encountered this today - I don't think it's a shining justifcation for the use of comprehensions because these two lines of code just as easily have been implemented using a single for loop with one extra line and far more clearly. <code>empty_props = [p for p,v in list(self.predicates.items()) if not v]         list(map(lambda k: self.predicates.pop(k, None), empty_props))</code> with the second line constructing an unused list only as a way of doing the pop. This is comprehension-obscurantism - I'm sure there are far worse examples, but my point is that comprehensions aren't always better</span>
<span class="comment-copy">Note: This is a <code>O(n**2)</code> solution, since it must perform a full linear scan of <code>edges</code> for every <code>v1</code> in <code>edges</code> (constructing the same <code>dict</code> for each <code>v1</code> as many times as that <code>v1</code> appears in <code>edges</code>). While it wouldn't reduce the big-O (since you can't assume any <code>v1</code> appears more than once), you could at least reduce the effective cost to <code>O(n * m)</code>, where <code>m</code> is the <i>unique</i> <code>v1</code> values, by changing <code>for v1, _, _ in edges</code> to <code>for v1 in {v1 for v1, _, _ in edges}</code>, which uniquifies the <code>v1</code>s to iterate over so you only scan <code>edges</code> and construct a new sub-<code>dict</code> once per unique <code>v1</code>.</span>
<span class="comment-copy">Whilst I recognize that you are answering the OP’s question/challenge, and I admire your determination in condensing the dictionary construction to a single line of code, I don’t see how anyone is ever going to maintain that code - so I don’t see that it has any real-world value. Well done.</span>
