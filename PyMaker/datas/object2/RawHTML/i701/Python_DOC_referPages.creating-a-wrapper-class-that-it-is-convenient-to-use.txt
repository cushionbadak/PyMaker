<div class="post-text" itemprop="text">
<p>In order to keep track of both the current and the previous value of certain variables that are continually updated inside of a loop, I created a wrapper class that automatically stores the old value inside of it when it is updated:</p>
<pre class="lang-python prettyprint-override"><code>class Updatable:
    def __init__(self, value=None, prev_value=None):
        # Initial conditions
        self._value = value
        self._prev_value = prev_value

    @property
    def value(self):
        return self._value

    @property
    def prev_value(self):
        return self._prev_value

    def update(self, new_value):
        self._prev_value = self._value
        self._value = new_value

    def has_value(self):
        return self._value is not None

    def has_prev_value(self):
        return self._prev_value is not None
</code></pre>
<p>However, in order for it to work more like a normal variable, I want all the ordinary operators to work as expected (except assignment, which cannot be overloaded in Python), so I have defined many of the special methods that a class can have:</p>
<pre class="lang-python prettyprint-override"><code>    # Object representation
    def __str__(self):
        return str(self._value)

    def __repr__(self):
        return repr(self._value)

    # Iteration
    def __len__(self):
        return len(self._value)

    def __getitem__(self, key):
        return self._value[key]

    def __reversed__(self):
        return reversed(self._value)

    # Arithmetic operations
    def __add__(self, other):
        return self._value + other

    def __sub__(self, other):
        return self._value - other

    def __mul__(self, other):
        return self._value * other

    def __matmul__(self, other):
        return self._value @ other

    def __truediv__(self, other):
        return self._value / other

    def __floordiv__(self, other):
        return self._value // other

    def __mod__(self, other):
        return self._value % other

    def __divmod__(self, other):
        return divmod(self._value, other)

    def __pow__(self, other, *args):
        return pow(self._value, other, *args)

    def __lshift__(self, other):
        return self._value &lt;&lt; other

    def __rshift__(self, other):
        return self._value &gt;&gt; other

    def __and__(self, other):
        return self._value &amp; other

    def __xor__(self, other):
        return self._value ^ other

    def __or__(self, other):
        return self._value | other

    # Comparison operators
    def __eq__(self, other):
        return self._value == other

    def __ne__(self, other):
        return self._value != other

    def __lt__(self, other):
        return self._value &lt; other

    def __gt__(self, other):
        return self._value &gt; other

    def __le__(self, other):
        return self._value &lt;= other

    def __ge__(self, other):
        return self._value &gt;= other
</code></pre>
<p>While this may seem like a lot of special methods, it is still far from <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">all special methods</a>, and supporting all of them would mean even more boiler plate code than what I already have.</p>
<p>Furthermore, defining these special methods doesn't allow me to use an instance as the second operand in a binary operation. For example, while the code</p>
<pre class="lang-python prettyprint-override"><code>a = Updatable(2)
a + 3
</code></pre>
<p>works, the code</p>
<pre class="lang-python prettyprint-override"><code>a = Updatable(2)
3 + a
</code></pre>
<p>results in the error <code>TypeError: unsupported operand type(s) for +: 'int' and 'Updatable'</code>, which is undesirable if it is going to be convenient to use.</p>
<p>Is there some other approach to creating a wrapper class that is (almost) as convenient to use as using the datatype it is wrapping directly (neglecting the fact that when using the naked datatype, you won't have access to the previous value unless you store it explicitly)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Add this to your class defination:</p>
<pre><code># Arithmetic operations
def __radd__(self, other):
    return other + self._value

def __add__(self, other):
    return self._value + other 
</code></pre>
<p>and then</p>
<pre><code>a = Updatable(2)
3 + a
</code></pre>
<p>Output: </p>
<pre><code>5
</code></pre>
<p>With the original function defination <code>__add__</code>:</p>
<pre><code>a = Updatable(2)
a + 3
</code></pre>
<p>Output:</p>
<pre><code>5
</code></pre>
</div>
<span class="comment-copy">For <code>3 + a</code> to work, you might need to define <a href="https://docs.python.org/3/reference/datamodel.html#object.__radd__" rel="nofollow noreferrer"><code>__radd__</code></a>. Yes, that's a lot of boilerplate code. Now, do you really need all of these methods?</span>
<span class="comment-copy">If you know the expected type of <code>_value</code> variable, just inherit from built in type, eg. <code>class Updatable(int): (...)</code></span>
<span class="comment-copy">I'd encourage the poster to consider telling us what the real problem is (unless this is purely an intellectual exercise). I suspect it may be an <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a></span>
<span class="comment-copy">@KWierzbicki the problem with inheriting from <code>int</code> or similar objects is that methods inherited from <code>int</code> will return <code>int</code> results, losing the desired cacheing behaviour.</span>
<span class="comment-copy">Possibly related <a href="https://stackoverflow.com/questions/6727491/track-changes-of-atributes-in-instance-python" title="track changes of atributes in instance python">stackoverflow.com/questions/6727491/â€¦</a></span>
<span class="comment-copy">Nice, although I would change the order of the operands in the <code>+</code> operation, otherwise it will fail for datatypes with <a href="https://en.wikipedia.org/wiki/Commutative_property" rel="nofollow noreferrer">noncommutative</a> plus operators, such as <code>str</code>.</span>
<span class="comment-copy">Could you switch the order of the operands in the <code>+</code> operation in your answer, please?</span>
