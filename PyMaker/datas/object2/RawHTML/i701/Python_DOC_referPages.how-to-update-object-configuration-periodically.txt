<div class="post-text" itemprop="text">
<p>I`m writing a connector to our CRM system. CRM has its own configurations I want to be aware of. CRM is the only source of trust for these configurations and provides them via an API. Now I have my connector in python package as a python class. CRM configurations are updated on <strong>init</strong>, but as soon as they can be changed from CRM I want them to be periodically updated. Is there any good way to create some kind of task on object instance creation to perform configuration updates?</p>
<pre><code>class Crm:
    def __init__(self, crm_config, mongo_connection_string):
        self.update_crm_configuration()

    def update_crm_configuration(self):
        self.crm_configuration = self.get_crm_configuration_from_crm_api()

    def get_crm_configuration_from_crm_api(self):
        r = self._send_crm_request_wrap(send_request_func=self._send_get_crm_configuration)
        return self._parse_crm_configuration_response(r.text)
</code></pre>
<p>Now I update configurations one time, but I need to update them periodically.</p>
</div>
<div class="post-text" itemprop="text">
<p>It appears the best way is not to use a different thread or task with periodic updates, but save last time the configuration was updated and if this time exits some timeout update the configuration before actually performing the request.</p>
<p>Or if your API has the luxury of good exceptions for the "Configuration was changed" it is even better to perform the configuration update on response handler before the request retry.</p>
<p>I`m using a request wrapper for these purposes.</p>
<pre><code>    def _send_crm_request_wrap(self, send_request_func, func_params=(),
                               check_crm_configuration=True,
                               retries_limit=None):
        if check_crm_configuration \
                and time.time() - self.last_update_crm_configuration_time &gt; CRM_CONFIGURATION_TIMEOUT:
            self.update_crm_configuration()

        while self.is_crm_locked():
            time.sleep(1000)

        if not self.is_authorized():
            self.auth()

        r = send_request_func(*func_params)
        if retries_limit is None:
            retries_limit = self.max_retries
        retry = 1
        while r.status_code == 205 and retry &lt;= retries_limit:
            waiting_time = randint(1000, 2000)
            logging.info(f'Retry {retry} for {send_request_func.__name__}. Waiting for {waiting_time} sec')
            time.sleep(waiting_time)
            r = send_request_func(*func_params)
            retry += 1

        if r.status_code not in [200]:
            message = f'AMO CRM {send_request_func.__name__} with args={func_params} failed. ' \
                      f'Error: {r.status_code} {r.text}'
            logging.error(message)
            raise ConnectionError(message)

        return r
</code></pre>
</div>
<span class="comment-copy">You can take a look at <a href="https://pypi.org/project/python-crontab/" rel="nofollow noreferrer">crontab</a> or use a restarting timer as described <a href="https://stackoverflow.com/a/24072850/3767239">here</a>.</span>
<span class="comment-copy">The main issue with threading for this problem is that you cannot pass object instance as a parameter for another thread and thus you cannot simply update the object calling its own function. I believe some tricky object serialization can help, but obviously, it is not an easy and transparent solution.</span>
<span class="comment-copy">Of course you can, with threading there's no problem, only for multiprocessing you would need serialization. For example <a href="https://docs.python.org/3/library/threading.html#threading.Thread" rel="nofollow noreferrer"><code>threading.Thread</code></a> you can pass <code>args=...</code> which will be arguments to the threaded function.</span>
