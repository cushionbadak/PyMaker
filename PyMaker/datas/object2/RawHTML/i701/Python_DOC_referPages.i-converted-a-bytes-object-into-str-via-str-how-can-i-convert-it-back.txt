<div class="post-text" itemprop="text">
<p>I converted some Chinese characters into UTF-8 in a string object for some operations.  I now have a problem when I try to convert the string object back into a bytes object.</p>
<p>I tried using <code>bytes()</code>:</p>
<pre><code>a = 'ä¸€'
bytes_value = a.encode('utf-8') 
string_value = str(b)
bytes_value_again = bytes(string_value)
</code></pre>
<p>I want to convert it back to a bytes object, so I can use <code>decode('utf-8')</code> to convert it back to the original Chinese characters.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should not convert <code>bytes</code> objects to strings with <code>str(bytes_value)</code>. You created a <a href="https://docs.python.org/3/library/functions.html#repr" rel="nofollow noreferrer">printable representation of the object</a>.</p>
<p>The proper way to convert from <code>bytes</code> to <code>str</code> is to <em>decode</em> the bytes to Unicode. If you have UTF-8 bytes, decode with that codec with the <a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode" rel="nofollow noreferrer"><code>bytes.decode()</code> method</a>:</p>
<pre><code>string_value = bytes_value.decode('utf8')
</code></pre>
<p>You <em>can</em> also specify the encoding if you want to use the <code>str()</code> function, see the  <a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow noreferrer"><code>str(bytes_value, encoding)</code> form in the documentation</a>:</p>
<pre><code>string_value = str(bytes_value, 'utf8')
</code></pre>
<p>If you accidentally used <code>str(bytes_value)</code> and can't now get the original value by fixing that error and re-running your code, you can recover the original value by using <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval()</code></a>:</p>
<pre><code>bytes_representation = str(bytes_value)  # "b'....'"
recovered_bytes_value = ast.literal_eval(bytes_representation)
</code></pre>
<p><strong>This should only be used to recover data, not as a production-level serialisation mechanism</strong>. <code>ast.literal_eval()</code> is quite slow, and not safe from denial-of-service attacks when used on user-supplied input (it is possible to crash Python or significantly slow it down with bad input).</p>
<p>If you are using an API that should really work on bytes but for some reason is only accepting strings (usually a warning sign of a incorrectly designed and implemented API), then either use a <a href="https://docs.python.org/3/library/binascii.html" rel="nofollow noreferrer">binary-to-ASCII encoding</a> (including <a href="https://docs.python.org/3/library/base64.html" rel="nofollow noreferrer">base64 / base16 / base32 / base85</a>) or decode the binary data as Latin-1.</p>
<p>This is even more important if you are doing this to encrypt data. The printable representation of a <code>bytes()</code> object only ever uses ASCII characters, always starts with <code>b'</code> or <code>b"</code>, and always ends in <code>'</code> or <code>"</code>. Any non-printable bytes (more than half of all 256 possible byte values) are represented with a limited range of <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow noreferrer"><code>\x{hh}</code> and <code>\{l}</code> escape sequences</a>. All this makes it much easier for a determined attacker to break your encryption. A best-practices encryption library will let you encrypt <code>bytes</code> directly. In fact, it is usually <em>preferred</em> to encrypt bytes.</p>
</div>
<span class="comment-copy">@Martijn Pieters I know, the reason why I use str() is that I need the string like " b'\xe5\x8d\xa4' " for calculation ( encrypt )</span>
<span class="comment-copy">No, encryption should normally be done on <i>bytes</i>, not on a string. Even if you do need to do it on a string, you want to <b>decode</b> the data. Either as UTF-8, or if a one-on-one byte-to-character mapping is needed, as Latin-1.</span>
<span class="comment-copy">You do <b>not</b> want to encrypt the <code>'b'</code> character at the start, the two quote characters, or the <code>\xHH</code> escape sequences. That's a much more limited characterset, if an attacker ever guessed that you made that mistake they'd have a huge lever to crack your encryption.</span>
<span class="comment-copy">@Martijn Pieters Thanks, that's very helpful. I am just learning cryptography and do some practice, and I know it is unsafe.</span>
