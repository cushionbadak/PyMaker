<div class="post-text" itemprop="text">
<p>I was fooling around with the <a href="https://docs.python.org/3/library/sys.html#sys.setrecursionlimit" rel="nofollow noreferrer">recursion limit</a> in Python, which may be dynamically altered using <code>sys.setrecursionlimit(limit)</code>. The code below demonstrates that the integer <code>limit</code> exactly corresponds to the maximum depth allowed for recursive function calls.</p>
<p>For recursive <em>indexing</em> using <code>[]</code>, the same recursion limit seems to apply, but apparently with a factor of 3, meaning that I can index three times deeper than I can call:
<a href="https://i.stack.imgur.com/NHCxz.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/NHCxz.png"/></a></p>
<p>The above plot is generated by the code below.</p>
<pre><code>import itertools, sys
import numpy as np
import matplotlib.pyplot as plt

limits = np.arange(10, 500, 100)

# Find max depth of recursive calls
maxdepth = []
for limit in limits:
    sys.setrecursionlimit(limit)
    try:
        n = [0]
        def fun(n=n):
            n[0] += 1
            fun()
        fun()
    except RecursionError:
        maxdepth.append(n[0])
a, b = np.polyfit(limits, maxdepth, 1)
plt.plot(limits, maxdepth, '*')
plt.plot(limits, a*limits + b, '-', label='call')
plt.text(np.mean(limits), a*np.mean(limits) + b, f'slope = {a:.2f}')

# Find max depth of getitem
maxdepth = []
n = 0
l = []; l.append(l)
for limit in limits:
    sys.setrecursionlimit(limit)
    for n in itertools.count(n):
        try:
            eval('l' + '[-1]'*n)
        except RecursionError:
            break
    maxdepth.append(n)
a, b = np.polyfit(limits, maxdepth, 1)
plt.plot(limits, maxdepth, '*')
plt.plot(limits, a*limits + b, '-', label='getitem')
plt.text(np.mean(limits), a*np.mean(limits) + b, f'slope = {a:.2f}')

plt.xlabel('Recursion limit')
plt.ylabel('Max depth')
plt.legend()
plt.savefig('test.png')
</code></pre>
<p>To test the recursive indexing I append a list <code>l</code> to itself and construct a long literal <code>[-1][-1][-1]...</code> which I then evaluate on <code>l</code> dynamically.</p>
<p>Question: Explain this factor of 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>There’s <strong>no recursion</strong> in <code>l[-1][-1]…</code>—it compiles to “push <code>l</code>; replace top of stack with its last element; replace…”.  Your <code>RecursionError</code> is from <strong>compiling</strong> the long string.</p>
<p>There is very literally a <a href="https://github.com/python/cpython/blob/8f59ee01be3d83d5513a9a3f654a237d77d80d9a/Python/symtable.c#L248" rel="nofollow noreferrer">factor of 3</a> used to approximate the stack usage of the byte-compiler <em>vs.</em> the interpreter proper.  (Python 2 has no such limit and just crashes on such expressions.)</p>
</div>
<span class="comment-copy">In my case I get a factor around 0.58 for call and 1.75 for getitem, which makes even less sense... 1.75/0.58 is still about 3 though.</span>
<span class="comment-copy">That was for small depth. Gets actually closer to 1 and 3 as I increase the limit. I still stay below 1 for call though when it should intuitively be exactly 1 for all cases. Interested to know what hidden mechanism is at work here...</span>
<span class="comment-copy">Strange. I found 1.00 and 3.00 on both Python 3.7 and 3.5, 64bit Linux Mint. I guess this could be platform dependent?</span>
<span class="comment-copy">@Julien: Some of the limit is expended on the test code and provides a constant offset.</span>
