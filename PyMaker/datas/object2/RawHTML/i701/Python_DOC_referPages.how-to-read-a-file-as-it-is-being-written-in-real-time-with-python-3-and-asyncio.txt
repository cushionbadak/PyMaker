<div class="post-text" itemprop="text">
<p>I want to write a Python program on Linux that reads a log file in real time as it is being written, for the purpose of sending an alarm if it detects certain things in the log. I want this to use asyncio for several reasons - I'm trying to build a framework that does many things at the same time based on asyncio, and I need the practice.</p>
<p>Since I'm using asyncio, I obviously don't want to use a blocking read to wait at the end of the input file for more lines to be written to it. I suspect I'll have to end up using select, but I'm not sure.</p>
<p>I suspect that this is pretty simple, but I have a hard time finding an example of how to do this, or coming up with one of my own even though I've dabbled a little bit in asyncio before. I can read and mostly understand other asyncio examples I find, but for some reason I find it difficult to write asyncio code of my own.</p>
<p>Therefore, I'd be very grateful if someone could point me to an example. Bonus points if the same technique also works for reading from stdin rather than a file.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I suspect I'll have to end up using select, but I'm not sure. I suspect that this is pretty simple, but I have a hard time finding an example of how to do this</p>
</blockquote>
<p>With asyncio, the idea is that you don't need to <code>select()</code> yourself because asyncio selects for you - after all, a <code>select()</code> or equivalent is at the heart of every event loop. Asyncio provides abstractions like <a href="https://docs.python.org/3/library/asyncio-stream.html" rel="nofollow noreferrer">streams</a> that implement a coroutine facade over the async programming model. There are also the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.add_reader" rel="nofollow noreferrer">lower-level</a> methods that allow you to hook into <code>select()</code> yourself, but normally you should work with streams.</p>
<p>In case of <code>tail -f</code>, you can't use <code>select()</code> because regular files are always readable. When there is no data, you get an EOF and are expected to try again later. This is why <code>tail -f</code> historically used reads with pauses, with the option to deploy notification APIs like <a href="http://man7.org/linux/man-pages/man7/inotify.7.html" rel="nofollow noreferrer">inotify</a> where available.</p>
</div>
<span class="comment-copy"><code>with open()</code> supports this. every new <code>read()</code> will continue from the last cursor position within the file. if there's new data, a <code>read()</code> will fetch it. <code>f.tell()</code> will tell you where you are in the file.</span>
<span class="comment-copy"><code>select</code> is probably your best bet, or checking the <code>os.stat(f).m_time</code> of the file. Or, use one of the methods mentioned <a href="https://stackoverflow.com/questions/182197/how-do-i-watch-a-file-for-changes">here</a> to determinate when you should do the read. I'm not a big fan of asyncio, but maybe it's worth a look at.</span>
<span class="comment-copy">Won't <code>read()</code> just immediately return <code>EOF</code>, or something?</span>
<span class="comment-copy">Have ye faith, little one: <a href="https://i.imgur.com/IHmrCyu.png" rel="nofollow noreferrer">i.imgur.com/IHmrCyu.png</a> (notice the 6 at the end, and that <code>read()</code> isn't blocking. It will continue by returning <code>f.data[f.curpos:]</code>, which will be empty at times.</span>
<span class="comment-copy">I see, thanks. Yeah, that is workable I suppose. I was expecting that I'd be using something like 'await fh.async_read()` or some such.</span>
