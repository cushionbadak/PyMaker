<div class="post-text" itemprop="text">
<p>I need to add an attribute (holding a tuple or object) to python objects dynamically. This works for Python classes written by me, but not for built in classes. </p>
<p>Consider the following program: </p>
<pre><code>import numpy as np

class My_Class():
    pass

my_obj = My_Class()
my_obj2 = My_Class()

my_obj.__my_hidden_field = (1,1)
my_obj2.__my_hidden_field = (2,1)

print(my_obj.__my_hidden_field, my_obj2.__my_hidden_field)
</code></pre>
<p>This correctly prints <code>(1, 1) (2, 1)</code>. However the following program doesnt work.</p>
<pre><code>X  = np.random.random(size=(2,3))


X.__my_hidden_field = (3,1) 
setattr(X, '__my_hidden_field', (3,1))
</code></pre>
<p>Both of the above line throws the following error <code># AttributeError: 'numpy.ndarray' object has no attribute '__my_hidden_field'</code></p>
<p>Now, the reason found from these questions (i.e., <a href="https://stackoverflow.com/questions/5741699/attribute-assignment-to-built-in-object">Attribute assignment to built-in object</a>, <a href="https://stackoverflow.com/questions/1529002/cant-set-attributes-of-object-class">Can't set attributes of object class</a>, <a href="https://stackoverflow.com/questions/8843140/python-dynamically-adding-attributes-to-a-built-in-class">python: dynamically adding attributes to a built-in class</a>) is Python does not allow dynamically adding attributes to built_in objects. </p>
<p>Excerpt from the answer: <a href="https://stackoverflow.com/a/22103924/8413477">https://stackoverflow.com/a/22103924/8413477</a> </p>
<blockquote>
<p>This is prohibited intentionally to prevent accidental fatal changes to built-in types (fatal to parts of the code that you never though of). Also, it is done to prevent the changes to affect different interpreters residing in the address space, since built-in types (unlike user-defined classes) are shared between all such interpreters.</p>
</blockquote>
<p>However, all the answers are quite old, and I am badly in need of doing this for my research project. </p>
<p>There is a module that allows to add methods to built in Class though: 
<a href="https://pypi.org/project/forbiddenfruit/" rel="nofollow noreferrer">https://pypi.org/project/forbiddenfruit/</a></p>
<p>However,it doesnt allow adding objects/attributes to each object. </p>
<p>Any help ?</p>
</div>
<div class="post-text" itemprop="text">
<p>You probably want <a href="https://docs.python.org/3/library/weakref.html#weakref.WeakKeyDictionary" rel="nofollow noreferrer"><code>weakref.WeakKeyDictionary</code></a>. From the doc,</p>
<blockquote>
<p>This can be used to associate additional data with an object owned by other parts of an application without adding attributes to those objects.</p>
</blockquote>
<p>Like an attribute, and unlike a plain dict, this allows the objects to get garbage collected when there are no other references to it.</p>
<p>You'd look up the field with</p>
<pre><code>my_hidden_field[X]
</code></pre>
<p>instead of</p>
<pre><code>X._my_hidden_field
</code></pre>
<p>Two caveats: First, since a weak key may be deleted at any time without warning, you shouldn't iterate over a <code>WeakKeyDictionary</code>. Looking up an object you have a reference to is fine though. And second, you can't make a weakref to an object type written in C that doesn't have a slot for it (true for many builtins), or a type written in Python that doesn't allow a <code>__weakref__</code> attribute (usually due to <code>__slots__</code>).</p>
<p>If this is a problem, you can just use a normal dict for those types, but you'll have to clean it up yourself.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Quick answer</h1>
<p><em>Is it possible to add attributes to built in python objects dynamically in Python?</em></p>
<p>No, the reasons your read about in the links you posted, are the same now days. But I came out with a recipe I think might be the starting point of your tracer.</p>
<h1>Instrumenting using subclassing combined with AST</h1>
<p>After reading a lot about this, I came out with a recipe that might not be the complete solution, but it sure looks like you can start from here.</p>
<p>The good thing about this recipe is that it doesn't use third-party libraries, all is achieved with the standard (Python 3.5, 3.6, 3.7) libraries.</p>
<h2>The target code.</h2>
<p>This recipe will make code like this be instrumented (simple instrumentation is performed here, this is just a poof of concept) and executed.</p>
<pre><code># target/target.py

d = {1: 2}
d.update({3: 4})
print(d)                 # Should print "{1: 2, 3: 4}"
print(d.hidden_field)    # Should print "(0, 0)"
</code></pre>
<h2>Subclassing</h2>
<p>Fist we have to add the <code>hidden_field</code> to anything we want to (this recipe have been tested only with dictionaries).</p>
<p>The following code receives a value, finds out its type/class and subclass it in order to add the mentioned <code>hidden_field</code>.</p>
<pre><code>def instrument_node(value):
    VarType = type(value)
    class AnalyserHelper(VarType):
        def __init__(self, *args, **kwargs):
            self.hidden_field = (0, 0)
            super(AnalyserHelper, self).__init__(*args, **kwargs)
    return AnalyserHelper(value)
</code></pre>
<p>with that in place you are able to:</p>
<pre><code>d = {1: 2}
d = instrument_node(d) 
d.update({3: 4})
print(d)                 # Do print "{1: 2, 3: 4}"
print(d.hidden_field)    # Do print "(0, 0)"
</code></pre>
<p>At this point, we know already a way to <em>"add instrumentation to a built-in dictionary"</em> <strong>but there is no transparency here</strong>.</p>
<h2>Modify the AST.</h2>
<p>The next step is to "hide" the <code>instrument_node</code> call and we will do that using the <a href="https://greentreesnakes.readthedocs.io/en/latest/" rel="nofollow noreferrer">ast</a> Python module.</p>
<p>The following is an AST node transformer that will take any dictionary it finds and wrap it in an <code>instrument_node</code> call:</p>
<pre><code>class AnalyserNodeTransformer(ast.NodeTransformer):
    """Wraps all dicts in a call to instrument_node()"""
    def visit_Dict(self, node):
        return ast.Call(func=ast.Name(id='instrument_node', ctx=ast.Load()),
                        args=[node], keywords=[])
        return node
</code></pre>
<h2>Putting all together.</h2>
<p>With thats tools you can the write a script that:</p>
<blockquote>
<ol>
<li>Read the target code.</li>
<li>Parse the program.</li>
<li>Apply AST changes. </li>
<li>Compile it.</li>
<li>And execute it.</li>
</ol>
</blockquote>
<pre><code>import ast
import os
from ast_transformer import AnalyserNodeTransformer

# instrument_node need to be in the namespace here.
from ast_transformer import instrument_node

if __name__ == "__main__":

    target_path = os.path.join(os.path.dirname(__file__), 'target/target.py')

    with open(target_path, 'r') as program:
        # Read and parse the target script.
        tree = ast.parse(program.read())
        # Make transformations.
        tree = AnalyserNodeTransformer().visit(tree)
        # Fix locations.
        ast.fix_missing_locations(tree)
        # Compile and execute.
        compiled = compile(tree, filename='target.py', mode='exec')
        exec(compiled)
</code></pre>
<p>This will take our target code, and wraps every dictionary with an <code>instrument_node()</code> and execute the result of such change.</p>
<p>The output of running this against our target code,</p>
<pre><code># target/target.py

d = {1: 2}
d.update({3: 4})
print(d)                 # Will print "{1: 2, 3: 4}"
print(d.hidden_field)    # Will print "(0, 0)"
</code></pre>
<p>is:</p>
<pre><code>&gt;&gt;&gt; {1: 2, 3: 4} 
&gt;&gt;&gt; (0, 0)
</code></pre>
<h2>Working example</h2>
<p>You can clone a working example <a href="https://github.com/RaydelMiranda/StackOverflowLabs/tree/master/python/ast_transformer" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it is possible, it is one of the coolest things of python, in Python, all the classes are created by the <code>type</code>class </p>
<p>You can read in detail <a href="https://www.python-course.eu/python3_classes_and_type.php" rel="nofollow noreferrer">here</a>, but what you need to do is this</p>
<pre><code>In [58]: My_Class = type("My_Class", (My_Class,), {"__my_hidden_field__": X})

In [59]: My_Class.__my_hidden_field__
Out[59]:
array([[0.73998002, 0.68213825, 0.41621582],
       [0.05936479, 0.14348496, 0.61119082]])



</code></pre>
<p>*Edited because inheritance was missing, you need to pass the original class as a second argument (in tuple) so that it updates, otherwise it simply re-writes the class) </p>
</div>
<span class="comment-copy">Why don't you subclass?</span>
<span class="comment-copy">It is possible to add attributes to some objects, but not possible to add them to other objects, regardless of whether they are built-in or not.</span>
<span class="comment-copy">I am trying to write a tracer to instrument python code for analysis. I want my instrumentation to be as transparent as possible. and subclassing may/may not solve the problem I haven't thought through about it yet. Even if it does work, it will be of less priority! @Tomothy32</span>
<span class="comment-copy">forbiddenfruit is a segfault waiting to happen, by the way. It brute-forces its way through to a type's dict without any real understanding of the consequences of doing so, and it doesn't handle any of the pitfalls, like the type attribute cache.</span>
<span class="comment-copy"><a href="https://repl.it/repls/PapayawhipLawfulRuntimes" rel="nofollow noreferrer">Here's a simple example that currently segfaults on repl.it.</a> (Also note the silently wrong result on the second print, before the third print completely wrecks everything.)</span>
<span class="comment-copy">It's not quite <code>__weakref__</code> that's necessary - types written in C that support weak references usually won't have a <code>__weakref__</code> attribute, but they will have space reserved to support weak referencing. You can check whether an object has such space reserved by checking if its type has a nonzero <code>__weakrefoffset__</code>.</span>
<span class="comment-copy">With functions being one example.</span>
<span class="comment-copy">I could not make the wrapper class AnalyzeHelper work for numpy.ndarray classes. How to make this technique work for built-in/third-party classes ??</span>
<span class="comment-copy">Well I guess that in order to declare a <code>numpy.ndarray</code> you have to make a call like <code>numpy.ndarray(&lt;initial data here&gt;)</code>, you should read into ast and see how you can modify nodes that represents that call. The thing is that AST is a good tool for achieve the transparency level you want.</span>
<span class="comment-copy">it wont work for built in classes. also I need to add information to objects rather than classes</span>
