<div class="post-text" itemprop="text">
<p>Im gonna include the description of the task this code is supposed to do in case someone needs it to answer me.</p>
<pre><code>#Write a function called "load_file" that accepts one 
#parameter: a filename. The function should open the
#file and return the contents.#
#
# - If the contents of the file can be interpreted as
#   an integer, return the contents as an integer.
# - Otherwise, if the contents of the file can be
#   interpreted as a float, return the contents as a
#   float.
# - Otherwise, return the contents of the file as a
#   string.
#
#You may assume that the file has only one line.
#
#Hints:
#
# - Don't forget to close the file when you're done!
# - Remember, anything you read from a file is
#   initially interpreted as a string.


#Write your function here!
def load_file(filename):
    file=open(filename, "r")
    try:
        return int(file.readline())
    except ValueError:
        return float(file.readline())
    except:
        return str(file.readline())
    finally:
        file.close()


#Below are some lines of code that will test your function.
#You can change the value of the variable(s) to test your
#function with different inputs.
#
#If your function works correctly, this will originally
#print 123, followed by &lt;class 'int'&gt;.
contents = load_file("LoadFromFileInput.txt")
print(contents)
print(type(contents))
</code></pre>
<p>When the code is tested with a file which contains "123", then everything works fine. When the website loads in another file to test this code, following error occurs:</p>
<pre><code>[Executed at: Sat Feb 2 7:02:54 PST 2019]

    We found a few things wrong with your code. The first one is shown below, and the rest can be found in full_results.txt in the dropdown in the top left:

    We tested your code with filename = "AutomatedTest-uwixoW.txt". We expected load_file to return the float -97.88285. However, it instead encountered the following error:

    ValueError: could not convert string to float:
</code></pre>
<p>So Im guessing the error occurs inside the first <code>except</code> statement, but i don't understand why. If an error occurs when the value inside a file is being converted to float, shouldnt the code just go to the second <code>except</code> statement ? And in the second <code>except</code> it would be converted to string, which will work anyway ? I'm guessing i misunderstand something about how <code>try-except(specified error)-except(no specified error)</code> works. </p>
<p>Sorry for long post.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, only one of those <code>except</code> blocks -- the first one matching the exception -- will be executed. The behavior you are describing would correspond to</p>
<pre><code>except ValueError:
    try:
        return float(file.readline())
    except:
        return str(file.readline())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>shouldnt the code just go to the second except statement ?</p>
</blockquote>
<p>Nope: this "flat" try/except statement works only for the <em>first</em> <code>try</code> block. If an exception occurs there, the <code>except</code> branches catch this exception and straight away evaluate the appropriate block. If an exception occurs in this block, it's not caught by anything, because there's no <code>try</code> block there.</p>
<p>So, you'd have to do a whole lot of nested try/except statements:</p>
<pre><code>try:
    do_this()
except ValueError:
    try:
        do_that()
    except ValueError:
        do_this()
    except:
        do_that_one()
except:
    # a whole bunch of try/except here as well
</code></pre>
<p>You may need to add an extra level of nesting.</p>
<p>This is terribly inefficient in terms of the amount of code you'll need to write. A better option might be:</p>
<pre><code>data = file.readline()
for converter in (int, float, str):
    try:
        return converter(data)
    except:
        pass
</code></pre>
<p>Note that if you do <code>converter(file.readline())</code>, a new line will be read on each iteration (or, in your case, in any new try/except block), which may not be what you need.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/errors.html#handling-exceptions" rel="nofollow noreferrer">docs.python.org/3/tutorial/errors.html#handling-exceptions</a></span>
<span class="comment-copy">Also, if the error occurs in the <code>try:</code> block, the line has been read and the the next time <code>readline()</code> is called it will read the next line in the file, so your <code>except:</code> code won't run on the same value as the one it failed on, but the next one in the file. Maybe put the read line in a var and return the cast of the var in both the <code>try</code> and <code>except</code> blocks.</span>
<span class="comment-copy">Thats the next problem that happened, solved it with your advice. Thanks.</span>
