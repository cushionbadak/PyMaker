<div class="post-text" itemprop="text">
<p>I am focusing on data with a regular expression. I am using python and I implement this function:</p>
<pre><code>import re
exp = r"\bTimestamp\s+([0-9]+)\s+ID=(\w{32})0*\s+Dest_ID=(\w{32})0*\sASN_Received\s+(?!0000)[0-9A-F]{4}+"
rx = re.compile(exp)
m=rx.match("Timestamp 1549035123  ID=02141592cc0000000300000000000000 Dest_ID=00000000000000000000000000000000 Nbr_Received = ec30000000")
m.groups()
print(m.groups())
</code></pre>
<p>But it does not work correctly:</p>
<p>I expect to have  this result:</p>
<pre><code>('1549033267', '02141592cc0000000500000000000000','00000000000000000000000000000000','ec30000000')
</code></pre>
<p>Then I want to convert the hexadecimal value to decimal by using this function: </p>
<pre><code>def Convert_Decimal(nbr_hex):
nbr_dec = nbr_hex[5] + nbr_hex[2:4] + nbr_hex[0:2]
reversed = int(nbr_dec, 16)
print(reversed)
</code></pre>
<p>As finalresult I want to have:</p>
<pre><code>('1549033267', '02141592cc0000000500000000000000','00000000000000000000000000000000','12524')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Hexadecimal values use the digits 0-9 and the letters A through to F (upper or lowercase), only, and in your case are of a fixed length, so <code>[0-9a-fA-F]{32}</code> suffices to match those values. You don't need to match trailing zeros, when you have a fixed-length value.</p>
<p>You really don't want to use <code>\w</code> here, you wouldn't want to match underscores, the rest of the English alphabet, or any other letter-like symbol in the Unicode standard (there are thousands).</p>
<p>Next, you are looking for <code>ASN_Received</code>, but your input string uses the text <code>Nbr_Received =</code> with whitespace around the <code>=</code> character. Account for that:</p>
<pre><code>exp = (
    r'\bTimestamp\s+([0-9]+)\s+'
    r'ID=([0-9a-fA-F]{32})\s+'
    r'Dest_ID=([0-9a-fA-F]{32})\s+'
    r'Nbr_Received\s*=\s*([0-9a-fA-F]{4,})'
)
</code></pre>
<p>I broke the expression across multiple lines to be easier to follow. Note that I used <code>{4,}</code> for the last hexadecimal value, matching 4 <em>or more</em> digits. You can't use <code>+</code> and <code>{n,m}</code> patterns together, choose one or the other.</p>
<p>You then get:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; exp = (
...     r'\bTimestamp\s+([0-9]+)\s+'
...     r'ID=([0-9a-fA-F]{32})\s+'
...     r'Dest_ID=([0-9a-fA-F]{32})\s+'
...     r'Nbr_Received\s*=\s*([0-9a-fA-F]{4,})'
... )
&gt;&gt;&gt; rx = re.compile(exp)
&gt;&gt;&gt; m = rx.match("Timestamp 1549035123  ID=02141592cc0000000300000000000000 Dest_ID=00000000000000000000000000000000 Nbr_Received = ec30000000")
&gt;&gt;&gt; print(m.groups())
('1549035123', '02141592cc0000000300000000000000', '00000000000000000000000000000000', 'ec30000000')
</code></pre>
<p>Also see <a href="https://regex101.com/r/SjxtaF/1/" rel="nofollow noreferrer">this online demo at regex101</a>, which explains each part of the pattern on the right-hand side.</p>
<p>I'd convert the last hexadecimal number via <a href="https://docs.python.org/3/library/stdtypes.html#bytes.fromhex" rel="nofollow noreferrer"><code>bytes.fromhex()</code></a> and <a href="https://docs.python.org/3/library/stdtypes.html#int.from_bytes" rel="nofollow noreferrer"><code>int.from_bytes()</code></a> to an integer:</p>
<pre><code>&gt;&gt;&gt; m.group(4)
'ec30000000'
&gt;&gt;&gt; bytes.fromhex(m.group(4))
b'\xec0\x00\x00\x00'
&gt;&gt;&gt; int.from_bytes(bytes.fromhex(m.group(4)), 'little')
12524
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; string = "Timestamp 1549035123  ID=02141592cc0000000300000000000000 Dest_ID=00000000000000000000000000000000 Nbr_Received = ec30000000"
&gt;&gt;&gt; pat = r'Timestamp\s+(\d+)\s+ID=(\w+)\s+Dest_ID=(\d+)\s+Nbr_Received\s+?=\s+?(\w+)'
&gt;&gt;&gt; re.findall(pat, string)
[('1549035123', '02141592cc0000000300000000000000', '00000000000000000000000000000000', 'ec30000000')]
</code></pre>
</div>
<span class="comment-copy">Your <code>exp</code> value currently produces a <code>re.error: multiple repeat at position 95</code> exception.</span>
<span class="comment-copy">Why the negative look-behind for the <code>Nbr_Received</code> number, and why not use proper <code>bytes.as_int()</code> or <code>struct()</code> unpacking for that value, to control byte order?</span>
<span class="comment-copy">You really should include an explanation as to why the OP should <i>try this</i>. Your pattern matches more than just hexadecimal digits, <code>\w</code> is really way too broad. The non-greedy classifiers on the <code>\s+</code> brackets are really not needed, as these are always followed by non-space characters. There is no risk of those patterns running away. You didn't address the hex-to-decimal portion of the question, either.</span>
<span class="comment-copy">Okay. The pattern seemed so stable.</span>
