<div class="post-text" itemprop="text">
<p>I have some code that will be running in a server. It can take a long time to run (minutes at least). I want to be able to poll the server for where in the code it currently is. I thought I could use <code>asyncio</code> to do that, but it looks like it may not be what I need. </p>
<p>Here is some code that I wrote to test it (saved as <code>test_async.py</code>):</p>
<pre><code>import asyncio
import time

the_status = 'idle'


async def waiting():
    global the_status
    await asyncio.sleep(0.001)
    the_status = 'running'
    time.sleep(30)
    the_status = 'finished'


def get_status():
    global the_status
    return the_status


async def main():
    loop.create_task(waiting())


loop = asyncio.get_event_loop()
loop.run_until_complete(main())
loop.close()
</code></pre>
<p>I run this by opening the Python console and typing:</p>
<pre><code>from test_async import *
</code></pre>
<p>What I expected to happen is that it would start running <code>waiting()</code>, change <code>the_status</code> to 'running', and then wait 30 seconds before turning the status to 'finished'. In the meantime, I should get the console prompt back and I would be able to get the current status by typing <code>get_status()</code>.</p>
<p>What is actually happening is that the variable <code>the_status</code> is never changing from its initial state of 'idle'.</p>
<p>Am I doing something wrong? Is asyncio not the answer to what I'm trying to do?</p>
<p>My Python version is 3.6.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Am I doing something wrong?</p>
</blockquote>
<p>The code has two issues:</p>
<ul>
<li><p><code>main</code> just creates a task without awaiting it - you can think of <code>create_task</code> as creating a "background" task. But in asyncio background tasks run only as long as the main loop does, so <code>run_until_complete(main())</code> exits immediately because <code>main()</code> returns immediately after creating the task. With the main loop stopping, the <code>waiting</code> task doesn't have a chance to start executing.</p></li>
<li><p><code>waiting</code> calls <code>time.sleep</code>, which is not allowed in asyncio. Asyncio is a cooperative multi-tasking system for JS-style callbacks and coroutines which suspend themselves when they await something that blocks. <code>time.sleep</code> doesn't suspend, it just blocks the whole event loop thread. Executing legacy blocking code inside asyncio is correctly done with <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" rel="nofollow noreferrer"><code>run_in_executor</code></a>.</p></li>
</ul>
<blockquote>
<p>Is asyncio not the answer to what I'm trying to do?</p>
</blockquote>
<p>If you have some blocking code that you need executed "in the background", you should use threads.</p>
<pre><code>import time, concurrent.futures

the_status = 'idle'

def waiting():
    global the_status
    time.sleep(0.001)
    the_status = 'running'
    time.sleep(30)
    the_status = 'finished'

executor = concurrent.futures.ThreadPoolExecutor()
executor.submit(waiting)
</code></pre>
<p>Importing the code works as expected:</p>
<pre><code>&gt;&gt;&gt; import thr2
&gt;&gt;&gt; thr2.the_status
'running'
</code></pre>
</div>
<span class="comment-copy">thank you for your response.   So the <code>time.sleep</code> I just included to simulate a function that would take a long time to run. In reality what the code is doing is running tesseract to do OCR, and then using Scikit-Learn to do a bunch of text classifications.   I wanted to have the ability to ask the code what is currently running, instead of waiting in the dark for it to finish. Most likely I'll call it as an api using Flask, but I haven't decided that yet.  I'll try <code>concurrent.futures</code> and will update here when I have the result.</span>
<span class="comment-copy"><code>concurrent.futures</code> worked perfectly! Thank you!</span>
<span class="comment-copy">@RogB Glad to hear. An especially nice thing about concurrent futures is that <code>submit</code> returns a future object, which allows you to check whether the computation is done and, when so, obtain the return value of the function. Then you no longer even need a global state.</span>
