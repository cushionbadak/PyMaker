<div class="post-text" itemprop="text">
<p>I'm trying to find keywords within a sentence, where the keywords are usually single words, but can be multi-word combos (like "cost in euros"). So if I have a sentence like <code>cost in euros of bacon</code> it would find <code>cost in euros</code> in that sentence and return true.</p>
<p>For this, I was using this code:</p>
<pre><code>if any(phrase in line for phrase in keyword['aliases']:
</code></pre>
<p>where <code>line</code> is the input and <code>aliases</code> is an array of phrases that match a keyword (like for cost in euros, it's <code>['cost in euros', 'euros', 'euro cost']</code>). </p>
<p>However, I noticed that it was also triggering on word parts. For example, I had a match phrase of <code>y</code> and a sentence of <code>trippy cake</code>. I'd not expect this to return true, but it does, since it apparently finds the <code>y</code> in <code>trippy</code>. How do I get this to only check whole words? Originally I was doing this keyword search with a list of words (essentially doing <code>line.split()</code> and checking those), but that doesn't work for multi-word keyword aliases.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should accomplish what you're looking for:</p>
<pre><code>import re

aliases = [
    'cost.',
    '.cost',
    '.cost.',
    'cost in euros of bacon',
    'rocking euros today',
    'there is a cost inherent to bacon',
    'europe has cost in place',
    'there is a cost.',
    'I was accosted.',
    'dealing with euro costing is painful']
phrases = ['cost in euros', 'euros', 'euro cost', 'cost']

matched = list(set([
    alias
    for alias in aliases
    for phrase in phrases
    if re.search(r'\b{}\b'.format(phrase), alias)
    ]))

print(matched)
</code></pre>
<p>Output:</p>
<pre><code>['there is a cost inherent to bacon', '.cost.', 'rocking euros today', 'there is a cost.', 'cost in euros of bacon', 'europe has cost in place', 'cost.', '.cost']
</code></pre>
<p>Basically, we're grabbing all matches, using pythons <code>re</code> module as our test, including cases where multiple <code>phrase</code>s occur in a given <code>alias</code>, using a compound <code>list comprehension</code>, then using <code>set()</code> to trim duplicates from the <code>list</code>, then using <code>list()</code> to coerce the <code>set</code> back into a <code>list</code>.</p>
<p>Refs:</p>
<p>Lists:
<a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html#more-on-lists</a></p>
<p>List comprehensions:
<a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions</a></p>
<p>Sets:
<a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html#sets</a></p>
<p>re (or regex):
<a href="https://docs.python.org/3/library/re.html#module-re" rel="nofollow noreferrer">https://docs.python.org/3/library/re.html#module-re</a></p>
</div>
<span class="comment-copy">what have you tried so far?</span>
<span class="comment-copy">in your sentences and keywords are there punctuation?</span>
<span class="comment-copy">@Primusa no, no punctuation.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/15863066/python-regular-expression-match-whole-word">Python regular expression match whole word</a></span>
<span class="comment-copy">Almost, but I've found it doesn't quite work when the keyword is at the end of a sentence and therefore has no space at the end.</span>
<span class="comment-copy">Update my answer. This should cover your use cases.</span>
<span class="comment-copy">@IronWaffleMan Note that I kinda overexplained in my answer here. Not meaning to imply your don't get it. Just trying to make the answer more useful for future folks looking for answers.</span>
<span class="comment-copy">And if this seems like it's an appropriate solution, please consider marking this as the accepted answer. If not, by all means, don't! :)</span>
