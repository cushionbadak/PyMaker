<div class="post-text" itemprop="text">
<p>I am receiving data from an external program (Max/MSP) over UDP.</p>
<p>The data is coming into Python fine.</p>
<p>Strings come in as expected. i.e if I send "89-90-10-10" it comes in as a string that I can use in Python.</p>
<p>However, if I send a single integer, it comes in as "int�,i�����" despite using the decode() method.</p>
<p>What is going wrong in my code?</p>
<pre><code>import socket

UDP_IP_ADDRESS = "127.0.0.1"

UDP_PORT_NO = 8813
serverSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
serverSock.bind((UDP_IP_ADDRESS, UDP_PORT_NO))


while True:
    print (type(data))
    print (repr(data))
    print (data.decode("utf-8"))
</code></pre>
<p>If I send "1" over udp from my other programme, I receive the following output in Python:</p>
<p></p>
<p>b'int\x00,i\x00\x00\x00\x00\x00\x01'</p>
<p>int,i</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue is that UDP stream is receiving bytes, regardless of whether you send a string or integer.  So the program is likely packing the integer into bytes. </p>
<p>The code below is a hack that is ignoring some of the data received.<br/>
When you send an integer of 1 and receive b'int\x00,i\x00\x00\x00\x00\x00\x01' 
the "int" is telling the receiver that this is an integer.  This is followed by nine bytes, where-as integers are usually sent in 1, 2, 4, or 8 bytes.<br/>
Using the last 8 bytes does not return the value 1, but using the last four bytes does, so the code below is slicing the bytes[-4:] to get only the last four.</p>
<p>There is probably some documentation or open source project that properly handles Max/MSP data so I suggest looking into that.</p>
<p>Here is the docs for the struct import that is used to unpack the data:
<a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">https://docs.python.org/3/library/struct.html</a></p>
<pre><code>import socket
import struct

UDP_IP_ADDRESS = "127.0.0.1"

UDP_PORT_NO = 8813
serverSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
serverSock.bind((UDP_IP_ADDRESS, UDP_PORT_NO))

while True:
    data, addr = serverSock.recvfrom(65536)
    if data.startswith(b'int'):
        # assumes 4 byte unsigned integer
        received = struct.unpack('!I', data[-4:])[0]
    else:
        received = data.decode('utf-8')
    print (repr(data))  # for debug purposes
    print (type(received), received)
</code></pre>
</div>
<span class="comment-copy">What are some concrete examples of the input and output you're sending and receiving? Also, <a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode" rel="nofollow noreferrer">decode</a> is for decoding bytes to a unicode string. It won't get you from string to integer.</span>
<span class="comment-copy">Python will expect to receive bytes from the socket.  For starters, I would change your print statement to this for diagnostic purposes (to see what you are receiving when a 1 is sent): `   print (type(data))`  `    print(repr(data))`  `    print(data.decode("utf-8"))`</span>
<span class="comment-copy">Is the integer sent in binary or encoded as a string? If it's binary, how are you decoding it?</span>
<span class="comment-copy">Updated. Barmar, I thought I was decoding it into utf-8, which would present the integer itself.</span>
<span class="comment-copy">I might have this figured out, or close to it, what do you get back if you send the integer 123456 and the integer 1234567?  I would like to see what the repr(data) is for each of those.</span>
<span class="comment-copy">Fantastic, I can confirm this works with multiple integer values including large numbers. Thanks so much and for the explanation too. Given your suggestion I should look into OSC - a protocol that has support in both Python and Max. Thank you again!</span>
