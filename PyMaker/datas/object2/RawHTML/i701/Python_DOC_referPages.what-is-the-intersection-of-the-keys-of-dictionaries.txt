<div class="post-text" itemprop="text">
<p>I'm trying to write a one liner function using map, filter, reduce that takes is a list of dictionaries (Ld) and returns a collection of the keys that are contained in all the dictionaries (the intersection of the keys).</p>
<p>The function below attempts to do this. The map portion returns a collection of True/False if the key is in a particular dictionary. The reduce returns True if all of such elements are true. Lastly, the filter portion filters out all the keys that don't satisfy such conditions.</p>
<pre><code>def intersection_of_keys(Ld):
    return filter(lambda key: reduce(lambda x, y: x*y, map(lambda dic: key in dic, Ld)), all_keys(Ld))

#For example:  
d1 = {1:12, 3:4, 2:5}  
d2 = {1:6, 3:8, 0:9}  
d3 = {3:0, 1:11, 2:3}  
Ld = [d1, d2, d3]  
print(intersection_of_keys(Ld))  
</code></pre>
<p>The code should print a collection containing 1 and 3. But the variable <strong><em>key</em></strong> inside the <strong>map</strong> portion is undefined. Any ideas why <strong><em>key</em></strong> is not passed into the lambda function definition for the map? And any ideas of how to work around this?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>filter</code>, <code>reduce</code>, <code>map</code>, and <code>lambda</code>... oh my! This is Python, remember, so don't make this harder than it needs to be. Just using a good ol' for-loop:</p>
<pre><code>&gt;&gt;&gt; keys, *morekeys = [d.keys() for d in Ld]
&gt;&gt;&gt; for k in morekeys: 
...     keys &amp;= k 
...
&gt;&gt;&gt; keys
{1, 3}
</code></pre>
<p>If you insist on using reduce, it's like this:</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; from operator import and_
&gt;&gt;&gt; reduce(and_, [d.keys() for d in Ld])
{1, 3}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I can't reproduce your error. If I run the code you provided (replacing <code>all_keys(Ld)</code> with <code>(k for d in Ld for k in d)</code>, and wrapping the call in <code>list</code> so it runs out the <code>filter</code>), I get:</p>
<pre><code>[1, 3, 1, 3, 3, 1]
</code></pre>
<p><a href="https://tio.run/##dY9BS8QwEIXv@RUPvDSSw7ZRcQN79bT/QGSpnRRD06SkKWyR/e11sroHQec08/Fm5r1pzR8x6K1PcUS/hC7H6Ge4cYopI1laOruR7dF6fxrsOldHkkaAK9m8pIBqQB8TCC7gSNd@KD1JIcqiC9mm2XbZxXCK/d9HeudZVfl2fKcWLDE/v2/orMDsfL8qjO10o@Q6U9TXf65TbEBK9csru7h7YU/23I6TtwYQVOOAz9rUjYI2DwqNebwIar7pU4HPCjuzZ6gL1GanwPq6SPVFcMwDXolH4hOk38SUOGbl3Zyr//JKuW1f" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p>which, while redundant, accurately describes the overlapping keys in the order they're seen.</p>
<p>That said, if you don't <em>need</em> to write it with <code>.keys()</code>/<code>map</code>/<code>filter</code>/<code>reduce</code>, there is a <em>much</em> better way to do this, as long as the exact ordering of the keys, and redundancy of output seen above isn't needed:</p>
<pre><code>def intersection_of_keys(Ld):
    return set(Ld[0]).intersection(*Ld[1:])
</code></pre>
<p>That's it; <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.intersection" rel="nofollow noreferrer"><code>set.intersection</code> takes varargs</a>, so you can pass it many things to intersect with as a single operation.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may consider using a one liner with <code>set</code> and <code>&amp;</code>:</p>
<pre><code>from functools import reduce

d1 = {1:12, 3:4, 2:5}  
d2 = {1:6, 3:8, 0:9}  
d3 = {3:0, 1:11, 2:3}  
Ld = [d1, d2, d3]

reduce(lambda x, y: x&amp;y.keys(), Ld)
&gt;&gt;&gt;{1, 3}
</code></pre>
<p>If you can't use <code>set</code> and <code>&amp;</code> and must stick with <code>reduce</code>:</p>
<pre><code>reduce(lambda x, y: [i for i in x if i in y], Ld)
&gt;&gt;&gt;[1, 3]
</code></pre>
<p>Finally if you can't even use list comprehensions and need to use <code>filter</code>:</p>
<pre><code>list(reduce(lambda x, y: filter(lambda a: a in y, x) , Ld))
&gt;&gt;&gt;[1, 3]
</code></pre>
</div>
<span class="comment-copy">I can't reproduce your error. It seems to work just fine (once I provide a suitable <code>all_keys</code> definition and <code>list</code>-ify the resulting <code>filter</code> object):  <a href="https://tio.run/##dY9BS8QwEIXv@RUPvDSSw7ZRcQN79bT/QGSpnRRD06SkKWyR/e11sroHQec08/Fm5r1pzR8x6K1PcUS/hC7H6Ge4cYopI1laOruR7dF6fxrsOldHkkaAK9m8pIBqQB8TCC7gSNd@KD1JIcqiC9mm2XbZxXCK/d9HeudZVfl2fKcWLDE/v2/orMDsfL8qjO10o@Q6U9TXf65TbEBK9csru7h7YU/23I6TtwYQVOOAz9rUjYI2DwqNebwIar7pU4HPCjuzZ6gL1GanwPq6SPVFcMwDXolH4hOk38SUOGbl3Zyr//JKuW1f" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a>. Can you provide a traceback or something?</span>
<span class="comment-copy">The keys views are already set-like, so it's a little wasteful to convert them to sets explicitly.</span>
<span class="comment-copy">@wim noted and edited</span>
