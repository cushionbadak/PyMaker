<div class="post-text" itemprop="text">
<pre><code>type(1,)
Out[1]: int
a=1,
a
Out[3]: (1,)
type(a)
Out[4]: tuple
</code></pre>
<p>I am using Python 3.6, and I am expecting type(1,) to return a tuple. </p>
<p>According to <a href="https://docs.python.org/3.3/tutorial/datastructures.html" rel="nofollow noreferrer">this link</a>:</p>
<blockquote>
<p>... a tuple with one item is constructed by following a value with a comma...</p>
</blockquote>
<p>What am I missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue lies in how python has to interpret function arguments, while allowing the "quality of life" trailing comma. Functions are called with parentheses with comma separated arguments. When you pass <code>type(1,)</code>, There is ambiguity between a comma separated argument with a trailing comma, and an actual tuple. </p>
<p>A simple example:</p>
<pre><code>def test(x):
    print(x) 

test("hello") #Output: hello
test("hello",) #is also valid, Output: hello
</code></pre>
<p>To see how python is actually accepting the argument, you can use the <a href="https://docs.python.org/3/library/functions.html#repr" rel="nofollow noreferrer"><code>repr</code></a> function.</p>
<pre><code>repr(1)
'1'
repr(1,)
'1'
</code></pre>
<p>To specifically ensure you pass a tuple as the first argument, you should wrap it in parenthesis and resolve ambiguity.</p>
<pre><code>repr((1,))
'(1,)'
type((1,))
tuple
</code></pre>
<p>The reason why it works after assigning is because the ambiguity is resolved while storing the value as a tuple.</p>
<pre><code>a = 1,
repr(a)
'(1,)'
</code></pre>
<p><strong>Additional info</strong></p>
<p>As for when trailing commas can be useful, we can refer to the relevant <a href="https://www.python.org/dev/peps/pep-0008/#when-to-use-trailing-commas" rel="nofollow noreferrer">PEP8</a> section.</p>
<blockquote>
<p>When trailing commas are redundant, they are often helpful when a
  version control system is used, when a list of values, arguments or
  imported items is expected to be extended over time. The pattern is to
  put each value (etc.) on a line by itself, always adding a trailing
  comma, and add the close parenthesis/bracket/brace on the next line.</p>
</blockquote>
<p>Which means, you should never be putting redundant trailing commas in a single line.</p>
<pre><code>#No good
func_with_future_changes_or_variable_args(arg1, arg2=True,)

#Good
func_with_future_changes_or_variable_args(arg1,
                                          arg2=True,
                                          )
</code></pre>
<p>I personally don't run into much issues with functions that change, but trailing commas are life-savers when maintaining lists or dictionaries that can change over time. For example:</p>
<pre><code>FILES = [
    'setup.cfg',
    'tox.ini',
    ]
</code></pre>
<p>Adding or removing values from a list like that only requires changing a single line in isolation like following, making it really easy to track in version control commits.</p>
<pre><code> FILES = [
     'setup.cfg',
     'tox.ini',
+    'new_item.txt',
    ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the docs:</p>
<blockquote>
<p>Tuples may be constructed in a number of ways:</p>
<ol>
<li>Using a pair of parentheses to denote the empty tuple: () </li>
<li>Using a trailing comma for a singleton tuple: a, or (a,) </li>
<li>Separating items with commas: a, b, c or (a, b, c) </li>
<li>Using the tuple() built-in:tuple() or tuple(iterable)</li>
</ol>
</blockquote>
<p>According to this, all of the following are tuples. You will notice explicit assignment to a variable removes all ambiguities:</p>
<pre><code>In [8]: a = ()
In [9]: type(a)
Out[9]: tuple    
In [10]: b = (1,)    
In [11]: type(b)
Out[11]: tuple    
In [12]: b = 1,    
In [13]: type(b)
Out[13]: tuple
</code></pre>
<p>When we look at <code>type(1,)</code>, we should keep in mind that <code>type()</code> is a function and the trailing comma is an <strong>argument separator</strong>. The <code>1</code> is the first argument which is an integer and as trailing commas are allowed in Python, this is a valid statement but much <em>less explicit</em>. According to the <a href="https://docs.python.org/2/library/functions.html#type" rel="nofollow noreferrer">official docs for <code>type()</code></a>, it is recommended to use the built-in isinstance function for type-checking which is more explicit:</p>
<pre><code>In [21]: isinstance((1,), tuple)
Out[21]: True
</code></pre>
</div>
<span class="comment-copy">You're missing that <code>type(...)</code> is a <i>function call</i> where <code>,</code> is the <i>argument separator</i>â€¦?</span>
<span class="comment-copy">A short note on when "Trailing Commas" are useful can be added to this answer.</span>
<span class="comment-copy">Good point, Added @Jay. Will have to say, my personal opinion does not quite agree with trailing commas in function arguments (though i love them for lists/dictionaries). However, i tried to keep the additional info as unbiased as possible.</span>
<span class="comment-copy">Cool. Now, the answer looks even better!</span>
<span class="comment-copy">Doesn't type() take just 1 argument? Shouldn't this be a syntax error - expected 1 argument got 2?</span>
<span class="comment-copy">1 or 3 arguments to be specific. However, as i mentioned, trailing commas are allowed and essentially removed when the arguments are being parsed. take a look at how you can call the simple example at the beginning of this answer. @JoePythonKing .The function <code>test(x)</code> can also only accept 1 argument, not 2.</span>
