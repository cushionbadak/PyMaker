<div class="post-text" itemprop="text">
<p>I am using the multiprocessing module of Python. I am testing the following code :</p>
<pre><code>from multiprocessing import *
from time import sleep

def f():
    print ('in child#1 proc')
    sleep(2)
    print('ch#1 ends')

def f1() :
    print ('in child#2 proc')
    sleep(10)
    print('ch#2 ends')


if __name__ == '__main__':
    p = Process(target=f)
    p1 = Process(target=f1, daemon=True)
    p.start()
    p1.start()
    sleep(1)

    print ('child procs started')
</code></pre>
<p>I have the following observations :</p>
<ul>
<li>The first child process <code>p</code> runs for 2 secs</li>
<li>After 1 sec, the second child process <code>p1</code> becomes zombie</li>
<li>The parent (main) process runs (is active) till child#1 (non-daemon process) is running, that is for 2secs</li>
</ul>
<p>Now I have the following queries :</p>
<ul>
<li>Why should the parent (main) process be active after it finishes execution? Note that the parent does not perform a <code>join</code> on <code>p</code>.</li>
<li>Why should the daemon child <code>p1</code> become a zombie after 1 sec? Note that the parent (main) process actually stays alive till the time <code>p</code> is running.</li>
</ul>
<p>I have executed the above program on ubuntu.
My observations are based on the output os the <code>ps</code> command on ubuntu</p>
</div>
<div class="post-text" itemprop="text">
<p>To sum up and persist the discussion in the comments of the other answer:</p>
<blockquote>
<p>Why should the parent (main) process be active after it finishes
  execution? Note that the parent does not perform a <code>join</code> on <code>p</code>.</p>
</blockquote>
<p><code>multiprocessing</code> tries to make sure that your programs using it behave well. That is, it attempts to clean up after itself. In order to do so, it utilizes the <a href="https://docs.python.org/3/library/atexit.html" rel="nofollow noreferrer"><code>atexit</code></a> module which lets you register exit handlers that are to be executed when the interpreter process prepares to terminate normally.<br/>
<code>multiprocessing</code> defines and registers the function <a href="https://github.com/python/cpython/blob/master/Lib/multiprocessing/util.py#L285-L325" rel="nofollow noreferrer"><code>_exit_function</code></a> that first calls <code>terminate()</code> on all still running daemonic childs and then calls <code>join()</code> on all remaining non-daemonic childs. Since <code>join()</code> blocks, the parent waits until the non-daemonic childs have terminated. <code>terminate()</code> on the other hand does not block, it simply sends a <code>SIGTERM</code> signal (on Unix) to childs and returns.<br/></p>
<p>That brings us to:</p>
<blockquote>
<p>Why should the daemon child <code>p1</code> become a zombie after 1 sec? Note that
  the parent (main) process actually stays alive till the time <code>p</code> is
  running.</p>
</blockquote>
<p>That is because the parent has reached the end of its instructions and the interpreter prepares to terminate, i.e. it executes the registered exit handlers. The daemonic child <code>p1</code> receives a <code>SIGTERM</code> signal. Since <code>SIGTERM</code> is allowed to be caught and handled inside processes, the child is not ordered to shut down immediately, but instead is given the chance to do some cleanup of its own. That's what makes <code>p1</code> show up as <code>&lt;defunct&gt;</code>. The Kernel knows that the process has been instructed to terminate, but the process has not done so yet.<br/>
In the given case, <code>p1</code> has not yet had the chance to honor the <code>SIGTERM</code> signal, presumably because it still executes <code>sleep()</code>. At least as of <a href="https://docs.python.org/3/library/time.html#time.sleep" rel="nofollow noreferrer">Python 3.5</a>:</p>
<blockquote>
<p>The function now sleeps at least <em>secs</em> even if the sleep is interrupted
  by a signal, except if the signal handler raises an exception (see <a href="https://www.python.org/dev/peps/pep-0475/" rel="nofollow noreferrer">PEP
  475</a> for the rationale).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The parent stays alive because it is the root of the app. It stays in memory while the children are processing. Note, join waits for the child to exit and then gives control back to the parent. If you don't join the parent will exit but remain in memory.</p>
<p>p1 will zombie because the parent exits after the sleep 1. It stays alive with p because you don't deamon p. if you don't deamon a process and you call start on it, the control is passed to the child and when the child is complete it will pass control back to the parent. if you do daemon it, it will keep control with the parent and run the child in the back.</p>
</div>
<span class="comment-copy">Wonderfully explained everything</span>
<span class="comment-copy">I have another query here. In this context when I run <code>p = Process(target=f); p1 = Process(target=f1, daemon=True); atexit.register(print, 1); p.start(); p1.start(); atexit.register(print, 2)</code> , when is the <code>_exit_function</code> cleanup registered. I mean, this cleanup must be registered in the context of parent process. And that should happen before the two registerations that I am doing here. And then the two prints should both happen after ch#1 ends. Why is that not the case</span>
<span class="comment-copy">It is registered when the specific <code>Process</code> subclass calls <code>_Popen</code> as part of the <code>start()</code> method. This imports the respective <code>popen_*</code> module, which in turn imports <code>util</code>, that registers the handler. As explained, atexit executes the handlers in the reverse order of registration. You first register <code>print(1)</code>; <code>p.start()</code>, registers <code>_exit_function</code>; then you register <code>print(2)</code>. So you see <code>2</code> printed first, then <code>ch#1 ends from joining </code>p` and at the end you see <code>1</code> from your first registered <code>print</code>. <code>in child#2 proc</code> might show up somewhere in between, but is not relevant here.</span>
<span class="comment-copy">But this <code>p.start()</code>, register <code>_exit_function</code> will register this function for the context of <code>p</code>. Isn't it. And then it should mean that <code>p</code> will <code>join/termintae</code> its children. But here we are talking about the <code>_exit_function</code> of <code>parent_of(p)</code></span>
<span class="comment-copy">Nope :) The chain of imports I described above for <code>p.start()</code> registers the exit handler for the <i>parent</i> process. The childs themselves also <a href="https://github.com/python/cpython/blob/3.7/Lib/multiprocessing/process.py#L277" rel="nofollow noreferrer">register</a> and explicitly <a href="https://github.com/python/cpython/blob/3.7/Lib/multiprocessing/process.py#L300" rel="nofollow noreferrer">execute</a> <code>_exit_function</code>, that's true. But that is done after forking the parent process; it has no effect on the sequence of exit handlers in the parent process.</span>
<span class="comment-copy">The parent does not exit. It simply waits for non-daemonic childs to exit. With <code>join</code> you can control <i>when</i> the parent waits. If you don't do it explicitily, the parent will wait when it reaches the end of its instructions and non-daemonic childs are still running. You can check that with <code>import atexit; atexit.register(print, "exiting main now")</code></span>
<span class="comment-copy">@Dunes Yes, because multiprocessing <a href="https://github.com/python/cpython/blob/3.7/Lib/multiprocessing/util.py#L327" rel="nofollow noreferrer">uses <code>atexit</code> to register its own cleanup</a>, i.e. this is where it is calling <a href="https://github.com/python/cpython/blob/3.7/Lib/multiprocessing/util.py#L320-L322" rel="nofollow noreferrer"><code>join</code> on non-daemonic childs</a> and <a href="https://github.com/python/cpython/blob/3.7/Lib/multiprocessing/util.py#L315-L318" rel="nofollow noreferrer"><code>terminate</code> on daemonic childs</a>. The call order is just reversed by the reversed order of registering the exit functions. Still, for the OS, the process is alive and has not <i>exited but remained in memory</i>.</span>
<span class="comment-copy">Ah, OK, so it's still not a feature of Unix processes, but of the <code>multiprocessing</code> module because it aims to mimic the API of <code>threading</code> (as no thread can survive without its owning process). And if you started the child process with <code>subprocess</code> you would witness different behaviour?</span>
<span class="comment-copy">@user3282758 As for the question about <code>p1</code> becoming a zombie: That's due to the <a href="https://docs.python.org/3.6/library/multiprocessing.html#multiprocessing.Process.terminate" rel="nofollow noreferrer"><code>terminate</code></a>. The daemonic child receives a <code>SIGTERM</code> which is not an order for immediate shutdown. The child has not had time to act on the signal, presumably because the <code>sleep</code> instruction has not yet been paused to check for signals. For the OS, the daemonic child is dead (&lt;defunct&gt;), the child has simply not yet realized that. My tests with longer sleeps saw the child cleanly exit before the parent though.</span>
<span class="comment-copy">@user3282758 That's simply how <a href="https://docs.python.org/3.7/library/atexit.html" rel="nofollow noreferrer"><code>atexit</code></a> works. <i>atexit runs these functions in the reverse order in which they were registered</i>. The idea is that you want to register cleanups for constructs when you create them. E.g. to query a DB, you create the connection first, and then the cursor on it, but you would clean up the cursor first and the connection last. <code>Process.start()</code> registers multiprocessing cleanups. If you register print first, it will execute after the mp cleanup, if you mp.start first, print will be called before the mp cleanup.</span>
