<div class="post-text" itemprop="text">
<p>I defined a new <code>float</code> subclass as follows:</p>
<pre><code>class newfloat(float):
    def __new__(cls, value, attribute):
        r = super().__new__(cls, value)
        r.attribute = attribute
        return r
</code></pre>
<p>When I instantiate a <code>newfloat</code> object, as follows, the <code>newfloat</code> object indeed has an attribute <code>attribute</code>. For example ...</p>
<pre><code>a = newfloat(1, 2)
print(a.attribute)
</code></pre>
<p>... this returns <code>2</code>.</p>
<p>So for some reason, the line <code>r.attribute = attribute</code> works, assigning the second argument value to the class attribute <code>attribute</code>. But this doesn't make sense to me, since objects of the base type, <code>float</code>, are immutable! Why does this work?</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually, the object returned by <code>super().__new__(cls, value)</code> is a <code>newfloat</code>.  That's why you pass along the <code>cls</code> when you call <code>super().__new__</code>.</p>
<p>When defining a new class, you'll get a namespace on instances by default (<a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow noreferrer">docs</a>, ctrl+f for "<em>custom class types</em>"), unless you opt-out of that by declaring <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><code>__slots__</code></a>. You can also set new attributes on instances, for the same reason.</p>
<pre><code>&gt;&gt;&gt; f = newfloat(1.23, 'ok')
&gt;&gt;&gt; f.__dict__
{'attribute': 'ok'}
&gt;&gt;&gt; f.hello = 'world'
&gt;&gt;&gt; f.__dict__
{'attribute': 'ok', 'hello': 'world'}
&gt;&gt;&gt; f
1.23
&gt;&gt;&gt; hash(f) == hash(1.23)
True
</code></pre>
<p>As a developer, the responsibility lies with you to ensure that classes modeling immutable types are correctly behaving like an immutable type should.</p>
</div>
<span class="comment-copy">The fact that <code>object</code> is in the MRO isn't really relevant. After all, <code>object()</code> doesn't have a <code>__dict__</code>. <code>float</code> inherits from <code>object</code> too, but <code>5.3</code> doesn't have a <code>__dict__</code>. <code>object</code> is in any type's MRO, but that fact tells you nothing about whether any type's instances will have a <code>__dict__</code>.</span>
