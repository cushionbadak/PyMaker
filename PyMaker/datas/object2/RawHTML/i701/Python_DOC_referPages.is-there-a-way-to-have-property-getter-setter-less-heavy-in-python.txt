<div class="post-text" itemprop="text">
<p>I have a simple class (<code>Node</code>) that has an ID and 3 coordinates (X,Y,Z). Its ID must be an integer and its coordinates floats, therefore I have used the following class definition.</p>
<p>I'm new to OO programming, but it seems "heavy" for such a simple class. Is there any way to compact that and make it less repetitive? For instance if I had 10 coordinates this would be a bit heavy.</p>
<p>Anyway it works I'm just wondering if there's a better way to do that.</p>
<pre><code>class Node():

    def __init__(self):
        self.ID = 0
        self.X = 0
        self.Y = 0
        self.Z = 0


    @property
    def ID(self):
        return self._ID

    @ID.setter
    def ID(self,value):
        self._ID = int(value)

    @property
    def X(self):
        return self._X


    @X.setter
    def X(self,value):
        self._X = float(value)

    @property
    def Y(self):
        return self._Y


    @Y.setter
    def Y(self,value):
        self._Y = float(value)

    @property
    def Z(self):
        return self._Z

    @Z.setter
    def Z(self,value):
        self._Z = float(value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python, if you want to provide read and write access to attributes, you simply make them "public".</p>
<p>Like so:</p>
<pre class="lang-py prettyprint-override"><code>class Node():

    def __init__(self):
        self.ID = 0  # No underscores
        self.X = 0   # means
        self.Y = 0   # public
        self.Z = 0   # (by convention)
</code></pre>
<p>Now you can use your class like this:</p>
<pre class="lang-py prettyprint-override"><code>n = Node()
n.Z = 9
</code></pre>
<p>This is perfectly fine, because you can still decide later on to adjust the behavior of the read and write operations (using the @property decorator), without braking the interface of your class.</p>
<p>You might also want to look into <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">dataclasses</a> (introducted in Python 3.7):</p>
<pre><code>from dataclasses import dataclass


@dataclass
class Node:
    ID = 0
    X = 0
    Y = 0
    Z: float = 0  # type hints are optional
</code></pre>
<p>A final note: class attributes are lowercase by convention. Only constants should be written with full uppercase letters.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you want is a custom descriptor, not <code>property</code> itself.</p>
<pre><code>class Force(object):
    def __init__(self, type_, var):
        self.type = type_
        self.var = "_" + var

    def __get__(self, obj, type):
        # obj is None when the descriptor is accessed via
        # the class, rather than an instance.
        # type is the class through which the descriptor is accessed;
        # not used here.
        if obj is None:
            return self
        return getattr(obj, self.var)

    def __set__(self, obj, value):
        setattr(obj, self.var, self.type(value))

class Node:
    ID = Force(int, 'ID')
    X = Force(float, 'X')
    Y = Force(float, 'Y')
    Z = Force(float, 'Z')

    def __init__(self):
        self.ID = 0
        self.X = 0
        self.Y = 0
        self.Z = 0
</code></pre>
<p>Python 3.6 added support for a <code>__set_name__</code> method which is called automatically when the descriptor is instantiated, receiving the name the descriptor is assigned to as an argument.</p>
<pre><code>class Force:
    def __init__(self, type_):
        self.type = type_

    def __set_name__(self, owner, name):
        # Owner is the class which contains the descriptor;
        # not used here
        self.var = "_" + name

    def __get__(self, obj, type):
        if obj is None:
            return self
        return getattr(obj, self.var)

    def __set__(self, obj, value):
        setattr(obj, self.var, self.type(value))

class Node:
    ID = Force(int)
    X = Force(float)
    Y = Force(float)
    Z = Force(float)

    def __init__(self):
        self.ID = 0
        self.X = 0
        self.Y = 0
        self.Z = 0
</code></pre>
<p>(I'm certain this can be improved. <code>Force.__init__</code> could take an initial value for each instance of the descriptor, instead of requiring <code>Node.__init__</code> to initialize each.)</p>
</div>
<span class="comment-copy">In Python we only use properties when necessary, not earlier. Your properties do not look necessary. Are you sure you <i>must</i> convert every attribute value, every time?</span>
<span class="comment-copy">Are you sure you want your <code>Node</code> objects to be mutable, i.e. for the attributes to be settable after a Node is created? There are benefits to immutable objects, and it would make this problem easier to solve.</span>
<span class="comment-copy">I need a property (i think) because I am reading a file and I need to convert the string from the files into float/integers. I need to convert it every time. I guess I could create my nodes like : Nodes(ID,X,Y,Z) and have my class be self.ID = float(ID). But it seems cleaner to define my nodes with Node.X = 'something'</span>
<span class="comment-copy">@Moose1231: I would definitely recommend <code>Nodes(int(ID), float(X), float(Y), float(Z))</code> and an immutable <code>Nodes</code> (using <code>typing.NamedTuple</code>) if you can do that.</span>
<span class="comment-copy">OP wants conversion to float/int, hence the properties. Unfortunately dataclasses can't do that.</span>
<span class="comment-copy">Why not store the values on the instances themselves instead of in a <code>self.values</code> dict? It's much easier to handle lifetimes that way. Storing values in an ID-keyed dict, new objects will inherit values from dead objects based on memory allocation, and values never get reclaimed.</span>
<span class="comment-copy">Yep, keying on <code>id(obj)</code> is just incorrect.</span>
<span class="comment-copy">My initial attempt to do that was leading to an infinite recursion error, although I really didn't try to debug it much. Come to think of it, it's because I was trying to use the same name (e.g. <code>X</code>) instead of a private version (e.g. <code>_X</code>). I'll fix it.</span>
