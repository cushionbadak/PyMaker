<div class="post-text" itemprop="text">
<p>I am trying to learn to use asyncio in Python to optimize scripts.
My example returns a <code>coroutine was never awaited</code> warning, can you help to understand and find how to solve it? </p>
<pre><code>import time 
import datetime
import random
import asyncio

import aiohttp
import requests

def requete_bloquante(num):
    print(f'Get {num}')
    uid = requests.get("https://httpbin.org/uuid").json()['uuid']
    print(f"Res {num}: {uid}")

def faire_toutes_les_requetes():
    for x in range(10):
        requete_bloquante(x)

print("Bloquant : ")
start = datetime.datetime.now()
faire_toutes_les_requetes()
exec_time = (datetime.datetime.now() - start).seconds
print(f"Pour faire 10 requêtes, ça prend {exec_time}s\n")

async def requete_sans_bloquer(num, session):
    print(f'Get {num}')
    async with session.get("https://httpbin.org/uuid") as response:
        uid = (await response.json()['uuid'])
    print(f"Res {num}: {uid}")

async def faire_toutes_les_requetes_sans_bloquer():
    loop = asyncio.get_event_loop()
    with aiohttp.ClientSession() as session:
        futures = [requete_sans_bloquer(x, session) for x in range(10)]
        loop.run_until_complete(asyncio.gather(*futures))
    loop.close()
    print("Fin de la boucle !")

print("Non bloquant : ")
start = datetime.datetime.now()
faire_toutes_les_requetes_sans_bloquer()
exec_time = (datetime.datetime.now() - start).seconds
print(f"Pour faire 10 requêtes, ça prend {exec_time}s\n")
</code></pre>
<p>The first <em>classic</em> part of the code runs correctly, but the second half only produces: </p>
<pre><code>synchronicite.py:43: RuntimeWarning: coroutine 'faire_toutes_les_requetes_sans_bloquer' was never awaited
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You made <code>faire_toutes_les_requetes_sans_bloquer</code> an <em>awaitable</em> function, a coroutine, by using<code>async def</code>.</p>
<p>When you call an awaitable function, you create a new coroutine object. The code inside the function won't run until you then <em>await</em> on the function or run it as a task:</p>
<pre><code>&gt;&gt;&gt; async def foo():
...     print("Running the foo coroutine")
...
&gt;&gt;&gt; foo()
&lt;coroutine object foo at 0x10b186348&gt;
&gt;&gt;&gt; import asyncio
&gt;&gt;&gt; asyncio.run(foo())
Running the foo coroutine
</code></pre>
<p>You want to keep that function <em>synchronous</em>, because you don't start the loop until inside that function:</p>
<pre><code>def faire_toutes_les_requetes_sans_bloquer():
    loop = asyncio.get_event_loop()
    # ...
    loop.close()
    print("Fin de la boucle !")
</code></pre>
<p>However, you are also trying to use a <code>aiophttp.ClientSession()</code> object, and that's an <em>asynchronous context manager</em>, you are expected to use it with <code>async with</code>, not just <code>with</code>, and so has to be run in aside an awaitable task. If you use <code>with</code> instead of <code>async with</code> a <code>TypeError("Use async with instead")</code> exception will be raised.</p>
<p>That all means you need to move the <code>loop.run_until_complete()</code> call <em>out</em> of your <code>faire_toutes_les_requetes_sans_bloquer()</code> function, so you can keep that as the main task to be run; you can call and await on <code>asycio.gather()</code> directly then:</p>
<pre><code>async def faire_toutes_les_requetes_sans_bloquer():
    async with aiohttp.ClientSession() as session:
        futures = [requete_sans_bloquer(x, session) for x in range(10)]
        await asyncio.gather(*futures)
    print("Fin de la boucle !")

print("Non bloquant : ")
start = datetime.datetime.now()
loop.run(faire_toutes_les_requetes_sans_bloquer())
exec_time = (datetime.datetime.now() - start).seconds
print(f"Pour faire 10 requêtes, ça prend {exec_time}s\n")
</code></pre>
<p>I used the new <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run" rel="nofollow noreferrer"><code>asyncio.run()</code> function</a> (Python 3.7 and up) to run the single main task. This creates a dedicated loop for that top-level coroutine and runs it until complete.</p>
<p>Next, you need to move the closing <code>)</code> parenthesis on the <code>await resp.json()</code> expression:</p>
<pre><code>uid = (await response.json())['uuid']
</code></pre>
<p>You want to access the <code>'uuid'</code> key on the result of the <code>await</code>, not the coroutine that <code>response.json()</code> produces.</p>
<p>With those changes your code works, but the asyncio version finishes in sub-second time; you may want to print microseconds:</p>
<pre><code>exec_time = (datetime.datetime.now() - start).total_seconds()
print(f"Pour faire 10 requêtes, ça prend {exec_time:.3f}s\n")
</code></pre>
<p>On my machine, the synchronous <code>requests</code> code in about 4-5 seconds, and the asycio code completes in under .5 seconds.</p>
</div>
<div class="post-text" itemprop="text">
<p>Do not use <code>loop.run_until_complete</code> call inside <code>async</code> function. The purpose for that method is to run an async function inside sync context. Anyway here's how you should change the code:</p>
<pre><code>async def faire_toutes_les_requetes_sans_bloquer():
    async with aiohttp.ClientSession() as session:
        futures = [requete_sans_bloquer(x, session) for x in range(10)]
        await asyncio.gather(*futures)
    print("Fin de la boucle !")

loop = asyncio.get_event_loop()
loop.run_until_complete(faire_toutes_les_requetes_sans_bloquer())
</code></pre>
<p>Note that alone <code>faire_toutes_les_requetes_sans_bloquer()</code> call creates a future that has to be either awaited via explicit <code>await</code> (for that you have to be inside <code>async</code> context) or passed to some event loop. When left alone Python complains about that. In your original code you do none of that.</p>
</div>
<span class="comment-copy">Why did you use <code>faire_toutes_les_requetes_sans_bloquer()</code> at the end of your module? That call creates the awaitable object (a coroutine), but you never <code>await</code> on it.</span>
<span class="comment-copy">thank you ! it's more clear now</span>
<span class="comment-copy">and don't forget to <code>import asyncio</code> and the beginning</span>
<span class="comment-copy">Note: this now will raise <code>TypeError("Use async with instead")</code>, because <code>ClientSession()</code> is an asynchronous context manager.</span>
<span class="comment-copy">@MartijnPieters Fair enough, fixed.</span>
<span class="comment-copy">thank you ! working :)</span>
