<div class="post-text" itemprop="text">
<pre><code>import weakref

class Cheese:
  def __init__(self,kind):
    self.kind = kind

  def __repr__(self):
    return "cheese {}".format(self.kind)



stock = weakref.WeakValueDictionary()
catalog = [Cheese("red"),Cheese("block"),Cheese("lock"),Cheese("hehe")]
for cheese in  catalog:
    stock[cheese.kind] = cheese

print(sorted(stock.keys()))
del catalog
print(sorted(stock.keys()))
</code></pre>
<p>result is :</p>
<pre><code>['block', 'hehe', 'lock', 'red']
['hehe']
</code></pre>
<p>Question: why result is not :</p>
<pre><code>['block', 'hehe', 'lock', 'red']
['block', 'hehe', 'lock', 'red']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That's because you're using a <code>weakref.WeakValueDictionary()</code> for <code>stock</code>. From the <a href="https://docs.python.org/3/library/weakref.html" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>A weak reference to an object is not enough to keep the object alive: when the only remaining references to a referent are weak references, <strong>garbage collection is free to destroy the referent and reuse its memory for something else</strong>.</p>
</blockquote>
<p>So destroying <code>catalog</code> allows the garbage collector to destroy <code>stock</code> contents.</p>
<p>Only remaining element is the last one because it's referenced by the last loop item as <code>cheese</code></p>
<p>If you perform a <code>del cheese</code>, then the second printout is completely empty.</p>
</div>
<div class="post-text" itemprop="text">
<p>A <code>WeakValueDictionary</code> will dispose the items if the values are not referenced anywhere else anymore.</p>
<p>In your case all values are referenced in <code>catalog</code>, and one item additionally as <code>cheese</code> (left over from the last iteration). When <code>catalog</code> is deleted only one element has an other reference, the others get disposed.</p>
</div>
<span class="comment-copy">OH  got it!  yes!  thanks</span>
