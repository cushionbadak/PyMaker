<div class="post-text" itemprop="text">
<p>I was learning itertools and was trying out to test the accuracy of Binet's formula implemented in python. Reason for using itertools was my assumption that this would take a lot of iterations and a discrepancy would occur only after a lot of iterations.  </p>
<pre><code>from math import sqrt
import itertools
#fibonacci function 2
def fib1():
    n = -1
    while True:
        n += 1
        yield int(((1+sqrt(5))**n-(1-sqrt(5))**n)/(2**n*sqrt(5)))

#fibonacci function 1
def fib2():
    a,b = 0,1
    while True:
        yield a
        a, b = b, a + b


r=itertools.dropwhile(lambda x: x[0]==x[1],itertools.zip_longest(fib1(),fib2()))
for item in itertools.islice(r,0,1):
    print(item)
</code></pre>
<p>Outputs:</p>
<pre><code>(498454011879265, 498454011879264)
</code></pre>
<p>Before using <code>int()</code> i used <code>round()</code> in <code>fib1()</code>, and the result was </p>
<pre><code>(308061521170130, 308061521170129)
</code></pre>
<p>So by changing that i was able to improve the iteration count by one. </p>
<p>My guess is that the <code>math.sqrt()</code> has some limitations and this can be swapped by "something else" to make it more accurate. <strong>My question is what all can be done to improve the accuracy of my binet's formula's implementation</strong>. </p>
<p>I read through <a href="https://docs.python.org/3/library/decimal.html#module-decimal" rel="nofollow noreferrer">decimal</a> but was not able to make it work for me. I read many questions on SO regarding Fibonacci  implementation in python and all of them uses <code>math.sqrt()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>decimal</code> is the way to go. By the way, at the end, there's no point <code>islice</code>ing by 1 when you can just do <code>next(r)</code>:</p>
<pre><code>from decimal import *
from math import sqrt
import itertools

getcontext().prec = 100

r5 = Decimal('5').sqrt()

#fibonacci function 2
def fib1():
    n = -1
    while True:
        n += 1
        yield round(((1+r5)**n-(1-r5)**n)/(2**n*r5))

#fibonacci function 1
def fib2():
    a,b = 0,1
    while True:
        yield a
        a, b = b, a + b


r = itertools.dropwhile(lambda x: x[0]==x[1],itertools.zip_longest(fib1(),fib2()))
print(next(r))
</code></pre>
<p>With a precision of <code>100</code>, a result of</p>
<pre><code>(196191955446197556957565929345772792668594307949581132632670453793550007197467505024573547039776940, 196191955446197556957565929345772792668594307949581132632670453793550007197467505024573547039776939)
</code></pre>
<p>was achieved. Pretty impressive! I used a precision of <code>1000</code>, and got</p>
<pre><code>(1269356787836526638292881388412062563384016584999139363845916252828272232391810020280832776534348222207097659424636568046262415695352482639760055677447593862489663810195738708939477943905134153356636045977981999863686835051315779906086619798132074368682560092328661225751314808679246693245387236063332746366841928263523362820098118474833094929286676587582542369660341001022447403731596463443972162558919745776554315895623816909167795557047770582177376717988622403278870301415328956789820495406257373628508043139338202820103414370691678600911481661883803507957985612992446553943499307293537223525134209303990984810141957868318317038241920752310815343034067670415777278631587961096314226337926487733666947275129471624775876156460533864928511199003774695438447857706244332893210973780928258183512460663452551185318925295791590656959561960353727992207635442970269567411956580203564583038131744735283364875667417153145494305056027330033836269453405615559944082171014269659283681044165083851285941191290, 1269356787836526638292881388412062563384016584999139363845916252828272232391810020280832776534348222207097659424636568046262415695352482639760055677447593862489663810195738708939477943905134153356636045977981999863686835051315779906086619798132074368682560092328661225751314808679246693245387236063332746366841928263523362820098118474833094929286676587582542369660341001022447403731596463443972162558919745776554315895623816909167795557047770582177376717988622403278870301415328956789820495406257373628508043139338202820103414370691678600911481661883803507957985612992446553943499307293537223525134209303990984810141957868318317038241920752310815343034067670415777278631587961096314226337926487733666947275129471624775876156460533864928511199003774695438447857706244332893210973780928258183512460663452551185318925295791590656959561960353727992207635442970269567411956580203564583038131744735283364875667417153145494305056027330033836269453405615559944082171014269659283681044165083851285941191291)
</code></pre>
<p>though the code did take a while to run (~30 sec).</p>
</div>
<span class="comment-copy">I used islice as I was printing out some more iterations after that to check out the next numbers as well. Thanks for pointing that out</span>
<span class="comment-copy">@BittoBennichan In that case, that's a pretty valid use. Anyway, glad to have helped!</span>
