<div class="post-text" itemprop="text">
<p>I'm having an issue with matching exactly one colon towards the tail end of a timestamp value. I want to match this colon exactly and then convert to a period. I have tried several ways to try to match this colon exactly, but to no avail.</p>
<p>Here's an example: 02:44:05:406 -&gt; 02:44:05.406</p>
<p>I created the following regex: :\d+$ -&gt; this will match :406 towards the end of the timestamp.</p>
<p>I tried a different approach: \d+:\d+$ -&gt; this matches 02:44, 44:05, 05:406</p>
<p>I even tried this one: [^\d+] -&gt; this matches all three colons :</p>
<p>However, I want the last colon - 02:44:05:406 and replace that with a "."</p>
<p>Any ideas on how to do this? I'm using Python 3 and regex.</p>
<p>EDIT: Removing ** from the third colon (e.g. <strong>:</strong>) to avoid confusion.</p>
</div>
<div class="post-text" itemprop="text">
<p>If regex is not mandatory, you could just use <a href="https://docs.python.org/3/library/stdtypes.html#str.rsplit" rel="nofollow noreferrer"><code>str.rsplit()</code></a> with <code>maxsplit</code> option:</p>
<pre><code>&gt;&gt;&gt; s = '02:44:05**:**406'
&gt;&gt;&gt; '.'.join(s.rsplit(':', 1))
02:44:05**.**406
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need this as your regex</p>
<pre><code>r'^(.*):'
</code></pre>
<p>Match as many characters as possible up to the last <code>:</code> and capture them</p>
<p>Then your substitution should be </p>
<pre><code>'\1.'
</code></pre>
<p>all the stuff captured followed by a dot</p>
<p>so your code looks like</p>
<pre><code>re.sub(r'^(.*):', '\1.', text)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#str.rpartition" rel="nofollow noreferrer">str.rpartition</a> to split the string on the final colon, then <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer">str.join</a> to create the new string.</p>
<pre><code>&gt;&gt;&gt; ts = '02:44:05:406'
&gt;&gt;&gt; a, sep, b = ts.rpartition(':')
&gt;&gt;&gt; res = '.'.join((a, b))
&gt;&gt;&gt; res
'02:44:05.406'
</code></pre>
<p>Or you could use string formatting to create the new string:</p>
<pre><code>&gt;&gt;&gt; res = '{}.{}'.format(a, b)
&gt;&gt;&gt; res
'02:44:05.406'
</code></pre>
</div>
<span class="comment-copy">Is regex mandatory?</span>
<span class="comment-copy">Your first regex is already matching what needs to be matched, it just needs a capturing group. <code>re.sub(r':(\d+)$', r'.\1', s)</code></span>
<span class="comment-copy">I will try this. I thought regex was the only way...</span>
