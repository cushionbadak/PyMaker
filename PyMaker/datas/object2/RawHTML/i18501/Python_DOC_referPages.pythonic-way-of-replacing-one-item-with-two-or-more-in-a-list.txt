<div class="post-text" itemprop="text">
<p>how can i programaticaly replace one item in a list with two or more? I'm doing it with splits and indexes, and it looks very un-python.</p>
<p>I'm wishing something like this exists:</p>
<pre><code>values = [ "a", "b", "old", "c" ]
[ yield ["new1", "new2"] if item == "old" else item for item in values ]
// return [ "a", "b", "new1", "new2", "c" ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best way to do this would be to use <a href="http://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>itertools.chain.from_iterable</code></a>:</p>
<pre><code>itertools.chain.from_iterable(
  ("new1", "new2") if item == "old" else (item, ) for item in values)
</code></pre>
<p>The 'multiple items per item' problem you face is solved by making a nested list, then expanding it out. By making all items tuples (single-item tuples where we only want one), we can achieve this.</p>
<p>Of course, if you need a list, rather than an iterator, wrap the whole thing with a call to <code>list()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you have the right idea.  However, list comprehensions aren't always a good fit.</p>
<p>Here is a solution using list concatenation:</p>
<pre><code>values = [ 'a', 'b', 'old', 'c' ]

def sub1(values, old, new):
    newvalues = []
    for item in values:
        if item == old:
            newvalues += new
        else:
            newvalues += [item]
    return newvalues

print sub1(values, 'old', ['new1', 'new2'])
</code></pre>
<p>and here one using a generator:</p>
<pre><code>def sub2(values, old, new):
    for item in values:
        if item == old:
            for i in new:
                yield i
        else:
            yield item

for i in sub2(values, 'old', ['new1', 'new2']):
    print i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a general* solution for multiple values, as demanded by OP <a href="https://stackoverflow.com/questions/18498634/pythonic-way-of-replacing-one-item-with-two-or-more-in-a-list/18498821?noredirect=1#comment27198446_18498821">here</a>:</p>
<pre><code>subs = {'old':("new1", "new2"), 'cabbage':('ham','and','eggs')}
itertools.chain.from_iterable(
  subs[item] if item in subs else (item, ) for item in values)
</code></pre>
<p>Using an append-based method doesn't become any easier or harder, either:</p>
<pre><code>def sub1(values, subs):
    newvalues = []
    for item in values:
        if item in subs:
            newvalues += subs[item]
        else:
            newvalues += [item]
    return newvalues
</code></pre>
<p><code>*</code> if your old items are unhashable, then this won't work, and you'll need to make them hashable or figure out another datastructure. You'll still like that more than writing equality tests out. </p>
</div>
<div class="post-text" itemprop="text">
<p>OK. More functional, but I'm not sure that's really more 'Pythonic':</p>
<pre><code>reduce(operator.add, [ [x] if x != 'old' else ['new1','new2']  for x in values ] )
</code></pre>
<p>Really the same as another answer, except reduce instead of itertools. </p>
<p>Reduce is a standard functional programming idiom, so it should be more obvious what it does.</p>
<p>itertools.chain.from_iterable is cool, but kind of obscure. </p>
</div>
<span class="comment-copy">wow, we had a good discussions on the other answers and everyone just deleted them. strange. But thanks everyone!</span>
<span class="comment-copy">@arshajii: what happens if "old" occurs twice?  Slicing solution won't catch 'em all unless you loop -- this Just Works(tm).</span>
<span class="comment-copy">Another variation: <code>[i for item in values for i in (('new1', 'new2') if item == 'old' else (item,))]</code></span>
<span class="comment-copy">@PavelAnossov That method of flattening is less clear and slower. In general, I would recommend against it.</span>
<span class="comment-copy">@gcb Using the standard library isn't a dependency - it's just not reinventing the wheel. Avoiding the standard library is just flat out a silly thing to do.</span>
<span class="comment-copy">@Lattyware: It might be less clear (and reinventing the wheel), but I don't think it's slower.</span>
<span class="comment-copy">This is not better than the other solution.</span>
<span class="comment-copy">@Marcin Why not?  I think it is more clear and easier to generalize.</span>
<span class="comment-copy">And I think you're wrong.</span>
<span class="comment-copy">@Marcin being fair, the manual for the linked function in the top answer even mentions it's "equivalent to" a function that idfah just posted. And I have to agree, that if I had to check for a dozen values, i'd probably use that style.</span>
<span class="comment-copy">The issue is the repeated extension of the list is much slower, and you are reinventing the wheel. I don't see your code is any clearer, it's just more verbose.</span>
<span class="comment-copy">good points. the only case then when i would pick the latter is, as you mention, if had to check some webservice or some other non interable structure. Thanks. Much appreciated.</span>
<span class="comment-copy">@gcb I think you're confused. Firstly, there is no structure which is incapable of iteration in defined or arbitrary order. Secondly, a webservice is not such a structure. Thirdly, the second form has no benefits in any case whatsoever, and will always be slower.</span>
<span class="comment-copy">This is considerably less efficient than <code>itertools.chain.from_iterable()</code> as it requires making a ton of intermediate lists. Also, <code>reduce()</code> and <code>operator.add()</code> is just recreating <code>sum()</code> (which is advised against for joining lists due to the reason I gave initially).</span>
