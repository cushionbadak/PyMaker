<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/15399024/does-the-is-operator-use-a-magic-method-in-python">Does the `is` operator use a __magic__ method in Python?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>While looking through the docs, and specifically here <a href="http://docs.python.org/2/reference/expressions.html#is" rel="noreferrer">http://docs.python.org/2/reference/expressions.html#is</a>, I still can't find the dunder/protocol method that defines the implementation of the Python keyword <code>is</code>. What method determines it? From what I understand, all <code>is</code> does is to compare the results of the <code>id</code> function when called on two objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no dunder method for <code>is</code>. You can't override it, and that's intentional. The whole point of <code>is</code> is that it tells you whether two expressions reference the same value. So it has to be false, by definition, for two different values. So there's no need to override it.</p>
<p>As <a href="http://docs.python.org/3/reference/expressions.html#is" rel="noreferrer">the docs</a> put it:</p>
<blockquote>
<p>The operators <code>is</code> and <code>not is</code> test for object identity: <code>x is y</code> is true if and only if <em>x</em> and <em>y</em> are the same object.</p>
</blockquote>
<p>(There's a little more in the <a href="http://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="noreferrer">Data model docs</a>.)</p>
<hr/>
<p>Also, <code>is</code> doesn't compare the results of <code>id</code>. </p>
<p><a href="http://docs.python.org/3/library/functions.html#id" rel="noreferrer"><code>id</code></a> is just defined to return "an integer which is guaranteed to be unique and constant for this object during its lifetime". Which means <code>is</code> certainly <em>could</em> use <code>id</code>, but I don't know of any implementation where it does.</p>
<p>That being said, in CPython, it does effectively the same thing under the covers—<a href="http://hg.python.org/cpython/file/3.3/Python/ceval.c#l4430" rel="noreferrer"><code>is</code></a> checks that the pointers are equal, while <a href="http://hg.python.org/cpython/file/3.3/Python/bltinmodule.c#l964" rel="noreferrer"><code>id</code></a> casts the pointer into an integer and returns it. So the only difference between implementing it directly vs. implementing it via <code>id</code> would be an extra pair of function calls and a cast that would compile to no machine code…</p>
<p>But in other implementations, even that may not be true. (Which should be obvious, when you consider that Jython and PyPy are written in languages that don't even have such a thing as a pointer.) For example, in PyPy, <code>is</code> checks that the underlying RPython objects are the same, while <code>id</code> returns a key generated on the fly (and cached if you later call <code>id</code> on the same value).</p>
</div>
<span class="comment-copy">You are right; and <code>id</code> returns the memory location of the object. So unless you want to put your object in some specific location in RAM, you should never need to write your own <code>is</code> implementation. If you want to check for equivalence of two objects, use <code>__eq__</code> instead</span>
<span class="comment-copy">@inspectorG4dget Thanks!</span>
<span class="comment-copy">I just learned the meaning of <a href="http://wiki.python.org/moin/DunderAlias" rel="nofollow noreferrer">dunder</a>!</span>
<span class="comment-copy">@StevenRumbalski Ha, upvote the thread to show appreciate :p</span>
<span class="comment-copy">@inspectorG4dget: That's a little misleading, because it's only true for CPython. Jython or PyPy couldn't return a memory location even if they wanted to.</span>
<span class="comment-copy">Wait, so there is no pure python implementation for <code>is</code>, its all in C?</span>
<span class="comment-copy">Nope. If <code>a</code> dies before <code>b</code> is created, they may have the same id despite being different objects. This isn't possible with <code>is</code>, since both objects must survive until the operator is evaluated.</span>
<span class="comment-copy">It can be collected between the evaluation of its ID and the creation of <code>b</code>. Consider the call <code>id([]) == id([])</code> (which returned <code>True</code> when I just tried it). The first list is created, then its ID is evaluated. At this point, there are no more references to it, and it can be GC'd. Then the second list is created, and it's free to reuse the just-collected object.</span>
<span class="comment-copy">@EdgarAroutiounian: This problem can also happen if you store <code>id</code> numbers and compare then later. Correctly using <code>id</code> for anything that couldn't be done with <code>is</code> can be tricky; you have to ensure that you only ever compare <code>id</code> numbers of objects with overlapping lifetimes.</span>
<span class="comment-copy">@nmclean: If <code>a</code> and <code>b</code> are variables, they won't be collected, but if they're placeholders for arbitrary expressions, <code>a</code> may be collectable after <code>id(a)</code> is evaluated. Try <code>id([]) == id([])</code> and see what you get.</span>
