<div class="post-text" itemprop="text">
<p>I'm trying to raise an exception within an <code>except:</code> block but the interpreter tries to be helpful and prints stack traces 'by force'. Is it possible to avoid this?</p>
<p>A little bit of background information: 
I'm toying with urwid, a <a href="http://excess.org/urwid/" rel="nofollow">TUI library</a> for python. The user interface is started by calling <code>urwid.MainLoop.run()</code> and ended by <em>raising</em> <code>urwid.ExitMainLoop()</code>. So far this works fine but what happens when another exception is raised? E.g. when I'm catching <code>KeyboardInterrupt</code> (the urwid MainLoop does not), I do some cleanup and want to end the user interface - by raising the appropriate exception. But this results in a screen full of stack traces.</p>
<p>Some little research showed python3 remembers chained exceptions and one can explicitly raise an exception with a 'cause': <code>raise B() from A()</code>. I learned a few ways to change or append data regarding the raised exceptions but I found no way to 'disable' this feature. I'd like to avoid the printing of stack traces and lines like <code>The above exception was the direct cause of...</code> and just raise the interface-ending exception within an <code>except:</code> block like I would outside of one.</p>
<p>Is this possible or am I doing something fundamentally wrong?</p>
<p><strong>Edit</strong>:
Here's an example resembling my current architecture, resulting in the same problem:</p>
<pre><code>#!/usr/bin/env python3
import time

class Exit_Main_Loop(Exception):
    pass

# UI main loop
def main_loop():
    try:
        while True:
            time.sleep(0.1)
    except Exit_Main_Loop as e:
        print('Exit_Main_Loop')
        # do some UI-related clean up

# my main script
try:
    main_loop()
except KeyboardInterrupt as e:
    print('KeyboardInterrupt')
    # do some clean up
    raise Exit_Main_Loop()      # signal the UI to terminate
</code></pre>
<p>Unfortunately I can't change <code>main_loop</code> to except <code>KeyboardInterrupt</code> as well. Is there a pattern to solve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I still don't quite understand your explanation, but from the code:</p>
<pre><code>try:
    main_loop()
except KeyboardInterrupt as e:
    print('KeyboardInterrupt')
    # do some clean up
    raise Exit_Main_Loop()      # signal the UI to terminate
</code></pre>
<p>There is no way that <code>main_loop</code> could ever see the <code>Exit_Main_Loop()</code> exception. By the time you get to the <code>KeyboardInterrupt</code> handle, <code>main_loop</code> is guaranteed to have already finished (in this case, because of an unhandled <code>KeyboardInterrupt</code>), so its exception handler is no longer active.</p>
<p>So, what happens is that you raise a new exception that nobody catches. And when an exception gets to the top of your code without being handled, Python handles it automatically by printing a traceback and quitting.</p>
<p>If you want to convert one type of exception into another so <code>main_loop</code> can handle it, you have to do that somewhere <em>inside</em> the <code>try</code> block.</p>
<p>You say:</p>
<blockquote>
<p>Unfortunately I can't change main_loop to except KeyboardInterrupt as well. </p>
</blockquote>
<p>If that's true, there's no real answer to your problem… but I'm not sure there's a problem in the first place, other than the one you created. Just remove the <code>Exit_Main_Loop()</code> from your code, and isn't it already doing what you wanted? If you're just trying to prevent Python from printing a traceback and exiting, this will take care of it for you.</p>
<hr/>
<p>If there really <em>is</em> a problem—e.g., the <code>main_loop</code> code has some cleanup code that you need to get executed no matter what, and it's not getting executed because it doesn't handle <code>KeyboardInterrupt</code>—there are two ways you could work around this.</p>
<hr/>
<p>First, as the <a href="http://docs.python.org/3/library/signal.html#general-rules" rel="nofollow"><code>signal</code></a> docs explain:</p>
<blockquote>
<p>The <code>signal.signal()</code> function allows to define custom handlers to be executed when a signal is received. A small number of default handlers are installed: … <code>SIGINT</code> is translated into a <code>KeyboardInterrupt</code> exception.</p>
</blockquote>
<p>So, all you have to do is replace the default handler with a different one:</p>
<pre><code>def handle_sigint(signum, frame):
    raise ExitMainLoop()
signal.signal(signal.SIGINT, handle_sigint)
</code></pre>
<p>Just do this before you start <code>main_loop</code>, and you should be fine. Keep in mind that there are some limitations with threaded programs, and with Windows, but if none of those limitations apply, you're golden; a ctrl-C will trigger an <code>ExitMainLoop</code> exception instead of a <code>KeyboardInterrupt</code>, so the main loop will handle it. (You may want to also add an <code>except ExitMainLoop:</code> block in your wrapper code, in case there's an exception <em>outside of</em> <code>main_loop</code>. However, you could easily write a <code>contextmanager</code> that sets and restores the signal around the call to <code>main_loop</code>, so there isn't any outside code that could possibly raise it.)</p>
<hr/>
<p>Alternatively, even if you can't edit the <code>main_loop</code> source code, you can always monkeypatch it at runtime. Without knowing what the code looks like, it's impossible to explain exactly how to do this, but there's almost always a way to do it.</p>
</div>
<span class="comment-copy">Do you want no stack trace at all, or do you want just the outermost exception's stack trace, or just the innermost exception's stack trace?</span>
<span class="comment-copy">If you don't want <i>any</i> stack trace, just wrap your whole "main" code in a <code>try:</code>/<code>except Exception as e:</code> and then handle the exception however you want (e.g., <code>print(repr(e)); sys.exit(1)</code>).</span>
<span class="comment-copy">I'd like to have nothing indicating an exception occurred (for the user) - no stack trace or other text output (except things I print myself, of course). I mean, I catched the exception and did what I had to do - there's no stack trace needed anymore (I'd print it myself if I wanted to read it). Similarly, urwid.MainLoop catches the Exit exception silent, too. I see no reason why just because there are two exceptions in a row (both catched properly) should result in an output resembling an uncatched exception.</span>
<span class="comment-copy">I still don't understand your issue. Can you give us an <a href="http://sscce.org" rel="nofollow noreferrer">SSCCE</a> that demonstrates your problem (preferably one that doesn't use <code>urwid</code> or any other event loop at all)?</span>
<span class="comment-copy">I added a small example, resembling my 'design' and the problem.</span>
<span class="comment-copy">In reality <code>main_loop()</code> is an external (ui) library that needs to terminate properly and this is done by raising (the also external) <code>Exit_Main_Loop</code>. I see your point, there's no way for it to work like it currently is but I don't know how to model it in a better (working/correct) way.</span>
<span class="comment-copy">So is there any actual problem, with the main loop not doing some proper shutdown that you need it to do because it doesn't handle <code>KeyboardInterrupt</code>? If so, there are two ways you can work around the problem, but they're both going to be at least a little ugly. Let me edit the answer to explain.</span>
<span class="comment-copy">Well, it performs a proper cleanup even in case of a <code>KeyboardInterrupt</code> (except for a printed stack trace) but in this case I need to do some clean up, too (prior to shutting down the UI). My initial answer was a bit... messy, mainly because I had a wrong understanding of the problem itself, sorry. Thanks a lot for your answer, I'm going with the signal handler.</span>
