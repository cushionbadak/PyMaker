<div class="post-text" itemprop="text">
<p>How can I get the number of milliseconds since epoch?</p>
<p>Note that I want the actual milliseconds, not seconds multiplied by 1000. I am comparing times for stuff that takes less than a second and need millisecond accuracy. (I have looked at lots of answers and they all seem to have a *1000)</p>
<p>I am comparing a time that I get in a POST request to the end time on the server. I just need the two times to be in the same format, whatever that is. I figured unix time would work since Javascript has a function to get that</p>
</div>
<div class="post-text" itemprop="text">
<p><code>time.time() * 1000</code> <em>will</em> give you millisecond accuracy if possible.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>int(time.time() * 1000)</code> will do what you want. <code>time.time()</code> generally returns a float value with double precision counting seconds since epoche, so multiplying it does no harm to the precision.</p>
<p>Another word to the misleading answer of @kqr: <code>time.clock()</code> does not give you the time of the epoch. It gives you the time that the process ran on the CPU for Unix, or the time passed since the first call to the function on Windows, see the <a href="https://docs.python.org/2/library/time.html#time.clock" rel="noreferrer">python docs</a>.</p>
<p>Also it's true that the docs state, that <code>time.time()</code> is not guaranteed to give you ms precision. Though this statement is mainly ment for you to make sure not to rely on this precision on embedded or praehistoric hardware, and I'm not aware of any example, where you actually wouldn't get ms precision.</p>
</div>
<div class="post-text" itemprop="text">
<p>I see many people suggesting <code>time.time()</code>. While <code>time.time()</code> is an accurate way of measuring the actual time of day, <em>it is not guaranteed to give you millisecond precision!</em> From the documentation:</p>
<blockquote>
<p>Note that even though the time is always returned as a floating point number, not all systems provide time with a better precision than 1 second. While this function normally returns non-decreasing values, it can return a lower value than a previous call if the system clock has been set back between the two calls.</p>
</blockquote>
<p>This is <em>not</em> the procedure you want when comparing two times! It can blow up in so many interesting ways without you being able to tell what happened. In fact, when comparing two times, you don't really need to know what time of day it is, only that the two values have the same starting point. For this, the <code>time</code> library gives you another procedure: <code>time.clock()</code>. The documentation says:</p>
<blockquote>
<p>On Unix, return the current processor time as a floating point number expressed in seconds. The precision, and in fact the very definition of the meaning of “processor time”, depends on that of the C function of the same name, but in any case, <strong>this is the function to use for benchmarking Python or timing algorithms.</strong></p>
<p>On Windows, this function returns wall-clock seconds elapsed since the first call to this function, as a floating point number, based on the Win32 function QueryPerformanceCounter(). <strong>The resolution is typically better than one microsecond</strong>.</p>
</blockquote>
<p>Use <code>time.clock()</code>.</p>
<hr/>
<p>Or if you just want to test how fast your code is running, you could make it convenient for yourself and use <a href="http://docs.python.org/2/library/timeit.html#timeit.timeit"><code>timeit.timeit()</code></a> which does all of the measuring for you and is the de facto standard way of measuring elapsed time in code execution.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="http://docs.python.org/2/library/datetime.html" rel="noreferrer">datetime</a>:</p>
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; delta = datetime.datetime.utcnow() - datetime.datetime(1970, 1, 1)
&gt;&gt;&gt; delta
datetime.timedelta(15928, 52912, 55000)
&gt;&gt;&gt; delta.total_seconds()
1376232112.055
&gt;&gt;&gt; delta.days, delta.seconds, delta.microseconds
(15928, 52912, 55000)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import datetime
time = datetime.datetime.now()
ms = time.microsecond
</code></pre>
<p>Returns a 6 digit number, microsecond. The last 3 digits are useless in PC since it works with ticks, which is slower than microsecond. The first 3 digits should be enough for your need.</p>
</div>
<span class="comment-copy">If you need millisecond accuracy are you sure you need absolute time (since epoch)? Typically that accuracy is only needed in a relative sense, say relative to when the computer started.</span>
<span class="comment-copy">I am comparing a time that I get in a post request to the end time on the server. Really I just need the two times to be in the same format, whatever that is. I figured unix time would work since js has a function to get that.</span>
<span class="comment-copy">you probably want <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow noreferrer"><code>time.perf_counter()</code></a> (only relative values make sense) to measure short intervals instead of the absolute time such as provided by <code>time.time()</code>.</span>
<span class="comment-copy">So on Unix, <code>clock()</code> is <i>not</i> appropriate. It counts, as you cite, processor time which is different from wall clock time, even in relative manners.</span>
<span class="comment-copy">If you are simply comparing two times, calculating the difference between two <code>clock()</code> calls will give you the most accurate measure of passed time. Using <code>time()</code> the delta might not be precise enough, and could even be <i>negative</i>!</span>
<span class="comment-copy">If you have several programs running at the same time, your system gets slower. The programs need more wall clock time, but the same CPU time. That can be a huge difference if you need the precise time.</span>
<span class="comment-copy"><a href="http://pastebin.com/0fcygeBF" rel="nofollow noreferrer">This program</a> shows the difference. If I run it to the end, the last calls to <code>fac()</code> need a CPU time of about .58 s, but a real time of about 7.5 s. This is because they don't get the full CPU's attention, and a job which ought to be finished in .58 s needs 7.5 s due to parallelization.</span>
<span class="comment-copy">If you're going to place the result in a DB, but sure to convert to str first as Python will note the long integer with a trailing "L".  Typical Python stuff, but I got burned by it today....</span>
<span class="comment-copy">it is incorrect unless the current UTC offset is exactly the same as in 1970. Use <code>.utcnow()</code>. <a href="http://stackoverflow.com/q/26313520/4279">more</a></span>
<span class="comment-copy">"Useless in PC since it works with ticks, which is slower than microsecond". Interesting.</span>
<span class="comment-copy">That won't give you milliseconds since the epoche, but milliseconds since the last second start.</span>
<span class="comment-copy">I was curious why I'm seeing the spelling 'epoche' so much on this page. A Google search says 'Epoche is a lovely gift store in Kallista, Victoria'—probably not what people mean. There's Epoché, an ancient Greek term, which is probably the source of the modern English word 'epoch'. But in every dictionary I've checked, 'epoch' is the correct spelling... unless 'epoche' is another one of those 'US English' spellings...</span>
<span class="comment-copy">@MichaelScheper Only if you count incidental misspellings as American English. Since both instances on this page are from the same user, we can assume that he is either mistaken or deliberately taking it back to the Greek source.</span>
