<div class="post-text" itemprop="text">
<p>I have this python code,</p>
<pre><code>open('%s.log'%hname,'w').writelines([ line for line in open('%s_tmp.log' %hname) if 'word' in line])
</code></pre>
<p>This prints the line same as in the <code>%hname_tmp.log</code> :</p>
<pre><code>b'line contains blah\n'
b'This is the next line\n'
</code></pre>
<p>I would like to remove <code>b'</code> and <code>\n'</code> before writing to the new file. Something like this:</p>
<pre><code>line contains blah
This is the next line
</code></pre>
<p>How can I do that ? I have tried </p>
<p><code>...writelines([line.rstrip() ...</code>, </p>
<p>but this jams everything in the new log file in one line while still keeping the <code>\n'</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Open the output file as binary:</p>
<pre><code>open('%s.log'%hname, 'wb').writelines([ line for line in open('%s_tmp.log' %hname) if 'word' in line])
</code></pre>
<p>or <em>decode</em> the <code>bytes</code> objects before writing:</p>
<pre><code>open('%s.log'%hname, 'w').writelines([line.decode('ascii') for line in open('%s_tmp.log' %hname) if 'word' in line])
</code></pre>
<p>If your <em>original</em> log file contains those characters, you wrote binary data to <em>that</em> log file instead. You can re-interpret those lines as bytes objects by using the <a href="http://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow"><code>ast.literal_eval()</code> utility function</a>:</p>
<pre><code>from ast import literal_eval

with open('%s.log'%hname, 'wb') as outfile:
    outfile.writelines(literal_eval(line.rstrip()) for line in open('%s_tmp.log' %hname) if 'word' in line)
</code></pre>
<p><code>literal_eval()</code> takes strings that represent Python literals and turns them back into Python objects just like the Python compiler would.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are reading the file as binary.  Try opening with <code>'rt'</code>.</p>
<pre><code>open('%s.log'%hname,'wt').writelines([ line for line in open('%s_tmp.log' %hname, 'rt') if 'word' in line])
</code></pre>
</div>
<span class="comment-copy"><code>re.sub(r'(b\'|\\n\')', '', line) for line in open...</code></span>
<span class="comment-copy">You are not telling us the whole story here; it looks as if you opened the input file as binary or are processing the lines such that you end up with <code>bytes</code> objects.</span>
<span class="comment-copy">@MartijnPieters: ok, the whole story is in another question :). Here is the link: <a href="http://stackoverflow.com/questions/18471829/logging-only-stderr-to-a-logfile-using-python-logger" title="logging only stderr to a logfile using python logger">stackoverflow.com/questions/18471829/â€¦</a></span>
<span class="comment-copy">with <code>wb</code> option, it complains, <code>TypeError: can't write str to binary stream</code></span>
<span class="comment-copy">@iamauser: What does <code>repr(line)</code> write to the file?</span>
<span class="comment-copy">Texts from stderr of a unix command.</span>
<span class="comment-copy">@iamauser: captured with <code>subprocess</code> or similiar? Then you get <code>bytes</code> binary data, not Unicode, and you'd have to write that as binary to a file.</span>
<span class="comment-copy">yes, from <code>subprocess</code> and using <code>logger</code> from python, I write to <code>.log</code> file. Sorry, but the <code>literal_eval()</code> isn't working for me.<code>File "/path/sw/python/3.0/lib/python3.0/ast.py", line 67, in _convert     raise ValueError('malformed string')</code></span>
<span class="comment-copy">Essentially, both my answer and Martijn's focus on the same thing: text vs. binary files.  Which approach to use depends on whether the source and the target files are (or, meant to be) text or binary.  Based on the <code>.log</code> suffix, I assumed they were both text files.</span>
<span class="comment-copy">yes they are. <code>wt</code> and <code>wb' from @Martijn answer don't work. </code>wt` and <code>rt</code> ends up in one line, same as before. May be I should try with <code>.txt</code> suffix.</span>
<span class="comment-copy">@iamauser, well, it works OK for me (on a Linux PC). If it's not working for you, maybe there's something you're not telling us.</span>
