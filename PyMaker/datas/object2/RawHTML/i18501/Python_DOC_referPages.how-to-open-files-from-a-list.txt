<div class="post-text" itemprop="text">
<p>I figured out how to go through a directory and look for a certain type of file and add them to a list. Now I have a list with the names of the files. How do I open all of them? Here is what I have so far:</p>
<pre><code>import os
import glob
import subprocess

os.chdir("/Users/blah/Desktop/Data")
reflist = glob.glob('*raw_ref.SDAT')
actlist = glob.glob('*raw_act.SDAT')

for i in reflist:
    os.popen("%r" %i)

for j in actlist:
    os.popen("%r" %j)
</code></pre>
<p>P.S. I'm on a Mac</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>ref_files = map(open, reflist)
</code></pre>
<p>Or, if you want finer control over the arguments to <code>open()</code>:</p>
<pre><code>ref_files = [open(filename, ...) for filename in reflist]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would recommend having as few files open simultaneously as possible.</p>
<pre><code>for file in reflist:
    with open(file) as f:
        pass # do stuff with f
    # when with block ends, f is closed

for file in actlist:
    with open(file) as f:
        pass # do stuff with f
    # when with block ends, f is closed
</code></pre>
<p>If you, for some reason, need all the files open simultaneously (which I find unlikely), then go with NPE's solution.</p>
<p>Keep in mind that when you don't use a context manager for file I/O (like <code>with</code> is used here) that you will need to manually close the files when you are done.</p>
</div>
<div class="post-text" itemprop="text">
<p>@Brian is right saying "I would recommend having as few files open simultaneously as possible." However this depends what you want to do. If you need several open files for reading, you can try this to make sure files are closed at the end:</p>
<pre><code># I don't know MAC path names.
filenames = ['/path/to/file', 'next/file', 'and/so/on']
# here the file descriptors are stored:
fds = []
try:
    for fn in filenames:
        # optional: forgive open errors and process the accessible files
        #try:
            fds.append(open(fn))
        #except IOError:
        #    pass

    # here you can read from files and do stuff, e.g. compare lines
    current_lines = [fd.readline() for fd in fds]
    # more code

finally:
    for fd in fds:
        fd.close()
</code></pre>
</div>
<span class="comment-copy"><code>popen()</code> is for spawning subprocesses, not reading files.  You may want to read through the <a href="http://docs.python.org/2/tutorial/inputoutput.html#reading-and-writing-files" rel="nofollow noreferrer">Python tutorial on file I/O</a>.</span>
<span class="comment-copy">Use <code>open()</code>, not <code>os.popen</code>.</span>
<span class="comment-copy">Also, what do you want to <i>do</i> with the files? Just opening them all and not keeping around a reference to the object you opened isn't going to be very useful (unless you're trying to test how many files you can leak before you get a <code>EMFILE</code> error or something weird like that). You need to store each opened file in a variable or a collection so you can use it.</span>
<span class="comment-copy">How do I execute ref_files if I implemented this?</span>
<span class="comment-copy">Good suggestion. If all you want to is iterate over each file in turn, you can make this even simpler with <a href="http://docs.python.org/3/library/fileinput.html#fileinput.input" rel="nofollow noreferrer"><code>fileinput</code></a>. Just <code>with fileinput.input(reflist) as f:</code>, then you can treat it as a single big text file, doing <code>for line in f:</code>. (And if you need to know which file you're on, etc., you can use the <code>filename</code>, etc. methods.)</span>
<span class="comment-copy">@abarnert IIRC - you'd need <code>with contextlib.closing(fileinput.input(reflist)) as f:</code> - and even then I'm not 100% sure if that does what one would expect it to...</span>
<span class="comment-copy">@JonClements: In 3.2+, <code>fileinput.input</code> returns a context manager. In earlier versions, you do need <code>closing</code>, but it does exactly what you'd expect it to. In particular, <code>fileinput</code> guarantees that at most one file is open at a time, and that calling <code>close</code> on it will close that file.</span>
<span class="comment-copy">@abarnert good to know... I wasn't sure if <code>fileinput</code> offered that guarantee (although no reason it shouldn't) - thanks ;)</span>
<span class="comment-copy">@abarnet good stuff. I can see this being really convenient when file size limits are imposed on log files, causing rollover. Just have to be careful to sort them by timestamp first. thanks</span>
