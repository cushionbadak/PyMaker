<div class="post-text" itemprop="text">
<p>Suppose I want to make an empty 3x4 2d array like such.</p>
<pre><code>x = [[0.0]*3]*4
</code></pre>
<p>However, using the above code, </p>
<pre><code>print x[0] is x[1]     # Output = True
</code></pre>
<p>Meaning,</p>
<pre><code>x[1][1] = 5.0
print x      # Output = [[0.0, 5.0, 0.0], 
             #           [0.0, 5.0, 0.0], 
             #           [0.0, 5.0, 0.0], 
             #           [0.0, 5.0, 0.0]]
</code></pre>
<p>To bypass creating this list with 4 identical references to the same list, I've been doing things like:</p>
<pre><code>y = [[0.0]*3, [0.0]*3, [0.0]*3, [0.0]*3]
</code></pre>
<p>Where</p>
<pre><code>print y[0] is y[1]     # Output = False
y[1][1] = 5.0
print y      # Output = [[0.0, 0.0, 0.0], 
             #           [0.0, 5.0, 0.0], 
             #           [0.0, 0.0, 0.0], 
             #           [0.0, 0.0, 0.0]]
</code></pre>
<p>Another approach would be to use list comprehension</p>
<pre><code>z = [[0.0]*3 for x in range(4)]
</code></pre>
<p>but, this still seems a little ugly.</p>
<p>Is there a way to make the array 'y' or 'z' where all the references are unique in an elegant format such as in 'x' using multiply on a list?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is in the official Python Programming FAQ, as <a href="http://docs.python.org/3.3/faq/programming.html#how-do-i-create-a-multidimensional-list" rel="nofollow">How do I create a multidimensional list?</a>.</p>
<p>The FAQ suggests three possibilities:</p>
<ol>
<li>Create a list of the desired length, then replace each element in a loop.</li>
<li>Use a list comprehension.</li>
<li>Use something like a numpy.array instead of a multidimensional list in the first place.</li>
</ol>
<p>I think most Python developers would suggest these in the exact opposite order as they're listed in the FAQ… but nobody would complain about any of them. So:</p>
<pre><code>a = np.zeros((3, 4))

a = [[0.0]*3 for _ in range(4)]

a = [None] * 4
for i, _ in enumerate(a):
    a[i] = [0.0]*3
</code></pre>
<hr/>
<p>If you find yourself doing this a lot (and not using numpy), you can always wrap it in a function. In fact, this is generally the best way to deal with <em>anything</em> that looks ugly even when you're doing it as pythonically as possible. So:</p>
<pre><code>def make_matrix(r, c):
    return [[0.0]*c for _ in range(r)]
</code></pre>
<p>And then it's about as clear as can be:</p>
<pre><code>a = make_matrix(3, 4)
</code></pre>
<hr/>
<p><code>itertools</code> has a function called <a href="http://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow"><code>repeat</code></a>, which is equivalent to the iterator version of <code>*</code>. The docs show some equivalent pure Python code, so it's pretty easy to adapt it to (shallow or deep) copy the object for each rep:</p>
<pre><code>def repeat(obj, times):
    for _ in range(times):
        yield copy.copy(obj)

list(repeat([0.0]*3, 4))
</code></pre>
<p>I don't think this is more readable—especially if you want to use it at multiple levels:</p>
<pre><code>list(repeat(list(repeat(0.0, 3)), 4))
</code></pre>
<p>… even if you wrap that in a function that listifies for you:</p>
<pre><code>def srepeat(object, times):
    return list(repeat(object, times))
srepeat(srepeat(0.0, 3), 4)
</code></pre>
<p>… and if you wrap it in a function that handles multiple dimensions, you've just re-created <code>make_matrix</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>List comprehensions are the usual answer. Not as clean as sequence multiplication, but the best that's available:</p>
<pre><code>[[0.0]*3 for _ in xrange(4)]
</code></pre>
<p>Note that for a lot of applications where you want a grid of values, you're doing something that <a href="http://www.numpy.org/" rel="nofollow">numpy</a> ndarrays could do faster and cleaner.</p>
</div>
<span class="comment-copy"><code>itertools.repeat</code> doesn't work like that. It'll do the same thing as the sequence multiplication code, except with an iterator instead of an outer list.</span>
<span class="comment-copy">@user2357112: You're right; you actually need a function that repeats copies… let me edit the answer. Thanks.</span>
