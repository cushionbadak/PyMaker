<div class="post-text" itemprop="text">
<p>For a project, I need a method of creating thousands of random strings while keeping collisions low. I'm looking for them to be only 12 characters long and uppercase only. Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>CODE:</strong></p>
<pre><code>from random import choice
from string import ascii_uppercase

print(''.join(choice(ascii_uppercase) for i in range(12)))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<p><em>5 examples:</em></p>
<pre><code>QPUPZVVHUNSN
EFJACZEBYQEB
QBQJJEEOYTZY
EOJUSUEAJEEK
QWRWLIWDTDBD
</code></pre>
<hr/>
<p><strong>EDIT:</strong></p>
<p>If you need only digits, use the <code>digits</code> constant instead of the <code>ascii_uppercase</code> one from the <code>string</code> module.</p>
<p><em>3 examples:</em></p>
<pre><code>229945986931
867348810313
618228923380
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By <code>Django</code>, you can use <code>get_random_string</code> function in <code>django.utils.crypto</code> module.</p>
<pre><code>get_random_string(length=12,
    allowed_chars=u'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')
    Returns a securely generated random string.

    The default length of 12 with the a-z, A-Z, 0-9 character set returns
    a 71-bit value. log_2((26+26+10)^12) =~ 71 bits
</code></pre>
<p>Example:</p>
<pre><code>get_random_string()
u'ngccjtxvvmr9'

get_random_string(4, allowed_chars='bqDE56')
u'DDD6'
</code></pre>
<p>But if you don't want to have <code>Django</code>, <a href="https://github.com/django/django/blob/0ed7d155635da9f79d4dd67e4889087d3673c6da/django/utils/crypto.py#L54" rel="noreferrer">here</a> is independent code of it:</p>
<p>Code:</p>
<pre><code>import random
import hashlib
import time

SECRET_KEY = 'PUT A RANDOM KEY WITH 50 CHARACTERS LENGTH HERE !!'

try:
    random = random.SystemRandom()
    using_sysrandom = True
except NotImplementedError:
    import warnings
    warnings.warn('A secure pseudo-random number generator is not available '
                  'on your system. Falling back to Mersenne Twister.')
    using_sysrandom = False


def get_random_string(length=12,
                      allowed_chars='abcdefghijklmnopqrstuvwxyz'
                                    'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):
    """
    Returns a securely generated random string.

    The default length of 12 with the a-z, A-Z, 0-9 character set returns
    a 71-bit value. log_2((26+26+10)^12) =~ 71 bits
    """
    if not using_sysrandom:
        # This is ugly, and a hack, but it makes things better than
        # the alternative of predictability. This re-seeds the PRNG
        # using a value that is hard for an attacker to predict, every
        # time a random string is required. This may change the
        # properties of the chosen random sequence slightly, but this
        # is better than absolute predictability.
        random.seed(
            hashlib.sha256(
                ("%s%s%s" % (
                    random.getstate(),
                    time.time(),
                    SECRET_KEY)).encode('utf-8')
            ).digest())
    return ''.join(random.choice(allowed_chars) for i in range(length))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Could make a generator:</p>
<pre><code>from string import ascii_uppercase
import random
from itertools import islice

def random_chars(size, chars=ascii_uppercase):
    selection = iter(lambda: random.choice(chars), object())
    while True:
        yield ''.join(islice(selection, size))

random_gen = random_chars(12)
print next(random_gen)
# LEQIITOSJZOQ
print next(random_gen)
# PXUYJTOTHWPJ
</code></pre>
<p>Then just pull from the generator when they're needed... Either using <code>next(random_gen)</code> when you need them, or use <code>random_200 = list(islice(random_gen, 200))</code> for instance...</p>
</div>
<div class="post-text" itemprop="text">
<p>This function generates random string of UPPERCASE letters with the specified length,</p>
<p><strong>eg:</strong> length = 6, will generate the following random sequence pattern</p>
<blockquote>
<p><strong><em>YLNYVQ</em></strong></p>
</blockquote>
<pre><code>    import random as r

    def generate_random_string(length):
        random_string = ''
        random_str_seq = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        for i in range(0,length):
            if i % length == 0 and i != 0:
                random_string += '-'
            random_string += str(random_str_seq[r.randint(0, len(random_str_seq) - 1)])
        return random_string
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For cryptographically strong pseudo-random bytes you might use the <a href="https://pypi.python.org/pypi/pyOpenSSL" rel="nofollow">pyOpenSSL</a> wrapper around OpenSSL.</p>
<p>It provides the <a href="http://pythonhosted.org/pyOpenSSL/openssl-rand.html" rel="nofollow"><code>bytes</code></a> function to gather a pseudo-random sequences of <em>bytes</em>.</p>
<pre><code>from OpenSSL import rand

b = rand.bytes(7)
</code></pre>
<p><sub>BTW, 12 uppercase letters is a little bit more that 56 bits of entropy. You will only to have to read 7 bytes.</sub></p>
</div>
<span class="comment-copy">You mean you don't want any lowercase digits?</span>
<span class="comment-copy">Hmm, yeah, that should be clarified :)</span>
<span class="comment-copy">Don't forget to read this page about <a href="http://docs.python.org/2/library/random.html" rel="nofollow noreferrer">the default random number generator in python</a>. The chance of collisions seems to be fully dependent on the size of the "random strings", but that does not mean that an attacker cannot re-create the random numbers; the random numbers generated are <i>not cryptographically secure</i>.</span>
<span class="comment-copy">Hah, right. I meant alphanumeric.</span>
<span class="comment-copy">yeah, well this is missleading: <i>"12 digits long and uppercase"</i> -- since digits can't be uppercased</span>
<span class="comment-copy">And if you need Alphanumeric i.e ASCII Uppercase plus digits then <code>import digits</code> <code>print(''.join(choice(ascii_uppercase + digits) for i in range(12)))</code></span>
<span class="comment-copy">Does this gives an unique Id each time? What if I call this function from multiple threads (e.g. 2 of them) for 10000 times? What is the probability of collision or getting the same id at given point of time?</span>
<span class="comment-copy">@AnilJ for further info on how the <code>random</code> module is working, please read the official documentation on it: <a href="https://docs.python.org/3/library/random.html" rel="nofollow noreferrer">docs.python.org/3/library/random.html</a></span>
<span class="comment-copy">Well, digits is not on Python3. You can use <code>string.hexdigits</code> to get a mix of '0123456789abcdefABCDEF', or just <code>string.digits + string.ascii_letters</code> for all letters.</span>
<span class="comment-copy">And the advantage of using a generator for this would be?</span>
<span class="comment-copy">@martineau can take one at a time, set up ones with different variables, can slice off to take n many at a time etc... The main difference is that it's in effect an iterable itself, instead of repeatedly calling a function...</span>
<span class="comment-copy">Why <i>wouldn't</i> you just repeatedly call a function?</span>
<span class="comment-copy"><code>functools.partial</code> can fix parameters, and <code>list(itertools.islice(gen, n))</code> isn't any better than <code>[func() for _ in xrange(n)]</code></span>
<span class="comment-copy">@user2357112 by building a generator, there's an advantage over resuming its state, than setting up and calling up a function repeatedly... Also the <code>list</code> and <code>islice</code> will work at the implementation level instead of as a list-comp that could leak its <code>_</code> (in Py 2.x) variable and has to build an unnecessary range constraint that's otherwise handled... Also, it's also harder to build on top of functions, rather than streams...</span>
<span class="comment-copy">With above code <code>random_str_seq = "ABC@#$%^!&amp;_+|*()OPQRSTUVWXYZ"</code> can give you even more complex results.</span>
<span class="comment-copy">Wouldn't 12 randomly selected uppercase letters correspond to ~56.4 bits worth of entropy?</span>
<span class="comment-copy">@DSM Yes of course. I don't know how I could find such a wrong result...</span>
<span class="comment-copy">rand.bytes is no more supported in the last versions of OpenSSL</span>
