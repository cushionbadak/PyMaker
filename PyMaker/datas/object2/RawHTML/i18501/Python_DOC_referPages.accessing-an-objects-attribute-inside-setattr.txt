<div class="post-text" itemprop="text">
<p>Python bit me today. I'm trying to access an object's attribute inside its <code>__setattr__</code> implementation - I can't figure out how. This is what I've tried so far:</p>
<pre><code>class Test1(object):
    def __init__(self):
        self.blub = 'hi1'

    def __setattr__(self, name, value):
        print self.blub

class Test2(object):
    def __init__(self):
        self.blub = 'hi2'

    def __setattr__(self, name, value):
        print object.__getattr__(self, 'blub')

class Test3(object):
    def __init__(self):
        self.blub = 'hi3'

    def __setattr__(self, name, value):
        print object.__getattribute__(self, 'blub')

class Test4(object):
    def __init__(self):
        self.blub = 'hi4'

    def __setattr__(self, name, value):
        print self.__getattr__('blub')

class Test5(object):
    def __init__(self):
        self.blub = 'hi5'

    def __setattr__(self, name, value):
        print self.__getattribute__('blub')

class Test6(object):
    def __init__(self):
        self.blub = 'hi6'

    def __setattr__(self, name, value):
        print self.__dict__['blub']
</code></pre>
<p>Testing: </p>
<pre><code>try:
    TestX().bip = 'bap'
except Exception as ex:
    print ex
</code></pre>
<p>with <code>X</code> from <code>1</code> to <code>6</code></p>
<p>Output:</p>
<pre><code>'Test1' object has no attribute 'blub'
type object 'object' has no attribute '__getattr__'
'Test3' object has no attribute 'blub'
'Test4' object has no attribute '__getattr__'
'Test5' object has no attribute 'blub'
'blub'
</code></pre>
<p>Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>OP, you haven't told us the whole story. You did not just run code like this:</p>
<pre><code>TestX().bip = 'bap'
</code></pre>
<p>You ran code like this:</p>
<pre><code>try:
    TestX().bip = 'bap'
except Exception as ex:
    print ex
</code></pre>
<p>There's a big difference. Why, you ask? Well, your output seems on first glance to indicate that <code>Test6</code> works, and several comments and answers assumed that it did. Why does it appear to work? Reading the code, there's <em>no way</em> it should work. A closer inspection of the source code reveals that if it <em>had</em> worked, it should have printed <code>hi6</code>, not <code>'blub'</code>.</p>
<p>I put a breakpoint at the <code>print ex</code> line in <code>pdb</code> to examine the exception:</p>
<pre><code>(Pdb) ex
KeyError('blub',)
(Pdb) print ex
'blub'
</code></pre>
<p>For some reason <code>print ex</code> does not print <code>KeyError: blub</code> like you'd expect, but just <code>'blub'</code>, which was why <code>Test6</code> appeared to work.</p>
<p>So we've cleared that up. In the future, please do not leave out code like this because it might be important.</p>
<p>All the other answers correctly point out that you have not set the attribute you're attempting to print, and that this is your problem. The answer you had accepted previously, before you accepted this answer istead, prescribed the following solution:</p>
<pre><code>def __setattr__(self, name, value):
    self.__dict__[name] = value
    print self.__dict__[name]
</code></pre>
<p>While this solution does indeed work, it is not good design. This is because you might want to change the base class at some point, and that base class might might have important side effects when setting and/or getting attributes, or it might not store the attributes in <code>self.__dict__</code> at all! It is better design to avoid messing around with <code>__dict__</code>.</p>
<p>The correct solution is to invoke the parent <code>__setattr__</code> method, and this was suggested by at least one other answer, though with the wrong syntax for python 2.x. Here's how I'd do it:</p>
<pre><code>def __setattr__(self, name, value):
    super(Test6, self).__setattr__(name, value)
    print getattr(self, name)
</code></pre>
<p>As you see I'm using <code>getattr</code> instead of <code>__dict__</code> to look up attributes dynamically. Unlike using <code>__dict__</code> directly, this will call <code>self.__getattr__</code> or <code>self.__getattribute__</code>, as appropriate.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because inside the <code>__init__</code> it is trying to set <code>blub</code> which calls <code>__setattr__</code>; and it does not set anything but tries to access (and print) <code>blub</code>, finds nothing and raises the error. Check this:</p>
<pre><code>&gt;&gt;&gt; class Test2(object):
  def __init__(self):
    print "__init__ called"
    self.blub = 'hi2'
    print "blub was set"

  def __setattr__(self, name, value):
    print "__setattr__ called"
    print self.blub


&gt;&gt;&gt; Test2()
__init__ called
__setattr__ called

Traceback (most recent call last):
  File "&lt;pyshell#10&gt;", line 1, in &lt;module&gt;
    Test2()
  File "&lt;pyshell#9&gt;", line 4, in __init__
    self.blub = 'hi2'
  File "&lt;pyshell#9&gt;", line 9, in __setattr__
    print self.blub
AttributeError: 'Test2' object has no attribute 'blub'
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>__setattr__</code> works on the class, so when you're over-riding - you <strong>need</strong> to make it actually set the attribute... otherwise, it'll never exist... eg:</p>
<pre><code>object.__setattr__(self, name, value)
</code></pre>
<p>So, in your <code>__init__</code>, when you do <code>self.blub = 'hi'</code> that's in effect a no-op.</p>
</div>
<div class="post-text" itemprop="text">
<p>You never actually set the attribute in your <code>__setattr__</code> so of course the object doesn't have it.</p>
<pre><code>def __setattr__(self, name, value):
    self.name = value
        # this doesn't work, since it calls itself (the __setattr__)

def __setattr__(self, name, value):
    super().__setattr__(name, value)
        # call the default implementation directly in Py 3.x

def __setattr__(self, name, value):
    super(TestX, self).__setattr__(name, value) # for Python 2.x
</code></pre>
<p>Of course doing this alone is good for nothing, you usually want to add some functionality oround this like some condition, debug printing, caching or whatever you need.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>print self.__dict__['blub']
</code></pre>
<p>Prints out <code>blub</code> which is correct. You have to set the new value first, because python won't do that for you, like that:</p>
<pre><code>def __setattr__(self, name, value):
    self.__dict__[name] = value
    print self.__dict__[name]
</code></pre>
<p>Then <code>test6.blub = 'test'</code> should print out <code>test</code></p>
<p><strong>Edit:</strong></p>
<p>As suggested by @Lauritz you can also use </p>
<pre><code>def __setattr__(self, name, value):
    super(Test6, self).__setattr__(name, value)
    print self.__dict__[name]
</code></pre>
<p>Which invokes the parent function, so if you superclass has already a <code>__setattr__</code> function it won't get overridden.</p>
</div>
<span class="comment-copy">Test6 worked as I saw?</span>
<span class="comment-copy">Out of curiosity, can you check your indentation on your original source-code because i noticed there was some inconsistencies in your space indentation (keep 4 spaces before each <code>def ...</code> after your class declaration.</span>
<span class="comment-copy">@TobSpr: From the admittedly twisted logic in this question it should have printed 'hi6'.</span>
<span class="comment-copy">@Torxed: Thanks for the edit.</span>
<span class="comment-copy">Thanks for all the effort. Yes you're right, I forgot to include the exception handling, I'm very sorry about that. Also, I'm glad about your explanation of the recommended solution. In fact I didn't use self.__dict__[name] = value in the <b>setattr</b> method, instead I set the attributes like this in <b>init</b>. Thinking about your post - I guess the same recommendation applies there, so I will try your solution with super().</span>
<span class="comment-copy">Makes sense of course. I was thinking about the wrong problem the whole time in relation to the actual implementation I wanted to do. Anyway, thanks.</span>
<span class="comment-copy">There's every indication that OP uses python 2.X, so <code>super()</code> <a href="http://docs.python.org/3/whatsnew/3.0.html#builtins" rel="nofollow noreferrer">will not work for him</a>, he needs to use <code>super(TestX, self)</code> instead.</span>
<span class="comment-copy">@LauritzV.Thaulow: You're right, edited.</span>
<span class="comment-copy"><code>print</code> doesn't have a return value, so it's not strictly true to say that it "returns" <code>blub</code>.</span>
<span class="comment-copy">Thanks I changed that</span>
<span class="comment-copy">I've got some problems with OP's question and this answer, but it's too long to detail in this comment, so I've made a separate <a href="http://stackoverflow.com/a/18205063/566644">answer</a>.</span>
<span class="comment-copy">I've updated the answer</span>
<span class="comment-copy">You're still using <code>__dict__</code>, which was what I had a problem with. In fact <code>super(Test6, self).__dict__</code> is always exactly the same dict object as <code>self.__dict__</code>, since <code>__dict__</code> is an attribute of the instance and not the class. My advice was invoking the parent <code>__setattr__</code> method instead.</span>
