<div class="post-text" itemprop="text">
<p>I have a Python socket server. In this socket server, when a new client connects and successfully authenticates themselves, it'll grab their json encoded information from the database. When it decodes it, it goes to a variable. Sometimes in the object, a key doesn't exist. I'll get a KeyError and the whole script will shut down. For example:</p>
<p>A client sends a packet to the server
The server handles it like this:</p>
<pre><code>def handleReceiveThisPacket(self, data):
    myInfo = self.info['exampleKey']
    return self.send(myInfo)
</code></pre>
<p>If "exampleKey" doesn't exist in the user's info (hey, it happens, like if I added a new key to the info for a new packet to handle something else and the user's info hasn't been updated yet), the whole script shuts down. I know I could easily do try, except but I often call keys throughout the script and I think it would look messy having a bunch of try and excepts everywhere, don't you think? Is there an easier way to just make it so Python gives off a warning about it but doesn't shut down, similar to how PHP does it?</p>
<p>Also, the client is a seperate class.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use exception handling; to catch the exceptions; they exist for the sole reason that the normal program would be simpler, without a need for constant error checking. Also to get an optional key from dictionary you can use the <code>get</code> method</p>
<pre><code>def handleReceiveThisPacket(self, data):
    # returns None if key not found
    myInfo = self.info.get('exampleKey')

    # returns 42 if key not found
    myInfo = self.info.get('exampleKey', 42)

    try:
        return self.send(myInfo)
    except Exception as e:
        print("Oops an exception occurred")
        print(e)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create your own <code>MyDict</code> class that wraps the <code>KeyError</code> and logs out warnings:</p>
<pre><code>import logging

log = logging.getLogger(__name__)

class MyDict(dict):
    def __getitem__(self, key):
        try:
            return super(MyDict, self).__getitem__(key)
        except KeyError:
            log.warning('Attempted to get value for missing key %s.', str(key))
            return None

In [33]: d = MyDict()

In [34]: d['test']
Attempted to get value for missing key test.
</code></pre>
<p>Or in short (just for default values):</p>
<pre><code>from collections import defaultdict

c = defaultdict(lambda: None)
c['test']

None
</code></pre>
<p>This example returns <code>None</code> as default value for missing keys, but you can customize it.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, the PHP language made many bad design decisions, this is just one of them. Be happy that python detects and handles these problems in a nice way. I personally always wrote PHP code that never created <em>any</em> warnings. Once you have warnings it's hard to distinguish what's acceptable and what's a real problem.</p>
<p>Second, you can handle the problem several ways:</p>
<ul>
<li>You can handle these exceptions in an upper layer (1 or 2, instead of a dozen)</li>
<li>You can use a <a href="http://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow">defaultdict</a>.</li>
<li>You can use a utility function.</li>
</ul>
<p>Example:</p>
<pre><code>def getkey(d, k):
  try:
    return d[k]
  except KeyError:
    return ""
</code></pre>
<p>Note that all these solution have the serious flaw that they make your code brittle. You won't detect all the possible typos you can make for the keys.</p>
<p>I think the most clear way would be to <em>fill</em> your data set with values for the missing keys, so you don't have to do <em>any</em> error handling.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may check if something is in a collection using the <code>in</code> operator:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; o = json.loads('{"a": 1}')
&gt;&gt;&gt; "a" in o
True
&gt;&gt;&gt; "b" in o
False

&gt;&gt;&gt; o = dict(a=1)
&gt;&gt;&gt; "a" in o
True
&gt;&gt;&gt; "b" in o
False

&gt;&gt;&gt; o = (1,2,3)
&gt;&gt;&gt; 1 in o
True
&gt;&gt;&gt; 4 in o
False
</code></pre>
<p>Also, <code>dict</code>s have a <a href="http://docs.python.org/2/library/stdtypes.html?highlight=dict%20get#dict.get" rel="nofollow"><code>.get(key, default=None)</code> method</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Catch the exception. <a href="http://docs.python.org/3/tutorial/errors.html#handling-exceptions" rel="nofollow">This</a> link explains exception handling in Python. Put a <code>try... except KeyError...</code> around the relevant code.</p>
<p>Alternatively, use the dictionary method get. <code>myInfo = self.info.get('exampleKey', default_value)</code> won't raise a KeyError, and will return <code>default_value</code> if 'exampleKey' isn't in myInfo.</p>
<p>A third option would be to check if the key is in the dictionary first: <code>if 'exampleKey' in self.info: myInfo = self.info['exampleKey']</code>.</p>
</div>
<span class="comment-copy">If you're worried about code cleanliness, why not make a <code>get_val(my_dict, my_key)</code> function that handles invalid keys with a try and except block in it so that you'll only need that code once?</span>
<span class="comment-copy">I actually never thought of that, thank you!</span>
<span class="comment-copy">Use <code>dict.get</code> instead of indexed access and PLEASE DO NOT CATCH <code>Exception</code>!</span>
<span class="comment-copy">The catching of Exception is to make sure that the <code>handleReceiveThisPacket</code> never crashes for any reason. Though generally catching all Exceptions is frowned upon, in this case it is a bit more acceptable.</span>
<span class="comment-copy">Though that's what the OP asked for, I don't think it's a good idea.. and I mention in my answer why.</span>
<span class="comment-copy">Yes, unless you provide sane defaults in the <code>info</code> dict. But it strongly depends on what the author is doing with the data later on, as it won't distinguish between <code>missed key, we can deal with it</code> and <code>missed key, something is going to blow up now</code> situations. The author's code should explicitly allow for certain keys' absence so that true unexpected situations are detected.</span>
<span class="comment-copy">The largest problem with ensuring that every key is present in every data value is that you could have data migration problems when new fields are added, then the entire data set requires updating (consider updating Mongo collections).  This can be expensive and also change modification timestamps when the object hasn't really changed.  As for the typos, that is what unit testing is for.</span>
<span class="comment-copy">@D.Shawley: 1) Oh, I meant filling the values in the <i>application</i> - that's how you do data migrations anyway... first you handle the missing keys in the app, then, if necessary, you update later the collection. 2) as for unit testing... yeah, sure, it will catch this, but then you could reason about a lot of other things in a similar way. if the language can help you detect problems, why would you throw that feature away?</span>
