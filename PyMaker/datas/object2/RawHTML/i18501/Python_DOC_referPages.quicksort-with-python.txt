<div class="post-text" itemprop="text">
<p>I am totally new to python and I am trying to implement quicksort in it.
Could someone please help me complete my code?</p>
<p>I do not know how to concatenate the three arrays and printing them. </p>
<pre><code>def sort(array=[12,4,5,6,7,3,1,15]):
    less = []
    equal = []
    greater = []

    if len(array) &gt; 1:
        pivot = array[0]
        for x in array:
            if x &lt; pivot:
                less.append(x)
            if x == pivot:
                equal.append(x)
            if x &gt; pivot:
                greater.append(x)
            sort(less)
            sort(pivot)
            sort(greater)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def sort(array=[12,4,5,6,7,3,1,15]):
    less = []
    equal = []
    greater = []

    if len(array) &gt; 1:
        pivot = array[0]
        for x in array:
            if x &lt; pivot:
                less.append(x)
            elif x == pivot:
                equal.append(x)
            else x &gt; pivot:
                greater.append(x)
        # Don't forget to return something!
        return sort(less)+equal+sort(greater)  # Just use the + operator to join lists
    # Note that you want equal ^^^^^ not pivot
    else:  # You need to hande the part at the end of the recursion - when you only have one element in your array, just return the array.
        return array
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Quick sort without additional memory (in place)</p>
<p>Usage:
</p>
<pre><code>array = [97, 200, 100, 101, 211, 107]
quicksort(array)
# array -&gt; [97, 100, 101, 107, 200, 211]
</code></pre>
<pre class="lang-py prettyprint-override"><code>def partition(array, begin, end):
    pivot = begin
    for i in xrange(begin+1, end+1):
        if array[i] &lt;= array[begin]:
            pivot += 1
            array[i], array[pivot] = array[pivot], array[i]
    array[pivot], array[begin] = array[begin], array[pivot]
    return pivot



def quicksort(array, begin=0, end=None):
    if end is None:
        end = len(array) - 1
    def _quicksort(array, begin, end):
        if begin &gt;= end:
            return
        pivot = partition(array, begin, end)
        _quicksort(array, begin, pivot-1)
        _quicksort(array, pivot+1, end)
    return _quicksort(array, begin, end)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is another concise and beautiful version</p>
<pre><code>def qsort(arr): 
    if len(arr) &lt;= 1:
        return arr
    else:
        return qsort([x for x in arr[1:] if x &lt; arr[0]]) + \
               [arr[0]] + \
               qsort([x for x in arr[1:] if x &gt;= arr[0]])

# this comment is just to improve readability due to horizontal scroll!!!
</code></pre>
<p>Let me explain the above codes for details</p>
<ol>
<li><p>pick the first element of array <code>arr[0]</code> as pivot</p>
<p><code>[arr[0]]</code></p></li>
<li><p><code>qsort</code> those elements of array which are less than pivot with <a href="http://www.secnetix.de/olli/Python/list_comprehensions.hawk" rel="nofollow noreferrer"><code>List Comprehension</code></a></p>
<p><code>qsort([x for x in arr[1:] if x &lt; arr[0]])</code></p></li>
<li><p><code>qsort</code> those elements of array which are larger than pivot with <code>List Comprehension</code></p>
<p><code>qsort([x for x in arr[1:] if x &gt;= arr[0]])</code></p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If I search "python quicksort implementation" in Google, this question is the first result to pop up. I understand that the initial question was to "help correct the code" but there already are many answers that disregard that request: the currently <a href="https://stackoverflow.com/a/20258416/1269892">second most voted one</a>, the horrendous <a href="https://stackoverflow.com/a/22813087/1269892">one-liner</a> with the hilarious "You are fired" comment and, in general, many implementations that are not in-place (i.e. use extra memory proportional to input list size). <a href="https://stackoverflow.com/a/27461889/1269892">This answer</a> provides an in-place solution but it is for <code>python 2.x</code>. So, below follows my interpretation of the in-place solution from <a href="http://rosettacode.org/wiki/Sorting_algorithms/Quicksort#Python" rel="noreferrer">Rosetta Code</a> which will work just fine for <code>python 3</code> too:</p>
<pre><code>import random

def qsort(l, fst, lst):
    if fst &gt;= lst: return

    i, j = fst, lst
    pivot = l[random.randint(fst, lst)]

    while i &lt;= j:
        while l[i] &lt; pivot: i += 1
        while l[j] &gt; pivot: j -= 1
        if i &lt;= j:
            l[i], l[j] = l[j], l[i]
            i, j = i + 1, j - 1
    qsort(l, fst, j)
    qsort(l, i, lst)
</code></pre>
<p>And if you are willing to forgo the in-place property, below is yet another version which better illustrates the basic ideas behind quicksort. Apart from readability, its other advantage is that it is <em>stable</em> (equal elements appear in the sorted list in the same order that they used to have in the unsorted list). This stability property does not hold with the less memory-hungry in-place implementation presented above.</p>
<pre><code>def qsort(l):
    if not l: return l # empty sequence case
    pivot = l[random.choice(range(0, len(l)))]

    head = qsort([elem for elem in l if elem &lt; pivot])
    tail = qsort([elem for elem in l if elem &gt; pivot])
    return head + [elem for elem in l if elem == pivot] + tail
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are many answers to this already, but I think this approach is the most clean implementation:</p>
<pre><code>def quicksort(arr):
    """ Quicksort a list

    :type arr: list
    :param arr: List to sort
    :returns: list -- Sorted list
    """
    if not arr:
        return []

    pivots = [x for x in arr if x == arr[0]]
    lesser = quicksort([x for x in arr if x &lt; arr[0]])
    greater = quicksort([x for x in arr if x &gt; arr[0]])

    return lesser + pivots + greater
</code></pre>
<p>You can of course skip storing everything in variables and return them straight away like this:</p>
<pre><code>def quicksort(arr):
    """ Quicksort a list

    :type arr: list
    :param arr: List to sort
    :returns: list -- Sorted list
    """
    if not arr:
        return []

    return quicksort([x for x in arr if x &lt; arr[0]]) \
        + [x for x in arr if x == arr[0]] \
        + quicksort([x for x in arr if x &gt; arr[0]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>Quicksort with Python</h1>
</blockquote>
<p>In real life, we should always use the builtin sort provided by Python. However, understanding the <a href="https://en.wikipedia.org/wiki/Quicksort" rel="noreferrer">quicksort</a> algorithm is instructive. </p>
<p>My goal here is to break down the subject such that it is easily understood and replicable by the reader without having to return to reference materials.</p>
<p>The quicksort algorithm is essentially the following:</p>
<ol>
<li>Select a pivot data point.</li>
<li>Move all data points less than (below) the pivot to a position below the pivot - move those greater than or equal to (above) the pivot to a position above it.</li>
<li>Apply the algorithm to the areas above and below the pivot</li>
</ol>
<p>If the data are randomly distributed, selecting the first data point as the pivot is equivalent to a random selection.</p>
<h2>Readable example:</h2>
<p>First, let's look at a readable example that uses comments and variable names to point to intermediate values:</p>
<pre><code>def quicksort(xs):
    """Given indexable and slicable iterable, return a sorted list"""
    if xs: # if given list (or tuple) with one ordered item or more: 
        pivot = xs[0]
        # below will be less than:
        below = [i for i in xs[1:] if i &lt; pivot] 
        # above will be greater than or equal to:
        above = [i for i in xs[1:] if i &gt;= pivot]
        return quicksort(below) + [pivot] + quicksort(above)
    else: 
        return xs # empty list
</code></pre>
<p>To restate the algorithm and code demonstrated here - we move values above the pivot to the right, and values below the pivot to the left, and then pass those partitions to same function to be further sorted.</p>
<h2>Golfed:</h2>
<p>This can be golfed to 88 characters:</p>
<pre><code>q=lambda x:x and q([i for i in x[1:]if i&lt;=x[0]])+[x[0]]+q([i for i in x[1:]if i&gt;x[0]])
</code></pre>
<p>To see how we get there, first take our readable example, remove comments and docstrings, and find the pivot in-place:</p>
<pre><code>def quicksort(xs):
    if xs: 
        below = [i for i in xs[1:] if i &lt; xs[0]] 
        above = [i for i in xs[1:] if i &gt;= xs[0]]
        return quicksort(below) + [xs[0]] + quicksort(above)
    else: 
        return xs
</code></pre>
<p>Now find below and above, in-place:</p>
<pre><code>def quicksort(xs):
    if xs: 
        return (quicksort([i for i in xs[1:] if i &lt; xs[0]] )
                + [xs[0]] 
                + quicksort([i for i in xs[1:] if i &gt;= xs[0]]))
    else: 
        return xs
</code></pre>
<p>Now, knowing that <code>and</code> returns the prior element if false, else if it is true, it evaluates and returns the following element, we have:</p>
<pre><code>def quicksort(xs):
    return xs and (quicksort([i for i in xs[1:] if i &lt; xs[0]] )
                   + [xs[0]] 
                   + quicksort([i for i in xs[1:] if i &gt;= xs[0]]))
</code></pre>
<p>Since lambdas return a single epression, and we have simplified to a single expression (even though it is getting more unreadable) we can now use a lambda:</p>
<pre><code>quicksort = lambda xs: (quicksort([i for i in xs[1:] if i &lt; xs[0]] )
                        + [xs[0]] 
                        + quicksort([i for i in xs[1:] if i &gt;= xs[0]]))
</code></pre>
<p>And to reduce to our example, shorten the function and variable names to one letter, and eliminate the whitespace that isn't required.</p>
<pre><code>q=lambda x:x and q([i for i in x[1:]if i&lt;=x[0]])+[x[0]]+q([i for i in x[1:]if i&gt;x[0]])
</code></pre>
<p>Note that this lambda, like most code golfing, is rather bad style.</p>
<h2>In-place Quicksort, using the Hoare Partitioning scheme</h2>
<p>The prior implementation creates a lot of unnecessary extra lists. If we can do this in-place, we'll avoid wasting space.</p>
<p>The below implementation uses the Hoare partitioning scheme, which you can <a href="https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme" rel="noreferrer">read more about on wikipedia</a> (but we have apparently removed up to 4 redundant calculations per <code>partition()</code> call by using while-loop semantics instead of do-while and moving the narrowing steps to the end of the outer while loop.).</p>
<pre><code>def quicksort(a_list):
    """Hoare partition scheme, see https://en.wikipedia.org/wiki/Quicksort"""
    def _quicksort(a_list, low, high):
        # must run partition on sections with 2 elements or more
        if low &lt; high: 
            p = partition(a_list, low, high)
            _quicksort(a_list, low, p)
            _quicksort(a_list, p+1, high)
    def partition(a_list, low, high):
        pivot = a_list[low]
        while True:
            while a_list[low] &lt; pivot:
                low += 1
            while a_list[high] &gt; pivot:
                high -= 1
            if low &gt;= high:
                return high
            a_list[low], a_list[high] = a_list[high], a_list[low]
            low += 1
            high -= 1
    _quicksort(a_list, 0, len(a_list)-1)
    return a_list
</code></pre>
<p>Not sure if I tested it thoroughly enough:</p>
<pre><code>def main():
    assert quicksort([1]) == [1]
    assert quicksort([1,2]) == [1,2]
    assert quicksort([1,2,3]) == [1,2,3]
    assert quicksort([1,2,3,4]) == [1,2,3,4]
    assert quicksort([2,1,3,4]) == [1,2,3,4]
    assert quicksort([1,3,2,4]) == [1,2,3,4]
    assert quicksort([1,2,4,3]) == [1,2,3,4]
    assert quicksort([2,1,1,1]) == [1,1,1,2]
    assert quicksort([1,2,1,1]) == [1,1,1,2]
    assert quicksort([1,1,2,1]) == [1,1,1,2]
    assert quicksort([1,1,1,2]) == [1,1,1,2]
</code></pre>
<h2>Conclusion</h2>
<p>This algorithm is frequently taught in computer science courses and asked for on job interviews. It helps us think about recursion and divide-and-conquer. </p>
<p>Quicksort is not very practical in Python since our builtin <a href="https://en.wikipedia.org/wiki/Timsort" rel="noreferrer">timsort</a> algorithm is quite efficient, and we have recursion limits. We would expect to sort lists in-place with <a href="https://docs.python.org/3/library/stdtypes.html#list.sort" rel="noreferrer"><code>list.sort</code></a> or create new sorted lists with <a href="https://docs.python.org/library/functions.html#sorted" rel="noreferrer"><code>sorted</code></a> - both of which take a <code>key</code> and <code>reverse</code> argument. </p>
</div>
<div class="post-text" itemprop="text">
<p>functional approach:</p>
<pre><code>def qsort(list):
    if len(list) &lt; 2:
        return list

    pivot = list.pop()
    left = filter(lambda x: x &lt;= pivot, list)
    right = filter(lambda x: x &gt; pivot, list)

    return qsort(left) + [pivot] + qsort(right)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>functional programming aproach</p>
<pre><code>smaller = lambda xs, y: filter(lambda x: x &lt;= y, xs)
larger = lambda xs, y: filter(lambda x: x &gt; y, xs)
qsort = lambda xs: qsort(smaller(xs[1:],xs[0])) + [xs[0]] + qsort(larger(xs[1:],xs[0])) if xs != [] else []

print qsort([3,1,4,2,5]) == [1,2,3,4,5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think both answers here works ok for the list provided (which answer the original question), but would breaks if an array containing non unique values is passed. So for completeness, I would just point out the small error in each and explain how to fix them.</p>
<p>For example trying to sort the following array  [12,4,5,6,7,3,1,15,1] (Note that 1 appears twice) with <a href="https://stackoverflow.com/users/1460057/brionius">Brionius</a> algorithm .. at some point will end up with the <strong>less</strong> array empty and the <strong>equal</strong> array with a pair of values (1,1) that can not be separated in the next iteration and the <strong>len() &gt; 1</strong>...hence you'll end up with an infinite loop</p>
<p>You can fix it by either returning array if <em>less</em> is empty or better by <strong>not</strong> calling sort in your equal array, as in <a href="https://stackoverflow.com/users/3011380/zangw">zangw</a> answer </p>
<pre><code>def sort(array=[12,4,5,6,7,3,1,15]):
    less = []
    equal = []
    greater = []

    if len(array) &gt; 1:
        pivot = array[0]
        for x in array:
            if x &lt; pivot:
                less.append(x)
            if x == pivot:
                equal.append(x)
            if x &gt; pivot:
                greater.append(x)

        # Don't forget to return something!
        return sort(less)+ equal +sort(greater)  # Just use the + operator to join lists
    # Note that you want equal ^^^^^ not pivot
    else:  # You need to hande the part at the end of the recursion - when you only have one element in your array, just return the array.
        return array
</code></pre>
<p>The fancier solution also breaks, but for a different cause, it is missing the <strong>return</strong> clause in the recursion line, which will cause at some point to return None and try to append it to a list ....</p>
<p>To fix it just add a return to that line</p>
<pre><code>def qsort(arr): 
   if len(arr) &lt;= 1:
      return arr
   else:
      return qsort([x for x in arr[1:] if x&lt;arr[0]]) + [arr[0]] + qsort([x for x in arr[1:] if x&gt;=arr[0]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><b>Partition</b> - Split an array by a pivot that smaller elements move to the left and greater elemets move to the right or vice versa. A pivot can be an random element from an array. To make this algorith we need to know what is begin and end index of an array and where is a pivot. Then set two auxiliary pointers L, R.</p>
<p>So we have an array user[...,begin,...,end,...]</p>
<p>The start position of L and R pointers<br/>
[...,begin,next,...,end,...]<br/>
     R       L</p>
<p>while L &lt; end<br/>
  1. If a user[pivot] &gt; user[L] then move R by one and swap user[R] with user[L]<br/>
  2. move L by one</p>
<p>After while swap user[R] with user[pivot]</p>
<p><b>Quick sort</b> - Use the partition algorithm until every next part of the split by a pivot will have begin index greater or equals than end index.</p>
<pre><code>def qsort(user, begin, end):

    if begin &gt;= end:
        return

    # partition
    # pivot = begin
    L = begin+1
    R = begin
    while L &lt; end:
        if user[begin] &gt; user[L]:
            R+=1
            user[R], user[L] = user[L], user[R]
        L+= 1
    user[R], user[begin] = user[begin], user[R]

    qsort(user, 0, R)
    qsort(user, R+1, end)

tests = [
    {'sample':[1],'answer':[1]},
    {'sample':[3,9],'answer':[3,9]},
    {'sample':[1,8,1],'answer':[1,1,8]},
    {'sample':[7,5,5,1],'answer':[1,5,5,7]},
    {'sample':[4,10,5,9,3],'answer':[3,4,5,9,10]},
    {'sample':[6,6,3,8,7,7],'answer':[3,6,6,7,7,8]},
    {'sample':[3,6,7,2,4,5,4],'answer':[2,3,4,4,5,6,7]},
    {'sample':[1,5,6,1,9,0,7,4],'answer':[0,1,1,4,5,6,7,9]},
    {'sample':[0,9,5,2,2,5,8,3,8],'answer':[0,2,2,3,5,5,8,8,9]},
    {'sample':[2,5,3,3,2,0,9,0,0,7],'answer':[0,0,0,2,2,3,3,5,7,9]}
]

for test in tests:

    sample = test['sample'][:]
    answer = test['answer']

    qsort(sample,0,len(sample))

    print(sample == answer)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or if you prefer a one-liner that also illustrates the Python equivalent of C/C++ varags, lambda expressions, and if expressions:</p>
<pre><code>qsort = lambda x=None, *xs: [] if x is None else qsort(*[a for a in xs if a&lt;x]) + [x] + qsort(*[a for a in xs if a&gt;=x])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def quick_sort(array):
    return quick_sort([x for x in array[1:] if x &lt; array[0]]) + [array[0]] \
        + quick_sort([x for x in array[1:] if x &gt;= array[0]]) if array else []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def Partition(A,p,q):
    i=p
    x=A[i]
    for j in range(p+1,q+1):
        if A[j]&lt;=x:
            i=i+1
            tmp=A[j]
            A[j]=A[i]
            A[i]=tmp
    l=A[p]
    A[p]=A[i]
    A[i]=l
    return i

def quickSort(A,p,q):
    if p&lt;q:
        r=Partition(A,p,q)
        quickSort(A,p,r-1)
        quickSort(A,r+1,q)
    return A
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A "true" in-place implementation [Algorithms 8.9, 8.11 from the Algorithm Design and Applications Book by Michael T. Goodrich and Roberto Tamassia]:</p>
<pre><code>from random import randint

def partition (A, a, b):
    p = randint(a,b)
    # or mid point
    # p = (a + b) / 2

    piv = A[p]

    # swap the pivot with the end of the array
    A[p] = A[b]
    A[b] = piv

    i = a     # left index (right movement -&gt;)
    j = b - 1 # right index (left movement &lt;-)

    while i &lt;= j:
        # move right if smaller/eq than/to piv
        while A[i] &lt;= piv and i &lt;= j:
            i += 1
        # move left if greater/eq than/to piv
        while A[j] &gt;= piv and j &gt;= i:
            j -= 1

        # indices stopped moving:
        if i &lt; j:
            # swap
            t = A[i]
            A[i] = A[j]
            A[j] = t
    # place pivot back in the right place
    # all values &lt; pivot are to its left and 
    # all values &gt; pivot are to its right
    A[b] = A[i]
    A[i] = piv

    return i

def IpQuickSort (A, a, b):

    while a &lt; b:
        p = partition(A, a, b) # p is pivot's location

        #sort the smaller partition
        if p - a &lt; b - p:
            IpQuickSort(A,a,p-1)
            a = p + 1 # partition less than p is sorted
        else:
            IpQuickSort(A,p+1,b)
            b = p - 1 # partition greater than p is sorted


def main():
    A =  [12,3,5,4,7,3,1,3]
    print A
    IpQuickSort(A,0,len(A)-1)
    print A

if __name__ == "__main__": main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The algorithm has 4 simple steps:</p>
<ol>
<li>Divide the array into 3 different parts: left, pivot and right, where pivot will have only one element. Let us choose this pivot element as the first element of array</li>
<li>Append elements to the respective part by comparing them to pivot element. (explanation in comments)</li>
<li>Recurse this algorithm till all elements in the array have been sorted</li>
<li>Finally, join left+pivot+right parts</li>
</ol>
<p>Code for the algorithm in python:</p>
<pre><code>def my_sort(A):

      p=A[0]                                       #determine pivot element. 
      left=[]                                      #create left array
      right=[]                                     #create right array
      for i in range(1,len(A)):
        #if cur elem is less than pivot, add elem in left array
        if A[i]&lt; p:
          left.append(A[i])         
          #the recurssion will occur only if the left array is atleast half the size of original array
          if len(left)&gt;1 and len(left)&gt;=len(A)//2:          
              left=my_sort(left)                            #recursive call
        elif A[i]&gt;p: 
          right.append(A[i])                                #if elem is greater than pivot, append it to right array
          if len(right)&gt;1 and len(right)&gt;=len(A)//2:        # recurssion will occur only if length of right array is atleast the size of original array
              right=my_sort(right)
     A=left+[p]+right                                        #append all three part of the array into one and return it
     return A

my_sort([12,4,5,6,7,3,1,15])
</code></pre>
<p>Carry on with this algorithm recursively with the left and right parts.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another quicksort implementation:</p>
<pre><code># A = Array 
# s = start index
# e = end index
# p = pivot index
# g = greater than pivot boundary index

def swap(A,i1,i2):
  A[i1], A[i2] = A[i2], A[i1]

def partition(A,g,p):
    # O(n) - just one for loop that visits each element once
    for j in range(g,p):
      if A[j] &lt;= A[p]:
        swap(A,j,g)
        g += 1

    swap(A,p,g)
    return g

def _quicksort(A,s,e):
    # Base case - we are sorting an array of size 1
    if s &gt;= e:
      return

    # Partition current array
    p = partition(A,s,e)
    _quicksort(A,s,p-1) # Left side of pivot
    _quicksort(A,p+1,e) # Right side of pivot

# Wrapper function for the recursive one
def quicksort(A):
    _quicksort(A,0,len(A)-1)

A = [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,-1]

print(A)
quicksort(A)
print(A)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>For Version Python 3.x</strong>: a functional-style using <code>operator</code> module, primarily to improve readability. </p>
<pre><code>from operator import ge as greater, lt as lesser

def qsort(L): 
    if len(L) &lt;= 1: return L
    pivot   = L[0]
    sublist = lambda op: [*filter(lambda num: op(num, pivot), L[1:])]

    return qsort(sublist(lesser))+ [pivot] + qsort(sublist(greater))
</code></pre>
<p>and is tested as        </p>
<pre><code>print (qsort([3,1,4,2,5]) == [1,2,3,4,5])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def quick_sort(self, nums):
    def helper(arr):
        if len(arr) &lt;= 1: return arr
        #lwall is the index of the first element euqal to pivot
        #rwall is the index of the first element greater than pivot
        #so arr[lwall:rwall] is exactly the middle part equal to pivot after one round
        lwall, rwall, pivot = 0, 0, 0
        #choose rightmost as pivot
        pivot = arr[-1]
        for i, e in enumerate(arr):
            if e &lt; pivot:
                #when element is less than pivot, shift the whole middle part to the right by 1
                arr[i], arr[lwall] = arr[lwall], arr[i]
                lwall += 1
                arr[i], arr[rwall] = arr[rwall], arr[i]
                rwall += 1
            elif e == pivot:
                #when element equals to pivot, middle part should increase by 1
                arr[i], arr[rwall] = arr[rwall], arr[i]
                rwall += 1
            elif e &gt; pivot: continue
        return helper(arr[:lwall]) + arr[lwall:rwall] + helper(arr[rwall:])
    return helper(nums)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a version of the quicksort using Hoare partition scheme and with fewer swaps and local variables</p>
<pre><code>def quicksort(array):
    qsort(array, 0, len(array)-1)

def qsort(A, lo, hi):
    if lo &lt; hi:
        p = partition(A, lo, hi)
        qsort(A, lo, p)
        qsort(A, p + 1, hi)

def partition(A, lo, hi):
    pivot = A[lo]
    i, j = lo-1, hi+1
    while True:
      i += 1
      j -= 1
      while(A[i] &lt; pivot): i+= 1
      while(A[j] &gt; pivot ): j-= 1

      if i &gt;= j: 
          return j

      A[i], A[j] = A[j], A[i]


test = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]
print quicksort(test)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I know many people have answered this question correctly and I enjoyed reading them. My answer is almost the same as zangw but I think the previous contributors did not do a good job of explaining visually how things actually work...so here is my attempt to help others that might visit this question/answers in the future about a simple solution for quicksort implementation.</p>
<p>How does it work ?</p>
<ol>
<li>We basically select the first item as our pivot from our list and then we create two sub lists.</li>
<li>Our first sublist contains the items that are less than pivot </li>
<li>Our second sublist contains our items that are great than or equal to pivot</li>
<li>We then quick sort each of those and we combine them the first group +  pivot + the second group to get the final result.</li>
</ol>
<p>Here is an example along with visual to go with it ...
(pivot)9,11,2,0</p>
<p>average: n log of n </p>
<p>worse case: n^2 </p>
<p><a href="https://i.stack.imgur.com/4otrp.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/4otrp.png"/></a></p>
<p>The code:</p>
<pre><code>def quicksort(data):
if (len(data) &lt; 2):
    return data
else:
    pivot = data[0]  # pivot
    #starting from element 1 to the end
    rest = data[1:]
    low = [each for each in rest if each &lt; pivot]
    high = [each for each in rest if each &gt;= pivot]
    return quicksort(low) + [pivot] + quicksort(high)
</code></pre>
<p>items=[9,11,2,0]
print(quicksort(items))</p>
</div>
<div class="post-text" itemprop="text">
<p>The algorithm contains two boundaries, one having elements less than the pivot  (tracked by index "j") and the other having elements greater than the pivot (tracked by index "i"). </p>
<p>In each iteration, a new element is processed by incrementing j.</p>
<p>Invariant:- </p>
<ol>
<li>all elements between pivot and i are less than the pivot, and </li>
<li>all elements between i and j are greater than the pivot.</li>
</ol>
<p>If the invariant is violated, ith and jth elements are swapped, and i 
is incremented. </p>
<p>After all elements have been processed, and everything after the pivot 
has been partitioned, the pivot element is swapped with the last element 
smaller than it.</p>
<p>The pivot element will now be in its correct place in the sequence. The 
elements before it will be less than it and the ones after it will be 
greater than it, and they will be unsorted.</p>
<pre><code>def quicksort(sequence, low, high):
    if low &lt; high:    
        pivot = partition(sequence, low, high)
        quicksort(sequence, low, pivot - 1)
        quicksort(sequence, pivot + 1, high)

def partition(sequence, low, high):
    pivot = sequence[low]
    i = low + 1
    for j in range(low + 1, high + 1):
        if sequence[j] &lt; pivot:
            sequence[j], sequence[i] = sequence[i], sequence[j]
            i += 1
    sequence[i-1], sequence[low] = sequence[low], sequence[i-1]
    return i - 1

def main(sequence):
    quicksort(sequence, 0, len(sequence) - 1)
    return sequence

if __name__ == '__main__':
    sequence = [-2, 0, 32, 1, 56, 99, -4]
    print(main(sequence))
</code></pre>
<h2>Selecting a pivot</h2>
<p>A "good" pivot will result in two sub-sequences of roughly the same 
size. Deterministically, a pivot element can either be selected in a 
naive manner or by computing the median of the sequence.</p>
<p>A naive implementation of selecting a pivot will be the first or last 
element. The worst-case runtime in this case will be when the input 
sequence is already sorted or reverse sorted, as one of the subsequences 
will be empty which will cause only one element to be removed per 
recursive call.</p>
<p>A perfectly balanced split is achieved when the pivot is the median
element of the sequence. There are an equal number of elements greater 
than it and less than it. This approach guarantees a better overall 
running time, but is much more time-consuming.</p>
<p>A non-deterministic/random way of selecting the pivot would be to pick 
an element uniformly at random. This is a simple and lightweight 
approach that will minimize worst-case scenario and also lead to a 
roughly balanced split. This will also provide a balance between the naive approach and the median approach of selecting the pivot.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>First we declare the first value in the array to be the
pivot_value and we also set the left and right marks</li>
<li>We create the first while loop, this while loop is there to tell
the partition process to run again if it doesn't satisfy the
necessary condition</li>
<li>then we apply the partition process</li>
<li>after both partition processes have ran, we check to see if it
satisfies the proper condition. If it does, we mark it as done,
if not we switch the left and right values and apply it again</li>
<li>Once its done switch the left and right values and return the
split_point</li>
</ol>
<p>I am attaching the code below! This quicksort is a great learning tool because of the <em>Location of the pivot value</em>. Since it is in a constant place, you can walk through it multiple times and really get a hang of how it all works. In practice it is best to randomize the pivot to avoid O(N^2) runtime.</p>
<pre><code>def quicksort10(alist):
    quicksort_helper10(alist, 0, len(alist)-1)

def quicksort_helper10(alist, first, last):
    """  """
    if first &lt; last:
        split_point = partition10(alist, first, last)
        quicksort_helper10(alist, first, split_point - 1)
        quicksort_helper10(alist, split_point + 1, last)

def partition10(alist, first, last):
    done = False
    pivot_value = alist[first]
    leftmark = first + 1
    rightmark = last
    while not done:
        while leftmark &lt;= rightmark and alist[leftmark] &lt;= pivot_value:
            leftmark = leftmark + 1
        while leftmark &lt;= rightmark and alist[rightmark] &gt;= pivot_value:
            rightmark = rightmark - 1

        if leftmark &gt; rightmark:
            done = True
        else:
            temp = alist[leftmark]
            alist[leftmark] = alist[rightmark]
            alist[rightmark] = temp
    temp = alist[first]
    alist[first] = alist[rightmark]
    alist[rightmark] = temp
    return rightmark
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def quick_sort(l):
    if len(l) == 0:
        return l
    pivot = l[0]
    pivots = [x for x in l if x == pivot]
    smaller = quick_sort([x for x in l if x &lt; pivot])
    larger = quick_sort([x for x in l if x &gt; pivot])
    return smaller + pivots + larger
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Full example with printed variables at partition step:</p>
<pre><code>def partition(data, p, right):
    print("\n==&gt; Enter partition: p={}, right={}".format(p, right))
    pivot = data[right]
    print("pivot = data[{}] = {}".format(right, pivot))

    i = p - 1  # this is a dangerous line

    for j in range(p, right):
        print("j: {}".format(j))
        if data[j] &lt;= pivot:
            i = i + 1
            print("new i: {}".format(i))
            print("swap: {} &lt;-&gt; {}".format(data[i], data[j]))
            data[i], data[j] = data[j], data[i]

    print("swap2: {} &lt;-&gt; {}".format(data[i + 1], data[right]))
    data[i + 1], data[right] = data[right], data[i + 1]
    return i + 1


def quick_sort(data, left, right):
    if left &lt; right:
        pivot = partition(data, left, right)
        quick_sort(data, left, pivot - 1)
        quick_sort(data, pivot + 1, right)

data = [2, 8, 7, 1, 3, 5, 6, 4]

print("Input array: {}".format(data))
quick_sort(data, 0, len(data) - 1)
print("Output array: {}".format(data))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an easy implementation:-</p>
<pre><code>def quicksort(array):
            if len(array) &lt; 2:
                  return array
            else:
                  pivot= array[0]
                  less = [i for i in array[1:] if i &lt;= pivot]

                  greater = [i for i in array[1:] if i &gt; pivot]

                  return quicksort(less) + [pivot] + quicksort(greater)

print(quicksort([10, 5, 2, 3]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def is_sorted(arr): #check if array is sorted
    for i in range(len(arr) - 2):
        if arr[i] &gt; arr[i + 1]:
            return False
    return True

def qsort_in_place(arr, left, right): #arr - given array, #left - first element index, #right - last element index
    if right - left &lt; 1: #if we have empty or one element array - nothing to do
        return
    else:
        left_point = left #set left pointer that points on element that is candidate to swap with element under right pointer or pivot element
        right_point = right - 1 #set right pointer that is candidate to swap with element under left pointer

        while left_point &lt;= right_point: #while we have not checked all elements in the given array
            swap_left = arr[left_point] &gt;= arr[right] #True if we have to move that element after pivot
            swap_right = arr[right_point] &lt; arr[right] #True if we have to move that element before pivot

            if swap_left and swap_right: #if both True we can swap elements under left and right pointers
                arr[right_point], arr[left_point] = arr[left_point], arr[right_point]
                left_point += 1
                right_point -= 1
            else: #if only one True we don`t have place for to swap it
                if not swap_left: #if we dont need to swap it we move to next element
                    left_point += 1
                if not swap_right: #if we dont need to swap it we move to prev element
                    right_point -= 1

        arr[left_point], arr[right] = arr[right], arr[left_point] #swap left element with pivot

        qsort_in_place(arr, left, left_point - 1) #execute qsort for left part of array (elements less than pivot)
        qsort_in_place(arr, left_point + 1, right) #execute qsort for right part of array (elements most than pivot)

def main():
    import random
    arr = random.sample(range(1, 4000), 10) #generate random array
    print(arr)
    print(is_sorted(arr))
    qsort_in_place(arr, 0, len(arr) - 1)
    print(arr)
    print(is_sorted(arr))

if __name__ == "__main__":
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code># 编程珠玑实现
# 双向排序: 提高非随机输入的性能
# 不需要额外的空间,在待排序数组本身内部进行排序
# 基准值通过random随机选取
# 入参: 待排序数组, 数组开始索引 0, 数组结束索引 len(array)-1
import random

def swap(arr, l, u):
    arr[l],arr[u] = arr[u],arr[l]
    return arr

def QuickSort_Perl(arr, l, u):
    # 小数组排序i可以用插入或选择排序 
    # if u-l &lt; 50 : return arr
    # 基线条件: low index = upper index; 也就是只有一个值的区间
    if l &gt;= u:
        return arr
    # 随机选取基准值, 并将基准值替换到数组第一个元素        
    swap(arr, l, int(random.uniform(l, u)))
    temp = arr[l]
    # 缓存边界值, 从上下边界同时排序
    i, j = l, u
    while True:
        # 第一个元素是基准值,所以要跳过
        i+=1
        # 在小区间中, 进行排序
        # 从下边界开始寻找大于基准值的索引
        while i &lt;= u and arr[i] &lt;= temp:
            i += 1
        # 从上边界开始寻找小于基准值的索引
        # 因为j肯定大于i, 所以索引值肯定在小区间中
        while arr[j] &gt; temp:
            j -= 1
        # 如果小索引仍小于大索引, 调换二者位置
        if i &gt;= j:
            break
        arr[i], arr[j] = arr[j], arr[i]
    # 将基准值的索引从下边界调换到索引分割点
    swap(arr, l, j)
    QuickSort_Perl(arr, l, j-1)
    QuickSort_Perl(arr, j+1, u)
    return arr

print('QuickSort_Perl([-22, -21, 0, 1, 2, 22])',
    QuickSort_Perl([-22, -21, 0, 1, 2, 22], 0, 5))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This algorithm doesn't use recursive functions.</p>
<p>Let <code>N</code> be any list of numbers with <code>len(N) &gt; 0</code>. Set <code>K = [N]</code> and execute the following program.</p>
<p>Note: This is a <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" rel="nofollow noreferrer">stable</a> sorting algorithm.</p>
<pre><code>def BinaryRip2Singletons(K, S):
    K_L = []
    K_P = [ [K[0][0]] ] 
    K_R = []
    for i in range(1, len(K[0])):
        if   K[0][i] &lt; K[0][0]:
            K_L.append(K[0][i])
        elif K[0][i] &gt; K[0][0]:
            K_R.append(K[0][i])
        else:
            K_P.append( [K[0][i]] )
    K_new = [K_L]*bool(len(K_L)) + K_P + [K_R]*bool(len(K_R)) + K[1:]
    while len(K_new) &gt; 0:
        if len(K_new[0]) == 1:
            S.append(K_new[0][0])
            K_new = K_new[1:]
        else: 
            break
    return K_new, S

N = [16, 19, 11, 15, 16, 10, 12, 14, 4, 10, 5, 2, 3, 4, 7, 1]
K = [ N ]
S = []

print('K =', K, 'S =', S)
while len(K) &gt; 0:
    K, S = BinaryRip2Singletons(K, S)
    print('K =', K, 'S =', S)
</code></pre>
<blockquote>
<p>PROGRAM OUTPUT:</p>
</blockquote>
<pre><code>K = [[16, 19, 11, 15, 16, 10, 12, 14, 4, 10, 5, 2, 3, 4, 7, 1]] S = []
K = [[11, 15, 10, 12, 14, 4, 10, 5, 2, 3, 4, 7, 1], [16], [16], [19]] S = []
K = [[10, 4, 10, 5, 2, 3, 4, 7, 1], [11], [15, 12, 14], [16], [16], [19]] S = []
K = [[4, 5, 2, 3, 4, 7, 1], [10], [10], [11], [15, 12, 14], [16], [16], [19]] S = []
K = [[2, 3, 1], [4], [4], [5, 7], [10], [10], [11], [15, 12, 14], [16], [16], [19]] S = []
K = [[5, 7], [10], [10], [11], [15, 12, 14], [16], [16], [19]] S = [1, 2, 3, 4, 4]
K = [[15, 12, 14], [16], [16], [19]] S = [1, 2, 3, 4, 4, 5, 7, 10, 10, 11]
K = [[12, 14], [15], [16], [16], [19]] S = [1, 2, 3, 4, 4, 5, 7, 10, 10, 11]
K = [] S = [1, 2, 3, 4, 4, 5, 7, 10, 10, 11, 12, 14, 15, 16, 16, 19]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def quick_sort(list):
    if len(list) ==0:
        return []

    return  quick_sort(filter( lambda item: item &lt; list[0],list)) + [v for v in list if v==list[0] ]  +  quick_sort( filter( lambda item: item &gt; list[0], list))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def quicksort(items):
    if not len(items) &gt; 1:
        return items
    items, pivot = partition(items)
    return quicksort(items[:pivot]) + [items[pivot]] + quicksort(items[pivot + 1:])


def partition(items):
    i = 1
    pivot = 0
    for j in range(1, len(items)):
        if items[j] &lt;= items[pivot]:
            items[i], items[j] = items[j], items[i]
            i += 1
    items[i - 1], items[pivot] = items[pivot], items[i - 1]
    return items, i - 1
</code></pre>
</div>
<span class="comment-copy">You could also swap out the 2nd <code>if</code>s in the for loop with <code>elif</code> and <code>else</code> to avoid doing unnecessary comparisons</span>
<span class="comment-copy">This is sound like merge sort not quick sort</span>
<span class="comment-copy">It's actually the <b>best</b> and most readable python code I found for quicksort <b>anywhere</b>. No indices, no helper functions, clearly shows the gist of the algorithm (divide and conquer).  (The default value for the array is rather unnecessary)</span>
<span class="comment-copy">@jsmedmar it will use more memory than an in place version, see suquant's answer for an in place quick sort.</span>
<span class="comment-copy">Very readable but does not this defeat the purpose of quick-sort since this won't achieve 'in place' sort? @RasmiRanjanNayak sort here is the user defined function (its a recursive call), not any built in function.</span>
<span class="comment-copy">This should be the selected answer, as quicksort is often the algorithm of choice (over e.g. merge sort) because it sorts in place (and still gives O(nlogn) runtime).</span>
<span class="comment-copy"><code>if end is None:</code> is going to be checked a lot of times, and only once is it going to be <code>True</code>. You should put this in a wrapper function so it is only called once.</span>
<span class="comment-copy">@RPGillespie done, tnx =)</span>
<span class="comment-copy">Ackchyually, bruhs, @mksteve is right and this line is incorrect. Additionally, <code>array[pivot], array[begin] = array[begin], array[pivot]</code> should replace <code>begin</code> with <code>end</code>.</span>
<span class="comment-copy">Although in-place is good, this is slow and it errors out due to hitting the max recursion depth when there is a lot of items.  see <a href="https://repl.it/@almenon/quicksorts?language=python3" rel="nofollow noreferrer">repl.it/@almenon/quicksorts?language=python3</a></span>
<span class="comment-copy">@zangw possible reasons for a downvote: 1) Quadratic runtime on already sorted or reversed arrays 2) The solution is not in-place. Therefore, a terrible implementation, sorry.</span>
<span class="comment-copy">Not very readable.</span>
<span class="comment-copy">not readable at all, are you truly trying to minimize the number of lines? Code is interpreted by machines, but understood by humans.</span>
<span class="comment-copy">@AlfredoGallegos, the whole point of quicksort is it happens in place, you may as well implement merge-sort if you are going to do this.</span>
<span class="comment-copy">Are these comment for real? If you want performance, use <code>sorted</code>, this is clearly for educational purposes. And it is readable, more readable than the accepted answer.</span>
<span class="comment-copy">Thanks for sharing this solution. Can you please help us understand the time-complexity? I see that the recursion will call it 15 times. Of these 8 are valid calls to the function. Does that mean the time-complexity is O(n) for the first solution and space complexity is O(1) as its in-place sort ?</span>
<span class="comment-copy">@Tammy it looks like you misunderstand the big-O notation. Moreover, I do not really understand your question. Could you perhaps ask it as a separate one? Finally, Quicksort as an algorithm runs in O(n logn) time and O(n) space.</span>
<span class="comment-copy">My Bad. Why on earth was i counting recursions ??  :-) Well, 15 recursions is [1 call (Level 0) + 2 call (Level 1 partition) + 4 call (Level 2 partition) + 8 call (Level 3 partition or Leaf nodes). So , we still have height as (lg8 + 1) = lgn. Total computation in each level is for c1(some cost) * n. Hence O(n lgn).  Space complexity, for one in-place exchange = O(1). Hence for n elements = O(n). Thanks for the pointer.</span>
<span class="comment-copy">this is far and away the best python quicksort on the internet, and it's sad to see it buried under so many O(n) space solutions :(</span>
<span class="comment-copy">Thanks for the kind words @Timofey. You might want to take a look at my algorithms repo, it has other versions of sorts, graph algorithms, etc. etc. <a href="https://github.com/alisianoi/algos-py" rel="nofollow noreferrer">github.com/alisianoi/algos-py</a></span>
<span class="comment-copy">O(N!)? is this a 'slowSort'?</span>
<span class="comment-copy">I believe in the first code example it should be 'lesser' and 'greater' instead of '[lesser]' and '[greater]' - else you'll end up with nested lists instead of a flat one.</span>
<span class="comment-copy">@Scott混合理论 I'm still learning time complexity, can you elaborate why this implementation is <code>O(N!)</code>? Assuming the nested list <code>[lesser]</code> and <code>[greater]</code> are typos, wouldn't it be average <code>O(3N logN)</code> which would reduce to the expected average <code>O(N logN)</code>? Granted, the 3 list comps do unnecessary work..</span>
<span class="comment-copy">@Chrispy what if you sort a inverted order list, like 5,4,3,2,1</span>
<span class="comment-copy">@Scott混合理论 you are right that worst-case run time of quick sort is slow Θ(n^2), but according to "introduction to algorithm", the average-case running time is Θ(n lg n). And, more importantly, quick sort generally outperforms heap sort in practice</span>
<span class="comment-copy">Your <code>partition</code> function seem not to work correctly for: <code>partition([5,4,3,2,1], 0, 4)</code>. Expected return index is 4, while it returns 3.</span>
<span class="comment-copy">@matino Where did that expectation come from? I believe I simplified the algorithm, though I could be wrong, or perhaps less efficient. If you could find a test-case for which the entire quicksort function fails, that would be helpful.</span>
<span class="comment-copy">You're right, the whole algorithm works just fine.</span>
<span class="comment-copy">list is reserved in python 3. see modified version of your code here:  <a href="https://gist.github.com/kunthar/9d8962e1438e93f50dc6dd94d503af3d" rel="nofollow noreferrer">gist.github.com/kunthar/9d8962e1438e93f50dc6dd94d503af3d</a></span>
<span class="comment-copy">akarca and @Kunthar Both these solutions in either python2 or python3 will pop an element from the list each time it is run, therefore destroying the list. Here is a fixed version: <a href="https://gist.github.com/joshuatvernon/634e0d912401899af0fdc4e23c94192b" rel="nofollow noreferrer">gist.github.com/joshuatvernon/634e0d912401899af0fdc4e23c94192b</a></span>
<span class="comment-copy">By the way, the concise version has less performance than the long one, since it is iterating the array twice to in the list comprehensions.</span>
<span class="comment-copy">please explain your code/additions so that OP and future views can benefit more.</span>
<span class="comment-copy">Please include explanation of what your code does and how it answers the question. Especially how does it relate to the code posted in the question. Answer should give the OP and future visitors guidance on how to debug and fix their problem. Pointing out, what the idea behind your code is, greatly helps in understanding the issue and applying or modifying your solution. <a href="https://stackoverflow.com">Stack Overflow</a> is not a code writing service, it’s a teaching and learning place.</span>
<span class="comment-copy">Nice (far as <a href="https://www.python.org/dev/peps/pep-0257/#id14" rel="nofollow noreferrer">undocumented code</a> goes), if similar to <a href="https://stackoverflow.com/a/24407355/3789665">acarca's</a>, <a href="https://stackoverflow.com/a/33163785/3789665">Arnaldo P. Figueira Figueira's</a> and <a href="https://stackoverflow.com/a/22225737/3789665">Birger's</a> answers from years gone by. Not sure this is an answer when the question reads <code>… complete my code?</code>. Using <code>lambda</code> to define <code>sublist()</code> doesn't look strictly necessary.</span>
<span class="comment-copy">@greybeard  Actually, Arnaldo's code did not compile in Python 3. Also, how can <code>sublist</code> be defined only using <code>filter</code>? Is that even possible?</span>
<span class="comment-copy">(Temporary comment: thinkin' of <code>def</code> - didn't start tinkering yet as I'm trying to figure out whether there's a more efficient way to "distribute" the elements of an iterable to separate lists (or, alternatively, one list with one "category" after the other).)</span>
<span class="comment-copy">18 other answers, more than half of which answer OP's original question of "how to concatenate the three arrays".  Does your answer add anything new?</span>
<span class="comment-copy">please provide some explanation</span>
<span class="comment-copy">While this code snippet may answer the question, it doesn't provide any context to explain how or why. Consider adding a sentence or two to explain your answer.</span>
