<div class="post-text" itemprop="text">
<p>I have a list of stocks and positions as tuples. Positive for buy, negative for sell. Example:</p>
<pre><code>p = [('AAPL', 50), ('AAPL', -50), ('RY', 100), ('RY', -43)]
</code></pre>
<p>How can I sum the positions of stocks, to get the current holdings?</p>
<pre><code>result = [('AAPL', 0), ('RY', 57)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this? You can read about <a href="http://docs.python.org/2/library/collections.html#collections.defaultdict"><code>collections.defaultdict</code></a>.</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; testDict = defaultdict(int)
&gt;&gt;&gt; p = [('AAPL', 50), ('AAPL', -50), ('RY', 100), ('RY', -43)]
&gt;&gt;&gt; for key, val in p:
        testDict[key] += val


&gt;&gt;&gt; testDict.items()
[('AAPL', 0), ('RY', 57)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution that doesn't involve importing:</p>
<pre><code>&gt;&gt;&gt; p = [('AAPL', 50), ('AAPL', -50), ('RY', 100), ('RY', -43)]
&gt;&gt;&gt; d = {x:0 for x,_ in p}
&gt;&gt;&gt; for name,num in p: d[name] += num
...
&gt;&gt;&gt; Result = map(tuple, d.items())
&gt;&gt;&gt; Result
[('AAPL', 0), ('RY', 57)]
&gt;&gt;&gt;
</code></pre>
<p>Note this is for Python 2.x.  In 3.x, you'll need to do: <code>Result = list(map(tuple, d.items()))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would do this using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>:</p>
<pre><code>In [2]: from collections import Counter

In [3]: c = Counter()

In [4]: for k, v in p:
   ...:     c[k] += v
   ...:     
In [5]: c
Out[5]: Counter({'AAPL': 0, 'RY': 57})
</code></pre>
<p>Then you can call the <code>most_common</code> method of <code>Counter</code> objects to get a list of tuples sorted by the values in descending order.</p>
<pre><code>In [5]: c.most_common()
Out[5]: [('RY', 57), ('AAPL', 0)]
</code></pre>
<p>In case you need to sort tuples by their first elements, use <code>sorted(c.items())</code>:</p>
<pre><code>In [6]: sorted(c.items())
Out[6]: [('AAPL', 0), ('RY', 57)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>without any explicit loops:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; p = [('AAPL', 50), ('AAPL', -50), ('RY', 100), ('RY', -43)]
&gt;&gt;&gt; map(lambda g: (g[0], sum(map(itemgetter(1), g[1]))),
...     groupby(sorted(p), itemgetter(0)))
[('AAPL', 0), ('RY', 57)]
</code></pre>
</div>
<span class="comment-copy">+1 Was just going to suggest <code>defaultdict</code> myself.</span>
<span class="comment-copy">How about that indeed! Thanks very much, worked perfectly and now I have some reading to do as well.</span>
<span class="comment-copy"><code>collections</code> library is full of gems. ;)</span>
<span class="comment-copy">Note that this will only work if the stocks are contiguous; you'd need to sort by the keyfunc otherwise.  Actually, come to think of it, I think it reads a little better without two maps: <code>[(k, sum(map(itemgetter(1), g))) for k,g in groupby(p, itemgetter(0))]</code>.</span>
