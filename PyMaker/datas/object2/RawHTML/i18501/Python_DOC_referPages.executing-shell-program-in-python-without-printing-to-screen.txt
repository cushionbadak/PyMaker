<div class="post-text" itemprop="text">
<p>Is there a way that I can execute a shell program from Python, which prints its output to the screen, and read its output to a variable without displaying anything on the screen?</p>
<p>This sounds a little bit confusing, so maybe I can explain it better by an example.</p>
<p>Let's say I have a program that prints something to the screen when executed</p>
<pre><code>bash&gt; ./my_prog
bash&gt; "Hello World"
</code></pre>
<p>When I want to read the output into a variable in Python, I read that a good approach is to use the <code>subprocess</code> module like so:</p>
<pre><code>my_var = subprocess.check_output("./my_prog", shell=True)
</code></pre>
<p>With this construct, I can get the program's output into <code>my_var</code> (here <code>"Hello World"</code>), however it is also printed to the screen when I run the Python script. Is there any way to suppress this? I couldn't find anything in the <code>subprocess</code> documentation, so maybe there is another module I could use for this purpose?</p>
<p>EDIT:
I just found out that <code>commands.getoutput()</code> lets me do this. But is there also a way to achieve similar effects in <code>subprocess</code>? Because I was planning to make a Python3 version at some point.</p>
<hr/>
<p>EDIT2: Particular Example</p>
<p>Excerpt from the python script:</p>
<pre><code>oechem_utils_path = "/soft/linux64/openeye/examples/oechem-utilities/"\
        "openeye/toolkits/1.7.2.4/redhat-RHEL5-g++4.3-x64/examples/"\
        "oechem-utilities/"

rmsd_path = oechem_utils_path + "rmsd"

for file in lMol2:
            sReturn = subprocess.check_output("{rmsd_exe} {rmsd_pars}"\
                 " -in {sIn} -ref {sRef}".format(rmsd_exe=sRmsdExe,\
                 rmsd_pars=sRmsdPars, sIn=file, sRef=sReference), shell=True)
    dRmsds[file] = sReturn
</code></pre>
<hr/>
<p>Screen Output (Note that not "everything" is printed to the screen, only a part of
the output, and if I use <code>commands.getoutput</code> everything works just fine:</p>
<pre><code>/soft/linux64/openeye/examples/oechem-utilities/openeye/toolkits/1.7.2.4/redhat-RHEL5-g++4.3-x64/examples/oechem-utilities/rmsd: mols in: 1  out: 0
/soft/linux64/openeye/examples/oechem-utilities/openeye/toolkits/1.7.2.4/redhat-RHEL5-g++4.3-x64/examples/oechem-utilities/rmsd: confs in: 1  out: 0
/soft/linux64/openeye/examples/oechem-utilities/openeye/toolkits/1.7.2.4/redhat-RHEL5-g++4.3-x64/examples/oechem-utilities/rmsd - RMSD utility [OEChem 1.7.2]

/soft/linux64/openeye/examples/oechem-utilities/openeye/toolkits/1.7.2.4/redhat-RHEL5-g++4.3-x64/examples/oechem-utilities/rmsd: mols in: 1  out: 0
/soft/linux64/openeye/examples/oechem-utilities/openeye/toolkits/1.7.2.4/redhat-RHEL5-g++4.3-x64/examples/oechem-utilities/rmsd: confs in: 1  out: 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To add to Ryan Haining's answer, you can also handle stderr to make sure nothing is printed to the screen:</p>
<pre><code> p = subprocess.Popen(command, shell=True, stdin=subprocess.PIPE, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, close_fds=True)
out,err = p.communicate()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If <code>subprocess.check_ouput</code> is not working for you, use a <a href="http://docs.python.org/2/library/subprocess.html#subprocess.Popen" rel="nofollow">Popen</a> object and a <code>PIPE</code> to capture the program's output in Python.</p>
<pre><code>prog = subprocess.Popen('./myprog', shell=True, stdout=subprocess.PIPE)
output = prog.communicate()[0]
</code></pre>
<p>the <code>.communicate()</code> method will wait for a program to finish execution and then return a tuple of <code>(stdout, stderr)</code> which is why you'll want to take the <code>[0]</code> of that. </p>
<p>If you also want to capture <code>stderr</code> then add <code>stderr=subprocess.PIPE</code> to the creation of the <code>Popen</code> object.</p>
<p>If you wish to capture the output of <code>prog</code> while it is running instead of waiting for it to finish, you can call <code>line = prog.stdout.readline()</code> to read one line at a time.  Note that this will hang if there are no lines available until there is one.</p>
</div>
<div class="post-text" itemprop="text">
<p>I always used <a href="http://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow">Subprocess.Popen</a>, which gives you no output normally</p>
</div>
<span class="comment-copy">Are you sure? Because <code>checkout_output</code> simply returns the output as a string, nothing is flushed on the screen.</span>
<span class="comment-copy">Yes I am, I will post the exact in and output to my initial query in a few moments</span>
<span class="comment-copy">I have added the particular issue under <code>EDIT2</code></span>
<span class="comment-copy">ahhh, I forgot the <code>stderr</code>! thank you, this solved my problem!</span>
<span class="comment-copy">you could use <code>output = check_output(cmd, stderr=STDOUT)</code>, to capture both stdout and stderr in a single variable.</span>
<span class="comment-copy">Thanks, I have tried that before and it still printed some of the output to the screen. Hm, maybe it's just a problem with this particular program and I will just go with <code>commands.getoutput</code></span>
<span class="comment-copy">@SebastianRaschka as I said in my answer, you can also capture <code>stderr</code> which is likely the cause of "some of the output" being printed</span>
<span class="comment-copy">yes, thank you, just overlooked it somehow, since this output is just the "regular" output and not an "error" notification</span>
