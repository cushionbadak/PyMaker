<div class="post-text" itemprop="text">
<p>Is it possible to mock a return value of a function called within another function I am trying to test? I would like the mocked method (which will be called in many methods I'm testing) to returned my specified variables each time it is called. For example: </p>
<pre><code>class Foo:
    def method_1():
       results = uses_some_other_method()
    def method_n():
       results = uses_some_other_method()
</code></pre>
<p>In the unit test, I would like to use mock to change the return value of <code>uses_some_other_method()</code> so that any time it is called in <code>Foo</code>, it will return what I defined in <code>@patch.object(...)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>There are two ways you can do this; with patch and with patch.object</p>
<p>Patch assumes that you are not directly importing the object but that it is being used by the object you are testing as in the following</p>
<pre><code>#foo.py
def some_fn():
    return 'some_fn'

class Foo(object):
    def method_1(self):
        return some_fn()

#bar.py
import foo
class Bar(object):
    def method_2(self):
        tmp = foo.Foo()
        return tmp.method_1()

#test_case_1.py
import bar
from mock import patch

@patch('foo.some_fn')
def test_bar(mock_some_fn):
    mock_some_fn.return_value = 'test-val-1'
    tmp = bar.Bar()
    assert tmp.method_2() == 'test-val-1'
    mock_some_fn.return_value = 'test-val-2'
    assert tmp.method_2() == 'test-val-2'
</code></pre>
<p>If you are directly importing the module to be tested, you can use patch.object as follows:</p>
<pre><code>#test_case_2.py
import foo
from mock import patch

@patch.object(foo, 'some_fn')
def test_foo(test_some_fn):
    test_some_fn.return_value = 'test-val-1'
    tmp = foo.Foo()
    assert tmp.method_1() == 'test-val-1'
    test_some_fn.return_value = 'test-val-2'
    assert tmp.method_1() == 'test-val-2'
</code></pre>
<p>In both cases some_fn will be 'un-mocked' after the test function is complete.</p>
<p>Edit:
In order to mock multiple functions, just add more decorators to the function and add arguments to take in the extra parameters</p>
<pre><code>@patch.object(foo, 'some_fn')
@patch.object(foo, 'other_fn')
def test_foo(test_other_fn, test_some_fn):
    ...
</code></pre>
<p>Note that the closer the decorator is to the function definition, the earlier it is in the parameter list.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be done with something like this:</p>
<pre><code># foo.py
class Foo:
    def method_1():
        results = uses_some_other_method()


# testing.py
from mock import patch

@patch('Foo.uses_some_other_method', return_value="specific_value"):
def test_some_other_method(mock_some_other_method):
    foo = Foo()
    the_value = foo.method_1()
    assert the_value == "specific_value"
</code></pre>
<p>Here's a source that you can read: <a href="http://alexmarandon.com/articles/python_mock_gotchas/" rel="nofollow noreferrer">Patching in the wrong place</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Let me clarify what you're talking about: you want to test <code>Foo</code> in a testcase, which calls external method <code>uses_some_other_method</code>. Instead of calling the actual method, you want to mock the return value.</p>
<pre><code>class Foo:
    def method_1():
       results = uses_some_other_method()
    def method_n():
       results = uses_some_other_method()
</code></pre>
<p>Okay, suppose the above code is in <code>foo.py</code>, <code>uses_some_other_method</code> is defined in module <code>bar.py</code>. Here is the unittest:</p>
<pre><code>import unitest
import mock

from foo import Foo


class TestFoo(unittest.TestCase):

    def setup(self):
        self.foo = Foo()

    @mock.patch('foo.uses_some_other_method')
    def test_method_1(self, mock_method):
        mock_method.return_value = 3
        self.foo.method_1(*args, **kwargs)

        mock_method.assert_called_with(*args, **kwargs)
</code></pre>
<p>If you want to change the return value every time you passed in different arguements, <code>mock</code> provides <a href="https://docs.python.org/3/library/unittest.mock.html#quick-guide" rel="noreferrer"><code>side_effect</code> </a>.</p>
</div>
<span class="comment-copy">Thank you for the explanation of the difference between patch and patch.object.</span>
<span class="comment-copy">how to <code>patch.object</code> two functions within the same class?</span>
<span class="comment-copy">What if foo is a library I have no access to and what I want to mock is the call to method_1?</span>
<span class="comment-copy">Great answer, very informative and clearly explained.</span>
<span class="comment-copy">Thank you so much for this phrase: "the closer the decorator is to the function definition, the earlier it is in the parameter list." Just spent 1 hour debugging this...</span>
