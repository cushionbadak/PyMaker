<div class="post-text" itemprop="text">
<p>Here is the question:</p>
<p>Given two words with the same number of letters in each, work out how many letters need to be changed to get from the first word to the second. A more complex version of edit distance is commonly used in spelling auto-correct algorithms on phones and word processors to find candidate corrections.</p>
<p>The two words should be read from the user with one word per line. For example:</p>
<pre><code>Word 1: hello
Word 2: jelly
2
</code></pre>
<p>this is all I got: </p>
<pre><code>w1 = input('Word 1: ')
w2 = input('Word 2: ')
for i in w1:
  for o in w2:
    print(i, o)
</code></pre>
<p>How do I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try something like:</p>
<pre><code>sum(c1 != c2 for c1,c2 in zip(w1,w2))
</code></pre>
<p><code>zip(w1,w2)</code> creates a generator that returns tuples consisting of corresponding letters of <code>w1</code> and <code>w2</code>. i.e.:</p>
<pre><code>&gt;&gt;&gt; list(zip(w1,w2))
[('h', 'j'), ('e', 'e'), ('l', 'l'), ('l', 'l'), ('o', 'y')]
</code></pre>
<p>We iterate over these tuples (<code>c1</code> gets assigned to each first char and <code>c2</code> to each second char) and check if <code>c1 != c2</code>. We add up all the instances for which this condition is satisfied to arrive at out answer.</p>
<p>(See <a href="http://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip()</code></a> and <a href="http://docs.python.org/3/library/functions.html#sum" rel="nofollow"><code>sum()</code></a>)</p>
<hr/>
<pre><code>&gt;&gt;&gt; w1 = 'hello'
&gt;&gt;&gt; w2 = 'jelly'
&gt;&gt;&gt; 
&gt;&gt;&gt; sum(c1 != c2 for c1,c2 in zip(w1,w2))
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="http://docs.python.org/2/library/difflib.html" rel="nofollow">difflib</a>:</p>
<pre><code>&gt;&gt;&gt; import difflib
&gt;&gt;&gt; w1, w2 = 'hello', 'jelly'
&gt;&gt;&gt; matcher = difflib.SequenceMatcher(None, w1, w2)
&gt;&gt;&gt; m = sum(size for start, end, size in matcher.get_matching_blocks())
&gt;&gt;&gt; n = max(map(len, (w1, w2))) # n = len(w1)
&gt;&gt;&gt; n - m
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A functional approach:</p>
<pre><code>&gt;&gt;&gt; from itertools import starmap
&gt;&gt;&gt; from operator import ne
&gt;&gt;&gt; sum(starmap(ne, zip(word1, word2)))
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the words are always going to be the same length you can use <a href="http://docs.python.org/2/library/functions.html#zip" rel="nofollow">zip</a> to loop through both lists at once:</p>
<pre><code>w1 = input('Word 1: ')
w2 = input('Word 2: ')
changes=0    
    for i, o in zip(w1, w2):
    if i != o:
        changes+=1

print "Changes needed: "+str(changes)
</code></pre>
</div>
<span class="comment-copy">thank you! It worked! Can you please explain what is happening in the code?</span>
<span class="comment-copy">@Samir Sure, I added some explanation.</span>
<span class="comment-copy"><code>difflib</code> is generally a good place to look when solving these types of problems. But for something this simple, it seems like overkill.</span>
<span class="comment-copy">The no import and not using <code>zip</code> approach:: <code>sum(map(str.__ne__, a, b))</code></span>
<span class="comment-copy">@JonClements: Nice!  Note that there's a subtle difference, as <code>zip()</code> stops after the shortest word, while <code>map()</code> goes on until the longest word is exhausted, using <code>None</code> as a fill value, in case the words have different lengths.</span>
<span class="comment-copy">True, but I would consider that more desired behaviour as <code>str.__ne__</code> will end up with a <code>TypeError</code> which is also in effect an assertion that the lengths are equal as stated in the problem text.</span>
