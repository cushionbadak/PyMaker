<div class="post-text" itemprop="text">
<p>Let C be a Python class and assume that the constructor of C takes an integer as argument.</p>
<p>Consider now the instructions</p>
<pre><code>x = C(0)
y = C(0)
</code></pre>
<p>The default behavior of Python implies that x and y occupy two different place in the memory.</p>
<blockquote>
<p>Is it possible to force x and y to share the same place in memory?</p>
</blockquote>
<p>I would be very happy if some Python decorator makes the job.</p>
<p><strong>[Note]</strong> I am looking for a way to memoize constructors (see <a href="http://en.wikipedia.org/wiki/Memoization" rel="nofollow">http://en.wikipedia.org/wiki/Memoization</a> for the memoization of functions).</p>
<p><strong>[Add]</strong> The Sage Open Source Mathematics Software provides a very good solution to this problem through the class <code>UniqueRepresentation</code> (see <a href="http://www.sagemath.org/doc/reference/structure/sage/structure/unique_representation.html" rel="nofollow">here</a>). Any class should inherit from this one to have the expected behavior. Nevertheless, I am wondering if there is a pure Python solution to this problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may want to use <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow">lru_cache</a>.  If your class definition is</p>
<pre><code>@lru_cache(maxsize=32)
class C(object):
    def __init__(self, num):
        self.num = num
</code></pre>
<p>then it behaves like</p>
<pre><code>&gt;&gt;&gt; a = C(1)
&gt;&gt;&gt; a.num = 2
&gt;&gt;&gt; b = C(1)
&gt;&gt;&gt; b.num
2
&gt;&gt;&gt; a is b
True
</code></pre>
<p>However, this makes the name <code>C</code> a function, and any class features aren't usable before the class is actually instantiated.  If you want, you can also directly cache the method <code>__new__</code>, which is responsible for the creation of the object.  <code>__new__</code> is a method which takes all the same arguments as <code>__init__</code> and it is called before <code>__init__</code> when we create class instances.</p>
<p>As caching the output of <code>__new__</code> is straightforward, we could make things a little bit more interesting.  Let's create a new decorator, which works just like <code>lru_cache</code>, but it can be used with classes to cache the output of <code>__new__</code>:</p>
<pre><code>def lru_cache_class(maxsize):
    def wrap(klass):
        @lru_cache(maxsize=maxsize)
        def new(cls, *args, **kwargs):
            self = object.__new__(cls)
            return self
        klass.__new__ = new
        return klass
    return wrap
</code></pre>
<p>We give <code>__new__</code> all possible arguments and keyword arguments so that it can be used with other classes as well.  Now we can cache the instances of class <code>C2</code> like this:</p>
<pre><code>@lru_cache_class(maxsize=32)
class C2(object):
    def __init__(self, num):
        self.num = num
</code></pre>
<p>And we can see that the objects are cached:</p>
<pre><code>&gt;&gt;&gt; c = C2(2)
&gt;&gt;&gt; c is C2(2)
True
</code></pre>
<p>There is, however, another subtle difference in this approach compared to the first.  For instance:</p>
<pre><code>&gt;&gt;&gt; d = C2(3)
&gt;&gt;&gt; d.num = 4
&gt;&gt;&gt; d.num
4
&gt;&gt;&gt; e = C2(3)
&gt;&gt;&gt; d.num == e.num
&gt;&gt;&gt; d.num
3
</code></pre>
<p>This behavior is expected because <code>__init__</code> is called anyway, although the object's memory location remains the same.  Depending on your use case, you may want to cache the output of <code>__init__</code> as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could just override the <code>__new__</code> to store cached versions of each object:</p>
<pre><code>class C(object):
    _cache = {}

    def __new__(cls, x):
        if x not in C._cache:
            C._cache[x] = object.__new__(cls, x)
        return C._cache[x]

    def __init__(self, x):
        self.x = x
</code></pre>
<p>Demonstration:</p>
<pre><code>&gt;&gt;&gt; a = C(1)
&gt;&gt;&gt; b = C(1)
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; id(a) == id(b)
True
</code></pre>
<p>Obviously, if you later change <code>x</code> instead of creating a new class, it won't become the same object as one previously defined with that value of <code>x</code>:</p>
<pre><code>&gt;&gt;&gt; a = C(1)
&gt;&gt;&gt; b = C(2)
&gt;&gt;&gt; a.x = 2
&gt;&gt;&gt; a is b
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are willing to have a function create the class instance for you, this might work.  Assuming you have your class <code>C</code> that accepts an integer:</p>
<pre><code>def C_getter(num, _class_archive={}):
    """\
    Returns an instance of the `C` class,
    making sure that if an object already exists with that
    integer number a new object is not created.

    The _class_archive is used to keep a record of all the instances
    in memory local to this function.  Don't actually supply an
    argument to _class_archive when you call this function.
    """

    if num not in _class_archive:
        _class_archive[num] = C(num)
    return _class_archive[num]
</code></pre>
<p>Use it like this:</p>
<pre><code>&gt;&gt;&gt; a = C_getter(0)
&gt;&gt;&gt; b = C_getter(0)
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; c = C(0)
&gt;&gt;&gt; a is c
False
</code></pre>
<p>I am taking advantage of the fact that if you use a mutable object as a default argument to a function, the <em>same</em> mutable object is used for each time the function is called.</p>
<p><strong>Edit</strong></p>
<p>If you wanted to make this generic (assuming all your classes need a single number), you could do the following:</p>
<pre><code>def getter(your_class, num, _class_archive={}):
    if (your_class, num) not in _class_archive:
        _class_archive[(your_class, num)] = your_class(num)
    return _class_archive[(your_class, num)]
</code></pre>
<p>You can use it like this:</p>
<pre><code>&gt;&gt;&gt; a = getter(C, 0)
&gt;&gt;&gt; b = getter(C, 0)
&gt;&gt;&gt; c = getter(A, 0)
</code></pre>
</div>
<span class="comment-copy">Uhh... why not <code>x = y = C(0)</code>? or <code>x = C(0); y=x</code>?</span>
<span class="comment-copy">But why x = y = C(0)? I want, when two objects are mathematically equivalent, that they share the same memory place. Assume that x = C(0) is defined as a local variable of a function f and y = C(0) is defined as a local variable of another function g.</span>
<span class="comment-copy">Are you thinking of something like copy-on-demand; like what happens when you <code>fork()</code>? Also, testing for equality in the sense of <code>x==y</code> is what <code>__eq__</code> is for</span>
<span class="comment-copy">I am searching a way to do memoization of constructors.</span>
<span class="comment-copy">Please explain <code>memoization of constructors</code></span>
<span class="comment-copy">This is a nice solution, but the problem is that the decorator <code>@lru_cache</code> turn the symbol <code>C</code> into a function identifier. Is there a similar solution that preserves the fact that <code>C</code> is a class?</span>
<span class="comment-copy">You're right.  I just edited my answer to show another way, which keeps the name <code>C</code> as a class.</span>
<span class="comment-copy">Thanks, this seems very great! Nevertheless, it would be very useful to have a class decorator to obtain the same behavior.</span>
<span class="comment-copy">Your solution is very interesting, but I think that there are some few issues. Your class decorator creates a new class from the input one. This new class loses some properties of the first one, like its doctstring. I think that an excellent solution does not create and return a new class but just add a memoized version of <code>__new__</code> to the input class. Do you think that this is feasible ?</span>
<span class="comment-copy">Overriding methods (<code>__new__</code> in this case) is only possible by inheritance.  Your concern about the class docstring is easily fixed -- just define <code>__doc__</code> attribute to be that of the parent class.  If you also want some nice string representation that points to the base class, you need to specify <code>__str__</code> method in the definition. But the excellent solution that you are expecting is just defining <code>__new__</code> with the <code>lru_cache</code> decorator in you class definition <code>C</code> (this is what I suggested before the last edit).</span>
<span class="comment-copy">Thanks for the answer! However, this solution is not generic in the following sense: you have to define, for each class A, a function A_getter. Moreover, I think that it is more accurate to define this function as a static method or a class method of C. This also works well but I think that it is a pity to (1) have to construct objects not through the constructor, (2) have to define a same static (or class) method for any class.</span>
<span class="comment-copy">@SamueleGiraudo I have made it a bit more generic, but it still won't satisfy all your criteria.</span>
<span class="comment-copy">This is a nice solution even if it indeed not satisfies all my criteria (I cannot up-vote because I have not enough reputation, sorry). Maybe, it is possible to improve it a little by replacing the argument <code>num</code> by <code>*args</code> to cover the case where constructors need any parameters.</span>
<span class="comment-copy">@SamueleGiraudo I thought of that, but in python 2.x this would require <code>_class_archive</code> to be <i>before</i> <code>*args</code>, and then you would have to supply an argument for <code>_class_archive</code> when you call the function, completely defeating the purpose.</span>
