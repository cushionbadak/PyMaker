<div class="post-text" itemprop="text">
<p>In the code below, class A has a member function which is set to point to a function defined outside the class. 
in class B, the same function is set to the external pointer in the class definition.
Calling the function for an object of type A will fail, because the self does not get passed to the function. But for B, the self gets passed.
Why does the self get passed for B, but not for A?</p>
<pre><code>def f1(s,a):
    print s
    print a

class A(object):
    def __init__(self):
        self.fp1 = f1

class B(object):
    fp1 = f1

a=A()
b=B()
try:a.fp1("blaa")
except Exception, e: print `e` 
try:b.fp1("bluu")
except Exception, e: print `e` 
</code></pre>
<p>Output: </p>
<pre><code>TypeError('f1() takes exactly 2 arguments (1 given)',)
&lt;__main__.B object at 0x2ab0dacabed0&gt;
bluu
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you did <code>self.fp1 = f1</code> you just assigned a function to an instance variable of the class <code>A</code>. So when you call it you have to pass two arguments.</p>
<p>When you did:</p>
<pre><code>   class B(object):
       fp1 = f1
</code></pre>
<p>during creation process of the class <code>B</code> python found a function <code>fp1</code> in the class scope and created an <code>instancemethod</code> from it (replaced the variable with name <code>fp1</code> with an <code>instancemethod</code> created from the function that it held before). When you call an <code>instancemethod</code> on an object <code>self</code> gets automatically passed as the first argument.</p>
<p>You can check this by typing:</p>
<pre><code>&gt;&gt;&gt; a = A()
&gt;&gt;&gt; b = B()
&gt;&gt;&gt; type(a.fp1)
function
&gt;&gt;&gt; type(b.fp1)
instancemethod
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In class <code>A</code> you bind a function to an instance. This could be really considered as "function pointer" so all arguments must be passed explicitly. In class <code>B</code> you bind the function to the class which will cause the function to work as method. You could modify class definition <code>A</code> to </p>
<pre><code>class A(object):
    def __init__(self):
        A.fp1 = f1
</code></pre>
<p>which will give the same behavior has class <code>B</code>, i.e. <code>fp1</code> of all instances points to <code>f1</code>, or you could wrap <code>f1</code>.</p>
<pre><code>class A(object):
    def __init__(self):
        self.fp1 = lambda a: f1(self, a)
</code></pre>
<p>This will allow to change <code>fp1</code> for each instance individually. The latter variant is probably what you were looking for.</p>
</div>
<div class="post-text" itemprop="text">
<p>The magic that makes <code>instance.method(...)</code> equivalent to <code>Class.method(instance, ...)</code> is dependent on the function object being an attribute of the class. The details vary (and with them, the ugly workaround by which you can create such a method). In Python 3, all functions are <a href="http://docs.python.org/3/reference/datamodel.html#descriptors" rel="nofollow">descriptors</a>. In Python 2, there are special <em>unbound method</em> objects which are implicitly created to wrap functions stored as class attributes and do roughly what all functions do by themselves in Python 3.</p>
<p>In either case, accessing it through an instance creates a <em>bound method</em> which passes the instance along as first argument when called. In either case, a function accessed through an instance attribute is in no way special, it's just another object which can be passed around and used.</p>
<p>You can achieve similar behavior by either using <code>partial</code> (a bit of a leaky abstraction):</p>
<pre><code>from functools import partial
# in __init__
self.fp1 = partial(f1, self)
</code></pre>
<p>or by creating a method which delegates:</p>
<pre><code>def __init__(self):
    self._fp1 = f1

def fp1(*args, **kwds):
    return self._fp1(self, *args, **kwds)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the first case you create a field in the class, that has a method object stored in it. So "a.fp1" is not a method call and therefore "a" is not put as the first argument. It's a retrieval of a method object, and then calling it.</p>
<p>For the second case, you can refer to the <a href="http://docs.python.org/2/tutorial/classes.html#random-remarks" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>Any function object that is a class attribute defines a method for
  instances of that class.</p>
</blockquote>
<p>So, for b "fp1" becomes a method for instances of class b.</p>
<p>You can find more detailed explanation here: <a href="https://stackoverflow.com/questions/14298844/method-objects-vs-function-objects-python-class-instances-vs-class">method objects vs function objects , Python class instances vs class</a></p>
</div>
