<div class="post-text" itemprop="text">
<p>I have a list:</p>
<pre><code>[0, 1, 2, 3, 4, 5]
</code></pre>
<p>I would like to combine the first item all others except the last.
The result should be a list, as the list below:</p>
<pre><code>[[0], [0,1], [0,2], [0,3], [0,4], [0,1,2], [0,1,3] [0,1, 4], [0,2,3], [0,2,4], [0,3,4], [0,1,2,3], [0,1,2,4], [0, 2,3,4], [0,1,2,3,4]]
</code></pre>
<p>How can I do this?
Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>This problem is related to <a href="http://en.wikipedia.org/wiki/Power_set" rel="nofollow">powersets</a></p>
<pre><code>&gt;&gt;&gt; L = [0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; [[L[0]] + [k for j,k in enumerate(L[1:-1]) if i&gt;&gt;j&amp;1] for i in range(1&lt;&lt;(len(L)-2))]
[[0], [0, 1], [0, 2], [0, 1, 2], [0, 3], [0, 1, 3], [0, 2, 3], [0, 1, 2, 3], [0, 4], [0, 1, 4], [0, 2, 4], [0, 1, 2, 4], [0, 3, 4], [0, 1, 3, 4], [0, 2, 3, 4], [0, 1, 2, 3, 4]]
</code></pre>
<p>If you want them sorted shortest to longest:</p>
<pre><code>&gt;&gt;&gt; M = [[L[0]] + [k for j,k in enumerate(L[1:-1]) if i&gt;&gt;j&amp;1] for i in range(1&lt;&lt;(len(L)-2))
&gt;&gt;&gt; sorted(M, key=len)
[[0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 1, 2], [0, 1, 3], [0, 2, 3], [0, 1, 4], [0, 2, 4], [0, 3, 4], [0, 1, 2, 3], [0, 1, 2, 4], [0, 1, 3, 4], [0, 2, 3, 4], [0, 1, 2, 3, 4]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools

a = [0, 1, 2, 3, 4, 5]

base = (a[0],)
items = a[1:-1]
combos = [base + combo for length in range(len(items)+1) for combo in itertools.combinations(items, length)]

# In case it matters that the sublists are lists rather than tuples:
combos = [list(combo) for combo in combos]

print combos
# [[0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [0, 1, 2, 3], [0, 1, 2, 4], [0, 1, 3, 4], [0, 2, 3, 4], [0, 1, 2, 3, 4]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First compute the <a href="http://en.wikipedia.org/wiki/Power_set" rel="nofollow">power set</a> of the all but the first item.  Searching on "python power set" you'll get several hits, including <a href="http://ruslanspivak.com/2011/06/09/power-set-generation-a-joy-of-python/" rel="nofollow">this one</a>.  You didn't specifically mention it, but you probably want the results in lexographical order, and the implementation I selected gets you most of the way there.</p>
<p>That will give you all the combinations you need, .e.g [[], <a href="http://en.wikipedia.org/wiki/Power_set" rel="nofollow">1</a>, ..., [1,2,3,4,5]] (note this includes the empty set and the whole set itself).  Now just prepend 0 to each of these gives [[0],[0,1],...[0,1,2,3,4,5]].</p>
</div>
<div class="post-text" itemprop="text">
<p>Its a combination of the first element plus the <a href="http://docs.python.org/2/library/itertools.html#recipes" rel="nofollow">powerset</a> of all the elements minus the first and last elements:</p>
<pre><code>from itertools import chain, combinations

test = [0, 1, 2, 3, 4, 5]

def powerset(iterable):
    "powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))


print [test[:1] + list(c) for c in powerset(test[1:-1])]

# [[0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [0, 1, 2, 3], [0, 1, 2, 4], [0, 1, 3, 4], [0, 2, 3, 4], [0, 1, 2, 3, 4]]   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a generator. </p>
<pre><code>from itertools import combinations

def custom_combination_gen(l):
    start = [l[0]]
    L = l[1:-1]
    yield start
    for y in range(1, len(L)+1):
        for x in combinations(L, y):
            yield start + list(x)
</code></pre>
<p>Running the code:</p>
<pre><code>print list(custom_combination_gen([0,1,2,3,4,5]))
[[0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [0, 1, 2, 3], [0, 1, 2, 4], [0, 1, 3, 4], [0, 2, 3, 4], [0, 1, 2, 3, 4]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools
a = [0, 1, 2, 3, 4, 5]
myList = []
myFinalList = []
for i in xrange(0,len(a)-2): myList += list(itertools.combinations(a[1:-1],i))
for item in myList: myFinalList.append(list(item)+[a[0]])
print myFinalList
</code></pre>
</div>
<span class="comment-copy">Unhelpful short answer - probably something in the <a href="http://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a> module.</span>
<span class="comment-copy">Why is <code>[1]</code> excluded?</span>
<span class="comment-copy">Perfect! Thanks!</span>
<span class="comment-copy">@InbarRose You're right.  Fixed.</span>
<span class="comment-copy">+1 but you can make it simpler by removing the inner square brackets in <code>combos = [[base + combo ...</code> and removing the next line. (also you can write <code>range(len(items)+1)</code> instead of <code>range(0, len(items)+1)</code>)</span>
<span class="comment-copy">@flornquake Good suggestions - that eliminates the <code>chain.from_iterable</code> step, too.</span>
<span class="comment-copy">Assisting instead of giving the program +1 :)</span>
<span class="comment-copy">Hi, your post has been flagged as "low quality", probably because it consists solely of code. You could massively improve your answer by providing an explanation of exactly how and why this answers the question?</span>
