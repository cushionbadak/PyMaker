<div class="post-text" itemprop="text">
<p>tl;dr I spawn 3 threads, each thread throws an exception, most pythonic way to raise all 3 exceptions?</p>
<p>Below is a code example that is similar to what I am doing.</p>
<pre><code>from multiprocessing.pool import ThreadPool

def fail_func(host):
    raise Exception('{} FAILED!!!'.format(host))

hosts = ['172.1.1.1', '172.1.1.2', '172.1.1.3']
pool = ThreadPool(processes=5)
workers = [pool.apply_async(fail_func(host)) for host in hosts]
# join and close thread pool
pool.join(); pool.close()
# get the exceptions
[worker.get() for worker in workers if not worker.successful()]
</code></pre>
<p>What it ends up doing is just failing on the 1st host with the following traceback:</p>
<pre><code>Traceback (most recent call last):
  File "thread_exception_example.py", line 8, in &lt;module&gt;
    workers = [pool.apply_async(fail_func(host)) for host in hosts]
  File "thread_exception_example.py", line 4, in fail_func
    raise Exception('{} FAILED!!!'.format(host))
Exception: 172.1.1.1 FAILED!!!
</code></pre>
<p>But what I want it to do is raise multiple exceptions for each thread that failed, like so:</p>
<pre><code>Traceback (most recent call last):
  File "thread_exception_example.py", line 8, in &lt;module&gt;
    workers = [pool.apply_async(fail_func(host)) for host in hosts]
  File "thread_exception_example.py", line 4, in fail_func
    raise Exception('{} FAILED!!!'.format(host))
Exception: 172.1.1.1 FAILED!!!

Traceback (most recent call last):
  File "thread_exception_example.py", line 8, in &lt;module&gt;
    workers = [pool.apply_async(fail_func(host)) for host in hosts]
  File "thread_exception_example.py", line 4, in fail_func
    raise Exception('{} FAILED!!!'.format(host))
Exception: 172.1.1.2 FAILED!!!

Traceback (most recent call last):
  File "thread_exception_example.py", line 8, in &lt;module&gt;
    workers = [pool.apply_async(fail_func(host)) for host in hosts]
  File "thread_exception_example.py", line 4, in fail_func
    raise Exception('{} FAILED!!!'.format(host))
Exception: 172.1.1.3 FAILED!!!
</code></pre>
<p>is there any pythonic way of doing this? or do I need to wrap everything in a try/except, collect all the messages, then re-raise a single Exception?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no way to "raise multiple exceptions". In a given exception context, there is either an exception, or not.</p>
<p>So yes, you will have to create a wrapper exception that holds all of the exceptions, and raise that. But you've almost got all the code you need:</p>
<pre><code>def get_exception():
    try:
        worker.get()
    except Exception as e:
        return e
</code></pre>
<p>Now, instead of:</p>
<pre><code>[worker.get() for worker in workers if not worker.successful()]
</code></pre>
<p>â€¦ you can just do:</p>
<pre><code>[get_exception(worker.get) for worker in workers if not worker.successful()]
</code></pre>
<p>And that's a list of exceptions.</p>
<hr/>
<p>Personally, I've always thought <code>AsyncResult</code> should have an <code>exception</code> method, similar to the one in <a href="http://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.exception" rel="nofollow"><code>concurrent.futures.Future</code></a>. But then I would have used <code>futures</code> here in the first place (installing the <a href="https://pypi.python.org/pypi/futures" rel="nofollow">backport</a> if I were forced to use Python 2.x).</p>
</div>
<span class="comment-copy">As a side note, it's a little confusing to call your results objects <code>worker</code>. Normally, that word refers to the subprocesses in the pool.</span>
<span class="comment-copy">As another side note, <code>multiprocessing.pool.ThreadPool</code> is an undocumented feature, while <code>multiprocessing.dummy.Pool</code> is documented and should give you what you want. I personally think that in this case, the much clearer name <code>ThreadPool</code> vs. <code>dummy.Pool</code> outweighs that, but it's worth knowing the choice for yourself.</span>
