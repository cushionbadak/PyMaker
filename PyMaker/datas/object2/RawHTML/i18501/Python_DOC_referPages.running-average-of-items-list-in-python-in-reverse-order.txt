<div class="post-text" itemprop="text">
<p>I need to find the average of items in a 1-dimensional list:
  For example: L = [123,678,234,256,789,-----]
               first i need to obtain the running average starting from the last item in the list.Thus providing a resultant list as follows: reslist= [416,489.25,426.33,522.5,789---].
Plz can any one suggest a simple code in python for doing this it will be helpful..</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution that uses recursion:</p>
<pre><code>def runningMean(seq, n=0, total=0):
    if not seq:
        return []
    total = total+seq[-1]
    return runningMean(seq[:-1], n=n+1, total=total) + [total/float(n+1)]
</code></pre>
<p><strong>DEMO</strong></p>
<pre><code>print(runningMean([123,678,234,256,789]))
</code></pre>
<p>output:</p>
<pre><code>[416.0, 489.25, 426.3333333333333, 522.5, 789.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So for each index <code>i</code>, you want the average of the values <code>L[i]</code> through <code>L[-1]</code>, right?</p>
<p>First, let's write a simple <code>average</code> function:</p>
<pre><code>def average(values):
    return sum(values) / len(values)
</code></pre>
<p>Now, we can translate the description into code:</p>
<pre><code>running_averages = [average(L[i:]) for i in range(len(L))]
</code></pre>
<p>You also seem to want to round things in some unspecified way (489.25 is rounded to 489, but 522.5 is left as 522.5); if you can describe the rule, I can show how to implement it, but I can't guess the rule from your examples.</p>
<hr/>
<p>Of course this isn't very efficient if L is long, because it will do <code>len(L)**2 / 2</code> additions. Is there a way we could do it in just <code>len(L)</code>? Sure, it's just a bit more complicated. For example:</p>
<pre><code>partial_sums = itertools.accumulate(reversed(L))
averages = [value/(i+1) for i, value in enumerate(partial_sums)]
averages.reverse()
</code></pre>
<p>The first and last steps are easy: just reverse the list at the start and then at the end. But what about the rest?</p>
<p>First, <a href="http://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow"><code>accumulate</code></a> just takes any iterable, and returns an iterator with the accumulated sums. So it gives you <code>i[0]</code>, then <code>i[0] + i[1]</code>, then <code>i[0] + i[1] + i[2]</code>, etc. But, because it remembers the last partial sum, each step only takes one addition. In other words, it's giving you <code>0 + i[0]</code>, then <code>result[0] + i[1]</code>, then <code>result[1] + i[2]</code>. If you want to see how it works (or if you're using an older version of Python that doesn't have <code>accumulate</code>), the linked documentation shows how you can build it yourself.</p>
<p>And then, we just divide each partial sum by the index (+ 1, because Python indices are 0-based) to get the running average. The list comprehension should be obvious; if you don't know the <a href="http://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a> function, that's the only clever bit.</p>
<hr/>
<p>That's not the only way to do it. You could also use <code>functools.reduce</code>, or an explicit loop, or build a tail-recursive function by accumulator passing, or a naive recursive function, or… It might be a good exercise to try to write as many of them as you can. There may be only one obvious way to do it, but sometimes it's not obvious which one is the obvious way until you try a few. :)</p>
<hr/>
<p>Another way to do this is with numpy. rogaos deleted his too-simple answer, but it's a start.</p>
<p>First, the easy part: reverse the list, and cram it into a numpy array:</p>
<pre><code>a = np.array(reversed(L))
</code></pre>
<p>Now, the trick is to write a vectorized running sum. Well, numpy comes with <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.convolve.html" rel="nofollow"><code>convolve</code></a>, and convolving with a run of N ones gives you an N+M-1-windowed sum. So, what happens if the window is as wide as the whole array? We get a windowed sum that's almost twice as long as we need, where the first len(L) values are the running sums. So:</p>
<pre><code>running_sums = np.convolve(a, np.ones(len(L)))[:len(L)]
</code></pre>
<p>Then we just divide by the indices, just as in the itertools version:</p>
<pre><code>running_means = running_sums / np.arange(1, len(L)+1)
</code></pre>
<p>And now we just reverse it and turn it back into a list:</p>
<pre><code>reslist = list(reversed(running_means))
</code></pre>
<p>Of course in real life, you'd probably want <code>L</code> and <code>reslist</code> to be numpy arrays too, which makes it even simpler.</p>
<p>Anyway, the upside of using numpy is that some of the operations are simpler (notice how I just divided one array by another, instead of writing a list comprehension), and usually about 10x faster (all of the looping and arithmetic takes place in C, or occasionally C++ or Fortran, instead of in Python). The downside is that you have to figure out how to turn each loop into a sensible mathematical operation. (If you don't know what <code>convolve</code> does, you never would have thought to use it here.)</p>
</div>
<span class="comment-copy">Why not just pass down the total instead of the mean? That would avoid all of the rounding errors (and performance costs) of all those unnecessary float divisions.</span>
<span class="comment-copy">Nice idea.  Edited</span>
<span class="comment-copy">Also, if you're going to use accumulator-passing recursion, why not make it tail-recursive (by passing down one more accumulator for the list itself)? I realize that doesn't help anything in Python… but it's a better demonstration of the way you'd do this in a functional language. (Well, you'd probably use a fold/reduce/etc.-type function rather than explicit recursion. Or, in a more modern functional language, probably a comprehension similar to my answer. But you know what I mean, right?)</span>
