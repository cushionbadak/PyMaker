<div class="post-text" itemprop="text">
<p>I am doing browser automation using python + splinter.
my structure is like this</p>
<pre><code>[root]
+--start.py
+--end.py
+--[module1]
|  +--mod11area1.py
|  +--mod12area2.py
|  +--[module1_2]
|  |  +--mod121area1.py
|  +--[module1_3]
|     +--mod131area1.py
+--[module2]
   +--mod21area1.py
</code></pre>
<p>start.py sets the initialization and opening of the browser
and the inner modules.py performs actions per module
this structure would then be merged into one script upon execute by appending the contents in this fasion:</p>
<pre><code>start.py
mod11area1.py
mod12area2.py
mod121area1.py
mod131area1.py
mod21area1.py
end.py
</code></pre>
<p><strong>My question is, is there a better way of doing this?</strong>  I'm quite new to this and just usually create a single script. since my project keeps on expanding I had to employ several other guys to script with me.  Hence I came up with this approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, Python has no simple way to merge scripts into one <code>.py</code> file.</p>
<p>But you can fake it, albeit in a fairly limited way.</p>
<hr/>
<p>Heres an example of how you can define multiple modules (each with their own namespace), in a single file.</p>
<p>But has the following limitations.</p>
<ul>
<li>No package support<br/><em>(although this could be made to work).</em></li>
<li>No support for modules depending on eachother<br/><em>(a module can't be imported unless its already defined).</em></li>
</ul>
<p>Example - 2 modules, each containing a function:</p>
<pre><code># Fake multiple modules in a single file.
import sys
_globals_init = None  # include ourself in namespace
_globals_init = set(globals().keys())

# ------------------------
# ---- begin
__name__ = "test_module_1"
__doc__ = "hello world"

def test2():
    print(123)


sys.modules[__name__] = type(sys)(__name__, __doc__)
sys.modules[__name__].__dict__.update(globals())
[globals().__delitem__(k) for k in list(globals().keys()) if k not in _globals_init]
# ---- end ------------


# ---------------------
# ---- begin
__name__ = "some_other"
__doc__ = "testing 123"

def test1():
    print(321)


sys.modules[__name__] = type(sys)(__name__, __doc__)
sys.modules[__name__].__dict__.update(globals())
[globals().__delitem__(k) for k in list(globals().keys()) if k not in _globals_init]
# ---- end ------------


# ----------------
# ---- example use

import test_module_1
test_module_1.test2()

import some_other
some_other.test1()

# this will fail (as it should)
test1()
</code></pre>
<p>Note, this isn't good practice, if you have this problem, you're probably better off with some alternative solution (such as using <a href="https://docs.python.org/3/library/zipimport.html" rel="nofollow">https://docs.python.org/3/library/zipimport.html</a>)</p>
</div>
<div class="post-text" itemprop="text">
<p>See my <a href="https://github.com/jasonrute/modulize" rel="nofollow noreferrer">GitHub project</a>.</p>
<p><strong>There is likely a better way for your needs.  I developed this project/hack for <em>programming contests</em> which only allow the contestant to submit <em>a single <code>.py</code> file</em>.  This allows one to develop a project with multiple <code>.py</code> files and then combine them into one <code>.py</code> file at the end.</strong></p>
<p>My hack is a decorator <code>@modulize</code> which converts a function into a module.  This module can then be imported as usual.  Here is an example.</p>
<pre><code>@modulize('my_module')
def my_dummy_function(__name__):  # the function takes one parameter __name__
    # put module code here
    def my_function(s): 
        print(s, 'bar')

    # the function must return locals()
    return locals()

# import the module as usual
from my_module import my_function
my_function('foo') # foo bar
</code></pre>
<p>I also have a script which can combine a project of many <code>.py</code> files which import each other into one '.py' file.</p>
<p>For example, assume I had the following directory structure and files:</p>
<pre><code>my_dir/
    __main__.py

        import foo.bar
        fb = foo.bar.bar_func(foo.foo_var)
        print(fb) # foo bar

    foo/
        __init__.py

            foo_var = 'foo'

        bar.py

            def bar_func(x):
                return x + ' bar'
</code></pre>
<p>The combined file will look as follows.  The code on the top defines the <code>@modulize</code> decorator.</p>
<pre><code>import sys
from types import ModuleType

class MockModule(ModuleType):
    def __init__(self, module_name, module_doc=None):
        ModuleType.__init__(self, module_name, module_doc)
        if '.' in module_name:
            package, module = module_name.rsplit('.', 1)
            get_mock_module(package).__path__ = []
            setattr(get_mock_module(package), module, self)

    def _initialize_(self, module_code):
        self.__dict__.update(module_code(self.__name__))
        self.__doc__ = module_code.__doc__

def get_mock_module(module_name):
    if module_name not in sys.modules:
        sys.modules[module_name] = MockModule(module_name)
    return sys.modules[module_name]

def modulize(module_name, dependencies=[]):
    for d in dependencies: get_mock_module(d)
    return get_mock_module(module_name)._initialize_

##===========================================================================##

@modulize('foo')
def _foo(__name__):
    ##----- Begin foo/__init__.py ------------------------------------------------##
    foo_var = 'foo'
    ##----- End foo/__init__.py --------------------------------------------------##
    return locals()

@modulize('foo.bar')
def _bar(__name__):
    ##----- Begin foo/bar.py -----------------------------------------------------##
    def bar_func(x):
        return x + ' bar'
    ##----- End foo/bar.py -------------------------------------------------------##
    return locals()

def __main__():
    ##----- Begin __main__.py ----------------------------------------------------##
    import foo.bar
    fb = foo.bar.bar_func(foo.foo_var)
    print(fb) # foo bar
    ##----- End __main__.py ------------------------------------------------------##

__main__()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of appending the contents into a single *.py file, why not just import what you need from the code that the other people in your team write?</p>
</div>
<span class="comment-copy">Why not just use version control(git)?</span>
<span class="comment-copy">@elyase this is just a patch process as we are still yet to purchase a proper software. version control is not my concern, however merging into 1 script is. thanks for the quick response</span>
<span class="comment-copy">As much as possible it has to be modular so that I could just take out script that don't meet my needs without affecting the final script.</span>
<span class="comment-copy">While the question is valid, you're trying to do something which is basically unsupported by Python. Any solution you use is likely to be rather hackish and not a method you could consider good-practice.</span>
