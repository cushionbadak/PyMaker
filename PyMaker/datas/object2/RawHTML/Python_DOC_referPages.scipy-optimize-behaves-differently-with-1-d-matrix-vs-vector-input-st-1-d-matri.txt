<div class="post-text" itemprop="text">
<p>I have experienced that feeding scipy.optimize a 1-d matrix (of shape (N,1)) gives different (wrong) results vs. giving it the same data in the form of vectors (vectors are <code>w</code> and <code>y</code> in the MVE below</p>
<pre><code>import numpy as np
from scipy.optimize import minimize
X = np.array([[ 1.13042959,  0.45915372,  0.8007231 , -1.15704469,  0.42920652],
       [ 0.14131009,  0.9257914 ,  0.72182141,  0.86906652, -0.32328187],
       [-1.40969139,  1.32624329,  0.49157981,  0.2632826 ,  1.29010016],
       [-0.87733399, -1.55999729, -0.73784827,  0.15161383,  0.11189782],
       [-0.94649544,  0.10406324,  0.65316464, -1.37014083, -0.28934968]])

wtrue = np.array([3.14,2.78,-1,0, 1.6180])

y = X.dot(wtrue)
def cost_function(w, X, y):
    return np.mean(np.abs(y - X.dot(w)))

#  %%
w0 = np.zeros(5)
output = minimize(cost_function, w0, args=(X, y), options={'disp':False, 'maxiter':128})
print('Vector Case:\n', output.x, '\n', output.fun)

# Reshaping w0 and y to (N,1) will 'break things'
w0 = np.zeros(5).reshape(-1,1)
y = y.reshape(-1,1) #This is the problem, only commenting this out will make below work
output = minimize(cost_function, w0, args=(X, y), options={'disp':False, 'maxiter':128})
print('1-d Matrix Case:\n', output.x, '\n', output.fun)
</code></pre>
<p>Gives</p>
<p>Vector Case:
[3.13999999e+00  2.77999996e+00 -9.99999940e-01  1.79002338e-08,1.61800001e+00] 
 1.7211226932545288e-08 // TRUE almost 0</p>
<p>1-d Matrix Case:
 [-0.35218177 -0.50008129  0.34958755 -0.42210756  0.79680766] 
 3.3810648518841924 // WRONG nowhere close to true solution</p>
<p>Does anyone know why the solution using the 1-d matrix inputs come out 'wrong'?</p>
<p>I suspect that this is b/c somewhere along the way <code>.minimize</code> turns the parameter vector into an actual vector and then I know that (2,) + (2,1) gives a (2,2) matrix rather than a (2,) or a (2,1). This still strikes me as 'weird' and I would like to know if I'm missing some bigger point here. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [300]: y                                                                               
Out[300]: array([ 4.7197293 ,  1.7725223 ,  0.85632763, -6.17272225, -3.8040323 ])
In [301]: w0                                                                              
Out[301]: array([0., 0., 0., 0., 0.])
In [302]: cost_function(w0,X,y)                                                           
Out[302]: 3.465066756332
</code></pre>
<p>Initially changing the shape of <code>y</code> doesn't change the cost:</p>
<pre><code>In [306]: cost_function(w0,X,y.reshape(-1,1))                                             
Out[306]: 3.4650667563320003
</code></pre>
<p>Now get a solution:
    In [308]: output = optimize.minimize(cost_function, w0, args=(X, y), options={'disp':False
         ...: , 'maxiter':128}) </p>
<pre><code>In [310]: output.x                                                                        
Out[310]: 
array([ 3.14000001e+00,  2.77999999e+00, -9.99999962e-01, -5.58139763e-08,
        1.61799993e+00])
</code></pre>
<p>Evaluate the cost as the optimal <code>x</code></p>
<pre><code>In [311]: cost_function(output.x,X,y)                                                     
Out[311]: 7.068144833866085e-08        # = output.fun
</code></pre>
<p>But with the reshaped <code>y</code>, the cost is different:</p>
<pre><code>In [312]: cost_function(output.x,X,y.reshape(-1,1))                                       
Out[312]: 4.377833258899681
</code></pre>
<p>The initial value <code>x0</code> is flattened by the code (look at <code>optimize.optimize._minimize_bfgs</code>), so changing the shape of <code>w0</code> doesn't matter.  But the <code>args</code> arrays are passed to the cost function without changed.  So if changing the shape of <code>y</code> changes the cost calculation, it will change the optimization.</p>
</div>
<span class="comment-copy">Inputting <code>(N,1)</code> invalidates the API as i see it. In it's core it boils down to numpy's <a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" rel="nofollow noreferrer">broadcasting rules</a> where probably much is to say. Numpy's rules surely differ from matlab/julia (imho) and therefore algebraic things like column-vectors / row-vectors need some care.</span>
<span class="comment-copy">Which API? The scipy.optimize.minimize? If so shouldn't there be an assert at the start of <code>minimize</code>?</span>
<span class="comment-copy">@alexandreiolov "If so shouldn't there be an assert at the start of minimize?" Yes, there should, but one cannot trust on it. One cannot put assertions for all possible cases that could go wrong, although this here sounds like a mistake that should rather be catched earlier than later. You could maybe propose a suitable assertion to the programmers of scipy.</span>
<span class="comment-copy">Your initial condition <code>w0</code> is flattened to conform to the required <code>(n,)</code> shape.  But your <code>y</code> is passed via <code>args</code> directly to your <code>cost_function</code>.  The error is the result of how <code>y - X.dot(w)</code> handles the different <code>y</code> shapes.  That's your responsibility, not <code>minimize's</code>.</span>
<span class="comment-copy">Thanks. This makes perfect sense. Your initial example above only works b/c w0 you chose is all zeros (which is also the case in my MVE so maybe you did this intentionaly), if you change it to anything else, it would fail and more clearly demonstrate your point, I would say.  The main point is that scipy.optimize.minimize silently flattens its input, which resulted in unexpected outcome for the original author of this code. Thanks again</span>
