<div class="post-text" itemprop="text">
<p>I wrote this code with nested <code>if else</code> cases, but I feel it's so ugly and wonder if there's any way to improve it (or any better way to accomplish this).</p>
<pre><code>def do_something(self, response):
    a_url = response.css('a.classA::attr(href)').extract_first()
    if a_url:
        a_url = a_url.split('&amp;')[0]
    else:
        a_url = response.css('a.classB::attr(href)').extract_first()
        if a_url:
            a_url = a_url.split('&amp;')[0]
        else:
            logger.error('get no url')
    if a_url:
        yield Request(
            url=a_url,
            dont_filter=True,
            callback=self.do_next_thing
        )
</code></pre>
<p>The main concern is that I wanna extract a url/link from a response, and then <strong>split</strong> it and get the first element. But <strong>a_url</strong> only exists in one of two(or may be more) elements. I can't do the <strong>split</strong> directly because <strong>a_url</strong> may be <code>NoneType</code>. I wanna try with <code>try except else</code> but that seems getting even more complicated.</p>
<p>Any better solutions?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you could do it like this:</p>
<pre><code>def do_something(self, response):
    a_url = (
        response.css('a.classA::attr(href)').extract_first()
        or
        response.css('a.classB::attr(href)').extract_first()
    )

    if not a_url:
        logger.error('get no url')
        return # or raise an exception and let the caller do the logging

    yield Request(
        url=a_url.split('&amp;')[0],
        dont_filter=True,
        callback=self.do_next_thing
    )
</code></pre>
<p>This uses the short-circuit behaviour of the <a href="https://docs.python.org/3/reference/expressions.html#or" rel="nofollow noreferrer"><code>or</code> operator</a>:</p>
<blockquote>
<p>The expression <code>x</code> or <code>y</code> first evaluates <code>x</code>; if <code>x</code> is true, its
  value is returned; otherwise, <code>y</code> is evaluated and the resulting value
  is returned.</p>
</blockquote>
<p>It also uses the "early return" technique, i.e. the failure case is handled first, and then the "normal" case can be done outside of any <code>if</code> or <code>else</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best way to simplify this code is to select both classes in scrappy in the first place:</p>
<pre><code>def do_something(self, response):  
    a_url = response.css("a.classA::attr(href), a.classB::attr(href)")
    if a_url:   
        yield Request(
            url=a_url.split('&amp;')[0],
            dont_filter=True,
            callback=self.do_next_thing
        )
    else:
        logger.error('get no url')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might want to consider splitting the method into two (later on even three) ones. Because as I see it, the first lines are more of a preparation than of actual logic. Something like this:</p>
<pre><code>def prepare_something(self, response):
  a_url = response.css('a.classA::attr(href)').extract_first()
  if a_url:
    return a_url.split('&amp;')[0]
  else:
    a_url = response.css('a.classB::attr(href)').extract_first()
    if a_url:
      return a_url.split('&amp;')[0]
    else:
      logger.error('get no url')
      return None


def do_something(self, response):
  a_url = self.prepare_something(response)
  if a_url:
    yield Request(
      url=a_url,
      dont_filter=True,
      callback=self.do_next_thing
    )
</code></pre>
<p>This way, imho, the code is a little bit cleaner, and you are able to see that you might want to refactor the <code>prepare_something</code> method, like the following: </p>
<pre><code>def get_a_url_part(self, response, path):
  a_url = response.css(path).extract_first()
  return a_url.split('&amp;')[0] if a_url else None

def prepare_something(self, response):
  a_url = self.get_a_url_part(response, 'a.classA::attr(href)')
  b_url = self.get_a_url_part(response, 'a.classB::attr(href)')
  return a_url if a_url else b_url

def do_something(self, response):
  a_url = self.prepare_something(response)
  if a_url:
    yield Request(
      url=a_url,
      dont_filter=True,
      callback=self.do_next_thing
   )
</code></pre>
<p>From my point of view this could be considered an improvement.</p>
<p>Regards :)</p>
</div>
<span class="comment-copy"><a href="https://codereview.stackexchange.com/">codereview.stackexchange.com</a></span>
