<div class="post-text" itemprop="text">
<p>I have a regex like --</p>
<pre><code>query = "(A((hh)|(hn)|(n))?)"
</code></pre>
<p>and an input <code>inp = "Ahhwps edAn"</code>. I want to extract all the matched pattern along with unmatched(remaining) but with preserving order of the input.
The output should look like -- <code>['Ahh', 'wps ed', 'An']</code> or <code>['Ahh', 'w', 'p', 's', ' ', 'e', 'd', 'An']</code>.
I had searched online but found nothing.
How can I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow noreferrer"><code>re.split</code></a> method may output captured submatches in the resulting array.</p>
<p>Capturing groups are those constructs that are formed with a pair of unescaped parentheses. Your pattern abounds in redundant capturing groups, and <code>re.split</code>  will return all of them. You need to remove those unnecessary ones, and convert all capturing groups to non-capturing ones, and just keep the outer pair of parentheses to make the whole pattern a single capturing group.</p>
<p>Use </p>
<pre><code>re.split(r'(A(?:hh|hn|n)?)', s)
</code></pre>
<p>Note that there may be an empty element in the output list. Just use <code>filter(None, result)</code>  to get rid of the empty values.</p>
</div>
<div class="post-text" itemprop="text">
<p>The match objects' span() method is really useful for what you're after.</p>
<pre><code>import re

pat = re.compile("(A((hh)|(hn)|(n))?)")
inp = "Ahhwps edAn"

result=[]
i=k=0
for m in re.finditer(pat,inp):
    j,k=m.span()
    if i&lt;j:
        result.append(inp[i:j])
    result.append(inp[j:k])
    i=k
if i&lt;len(inp):
    result.append(inp[k:])

print result
</code></pre>
<p>Here's what the output looks like.</p>
<pre><code>['Ahh', 'wps ed', 'An']
</code></pre>
<p>This technique handles any non-matching prefix and suffix text as well. If you use an inp value of "prefixAhhwps edAnsuffix", you'll get the output I think you'd want:</p>
<pre><code>['prefix', 'Ahh', 'wps ed', 'An', 'suffix']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>import re
import itertools
new_data = list(itertools.chain.from_iterable([re.findall(".{"+str(len(i)/2)+"}", i) for i in inp.split()]))
</code></pre>
<p>Output:</p>
<pre><code>['Ahh', 'wps', 'ed', 'An']
</code></pre>
</div>
<span class="comment-copy">@WiktorStribi≈ºew, Thanks a lot. It worked like a charm.</span>
<span class="comment-copy">I observed empty strings and removed them. Thanks for suggesting <code>filter</code> method.</span>
