<div class="post-text" itemprop="text">
<p>I'm a C++ guy, I love parallelism, HPC applications and I know OpenMP pretty well. Now I'm learning python and I know the basics.</p>
<p>As a personal project to improve my python skills, I would like to implement a parallel version of the <a href="http://www.cse.iitd.ac.in/~rjaiswal/2015/col870/Project/Nipun.pdf" rel="nofollow noreferrer">Elkan algorithm for k-means</a>. A parallel version implemented with C and OpenMP of this algorithm is <a href="http://www.vlfeat.org/overview/ikm.html#tut.ikm.elkan" rel="nofollow noreferrer">present in VLFeat</a>. </p>
<p>Now, I know how I could easily implement the Elkan algorithm in python...But what about parallelism? The cool thing about OpenMP is that you take serial code, you add <code>#pragma omp parallel for</code> and SBAM, it's parallel!</p>
<p>How can I achieve something similar in python? Or do I have to design the parallel algorithm from the beginning, i.e., not writing the serial version first and then make it parallel, but managing threads explicitly etc (which is an huge pain)?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, CPU parallelism in Python can only be obtained via native code or via multiple processes.</p>
<p>Second, the analogy to OpenMP would be the <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">multiprocessing</a> module.</p>
<p>It has a lot going on, but for simple for loops, etc. it's quite easy to use.</p>
<pre><code>results = map(operation, things)
</code></pre>
<p>would become</p>
<pre><code>import multiprocessing
pool = multiprocessing.Pool()
results = pool.map(operation, things)
</code></pre>
</div>
<span class="comment-copy">Just so you are aware of it: multithreading in Python is useless (if not counter-productive) for CPU-bound applications. You'll need multiprocessing instead. Thanks Mr <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">GIL</a>. Wonderful reference <a href="http://www.dabeaz.com/python/UnderstandingGIL.pdf" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">This may have some useful references: <a href="https://www.scipy.org/topical-software.html#parallel-and-distributed-programming" rel="nofollow noreferrer">Parallel and distributed programming within NumPy/SciPy</a>.</span>
<span class="comment-copy">So you're telling me that parallelism is achievable in Python not by multithreading but by allocating multiple processes only? Wow, that sounds an overkill!</span>
<span class="comment-copy">Threads in python are very limited when compared to threads in C++ due to <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">Global Interpreter Lock</a></span>
<span class="comment-copy">@justHelloWorld, the overhead of processes vs threads themselves is not necessarily all that different, depending on the program. Python, MRI Ruby, and Javascript all use a multiprocessing paradigm. It's not without its advantages. Being into C++ parallelism, you like have heard/used <a href="http://mpitutorial.com/" rel="nofollow noreferrer">MPI</a>.</span>
