<div class="post-text" itemprop="text">
<p>I am trying to make a fast copy of a class instance. <code>cPickle.loads(cPickle.dumps(),-1)</code> works fine, almost 5 times faster than <code>copy.deepcopy</code>, but I <a href="https://stackoverflow.com/a/29385667">read that <code>ujson</code> is much faster than <code>cPickle</code></a>. I could not get ujson to work with a custom class, is it possible to do so?</p>
<p>example:</p>
<pre><code>import cPickle as pickle
import ujson

class AClass(object):
    def __init__(self):
        print('init')
        self.v = 10
        self.z = [2,3,4]
        self._zdict = dict(zip(self.z,self.z))

a = AClass()
a
#&lt;__main__.AClass at 0x118b1d390&gt;


# does not work with ujson
ua = ujson.dumps(a)
au = ujson.loads(ua)
au
#{u'v': 10, u'z': [2, 3, 4]}


# but works with pickle
pa = pickle.dumps(a)
ap = pickle.loads(pa)
ap
#&lt;__main__.AClass at 0x117460190&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An idea is to define your own protocole, base of the concept described for <a href="https://docs.python.org/3/library/pickle.html#pickling-class-instances" rel="nofollow noreferrer">pickle</a>.
Define a <code>__getstate__</code> and <code>__setsatte__</code> instance in your class:</p>
<pre><code>class AClass(object):
    def __init__(self, v, z):
        self.v = v
        self.z = z
        self._zdict = dict(zip(self.z, self.z))

    def __repr__(self):
        return repr({'v': self.v, 'z': self.z, '_zdict': self._zdict})

    def __getstate__(self):
        return {'v': self.v, 'z': self.z}

    def __setstate__(self, state):
        self.__dict__.update(state)
        self._zdict = dict(zip(self.z, self.z))
</code></pre>
<p>Then, you can define a <code>save()</code> and a <code>load()</code>function like this:</p>
<pre><code>import importlib
import json
import io

def save(instance, dst_file):
    data = {
        'module': instance.__class__.__module__,
        'class': instance.__class__.__name__,
        'state': instance.__getstate__()}
    json.dump(data, dst_file)


def load(src_file):
    obj = json.load(src_file)
    module_name = obj['module']
    mod = importlib.import_module(module_name)
    cls = getattr(mod, obj['class'])
    instance = cls.__new__(cls)
    instance.__setstate__(obj['state'])
    return instance
</code></pre>
<p>Simple usage (using a <code>StringIO</code> here instead of a classic file):</p>
<pre><code>a_class = AClass(10, [2, 3, 4])
my_file = io.StringIO()
save(a_class, my_file)

print(my_file.getvalue())
# -&gt; {"module": "__main__", "class": "AClass", "state": {"v": 10, "z": [2, 3, 4]}}

my_file = io.StringIO(my_file.getvalue())
instance = load(my_file)

print(repr(instance))
# -&gt; {'v': 10, 'z': [2, 3, 4], '_zdict': {2: 2, 3: 3, 4: 4}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>ujson</code> isn't serializing the <em>object</em>; it's just encoding its attribute <code>dict</code> as a JSON object. There isn't enough information there to reproduce the original object in it entirety; the most obvious indication is that nothing in the output of <code>ujson.dumps</code> records what class <code>a</code> was an instance of.</p>
<p>The reason <code>usjon</code> is so much faster than <code>cPickle</code> is that <code>cPickle</code> has to do a lot more.</p>
</div>
<span class="comment-copy">No. You can tell by looking at the output of <code>ujson.dumps</code> (it's just a <code>str</code> object) that it doesn't contain the information needed to rebuild the source object. It's <i>just</i> a JSON encoder. That's part of the reason it is faster then <code>cPickle</code>; it doesn't have to do as much.</span>
<span class="comment-copy">I think, you have to develop your own JSON protocole. It can be easy to dump a class instance into a JSON object (in fact you dump the <code>__dict__</code>). But, it's not easy to load a JSON object: how do you differentiate a <code>dict</code> from a class instance. There is no JSON syntax for that.</span>
<span class="comment-copy">so, i guess, <code>cPickle</code> is my best bet</span>
