<div class="post-text" itemprop="text">
<p>I have one base class with abstractmethod and subclass which implements this method. How to determine in runtime if in object (without checking type of object or calling method) that method is abstract or not?</p>
<pre><code>class Base:
    @abc.abstractmethod
    def someAbstractMethod(self):
        raise NotImplementedError("Not implemented yet.")


class Subclass(Base):
    def someAbstractMethod(self):
        some_operations

objects = [Base(),Subclass(),Base(),Subclass(),Subclass(),...]
for object in objects:
    #here I want check if method is still abstract or not
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python prevents the creation of instances for classes with abstract methods. So <em>just the fact that you have an instance</em> means you have no abstract methods.</p>
<p>You do, however, have to use the <a href="https://docs.python.org/3/library/abc.html#abc.ABCMeta" rel="nofollow noreferrer"><code>ABCMeta</code> metaclass</a> to properly trigger this behaviour:</p>
<pre><code>class Base(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def someAbstractMethod(self):
        raise NotImplementedError("Not implemented yet.")
</code></pre>
<p>You can also inherit from <a href="https://docs.python.org/3/library/abc.html#abc.ABC" rel="nofollow noreferrer"><code>abc.ABC</code></a> to get the same metaclass via a base class.</p>
<p>If you wanted to see what abstract methods a <em>class</em> might have listed, use the <code>__abstractmethods__</code> attribute; it is a set of all names that are still abstract:</p>
<pre><code>&gt;&gt;&gt; import abc
&gt;&gt;&gt; class Base(metaclass=abc.ABCMeta):
...     @abc.abstractmethod
...     def someAbstractMethod(self):
...         raise NotImplementedError("Not implemented yet.")
...
&gt;&gt;&gt; class Subclass(Base):
...     def someAbstractMethod(self):
...         some_operations
...
&gt;&gt;&gt; Base.__abstractmethods__
frozenset({'someAbstractMethod'})
&gt;&gt;&gt; Subclass.__abstractmethods__
frozenset()
</code></pre>
<p>All that the <code>@abc.abstractmethod</code> decorator does is set a <code>__isabstractmethod__</code> attribute on the function object; it is the metaclass that then uses those attributes.</p>
<p>So if you are dig in too deep or are using a third-party library that has forgotten to use the <code>ABCMeta</code> metaclass, you can test for those attributes:</p>
<pre><code>&gt;&gt;&gt; class Base:    # note, no metaclass!
...     @abc.abstractmethod
...     def someAbstractMethod(self):
...         raise NotImplementedError("Not implemented yet.")
...
&gt;&gt;&gt; getattr(Base().someAbstractMethod, '__isabstractmethod__', False)
True
</code></pre>
<p>If you need to 'repair' such broken abstract base classes, you'd need subclass and mix in <code>ABCMeta</code>, <strong>and</strong> add a <code>__abstractmethods__</code> frozenset to the class you are inheriting from:</p>
<pre><code>BaseClass.__abstractmethods__ = frozenset(
    name for name, attr in vars(BaseClass).items()
    if getattr(attr, '__isabstractmethod__', False))

class DerivedClass(BaseClass, metaclass=abc.ABCMeta):
    # ...
</code></pre>
<p>Now <code>DerivedClass</code> is a proper ABC-derived class where any abstract methods are properly tracked and acted on.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're not using <code>abc</code> correctly here (well not as it's intended to be used at least). Your <code>Base</code> class should use <code>abc.ABCMeta</code> as metaclass, which would prevent instanciation of child classes not implementing abstractmethods. Else just using the <code>abc.abstractmethod</code> decorator is mostly useless.</p>
<p>Python 2.7:</p>
<pre><code>class Base(object):
    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def someAbstractMethod(self):
        # no need to raise an exception here
        pass
</code></pre>
<p>Python 3.x</p>
<pre><code>class Base(metaclass=abc.ABCMeta):

    @abc.abstractmethod
    def someAbstractMethod(self):
        # no need to raise an exception here
        pass
</code></pre>
</div>
<span class="comment-copy">Yes, these classes are not mine. Thanks a lot for last way.</span>
<span class="comment-copy">@PiotrWasilewicz: you can always add the metaclass to your own derived classes still.</span>
<span class="comment-copy">Should I create subclass of "Subclass" class and add the metaclass there?</span>
<span class="comment-copy">@PiotrWasilewicz: I've added some more instructions.</span>
<span class="comment-copy">Thank you! This was helpful.</span>
<span class="comment-copy">I know, I didn't mention that these classes are not mine. But thanks.</span>
<span class="comment-copy">Then contact the author and point her/him to the ABC module's documentation...</span>
