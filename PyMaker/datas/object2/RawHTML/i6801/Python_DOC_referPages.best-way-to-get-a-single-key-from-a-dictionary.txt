<div class="post-text" itemprop="text">
<p>Having a python dictionary and knowing it is made of just one key/value pair, what's the best way to retrieve that single/unique item?</p>
<p>So far I know I could use one of these two ways:</p>
<ol>
<li><p><code>list(mydict.keys())[0]</code></p></li>
<li><p><code>next(iter(mydict))</code></p></li>
</ol>
<p>As far as I understand, <code>list</code> performances are worse than <code>iter</code> ones so the latter approach should be better, right? Which ways is best? There's something that's even better than the two way I indicated? Please let me know.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Which way is best? </p>
</blockquote>
<p>I recommend using <code>next(iter(d))</code> over <code>list(mydict.keys())[0]</code> to retrieve a key from a dictionary. As you suspected, using <code>next(iter(d))</code> is <em>much</em> better in terms of efficiency.</p>
<p>The efficiency difference can be observed by timing each method:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; setup='from string import ascii_letters; d = {k: v for k, v in enumerate(ascii_letters)}'
&gt;&gt;&gt; timeit.timeit(stmt='list(d.keys())[0]', setup=setup)
1.0895291733333334
&gt;&gt;&gt; timeit.timeit(stmt='next(iter(d))', setup=setup)
0.2682935466666656
</code></pre>
<p>The choice of using <code>next(iter(d))</code> over <code>list(d.keys())[0]</code> becomes very, <em>very</em> obvious as the size of the dictionary increases:</p>
<pre><code>&gt;&gt;&gt; setup='d = {k: v for k, v in enumerate(range(500, 10000))}'
&gt;&gt;&gt; timeit.timeit(stmt='list(d.keys())[0]', setup=setup)
98.52252842666667
&gt;&gt;&gt; timeit.timeit(stmt='next(iter(d))', setup=setup)
0.2720192000000452
</code></pre>
<p><code>next(iter(d))</code> performs so much better than <code>list(d.keys())[0]</code> mainly because it avoids creating a potential huge list of all of the dictionaries keys in memory, when it really only needs the first element.</p>
</div>
<div class="post-text" itemprop="text">
<p>To get the "first" key-value pair from a dictionary, you will have to use an <code>OrderedDict</code>:</p>
<pre><code>from collections import OrderedDict
d = OrderedDict()

#add items as normal

first_key = [a for a, b in d.items()][0]
print(d[first_key])
</code></pre>
</div>
<span class="comment-copy">There is no "first" when it comes to a dictionary, since its not ordered. Only keys are unique, and values can be duplicated without issue. Please describe the problem you are trying to solve here.</span>
<span class="comment-copy">How do you want to process the key/value pairs?  Using a <code>for</code> loop is a common way to iterate (in Python3).  You can use <code>for key, value in mydict.items():</code>.</span>
<span class="comment-copy">@BurhanKhalid In python3 dictionaries by default maintain insertion order. So technically, yes there is an order. If you add key/value for 'a' and then 'b' then 'c'. the .keys() operator should return them in that order.</span>
<span class="comment-copy">@Erich: This is only true since Python3.6, and this behaviour "should not be relied upon" <a href="https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation" rel="nofollow noreferrer">docs.python.org/3/whatsnew/3.6.html#new-dict-implementation</a></span>
<span class="comment-copy">@BurhanKhalid : I removed the word "first" from my question replacing it with "single" to avoid misunderstanding</span>
<span class="comment-copy">Ok, thank you. So <code>next(iter(d))</code> is better than <code>list(d.keys())[0]</code>; is it the best way for the purpose also?</span>
<span class="comment-copy">Thanks, I'll accept your answer then :-)</span>
<span class="comment-copy">"Less instructions" is at most very weakly correlated with "more efficient". The time taken to execute an instruction varies wildly, especially for instructions like CALL_FUNCTION.</span>
<span class="comment-copy">@user2357112 True. That is a good point. However, I also provided timings, and I believe that they provide a good idea of the efficiency of the two methods and help support my argument.</span>
<span class="comment-copy">The timings are good, as is the part where you actually talk about the giant unnecessary list that <code>next(iter(d))</code> doesn't create, but the part about "uses less instructions, and thus is more efficient" is an invalid inference. I'd recommend just removing the disassembly and the conclusions drawn from it.</span>
<span class="comment-copy">Thank you, I didn't know about OrderedDict</span>
