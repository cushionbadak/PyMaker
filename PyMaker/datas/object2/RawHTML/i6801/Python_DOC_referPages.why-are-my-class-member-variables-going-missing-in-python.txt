<div class="post-text" itemprop="text">
<p>I made a class. I think that I create a member variable named "myTup" in the initializer/constructor. I try to make sure that I actually did create myTup  by making the following call right at the very end of the initializer:</p>
<pre><code>assert(hasattr(self, 'myTup'))
</code></pre>
<p>However, later, the interpreter says that my instance/object doesn't have a member variable named "myTup."</p>
<p>Where did myTup go? Come back to me... please Q_Q</p>
<p>The following script is only long due to all of the little debug statements. Without the debugging, it's actually quite short and simple.</p>
<h2>Code:</h2>
<pre><code>import inspect
def lineno():
    # Returns the current line number in our program.
    return inspect.currentframe().f_back.f_lineno

class DemoClass:

    def __init__(self, initial_data):

        went_in = False # did not enter the if-elif-else block

        if isinstance(initial_data, str):
            print('line number:', lineno())
            t = tuple(initial_data)
            self = DemoClass(t)
            went_in = True        
        elif isinstance(initial_data, DemoClass):
            print('line number:', lineno())
            self = initial_data
            went_in = True
        elif isinstance(initial_data, tuple):
            print('line number:', lineno())
            self.myTup = initial_data
            went_in = True
        else:
            print('line number:', lineno())
            went_in = True
            assert(False)

        assert(hasattr(self, 'myTup'))
        print('line number:', lineno())
        print('went_in:', went_in)
        print('myTup:', self.myTup)

    def __str__(self):
        return "DemoClass" + str(self.myTup)

obj = DemoClass("s")
print(obj)
</code></pre>
<h2>Output:</h2>
<pre><code>line number: 13
line number: 22
line number: 31
went_in: True
myTup: ('s',)
line number: 31
went_in: True
myTup: ('s',)
Traceback (most recent call last):

  [... truncated / abridged ...]

  File "E:/awesome_folder_name/missing_member_var.py", line 36, in __str__
    return "DemoClass" + str(self.myTup)

AttributeError: 'DemoClass' object has no attribute 'myTup'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't replace the instance created in <code>__init__</code>. The following replaces only the <code>self</code> reference in the <code>__init__</code> method, <strong>not the previous instance that <code>self</code> was bound to</strong>:</p>
<pre><code>if isinstance(initial_data, str):
    # ...
    t = tuple(initial_data)
    self = DemoClass(t)
</code></pre>
<p>When <code>__init__</code> returns, the <code>obj = DemoClass("s")</code> line still bound the first instance, not the one you created with your recursive call. That first instance has no <code>myTup</code> attribute.</p>
<p>You'd have to call <code>self.__init__(t)</code> instead to operate on the same instance:</p>
<pre><code>if isinstance(initial_data, str):
    # ...
    t = tuple(initial_data)
    self.__init__(t)
</code></pre>
<p>This then calls <code>__init__</code> again, with the same instance bound, and thus will set <code>myTup</code> on the right object.</p>
<p>Note that I'd avoid using recursion here. There is no need, just set a tuple in the different branches and then assign <code>myTup</code> at the end:</p>
<pre><code>def __init__(self, initial_data):
    if isinstance(initial_data, str):
        initial_data = tuple(initial_data)
    elif isinstance(initial_data, DemoClass):
        initial_data = initial_data.myTup
    elif not isinstance(initial_data, tuple):
        raise ValueError('Invalid data')

    self.myTup = initial_data
</code></pre>
<p>If you must control what instance is returned when trying to create a new one with <code>DemoClass()</code>, then you can only do so with the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code> method</a>; it is responsible for producing the instance in the first place (after which the default implementation would call <code>__init__</code> on that new instance).</p>
</div>
<span class="comment-copy">Why do you redefine <code>self</code>?</span>
<span class="comment-copy">The line <code>self = DemoClass(t)</code> is your issue. Your code wants to overload <code>__init__()</code> to deal with different types for initial_data (which is fine), but don't try to recursively call <code>__init__</code> from itself, and never try to overwrite <code>self</code> anywhere inside an object or its methods.</span>
<span class="comment-copy">The whole <code>line_no</code>,<code>went_in</code> inspection code is wack, it just confuses things. You don't need an if-else ladder for handling multiple types for <code>initial_data</code>.</span>
<span class="comment-copy">You want to allow <code>DemoClass.__init__()</code> to be called with three different possibilities for <code>initial_data</code> : a string, a tuple, or an existing instance of DemoClass. This last one is weird: are you trying to copy or clone an object? (use copy()). There's no point in doing what you do: wrapping the given instance of DemoClass inside a new instance of DemoClass. You couldn't access its <code>initial_data</code> except by writing <code>obj. initial_data.initial_data</code></span>
<span class="comment-copy">You might find <a href="https://codereview.stackexchange.com/">CodeReview.SE</a> helpful</span>
