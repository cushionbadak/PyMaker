<div class="post-text" itemprop="text">
<p>I am reading <em>Fluent Python</em>. </p>
<p>Code 1-1, here it constructs a class with namedtuples and implements <code>__len__</code> and <code>__getitem__</code>. </p>
<pre><code>import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])


class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit) for rank in self.ranks for suit in self.suits]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]
</code></pre>
<p>but later the author uses random.choice to choose a card from deck</p>
<pre><code>from random import choice
deck = FrenchDeck()
choice(deck)
</code></pre>
<p>how is this working? I don't think deck is a sequence.</p>
</div>
<div class="post-text" itemprop="text">
<p>Implementing <code>__getitem__</code> makes your class iterable. Watch:</p>
<pre><code>&gt;&gt;&gt; class LegacyIterable(object):
...     def __init__(self):
...         self._list = ['a', 'b', 'c']
...     def __getitem__(self, item):
...         return self._list[item]
... 
&gt;&gt;&gt; x = LegacyIterable()
&gt;&gt;&gt; for e in x:
...     print e
... 
a
b
c
</code></pre>
<p>If a class does not have an <code>__iter__</code> method but a <code>__getitem__</code> method, Python, when forced to do so, constructs an iterator from an instance that tries to access its elements via <code>__getitem__</code>. It starts at index 0 and ends as soon as an <code>IndexError</code> is thrown.</p>
<p>However, since <code>LegacyIterable</code> instances don't have a <code>__len__</code> method, they formally don't count as sequences yet and <code>random.choice</code> would complain with</p>
<pre><code>TypeError: object of type 'LegacyIterable' has no len()
</code></pre>
<p>However, once we give it a <code>__len__</code> method instances count as sequences, and that's all that <code>random.choice</code> wants according to its documentation.</p>
<pre><code>&gt;&gt;&gt; LegacyIterable.__len__ = lambda x: 3
&gt;&gt;&gt; choice(LegacyIterable())
'c'
</code></pre>
<blockquote>
<p>choice(self, seq) method of random.Random instance<br/>
      Choose a random element from a non-empty sequence.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><code>random.choice</code> takes a random element from a non-empty <em>sequence</em>. If you implement <code>__getitem__</code>, <a href="https://docs.python.org/3.6/library/functions.html#iter" rel="nofollow noreferrer">python can use that to treat your object as a sequence by indexing</a> and that's what it does. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>deck</code> is indeed not a list, <strong>but</strong> as stated by <a href="https://docs.python.org/2/reference/datamodel.html" rel="nofollow noreferrer">documentation</a>, any object whose class implements <code>__getitem__</code> can be treated as a list-like object, e.g. <em>a sequence</em>. Since implementing <code>__getitem__</code> allows you things like <code>deck[i]</code>, you can call <code>choice(deck)</code> because what <code>choice(deck)</code> does is it generates a random number <code>i</code> betwen 0 and <code>len(deck)</code> and returns <code>deck(i)</code>.</p>
</div>
<span class="comment-copy">Python uses <a href="https://en.wikipedia.org/wiki/Duck_typing" rel="nofollow noreferrer">duck typing</a>: By giving your type a length and a way to access an item at an index, you <i>made</i> it <a href="https://docs.python.org/3/glossary.html#term-sequence" rel="nofollow noreferrer">a sequence</a>. So yes, <code>deck</code> is a sequence.</span>
<span class="comment-copy">Yes, wrong word used. I wanted to use list instead of sequence. Will correct my mistake, didn't even see it...</span>
