<div class="post-text" itemprop="text">
<p>I have a result list i.e</p>
<pre><code>result=[{u'faceRectangle': {u'width': 246, u'top': 196, u'height': 246, u'left': 113}},
        {u'faceRectangle': {u'width': 217, u'top': 213, u'height': 217, u'left': 614}}]
</code></pre>
<p>I can access each element by</p>
<pre><code>result[index]['faceRectangle']['width']
</code></pre>
<p>Now i want to run a for loop on this result list to save each output in different variable as
width1,top1,height1,left1,width2,top2,height2,left2</p>
<p>How to do so?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code> width = map(lambda x: x['faceRectangle']['width'], result)
 height = map(lambda x: x['faceRectangle']['height'], result)
 top = map(lambda x: x['faceRectangle']['top'], result)
 left = map(lambda x: x['faceRectangle']['left'], result)
</code></pre>
<p>And now you can access each value by index like width[0]</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you have the concept of "Rect" here, you could define a data structure to represent it, for instance a <code>class</code> or a <code>tuple</code>.</p>
<p>It is straightforward with a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuple</a>:</p>
<pre><code>import collections

Rect = collections.namedtuple('Rect', ['width', 'top', 'height', 'left'])
rect1 = Rect(**result[0]['faceRectangle'])
rect2 = Rect(**result[1]['faceRectangle'])

print(rect1)
print(rect1.width)
print(rect1.top)
print(rect1.height)
print(rect1.left)
print(rect2)
</code></pre>
<p>You get:</p>
<pre><code>Rect(width=246, top=196, height=246, left=113)
246
196
246
113
Rect(width=217, top=213, height=217, left=614)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As @jedwards pointed out in a comment, this is almost certainly a bad idea.</p>
<p>However, you can use <code>operator.itemgetter</code> to return a tuple of values. This would let you express your idea somewhat compactly:</p>
<pre><code>getvars = operator.itemgetter('height', 'left', 'top', 'width')

height1, left1, top1, width1 = getvars(result[1]['faceRectangle'])        
height2, left2, top2, width2 = getvars(result[2]['faceRectangle'])
</code></pre>
<p>Of course, this assumes that you know how many results there are, and that there are always the same number, and that you need to deal with them all at the same time.</p>
<p>You're probably much better off dealing with them one or two at a time, and using a variable as a reference to just the <code>faceRect</code> dictionary:</p>
<pre><code>r1 = result[1]['faceRectangle']
r2 = result[2]['faceRectangle']

if r1['width'] &lt; r2['width']:
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Similarly to <a href="https://stackoverflow.com/users/5636858/ingvar">@ingvar</a>'s <a href="https://stackoverflow.com/a/46122812/6209196">answer</a> you could use a list comprehension instead of a <code>map</code> with <code>lambda</code>, and this could be run in both Python 2 and 3.</p>
<pre><code>width = [element for element in result['faceRengtangle']['width']]
height = [element for element in result['faceRengtangle']['height']]
top = [element for element in result['faceRengtangle']['top']]
left = [element for element in result['faceRengtangle']['left']]
</code></pre>
<p>So, again, if you wanted to use the 2nd <code>result</code>'s <code>width</code> afterwards for example, you would access it with <code>width[1]</code> since indexes start counting from <code>0</code>.</p>
</div>
<span class="comment-copy">That's <i>really</i> not the best way to do whatever it is that it seems like you want to do (dynamically creating globals).  Maybe if you tell us more about what you're trying to do we can suggest a better approach?</span>
<span class="comment-copy">Actuallt length of list can reach upto 20..i want to handle each elememt and feed them in next line of code i.e                                                                rect =patches.Rectangle((left,top),width,heigth,linewidth=1,edgecolor='y',facecolor='none')</span>
<span class="comment-copy">So just process the whole list in a loop: <code>for x in result:</code></span>
<span class="comment-copy">Notice: <code>map()</code> function is a generator in Python 3, so your code won't work, because <code>width[0]</code> will fail.</span>
<span class="comment-copy">this question is about python27. in python3 this will not work ofc</span>
<span class="comment-copy">this one worked for my scenario...</span>
