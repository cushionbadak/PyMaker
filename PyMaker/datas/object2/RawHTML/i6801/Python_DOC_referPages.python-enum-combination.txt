<div class="post-text" itemprop="text">
<p>I would like to create a new Enum (IntEnum) class based on two existing ones. There is a working solution for this, like so:</p>
<pre><code>from enum import unique, IntEnum
from itertools import chain
from collections import OrderedDict

@unique
class FirstEnumClass(IntEnum):
    a = 1
    b = 2

@unique
class SecondEnumClass(IntEnum):
    c = 3
    d = 4

# here a combined class is created:
CombinedEnumClass = unique(IntEnum('CombinedEnumClass', OrderedDict([(i.name, i.value) for i in chain(FirstEnumClass, SecondEnumClass)])))
</code></pre>
<p>My question: is there a fancy way to achieve this, so that there is a proper class definition? Like overriding some of the metaclass methods, or so? I would like something like this, so that docstring can also be given:</p>
<pre><code>@unique
class CombinedEnumClass(IntEnum):
    """ docstring """
    # magic needed here
</code></pre>
<p>Any idea? Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>The library <a href="https://docs.python.org/3/library/enum.html#restricted-subclassing-of-enumerations" rel="nofollow noreferrer">prevents explicitly</a> to do that:</p>
<blockquote>
<p>Subclassing an enumeration is allowed only if the enumeration does not
  define any members.</p>
<p>Allowing subclassing of enums that define members would lead to a
  violation of some important invariants of types and instances. On the
  other hand, it makes sense to allow sharing some common behavior
  between a group of enumerations.</p>
</blockquote>
<p>Therefore, I found a <a href="https://stackoverflow.com/a/41807919/4530440">Stackoverflow answer</a> using almost the same workaround as you do. I think this is the only way.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python 2</strong></p>
<p>Using a trick with <code>vars()</code> this can be accomplished:</p>
<pre><code>class CombinedEnum(IntEnum):
    """ doc string """
    cls = vars()
    for member in chain(list(FirstEnumClass), list(SecondEnumClass)):
        cls[member.name] = member.value
    del member, cls

print(list(CombinedEnum))
</code></pre>
<p>This works because:</p>
<ul>
<li><code>vars()</code> returns the current namespace</li>
<li>modifying that namespace modifies the class</li>
</ul>
<p>We delete <code>member</code> and <code>cls</code> because we don't want them to become members.</p>
<hr/>
<p><strong>Python 3</strong></p>
<p>The above doesn't (yet) work with the new <code>Enum</code> in Python3 3.4 and 3.5 (not sure about 3.6).  The work-a-round is to use <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer"><code>aenum</code></a> instead, which allows us to tell <code>Enum</code> to ignore certain names:</p>
<pre><code>from aenum import IntEnum

class CombinedEnum(IntEnum):
    """ doc string """
    _ignore_ = 'member cls'
    cls = vars()
    for member in chain(list(FirstEnumClass), list(SecondEnumClass)):
        cls[member.name] = member.value
</code></pre>
<hr/>
<p><sup>1</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="nofollow noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer">Advanced Enumeration (<code>aenum</code>)</a>  library.</p>
</div>
<span class="comment-copy">You don't need the <code>OrderedDict</code>, you can give just the list comprehension.</span>
<span class="comment-copy">I know, it works that way, the thing is that I'm using PyCharm, and it gives a warning if just a list is given: "Expected type 'Integral', got 'List[Tuple[Any, Any]]' instead", and OrderedDict solved that. But true, it works without that. Anyways, I still cannot manage to do this like a class definition.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/33679930/how-to-extend-python-enum">How to extend Python Enum?</a></span>
<span class="comment-copy">Yeah, it seems like this is the only way. meanwhile I tried something like in <a href="https://stackoverflow.com/questions/32214614/automatically-setting-an-enum-members-value-to-its-name">this post</a>, to subclass the EnumMeta metaclass itself and play with its <code>__new__</code> method, but eventually all try runs into the same problem: <code>TypeError: Cannot extend enumerations</code>.</span>
<span class="comment-copy">It looks good, but it does not work for me: <code>File "C:\Anaconda3\lib\enum.py", line 66, in __setitem__  raise TypeError('Attempted to reuse key: %r' % key)  TypeError: Attempted to reuse key: 'member'</code>  I tried to skip the <code>cls[member.name] = member.value</code> line and write a <code>pass</code> instead, but still the same is raised. I use Python 3.5.2 with Anaconda3.</span>
<span class="comment-copy">I tried it in Python 2.7, and it works there. Do you know a way for Python 3.x?</span>
<span class="comment-copy">@waszil:  Thanks for finding that.  I added a Python 3 work around.</span>
<span class="comment-copy">@EthanFurman, so why did you [restrict subclassing of enumerations?]( <a href="https://docs.python.org/3/library/enum.html#restricted-subclassing-of-enumerations" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a>) in the first place. And what does <code>_ignore_</code> var is doing? Thanks for your libraries.</span>
<span class="comment-copy">@OwlMax:  subclassing added complications with equality and identity, and we didn't feel it was a net win to allow it; The <code>_ignore_</code> variable is telling the <code>Enum</code> metaclass to discard those names from the final enum class.</span>
