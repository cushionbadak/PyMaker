<div class="post-text" itemprop="text">
<p>I wrote a python code like this  (it shall convert table of unsigned values to table of bytes):</p>
<pre><code>def foo(in_value, index)
  TabOut[index*2] = in_value%255
  TabOut[index*2+1] = in_value//255



for i in range(0,1024):
  foo(tabIn[i],i)
</code></pre>
<p>I have to run this function 200 times per second. How to optimize it?</p>
</div>
<div class="post-text" itemprop="text">
<p>To go faster, you can use <a href="https://docs.python.org/3/library/functions.html#divmod" rel="nofollow noreferrer"><code>divmod</code></a> function:</p>
<pre><code>TabOut[index * 2 + 1], TabOut[index * 2] = divmod(value, 255)
</code></pre>
<p>You can also avoid calling a function:</p>
<pre><code>for i in range(1024):
    TabOut[index * 2 + 1], TabOut[index * 2] = divmod(tabIn[i], 255)
</code></pre>
<p>And use a classic iteration:</p>
<pre><code>for index, value in enumerate(tabIn):
    TabOut[index * 2 + 1], TabOut[index * 2] = divmod(value, 255)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>a different approach is to fill the resulting <code>tab</code> in one go using the <code>list</code> constructor:</p>
<pre><code>from itertools import chain

tab = list(chain.from_iterable((b, a)
           for a, b in (divmod(value, 255) for value in tab_in)))
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3.6/library/functions.html#divmod" rel="nofollow noreferrer"><code>divmod()</code></a> might help slightly.  But I feel like the fundamentals are flawed.  First, I don't see why you'd need to compute all 1024 calculations at once, and if for some reason you did, I don't see why you'd need to run through this more than once (why not cache it?), let alone 200x/sec.  And even if you could convince me that <i>that</i> was necessary, building the table "up" by multiplying and adding instead of dividing and subtracting seems faster.</span>
<span class="comment-copy">shame it has to be 255 not 256...dividing by 256 would be much faster. There's a potential trick to divide by 256 then multiply by (1 + 1/255) but with modern CPU I doubt you'd measure a difference.</span>
<span class="comment-copy">Actually I'm not sure why it's <code>%255</code>. Why don't you want to use the value 255? If there's some specific reason that might be useful context.</span>
<span class="comment-copy">If it turns out be be 256, it might be worth looking into the bitwise operators right shift and AND and comparing their speed to divmod.  It'd be orders of magnitude faster on microcontrollers, but I haven't ever needed the speed on a PC.</span>
<span class="comment-copy">i think you'd need to revert the order of the indices. the even ones collect the <code>%</code>; the odd ones the <code>//</code>.</span>
<span class="comment-copy">@hiroprotagonist: According to the documentation, the result is the same as <code>(a // b, a % b)</code>. So, yes I fix that.</span>
