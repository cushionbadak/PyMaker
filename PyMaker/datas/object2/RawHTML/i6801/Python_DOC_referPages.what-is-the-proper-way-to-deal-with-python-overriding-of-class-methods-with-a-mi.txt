<div class="post-text" itemprop="text">
<p>I'm having a minor, I hope, issue with theory and the proper way to deal with a problem. It's easier for me to show an example then to explain as I seem to fail with my vocabulary.</p>
<pre><code>class Original_1:
    def __init__(self):
        pass
    def meth1(self):
        pass
    def meth2(self):
        pass

class Original_2(Original_1):
    def __init__(self):
        Original_1.__init__(self)
    def meth3(self):
        pass

class Mixin:
    def __init__(self):
        pass
    def meth4(self):
        ...
        meth1(self)
        meth2(self)

class NewClass_1(Original_1, Mixin):
    def __init__(self):
        Original_1.__init__(self)
        Mixin.__init__(self)

class NewClass_2(Original_2, Mixin):
    def __init__(self):
        Original_2.__init__(self)
        Mixin.__init__(self)
</code></pre>
<p>Now the goal is to extend Original_1 or Original_2 with new methods in the Mixin, but I run into some questions if I use meth1(), meth2(), or meth3() in the mixin. 1. I'm not referencing Original_1 or Origninal_2 in the mixin. (At this point it runs but I don't like it.) 2. If I make Mixin a child of Original_1, it breaks. I could make two separate NewClass_X but then I'm duplicating all of that code. </p>
</div>
<div class="post-text" itemprop="text">
<p>Mixins are used to add functionality (usually methods) to classes by using multiple inheritance.</p>
<p>For example, let's say you want to make a class's <code>__str__</code> method return everything in uppercase. There are two ways you can do this:</p>
<ol>
<li><p>Manually change every single class's <code>__str__</code> method:</p>
<pre><code>class SomeClass(SomeBase):
    def __str__(self):
        return super(SomeClass, self).__str__().upper()
</code></pre></li>
<li><p>Create a mixin class that does only this and inherit from it:</p>
<pre><code>class UpperStrMixin(object):
    def __str__(self):
        return super(UpperStrMixin, self).__str__().upper()

class SomeClass(SomeBase, UpperStrMixin):
    ...
</code></pre></li>
</ol>
<p>In the second example, notice how <code>UpperStrMixin</code> is completely useless as a standalone class. Its only purpose is to be used with multiple inheritance as a base class and to override your class's <code>__str__</code> method.</p>
<p>In your particular case, the following will work:</p>
<pre><code>class Mixin:
    def __init__(self, option):
        ...

    def meth4(self):
        ...
        self.meth1()
        self.meth2()

class NewClass_1(Original_1, Mixin):
    def __init__(self, option):
        Original_1.__init__(self)
        Mixin.__init__(self, option)
        ...

class NewClass_2(Original_2, Mixin):
    def __init__(self, option):
        Original_2.__init__(self)
        Mixin.__init__(self, option)
        ...
</code></pre>
<p>Even though <code>Mixin.meth1</code> and <code>Mixin.meth2</code> aren't defined, this isn't an issue because an instance of <code>Mixin</code> is never created directly and it's only used indirectly through multiple inheritance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>Mixin</code> is not a standalone class, you can just write it to assume that the necessary methods exist, and it will find them on <code>self</code> assuming the <code>self</code> in question provides, or derives from another class which provides, <code>meth1</code> and <code>meth2</code>.</p>
<p>If you want to ensure the methods exist, you can either document it in the <code>Mixin</code> docstring, or for programmatic enforcement, use <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">the <code>abc</code> module</a> to make <code>Mixin</code> an <code>ABC</code> and specify what methods must be defined; if a given class doesn't provide them (directly or via inheritance) then you'll get an error if you attempt to instantiate it (because the class is still abstract until those methods are defined):</p>
<pre><code>from abc import ABCMeta, abstractmethod

class Mixin(metaclass=ABCMeta):
    def __init__(self):
        pass

    @abstractmethod
    def meth1(self): pass

    @abstractmethod
    def meth2(self): pass

    def meth4(self):
        ...
        self.meth1()  # Method call on self will dispatch to other class's meth1 dynamically
        self.meth2()  # Method call on self will dispatch to other class's meth2 dynamically
</code></pre>
<p>Beyond that, you can simplify your code significantly by <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">using <code>super</code></a> appropriately, which would remove the need to explicitly call the <code>__init__</code>s for each parent class; they'd be called automatically so long as all classes use <code>super</code> appropriately (note: for safety, in cooperative inheritance like this, you usually accept the current class's recognized arguments plus varargs, passing the varargs you don't recognize up the call chain blindly):</p>
<pre><code>class Original_1:
    def __init__(self, orig1arg, *args, **kwargs):
        self.orig1val = orig1arg           # Use what you know
        super().__init__(*args, **kwargs)  # Pass what you don't

    def meth1(self):
        pass

    def meth2(self):
        pass

class Original_2(Original_1):
    def __init__(self, orig2arg, *args, **kwargs):
        self.orig2val = orig2arg                 # Use what you know
        super().__init__(self, *args, **kwargs)  # Pass what you don't

    def meth3(self):
        pass

class Mixin(metaclass=ABCMeta):
    # If Mixin, or any class in your hierarchy, doesn't need to do anything to
    # be initialized, just omit __init__ entirely, and the super from other
    # classes will skip over it entirely
    def __init__(self, mixinarg, *args, **kwargs):
        self.mixinval = mixinarg                 # Use what you know
        super().__init__(self, *args, **kwargs)  # Pass what you don't

    @abstractmethod
    def meth1(self): pass

    @abstractmethod
    def meth2(self): pass

    def meth4(self):
        ...
        self.meth1()  # Method call on self will dispatch to other class's meth1
        self.meth2()  # Method call on self will dispatch to other class's meth1

class NewClass_1(Original_1, Mixin):
    def __init__(self, newarg1, *args, **kwargs):
        self.newval1 = newarg1                   # Use what you know
        super().__init__(self, *args, **kwargs)  # Pass what you don't

class NewClass_2(Original_2, Mixin):
    def __init__(self, newarg2, *args, **kwargs):
        self.newval2 = newarg2                   # Use what you know
        super().__init__(self, *args, **kwargs)  # Pass what you don't
</code></pre>
<p>Note that using <code>super</code> everywhere means you don't need to explicitly call each <code>__init__</code> for your parents; it automatically linearizes the calls, so for example, in <code>NewClass_2</code>, that single <code>super().__init__</code> will delegate to the first parent (<code>Original_2</code>), which then delegates to <code>Original_1</code>, which then delegates to <code>Mixin</code> (even though <code>Original_1</code> knows <em>nothing</em> about <code>Mixin</code>).</p>
<p>In more complicated multiple inheritance (say, you inherit from <code>Mixin</code> through two different parent classes that both inherit from it), using <code>super</code> is the only way to handle it reasonably; <code>super</code> naturally linearizes and deduplicates the parent class tree, so even though two parents derive from it, <code>Mixin.__init__</code> would still only be called once, preventing subtle errors from initializing <code>Mixin</code> more than once.</p>
<p>Note: You didn't specify which version of Python you're using. Metaclasses and <code>super</code> are both better and simpler in Python 3, so I've used Python 3 syntax. For Python 2, you'd need to set the metaclass a different way, and call <code>super</code> providing the current class object and <code>self</code> explicitly, which makes it less nice, but then, Python 2 is generally less nice at this point, so consider writing new code for Python 3?</p>
</div>
<span class="comment-copy"><i>At this point it runs but I don't like it.</i>: why? You can call <code>self.meth1()</code> within the mixin and it should work as you intend it to. I think you need to clarify what is wrong with the scenario where your code actually runs and why you don't like it.</span>
<span class="comment-copy">I've tried self.meth1() in the Mixin but as meth1() is defind in the Orginal_1 class, it doesn't exist in the Mixin unless I make it a child of Original_1. What I don't like is using a function/method in my mixin that has no definition except in a foreign class. There is no "unity" for lack of a better term. This became apparent to me when my IDE told me there was no definition of the method. Plus when I do make it a child of the base parent class, I get errors. <code>TypeError: module.__init__() takes at most 2 arguments (3 given)</code></span>
<span class="comment-copy">But that's what a mixin is. You usually don't create instances of mixins directly because they can't work standalone, they're only used to add functionality to other classes through multiple inheritance. If your mixin class only adds in a <code>meth4</code> method, remove <code>Mixin.__init__</code> and it should work fine. The limitations of your IDE are a different issue that shouldn't dictate your coding style to this degree.</span>
<span class="comment-copy">Thank You. It's nice to know I might have been on the right track. It just didn't feel 'right' to me, if you know what I mean.</span>
<span class="comment-copy">The reason I'm using NewClass_1.__init__(self, ...) is I need to add parameters to the "Mixin" class as part of the added functionality. Maybe I'm using the term mixin improperly. What I am attempting to accomplish is to add text scrolling functionality to Adafruit's library for LCD displays. It consists of a base class that is sub-classed for specific hardware. I then subclass the multiple HW specific classes, adding options and methods to scroll the text when a line is filled.</span>
<span class="comment-copy">@JamesKey: Can you post your rough implementation of the text scrolling and a link to the original library?</span>
<span class="comment-copy">My Library: <a href="https://bitbucket.org/jameslkey/lcdscroll" rel="nofollow noreferrer">link</a> go to source..LcdScroll/lcdscroll.py Original Library: <a href="https://github.com/adafruit/Adafruit_Python_CharLCD/tree/master/Adafruit_CharLCD" rel="nofollow noreferrer">link</a></span>
<span class="comment-copy">@JamesKey: I think renaming <code>LcdScroller</code> to <code>LcdScrollerMixin</code> and not inheriting from <code>Adafruit_CharLCD</code> is all you need. Otherwise, I don't see much else that you can do without just patching this functionality directly into the original library's code.</span>
<span class="comment-copy">Thank you very much!</span>
<span class="comment-copy">It is written in 3, and I now have an inkling of how super super() really is!</span>
