<div class="post-text" itemprop="text">
<p>Cufflinks provides an interface between Panda's <code>DataFrame</code> and plotly <code>iplot</code> in the form of <code>DataFrame.iplot</code>. The first two output examples below do not surprise me, but the third does. Each is run in a new instance of iPython3.</p>
<pre><code>import pandas as pd
pd.DataFrame.iplot

Out[1]: AttributeError: type object 'DataFrame' has no attribute 'iplot'  

import pandas as pd
import cufflinks as cf
pd.DataFrame.iplot

Out[1]: &lt;function cufflinks.plotlytools._iplot&gt;

import cufflinks as cf
import pandas as pd
pd.DataFrame.iplot

Out[1]: &lt;function cufflinks.plotlytools._iplot&gt;
</code></pre>
<p>In the first we see pd.DataFrame does not contain <code>iplot</code> by default. When cufflinks is imported after Pandas in the second example, it could easily add an extra method to the <code>DataFrame</code> class to provide additional functionality. However, in the third method the <code>DataFrame</code> class will be defined during the <code>import pandas</code> statement after <code>cufflinks</code> has been imported. How is the additional method still added? This is definitely convenient, as my understanding of how the middle example <em>could</em> work would require always importing the libraries in order, which is undesirable, so I would be interested to know the trick used here.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm fairly sure this is because python <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="nofollow noreferrer">caches</a> the modules it loads. For example, all of the below expressions are true:</p>
<pre><code>import sys.modules
import pandas as pd
import pandas as pds
print(pd is pds)
print(pd is sys.modules['pandas'])
print(pds is sys.modules['pandas'])
</code></pre>
<p>prints:</p>
<pre><code>True
True
True
</code></pre>
</div>
<span class="comment-copy">Cufflinks loads pandas inside own source code; <a href="https://github.com/santosjorge/cufflinks/blob/master/cufflinks/pandastools.py" rel="nofollow noreferrer">github.com/santosjorge/cufflinks/blob/master/cufflinks/â€¦</a></span>
<span class="comment-copy">This occurred to me as well, but even if I choose a different alias for pandas, i.e. <code>import pandas as pds</code> then I still find that <code>pds.DataFrame.iplot</code> exists as long as cufflinks was imported along the way.</span>
<span class="comment-copy">Nice, I did not know that! Based on your comment I tested the following: import a class A from module M, add a method f to class A, import module M as M2, and finally invoke M2.A().f(), which works correctly. This is very interesting behavior. It is convenient, but I could also imagine how it could cause some nasty bugs. In either case, I don't think this pattern occurs very often, but it is nice to know how it works.</span>
