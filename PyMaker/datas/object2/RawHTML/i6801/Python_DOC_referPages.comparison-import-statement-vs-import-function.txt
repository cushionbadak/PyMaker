<div class="post-text" itemprop="text">
<p>As a followup to the question <a href="https://stackoverflow.com/q/46173417/7051394">Using builtin <code>__import__()</code> in normal cases</a>, I lead a few tests, and came across surprising results.</p>
<p>I am here comparing the execution time of a classical <code>import</code> statement, and a call to the <code>__import__</code> built-in function.
For this purpose, I use the following script in interactive mode:</p>
<pre><code>import timeit   

def test(module):    
    t1 = timeit.timeit("import {}".format(module))
    t2 = timeit.timeit("{0} = __import__('{0}')".format(module))
    print("import statement:   ", t1)
    print("__import__ function:", t2)
    print("t(statement) {} t(function)".format("&lt;" if t1 &lt; t2 else "&gt;"))
</code></pre>
<p>As in the linked question, here is the comparison when importing <code>sys</code>, along with some other standard modules:</p>
<pre><code>&gt;&gt;&gt; test('sys')
import statement:    0.319865173171288
__import__ function: 0.38428380458522987
t(statement) &lt; t(function)

&gt;&gt;&gt; test('math')
import statement:    0.10262547545597034
__import__ function: 0.16307580163101054
t(statement) &lt; t(function)

&gt;&gt;&gt; test('os')
import statement:    0.10251490255312312
__import__ function: 0.16240755669640627
t(statement) &lt; t(function)

&gt;&gt;&gt; test('threading')
import statement:    0.11349136644972191
__import__ function: 0.1673617034957573
t(statement) &lt; t(function)
</code></pre>
<p>So far so good, <code>import</code> is faster than <code>__import__()</code>.
This makes sense to me, because as I wrote in the linked post, I find it logical that the <code>IMPORT_NAME</code> instruction is optimized in comparison with <code>CALL_FUNCTION</code>, when the latter results in a call to <code>__import__</code>.</p>
<p>But when it comes to less standard modules, the results reverse:</p>
<pre><code>&gt;&gt;&gt; test('numpy')
import statement:    0.18907936340054476
__import__ function: 0.15840019037769792
t(statement) &gt; t(function)

&gt;&gt;&gt; test('tkinter')
import statement:    0.3798560809537861
__import__ function: 0.15899962771786136
t(statement) &gt; t(function)

&gt;&gt;&gt; test("pygame")
import statement:    0.6624641952621317
__import__ function: 0.16268579177259568
t(statement) &gt; t(function)
</code></pre>
<p>What is the reason behind this difference in the execution times?
What is the actual reason why the <code>import</code> statement is faster on standard modules?
On the other hand, why is the <code>__import__</code> function faster with other modules?</p>
<p><em>Tests lead with Python 3.6</em></p>
</div>
<div class="post-text" itemprop="text">
<p><code>timeit</code> measures the total execution time, but the first import of a module, whether through <code>import</code> or <code>__import__</code>, is slower than subsequent ones - because it's the only one that actually performs module initialization. It has to search the filesystem for the module's file(s), load the module's source code (slowest) or previously created bytecode (slow but a bit faster than parsing the <code>.py</code> files) or shared library (for C extensions), execute the initialization code, and store the module object in <code>sys.modules</code>. Subsequent imports get to skip all that and retrieve the module object from <code>sys.modules</code>.</p>
<p>If you reverse the order the results will be different:</p>
<pre><code>import timeit   

def test(module):    
    t2 = timeit.timeit("{0} = __import__('{0}')".format(module))
    t1 = timeit.timeit("import {}".format(module))
    print("import statement:   ", t1)
    print("__import__ function:", t2)
    print("t(statement) {} t(function)".format("&lt;" if t1 &lt; t2 else "&gt;"))

test('numpy')
import statement:    0.4611093703134608
__import__ function: 1.275512785926014
t(statement) &lt; t(function)
</code></pre>
<p>The best way to get non-biased results is to import it once and then do the timings:</p>
<pre><code>import timeit   

def test(module):    
    exec("import {}".format(module))
    t2 = timeit.timeit("{0} = __import__('{0}')".format(module))
    t1 = timeit.timeit("import {}".format(module))
    print("import statement:   ", t1)
    print("__import__ function:", t2)
    print("t(statement) {} t(function)".format("&lt;" if t1 &lt; t2 else "&gt;"))

test('numpy')
import statement:    0.4826306561727307
__import__ function: 0.9192819125911029
t(statement) &lt; t(function)
</code></pre>
<p>So, yes, <code>import</code> is always faster than <code>__import__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Remember that all modules get cached into <code>sys.modules</code> after the first import, so the time...</p>
<p>Anyway, my results look like this:</p>
<pre><code>#!/bin/bash

itest() {
    echo -n "import $1: "
    python3 -m timeit "import $1"
    echo -n "__import__('$1'): "
    python3 -m timeit "__import__('$1')"
}

itest "sys"
itest "math"
itest "six"
itest "PIL"
</code></pre>
<ul>
<li><code>import sys</code>:  0.481</li>
<li><code>__import__('sys')</code>:  0.586</li>
<li><code>import math</code>:  0.163</li>
<li><code>__import__('math')</code>:  0.247</li>
<li><code>import six</code>:  0.157</li>
<li><code>__import__('six')</code>:  0.273</li>
<li><code>import PIL</code>:  0.162</li>
<li><code>__import__('PIL')</code>:  0.265</li>
</ul>
<p><a href="https://i.stack.imgur.com/tQ7QW.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/tQ7QW.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>What is the reason behind this difference in the execution times?</p>
</blockquote>
<p>The import statement has a pretty straighforward path to go through. It leads to <code>IMPORT_NAME</code> which calls <a href="https://github.com/python/cpython/blob/d056818ed2ade6d28190a375d7183f4aef9caa55/Python/ceval.c#L4876" rel="nofollow noreferrer"><code>import_name</code></a> and imports the given module (if no overriding of the name <code>__import__</code> has been made):</p>
<pre><code>dis('import math')
  1           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 (None)
              4 IMPORT_NAME              0 (math)
              6 STORE_NAME               0 (math)
              8 LOAD_CONST               1 (None)
             10 RETURN_VALUE
</code></pre>
<p><code>__import__</code>, on the other hand, goes through the generic function call steps that all functions do via <code>CALL_FUNCTION</code>:</p>
<pre><code>dis('__import__(math)')
  1           0 LOAD_NAME                0 (__import__)
              2 LOAD_NAME                1 (math)
              4 CALL_FUNCTION            1
              6 RETURN_VALUE
</code></pre>
<p>Sure, it's builtin and so faster than normal py functions but it is still slower than the <code>import</code> statement with <code>import_name</code>. </p>
<p>This is why, the difference in time between them is constant. Using @MSeifert snippet (that corrected the unjust timings :-) and adding another print, you can see this:</p>
<pre><code>import timeit   

def test(module):    
    exec("import {}".format(module))
    t2 = timeit.timeit("{0} = __import__('{0}')".format(module))
    t1 = timeit.timeit("import {}".format(module))
    print("import statement:   ", t1)
    print("__import__ function:", t2)
    print("t(statement) {} t(function)".format("&lt;" if t1 &lt; t2 else "&gt;"))
    print('Diff: {}'.format(t2-t1))


for m in sys.builtin_module_names:
    test(m)
</code></pre>
<p>On my machine, there's a constant diff of around 0.17 between them (with slight variance that's generally expected)</p>
<p><sub>*It is worth noting that these aren't <em>exactly</em> equivalent. <code>__import__</code> doesn't do any name binding as the bytecode attests.</sub></p>
</div>
<span class="comment-copy">I'm assuming the possibility of builtin modules being cached somewhere in advance.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ I did not want to drop the clue and influence potential answerers, but... Yes, I think that's related.</span>
<span class="comment-copy">I thought that <code>timeit</code> cleaned the context after execution... It appears I was wrong. So, the reason why <code>import</code> is faster than <code>__import__</code> actually is related to the <code>IMPORT_NAME</code> bytecode instruction?</span>
<span class="comment-copy">No, it doesn't. It just evaluates the setup multiple times which sort of represents the cleanup. However for imports: These are cached between runs (see for example <a href="https://gist.github.com/MSeifert04/f280314d5760bfefcb7a6160354b1aed" rel="nofollow noreferrer">this gist</a>.</span>
<span class="comment-copy">@Rightleg Once a module is loaded(locally or globally) it always stays in <code>sys.modules</code>, future imports simply fetch it from there(unless you delete it from <code>sys.modules</code>), hence no cleanup happens. A name lookup and function call are the reasons why <code>__import__</code> is slow.</span>
<span class="comment-copy">@Rightleg I'm not sure about the reason for the speed difference but yes a bytecode would be faster than looking up the name <code>__import__</code> and calling the function. Even if the function would just do the same as the bytecode. But there could also be loads of differences between the actual implementation of the bytecode and the function call. I mean the <a href="https://docs.python.org/3/library/functions.html#__import__" rel="nofollow noreferrer">function</a> takes a lot of parameters that the statement doesn't need.</span>
<span class="comment-copy"><code>import</code> also looks up the <code>__import__</code> name, because it has to check if <code>__import__</code> was replaced. If <code>__import__</code> hasn't been replaced, <code>import</code> gets to take a fast path, though.</span>
