<div class="post-text" itemprop="text">
<p>I was watching how to plot Histrogram using python and coming across this statement and I am not sure what it means or how it works.</p>
<pre><code>population_ages = [22,55,62,45,21,22,34,42,42,4,99,102,110,120,121,122,130,111,115,112,80,75,65,54,44,43,42,48]

ids = [x for x in range(len(population_ages))]
</code></pre>
<p>I am not sure how this statement works. I have tried watching videos on how len and range works but still unsure of how it applies to this statement.</p>
<pre><code>ids = [..... range(len(population_ages)] 
</code></pre>
<p>Thanks,</p>
</div>
<div class="post-text" itemprop="text">
<p><code>range(start_number, end_number)</code> creates a range of value from start_number to end_number so in your case, since the length of population_ages is 28, you'll have values that are <code>0,1,2...27</code></p>
<p><code>[x for x in ...]</code> simply gives you each value within a list. For example [x for x in 'Hello'] will make a list equal to <code>['H', 'e', 'l', 'l', 'o']</code>. <code>x</code> can be named anything. </p>
</div>
<div class="post-text" itemprop="text">
<p>It's called a list comprehension, and</p>
<pre><code>ids = [x for x in range(len(population_ages))]
</code></pre>
<p>is the same as</p>
<pre><code>ids = []
for x in range(len(population_ages)):
    ids.append(x)
</code></pre>
<p>Being able to spell it using only one line of code can often help readability.</p>
<p>In this case you'll often see people using <code>i</code> as the name of the variable, as in:</p>
<pre><code>for i in range(len(mylist)):
</code></pre>
<p>since <code>i</code> will be an integer getting the legal indexes into <code>mylist</code>, i.e. the half-open interval [0..len(mylist)&gt; meaning the first time <code>i</code> will get the value zero <code>0</code> and the last time it will get the length of the list - 1.</p>
</div>
<div class="post-text" itemprop="text">
<p>In your example:
<code>len(population_ages)</code>: computes the length of the list <code>population_ages</code>.</p>
<p><code>for x in range(len(population_ages)</code>: when you do a cycle like <code>for x in range(number)</code> you're indicating that the cycle will range from 1 to the <code>number</code>. In this case it will go from 1 to the length of your list which is 28.</p>
<p>In the expression <code>[x for x in range(number))]</code> the first x is taking the values that result from the evaluation of the loop, in your case it is going to be 1,2,3.....25. </p>
<p>If you wanted for example to show the same values of your list you should put something like this: </p>
<pre><code>ids = [x for x in population_ages)]
</code></pre>
<p>For more information about these topics you could read:</p>
<p><a href="https://docs.python.org/3/library/functions.html#len" rel="nofollow noreferrer">len_documentation</a>, <a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" rel="nofollow noreferrer">python-list-comprehensions</a></p>
<p>I hope this help you</p>
</div>
<div class="post-text" itemprop="text">
<p>Other answers already cover the basics.</p>
<p>I would like to add that the list comprehension in</p>
<pre><code>ids = [x for x in range(len(population_ages))]
</code></pre>
<p>is a specialization of</p>
<pre><code>[x for x in iterable]
</code></pre>
<p>which isn't really useful because</p>
<ul>
<li>it produces <code>x</code>, untransformed from the iterable</li>
<li>it produces something no matter what.</li>
</ul>
<p>list comprehension is more useful in cases like this:</p>
<pre><code>[f(x) for x in iterable if condition(x)]
</code></pre>
<p>If you <em>really</em> want a list out of this, it's even better &amp; faster to create it by passing the iterable through the <code>list</code> object:</p>
<pre><code>list(range(len(population_ages)))
</code></pre>
<p>(in python 2, <code>range(len(population_ages))</code> is even enough since it directly returns a <code>list</code>, but your code isn't portable to python 3 if you really need a subscriptable object.)</p>
<p>Also note that manipulating indexes is often a source of errors. Python has a lot of ways <em>not</em> to use indexes (unlike languages like C). A few examples:</p>
<ul>
<li>it can iterate on the values themselves</li>
<li>it can iterate on the indexes+values using <code>enumerate(iterable)</code></li>
<li>iterables of comparable sizes can be processed in parallel using <code>zip</code> or <code>itertools.zip_longest</code></li>
<li>there are built-in dictionaries</li>
</ul>
<p>so think hard before using indices. There are probably better ways.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's see:</p>
<p><code>population_ages</code> is the list with all the records.</p>
<p><code>len(population_ages)</code> returns the length of the list. The list <code>population_ages</code> has 28 elements, therefore <code>len(population_ages)</code> returns 28.</p>
<p><code>range(len(population_ages))</code>, which in this case is <code>range(28)</code>, returns <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]</code>. That's a list that contains all the possible indexes that you can use to access population_ages (you can evaluate <code>population_ages[0]</code>, <code>population_ages[1]</code>, ..., <code>population_ages[27]</code>; but from 28 and onwards, it will raise and <code>IndexError</code>).</p>
<p><code>[x for x in range(len(population_ages))]</code> generates a list, in which each element is each element in <code>range(len(population_ages))</code>. This step isn't changing anything, the result still is <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]</code>.</p>
<p>That's what's being saved as ids. I wouldn't know how your code uses it later, but that's step by step what that line is doing.</p>
</div>
<span class="comment-copy">Note that the <code>[x for x in ...]</code> "wrapper" is entirely superfluous is Python 2 and could be replaced with a simple <code>list(...)</code> in Python 3 (or just leave the <code>range</code> generator as is, depending on what you need it for). In other words, this is probably not very pythonic code.</span>
<span class="comment-copy">The end is <code>end_number-1</code>, so it goes to <code>27</code>.</span>
<span class="comment-copy">also <code>ids = list(range(len(population_ages))</code> avoids the comprehension.</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre or just <code>ids = range(len(population_ages))</code>, but neither of those are pedagogically preparing you for <code>enumerate(population_ages)</code>..</span>
<span class="comment-copy">yes, <code>range(len(x))</code> isn't very pythonic, unless you really want the indices and not the data. But that probably means that your data model has an issue.</span>
<span class="comment-copy">@thebjorn. Yes, we'll see <code>yield</code> in another lesson :)</span>
