<div class="post-text" itemprop="text">
<p>I want to change the <code>dir()</code> output for my class. Normally, for all other objects, it's done by defining own <code>__dir__</code> method in their class. But if I do this for my class, it's not called.</p>
<pre><code>class X(object):
    def __dir__():
        raise Exception("No!")

&gt;&gt;&gt;dir(X)
['__class__', '__delattr__', '__dict__',....
</code></pre>
<p>How can I change the <code>dir()</code> output for class?</p>
</div>
<div class="post-text" itemprop="text">
<p>That's because <code>dir</code> calls the <code>__dir__</code> of the type of the input (equivalent to: <code>type(inp).__dir__(inp)</code>). For instances of a class it will call the classes <code>__dir__</code> but if called on a class it will call the <code>__dir__</code> of the meta-class.</p>
<pre><code>class X(object):
    def __dir__(self):  # missing self parameter
        raise Exception("No!")

dir(X())  # instance!
# Exception: No!
</code></pre>
<p>So if you want to customize <code>dir</code> for your class (not instances of your class) you need to add a metaclass for your <code>X</code>:</p>
<pre><code>import six

class DirMeta(type):
    def __dir__(cls):
        raise Exception("No!")

@six.add_metaclass(DirMeta)
class X(object):
    pass

dir(X)
# Exception: No!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As @MSeifert already explained, <code>dir</code> calls the <code>__dir__</code> attrbiute of the object's class. So <code>type(X).__dir__</code> is called, not <code>X.__dir__</code>. Just for those that are interested, here is a look behinds the scenes of what exactly occurs.</p>
<p>The implementation of <code>dir</code> is in <a href="https://github.com/python/cpython/blob/master/Python/bltinmodule.c#L778" rel="nofollow noreferrer">bltinmodule.c</a>:</p>
<pre class="lang-c prettyprint-override"><code>builtin_dir(PyObject *self, PyObject *args)
{
    PyObject *arg = NULL;

    if (!PyArg_UnpackTuple(args, "dir", 0, 1, &amp;arg))
        return NULL;
    return PyObject_Dir(arg);
}
</code></pre>
<p>The <code>dir</code> function calls the API function <code>PyObject_Dir</code>. The <code>PyObject_Dir</code> function is implemented in <a href="https://github.com/python/cpython/blob/2ebc5ce42a8a9e047e790aefbf9a94811569b2b6/Objects/object.c#L1421" rel="nofollow noreferrer">object.c</a>:</p>
<pre class="lang-c prettyprint-override"><code>PyObject *
PyObject_Dir(PyObject *obj)
{
    return (obj == NULL) ? _dir_locals() : _dir_object(obj);
}
</code></pre>
<p><code>PyObject_Dir</code> is defined using two helper functions. When an object is passed in - as is the case here - then the <code>_dir_object</code> function is called. It is also implemented in <a href="https://github.com/python/cpython/blob/2ebc5ce42a8a9e047e790aefbf9a94811569b2b6/Objects/object.c#L1388" rel="nofollow noreferrer">object.c</a>:</p>
<pre class="lang-c prettyprint-override"><code>static PyObject *
_dir_object(PyObject *obj)
{
    PyObject *result, *sorted;
    PyObject *dirfunc = _PyObject_LookupSpecial(obj, &amp;PyId___dir__);

    assert(obj);
    if (dirfunc == NULL) {
        if (!PyErr_Occurred())
            PyErr_SetString(PyExc_TypeError, "object does not provide __dir__");
        return NULL;
    }
    /* use __dir__ */
    result = _PyObject_CallNoArg(dirfunc);
    Py_DECREF(dirfunc);
    if (result == NULL)
        return NULL;
    /* return sorted(result) */
    sorted = PySequence_List(result);
    Py_DECREF(result);
    if (sorted == NULL)
        return NULL;
    if (PyList_Sort(sorted)) {
        Py_DECREF(sorted);
        return NULL;
    }
    return sorted;
}
</code></pre>
<p>The part were focusing on is:</p>
<pre><code>PyObject *dirfunc = _PyObject_LookupSpecial(obj, &amp;PyId___dir__);
</code></pre>
<p>This is where the <code>__dir__</code> special method is looked-up on the object passed in. This is done using <code>_PyObject_LookupSpecial</code>. <code>_PyObject_LookupSpecial</code> is defined in <a href="https://github.com/python/cpython/blob/e3b2b4b8d9e751b49e3550cb83ba39b54fdc377c/Objects/typeobject.c#L1418" rel="nofollow noreferrer">typeobject.c</a>:</p>
<pre class="lang-c prettyprint-override"><code>PyObject *
_PyObject_LookupSpecial(PyObject *self, _Py_Identifier *attrid)
{
    PyObject *res;

    res = _PyType_LookupId(Py_TYPE(self), attrid);
    if (res != NULL) {
        descrgetfunc f;
        if ((f = Py_TYPE(res)-&gt;tp_descr_get) == NULL)
            Py_INCREF(res);
        else
            res = f(res, self, (PyObject *)(Py_TYPE(self)));
    }
    return res;
}
</code></pre>
<p><code>_PyObject_LookupSpecial</code> first calls <code>Py_TYPE</code> on the object passed in, before looking-up the attribute using <code>_PyType_LookupId</code>. <a href="https://github.com/python/cpython/blob/master/Include/object.h#L118" rel="nofollow noreferrer"><code>Py_TYPE</code> is a macro</a> that gets the <code>ob_type</code> member of objects. It's expanded form is:</p>
<pre><code>(((PyObject*)(o))-&gt;ob_type)
</code></pre>
<p>And as you probably guessed, The <a href="https://github.com/python/cpython/blob/master/Include/object.h#L112" rel="nofollow noreferrer"><code>ob_type</code> attribute is the class (or type) of the object</a>:</p>
<pre><code>typedef struct _object {
    _PyObject_HEAD_EXTRA
    Py_ssize_t ob_refcnt;
    struct _typeobject *ob_type;
} PyObject;
</code></pre>
<p>So, as you can see from above, the <code>__dir__</code> attribute used is indeed the object's class.</p>
</div>
<span class="comment-copy">See <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer"><i>Special method lookup</i></a>; <code>type(X).__dir__</code> is used, not <code>X.__dir__</code>.</span>
<span class="comment-copy">"Normally, for all other objects, it's done by defining own <code>__dir__</code> method in their class" - same with this object. You define a <code>__dir__</code> method in this class's class, a.k.a. its metaclass.</span>
<span class="comment-copy">It worked, thanks. But now I stuck inside <code>__dir__</code>, because in reality I don't want to <code>raise</code> anything, I just want to remove few methods (from unittest's inspection). But I couldn't find any way to get access to <code>cls</code> content. I knew, I shouldn't go into this forest...</span>
<span class="comment-copy">Oh, I found <code>cls.__dict__.keys()</code>. Exactly what I need.</span>
<span class="comment-copy">@GeorgeShuklin The alternative would be to use the inheritance from <code>type</code>. For example using <code>normal_dir = super().__dir__()</code> (this is what would be normally shown when you call <code>dir</code>) and then modify (add/remove stuff) the <code>normal_dir</code> before returning it. But <code>cls.__dict__.keys()</code> should also work. :)</span>
