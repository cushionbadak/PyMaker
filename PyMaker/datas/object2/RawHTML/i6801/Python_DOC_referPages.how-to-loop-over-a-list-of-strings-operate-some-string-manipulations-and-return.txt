<div class="post-text" itemprop="text">
<p>Here is the way I come up with:</p>
<pre><code>a = 'bats bear'
b = 'cats pear'

def sub_strings(a, b):
    for s in [a, b]:
        s = re.sub('\\b.ear\\b', '', s)  
    return a, b

a, b = sub_strings(a, b)
</code></pre>
<p>But that doesn't work at all, and the function still outputs the original strings <code>('bats bear', 'cats pear')</code>. What's wrong with this approach?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem you are having is that in Python, strings (i.e., <code>str</code> type objects) are immutable objects. Because a string object cannot be changed, ANY function you perform on a string <strong>never changes the original string</strong>. It <strong><em>ALWAYS</em></strong> remains the same:</p>
<pre><code>&gt;&gt;&gt; s = 'abc'
&gt;&gt;&gt; s.replace('abc', 'def') #  perform some method on s
&gt;&gt;&gt; print(s) #  has s been changed?
abc # NOPE
</code></pre>
<p>If you want to get a manipulated version of your string, you have to save the manipulated version somewhere and return <em>THAT</em>. The other answers that have been provided show clearly how to do this.</p>
<p>As for your actual problem, I would suggest using a generator. A generator is a function that behaves very differently from a normal function. One of these differences is the generator function is capable of generating multiple results- one at a time- with only a single function call.</p>
<p>To make a generator, instead of using the word <code>return</code>, you use <code>yield</code>. Here is an example:</p>
<pre><code>a = 'bats bear'
b = 'cats pear'

def sub_string_gen(*strings):
    for s in strings:
        yield re.sub('\\b.ear\\b', '', s)  

a, b = sub_strings(a, b) #  generator is "unpacked" here
</code></pre>
<p>Note that the <code>*strings</code> syntax allows the function to accept multiple arguments. The arguments are available inside your function under a list with the name <code>strings</code>.</p>
<p>The reason the above code works is that the last line auto-magically performs an UNPACKING of your executed generator. In other words, each result is yielded one at a time, and unpacked into the corresponding provided names one at a time.</p>
<p>Be careful, however, that you don't try to do THIS:</p>
<pre><code>a = sub_strings(a) #  BAD!
</code></pre>
<p>This will NOT work the way you expect. It will not work because <code>a = sub_strings(a)</code> does not <em>unpack</em> the generator; it instead <em>creates</em> a generator and <em>assigns</em> it to <code>a</code>; the generator has NOT been unpacked. Clarification on terminology: <code>sub_strings</code> is a <strong>generator function</strong>; <code>sub_strings(a,b,c)</code> <em>creates</em> a <strong>generator</strong> <em>using</em> that generator function.</p>
<p>To unpack the generator to a single name, do this instead:</p>
<pre><code>a, = sub_strings(a) #  Note the comma
</code></pre>
<p>The extra comma makes the <code>a</code> into a tuple of symbols instead of a singleton. This lets the interpreter know that you mean to "unpack" the generator into the lone symbol, <code>a</code>. </p>
<p>I like this syntax very much because it keeps you from making errors that are not always easy to see. For example, if you provide too many arguments to <code>sub_strings</code> but not enough variables, it will give you an error and let you know there is a problem:</p>
<pre><code>&gt;&gt;&gt; a, b = sub_strings(a, b, c) #  extra c argument
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: too many values to unpack (expected 2)
</code></pre>
<p>Another way to use your generator is to simply stuff the results into a list, a tuple, or anything else that accepts an iterable object (generators are iterable):</p>
<pre><code>&gt;&gt;&gt; results = list(sub_strings(a, b, c, d, e, f))
</code></pre>
<p>There is also another very nice alternative syntax that does the same thing. Here we see that star again (some people call it the "splat"). The splat "unpacks" the generator one value at a time, much the same as it was automatically unpacked before:</p>
<pre><code>&gt;&gt;&gt; results = [*sub_strings(a, b, c, d, e, f)]
</code></pre>
<p>Lastly: you don't even have to define a function to make a generator. You can instead just use what is called a <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression" rel="nofollow noreferrer">generator expression</a>. </p>
<pre><code>&gt;&gt;&gt; a, b = (re.sub('\\b.ear\\b', '', s)  for s in (a, b))
</code></pre>
<p>You can use such an expression in any of the places we used our generator above:</p>
<pre><code>&gt;&gt;&gt; results = list((re.sub('\\b.ear\\b', '', s)  for s in (a, b)))
&gt;&gt;&gt; results = [*(re.sub('\\b.ear\\b', '', s)  for s in (a, b))]
</code></pre>
<p>Observe that the part that is called <em>the generator expression</em> <strong>replaced</strong> the generator function call- which creates a generator- in the previous versions of the code.</p>
<p>However, if your goal is a <code>list</code> an even shorter syntax is just to use what is called a list comprehension:</p>
<pre><code>&gt;&gt;&gt; results = [re.sub('\\b.ear\\b', '', s)  for s in (a, b)]
</code></pre>
<p>There is much, MUCH more to learn about Python generators. Go <a href="https://wiki.python.org/moin/Generators" rel="nofollow noreferrer">here</a> to get started.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>s = re.sub('\\b.ear\\b', '', s) 
</code></pre>
<p>does not do what you think it does. It merely <em>rebinds</em> the variable named <code>s</code> to the modified string returned by <code>re.sub()</code>. It does not alter the variables <code>a</code> nor <code>b</code>. You can check that by printing out the value of <code>s</code> in the loop.</p>
<p>Instead you can return a generator:</p>
<pre><code>def sub_strings(a, b):
    return (re.sub(r'\b.ear\b', '', s) for s in (a, b))
</code></pre>
<p>A list comprehension will also work:</p>
<pre><code>def sub_strings(a, b):
    return [re.sub(r'\b.ear\b', '', s) for s in (a, b)]
</code></pre>
<p>Either way, the result will be unpacked into the variables <code>a</code> and <code>b</code> as required.</p>
<hr/>
<p>You might want to consider generalising the function so that it accepts an arbitrary number of parameters:</p>
<pre><code>def sub_strings(*args):
    return (re.sub(r'\b.ear\b', '', s) for s in args)
</code></pre>
<p>Now you can call it with any number of arguments:</p>
<pre><code>&gt;&gt;&gt; print(list(sub_strings('bats bear', 'cats pear', 'rats hear')))
['bats ', 'cats ', 'rats ']
&gt;&gt;&gt; print(list(sub_strings('bats bear', 'cats pear', 'rats hear', 'gnats rear')))
['bats ', 'cats ', 'rats ', 'gnats ']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this</p>
<pre><code>a = 'bats bear'
b = 'cats pear'

def sub_strings(a, b):
    result = []
    for s in [a, b]:
        result.append(re.sub('\\b.ear\\b', '', s)  )
    return result[0], result[1]

a, b = sub_strings(a, b)
</code></pre>
</div>
