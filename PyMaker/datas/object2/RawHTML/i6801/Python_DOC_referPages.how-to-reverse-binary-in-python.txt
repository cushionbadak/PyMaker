<div class="post-text" itemprop="text">
<p>So I am wondering if a binary string such as:  </p>
<pre><code>01001000 01100101 01101100 01101100 01101111 00100000 01001101 01101111 01101101 00100001 
</code></pre>
<p>(Hello Mom!)<br/>
can be reversed in the way that <strong><em>ALL</em></strong> <code>1</code>s turn into <code>0</code>s and vice verca in Python 3.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a="01001000 01100101 01101100 01101100 01101111 00100000 01001101 01101111 01101101 00100001"
a=a.replace('0','a').replace('1','0').replace('a','1')
</code></pre>
<p>You could use the replace function.</p>
<p>Output:</p>
<pre><code>'10110111 10011010 10010011 10010011 10010000 11011111 10110010 10010000 10010010 11011110'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use join with a generator, and replace the <code>'1'</code> with <code>'0'</code>s and vice versa, while keeping any character that is neither (a space in your example) unchanged:</p>
<pre><code>string = "01001000 01100101 01101100 01101100 01101111 00100000 01001101 01101111 01101101 00100001"
reverse = ''.join('0' if c=='1' else ('1' if c=='0' else c) for c in string)
print(reverse)
</code></pre>
<p>Outputs:</p>
<pre><code>10110111 10011010 10010011 10010011 10010000 11011111 10110010 10010000 10010010 11011110
</code></pre>
<p>As commented by @AChampion, you could shorten and improve the above code using:</p>
<pre><code>string = "01001000 01100101 01101100 01101100 01101111 00100000 01001101 01101111 01101101 00100001"
reverse = ''.join('10'[int(c)] if c in '01' else c for c in string)
print(reverse)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can split the binary string and use bitwise manipulation, e.g.:</p>
<pre><code>In []:
x = '01001000 01100101 01101100 01101100 01101111 00100000 01001101 01101111 01101101 00100001'
r = [format(int(n, 2) ^ 0xff, 'b') for n in x.split()]
r

Out[]:
['10110111', '10011010', '10010011', '10010011', '10010000',
 '11011111', '10110010', '10010000', '10010010', '11011110']
</code></pre>
<p>It's simple enough to join this back up:</p>
<pre><code>In []:
' '.join(r)

Out[]:
'10110111 10011010 10010011 10010011 10010000 11011111 10110010 10010000 10010010 11011110'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html?highlight=translate#str.translate" rel="nofollow noreferrer"><code>str.translate()</code></a> is very useful, and efficient, for this:</p>
<pre><code>bits = '01001000 01100101 01101100 01101100 01101111 00100000 01001101 01101111 01101101 00100001'

table = {ord('0'): '1', ord('1'): '0'}    # '0' -&gt; '1', '1' -&gt; '0'
inverted_bits = bits.translate(table)
print(inverted_bits)
</code></pre>
<p>Output:</p>
<pre>
10110111 10011010 10010011 10010011 10010000 11011111 10110010 10010000 10010010 11011110
</pre>
<p>This is also handy if you wanted to apply other transformations. For example the spaces could also be removed with this translation table:</p>
<pre><code>table = {ord('0'): '1', ord('1'): '0', ord(' '): None}
print(bits.translate(table))
</code></pre>
<p>Output:</p>
<pre>
10110111100110101001001110010011100100001101111110110010100100001001001011011110
</pre>
<p>Also, use <a href="https://docs.python.org/3/library/stdtypes.html?highlight=translate#str.maketrans" rel="nofollow noreferrer"><code>str.maketrans()</code></a> to create the translation table:</p>
<pre><code>&gt;&gt;&gt; table = str.maketrans('01', '10')
&gt;&gt;&gt; print(bits.translate(table))
10110111 10011010 10010011 10010011 10010000 11011111 10110010 10010000 10010010 11011110
</code></pre>
<p>or</p>
<pre><code>&gt;&gt;&gt; print(bits.translate(str.maketrans('01', '10', ' ')))
10110111100110101001001110010011100100001101111110110010100100001001001011011110
</code></pre>
</div>
<span class="comment-copy">That is called bitwise <code>xor</code> or <code>^</code> operator.</span>
<span class="comment-copy">@AChampion: Bitwise <code>xor</code> doesn't work on a string.</span>
<span class="comment-copy">@KenWhite You can just convert to <code>int(n, 2) ^ 0xff</code>.</span>
<span class="comment-copy">@AChampion: Yes, I'm aware. You didn't explain that; you suggested using <code>^</code> on a string, and I pointed out that will not work.</span>
<span class="comment-copy">I rolled back your edit. You <b>cannot</b> edit your post to ask an additional question, especially after this one has been answered. If you now have another question, first search this site <b>thoroughly</b> to see if it's been asked and answered before. If it has not, then click the <i>Ask Question</i> button and create a new post to ask it.</span>
<span class="comment-copy">Nice "workaround" method without getting into actual binary operators.</span>
<span class="comment-copy">Use <a href="https://docs.python.org/3/library/stdtypes.html?highlight=translate#str.translate" rel="nofollow noreferrer"><code>str.translate()</code></a> to avoid any "workaround" which requires that the string be processed 3 times.</span>
<span class="comment-copy"><code>''.join('10'[int(c)] for c in string)</code> would also work.</span>
<span class="comment-copy">@AChampion You're right, thanks, I included your suggestion in my answer.</span>
<span class="comment-copy">Can you please provide feedback if you vote down, it's helps!</span>
