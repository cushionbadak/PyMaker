<div class="post-text" itemprop="text">
<p>Python's callables are objects that have a <code>__call__</code> method.
They are most of the time functions, but might be class instances as well.</p>
<p>But it so happens that functions do have a <code>__call__</code> method.
Therefore, a <code>__call__</code> method has a <code>__call__</code> method as well.
The following REPL session shows that we can chain the <code>__call__</code>s:</p>
<pre><code>&gt;&gt;&gt; print
&lt;built-in function print&gt;

&gt;&gt;&gt; print.__call__
&lt;method-wrapper '__call__' of builtin_function_or_method object at 0x0000025E2D597F78&gt;

&gt;&gt;&gt; print.__call__.__call__
&lt;method-wrapper '__call__' of method-wrapper object at 0x0000025E2F631438&gt;

&gt;&gt;&gt; print.__call__.__call__.__call__
&lt;method-wrapper '__call__' of method-wrapper object at 0x0000025E2F5F85F8&gt;

&gt;&gt;&gt; print.__call__.__call__.__call__.__call__
&lt;method-wrapper '__call__' of method-wrapper object at 0x0000025E2F725DA0&gt; 
</code></pre>
<p>... and so on.
Remarkably, all these methods have different addresses.
In addition, they all have the same behaviour:</p>
<pre><code>&gt;&gt;&gt; print("a")
a
&gt;&gt;&gt; print.__call__("a")
a
&gt;&gt;&gt; print.__call__.__call__("a")
a
&gt;&gt;&gt; print.__call__.__call__.__call__("a")
</code></pre>
<p>So, when I write <code>print("a")</code>, what is actually called?
Is it <code>print</code>, or <code>print.__call__</code>?
And what if I define a <code>Foo</code> class with a <code>__call__</code> method?</p>
<p>Furthermore, how is it possible that every <code>__call__</code> method has its own <em>different</em> <code>__call__</code> method?
Could it be that they are in fact created when I tried to access them?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>print</code> is an instance of the class <code>builtin_function_or_method</code>:</p>
<pre><code>&gt;&gt;&gt; type(print)
builtin_function_or_method
</code></pre>
<p>As we all know (hopefully) when you access a method the instance is implicitly passed as first argument:</p>
<pre><code>&gt;&gt;&gt; type(print).__call__(print, 10)
10
&gt;&gt;&gt; print.__call__(10)  # equivalent
10
</code></pre>
<p>That means you actually have something like a bound method when you access <code>__call__</code> of a function. However bound methods (or in this case methodwrappers) are also instances of the type <code>method_wrapper</code>:</p>
<pre><code>&gt;&gt;&gt; type(print.__call__)
method-wrapper
</code></pre>
<p>So when you access the <code>__call__</code> method of that one it's again a "new" bound method.</p>
<pre><code>&gt;&gt;&gt; type(print.__call__).__call__(print.__call__, 10)  # equivalent
10
</code></pre>
<p>At this point it becomes recursive because a method of a method-wrapper is just another method-wrapper instance:</p>
<pre><code>&gt;&gt;&gt; type(print.__call__.__call__)
method-wrapper
</code></pre>
<p>However all that does it just creates a lot of "unnecessary" bound methods...</p>
</div>
<div class="post-text" itemprop="text">
<p>Like methods on classes, the <code>__call__</code> attribute is a <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer"><em>descriptor</em> object</a> defined on the type, bound to the object you looked it up on:</p>
<pre><code>&gt;&gt;&gt; type(print).__dict__['__call__']
&lt;slot wrapper '__call__' of 'builtin_function_or_method' objects&gt;
&gt;&gt;&gt; type(print).__dict__['__call__'].__get__(print)
&lt;method-wrapper '__call__' of builtin_function_or_method object at 0x10cc66f78&gt;
&gt;&gt;&gt; print.__call__
&lt;method-wrapper '__call__' of builtin_function_or_method object at 0x10cc66f78&gt;
</code></pre>
<p>The binding behaviour (through the <code>__get__</code> method) is how the resulting <code>method-wrapper</code> instance knows to pass in the <code>print</code> object as <code>self</code>, just like the instance gets passed into methods you defined on a custom Python class.</p>
<p>So yes, that means they are created on demand, and thus will have a unique id. They are otherwise just more instances of the same type.</p>
</div>
<span class="comment-copy">They have different addresses because they are descriptors, and are bound to the function object instance when accessed.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/q/32855927/846892">Close enough?</a></span>
