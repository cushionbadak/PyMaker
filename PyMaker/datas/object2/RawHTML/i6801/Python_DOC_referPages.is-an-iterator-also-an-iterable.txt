<div class="post-text" itemprop="text">
<p>I found that:</p>
<pre><code>&gt;&gt;&gt; a={'x':42, 'y':3.14, 'z':7}
&gt;&gt;&gt; b=a.__iter__()
&gt;&gt;&gt; b.__dir__()
['__next__', ..., '__iter__', ...]
&gt;&gt;&gt; b
&lt;set_iterator object at 0x7efdd4e5afc0&gt;
</code></pre>
<p>Does an iterator always have the <code>__iter__</code> method?</p>
<p>According to <a href="https://stackoverflow.com/a/9884259">https://stackoverflow.com/a/9884259</a> an iterator also an iterable. If it is true that an iterator always has <code>__iter__</code> method?</p>
</div>
<div class="post-text" itemprop="text">
<p>An iterable needs to implement an <a href="https://www.python.org/dev/peps/pep-0234/#python-api-specification" rel="noreferrer"><code>__iter__</code> method or a <code>__getitem__</code> method</a>:</p>
<blockquote>
<p>An object can be iterated over with <code>for</code> if it implements <code>__iter__()</code> or <code>__getitem__()</code>.</p>
</blockquote>
<p>An iterator needs a <code>__iter__</code> method (that returns <code>self</code>) and a <code>__next__</code> method (I'm not 100% sure about the <code>__next__</code>).</p>
<h2>it is true that an iterator always has <code>__iter__</code> method?</h2>
<p>Yes!</p>
<p>This is also documented in the <a href="https://docs.python.org/reference/datamodel.html#object.__iter__" rel="noreferrer">Data model</a>:</p>
<blockquote>
<p><code>object.__iter__(self)</code></p>
<p>This method is called when an iterator is required for a container. This method should return a new iterator object that can iterate over all the objects in the container. For mappings, it should iterate over the keys of the container.</p>
<p><strong>Iterator objects also need to implement this method; they are required to return themselves</strong>. For more information on iterator objects, see Iterator Types.</p>
</blockquote>
<p>(Emphasis mine)</p>
<p>As to your second question:</p>
<h2>Is an iterator also an iterable?</h2>
<p>Yes, because it has a <code>__iter__</code> method.</p>
<h3>Additional notes</h3>
<p>Besides the formal implementation it's easy to check if something is iterable by just checking if <code>iter()</code> can be called on it:</p>
<pre><code>def is_iterable(something):
    try:
        iter(something)
    except TypeError:
        return False
    else:
        return True
</code></pre>
<p>Likewise it's possible to check if something is an iterator by checking if <code>iter()</code> called on something returns itself:</p>
<pre><code>def is_iterator(something):
    try:
        return iter(something) is something  # it needs to return itself to be an iterator
    except TypeError:
        return False
</code></pre>
<p>But don't use them in development code, these are just for "visualization". Mostly you just iterator over something using <code>for ... in ...</code> or if you need an iterator you use <code>iterator = iter(...)</code> and then process the iterator by calling <code>next(iterator)</code> until it throws a <code>StopIteration</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>An iterator is iterable</strong>. And yes, an iterator always has an <code>__iter__</code> method.</p>
<p>Calling <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter</code></a> on an iterator, which summons the <code>__iter__</code> hook, returns the same iterator:</p>
<pre><code>&gt;&gt;&gt; it = iter([]) # return iterator from iterable
&gt;&gt;&gt; it is iter(iter(it)) is it.__iter__().__iter__().__iter__()
True
</code></pre>
<p>A classical example of <a href="https://en.wikipedia.org/wiki/Method_chaining" rel="nofollow noreferrer">method chaining</a>.</p>
<p>As you must have also noticed, most implementations of the iterator protocol for custom classes always follows:</p>
<pre><code>def __iter__(self):
    return self
</code></pre>
<p>That is if the iteration is not delegated to another iterator, via say <code>return iter(...)</code>.</p>
<p>It would be quite counter-intuitive for an <strong>iterator</strong> to not implement the <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__iter__" rel="nofollow noreferrer"><strong>iterator protocol</strong></a> don't you think? The <code>__iter__</code> implementation of the protocol is described below:</p>
<blockquote>
<pre><code>iterator.__iter__()
</code></pre>
<p>Return the iterator object <strong>itself</strong>. This is required to allow both
  containers and iterators to be used with the <code>for</code> and <code>in</code> statements.</p>
</blockquote>
<p>[<em>Emphasis mine</em>]</p>
<p>This behaviour is expectedly consistent with iterator objects returned by builtins:</p>
<pre><code>&gt;&gt;&gt; m = map(None, [])
&gt;&gt;&gt; m
&lt;map object at 0x...&gt;
&gt;&gt;&gt; m is m.__iter__().__iter__().__iter__()
True
</code></pre>
<p><sub>P.S: I apologise for calling dunders repeatedly; makes it look like it's the right thing to do. <a href="https://pastebin.com/C9fSH7eF" rel="nofollow noreferrer">But it's not</a>!</sub></p>
</div>
<div class="post-text" itemprop="text">
<p><strong>An iterator is iterable.</strong></p>
<p>That's documented and explained <a href="https://docs.python.org/3/glossary.html" rel="nofollow noreferrer">here</a>:</p>
<blockquote>
<p>Iterators are required to have an <code>__iter__()</code> method that returns the iterator object itself so <em>every iterator is also iterable</em></p>
</blockquote>
<p><strong>An iterable is not necessarily an iterator</strong></p>
<p>Iterators must have a <code>__next__</code> method, by definition.  To give a simple counterexample:</p>
<pre><code>&gt;&gt;&gt; ''.__next__
AttributeError: 'str' object has no attribute '__next__'
</code></pre>
<p>A string object is an iterable, but is not an iterator.   </p>
</div>
<span class="comment-copy">Yes, it always does. And it <i>should return <code>self</code></i>.</span>
<span class="comment-copy">Seriously, though, check out <a href="https://gist.github.com/juanarrivillaga/e6a68d70cbae3d2ca72f3d81f869d4f6" rel="nofollow noreferrer">this gist</a>. I think it should clear up some confusion with regards to for loops, what is an iterator, and what is an iterable.</span>
<span class="comment-copy">I think it's worth noting that sometimes people's language about iterators and iterables is the reverse of the actual protocol details. That is, if somebody says "X is an iterable", they may intend to exclude iterators (despite iterators always having an <code>__iter__</code> method and so being iterable in the official sense). There's no good single-word term for "non-iterator iterable", so some folks just use "iterable" for that, even though its not accurate. I elaborated a bit on this topic in <a href="https://stackoverflow.com/a/40324491/1405065">a previous answer</a>.</span>
<span class="comment-copy">Thanks. Which reference can I find "An iterable has an <b>iter</b> method or a <b>getitem</b> and <b>len</b> method"?  What are those iterables which don't have <code>__iter__</code>?</span>
<span class="comment-copy">@Ben I added some links :)</span>
<span class="comment-copy">Thanks. What are those builtin iterables which don't have <code>__iter__</code>?</span>
<span class="comment-copy">I don't think there are any. That's mostly used for user-defined sequence-like iterables.</span>
<span class="comment-copy">@Ben: In Python 2, <code>str</code> doesn't have an <code>__iter__</code>. I'm not aware of any built-in iterable types with no <code>__iter__</code> on Python 3.</span>
<span class="comment-copy">No. An iterator could have <code>__getitem__</code> instead of <code>__iter__</code> so this is not true.</span>
<span class="comment-copy">No, you're thinking about "iterables". "Iterators" always have a <code>__iter__</code> method.</span>
<span class="comment-copy">Ok - I'm clear. thanks.</span>
<span class="comment-copy"><i>This is required to allow both containers and iterators to be used with the for and in statements</i>  &lt;-- that seems to be a documentation bug.  A container can just implement <code>__contains__</code>, and then <code>__iter__</code> is <i>not</i> required for it to be used on the right hand side of <code>in</code> statement.</span>
<span class="comment-copy">@wim I think they mean the for-loop syntax: <code>for ... in ...</code> with "<code>for</code> and <code>in</code>". Not actually the <code>in</code> as in <code>contains</code>.</span>
<span class="comment-copy">Thanks. "A string object is an iterable, but is not an iterator. "  but <code>'abc'.__iter__</code> exists and <code>'abc'</code> is a string object. Do I miss something?</span>
<span class="comment-copy">Iterators return themself when <code>__iter__</code> is called. But strings return an <code>string_iterator</code> object. So it's iterable but not an iterator (it didn't return itself).</span>
<span class="comment-copy">@MSeifert Is <code>string_iterator</code> object not an iterator?</span>
<span class="comment-copy">@Ben <b>because to be an iterator it needs a <code>__next__</code> method</b>.</span>
<span class="comment-copy">@juanpa.arrivillaga No, they are really classes. Just try: <code>map.__iter__</code> and <code>map.__next__</code>. I'm not saying <code>open</code> or <code>iter</code> are iterators. Those two are truly factory functions that return iterators.</span>
