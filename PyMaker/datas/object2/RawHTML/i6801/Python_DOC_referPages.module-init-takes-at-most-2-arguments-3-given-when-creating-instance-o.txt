<div class="post-text" itemprop="text">
<p>I have a class named <code>Board</code> that acts as a superclass. 
It is basically a randomly generated Sudoku Board with 81 numbers placing correctly on it by the rules. </p>
<p>Then I defined a subclass named <code>normalSudoku</code> where it will be initialized with a parameter "difficulties"(a string) where it will decide how many empty entries will appear on the Sudoku.</p>
<p>When I created an instance of normalSudoku and try to print it out to see if it works, the following error pops out:</p>
<pre><code>TypeError: module.__init__() takes at most 2 arguments (3 given)
</code></pre>
<p>I am not sure what I did wrong and I am a bit confused about the use of <code>self</code> and object initialization in python. </p>
<p>My <code>Board</code> Class:</p>
<pre><code>class Board(object):    
    def __init__(self):
        self.sudoku = self.__create__()

    def __create__(self):
       #generateion of board goes here
       #it will return a 9x9 2d-list
</code></pre>
<p>My <code>normalSudoku</code> Class:</p>
<pre><code>import Board
import random

class normalSudoku(Board):
    def __init__(self,difficulties):
        Board.Board.__init__(self)
        self.Create_Empty_Entries(self,difficulties)

    def Create_Empty_Entries(self, difficulties):
        numbers = list(range(0,9))
        if difficulties == "Easy":
            for x in range(25):
                a = random.choice(numbers)
                b = random.choice(numbers)
                self.sudoku[a][b] = None
        elif difficulties == "Medium":
            for x in range(35):
                a = random.choice(numbers)
                b = random.choice(numbers)
                self.sudoku[a][b] = None
        elif difficulties == "Hard":
            for x in range(45):
                a = random.choice(numbers)
                b = random.choice(numbers)
                self.sudoku[a][b] = None
        elif difficulties == "Expert":
            for x in range(65):
                a = random.choice(numbers)
                b = random.choice(numbers)
                self.sudoku[a][b] = None
        else:
            print("The Level of Difficulty you chose does not exist.")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to create a subclass of a <strong>module</strong>, not your base class.</p>
<p>You import the module here:</p>
<pre><code>import Board
</code></pre>
<p>then try to subclass that directly:</p>
<pre><code>class normalSudoku(Board):
</code></pre>
<p><code>Board</code> is the module. If the class is named the same, it's an attribute on the module:</p>
<pre><code>class normalSudoku(Board.Board):
    def __init__(self,difficulties):
        Board.Board.__init__(self)
</code></pre>
<p>You already had the <code>__init__</code> call call correct, just not the base class reference.</p>
<p>Alternatively, import the class from the module:</p>
<pre><code>from Board import Board
</code></pre>
<p>and leave your <code>class</code> definition the same but adjust the <code>__init__</code> call:</p>
<pre><code>class normalSudoku(Board):
    def __init__(self,difficulties):
        Board.__init__(self)
</code></pre>
<p>Some other pointers:</p>
<ul>
<li><p>Don't use <code>__name__</code> dunder (double underscore) names. Those are <a href="https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers" rel="nofollow noreferrer">reserved by Python for future system use</a>, and thus can lead to forward compatibility issues.</p></li>
<li><p>Try to follow the <a href="https://www.python.org/dev/peps/pep-0008/#naming-conventions" rel="nofollow noreferrer">Python PEP 8 naming conventions</a>; it'll lead to more clarity. Modules are generally named using <code>lower_case_with_underscores</code> names, classes use <code>CamelCase</code>. Your module should be named <code>board</code>, the class <code>Board</code>, making the difference obvious. The same goes for methods; those should be lowercase too.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In addtition to <a href="https://stackoverflow.com/a/46130992/4832333">Martjin Pieters' answer</a>, your line 
<code>self.Create_Empty_Entries(self,difficulties)</code> is also incorrect, it should be <code>self.Create_Empty_Entries(difficulties)</code>.</p>
<p>Consider this :</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
    def foo(self):
        return self


&gt;&gt;&gt; print Foo
&lt;class '__main__.Foo'&gt;
&gt;&gt;&gt; instance = Foo()
&gt;&gt;&gt; print instance
&lt;__main__.Foo object at 0x02FFF7F0&gt;
&gt;&gt;&gt; print instance.foo() #as you can see, I don't pass any argument here
&lt;__main__.Foo object at 0x02FFF7F0&gt; #however you can note that internally, "instance" passed itself as "foo()" first argument
</code></pre>
</div>
<span class="comment-copy">Thank you very much for pointing out my mistakes! Your answer is really helpful. I have fixed all the errors now and had a better understanding of classes structure in python. :)</span>
<span class="comment-copy">yeah that too, I could say that when a class calls its member function, it automatically passes itself as its first argument right?</span>
<span class="comment-copy">Yup, but not quite : you've got it, but just be sure to make the difference between the class, and its instance. There are subtleties.  Your satement is correct if the method called is a "classmethod" (defined with the decorator <code>@classmethod</code>. For what you mean, you should say : When an instance calls its member method, it automatically passes itself as its first argument</span>
