<div class="post-text" itemprop="text">
<p>If I have a dictionary like:</p>
<pre><code>{ 'a': 1, 'b': 2, 'c': 3 }
</code></pre>
<p>How can I convert it to this?</p>
<pre><code>[ ('a', 1), ('b', 2), ('c', 3) ]
</code></pre>
<p>And how can I convert it to this?</p>
<pre><code>[ (1, 'a'), (2, 'b'), (3, 'c') ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; d = { 'a': 1, 'b': 2, 'c': 3 }
&gt;&gt;&gt; d.items()
[('a', 1), ('c', 3), ('b', 2)]
&gt;&gt;&gt; [(v, k) for k, v in d.iteritems()]
[(1, 'a'), (3, 'c'), (2, 'b')]
</code></pre>
<p>It's not in the order you want, but dicts don't have any specific order anyway.<sup>1</sup> Sort it or organize it as necessary.</p>
<p>See: <a href="http://docs.python.org/library/stdtypes.html#dict.items" rel="noreferrer">items()</a>, <a href="http://docs.python.org/library/stdtypes.html#dict.iteritems" rel="noreferrer">iteritems()</a></p>
<hr/>
<p>In Python 3.x, you would not use <code>iteritems</code> (which no longer exists), but instead use <code>items</code>, which now returns a "view" into the dictionary items. See the <a href="http://docs.python.org/release/3.0.1/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="noreferrer">What's New</a> document for Python 3.0, and the new <a href="http://docs.python.org/py3k/library/stdtypes.html#dictionary-view-objects" rel="noreferrer">documentation on views</a>.</p>
<p><sup>1: Insertion-order preservation for dicts was <a href="https://docs.python.org/3/whatsnew/3.7.html#summary-release-highlights" rel="noreferrer">added in Python 3.7</a></sup></p>
</div>
<div class="post-text" itemprop="text">
<p>since no one else did, I'll add py3k versions:</p>
<pre><code>&gt;&gt;&gt; d = { 'a': 1, 'b': 2, 'c': 3 }
&gt;&gt;&gt; list(d.items())
[('a', 1), ('c', 3), ('b', 2)]
&gt;&gt;&gt; [(v, k) for k, v in d.items()]
[(1, 'a'), (3, 'c'), (2, 'b')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use list comprehensions.</p>
<pre><code>[(k,v) for k,v in a.iteritems()] 
</code></pre>
<p>will get you <code>[ ('a', 1), ('b', 2), ('c', 3) ]</code> and </p>
<pre><code>[(v,k) for k,v in a.iteritems()] 
</code></pre>
<p>the other example.</p>
<p><a href="http://docs.python.org/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">Read more about list comprehensions</a> if you like, it's very interesting what you can do with them.</p>
</div>
<div class="post-text" itemprop="text">
<p><b>Create a list of namedtuples</b></p>
<p>It can often be very handy to use <b><a href="http://docs.python.org/library/collections.html#collections.namedtuple" rel="noreferrer">namedtuple</a></b>. For example, you have a dictionary of 'name' as keys and 'score' as values like:</p>
<pre><code>d = {'John':5, 'Alex':10, 'Richard': 7}
</code></pre>
<p>You can list the items as tuples, sorted if you like, and get the name and score of, let's say the player with the highest score (index=0) very Pythonically like this:</p>
<pre><code>&gt;&gt;&gt; player = best[0]

&gt;&gt;&gt; player.name
        'Alex'
&gt;&gt;&gt; player.score
         10
</code></pre>
<p>How to do this:</p>
<p><b>list in random order or keeping order of <a href="http://docs.python.org/library/collections.html#collections.OrderedDict" rel="noreferrer">collections.OrderedDict</a>:</b></p>
<pre><code>import collections
Player = collections.namedtuple('Player', 'name score')
players = list(Player(*item) for item in d.items())
</code></pre>
<p><b> in order, sorted by value ('score'):</b></p>
<pre><code>import collections
Player = collections.namedtuple('Player', 'score name')
</code></pre>
<p>sorted with lowest score first:</p>
<pre><code>worst = sorted(Player(v,k) for (k,v) in d.items())
</code></pre>
<p>sorted with highest score first:</p>
<pre><code>best = sorted([Player(v,k) for (k,v) in d.items()], reverse=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you want is <code>dict</code>'s <code>items()</code> and <code>iteritems()</code> methods. <code>items</code> returns a list of (key,value) tuples. Since tuples are immutable, they can't be reversed. Thus, you have to iterate the items and create new tuples to get the reversed (value,key) tuples. For iteration, <code>iteritems</code> is preferable since it uses a generator to produce the (key,value) tuples rather than having to keep the entire list in memory.</p>
<pre><code>Python 2.5.1 (r251:54863, Jan 13 2009, 10:26:13) 
[GCC 4.0.1 (Apple Inc. build 5465)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; a = { 'a': 1, 'b': 2, 'c': 3 }
&gt;&gt;&gt; a.items()
[('a', 1), ('c', 3), ('b', 2)]
&gt;&gt;&gt; [(v,k) for (k,v) in a.iteritems()]
[(1, 'a'), (3, 'c'), (2, 'b')]
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>[(k,v) for (k,v) in d.iteritems()]
</code></pre>
<p>and</p>
<pre><code>[(v,k) for (k,v) in d.iteritems()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By <code>keys()</code> and <code>values()</code> methods of dictionary and <code>zip</code>.</p>
<p><code>zip</code> will return a list of tuples which acts like an ordered dictionary.</p>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; d = { 'a': 1, 'b': 2, 'c': 3 }
&gt;&gt;&gt; zip(d.keys(), d.values())
[('a', 1), ('c', 3), ('b', 2)]
&gt;&gt;&gt; zip(d.values(), d.keys())
[(1, 'a'), (3, 'c'), (2, 'b')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre>
&gt;&gt;&gt; a={ 'a': 1, 'b': 2, 'c': 3 }

&gt;&gt;&gt; [(x,a[x]) for x in a.keys() ]
[('a', 1), ('c', 3), ('b', 2)]

&gt;&gt;&gt; [(a[x],x) for x in a.keys() ]
[(1, 'a'), (3, 'c'), (2, 'b')]
</pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>d = {'John':5, 'Alex':10, 'Richard': 7}
list = []
for i in d:
   k = (i,d[i])
   list.append(k)

print list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For Python3.x use</p>
<pre><code>for key, value in dict.items():
    temp = [key,value]
    dictlist.append(temp)
</code></pre>
<p>For Python 2.7 use </p>
<pre><code>for key, value in dict.iteritems():
    temp = [key,value]
    dictlist.append(temp)
</code></pre>
<p>Thanks</p>
</div>
<span class="comment-copy"><code>[tuple(reversed(x)) for x in d.items()]</code></span>
<span class="comment-copy">@garej: Given <code>x</code> is already a <code>tuple</code> in your code (it's the nature of <code>items</code> to produce an iterable of <code>tuple</code>s), it would be simpler/faster to just do <code>[x[::-1] for x in d.items()]</code>; the reversing slice directly constructs a reversed <code>tuple</code> of the proper size rather than having the <code>tuple</code> constructor iteratively populate (with overallocation and resizing at the end) a <code>tuple</code> from a <code>reversed</code> iterator.</span>
<span class="comment-copy">@ShadowRanger, you are right. I just wanted to be explicit that it is not always a need for <code>k, v</code> pattern in such cases.</span>
<span class="comment-copy">items() returns a dict_keys view in python3. Wrap this call with a cast to a list "list()". See @SilentGhost's reply</span>
<span class="comment-copy">"[(k,v) for (k,v) in d.iteritems()]" is a terrible equivalent to d.items()</span>
<span class="comment-copy">This worked for me as an alternative to <code>collections.OrderedDict()</code> that works better with multiple versions of Python HTTP Requests lib. Even though I dislike the <code>zip</code> function name as being somewhat vague/overloaded.</span>
<span class="comment-copy">Note the <code>zip</code>-ification is not a "deep" casting, i.e. if there are nested children, they wont be affected. You might have to roll your own recursion.</span>
<span class="comment-copy">Although this code may help to solve the problem, it doesn't explain <i>why</i> and/or <i>how</i> it answers the question. Providing this additional context  would significantly improve its long-term educational value. Please <a href="https://stackoverflow.com/posts/39097455/edit">edit</a> your answer to add explanation, including what limitations and assumptions apply.</span>
