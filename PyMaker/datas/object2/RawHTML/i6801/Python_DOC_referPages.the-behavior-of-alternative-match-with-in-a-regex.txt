<div class="post-text" itemprop="text">
<p>I seldom use | together with .* before. But today when I use both of them together, I find some results really confusing. The expression I use is as follows (in python):</p>
<pre><code>&gt;&gt;&gt; s = "abcdefg"
&gt;&gt;&gt; re.findall(r"((a.*?c)|(.*g))",s)
[('abc',''),('','defg')]
</code></pre>
<p>The result of the first caputure is all right, but the second capture is beyond my expectation, for I have expected the second capture would be "abcdefg" (the whole string).</p>
<p>Then I reverse the two alternatives:</p>
<pre><code>&gt;&gt;&gt; re.findall(r"(.*?g)|(a.*?c)",s)
[('abcdefg', '')]
</code></pre>
<p>It seems that the regex engine only reads the string once - when the whole string is read in the first alternative, the regex engine will stop and no longer check the second alternative. However, in the first case, after dealing with the first alternative, the regex engine only reads from "a" to "c", and there are still "d" to "g" left in the string, which matches ".*?g" in the second alternative. Have I got it right? What's more, as for an expression with alternatives, the regex engine will check the first alternative first, and if it matches the string, it will never check the second alternative. Is it correct?</p>
<p>Besides, if I want to get both "abc" and "abcdefg" or "abc" and "bcde" (the two results overlap) like in the first case, what expression should I use?</p>
<p>Thank you so much!</p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot have two matches starting from the same location in the regex (the only regex flavor that does it is Perl6). </p>
<p>In <code>re.findall(r"((a.*?c)|(.*g))",s)</code>, <code>re.findall</code> will grab all non-overlapping matches in the string, and since the first one starts at the beginning, ends with <code>c</code>, the next one can only be found after <code>c</code>, within <code>defg</code>.</p>
<p>The <code>(.*?g)|(a.*?c)</code> regex matches <code>abcdefg</code> because the regex engine parses the string from left to right, and <code>.*?</code> will get any 0+ chars as few as possible but up to the first <code>g</code>. And since <code>g</code> is the last char, it will match and capture the whole string into Group 1.</p>
<p>To get <code>abc</code> and <code>abcdefg</code>, you may use, say</p>
<pre><code> (a.*?c)?.*g
</code></pre>
<p>See the <a href="https://regex101.com/r/3W4SAq/1" rel="nofollow noreferrer">regex demo</a></p>
<p><a href="https://ideone.com/yUM1sB" rel="nofollow noreferrer">Python demo</a>:</p>
<pre><code>import re
rx = r"(a.*?c)?.*g"
s = "abcdefg"
m = re.search(rx, s)
if m:
    print(m.group(0)) # =&gt; abcdefg
    print(m.group(1)) # =&gt; abc
</code></pre>
<p>It might not be what you exactly want, but it should give you a hint: you match the bigger part, and capture a subpart of the string.</p>
</div>
<div class="post-text" itemprop="text">
<p>Re-read the docs for the <a href="https://docs.python.org/3/library/re.html?highlight=re%20findall#re.findall" rel="nofollow noreferrer"><code>re.findall</code></a> method.</p>
<p><code>findall</code> "return[s] all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found."</p>
<p>Specifically, <em>non-overlapping</em> matches, and <em>left-to-right</em>. So if you have a string <code>abcdefg</code> and one pattern will match <code>abc</code>, then any other patterns must (1) not overlap; and (2) be further to the right.</p>
<p>It's perfectly valid to match <code>abc</code> and <code>defg</code> per the description. It would be a bug to match <code>abc</code> and <code>abcdefg</code> or even <code>abc</code> and <code>cdefg</code> because they would overlap.</p>
</div>
<span class="comment-copy">You cannot have two matches starting from the same location in the regex. <code>re.findall</code> will grab all non-overlapping matches in the string, and since the first one starts at the beginning, ends with <code>c</code>, the next one can only be found after <code>c</code>, within <code>defg</code>.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ You know, the dupe reason is not correct (it is not the dupe of <a href="https://stackoverflow.com/questions/6018340/capturing-group-with-findall">Capturing group with findall?</a> question).</span>
<span class="comment-copy">@WiktorStribiżew Apologies, read the first few sentences and reacted.</span>
<span class="comment-copy">Thank you for your answer! I use this expression because I am now working on a classical text, each line (paragraph) containing some sentences with annotations in brackets and some without annotations. So I use r"(.*?)(\(.*?\))|(.*?)$" to grab all the sentences with and without annotations in each line.  Actually I really want (.*?)$ in the second alternative to match the rest of the string rather than the whole, but I don't know whether it is just a coincidence which may be broken somewhere, or it's a built-in feature. Now I know that it's a safe behavior which I could rely on. Thanks!</span>
<span class="comment-copy">You know, the fact that <code>abc</code> and <code>abcdefg</code> overlap is of minor importance since overlapping string that do not start at the same location can be caught with a regex using lookaheads, but the problem here is that they start at the same location in string.</span>
<span class="comment-copy">Now I see! Thank you for your answer!</span>
