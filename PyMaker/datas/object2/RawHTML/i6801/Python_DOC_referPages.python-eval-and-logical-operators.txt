<div class="post-text" itemprop="text">
<p>I have a JSON "database" - it's a python list of JSON objects:</p>
<pre><code>[{'_id': 'TRANSACTION0', 'Offer': {'From': 'merchant1', 'To': 'customer1', 'Item': 'Car', 'Price': 1000, 'Timestamp': 2}, 'Accept': {'Quantity': 1, 'Address': '123 Fake Street', 'Timestamp': 5}},
{'_id': 'TRANSACTION1', 'Offer': {'From': 'merchant1', 'To': 'customer2', 'Item': 'Computer', 'Price': 500, 'Timestamp': 5}},
{'_id': 'TRANSACTION2', 'Offer': {'From': 'merchant3', 'To': 'customer3', 'Item': 'Garbage bin', 'Price': 10, 'Timestamp': 0}, 'Accept': {'Quantity': 2, 'Address': '456 MadeUp Road', 'Timestamp': 1}},
{'_id': 'TRANSACTION3', 'Offer': {'From': 'merchant2', 'To': 'customer1', 'Item': 'Car', 'Price': 2000, 'Timestamp': 3}, 'Accept': {'Quantity': 2, 'Address': 'The White House', 'Timestamp': 3}},
{'_id': 'TRANSACTION4', 'Offer': {'From': 'merchant3', 'To': 'customer3', 'Item': 'Pens', 'Price': 2, 'Timestamp': 0}, 'Accept': {'Quantity': 4, 'Address': 'Houses of Parliment', 'Timestamp': 1}},
{'_id': 'TRANSACTION5', 'Offer': {'From': 'merchant4', 'To': 'customer1', 'Item': 'Headphones', 'Price': 200, 'Timestamp': 4}},
{'_id': 'TRANSACTION6', 'Offer': {'From': 'merchant1', 'To': 'customer2', 'Item': 'Water Bottle', 'Price': 1, 'Timestamp': 1}, 'Accept': {'Quantity': 3, 'Address': 'Timbuktu', 'Timestamp': 14}},
{'_id': 'TRANSACTION7', 'Offer': {'From': 'merchant2', 'To': 'customer3', 'Item': 'Laptop', 'Price': 900, 'Timestamp': 0}},
{'_id': 'TRANSACTION8', 'Offer': {'From': 'merchant4', 'To': 'customer1', 'Item': 'Chair', 'Price': 80, 'Timestamp': 3}, 'Accept': {'Quantity': 1, 'Address': 'Mordor', 'Timestamp': 3}},
{'_id': 'TRANSACTION9', 'Offer': {'From': 'merchant3', 'To': 'customer3', 'Item': 'Garbage bin', 'Price': 5, 'Timestamp': 2}, 'Accept': {'Quantity': 2, 'Address': 'The wall', 'Timestamp': 2}}]
</code></pre>
<p>My intention is to use queries, which will be stored in dictionaries, against this database. In this example, the dictionary contains:</p>
<pre><code>a_dict = {"query1": "'Offer' and 'Accept'"}
</code></pre>
<p>Note that the dictionary will contain more queries, and also more complicated queries (e.g. <code>(cond1 and cond2) or (cond2 and cond3)</code>), but I need to understand why Python is doing what it's doing (and how to overcome it) as opposed to solely what the solution is.</p>
<p>I need to have something which evaluates and runs <code>query1</code> correctly. My wrongful implementation is currently:</p>
<pre><code>if (eval(a_dict["query1"]) + "in i"):
</code></pre>
<p>This is the same as:</p>
<pre><code>if 'Offer' and 'Accept' in i:
</code></pre>
<p>Due to short-circuiting, this evaluates to only checking whether <code>Accept</code> is in <code>i</code>. In this example, everytime there is an <code>Accept</code> there is an <code>Offer</code>, but this may not always be the case.</p>
<p>A rightful if statement would be:</p>
<pre><code>if 'Offer' in i and 'Accept' in i:
</code></pre>
<p>However, this isn't easily composable from the type of potential queries I would have. Ideally, I'd like to have an elegant solution which was "plug and play", similar to my <code>eval</code> if statement given above.</p>
<p>Is there anyway to be able take a particular query from a dictionary, plug that into an <code>if</code> statement, and then run that <code>if</code> statement as I'm intending (under the assumption that all the queries make logical sense)?</p>
<p><a href="https://www.python.org/dev/peps/pep-0308/" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-0308/</a> This article says FAQ 4.16 gives alternatives, but I can't seem to find it anywhere</p>
</div>
<div class="post-text" itemprop="text">
<p>Please don't use eval to do queries. This is guaranteed to blow up in your face when you don't expect it. Maybe you've heard of SQL injections; the security implications of using eval to build queries are huge.</p>
<h2>A filter-based query system</h2>
<p>Instead, begin by writing filter functions for common queries. This will also solve your problem and provide a "plug-and-play" way to compose queries.</p>
<p>Here's a pointer as to how to implement it:</p>
<p>Think of a query as a function which takes as arguments a few literal values (and, implicitly, a set of records), and returns a resultset of records. Ditching the list and using the <code>set</code> datatype for the resultset, keyed by your record id, will increase performance a lot.</p>
<p>Then an "AND" becomes a function which takes two (or more) sets of records and builds the set intersection of them, and an "OR" becomes a function which takes two (or more) sets of records and builds the union of them. (NOT would be the set difference between the whole set of records and one or more subsets).</p>
<p>If you build your functions this way, a query will become a simple tree of function calls, such as:</p>
<pre><code>result = q_and(q_or(q_merchant_is('merchant2'), 
                    q_address_is('123 FakeStreet')), 
               q_quantity_above(3))
</code></pre>
<p>(Formatted for better legibility)</p>
<p>It's not that hard to write a parser for a simple query language that will build such a query, but if you don't need to provide a frontend for endusers, you might not need your own query language because the python representation of the query as seen above is simple and clear enough. And if you do need to represent your queries as dictionaries, well, if you choose a structure that closely mimicks the final structure of the query call tree, it's trivial to write a <code>query_builder</code> function that turns one of your dict queries into a function that will run the tree of query function calls when called.</p>
<p>Note: As you can see, <code>q_merchant_is</code>, <code>q_quantity_above</code> etc don't take a set of records to filter. You can fix this by making a Query class and set the full set as an instance attribute, so that each query method has access to the full recordset if it needs it:</p>
<pre><code>class Query(object):
    def __init__(self, all_records):
        self.records = all_records

    def merchant_is(self, name):
        result = set()
        for record in self.records:
            if record['Offer']['From'] == name:
               result.add(record['_id'])
        return result

    def q_and(self, *args):
        result = args[0]
        for i in range(1, len(args)):
            result = args[i].intersection(result)
        return result
    ...

q = Query(my_full_record_set)
result = q.q_and(q.q_or(q.merchant_is('merchant2').........))    
</code></pre>
<h3>Performance and indices</h3>
<p>You see that each query function that queries for a literal value basically scans over the whole dataset to filter it. If your query contains many such searches for literal parts, you'll scan your dataset multiple times. For large datasets, this can become prohibitive.</p>
<p>A simple solution would be to index the fields you want to query against in one dict per field. This would speed up the query by orders of magnitude, but if your data changed, you'd need to make sure to keep the indices up to date.</p>
<h1>Classifier query system</h1>
<p>Another solution would be to build your query functions as classifiers instead of filters, meaning that <code>merchant_is</code> would take a literal value and a record and answer True or False, depending on whether the record contained that literal value in the right field. We could make this all work efficiently by having factory functions which build a composite query.</p>
<p>The example query from the filter section would then become:</p>
<pre><code>query = q_and(q_or(q_merchant_is('merchant2'),
                   q_address_is('123 FakeStreet')),
              q_quantity_above(3))
result = perform_query(query, all_my_records)
</code></pre>
<p><code>q_merchant_is</code> would turn into the following:</p>
<pre><code>def q_merchant_is(literal):
    return lambda record: record['Orders']['From'] == literal
</code></pre>
<p>Note how you're returning a function that, when called with a record, 
will classify it.</p>
<p><code>q_or</code> might look like this:</p>
<pre><code>def q_or(*args):
    def or_template(record):
        for classifier in args:
            if classifier(record):
                return True
        return False
    return or_template
</code></pre>
<p>or a bit terser (I'm not sure whether this is more efficient or not):</p>
<pre><code>def q_or(*args):
    return lambda record: any([ classifier(record) for classifier in args])
</code></pre>
<p><code>q_or</code> now returns a function that runs a number of classifiers against the record passed as an argument and returns True if at least one of the classifiers returns True. <code>q_and</code> works just like <code>q_or</code> except that it only returns True if every classifier returns True. And <code>q_not</code> would simply return True if it's classifier returned False, and vice versa.</p>
<p>Now all you need is:</p>
<pre><code>def perform_query(query, all_records):
    return filter(query, all_records)
</code></pre>
<p>This will only iterate over your dataset a single time and is pretty much as efficient as it can get in python without involving eval, compile and exec, but it's somewhat harder to understand than the filter approach.</p>
<blockquote>
<p>However, this isn't easily composable from the type of potential queries I would have. Ideally, I'd like to have an elegant solution which was "plug and play"</p>
</blockquote>
<p>With both the filter and the classifier systems, it is easy to extend the system with new query elements. In the filter example, you add a method to your Query class. In the classifier example, you add a query function builder like the one I wrote for <code>q_merchant_is</code>. Usually that involves two lines of python code.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no function or module that will automagically parse your queries the way you want. You'll have to write your own parser and implement the evaluation logic yourself.</p>
<p>There are modules that can help you parse the query string; for example <a href="https://pypi.python.org/pypi/pyparsing" rel="nofollow noreferrer">pyparsing</a>. If the query syntax isn't overly complex, you can probably also implement your own parser with simple string operations or perhaps with the <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">regex module</a>.</p>
<p>Whatever you end up using:
<a href="https://stackoverflow.com/questions/1832940/why-is-using-eval-a-bad-practice"><strong>Do</strong></a> <a href="https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow noreferrer">not</a> <a href="https://softwareengineering.stackexchange.com/questions/311507/why-are-eval-like-features-considered-evil-in-contrast-to-other-possibly-harmfu/311510">use</a> <a href="https://stackoverflow.com/questions/1933451/why-should-exec-and-eval-be-avoided"><code>eval</code></a>.</p></div>
<div class="post-text" itemprop="text">
<p>I really doubt you will find a simple "plug and play" solution here. The best you could do would be to implement a proper minilanguage (parser &amp; interpreter) for your queries. </p>
<p>The good news is that it might not be <em>that</em> difficult. If you already have working experience writing parsers and interpreters / compiler then python has no shortage of builtin and 3rd part tools, pick one and go. </p>
<p>Else  there's <a href="https://ruslanspivak.com/lsbasi-part1/" rel="nofollow noreferrer">an excellent python tutorial on Ruslan Pivack's blog named "let's build a simple interpreter"</a> that will guide you thru the whole process of creating a simple Pascal parser and interpreter in Python, explaining the terminology etc.</p>
</div>
<span class="comment-copy">"it's a python list of JSON objects:" : nope, it's a python list of python dicts. JSON is a text format, so there's nothing like a "json object" in any language.</span>
<span class="comment-copy">can you explain your problem</span>
