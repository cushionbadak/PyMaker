<div class="post-text" itemprop="text">
<p>I am trying to create a cd (in terminal) type functionality using python program.</p>
<p>here the root path is "/" and path seperator is also "/"</p>
<pre><code>old_path = Path('/a/b/c/d')
</code></pre>
<p>Here Path is a class which has two methods</p>
<pre><code>class Path:
    def __init__(self, path):
        self.current_path = path

    def cd(self, new_path):
        pass
</code></pre>
<p>How can i create a functionality such that i can use</p>
<pre><code>path.cd('../x')
</code></pre>
<p>to change the directory just like the functionality we get when we use cd in terminal. </p>
<pre><code>class Path:
    def __init__(self, path):
        self.current_path = path

    def cd(self, new_path):
        pass

path = Path('/a/b/c/d')
path.cd('../x')
print(path.current_path)
</code></pre>
<p>When i print this i am getting</p>
<pre><code>/a/b/c/d
</code></pre>
<p>But i need to get output as</p>
<pre><code>/a/b/c/x/
</code></pre>
<p>Showing the new path.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should do the job:</p>
<pre><code>class Path:
    def __init__(self, path):
        self.current_path = path

    def cd(self, new_path):
        new_split = new_path.split("/")
        old_split = self.current_path.split("/")
        for i in new_split:
            if i == "..":
                new_split.pop(0)
                old_split = old_split[:-1]
        old_split += new_split
        self.current_path = "/".join(old_split)
</code></pre>
<p>What my implementation of <code>cd</code> does is it splits both the current and the new path into lists, using <code>/</code> as a delimiter. Then, for every <code>..</code> in the path, it removes the last element of the current path list, effectively going up one level in the directory tree. The <code>..</code> is also removed from the new path list. Finally, what remains of the two lists is joined together, and the result is the new path.</p>
<p>Even better would be if you modified Path to store the current path as a list, instead of converting in <code>cd</code>:</p>
<pre><code>class Path:
    def __init__(self, path):
        self.current_path = path.split("/")

    def cd(self, new_path):
        new_split = new_path.split("/")
        for i in new_split:
            if i == "..":
                new_split.pop(0)
                self.current_path = self.current_path[:-1]
        self.current_path += new_split

    def getString(self):
        return "/".join(self.current_path)
</code></pre>
<p>And whenever you need the path as a string, you call <code>path.getString()</code>. A better but quite more advanced way to achieve that is by overriding the <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer"><code>__str__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer"><code>__repr__</code></a> methods of the base object. These are essentially hidden functions that every class has, but which python defines for us. The purpose of these two specific ones is to give string representations of objects. The default code for them doesn't produce anything meaningful:</p>
<pre><code>&lt;__main__.Path object at 0x0000000003D79A58&gt;
</code></pre>
<p>However, by overriding them, we can use <code>str()</code> on instances of <code>Path</code>, and we will get a string representation in the exact format we want. The modified class will look like so:</p>
<pre><code>class Path:
    def __init__(self, path):
        self.current_path = path.split("/")

    def cd(self, new_path):
        new_split = new_path.split("/")
        for i in new_split:
            if i == "..":
                new_split.pop(0)
                self.current_path = self.current_path[:-1]
        self.current_path += new_split

    def __repr__(self):
        return "/".join(self.current_path)

    def __str__(self):
        return self.__repr__()
</code></pre>
<p>And you can print straight away without having to call anything:</p>
<pre><code>&gt;&gt;&gt; print(path)
/a/b/c/x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>import re

def cd(self, new_path):
    paths = [self.current_path[i:i+2] for i in range(0, len(self.current_path), 2)]
    path = re.findall("\.|/\w", new_path)
    new_path = paths[0]+''.join(a if b == "." else b for a, b in zip(paths[1:], path))
    self.current_path = new_path
</code></pre>
<p><code>current_path</code> is now:</p>
<pre><code>'/a/b/c/x'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Path:
def __init__(self, path):
    self.current_path = path

def cd(self, new_path):
    new_split = new_path.split("/")
    old_split = self.current_path.split("/")
    for i in new_split:
        if i == "..":
            old_split.pop(-1)
        else:
            old_split.append(i)

    self.current_path = "/".join(old_split)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Compare to all other answers. Probably this is a better solution. It covered most of cases, but it is still not perfect, because what I do is just using <code>if condition</code> to cover more cases. </p>
<pre><code>def cd(self, new_path):
    positions = self.current_path.split('/')

    if new_path == '/..':
        return None

    if new_path[:2] == '..':
        # start with ..
        # parent path       
        parent_path = ''.join(str(p)+'/' for p in positions[:-1])[:-1]
        self.current_path = parent_path+new_path[2:]
    else:

        if '..' in new_path:
            # contain parent path
            parts = new_path.split('..')
            if new_path[:4] == '/../':
                self.current_path = parts[1]
            elif new_path[0] != '/':
                # relative path
                pa = self.current_path + '/' + parts[0][:-1]
                self.current_path = ''.join(str(p)+'/' for p in pa.split('/')[:-1])+parts[1][1:]
            else:
                # absolute path
                pa = parts[0][:-1]
                self.current_path = ''.join(str(p)+'/' for p in pa.split('/')[:-1])+parts[1][1:]
        else:
            # not conatin parent path
            if new_path[0] != '/':
                # relative path
                self.current_path += '/'+new_path
            else: 
                self.current_path = new_path
</code></pre>
<ul>
<li><a href="https://gist.github.com/tim-hub/df6387c54b21e900d322a7c291b00998" rel="nofollow noreferrer">my gist python path with test cases and results</a></li>
</ul>
</div>
<span class="comment-copy">... just use <code>ipython</code>..., or, use the built-in <code>pathlib</code>, which</span>
<span class="comment-copy">I am trying to implement a program for this use case</span>
<span class="comment-copy">because <code>cd()</code> doesn't do anything: <code>pass</code>. Please review <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a> and show us what you've tried to solve the problem.</span>
<span class="comment-copy">@PadmajaGanesh right. And I suggest that you use <code>pathlib</code> already, which gives you a <code>Path</code> object to work with with useful primitive operations, that you can wrap with your own functionality...</span>
<span class="comment-copy"><b>even better</b> would be to store the path as a <code>pathlib.Path</code> and use those operations available there to implement these things... Also, <code>__str__</code> is not what I would call "advanced", implementing a <code>getString</code> method is just plain un-Pythonic, and really just says "I am a Java programmer writing in Python" more than anything.</span>
<span class="comment-copy">@juanpa.arrivillaga It is advanced in the sense that a novice python programmer, the type that would ask this sort of question, wouldn't even know that these methods exist.</span>
<span class="comment-copy">path = re.findall("\.|/\w", new_path) , could check this line please ?</span>
<span class="comment-copy">@PadmajaGanesh I am not sure what you mean. Would you like me to explain how it works?</span>
<span class="comment-copy">I am actually getting an error in that line sir, when i try to execute.</span>
<span class="comment-copy">@PadmajaGanesh try importing <code>re</code> at the top of your file. <code>import re</code>. Let me know how it works.</span>
<span class="comment-copy">the simplest way</span>
<span class="comment-copy">Why is it the simplest way ?</span>
<span class="comment-copy">do you have a simpler way?</span>
<span class="comment-copy">you forgot this case <code>/a/b../c/d/</code></span>
