<div class="post-text" itemprop="text">
<p>I have some credit card numbers with me and want to validate them over the below rules.</p>
<p>► It must only consist of digits (0-9)</p>
<p>► It may have digits in groups of 4, separated by one hyphen "-"</p>
<p>► It must NOT have 4 or more consecutive repeated digits</p>
<p>► It may contain exactly digits without any spaces</p>
<p>Input:</p>
<ul>
<li><p>5123-4567-8912-3456</p></li>
<li><p>61234-567-8912-3456</p></li>
<li><p>4123356789123456</p></li>
<li><p>5133-3367-8912-3456</p></li>
</ul>
<p><strong>Output:</strong></p>
<ul>
<li><p>Valid</p></li>
<li><p>Invalid  (because the card number is not divided into equal groups of 4)</p></li>
<li><p>Valid</p></li>
<li><p>Invalid (consecutive 33 33digits is repeating  4 times)</p></li>
</ul>
<p>I have tried <a href="https://regex101.com/r/JKeOVl/1" rel="nofollow noreferrer">here</a> and it works only if i include hyphen at the end. Can somebody give me a correct reg ex for it.</p>
<p><strong>Edit:</strong></p>
<p>Regex Code: <code>([0-9]{4}-){4}</code></p>
<p>Input to be matched <code>6244-5567-8912-3458</code></p>
<p>It doesn't match until I put hyphen at the end.</p>
<p><strong>Edit</strong></p>
<pre><code>import re
import itertools
text="5133-3367-8912-3456"
print(len(text))

l=[(k, sum(1 for i in g)) for k,g in itertools.groupby(text)]  #To calculate frequency of characters and later we can filter it with the condition v&lt;=3 for checking the concurrency condition

if re.search(r'^[456]+',text) and len(text)==16  and re.search(r'[\d]',text) and all(v&lt;=3 for k,v in l) and bool(re.search(r'\s',text)) is False and bool(re.search(r'[a-z]',text)) is False or( bool(re.search(r'-',text))is True and len(text)==19) :
    print("it passed")

else :
    print("False")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your regex is almost correct. It asks for four dash terminated groups of numbers. What you want is three dash-terminated groups, followed by a non-dash-terminated group, or a single blob with no dashes:</p>
<pre><code>(?:[0-9]{4}-){3}[0-9]{4}|[0-9]{16}
</code></pre>
<p>[<a href="https://regex101.com/r/WvwXHN/5" rel="nofollow noreferrer">Link</a>]</p>
<p>I made the group <a href="https://docs.python.org/3/howto/regex.html#non-capturing-and-named-groups" rel="nofollow noreferrer">non-capturing</a> since you don't need to capture the contents. You can also use <code>\d</code> instead of <code>[0-9]</code>:</p>
<pre><code>(?:\d{4}-?){3}\d{4}
</code></pre>
<p>[<a href="https://regex101.com/r/WvwXHN/6" rel="nofollow noreferrer">Link</a>]</p>
<p>The validation of consecutive numbers is probably easier to do in a separate step. Once the regex match passes, remove all the dashes:</p>
<pre><code>num = num.replace('-', '')
</code></pre>
<p>Now check for repeated digits using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a>, something like in this <a href="https://stackoverflow.com/q/6352425/2988730">question</a>/<a href="https://stackoverflow.com/a/6352456/2988730">answer</a>:</p>
<pre><code>from itertools import groupby

if max(len(list(g)) for _, g in groupby(num)) &gt;= 4:
    print('Invalid: too many repeated digits')
</code></pre>
<p><strong>Full Code</strong></p>
<pre><code>from itertools import groupby
import re

pattern = re.compile(r'(?:\d{4}-){3}\d{4}|\d{16}')

def count_consecutive(num):
    return max(len(list(g)) for _, g in groupby(num)

num = '6244-5567-8912-3458'
if not pattern.fullmatch(num) or count_consecutive(num.replace('-', '')) &gt;= 4:
    print('Failed')
else:
   print('Success')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My solution has a 2-step logic. The reason you can not do this in one go, has to do with the limitations of python's re. We'll save that for later. If you're interested, look at <strong>Addendum 1</strong>.</p>
<p>2 steps: the first step will check if the '-' are in the right place, while the second one will check if there are not 4 consecutive equal numbers.</p>
<p>I will start with the 2nd step, the most memory-consuming one: a regex that checks if there are no consecutive 4 numbers. The following regex will do:</p>
<pre><code>((\d)(?!\2{3})){16}
</code></pre>
<p>Explanation:</p>
<pre><code>(                       # group 1 start
  (\d)                  # group 2: match a digit
  (?!\2{3})             # negative lookahead: not 3 times group 2
){16}                   # repeat that 16 times.
</code></pre>
<p>look at <a href="https://regex101.com/r/e7LUJt/1" rel="nofollow noreferrer">example 1</a></p>
<p>The first step would be matching groups of 4 digits, eventually separated by '-' (look at <a href="https://regex101.com/r/XJsoCv/2" rel="nofollow noreferrer">example 2</a>) The problem to solve here, is to make sure that if first and second group digits is separated by a '-', then all groups need to be separated by a '-'. We manage to do that by using a backreference to group 2 in the next regex.</p>
<pre><code>(\d{4})(-?)(\d{4})(\2\d{4}){2}
</code></pre>
<p>Explanation:</p>
<pre><code>(\d{4})                 # starting 4 digits
(-?)                    # group 2 contains a '-' or not
(\d{4})                 # 2nd group of 4 digits
(\2\d{4}){2}            # last 2 groups, starting with a backreference
                        # to group 2 ( a '-' or not)
</code></pre>
<p>Example program:</p>
<pre><code> import re

 pattern1 = r"(\d{4})(-?)(\d{4})(\2\d{4}){2}"
 pattern2 = r"((\d)(?!\2{3})){16}"

 tests = ["5123-4567-8912-3456"]

 for elt in tests:
     if re.match( pattern1, elt):
         print "example has dashes in correct place"
         elt = elt.replace("-", "")
         if re.match(pattern2, elt):
             print "...and has the right numbers."
</code></pre>
<p><strong>Addendum:</strong>
Now for desert. I've put a regex together to do this in one go. Let's think about what is needed for every digit depending on its position in a group:</p>
<ul>
<li>1st digit: followed by 3 digits</li>
<li>2nd digit: followed by 3 digits OR digit, digit, dash, digit</li>
<li>3rd digit: followed by 3 digits OR digit, dash, digit, digit</li>
<li>4th digit: followed by 3 digits OR dash, digit, digit, digit</li>
</ul>
<p>So, for the lookahead we used in example 1, we need to present for each digit all possibilities of follow-ups. Let's have a look at a pattern for a group of 4 digits:</p>
<pre><code>(
  (\d)             # the digit at hand
  (?!              # negative lookahead
   \2{3}           # digit, digit, digit
  |\2{2}-\2        # OR digit, digit, dash, digit
  |\2-\2{2}        # OR digit, dash, digit, digit
  |-\2{3}          # OR dash, digit, digit, digit
  )
){4}               # 4 times, for each digit in a group of 4
</code></pre>
<p>We would like to expand that to 16 digits of course. We need to define if it's possible to add '-' before the digit. A simple <code>-?</code> won't do, because a creditcard doesn't start with a dash. Let's use alternation:</p>
<pre><code>(?                 # if
  (?&lt;=\d{4})       # lookbehind: there are 4 preceding digits
  -?               # then: '-' or not
  |                # else: nothing
)
</code></pre>
<p>Combined, this brings us to:</p>
<pre><code>\b((?(?&lt;=\d{4})-?|)(\d)(?!\2{3}|\2{2}-\2|\2-\2{2}|-\2{3})){16}\b
</code></pre>
<p>Look at <a href="https://regex101.com/r/e7LUJt/6" rel="nofollow noreferrer">example 3</a>. We need the \b on both sides because we want to make sure that, whenever the match succeeds, it matches the <code>complete</code> string.</p>
<p>Let's be fair: one has its doubts if this is the way to go. On the upside, we have a valid reason for doing it in 2 steps now: python's standard re doesn't support conditionals and what not. You can workaround this, by using a replacement. Or switch programming language. ;-)</p>
<p><strong>Addendum 2:</strong> People asked me where the <code>16</code> comes from in <a href="https://regex101.com/r/e7LUJt/6" rel="nofollow noreferrer">example 3</a>. Isn't it true that the complete string can be 19 characters long? The reason is whenever the inner regex (group 1) matches once, it matches with either <code>[0-9]</code> or <code>-[0-9]</code>. That match has to succeed exactly 16 times.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unless you really want/need to use <em>regex</em>, this task can be solved by simple python code like this:</p>
<pre><code>import itertools
card = "5133-3467-8912-.456"

# Check if hyphens are ok
if (len(card.split('-')) == 1 and len(card) == 16) or (len(card.split('-')) == 4 and all(len(i) == 4 for i in card.split("-"))):
    # Remove all hyphens (if any)
    card = card.replace("-", "")
    try:
        # Check if numbers only
        int(card)
        # Check if more than 3 repeated digits
        if max(len(list(g)) for _, g in itertools.groupby(card)) &gt; 3:
            print("Failed: 4+ repeated digits")
        else:
            print("Passed")
    except ValueError as e:
        print("Failed: non-digit characters")
else:
    print("Failed: bad hyphens or length")
</code></pre>
</div>
<span class="comment-copy">You are on the right track throughout. A bit off though.</span>
<span class="comment-copy">You should mention that dashes are optional explicitly. Is <code>1234-56789012-3456</code> valid?</span>
<span class="comment-copy">Yeah i should have mentioned it. No 1234-56789012-3456 is not valid</span>
<span class="comment-copy">Please edit that into your question, especially the test cases you give in the beginning, which are very helpful.</span>
<span class="comment-copy">Added to the question</span>
<span class="comment-copy">Dash is optional between group.</span>
<span class="comment-copy">We cannot directly remove dashes in between because if we remove in suppose one of the case 61234-567-8912-3456 it will become valid and we cannot have a group of more than 4 digits.</span>
<span class="comment-copy">@codaholic. You remove the dashes <i>after</i> you validate the string</span>
<span class="comment-copy">@Toto. Fixed. Thanks for the catch</span>
<span class="comment-copy">@codaholic. I posted the full sequence so you could see how it works.</span>
<span class="comment-copy">You are forgetting about the second part of the question....</span>
<span class="comment-copy">enlighten me. What second part?</span>
<span class="comment-copy">No digits repeated more than four times.</span>
<span class="comment-copy">Take a closer look. That's what example 1 shows.</span>
<span class="comment-copy">Unless you show how to apply these, they are not of much use on their own.</span>
<span class="comment-copy">This is arguably not simpler than regex, but I do agree that plugging regex into everything indiscriminately is not a good idea.</span>
