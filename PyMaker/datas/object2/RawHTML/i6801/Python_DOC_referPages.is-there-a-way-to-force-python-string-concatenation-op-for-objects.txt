<div class="post-text" itemprop="text">
<p>I have some doubts about  having a class and an instance of that class and  concatenating them. The usual is:</p>
<pre><code>class MyClass(object):
    # __init__, more code and so on...
    def __str__(self):
        return "a wonderful instance from a wonderful class"

myInstance = MyClass()
message = "My instance is " + str(myInstance) + "."
print(message)
</code></pre>
<p>And this would go to the <code>__str__()</code> method in <code>MyClass</code> and successfully print the line, as I remembered from looking the python docs.</p>
<p>But, it is not possible some operator overloading for making possible this?:</p>
<pre><code>message = "My instance is " + myInstance + "."
</code></pre>
<p>I'm just curious, because I thought it could be possible but I can't find this in the python docs. I have an object in this circumstances and thought I could do this shorter, and also implement the operator overloading in the root of a class hierarchy saving the writing in the childs.</p>
<p>I suppose I can't workaround the <code>str()</code> call. Can I?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can implement the <a href="https://docs.python.org/3/reference/datamodel.html#object.__radd__" rel="nofollow noreferrer"><code>__radd__</code> hook</a> to capture being added to another object:</p>
<pre><code>def __radd__(self, other):
    return other + str(self)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class MyClass(object):
...     # __init__, more code and so on...
...     def __str__(self):
...         return "a wonderful instance from a wonderful class"
...     def __radd__(self, other):
...         return other + str(self)
...
&gt;&gt;&gt; "My instance is " + MyClass() + "."
'My instance is a wonderful instance from a wonderful class.'
</code></pre>
<p>You'd probably want to implement <a href="https://docs.python.org/3/reference/datamodel.html#object.__add__" rel="nofollow noreferrer"><code>__add__</code></a> too, for when your object is the left-hand operator.</p>
<p>However, you should really use <a href="https://docs.python.org/3/library/string.html#formatstrings" rel="nofollow noreferrer"><em>string formatting</em></a> to put objects into strings:</p>
<pre><code>f"My instance is {myInstance}."
</code></pre>
<p>or</p>
<pre><code>"My instance is {}.".format(myInstance)
</code></pre>
<p>This calls the <a href="https://docs.python.org/3/reference/datamodel.html#object.__format__" rel="nofollow noreferrer"><code>__format__()</code> hook</a> on the object, which by default converts your object to a string.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should adopt the <code>format()</code> method for your code. It does that automatically and is far more pythonic then concatenating the string.</p>
<pre><code>class MyClass(object):
    # __init__, more code and so on...
    def __str__(self):
        return "a wonderful instance from a wonderful class"

my_instance = MyClass()
print("My instance is {}.".format(my_instance))
</code></pre>
</div>
<span class="comment-copy">@Jean-Fran√ßoisFabre: in this case, because it returns a string, it'll work without <code>__add__</code>.</span>
<span class="comment-copy">And the same with __ladd__() if the concat goes <code>myInstance +"string"</code>, isnt it?</span>
<span class="comment-copy">@madtyn: yes, in that case <code>__add__</code> (no <code>l</code>) is called.</span>
<span class="comment-copy">I'm trying this, but finally I'll probably stick to the string format way.</span>
<span class="comment-copy">@madtyn: it is, which is why I gave a <code>str.format()</code> example as well.</span>
