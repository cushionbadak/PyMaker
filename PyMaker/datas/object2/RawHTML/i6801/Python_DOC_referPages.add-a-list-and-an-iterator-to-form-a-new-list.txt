<div class="post-text" itemprop="text">
<p>I tried:</p>
<pre><code>a_list = [1,2,3]
b_list = [4,5]
...

call_function(a_list + iter(b_list))  # TypeError
</code></pre>
<p>Is there a better code than this:</p>
<pre><code>a_list = [1,2,3]
b_list = [4,5]
...

new_list = a_list[:]
new_list += iter(b_list)  # no TypeError?
call_function(new_list)
</code></pre>
<p>Consider any iterator, I'm using <code>islice</code> in place of <code>iter</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In <a class="post-tag" href="/questions/tagged/python-3.5" rel="tag" title="show questions tagged 'python-3.5'">python-3.5</a>, you can use <em>iterable unpacking</em>:</p>
<pre><code>call_function([<b>*</b>a_list, <b>*</b>iter(b_list)])</code></pre>
<p>This works since:</p>
<pre><code>&gt;&gt;&gt; [*a_list, *iter(b_list)]
[1, 2, 3, 4, 5]
</code></pre>
<p>Notice the asterisk (<code>*</code>) in front of both <code>a_list</code> and <code>iter(b_list)</code>. Furthermore <code>a_list</code> only has to be a <em>finite</em> iterable/iterator. So you can simply construct a list that concatenates finite iterables together.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can <em>generally</em> use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> to join iterables:</p>
<pre><code>from itertools import chain

new_list = list(chain(a_list, iter(b_list))) 
print(new_list)
# [1, 2, 3, 4, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The existing answers already address the workaround. Additionally, this line:</p>
<pre><code>new_list += iter(b_list)
</code></pre>
<p>Does not throw an error, because it calls <code>list.__iadd__</code> which supports the addition of iterators.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/reference/datamodel.html#object.__iadd__" rel="nofollow noreferrer"><code>__iadd__()</code></a> which is the real function trigger by the syntactic sugar <code>+=</code> (That's why it doesn't create an error).</p>
<pre><code>call_function(a_list.__iadd__(iter(b_list)))
</code></pre>
<p>Produce</p>
<pre><code>&gt;&gt;&gt; a_list.__iadd__(iter(b_list))
[1, 2, 3, 4, 5]
</code></pre>
<p>This is fun but not really good in term of readability to be honest. Prefer other answers :)</p>
<p><strong>EDIT</strong>:</p>
<p>Of course to produce new_list, you have to make a copy of <code>list_a</code> has you did in your question.</p>
<pre><code>a_list[:].__iadd__(iter(b_list))
</code></pre>
</div>
<span class="comment-copy">why not <code>new_list = a_list + b_list</code> ?</span>
<span class="comment-copy">please see the last line</span>
<span class="comment-copy">@BearBrown: the <code>b_list</code> is only used to construct an iterable/iterator... Afaik you should see it as a blackbox iterable/iterator.</span>
<span class="comment-copy">I meant to form a new list (in question title). I didn't specify it in the question body, though</span>
<span class="comment-copy">@Adam make sense. Edit answer but it is very close to the code in your original question.</span>
