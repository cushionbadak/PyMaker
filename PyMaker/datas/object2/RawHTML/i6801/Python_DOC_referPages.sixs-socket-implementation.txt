<div class="post-text" itemprop="text">
<p>I build an app compatible between Python 2 and 3. In order to provide compatibility between those two Python versions, I use <a href="https://pythonhosted.org/six/" rel="nofollow noreferrer">six library</a>.</p>
<p>My code uses <a href="https://docs.python.org/3/library/socket.html#socket.socket" rel="nofollow noreferrer">sockets</a>. Under Python 3 it is possible to create them using <code>with</code> statement, but under Python 2 it claims on missing <code>__exit__</code> attribute.</p>
<p>Is there any function of six providing disposable socket? If not, what solution would you consider as the most clear in this case?</p>
</div>
<div class="post-text" itemprop="text">
<p>AFAIK (by scanning through its docs) <code>six</code> doesn't do much in this case. In Python 2, you could wrap <code>socket</code> up in a context manager with the <code>contextmanager</code> decorator and supply that:</p>
<pre><code>from sys import version_info 
import socket

if version_info[0] == 2:
    from contextlib import contextmanager

    @contextmanager
    def sock(*args, **kwargs):
        s = socket.socket(*args, **kwargs)
        try:
            yield s
        finally:
            s.close()
else:  # Python 3
    sock = socket.socket
</code></pre>
<p>In both cases you use the <code>with</code> statement accordingly:</p>
<pre><code>with sock(socket.AF_INET, socket.SOCK_STREAM) as s:
    # use s
</code></pre>
</div>
<span class="comment-copy">good point. the only change I would apply in comparison to your suggestion is using six Python version checking (<a href="https://pythonhosted.org/six/#package-contents" rel="nofollow noreferrer">pythonhosted.org/six/#package-contents</a>) instead of <code>version_info[0]</code>.</span>
<span class="comment-copy">Additional question: what is the benefit of introducing two versions instead of using python2 version only?</span>
<span class="comment-copy">@pt12lol yes, I missed the try-finally. I'm guessing you could rebind the name <code>socket</code> to the context manager version in Python 2 but I don't like renaming standard names like that. Instead, I opted to bind it to a new name which you can use unconditionally.</span>
