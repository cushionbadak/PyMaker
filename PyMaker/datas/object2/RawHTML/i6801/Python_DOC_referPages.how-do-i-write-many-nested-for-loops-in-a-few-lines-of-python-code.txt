<div class="post-text" itemprop="text">
<p><strong>What I have:</strong> I have the list <code>List123=[-13,3,12,1]</code> and the 2-by-4-matrix <code>Matrix123=numpy.zeros((2,4), dtype=Decimal)</code>.</p>
<p><strong>What I want:</strong> I want to change all entries of the matrix to any entry of the list and then print it to the terminal. There are 4^(2*4)=65536 possible combinations. I want to print every combination.</p>
<p><strong>How I do it now:</strong> Here is the my current code:</p>
<pre><code>List123=[-13,3,12,1]

Matrix123=numpy.zeros((2,4), dtype=Decimal)

k=0
for k in List123:
    Matrix123[0,0]=k
    for k in List123:
        Matrix123[0,1]=k
        for k in List123:
            Matrix123[0,2]=k
            for k in List123:
                Matrix123[0,3]=k
                for k in List123:
                    Matrix123[1,0]=k
                    for k in List123:
                        Matrix123[1,1]=k
                        for k in List123:
                            Matrix123[1,2]=k
                            for k in List123:
                                Matrix123[1,3]=k
                                print Matrix123
                                print " "
</code></pre>
<p><strong>My question:</strong> <em>What is a more compact way to write this in only a few lines of code?</em> I need to do the same for a 23-by-27 Matrix. That would mean that I have to write code for 23*27=621 for-loops manually, if I don't find a more compact way.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a>:</p>
<pre><code>import itertools

list123 = [-13, 3, 12, 1]

for matrix in itertools.product(list123, repeat=8):
  print matrix
</code></pre>
<p>It will output all the possible solution of length 8 with <code>-13, 3, 12 and 1</code>. <code>matrix</code> will be a tuple with 8 numbers, being the possible solutions. </p>
<p>If you need it to output the result in the real <code>numpy.matrix</code> form, you can create them on the fly (even though it will take more time).</p>
<pre><code>import numpy as np

for prod in itertools.product(list123, repeat=8):
  print np.matrix([prod[:4], prod[4:]])
</code></pre>
<p>Or using <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html" rel="nofollow noreferrer"><code>reshape</code></a> to improve readability (Thanks to @MenglongLi)</p>
<pre><code>for prod in itertools.product(list123, repeat=8):
  print np.reshape(prod, (2, 4))
</code></pre>
<p>It will gave you 65536 results as expected.</p>
</div>
<div class="post-text" itemprop="text">
<p>I highly recommend you to use itertools in python build-in tools:</p>
<pre><code>from itertools import product
import numpy as np

List123 = [-13, 3, 12, 1]

for i in product(List123, repeat=8):
    print(np.array(i).reshape(2, 4))
</code></pre>
<p>Here's a pure recursion function version:</p>
<pre><code>import numpy as np

List123 = [-13, 3, 12, 1]

def dfs(depth=1, result=None):
    if result is None:
        result = []
    if depth == 9:
        print(np.array(result).reshape(2, 4))
        return

    for i in List123:
        dfs(depth + 1, result + [i])

dfs()
</code></pre>
<p>In both way, you have 65536 results.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>np.meshgrid</code>:</p>
<pre><code>def my_product(list, shape = (4,2)):
    r = np.product(shape)
    out = np.stack(np.meshgrid(*(List123,) * r))
    out = out.reshape(shape[::-1] + (-1,)).T
    for mat in list(out):
        print(mat)
</code></pre>
<p>Of course, if your <code>shape</code> is <code>(23,27)</code>, this will cause a <code>memerror</code> even if <code>len(list) = 2</code> as all those permutations would fill all the storage on earth a ridiculous number of times over, and printing them all would take until the heat death of the universe.</p>
</div>
<span class="comment-copy">how about a for loop which iteratoes from 0 to 3 for the last slice of Matrix, and another for loop for the first index, ranging from 0 to 1 ?</span>
<span class="comment-copy">You do realize that <code>4^(27*23) ~= 6.x10^373</code> and printing that many items will finish sometime around the heat death of the universe?</span>
<span class="comment-copy">You really, really shouldn't use <code>numpy.matrix</code> anymore. Just use <code>np.array</code></span>
<span class="comment-copy">@juanpa.arrivillaga is it due to performance issues? Can you provide a link or something about the topic?</span>
<span class="comment-copy">No, more of a design consideration. Anyway, that's what <a href="https://docs.scipy.org/doc/numpy-dev/user/numpy-for-matlab-users.html#short-answer" rel="nofollow noreferrer">scipy recommends</a>. Essentially, <code>numpy.matrix</code> only exists for people coming from matlab to have something similar to the corresponding data-structure there. However, <code>numpy</code> and the <code>scipy</code> stack don't really have heavy support for it, and often, functions will return <code>numpy.ndarray</code>s regardless of if you input a <code>np.matrix</code></span>
<span class="comment-copy">@juanpa.arrivillaga still, np.linalg.eigh return a np.matrix for the eigenvalue decomposition of an hermitian matrix, when it could return a 2D array. Why so?</span>
<span class="comment-copy">@P.Camilleri I think a lot of the <code>linalg</code> functions do. Probably for historical reasons.</span>
<span class="comment-copy">This is very elegant.</span>
<span class="comment-copy">death of the universe +1</span>
