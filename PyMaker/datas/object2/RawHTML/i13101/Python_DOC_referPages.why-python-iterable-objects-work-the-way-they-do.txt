<div class="post-text" itemprop="text">
<p>I read about the built in iteration methods of objects from the Python documentation:</p>
<p><a href="https://docs.python.org/2/library/stdtypes.html#iterator-types" rel="nofollow">https://docs.python.org/2/library/stdtypes.html#iterator-types</a></p>
<p>What it says about <code>__iter__</code> method is as follows: </p>
<blockquote>
<p>Return an iterator object. The object is required to support the
  iterator protocol described below.</p>
</blockquote>
<p>However, in my opinion this seems not to be the case, if I make <code>__iter__</code> method return a string like <code>'abc'</code> I get a type error: <code>TypeError: iter() returned non-iterator of type 'str'</code> but as we know, strings are iterable objects, how is it possible that python treats it like it is not an iteration object?</p>
<p>I can work around this problem like this:</p>
<pre><code>def __iter__(self):
    return 'abc'.__iter__()
</code></pre>
<p>but I don't understand why I have to do it this way instead of just returning the <code>'abc'</code> object.</p>
<p>I also noticed that the Python Documentation is not very helpful for beginners, it sure as hell is not making this learning progress easy. With what logic one could come to the conclusion that <code>return 'abc'.__iter__()</code> is the way to go by reading the documentation?</p>
<p>If you have any suggestions on where I could learn more about built in methods and the like in depth, I would be more than happy if you would share. </p>
</div>
<div class="post-text" itemprop="text">
<p>Pragmatic answer: An iterator needs to support <code>next()</code>.</p>
<p>A string does not:</p>
<pre><code>next('abc')
TypeError: 'str' object is not an iterator
</code></pre>
<p>Just to be iterable is not enough.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a bit of a fine point, but the key is that an iterator (e.g., <code>iter("abc")</code> or the equivalent <code>"abc".__iter__()</code>) and iterable (e.g, <code>"abc"</code>) are two slightly different things, and <code>__iter__</code> is required to return an iterator.</p>
</div>
<div class="post-text" itemprop="text">
<p>A string is an object which can be iterated on, but itself is not an iterator. They are two separate classes in the object hierarchy. </p>
</div>
<div class="post-text" itemprop="text">
<p>From the python <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow">Documentation</a>:</p>
<p><strong>An iterable is</strong></p>
<blockquote>
<p><strong>an object <em>capable</em> of returning its members one at a time</strong>.</p>
<p>This means all sequence types (<code>list</code>, <code>str</code>, and <code>tuple</code> objects) and some non-sequence types like <code>dict</code> and <code>file</code> and objects of any classes you define with an <code>__iter__()</code> or <code>__getitem__()</code> methoda are iterables.</p>
<p>Iterables can be used in a for loop and in many other places where a sequence is needed (<code>zip()</code>, <code>map()</code>, ...). When an iterable object is passed as an argument to the built-in function <code>iter()</code>, it returns an iterator for the object.</p>
</blockquote>
<p>On the other hand <strong>an iterator is</strong></p>
<blockquote>
<p><strong>an object <em>representing</em> a stream of data</strong>.</p>
<p>Repeated calls to the iteratorâ€™s <code>next()</code> method return successive items in the stream. When no more data are available a <code>StopIteration</code> exception is raised instead.</p>
</blockquote>
</div>
<span class="comment-copy">Strings are <i>iterable</i> but they are not <i>iterators</i>. The documentation is perfectly clear on what constitutes an <i>iterator</i>: any object supporting the iterator protocol.</span>
<span class="comment-copy">I see, seems like I assumed that string has <code>__next__</code> method since you can iterate it. This seems to be the best answer so far.</span>
<span class="comment-copy">None of the builtin sequence are iterator.  They all have a corresponding iterator. <code>iter('abc')</code> returns <code>&lt;str_iterator object at 0x00000051168AE0B8&gt;</code>.  This separation allows then to not only be re-iterated, but allow to have multiple iterators as the same time.  Consider <code>s = 'abc'\nfor c1 in s:\n  for c2 in s:\n    yield c1,c2</code> to get all ordered pairs of letters in a string s  Each for loop calls iter(s) to get its own iterator.</span>
