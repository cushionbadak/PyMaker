<div class="post-text" itemprop="text">
<p>I have sentences with horrible usage of punctuation, e.g.: </p>
<pre class="lang-none prettyprint-override"><code>Some people do it right; some forget a whitespace;some add a wrong one ; pretty annoying! ;)
</code></pre>
<p>I need to know the position of each "genuine" punctuation mark which particularly exclude their use in text emoticons. If I use:</p>
<pre><code>&gt;&gt;&gt; print re.findall(r'\w+\s*(;)\s*\w+', s)
[';', ';', ';']
</code></pre>
<p>So I match the semicolons correctly, but I don't have their position within the string. However, when I use <code>finditer</code>:</p>
<pre><code>&gt;&gt;&gt; p = re.compile(r'\w+\s*(;)\s*\w+')
&gt;&gt;&gt; for m in p.finditer(s):
...    print m.group(), m.span()
right; some (18, 29)
whitespace;some (39, 54)
one ; pretty (67, 79)
</code></pre>
<p>I get, correctly, the whole matching group. When I use the naive approach</p>
<pre><code>&gt;&gt;&gt; p = re.compile(r';')
&gt;&gt;&gt; for m in p.finditer(s):
...     print m.group(), m.span()
; (23, 24)
; (49, 50)
; (71, 72)
; (90, 91)
</code></pre>
<p>I get the position of all "genuine" punctuation marks, but also the one that is part of the <code>;)</code> emoticon.</p>
<p>The example uses only <code>;</code>, but it can be all kinds of punctuation marks: <code>.,;:?!</code>. Also, I don't have to worry about decimal numbers. </p>
<p>Of course, I can change <code>\w+</code> to <code>[a-zA-Z]+</code>, but this would interfere with sentences that end with a number, e.g., <code>The answer is 42.</code>.</p>
<p>I guess I can apply the naive approach on the individual groups, but maybe there's a more straightforward way to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>When called without arguments, <a href="https://docs.python.org/3/library/re.html#re.match.group" rel="nofollow"><code>match.group</code></a> returns the whole match. In your regex pattern the group containing <code>;</code> can be referred to as 1. </p>
<p>Call <code>start</code> method of match objects with the group name as argument:</p>
<pre><code>for m in p.finditer(s):
    print(m.start(1), s[m.start(1)])
</code></pre>
<p>outputs</p>
<pre><code>23 ;
49 ;
71 ;
</code></pre>
<p>Consider specifying a symbolic group name, which you'll be able to use in place of 1 e.g</p>
<pre><code>p = re.compile(r'\w+\s*(?P&lt;semicolon&gt;;)\s*\w+')
for m in p.finditer(s):
    print(m.start('semicolon'), s[m.start('semicolon')])
</code></pre>
<p>The output is the same.</p>
</div>
<span class="comment-copy">You probably should use a proper <a href="https://stackoverflow.com/questions/tagged/nlp">nlp</a> package to do this.</span>
<span class="comment-copy">You are presupposing that smileys are unambiguous even though your problem statement is for mistakes in text.  This seems rather impossible to pull off reliably.  Also, some people (like occasionally myself :-) collapse closing parentheses with smileys.</span>
<span class="comment-copy">I'm using a relatively flexible regex based method to identify text emoticons. <code>:-)</code>, <code>:0)))</code>, <code>;o)</code>, <code>[-:</code>, <code>}=:</code>, <code>;D</code>, ... are all OK. However, this flexibility here comes with the price that finding punctuation marks is not trivial any more. Right now I have a bad case when there's a emoticon after a sentence, e.g., <code>..., right? ;)</code>. The question mark doesn't match with my current regex pattern. But you're right, I don't think it will ever be 100% accurate.</span>
<span class="comment-copy">This works! I was exactly missing the opportunity to refer to the group containing the punctuation mark. vaultah, thanks!</span>
<span class="comment-copy">@Christian no problem, I'm glad I understood your question correctly :)</span>
