<div class="post-text" itemprop="text">
<p>I'm a beginner in Python programming and I'm having some trouble with some list stuff. </p>
<p>So I want to write a function that returns a boolean value. The function will inform the user whether there is a duplicate consecutive pair of elements in the list he or she entered. By the way, I want to do this using only <code>len()</code>, <code>range()</code>, <code>loops</code>, <code>if-statements</code>, variables and arithmetic (no built in functions).</p>
<p>For example:</p>
<pre><code>contains_consecutive_duplicates([1,3,3]) should return True

contains_consecutive_duplicates([3,2,3]) should return False
</code></pre>
<p>My code:</p>
<pre><code>def contains_consecutive_duplicates(xs):
     for i in xs:
         if xs[i] == xs[i-1] or xs[i] == xs[i+1]:
             return True
         else:
             return False
</code></pre>
<p>My logic to this was as follows: Each time the for loop would run, <code>i</code> would refer to some element in the list. If that element was such that the element before it or after it was equal to it, then the for loop would return true. If not, keep searching. If there are none, it would return false.</p>
<p>Now, I actually understand where the error is (I think). The problem is that I don't know how to solve it. I think the for loop is running into a problem at the beginning (when <code>i</code> is reffering to the 0th element). There is no element before the 0th element, hence the error:</p>
<pre><code>"index out of range"
</code></pre>
<p>P.S: Is that how you return a boolean value?</p>
<p>Is there a better way to do this?</p>
<p>I would appreciate any help given! Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>This should do the trick:</p>
<pre><code>def contains_consecutive_duplicates(xs):
    for i in range(1, len(xs) - 1):
        if xs[i] == xs[i-1] or xs[i] == xs[i+1]:
            return True
    return False
</code></pre>
<p>It iterates through all values bar the first and last (created by the range function), returning (which ends the loop) if it finds a duplicate.
If it reaches the end and hasn't found a duplicate one must not exist, so it returns <code>False</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>@roeland pointed out the problem with assuming iterating the <code>list</code> directly would get you indices (if you want index and value, use <code>enumerate</code>). But in this case you don't actually need the index.</p>
<p>For the simple case (where it's known to be a container you can slice), you can just iterate with <code>zip</code> over offset slices:</p>
<pre><code>def contains_consecutive_duplicates(xs):
     return any(x == y for x, y in zip(xs, xs[1:]))
</code></pre>
<p>More general solutions can be made with <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a> to handle the case where you can't slice, but this is simple and involves no imports.</p>
<p>Use of <code>any</code> in this case is just a short hand to slurp the generator expression and return <code>True</code> if any values are truthy. The long equivalent form is:</p>
<pre><code>def contains_consecutive_duplicates(xs):
    for x1, x2 in zip(xs, xs[1:]):
        if x1 == x2:
            return True
    return False
</code></pre>
<p>Since your teacher apparently thinks built-ins are bad, but <code>len</code> and <code>range</code> aren't built-ins (they are), you can do this the dumb way:</p>
<pre><code>def contains_consecutive_duplicates(xs):
    for i in range(len(xs) - 1):
        if xs[i] == xs[i+1]:
            return True
    return False
</code></pre>
<p>Which does the same work as <code>zip</code>ing, just less efficiently (generating index integers and explicitly indexing is surprisingly expensive in Python relative to native iteration).</p>
</div>
<div class="post-text" itemprop="text">
<p>This should do:</p>
<pre><code>&gt;&gt;&gt; def contains_consecutive_duplicates(xs):
...   for i, v in enumerate(xs[:-1]):
...     if v == xs[i+1]:
...       return True
...     else:
...       pass
...   return False
&gt;&gt;&gt; l1 = [1,3,3]
&gt;&gt;&gt; l2 = [1,3,2]
&gt;&gt;&gt; l3 = []
&gt;&gt;&gt; l4 = [2]
&gt;&gt;&gt; contains_consecutive_duplicates(l1)
True
&gt;&gt;&gt; contains_consecutive_duplicates(l2)
False
&gt;&gt;&gt; contains_consecutive_duplicates(l3)
False
&gt;&gt;&gt; contains_consecutive_duplicates(l4)
False
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By using only <code>range</code>, <code>for</code> and <code>if</code> statements, this can be done with:</p>
<pre><code>def contains_consequtive_duplicates(xs):
    for i in range(len(xs)-1):
        if xs[i] == xs[i+1]: return True
    return False
</code></pre>
<p>You access lists with their <code>index</code> and not by their <strong>value</strong> (which you are by using <code>for i in list</code>). Additionally, if you perform the check <code>xs[i] == xs[i-1]</code> this will not yield the result you want since <code>x[-1]</code> will check the end of the list so <code>[3, 2, 3]</code> will return True.</p>
<p>As a small demonstration:</p>
<pre><code>if contains_consequtive_duplicates([1,3,3]): print "consecutive"
# Prints Consequtive

if contains_consequtive_duplicates([3, 2, 3]): print "consecutive"
# Prints nothing
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>def contains_consecutive_duplicates(xs):
    for i in xs:
        if xs.indexOf(i)==len(xs):
            break
        if xs[i] == xs[i-1] or xs[i] == xs[i+1]:
            return True
        else:
            return False
</code></pre>
<p>What you are doing is trying to do is evaluate <code>xs[i+1]</code>, but that does not exist.</p>
</div>
<span class="comment-copy"><code>for i in xs</code> loops over the values in the array, not over the indices.</span>
<span class="comment-copy">Also, a problem that you could be having is with checking for the next item in the list. If you have a list that only goes up to xs[4], the function will try to check the value of xs[5], but since there is no xs[5], that's where you get the index error</span>
<span class="comment-copy">There is no reason to check both forward and backwards. As long as you check the right indices, testing in only one direction will catch all duplicates with half the comparison work.</span>
<span class="comment-copy">@ShadowRanger Yes you're completely correct. I actually think the other answers are better, but because it's a learning exercise for the student I prefer to make as few changes to the code as possible, so they don't get confused learning everything at once.</span>
<span class="comment-copy">Thanks that really helped!!!!</span>
<span class="comment-copy">Note: For greater speed/brevity, but slightly less obvious behavior, the <code>return</code> could be <code>return any(map(eq, xs, xs[1:]))</code> if you include <code>from operator import eq</code> (and on Py2 <code>from future_builtins import map</code>), but that's getting into the weeds, and it's less intuitive for new programmers.</span>
<span class="comment-copy">I believe you want to keep an explicit <code>return False</code> in there; the default return of <code>None</code> is falsy, but the assignment seems to be overly concerned with the return being an actual <code>bool</code>.</span>
<span class="comment-copy">This doesn't fix the issue with trying to use values of <code>xs</code> as <code>indices</code> into it (which would only actually check consecutive indices if the values were consecutive integers). And the test for <code>len</code> won't prevent the <code>+1</code> test from triggering an <code>IndexError</code>, because <code>len(xs)</code> is not a valid index, so <code>i</code> would pass the test, but <code>i+1</code> would error.</span>
<span class="comment-copy">.. and aside from those, you'd only ever look at <code>i = xs[0]</code>, because the <code>if</code> immediately returns either True or False.</span>
<span class="comment-copy">whoops, i fixed it</span>
