<div class="post-text" itemprop="text">
<p>I'm trying to validate a checksum on a string which in this case is calculated by performing an XOR on each of the individual characters.</p>
<p>Given my test string:</p>
<pre><code>check_against = "GPGLL,5300.97914,N,00259.98174,E,125926,A"
</code></pre>
<p>I figured it would be as simple as:</p>
<pre><code>result = 0
for char in check_against:
    result = result ^ ord(char)
</code></pre>
<p>I know the result should be <code>28</code>, however my code gives <code>40</code>.</p>
<p>I'm not sure what encoding the text is suppose to be in, although I've tried encoding/decoding in <code>utf-8</code> and <code>ascii</code>, both with the same result. </p>
<p>I implemented this same algorithm in C by simply doing an XOR over the char array with perfect results, so what am I missing?</p>
<p><strong>Edit</strong></p>
<p>So it was a little while ago that I implemented (what I thought) was the same thing in C. I knew it was in an Objective-C project but I thought I had just done it this way. Totally wrong, first there was a step where I converted the checksum string value at the end to hex like so (I'm filling some things in here so that I'm only pasting what is relevant):</p>
<pre><code> unsigned int checksum = 0;
 NSScanner *scanner = [NSScanner scannerWithString:@"26"];
 [scanner scanHexInt:&amp;checksum];
</code></pre>
<p>Then I did the following to compute the checksum:</p>
<pre><code> NSString sumString = @"GPGLL,5300.97914,N,00259.98174,E,125926,A";
 unsigned int sum = 0;
 for (int i=0;i&lt;sumString.length;i++) {
     sum = sum ^ [sumString characterAtIndex:i];
 }
</code></pre>
<p>Then I would just compare like so:</p>
<pre><code> return sum == checksum;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So as @metatoaster, @XD573, and some others in the comments have helped figure out, the issue was the difference between the result, which was base 10, and my desired solution (in base 16).</p>
<p>The result for the code, <code>40</code> is correct - in base 10, however my correct value I was trying to achieve, <code>28</code> is given in base 16. Simply converting the solution from base 16 to base 10, for example like so:</p>
<pre><code>int('28', 16)
</code></pre>
<p>I get <code>40</code>, the computed result.</p>
</div>
<div class="post-text" itemprop="text">
<p>I created the C version as shown here:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
    char* str1="GPGLL,5300.97914,N,00259.98174,E,125926,A";
    int sum = 0;
    int i = 0;

    for (i; i &lt; strlen(str1); i++) {
        sum ^= str1[i];
    }

    printf("checksum: %d\n", sum);

    return 0;
}
</code></pre>
<p>And When I compiled and ran it:</p>
<pre><code>$ gcc -o mytest mytest.c
$ ./mytest
checksum: 40
</code></pre>
<p>Which leads me to believe that the assumptions you have from your equivalent C code are incorrect.</p>
</div>
<span class="comment-copy"><code>hex(40) == 0x28</code> ?</span>
<span class="comment-copy">Another way to check your raw values <code>map(ord, check_against)</code>, then reduce it using <a href="https://docs.python.org/2/library/operator.html#operator.xor" rel="nofollow noreferrer"><code>operator.xor</code></a>, like so <code>reduce(xor, map(ord, check_against))</code>. In python 3 it will be <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a>.</span>
<span class="comment-copy">I believe for your given example string <code>utf-8</code> vs <code>ascii</code> is a dead end because the ASCII characters have the same values in Unicode. <code>bytearray(check_against, encoding='utf-8') == bytearray(check_against)</code> returns <code>True</code> in Python 2.</span>
<span class="comment-copy">Also, finally, what is your C code? I am sure the answer is <code>40</code> in base10 and <code>0x28</code> in base16. How did you generate the output <code>28</code> with C?</span>
<span class="comment-copy">Final note, seems like nobody is acknowledging this: <code>printf("%x\n", 40);</code> results in <code>28</code> being printed out.</span>
<span class="comment-copy">You are correct, I just added an edit with my (Objective C, forgot it wasn't just in C) code. My current code is missing an conversion to hex for the checksum as a String I think. Also, I think there is some confusion here between the hex values and string values of the numbers in general, with myself included.</span>
