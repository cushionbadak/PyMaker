<div class="post-text" itemprop="text">
<p>I want to write a wrapper for functions which is aware of positional arguments. Unfortunately, I also want to allow the wrapped function to be called with named positional arguments (for readability). Since the wrapped function is actually a new function, it would not have the positional argument names for the old function.</p>
<p>Example: Here is a wrapper.</p>
<pre><code>def double_second_argument(f):

    def g(*args):
        newargs = list(args)
        newargs[1] *= 2
        return f(*newargs)

    return g
</code></pre>
<p>Here is a function.</p>
<pre><code>def add(x, y):
    return x + y
</code></pre>
<p>I wrap the function.</p>
<pre><code>add_twice = double_second_argument(add)
</code></pre>
<p>I call the function without and with named parameters.</p>
<pre><code>&gt;&gt;&gt; add_twice(3, 5)
13
&gt;&gt;&gt; add_twice(x=3, y=5) # = 13
TypeError: g() got an unexpected keyword argument 'x'
</code></pre>
<p>I get an error, because <code>g</code> doesn't have <code>**kwargs</code>, and adding it in would have just turned the error into an <code>IndexError</code>, since <code>newargs[1]</code> would have indexed an empty list.</p>
<p>Even worse is if the original function itself is wrapped (perhaps by the same wrapper). We would have to define both wrappers in a way that preserves the argument list.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/inspect.html#inspect.Signature" rel="nofollow"><code>inspect.signature</code></a> is used to get the signature of a function, even if the function is (correctly) wrapped. (See <a href="https://www.python.org/dev/peps/pep-0362/#implementation" rel="nofollow">PEP-3062/Implementation</a>.) This can be used to get the parameter names, and then wrap the wrapped function in another wrapper that will extract <code>kwargs</code> to put into <code>args</code>.</p>
<pre><code>from inspect import signature
from functools import wraps

def expands_positional_args(f):

    # Save the parameter list.
    params = list(signature(f).parameters.keys())

    def wrap(g):

        @wraps(g)
        def kw_to_positional(*args, **kwargs):

            if len(args) &lt; len(params): # not enough args

                kwargs = kwargs.copy()
                args = list(args)

                # Extract and remove the args from kwargs
                args.extend(kwargs.pop(p) for p in params[len(args):])

            return g(*args)

        return kw_to_positional

    return wrap
</code></pre>
<p>(Note: This doesn't handle default args, assumes that there are no keyword arguments for f, and raises a <code>KeyError</code> for missing arguments. I fix those issues <a href="http://pastebin.com/KSE8jFfy" rel="nofollow">in this version</a>.)</p>
<p>Now, we have:</p>
<pre><code>&gt;&gt;&gt; def double_second_argument(f):
...     @expands_positional_args(f)
...     def g(*args):
...         newargs = list(args)
...         newargs[1] *= 2
...         return f(*newargs)
...     return g
...
&gt;&gt;&gt; def add(x, y):
...     return x + y
...
&gt;&gt;&gt;
&gt;&gt;&gt; add_twice = double_second_argument(add)
&gt;&gt;&gt;
&gt;&gt;&gt; add_twice(3, 5) # = 13
13
&gt;&gt;&gt; add_twice(x=3, y=5) # = 13
13
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/inspect.html#inspect.Signature.bind" rel="nofollow noreferrer">inspect.Signature.bind</a> can be used for that purpose.</p>
<pre><code>from functools import wraps
from inspect import signature, BoundArguments, Parameter


def positional_argument_wrapper(func):

    func_signature = signature(func)
    if any(v.kind == Parameter.VAR_KEYWORD
           for v in func_signature.parameters.values()):
        raise TypeError('Keyword-only arguments are not supported by '
                        'positional_argument_wrapper')

    @wraps(func)
    def wrapped_func(*args, **kwargs):
        bound_arguments: BoundArguments = func_signature.bind(*args, **kwargs)
        bound_arguments.apply_defaults()
        assert len(bound_arguments.kwargs) == 0
        print(f'The positional arguments are {bound_arguments.args}')
        return func(*args, **kwargs)
    return wrapped_func


@positional_argument_wrapper
def myfunc1(x=None, y=7):
    print(f'myfunc called with x={x} and y={y}')


# prints: The positional arguments are (3,)
#         myfunc called with x=3 and y=7
myfunc1(x=3)
# prints: The positional arguments are (None, 3)
#         myfunc called with x=None and y=3
myfunc1(y=3)

# raises: TypeError: Keyword-only arguments are not supported by positional_argument_wrapper
@positional_argument_wrapper
def myfunc1(x=None, y=7, **kwargs):
    pass
</code></pre>
</div>
