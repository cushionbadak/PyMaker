<div class="post-text" itemprop="text">
<p>It can be weird but I am looking for a way to get automatically all variables and method within a python script.</p>
<p>For example,</p>
<pre><code>a = 1
b = 2
c = 3
myList = range(10)

def someMethod(x): 
    something = do_something()
    return something

f = someMethod(b)

print f
</code></pre>
<p>I want to get</p>
<pre><code>a, b, c, someMethod, something, f
</code></pre>
<p>This is a demonstrative example, I want to do this for a much bigger script.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/ast.html" rel="noreferrer"><code>ast</code> module</a> can do this fairly easily. If we assume the source is stored in a variable named <code>source</code> (could be read from a file):</p>
<pre><code>import ast

root = ast.parse(source)
names = sorted({node.id for node in ast.walk(root) if isinstance(node, ast.Name)})
</code></pre>
<p>That loses ordering to gain uniquification and friendly display order, but you could just use a list comprehension or generator expression instead of a set comprehension if you don't need uniqueness but want ordering. The resulting <code>list</code> is:</p>
<pre><code>['a', 'b', 'c', 'do_something', 'f', 'myList', 'range', 'someMethod', 'something', 'x']
</code></pre>
<p>Unlike the other solutions posted so far, this will recurse into classes and functions to get the names used inside them, and doesn't require you to import the module or class to check, nor does it require you to implement recursive processing yourself; any syntactically valid Python code will work.</p>
<p>Oddly, on Python 3 (substituting a valid <code>print</code> function call), you get:</p>
<pre><code> ['a', 'b', 'c', 'do_something', 'f', 'myList', 'print', 'range', 'someMethod', 'something']
</code></pre>
<p>which adds <code>print</code> (as expected; it's a name now, not a keyword statement), but omits <code>x</code>. You didn't ask for <code>x</code> (the argument received by <code>someMethod</code>), and this doesn't produce it on Python 3. Names in function prototypes appear to not create a <code>ast.Name</code> node there, go figure. You can pull that info out of the <code>ast.FunctionDef</code> node from the <code>arg</code> attribute of each entry in the <code>list</code> <code>node.args.args</code>, but it's probably still not comprehensive; I suspect other definition related names might be missed, e.g. in class declarations with inheritance. You'd need to poke around with some examples to make sure you're checking everything (assuming you want stuff like <code>x</code> and want to work on Python 3).</p>
<p>That said, <code>x</code> would show up just fine if you referenced it; if you passed it to <code>do_something</code> or used it in any way besides receiving and discarding it, it would show up.</p>
<p>You can also make an effort to only handle names assigned to, not used (to exclude <code>do_something</code>, <code>range</code>) by extending the test to:</p>
<pre><code>names = sorted({node.id for node in ast.walk(root) if isinstance(node, ast.Name) and not isinstance(node.ctx, ast.Load)})
</code></pre>
<p>But that will also drop <code>someMethod</code> (in both Py2 and Py3) because the definition itself doesn't produce an <code>ast.Name</code>, only the use of it does. So again, you'd have to delve a little deeper into the <code>ast.Node</code> internals for <code>ast.FunctionDef</code>, <code>ast.ClassDef</code>, etc. to get the names that aren't <code>walk</code>-ed directly.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a lot of variables imported by python so you're going to get a long list, but <code>vars()</code> will work. </p>
<pre><code>a = 1
b = 2
c = 3
myList = range(10)

def someMethod(x): 
    something = 4
    return something

f = someMethod(b)

print vars()
</code></pre>
<p><em>in terminal:</em></p>
<pre><code> $ python temp.py
{'a': 1, 'c': 3, 'b': 2, 'myList': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 'f': 4, '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'temp.py', '__package__': None, 'someMethod': &lt;function someMethod at 0x10759b488&gt;, '__name__': '__main__', '__doc__': None}
</code></pre>
<p><strong>EDIT</strong><br/>
You can clean it up a bit by checking for type of variables</p>
<pre><code>import types
all_vars = dict(vars())
for var_name, var in all_vars.iteritems():
    if type(var) not in [types.ModuleType, types.FunctionType] and not var_name.startswith("_"):
        print var_name
</code></pre>
<p><em>in terminal:</em> </p>
<pre><code>$ python temp.py
a
c
b
myList
f
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>globals()</code> function to get all the global names in your module, and since python has some global names by default like <code>__builtins__</code> you can escape them :</p>
<p>Since <code>globals()</code> return a dictionary contains the names and the values and builtin names have a format like <code>__builtins__</code> you can filter them:</p>
<pre><code>&gt;&gt;&gt; print([var for var in globals().keys() if '__' not in var])
['someMethod', 'c', 'b', 'a', 'myList']
</code></pre>
<p>But note that it won't give you the local names inside the function like <code>something</code>. For that aim you can see <code>inspect</code> module <a href="https://docs.python.org/3/library/inspect.html#inspect.getmembers" rel="nofollow">https://docs.python.org/3/library/inspect.html#inspect.getmembers</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use dir() built-in for this. Suppose you save your file as test.py. You can do as follows:</p>
<pre><code>&gt;&gt;&gt; import test

&gt;&gt;&gt; dir(test)
['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'a', 'b', 'c', 'f', 'myList', 'someMethod']
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">Just wondering, should your output include <code>something</code> also?</span>
<span class="comment-copy">oh yes, I am sorry I will edit my question.. Thanks dude</span>
<span class="comment-copy">Why do you need all these names? This looks like a potential XY problem... <a href="http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem" title="what is the xy problem">meta.stackexchange.com/questions/66377/what-is-the-xy-problem</a></span>
<span class="comment-copy">there is the <code>ast</code> module for parsing code. <a href="http://stackoverflow.com/questions/32382963/how-to-parse-python-code-to-identify-global-variable-uses">this</a> is only sort of related (since it is looking for instances of global variables) but it might be a good start</span>
<span class="comment-copy">And <code>locals</code> also as the OP wants <code>something</code> to be printed.</span>
<span class="comment-copy">@BhargavRao: <code>locals</code> doesn't work unless it's performed while the function is being called. It can't get you the locals for a function you're not running.</span>
<span class="comment-copy">@ShadowRanger Yep. Correct. But I just added that comment to match the OPs output. (The OP is calling that inside the function. It'll also print <code>x</code>, the argument). Regards.</span>
<span class="comment-copy">@BhargavRao Thanks for attention I added a link to <code>inspect</code> module for more info.</span>
