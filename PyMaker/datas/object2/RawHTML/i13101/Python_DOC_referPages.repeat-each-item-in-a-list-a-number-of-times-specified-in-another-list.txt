<div class="post-text" itemprop="text">
<p>I have two lists, <code>x</code> and <code>y</code>:</p>
<pre><code>&gt;&gt;&gt; x = [2, 3, 4]
&gt;&gt;&gt; y = [1, 2, 3]
</code></pre>
<p>I want to use these to create a new list.  The new list will have each element in <code>x</code> repeated the number of times specified by the corresponding element in <code>y</code>.  Hence, the desired output is</p>
<pre><code>&gt;&gt;&gt; new_list
[2, 3, 3, 4, 4, 4]
</code></pre>
<p>The order of the elements in <code>new_list</code> doesn't matter to me.  It's also not crucial that it be a <code>list</code> -- any sequence type is fine.</p>
<p>What is the fastest, most efficient, most Pythonic way to achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>You can use list comprehension, like this</p>
<pre><code>&gt;&gt;&gt; x = [2, 3, 4]
&gt;&gt;&gt; y = [1, 2, 3]
&gt;&gt;&gt; [item for item, count in zip(x, y) for i in range(count)]
[2, 3, 3, 4, 4, 4]
</code></pre>
<p>Here, we <code>zip</code> the <code>x</code> and <code>y</code> so that the element from <code>x</code> and its corresponding count from <code>y</code> are grouped as a single tuple. Then, we iterate <code>count</code> number of items to produce the same item.</p></li>
<li><p>If your objects in <code>x</code> are immutables, then you can create <code>count</code> copies of the same and put them together in a list, like this</p>
<pre><code>&gt;&gt;&gt; [i for item, count in zip(x, y) for i in [item] * count]
[2, 3, 3, 4, 4, 4]
</code></pre></li>
<li><p>You can do the same lazily, with <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer"><code>itertools.repeat</code></a>, like this</p>
<pre><code>&gt;&gt;&gt; from itertools import chain, repeat
&gt;&gt;&gt; chain.from_iterable((repeat(item, count) for item, count in zip(x,y)))
&lt;itertools.chain object at 0x7fabe40b5320&gt;
&gt;&gt;&gt; list(chain.from_iterable((repeat(item, cnt) for item, cnt in zip(x,y))))
[2, 3, 3, 4, 4, 4]
</code></pre>
<p>Please note that the <code>chain</code> returns an iterable, not a list. So, if you don't want all the elements at once, you can get the items one by one from it. This will be highly memory efficient if the <code>count</code> is going to be a very big number, as we don't create the entire list in the memory immediately. We generate the values on-demand.</p></li>
<li><p><a href="https://stackoverflow.com/questions/33382474/repeat-each-item-in-a-list-a-number-of-times-specified-in-another-list/33382503?noredirect=1#comment54558615_33382503">Thanks ShadowRanger</a>. You can actually apply <code>repeat</code> over <code>x</code> and <code>y</code> and get the result like this</p>
<pre><code>&gt;&gt;&gt; list(chain.from_iterable(map(repeat, x, y)))
[2, 3, 3, 4, 4, 4]
</code></pre>
<p>here, <code>map</code> function will apply the values from <code>x</code> and <code>y</code> to <code>repeat</code> one by one. So, the result of <code>map</code> will be</p>
<pre><code>&gt;&gt;&gt; list(map(repeat, x, y))
[repeat(2, 1), repeat(3, 2), repeat(4, 3)]
</code></pre>
<p>Now, we use <code>chain.from_iterable</code> to consume values from each and every iterable from the iterable returned by <code>map</code>.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>numpy's <code>repeat</code> function gets the job done:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = [2, 3, 4]
&gt;&gt;&gt; y = [1, 2, 3]
&gt;&gt;&gt; np.repeat(x, y)
array([2, 3, 3, 4, 4, 4])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple using <code>for</code> loop.</p>
<pre><code>&gt;&gt;&gt; x = [2, 3, 4]
&gt;&gt;&gt; y = [1, 2, 3]
&gt;&gt;&gt; final = []
&gt;&gt;&gt; for index, item in enumerate(y):
        final.extend([x[index]]*item)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to achieve this is via using <a href="https://docs.python.org/3/library/collections.html#collections.Counter.elements" rel="nofollow noreferrer"><strong><code>.elements()</code></strong></a> function of <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><strong><code>collections.Counter()</code></strong></a> along with <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><strong><code>zip</code></strong></a>. For example:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter

&gt;&gt;&gt; x = [2, 3, 4]
&gt;&gt;&gt; y = [1, 2, 3]

# `.elements()` returns an object of `itertool.chain` type, which is an iterator.
# in order to display it's content, here type-casting it to `list` 
&gt;&gt;&gt; list(Counter(dict(zip(x,y))).elements())
[2, 3, 3, 4, 4, 4]
</code></pre>
</div>
<span class="comment-copy">Asking for the "fastest, most efficient, most Pythonic way" is like asking for the "fastest, safest, and most purple car".  While it's nice when the most Pythonic way is the fastest, caring overmuch about whether it's the fastest is as unpythonic as it gets.</span>
<span class="comment-copy">The <code>chain</code> approach can simplify to: <code>list(chain.from_iterable(map(repeat, x, y)))</code> (probably want to do <code>from future_builtins import map</code> if this is Py2, unnecessary on Py3).</span>
<span class="comment-copy">Could also use <code>list(chain.from_iterable(starmap(repeat, izip(x, y))))</code> as well, with <code>izip -&gt; zip</code> for python3.x ... Not sure if that's better though...</span>
<span class="comment-copy">@mgilson, any opportunity to use <code>starmap</code> must be considered Pythonic</span>
<span class="comment-copy">or <code>for i, j in zip(x, y): final += [i] * j</code></span>
