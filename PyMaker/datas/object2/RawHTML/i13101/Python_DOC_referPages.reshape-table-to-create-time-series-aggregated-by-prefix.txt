<div class="post-text" itemprop="text">
<p>I have a table similar to the following:</p>
<pre><code>name,time_in,time_out
jim,1/1/2000 08:24,1/1/2000 15:24
jim,1/2/2000 08:13,1/2/2000 16:24
jim,1/3/2000 08:14,1/3/2000 15:25
jim,1/4/2000 08:33,1/4/2000 16:23
linda,1/1/2000 08:24,1/1/2000 15:24
mark,1/2/2000 08:13,1/2/2000 16:24
mark,1/3/2000 08:14,1/3/2000 15:25
mark,1/4/2000 08:33,1/4/2000 16:23
</code></pre>
<p>Ignore the actual times, point is the days don't line up.  Most of what I've seen for re-shaping has everything nice and square, where my data may end up being sparse reshaped.  Is there an easy way (looking for R solutions, but open to Excel or anything quick) to create a table aggregation similar to the following:</p>
<pre><code>jim,1/1/2000 08:24,1/1/2000 15:24,1/2/2000 08:13,1/2/2000 16:24,1/3/2000 08:14,1/3/2000 15:25,1/4/2000 08:33,1/4/2000 16:23
linda,1/1/2000 08:24,1/1/2000 15:24
mark,1/2/2000 08:13,1/2/2000 16:24,1/3/2000 08:14,1/3/2000 15:25,1/4/2000 08:33,1/4/2000 16:23
</code></pre>
<p>Where each person is aggregated to one row (don't know how to handle headers either at this point, open for suggestions.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider this base R solution that uses a running count on the distinct names and the reshapes long to wide by count:</p>
<pre><code># RECREATING DATA FRAME
df &lt;- data.frame(name = c("Jim", "Jim", "Jim", "Jim", "linda", "mark", "mark", "mark"),
       time_in = c("1/1/2000 8:24", "1/2/2000 08:13", "1/3/2000 08:14", "1/4/2000 08:33",
                   "1/1/2000 08:24", "1/2/2000 08:13", "1/3/2000 08:14", "1/4/2000 08:33"),
       time_out = c("1/1/2000 15:24", "1/2/2000 16:24", "1/3/2000 15:25", "1/4/2000 16:23",
                    "1/1/2000 15:24", "1/2/2000 16:24", "1/4/2000 15:25", "1/4/2000 16:23"))

# COUNTING BY GROUPED NAMES
df$numcount &lt;- sapply(1:nrow(df),
                      function(i) sum(df[1:i, c("name")] == df$name[i]))

# RESHAPING LONG TO WIDE
reshapedf &lt;- reshape(df, v.names = c("time_in", "time_out"), 
                           timevar=c("numcount"), idvar = c("name"), 
                           direction = "wide")

row.names(reshapedf) &lt;- NULL

reshapedf
</code></pre>
<p><strong>OUTPUT</strong></p>
<pre><code>   name      time_in.1     time_out.1      time_in.2     time_out.2      time_in.3     time_out.3      time_in.4     time_out.4
1   Jim  1/1/2000 8:24 1/1/2000 15:24 1/2/2000 08:13 1/2/2000 16:24 1/3/2000 08:14 1/3/2000 15:25 1/4/2000 08:33 1/4/2000 16:23
2 linda 1/1/2000 08:24 1/1/2000 15:24           &lt;NA&gt;           &lt;NA&gt;           &lt;NA&gt;           &lt;NA&gt;           &lt;NA&gt;           &lt;NA&gt;
3  mark 1/2/2000 08:13 1/2/2000 16:24 1/3/2000 08:14 1/4/2000 15:25 1/4/2000 08:33 1/4/2000 16:23           &lt;NA&gt;           &lt;NA&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With the assumption that all the lines to be aggregated under the same name are contiguous, this Python script</p>
<pre><code>from itertools import groupby

with open('infile.txt') as in_f, open('outfile.txt', 'w') as out_f:
    next(in_f)  # skip header
    aggr = groupby(in_f, lambda line: line.partition(',')[0])
    for k, lines in aggr:
        slines = (l.lstrip(k+',').rstrip() for l in lines)
        out_line = k+','+','.join(slines)+'\n'
        out_f.write(out_line)
</code></pre>
<p>does the trick.</p>
<p>For example, with an input file of</p>
<pre><code>name,time_in,time_out
jim,1/1/2000 08:24,1/1/2000 15:24
jim,1/2/2000 08:13,1/2/2000 16:24
jim,1/3/2000 08:14,1/3/2000 15:25
jim,1/4/2000 08:33,1/4/2000 16:23
linda,1/1/2000 08:24,1/1/2000 15:24
mark,1/2/2000 08:13,1/2/2000 16:24
mark,1/3/2000 08:14,1/3/2000 15:25
mark,1/4/2000 08:33,1/4/2000 16:23
</code></pre>
<p>it produces an output file of</p>
<pre><code>jim,1/1/2000 08:24,1/1/2000 15:24,1/2/2000 08:13,1/2/2000 16:24,1/3/2000 08:14,1/3/2000 15:25,1/4/2000 08:33,1/4/2000 16:23
linda,1/1/2000 08:24,1/1/2000 15:24
mark,1/2/2000 08:13,1/2/2000 16:24,1/3/2000 08:14,1/3/2000 15:25,1/4/2000 08:33,1/4/2000 16:23
</code></pre>
<p>It leverages the power of <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow">itertools.groupby</a></p>
<p>Basically, it keeps grouping the lines as long as the prefix (i.e. the name) doesn't change. When it does it moves on, creating another group on the newly found prefix.
It then simply joins the elements of each group on a single line, separated by ','</p>
<p>Note: in case you want the header to appear in the output file, change the line</p>
<pre><code>    next(in_f)  # skip header
</code></pre>
<p>to</p>
<pre><code>    out_f.write(next(in_f))  # write and skip header
</code></pre>
</div>
