<div class="post-text" itemprop="text">
<p>I have been learning Python in my spare time for a small amount of time now and I set myself a challenge to build a password cracker for a very specific task, it was to test how effective the security on my ADSL Router was (not very) - using Wireshark I could quite clearly see how it was hashing the password over http and I developed some code to perform a wordlist attack. (I apologise if you think my code is badly written - you would probably be correct!).</p>
<pre><code>#!/usr/bin/env python

import hashlib, os, time, math
from hashlib import md5

def screen_clear():
    if os.name == 'nt':
        return os.system('cls')
    else:
        return os.system('clear')

screen_clear()

print ""
print "Welcome to the Technicolor md5 cracker"
print ""

user = raw_input("Username: ")
print ""
nonce = raw_input("Nonce: ")
print ""
hash = raw_input("Hash: ")
print ""
file = raw_input("Wordlist: ")
print ""

realm = "Technicolor Gateway"
qop = "auth"
uri = "/login.lp"

HA2 = md5("GET" + ":" + uri).hexdigest()

wordlist = open(file, 'r')

time1 = time.time()

for word in wordlist:
    pwd = word.replace("\n","") 
    HA1 = md5(user + ":" + realm + ":" + pwd).hexdigest()
    hidepw = md5(HA1 + ":" + nonce +":" + "00000001" + ":" + "xyz" + ":" + qop + ":" + HA2).hexdigest()
    if hidepw == hash:
        screen_clear()
        time2 = time.time()
        timetotal = math.ceil(time2 - time1)
        print pwd + " = " + hidepw + " (in " + str(timetotal) + " seconds)"
        print ""
        end = raw_input("hit enter to exit")
        exit()

wordlist.close()

screen_clear()
time2 = time.time()
totaltime = math.ceil(time2 - time1)
print "Sorry, out of " + str(tested) + " passwords tested, your password was not found (in " + str(totaltime) + " seconds)"
print ""
end = raw_input("hit enter to exit")
screen_clear()
exit()
</code></pre>
<p>This works well enough but has left me wanting more, so I thought I could add some Multiprocessing power to it to speed things up - using various different instructions and guides I have failed to end up with a successful result! (although feeling like i was very close)</p>
<p>Please could someone either point me towards "An idiots guide to multicore python password cracking" or help my modify my code to suit.</p>
<p>P.S. my original plan was to use opencl or cuda...but I quickly learned how out of my depth I was!</p>
</div>
<div class="post-text" itemprop="text">
<p>I have made an example for you that should be relatively easy to add into your code.  Here is how it works; First, we need to brake up the <code>wordlist</code> into manageable chunks that we can throw into the multiprocessor module.  I do this by making a list with a dictionary of 'starting' and 'stopping' points.  Next, I pass those arguments into <code>apply_async</code> which will in turn run the <code>pwd_find</code> function.  This is the function you want to add your <code>for word in wordlist:</code> loop, but with a starting and stopping point (see code below).</p>
<pre><code>from multiprocessing import Pool
import math
import time

cores = 4  # Number of cores to use
wordlist = []

for i in range(127):  # Remove this for your own word list.
    wordlist.append(str(i))  # Creates a large 'word' list for testing.

def pwd_find(start, stop):

    for word in range(start, stop):
        print(wordlist[word])
        time.sleep(0.1)  # Slows things down so it's easier to see that your system is using more than one core.
        ### Add your code here... ###


break_points = []  # List that will have start and stopping points
for i in range(cores):  # Creates start and stopping points based on length of word list
    break_points.append({"start":math.ceil(len(wordlist)/cores * i), "stop":math.ceil(len(wordlist)/cores * (i + 1))})

if __name__ == '__main__':  # Added this because the multiprocessor module acts funny without it.

    p = Pool(cores)  # Number of processors to utilize.
    for i in break_points:  # Cycles though the breakpoints list created above.
        print(i)  # shows the start and stop points.
        a = p.apply_async(pwd_find, kwds=i, args=tuple())  # This will start the separate processes.
    print("Done!")
    p.close()
    p.join()
</code></pre>
<p>If your code finds a match, add <code>p.terminate</code> followed by <code>p.join</code> to kill the processors.</p>
<p>If you would like to lean more about the multiprocessor module, <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply_async" rel="nofollow">go here</a> to learn more.</p>
<p>I hope this helps you out, or at the very least, gives you a better insight into multiprocessing!</p>
</div>
<span class="comment-copy">That you very much for the detailed answer, due to work commitments I haven't had time to get back home to try this out, I will be sure to let you know of my success on my return!</span>
<span class="comment-copy">Spent the evening getting my code to work, and it is now giving me a correct answer (will now compare to see how much quicker it is)! thanks for your help - you explained just enough for me to still do some thinking! one problem was that the dictionary contained an float intead of an integer (easily solved) but took me a while to work out how to output any error from within the apply_async processes ( print (a.get()) ) - it was all very interesting and i have certainly learned a lot</span>
<span class="comment-copy">Just to follow this up, it just about halfed the time needed to run through the entire "rockyou.txt" wordlist on my hyperthreaded dual core laptop! Fantastic.</span>
