<div class="post-text" itemprop="text">
<p>Is there a way to access the list as it is comprehended? In particular I'd like to iterate once again over elements already added.</p>
<p>for example, im looking for something like this:</p>
<pre><code>[x for x in range(foo) if x not in self]
</code></pre>
<p>or</p>
<pre><code>[x for x in range(foo) if any(y for y in self)]
</code></pre>
<p>where self would be the just-comprehended list itself.</p>
</div>
<div class="post-text" itemprop="text">
<p>In short: No. You cannot do this. Python's list comprehensions (and related constructs like generator expressions) are not as powerful as Haskell's lazy lists (which could do what you want). The syntax is similar, but Python is not pure a functional language with lazy, recursive evaluation as a syntax feature; its interpreter isn't sophisticated enough to understand and handle behaviors like this.</p>
<p>More complicated answer: You could hack your way around it in specific cases by misusing list comprehensions (e.g. the <code>set</code> updating hack used in acushner's answer). But list comprehensions should generally strive to be transformations and filters of existing data; they should not perform other work by side-effect, because it makes the code much more complicated, confusing maintainers. List comprehensions are a functional pattern; side-effects are distinctly non-functional, so people don't look for or expect them. If you need to do something like this, it's a much better idea to write a function (possibly a generator function) that can isolate the complexity and maintain internal state that tracks the values produced so far. The various uniquifying recipes provided in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertools</code> recipes</a> are a good example.</p>
<p>Getting rather advanced: Haskell can do this because its list comprehensions can be lazy, yet reusable (it has memory). So Haskell can have its cake and eat it too; a list can define elements in terms of previous elements, because those elements will be generated if needed, and can be read more than once. Python separates laziness from reusability. A list comprehension is evaluated eagerly; it finishes being populated before it's actually bound to a name you could use to access it (so it can't read values from the intermediate list as its being built). A generator expression is mostly lazy (it binds the iterable it's working on eagerly, but everything else is lazy) so by the time it's evaluated, it could be bound to a name, but it has no memory; you can't use values from the genexpr inside the genexpr because doing so would necessarily advance the generator (and in most cases I can think of, lead to infinite recursion as it tried to repeatedly define the next result in terms of the next result, over and over).</p>
</div>
<div class="post-text" itemprop="text">
<p>first, <code>any(y for y in self)</code> is just <code>any(self)</code>.</p>
<p>second, your function won't do anything. what you're effectively writing is:</p>
<pre><code>res = []
for x in range(foo):
    if any(res):
        res.append(x)
</code></pre>
<p>which is just an empty list.</p>
<p>what  you want is a <code>set</code>.</p>
<pre><code>res = set(values)
</code></pre>
<p>if you care about order, you can do something like:</p>
<pre><code>seen = set()
[x for x in values if x not in seen and not seen.add(x)]
</code></pre>
</div>
<span class="comment-copy">You can't, this is a problem I came across recently and there is no method of doing so.You'll just have to use a regular for loop and list.append()</span>
<span class="comment-copy">A <code>list</code> comprehension is a literal expression of a <code>list</code>. You can't inspect it before it's created.</span>
<span class="comment-copy">Can it be done with a generator then?</span>
<span class="comment-copy">@Slimior: No, not in any way that wouldn't contort Python in horribly ugly ways. Haskell comprehensions can be defined recursively like this, Python's cannot.</span>
<span class="comment-copy">@ShadowRanger add that as an answer, you told me exactly what i needed</span>
<span class="comment-copy">This does not answer my question. The example with <code>any()</code> is just to simply show that i want to be able to iterate over already generated items, the actual purpose is more complicated and cannot be done with <code>set</code>. Already thought about it ;)</span>
<span class="comment-copy">what's a specific use case for this?</span>
