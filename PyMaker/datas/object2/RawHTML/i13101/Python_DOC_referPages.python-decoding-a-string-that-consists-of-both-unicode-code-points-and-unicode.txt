<div class="post-text" itemprop="text">
<p>Parsing some HTML content I got the following string:</p>
<pre><code>АБВ\u003d\"res
</code></pre>
<p>The common advice on handling it appears to be to decode using unicode_escape. However, this results in the following:</p>
<pre><code>ÐÐÐ="res
</code></pre>
<p>The escaped characters get correctly decoded, but cyrillic letters for some reason get mangled. Other than using regexes to extract everything that looks like a unicode string, decoding only them using unicode_escape and then putting everything into a new string, which other methods exist to decode strings with unicode code points in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>unicode_escape</code> treats the input as <em>Latin-1 encoded</em>; any bytes that do not represent a Python string literal escape sequence are decoded mapping bytes directly to Unicode codepoints. You gave it UTF-8 bytes, so the cyrillic characters are represented with 2 bytes each where decoded to two Latin-1 characters each, one of which is U+00D0 <code>Ð</code>, the other unprintable:</p>
<pre><code>&gt;&gt;&gt; print repr('АБВ\\u003d\\"res')
'\xd0\x90\xd0\x91\xd0\x92\\u003d\\"res'
&gt;&gt;&gt; print repr('АБВ\\u003d\\"res'.decode('latin1'))
u'\xd0\x90\xd0\x91\xd0\x92\\u003d\\"res'
&gt;&gt;&gt; print 'АБВ\\u003d\\"res'.decode('latin1')
ÐÐÐ\u003d\"res
</code></pre>
<p>This kind of mis-decoding is called a <a href="https://en.wikipedia.org/wiki/Mojibake" rel="nofollow">Mojibake</a>, and can be repaired by re-encoding to Latin-1, then decoding from the correct codec (UTF-8 in your case):</p>
<pre><code>&gt;&gt;&gt; print 'АБВ\u003d\\"res'.decode('unicode_escape')
ÐÐÐ="res
&gt;&gt;&gt; print 'АБВ\u003d\\"res'.decode('unicode_escape').encode('latin1').decode('utf8')
АБВ="res
</code></pre>
<p>Note that this will <em>fail</em> if the <code>\uhhhh</code> escape sequences encode codepoints outside of the Latin-1 range (U+0000-U+00FF).</p>
<p>The Python 3 equivalent of the above uses <a href="https://docs.python.org/3/library/codecs.html#codecs.encode" rel="nofollow"><code>codecs.encode()</code></a>:</p>
<pre><code>&gt;&gt;&gt; import codecs
&gt;&gt;&gt; codecs.decode('АБВ\\u003d\\"res', 'unicode_escape').encode('latin1').decode('utf8')
'АБВ="res'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The regex really is the easiest solution (Python 3):</p>
<pre><code>text = 'АБВ\\u003d\\"re'
re.sub(r'(?i)(?&lt;!\\)(?:\\\\)*\\u([0-9a-f]{4})', lambda m: chr(int(m.group(1), 16)), text)
</code></pre>
<p>This works fine with any 4-nibble Unicode escape, and can be pretty easily extended to other escapes.</p>
<p>For Python 2, make all strings <code>u''</code> strings, and use <code>unichr</code>.</p>
</div>
<span class="comment-copy">Please show us a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> that shows this behaviour, including a <code>repr()</code> output of the original value you decoded.</span>
<span class="comment-copy">Presumably this is Python 2.7 and the input is a <i>byte string</i>? So the repr could be <code>'\xd0\x90\xd0\x91\xd0\x92\\u003d\\"res'</code>.</span>
<span class="comment-copy">@MartijnPieters This <i>is</i> a minimal example. repr() output is      <code>Ð\x90Ð\x91Ð\x92="res</code> And no, this is Python 3.</span>
<span class="comment-copy">No it is not. There is no code. I had to guess as to how to reproduce your output.</span>
<span class="comment-copy">And a proper MCVE would have shown us you are using Python 3.</span>
<span class="comment-copy">On Python 2, this will only work for U+0000-U+00FF.</span>
<span class="comment-copy">OK, noted that this is for Python 3. (Using unicode strings and <code>unichr</code> makes it work for Python 2)</span>
<span class="comment-copy">The OP is almost certainly using Python 2 however; they have a UTF-8 bytestring (which is why they get the Mojibake output they posted in their question).</span>
