<div class="post-text" itemprop="text">
<p>I noticed by chance that a simple program generating a class from a large datafile ran a lot faster in Python 2.7 vs. 3.5. I read <a href="https://stackoverflow.com/questions/23453133/is-there-a-reason-python-3-enumerates-slower-than-python-2">here</a> that the use of "infinite precision" integers was to blame for slowdown in simple enumeration, but even when I tried a simple test instantiating this class I found that Python 3 was significantly slower:</p>
<pre><code>class Benchmark(object):
    def __init__(self):
        self.members = ['a', 'b', 'c', 'd']


def test():
    test = Benchmark()

if __name__ == '__main__':
    import timeit
    print(timeit.timeit("test()", setup="from __main__ import test"))
</code></pre>
<p>I thought perhaps it was something to do with the size of each class instance, but the Python 3 instance was smaller than 2 (56 vs. 64)</p>
<pre><code>$python3 benchmarks.py
0.7017288669958361
$python benchmarks.py
0.508942842484
</code></pre>
<p>I have tried many variations on this theme, including with 3.4 on a different machine, and still get the same results. Any ideas what's going on?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are not measuring class instantiation time, you are measuring class instantiation, plus assignment, plus list creation, ...</p>
<p>Here's a correct benchmark:</p>
<pre><code>$ python -m timeit -s 'class C(object): pass' 'C()'
10000000 loops, best of 3: 0.0639 usec per loop
$ python3 -m timeit -s 'class C(object): pass' 'C()'
10000000 loops, best of 3: 0.0622 usec per loop
</code></pre>
<p>As you can see, Python 3 is sightly faster.</p>
</div>
<span class="comment-copy">The linked duplicate is about Python 3 being faster than Python 2, while this question is about the other way around.  Voting to reopen.</span>
<span class="comment-copy">What do you get if simply run <code>timeit("Benchmark()", ...)</code>? It sounds like you don't really want to time the function call, the variable assignment, etc. And what if you only time the list creation?</span>
<span class="comment-copy">I get the same results as you until I pare this down to just the class. I did just <code>class A: pass</code> then changed your <code>timeit</code> call to <code>timeit("A()", setup="from __main__ import A")</code> and Py2 was twice as slow as Py3. Whatever the initial results, I doubt this has to do with object instantiation. If I make that <code>class A(object): pass</code>, the results are indistinguishable.</span>
<span class="comment-copy">Is instance creation really a bottleneck for any real code? I'd guess that any other work you do with your class is going to be orders of magnitude slower than the class creation, so I wouldn't worry about how long it takes. If you've profiled your code and see that this is really an issue, then sure, you should investigate it, but I doubt that's the case.</span>
<span class="comment-copy">I'm more just curious, quibbling over 20secs to run something vs 5 seconds for Py2, but does seem a little odd that Py3 should be slower. I stripped it down to just timing instantiation of a completely empty class and I'm still finding 3 slower than 2, on both macbook pro and work machine running ubuntu with i7-4790K 4.00GHz processor and 16gb ram, both versions installed in same place and everything.</span>
<span class="comment-copy">In addition, Python 3 is saving more memory than you think; the total size overhead of an instance is the <code>sys.getsizeof</code> for the instance plus the <code>sys.getsizeof</code> for its <code>__dict__</code> (unless <code>__dict__</code> was suppressed at C layer or using <code>__slots__</code>). <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-412" rel="nofollow noreferrer">Python 3.3 introduced shared key dictionaries</a>, so in addition to the object structure shrinking a little (8 bytes on x64), the size of <code>__dict__</code> for single attribute instances drops by a factor of ~3x (on my Linux x64 machine, from 280 bytes to 96 bytes). Big savings for lots of instances.</span>
<span class="comment-copy">Andrea: You might want to have the test assign a single compile time literal member; while list construction, function calls and item assignment aren't properly part of a good test, assigning at least one instance attribute in <code>__init__</code> should be part of a reasonable test.</span>
<span class="comment-copy">@ShadowRanger: if you mix too many things in benchmarks, you'll never find out what's wrong. This question is a clear-cut example: the OP thinks class instantiation is slower while it's not.</span>
<span class="comment-copy">Yeah, all I'm saying is that for most people, initializing the members is part and parcel of "class instantiation". Just use a literal that can be expressed with a <code>LOAD_CONST</code> in the byte code (e.g. empty <code>tuple</code> <code>()</code> or <code>int</code> <code>0</code>) and you'll limit additional confounding factors, while still testing a fairly important part of instance creation. Shared key dictionaries may slightly slow instance creation, though the benefits in other cases (lower memory use, often higher speed in use) is usually worth it.</span>
<span class="comment-copy">Yeah I realised that after shx2's comment on the original post. I'm still getting the same issues, comparing python3.5 with 2.7.1.   <code>$ python -m timeit -s 'class C(object): pass' 'C()' </code> <code>10000000 loops, best of 3: 0.0896 usec per loop </code> <code>$ python3 -m timeit -s 'class C(object): pass' 'C()' </code> <code>10000000 loops, best of 3: 0.106 usec per loop</code></span>
