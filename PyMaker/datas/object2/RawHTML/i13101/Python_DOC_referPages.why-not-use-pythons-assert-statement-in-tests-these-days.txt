<div class="post-text" itemprop="text">
<p>In Python testing, why would you use assert methods:</p>
<pre><code>self.assertEqual(response.status_code, 200)
self.assertIn('key', my_dict)
self.assertIsNotNone(thing)
</code></pre>
<p>As opposed to the direct assertions:</p>
<pre><code>assert response.status_code == 200
assert 'key' in my_dict
assert thing is not None
</code></pre>
<p>According to the <a href="https://docs.python.org/3/library/unittest.html#basic-example" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>These methods are used instead of the assert statement so the test runner can accumulate all test results and produce a report</p>
</blockquote>
<p>However this seems to be bogus, a test runner can accumulate results and produce a report regardless.  In a <a href="https://stackoverflow.com/a/2958450/674039">related post</a> unutbu has shown that unittest will raise an <code>AssertionError</code> just the same as the assert statement will, and that was over 7 years ago so it's not a shiny new feature either.</p>
<p>With a modern test runner such as pytest, the failure messages generated by the assertion helper methods aren't any  more readable (arguably the camelCase style of unittest is <em>less</em> readable). <strong>So, why not just use assert statements in your tests?</strong>  What are the perceived disadvantages and why haven't important projects such as CPython moved away from unittest yet?</p>
</div>
<div class="post-text" itemprop="text">
<p>The link to the docs that you found is the correct answer. If you do not like this style of writing tests I would highly suggest using pytest:</p>
<p><a href="http://pytest.org/latest/" rel="nofollow">http://pytest.org/latest/</a></p>
<p>pytest has done a bunch of work that allows you to use the assert statement the way you want to. It also has a bunch of other really nice features such as their fixtures.</p>
</div>
<div class="post-text" itemprop="text">
<p>The key difference between using <code>assert</code> keyword or dedicated methods is the output report. Note that the statement following <code>assert</code> is always <code>True</code> or <code>False</code> and can't contain any extra information.</p>
<pre><code>assert 3 == 4
</code></pre>
<p>will simply show an <code>AssertionError</code> in the report.
However,</p>
<pre><code>self.assertTrue(3 == 4)
</code></pre>
<p>Gives some extra info: <code>AssertionError: False is not true</code>. Not very helpful, but consider:</p>
<pre><code>self.assertEqual(3, 4)
</code></pre>
<p>It's much better as it tells you that <code>AssertionError: 3 != 4</code>. You read the report and you know what kind of assertion it was (equality test) and values involved.</p>
<p>Suppose you have some function, and want to assert value it returns.
You can do it in two ways:</p>
<pre><code># assert statement
assert your_function_to_test() == expected_result

# unittest style
self.assertEqual(your_function_to_test(), expected_result)
</code></pre>
<p>In case of error, the first one gives you no information besides the assertion error, the second one tells you what is the type of assertion (equality test) and what values are involved (value returned and expected).</p>
<p>For small projects I never bother with unittest style as it's longer to type, but in big projects you may want to know more about the error.</p>
</div>
<span class="comment-copy">I work so far out of <code>unittest</code> that I use <code>print()</code> instead of <code>assert</code>. I think it all depends on the complexity and scale of your project.</span>
<span class="comment-copy">This seems to be mostly a matter of opinion. If you think <code>assert</code> is superior then there's nothing that prevents (besides maybe your colleagues disagreeing) you from using that. However it should be known that you might override methods in the <code>TestCase</code> class and customize the behaviour - the <code>assert</code> statement doesn't have this flexibility. Also the <code>TestCase.failureException</code> may be altered which invalidates your point about it being the same exception that's thrown as from the <code>assert</code> statement (this could be used if you want to consider <code>assert</code> an error instead of failure).</span>
<span class="comment-copy">Just plain <code>assert</code> is far more readable. So always use <code>pytest</code> if your tests fail.</span>
<span class="comment-copy">@o11c Yeah, I agree.  But the question is more about, why all these <code>self.assertStuff</code> methods exist at all and why do many well-respected libraries still actively use them.</span>
<span class="comment-copy">I do use pytest, as mentioned in the question.  How can the claim in the docs be considered correct, when the test runner happily accumulates all test results and produces a report regardless of whether you use assert statements or the helper functions?</span>
<span class="comment-copy">You can add an arbitrary string to an assertion, to be included in the raised <code>AssertionError</code>: <code>assert 3 == 4, "3 != 4"</code>.</span>
<span class="comment-copy">More importantly, the test runner / test framework is able to automatically generate the context.</span>
