<div class="post-text" itemprop="text">
<p>Here is a simple Python (version 3.4) code I've written to get a 32bit sized integer (int type I would assume) from an array of 4 bytes:</p>
<pre><code>import binascii
import socket   
import struct
import array
import pickle
import ctypes
import numpy
import sys

float_val = 1.0 + 0.005
print(float_val)

packed = struct.pack('f', float_val)
print(len(packed)) 

tempint2 = struct.unpack("&gt;I", packed)[0]
tempint3 = struct.unpack_from("&gt;I", packed)[0]
tempint4 = int.from_bytes(packed, byteorder='big', signed=False)

print(sys.getsizeof(tempint2))
print(tempint2)
print(sys.getsizeof(tempint3))
print(tempint3)
print(sys.getsizeof(tempint4))
print(tempint4)
</code></pre>
<p>However, none of the attempts (tempint2/tempint3/tempint4) gives the value I expected (4-byte size integer). Somehow, the size is all 18 bytes (sys.getsizeof() function result). Can you tell me how to get the expected answer (4-byte or 32bit size integer)?</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, due to Python's... ahem... "magic", <code>sys.getsizeof()</code> won't return the <code>len</code>gth of a <code>list</code>, but the <code>sizeof</code> the whole datastructure as represented internally by the Python interpreter.</p>
<p>Now, the answer (for integers) is simply... (for all combinations of Python 2.x/Python 3.x and 32-bit/64-bit):</p>
<pre><code>from math import ceil, floor, log

def minimumAmountOfBytesToHoldTheStuff(x):
    # Avoid math domain errors
    if x &lt; 0:
        x = ~x

    # Avoid more math domain erros
    if x == 0:
        x = 1

    return int(ceil((floor(log(x, 2)) + 1 ) / 8))

def powersOfTwo():
    x = 1
    while True:
        yield x
        x *= 2

def minimumAmountOfBytesToHoldTheStuffOnRealMachines(x):
    bytes = minimumAmountOfBytesToHoldTheStuff(x)
    for power in powersOfTwo():
        if bytes &lt;= power:
            return power

print(minimumAmountOfBytesToHoldTheStuffOnRealMachines(tempint))
</code></pre>
<p><strong>Note</strong>: It appears that <code>log(x, 2)</code> breaks for <code>x &gt;= pow(2, 48) - 1</code>, and so does the whole algorithm. This is probably an issue from the C library/the stupid floating-point accurracy errors, because <code>log(n, x)</code> in Python is translated into <code>log(n) / log(x)</code> in C.</p>
<p><strong>Edit</strong>: This one is an optimized version for Python 3.x that is independent of bot floating-point and logarithmic operations, and thus is accurate on all situations...</p>
<pre><code>from math import ceil

def minimumAmountOfBytesToHoldTheStuff(x):
    # Avoid math domain errors
    if x &lt; 0:
        x = ~x

    # Avoid more math domain erros
    if x == 0:
        x = 1

    return int(ceil(x.bit_length() / 8))
</code></pre>
<p>The other functions are the same.</p>
<p>I hope this has led some light on you!</p>
</div>
<span class="comment-copy"><code>sys.getsizeof() </code> includes the overhead of the python object ... you can use numpy to create an array of actual 4 byte integers ... or just deal with the fact that is is 4 bytes of number data and 12 bytes of python object overhead (this is almost definately fine....) is it not giving you the actual value you expect for the number? if not what do you expect vs what do you get?</span>
<span class="comment-copy">This code sniffet is from another python program where I created 4-byte int array by using numpy. What I want to do is like this (in C): float f = 1.005; unsigned int a = *(unsigned int *)(&amp;f); However, the python complains that the numpy 32bit int cannot accomodate the int came from the code sniffet above.</span>
<span class="comment-copy">capital I is unsigned 4 byte int ... if you want negative values you will need lowercase i (I think)</span>
<span class="comment-copy">If you're trying to get a 32-bit float, why aren't you asking <code>struct</code> to give you one of those instead?</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/444591/convert-a-string-of-bytes-into-an-int-python">convert a string of bytes into an int (python)</a></span>
<span class="comment-copy">That's funny, <code>math.log(2**33, 2)</code> works fine for me in Python 2.7.5, returns <code>33.0</code>.</span>
<span class="comment-copy">@MarkRansom: Try out <code>math.log(2**48-1, 2)</code>. The function works out whenever <code>x</code> is a perfect power of 2, but not otherwise if <code>x &gt;= pow(2, 48) - 1</code>. <b>Edit</b>: Sorry, I originally stated the barrier was at <code>2^32</code>, whereas it is at <code>2^48</code>.</span>
<span class="comment-copy">@KemyLand: Note that Python 3's <a href="https://docs.python.org/3/library/math.html#math.log2" rel="nofollow noreferrer"><code>math</code> module offers a <code>log2</code> function</a> that computes more accurately. And for computing bits required to hold a value, it provides the even more useful/efficient <code>bit_length()</code> method on <code>int</code>s. Since the OP is using Python 3.4, you could use <code>x.bit_length()</code> for speed and accuracy.</span>
<span class="comment-copy">@ShadowRanger: Thanks, I didn't noticed the OP was using 3.4, so I'll leave the code as-is for 2.x readers and add a modified/optimized version for 3.4.</span>
