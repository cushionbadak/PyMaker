<div class="post-text" itemprop="text">
<p>In Python 3.5.0 this code:</p>
<pre><code>a = (1,2)
class Foo(object):
    b = (3,4)
    c = tuple((i,j) for j in b for i in a)
    d = tuple((i,j) for i in a for j in b)
</code></pre>
<p>produces:</p>
<pre><code>Traceback (most recent call last):
  File "genexprtest.py", line 2, in &lt;module&gt;
    class Foo(object):
  File "genexprtest.py", line 5, in Foo
    d = tuple((i,j) for i in a for j in b)
  File "genexprtest.py", line 5, in &lt;genexpr&gt;
    d = tuple((i,j) for i in a for j in b)
NameError: name 'b' is not defined
</code></pre>
<p>Why do I get this error? And why do I not get this error on the previous line?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is because the expression <code>for i in a</code> has a <strong>local variable scope</strong>, and expression <code>for j in b</code> is inside the scope, thus, no <code>b</code> is found.<br/>
Actually, if you write <code>c = tuple((i, j) for i in a for j in b)</code>, it will throw the same exception.  </p>
<p>The solution is put <code>b</code> into scope of class definition (as you already did) and refer it by <code>self.b</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I spent ages experimenting and I have a theory about why you're getting this error. I'm not certain but this does explain why it works for <code>c</code> and not for <code>d</code>. I hope this helps you, comment if you disagree :)</p>
<pre><code>def Tuple(this):
    print(a) # this always works
    try:
        print(b) # this always gives an error
    except NameError:
        print("...b is not defined")
    try:
        return tuple(this) # this only gives an error for d and e
    except NameError:
        print("...couldn't make it a tuple")


a = (1,2)     
class Foo(object):
    b = (3,4)
    c = Tuple((i,j) for j in b for i in a)
    d = Tuple((i,j) for i in a for j in b)
    e = Tuple((i,j,k) for i in a for j in b for k in (5, 6))
    f = Tuple((i,j,k) for j in b for i in (5, 6) for k in a)

    print("\nc:", c,"\nd:", d,"\ne:", e,"\nf:", f)
</code></pre>
<p><strong>What happened:</strong> every time I called the <code>Tuple()</code> function, <code>b</code> was not defined, but <code>a</code> was always defined. This explains why you get an error for <code>d</code> and <code>e</code> but it doesn't explain why <code>c</code> and <code>f</code> work even though <code>b</code> is 'not defined'</p>
<p><strong>My theory:</strong> The first <code>for</code> loop is calculated before the whole thing is converted into a tuple. For example, if you tried to do this: <code>Tuple((a, b, c) for a in loop1, for b in loop2 for c in loop3)</code>, in the Foo class it would calculate <code>for a in loop1</code> first, then it would move to the foo and calculate the loops 2 and 3.</p>
<p><strong>In summary:</strong> </p>
<ol>
<li>does first for loop</li>
<li>moves to tuple function</li>
<li>does the remaining loops</li>
<li>the error occurs if a variable in the 2nd or 3rd loop is in class Foo</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>In my opinion, the error arises because <code>b</code> is defined as a class variable. To properly use it, you need to treat it as such (<code>self.b</code>).
Also, you should use constructor:</p>
<pre><code>a = (1, 2)

class Foo(object):
    def __init__(self):
        self.b = (3, 4)
        self.c = tuple((i, j) for j in self.b for i in a)
        self.d = tuple((i, j) for i in a for j in self.b)
</code></pre>
<p>This is a clearer code. And it behaves properly. Hope it helps.</p>
<p>EDIT: if you don't want to use <code>__init__</code>, there is also a possibility to get <code>c</code> and <code>d</code> using methods:</p>
<pre><code>a = (1, 2)

class Foo(object):
    b = (3, 4)

    def get_c(self):
        return tuple((i, j) for j in self.b for i in a)

    def get_d(self):
        return tuple((i, j) for i in a for j in self.b)
</code></pre>
<p>This also works perfectly fine.
You can try both implementations like this:</p>
<pre><code>inst = Foo()
# 1st one
print(inst.c)
print(inst.d)
# 2nd one
print(inst.get_c())
print(inst.get_d())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <strong>solution</strong> to your specific case is to use <a href="https://docs.python.org/2/library/itertools.html#itertools.product" rel="nofollow noreferrer">itertools</a>:</p>
<pre><code>d = tuple(itertools.product(a, b))
</code></pre>
<p>The <strong>explanation</strong> for the seemingly unexpected behavior is twofold:</p>
<ol>
<li><p>Bare class attributes such as <code>b</code> are only accessible in the <strong>root class scope</strong>. See <a href="https://www.python.org/dev/peps/pep-0227/#discussion" rel="nofollow noreferrer">pep 227</a>:</p>
<blockquote>
<p>Names in class scope are not accessible. Names are resolved in the innermost enclosing function scope. If a class definition occurs in a chain of nested scopes, the resolution process skips class definitions.</p>
</blockquote></li>
<li><p>Nested loops in generators <strong>don't function like you might expect</strong>. The first loop is actually the outermost and the second the innermost. From python <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>Subsequent for clauses cannot be evaluated immediately since they may depend on the previous for loop. For example: (x*y for x in range(10) for y in bar(x)).</p>
</blockquote></li>
</ol>
<p>The second point can be illustrated with added line-breaks.</p>
<pre><code>d = tuple((i,j) 
    for i in a
        for j in b)
</code></pre>
<p>This means that <code>b</code> is actually referenced from the inner loop (nested scope) and thus a <code>NameError</code> is thrown. In the first generator however, the reference is in the outer one which works fine.</p>
</div>
<span class="comment-copy">Because generator expressions and class definitions are both their own scope</span>
<span class="comment-copy">But if they are both in their own scope, why the heck does the access to b in the previous line (c=...) succeed?</span>
<span class="comment-copy">In the first example, <code>b</code> iterated over in the outermost <code>for</code> expression, which is evaluated immediately - see e.g. <a href="https://www.python.org/dev/peps/pep-0289/#early-binding-versus-late-binding" rel="nofollow noreferrer">python.org/dev/peps/pep-0289/#early-binding-versus-late-binding</a> for the rationale. Similarly, if you change the example in the docs to <code>b = list(i for i in range(a))</code> it works fine, and <code>d = tuple((i,j) for i, j in itertools.product(b, a))</code> will work either way around.</span>
<span class="comment-copy">So the immediate evaluation does not happen within the generator expression scope but rather in the scope surrounding the generator expression definition. Is this intentional and specified somewhere in the Python docs?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer"><i>"...the leftmost for clause is immediately evaluated... Subsequent for clauses cannot be evaluated immediately since they may depend on the previous for loop"</i></a></span>
