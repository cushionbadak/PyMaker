<div class="post-text" itemprop="text">
<p>The related question <a href="https://stackoverflow.com/questions/243865/how-do-i-merge-two-python-iterators">How do I merge two python iterators?</a> works well for two independent iterators.  However, I haven't been able to find or think of the tools necessary for merging two iterators where one is recursive and takes the other as an input.  I have iterator <code>stuff</code> that is a simple list.  Then I have iterator <code>theta</code> that takes a function <code>func</code> and yields x, func(x), func(func(x)), where one of the inputs to <code>func</code> is an element of <code>stuff</code>.  I've solved this with mutable state as follows:</p>
<pre><code>theta = some_initial_theta
for thing in stuff:
    theta = update_theta(theta, thing)
return theta
</code></pre>
<p>A concrete example in this format:</p>
<pre><code>def update_theta(theta, thing):
    return thing * 2 + theta

stuff = [100, 200, 300, 400]


def my_iteration():
    theta = 0
    for thing in stuff:
        theta = update_theta(theta, thing)
    print(theta)
# This prints 2000
</code></pre>
<p>I'm sure there's an elegant way of doing this without the mutable state and the for loop.  A simple zip doesn't do it for me because the <code>theta</code> iterator uses its previous element as an input to the next element.</p>
<p>One elegant way of expressing theta is using the <code>iterate</code> method available in the <a href="https://pythonhosted.org/more-itertools/api.html#more_itertools.iterate" rel="nofollow noreferrer">more_itertools package</a>:</p>
<pre><code>iterate(lambda theta: update_theta(theta, thing), some_initial_theta)
</code></pre>
<p>However, the problem with this is that <code>thing</code> will be fixed throughout the iteration.  It would be possible to deal with this by passing in the entire list <code>stuff</code> and then return the remainder of it from the update_theta method:</p>
<pre><code>iterate(lambda theta: update_theta(theta[0], theta[1]), (some_initial_theta, stuff))
</code></pre>
<p>However, I'd really rather not modify the <code>update_theta</code> method to take an entire list it's not interested in and deal with the mechanics of returning the tail of that list.  While it's programmatically not difficult, it's poor separation of concerns.  <code>update_theta</code> shouldn't know anything about or care about the entire list <code>stuff</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As Peter Wood suggests in the comments, this is <strong>exactly</strong> what the built-in function <a href="https://docs.python.org/2/library/functions.html#reduce" rel="nofollow"><code>reduce</code></a> does:</p>
<pre><code>result = reduce(update_theta, stuff, some_initial_theta)
</code></pre>
<p>In Python 3, <code>reduce</code> has been moved to <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow"><code>functools.reduce</code></a>, so you'd need to import that:</p>
<pre><code>from functools import reduce
</code></pre>
<p>If you want an iterator of all the intermediate values, Python 3 provides <code>itertools.accumulate</code>. There's no argument to specify an initial value, so you'd need to put the initial value in the iterator:</p>
<pre><code>from itertools import accumulate, chain
result_iterator = accumulate(chain([some_initial_theta], stuff), update_theta)
</code></pre>
<p>Python 2 doesn't have <code>itertools.accumulate</code>, but you could copy the equivalent code from the Python 3 documentation. There's no easy way to formulate it in terms of the Python 2 standard tools, which is why people wanted it added to Python 3 in the first place.</p>
</div>
<span class="comment-copy">Can you provide a simple self-contained example showing what you're talking about (e.g., actual examples of simple iterators that behave in the way you describe)?</span>
<span class="comment-copy">@BrenBarn I added a concrete example.</span>
<span class="comment-copy">See <a href="https://docs.python.org/2/library/functions.html#reduce" rel="nofollow noreferrer"><b><code>reduce</code></b></a></span>
<span class="comment-copy">@PeterWood how will you deal with taking a new element of the list <code>stuff</code> on each step of the reduce?</span>
<span class="comment-copy">I don't really see anything wrong with the way you're doing it.  Also from your example it seems you're trying to combine the two iterators to get a single result (not an iterable of intermediate results), which is somewhat different from the question you linked to, and means that the details of what goes on along the way to that result are probably less important.</span>
<span class="comment-copy">Thanks!  I need to test out <code>reduce</code> some more.  I think what tripped me up with <code>reduce</code> earlier is that it handles only 2 parameters.  Like x and y in x + y, whereas my update_theta() takes many parameter.  I think what I need to do is define a lambda that keeps constant all the other parameters and then simply use it with reduce like a single parameter function.</span>
<span class="comment-copy">I've been slow getting back to this, but I believe your solution is the right one, so I'll go ahead and give you credit.  I just need to use a lambda to reduce it to two parameters.</span>
