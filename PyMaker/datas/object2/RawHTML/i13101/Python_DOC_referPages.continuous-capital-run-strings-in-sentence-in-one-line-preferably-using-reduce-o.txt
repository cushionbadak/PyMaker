<div class="post-text" itemprop="text">
<p>Here I am trying to get all the continuous capital letter strings in a sentence. I have tried the following which gives an output as 'LJ'</p>
<p>I haven't been able to figure out why it doesn't add <code>STRR</code> and <code>HLLJ</code> but it adds only <code>LJ</code> instead to the list. Does it assume <code>[""]</code> as a string.</p>
<pre><code>reduce(lambda x ,y : x[-1] + (y) if y.isupper() or y.isspace() else x,"STRR hello HLLJ",[""])
</code></pre>
<p>My input is :
<code>STRR hello HLLJ</code> and I wish to get an output as <code>["STRR","HLLJ"]</code></p>
<p>Test case : 
    <code>ABCD AAA lkjl JJJJJJ. Here it should give ["ABCD AAA","JJJJJJ"]</code></p>
<p>Any help is appreciated.</p>
<p><strong>Using Reduce I came up with this Finally but its not efficient:</strong> </p>
<p><code>reduce(lambda x, y : x[0:len(x)-1] + [x[-1]+y] if y.isupper() or y.isspace() else x + [""] if not x[-1].strip() is "" else x,"STRR Hello HLLJ", [""])</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Finding patterns in strings is what the <a href="http://docs.python.org/2/library/re.html" rel="nofollow"><code>re</code> module</a> is for:</p>
<pre><code>In [1]: import re
In [2]: re.findall("[A-Z]+(?: [A-Z]+)*", "ABCD AAA lkjl JJJJJJ")
Out[2]: ['ABCD AAA', 'JJJJJJ']
</code></pre>
<p>or, if you don't want to include capital letters that are part of another word, you can exclude them using <a href="http://www.regular-expressions.info/wordboundaries.html" rel="nofollow">word boundary anchors</a>:</p>
<pre><code>In [3]: re.findall(r"\b[A-Z]+(?: [A-Z]+)*\b", "ABCD AAA Lkjl JJJJJJ")
Out[3]: ['ABCD AAA', 'JJJJJJ']
</code></pre>
<p>Caveat: This only looks for ASCII letters.</p>
</div>
<div class="post-text" itemprop="text">
<p>With a regular expression and <a href="https://docs.python.org/2/library/re.html" rel="nofollow"><code>re.findall</code></a></p>
<pre><code>&gt;&gt;&gt; asd="HELLO worLD"
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall("[A-Z\s]+",asd)
['HELLO', 'LD']
</code></pre>
<p>Explanation:</p>
<ul>
<li><code>[A-Z\s]+</code> matches one or more subsequent captial letters or whitespace</li>
<li><code>findall</code> returns a list of all matches.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Just for completeness, another solution using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a>:</p>
<pre><code>&gt;&gt;&gt; s = "STRR hello HLLJ"
&gt;&gt;&gt; [''.join(g) for k, g in itertools.groupby(s, key=str.isupper) if k]
['STRR', 'HLLJ']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is my version using reduce which works as it should for input <code>"STRR Hello HLLJ"</code> it gives output <code>['STRR H', ' HLLJ']</code>. Its nice to get different ways to solve.</p>
<pre><code>reduce(lambda x, y : x[0:len(x)-1] + [x[-1]+y] if y.isupper() or y.isspace() else x + [""] if not x[-1].strip() is "" else x,"STRR Hello HLLJ", [""])
</code></pre>
<p>I know this is not efficient.</p>
</div>
<span class="comment-copy">Is this an entry for an obfuscated Python contest?</span>
<span class="comment-copy">No it isn't . I just wanted to possibly have mostly one line functions in my code . I have to find Longest capital run strings , Avg capital run strings and capital run length total.</span>
<span class="comment-copy">Somehow, it seems relatively simpler to write <code>reduce(lambda x, y : x+y  if y.isupper() or y.isspace() else x, "STRR hello HLLJ").split()</code> instead. No juggling with lists and their elements inside the lambda.</span>
<span class="comment-copy">Oh thats good. You could add that as an answer . But why does it not work adding to the last element in a list</span>
<span class="comment-copy">Yeah, I wanted to figure out what's going on with the original expression before putting my variant as an answer. Later perhaps.</span>
<span class="comment-copy">Nice, but IMHO, given OP's original condition <code>if y.isupper() or y.isspace()</code> it should probably be <code>[A-Z ]+</code> (A-Z or space).</span>
<span class="comment-copy">@tobias_k: Good point, but simply adding the space to character class won't work properly since the match shouldn't start or end with a space. I've updated my answer.</span>
<span class="comment-copy">This regex would find <code>['HELLO ', 'LD']</code>, though.</span>
<span class="comment-copy">I wont be using this but it looks cool.</span>
