<div class="post-text" itemprop="text">
<p>My input is</p>
<pre><code>[['apple',{'john':3,'anna':4,'kitty':6}],['pear',{'john':4,'anna':3,'kitty':3}]]
</code></pre>
<p>Expected output:</p>
<pre><code>{
    'key':['apple','pear'],
    'value':[
        {
            'name':'john',
            'data':[3,4]
        },
        {
            'name':'anna',
            'data':[4,3]
        },
        {
            'name':'kitty',
            'data':[6,3]
        }
    ]
}
</code></pre>
<p>The <code>key</code> is a list which conclude the first part of each item, such as 'apple' 'pear', and the <code>value</code> is another list.</p>
<p>How should I do it? </p>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve this with the help of <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>:</p>
<pre><code>from collections import defaultdict
value, key = defaultdict(list), []

for x in l:
    key.append(x[0])
    for k, v in x[1].items():
        value[k].append(v)
</code></pre>
<p>To get the result:</p>
<pre><code>In [15]: {'key': key, 'value': [{'name': k, 'data': v} for k, v in value.items()]}
Out[15]: 
{'key': ['apple', 'pear'],
 'value': [
  {'data': [4, 3], 'name': 'anna'},
  {'data': [6, 3], 'name': 'kitty'},
  {'data': [3, 4], 'name': 'john'}]}
</code></pre>
<hr/>
<p>For a more efficient (?) version, subclass <code>defaultdict</code> to customize the default <code>__missing__</code> hook to call the <code>default_factory</code> with missing key as a parameter (I copied this text and the implementation from the <a href="https://stackoverflow.com/a/32932568/2301450">other answer of mine</a>). Then you'll be able to do this in a single pass:</p>
<pre><code>from collections import defaultdict

class mydefaultdict(defaultdict):
    def __missing__(self, key):
        self[key] = value = self.default_factory(key)
        return value

# pass 'name' to the dictionary
value = mydefaultdict(lambda name: {'name': name, 'data': []})
key = []

for x in l:
    key.append(x[0])
    for k, v in x[1].items():
        value[k]['data'].append(v)
</code></pre>
<p>The result is then</p>
<pre><code>In [24]: {'key': key, 'value': value.values()}
Out[24]: 
{'key': ['apple', 'pear'],
 'value': [
  {'data': [4, 3], 'name': 'anna'},
  {'data': [6, 3], 'name': 'kitty'},
  {'data': [3, 4], 'name': 'john'}]}
</code></pre>
<p>In Python 3, you'll have to call <code>list(value.values())</code> instead of just <code>value.values()</code> to get a <code>list</code> object.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use following snippet:</p>
<pre><code>input = [['apple',{'john':3,'anna':4,'kitty':6}],['pear',{'john':4,'anna':3,'kitty':3}]]

tmp = {}
output = {'key': [], 'value': []}

for item in input:
    output['key'].append(item[0])
    for name in item[1]:
        try:
            tmp[name].append(item[1][name])
        except KeyError:
            tmp[name] = [item[1][name]]

output['value'] = [{'name': name, 'data': data} for name, data in tmp.items()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This function can help you</p>
<pre><code>def map_data(data):
    _tmp = {}
    _keys = []
    for _d in data:
        _keys.append(_d[0])
        for _k in _d[1].keys():
            _v  = _tmp.get(_k)
            if not _v:
                _v = {"name": _k, "data": []}

            _v["data"].append(_d[1][_k])
            _tmp[_k] = _v

    return {"key": _keys, "value": [_v for _v in _tmp.values()]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution:</p>
<pre><code>import json                                                                                         

my_list = [['apple',{'john':3,'anna':4,'kitty':6}],['pear',{'john':4,'anna':3,'kitty':3}]]

name_list = [item[1] for item in my_list]  # [{'john': 3, 'kitty': 6, 'anna': 4}, {'john': 4, 'kitty
names = name_list[0].keys()  # ['john', 'kitty', 'anna']                       
name_values = [[item[key] for item in name_list] for key in names]  # [[3, 4], [6, 3], [4, 3]]
result = {                                                                     
    'key': [item[0] for item in my_list],                                      
    'value': [                                                                 
        {'name': name, 'value': value}                                         
        for (name, value) in zip(names, name_values)                           
    ]                                                                          
}                                                                              

print(json.dumps(result, indent=4))
</code></pre>
<p>And the output:</p>
<pre><code>{
    "value": [
        {
            "name": "john", 
            "value": [
                3, 
                4
            ]
        }, 
        {
            "name": "kitty", 
            "value": [
                6, 
                3
            ]
        }, 
        {
            "name": "anna", 
            "value": [
                4, 
                3
            ]
        }
    ], 
    "key": [
        "apple", 
        "pear"
    ]
}
</code></pre>
<hr/>
<p>EDIT:</p>
<p>emmm, just found a better way to merge the dict value.</p>
<p>If the name_dict look like this one:</p>
<pre><code>&gt;&gt;&gt; name_dict
[{'john': [3], 'kitty': [6], 'anna': [4]}, {'john': [4], 'kitty': [3], 'anna': [3]}]
</code></pre>
<p>the task would be easy. What's the difference? The value is a list.</p>
<p>Now, we can use <code>collections.Counter</code> to merge two dicts!</p>
<pre><code>&gt;&gt;&gt; Counter(name_dict[0]) + Counter(name_dict[1])
Counter({'kitty': [6, 3], 'anna': [4, 3], 'john': [3, 4]})
</code></pre>
<p>so here is the new solution, we convert the value to a list first:(skip the 'key', only show the 'value'):</p>
<pre><code>  from collections import Counter 

  my_list = [['apple',{'john':3,'anna':4,'kitty':6}],['pear',{'john':4,'anna':3,'kitty':3}]]
  name_list = [item[1] for item in my_list]    

  for item in name_list:                                                          
      for key, value in item.items():                                             
          item[key] = [value]                                                     

  name_values = dict(Counter(name_list[0]) + Counter(name_list[1]))  # {'john': [3, 4], 'kitty': [6, 3], 'anna': [4, 3]}             

  print([{'name': name, 'value': value} for (name, value) in name_values.items()])

  # output
  [{'name': 'john', 'value': [3, 4]}, {'name': 'kitty', 'value': [6, 3]}, {'name': 'anna', 'value': [4, 3]}]
</code></pre>
</div>
<span class="comment-copy">Want to share your attempts with us?</span>
<span class="comment-copy">It give me a great inspiration,thanks</span>
<span class="comment-copy">thank you, I resolved in the same wayðŸ˜Š</span>
<span class="comment-copy">that's a pretty way,what if the name_list is a huge object?</span>
<span class="comment-copy">@user1594252 ah, it's <code>name_list = [item[1] for item in my_list]</code>, just in the first version of this answer.</span>
<span class="comment-copy">@user1594252 Updated the answer, hope it helps.</span>
