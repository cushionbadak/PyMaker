<div class="post-text" itemprop="text">
<p>So I'm listing all the models and the avg mpg in a function.</p>
<p>Where I have </p>
<pre><code>list1 = ['DODGE',20, 'BMW', 28, 'FORD',25, 'DODGE',28,'FORD',20]
</code></pre>
<p>and the expected output is</p>
<pre><code>list_out = ['DODGE', 24, 'BMW',28, 'FORD', 22.5]
</code></pre>
<p>my code so far is </p>
<pre><code>def average_mpg_by_maker(mileage_list):
    maker_list = []
    total_hwy = 0
    counter = 0
    list_makers = []
    for hwy_mpg, maker in mileage_list:
        if maker not in maker_list:
            maker_list.append(maker)

    for make in maker_list:
         total_hwy += hwy_mpg
         counter +=1
        list_makers.extend([make,total_hwy])
    return list_makers
</code></pre>
<p>which results in all the mpg keep on adding regardless of the model.
How can I fix it?</p>
<p>Edit: the counter is so that the total mpg can be divide by the number of the times the make appears for example for 
<code>'DODGE' appeared 2 times so 48/2= 24 mpg</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Your code seems to rely on a magical <code>hwy_mpg</code>; that value is simply the very last value from the <code>mileage_list</code>.</p>
<p>Store the <em>total so far</em> and the <em>count of entries</em> in a dictionary, keyed by 
manufacturer:</p>
<pre><code>def average_mpg_by_maker(mileage_list):
    per_maker = {}
    for maker, mpg in mileage_list:
        info = per_maker.setdefault(maker, {'total': 0, 'count': 0})
        info['total'] += mpg
        info['count'] += 1
    return [(maker, info['total'] / info['count']) for maker, info in per_maker.items()]
</code></pre>
<p>You could also simply group the entries into lists, keyed on the maker, and sum the values later on:</p>
<pre><code>def average_mpg_by_maker(mileage_list):
    per_maker = {}
    for maker, mpg in mileage_list:
        per_maker.setdefault(maker, []).append(mpg)
    return [(maker, sum(entries) / len(entries)) for maker, entries in per_maker.items()]
</code></pre>
<p>The above function assumes your <code>mileage_list</code> uses <em>tuples</em> per entry:</p>
<pre><code>list1 = [('DODGE', 20), ('BMW', 28), ('FORD', 25), ('DODGE', 28), ('FORD', 20)]
</code></pre>
<p>The output uses floating point values, consistently:</p>
<pre><code>&gt;&gt;&gt; def average_mpg_by_maker(mileage_list):
...     per_maker = {}
...     for maker, mpg in mileage_list:
...         info = per_maker.setdefault(maker, {'total': 0, 'count': 0})
...         info['total'] += mpg
...         info['count'] += 1
...     return [(maker, float(info['total']) / info['count']) for maker, info in per_maker.items()]
...
&gt;&gt;&gt; list1 = [('DODGE', 20), ('BMW', 28), ('FORD', 25), ('DODGE', 28), ('FORD', 20)]
&gt;&gt;&gt; average_mpg_by_maker(list1)
[('FORD', 22.5), ('DODGE', 24.0), ('BMW', 28.0)]
</code></pre>
<p>The order of the output differs from your expected output because dictionary order is arbitrary and depends on the current <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow">hash randomisation value</a> as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a dictionary instead:</p>
<pre><code>dict1 = {'DODGE':20, 'BMW': 28, 'FORD',25, 'DODGE',28,'FORD',20}
replication=dict1
dict2={}
return_dict={}
for key in replication.keys():
    if key not in return_dict.keys():
        return_dict[key]=replication[key]
        dict2[key]=1
    else:
        return_dict[key]+=replication[key]
        dict2[key]+=1
    del replication[key]
for key in return_dict.keys():
    return_dict[key]/=dict2[key]
return return_dict
</code></pre>
<p>I think this should work.</p>
</div>
<span class="comment-copy">Your sample code seems to suggest your actual <code>mileage_list</code> is a list of tuples, each containing a string and an integer, not a list with alternating string and integer values.</span>
<span class="comment-copy">Why do you write <code>counter +=0</code>?</span>
<span class="comment-copy">Please add an example of input, with the expected output and the actual output.</span>
<span class="comment-copy">Why didn't you use a dict instead of a list? A list seems counter-intuitive.</span>
<span class="comment-copy">@JAW: multiple entries per car maker. A list of tuples makes some sense there; the alternative would be to use a dictionary with <i>lists</i> of mpg measurements for each manufacturer, of course.</span>
