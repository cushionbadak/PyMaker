<div class="post-text" itemprop="text">
<p>I wrote a very simple Spark code in Python: </p>
<pre><code>import collections
Person = collections.namedtuple('Person', ['name', 'age', 'gender'])

a = sc.parallelize([['Barack Obama', 54, 'M'], ['Joe Biden', 74, 'M']])
a = a.map(lambda row: Person(*row))

print a.collect()

def func(row):
    tmp = row._replace(name='Jack Rabbit')
    return tmp

print a.map(func).collect()
</code></pre>
<p>I get following output and error:</p>
<pre><code>[Person(name='Barack Obama', age=29, gender='M'), Person(name='Joe Biden', age=57, gender='M')]

Py4JJavaError: An error occurred while calling z:org.apache.spark.api.python.PythonRDD.collectAndServe.
: org.apache.spark.SparkException: Job aborted due to stage failure: Task 49 in stage 11.0 failed 4 times, most recent failure: Lost task 49.3 in stage 11.0 (TID 618, 172.19.75.121): org.apache.spark.api.python.PythonException: Traceback (most recent call last):
  File "/etc/spark-1.4.0-bin-cdh4/python/lib/pyspark.zip/pyspark/worker.py", line 111, in main
    process()
  File "/etc/spark-1.4.0-bin-cdh4/python/lib/pyspark.zip/pyspark/worker.py", line 106, in process
    serializer.dump_stream(func(split_index, iterator), outfile)
  File "/etc/spark-1.4.0-bin-cdh4/python/lib/pyspark.zip/pyspark/serializers.py", line 263, in dump_stream
    vs = list(itertools.islice(iterator, batch))
  File "&lt;ipython-input-19-f0b4885784cb&gt;", line 2, in func
  File "&lt;string&gt;", line 32, in _replace
RuntimeError: uninitialized classmethod object

    at org.apache.spark.api.python.PythonRDD$$anon$1.read(PythonRDD.scala:138)
    at org.apache.spark.api.python.PythonRDD$$anon$1.&lt;init&gt;(PythonRDD.scala:179)
    at org.apache.spark.api.python.PythonRDD.compute(PythonRDD.scala:97)
    at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:277)
    at org.apache.spark.rdd.RDD.iterator(RDD.scala:244)
    at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:63)
    at org.apache.spark.scheduler.Task.run(Task.scala:70)
    at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:213)
    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
    at java.lang.Thread.run(Thread.java:662)
</code></pre>
<p>However, if I run the following piece of code, I don't get any error:</p>
<pre><code>for row in a.collect():
  func(row)
</code></pre>
<p>What gives?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edit</strong>:</p>
<p>Support for serializing named tuples has been introduced with <a href="https://issues.apache.org/jira/browse/SPARK-10542" rel="nofollow">SPARK-10542</a>.</p>
<p><strong>Original answer</strong></p>
<p>Why it doesn't work? Because <code>namedtuple</code> call creates a class and classes in Spark are not serialized as a part of the closure. It means you have to create a separate module* and make sure it is available on the workers:</p>
<pre><code>txt = "\n".join(["import collections",
    "Person = collections.namedtuple('Person', ['name', 'age', 'gender'])"])

with open("persons.py", "w") as fw:
    fw.write(txt)

sc.addPyFile("persons.py")  # Ship module to the worker nodes
</code></pre>
<p>Next you can simply import and everything should work as expected:</p>
<pre><code>import persons

a.map(func).collect()
</code></pre>
<p>On a side note leading underscore is there for a reason.</p>
<hr/>
<p>* It could be done dynamically like this <code>a.map(lambda row: collections.namedtuple('Person', ['name', 'age', 'gender'])(*row))</code> or by defining <code>Person</code> inside <code>mapPartitions</code> but it is neither pretty or efficient.</p>
</div>
<span class="comment-copy">Thanks for the answer, solved my problem. However, I still wonder, how do worker nodes know how to serialize and de-serialize data for custom types such as the namedtuple above?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
