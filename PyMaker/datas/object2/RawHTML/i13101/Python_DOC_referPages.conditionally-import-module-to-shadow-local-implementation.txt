<div class="post-text" itemprop="text">
<p>I am writing a Python script where some of the core functionalities can be done by another existing library. Unfortunately, while that library has more features, it is also slower, so I'd like if the user could at runtime select whether they want to use that library or my own fast and simple implementation. Unfortunately I'm stuck at a point where I don't understand some of the workings of Python's module system.</p>
<p>Suppose that my main program was <code>main.py</code>, that the (optional) external module is in <code>module_a.py</code> and that my own fast and simple implementation of <code>module_a</code> together with the actual program code that uses either my own implementation or the one of <code>module_a</code> is in the file <code>module_x.py</code>:</p>
<p>main.py:</p>
<pre><code>import module_x
module_x.test(True)
module_x.test(False)
</code></pre>
<p>module_a.py:</p>
<pre><code>class myclass():
    def __init__(self):
        print("i'm myclass in module_a")
</code></pre>
<p>module_x.py:</p>
<pre><code>class myclass():
    def __init__(self):
        print("i'm myclass in module_x")

def test(enable_a):
    if enable_a:
        try:
            from module_a import myclass
        except ImportError:
            global myclass
            enable_a = False
    else:
        global myclass
    i = myclass()
</code></pre>
<p>When I now execute <code>main.py</code> I get:</p>
<pre><code>$ python3 main.py
i'm myclass in module_a
i'm myclass in module_a
</code></pre>
<p>But why is this? If <code>False</code> is passed to <code>test()</code> then the import of the <code>module_a</code> implementation should never happen. Instead it should only see <code>myclass</code> from the local file. Why doesn't it? How do I make <code>test()</code> use the local definition of <code>myclass</code> conditionally?</p>
<p>My solution is supposed to run in Python3 but I see the same effect when I use Python2.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>An <code>import</code> statement is <em>permanent</em> within the thread of execution unless it is explicitly undone.  Furthermore, once the <code>from ... import</code> statement is executed in this case, it replaces the variable <code>myclass</code> in the global scope (at which point the class it was previously referencing defined in the same file is no longer referenced and can in theory be garbage collected)</p>
<p>So what is happening here is whenever you run <code>test(True)</code> the first time, your <code>myclass</code> in <code>module_x</code> is effectively deleted and replaced with the <code>myclass</code> from <code>module_a</code>.  All subsequent calls to <code>test(False)</code> then call <code>global myclass</code> which is effectively a no-op since the global myclass now refers to the one imported from the other class (and besides the <code>global</code> call is unneeded when not changing the global variable from a local scope as explained <a href="https://stackoverflow.com/questions/4693120/use-of-global-keyword-in-python">here</a>).</p>
<p>To work around this, I would strongly suggest encapsulating the desired module-switching behavior in a class that is independent of either module you would like to switch.  You can then charge that class with holding a reference to both modules and providing the rest of you client code with the correct one.  E.g.</p>
<p>module_a_wrapper.py</p>
<pre><code>import module_x
import module_a

class ModuleAWrapper(object):
    _target_module = module_x # the default

    @classmethod
    def get_module(cls):
        return cls._target_module

def set_module(enable_a):
    if enable_a:
        ModuleAWrapper._target_module = module_a
    else:
        ModuleAWrapper._target_module = module_x

def get_module():
    return ModuleAWrapper.get_module()
</code></pre>
<p>main.py:</p>
<pre><code>from module_a_wrapper import set_module, get_module
set_module(True)
get_module().myclass()
set_module(False)
get_module().myclass()
</code></pre>
<p>Running:</p>
<pre><code>python main.py

# Outputs:
i'm myclass in module_a
i'm myclass in module_x
</code></pre>
<p>You can read more about the guts of the python import system <a href="https://docs.python.org/3/reference/import.html" rel="nofollow noreferrer">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The answer by lemonhead properly explains why this effect happens and gives a valid solution.</p>
<p>The general rule seems to be: wherever and however you import a module, it will <em>always</em> replace any variables of the same name from the global scope.</p>
<p>Funnily, when I use the <code>import foo as bar</code> construct, then there must neither be a global variable named <code>foo</code> nor one named <code>bar</code>!</p>
<p>So while lemonhead's solution worked it adds lots of complexity and will lead to my code being much longer because every time I want to get something from either module I have to prefix that call with the getter function.</p>
<p>This solution allows me to solve the problem with a minimal amount of changed code:</p>
<p>module_x.py:</p>
<pre><code>class myclass_fast():
    def __init__(self):
        print("i'm myclass in module_x")

def test(enable_a):
    if enable_a:
        try:
            from module_a import myclass
        except ImportError:
            enable_a = False
            myclass = myclass_fast
    else:
        myclass = myclass_fast
    i = myclass()
</code></pre>
<p>So the only thing I changed was to rename the class I had in global scope from <code>myclass</code> to <code>myclass_fast</code>. This way it will not be overwritten anymore by the import of <code>myclass</code> from <code>module_a</code>. Then, on demand, I change the <em>local</em> variable <code>myclass</code> to either be the imported module or <code>myclass_fast</code>.</p>
</div>
<span class="comment-copy">Try to comment line module_x.test(True) and run with False at start, you'll see</span>
<span class="comment-copy">That is not a solution because after having run <code>module_x.test(True)</code> only once, <code>module_x.test(False)</code> will refuse to work. Why is this and how to fix it?</span>
<span class="comment-copy">It's because variable myclass has been created at first run, and never been reassigned or destroyed. Also, it shadows myclass from module_x forever. So, u should rebuild this module with another approach</span>
<span class="comment-copy">Great, which one? That things work this way seems totally unintuitive to me.</span>
<span class="comment-copy">A simple solution is to <code>import myclass as myclass_slow</code> and define <code>class myclass_fast</code> , then conditionally set <code>myclass = myclass_fast if use_fast else myclass_slow</code>.</span>
