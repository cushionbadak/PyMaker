<div class="post-text" itemprop="text">
<p>I need to write a function where, for any list, each element in the list is added together and to see if it equals a constant. </p>
<p>For example:</p>
<pre><code>L = [1, 2, 3, 4]
</code></pre>
<p>The sum of each element added together is <code>1+2=3</code>, <code>1+3=4</code>, <code>1+4=5</code>, <code>2+3=5</code>, <code>2+4=6</code>, <code>3+4=7</code>.</p>
<p>And then to test each of these results to a constant eg if the output = C where <code>C = 3</code>, and append the two numbers that were summed to equal the constant to a new list to be printed.</p>
<p>I am not allowed to use indexing here.</p>
<p>So far I am able to add the numbers in pairs along the list:</p>
<pre><code>def prize(L):
    possible = []
    C = 4
    prevprev = L.pop(0)
    prev = L.pop(0)
    print("initial", prevprev, prev)

    for n in L:
        i = prev + prevprev
        prevprev = prev
        prev = L.pop(0)


    if i == C:
        possible.append(i)

    return possible

print("possible ", possible)
</code></pre>
<p>But for some reason this misses out the last 2 elements in the list when iterating over it.</p>
</div>
<div class="post-text" itemprop="text">
<p>I couldn't quite follow your code or explanation quite well, but I believe this does what you want. This is done without the <code>itertools</code> module. Using it would produce a more compact code. This is done as an alternative to <code>itertools</code></p>
<pre><code>lst = [1, 2, 3, 4]

def prize(L):
    pair_list = []
    C = 4

    # Creates a list of tuples (1, 2), (1, 3), etc
    for x in L:
        for y in L:
            # if x != y | To prevent 1 + 1 and 2 + 2 (following example)
            # (y, x) not in pair_list | Prevent inverted pairs
            if x != y and x + y == C and (y, x) not in pair_list:
                pair_list.append((x, y))

    # Return list tuples that add to constant           
    return pair_list

print('Possible', prize(lst))
</code></pre>
<p>if you wish to use itertools then you would use</p>
<pre><code>from itertools import combinations

def prize(L):
    C = 4
    return [(x, y) for x, y in combinations(L, 2) if x + y == C]

lst = [1, 2, 3, 4]

print('Possible', prize(lst))
</code></pre>
</div>
<span class="comment-copy">Just a <b>Tip</b>: <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>L = [1, 2, 3, 4]; sum([sum(i) for i in list(__import__('itertools').combinations(L, 2))])</code></a>.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/1637807/modifying-list-while-iterating">Modifying list while iterating</a> and <a href="http://stackoverflow.com/questions/4081217/how-to-modify-list-entries-during-for-loop">How to modify list entries during for loop?</a>. See also: <a href="https://unspecified.wordpress.com/2009/02/12/thou-shalt-not-modify-a-list-during-iteration/" rel="nofollow noreferrer">Thou shalt not modify a list during iteration</a></span>
<span class="comment-copy">@TessellatingHeckler thank you for that last link, that explains why i wasn't getting the desired results :)</span>
<span class="comment-copy">@KevinGuan unfortunately we have not been taught about itertools yet, so I'd rather stick with what i know for now, but thank you anyway!</span>
<span class="comment-copy">Thank you so much! This does exactly what I was trying to do. Thank you for the comments as well, that really helps with understanding the code :)</span>
