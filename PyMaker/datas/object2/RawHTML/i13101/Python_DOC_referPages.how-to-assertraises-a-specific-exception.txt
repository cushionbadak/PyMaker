<div class="post-text" itemprop="text">
<p>I have following code:</p>
<pre><code>def foo(input):
    if not input.startswith("prefix"):
        raise Exception("input should start with prefix!")
    process(input)
</code></pre>
<p>Now I want to unit test this function; when <code>input</code> is not starting with <code>"prefix"</code> it can actually throw an exception. Here's my <code>unittest</code> code:</p>
<pre><code>def test_foo_invalud_type(self):
    self.assertRaises(Exception, foo, 999)
</code></pre>
<p>The problem with this test code is: it catches the exception, but the exception is <code>'int' object has no attribute 'startswith'</code>, instead of <code>input should start with prefix!</code>. The test will pass, but it's not a good test. How can I identify the two exceptions?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>raise Exception</code> is very bad form - try to be more specific when raising exceptions. Using such a general exception makes it really difficult to distinguish between the two different cases you're trying to test for.</p>
<p>In this case, for example, I think <code>ValueError</code> would be most appropriate within <code>foo</code>, as it's the right type of thing (a string) but doesn't have the right value (no <code>'prefix'</code> at the start). </p>
<pre><code>def foo(input):
    if not input.startswith("prefix"):
        raise ValueError("input should start with prefix!")
    process(input)
</code></pre>
<p>This lets you distinguish between the <em>type</em> of the input being wrong (which raises an <code>AttributeError</code> due to the absence of <code>.startswith</code>*):</p>
<pre><code>def test_foo_invalid_type(self):  # note fixed typo in 'invalud'
    self.assertRaises(AttributeError, foo, 999)  # and more specific error
</code></pre>
<p>and the <em>value</em> of the input being wrong (the <code>ValueError</code> explicitly raised for a missing <code>'prefix'</code> prefix):</p>
<pre><code>def test_foo_invalid_value(self):
    with self.assertRaises(ValueError) as cm:
       foo('no prefix')
       self.assertEqual(
           cm.exception.args, 
           ('input should start with prefix!',),
       )
</code></pre>
<p>Note how you can use the <code>with</code> context manager form of <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaises" rel="nofollow"><code>assertRaises</code></a> to get access to the error itself. This allows you to also check that the correct message is being provided for the error.</p>
<hr/>
<p>* You could even consider handling the <code>AttributeError</code> <em>within</em> <code>foo</code>, and raising a <code>TypeError</code> instead. That seems like a more natural fit for <em>"that parameter was the wrong type"</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are passing an int to your function <code>foo</code> but it looks like you wanted a str (as you're using <code>startswith</code> on the <code>input</code> parameter). Your unit test should be:</p>
<pre><code>def test_foo_invalud_type(self):
    self.assertRaises(Exception, foo, '999')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The line that is raising the error is:</p>
<pre><code>if not input.startswith("prefix"):
</code></pre>
<p>And not:</p>
<pre><code>    raise Exception("input should start with prefix!")
</code></pre>
<p>Because you are passing an int instead a string: 999 instead '999'</p>
<p>Remember that int, have not an attribute startswith.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simply implement and raise your own exception.</p>
<pre><code>class BadStartException(Exception):
    pass

def foo(input):
    if not input.startswith("prefix"):
        raise BadStartException("input should start with prefix!")
    process(input)

def test_foo_invalud_type(self):
    self.assertRaises(BadStartException, foo, 999)
</code></pre>
<p>Note that your test would fail now. I'm not sure if that's what you wanted to test.</p>
</div>
<span class="comment-copy">I think I misinterpreted the question at least twice, but I'm happy with that now...</span>
<span class="comment-copy">Thank you. I have to admit that my question was a bad description.</span>
<span class="comment-copy">But the problem is that <code>foo(999)</code> doesn't <code>raise BadStartException</code>, it's an <code>AttributeError</code>!</span>
<span class="comment-copy">@jonrsharpe that is a problem with <code>foo</code>, not a problem with this answer. Don't raise <code>Exception</code>!</span>
