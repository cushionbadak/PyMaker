<div class="post-text" itemprop="text">
<p>I understand the basic examples shown with using python 3.5 and its new async/await functionality (which is super cool).</p>
<p>One of the things I am exploring is how I might be able to start some async work, and once some blocking work is started, serialize (pickle?) the state of the coroutine, and then at some deferred point in time (possibly on a different machine), restart the same program, reload the state, and attempt to make progress, and repeat until the async work is done.</p>
<p>Specifically in the diagram at <a href="https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines" rel="nofollow">https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines</a> ... I am wondering if I can replace event loop to accomplish this. How might I go about doing such a thing?</p>
<p>I am hoping someone with more expertise in python's coroutines, asyncio and new async/await functionality maybe able to shed light on how to do this either using the approach I am trying by sharing some pointers, or quite possibly suggest something better.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>asyncio</code> library itself has only sockets, pipes and processes.</p>
<p>For complex interprocess communications you need something built on top of asyncio.</p>
<p>Your example describes typical message queue usage, e.g. RabbitMQ with <a href="https://github.com/benjamin-hodgson/asynqp" rel="nofollow">asynqp</a> library.</p>
<p>Or you may build something from scratch, say, using <a href="https://github.com/aio-libs/aiozmq" rel="nofollow">aiozmq</a>.</p>
<p>You question is too broad for making strict answer.</p>
</div>
<span class="comment-copy">I am not trying to make an async library for X (where X = RabbitMQ etc.)  ... asyncio is more than just those. For example, event_loop comes from asyncio, and is responsible for executing coroutines to completion. I want to understand how one might build a custom event loop/executor to introduce ability to serialize coroutines, and then pick up from where they were left off in a future/another instance of the process on some other machine. Hopefully that clarifies as well as make a bit more specific?</span>
<span class="comment-copy">No, using custom event_loop or executor for tasks like you wish is wrong. It should be done by a library using standard event loop. The library might provide future-like objects for tasks executed on another machine, sure.</span>
<span class="comment-copy">Yes, assume there is a library for the tasks themselves to produce future-like objects. However I want the main program that started the task to not sit there blocked on async work consuming resources, but instead to end the process and then pick up at a later point.</span>
