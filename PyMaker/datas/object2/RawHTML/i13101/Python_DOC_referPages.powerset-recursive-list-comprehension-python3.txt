<div class="post-text" itemprop="text">
<p>I'm new to Python3 and are trying to do a recursive powerset function. It should use list comprehension. </p>
<p>I wrote:</p>
<pre><code>def powerset(seq):
    if not seq:
       return [[]]
    return powerset(seq[1:]) + [[seq[0]] + n for n in powerset(seq[1:])]
</code></pre>
<p>This function works but I got feedback and was told it was unnecessary to call the function two times. It did to much computing. It should easily be able to compute up to 20 powersets. So how should I do? I can't get it to work without calling the function twice. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just calculate <code>powerset(seq[1:])</code> once, store it in a variable, and use it twice:</p>
<pre><code>def powerset(seq):
    if not seq:
        return [[]]
    ps = powerset(seq[1:])
    return ps + [[seq[0]] + n for n in ps]
</code></pre>
<p>The difference to yours is that this way, you <em>use</em> <code>ps</code> twice, but you <em>compute</em> it just once.</p>
<hr/>
<p>Alternatively, you could use a double list-comprehension (if you like that sort of thing...)</p>
<pre><code>def powerset(seq):
    return [x for ps in powerset(seq[1:]) for x in ([seq[0]] + ps, ps)] if seq else [[]]
</code></pre>
<p>Here, the same temporary variable <code>ps</code> is defined <em>inside</em> the list comprehension. Note, however, that the results will be in a slightly different order this way.</p>
<hr/>
<blockquote>
<p>I feel very unclear. I actually don't understand how just assigning it to a variable can change that? It means the same thing?</p>
</blockquote>
<p>You seem to think too much in terms of pure math here. In programming, <code>y = f(x)</code> does not mean "y is the same as/synonymous for f(x)", but "assign the <em>result</em> of f(x) to y".</p>
</div>
<span class="comment-copy">Do you know how to save a function's return value to a variable, and then use the variable?</span>
<span class="comment-copy">You mean something like res += res + [[seq[0] + n for n in powerset(seq[1:])] where res is an empty list? Or do I have completely wrong?</span>
<span class="comment-copy">Completely wrong, unfortunately. Do you know what <code>subset = powerset(seq[1:])</code> would mean?</span>
<span class="comment-copy">To store it in a variable? What does your subset mean in the list-comprehension you wrote below mean?</span>
<span class="comment-copy">That's a tuple literal. If you're not familiar with tuples, whatever you're going through to learn Python will hopefully cover them pretty soon. The <a href="https://docs.python.org/3/tutorial/" rel="nofollow noreferrer">Python tutorial</a> might help explain the basics in more detail than is appropriate for Stack Overflow comments.</span>
<span class="comment-copy">Doubly-nested list comprehensions are almost always reducible to single list comprehensions. In this case, it would be <code>[x for subset in powerset(seq[1:]) for x in (subset, [seq[0]] + subset)]</code>.</span>
<span class="comment-copy">But how is it any difference from storing it in a variable in just writing it out? It does the same thing right? And I'm not that familiar with double-nested list-comprehension. What does "+ps, ps" mean (not powerset(seq[1:]))? Isn't that calling the function to much too?</span>
<span class="comment-copy">@user2357112 Yes, I was thinking of something like this, but somehow messed it up. Fixed now.</span>
<span class="comment-copy">@blik3o: You seem to be unclear about what causes a function to be called. If you assign <code>ps = powerset(seq[1:])</code>, using <code>ps</code> doesn't cause <code>powerset</code> to be called again.</span>
<span class="comment-copy">I feel very unclear. I actually don't understand how just assigning it to a variable can change that? It means the same thing?</span>
