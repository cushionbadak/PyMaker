<div class="post-text" itemprop="text">
<p>This is the method I want to test. In this test method (test_get_all_products), I want to pass in a list of products and a mocked response for the DB call which is identified by dal.  </p>
<pre><code>def get_all_user_standalone_products(all_products, dal):
standalone_products = []
if all_products is not None:
    all_products = all_products['userRenewableProduct']
    for product in all_products:
        sku_id = product.get('skuID', 0)
        sku_cost_id = product.get('skuCostID', 0)
        standalone_product = which_standalone_product(sku_id)

        if product.get('isDisabled') or standalone_product is None:
            continue

        product['productType'] = standalone_product['name']

        sku_cost_data = dal.skucosts.get_costs_for_sku_cost_id(
            sku_cost_id)
        product['termMonths'] = sku_cost_data['termMonths']

        upgrade_sku_ids = standalone_product.get(
            'upgrade_sku_ids', [])
        if len(upgrade_sku_ids) &gt; 0:
            product['canUpgrade'] = True

        product['upgradeSkus'] = upgrade_sku_ids
        standalone_products.append(product)
return standalone_products
</code></pre>
<p>This is my test</p>
<pre><code>product_sku_cost= {
        u'testPriceSetID':u'',
        u'skuID':88,
        u'currencyTypeID':1,
        u'termMonths':1,
        u'dateCreated':   u'2015-10-07T17:03:00   Z',
        u'skuCostID':2840,
        u'cost':9900,
        u'skuTypeID':13,
        u'dateModified':   u'2015-10-07T17:03:00   Z',
        u'isDefault':True,
        u'name':u'Product'}

@patch('model.dal')
def test_get_all_products(self, dal):
      # this is my mock - I want it to return the dictionary above.
      dal.SKUCosts.get_costs_for_sku_cost_id.return_value = product_sku_cost
      products = get_all_user_standalone_products(renewable_products, dal)

      assert products[0]['canUpgrade'] is True
      assert products[0]['termMonths'] == 1
</code></pre>
<p>But when I assert the products[0]['termMonths'] == 1 which comes from the mocked object, it fails because the termMonths is actually the Mock object itself, not the return value(product_sku_cost) I was expecting.</p>
<p>Please help me figure out what I am doing incorrectly above.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is just a TYPO error: try to change <code>SKUCost</code> to <code>skucost</code> where you configured <code>dal</code>. So configuration line become:</p>
<pre><code>dal.skucsts.get_costs_for_sku_cost_id.return_value = product_sku_cost
</code></pre>
<p>Anyway there is some other issues in your test: You don't need to patch anything in your test because you're passing <code>dal</code> object and nothing use <code>model.dal</code> reference. I don't know what <code>model.dal</code> but if what you want to do is to have the same <em>signature/properties</em> you can use <a href="https://docs.python.org/3/library/unittest.mock.html#create-autospec" rel="nofollow"><code>create_autospec</code></a> to build it.</p>
<p>Your test can be:</p>
<pre><code>def test_get_all_products(self, dal):
   # this is my mock - I want it to return the dictionary above.
   dal = create_autospec(model.dal)
   dal.skucosts.get_costs_for_sku_cost_id.return_value = product_sku_cost
   ...
</code></pre>
<p>If <code>model.dal</code> is a class use <code>instance=True</code> when you create autospec.</p>
</div>
