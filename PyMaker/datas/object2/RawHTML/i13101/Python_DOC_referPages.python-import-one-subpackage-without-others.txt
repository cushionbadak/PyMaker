<div class="post-text" itemprop="text">
<p>I have the following package structure</p>
<pre><code>package
    __init__.py
    sub1
        __init__.py
        foo.py      # Contains class Foo
    sub2
        __init__.py
        bar.py      # Contains class Bar
</code></pre>
<p>I want to be able to just <code>import package</code> and have <code>package.Foo</code> and <code>package.Bar</code>, i.e. I want to have the subpackages be transparent to users.  </p>
<p>The catch is that importing sub2 takes a long time, and many users don't care at all about the stuff in sub2 and only want the stuff in sub1.  Thus I want users to be able to say <code>import package.sub1</code> or <code>from package import sub1</code> to <strong>just</strong> import sub1 and skip the import of sub2.</p>
<p>I know I can achieve the first part by having <code>package/__init__.py</code> contain</p>
<pre><code>from .sub1 import *
from .sub2 import *
</code></pre>
<p>and having <code>package/sub1/__init__.py</code> be <code>from .foo import Foo</code> and similarly for sub2.  However, this will always import sub1 and sub2 even if the user tries to import only <code>package.sub1</code>.</p>
<p>Correspondingly, I can achieve the second part by having <code>package/__init__.py</code> be empty and using the same <code>sub1/__init__.py</code> as above.  However, then just saying <code>import package</code> doesn't load sub1 or sub2, so users would have to explicitly load them and then refer to <code>package.sub1.Foo</code>.</p>
<p>Ideally a solution would work both in 2.7.10 and 3.5.0, but I'll accept one or the other if both isn't possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/importlib.html#importlib.util.LazyLoader" rel="nofollow"><code>LazyLoader</code></a> class is provided for exactly this kind of situation: postponing loading of the module when it is actually used, instead of at the point of importing it.</p>
<p>To build a lazy loader you can follow the example in the documentation:</p>
<pre><code>suffixes = importlib.machinery.SOURCE_SUFFIXES
loader = importlib.machinery.SourceFileLoader
lazy_loader = importlib.util.LazyLoader.factory(loader)
finder = importlib.machinery.FileFinder(path, [(lazy_loader, suffixes)])
</code></pre>
<p>then you can use <a href="https://docs.python.org/3/library/importlib.html#importlib.abc.PathEntryFinder.find_spec" rel="nofollow"><code>finder.find_spec</code></a> to obtain the spec of a module and pass the result to <a href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.create_module" rel="nofollow"><code>Loader.create_module</code></a> to load it.</p>
<p>This is a bit cumbersome to do manually for just one module.</p>
<p>Note that searching for "lazy import python" you'll find quite a few solutions that have different pro and cons, some of which run in python2.x. However the <code>LazyLoader</code> class above is the official way of doing it in python3.5+</p>
</div>
<div class="post-text" itemprop="text">
<p>you could add your shortcuts to the <code>__init__.py</code> of your module:</p>
<p><strong>package/__init__.py</strong></p>
<pre><code>__all__ = [
    ... add everything you want to be listed for this module
    'Foo',
    'Bar',
    ...
]
from package.sub1.foo import Foo
from package.sub2.bar import Bar
</code></pre>
<p>now you should be able to call:</p>
<pre><code>from package import Bar
</code></pre>
</div>
<span class="comment-copy">a better question is why do you have a long-running code at the module level in <code>sub2</code></span>
<span class="comment-copy">So, in fact, your question is: "I want <code>import package.sub1</code> to do strictly fewer things than just <code>import package</code>, right? Absent some weird hack like reading the bytecode in advance, i think it's not possible. <code>import A.B</code> must <code>import A</code> first. Note at the bottom of <a href="https://docs.python.org/3.6/library/importlib.html" rel="nofollow noreferrer">docs.python.org/3.6/library/importlib.html</a> (last code block, line 15), <code>import_module</code> is a recursive function. However, you can easily have a third subpackage, <code>package.everything</code>, which will really import <code>sub1</code> and <code>sub2</code> into the same namespace.</span>
<span class="comment-copy">@Veky: That is indeed exactly what I ended up doing (well, <code>package.all</code>, but close enough)</span>
<span class="comment-copy">.all was my first idea, but I decided against it, since it a) evokes false association with <code>package.__all__</code>, and b) is a bit too short for something you don't want to encourage people to do (an attractive nuisance).</span>
<span class="comment-copy">I can't get this to actually load the stuff from the subpackage.  If <code>sub2/__init__.py</code> has <code>from .bar import Bar</code>, it returns <code>ImportError: No module named 'package.bar'</code>  If it uses an absolute import, I get <code>ValueError: module object for 'package.sub2' substituted in sys.modules during a lazy load</code>  It also seems like this will just have the symbols under sub2, so I'd still have to say <code>package.sub2.Bar</code> rather than just <code>package.Bar</code></span>
<span class="comment-copy">For anyone looking at this in the future, if you (like me) can't get lazy loader to work, my solution was to just have a <code>package.all</code> (or .everything if you prefer) that imports everything, and the top level package doesn't import anything.  See the comments on the question for more discussion</span>
<span class="comment-copy">this enables <code>package.Bar</code> after <code>import package</code> but it doesn't handle the "lazy import" part of the question.</span>
