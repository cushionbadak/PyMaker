<div class="post-text" itemprop="text">
<p>Is there a way to evalute the number of numeric operations (+, -, /, *) in a function/expression? </p>
<p>In example, lets take a simple linear algebra problem (<code>Ax = b</code>):</p>
<pre><code>A_data = np.array([[1, -4, 1],
                  [1, 6, -1],
                  [2, -1, 2]], dtype=float)

b_data = np.array([[7],
                  [13],
                  [5]], dtype=float)
</code></pre>
<p>Next, lets apply Gauss elimination procedure:</p>
<pre><code>def gauss_elim(A, b):
    Ab = np.column_stack((A, b))
    for k, pivot_row in enumerate(Ab[:-1]):
        for row in Ab[k+1:]:
            if pivot_row[k] != 0:
                row[k:] = row[k:] - pivot_row[k:] * row[k]/pivot_row[k]
    return Ab
</code></pre>
<p>The result is:</p>
<pre><code>array([[  1. ,  -4. ,   1. ,   7. ],
       [  0. ,  10. ,  -2. ,   6. ],
       [  0. ,   0. ,   1.4, -13.2]])
</code></pre>
<p>How could I count the operations?</p>
<p>Note: I know the number of operations can be evaluated mathematically beforehand (i.e. for <a href="https://en.wikipedia.org/wiki/Gaussian_elimination#Computational_efficiency" rel="nofollow">Gaussian elimination</a> it is O(n^3)).</p>
</div>
<div class="post-text" itemprop="text">
<p>I am assuming you are trying to reduce the complexity here for performance. Listed in this post is an approach to <em>kill</em> the inner loop of <code>Gauss-elimination</code> with <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" rel="nofollow"><code>broadcasting</code></a> giving us a partially vectorized solution, like so -</p>
<pre><code># Concatenate A and b into a single 2D array
Ab = np.concatenate((A,b),axis=1)

for k, pivot_row in enumerate(Ab[:-1]):

    # Vectorized broadcasting magic happens here : 
    # Calculate offsets corresponding to "pivot_row[k:] * row[k]/pivot_row[k]" 
    offsets = (Ab[k+1:,k][:,None] * pivot_row[k:])/pivot_row[k]

    # Update each row
    Ab[k+1:,k:] -= offsets
</code></pre>
<p>Runtime tests and verify output -</p>
<pre><code>In [137]: def partvect_gauss_elim(A,b):
     ...:     Ab = np.concatenate((A,b),axis=1)
     ...:     for k, pivot_row in enumerate(Ab[:-1]):
     ...:         offsets = (Ab[k+1:,k][:,None] * pivot_row[k:])/pivot_row[k]
     ...:         Ab[k+1:,k:] -= offsets
     ...:     return Ab
     ...: 
     ...: def original_gauss_elim(A,b):
     ...:     Ab = np.concatenate((A,b),axis=1)
     ...:     for k, pivot_row in enumerate(Ab[:-1]):
     ...:         for row in Ab[k+1:]:
     ...:             if pivot_row[k] != 0:
     ...:                 row[k:] = row[k:] - pivot_row[k:] * row[k]/pivot_row[k]
     ...:     return Ab
     ...: 

In [138]: A = np.random.randint(0,9,(50,50))
     ...: b = np.random.randint(0,9,(50,1))
     ...: 

In [139]: np.allclose(original_gauss_elim(A,b),partvect_gauss_elim(A,b))
Out[139]: True

In [140]: %timeit original_gauss_elim(A,b)
100 loops, best of 3: 12.1 ms per loop

In [141]: %timeit partvect_gauss_elim(A,b)
100 loops, best of 3: 2.56 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you can take a little time for it, there should be a way: create a class of numbers and override the basic arithmetic methods: <code>__add__</code>, <code>__mul__</code>, <code>__sub__</code>, <code>__div__</code> by embedding a counter system in it (related to some global variable for instance). You should then be able to force Numpy to use your type by using the <code>dtype=object</code> parameter (at array creation) to make sure that Numpy doesn't convert your numbers to any other type. I sometimes did it for simpler task; I never did it with Numpy, but it should probably work. Hope it can help.</p>
</div>
<span class="comment-copy">What do you mean by <code>numerically</code>?</span>
<span class="comment-copy"><i>"Is there a way to evalute the number of numeric operations (+, -, /, *) numerically."</i> - there's four of them?</span>
<span class="comment-copy">you <i>may</i> be able to do that using <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.call_count" rel="nofollow noreferrer"><code>unittest.mock.Mock.call_count</code></a> and using <code>object</code> arrays</span>
<span class="comment-copy">By <code>numerically</code> I mean to count it in the program and not mathematically beforehand. In example for the case above, I know that mathematical arithmetic complexity is O(n^2), see for instance: <a href="https://en.wikipedia.org/wiki/Gaussian_elimination#Computational_efficiency" rel="nofollow noreferrer">en.wikipedia.org/wiki/â€¦</a>.</span>
<span class="comment-copy">@blaz Are you talking about performance to reduce time complexity and thus improve performance? That "numerically" or beforehand thing is still unclear to me.</span>
