<div class="post-text" itemprop="text">
<p>I am using Python's <a href="http://docs.python.org/library/logging.html" rel="noreferrer">logging</a> module and I want to disable the console logging for some time but it doesn't work.</p>
<pre><code>#!/usr/bin/python
import logging

logger = logging.getLogger() # this gets the root logger
# ... here I add my own handlers 
#logger.removeHandler(sys.stdout)
#logger.removeHandler(sys.stderr)

print logger.handlers 
# this will print [&lt;logging.StreamHandler instance at ...&gt;]
# but I may have other handlers there that I want to keep

logger.debug("bla bla")
</code></pre>
<p>The above code displays the <code>bla bla</code> on stdout and I don't know how can I safely disable the console handler. How can I be sure that I temporarily remove the console StreamHandler and not another one?</p>
</div>
<div class="post-text" itemprop="text">
<p>I found a solution for this:</p>
<pre><code>logger = logging.getLogger('my-logger')
logger.propagate = False
# now if you use logger it will not log to console.
</code></pre>
<p>This will prevent logging from being send to the upper logger that includes the console logging.</p>
</div>
<div class="post-text" itemprop="text">
<p>I use:</p>
<pre><code>logger = logging.getLogger()
logger.disabled = True
... whatever you want ...
logger.disabled = False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use:</p>
<pre><code>logging.basicConfig(level=your_level)
</code></pre>
<p>where <strong>your_level</strong> is one of those:</p>
<pre><code>      'debug': logging.DEBUG,
      'info': logging.INFO,
      'warning': logging.WARNING,
      'error': logging.ERROR,
      'critical': logging.CRITICAL
</code></pre>
<p>So, if you set <strong>your_level</strong> to <strong>logging.CRITICAL</strong>, you will get only critical messages sent by: </p>
<pre><code>logging.critical('This is a critical error message')
</code></pre>
<p>Setting <strong>your_level</strong> to <strong>logging.DEBUG</strong> will show all levels of logging.</p>
<p>For more details, please take a look at <a href="http://docs.python.org/library/logging.html?highlight=logging#simple-examples" rel="noreferrer">logging examples.</a></p>
<p>In the same manner to change level for each Handler use <a href="http://docs.python.org/library/logging.html?highlight=logging#logging.Handler.setLevel" rel="noreferrer">Handler.setLevel()</a> function.</p>
<pre><code>import logging
import logging.handlers

LOG_FILENAME = '/tmp/logging_rotatingfile_example.out'

# Set up a specific logger with our desired output level
my_logger = logging.getLogger('MyLogger')
my_logger.setLevel(logging.DEBUG)

# Add the log message handler to the logger
handler = logging.handlers.RotatingFileHandler(
          LOG_FILENAME, maxBytes=20, backupCount=5)

handler.setLevel(logging.CRITICAL)

my_logger.addHandler(handler)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>(long dead question, but for future searchers)</p>
<p>Closer to the original poster's code/intent, this works for me under python 2.6</p>
<pre><code>#!/usr/bin/python
import logging

logger = logging.getLogger() # this gets the root logger

lhStdout = logger.handlers[0]  # stdout is the only handler initially

# ... here I add my own handlers 
f = open("/tmp/debug","w")          # example handler
lh = logging.StreamHandler(f)
logger.addHandler(lh)

logger.removeHandler(lhStdout)

logger.debug("bla bla")
</code></pre>
<p>The gotcha I had to work out was to remove the stdout handler <em>after</em> adding a new one; the logger code appears to automatically re-add the stdout if no handlers are present.</p>
</div>
<div class="post-text" itemprop="text">
<p>Context manager</p>
<pre><code>import logging 
class DisableLogger():
    def __enter__(self):
       logging.disable(logging.CRITICAL)
    def __exit__(self, a, b, c):
       logging.disable(logging.NOTSET)
</code></pre>
<p>Example of use:</p>
<pre><code>with DisableLogger():
    do_something()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are some really nice answers here, but apparently the simplest is not taken too much in consideration (only from infinito).</p>
<pre><code>root_logger = logging.getLogger()
root_logger.disabled = True
</code></pre>
<p>This disables the root logger, and thus all the other loggers.
I haven't really tested but it should be also the fastest.</p>
<p>From the logging code in python 2.7 I see this</p>
<pre><code>def handle(self, record):
    """
    Call the handlers for the specified record.

    This method is used for unpickled records received from a socket, as
    well as those created locally. Logger-level filtering is applied.
    """
    if (not self.disabled) and self.filter(record):
        self.callHandlers(record)
</code></pre>
<p>Which means that when it's disabled no handler is called, and it should be more efficient that filtering to a very high value or setting a no-op handler for example.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>To fully disable logging</strong>:</p>
<pre><code>logging.disable(sys.maxint) # Python 2

logging.disable(sys.maxsize) # Python 3
</code></pre>
<p><strong>To enable logging</strong>:</p>
<pre><code>logging.disable(logging.NOTSET)
</code></pre>
<hr/>
<p>Other answers provide work arounds which don't fully solve the problem, such as</p>
<pre><code>logging.getLogger().disabled = True
</code></pre>
<p>and, for some <code>n</code> greater than 50,</p>
<pre><code>logging.disable(n)
</code></pre>
<p>The problem with the first solution is that it only works for the root logger. Other loggers created using, say, <code>logging.getLogger(__name__)</code> are not disabled by this method.</p>
<p>The second solution does affect all logs. But it limits output to levels above that given, so one could override it by logging with a level greater than 50. </p>
<p>That can be prevented by</p>
<pre><code>logging.disable(sys.maxint)
</code></pre>
<p>which as far as I can tell (after reviewing the <a href="https://hg.python.org/cpython/file/2.7/Lib/logging/__init__.py" rel="noreferrer">source</a>) is the only way to fully disable logging.</p>
</div>
<div class="post-text" itemprop="text">
<p>No need to divert stdout. Here is better way to do it:</p>
<pre><code>import logging
class MyLogHandler(logging.Handler):
    def emit(self, record):
        pass

logging.getLogger().addHandler(MyLogHandler())
</code></pre>
<p>An even simpler way is:</p>
<pre><code>logging.getLogger().setLevel(100)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't know the logging module very well, but I'm using it in the way that I usually want to disable only debug (or info) messages. You can use <code>Handler.setLevel()</code> to set the logging level to CRITICAL or higher.</p>
<p>Also, you could replace sys.stderr and sys.stdout by a file open for writing. See <a href="http://docs.python.org/library/sys.html#sys.__stdout__" rel="nofollow noreferrer">http://docs.python.org/library/sys.html#sys.<strong>stdout</strong></a>. But I wouldn't recommend that.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could also:</p>
<pre><code>handlers = app.logger.handlers
# detach console handler
app.logger.handlers = []
# attach
app.logger.handlers = handlers
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import logging

log_file = 'test.log'
info_format = '%(asctime)s - %(levelname)s - %(message)s'
logging.config.dictConfig({
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'info_format': {
            'format': info_format
        },
    },
    'handlers': {
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'info_format'
        },
        'info_log_file': {
            'class': 'logging.handlers.RotatingFileHandler',
            'level': 'INFO',
            'filename': log_file,
            'formatter': 'info_format'
        }
    },
    'loggers': {
        '': {
            'handlers': [
                'console',
                'info_log_file'
            ],
            'level': 'INFO'
        }
    }
})


class A:

    def __init__(self):
        logging.info('object created of class A')

        self.logger = logging.getLogger()
        self.console_handler = None

    def say(self, word):
        logging.info('A object says: {}'.format(word))

    def disable_console_log(self):
        if self.console_handler is not None:
            # Console log has already been disabled
            return

        for handler in self.logger.handlers:
            if type(handler) is logging.StreamHandler:
                self.console_handler = handler
                self.logger.removeHandler(handler)

    def enable_console_log(self):
        if self.console_handler is None:
            # Console log has already been enabled
            return

        self.logger.addHandler(self.console_handler)
        self.console_handler = None


if __name__ == '__main__':
    a = A()
    a.say('111')
    a.disable_console_log()
    a.say('222')
    a.enable_console_log()
    a.say('333')
</code></pre>
<p>Console output:</p>
<pre><code>2018-09-15 15:22:23,354 - INFO - object created of class A
2018-09-15 15:22:23,356 - INFO - A object says: 111
2018-09-15 15:22:23,358 - INFO - A object says: 333
</code></pre>
<p>test.log file content:</p>
<pre><code>2018-09-15 15:22:23,354 - INFO - object created of class A
2018-09-15 15:22:23,356 - INFO - A object says: 111
2018-09-15 15:22:23,357 - INFO - A object says: 222
2018-09-15 15:22:23,358 - INFO - A object says: 333
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>subclass the handler you want to be able to disable temporarily:</p>
<pre><code>class ToggledHandler(logging.StreamHandler):
"""A handler one can turn on and off"""

def __init__(self, args, kwargs):
    super(ToggledHandler, self).__init__(*args, **kwargs)
    self.enabled = True  # enabled by default

def enable(self):
    """enables"""
    self.enabled = True

def disable(self):
    """disables"""
    self.enabled = False

def emit(self, record):
    """emits, if enabled"""
    if self.enabled:
        # this is taken from the super's emit, implement your own
        try:
            msg = self.format(record)
            stream = self.stream
            stream.write(msg)
            stream.write(self.terminator)
            self.flush()
        except Exception:
            self.handleError(record)
</code></pre>
<p>finding the handler by name is quite easy:</p>
<pre><code>_handler = [x for x in logging.getLogger('').handlers if x.name == your_handler_name]
if len(_handler) == 1:
    _handler = _handler[0]
else:
    raise Exception('Expected one handler but found {}'.format(len(_handler))
</code></pre>
<p>once found:</p>
<pre><code>_handler.disable()
doStuff()
_handler.enable()
</code></pre>
</div>
<span class="comment-copy">For those wondering why anyone would want to disable logging: You wouldn't want to log private data like passwords or API keys.</span>
<span class="comment-copy">@StevenVascellaro. Why are those being sent to a logger in the first place then? That doesn't sound right...</span>
<span class="comment-copy">@MadPhysicist I have an application which sends XML requests to an external API. By default, these requests are logged to a file. However, the initial login requires authentication with a username and password, which I don't want logged.</span>
<span class="comment-copy">@StevenVascellaro. I see. Thanks for the explanation.</span>
<span class="comment-copy">You do not show how/where you add your handlers. If they were added to the root logger this would prevent logging from adding default StreamHandler as described at <a href="https://docs.python.org/3/library/logging.html#logging.basicConfig" rel="nofollow noreferrer">docs.python.org/3/library/logging.html#logging.basicConfig</a> Also, per linked description, the default StreamHandler is only added during first call emitting log message so when you print <code>logger.handlers</code> it should be empty (as it precedes <code>logger.debug()</code> call). The code in question displays only <code>[]</code> (empty list of handlers). Verified with Python 2.7.15 and Python 3.6.6.</span>
<span class="comment-copy">This works for Python 3.5. Thank you!</span>
<span class="comment-copy">I don't think this is a good solution. Not propagating to higher loggers could have other undesirable consequences.</span>
<span class="comment-copy">If you wanted to only filter message below a certain log level (say, all <code>INFO</code> messages), you could change the second line to something like <code>logger.setLevel(logging.WARNING)</code></span>
<span class="comment-copy">How would you re-enable the log afterwards?</span>
<span class="comment-copy"><b>Not an answer</b> as blocking propagation effectively disables all handlers of the root logger and the question clearly states <i>(…) but I may have other handlers there that I want to keep</i> which suggests the intention is to disable default StreamHandler of the root logger <b>only</b>.</span>
<span class="comment-copy">this also works at the <code>logging</code> module level to disable logging <i>entirely</i>, for example: <code>import logging; logging.disable(logging.CRITICAL);</code>: <a href="https://docs.python.org/2/library/logging.html#logging.disable" rel="nofollow noreferrer">docs.python.org/2/library/logging.html#logging.disable</a></span>
<span class="comment-copy">This is much better than disabling propagation.</span>
<span class="comment-copy"><b>Not an answer</b> – the question asks how to disable default StreamHandler <b>only</b>.</span>
<span class="comment-copy">The <code>disabled</code> attribute is not part of the public API. See <a href="https://bugs.python.org/issue36318" rel="nofollow noreferrer">bugs.python.org/issue36318</a>.</span>
<span class="comment-copy">This is generally useful info, but the question asked how t o disable console logging, not how to add an additional handler.   if you were to examine my_logger.handlers with the above code applied to the original example, you'd see two handlers -- your new file handler and the original stream handler.</span>
<span class="comment-copy">The sequence <code>logger = logging.getLogger(); lhStdout = logger.handlers[0]</code> is wrong as the root logger initially has no handlers – <code>python -c "import logging; assert not logging.getLogger().handlers"</code>. Verified with Python 2.7.15 and Python 3.6.6.</span>
<span class="comment-copy">I really like this idiom, but I would rather be able to disable a particular namespace. For example, I just want the root logger temporarily disabled. Although using this idiom, we should be able to just temporarily add/remove handlers and the such.</span>
<span class="comment-copy">The question asks how to disable default StreamHandler <b>only</b>.</span>
<span class="comment-copy">You don’t need to roll your own class, you can use @contextmanager from contextlib and write a yielding function</span>
<span class="comment-copy">Unless I am doing something wrong, this only disables the root logger and not any created like <code>log = logging.getLogger(__name__)</code></span>
<span class="comment-copy">This could be problematic if you're dealing with multiple loggers or multiple handlers.    If, for example, you still want to log to a file but want to disable the stream handler in a specific case.</span>
<span class="comment-copy"><i>This disables the root logger, and thus all the other loggers</i> – strictly speaking disabling the root logger does not disable any other loggers. Besides the question asks about disabling default StreamHandler <b>only</b>.</span>
<span class="comment-copy">The <code>disabled</code> attribute is not part of the public API. See <a href="https://bugs.python.org/issue36318" rel="nofollow noreferrer">bugs.python.org/issue36318</a>.</span>
<span class="comment-copy">Downvote as the question asks how to disable standard StreamHandler <b>only</b></span>
<span class="comment-copy">In Python 2.7+ this is available as <a href="https://docs.python.org/2/library/logging.handlers.html#nullhandler" rel="nofollow noreferrer">NullHandler()</a></span>
<span class="comment-copy">The reason why this works (disables default StreamHandler) can be seen when reading description of <code>logging.basicConfig()</code> function (emphasis mine): <i>Does basic configuration for the logging system by creating a StreamHandler with a default Formatter and adding it to the root logger. The functions debug(), info(), warning(), error() and critical() will call basicConfig() automatically <b>if no handlers are defined for the root logger</b>.</i> – <a href="https://docs.python.org/3/library/logging.html#logging.basicConfig" rel="nofollow noreferrer">docs.python.org/3/library/logging.html#logging.basicConfig</a></span>
<span class="comment-copy">This could work if logger.handlers would be contain something, currently is <code>[]</code>.</span>
<span class="comment-copy">Why are you using <code>app.logger</code> which you don't even specify instead of the root logger explicitly mentioned in the question (<code>logging.getLogger()</code>) and most answers? How do you know you can safely modify <code>handlers</code> property instead of calling <code>Logger.addHandler</code> method?</span>
<span class="comment-copy">Add some description about the code. It would help much better</span>
