<div class="post-text" itemprop="text">
<p><strong>How to find the majority votes for a list that can contain -1s, 1s and 0s?</strong> </p>
<p>For example, given a list of:</p>
<pre><code>x = [-1, -1, -1, -1, 0]
</code></pre>
<p>The majority is -1 , so the output should return <code>-1</code></p>
<p>Another example, given a list of:</p>
<pre><code>x = [1, 1, 1, 0, 0, -1]
</code></pre>
<p>The majority vote would be <code>1</code></p>
<p>And when we have a tie, the majority vote should return 0, e.g.:</p>
<pre><code>x = [1, 1, 1, -1, -1, -1]
</code></pre>
<p>This should also return zero:</p>
<pre><code>x = [1, 1, 0, 0, -1, -1]
</code></pre>
<p>The simplest case to get the majority vote seem to sum the list up and check whether it's negative, positive or 0. </p>
<pre><code>&gt;&gt;&gt; x = [-1, -1, -1, -1, 0]
&gt;&gt;&gt; sum(x) # So majority -&gt; 0
-4
&gt;&gt;&gt; x = [-1, 1, 1, 1, 0]
&gt;&gt;&gt; sum(x) # So majority -&gt; 1
2
&gt;&gt;&gt; x = [-1, -1, 1, 1, 0]
&gt;&gt;&gt; sum(x) # So majority is tied, i.e. -&gt; 0
0
</code></pre>
<p>After the sum, I could do this check to get the majority vote, i.e.:</p>
<pre><code>&gt;&gt;&gt; x = [-1, 1, 1, 1, 0]
&gt;&gt;&gt; majority = -1 if sum(x) &lt; 0 else 1 if sum(x)!=0 else 0
&gt;&gt;&gt; majority
1
&gt;&gt;&gt; x = [-1, -1, 1, 1, 0]
&gt;&gt;&gt; majority = -1 if sum(x) &lt; 0 else 1 if sum(x)!=0 else 0
&gt;&gt;&gt; majority
0
</code></pre>
<p>But as noted previously, it's ugly: <a href="https://stackoverflow.com/questions/14029245/python-putting-an-if-elif-else-statement-on-one-line">Python putting an if-elif-else statement on one line</a> and not pythonic.</p>
<p>So the solution seems to be </p>
<pre><code>&gt;&gt;&gt; x = [-1, -1, 1, 1, 0]
&gt;&gt;&gt; if sum(x) == 0:
...     majority = 0
... else:
...     majority = -1 if sum(x) &lt; 0 else 1
... 
&gt;&gt;&gt; majority
0
</code></pre>
<hr/>
<h1>EDITED</h1>
<p>But there are cases that <code>sum()</code> won't work, @RobertB's e.g. </p>
<pre><code>&gt;&gt;&gt; x = [-1, -1, 0, 0, 0, 0]
&gt;&gt;&gt; sum(x) 
-2
</code></pre>
<p>But in this case the majority vote should be 0!!</p>
</div>
<div class="post-text" itemprop="text">
<p>I am assuming that votes for 0 count as votes. So <code>sum</code> is not a reasonable option.</p>
<p>Try a Counter:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; x = Counter([-1,-1,-1, 1,1,1,1,0,0,0,0,0,0,0,0])
&gt;&gt;&gt; x
Counter({0: 8, 1: 4, -1: 3})
&gt;&gt;&gt; x.most_common(1)
[(0, 8)]
&gt;&gt;&gt; x.most_common(1)[0][0]
0
</code></pre>
<p>So you could write code like:</p>
<pre><code>from collections import Counter

def find_majority(votes):
    vote_count = Counter(votes)
    top_two = vote_count.most_common(2)
    if len(top_two)&gt;1 and top_two[0][1] == top_two[1][1]:
        # It is a tie
        return 0
    return top_two[0][0]

&gt;&gt;&gt; find_majority([1,1,-1,-1,0]) # It is a tie
0
&gt;&gt;&gt; find_majority([1,1,1,1, -1,-1,-1,0])
1
&gt;&gt;&gt; find_majority([-1,-1,0,0,0]) # Votes for zero win
0
&gt;&gt;&gt; find_majority(['a','a','b',]) # Totally not asked for, but would work
'a'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use  <a href="https://docs.python.org/3/library/statistics.html#statistics.mode" rel="nofollow">statistics.mode</a> if you were using python &gt;= 3.4 ,catching a <code>StatisticsError</code> for when you have no unique mode:</p>
<pre><code>from statistics import mode, StatisticsError

def majority(l):
    try:
        return mode(l)
    except StatisticsError:
        return 0
</code></pre>
<p>The <a href="https://hg.python.org/cpython/file/3.5/Lib/statistics.py" rel="nofollow">statistics</a> implementation itself uses a Counter dict:</p>
<pre><code>import  collections
def _counts(data):
    # Generate a table of sorted (value, frequency) pairs.
    table = collections.Counter(iter(data)).most_common()
    if not table:
        return table
    # Extract the values with the highest frequency.
    maxfreq = table[0][1]
    for i in range(1, len(table)):
        if table[i][1] != maxfreq:
            table = table[:i]
            break
    return table

def mode(data):
    """Return the most common data point from discrete or nominal data.

    ``mode`` assumes discrete data, and returns a single value. This is the
    standard treatment of the mode as commonly taught in schools:

    &gt;&gt;&gt; mode([1, 1, 2, 3, 3, 3, 3, 4])
    3

    This also works with nominal (non-numeric) data:

    &gt;&gt;&gt; mode(["red", "blue", "blue", "red", "green", "red", "red"])
    'red'

    If there is not exactly one most common value, ``mode`` will raise
    StatisticsError.
    """
    # Generate a table of sorted (value, frequency) pairs.
    table = _counts(data)
    if len(table) == 1:
        return table[0][0]
    elif table:
        raise StatisticsError(
                'no unique mode; found %d equally common values' % len(table)
                )
    else:
        raise StatisticsError('no mode for empty data')
</code></pre>
<p>Another way  using a Counter and catching an empty list:</p>
<pre><code>def majority(l):
    cn = Counter(l).most_common(2)
    return 0 if len(cn) &gt; 1 and cn[0][1] == cn[1][1] else next(iter(cn),[0])[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can <a href="https://stackoverflow.com/questions/2600191/how-can-i-count-the-occurrences-of-a-list-item-in-python">count occurences</a> of 0 and test if they are majority. </p>
<pre><code>&gt;&gt;&gt; x = [1, 1, 0, 0, 0]
&gt;&gt;&gt; if sum(x) == 0 or x.count(0) &gt;= len(x) / 2.0:
...     majority = 0
... else:
...     majority = -1 if (sum(x) &lt; 0) else 1
... majority
0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This solution is based on counting occurrences and sorting:</p>
<pre><code>import operator
def determineMajority(x):
    '''
    &gt;&gt;&gt; determineMajority([-1, -1, -1, -1, 0])
    -1

    &gt;&gt;&gt; determineMajority([1, 1, 1, 0, 0, -1])
    1

    &gt;&gt;&gt; determineMajority([1, 1, 1, -1, -1, -1])
    0

    &gt;&gt;&gt; determineMajority([1, 1, 1, 0, 0, 0])
    0

    &gt;&gt;&gt; determineMajority([1, 1, 0, 0, -1, -1])
    0

    &gt;&gt;&gt; determineMajority([-1, -1, 0, 0, 0, 0])
    0
    '''

    # Count three times
    # sort on counts
    xs = sorted(
        [(i, x.count(i)) for i in range(-1,2)],
        key=operator.itemgetter(1),
        reverse=True
    )

    if xs[0][1] &gt; xs[1][1]:
        return xs[0][0]
    else:
        # tie
        return 0


if __name__ == '__main__':
    import doctest
    doctest.testmod()
</code></pre>
<p>Additionally, there is one if statements. As mentioned in the comments it is undefined what happens with </p>
<blockquote>
<p>x = [1, 1, 0, 0, -1]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I believe this works for all provided test cases. Please let me know if I did something wrong.</p>
<pre><code>from collections import Counter

def fn(x):
    counts = Counter(x)
    num_n1 = counts.get(-1, 0)
    num_p1 = counts.get(1, 0)
    num_z = counts.get(0, 0)
    if num_n1 &gt; num_p1:
        return -1 if num_n1 &gt; num_z else 0
    elif num_p1 &gt; num_n1:
        return 1 if num_p1 &gt; num_z else 0
    else:
        return 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import Counter

result = Counter(votes).most_common(2)

result = 0 if result[0][1] == result[1][1] else result[0][0]
</code></pre>
<p>Error handling for empty <code>votes</code> lists or <code>votes</code> lists with a set cardinality of 1 is trivial and left as an exercise for the reader.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code># These are your actual votes
votes = [-1, -1, -1, -1, 0]

# These are the options on the ballot
ballot = (-1, 0, 1)

# This is to initialize your counters
counters = {x: 0 for x in ballot}

# Count the number of votes
for vote in votes:
    counters[vote] += 1

results = counters.values().sort()

if len(set(values)) &lt; len(ballot) and values[-1] == values [-2]:
    # Return 0 if there's a tie
    return 0
else:
    # Return your winning vote if there isn't a tie
    return max(counters, key=counters.get)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This works with any number of candidates. If there is a tie between two candidates it returns zero else it returns candidate with most votes.</p>
<pre><code>from collections import Counter
x = [-1, -1, 0, 0, 0, 0]
counts = list((Counter(x).most_common())) ## Array in descending order by votes
if len(counts)&gt;1 and (counts[0][1] == counts[1][1]): ## Comparing top two candidates 
   print 0
else:
   print counts[0][0]
</code></pre>
<p>We compare only two candidates because if there is a tie between two candidates it should return 0 and it doesn't depend on third candidate value</p>
</div>
<div class="post-text" itemprop="text">
<p>A very simple approach.</p>
<pre><code>a = [-1, -1, -1, -1, 0]   # Example
count = {}
for i in a:
    if i not in count:
        count[i] = 1
    else:
        count[i] += 1
m_count = max(count.values())
for key in count:
    if count[key] == m_count:
        print key
</code></pre>
<p>In the above example the output will be -1,
however if there is a tie, both the keys will be printed.</p>
</div>
<div class="post-text" itemprop="text">
<p>An obvious approach is making a counter and updating it according to the data list <code>x</code>. Then you can get the list of numbers (from -1, 0, 1) that are the most frequent. If there is 1 such number, this is what you want, otherwise choose 0 (as you requested).</p>
<pre><code>counter = {-1: 0, 0: 0, 1: 0}
for number in x:
    counter[number] += 1
best_values = [i for i in (-1, 0, 1) if counter[i] == max(counter.values())]
if len(best_values) == 1:
    majority = best_values[0]
else:
    majority = 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need anything but built-in list operators and stuff, no need to import anything.</p>
<pre><code>  votes = [ -1,-1,0,1,0,1,-1,-1] # note that we don't care about ordering

    counts = [ votes.count(-1),votes.count(0),votes.count(1)] 

    if (counts[0]&gt;0 and counts.count(counts[0]) &gt; 1) or (counts[1]&gt;0 and counts.count(counts[1])&gt;1):
         majority=0
    else:
         majority=counts.index(max(counts))-1 # subtract 1 as indexes start with 0

    print majority
</code></pre>
<p>3d line puts counts of respective votes in a new list, and counts.index() shows us which list position we find the max votes.</p>
<p>I would dare to say that this should be about as pythonic as it can, without getting into eye-gouging oneliners.</p>
<p>Upd: rewrote without text strings and updated to return 0 in case of several equal results (didnt notice this in the original post), added an IF for case if only one vote, eg votes=[-1]</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import Counter

def find_majority_vote(votes):
  counter = Counter(votes)
  most_common = counter.most_common(2)
  if len(most_common)==2:
    return 0 if most_common[0][1] == most_common[1][1] else most_common[0][0]
  else:
    return most_common[0][0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import numpy as np

def fn(vote):
   n=vote[np.where(vote&lt;0)].size
   p=vote[np.where(vote&gt;0)].size
   ret=np.sign(p-n)
   z=vote.size-p-n
   if z&gt;=max(p,n):
      ret=0
   return ret

# some test cases
print fn(np.array([-1,-1, 1,1,1,1,0,0,0,0,0,0,0,0]))
print fn(np.array([-1, -1, -1, 1,1,1,0,0]))
print fn(np.array([0,0,0,1,1,1]))
print fn(np.array([1,1,1,1, -1,-1,-1,0]))
print fn(np.array([-1, -1, -1, -1, 1, 0]))
</code></pre>
</div>
<span class="comment-copy">Can the majority vote be 0? So if <code>[-1, -1, 0, 0, 0, 0]</code> is the answer zero? In that case, <code>sum</code> is not going to work for you.</span>
<span class="comment-copy">It's not a statement; it's an expression.  How can using one of the built-in expressions in the language be "not pythonic?"</span>
<span class="comment-copy">ooo, yeah, right. So what's the solution?</span>
<span class="comment-copy">I would recommend that you replace "majority" with "plurality" in your problem title and definition, as this appears to be what you mean.  It's a fairly significant difference in the solution.</span>
<span class="comment-copy">Are they always grouped?</span>
<span class="comment-copy">What is there's a draw with the counter? e.g. <code>x = [1, 1, 0, 0, -1]</code>?</span>
<span class="comment-copy">In the case of <code>x = [1, 1, 0, 0, -1]</code> the majority would be both <code>1 and 0</code>.</span>
<span class="comment-copy">Try it. Either way, a Counter simplifies everything I would think.</span>
<span class="comment-copy">Ok I gave you a solution in the answer.</span>
<span class="comment-copy">Except when OP says "majority", it appears to mean "plurality".</span>
<span class="comment-copy">Try <code>x = [1,-1,-1,0,0]</code></span>
<span class="comment-copy"><code>x = [1,-1,-1,0,0]</code> will give <code>majority = -1</code></span>
<span class="comment-copy">Why are you doing tests to mc? In every case you can just return mc.</span>
<span class="comment-copy">@RobertB Yes I realize that. Sorry I will fix it.</span>
<span class="comment-copy">Ok now I like it. It is more compact than mine ;)</span>
<span class="comment-copy">Question: If you have an input of <code>[0,0,0,1,1,1]</code> or <code>[-1, -1, -1, 0,0,0]</code>, these are ties. Will <code>most_common(1)[0][0]</code> always return 0? Might it sometimes return 1? Can't find any documentation on this, so I worry. In practice, it seems to consistently return 0, but I'm not sure why.</span>
<span class="comment-copy">@RobertB You have made me realize that my answer is undefined for those test cases. In <a href="https://docs.python.org/3/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer">the documentation</a> it clearly states that there is no guarantee over the order of returned elements from Counter.most_common. Makes sense because the underlying structure is typically a dictionary which is ordered in a volatile hash table bucket scheme. However, it should be noted that the question itself did not define what should happen in these "tie" cases between 1 or -1 and 0.</span>
<span class="comment-copy">Whoa. I've never used <code>max</code> that way... this is very clever.</span>
<span class="comment-copy">I don't think this will give you what you want if votes is, e.g. <code>[-1, -1, 1, 1]</code></span>
<span class="comment-copy">@TomKarzesThat gives 0 since <code>sum([-1,-1,1,1])</code> is 0 which is correct since it is a tie, given the rules. What did you think was wrong?</span>
<span class="comment-copy">Ok wait, what if votes is:  <code>[-1, 0, 0, 1, 1]</code>?  As opposed to <code>[-1, 1, 1, 0, 0]</code>?  These give different answers.</span>
<span class="comment-copy">Your new edit will fail if everyone votes the same <code>[1,1,1]</code></span>
<span class="comment-copy">okay you can ignore my answer. I gave the same answer as RobertB . I checked it after answering the question.</span>
