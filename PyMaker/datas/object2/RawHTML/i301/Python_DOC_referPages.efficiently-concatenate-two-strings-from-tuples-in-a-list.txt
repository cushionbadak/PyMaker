<div class="post-text" itemprop="text">
<p>I want to concatenate the two string elements in a list of tuples</p>
<p>I have this:</p>
<pre><code>mylist = [('a', 'b'), ('c', 'd'), ('e', 'f'), ('g', 'h')]
myanswer = []

for tup1 in mylist:
   myanswer.append(tup1[0] + tup[1])
</code></pre>
<p>It's working but is there any easy way to do this? My real list has around 1000 items and I don't think a <code>for</code> loop is the most efficient way.</p>
<p>Expected output:</p>
<pre><code>myanswer = ["ab", "cd", "ef", "gh"]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a list comprehension, and for just two elements, I'd use tuple unpacking and concatenation:</p>
<pre><code>myanswer = [s1 + s2 for s1, s2 in mylist]
</code></pre>
<p>Another option is to use a <a href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings" rel="nofollow noreferrer">formatted string literal</a>:</p>
<pre><code>myanswer = [f"{s1}{s2}" for s1, s2 in mylist]
</code></pre>
<p>Both are reasonably fast:</p>
<pre><code>&gt;&gt;&gt; from random import choice
&gt;&gt;&gt; from string import ascii_letters
&gt;&gt;&gt; from timeit import Timer
&gt;&gt;&gt; testdata = [(choice(ascii_letters), choice(ascii_letters)) for _ in range(10000)]
&gt;&gt;&gt; count, total = Timer('[f"{s1}{s2}" for s1, s2 in mylist]', 'from __main__ import testdata as mylist').autorange()
&gt;&gt;&gt; print(f"List comp with f-string, 10k elements: {total / count * 1000000:7.2f} microseconds")
List comp with f-string, 10k elements: 1249.37 microseconds
&gt;&gt;&gt; count, total = Timer('[s1 + s2 for s1, s2 in mylist]', 'from __main__ import testdata as mylist').autorange()
&gt;&gt;&gt; print(f"List comp with concatenation, 10k elements: {total / count * 1000000:6.2f} microseconds")
List comp with concatenation, 10k elements: 1061.89 microseconds
</code></pre>
<p>Concatenation wins out here.</p>
<p>A list comprehension removes the need to look up the list object and its <code>.append()</code> method each time in a loop, see <a href="https://stackoverflow.com/questions/16341775/what-is-the-advantage-of-a-list-comprehension-over-a-for-loop/16341841#16341841">What is the advantage of a list comprehension over a for loop?</a></p>
<p>Formatted string literals where introduced in Python 3.6, and are easily the fastest way of composing strings with interpolated elements (even though they <a href="https://stackoverflow.com/questions/37365311/why-are-literal-formatted-strings-so-slow-in-python-3-6-alpha-now-fixed-in-3-6">didn't start out that way</a>).</p>
<p>I also tried out [<code>itertools.starmap()</code>] with [<code>operator.add()</code>] and [<code>str.join()</code>], but this doesn't appear to be competitive:</p>
<pre><code>&gt;&gt;&gt; count, total = Timer('list(starmap(add, mylist))', 'from __main__ import testdata as mylist; from itertools import starmap; from operator import add').autorange()
&gt;&gt;&gt; print(f"itertools.starmap and operator.add, 10k elements: {total / count * 1000000:6.2f} microseconds")
itertools.starmap and operator.add, 10k elements: 1275.02 microseconds
&gt;&gt;&gt; count, total = Timer('list(starmap(str.join, mylist))', 'from __main__ import testdata as mylist; from itertools import starmap').autorange()
&gt;&gt;&gt; print(f"itertools.starmap and str.join, 10k elements: {total / count * 1000000:6.2f} microseconds")
itertools.starmap and str.join, 10k elements: 1564.79 microseconds
</code></pre>
<p>It does improve with more elements; by 1 million elements, <code>map(starmap(add, largelist))</code> is winning by a small margin (133ms vs 140ms for a list comprehension with concatenation).</p>
</div>
<span class="comment-copy">Well, your question was confusing. You claimed it wasn't working, then correct it to working code and are asking for a more efficient way to do this. You do want to make sure you are asking the question correctly and clearly, with an example that is actually valid Python code</span>
