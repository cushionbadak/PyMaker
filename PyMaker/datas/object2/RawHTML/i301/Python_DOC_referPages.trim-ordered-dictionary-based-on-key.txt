<div class="post-text" itemprop="text">
<p>What is the fastest way to "trim" a dictionary based on they key?
My understanding is that dictionaries now preserve order since Python 3.7</p>
<p>I have a dictionary that contains key (type datetime): val (type float).
The dictionary is in a sorted (chronological) order.</p>
<pre><code>time_series_dict = 
{"2019-02-27 14:00:00": 95,
"2019-02-27 15:00:00": 98,
"2019-02-27 16:25:00: 80,
.............
"2019-03-01 12:15:00": 85
}
</code></pre>
<p>I would like to trim the dictionary, removing everything outside of <strong>start_date</strong> and <strong>end_date</strong>. Dictionary can have 1000s of values.
Is there a faster method than:</p>
<pre><code>for k in list(time_series_dict.keys()):
    if not start_date &lt;= k &lt;= end_date:
        del time_series_dict[k]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your dictionaries have 1000s of keys, and you are removing keys from the start and end of the ordered sequence of timestamps, consider using <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="nofollow noreferrer">binary search</a> to find the cut-off points in a list copy of the keys. Python includes the <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code> module</a> for this:</p>
<pre><code>from bisect import bisect_left, bisect_right

def trim_time_series_dict(tsd, start_date, end_date):
    ts = list(tsd)
    before = bisect_right(ts, start_date)  # insertion point at &gt; start_date
    after = bisect_left(ts, end_date)      # insertion point is &lt; end_date
    for i in range(before):                # up to == start_date
        del tsd[ts[i]]
    for i in range(after + 1, len(ts)):    # from &gt;= end_date onwards
        del tsd[ts[i]]
</code></pre>
<p>I've run some <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">time trials</a> to see if this is going to make a difference against your typical datasets; as expected, it pays off when the number of keys removed is significantly lower than the length of the input dictionary.</p>
<p>Time trial setup (imports, building the test data dictionary and start and end dates, defining the test functions)</p>
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; from bisect import bisect_left, bisect_right
&gt;&gt;&gt; from datetime import datetime, timedelta
&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; from timeit import Timer
&gt;&gt;&gt; def randomised_ordered_timestamps():
...     date = datetime.now().replace(second=0, microsecond=0)
...     while True:
...         date += timedelta(minutes=random.randint(15, 360))
...         yield date.strftime('%Y-%m-%d %H:%M:%S')
...
&gt;&gt;&gt; test_data = {ts: random.randint(50, 500) for ts in islice(randomised_ordered_timestamps(), 10000)}
&gt;&gt;&gt; start_date = next(islice(test_data, 25, None))                 # trim 25 from the start
&gt;&gt;&gt; end_date = next(islice(test_data, len(test_data) - 25, None))  # trim 25 from the end
&gt;&gt;&gt; def iteration(t, start_date, end_date):
...     time_series_dict = t.copy()  # avoid mutating test data
...     for k in list(time_series_dict.keys()):
...         if not start_date &lt;= k &lt;= end_date:
...             del time_series_dict[k]
...
&gt;&gt;&gt; def bisection(t, start_date, end_date):
...     tsd = t.copy()  # avoid mutating test data
...     ts = list(tsd)
...     before = bisect_right(ts, start_date)  # insertion point at &gt; start_date
...     after = bisect_left(ts, end_date)      # insertion point is &lt; end_date
...     for i in range(before):                # up to == start_date
...         del tsd[ts[i]]
...     for i in range(after + 1, len(ts)):    # from &gt;= end_date onwards
...         del tsd[ts[i]]
...
</code></pre>
<p>Trial outcome:</p>
<pre><code>&gt;&gt;&gt; count, total = Timer("t.copy()", "from __main__ import test_data as t").autorange()
&gt;&gt;&gt; baseline = total / count
&gt;&gt;&gt; for test in (iteration, bisection):
...     timer = Timer("test(t, s, e)", "from __main__ import test, test_data as t, start_date as s, end_date as e")
...     count, total = timer.autorange()
...     print(f"{test.__name__:&gt;10}: {((total / count) - baseline) * 1000000:6.2f} microseconds")
...
 iteration: 671.33 microseconds
 bisection:  80.92 microseconds
</code></pre>
<p>(The test subtracts the base-line cost of making a dict copy first).</p>
<p>However, there may well be more efficient data structures for these kind of operations. I checked out the <a href="http://www.grantjenks.com/docs/sortedcontainers/" rel="nofollow noreferrer"><code>sortedcontainers</code> project</a> as it includes a <a href="http://www.grantjenks.com/docs/sortedcontainers/sorteddict.html" rel="nofollow noreferrer"><code>SortedDict()</code> type</a> that supports bisection on the keys directly. Unfortunately, while it performs better than your iteration approach, I can't make it perform better here than bisecting on a copy of the keys list:</p>
<pre><code>&gt;&gt;&gt; from sortedcontainers import SortedDict
&gt;&gt;&gt; test_data_sorteddict = SortedDict(test_data)
&gt;&gt;&gt; def sorteddict(t, start_date, end_date):
...     tsd = t.copy()
...     # SortedDict supports slicing on the key view
...     keys = tsd.keys()
...     del keys[:tsd.bisect_right(start_date)]
...     del keys[tsd.bisect_left(end_date) + 1:]
...
&gt;&gt;&gt; count, total = Timer("t.copy()", "from __main__ import test_data_sorteddict as t").autorange()
&gt;&gt;&gt; baseline = total / count
&gt;&gt;&gt; timer = Timer("test(t, s, e)", "from __main__ import sorteddict as test, test_data_sorteddict as t, start_date as s, end_date as e")
&gt;&gt;&gt; count, total = timer.autorange()
&gt;&gt;&gt; print(f"sorteddict: {((total / count) - baseline) * 1000000:6.2f} microseconds")
sorteddict: 249.46 microseconds
</code></pre>
<p>I may be using the project wrong, however. Deleting keys from <code>SortedDict</code> objects is O(NlogN) so I suspect that that's where this falls down. Creating a new <code>SortedDict()</code> object from the other 9950 key-value pairs is slower still (over 2 milliseconds, not something you want to compare against the other approaches).</p>
<p>However, if you were to use the <a href="http://www.grantjenks.com/docs/sortedcontainers/sortedlist.html#sortedcontainers.SortedList.irange" rel="nofollow noreferrer"><code>SortedDict.irange()</code> method</a> you can simply <em>ignore</em> values, not delete them, and iterate over a sub-set of dictionary keys:</p>
<pre><code>for ts in timeseries(start_date, end_date, inclusive=(False, False)):
    # iterates over all start_date &gt; timestamp &gt; end_date keys, in order.
</code></pre>
<p>eliminating the need to delete anything. The <code>irange()</code> implementation uses bisection under the hood.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import time

import timeit

print(timeit.timeit(setup="""import datetime
time_series_dict = {}
for i in range(10000):
    t =datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S:%f')
    time_series_dict[t] = i
    if i ==100:
        start_time = t
    if i == 900:
        end_time = t
        """,
stmt="""
tmp = time_series_dict.copy()
for k in list(tmp.keys()):
    if not start_time &lt;= k &lt;= end_time:
        del tmp[k]

""",
number=10000
))
print(timeit.timeit(setup="""import datetime
time_series_dict = {}
for i in range(10000):
    t =datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S:%f')
    time_series_dict[t] = i
    if i ==100:
        start_time = t
    if i == 900:
        end_time = t
""",
stmt="""
tmp = time_series_dict.copy()
result = {}
for k in list(tmp.keys()):
    if start_time &lt;= k &lt;= end_time:
        result[k] = tmp[k]
""",
number=10000
))
print(timeit.timeit(setup="""
import datetime
from bisect import bisect_left, bisect_right

time_series_dict = {}
for i in range(10000):
    t =datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S:%f')
    time_series_dict[t] = i
    if i ==100:
        start_time = t
    if i == 900:
        end_time = t

""",
stmt="""
tmp = time_series_dict.copy()
def trim_time_series_dict(tsd, start_date, end_date):
    ts = list(tsd)
    before = bisect_right(ts, start_date)  # insertion point at &gt; start_date
    after = bisect_left(ts, end_date)      # insertion point is &lt; end_date
    for i in range(before):                # up to == start_date
        del tsd[ts[i]]
    for i in range(after + 1, len(ts)):    # from &gt;= end_date onwards
        del tsd[ts[i]]

trim_time_series_dict(tmp, start_time, end_time)
""",
number=10000
))
</code></pre>
<p>test result</p>
<pre><code>12.558672609
9.662761111
7.990544049
</code></pre>
</div>
<span class="comment-copy">Maybe use a different data structure, like a binary search tree? Java has <code>TreeMap</code>, but AFAIK there's <a href="https://stackoverflow.com/q/17857496/1639625">nothing like that</a> in the Python standard library.</span>
<span class="comment-copy">With <code>list(tsd)</code> won't you have the same O(n) as with just iterating and checking all the keys? Granted: You have to do <i>much</i> fewer actual comparisons.</span>
<span class="comment-copy">@tobias_k: yes, <code>list(tsd)</code> will linearly scale with the size of the dictionary, but it is really worth avoiding adding the cost of O(n) comparisons here. It's constant costs that make the difference here.</span>
<span class="comment-copy">mine was about 32% slower ;)</span>
<span class="comment-copy">Please use the <code>timeit</code> module to do time trials, it takes care of repeating, picking the best clock to measure how long the operations take, and it also disables the GC to minimise, where possible, processes that can interfere with taking measurements.</span>
<span class="comment-copy">By not repeating your tests, you've made them highly susceptible to other processes on your computer taking CPU time away just at the wrong moment. You can't trust your timings at all now. I highly doubt that creating a <i>new</i> dictionary is 25% faster, for example. It is rather trivial to lose 470 microseconds somewhere else on your system, from time to time.</span>
<span class="comment-copy">“Teach others is the best way to learn". Thanks for your help I have update the code using <code>timeit</code> and the result is amazing. Did I do something wrong ?</span>
<span class="comment-copy">Yes, you manipulate <code>tmp</code> (your copy) directly still, then assign the empty <code>result</code> dict to <code>tmp</code>. <code>tmp[k] = tmp[k]</code> is 'fast' because no new space has to be allocated. You want to assign with <code>result[k] = tmp[k]</code> in the loop.</span>
<span class="comment-copy">The bisection test differs in that you added an extra function call into the mix, where the first two time trials do not make such function calls to achieve their work.</span>
