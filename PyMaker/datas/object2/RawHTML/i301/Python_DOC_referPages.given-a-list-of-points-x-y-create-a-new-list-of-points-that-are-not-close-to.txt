<div class="post-text" itemprop="text">
<p>I need help with this as I am a beginner:
Given the list of x,y points</p>
<pre><code>list=  [(788, 117), (788, 118), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329), (397, 330), (568, 338), (788, 117), (788, 118), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329), (397, 330), (568, 338), (418, 112), (418, 113), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329), (397, 330), (568, 338), (418, 112), (418, 113), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329), (397, 330), (568, 338), (418, 112)
</code></pre>
<p>I want to create a new list with points that are not close to each other.
Example (788, 117), (788, 118) are close to each other.</p>
<p>This the function i believe will help to find euclidian distance:</p>
<pre><code>def dist(p, q):
    "Return the Euclidean distance between points p and q."
    return int(math.hypot(p[0] - q[0], p[1] - q[1]))
</code></pre>
<p>Thank you in advance</p>
<p>Update:</p>
<p>this is what I tried out and it did not work how I would like:</p>
<pre><code>import math

list1 = [(788, 117), (788, 118), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329), (397, 330),
         (568, 338), (788, 117), (788, 118), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329),
         (397, 330), (568, 338), (418, 112), (418, 113), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284),
         (397, 329), (397, 330), (568, 338), (418, 112), (418, 113), (516, 164), (799, 171), (453, 225), (740, 284),
         (741, 284), (397, 329), (397, 330), (568, 338), (418, 112)]
list2 = []


def dist(p, q):
    "Return the Euclidean distance between points p and q."
    return int(math.hypot(p[0] - q[0], p[1] - q[1]))


while True:

    for i in list1:
        for j in list1:
            if i not in list2 and dist(i, j) &lt;= 5:
                list2.append(i)

    print("list1 ", list1)
    print("list2 ", list2)
</code></pre>
<p>Result:
with greater lists containing no duplicate points, it seems to become more of a challenge</p>
<pre><code>list1  [(788, 117), (788, 118), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329), (397, 330), (568, 338), (788, 117), (788, 118), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329), (397, 330), (568, 338), (418, 112), (418, 113), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329), (397, 330), (568, 338), (418, 112), (418, 113), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329), (397, 330), (568, 338), (418, 112)]
list2  [(788, 117), (788, 118), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329), (397, 330), (568, 338), (418, 112), (418, 113)]
</code></pre>
<p>The list is constantly being updated, that's why I have a while loop
What am I doing wrong here</p>
<p>Update:</p>
<pre><code>points =  [(336, 14), (335, 15), (336, 15), (337, 15), (524, 15), (525, 15), (526, 15), (335, 16), (336, 16), (337, 16),
           (525, 16), (526, 16), (336, 17), (706, 19), (705, 20), (706, 20), (707, 20), (705, 21), (706, 21), (707, 21),
           (706, 22), (434, 66), (433, 67), (434, 67), (435, 67), (433, 68), (434, 68), (435, 68), (717, 73), (718, 73),
           (716, 74), (717, 74), (718, 74), (717, 75), (718, 75), (370, 127), (371, 127), (372, 127), (370, 128),
           (371, 128), (372, 128), (371, 129), (600, 129), (601, 129), (602, 129), (601, 130), (602, 130), (485, 140),
           (486, 140), (390, 174), (391, 174), (392, 174), (390, 175), (391, 175), (392, 175), (658, 186), (659, 186),
           (658, 187), (659, 187), (660, 187), (658, 188), (659, 188), (660, 188), (315, 231), (314, 232), (315, 232),
           (316, 232), (314, 233), (315, 233), (316, 233), (485, 240), (486, 240), (487, 240), (485, 241), (486, 241),
           (487, 241), (485, 242), (486, 242), (665, 250), (666, 250), (645, 339), (646, 339), (593, 384), (594, 384),
           (595, 384), (596, 384), (593, 385), (594, 385), (595, 385), (710, 386), (711, 386), (709, 387), (710, 387),
           (711, 387), (712, 387), (709, 388), (710, 388), (711, 388), (712, 388)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> to find all possible point pairs and a list comprehension to eliminate the pairs that are too close. For example:</p>
<pre><code>import itertools
min_distance = 1
my_list =  [(788, 117), (788, 118), (516, 164), (799, 171), ...]
print([pair for pair in itertools.combinations(my_list, 2) if dist(*pair) &gt; min_distance])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To make this as efficient as possible, you should short circuit the combination generation using a set of points that are known to be excluded as you go through them. You could also use the square of the distance as a criteria so that you avoid square root calculations.</p>
<p>In you sample list of points, I noticed that you have a lot of duplications. This means that every point that is repeated will be excluded because it is at a distance of zero from another point. Note that this is an issue with both your data and and your algorithm.  Your algorithm will check the distance between each point and itself (resulting in zero) so all points will be excluded no matter what.  Your second for-loop only needs to match <em>j</em> points that are after the <em>i</em> point in the list and should exclude both <em>i</em> and <em>j</em> if they are too close to each other. </p>
<p>Assuming that your requirement is for <em>distinct</em> points that are not close to each other, here's an example of how you could do it:</p>
<pre><code>points =  [(788, 117), (788, 118), (516, 164), (799, 171), (453, 225), (740, 284), (741, 284), (397, 329), (397, 330), (568, 338)]
minimumDistance = 5

from itertools import combinations
tooClose = set()
minDistance2 = minimumDistance * minimumDistance
for point,otherPoint in combinations(list(set(points)),2):
    if point in tooClose and otherPoint in tooClose : continue
    dx,dy = (point[0]-otherPoint[0]), (point[1]-otherPoint[1])
    if (dx*dx+dy*dy) &lt;= minDistance2:
        tooClose.add(point)
        tooClose.add(otherPoint)
result = [point for point in points if point not in tooClose]
print(result)
</code></pre>
</div>
<span class="comment-copy">Where are you stuck? Does your euclidian distance function work as you expected to produce your desired output?</span>
<span class="comment-copy">What is your expected result in this case? We can't help you if we don't understand what you want. What is the threshold for "close"? Do you just want the new list to contain points from the old list that aren't "close" to each other? If so, which point(s) should be removed from pairs (or bigger groups) of points that are "close"?</span>
<span class="comment-copy">for now, my brain can't comprehend it, but it works</span>
<span class="comment-copy">Note that this gives a list of points that are at a distance of at least 5 from any other points.  Your requirement statement could also be read to mean a set of points that are at that minimum distance from each other AFTER excluding some other points.  That would be a graph analysis known as "maximum clique" which is an NP-Complete problem.  Contrary to the above solution, that problem would take an exponential time to solve as you add more points.</span>
