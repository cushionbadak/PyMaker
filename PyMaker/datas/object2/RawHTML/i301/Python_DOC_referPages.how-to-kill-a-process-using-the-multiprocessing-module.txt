<div class="post-text" itemprop="text">
<p>I have a process that is essentially just an infinite loop and I have a second process that is a timer. How can I kill the loop process once the timer is done?</p>
<pre><code>def action():
  x = 0
  while True:
      if x &lt; 1000000:
          x = x + 1
      else:
          x = 0

def timer(time):
  time.sleep(time)
  exit()    

loop_process = multiprocessing.Process(target=action)
loop_process.start()
timer_process = multiprocessing.Process(target=timer, args=(time,))
timer_process.start()
</code></pre>
<p>I want the python script to end once the timer is done.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do it by using a <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">sharing state between the processes</a> and creating a flag value that all the concurrent processes can access (although this may be somewhat inefficient). </p>
<p>Here's what I'm suggesting:</p>
<pre><code>import multiprocessing as mp
import time

def action(run_flag):
    x = 0
    while run_flag.value:
        if x &lt; 1000000:
            x = x + 1
        else:
            x = 0

    print('action() terminating')


def timer(run_flag, secs):
    time.sleep(secs)
    run_flag.value = False


if __name__ == '__main__':

    run_flag = mp.Value('I', True)

    loop_process = mp.Process(target=action, args=(run_flag,))
    loop_process.start()

    timer_process = mp.Process(target=timer, args=(run_flag, 2.0))
    timer_process.start()

    loop_process.join()
    timer_process.join()

    print('done')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple return statement after <code>else</code> in <code>action()</code> would work perfectly. Moreover, you had an error in your <code>timer</code> function. Your argument had the same name as inbuilt library time.</p>
<pre><code>def action():
   x = 0
   while True:
      if x &lt; 1000000:
         x = x + 1
      else:
         x = 0
         return # To exit else it will always revolve in infinite loop

def timer(times):
   time.sleep(times)
   exit()    

loop_process = multiprocessing.Process(target=action)
loop_process.start()
timer_process = multiprocessing.Process(target=timer(10))
timer_process.start()
</code></pre>
<p><em>Hope this answers your question!!!</em></p>
</div>
<div class="post-text" itemprop="text">
<p>I think you don't need to make a second process just for a timer.</p>
<h2>Graceful Timeout</h2>
<p>In case you need clean up before exit in your <code>action</code> process, you can use a <code>Timer</code>-thread and let the while-loop check if it is still alive. This allows your worker process to exit gracefully, but you'll have to pay with reduced performance
because the repeated method call takes some time. Doesn't have to be an issue if it' s not a tight loop, though.</p>
<pre><code>from multiprocessing import Process
from datetime import datetime
from threading import Timer


def action(runtime, x=0):
    timer = Timer(runtime, lambda: None)  # just returns None on timeout
    timer.start()
    while timer.is_alive():
        if x &lt; 1_000_000_000:
            x += 1
        else:
            x = 0

if __name__ == '__main__':

    RUNTIME = 1

    p = Process(target=action, args=(RUNTIME,))
    p.start()
    print(f'{datetime.now()} {p.name} started')
    p.join()
    print(f'{datetime.now()} {p.name} ended')
</code></pre>
<p>Example Output:</p>
<pre class="lang-none prettyprint-override"><code>2019-02-28 19:18:54.731207 Process-1 started
2019-02-28 19:18:55.738308 Process-1 ended
</code></pre>
<hr/>
<h2>Termination on Timeout</h2>
<p>If you don't have the need for a <em>clean</em> shut down (you are not using shared queues, working with DBs etc.), you can let the parent process <code>terminate()</code> the worker-process after your specified time. </p>
<blockquote>
<p><strong>terminate()</strong></p>
<p>Terminate the process. On Unix this is done using the SIGTERM signal; on Windows TerminateProcess() is used. Note that exit handlers and finally clauses, etc., will not be executed.</p>
<p>Note that descendant processes of the process will not be terminated â€“ they will simply become orphaned.</p>
<blockquote>
<p>Warning If this method is used when the associated process is using a pipe or queue then the pipe or queue is liable to become corrupted and may become unusable by other process. Similarly, if the process has acquired a lock or semaphore etc. then terminating it is liable to cause other processes to deadlock. <a href="https://docs.python.org/3.7/library/multiprocessing.html#multiprocessing.Process.terminate" rel="nofollow noreferrer">docs</a></p>
</blockquote>
</blockquote>
<p>If you don't have anything to do in the parent you can simply <code>.join(timeout)</code> the worker-process and <code>.terminate()</code> afterwards.</p>
<pre><code>from multiprocessing import Process
from datetime import datetime

def action(x=0):
    while True:
        if x &lt; 1_000_000_000:
            x += 1
        else:
            x = 0

if __name__ == '__main__':

    RUNTIME = 1

    p = Process(target=action)
    p.start()
    print(f'{datetime.now()} {p.name} started')
    p.join(RUNTIME)
    p.terminate()
    print(f'{datetime.now()} {p.name} terminated')
</code></pre>
<p>Example Output:</p>
<pre class="lang-none prettyprint-override"><code>2019-02-28 19:22:43.705596 Process-1 started
2019-02-28 19:22:44.709255 Process-1 terminated
</code></pre>
<hr/>
<p>In case you want to use <code>terminate()</code>, but need your parent unblocked you could also use a <code>Timer</code>-thread within the parent for that.</p>
<pre><code>from multiprocessing import Process
from datetime import datetime
from threading import Timer

def action(x=0):
    while True:
        if x &lt; 1_000_000_000:
            x += 1
        else:
            x = 0


def timeout(process, timeout):
    timer = Timer(timeout, process.terminate)
    timer.start()


if __name__ == '__main__':

    RUNTIME = 1

    p = Process(target=action)
    p.start()
    print(f'{datetime.now()} {p.name} started')
    timeout(p, RUNTIME)
    p.join()
    print(f'{datetime.now()} {p.name} terminated')
</code></pre>
<p>Example Output:</p>
<pre class="lang-none prettyprint-override"><code>2019-02-28 19:23:45.776951 Process-1 started
2019-02-28 19:23:46.778840 Process-1 terminated
</code></pre>
</div>
<span class="comment-copy">This solution worked for me. Thank you.</span>
<span class="comment-copy">coder44586: Glad to hear that...you're welcome. There might be less overhead by using a <code>Threading.Timer</code> instead of doing the timing is a separate process.</span>
