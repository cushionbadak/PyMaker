<div class="post-text" itemprop="text">
<p>I have a single dataframe A with several columns and I would like to sum all those columns "with themselves" to get a dataframe B.</p>
<pre><code>A = [col1 col2 col3 
       0    1    2
       1    1    0
      -1    0    1]
</code></pre>
<p>and B should look like:</p>
<pre><code>B = [col1+col2  col1+col3  col2+col3
         1          2           3
         2          1           1
        -1          0           1]
</code></pre>
<p>Basically, the philosophy behind this operation is exactly what is embedded in the itertools.product() function, that yields a cartesian product.</p>
<p>itertools.product('ABCD', 'xy') --&gt; Ax Ay Bx By Cx Cy Dx Dy</p>
<p>I just need to apply the same principle and get :<br/>
function_smg('ABCD', 'xy') --&gt; A+x A+y B+x B+y C+x C+y D+x D+y</p>
<p>My dataframe is huge so I can't afford for loops and I need an iterator or a generator. 
If there's no function that does the trick, how can I build a generator to do so?</p>
<p>Thanks a lot</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's one approach. You can start by getting all the length 2 combinations from the existing columns using <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a>:</p>
<pre><code>from itertools import combinations
c = combinations(df.T.values.tolist(), 2)
# [([0, 1, -1], [1, 1, 0]), ([0, 1, -1], [2, 0, 1]), ([1, 1, 0], [2, 0, 1])]
</code></pre>
<p>And then add the values in each tuples zipped together with:</p>
<pre><code>from itertools import starmap
from operator import add

l = [list(starmap(add,zip(i,j))) for i,j in c]
pd.DataFrame(l, index=df.columns).T

    col1  col2  col3
0     1     2     3
1     2     1     1
2    -1     0     1
</code></pre>
<hr/>
<p>Or if <code>numpy</code> is also an option:</p>
<pre><code>import numpy as np
c = list(combinations(df.T.values.tolist(), 2))
pd.DataFrame(np.array(c).sum(1), index=df.columns).T

    col1  col2  col3
0     1     2     3
1     2     1     1
2    -1     0     1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's actually something more precise than an itertools product for this problem. Try <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">itertools combinations</a></p>
<pre><code>import pandas as pd
from itertools import combinations
A = pd.DataFrame({"col1": [0, 1, -1],
              "col2": [1, 1, 0],
              "col3": [2, 0, 1]})

B = pd.DataFrame() #Create an empty dataframe first
for col1, col2 in combinations(A.columns, 2):
    B[f"{col1}+{col2}"] = A[col1] + A[col2] #Create columns one by one.
    #B["{}+{}".format(col1, col2)] = A[col1] + A[col2] (Before python 3.6)

print(B)
#Output:
   col1+col2  col1+col3  col2+col3
0          1          2          3
1          2          1          1
2         -1          0          1
</code></pre>
</div>
<span class="comment-copy"><code>itertools.product('ABCD', 'xy')</code> yields <code>('A', 'x'), ('A', 'y'), ... ('D', 'y')</code>, so when iterating over it you get a tuple which you can pass to <code>sum()</code> or a similar appropriate function like <code>str.join()</code> or <code>math.fsum()</code>. Your generator then looks like <code>(sum(p) for p in itertools.product('ABCD', 'xy'))</code></span>
<span class="comment-copy">Thanks yatu, I think that might be very helpful! good vectorization problem :)</span>
<span class="comment-copy">check the numpy solution for a better performance  @cyrilmuay</span>
