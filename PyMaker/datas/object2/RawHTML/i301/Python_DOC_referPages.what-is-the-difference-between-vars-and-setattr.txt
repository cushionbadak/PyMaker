<div class="post-text" itemprop="text">
<blockquote>
<p>After failing to use vars to change db.Model(flask-sqlalchemy) value I solved it by using <code>setattr</code> instead, but after reading doc still don't get the difference between <code>vars</code> and <code>setattr</code>. </p>
</blockquote>
<p>Here is what I have tried</p>
<h2>Failed in <code>vars</code></h2>
<h3>Code</h3>
<pre><code>from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

def set_option_parameters(var, option_keys, options):
    for option_key in options:
        if option_key in option_keys and options[option_key] is not None:
            vars(var)[option_key] = options[option_key]
            # setattr(var, option_key, options[option_key])

class Application(db.Model):
    id = db.Column(db.BigInteger(), primary_key=True, autoincrement=True)
    name = db.Column(db.VARCHAR(20), nullable=False)
    ...
    def __init__(self, options):
        option_keys = set(["name"])
        set_option_parameters(self, option_keys, options)

    def modification(self, options):
        modifiable = set(["name"])
        set_option_parameters(self, modifiable, options)
</code></pre>
<p><code>vars(var)[option_key] = options[option_key]</code> <em>works fine in initing a <code>Application</code> object</em> , but failed in <code>modification</code>(<code>name</code> didn't change).</p>
<h3>Log/Test</h3>
<p>And I tried to print the <code>application.__dict__</code> before <code>db.session.commit()</code>, it did be modified!</p>
<pre><code>application = Application.query.filter_by(id=args["id"]).first()
# args["name"] is not None
app.logger.info(f"Before: {application.__dict__}")
application.modification(args)
app.logger.info(f"After: {application.__dict__}")
db.session.commit()
</code></pre>
<p>output</p>
<pre><code>[2019-02-27 11:22:59,209] INFO in equipmentbaseapplicationhandler: Before:{'_sa_instance_state': &lt;sqlalchemy.orm.state.InstanceState object at 0x7f718ac2b588&gt;, 'id': 9, 'name': 'old_name'}
[2019-02-27 11:22:59,209] INFO in equipmentbaseapplicationhandler: After:{'_sa_instance_state': &lt;sqlalchemy.orm.state.InstanceState object at 0x7f718ac2b588&gt;, 'id': 9, 'name': 'new_name'}
</code></pre>
<p><strong>BUT</strong> When I checked in mysql, it did not work</p>
<h2>Successed in <code>setattr</code></h2>
<p>Then I changed to <code>setattr(var, option_key, options[option_key])</code> in function <code>set_option_parameters</code>.</p>
<p>it works good in both init and modification, and the output of <code>application.__dict__</code> is the same!</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow noreferrer">From the docs</a> for <code>vars</code>:</p>
<blockquote>
<p>Objects such as modules and instances have an updateable <strong>dict</strong> attribute; however, other objects may have write restrictions on their <strong>dict</strong> attributes (for example, classes use a types.MappingProxyType to prevent direct dictionary updates).</p>
</blockquote>
<p>Looking through the SQLAlchemy source code (for instance, <a href="https://github.com/sqlalchemy/sqlalchemy/blob/c9a31767e0d3a15ab45101aca21924cb4434c7b9/lib/sqlalchemy/sql/base.py#L326" rel="nofollow noreferrer">here</a>), it is a common pattern to return a copy of <code>some_model.__dict__</code> when accessed, rather than returning the <code>__dict__</code> itself. So you are likely updating a copy rather than the original. Otherwise, it's possible that the dict is getting overwritten by the attributes themselves, even if the dict changes.</p>
<p><code>setattrs</code> is the correct pattern, and is more explicit.</p>
</div>
<span class="comment-copy">Please see <a href="https://stackoverflow.com/questions/17013965/sqlalchemy-commit-changes-to-object-modified-through-dict" title="sqlalchemy commit changes to object modified through dict">stackoverflow.com/questions/17013965/â€¦</a></span>
