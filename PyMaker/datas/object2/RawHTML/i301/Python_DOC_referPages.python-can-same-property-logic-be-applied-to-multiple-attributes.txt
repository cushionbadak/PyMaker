<div class="post-text" itemprop="text">
<p>Is there a way to apply the same property logic to a set of attributes in a class? For example, I want to apply the same <code>@attr1.setter</code> decorator to <code>attr2</code>, <code>attr3</code>, and <code>attr4</code> without having to define the property for each attribute.</p>
<pre><code>class Sample:
    def __init__(self):
        self.attr1 = None
        self.attr2 = None
        self.attr3 = None
        self.attr4 = None

    @property
    def attr1(self):
        return self.__attr1

    @attr1.setter
    def attr1(self, val):
        if val &lt; 0:
            self.__attr1 = 0
        else:
            self.__attr1 = val
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just create your own descriptor for this:</p>
<pre><code>class MyDescriptor:
    def __set_name__(self, owner, name):
        self.name = f'_{name}'
    def __get__(self, instance, owner):
        return getattr(instance, self.name)
    def __set__(self, instance, val):
        if val is None:
            setattr(instance, self.name, None)
        elif val &lt; 0:
            setattr(instance, self.name, 0)
        else:
            setattr(instance, self.name, val)

class Sample:
    attr1 = MyDescriptor()
    attr2 = MyDescriptor()
    attr3 = MyDescriptor()
    attr4 = MyDescriptor()
    def __init__(self):
        self.attr1 = None
        self.attr2 = None
        self.attr3 = None
        self.attr4 = None
</code></pre>
<p>Now, in action:</p>
<pre><code>In [3]: s = Sample()

In [4]: s.attr1 = -99

In [5]: s.attr1
Out[5]: 0

In [6]: s.attr2

In [7]: s.attr2 = 10

In [8]: s.attr2
Out[8]: 10

In [9]: s.attr2 = -1

In [10]: s.attr2
Out[10]: 0
</code></pre>
<p>See the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">Descriptor HOWTO</a> and some more relevant <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">documentation</a></p>
<p>Note, I incorporated the possibility of <code>None</code> in your setter logic (your code would have raised a <code>TypeError</code> on initialization of an instance, because the setter checks if <code>None &lt; 0</code>). Also note, you probably don't want to be using double-underscore name-mangling (<strong>which doesn't mean private</strong>), so I used the <em>conventional</em> single-underscore to denote a variable not part of the public api. Using double-underscore name-mangling complicates things here.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could override the <code>__getattr__</code> and <code>__setattr__</code> to behave the way you want them. This way you don't need to define any private variables nor initialize any of the member variables either. </p>
<pre><code>class Sample:
    def __getattr__(self, attr):
        return self.__dict__.get(attr)

    def __setattr__(self, attr, val):
        if val is not None and val &lt; 0:
            self.__dict__[attr] = 0
        else:
            self.__dict__[attr] = val

s = Sample()

print(s.attr1) # None
s.attr1 = 10
print(s.attr1) # 10
s.attr1 = -10
print(s.attr1) # 0
s.attr1 = None
print(s.attr1) # None
</code></pre>
</div>
<span class="comment-copy">If I define attr1/2/3/4 as class attributes won't they be shared between class instances? i.e. <code>attr1 = MyDescriptor()</code></span>
<span class="comment-copy">@tyleax that's <b>exactly what <code>property</code> is doing</b>. That is, the <i>property object</i> belongs to the <i>class</i>. So <code>@property def blah()....</code> is equivalent to <code>def blah() ... blah = property(blah)</code>. Descriptors (which <code>property</code> is just a handy convenient one) always belong to the class.</span>
