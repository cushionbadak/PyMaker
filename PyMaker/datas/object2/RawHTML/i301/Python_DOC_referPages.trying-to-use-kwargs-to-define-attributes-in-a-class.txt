<div class="post-text" itemprop="text">
<p>So I have a class that defines characters and its attributes and it goes like this:</p>
<pre><code>class character():

    def __init__(self, health, dodge, damage, critAdd):

        self.health=health
        self.dodge=dodge
        self.damage=damage
        self.critAdd=critAdd
</code></pre>
<p>and when I create an instance as this:</p>
<pre><code>knight=character(150, 5, 40, 1.5)
</code></pre>
<p>it works perfectly. But what I´m trying to create is a way of creating it with key values, like this:</p>
<pre><code>knight=character(health=150, dodge=5, damage=40, critAdd=1.5)
</code></pre>
<p>So i tried to write the <code>__init__</code> like this, using <em><code>**kwargs</code></em>:</p>
<pre><code>def __init__(self, **kwargs):

    self.health=health
    self.dodge=dodge
    self.damage=damage
    self.critAdd=critAdd
</code></pre>
<p>It says:</p>
<pre><code>NameError: name 'health' is not defined
</code></pre>
<p>What am I doing wrong? I´m really new to programming so I can´t figure it out.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>kwargs</code> is just a mapping; it doesn't magically create local variables for your function. You need to index the python dictionary with the desired key.</p>
<pre><code>def __init__(self, **kwargs):
    self.health = kwargs['health']
    self.dodge = kwargs['dodge']
    self.damage = kwargs['damage']
    self.critAdd = kwargs['critAdd']
</code></pre>
<p>A <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">dataclass</a> simplifies this:</p>
<pre><code>from dataclasses import dataclass

@dataclass
class Character:
    health: int
    dodge: int
    damage: int
    critAdd: float
</code></pre>
<p>This generates your original <code>__init__</code> automatically.</p>
<p>If you need to do additional work in <code>__init__</code> after adding the dataclass decorator you can define <code>__post_init__</code> which a dataclass will call after <code>__init__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You do not need to define your method with <code>**kwargs</code> to support passing arguments by keyword. Your original version of <code>__init__</code> already supports the <code>character(health=150, dodge=5, damage=40, critAdd=1.5)</code> syntax you want to use. Your original version is <em>better</em> than using <code>**kwargs</code>, because it ensures that exactly the right parameters were passed, rejecting things like <code>helth=150</code> typos.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use <code>get()</code>, for example:</p>
<pre><code>class Example():
    def __init__(self, **kwargs):

  self.health= kwargs.get('health', 10) # The first argument is the variable you want
                                        # The second is the default in case this kwarg do not exist


a = Example(health=50)
b = Example()

print(a.health)
print(b.health)

</code></pre>
</div>
<span class="comment-copy">What's your reason for wanting to use **kwargs?  Your initial version is <i>better</i>, and will still support using keywords / arbitrary order.</span>
<span class="comment-copy">health is not defined. You need to access health in kwargs, which is a dictionary.@wim, at what number of arguments does the original version cease to be better?</span>
<span class="comment-copy">@wim I just thought it would be more organized. I guess I could keep it like that but if I wanted to use **kwargs (so I can understand how it works, kinda confusing for me), could I do it?</span>
<span class="comment-copy">If you need to do additional work in the <code>__init__</code> after adding the <code>dataclass</code> decorator do you continue defining the <code>__init__</code> method?</span>
<span class="comment-copy">You can define <code>__post_init__</code>, which a dataclass will call after <code>__init__</code>.</span>
