<div class="post-text" itemprop="text">
<p>i have python dictionary like this:</p>
<pre><code>bla = {
    "ab_1A": str(round(kit['a8'].value,2)),
    "bc_2A": str(round(kit['a14'].value,2)),
    "ca3_A": str(round(kit['a35'].value,2)),
    "4A_1": str(round(kit['a51'].value,2)),
    ....
}
</code></pre>
<p>where I read cells from .xls file. Is there any good idea to check if eg. a8 exist and there is no NoneType and if so, put 0? Thanks for any respo. 'Kit' - that's the name of spreadsheet</p>
</div>
<div class="post-text" itemprop="text">
<p>Have a look at <a href="https://docs.python.org/3/library/collections.html?highlight=defaultdict#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> - it let's you use a dictionary like normal, but any attempt to access a key that isn't in the dictionary causes that key to be created with a default value you specify.</p>
<p>You could make the default be a float, which will default to 0.0 because that's what floats do, or you could create a "magic" value and use that for your default:</p>
<pre><code>kit = collections.defaultdict(float)

kit = collections.defaultdict(return_some_magic_value)
</code></pre>
<p>If you're actually trying to implement a spreadsheet, though, I'd suggest that you think about how you'll handle cycles of cells referencing other cells. It's not a totally trivial problem, and the answer to that question will inform how you store your cells.</p>
<p>The most basic solution would be to store everything unresolved, then iterate through the cells doing a "depth-first" evaluation: if a cell references another cell, go resolve that one then come back. You'd mark the cells resolved as you did them, so that your iteration and your recursion didn't collide. An easy approach might be to evaluate them into a separate dictionary. You might even use a <code>defaultdict</code> where the factory function actually did the recursive evaluation for you!</p>
</div>
<div class="post-text" itemprop="text">
<p>One primitive way to do it:</p>
<pre><code>def default_cell(xl_obj, cell, default_val):
    try: 
        return str(round(xl_obj[cell].value,2))
    except: #best if you can narrow down the exception...
        return default_val

kit = {
    "1A": default_cell('a8', "0.00"),
    "2A": default_cell('a9', "0.00"),
    ....
}
</code></pre>
<p>It is <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">easier to ask for forgiveness than permission</a> in Python.</p>
</div>
<span class="comment-copy">more information is needed about your logic.. what the the relationship between <code>kit['1A']</code> and <code>kit['a8']</code>,  <code>kit['2A']</code> and <code>kit['a9']</code>, and so on</span>
<span class="comment-copy">I am sure there is a way but first put MVCE here.</span>
<span class="comment-copy">It's not clear how the <code>kit</code> self referencing is supposed to work in your code.  Please provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">Sorry, my mistakes. There is no relationship between 1A and a8. 1A, 2A... is random name and the cells are not structured.</span>
