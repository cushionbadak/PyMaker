<div class="post-text" itemprop="text">
<p>Unfortunately I was not able to be more specific with my title, but an example should make my problem clear. I have two lists f and a and if f[i] is equal to f[i-1]. I would like to have a new entry in f which is equal to f[i] and f[i-1] (obviously) and overwrites both of them. In a I would like to have to a_new = a[i] + a[i-1] replacing a[i] and a[i-1].</p>
<pre><code>f = [10, 25, 50, 50, 75, 100, 1000, 1000, 1100, 1100]
a = [1, 3, 2, 4, 5, 3, 10, 15, 5, 5]
</code></pre>
<p>My desired output is:</p>
<pre><code>f = [10, 25, 50, 75, 100, 1000, 1100]
a = [1, 3, 6, 5, 3, 25, 10]
</code></pre>
<p>I believe that some sort of list comprehension would be the optimal approach, but I couldn't figure it out yet. I doesn't need to be a list comprehension though, I am happy as long as there is some solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can <code>zip</code> the lists together, use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> to group the pairs by the <code>f</code> values, then sum the <code>a</code> values for each group.  Then you just need to unzip them back into separate lists</p>
<pre><code>from itertools import groupby
from operator import itemgetter

groups = groupby(zip(f, a), key=itemgetter(0))
f_a_generator = ((k, sum(map(itemgetter(1), pairs))) for k, pairs in groups)
f1, a1 = zip(*f_a_generator)  # map(list, ...) If you need them as lists

print(f1, a1, sep='\n')
# (10, 25, 50, 75, 100, 1000, 1100)
# (1, 3, 6, 5, 3, 25, 10)
</code></pre>
<p>To answer your question in the comments, you can change the line </p>
<pre><code>sum(map(itemgetter(1), pairs)))
</code></pre>
<p>to call some function other than <code>sum</code>:</p>
<pre><code>def logarithmic_sum(values):
    return 10*np.log10(sum((10**(val/10)) for val in values))

groups = groupby(zip(f, a), key=itemgetter(0))
f_a_generator = ((k, logarithmic_sum(map(itemgetter(1), pairs))) for k, pairs in groups)
f1, a1 = zip(*f_a_generator)

print(f1, a1, sep='\n')
# (10, 25, 50, 75, 100, 1000, 1100)
# (1.0000000000000002, 2.999999999999999, 6.124426027943397, 5.0, 2.999999999999999, 16.193310480660944, 8.010299956639813)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For first array case:</p>
<pre><code>for i in range(1, len(f)-2):
    if f[i] == f[i-1]:
        del f[i]

print(f)
</code></pre>
</div>
<span class="comment-copy"><code>I would like my last entry in f to be f[i]</code> please can you better explain what you mean?</span>
<span class="comment-copy">Tried it @yatu.</span>
<span class="comment-copy">I would appreciate any solution @meowgoesthedog.</span>
<span class="comment-copy">I didn't ask this originally because I didn't think it would be a problem: How could I implement logarithmic addition instead of the simple sum? So instead of a_new = a[i] + a[i-1] I would actually like to do the following: a_new = 10*np.log10(10** (a[i]/10) + 10** (a[i-1]/10))</span>
<span class="comment-copy">@Larzeb I've edited my answer.  Basically, you need to write a function that performs that calculation, and then call it instead of <code>sum</code></span>
