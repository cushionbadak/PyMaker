<div class="post-text" itemprop="text">
<p>I'm learning how to use <code>Enum</code> classes in Python, and have found that whenever I need to access the actual value of the enum, I need to append the <code>.value</code> property:</p>
<pre><code>from enum import Enum
class Pets(Enum):
    DOG = "Fido"
    CAT = "Kitty"

Pets.DOG # yields Pets.DOG
Pets.DOG.value # yields Fido
</code></pre>
<p>As an exercise, I'm trying configure my <code>Enum</code> class so that I do not need to continually access that <code>value</code> property. <strong>My desired behavior is that when I call <code>Pets.DOG</code>, I get <code>Fido</code> as my value.</strong></p>
<p>I'm tried to implement this with <code>__getattr_(cls, item)</code>:</p>
<pre><code>class Pets(Enum):

    def __getattr__(self, item):
        print(f"__getattr__ called with {item}")
        return getattr(self, item).value

    DOG = "Fido"
    CAT = "Kitty"


if __name__ == "__main__":

    pets = Pets()
    pets.DOG
</code></pre>
<p>However, I receive a <code>RecursionError: maximum recursion depth exceeded while calling a Python object</code>, and <code>item</code> is a string value of <code>_value_</code>. I'm not quite understanding why this behavior is happening - is this built in Python behavior, or because I am using a special class <code>Enum</code>?</p>
<p>I did take a look at a similar SO post, but the solutions there were to use another module (<code>inspect</code>), or access the <code>__dict__</code> or <code>dir()</code> and parse it yourself with a combination of conditionals or regex. Is there a better way to access the underlying <code>Enum</code>'s value?</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use the enum class if you want to map attributes to strings. The whole <em>point</em> of the <code>enum</code> module is to produce a set of singleton objects that represent an enumeration, not strings. From the module documentation:</p>
<blockquote>
<p>An enumeration is a set of symbolic names (members) bound to <strong>unique, constant values</strong>. Within an enumeration, <strong>the members can be compared by identity</strong>, and the enumeration itself can be iterated over.)</p>
</blockquote>
<p><em>Bold emphasis mine.</em> Strings are not unique, constant values (I can create more <code>"Fido"</code> strings at will) and are not designed to be compared by identity (even though <a href="https://stackoverflow.com/questions/24245324/about-the-changing-id-of-an-immutable-string/24245514#24245514">sometimes, for a subset of strings, you can</a>).</p>
<p>Just define your own class with attributes that are strings, directly:</p>
<pre><code>class Pets:
    DOG = "Fido"
    CAT = "Kitty"
</code></pre>
<p>Your infinite recursion error is caused by a misunderstanding on your part as to what that method is used for. Like <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer">all special methods</a>, <code>object.attr</code> looks up <code>__getattr__</code> on the <em>object type</em>, meaning here that your method applies to <em>instances</em> of your <code>Enum</code> subclass, the <code>DOG</code> and <code>CAT</code> attributes here, not to the class itself, and interferes with the <code>EnumMeta</code> metaclass trying to test for the <code>_value_</code> attibute, which is handled by your <code>__getattr__</code> method with <code>self</code> being the newly-minted <code>Pets.DOG</code> instance, and <code>item</code> set to <code>'_value_'</code>, which then calls <code>getattr(Pets.DOG, '_value_')</code>, which calls <code>__getattr__</code>, etc.</p>
<p>For your approach to work, you'd have to subclass <code>EnumMeta</code> and implement <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code></a> on that subclass (<code>__getattr__</code> is only ever called for <em>missing</em> attributes). However, take into account that <code>__getattribute__</code> is used for <em>all</em> attribute access, so you have to take care to check for instances of the current class first:</p>
<pre><code>class EnumDirectValueMeta(EnumMeta):
    def __getattribute__(cls, name):
        value = super().__getattribute__(name)
        if isinstance(value, cls):
            value = value.value
        return value

class Pets(Enum, metaclass=EnumDirectValueMeta):
    DOG = "Fido"
    CAT = "Kitty"
</code></pre>
<p>at which point <code>Pets.DOG</code> produces <code>'Fido'</code>.</p>
</div>
<span class="comment-copy">The value is generally arbitrary. If you actually care about the value of the enum, then the odds are you aren't using enums properly in the first place.</span>
<span class="comment-copy">Could you elaborate further on how I am not using it properly?</span>
<span class="comment-copy">Because you're continually accessing the value; you should generally be doing that in relatively few places, right down at the lowest levels of abstraction, and using e.g. <code>Pets.DOG</code> elsewhere.</span>
<span class="comment-copy">Your code should just use the singleton <code>Pets.DOG</code>. If <code>Pets.DOG.value</code> has some data that matters, then you probably don't want an enumeration, actually - you'd want a namespace, or a dataclass, or something else.</span>
<span class="comment-copy">Got it, that makes sense. I guess that answers half my question. I’d still be curious to understand why I’m reach a max recursion error here.</span>
<span class="comment-copy">Thanks. This is painfully obvious now. Just for my own curiosity, how would I debug the recursive error? I know it's coming from <code>get_attr()</code> inside my <code>__get_attr__</code> call.</span>
<span class="comment-copy">@YuChen: because the <code>__getattr__</code> method applies to the enum instances. You'd have to create a custom <code>enum.EnumMeta</code> metaclass subclass to override attribute lookup behaviour on the <i>class</i>. Because you defined the method, it interferes with the <code>EnumMeta</code> class <code>__new__</code> implementation, which tries to access the <code>_value_</code> attribute on the instances it creates, with <code>hasattr(enum_member, '_value_')</code>; <code>__getattr__(Pets.DOG, '_value_')</code> calls <code>getattr(self, '_value_')</code>, which calls <code>getattr(self, '_value_')</code>, ad infinitum.</span>
