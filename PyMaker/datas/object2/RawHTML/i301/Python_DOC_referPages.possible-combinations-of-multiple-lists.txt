<div class="post-text" itemprop="text">
<p>I have a set of variables in a list</p>
<pre><code>list = [ 'A', 'B', 'C']
</code></pre>
<p>I iteratively remove one variable from the list and append this to the original list in a list of lists, stopping when the list only has one item. For example, the output using the list above would be:</p>
<pre><code>list_of_var_lists = [
[['A', 'B', 'C'], ['A', 'B'], ['A']],
[['A', 'B', 'C'], ['A', 'B'], ['B']],
[['A', 'B', 'C'], ['A', 'C'], ['A']],
[['A', 'B', 'C'], ['A', 'C'], ['C']],
[['A', 'B', 'C'], ['B', 'C'], ['B']],
[['A', 'B', 'C'], ['B', 'C'], ['C']]
]
</code></pre>
<p>How would i do for a list of any size?</p>
<p>Many thanks, J</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution using <a href="https://docs.python.org/3.7/library/itertools.html#itertools.permutations" rel="nofollow noreferrer">itertools.permutations</a>. It is a generator rather than a massive lists of lists of lists, since the number of such sublists grows hyper-exponentially:</p>
<pre><code>import itertools

def list_unpacker(ls):
    for p in itertools.permutations(ls):
        sublists = []
        current_list = ls[:]
        sublists.append(current_list)
        for x in p[:-1]:
            current_list = [y for y in current_list if y != x]
            sublists.append(current_list)
        yield sublists

for lists in list_unpacker(['a','b','c']):
    print(lists)
</code></pre>
<p>Output:</p>
<pre><code>[['a', 'b', 'c'], ['b', 'c'], ['c']]
[['a', 'b', 'c'], ['b', 'c'], ['b']]
[['a', 'b', 'c'], ['a', 'c'], ['c']]
[['a', 'b', 'c'], ['a', 'c'], ['a']]
[['a', 'b', 'c'], ['a', 'b'], ['b']]
[['a', 'b', 'c'], ['a', 'b'], ['a']]
</code></pre>
</div>
<span class="comment-copy">Try <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations()</code></a>.</span>
<span class="comment-copy">Awesome, Thank you.</span>
