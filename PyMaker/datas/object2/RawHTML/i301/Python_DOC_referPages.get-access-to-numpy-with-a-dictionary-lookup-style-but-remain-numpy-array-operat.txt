<div class="post-text" itemprop="text">
<p>I want to construct a class inheriting from the numpy.ndarray, so that it can do normal operations as a numpy array(+, -, *, /,...). The only thing I want to change is that the way we access the items in our Data. For example:</p>
<pre><code>import numpy as np
from PIL import Image
class Data(np.ndarray):
    """
    Something magical here 
    """

img = np.asarray(Image.open('lena.jpg'))
data = img.view(Data)
data['Red'] #equivalent to img[:,:,0]
normalized_data = data/255. #normalize the data 
</code></pre>
<p>Can anyone help me solve this? Thanks and kind regards</p>
</div>
<div class="post-text" itemprop="text">
<p>You are going to want to override the __getitem__ method. Here is another question which may provide some intuition: <a href="https://stackoverflow.com/questions/43627405/understanding-getitem-method">Understanding __getitem__ method</a>. </p>
<p>Link to the docs: <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#object.__getitem__</a></p>
<p>If you want to change you you set the values, you override __setitem__</p>
<p>An example:</p>
<pre><code>def __getitem__(self, key):
    """ Controls how values are 'gotten'. """
    if key == 'red':
        return self.data[:,:,0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you would be better off writing your class from scratch, rather than by extending <code>numpy.ndarray</code></p>
<p>My reasons:</p>
<ol>
<li>Since you will be working with non-numeric indices, you are probably going to restrict yourself to 1-dimensional structures. Which means you will be completely ignoring all the multi-dimensional capabilities of <code>numpy.ndarray</code>s.</li>
<li><code>numpy.ndarray</code> comes with some restrictions such as the fact that the elements must all be of uniform byte-size. Those restrictions may not suit you.</li>
</ol>
<p>Also, you you might want to take a look at <a href="https://docs.scipy.org/doc/numpy-1.15.0/user/basics.rec.html" rel="nofollow noreferrer">structured arrays of numpy</a>, as they can also be indexed with non-numeric indexes (well, in a certain limited sense, actually -- please go through the examples given there).</p>
<p>Just curious about your <strong>desired functionality and semantics</strong>: In numpy, if <code>x</code> and <code>y</code> are two 1d numpy arrays of the same length, you are allowed to compare them with <code>x == y</code>. On the other hand, if <code>data_1</code> and <code>data_2</code> are two of <strong>your</strong> arrays, having the same length of <code>3</code>, they might still be indexed differently. <code>data_1</code> might be indexed with the index values <code>'red'</code>, <code>'green'</code>, and <code>'blue'</code>, while <code>data_2</code> might be indexed with values <code>'high'</code>, <code>'medium'</code>, <code>'low'</code>. In both cases, the number of valid indices is <code>3</code>, so, in a sense, both <code>data_1</code> and <code>data_2</code> are of the same length of 3. But then, would you consider it valid to compare them with <code>data_1 == data_2</code>? What about the array of booleans resulting from the comparison? Would you index the boolean array with <code>'red'</code>, <code>'green'</code>, and <code>'blue'</code>, or with <code>'high'</code>, <code>'medium'</code>, <code>'low'</code>?</p>
</div>
<span class="comment-copy">For a start I'd just a write a function to do the named selection.  Latter it could be cast as a Class with its own <code>get_item</code> method.  Look at <code>np.lib.index_tricks</code> for examples.</span>
