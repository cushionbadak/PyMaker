<div class="post-text" itemprop="text">
<p>What exactly does the keyword <code>in</code> check for in python, generally? equality, identity, something else?</p>
<p>Example:</p>
<p>Suppose I have two classes X and Y with different <code>__eq__</code> operators</p>
<pre><code>class X:
  def __eq__(self,other):
    return False

class Y:
  def __eq__(self,other):
    return True
</code></pre>
<p>Now I can do</p>
<pre><code>a = X()
b = a
k = [a]
b in k # -&gt; True
</code></pre>
<p>This suggests a check for identity to me.<br/>
But I can also do</p>
<pre><code>c = Y()
d = Y()
c is d # -&gt; False
l = [d]
c in l # -&gt; True
</code></pre>
<p>which suggests a check for equality. The only theory I came up with is that it first checks for identity, and if this is not the case, then check for equality. Is that correct?</p>
</div>
<div class="post-text" itemprop="text">
<p>Checking containment on a <strong>list</strong> is equivalent to looking for identity or equality on each element.</p>
<p>From <a href="https://docs.python.org/3/reference/expressions.html#membership-test-operations" rel="nofollow noreferrer">the documentation</a>:</p>
<blockquote>
<p>For container types such as <strong>list, tuple, set, frozenset, dict, or collections.deque</strong>,
  the expression <code>x in y</code> is equivalent to <code>any(x is e or x == e for e in y)</code></p>
</blockquote>
<p>(With the caveat that the objects in a hash-based container, like a set, must have a hash implementation that is consistent with their definition of equality.)</p>
<p>For user-defined container types, the behaviour of <code>in</code> is determined by the <code>__contains__</code> method.</p>
</div>
<div class="post-text" itemprop="text">
<p>The true answer is that by itself, <code>in</code> doesn't do any test - it's up to the container (the object after <code>in</code> in your expression) implementation. <code>in</code> will actually invoke either <code>container.__contains__(obj)</code>  if it's defined, else <code>container.__getitem__(obj)</code>, and return the result. How the container implements the test (identity, equality, arcane algorithm based on the moon's phase and the captain's birthdate) is the container's concerns.</p>
</div>
<span class="comment-copy">Yes. It checks for identity and then equality.</span>
<span class="comment-copy">Your <code>==</code> would be entirely broken if <code>a is b</code> is <code>True</code> but <code>a == b</code> is <code>False</code>. Equality is, by definition, reflexive: <code>x == x</code> for all <code>x</code>.</span>
<span class="comment-copy">@chepner That's the schizophrenic object pattern…</span>
<span class="comment-copy">@chepner There are objects for which <code>x!=x</code>. E.g. <code>float('nan')</code> is not equal to itself.</span>
<span class="comment-copy"><code>in</code> itself uses <i>neither</i>; see <a href="https://docs.python.org/3/reference/expressions.html#membership-test-operations" rel="nofollow noreferrer">docs.python.org/3/reference/…</a>.</span>
<span class="comment-copy">Unless, of course, the container defines a <code>__contains__</code> method, e.g. for testing the hashcode first... which should also be the case for <code>set</code> etc., so that documentation can not really be accurate, right?</span>
<span class="comment-copy">or if it defines <code>__getitem__</code> FWIW.</span>
<span class="comment-copy">You can also have fun with Russell's Paradox by defining <code>__contains__ = lambda *args: True</code>.</span>
<span class="comment-copy">@khelwood you may want to update your answer to make clear that this extract only applies to some of the builtins containers...</span>
<span class="comment-copy">@brunodesthuilliers Does it not say already?</span>
<span class="comment-copy">You could  add "hashcode" as as example for another (actual) containment test.</span>
