<div class="post-text" itemprop="text">
<p>Is there a way in python to programmatically determine the width of the console? I mean the number of characters that fits in one line without wrapping, not the pixel width of the window.</p>
<p><b>Edit</b></p>
<p>Looking for a solution that works on Linux</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
rows, columns = os.popen('stty size', 'r').read().split()
</code></pre>
<p>uses the 'stty size' command which according to <a href="http://mail.python.org/pipermail/python-list/2000-May/033312.html" rel="noreferrer">a thread on the python mailing list</a> is reasonably universal on linux. It opens the 'stty size' command as a file, 'reads' from it, and uses a simple string split to separate the coordinates.</p>
<p>Unlike the os.environ["COLUMNS"] value (which I can't access in spite of using bash as my standard shell) the data will also be up-to-date whereas I believe the os.environ["COLUMNS"] value would only be valid for the time of the launch of the python interpreter (suppose the user resized the window since then).</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure why it is in the module <code>shutil</code>, but it landed there in Python 3.3, <a href="http://docs.python.org/3/library/shutil.html#querying-the-size-of-the-output-terminal" rel="noreferrer">Querying the size of the output terminal</a>:</p>
<pre><code>&gt;&gt;&gt; import shutil
&gt;&gt;&gt; shutil.get_terminal_size((80, 20))  # pass fallback
os.terminal_size(columns=87, lines=23)  # returns a named-tuple
</code></pre>
<p>A low-level implementation is in the os module.</p>
<p>A backport is now available for Python 3.2 and below: </p>
<ul>
<li><a href="https://pypi.python.org/pypi/backports.shutil_get_terminal_size" rel="noreferrer">https://pypi.python.org/pypi/backports.shutil_get_terminal_size</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>use</p>
<pre><code>import console
(width, height) = console.getTerminalSize()

print "Your terminal's width is: %d" % width
</code></pre>
<p><strong>EDIT</strong>: oh, I'm sorry. That's not a python standard lib one, here's the source of console.py (I don't know where it's from).</p>
<p>The module seems to work like that: It checks if <code>termcap</code> is available, when yes. It uses that; if no it checks whether the terminal supports a special <code>ioctl</code> call and that does not work, too, it checks for the environment variables some shells export for that.
This will probably work on UNIX only.</p>
<pre><code>def getTerminalSize():
    import os
    env = os.environ
    def ioctl_GWINSZ(fd):
        try:
            import fcntl, termios, struct, os
            cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ,
        '1234'))
        except:
            return
        return cr
    cr = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
    if not cr:
        try:
            fd = os.open(os.ctermid(), os.O_RDONLY)
            cr = ioctl_GWINSZ(fd)
            os.close(fd)
        except:
            pass
    if not cr:
        cr = (env.get('LINES', 25), env.get('COLUMNS', 80))

        ### Use get(key[, default]) instead of a try/catch
        #try:
        #    cr = (env['LINES'], env['COLUMNS'])
        #except:
        #    cr = (25, 80)
    return int(cr[1]), int(cr[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Code above didn't return correct result on my linux because winsize-struct has 4 unsigned shorts, not 2 signed shorts:</p>
<pre><code>def terminal_size():
    import fcntl, termios, struct
    h, w, hp, wp = struct.unpack('HHHH',
        fcntl.ioctl(0, termios.TIOCGWINSZ,
        struct.pack('HHHH', 0, 0, 0, 0)))
    return w, h
</code></pre>
<p>hp and hp should contain pixel width and height, but don't.</p>
</div>
<div class="post-text" itemprop="text">
<p>I searched around and found a solution for windows at :</p>
<p><a href="http://code.activestate.com/recipes/440694-determine-size-of-console-window-on-windows/">http://code.activestate.com/recipes/440694-determine-size-of-console-window-on-windows/</a></p>
<p>and a solution for linux here.</p>
<p>So here is a version which works both on linux, os x and windows/cygwin :</p>
<pre><code>""" getTerminalSize()
 - get width and height of console
 - works on linux,os x,windows,cygwin(windows)
"""

__all__=['getTerminalSize']


def getTerminalSize():
   import platform
   current_os = platform.system()
   tuple_xy=None
   if current_os == 'Windows':
       tuple_xy = _getTerminalSize_windows()
       if tuple_xy is None:
          tuple_xy = _getTerminalSize_tput()
          # needed for window's python in cygwin's xterm!
   if current_os == 'Linux' or current_os == 'Darwin' or  current_os.startswith('CYGWIN'):
       tuple_xy = _getTerminalSize_linux()
   if tuple_xy is None:
       print "default"
       tuple_xy = (80, 25)      # default value
   return tuple_xy

def _getTerminalSize_windows():
    res=None
    try:
        from ctypes import windll, create_string_buffer

        # stdin handle is -10
        # stdout handle is -11
        # stderr handle is -12

        h = windll.kernel32.GetStdHandle(-12)
        csbi = create_string_buffer(22)
        res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)
    except:
        return None
    if res:
        import struct
        (bufx, bufy, curx, cury, wattr,
         left, top, right, bottom, maxx, maxy) = struct.unpack("hhhhHhhhhhh", csbi.raw)
        sizex = right - left + 1
        sizey = bottom - top + 1
        return sizex, sizey
    else:
        return None

def _getTerminalSize_tput():
    # get terminal width
    # src: http://stackoverflow.com/questions/263890/how-do-i-find-the-width-height-of-a-terminal-window
    try:
       import subprocess
       proc=subprocess.Popen(["tput", "cols"],stdin=subprocess.PIPE,stdout=subprocess.PIPE)
       output=proc.communicate(input=None)
       cols=int(output[0])
       proc=subprocess.Popen(["tput", "lines"],stdin=subprocess.PIPE,stdout=subprocess.PIPE)
       output=proc.communicate(input=None)
       rows=int(output[0])
       return (cols,rows)
    except:
       return None


def _getTerminalSize_linux():
    def ioctl_GWINSZ(fd):
        try:
            import fcntl, termios, struct, os
            cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ,'1234'))
        except:
            return None
        return cr
    cr = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
    if not cr:
        try:
            fd = os.open(os.ctermid(), os.O_RDONLY)
            cr = ioctl_GWINSZ(fd)
            os.close(fd)
        except:
            pass
    if not cr:
        try:
            cr = (env['LINES'], env['COLUMNS'])
        except:
            return None
    return int(cr[1]), int(cr[0])

if __name__ == "__main__":
    sizex,sizey=getTerminalSize()
    print  'width =',sizex,'height =',sizey
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Starting at Python 3.3 it is straight forward:
<a href="https://docs.python.org/3/library/os.html#querying-the-size-of-a-terminal">https://docs.python.org/3/library/os.html#querying-the-size-of-a-terminal</a></p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; ts = os.get_terminal_size()
&gt;&gt;&gt; ts.lines
24
&gt;&gt;&gt; ts.columns
80
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's either:</p>
<pre><code>import os
columns, rows = os.get_terminal_size(0)
# or
import shutil
columns, rows = shutil.get_terminal_size()
</code></pre>
<p>The <code>shutil</code> function is just a wrapper around <code>os</code> one that catches some errors and set up a fallback, however it has one huge caveat - <strong>it breaks when piping!</strong>, which is a pretty huge deal.<br/>
To have get terminal size when piping use <code>os.get_terminal_size(0)</code> instead.</p>
<p>First argument <code>0</code> is an argument indicating that stdin file descriptor should be used instead of default stdout. We want to use stdin because stdout detaches itself when it is being piped which raises in this case raises an error..<br/>
I've tried to figure out when would it makes sense to use stdout instead of stdin argument and have no idea why it a default here.</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like there are some problems with that code, Johannes:</p>
<ul>
<li><code>getTerminalSize</code> needs to <code>import os</code></li>
<li>what is <code>env</code>? looks like <code>os.environ</code>.</li>
</ul>
<p>Also, why switch <code>lines</code> and <code>cols</code> before returning? If <code>TIOCGWINSZ</code> and <code>stty</code> both say <code>lines</code> then <code>cols</code>, I say leave it that way. This confused me for a good 10 minutes before I noticed the inconsistency.</p>
<p>Sridhar, I didn't get that error when I piped output. I'm pretty sure it's being caught properly in the try-except.</p>
<p>pascal, <code>"HHHH"</code> doesn't work on my machine, but <code>"hh"</code> does. I had trouble finding documentation for that function. It looks like it's platform dependent.</p>
<p>chochem, incorporated.</p>
<p>Here's my version:</p>
<pre><code>def getTerminalSize():
    """
    returns (lines:int, cols:int)
    """
    import os, struct
    def ioctl_GWINSZ(fd):
        import fcntl, termios
        return struct.unpack("hh", fcntl.ioctl(fd, termios.TIOCGWINSZ, "1234"))
    # try stdin, stdout, stderr
    for fd in (0, 1, 2):
        try:
            return ioctl_GWINSZ(fd)
        except:
            pass
    # try os.ctermid()
    try:
        fd = os.open(os.ctermid(), os.O_RDONLY)
        try:
            return ioctl_GWINSZ(fd)
        finally:
            os.close(fd)
    except:
        pass
    # try `stty size`
    try:
        return tuple(int(x) for x in os.popen("stty size", "r").read().split())
    except:
        pass
    # try environment variables
    try:
        return tuple(int(os.getenv(var)) for var in ("LINES", "COLUMNS"))
    except:
        pass
    # i give up. return default.
    return (25, 80)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Many of the Python 2 implementations here will fail if there is no controlling terminal when you call this script.  You can check sys.stdout.isatty() to determine if this is in fact a terminal, but that will exclude a bunch of cases, so I believe the most pythonic way to figure out the terminal size is to use the builtin curses package.</p>
<pre><code>import curses
w = curses.initscr()
height, width = w.getmaxyx()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I was trying the solution from here that calls out to <code>stty size</code>:</p>
<pre><code>columns = int(subprocess.check_output(['stty', 'size']).split()[1])
</code></pre>
<p>However this failed for me because I was working on a script that expects redirected input on stdin, and <code>stty</code> would complain that "stdin isn't a terminal" in that case.</p>
<p>I was able to make it work like this:</p>
<pre><code>with open('/dev/tty') as tty:
    height, width = subprocess.check_output(['stty', 'size'], stdin=tty).split()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@reannual's answer works well, but there's an issue with it: <code>os.popen</code> <a href="https://docs.python.org/2/library/os.html#os.popen" rel="nofollow">is now deprecated</a>. The <code>subprocess</code> module should be used instead, so here's a version of @reannual's code that uses <code>subprocess</code> and directly answers the question (by giving the column width directly as an <code>int</code>:</p>
<pre><code>import subprocess

columns = int(subprocess.check_output(['stty', 'size']).split()[1])
</code></pre>
<p>Tested on OS X 10.9</p>
</div>
<div class="post-text" itemprop="text">
<p>Try <strong>"blessings"</strong></p>
<p>I was looking for the very same thing. It is very easy to use and offers tools for coloring, styling and positioning in the terminal. What you need is as easy as:</p>
<pre><code>from blessings import Terminal

t = Terminal()

w = t.width
h = t.height
</code></pre>
<p>Works like a charm in Linux. (I'm not sure about MacOSX and Windows)</p>
<p>Download and documentation <a href="https://pypi.python.org/pypi/blessings/" rel="nofollow">here</a></p>
<p>or you can install it with pip:</p>
<pre><code>pip install blessings
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python 3.3 or above, I'd recommend the built-in <code>get_terminal_size()</code> as already recommended. However if you are stuck with an older version and want a simple, cross-platform way  of doing this, you could use <a href="https://github.com/peterbrittain/asciimatics" rel="nofollow">asciimatics</a>.  This package supports versions of Python back to 2.7 and uses similar options to those suggested above to get the current terminal/console size.</p>
<p>Simply construct your <code>Screen</code> class and use the <code>dimensions</code> property to get the height and width.  This has been proven to work on Linux, OSX and Windows.</p>
<p>Oh - and full disclosure here: I am the author, so please feel free to open a new issue if you have any problems getting this to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an version that should be Linux and Solaris compatible. Based on the posts and commments from <a href="https://stackoverflow.com/users/68595/madchine">madchine</a>. Requires the subprocess module.</p>
<pre>
def termsize():
    import shlex, subprocess, re
    output = subprocess.check_output(shlex.split('/bin/stty -a'))
    m = re.search('rows\D+(?P\d+); columns\D+(?P\d+);', output)
    if m:
        return m.group('rows'), m.group('columns')
    raise OSError('Bad response: %s' % (output))
</pre>
<pre>
&gt;&gt;&gt; termsize()
('40', '100')
</pre>
</div>
<span class="comment-copy">Look this answer for a more extensive solution to have a "columns dependent" printing mechanism. <a href="https://stackoverflow.com/questions/44129613/how-to-print-number-of-characters-based-on-terminal-width-that-also-resize/44133299#44133299" title="how to print number of characters based on terminal width that also resize">stackoverflow.com/questions/44129613/â€¦</a></span>
<span class="comment-copy">You can get this to work on Solaris as well if instead of "size" you pass "-a". There will be "rows = Y; columns = X" in the semicolon delimited output.</span>
<span class="comment-copy">COLUMNS isn't exported by default in Bash, that's why os.environ["COLUMNS"] doesn't work.</span>
<span class="comment-copy"><code>rows, columns = subprocess.check_output(['stty', 'size']).split()</code> is a little shorter, plus subprocess is the future</span>
<span class="comment-copy">tput is better than stty, as stty cannot work with PIPE.</span>
<span class="comment-copy"><code>rows, columns = subprocess.check_output(['stty', 'size']).decode().split()</code> If you want unicode strings for py2/3 compatibility</span>
<span class="comment-copy">That's because you shouldn't be using 2.7 any longer, make the jump to 3.x it's worth it.</span>
<span class="comment-copy">@osirisgothra Many hosting providers do not support python3 yet, so some of us are forced to use python2 for back end development.  Though that should have nothing to do with getting terminal size...</span>
<span class="comment-copy">@osirisgothra Because there's a lot of Python 2 code that would take too much work to port. Also, Pypy still has rather poor Python 3 support.</span>
<span class="comment-copy">@whitebeard Is there a reason the subscriber can't install Python 3 on a VPS? Or in 2016, are people still using shared hosting whose administrator is unwilling to install Python 3? For example, WebFaction shared hosting has <code>python3.5</code> installed.</span>
<span class="comment-copy">+1 for a solution that also works when standard input has been redirected from a file! With other solutions, I was either getting <code>Inappropriate ioctl for device</code> errors/warnings, or getting the defined fallback value of 80.</span>
<span class="comment-copy">Thanks for quick reply, but here (<a href="http://effbot.org/zone/console-handbook.htm" rel="nofollow noreferrer">effbot.org/zone/console-handbook.htm</a>) it says that "The Console module is currently only available for Windows 95, 98, NT, and 2000." I am looking for a solution that works on Linux. It probably wasn't clear from the tag, I will edit the question accordingly.</span>
<span class="comment-copy">since this "console" module you're using is not on the standard python library, you should provide its source code or at least a link to it.</span>
<span class="comment-copy">I'm so sorry about that. In fact, I didn't know that module. I tryied import console and it worked, I used console.&lt;tab&gt;&lt;tab&gt; and getTerminalSize() showed up. Instead of looking where it's from I already posted an answer because I was so lucky of the simplicity <i>g</i></span>
<span class="comment-copy">I might be looking at a different "console" module, could you please provide a link for the one you have?</span>
<span class="comment-copy">Oh, and not to pile on the code, but "cr" is a confusing name because it implies the tuple is (cols, rows).  In reality, it is the reverse.</span>
<span class="comment-copy">This is how it should be done; note that if you intend to print to the terminal, you should use '1' as the file descriptor (first argument of ioctl), as stdin might be a pipe or some different tty.</span>
<span class="comment-copy">Perhaps the 0 should be replaced with <code>fcntl.ioctl(sys.stdin.fileno(), ...</code></span>
<span class="comment-copy">this is the best answer - your users will be happy that there's not a surprise subprocess happening just to get term width</span>
<span class="comment-copy">this is indeed the cleanest answer. I think you should use <code>stdout</code> or <code>stderr</code> instead of <code>stdin</code>, though. <code>stdin</code> might very well be a pipe. You might also want to add a line such as <code>if not os.isatty(0): return float("inf")</code>.</span>
<span class="comment-copy">this somehow works on a chromebook terminal which has like no functionality. +1</span>
<span class="comment-copy">You saved me the time of doing this myself.  Works on Linux.  Should work on Windows as well. Thanks!</span>
<span class="comment-copy">Borrowed here: <a href="https://gist.github.com/jtriley/1108174" rel="nofollow noreferrer">gist.github.com/jtriley/1108174</a></span>
<span class="comment-copy"><code>shutil.get_terminal_size() is the high-level function which should normally be used, os.get_terminal_size is the low-level implementation.</code></span>
<span class="comment-copy">This is a near copy of a year-older answer given above.</span>
<span class="comment-copy"><code>os.get_terminal_size()</code> was introduced in Python 3.3</span>
<span class="comment-copy">I was wandering about the <code>env</code> too, and it is indeed <code>env = os.environ</code>, from <a href="http://stackoverflow.com/a/566752/277826">accepted answer</a>.</span>
