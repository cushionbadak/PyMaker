<div class="post-text" itemprop="text">
<p>I have a list of dictionaries with all of them having the same keys such as</p>
<pre><code>input = [                  
    {                      
        "animal": "Tiger"
        "country": "US",   
        "color": "yellow-black"   
    },                     
    {                      
        "animal": "Dog"
        "country": "UK",   
        "color": "brown"       
    },                     
    {                      
        "animal": "Tiger"
        "country": "Nepal",   
        "color": "yellow-black"     
    }                                                              
]  
</code></pre>
<p>I would like to create a new dictionary where the ones which share the same value for a specified key (here animal) are grouped together. While grouping them I would like to remove the 'animal' key from the initial dictionaries. For the given example it would like this</p>
<pre><code>output = {
        "Tiger":
        [{                      
            "country": "US",   
            "color": "yellow-black"   
        }, 
        {                      
            "animal": "Tiger"
            "country": "Nepal",   
            "color": "yellow-black"     
        }],
        "Dog": [
        {                      
            "country": "UK",   
            "color": "brown"       
        }]                     
}                                                                  
</code></pre>
<p>I achieve this with the code below, but I am quite sure that there must be a more elegant approach to this. Is it possible to write this as a one-liner? </p>
<pre><code>grouped = dict((k, list(g)) for k, g in itertools.groupby(input, key=lambda x:x['animal'])) 
for k, g in grouped.items():                                                                  
    for i in range(len(grouped)):                                                             
        del g[i]['animal']  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way is probably using a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>. I'm assuming you actually want to drop the <code>"animal"</code> tag in the output, since you also have missing commas in the input so likely a typo.</p>
<pre><code>from collections import defaultdict

output = defaultdict(list)

inp = [                  
    {                      
        "animal": "Tiger",
        "country": "US",   
        "color": "yellow-black"   
    },                     
    {                      
        "animal": "Dog",
        "country": "UK",   
        "color": "brown"       
    },                     
    {                      
        "animal": "Tiger",
        "country": "Nepal",   
        "color": "yellow-black"     
    }                                                              
]  

for item in inp:
    output[item['animal']].append({k: v for k, v in item.items() 
                                   if k != 'animal'})
</code></pre>
<p>Depending on how many key/value pairs you have in your dictionary, it may be quicker to simply remove the key from the dictionary, rather than use a dictionary comprehension to rebuild a dictionary excluding that key. For a sample this size, it really doesn't matter for speed, and it doesn't risk altering your initial data.</p>
</div>
<div class="post-text" itemprop="text">
<p>This would be your fixed attempt - but it needs pre-sorting and is less effective then the defaultdict:</p>
<pre><code># fixed data
data = [ { "animal": "Tiger",  "country": "US",    "color": "yellow-black" },
         {  "animal": "Dog",   "country": "UK",    "color": "brown" }, 
         {  "animal": "Tiger", "country": "Nepal", "color": "yellow-black" } ] 

from itertools import groupby

# groupby needs sorted keys if you want to group them together 
grouped = dict((k, list(g)) for k, g in groupby(sorted(data,key=lambda x:x["animal"]), 
                                                key=lambda x:x['animal'])) 

# delete the animal key
for k in grouped:
    for inner in grouped[k]:
        del inner["animal"]

print(grouped)
</code></pre>
<p>Output:</p>
<pre><code>{  'Dog': [{'country': 'UK', 'color': 'brown'}], 
 'Tiger': [{'country': 'US', 'color': 'yellow-black'}, 
           {'country': 'Nepal', 'color': 'yellow-black'}]}
</code></pre>
<p>Doku:</p>
<ul>
<li><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby()</a></li>
</ul>
<blockquote>
<p>Make an iterator that returns <strong>consecutive keys</strong> and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Not be one liner but <code>defaultdict</code> is the one to go with</p>
<pre><code>from collections import defaultdict
d=defaultdict(list)
for i in input:
    d[i['animal']].append({k:v for k,v in  i.items() if k!='animal' })
</code></pre>
</div>
<span class="comment-copy">Do you really want <code>"animal": "Tiger"</code> in the output? As in, it's a repeated item that you've categorised under the primary key</span>
<span class="comment-copy">Your input dict is missing a few commas. I also notice that when I run your <code>groupby</code> approach, the "Tiger" list only has the nepalese tiger; the US tiger is not present. For this reason I don't think the <code>groupby</code> approach is a practical one.</span>
<span class="comment-copy">itertools.,groupby only groups consecutive keys - your tigers are one other animal appart so they wont be grouped</span>
<span class="comment-copy">Sorry for the typos, I will make the corrections. @PatrickArtner thank you for the insight, learnt something new today</span>
<span class="comment-copy">This works great. Just out of pure curiosity, would you happen how I can shorten my code above assuming that I am using the grouped functionality?</span>
<span class="comment-copy">@Tony.H you want a solution using <code>itertools.groupby</code>? I can have a go, since I don't mind trying to correct initial code rather than just give another approach, but I want to be sure that's what you're asking me to do.</span>
<span class="comment-copy">yes I would be very grateful for that. I like your solution but I was just curious how it would work with <code>itertools.groupby</code></span>
<span class="comment-copy">@roganjosh  already did the groupby one ;o)</span>
<span class="comment-copy">@PatrickArtner Oh, I know it's not the cleanest approach, but you did answer the subsidiary question the OP had for me on how to make it work, so I've upvoted :)</span>
<span class="comment-copy">thank you @PatrickArtner</span>
