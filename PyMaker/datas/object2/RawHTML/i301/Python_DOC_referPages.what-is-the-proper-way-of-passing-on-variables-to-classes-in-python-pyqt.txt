<div class="post-text" itemprop="text">
<p>Imagine I have GUI class whose main function is to handle the graphical presentation of the program, but that also stores information and links different operations. So for example something like this:</p>
<pre><code>import sys
from PyQt5.QtWidgets import QWidget, QPushButton, QGridLayout, QApplication

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.button_a = QPushButton('button_a')
        self.button_b = QPushButton('button_b')
        self.button_c = QPushButton('button_c')
        self.layout = QGridLayout()
        self.layout.addWidget(self.button_a, 0, 0)
        self.layout.addWidget(self.button_b, 1, 0)
        self.layout.addWidget(self.button_c, 2, 0)
        self.setLayout(self.layout)

        self.variable_a = 1
        self.variable_b = 2
        self.variable_c = 3
        self.object_a = None
        self.object_b = None
        self.object_c = None

        self.button_a.clicked.connect(self.do_something)
        self.button_b.clicked.connect(self.do_something_else)
        self.button_c.clicked.connect(self.do_something_entirely_different)

    def do_something(self):
        self.object_a = ObjectClassA(self)

    def do_something_else(self):
        self.object_b = ObjectClassB(
            self.variable_a, self.variable_b, self.variable_c
        )

    def do_something_entirely_different(self):
        self.object_c = ObjectClassC()


class ObjectClassA:
    def __init__(self, gui):
        self.variable_a = gui.variable_a
        self.variable_b = gui.variable_b
        self.variable_c = gui.variable_c


class ObjectClassB:
    def __init__(self, variable_a, variable_b, variable_c):
        self.variable_a = variable_a
        self.variable_b = variable_b
        self.variable_c = variable_c


class ObjectClassC:
    def __init__(self):
        self.variable_a = GUI.variable_a
        self.variable_b = GUI.variable_b
        self.variable_c = GUI.variable_c


if __name__ == '__main__':
    app = QApplication(sys.argv)
    GUI = MainWindow()
    GUI.show()
    sys.exit(app.exec_())
</code></pre>
<p>Which would be the proper approach here? I see that if you pass along the whole MainWindow class, the new instance of ObjectClassA would have basically access to all the information stored in the MainWindow. But on the other hand, if I only pass along every variable individually, I can end up passing on a long list of things which appears to be cumbersome. Or is it better to simply refer to the instance of the MainWindow?</p>
<p>I already found <a href="https://stackoverflow.com/questions/13455143/what-is-the-proper-way-to-access-python-class-variables">this similar question</a> although I am not quite sure how the answer applies to my question.</p>
</div>
<div class="post-text" itemprop="text">
<p>The second way <code>ObjectClassB</code> is better because it respects object encapsulation.
In order to decrease the number of arguments, you can use <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">dictionaries</a>, like this example.</p>
<pre><code>def do_something_else(self):
    args = {'a':self.variable_a, 'b':self.variable_b, 'c':self.variable_c}
    self.object_b = ObjectClassB(args)


class ObjectClassB:
    def __init__(self, mydict):
        self.variable_a = mydict['a']
        self.variable_b = mydict['b']
        self.variable_c = mydict['c']
</code></pre>
</div>
<span class="comment-copy">You might also want to copy the variables</span>
<span class="comment-copy">I see, thank you for the suggestion! What does object encapsulation mean?</span>
<span class="comment-copy">Short definition: Encapsulation is one of the fundamentals of OOP. It refers to the bundling of data with the methods that operate on that data. Encapsulation is used to hide the values or state of a structured data object inside a class, preventing unauthorized parties' direct access to them. Publicly accessible methods are generally provided in the class (so-called getters and setters) to access the values, and other client classes call these methods to retrieve and modify the values within the object.  More info: <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" rel="nofollow noreferrer">en.wikipedia.org/wiki/Encapsulation_(computer_programming)</a></span>
<span class="comment-copy">Ahh that makes sense, I guess. Funnily enough, I already programmed getters and setters for some of my classes myself (although not for everything, so not super consistent there), because I saw it was used in libraries. I was wondering why you wouldn't just access/edit the variable by simply calling it by its name.</span>
