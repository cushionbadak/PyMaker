<div class="post-text" itemprop="text">
<p>I have a string which includes encoded bytes inside it:</p>
<pre><code>str1 = "b'Output file \xeb\xac\xb8\xed\x95\xad\xeb\xb6\x84\xec\x84\x9d.xlsx Created'"
</code></pre>
<p>I want to decode it, but I can't since it has become a string. Therefore I want to ask whether there is any way I can convert it into </p>
<pre><code>str2 = b'Output file \xeb\xac\xb8\xed\x95\xad\xeb\xb6\x84\xec\x84\x9d.xlsx Created'
</code></pre>
<p>Here <code>str2</code> is a <code>bytes</code> object which I can decode easily using </p>
<pre><code>str2.decode('utf-8')
</code></pre>
<p>to get the final result:</p>
<pre><code>'Output file 문항분석.xlsx Created'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple way is to assume that all  the characters of the initial strings are in the [0,256) range and map to the same Unicode value, which means that it is a Latin1 encoded string.</p>
<p>The conversion is then trivial:</p>
<pre><code>str1[2:-1].encode('Latin1').decode('utf8')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a>:</p>
<pre><code>&gt;&gt;&gt; print(str1)
b'Output file \xeb\xac\xb8\xed\x95\xad\xeb\xb6\x84\xec\x84\x9d.xlsx Created'
&gt;&gt;&gt; type(str1)
&lt;class 'str'&gt;
</code></pre>
<p></p>
<pre><code>&gt;&gt;&gt; from ast import literal_eval
&gt;&gt;&gt; literal_eval(str1).decode('utf-8')
'Output file 문항분석.xlsx Created'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on the SyntaxError mentioned in your comments, you may be having a testing issue when attempting to print due to the fact that <code>stdout</code> is set to <code>ascii</code> in your console (and you may also find that your console does not support some of the characters you may be trying to print). You can try something like the following to set <code>sys.stdout</code> to <code>utf-8</code> and see what your console will print (just using string slice and <code>encode</code> below to get bytes rather than the <code>ast.literal_eval</code> approach that has already been suggested):</p>
<pre><code>import codecs
import sys

sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer)

s = "b'Output file \xeb\xac\xb8\xed\x95\xad\xeb\xb6\x84\xec\x84\x9d.xlsx Created'"
b = s[2:-1].encode().decode('utf-8')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Finally I have found an answer where i use a function to cast a string to bytes without encoding.Given string</p>
<p><code>str1 = "b'Output file \xeb\xac\xb8\xed\x95\xad\xeb\xb6\x84\xec\x84\x9d.xlsx Created'"</code></p>
<p>now i take only actual encoded text inside of it </p>
<p><code>str1[2:-1]</code></p>
<p>and pass this to the function which convert the string to bytes without encoding its values</p>
<pre><code>import struct
def rawbytes(s):
    """Convert a string to raw bytes without encoding"""
    outlist = []
    for cp in s:
        num = ord(cp)
        if num &lt; 255:
            outlist.append(struct.pack('B', num))
        elif num &lt; 65535:
            outlist.append(struct.pack('&gt;H', num))
        else:
            b = (num &amp; 0xFF0000) &gt;&gt; 16
            H = num &amp; 0xFFFF
            outlist.append(struct.pack('&gt;bH', b, H))
    return b''.join(outlist)
</code></pre>
<p>So, calling the function would convert it to bytes which then is decoded</p>
<p><code>rawbytes(str1[2:-1]).decode('utf-8')</code></p>
<p>will give the correct output</p>
<p><code>'Output file 문항분석.xlsx Created'</code></p>
</div>
<span class="comment-copy">Thank you, it is very short and way more easier solution then i found</span>
<span class="comment-copy">But one thing is that it works fine when i run this code separately but in my main program when i implement it, the string after Latin1 encoding will automatically add \ in-front of any \ so there is \\ in the string therefore decoding it makes it just remove the single slash.So, the above code becomes similar to str1[2:-1]. I think in order to escape \ character python is adding another \. How can i deal with it</span>
<span class="comment-copy">SyntaxError: bytes can only contain ASCII literal characters.</span>
<span class="comment-copy">That suggests your input is actually something like <code>"b'Output file ë¬¸í\x95\xadë¶\x84ì\x84\x9d.xlsx Created'"</code>, rather than the escaped string I inferred from your question. I think at that point it's time to go and fix whatever's sending you such messed up input, to be honest …</span>
<span class="comment-copy"><a href="https://www.dropbox.com/s/fmkrhy0pt29rdi3/%7BD15995AE-C51A-44DF-A53D-ED8A1CD4984C%7D.png.jpg?dl=0" rel="nofollow noreferrer">dropbox.com/s/fmkrhy0pt29rdi3/…</a></span>
<span class="comment-copy">Please see my previous comment – once things are as messed up as that, you're better off fixing whatever is generating such an unpleasant string.</span>
<span class="comment-copy">I myself has converted it to bytes msg = bytes("Output file " + output_filename + " Created", 'utf-8') print(msg) To send the msg through popen().communicate() function which doesn't support the original msg after i receive after communicate i get the list of bytes string like above</span>
<span class="comment-copy">AttributeError: 'OutStream' object has no attribute 'buffer'</span>
<span class="comment-copy">@SujilDevkota - unfortunately, I can't replicate that error. There must be some other environmental factors (i.e. additional code that is not included in the question, some sort of OS / shell combination that we aren't expecting, etc).</span>
