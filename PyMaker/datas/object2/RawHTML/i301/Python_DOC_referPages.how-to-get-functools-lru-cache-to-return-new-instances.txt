<div class="post-text" itemprop="text">
<p>I use Python's <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>lru_cache</code></a> on a function which returns a mutable object, like so:</p>
<pre><code>import functools

@functools.lru_cache()
def f():
    x = [0, 1, 2]  # Stand-in for some long computation
    return x
</code></pre>
<p>If I call this function, mutate the result and call it again, I do not obtain a "fresh", unmutated object:</p>
<pre><code>a = f()
a.append(3)
b = f()
print(a)  # [0, 1, 2, 3]
print(b)  # [0, 1, 2, 3]
</code></pre>
<p>I get why this happens, but it's not what I want. A fix would be to leave the caller in charge of using <code>list.copy</code>:</p>
<pre><code>a = f().copy()
a.append(3)
b = f().copy()
print(a)  # [0, 1, 2, 3]
print(b)  # [0, 1, 2]
</code></pre>
<p>However I would like to fix this inside <code>f</code>. A pretty solution would be something like</p>
<pre><code>@functools.lru_cache(copy=True)
def f():
    ...
</code></pre>
<p>though no <code>copy</code> argument is actually taken by <code>functools.lru_cache</code>.</p>
<p>Any suggestion as to how to best implement this behavior?</p>
<h3>Edit</h3>
<p>Based on the answer from holdenweb, this is my final implementation. It behaves exactly like the builtin <code>functools.lru_cache</code> by default, and extends it with the copying behavior when <code>copy=True</code> is supplied.</p>
<pre><code>import functools
from copy import deepcopy

def lru_cache(maxsize=128, typed=False, copy=False):
    if not copy:
        return functools.lru_cache(maxsize, typed)
    def decorator(f):
        cached_func = functools.lru_cache(maxsize, typed)(f)
        @functools.wraps(f)
        def wrapper(*args, **kwargs):
            return deepcopy(cached_func(*args, **kwargs))
        return wrapper
    return decorator

# Tests below

@lru_cache()
def f():
    x = [0, 1, 2]  # Stand-in for some long computation
    return x

a = f()
a.append(3)
b = f()
print(a)  # [0, 1, 2, 3]
print(b)  # [0, 1, 2, 3]

@lru_cache(copy=True)
def f():
    x = [0, 1, 2]  # Stand-in for some long computation
    return x

a = f()
a.append(3)
b = f()
print(a)  # [0, 1, 2, 3]
print(b)  # [0, 1, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since the <code>lru_cache</code> decorator has unsuitable behaviour for you, the best you can do is to build your own decorator that returns a <em>copy</em> of what it gets from <code>lru_cache</code>. This will mean that the first call with a particular set of arguments will create two copies of the object, since now the cache will only be holding prototype objects.</p>
<p>This question is made more difficult because <code>lru_cache</code> can take arguments (<code>mazsize</code> and <code>typed</code>), so a <em>call</em> to <code>lru_cache</code> returns a <em>decorator</em>. Remembering that a decorator takes a function as its argument and (usually) returns a function, you will have to replace <code>lru_cache</code> with a function that takes two arguments and returns a function that takes a function as an argument and returns a (wrapped) function which is not an easy structure to wrap your head around.</p>
<p>You would then write your functions using the <code>copying_lru_cache</code> decorator instead of the standard one, which is now applied "manually" inside the updated decorator.</p>
<p>Depending on how heavy the mutations are, you might get away without using deepcopy, but you don't give enough information to determine that.</p>
<p>So your code would then read</p>
<pre><code>from functools import lru_cache
from copy import deepcopy

def copying_lru_cache(maxsize=10, typed=False):
    def decorator(f):
        cached_func = lru_cache(maxsize=maxsize, typed=typed)(f)
        def wrapper(*args, **kwargs):
            return deepcopy(cached_func(*args, **kwargs))
        return wrapper
    return decorator

@copying_lru_cache()
def f(arg):
    print(f"Called with {arg}")
    x = [0, 1, arg]  # Stand-in for some long computation
    return x

print(f(1), f(2), f(3), f(1))
</code></pre>
<p>This prints</p>
<pre><code>Called with 1
Called with 2
Called with 3
[0, 1, 1] [0, 1, 2] [0, 1, 3] [0, 1, 1]
</code></pre>
<p>so the cacheing behaviour your require appears to be present. Note also tht the documentation for <code>lru_cache</code> specifically warns that</p>
<blockquote>
<p>In general, the LRU cache should only be used when you want to reuse previously computed values. Accordingly, it doesn’t make sense to cache functions with side-effects, functions that need to create distinct mutable objects on each call, or impure functions such as time() or random().</p>
</blockquote>
</div>
<span class="comment-copy">I don't think this is an appropriate use of <code>functools.lru_cache</code> because your function doesn't have any arguments (which are used to look-up previous results in the cache). To get what you have to work, make your function return a copy (or <code>deepcopy</code>) of <code>x</code>—which will likely defeat the purpose of using the decorator in this scenario.</span>
<span class="comment-copy">@martineau The function in my actual use case will have arguments. This does not matter for the question.</span>
<span class="comment-copy">Well, it does in so far as it would have made providing a working answer a little easier, but I hope I've finally arrived at something you can use - if you must despite the documented warnings.</span>
<span class="comment-copy">Hence my use of the phrase "something like" ;-). Good catch, fixed (I think).</span>
<span class="comment-copy">That looks better. However it seems like doing a copy on every call to the wrapped function is going to cancel-out to some degree the likely reason for using a LRU cache in the first place.</span>
<span class="comment-copy">@martineau Well, each computation might take a long time, even though the returned object is small.</span>
<span class="comment-copy">@holdenweb Can you provide a small but complete example using your <code>copying_lru_cache</code> decorator?</span>
<span class="comment-copy">@jmd_dk: It's a decorator—use it like any other.</span>
