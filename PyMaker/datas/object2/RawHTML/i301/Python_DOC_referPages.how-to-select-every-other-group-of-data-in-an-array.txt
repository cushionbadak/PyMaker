<div class="post-text" itemprop="text">
<p>I have a data set of ~100,000 data points, and I need to be able to select every other group of 10,000 data points and append them into a new list (so I will end up with a data set of data points 0-10000, 20,000-30,000, 40,000-50,000 etc). I cannot separate the data by simply thresholding the values themselves, I need to separate by index.</p>
<p>I think I need to write a loop which can select in order the first 10,000 data points, check to see if the iteration number is odd or even, and if odd, append to the new list, then repeat the loop, but since the next iteration is an even number, the second 10,000 data points get ignored, and so on until the end. I understand the logic and have a vague idea of what to do but I am a chemist, not a programmer, and I don't know enough Python syntax to even begin googling to try and find out which commands I need. I don't know how to call each set of ten thousand data points in succession and I don't know how to tell Python to count iterations, let alone ignore every even one! </p>
</div>
<div class="post-text" itemprop="text">
<p>There are more sophisticated ways to do this using list comprehension, etc., but here is a way to do this that might be easiest to understand:</p>
<p>Assuming your data is in an array <code>data</code>.</p>
<pre><code>import numpy as np

data = list(data)
data_subset = []
interval_length = 10,000
n_intervals = int(len(data)/interval_length)

# get every other data interval, starting with the first
for i in range(0, n_intervals, 2):
  start_index = i * interval_length
  stop_index = start_index + interval_length
  data_subset += data[start_index:stop_index]

data_subset = np.array(data_subset)
print(data_subset)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about trying this on a smaller list and then extending it to your larger list? </p>
<pre><code>ls = [1,2,2,2,2,11,2,2,3,4,44,399,9,9,0]

group_sizes = 3

# getting groups of size 'group_sizes' and then choosing every other one ...
groups = [ls[n:n+group_sizes] for n in range(0, len(ls), group_sizes) if n % 2 == 0]
</code></pre>
<p>output</p>
<pre><code>print groups
# [[1, 2, 2], [2, 2, 3], [9, 9, 0]]
</code></pre>
</div>
<span class="comment-copy">Welcome to SO. Please read <a href="https://stackoverflow.com/help/asking">how to ask questions</a>. This question is way too broad. There are many python tutorial over the internet.</span>
<span class="comment-copy">Hi Alexander, I'm quite aware that my question might be very simple. As I pointed out, I don't know enough python syntax to even know what to search for on Google to get a relevant answer. Believe me, I've now spent six hours trying to find an appropriate tutorial online - if you could point me towards one I would be very grateful.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/index.html" rel="nofollow noreferrer">docs.python.org/3/tutorial/index.html</a></span>
<span class="comment-copy">You don't even know Python? You should take some time, learn about it, and come back. We are not a code-writing service.</span>
<span class="comment-copy">Hi, thanks for the suggestion,I don't fully understand what the n_intervals bit is for? Also when I tried this substituting my actual data set into the bits where you've written 'data' it showed up with an error saying 'ValueError: operands could not be broadcast together with shapes (0,) (10000,)', but I don't understand what the error means?</span>
<span class="comment-copy">n_intervals is referring to the total number of groups of 10,000 data points. You then select every other group.  The error you are running into is probably because your data is stored as a numpy array and not a regular list. Answer is edited to reflect this.</span>
