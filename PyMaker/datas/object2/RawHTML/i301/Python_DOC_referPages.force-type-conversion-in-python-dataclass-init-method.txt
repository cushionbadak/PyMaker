<div class="post-text" itemprop="text">
<p>I have the following very simple dataclass:</p>
<pre><code>import dataclasses

@dataclasses.dataclass
class Test:
    value: int
</code></pre>
<p>I create an instance of the class but instead of an integer I use a string:</p>
<pre><code>&gt;&gt;&gt; test = Test('1')
&gt;&gt;&gt; type(test.value)
&lt;class 'str'&gt;
</code></pre>
<p>What I actually want is a forced conversion to the datatype i defined in the class defintion:</p>
<pre><code>&gt;&gt;&gt; test = Test('1')
&gt;&gt;&gt; type(test.value)
&lt;class 'int'&gt;
</code></pre>
<p>Do I have to write the <code>__init__</code> method manually or is there a simple way to achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The type hint of dataclass attributes is never obeyed in the sense that types are enforced or checked. Mostly static type checkers like <a href="http://mypy-lang.org" rel="nofollow noreferrer">mypy</a> are expected to do this job, Python won't do it at runtime, as it never does.</p>
<p>If you want to add manual type checking code, do so in the <a href="https://docs.python.org/3/library/dataclasses.html#post-init-processing" rel="nofollow noreferrer"><code>__post_init__</code></a> method:</p>
<pre><code>@dataclasses.dataclass
class Test:
    value: int

    def __post_init__(self):
        if not isinstance(self.value, int):
            raise ValueError('value not an int')
            # or self.value = int(self.value)
</code></pre>
<p>You could use <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.fields" rel="nofollow noreferrer"><code>dataclasses.fields(self)</code></a> to get a tuple of <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.Field" rel="nofollow noreferrer"><code>Field</code></a> objects which specify the field and the type and loop over that to do this for each field automatically, without writing it for each one individually.</p>
<pre><code>def __post_init__(self):
    for field in dataclasses.fields(self):
        value = getattr(self, field.name)
        if not isinstance(value, field.type):
            raise ValueError(f'Expected {field.name} to be {field.type}, '
                             f'got {repr(value)}')
            # or setattr(self, field.name, field.type(value))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could achieve this using the <code>__post_init__</code> method:</p>
<pre><code>import dataclasses

@dataclasses.dataclass
class Test:
    value : int

    def __post_init__(self):
        self.value = int(self.value)
</code></pre>
<p>This method is called following the <code>__init__</code> method</p>
<p><a href="https://docs.python.org/3/library/dataclasses.html#post-init-processing" rel="nofollow noreferrer">https://docs.python.org/3/library/dataclasses.html#post-init-processing</a></p>
</div>
<span class="comment-copy">thanks! this not exactly what i wanted (exception instead of conversion), but thanks to your suggestion I was able to find a solution</span>
<span class="comment-copy">I would err on the side of exceptions instead of implicit conversion, but I did give you the conversion alternative in the comments thereâ€¦</span>
<span class="comment-copy">oops, didnt see that last comment!</span>
<span class="comment-copy">An alternative <a href="https://stackoverflow.com/a/50622643/">solution</a> using a decorator instead of <code>__post_init__</code>.</span>
