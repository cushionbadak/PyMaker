<div class="post-text" itemprop="text">
<p>I have a program written in python which goes as follows:</p>
<pre><code>for i in range(4954):
    ........
    save("/Downloads/pos_" + str(i) + ".h5")
</code></pre>
<p>The fact is the program running time increases exponentially(we observed it using <code>time.time()</code>)</p>
<p>So what I need is run the program for 10 min and then re run the program.
But I just need to change the i in for loop to the number at which it is stopped.
I can do a cron job, but what should I do to change <code>i</code> value?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>marshal.dump</code>(<a href="https://docs.python.org/3/library/marshal.html" rel="nofollow noreferrer">https://docs.python.org/3/library/marshal.html</a>) to save the value when stopping the program, and then loading it via <code>marshal.load</code> when starting.</p>
<p>Honestly, I think it would be a much better approach to fix the root cause of the problem, i.e. solving the exponential run time.</p>
</div>
<div class="post-text" itemprop="text">
<p>If each iteration (each <code>i</code> value) in the loop is independent with each other, you can parallelize it with <a href="https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor-example" rel="nofollow noreferrer"><code>ProcessPoolExecutor</code></a>:</p>
<pre class="lang-py prettyprint-override"><code>import concurrent.futures

def downloader(i):
    ...
    save("/Downloads/pos_" + str(i) + ".h5")

def main():
    i_range = list(range(4954))
    with concurrent.futures.ProcessPoolExecutor(10) as executor: # create 10 workers (subprocesses)
        for number, result in zip(i_range , executor.map(downloader, i_range)):
            print('File %d is scheduled to download!' % (number))

if __name__ == '__main__':
    main()
</code></pre>
<p>This requires Python3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider using a generator:</p>
<pre><code>import time

def gen(n):
    for i in range(n):
        yield n

g = gen(4954)

time_limit = 600

while some_condition:
# whatever condition required for you to continually restart this section

    start = time.time()
    while time.time() - start &lt; time_limit:
        ... some code...
        try: 
            save("/Downloads/pos_" + str(next(g)) + ".h5")
        except StopIteration:
            print('end of iterations')
</code></pre>
<p>Where <code>g</code> will remember the iteration it's on and continue the next time you call <code>next(g)</code>.  </p>
</div>
<div class="post-text" itemprop="text">
<p>Here my solution:</p>
<pre><code>import os
import time
import threading

class test_class(object):
    def __init__(self):
        self.iter_number = 0
        self.new_iter_number = 0

        self.iter_file_dir = "/tmp_file.txt" # tmp file where sto the new iteration number remaining

        self.end_iteration = False # Flag to stop the iteration

        self.delay = 1 # Seconds that means 10 minutes

        with open(self.iter_file_dir, "r") as file:
            self.iter_number = int(file.readline())

        self.run()

    def for_function(self):
        for i in range(self.iter_number):
            save("/Downloads/pos_" + str(i) + ".h5")
            if(self.end_iteration):
                self.new_iter_number = self.iter_number - i
                break

    def run(self):
        threading.Thread(name="Iteration_Thread", target=self.for_function).start()

        time_remaining = self.delay-time.time()%self.delay
        time.sleep(time_remaining)

        self.end_iteration = True

        # Save the file with the new value
        with open(self.iter_file_dir, 'w') as f:
            f.write(str(self.new_iter_number))
test_class()
</code></pre>
<p>The idea behind this code is simple:</p>
<ol>
<li>Create a tmp_file.txt where you want, and write in them the number of iteration that you need in the for.</li>
<li>Create a timer that sleep for X minutes and after that set a flag that terminate the for loop.</li>
<li>After that save in the tmp_file.txt the new calculated iteration number</li>
</ol>
<p>Each time that the cron run the program it will load the new iteration value. Obviously when the iteration are finished in the file the 0 is written, so no more iteration were performed.</p>
</div>
<span class="comment-copy">What stops the program after x minutes?</span>
<span class="comment-copy">Its better to assign <code>i=next(g)</code> and use <code>i</code> later because every invocation to <code>next</code> will increase the counter by 1. And make sure <code>next(g)</code> is placed inside the <code>try</code> structure.</span>
<span class="comment-copy">In this instance I don't imagine there's any difference between <code>i=next(g)</code> vs just calling <code>next(g)</code> directly.  The last <code>i</code> would be released regardless and are incremented correctly.</span>
<span class="comment-copy">I assume this program is used to download something from Internet. So <code>i</code> should be also used to construct the URL.</span>
<span class="comment-copy">Another problem: the generator object <code>g</code> should be saved in a file to survive restarts.</span>
<span class="comment-copy">Right, but I still don't see your point.  If the generator was a bit more complex and the yield might be affected, I might agree.  In this case i fail to see how it is any different.  Also, this script assumes everything is done <i>within</i> the script itself.  It does not attempt to be a solution that relies on external restart.</span>
