<div class="post-text" itemprop="text">
<p>I have list of tuples like :</p>
<pre><code>[('a', '76', '20190208011713-0500'),
 ('b', '14', '20190208011713-0500'),
 ('c', '99', '20190208011713-0500'),
 ('d', '62', '20190208011713-0500'),
 ('e', '112', '20190208011713-0500'),
 ('f', '78', '20190208011713-0500'),
 ('g', '20', '20190208011713-0500'),
 ('h', '14', '20190208011713-0500'),
 ('i', '23', '20190208011713-0500'),
 ('a', '45', '20190208011803-0500'),
 ('b', '36', '20190208011803-0500'),
 ('c', '22', '20190208011803-0500'),
 ('d', '69', '20190208011803-0500'),
 ('e', '11', '20190208011803-0500'),
 ('f', '118', '20190208011803-0500'),
 ('g', '29', '20190208011803-0500'),
 ('h', '34', '20190208011803-0500'),
 ('i', '63', '20190208011803-0500')]
</code></pre>
<p>The third element of all the tuples are the same. I am trying to convert this list into a dictionary in the following way:</p>
<pre><code>{timestamp: 20190208011713-0500,
  'a' : 76,
  'b' : 14,
  'c' : 99,
  'd' : 62,
  'e' : 112,
  'f' : 78,
  'g' : 20,
  'h' : 14,
  'i' : 23}
</code></pre>
<p><strong>UPDATE:</strong></p>
<p>As of now I am doing it manually but I have around 1000's of tuples in a list with the same timestamp, but sometimes I do also have different timestamps. I am trying to automate this process by writing a function as I need to re-use the code again and again for multiple list of tuples to create list of dictionaries but I'm not sure how to approach this problem. Any help would be appreciated?</p>
<pre><code>[{'timestamp': '20190208011713-0500',
  'a' : 76,
  'b' : 14,
  'c' : 99,
  'd' : 62,
  'e' : 112,
  'f' : 78,
  'g' : 20,
  'h' : 14,
  'i' : 23}, 
  {'timestamp': '20190208011803-0500',
  'a' : 45,
  'b' : 36,
  'c' : 22,
  'd' : 69,
  'e' : 11,
  'f' : 118,
  'g' : 29,
  'h' : 34,
  'i' : 63}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the timestamp is guaranteed to be the same, or otherwise you don't care if it isn't, then just use:</p>
<pre><code>result = {'timestamp': your_list[0][-1]}
result.update(tup[:2] for tup in your_list)
</code></pre>
<p>The second line takes the first two elements of each tuple, and passes those directly to the <a href="https://docs.python.org/library/stdtypes.html#dict.update" rel="nofollow noreferrer"><code>dict.update()</code> method</a>. Like the <a href="https://docs.python.org/library/stdtypes.html#dict" rel="nofollow noreferrer"><code>dict()</code> constructor</a>, that method accepts an iterable of <code>(key, value)</code> tuples, and with slicing, that's what you have already.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; result = {'timestamp': your_list[0][-1]}
&gt;&gt;&gt; result.update(tup[:2] for tup in your_list)
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(result)
{'a': '76',
 'b': '14',
 'c': '99',
 'd': '62',
 'e': '112',
 'f': '78',
 'g': '20',
 'h': '14',
 'i': '23',
 'timestamp': '20190208011713-0500'}
</code></pre>
<p>If speed is of the essence, you can use <a href="https://docs.python.org/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter()</code></a> to do the fetching, and use the <a href="https://docs.python.org/2/library/future_builtins.html#future_builtins.map" rel="nofollow noreferrer">Python 3 version of <code>map()</code></a> to apply it when updating:</p>
<pre><code>from operator import itemgetter
try:
    # forward compatibility with Python 3
    from future_builtins import map
except ImportError:
    pass

result = {'timestamp': your_list[0][-1]}
result.update(map(itemgetter(0, 1), your_list))
</code></pre>
<p>With those changes the whole <code>result.update()</code> loop is executed in native C code.</p>
<p>If your timestamps are not guaranteed to be the same and you need to produce a list, you need to split out (group) your tuples by timestamp. If your input is at least <em>grouped</em> (all entries with the same timestamp appear consecutively), then you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code></a> to do the grouping. The way you then build each dictionary remains the same; we can use the <code>itemgetter()</code> calleble here too to produce the grouping key:</p>
<pre><code>from itertools import groupby
from operator import itemgetter
try:
    # forward compatibility with Python 3
    from future_builtins import map
except ImportError:
    pass

def group_timestamp(timestamp, group):
    d = {'timestamp': timestamp}
    d.update(map(itemgetter(0, 1), group))
    return d

result = [group_timestamp(ts, group) for ts, group in groupby(your_list, itemgetter(2))]
</code></pre>
<p>If they are not grouped, then I'd <em>not</em> sort the input. You want to shunt them into each timestamp group linearly, using a dictionary to do the grouping, then just sort the values of that dictionary when producing the output:</p>
<pre><code>groups = {}
for key, value, ts in your_list:
    if ts not in groups:
        groups[ts] = {'timestamp': ts}
    groups[ts][key] = value

result = sorted(groups.values(), key=itemgetter('timestamp'))
</code></pre>
<p>This gives you the grouped dicitonaries in timestamp order. If output order doesn't matter, just use <code>result = list(groups.values())</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Accounting for changing timestamps:</p>
<pre><code>lst = [('a', '76', '20190208011713-0500'),
    ('b', '14', '20190208011713-0500'),
    ('c', '99', '20190208011713-0500'),
    ('d', '62', '20190208011713-0500'),
    ('e', '112', '20190208011713-0500'),
    ('f', '78', '20190208011713-0500'),
    ('g', '20', '20190208011713-0500'),
    ('h', '14', '20190208011713-0500'),
    ('i', '23', '20190208011713-0500')]

dict = {}

for tuple in lst:
    if tuple[2] in dict:
        dict[tuple[2]][tuple[0]] = tuple[1]
    else:
        dict[tuple[2]] = {}
        dict[tuple[2]][tuple[0]] = tuple[1]
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>{'20190208011713-0500': {'a': '76',
  'b': '14',
  'c': '99',
  'd': '62',
  'e': '112',
  'f': '78',
  'g': '20',
  'h': '14',
  'i': '23'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>tups = [('a', '76', '20190208011713-0500'),
 ('b', '14', '20190208011713-0500'),
 ('c', '99', '20190208011713-0500'),
 ('d', '62', '20190208011713-0500'),
 ('e', '112', '20190208011713-0500'),
 ('f', '78', '20190208011713-0500'),
 ('g', '20', '20190208011713-0500'),
 ('h', '14', '20190208011713-0500'),
 ('i', '23', '20190208011713-0500')]


def to_dict(tups):
    my_dict = {element[0]: element[1] for element in tups}
    my_dict['timestamp'] = tups[-1][2] 
    return my_dict

m_d = to_dict(tups)
print(m_d) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the simplest way is the following:</p>
<pre><code>return_dict = dict([item[:2] for item in your_list])
return_dict["timestamp"] = your_list[0][2]
</code></pre>
</div>
<span class="comment-copy">Side note: Python 2.7 will reach it's end of life in <a href="https://pythonclock.org/" rel="nofollow noreferrer">10 months time</a>. If this is a new project, you should really be building this in Python 3. My answer below is fully compatible with both Python 2 and 3, so you can take it with you.</span>
<span class="comment-copy">Thanks @Martijn I'll keep that in mind. Yes, I am using python 2.7 for this project and having you said that I will migrate my code to python3 from python2. And your solution works:)</span>
<span class="comment-copy">The above code works fine but only for same timestamp not for different timestamps.</span>
<span class="comment-copy">@akashbachu: which is why the answer starts with <i>If the timestamp is guaranteed to be the same,</i></span>
<span class="comment-copy">@akashbachu: are the timestamps <i>grouped</i> at least? Or do can they appear in any order?</span>
<span class="comment-copy">They appear in random order.</span>
<span class="comment-copy">@akashbachu: right, I've given options for when they are grouped and when they are not.</span>
