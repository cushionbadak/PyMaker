<div class="post-text" itemprop="text">
<p>My program can allocate suddenly a lot of RAM based on usage.
I want to limit the RAM it can take from the system.</p>
<p>I saw here:
<a href="https://stackoverflow.com/questions/41105733/limit-ram-usage-to-python-program">Limit RAM usage to python program</a></p>
<p>But it works only for Unix.
Any solution for Windows?</p>
</div>
<div class="post-text" itemprop="text">
<p>A <a href="https://docs.microsoft.com/en-us/windows/desktop/ProcThread/job-objects" rel="nofollow noreferrer">Job object</a> supports limiting the committed memory of a process. In Python, we can implement this via PyWin32 or ctypes. </p>
<p>Note that prior to Windows 8 a process can only be in a single Job. A couple of common cases where this is a concern include the py.exe launcher (the default association for .py files), which runs python.exe in a Job, and the Task Scheduler service, which runs each task in a Job.</p>
<h2>PyWin32 Example</h2>
<pre><code>import sys
import warnings

import winerror
import win32api
import win32job

g_hjob = None

def create_job(job_name='', breakaway='silent'):
    hjob = win32job.CreateJobObject(None, job_name)
    if breakaway:
        info = win32job.QueryInformationJobObject(hjob,
                    win32job.JobObjectExtendedLimitInformation)
        if breakaway == 'silent':
            info['BasicLimitInformation']['LimitFlags'] |= (
                win32job.JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK)
        else:
            info['BasicLimitInformation']['LimitFlags'] |= (
                win32job.JOB_OBJECT_LIMIT_BREAKAWAY_OK)
        win32job.SetInformationJobObject(hjob,
            win32job.JobObjectExtendedLimitInformation, info)
    return hjob

def assign_job(hjob):
    global g_hjob
    hprocess = win32api.GetCurrentProcess()
    try:
        win32job.AssignProcessToJobObject(hjob, hprocess)
        g_hjob = hjob
    except win32job.error as e:
        if (e.winerror != winerror.ERROR_ACCESS_DENIED or
            sys.getwindowsversion() &gt;= (6, 2) or
            not win32job.IsProcessInJob(hprocess, None)):
            raise
        warnings.warn('The process is already in a job. Nested jobs are not '
            'supported prior to Windows 8.')

def limit_memory(memory_limit):
    if g_hjob is None:
        return
    info = win32job.QueryInformationJobObject(g_hjob,
                win32job.JobObjectExtendedLimitInformation)
    info['ProcessMemoryLimit'] = memory_limit
    info['BasicLimitInformation']['LimitFlags'] |= (
        win32job.JOB_OBJECT_LIMIT_PROCESS_MEMORY)
    win32job.SetInformationJobObject(g_hjob,
        win32job.JobObjectExtendedLimitInformation, info)

def main():
    assign_job(create_job())
    memory_limit = 100 * 1024 * 1024 # 100 MiB
    limit_memory(memory_limit)
    try:
        bytearray(memory_limit)
    except MemoryError:
        print('Success: available memory is limited.')
    else:
        print('Failure: available memory is not limited.')
    return 0

if __name__ == '__main__':
    sys.exit(main())
</code></pre>
</div>
<span class="comment-copy">Tried combining it with resource.RLIM_INFINITY? <a href="https://docs.python.org/3/library/resource.html#resource.RLIM_INFINITY" rel="nofollow noreferrer">docs.python.org/3/library/resource.html#resource.RLIM_INFINITY</a></span>
<span class="comment-copy">Rather than limiting the amount of memory you are able to utilise, I think it better for you to do the actions you want in a more efficient way that is not so consuming on the systems resources. Ramping up hardware is the worst kind of scalability.</span>
<span class="comment-copy">@SharanArumugam As I said, resource is only unix library</span>
<span class="comment-copy">@Swift its other party program I cant control it</span>
<span class="comment-copy">@eryksun how to do it?</span>
