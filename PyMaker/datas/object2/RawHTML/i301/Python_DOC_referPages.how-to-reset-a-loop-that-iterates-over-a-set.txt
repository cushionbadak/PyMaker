<div class="post-text" itemprop="text">
<p>How can I reset a loop that iterates over a set? A common answer for iterating over a list is to reset the index you are using to access the list, however sets do not support indices. </p>
<p>The point is to be able to iterate over a large set of objects, perform some action against each element until a result matches the result I require. The functionality I am searching for is the ability to <em>reset</em> a loop. Meaning restart the iteration from the beginning to ensure I visit every element again for whatever reason. </p>
<p>How can I reset the following loop?</p>
<pre><code>for element in some_set:
   print element
   if element + offset == needed_result:
      # reset
</code></pre>
<p>I'm using python 2.7 for this specific problem, but I'd also welcome python 3 solutions.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to do so would be by using <a href="https://docs.python.org/3/howto/functional.html" rel="nofollow noreferrer">iterators</a>. You could define an iterator by simply calling <code>iter()</code> on your set, and call its <code>next</code> method on each iteration. When the condition is met, you can simply create again the iterator object from the set and repeat the process:</p>
<pre><code>s = {1,2,3,4,5}
s_ = iter(s)
# Just a counter to avoid endless loop
cont = 0
while cont &lt; 10:
    try:
        i = next(s_)
    except StopIteration:
        break
    # Some condition
    if flag == True: 
        # Reset the iterator when the condition is met
        s_ = iter(s) 
        continue
    cont += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would just convert the set to a list and use a while loop:</p>
<pre><code>sett = {'a','b','c','d','e','f','g','h'}
lisst = list(set)

position = 0
while (position &lt;= 8):
   element = lisst[position]
   print element
   if element + offset == needed_result:
        position = 0
   else:
        position += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a neat trick that takes <strong>any kind of iterable</strong> (including sets), and returns an instance of a <code>ReIterable</code> class (our short name for "resettable iterable").</p>
<p>We can then use the re-iterable in a <code>for</code> loop as <code>for r in my_reiterable</code>, just as we would use the original iterable in <code>for i in my_iterable</code>.</p>
<p>Inside the <code>for</code> loop, whenever the conditions are right for re-setting the loop, <strong>we only have to call the <code>reset()</code> method on the re-iterable</strong>.</p>
<p>Here's an example usage with a set <code>s</code> (but it could just as well have been a list or any other iterable):</p>
<pre><code>s = {'a', 'b', 'c', 'd', 'e', 'f'}
r = ReIterable(s)
for i in r:
    print ('In for loop,', i)
    if (i == 'c'):
        resp = str(input('Found "c". Do you want to reset?(y/n):'))
        if (resp == 'y'):
            r.reset()
</code></pre>
<p>Here's the output (Note that the first time the user was prompted to reset, the user responded with a <code>y</code>, causing the set to be iterated all over again. The second time the user was prompted to reset, the user responded with a <code>n</code>, and the loop proceeded without getting reset):</p>
<pre><code>In for loop, e
In for loop, c
Found "c". Do you want to reset?(y/n):y
In for loop, e
In for loop, c
Found "c". Do you want to reset?(y/n):n
In for loop, a
In for loop, d
In for loop, b
In for loop, f
</code></pre>
<p>How does this work? The wrapper class ReIterable makes use of the protocol between a <code>for</code> loop and an iterable.</p>
<p>Here's what the <code>ReIterable</code> class looks like (but you only need to know how to <strong>use</strong> the class, though, as shown above):</p>
<pre><code>class ReIterable:
    def __init__(self,original):
        self.original = original
        self.iterator = iter(original)
        self.reset_flag = False

    def __iter__(self):
        return self

    def __next__(self):
        if (self.reset_flag):
            print ('In __next__(), reset_flag True')
            self.iterator = iter(self.original)
            self.reset_flag = False
        return next(self.iterator)

    def reset(self):
        self.reset_flag = True
</code></pre>
<p><strong>Note:</strong></p>
<p>Besides the fact that it supports the reset operation, the <code>ReIterable</code> class essentially delegates all the iteration work to the original iterable or its iterator. The actual "resetting" involves junking the old iterator and getting a new one (as also in @yatu's answer).</p>
</div>
<span class="comment-copy"><i>"reset the index you are using"</i> - that doesn't work in a <code>for</code> loop either. What's the broader context, the problem you're trying to solve?</span>
<span class="comment-copy">what do you mean by <i>reset</i>? You make <code>break</code> from the loop and start iterating again, but why? Sets are unordered you know i hope</span>
<span class="comment-copy">What do you mean by <code>reset</code>? It's not as if the set is "exhausted", it will always contain the same elements, it's immutable - and unlike lists, it's also unordered.</span>
<span class="comment-copy">@jonrsharpe the broader context is exactly this. I am iterating over an unordered large list, where for each element I must hash the value and compare it to some value until I find a certain value matching the hash, however this is irrelevant. I would like to be able to reset this iteration to begin again at a given condition.</span>
<span class="comment-copy">@Chris_Rands if I am iterating over a set (meaning incrementing the element I am accessing by one), I'd like to reset the iteration and begin the exact same loop at the first element ensuring I can visit every value once.</span>
<span class="comment-copy">Upvoted endless loop - cool .... you are aware that <code>cont</code> is a <code>NameError</code> to be happening and even if not - it will never rise above 1 (if 2 is the 2nd value iterated) .. and still be an endless loop ;)</span>
<span class="comment-copy">Well there is no info on what condition would end the loop. Added a counter so it is more clear that it should break under some condition... but with no further info I'm only guessing here @PatrickArtner</span>
<span class="comment-copy">Might want to wrap that <code>next</code> in a <code>except StopIteration: break</code>.</span>
<span class="comment-copy">An iterator is exactly what would solve my issue. This question does not care for <i>what</i> the reset condition is - only that there will be one. The question is for <i>how</i> to perform the reset on loop of a specific data structure.</span>
<span class="comment-copy">Yes true thanks for the suggestion @DanD.</span>
<span class="comment-copy">sets do not support indices</span>
<span class="comment-copy">I realized that after you made your comment, you need to convert it to a list, see edit</span>
