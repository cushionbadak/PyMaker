<div class="post-text" itemprop="text">
<p>The following is a class which is designed to hold a list, and add to the list any new values that are provided to it (as well as being able to print the list):</p>
<pre><code>class foobar:
    def __init__(self, value=None):
        if type(value) is str:
            self.value = [value]
        else:
            self.value = ['']

    def __iadd__(self, new_value):
        self.value.append(new_value)

    def add(self, new_value):
        self.value.append(new_value)

    def __str__(self):
        return str(self.value)
</code></pre>
<p><em>The function</em> <code>add</code> <em>is only present for testing purposes.</em></p>
<p>This issue that this was presenting was that the two functions of the object, <code>add</code> and <code>__iadd__()</code> did not behave the same. Or so I thought...</p>
<p>In reality, the two functions mentioned above <em>do</em> produce the same result, but <code>add</code> and <code>+=</code> produce different results.</p>
<p>Example run:</p>
<pre><code>&gt;&gt;&gt; testStr = foobar()
&gt;&gt;&gt; testStr
&lt;__main__.foobar instance at 0x00000000034CCE48&gt;
&gt;&gt;&gt; print testStr
['']
&gt;&gt;&gt; testStr.add('val1')
&gt;&gt;&gt; testStr
&lt;__main__.foobar instance at 0x00000000034CCE48&gt;
&gt;&gt;&gt; print testStr
['', 'val1']
&gt;&gt;&gt; testStr.__iadd__('val2')
&gt;&gt;&gt; testStr
&lt;__main__.foobar instance at 0x00000000034CCE48&gt;
&gt;&gt;&gt; print testStr
['', 'val1', 'val2']
&gt;&gt;&gt; testStr += 'val3'
&gt;&gt;&gt; testStr
&gt;&gt;&gt; print testStr
None
</code></pre>
<p>As you can see, the <code>+=</code> operation turns the <code>testStr</code> instance of <code>foobar</code> into a <code>NoneType</code>, thus (obviously) removing the value contained within.</p>
<p>It was my understanding that <code>__iadd__()</code> and the <code>+=</code> operator should behave the same, but it would seem not. Can <code>__iadd__()</code> be implemented here to update the behaviour of <code>+=</code> appropriately here, or is there an issue with this type of operation?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__iadd__</code> must return the updated object (which can be <code>self</code>):</p>
<pre><code>def __iadd__(self, new_value):
    self.value.append(new_value)
    return self
</code></pre>
<p>You didn't return anything, so <code>None</code>, the default return value, was used instead.</p>
<p>From the <a href="https://docs.python.org/3/reference/datamodel.html#object.__iadd__" rel="nofollow noreferrer"><code>__iadd__</code> documentation</a>:</p>
<blockquote>
<p>These methods should attempt to do the operation in-place (modifying <em>self</em>) <strong>and return the result</strong> (which could be, but does not have to be, <em>self</em>). <em>[...]</em>  For instance, if <code>x</code> is an instance of a class with an <code>__iadd__()</code> method, <strong><code>x += y</code> is equivalent to <code>x = x.__iadd__(y)</code></strong>.</p>
</blockquote>
<p>Bold emphasis mine; note the <code>x = x.__iadd__(y)</code> equivalence.</p>
</div>
<span class="comment-copy">On a clarification note, The statement that the operation += is equivalent to __iadd__() suggests to me that they should behave in the same manner. Why, then, would the += function not work despite the __iadd__() function working? I'm thinking that the += operator is calling some other function, which then calls the __iadd__() function, which is why the return is necessary.</span>
<span class="comment-copy">@KieranMoynihan: they do behave in the same manner, but you need to read the documentation and return the correct result. Your <code>__iadd__</code> implementation was incomplete, it returned <code>None</code>, so it wasn't working <i>correctly</i>.</span>
<span class="comment-copy">I understand that my implementation of __iadd__() was not properly done, I simply fail to see how the two can be stated to "behave in the same manner" if the outcome of running the two of them are different.  The conclusion I'm coming to is that += uses the return of __iadd__() to update the object, which makes sense. However, if this is the case, then the two are not the same, as += has additional steps within it that __iadd__() does not take.</span>
<span class="comment-copy">@KieranMoynihan: note that just about <i>all</i> special methods (using the <code>__*__</code> convention) are <i>hooks</i>, called by Python where available, from the operations that do the work. <code>+=</code> is indeed not a direct call to <code>__iadd__</code>, it is implented as a <a href="https://github.com/python/cpython/blob/a24107b04c1277e3c1105f98aff5bfa3a98b33a0/Objects/abstract.c#L1108-L1127" rel="nofollow noreferrer"><code>PyNumber_InPlaceAdd()</code> operation</a>, which also handles inverting the operands to use the <code>x.__add__(y)</code> and  <code>y.__radd__(x)</code> fallbacks.</span>
<span class="comment-copy">Thanks for clearing that up!</span>
