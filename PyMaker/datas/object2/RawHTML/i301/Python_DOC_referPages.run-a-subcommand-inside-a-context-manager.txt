<div class="post-text" itemprop="text">
<p>In the context of a python <code>click</code> CLI application, I would like to run a subcommand inside of a context manager that would be setup in a higher level command. How is it possible to do that with <code>click</code>? My pseudo-code looks something like:</p>
<pre class="lang-py prettyprint-override"><code>
import click

from contextlib import contextmanager

@contextmanager
def database_context(db_url):
    try:
        print(f'setup db connection: {db_url}')
        yield
    finally:
        print('teardown db connection')


@click.group
@click.option('--db',default='local')
def main(db):
    print(f'running command against {db} database')
    db_url = get_db_url(db)
    connection_manager = database_context(db_url)
    # here come the mysterious part that makes all subcommands
    # run inside the connection manager

@main.command
def do_this_thing()
    print('doing this thing')

@main.command
def do_that_thing()
    print('doing that thing')

</code></pre>
<p>And this would be called like:</p>
<pre class="lang-sh prettyprint-override"><code>&gt; that_cli do_that_thing
running command against local database
setup db connection: db://user:pass@localdb:db_name
doing that thing
teardown db connection

&gt; that_cli --db staging do_this_thing
running command against staging database
setup db connection: db://user:pass@123.456.123.789:db_name
doing this thing
teardown db connection
</code></pre>
<p>Edit: note that the above example is forged to better illustrate the missing functionality of <code>click</code>, not that I want to solve this problem in particular. I know I could repeat the same code in all commands and achieve the same effect, which I already do in my real use case. My question is precisely on what could I do <strong>only</strong> in the main function, that would run all transparently subcommands in a context manager.</p>
</div>
<div class="post-text" itemprop="text">
<h3>Decorating commands</h3>
<ol>
<li>Define a context manager <strong>decorator</strong> using <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ContextDecorator" rel="nofollow noreferrer"><code>contextlib.ContextDecorator</code></a></li>
<li>Use <a href="http://click.palletsprojects.com/en/7.x/commands/#nested-handling-and-contexts" rel="nofollow noreferrer"><code>click.pass_context</code></a> decorator on <code>main()</code>, so you can explore click context</li>
<li>Create an instance <code>db_context</code> of the context manager</li>
<li>Iterate on commands defined for group <code>main</code> using <code>ctx.command.commands</code></li>
<li>For each command, replace the original callback (function called by the command) with the same callback decorated with the context manager <code>db_context(cmd)</code></li>
</ol>
<p>This way you will programmatically modify each command to behave just like:</p>
<pre><code>@main.command()
@db_context
def do_this_thing():
    print('doing this thing')
</code></pre>
<p>But without requiring to change your code beyond your function <code>main()</code>.</p>
<p>See the code below for a working example:</p>
<pre><code>import click
from contextlib import ContextDecorator


class Database_context(ContextDecorator):
    """Decorator context manager."""

    def __init__(self, db_url):
        self.db_url = db_url

    def __enter__(self):
        print(f'setup db connection: {self.db_url}')

    def __exit__(self, type, value, traceback):
        print('teardown db connection')


@click.group() 
@click.option('--db', default='local')
@click.pass_context
def main(ctx, db):

    print(f'running command against {db} database')
    db_url = db  # get_db_url(db)

# here come the mysterious part that makes all subcommands
# run inside the connection manager

    db_context = Database_context(db_url)           # Init context manager decorator
    for name, cmd in ctx.command.commands.items():  # Iterate over main.commands
        cmd.allow_extra_args = True                 # Seems to be required, not sure why
        cmd.callback = db_context(cmd.callback)     # Decorate command callback with context manager


@main.command()
def do_this_thing():
    print('doing this thing')


@main.command()
def do_that_thing():
    print('doing that thing')


if __name__ == "__main__":
    main()
</code></pre>
<p>It does what you describe in your question, hope it will work as expected in real code.</p>
<hr/>
<h3>Using <a href="https://click.palletsprojects.com/en/7.x/commands/#nested-handling-and-contexts)." rel="nofollow noreferrer"><code>click.pass_context</code></a></h3>
<p>This code below will give you an idea of how to do it using <code>click.pass_context</code>.</p>
<pre><code>import click
from contextlib import contextmanager

@contextmanager
def database_context(db_url):
    try:
        print(f'setup db connection: {db_url}')
        yield
    finally:
        print('teardown db connection')


@click.group()
@click.option('--db',default='local')
@click.pass_context
def main(ctx, db):
    ctx.ensure_object(dict)
    print(f'running command against {db} database')
    db_url = db #get_db_url(db)
    # Initiate context manager
    ctx.obj['context'] = database_context(db_url)

@main.command()
@click.pass_context
def do_this_thing(ctx):
    with ctx.obj['context']:
        print('doing this thing')

@main.command()
@click.pass_context
def do_that_thing(ctx):
    with ctx.obj['context']:
        print('doing that thing')

if __name__ == "__main__":
    main(obj={})
</code></pre>
<p>Another solution to avoid explicit <code>with</code> statement could be passing the context manager as a decorator using <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ContextDecorator" rel="nofollow noreferrer"><code>contextlib.ContextDecorator</code></a>, but it would likely be more complex to setup with <code>click</code>.</p>
</div>
<span class="comment-copy">Context mangers where designed to operate in conjuction with Python's <a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer"><code>with</code></a> statement, but you're not using one to wrap a block of code (so it doesn't work).</span>
<span class="comment-copy">I know, that's the root of the problem. By the nature of the click framework, there is no place in the <code>main</code> command where a subcommand is explicitely called. The call is done by the framework, depriving me of the possibility to use the context manager in a <code>with</code> statement.</span>
<span class="comment-copy">How would you like the sub commands to access <code>db</code>?  Passed into the sub commands or available through some sort of global?</span>
<span class="comment-copy">@StephenRauch through a global DB object, that only works correctly inside an application and database context.</span>
<span class="comment-copy">Thank you for your answer, but using the context manager in every sub-command is exactly the goal of the whole thing. My real use-case is to have many commands doing things with the database in a transparent way, and using the context manager only once in the main command.</span>
<span class="comment-copy">Not sure it can be done, at least not if you create a context in the local scope of main(), because you will exit this context before executing the command. Maybe click is not the way to go to achieve this?</span>
<span class="comment-copy">@AntoineGallix Finally found how to proceed! This problem ate me all day, took me a while to figure how to properly and simply modify how the commands are called. This is definitely more a hack than a best practice, but it works.</span>
<span class="comment-copy">Great solution! I was hoping for a dedicated feature of click, but apparently it doesn't exist, so your solution fill this gap. Thanks.</span>
