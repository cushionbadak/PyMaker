<div class="post-text" itemprop="text">
<p>I have functions using glob to identify files for removal. In the first function, the recursive toggle works as intended. In the second function, the recursive toggle is somewhat working... Here's a sample of my code below.</p>
<pre><code>for item in glob.glob(myfile_path + '/**', recursive=self.recrsv.get()):
    if item.endswith(".mesg"):
        os.remove(os.path.join(myfile_path, item))
</code></pre>
<p>This function works as intended.</p>
<pre><code>for junk in glob.glob(myfile_path + '/**' + "/*.*[0-9][0-9][0-9][0-9]", recursive=self.recrsv.get()):
    os.remove(os.path.join(myfile_path, junk))
</code></pre>
<p>This function somewhat works. Whether <code>recursive</code> is set to <code>True</code> or <code>False</code>, it still goes into the first level of subdirectories and deletes files <code>*.*[0-9][0-9][0-9][0-9]</code> . It does <em>not</em> go into the second level of subdirectories unless <code>recursive</code> is set to <code>True</code>.</p>
<p>Note: Recursive is set to a <code>tk.BooleanVar()</code> named <code>self.recrsv</code> used in a Checkbutton in a tkinter widget.</p>
<p>Thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>With <code>recursive=False</code>,</p>
<pre><code>myfile_path + '/**' + "/*.*[0-9][0-9][0-9][0-9]"
</code></pre>
<p>is equivalent to</p>
<pre><code>myfile_path + '/*' + "/*.*[0-9][0-9][0-9][0-9]"
</code></pre>
<p>or</p>
<pre><code>myfile_path + '/*/*.*[0-9][0-9][0-9][0-9]"
</code></pre>
<p>However, even with <code>recursive=False</code>, this pattern <em>explicitly says</em> to search through subdirectories of <code>myfile_path</code>, not through the contents of <code>myfile_path</code> itself. A pattern saying to search through <code>myfile_path</code> would be</p>
<pre><code>myfile_path + '/*.*[0-9][0-9][0-9][0-9]"
</code></pre>
<p>(Also, building a glob this way is dangerous, because <code>myfile_path</code> could contain glob metacharacters. Remember to use <code>glob.escape</code> on components you want to match literally, or pick a search mechanism that doesn't need escaping.)</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/glob.html" rel="nofollow noreferrer">https://docs.python.org/3/library/glob.html</a></p>
<p>"If recursive is true, the pattern “**” will match any files and zero or more directories and subdirectories. If the pattern is followed by an os.sep, only directories and subdirectories match."</p>
<p>So <code>**</code> in <code>&lt;myfile_path&gt;/**/*.*[0-9][0-9][0-9][0-9]</code> matches exactly one level of subdirectories when recursive is set to false. Because <code>/</code> is <code>os.sep</code> I assume.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've made a workaround for my issue using an if-statement and repeating the glob under it.</p>
<pre><code>    for junk in glob.glob(myfile_path + "/*.*[0-9][0-9][0-9][0-9]"):
        os.remove(os.path.join(myfile_path, junk))

    #The above code will delete the specified junk file within myfile_path.

    if self.recrsv.get()==1:
        for junk in glob.glob(myfile_path + '/**' + "/*.*[0-9][0-9][0-9][0-9]",
                              recursive=self.recrsv.get()):
            os.remove(os.path.join(myfile_path, junk)

    #The above code checks the recursive variable, and if true, will recursively delete the junk files.
</code></pre>
<p>If I do not use the if-statement and simply rely on glob's own recursive check, the junk file will be removed from the first level of subdirectories even if <code>recursive=False</code>.</p>
<p>I can probably clean up the code some more to be a bit more if-statement-intuitive, but the problem has been solved. Thank you, @Szellem and @user2357112 for your efforts.</p>
</div>
<span class="comment-copy"><code>myfile_path + "/*.*[0-9][0-9][0-9][0-9]"</code> fails to search subdirectories for files that end in the specified extension. It's perfect for the files within <code>myfile_path</code>, but not the subdirectories (which is my objective).</span>
<span class="comment-copy">@K.Hess: ...then why did you say that <code>myfile_path + '/**' + "/*.*[0-9][0-9][0-9][0-9]"</code> "somewhat works"? What do you not like about its behavior? Your question definitely <i>sounded</i> like you wanted to stop searching subdirectories.</span>
<span class="comment-copy">I should have clarified, "somewhat works" is stating that the method works on subdirectories 2 levels down and more (myfile_path/dir1/dir2); however, on the immediate subdirectory (myfile_path/dir1), the specified files are deleted regardless of recursive being set to True or False.</span>
<span class="comment-copy">@K.Hess: Are you looking for a single glob pattern that will do a recursive search with <code>recursive=True</code>, but only search through <code>myfile_path</code> with <code>recursive=False</code>? I don't think that's possible.</span>
<span class="comment-copy">That is correct. It is successfully working on the first for-statement beginning with <code>for item</code>. Files with extension <code>.mesg</code> are properly deleted only in <code>myfile_path</code>, and are deleted in subdirectories when I set <code>recursive</code> to <code>True</code>. However, the nastier extension I'm trying to delete changes in sequential order. <code>.e8754</code>, <code>.o8755</code> for example, so I need to get a little more creative in searching it out.</span>
<span class="comment-copy">This doesn't seem to hold true for the first for-statement (the <code>for item</code> statement). Files with the extension <code>.mesg</code> are deleted in subdirectories only if I set <code>recursive</code> to <code>True</code>. Otherwise, the <code>'/**'</code> seems to be ignored.</span>
<span class="comment-copy">Of course, because in that case <code>**</code> is not followed by a path separator so it matches files, but in the second case it is followed by a path separator so it doesn't match files that are not directories.</span>
<span class="comment-copy">So if you want them to work the same way, either add one more <code>/**</code> to the first one or remove <code>/**</code> from the second one.</span>
<span class="comment-copy">At the risk of sounding dumb, can I ask you to avoid pronouns "first one, second one"? Per your suggestion (I think), I changed the script to <code>for junk in glob.glob(myfile_path + '/**' + "/**/*.*[0-9][0-9][0-9][0-9]", recursive=self.recrsv.get()):             os.remove(os.path.join(myfile_path, junk))</code>. This leads to an odd case where, if recursive is false, the specified file is removed from myfile_path\dir1\dir2, and if recursive is true, the specified file is removed from myfile_path and myfile_path\dir1.</span>
<span class="comment-copy">If recursive is false, the two <code>**/**/</code> will match exactly two levels of subdirectories. If recursive is true, then they can match zero levels which means the files that are directly in <code>myfile_path</code> are matched. Btw I meant this with my comment: <code>for junk in glob.glob(myfile_path + "*.*[0-9][0-9][0-9][0-9]", recursive=self.recrsv.get()): os.remove(os.path.join(myfile_path, junk))</code>  But now I'm starting to understand your problem, because this won't match subdirectories even if recursive is set to true.</span>
