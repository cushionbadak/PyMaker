<div class="post-text" itemprop="text">
<p>I need to generate all combinations of a matrix in Python. The input will be two integers n and m, and I need to generate all possible states of that matrix with 1 and 0 as possible values.</p>
<p>For example:</p>
<pre><code>n = 3 m = 2
[[0 0 0] [1 0 0] [1 1 0]
 [0 0 0] [0 0 0] [0 0 0]
 [0 0 0],[0 0 0],[0 0 0] . . . . .
]
</code></pre>
<p>Is there a clean and efficient way to do this given I will not know the values for n and m until runtime? The highest value used will be n = 16  m = 16.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way is by generating all binary sequences of length <code>m*n</code> in a list comprehension, and reshaping them into a <code>(m,n)</code> shaped nested list on each iteration. </p>
<p>A simple way to generate all sequences is by taking the cartesian product of <code>01</code> with <code>n*m</code> repeats, which will be produce <code>2^(m*n)</code> combinations:</p>
<pre><code>from itertools import product
m=3
n=3

x = [[list(i[x:x+m]) for x in range(0, len(i), m)] for i in product("01", repeat=m*n)]
</code></pre>
<p><b> Output </b></p>
<pre><code>[[['0' '0' '0']
  ['0' '0' '0']
  ['0' '0' '0']]

 [['0' '0' '0']
  ['0' '0' '0']
  ['0' '0' '1']]

 [['0' '0' '0']
  ['0' '0' '0']
  ['0' '1' '0']]
 ...

print(len(x))
# 512
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want all matrices at once, just produce flat lists using <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> and <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html" rel="nofollow noreferrer"><code>numpy.reshape</code></a> them:</p>
<pre><code>from itertools import product
import numpy as np

n, m = 2, 2

x = product([1, 0], repeat=n*m)
x = np.reshape(list(x), (-1, n, m))
print(x)
</code></pre>
<p>With the output for 2x2:</p>
<pre><code>array([[[1, 1],
        [1, 1]],

       [[1, 1],
        [1, 0]],

       [[1, 1],
        [0, 1]],

       [[1, 1],
        [0, 0]],

       [[1, 0],
        [1, 1]],

       [[1, 0],
        [1, 0]],

       [[1, 0],
        [0, 1]],

       [[1, 0],
        [0, 0]],

       [[0, 1],
        [1, 1]],

       [[0, 1],
        [1, 0]],

       [[0, 1],
        [0, 1]],

       [[0, 1],
        [0, 0]],

       [[0, 0],
        [1, 1]],

       [[0, 0],
        [1, 0]],

       [[0, 0],
        [0, 1]],

       [[0, 0],
        [0, 0]]])
</code></pre>
<hr/>
<p>Note that for <code>n, m = 16, 16</code> there are <code>2**(16*16)</code> combinations, which is about <code>10**77</code>, so much too large to fit into memory. In that case you probably have to process each matrix on its own:</p>
<pre><code>def get_combinations(n, m):
    for flat in product([1, 0], repeat=n*m):
        yield np.reshape(flat, (n, m))
</code></pre>
<p>Which you can use like this:</p>
<pre><code>from itertools import islice

for m in islice(get_combinations(3, 3), 3):  # only get the first three
    print(m)

[[1 1 1]
 [1 1 1]
 [1 1 1]]
[[1 1 1]
 [1 1 1]
 [1 1 0]]
[[1 1 1]
 [1 1 1]
 [1 0 1]]
</code></pre>
</div>
<span class="comment-copy">There will be 2^(nm) outputs. There is no faster way then to enumerate every single one of them. Also, what have you tried?</span>
<span class="comment-copy">it may be worth asking whether you need those matrices, or if they are some intermediate state to something else. if the latter, you can optimise it in that way</span>
<span class="comment-copy">Sorry yes the integers are the rows and columns. Until now I knew the values before runtime so was simply using two nested loops but this isn't feasible anymore</span>
<span class="comment-copy">@yatu: Fixed using <code>itertools.product</code> like you, but still using <code>numpy.reshape</code> instead of multiple calls to <code>numpy.array</code> and <code>numpy.array_split</code>.</span>
<span class="comment-copy">Ended up going with a non-numpy solution, nice one @Graipher +1</span>
