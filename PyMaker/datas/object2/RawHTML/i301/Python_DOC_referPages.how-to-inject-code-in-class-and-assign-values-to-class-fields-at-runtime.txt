<div class="post-text" itemprop="text">
<p>I have a BatchJob specification file (batch.spec) something like below:</p>
<pre><code>python = &lt;&lt;EOF

def foo():
    return f"foo: I am {self.name}"

def bar():
    return f"bar: I am {self.name}"

EOF

&lt;batch&gt;
  name p&amp;l_calculator
  exec echo %foo()%
&lt;/batch&gt;
</code></pre>
<p>I am converting this file to a python dict by using <a href="https://github.com/etingof/apacheconfig" rel="nofollow noreferrer">https://github.com/etingof/apacheconfig</a> </p>
<pre><code>from apacheconfig import *

with make_loader() as loader:
    config = loader.load('batch.spec')

# Print content of python dict
for key, value in config.items():
    print(key, value)

# output from print statement above
# python 
# def foo():
#     return f"foo: I am {self.name}"
#
# def bar():
#     return f"bar: I am {self.name}"
# batch {'name': 'p&amp;l_calculator', 'exec': 'echo %foo()%'}
</code></pre>
<p>Now I am converting this python dict to a BatchJobSpec object like below:</p>
<pre><code>class BatchJobSpec:

    def __init__(self, pythoncode , batch):
        self.pythoncode = pythoncode
        self.name = batch.get("name")
        self.exec = batch.get("exec")

batchjobspec = BatchJobSpec(config.get("python"), config.get("batch"))
</code></pre>
<p>If I print batchjobspec fields, then I will get something like below</p>
<pre><code>print(batchjobspec.pythoncode)
print(batchjobspec.name)
print(batchjobspec.exec) 

# Output from above print statements
# def foo():
#     return f"foo: I am {self.name}"
#
# def bar():
#     return f"bar: I am {self.name}"
# p&amp;l_calculator
# echo %foo()%
</code></pre>
<p><strong>Problem:</strong> I want the value of "batchjobspec.exec" to be interpolated when I try to access it, i.e. it should not be "echo %foo()%" but it should be "echo foo: I am p&amp;l_calculator". </p>
<p>i.e. somehow in the getter of fields, I want to check if there is "% %" syntax. If yes, and if content inside "% %" contains a callable then I want to call that callable and append the value returned from callable to the value of the corresponding field. I guess I will have to make these callables available in the BatchJobSpec dict as well. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Comment</strong>:  I have foo as well as bar. exec(str) will execute both</p>
</blockquote>
<p>In your <code>self.pythoncode</code> you have definitons of functions like <code>def foo():</code>. Therefore <code>exec</code> doesn't <strong>execute</strong> but do <strong>define</strong> these functions in the local namespace. To <strong>execute</strong> these functions as a <code>class methode</code>, you have to create a <code>attribute</code>, referencing these local functions, in the <code>class</code> itself.</p>
<ol>
<li><p>In this example, the function names are known beforhand</p>
<pre><code>class BatchJobSpec:
    def __init__(self, pythoncode , batch):
        self.pythoncode = pythoncode
        self.name = batch['name']
        self._exec = ['for', 'bar']
        self.exec()
</code></pre></li>
<li><p>To make <code>self</code> visible in the local namespace, define the <code>locals_</code> dict.<br/>
<code>exec</code> the string <code>self.pythoncode</code> results in insert the reference to the functions into <code>locals_</code>. To use these local references, as a <code>class methode</code> and make it persistent, use <code>self.__setattr__(...</code>.</p>
<pre><code>    def exec(self):
        locals_ = {'self': self}
        exec(self.pythoncode, locals_)
        for attrib in self._exec:
            print('__setattr__({})'.format(attrib))
            self.__setattr__(attrib, locals_[attrib])
</code></pre></li>
<li><p><strong>Usage</strong>: Different python <code>format</code> syntax, as i using python 3.5</p>
<pre><code>python = """
def foo():
    return 'foo: I am {name}'.format(name=self.name)

def bar():
    return 'bar: I am {name}'.format(name=self.name)
"""

if __name__ == "__main__":
    batchjobspec = BatchJobSpec(config.get("python"), config.get("batch"))
    print('echo {}'.format(batchjobspec.foo()))
    print('echo {}'.format(batchjobspec.bar()))
</code></pre></li>
<li><blockquote>
<p><strong>Output</strong>:</p>
<pre><code>__setattr__(foo)
__setattr__(bar)
echo foo: I am p&amp;l_calculator
echo bar: I am p&amp;l_calculator
</code></pre>
</blockquote></li>
</ol>
<hr/>
<blockquote>
<p><strong>Question</strong>  I want the value of "batchjobspec.exec" to be interpolated when I try to access it</p>
</blockquote>
<ul>
<li><a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer">library/functions - <code>exec</code></a> </li>
<li><a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer"><code>object.__setattr__</code></a> </li>
</ul>
<hr/>
<p>Change your <code>class BatchJobSpec</code> to:</p>
<pre><code>class BatchJobSpec:

    def __init__(self, pythoncode , batch):
        self.pythoncode = pythoncode
        self.name = batch.get("name")
        self._exec = batch.get("exec")

    @property
    def exec(self):
        to_exec = 'foo'
        self.__setattr__(to_exec, lambda : exec('print("Hello world")'))

        self.foo()
        return None
</code></pre>
</div>
<span class="comment-copy">Looks like a simple <code>string.replace('%...%', name)</code></span>
<span class="comment-copy">@stovfl yes replacement part is simple but the callable (function foo and bar in the example above) won't be available directly in the BatchJobSpec class dict. Callables are present as formatted string inside field "pythoncode".</span>
<span class="comment-copy">Thanks for the answer but please note that the functions "foo" and "bar" are not present in the class. They are inside field "self.pythoncode", how can I get these functions injected to the class? Do I need to add setter for pythoncode field and update class dict from there?</span>
<span class="comment-copy">foo is already there in the self.pythoncode, I dont want to create any new foo.</span>
<span class="comment-copy">@LokeshAgrawal: <b>No</b>, in the <code>.pythoncode</code> is a <code>str</code>, the created <code>self.foo</code> is a reference to this string executed thru <code>exec(&lt;code&gt;)</code></span>
<span class="comment-copy">exec will execute all the code in the str. There can be many functions in str. As an example check in my question I have foo as well as bar. exec(str) will execute both.</span>
<span class="comment-copy">Can you please generalize this solution, without assuming that there will be only foo and bar functions.</span>
