<div class="post-text" itemprop="text">
<p>I have a Python class as follows:</p>
<pre><code>class Base:
    def __init__(self, response=20):
        self.response = response

    def func1(self):
       self.response = 10

    def func2(self):
        self.response = 20

    def func3(self):
        self.response = 30
</code></pre>
<p>Every time the value of response changes, I need it to be captured. So I defined a <code>__setattr__</code> method as follows:</p>
<pre><code>class Base:
    def __init__(self, response=20):
        self.response = response

    def __setattr__(self, name, value):
        if name == 'response':
            print('{} is set to {}'.format(name, value))

    def func1(self):
       self.response = 10

    def func2(self):
        self.response = 20

    def func3(self):
        self.response = 30
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>=============================================================
In [10]: a = Base()
response is set to 20

In [11]: a.func1()
response is set to 10

In [12]: a.func2()
response is set to 20
</code></pre>
<p>Works really well.</p>
<p>Now I introduced one more class attribute whose value is initialized by a dictionary lookup as follows:</p>
<pre><code>my_dict = {20:'key1'}

class Base:
    def __init__(self, response=20):
        self.response = response
        self.key = getattr(my_dict,self.response).value

    def __setattr__(self, name, value):
        if name == 'response':
            print('{} is set to {}'.format(name, value))

    def func1(self):
        self.response = 10

    def func2(self):
        self.response = 20

    def func3(self):
        self.response = 30
</code></pre>
<p>This gives an error stating:</p>
<pre class="lang-none prettyprint-override"><code> ----&gt; 6         self.key = getattr(my_dict,self.response)
AttributeError: 'Base' object has no attribute 'response'
</code></pre>
<p>What am I doing wrong.Also if I remove the <code>__setattr__</code> method, the <code>getattr</code> starts working. What is the issue here?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should call the parent implementation of __setattr__ to actually create the attribute:</p>
<pre><code>def __setattr__(self, name, value):
    if name == 'response':
        print('{} is set to {}'.format(name, value))
    super.__setattr__(self,name,value)
</code></pre>
<p>Also if you want the value associated with dictionary's key use :</p>
<pre><code>self.key = my_dict.get(self.response)
</code></pre>
<p>You can find more details by looking at the official documentation <a href="https://docs.python.org/3/reference/datamodel.html?highlight=setattr#object.__setattr__" rel="nofollow noreferrer">here(3.7)</a>
and <a href="https://docs.python.org/2.7/reference/datamodel.html?highlight=setattr#object.__setattr__" rel="nofollow noreferrer">here(2.7)</a></p>
</div>
<span class="comment-copy">Why not simply make it a property?</span>
<span class="comment-copy">how would i do that ?</span>
<span class="comment-copy"><code>my_dict = {20:'key1'}</code> has no attr <code>20</code> it is really so, it has key <code>20</code>.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/17330160/how-does-the-property-decorator-work" title="how does the property decorator work">stackoverflow.com/questions/17330160/…</a></span>
<span class="comment-copy">You never actually set any attributes. Your instances doesn't have a response attribute, you've intercepted that and simply printed a message. So <code>getattr(my_dict,self.response)</code> will fail, since <code>self.response</code> does not exist. Even if it <i>did</i>, you will fail with <code>getattr(my_dict, 20)</code>, since your dict doesn't have an attribute <code>20</code> (that's not really a valid attribute to access, so it just fails with a type error, since the argument to <code>setattr</code> and <code>getattr</code> must be <code>str</code> objects)</span>
<span class="comment-copy">Pycharm gives this warning..Passing Base instead of super. Is this intentional? less... (⌘F1)  Inspection info: This inspection checks for calls of a method by class while passing an instance of a different class as self parameter:   foo = Foo()   Bar.baz(foo, *more) Sometimes this may be intentional and correct. But when unintentional, this leads to subtle bugs.   Is this fine ?</span>
