<div class="post-text" itemprop="text">
<p>I am writing test cases for JSON endpoints in a Flask app.</p>
<pre><code>import unittest
from flask import json
from app import create_app


class TestFooBar(unittest.TestCase):
    def setUp(self):
        self.app = create_app('testing')
        self.app_context = self.app.app_context()
        self.app_context.push()

    def test_ham(self):
        resp = self.client.post('/endpoint',
                                headers={'Content-Type': 'application/json'},
                                data=json.dumps({'foo': 2,
                                                 'bar': 3}))
        assert resp.status_code == 200

    def test_eggs(self):
        resp = self.client.post('/endpoint', data={'foo': 5,
                                                   'bar': 7})
        assert resp.status_code == 200

    def test_ham_and_eggs(self):
        with self.app.test_client() as self.client:
            self.test_ham()
            self.test_eggs()
</code></pre>
<p>Just to understand what's happening, do both ways of sending a <code>POST</code> message in the code above make sense? In particular, am I double-JSON encoding in the first case?</p>
<p>Or, briefly, what is the difference between <code>test_ham</code> and <code>test_eggs</code>? Is there any?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are not double-encoding JSON, no, because <code>data</code> doesn't encode anything to JSON. <code>test_ham</code> posts JSON, <code>test_eggs</code> does not.</p>
<p>Starting from Flask 1.0, the Flask test client supports posting JSON directly, via the <code>json</code> keyword argument, use it to cut down on boilerplate code here:</p>
<pre><code>def test_ham(self):
    resp = self.client.post('/endpoint', json={'foo': 2, 'bar': 3})
    assert resp.status_code == 200
</code></pre>
<p>See the <a href="http://flask.pocoo.org/docs/1.0/testing/#testing-json-apis" rel="nofollow noreferrer"><em>Testing JSON APIs</em> section</a> of the Flask <em>Testing</em> documentation chapter:</p>
<blockquote>
<p>Passing the <code>json</code> argument in the test client methods sets the request data to the JSON-serialized object and sets the content type to <code>application/json</code>.</p>
</blockquote>
<p>Passing a dictionary to <code>data</code> produces a different kind of request, a <code>application/x-www-form-urlencoded</code> encoded request just like a <code>&lt;form method="POST" ...&gt;</code> form would produce from your browser, and the <code>foo</code> and <code>bar</code> values would have to be accessed via the <a href="http://flask.pocoo.org/docs/1.0/api/#flask.Request.form" rel="nofollow noreferrer"><code>request.form</code> object</a>. Do not use it when posting JSON is needed.</p>
</div>
<span class="comment-copy">Please stick to <b>one question per post</b>. <code>json.dump()</code> and <code>json.dumps()</code> are documented clearly in the <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">module documentation</a>, one writes the result to a file, the other returns the encoded JSON data to the caller.</span>
<span class="comment-copy">The <code>get_json()</code> warning indicates you are using <code>request.json</code> somewhere in your Flask app, and the warning tells you to use <code>request.get_json()</code> instead. See <a href="//stackoverflow.com/a/20001283">How to get POSTed json in Flask?</a></span>
<span class="comment-copy">If you want to see where you are using <code>request.json</code>, you can turn the warning into an exception by running Flask with <code>PYTHONWARNINGS=error</code>.</span>
