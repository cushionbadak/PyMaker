<div class="post-text" itemprop="text">
<p>I have the following C code which I would use from a python script. </p>
<p>This is just an excerpt of an auto-generated huge library which I'm not able to change, unfortunately. Here I just wanted to print the structure elements to a console to demonstrate what is going wrong.</p>
<pre class="lang-cpp prettyprint-override"><code>
// CFunc.h
#include &lt;stdio.h&gt;

typedef struct
{
    int npar;
    struct
    {
        int id;
        int value;
    } params[10];
} Data_t;

void Cfunc( const Data_t * d);


// CFunc.c

#include "CFunc.h"

void Cfunc( const Data_t * d)
{
    int inpar = 0;
    int maxnpar = 0;

    printf("%d:\n", d-&gt;npar);
    maxnpar = d-&gt;npar;

    inpar=0;
    while (maxnpar &gt; inpar)
    {
        printf("  %d: %08x %08x\n", inpar, d-&gt;params[inpar].id, *(int*)&amp;d-&gt;params[inpar].value);
        inpar++;
    }
}
</code></pre>
<p>It is compiled and linked to a share library with:</p>
<blockquote>
<p>gcc -fPIC -c CFunc.c -o CFunc.o<br/>
  gcc -shared -lrt -Wl,-soname,libCFunc.so.1 -o libCFunc.so CFunc.o</p>
</blockquote>
<p>So I did the following implementation using ctypes:</p>
<pre class="lang-python prettyprint-override"><code>from ctypes import *

lib = CDLL('./libCFunc.so')


class Data_2(Structure):
    pass
class Data_t(Structure):
    def __init__(self, list):
        self.npar = len(list)
        self.params = (Data_2 * self.npar)(*list)

Data_2._fields_ = [
    ('id', c_int),
    ('value', c_int),
]
Data_t._fields_ = [
    ('npar', c_int),
    ('params', POINTER(Data_2)),
]

def pyFunc(d):
    lib.Cfunc.argtypes = (POINTER(Data_t),)

    lib.Cfunc(byref(d))

    return
</code></pre>
<p>So I'm initializing the structure out of a list of given tuples, in this case just 2 and calling the C-function to see its output.</p>
<pre class="lang-python prettyprint-override"><code>paramlist = ( 
    ( 0x050000000, 0x00000000 ),  
    ( 0x050000001, 0x447a0000 ) )
temp = Data_t(paramlist)

pyFunc(temp)
</code></pre>
<p>Unfortunately the output is not as expected:</p>
<blockquote>
<p>2:<br/>
    0: 00000000 79948ef0<br/>
    1: 00007fe5 00000000  </p>
</blockquote>
<p>Any thoughts what I am missing ?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer">[Python 3]: ctypes - A foreign function library for Python</a>.</p>
<ul>
<li>The structs from <em>C</em> and <em>Python</em> don't match

<ul>
<li><em>params</em> is <strong>an <em>array</em> not a <em>pointer</em></strong></li>
</ul></li>
<li>Because of the above inconsistency, you overcomplicated things in <em>Python</em>:

<ul>
<li>You don't have incomplete types, so your structures can be statically defined</li>
</ul></li>
</ul>
<p>I restructured your code a bit.</p>
<p><em>dll.h</em>:</p>
<pre class="lang-c prettyprint-override"><code>#pragma once


typedef struct Data_ {
    int npar;
    struct
    {
        int id;
        int value;
    } params[10];
} Data;


void test(const Data *d);
</code></pre>
<p><em>dll.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include "dll.h"
#include &lt;stdio.h&gt;


void test(const Data *d) {
    int inpar = 0;
    int maxnpar = 0;

    printf("%d:\n", d-&gt;npar);
    maxnpar = d-&gt;npar;

    inpar = 0;
    while (inpar &lt; maxnpar)
    {
        printf("  %d: %08x %08x\n", inpar, d-&gt;params[inpar].id, *(int*)&amp;d-&gt;params[inpar].value);
        inpar++;
    }
}
</code></pre>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import ctypes


DLL = "./libdll.so"


class DataInner(ctypes.Structure):
    _fields_ = [
        ("id", ctypes.c_int),
        ("value", ctypes.c_int),
    ]


DataInnerArr10 = DataInner * 10


class Data(ctypes.Structure):
    _fields_ = [
        ("npar", ctypes.c_int),
        ("params", DataInnerArr10),
    ]

    def __init__(self, data):
        self.npar = len(data)
        self.params = DataInnerArr10(*data)


def main():
    dll_dll = ctypes.CDLL(DLL)
    test_func = dll_dll.test
    test_func.argtypes = [ctypes.POINTER(Data)]

    param_list = (
        (0x050000000, 0x00000000),
        (0x050000001, 0x447a0000),
    )

    d = Data(param_list)

    test_func(ctypes.byref(d))
    print("Done.")


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre class="lang-c prettyprint-override"><code>[cfati@cfati-5510-0:/cygdrive/e/Work/Dev/StackOverflow/q054888242]&gt; ls
code.py  dll.c  dll.h
[cfati@cfati-5510-0:/cygdrive/e/Work/Dev/StackOverflow/q054888242]&gt; gcc -shared -fPIC -o libdll.so dll.c
[cfati@cfati-5510-0:/cygdrive/e/Work/Dev/StackOverflow/q054888242]&gt; ls
code.py  dll.c  dll.h  libdll.so
[cfati@cfati-5510-0:/cygdrive/e/Work/Dev/StackOverflow/q054888242]&gt; python3 code.py
Python 3.6.4 (default, Jan  7 2018, 15:53:53)
[GCC 6.4.0] on cygwin

2:
  0: 50000000 00000000
  1: 50000001 447a0000
Done.
</code></pre>
</blockquote>
</div>
<span class="comment-copy">regarding: <code>typedef struct {     int npar;     struct     {         int id;         int value;     } params[10]; } Data_t;</code>  1) always use a 'tag' name on every struct as that is what most debuggers use to be able to access the individual fields in the struct.  2) for flexibility, separate the definition if the struct from the <code>typedef</code> for the struct</span>
<span class="comment-copy">The code I posted is just an example of a more complex library and your concerns are covered... Thank you for that remark.</span>
<span class="comment-copy">Many thanks, that works! I was persuaded, that array initialisation is done similar to <code>self.params = (Data_2 * self.npar)(*list)</code> ... at least that was my understanding cross-reading on SE. I also completely missed that <code>self.params</code> needs to be of fixed element size and cannot be initialised dynamically using <code>...* self.npar</code>. Of course, I had also <code>self.params = Data_2 * self.npar(*list)</code> in my mind which however is not legal syntax. Would you mind elaborate on the differences to <code>DataInnerArr10 = DataInner * 10</code> + <code>self.params = DataInnerArr10(*data)</code> ? That's still not clear to me :-/</span>
<span class="comment-copy">Youi're welvome! <i>DataInnerArr10</i> (as its name suggests) is a <b>type</b>, an array of 10 <i>DataInne</i> structures. When doubt always use <i>print</i> (<code>print(type(DataInnerArr10), dir(DataInnerArr10))</code>). The second is the initializer, it's a <i>tuple unpacking</i>: basically it passes 2 values tuples from the main matrix (2D) to <i>DataInner</i> constructor in order to initialize its 2 members.</span>
