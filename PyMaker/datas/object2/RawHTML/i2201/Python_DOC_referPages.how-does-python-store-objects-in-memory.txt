<div class="post-text" itemprop="text">
<p>It is my understanding that a list is a block of contiguous memory locations that contain pointers to the element values in memory. As shown below: </p>
<p><a href="https://i.stack.imgur.com/ID5E8.png" rel="nofollow noreferrer"><img alt="list in memory" src="https://i.stack.imgur.com/ID5E8.png"/></a></p>
<p>My question is whether its the same with objects in memory ie: 
suppose I have a point class with an init method implemented as follows: </p>
<pre><code>class Point: 
    def __init__(self, x, y): 
        self.x = x
        self.y = y
</code></pre>
<p>And I create a new point object:</p>
<pre><code>p = Point(4,6)
</code></pre>
<p>Would the pointer to <code>p.x</code> and the pointer to <code>p.y</code> be next to each other in memory? </p>
</div>
<div class="post-text" itemprop="text">
<p>Python - that is, the programming language - has no concept of memory locations or pointers. So from that point of view, there is no answer to your question. Your question can only be answered for a specific <em>implementation</em> of python, like <a href="https://github.com/python/cpython" rel="nofollow noreferrer">CPython</a>.</p>
<p>That said, the answer is going to be <strong>no</strong> for pretty much every implementation of python. That's because (most) python classes store their attributes in a dictionary. We can access this dictionary through the name <a href="https://docs.python.org/3/library/stdtypes.html#object.__dict__" rel="nofollow noreferrer"><code>__dict__</code></a>:</p>
<pre><code>&gt;&gt;&gt; Point(1, 2).__dict__
{'x': 1, 'y': 2}
</code></pre>
<p>Since dicts have to be efficient and have an O(1) lookup time, they are usually implemented as <a href="https://en.wikipedia.org/wiki/Hash_table" rel="nofollow noreferrer">hash tables</a>. The chance of <code>x</code> and <code>y</code> being right next to each other in a hash table is very slim.</p>
<p>Not all classes use a dictionary to store attributes, though. There are two exceptions:</p>
<ul>
<li>Built-in classes like dictionaries, integers, strings, etc.</li>
<li>Classes with a <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><code>__slots__</code></a> attribute</li>
</ul>
<p>The special <code>__slots__</code> class variable allows us to tell python which attributes the class will have. Python will then only allocate just enough memory to store these attributes, and trying to create any other attributes will cause an error:</p>
<pre><code>class Point: 
    __slots__ = ('x', 'y')

    def __init__(self, x, y): 
        self.x = x
        self.y = y
</code></pre>
<pre><code>&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; p.x
1
&gt;&gt;&gt; p.__dict__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Point' object has no attribute '__dict__'
&gt;&gt;&gt; p.z = 3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Point' object has no attribute 'z'
</code></pre>
<p>If a class uses <code>__slots__</code>, it's far more likely that all of its attributes are stored next to each other in memory. But it's still no guarantee. The python implementation can store the attributes however it wants.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not in general because the attributes of an ordinary object are stored in a hash table, keyed by the attribute name.  Other implementations are possible (as in Self and some Javascript implementations), but to my knowledge, no Python implementation currently does this.</p>
<p>If you used tuples, as in <code>collections.namedtuple</code> (the implementation is quite instructive), then the pointers would be adjacent.</p>
</div>
<span class="comment-copy">Typically CPython object namespaces are simply <code>dict</code> objects. These would be implementation details of whichever Python implementation and version you are using.</span>
<span class="comment-copy">If you are interested in the internals of CPython, here's a brief look that may get you started: <a href="https://hackmd.io/s/ByMHBMjFe#08-Debugging-Python-Objects" rel="nofollow noreferrer">hackmd.io/s/ByMHBMjFe#08-Debugging-Python-Objects</a></span>
<span class="comment-copy">Well, CPython &gt;= 3.6 actually uses an ordered dictionary implementation that I believe will store DictEntry objects (which are just structs that contain pointers to the hash value, the key and the value) in contigous arrays, but again, implementation details... <a href="https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6" title="are dictionaries ordered in python 3 6">stackoverflow.com/questions/39980323/â€¦</a></span>
<span class="comment-copy">And of course, som classes have <code>__slots__</code> instead of a dict</span>
