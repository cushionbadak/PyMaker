<div class="post-text" itemprop="text">
<p>Python variables are for the most part really easy to understand, but there is one case I have been struggling with. If I want to point my variable to a new memory address, how do I do this? Or, if Python does this by default (treating variables like pointers), then how do I literally assign the value from a new variable to the memory address of the old variable?</p>
<p>For example, if I type</p>
<pre><code>a=1
b=2
c=a
c=b
</code></pre>
<p>What is the value of <code>c</code>? And what does it point to? Is the statement replacing the pointer <code>c -&gt; a</code> with pointer <code>c -&gt; b</code> or grabbing the value from <code>b</code> and overwriting <code>a</code> with <code>b</code>'s value? <code>c=b</code> is ambiguous.</p>
<p>In other words, if you start with this:</p>
<pre><code>a -&gt; 1 &lt;- c
b -&gt; 2
</code></pre>
<p>is it re-pointing <code>c</code> like this:</p>
<pre><code>a -&gt; 1    _c
b -&gt; 2 &lt;-/
</code></pre>
<p>or copying <code>b</code> like this?</p>
<pre><code>a -&gt; 2 &lt;- c
b -&gt; 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, in your code:</p>
<pre><code>a=1
b=2
c=a
c=b
</code></pre>
<p>Before you assign <code>c</code> to <code>b</code>'s value and after you assign <code>c</code> to <code>a</code>'s value, <code>c</code> will be <code>a</code>.</p>
<p>And after, at the end of the code, <code>c</code> will be <code>b</code>, because you're reassigning the variable.</p>
<p>The second assignment, basically creates new variable, without knowing that the variable is there already, so it will just do it but no way of accessing previous holding-value of the varaible</p>
</div>
<div class="post-text" itemprop="text">
<p>There are no pointers to variables in Python. In particular, when you say this:</p>
<blockquote>
<p>Is the statement replacing the pointer <code>c -&gt; a</code> with pointer <code>c -&gt; b</code>...</p>
</blockquote>
<p>Python does not have any such thing as "the pointer <code>c -&gt; a</code>", so it is not doing that.</p>
<blockquote>
<p>...or grabbing the value from b and overwriting a with b's value</p>
</blockquote>
<p>but there is no assignment to <code>a</code>, so it's not doing that either.</p>
<p>Instead, Python keeps a symbol table<sup>1</sup> that maps each name (<code>a</code>, <code>b</code>, <code>c</code>, etc.) to a pointer to an object. In your code sample, after you assign to <code>a</code> and <code>b</code>, it would look like this (obviously I have made up the memory addresses):</p>
<pre><code>a -&gt; 0xfffa9600 -&gt; 1
b -&gt; 0xfffa9608 -&gt; 2
</code></pre>
<p>and then after you assign <code>c = a</code>, it would look like this:</p>
<pre><code>a -&gt; 0xfffa9600 -&gt; 1
b -&gt; 0xfffa9608 -&gt; 2
c -&gt; 0xfffa9600 -&gt; 1
</code></pre>
<p>Note that <code>c</code> is entirely independent of <code>a</code>. When you run <code>c = b</code>, it replaces the pointer associated with <code>c</code> in the symbol table with the pointer that was associated with <code>b</code>, but <code>a</code> is not affected:</p>
<pre><code>a -&gt; 0xfffa9600 -&gt; 1
b -&gt; 0xfffa9608 -&gt; 2
c -&gt; 0xfffa9608 -&gt; 2
</code></pre>
<p>In this case that's pretty much all there is to it because the objects in question, namely the integer constants <code>1</code> and <code>2</code>, are immutable. However, if you use mutable objects, they do start to act a bit more like pointers in the sense that changes to the object when it's stored in one variable are reflected in other variables that refer to the same object. For example, consider this sample of code:</p>
<pre><code>x = {'a': 1, 'b': 2}
y = x
</code></pre>
<p>Here, the symbol table might look something like this:</p>
<pre><code>x -&gt; 0xffdc1040 -&gt; {'a': 1, 'b': 2}
y -&gt; 0xffdc1040 -&gt; {'a': 1, 'b': 2}
</code></pre>
<p>If you now run</p>
<pre><code>y['b'] = y['a']
</code></pre>
<p>then it doesn't actually change the pointer associated with <code>y</code> in the symbol table, but it does change the object pointed to by that pointer, so you wind up with</p>
<pre><code>x -&gt; 0xffdc1040 -&gt; {'a': 1, 'b': 1}
y -&gt; 0xffdc1040 -&gt; {'a': 1, 'b': 1}
</code></pre>
<p>and you'll see that your assignment to <code>y['b']</code> has affected <code>x</code> as well. Contrast this with</p>
<pre><code>y = {'a': 1, 'b': 2}
</code></pre>
<p>which actually makes <code>y</code> point at an entirely different object, and is more akin to what you were doing before with <code>a</code>, <code>b</code>, and <code>c</code>.</p>
<hr/>
<p><sup>1</sup>Actually there are several symbol tables, corresponding to different scopes, and Python has an order in which it checks them, but that detail isn't particularly relevant here.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>c</code> doesn't "<em>Point at <code>a</code> or <code>b</code></em>"... it points at the <code>1</code> or <code>2</code> objects.</p>
<pre><code>&gt;&gt;&gt; a = 1
&gt;&gt;&gt; b = 2
&gt;&gt;&gt; c = a
&gt;&gt;&gt; c
1
&gt;&gt;&gt; c = b
&gt;&gt;&gt; c
2
&gt;&gt;&gt; b = 3
&gt;&gt;&gt; c
2
</code></pre>
<p>This can be proven somewhat with <code>id()</code> - <code>b</code> and <code>c</code> point at the same "<em>thing</em>":</p>
<pre><code>&gt;&gt;&gt; b = 2
&gt;&gt;&gt; c = b
&gt;&gt;&gt; id(b)
42766656
&gt;&gt;&gt; id(c)
42766656
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Answering both of your question at once <strong>What is the value of c?</strong> <strong>What does c point to?</strong>, I've added an step by step execution with the <code>id()</code> of each variable with proper comment. Hope this helps you understand properly what is happening under the hood.</p>
<pre><code>&gt;&gt;&gt; a=1
&gt;&gt;&gt; b=2
&gt;&gt;&gt; print(id(a))
1574071312    # this is the address of a
&gt;&gt;&gt; print(id(b))
1574071344    # this is the address of b
&gt;&gt;&gt;c=a        # assignment of a to c
&gt;&gt;&gt; print(c)
1             # c will contain now the value of a
&gt;&gt;&gt; print(id(c))
1574071312    # this is the address of c which is same as a
&gt;&gt;&gt; c=b       # re-assignment of b to c
&gt;&gt;&gt; print(c)
2             # c wil contain now the value of b  
&gt;&gt;&gt; print(id(c))
1574071344    # this the address of c now which is same as b
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well my friend, in this example if <code>c</code> is pointing to <code>a</code>, it'll appear like they are pointing at the same value but not, for example if you're pointing</p>
<pre><code>a = 2
c = a
</code></pre>
<p>then after this declaration, if you change the value of <code>a = 3</code>, <code>c</code> will change it's value to <code>3</code> also.</p>
<p>Imagine those variables values <code>[2][3]</code> in boxes and the variables <code>a, b, c</code> are just pointing to those boxes.</p>
<p>If one variable <code>a</code> is pointing to one box, and the other variable <code>c</code> is pointing to the variable <code>a</code> that is pointing to the box <code>[2]</code>, the last variable <code>c</code> is just following the first variable <code>a</code>, not the value <code>[2]</code>, hope this explanation gets you happy.</p>
</div>
<div class="post-text" itemprop="text">
<p>So to summarize a few of the really good answers I saw from others,</p>
<ol>
<li>Values are objects at a memory location without a name.</li>
<li>Variables (variable names/labels) have no intrinsic value. They are separate objects with their own space in memory, and they can point to any value objects.</li>
<li>The Assignment operator points a label object to a value object.</li>
</ol>
<p>Let's inaccurately go step by step through the assignment operation from the point of view of the Python interpreter:</p>
<ol>
<li><p>First, we create a value.</p>
<pre><code>[value obj]
</code></pre>
<blockquote>
<p>Note: [ ] denotes a physical memory location. This means the value has its own unique memory address.</p>
</blockquote></li>
<li><p>Next, we create a label.</p>
<pre><code>[Label obj] -&gt; nothing
</code></pre></li>
<li><p>Last, we assign the label to its value.</p>
<pre><code>[Label obj] -&gt; [value obj]     
</code></pre></li>
</ol>
<p>So,</p>
<pre><code>a = 1
</code></pre>
<p>is the same as</p>
<pre><code>[memorylocation containing "a"] -&gt; [memorylocation containing 1]
</code></pre>
<p>and</p>
<pre><code>c = b
</code></pre>
<p>is same as </p>
<pre><code>[memorylocation containing "c"]  -&gt;  "b" resolved to [memorylocation containing 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Basically, in the fourth line c variable is being overwritten by the value of b. As this is the last statement, c will hold the value of 2. </p>
</div>
<div class="post-text" itemprop="text">
<p>What you've encountered is reference duplication in Python. To quote from <a href="https://docs.python.org/2/library/copy.html" rel="nofollow noreferrer">copy module documentation</a>:</p>
<blockquote>
<p>Assignment statements in Python do not copy objects, they create bindings between a target and an object</p>
</blockquote>
<p>You can observe how that  works in practice if you think in terms of objects and their values, and use <a href="https://stackoverflow.com/a/133024/3701431"><code>is</code> operator</a> and <code>id()</code> built-in function:</p>
<pre><code>&gt;&gt;&gt; a=1
&gt;&gt;&gt; b=2
&gt;&gt;&gt; c=a
&gt;&gt;&gt; a is c
True
&gt;&gt;&gt; id(a), id(c)
(10932288, 10932288)
&gt;&gt;&gt; id(a), id(c)
</code></pre>
<p>Among other things you can verify exactly the same via references count:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; a=1
&gt;&gt;&gt; b=2
&gt;&gt;&gt; sys.getrefcount(a)
803
&gt;&gt;&gt; sys.getrefcount(b)
97
&gt;&gt;&gt; c=a
&gt;&gt;&gt; sys.getrefcount(c)
804
&gt;&gt;&gt; sys.getrefcount(a)
804
&gt;&gt;&gt; c=b
&gt;&gt;&gt; sys.getrefcount(a)
803
&gt;&gt;&gt; sys.getrefcount(b)
98
&gt;&gt;&gt; 
</code></pre>
<hr/>
<p>Tangentially, this is related to deep and shallow copying. Again from copy documentation:</p>
<blockquote>
<p>The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances):</p>
<ul>
<li>A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.</li>
<li>A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.</li>
</ul>
</blockquote>
<p>Your example uses simple variables and they will always default to reference duplication - no new objects no matter if you try to deep copy them:</p>
<pre><code>&gt;&gt;&gt; import copy
&gt;&gt;&gt; id(b),id(c)
(10932320, 10932320)
&gt;&gt;&gt; c = copy.deepcopy(b)
&gt;&gt;&gt; id(b),id(c)
(10932320, 10932320)
</code></pre>
<p>However, if you try to assign tuples or lists, the story is different:</p>
<pre><code>&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = [3,2,1]
&gt;&gt;&gt; c = a
&gt;&gt;&gt; id(a),id(c)
(139967175260872, 139967175260872)
&gt;&gt;&gt; c = copy.deepcopy(a)
&gt;&gt;&gt; id(a),id(c)
(139967175260872, 139967175315656)
</code></pre>
<p>In the above example, you get an entirely different object. Why this might be useful ? The fact that simple assignment just makes two variables reference same object also implies that if you change one , changes get reflected in the other. </p>
<pre><code>&gt;&gt;&gt; id(c),id(a)
(139967175260872, 139967175260872)
&gt;&gt;&gt; a.append(25)
&gt;&gt;&gt; id(c),id(a)
(139967175260872, 139967175260872)
&gt;&gt;&gt; c
[1, 2, 3, 25]
&gt;&gt;&gt; 
</code></pre>
<p>This can be impractical when you want to keep original data. When you want to have two same objects initially, but then let them change in their own way - that's where you want to have either shallow copy for just object itself or deep copy for all objects that are contained within the object:</p>
<pre><code>&gt;&gt;&gt; c = copy.deepcopy(a)
&gt;&gt;&gt; a.append(35)
&gt;&gt;&gt; a
[1, 2, 3, 25, 35]
&gt;&gt;&gt; c
[1, 2, 3, 25]
</code></pre>
<p>And just for demo purposes, shallow copy:</p>
<pre><code>&gt;&gt;&gt; c = a
&gt;&gt;&gt; a.append([9,8,7])
&gt;&gt;&gt; a
[1, 2, 3, 25, 35, [9, 8, 7]]
&gt;&gt;&gt; c = a
&gt;&gt;&gt; id(a), id(c), id(a[-1])
(139967175260872, 139967175260872, 139967175315656)
&gt;&gt;&gt; c = copy.copy(a)
&gt;&gt;&gt; id(a), id(c), id(a[-1])
(139967175260872, 139967175315528, 139967175315656)
</code></pre>
<p>See also <a href="https://stackoverflow.com/a/17246744/3701431">grc's excellent answer</a> on the same topic with better examples.</p>
</div>
<span class="comment-copy">In python you can reassign variables as you wish. c now refers to the same objects as b refers. Try this <code>print(id(c) == id(b))</code> and <code>print(id(c) == id(a))</code>. Any similarity between c and a is now erased. See more about name here: <a href="https://docs.python.org/3/reference/executionmodel.html" rel="nofollow noreferrer">docs.python.org/3/reference/executionmodel.html</a>. I'm sure however there are more elaborate answers here on SO on the topic.</span>
<span class="comment-copy">Ok after seeing your update: name point at objects. they don't hold any values. no copying is involved.</span>
<span class="comment-copy">Read the following article by StackOverflow legend, Ned Batchelder, that explains this exhaustively: <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Facts and myths about Python names and values</a></span>
<span class="comment-copy">@juanpa.arrivillaga good article. Even has a code runtime visualizer.</span>
<span class="comment-copy">@juanpa.arrivillaga Exactly the reference we needed. Any1 who has interest in understanding this question should be linked to that page.</span>
<span class="comment-copy">Thanks. I like your answer, because it shows how different Python's execution model is from C++. In your explanation, when you say "assign <code>c</code> to <code>b</code>", a C++ developer would look at this and say it is backwards. They would "assign <code>b</code> to <code>c</code>", because the assignment operator is a very low-level operation with an implied flow/direction for the data (retrieve value of <code>b</code>, malloc to memory heap, and dump the CPU's register into the memory location at <code>c</code>).</span>
<span class="comment-copy">From now on, this is how I will be thinking about it.</span>
<span class="comment-copy">I actually think this answer is a little misleading, since it says things like "<code>c</code> will be <code>a</code>", but it's really not true that <code>c</code> is <code>a</code>; instead, <code>c</code> "is" the same value that <code>a</code> also happens to be. There's no relation between <code>c</code> and <code>a</code>, except that (at a particular point in the program's execution) they happen to both refer to the same value. @Ryan, if this explanation really helps you understand how Python actually works, that's fine, but I think it has the potential to confuse other people in the same way you were confused when you asked the question.</span>
<span class="comment-copy">@Ryan in C terms, I suppose, you could say that in Python, you can never really refer to a value of an object directly, just indirectly through a pointer which you cannot dereference. You can merely swap pointers around on a symbol table.</span>
<span class="comment-copy">@Ryan I disagree. To be clear, I understand the way you see it as you explained in your comment, and <i>some</i> low-level programmers will also understand the answer that way, and for them it will be helpful, but I think other people (specifically other low-level programmers) will misinterpret it, and for those people this way of explaining it will be harmful. I'm skeptical that this is only misleading to non-C programmers, as you claim.</span>
<span class="comment-copy">Nice! Are these memory addresses equal to the ids of the objects?</span>
<span class="comment-copy">Very in depth. Thank you. As someone else pointed out I was not clear in my explanation. When I wrote <code>c -&gt; a</code>, in my mind I was resolving <code>a</code> to a physical location in memory storing the value 1. It seems that Python has an added layer of resolution. My background in C++ causes confusion for me in Python.</span>
<span class="comment-copy">@AntonvBR If by "ids" you mean the values returned from <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">the <code>id()</code> builtin function</a>: they might be. In the standard Python interpreter (CPython), at least currently, <code>id()</code> does give the memory address. Other Python interpreters (or future versions of CPython) might do it differently.</span>
<span class="comment-copy">@Ryan You're welcome, glad I could help. This is a common source of confusion for people coming to Python from lower level languages so you'll find a lot written about it on Stack Overflow and elsewhere.</span>
<span class="comment-copy">Your answer is a good balance between in depth and easy to understand. It is critical for C++ developers like me to realize that the value is an object separate from the label <code>c</code>. <code>c</code> IS a memory location that contains a pointer to another memory location that is called <code>1</code>, but in C++, <code>c</code> IS a memory location that contains data that is <code>1</code>.</span>
<span class="comment-copy">Please edit your question, using formatting makes it easier readable</span>
<span class="comment-copy">This is a good way to explain it to new programmers. The [ ] square brackets visualization is very helpful.</span>
<span class="comment-copy">@Ryan The trouble is, this isn't correct.</span>
<span class="comment-copy">I think "variable object" and "name object" is just confusing. In Python, a namespace is quite literally a <code>dict</code>.</span>
<span class="comment-copy">How do I explicitly force b's value to overwrite/copy to a's value?</span>
<span class="comment-copy">@Ryan in Python, you do not. Variables act like name-tags to objects, they are not memory addresses. Python doesn't have pointers.</span>
<span class="comment-copy">This explanation is ambiguous, because it relies on me already understanding that the "c variable" is its own memory location pointing to another memory location.</span>
