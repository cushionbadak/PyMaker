<div class="post-text" itemprop="text">
<pre><code>L = [random.randint(0,50) for i in range(5) random.randint(0,12) for i in range(2)]
</code></pre>
<p>How do I get it to pick 5 random numbers between (0,50), then 2 random numbers between(0,12)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can vary the second argument to <code>randint()</code> based on the value of <code>i</code>:</p>
<pre><code>[randint(0, 50 if i &lt; 5 else 12) for i in range(7)]
</code></pre>
<p>The <code>50 if i &lt; 5 else 12</code> expression will change what is passed to <code>random.randint()</code> for the last two iterations.</p>
<p>There are many more variations you can spell this in. List comprehensions are a bunch of loops and <code>if</code> filters that repeatedly execute the expression at the front. There are lots of ways to spell <em>vary the arguments to a function call based on the iteration values</em> in expressions.</p>
<p>For example, you could record those arguments in <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial()</code> objects</a>:</p>
<pre><code>from functools import partial
from random import randint

rint50 = partial(randint, 0, 50)
rint12 = partial(randint, 0, 12)
[rint() for rint in [rint50] * 5 + [rint12] * 2]
</code></pre>
<p>The possibilities are endless. Lambdas, <code>randint(0, upperbound)</code>, <code>randint(*args)</code>, a function that'll vary its results depending on how often it has been called, etc. But I wouldn't argue that any of these are actually more readable or understandable.</p>
<p>For this case, with just 7 values, I'd just concatenate the two lists:</p>
<pre><code>[randint(0, 50) for _ in range(5)] + [randint(0, 12) for _ in range(2)]
</code></pre>
<p>as it's just cleaner and more readable. The small performance cost of creating a 3rd list that contains the results of the two list comprehensions is negligible here.</p>
</div>
<div class="post-text" itemprop="text">
<p>Something like this maybe, concatenating 2 lists:</p>
<pre><code>from random import randint
my_list = [randint(0,50) for i in range(5)] + [randint(0,12) for i in range(2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't reuse the name <code>list</code>.  One way would be to loop through an iterable of the bounds, and send those to <code>randint</code></p>
<pre><code>from random import randint

lst = [randint(*bounds) for bounds in [(0, 50)]*5 + [(0, 12)]*2]
</code></pre>
<p>You could also use <code>itertools.chain</code> and <code>itertools.repeat</code> to avoid building that list of bounds</p>
<pre><code>lst = [randint(*bounds) for bounds in chain(repeat((0, 50), 5), repeat((0, 12), 2))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import random
l = [random.randint(0,50) for i in range(5)]
l.extend([random.randint(0,12) for i in range(2)])

print(l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another variation that avoids doing an <code>if</code> test on every iteration. It also uses <code>randrange</code>, which is slightly more efficient than <code>randint</code>.</p>
<pre><code>from random import randrange
lst = [randrange(hi) for num, hi in ((5, 51), (2, 13)) for _ in range(num)]
print(lst)
</code></pre>
<p><strong>typical output</strong></p>
<pre><code>[10, 31, 46, 25, 23, 6, 5]
</code></pre>
<p>This is equivalent to</p>
<pre><code>lst = []
for num, hi in ((5, 51), (2, 13)):
    for _ in range(num):
        lst.append(randrange(hi))
</code></pre>
<p>The outer loop selects <code>num</code>, the number of items in the sublist, and <code>hi</code> the size of the random range for that sublist; the inner loop generates the required amount of random numbers in the desired range.</p>
<hr/>
<p>FWIW, here's some <a href="https://docs.python.org/3/library/timeit.html#timeit.Timer.repeat" rel="nofollow noreferrer"><code>timeit</code></a> code comparing the various algorithms that have been submitted. It also verifies that they produce the same results when given the same random seed. My simple verification code uses <code>eval</code>, so it can only test expressions, not statements, so it can't test jpp's or Abhishek's code; besides, jpp's Numpy code gives different results anyway, since it uses a different seeding algorithm. Please see the <code>timeit</code> docs for info on what <code>timeit</code> does, and how to interpret the results.</p>
<pre><code>from timeit import Timer
import random
from random import randint, randrange, seed
from itertools import chain, repeat, starmap
from functools import partial
import numpy as np

imports = 'random, randint, randrange, seed, chain, repeat, starmap, partial, np'

commands = (
    ('Martijn', '', '[randint(0, 50 if i &lt; 5 else 12) for i in range(7)]'),
    ('Martijn_partial', 
        'rint50 = partial(randint, 0, 50); rint12 = partial(randint, 0, 12)', 
        '[rint() for rint in [rint50] * 5 + [rint12] * 2]'
    ),
    ('Patrick', '', '[randint(*bounds) for bounds in [(0, 50)]*5 + [(0, 12)]*2]'),
    ('Patrick_chain', '', 
        '[randint(*bounds) for bounds in chain(repeat((0, 50), 5), repeat((0, 12), 2))]'
    ),
    ('Ralf', '', '[randint(0,50) for i in range(5)] + [randint(0,12) for i in range(2)]'),
    ('Abhishek', '', 'l = [random.randint(0,50) for i in range(5)];'
        'l.extend([random.randint(0,12) for i in range(2)])'
    ),
    ('PM 2Ring', '', '[randrange(hi) for num, hi in ((5, 51), (2, 13)) for _ in range(num)]'),
    ('jpp', '', 'A = np.zeros(7); ' 
        'A[:5] = np.random.randint(0, 20, 5); A[5:] = np.random.randint(0, 12, 2)'
    ),
    ('Tanmay jain', '', 
        '[random.randint(0,50) if i &lt; 5 else random.randint(0,12) for i in range(7)]'
    ),
    ('juanpa', '', '[random.randint(a,b) for args in (((0,50) for _ in range(5)),' 
        '((0, 12) for _ in range(2))) for a, b in args]'
    ),
    ('juanpa_starmap', '', 'list(starmap(random.randint,'
        'chain(repeat((0,50),5), repeat((0,12),2))))'
    ),
)

def verify():
    for name, setup, cmd in commands:
        if name in ('jpp', 'Abhishek'):
            continue
        seed(17)
        if setup:
            exec(setup)
        print('{:16}: {}'.format(name, eval(cmd)))
    print()

def time_test(loops):
    timings = []
    print('loops =', loops)
    for name, setup, cmd in commands:
        setup = 'from __main__ import ' + imports + ';' + setup
        t = Timer(cmd, setup=setup)
        result = sorted(t.repeat(3, loops))
        timings.append((result, name))
    timings.sort()
    for result, name in timings:
        print('{:16} : {}'.format(name, result))

verify()
time_test(5000)
</code></pre>
<p><strong>typical output</strong></p>
<pre><code>Martijn         : [33, 26, 19, 23, 18, 2, 12]
Martijn_partial : [33, 26, 19, 23, 18, 2, 12]
Patrick         : [33, 26, 19, 23, 18, 2, 12]
Patrick_chain   : [33, 26, 19, 23, 18, 2, 12]
Ralf            : [33, 26, 19, 23, 18, 2, 12]
PM 2Ring        : [33, 26, 19, 23, 18, 2, 12]
Tanmay jain     : [33, 26, 19, 23, 18, 2, 12]
juanpa          : [33, 26, 19, 23, 18, 2, 12]
juanpa_starmap  : [33, 26, 19, 23, 18, 2, 12]

loops = 5000
jpp              : [0.23938178099342622, 0.24184146700281417, 0.3152835669970955]
PM 2Ring         : [0.26918871099769603, 0.27244400099880295, 0.2916741489971173]
Patrick          : [0.34155847399961203, 0.34415175200410886, 0.3531294650019845]
juanpa_starmap   : [0.3417540490045212, 0.34329504700144753, 0.3438059809996048]
Martijn          : [0.3509639670010074, 0.362117896998825, 0.547288200003095]
Martijn_partial  : [0.3511254819968599, 0.35262946599686984, 0.39430355399963446]
Patrick_chain    : [0.3541102219969616, 0.3545923809942906, 0.3555165420038975]
Tanmay jain      : [0.3558294050017139, 0.5510739650053438, 0.7693202439986635]
Ralf             : [0.3678122450000956, 0.44522786799643654, 0.44827762299973983]
juanpa           : [0.4089203829935286, 0.41227930299646687, 0.42410747800022364]
Abhishek         : [0.4811078249986167, 0.4942625819967361, 0.6255962599971099]
</code></pre>
<p>As you can see, jpp's Numpy code is the fastest. I expect that the speed difference would be even more apparent if we were generating a longer list of numbers.</p>
<p>These timing were performed on an ancient 32 bit single core 2GHz machine, running Python 3.6.0 on a Debian derivative distro. YMMV.</p>
<hr/>
<p>Here are timings for the production of lists (or arrays) of 50 + 20 = 70 values in the same ranges.</p>
<pre><code>loops = 500
jpp              : [0.025625186994147953, 0.025764200996491127, 0.03122780400008196]
PM 2Ring         : [0.21989007600495825, 0.2200367909972556, 0.22065802400175016]
juanpa_starmap   : [0.3094131350007956, 0.3110805670003174, 0.31563361900043674]
Patrick_chain    : [0.3122365829985938, 0.31262181099737063, 0.3137894630053779]
Patrick          : [0.3130071220002719, 0.31769691400404554, 0.3179219129960984]
Ralf             : [0.31566168300196296, 0.3157304769993061, 0.3234770689959987]
Martijn          : [0.3193310350034153, 0.3275600470005884, 0.35491854500287445]
Martijn_partial  : [0.321399387998099, 0.3226969290044508, 0.32442738999816356]
Abhishek         : [0.32655813400197076, 0.3363869300010265, 0.3657162370000151]
Tanmay jain      : [0.32833286200184375, 0.33107244400162017, 0.39565577400207985]
juanpa           : [0.35968791200139094, 0.3754627199959941, 0.3933205349967466]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are happy using a 3rd party library, you can via NumPy:</p>
<pre><code>import numpy as np

np.random.seed(0) # for consistency / testing

A = np.zeros(7)
A[:5] = np.random.randint(0, 20, 5)
A[5:] = np.random.randint(0, 12, 2)

array([ 12.,  15.,   0.,   3.,   3.,   7.,   9.])
</code></pre>
<p>The benefit of this method, memory pre-allocation, will be evident with larger arrays.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>since you want to pick 5 random values from 0 - 50( exclusive)
i = 0...4
and then you want to pick 2 random values from 0 - 12( exclusive)
i = 5 6
</code></pre>
<p><br/></p>
<pre><code>lst = [random.randint(0,50) if i &lt; 5 else random.randint(0,12) for i in range(7)]

print(lst) # [7, 10, 40, 4, 38, 1, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You <em>can</em> do this using list-comprehensions and only built-ins, some monstrosity like:</p>
<pre><code>&gt;&gt;&gt; result = [
...     random.randint(a,b)
...     for args in (((0,50) for _ in range(5)), ((0, 12) for _ in range(2)))
...     for a, b in args
... ]
&gt;&gt;&gt; result
[33, 38, 19, 9, 47, 0, 8]
</code></pre>
<p>Perhaps, if you want to use itertools, you can do something like:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain, repeat, starmap
&gt;&gt;&gt; list(starmap(random.randint, chain(repeat((0,50),5), repeat((0,12),2))))
[16, 47, 40, 21, 15, 12, 4]
</code></pre>
<p>Both of these approaches are hardly readable and simple. Instead, I would personally go with two for-loops, the naive approach. It would be efficient, simple, and readable. Other than showboating, I see no advantage to the above approaches in production code.</p>
</div>
<span class="comment-copy">whats your desired output? and don't name your list <code>list</code></span>
<span class="comment-copy">List comprehensions are just for loops that build a list. If you can express your needs in a regular <code>for</code> loop with a <code>list.append(...)</code> part, then you can probably make it a list comprehension too.</span>
<span class="comment-copy">It's only named list on here, Not in my actual code. My desired outcome is a list of 7 random numbers, 5 that have been picked from a range of (0,50) and 2 that have been picked from a range of (0,12)</span>
<span class="comment-copy">You may be interested in the <code>timeit</code> results I've added to my answer.</span>
<span class="comment-copy">Nice! I think the only thing I don't like about list comprehension is readability.</span>
<span class="comment-copy">@artomason: that depends on how you are are using them. Here, the expression is easily too ugly.</span>
<span class="comment-copy">Perfect man, Thank you! I must have missed it in my frustration!</span>
<span class="comment-copy">For 7 values, comparing timings is next to meaningless. Looking at this from a perf perspective really is a premature optimisation.</span>
