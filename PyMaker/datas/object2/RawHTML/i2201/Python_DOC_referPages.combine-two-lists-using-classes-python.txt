<div class="post-text" itemprop="text">
<p>So I want to create two list objects and combine them using function union in class MySet. So far I have</p>
<pre><code>class MySet:
    def __init__(self, elements):
        self.elements=elements
    def union(self, sets):
        for i in self.elements:
            self.elements.append(sets)
            break
        for j in self.elements and sets
            #print j only once
            #idk if even the first part is the right syntax
</code></pre>
<p>So to use it I would do</p>
<pre><code>seta = MySet([1,2,3])
setb = MySet([1,10,11])
setc = seta.union(setb)
</code></pre>
<p>Also, I don't want it to print duplicates. So setc.elements should output [1,2,3,10,11]. And seta.elements should still be [1,2,3] and so on. Thank you. </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">Python Sets</a> are a good way of doing this.</p>
<pre><code>def union(self, new_set):
    seta = set(self.elements)
    setb = set(new_set)
    set_diff = setb - seta  # remove any overlap
    return self.elements + list(set_diff)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want <code>set</code>-like behaviour, use actual <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.union" rel="nofollow noreferrer"><code>sets</code></a>.</p>
<pre><code>new_set = set(seta) + set(setb)  # seta &amp; setb are lists
</code></pre>
<p>But if you really need to use a class which behaves like a list, change the <code>union()</code> function to this:</p>
<pre><code>def union(self, other_set):
    new_set = [i for i in self.elements]  # which is actually a list
    for j in other_set:
        if j not in self.elements:
            new_set.append(j)
    return new_set
</code></pre>
<p>First, new_set is being created as copy of <code>self</code> (seta). Then, each element of <code>other_set</code> (setb) which is not in self gets added, in order, to the new set.</p>
</div>
<div class="post-text" itemprop="text">
<p>This setup would accomplish what you are speaking of, just set up the method to concatenate the two list, how you call the methods is important.    </p>
<pre><code>class MySet:
    def __init__(self, elements):
        self.elements=elements
    def union(self,set_2):
        return list(set(self.elements) | set(set_2))

seta = MySet([1, 2, 3])
setb = MySet([1, 10, 11])
setc = seta.union(setb.elements)

print(seta.elements) # =&gt; [1, 2, 3]
print(setb.elements) # =&gt; [1, 10, 11]
print(setc) # =&gt; [1, 2, 3, 10, 11]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answer of @aneroid is good, but would be very slow if <code>other_set</code> is large. Using set is one of the most scalable choices. The order will be ignored.</p>
<pre><code>def union(self, other_set):
    return list(set(self.elements).union(other_set))
</code></pre>
<p>If you want to keep the order, making a set object would be faster for very large <code>other_set</code>.</p>
<pre><code>def union(self, other_set):
    new_set = [i for i in self.elements]  # which is actually a list
    set_obj = set(new_set)
    for j in other_set:
        if j not in set_obj:
            new_set.append(j)
    return new_set
</code></pre>
</div>
<span class="comment-copy">Thank you. This is closest to what I would like to do, but it's not working.</span>
<span class="comment-copy">Forgot to return the new set. Added it now.</span>
