<div class="post-text" itemprop="text">
<p>input data:</p>
<pre><code>input_tuple = (
            (1, 'name1', 'Noah'),
            (1, 'name2', 'Liam'),

            (2, 'name3', 'Mason'),

            (3, 'name4', 'Mason'),

            (4, 'name5', 'Noah'),
            (4, 'name6', 'Liam'),

            (5, 'name7', 'Elijah'),
            (5, 'name8', 'Noah'),
            (5, 'name9', 'Liam')
          )
</code></pre>
<p>converted into dict(key, value):</p>
<pre><code>input_tuple = {
         1: [['name1', 'Noah'], ['name2', 'Liam']],
         2: [['name3', 'Mason']],
         3: [['name4', 'Mason']],
         4: [['name5', 'Noah'], ['name6', 'Liam']],
         5: [['name7', 'Elijah'], ['name8', 'Noah'], 
             ['name9', 'Liam']]
         }
</code></pre>
<p>did some more filter just for understanding the data model:</p>
<pre><code>    dict =   
    {
    1: ['Noah', 'Liam'],
    2: ['Mason'],
    3: ['Mason'],
    4: ['Noah', 'Liam'],
    5: ['Elijah', 'Noah', 'Liam']
    }
</code></pre>
<p>Now i want to eliminate duplicate and then revert back to tuple like below:
duplicate matching conditions:
1) eliminate duplicate if len(value) &gt; 1
2) value should exact match not partial.</p>
<p>Note:
key 2 and 3 value is not duplicate because len(value) is not -gt 1
key 4 value has gone because its exact duplicate
since we are doing exact matching, hence in key 5 value ['Noah', Liam] will not go.</p>
<pre><code> output_tuple = 
      (
        (1, 'name1', 'Noah'),
        (1, 'name2', 'Liam'),

        (2, 'name3', 'Mason'),

        (3, 'name4', 'Mason'),

        (5, 'name7', 'Elijah'),
        (5, 'name8', 'Noah'),
        (5, 'name9', 'Liam')
      )
</code></pre>
<p>code which i tried:</p>
<pre><code>from functools import reduce
from collections import defaultdict

input_tuple_dictionary = defaultdict(list)
for (key, *value) in input_tuple:
    input_tuple_dictionary[key].append(value[1])

input_tuple_dictionary
for index in range(len(input_tuple_dictionary)-1):
    for key, value in input_tuple_dictionary.items():
        if len(value) &gt; 1:
            if value == value[index+1]:
                print(key)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is one solution using a <code>defaultdict</code> of <code>set</code> objects and <code>toolz.unique</code>. <code>toolz.unique</code> is equivalent to the <code>itertools</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>unique_everseen</code> recipe</a> available in the docs.</p>
<p>The idea is to find keys with lone values and also keys which do not have duplicate values. The <em>union</em> of these two categories make up your result.</p>
<pre><code>from collections import defaultdict
from toolz import unique

dd = defaultdict(set)

for k, _, v in input_tuple:
    dd[k].add(v)

lones = {k for k, v in dd.items() if len(v) == 1}
uniques = set(unique(dd, key=lambda x: frozenset(dd[x])))

res = tuple(i for i in input_tuple if i[0] in lones | uniques)
</code></pre>
<p>Result:</p>
<pre><code>print(res)

((1, 'name1', 'Noah'),
 (1, 'name2', 'Liam'),
 (2, 'name3', 'Mason'),
 (3, 'name4', 'Mason'),
 (5, 'name7', 'Elijah'),
 (5, 'name8', 'Noah'),
 (5, 'name9', 'Liam'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One common solution for skipping duplicates is to keep a set that contains all of the elements you've already seen. If the object has been seen before, you don't add it to the result.</p>
<p>The tricky bit is that the object you're trying to un-duplicate is the aggregation of multiple objects that reside within different tuples in your collection. Using <code>groupby</code> is an effective way to get those objects together in one convenient package.</p>
<pre><code>from itertools import groupby

input_tuple = (
    (1, 'name1', 'Noah'),
    (1, 'name2', 'Liam'),

    (2, 'name3', 'Mason'),

    (3, 'name4', 'Mason'),

    (4, 'name5', 'Noah'),
    (4, 'name6', 'Liam'),

    (5, 'name7', 'Elijah'),
    (5, 'name8', 'Noah'),
    (5, 'name9', 'Liam')
  )

seen = set()
result = []
for _, group in groupby(input_tuple, key=lambda t: t[0]):
    #convert from iterator to list, since we want to iterate this more than once
    group = list(group)
    #extract just the names from each tuple.
    names = tuple(t[2] for t in group)
    #check for duplicates, but only for name groups with more than one element.
    if len(names) == 1 or names not in seen:
        result.extend(group)
    seen.add(names)

print(result)
</code></pre>
<p>Result:</p>
<pre><code>[(1, 'name1', 'Noah'), (1, 'name2', 'Liam'), (2, 'name3', 'Mason'), (3, 'name4', 'Mason'), (5, 'name7', 'Elijah'), (5, 'name8', 'Noah'), (5, 'name9', 'Liam')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code># Using the dict format of yours
data = [set(dict[x]) for x in range(1, len(dict) + 1)]
input_tuple = dict
seen = []
output_tuple = []
for i in range(len(data)):
    if (data[i] not in seen) or len(data[i]) == 1:
        for j in range(len(input_data)):
            if input_data[j][0] == i + 1:
                output_tuple.append(input_data[j])
    seen.append(data[i])
output_tuple = tuple(output_tuple)
</code></pre>
<p>If you did not understand please ask</p>
<p>Good Luck</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import defaultdict

dct = defaultdict(list) 

for k,n_id,name in input_tuple:
    dct[k].append(name)

#print(dct)

seen = set()
ignore_id_set = set()

for _id, _namelst in dct.items():
    if len(_namelst) &gt; 1:
        k = tuple(sorted(_namelst)) # note 1 

        if k not in seen:
            seen.add(k)
        else:
            ignore_id_set.add(_id) # duplicate

#print(seen)

# del dct,seen # dct,seen are now eligible for garbage collection

output = tuple(item for item in input_tuple if item[0] not in ignore_id_set)
print(output)


'''
note 1:
    important to sort **if** situations like this can be possible
     (1, 'name1', 'Noah'),
     (1, 'name2', 'Liam'),

     (4, 'name6', 'Liam'),
     (4, 'name5', 'Noah'),

     because when we will create dct it will result in 

     1 : [Noah,Liam]
     4 : [Liam,Noah]

     since we want to treat them as duplicates we need to sort before creating their hash( via tuple)

**else** no need to do sort

'''
</code></pre>
</div>
<span class="comment-copy">How exactly is a "duplicate" defined?</span>
<span class="comment-copy">Why are Noah and Liam for id = 5 not removed?</span>
<span class="comment-copy">because if you compare with 1: and 5 key value. its not exactly same.</span>
<span class="comment-copy">"['Elijah', 'Noah', 'Liam']" is not equal to "['Noah', 'Liam']"</span>
<span class="comment-copy">So why are Noah and Liam removed for id = 4?</span>
<span class="comment-copy">getting module error: ModuleNotFoundError: No module named 'toolz'</span>
<span class="comment-copy">@Vikash, See the 2nd sentence .. <code>toolz.unique is equivalent to the itertools unique_everseen recipe available in the docs.</code> I've added a link for you.</span>
<span class="comment-copy">Hi All, Thank You so much for your wonderful responses and support. my data are little huge and there is memory overflow.. so I will run tomorrow with full set and then tick the answer.</span>
<span class="comment-copy">However , meanwhile if possible can you please assist me to create comprehension code like below:</span>
<span class="comment-copy"># chooses first seen as unique (this is for single duplicate check) result = (tuple({(x[0], x[4]): x for x in input_tuple[::-1]}.values())[::-1])</span>
<span class="comment-copy">nice answer, but if (4, 'name6', 'Liam') comes before (4, 'name5', 'Noah') it doesn't produce correct result.</span>
<span class="comment-copy">You're right. If, for the purposes of duplicate detection, you wanted to completely disregard the order of names within a group, you could do <code>names = tuple(sorted(t[2] for t in group))</code>. If you <i>do</i> care about the order of names within a group, but want to order lexicographically by the <code>"name&lt;digit&gt;"</code> element, then perhaps you could do <code>names = tuple(t[2] for t in sorted(group, key=lambda t: t[1]))</code>.</span>
<span class="comment-copy">Thank you for your prompt reply. This will help OP to decide what kind of behavior he wants, originally I also didn't take into account the problem that I found in your solution but for mine it was quick fix, I just sort the list( names list which has same id) before creating hash from it( via tuple).</span>
<span class="comment-copy">Hi Tanmay, its working fine, but  since i have to process a huge data, hence it may create memory issue.</span>
