<div class="post-text" itemprop="text">
<p>I am attempting to utilize the Python module <code>subprocess</code> to automate a terminal command on Mac. Specifically, I am running a <a href="https://salferrarello.com/mac-pfctl-port-forwarding/" rel="nofollow noreferrer">certain command</a> to create <a href="https://en.wikipedia.org/wiki/Port_forwarding" rel="nofollow noreferrer">port mappings</a> on my machine. However, the command in question requires both root privileges and piping:</p>
<pre><code>echo "
rdr pass inet proto tcp from any to any port 80 -&gt; 127.0.0.1 port 8080
" | sudo pfctl -ef - 
</code></pre>
<p>In order to pass my root password to the shell command with <code>subprocess</code>, I followed the code example found <a href="https://stackoverflow.com/questions/13045593/using-sudo-with-python-script/24257940#answer-23692520">here</a> to create a script below:</p>
<pre><code>from subprocess import PIPE, Popen
p = Popen(['echo', '"rdr pass inet proto tcp from any to any port 80 -&gt; 127.0.0.1 port 8080"\n'], stdin=PIPE, stderr=PIPE, universal_newlines=True)
p2 = Popen(['sudo', '-S']+['pfctl', '-ef', '-'], stdin=p.stdout, stderr=PIPE, universal_newlines=True) 
return p2.communicate('my_root_password\n')[1] 
</code></pre>
<p>Note that to implement the piping of the <code>echo</code> output to the command <code>pfctl -ef -</code> I have created two <code>Popen</code> objects and have passed the <code>stdout</code> of the first object to the <code>stdin</code> parameter of second, as recommended in the <a href="https://docs.python.org/3/library/subprocess.html#replacing-shell-pipeline" rel="nofollow noreferrer"><code>subprocess</code> docs</a>, and am using <code>Popen.communicate</code> to write the root password to the stdin. </p>
<p>However, my script above is not working, as <em>I am still prompted in the terminal to enter my root password</em>. Strangely, I am able to successfully write my root password to stdin when using a command without piping, for instance, when running <code>sudo pfctl -s nat</code> (to display my current port mapping settings):</p>
<pre><code>p = Popen(['sudo', '-S']+'pfctl -s nat'.split(), stdin=PIPE, stderr=PIPE, universal_newlines=True)
print(p.communicate('root_password\n')[1])
</code></pre>
<p>The above code works, as the mapping configuration is displayed without any password prompt. </p>
<p>How can my first Python script be changed so that I am not prompted to enter my root password, having already utilized <code>Popen.communicate</code> to write the password to stdin? </p>
<hr/>
<p>I am running this code on macOS Sierra 10.12.5</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this is just a simple case of the pipes not being connected up properly. You don't specify a pipe for the <code>stdout</code> of the first process so by the looks of things the output just gets printed to the terminal then the process finishes.</p>
<p>When second process starts, it will prompt for the password and as far as I can see receive it correctly. However the <code>communicate</code> method then closes the input and waits for the process to finish. As far as I can see the output of the first process never reaches the second, which is why your script isn't working. Instead of creating a separate <code>echo</code> process, why not just send all the text data you need with <code>communicate</code>?</p>
<p>The other problem it looks like you have (I don't have a MAC to check) is that <code>sudo</code> is printing the prompt directly to the terminal (ie via <code>/dev/tty</code> rather than <code>stdout</code>). On my version of <code>sudo</code> (on Debian) adding the <code>-S</code> option causes it to print the prompt to <code>stderr</code>. However it looks like the <code>-S</code> option doesn't do this on a MAC. Instead try disabling the prompt with <code>-p ''</code>.</p>
<p>Putting everything together, this should work:</p>
<pre><code>from subprocess import PIPE, Popen
from getpass import getpass

password = getpass()

cmd = ['sudo', '-k', '-S', '-p', '', 'pfctl', '-ef', '-']
p = Popen(cmd, stdin=PIPE, stderr=PIPE, universal_newlines=True) 
text = password + '\n'
text += 'rdr pass inet proto tcp from any to any port 80 -&gt; 127.0.0.1 port 8080\n'
p.communicate(text)
</code></pre>
<h3>Security Note</h3>
<p>This answer was updated to not use a plain text password. See the comments below for a good example of why this is a bad idea! Note also that storing passwords in memory with Python isn't completely secure as if the memory is swapped to disk, this will include the password in plain text. With a lower level language, the <code>mlock</code> system call would be used to prevent any memory containing the password from being swapped.</p>
</div>
<span class="comment-copy">Not an answer, but why not remove the sudo and run the script as root?</span>
<span class="comment-copy">@mVChr That is a good idea, but I am actually planning on running this as part of a program that queries the user for the password to make changes, in this case, update the port mapping rules.</span>
<span class="comment-copy"><code>sudo</code> reads your password from <code>stdin</code>, your <code>stdin</code> is connected to other process <code>stdout</code>, <code>sudo</code> cannot read your password.</span>
<span class="comment-copy">@yorodm That makes sense. Is there any way I could work around that?</span>
<span class="comment-copy">1. User must be in sudoers file. or 2. Use <code>subprocess.call</code></span>
<span class="comment-copy">Thank you very much! This works, however, it only updates the configuration file when running the code in a new terminal window every time. Do you know why this might be? I am assuming that is simply a feature of <code>pfctl</code> and the Mac port manager, however, could the code have something to do with it?</span>
<span class="comment-copy">Ah, probably because <code>sudo</code> doesn't need a password the second time round, so the password gets sent to <code>pfctl</code>. Try adding the <code>-k</code> option to <code>sudo</code>, which should make sure it always asks for a password.</span>
<span class="comment-copy">Thank you again! It works now! Will award bounty once the system lets me (in 21 hours).</span>
