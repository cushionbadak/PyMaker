<div class="post-text" itemprop="text">
<p>I have a function that can be run in parallel, however, as I try running it, it appears that the function is being called serially. </p>
<pre><code>import multiprocessing as mp
def function_to_be_parallelized(x,y,z):
    #compute_array takes 1-5 minutes computation to depending on x,y,z
    computed_array=compute_array(x,y,z)
    print ("running with parameters"+str(x*y*z))
    return computed_array

def run(xs,ys,zs):

    pool = mp.Pool(processes=4)
    all_outputs = [pool.apply(function_to_be_parallelized, args=(x,y,z)) for x in xs for y in ys for z in zs]
</code></pre>
<p>What I find is that the print statements are printed one at a time, and each is only printed once the previous process is finished, I'm running this on a machine with 4 cores. </p>
<p>Is this because the processes in the inner function each occupy more than 2 cores (so that it cannot be parallelized)? Or is there another reason?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>pool.apply</code> <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply" rel="nofollow noreferrer">waits for the result to be ready</a>, so you're not submitting a new job until the previous job finishes. You'd have to use something like <code>apply_async</code> or <code>map</code>, but even then, there's no guarantee you'll see interleaved or out-of-order execution, and the benefits of parallelization will probably be swamped by overhead for a function like this.</p>
</div>
<div class="post-text" itemprop="text">
<p><strike>This looks okay to me. It is likely an issue with waiting for the print buffer to fill.</strike> Look into apply_async: <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.pool.multiprocessing.Pool.apply_async" rel="nofollow noreferrer">https://docs.python.org/2/library/multiprocessing.html#multiprocessing.pool.multiprocessing.Pool.apply_async</a></p>
<p>Also,
The print command is being called, python will not send your <code>print</code> to stdout unless there is enough stuff in there. Try adding a <code>sys.stdout.flush()</code> into your <code>function_to_be_parallellized</code> to force printing ASAP.</p>
</div>
<span class="comment-copy">Welcome to StackOverflow.  Please read and follow the posting guidelines in the help documentation, as suggested when you created this account.  <a href="http://stackoverflow.com/help/mcve">Minimal, complete, verifiable example</a> applies here.  We cannot effectively help you until you post your MCVE code and accurately describe the problem. We should be able to paste your posted code into a text file and reproduce the problem you described.</span>
<span class="comment-copy"><code>for x in xs for y in ys for z in zs</code> almost certainly isn't what you want</span>
<span class="comment-copy">Your function runs in a very quickly.  Just what sort of interleaving did you expect?  Even when I fix just enough errors in your posted code (I'm not sure what it's supposed to demonstrate) to let it run, it does just what I'd expect -- which I believe is what you're describing.</span>
<span class="comment-copy">@Prune, it's impossible for me to write the whole code here so that you can reproduce the problem, it has a lot of dependencies in my own code base. The function is obviously more than I have written here, so it's not fast enough to not get interleaving. I'm trying to understand what can be achieved with mp.pool()</span>
<span class="comment-copy">It's not impossible. The code need only illustrate the fundamental issue you're facing, not be something tied to you or actual issue</span>
<span class="comment-copy">Thanks, the inner function takes actually quite long (many dependencies), so the problem here is with "apply"? then what's the point of having pool.apply if it always executes them serially?</span>
<span class="comment-copy">It absolutely doesn't look ok to me. The list comprehension looks very wrong and there's no desired output given to say otherwise</span>
<span class="comment-copy">Yep, you got me. I always use apply_async, which I believe should work in this case, and is what I was imagining, while apply is blocking. Issues with the list comprehension aside, apply_async should be used here.</span>
