<div class="post-text" itemprop="text">
<p>Because I am used to the old ways of duck typing in Python, I fail to understand the need for ABC (abstract base classes). The <a href="https://docs.python.org/2/library/abc.html" rel="noreferrer">help</a> is good on how to use them.</p>
<p>I tried to read the rationale in the <a href="https://www.python.org/dev/peps/pep-3119/" rel="noreferrer">PEP</a>, but it went over my head. If I was looking for a mutable sequence container, I would check for <code>__setitem__</code>, or more likely try to use it (<a href="https://docs.python.org/2/glossary.html#term-eafp" rel="noreferrer">EAFP</a>). I haven't come across a real life use for the <a href="https://docs.python.org/2/library/numbers.html#module-numbers" rel="noreferrer">numbers</a> module, which does use ABCs, but that is the closest I have to understanding.</p>
<p>Can anyone explain the rationale to me, please?</p>
</div>
<div class="post-text" itemprop="text">
<h3>Short version</h3>
<p>ABCs offer a higher level of semantic contract between clients and the implemented classes.</p>
<h3>Long version</h3>
<p>There is a contract between a class and its callers. The class promises to do certain things and have certain properties. </p>
<p>There are different levels to the contract. </p>
<p>At a very low level, the contract might include the name of a method or its number of parameters. </p>
<p>In a staticly-typed language, that contract would actually be enforced by the compiler. In Python, you can use EAFP or introspection to confirm that the unknown object meets this expected contract.</p>
<p>But there are also higher-level, semantic promises in the contract. </p>
<p>For example, if there is a <code>__str__()</code> method, it is expected to return a string representation of the object. It <em>could</em> delete all contents of the object, commit the transaction and spit a blank page out of the printer... but there is a common understanding of what it should do, described in the Python manual.</p>
<p>That's a special case, where the semantic contract is described in the manual.  What should the <code>print()</code> method do? Should it write the object to a printer or a line to the screen, or something else? It depends - you need to read the comments to understand the full contract here. A piece of client code that simply checks that the <code>print()</code> method exists has confirmed part of the contract - that a method call can be made, but not that there is agreement on the higher level semantics of the call.</p>
<p>Defining an Abstract Base Class (ABC) is a way of producing a contract between the class implementers and the callers. It isn't just a list of method names, but a shared understanding of what those methods should do. If you inherit from this ABC, you are promising to follow all the rules described in the comments, including the semantics of the <code>print()</code> method.</p>
<p>Python's duck-typing has many advantages in flexibility over static-typing, but it doesn't solve all the problems. ABCs offer an intermediate solution between the free-form of Python and the bondage-and-discipline of a staticly-typed language. </p>
</div>
<div class="post-text" itemprop="text">
<p>@Oddthinking's answer is not wrong, but I think it misses the <em>real</em>, <em>practical</em> reason Python has ABCs in a world of duck-typing.</p>
<p>Abstract methods are neat, but in my opinion they don't really fill any use-cases not already covered by duck typing. Abstract base classes' real power lies in <a href="https://docs.python.org/3/library/abc.html#abc.ABCMeta.__subclasshook__" rel="noreferrer">the way they allow you to customise the behaviour of <code>isinstance</code> and <code>issubclass</code></a>. (<code>__subclasshook__</code> is basically a friendlier API on top of Python's <a href="https://docs.python.org/3.3/reference/datamodel.html#customizing-instance-and-subclass-checks" rel="noreferrer"><code>__instancecheck__</code> and <code>__subclasscheck__</code></a> hooks.) Adapting built-in constructs to work on custom types is very much part of Python's philosophy.</p>
<p>Python's source code is exemplary. <a href="https://hg.python.org/cpython/file/8e0dc4d3b49c/Lib/_collections_abc.py#l143" rel="noreferrer">Here</a> is how <code>collections.Container</code> is defined in the standard library (at time of writing):</p>
<pre><code>class Container(metaclass=ABCMeta):
    __slots__ = ()

    @abstractmethod
    def __contains__(self, x):
        return False

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Container:
            if any("__contains__" in B.__dict__ for B in C.__mro__):
                return True
        return NotImplemented
</code></pre>
<p>This definition of <code>__subclasshook__</code> says that any class with a <code>__contains__</code> attribute is considered to be a subclass of Container, even if it doesn't subclass it directly. So I can write this:</p>
<pre><code>class ContainAllTheThings(object):
    def __contains__(self, item):
        return True

&gt;&gt;&gt; issubclass(ContainAllTheThings, collections.Container)
True
&gt;&gt;&gt; isinstance(ContainAllTheThings(), collections.Container)
True
</code></pre>
<p>In other words, <em>if you implement the right interface, you're a subclass!</em> ABCs provide a formal way to define interfaces in Python, while staying true to the spirit of duck-typing. Besides, this works in a way that honours the <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noreferrer">Open-Closed Principle</a>.</p>
<p>Python's object model looks superficially similar to that of a more "traditional" OO system (by which I mean Java*) - we got yer classes, yer objects, yer methods - but when you scratch the surface you'll find something far richer and more flexible. Likewise, Python's notion of abstract base classes may be recognisable to a Java developer, but in practice they are intended for a very different purpose.</p>
<p>I sometimes find myself writing polymorphic functions that can act on a single item or a collection of items, and I find <code>isinstance(x, collections.Iterable)</code> to be much more readable than <code>hasattr(x, '__iter__')</code> or an equivalent <code>try...except</code> block. (If you didn't know Python, which of those three would make the intention of the code clearest?)</p>
<p>That said, I find that I rarely need to write my own ABC and I typically discover the need for one through refactoring. If I see a polymorphic function making a lot of attribute checks, or lots of functions making the same attribute checks, that smell suggests the existence of an ABC waiting to be extracted.</p>
<p><sub>*without getting into the debate over whether Java is a "traditional" OO system...</sub></p>
<hr/>
<p><strong>Addendum</strong>: Even though an abstract base class can override the behaviour of <code>isinstance</code> and <code>issubclass</code>, it still doesn't enter the <a href="https://www.python.org/download/releases/2.3/mro/" rel="noreferrer">MRO</a> of the virtual subclass. This is a potential pitfall for clients: not every object for which <code>isinstance(x, MyABC) == True</code> has the methods defined on <code>MyABC</code>.</p>
<pre><code>class MyABC(metaclass=abc.ABCMeta):
    def abc_method(self):
        pass
    @classmethod
    def __subclasshook__(cls, C):
        return True

class C(object):
    pass

# typical client code
c = C()
if isinstance(c, MyABC):  # will be true
    c.abc_method()  # raises AttributeError
</code></pre>
<p>Unfortunately this one of those "just don't do that" traps (of which Python has relatively few!): avoid defining ABCs with both a <code>__subclasshook__</code> and non-abstract methods. Moreover, you should make your definition of <code>__subclasshook__</code> consistent with the set of abstract methods your ABC defines.</p>
</div>
<div class="post-text" itemprop="text">
<p>A handy feature of ABCs is that if you don't implement all necessary methods (and properties) you get an error upon instantiation, rather than an <a href="https://docs.python.org/2/library/exceptions.html#exceptions.AttributeError" rel="noreferrer" title="exceptions.AttributeError"><code>AttributeError</code></a>, potentially much later, when you actually try to use the missing method.</p>
<pre><code>from abc import ABCMeta, abstractmethod

# python2
class Base(object):
    __metaclass__ = ABCMeta

    @abstractmethod
    def foo(self):
        pass

    @abstractmethod
    def bar(self):
        pass

# python3
class Base(object, metaclass=ABCMeta):
    @abstractmethod
    def foo(self):
        pass

    @abstractmethod
    def bar(self):
        pass

class Concrete(Base):
    def foo(self):
        pass

    # We forget to declare `bar`


c = Concrete()
# TypeError: "Can't instantiate abstract class Concrete with abstract methods bar"
</code></pre>
<p>Example from <a href="https://dbader.org/blog/abstract-base-classes-in-python" rel="noreferrer">https://dbader.org/blog/abstract-base-classes-in-python</a></p>
<p>Edit: to include python3 syntax, thanks @PandasRocks</p>
</div>
<div class="post-text" itemprop="text">
<p>It will make determining whether an object supports a given protocol without having to check for presence of all the methods in the protocol or without triggering an exception deep in "enemy" territory due to non-support much easier.</p>
</div>
<div class="post-text" itemprop="text">
<p>Abstract method make sure that what ever method you are calling in the parent class has to be appear in child class. Below are noraml way of calling and using abstract.
The program written in python3 </p>
<p>Normal way of calling</p>
<pre><code>class Parent:
def methodone(self):
    raise NotImplemented()

def methodtwo(self):
    raise NotImplementedError()

class Son(Parent):
   def methodone(self):
       return 'methodone() is called'

c = Son()
c.methodone()
</code></pre>
<blockquote>
<blockquote>
<p>'methodone() is called'</p>
</blockquote>
</blockquote>
<pre><code>c.methodtwo()
</code></pre>
<blockquote>
<blockquote>
<p>NotImplementedError</p>
</blockquote>
</blockquote>
<p>With Abstract method</p>
<pre><code>from abc import ABCMeta, abstractmethod

class Parent(metaclass=ABCMeta):
    @abstractmethod
    def methodone(self):
        raise NotImplementedError()
    @abstractmethod
    def methodtwo(self):
        raise NotImplementedError()

class Son(Parent):
    def methodone(self):
        return 'methodone() is called'

c = Son()
</code></pre>
<blockquote>
<blockquote>
<p>TypeError: Can't instantiate abstract class Son with abstract methods methodtwo.</p>
</blockquote>
</blockquote>
<p>Since methodtwo is not called in child class we got error. The proper implementation is below</p>
<pre><code>from abc import ABCMeta, abstractmethod

class Parent(metaclass=ABCMeta):
    @abstractmethod
    def methodone(self):
        raise NotImplementedError()
    @abstractmethod
    def methodtwo(self):
        raise NotImplementedError()

class Son(Parent):
    def methodone(self):
        return 'methodone() is called'
    def methodtwo(self):
        return 'methodtwo() is called'

c = Son()
c.methodone()
</code></pre>
<blockquote>
<blockquote>
<p>'methodone() is called'</p>
</blockquote>
</blockquote>
</div>
<span class="comment-copy">I think that you have a point there, but I can't follow you. So what is the difference, in terms of contract, between a class that implements <code>__contains__</code> and a class that inherits from <code>collections.Container</code>? In your example, in Python there was always a shared understanding of <code>__str__</code>. Implementing <code>__str__</code> makes the same promises as inheriting from some ABC and then implementing <code>__str__</code>. In both cases you can break the contract; there are no provable semantics such as the ones we have in static typing.</span>
<span class="comment-copy"><code>collections.Container</code> is a degenerate case, that only includes <code>\_\_contains\_\_</code>, and only to mean the predefined convention. Using an ABC doesn't add much value by itself, I agree. I suspect it was added to allow (for e.g.) <code>Set</code> to inherit from it. By the time you get to <code>Set</code>, suddenly belonging to the the ABC has considerable semantics. An item can't belong to the collection twice. That is NOT detectable by the existence of methods.</span>
<span class="comment-copy">The <code>Set</code> example looks better to me than the <code>print()</code> function. In particular, I didn't understand the higher level contract of the <code>print()</code> method. It looks to me similar to the <code>__contains__</code> and <code>__str__</code> cases, where the semantics of these are documented in their respective help/comments. But when you have a complex object like <code>Set</code>, the semantics are not the semantics of any one function or property of the object. Am I missing something?</span>
<span class="comment-copy">Yes, I think <code>Set</code> is a better example than <code>print()</code>. I was attempting to find a method name whose meaning was ambiguous, and couldn't be grokked by the name alone, so you couldn't be sure that it would do the right thing just by its name and the Python manual.</span>
<span class="comment-copy">Any chance of rewriting the answer with <code>Set</code> as the example instead of <code>print</code>? <code>Set</code> makes a lot of sense, @Oddthinking.</span>
<span class="comment-copy">"if you implement the right interface, you're a subclass" Thanks a lot for that. I don't know if Oddthinking missed it, but I certainly did. FWIW, <code>isinstance(x, collections.Iterable)</code> is clearer for me, and I do know Python.</span>
<span class="comment-copy">Excellent post.  Thank you.  I think that the Addendum, "just don't do that" trap, is a bit like doing normal subclass inheritance but then having the <code>C</code> subclass delete (or screw up beyond repair) the <code>abc_method()</code> inherited from <code>MyABC</code>. The principal difference is that it's the superclass that is screwing up the inheritance contract, not the subclass.</span>
<span class="comment-copy">Would you not have to do <code>Container.register(ContainAllTheThings)</code> for the given example to work?</span>
<span class="comment-copy">@BoZenKhaa The code in the answer works! Try it! The meaning of <code>__subclasshook__</code> is "any class which satisfies this predicate is considered a subclass for the purposes of <code>isinstance</code> and <code>issubclass</code> checks, <b>regardless of whether it was registered with the ABC</b>, and <b>regardless of whether it's a direct subclass</b>". As I said in the answer, <i>if you implement the right interface, you're a subclass!</i></span>
<span class="comment-copy">Yes, of course it does, I was just being blind to a typo in my code, thank you :-). Great post. I should get some IDE.</span>
<span class="comment-copy">The example and the link were both very helpful. Thanks!</span>
<span class="comment-copy">best, clearest illustration.  Instant comprehension</span>
<span class="comment-copy">if Base is defined in a separate file, you must inherit from it as Base.Base or change the import line to 'from Base import Base'</span>
<span class="comment-copy">It should be noted that in Python3 the syntax is slightly different. See this answer: <a href="https://stackoverflow.com/questions/28688784/no-error-while-instantiating-abstract-class-even-though-abstract-method-is-not" title="no error while instantiating abstract class even though abstract method is not">stackoverflow.com/questions/28688784/â€¦</a></span>
<span class="comment-copy">Coming from a C# background, this is the <i>the</i> reason to use abstract classes. You're providing functionality, but stating that the functionality requires further implementation. The other answers seem to miss this point.</span>
<span class="comment-copy">Thanks. Isn't that the same point made in cerberos answer above?</span>
