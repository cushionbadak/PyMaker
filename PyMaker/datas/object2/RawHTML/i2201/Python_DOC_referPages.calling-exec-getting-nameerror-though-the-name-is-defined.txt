<div class="post-text" itemprop="text">
<p>I have a file named <code>file.py</code> containing the following script:</p>
<pre><code>def b():
    print("b") 
def proc():
    print("this is main")
    b()    
proc()
</code></pre>
<p>And I have another file named <code>caller.py</code>, which contains this script:</p>
<pre><code>text = open('file.py').read()
exec(text)
</code></pre>
<p>When I run it, I get the expected output:</p>
<pre><code>this is main 

b
</code></pre>
<p>However, if I change <code>caller.py</code> to this:</p>
<pre><code>def main():
    text = open('file.py').read()
    exec(text)
main()
</code></pre>
<p>I get the following error:</p>
<pre><code>this is main
Traceback (most recent call last):
  File "./caller.py", line 7, in &lt;module&gt;
    main()
  File "./caller.py", line 5, in main
    exec(text)
  File "&lt;string&gt;", line 10, in &lt;module&gt;
  File "&lt;string&gt;", line 8, in main
NameError: global name 'b' is not defined
</code></pre>
<p>How is function <code>b()</code> getting lost?  It looks to me like I'm not violating any scope rules.  I need to make something similar to the second version of <code>caller.py</code> work.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>exec(text)</code> executes <code>text</code> in the current scope, but modifying that scope (as <code>def b</code> does via the implied assignment) is undefined.</p>
<p>The fix is simple:</p>
<pre><code>def main():
    text = open('file.py').read()
    exec(text, {})
</code></pre>
<p>This causes <code>text</code> to run in an empty <em>global</em> scope (augmented with the default <code>__builtins</code> object), the same way as in a regular Python file.</p>
<p>For details, see the <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code> documentation</a>.  It also warns that modifying the default local scope (which is implied when not specifying any arguments besides <code>text</code>) is unsound:</p>
<blockquote>
<p>The default <em>locals</em> act as described for function <code>locals()</code> below: modifications to the default locals dictionary should not be attempted. Pass an explicit <em>locals</em> dictionary if you need to see effects of the code on <em>locals</em> after function <code>exec()</code> returns.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Would it work for you if you imported and called the function instead?</p>
<p>myfile.py</p>
<pre><code>def b():
    print("b") 

def proc():
    print("this is main")
    b()
</code></pre>
<p>caller.py</p>
<pre><code>import myfile

myfile.proc()
</code></pre>
</div>
<span class="comment-copy">I'm curious why you want to do this rather than importing <code>file.py</code>. Anything imported automatically executes all code not under a <code>if __name__ == '__main__'</code> clause, and you can also use functions explicitly like <code>file.proc</code> or <code>file.b</code>. Although your question is interesting just from the mystery angle of what you've pointed out - perhaps that's why you posted rather than looking for a workaround.</span>
<span class="comment-copy">Because it's not calling the same thing all the time--my program reads arbitrary scripts from a database table and executes them on an as-needed basis.</span>
<span class="comment-copy">Pasting the code into <code>main</code> actually wouldn't produce the same error; <code>def b()</code> would define <code>b</code> locally inside <code>main</code>, but all attempts to access <code>b</code> would be inside <code>main</code> too, so things would be fine. The difference with <code>exec</code> is that trying to assign variables (<code>def</code> counts as assignment) is undefined behavior with the default locals, and functions defined with <code>exec</code> don't see locals in the <code>exec</code> scope.</span>
<span class="comment-copy">Thanks, I incorporated this.</span>
<span class="comment-copy">Exactly right.  Thanks!</span>
<span class="comment-copy">No, see comment above.</span>
