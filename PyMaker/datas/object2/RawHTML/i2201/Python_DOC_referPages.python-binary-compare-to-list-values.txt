<div class="post-text" itemprop="text">
<p>I am trying to figure out how to do this in Python:</p>
<p>Print out all subsets of any given set.</p>
<p>For example: <code>[1,2]</code></p>
<p>So the answer is by hand the following:</p>
<pre><code>[]
[2]
[1]
[1,2]
</code></pre>
<p>I realized that the total number of solutions would be <code>2(exp)n</code>, where <code>n</code> is the number of elements in the list.</p>
<p>So for example, if the list is <code>[1,3,4]</code>, then the total number of subsets would be <code>2(exp)3 = 8</code>.</p>
<p>I also realized that if I got the binary bit representation of the list above, the following appears:</p>
<p>So for example: <code>[1,2]</code></p>
<pre><code>00 : []
01 : [2]
10 : [1]
11 : [1,2]
</code></pre>
<p>Each position of the bit that contains a <code>1</code>, that is the position of the subset when indexing it to the original set <code>[1,2]</code>.  eg binary 01 = get index at position 1 of the original set <code>[1,2]</code> which would be <code>[2]</code>.</p>
<p>Binary 11, means get index positions 0 and 1 from the original set <code>[1,2]</code> which gives an answer of <code>[1,2]</code>, etc.</p>
<p>How can I code this, the code I have is so messy, is there a easy way to map this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a loop that iterates through all the binary combinations and a nested loop that tests each bit of the counter to decide whether or not to add the list element of the corresponding index to the output list:</p>
<pre><code>def combinations(l):
    for i in range(1 &lt;&lt; len(l)):
        c = []
        for b in range(len(l)):
            if i &amp; (1 &lt;&lt; (len(l) - b - 1)):
                c.append(l[b])
        yield c
</code></pre>
<p>or with list comprehension:</p>
<pre><code>def combinations(l):
    return [[l[b] for b in range(len(l)) if i &amp; (1 &lt;&lt; (len(l) - b - 1))] for i in range(1 &lt;&lt; len(l))]
</code></pre>
<p>so that:</p>
<pre><code>list(combinations([1, 2])))
</code></pre>
<p>would return:</p>
<pre><code>[[], [2], [1], [1, 2]]
</code></pre>
<p>and:</p>
<pre><code>list(combinations([1, 3, 4]))
</code></pre>
<p>would return:</p>
<pre><code>[[], [4], [3], [3, 4], [1], [1, 4], [1, 3], [1, 3, 4]]
</code></pre>
</div>
<span class="comment-copy">Welcome to Stack Overflow! Please take the tour and read through the help center, in particular how to ask. Your best bet here is to do your research, search for related topics on SO, and give it a go. After doing more research and searching, post a Minimal, Complete, and Verifiable example of your attempt and say specifically where you're stuck, which can help you get better answers!</span>
<span class="comment-copy">Perhaps this might be helpful: <a href="https://stackoverflow.com/questions/374626/how-can-i-find-all-the-subsets-of-a-set-with-exactly-n-elements" title="how can i find all the subsets of a set with exactly n elements">stackoverflow.com/questions/374626/â€¦</a></span>
<span class="comment-copy">have a look at the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a>: <code>def powerset(iterable):</code>  - it creates all of your sets as tuples. maybe you can work from there</span>
<span class="comment-copy">Thank you for your answer, can you explain what this line does exactly?:  for i in range(1 &lt;&lt; len(l)): ( Are they both l,s or 1's? Also why are you minusing the letter l and letter b in this statement: if i &amp; (1 &lt;&lt; (len(l) - b - 1)): Thx in advanced</span>
<span class="comment-copy">You're welcome. By "this line" are you talking about list comprehension? It's just a way to write my first code example more concisely. You can read more about it <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">oh no, I do understand list compreehension, I just don't understand why you are &amp;'ing all binary numbers from 0..4 ( in case of 2 elements in l ) with len(l)-b-1. This line specifically: if i &amp; (1 &lt;&lt; (len(l) - b - 1)): Sorry I am a little slow...</span>
