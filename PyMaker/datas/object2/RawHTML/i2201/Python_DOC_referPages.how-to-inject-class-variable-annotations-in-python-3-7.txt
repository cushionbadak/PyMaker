<div class="post-text" itemprop="text">
<p>In Python 3.7, static fields can be annotated with the following syntax defined in <a href="https://www.python.org/dev/peps/pep-0526/#class-and-instance-variable-annotations" rel="nofollow noreferrer">PEP 526</a>:</p>
<pre><code>class A:
   foo: int
</code></pre>
<p>How can I make these annotations later on, after the class is defined? I would expect the following to work:</p>
<pre><code>A.bar : float
</code></pre>
<p>However, it doesn't seem to have an identical effect to the first code. When we look at <code>A</code>'s <code>__dict___</code>, those two snippets don't have the same effect.</p>
<p>After example 1 <em>and</em> after example 2, we get identical <code>__dict__</code>'s, i.e. the second example must show effect somewhere else. The dict created is:</p>
<pre><code>&gt;&gt; pprint(A.__dict__):
mappingproxy({'__annotations__': {'foo': &lt;class 'int'&gt;}, # &lt;-!
              '__dict__': &lt;attribute '__dict__' of 'A' objects&gt;,
              '__doc__': None,
              '__module__': '__main__',
              '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;})
</code></pre>
<p>I don't think editing <code>__annotations__</code> is a "good" method of achieving what I want, especially because I'm not sure if it's the only case where <code>foo</code> is registered.</p>
<p>What is the proper way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The information used in variable annotations for instance and class attributes is stored in the <code>__annotations__</code> mapping on the class, a dictionary that's writable.</p>
<p>If you want to add to the information stored there, then just add your new information directly to that mapping:</p>
<pre><code>A.__annotations__['bar'] = float
</code></pre>
<p>The <code>A.bar: float</code> annotation is discarded <em>by Python</em>, as there is no dedicated location to store the information for <a href="https://www.python.org/dev/peps/pep-0526/#annotating-expressions" rel="nofollow noreferrer">annotated expressions</a>; it is up to the static type checker implementation to decide if that expression has meaning.</p>
<p>See the <a href="https://www.python.org/dev/peps/pep-0526/#runtime-effects-of-type-annotations" rel="nofollow noreferrer"><em>Runtime Effects of Type Annotations</em> section</a> of <em>PEP 526 -- Syntax for Variable Annotations</em>, the document that defines this syntax:</p>
<blockquote>
<p>In addition, at the module or class level, if the item being annotated is a <em>simple name</em>, then it and the annotation will be stored in the <code>__annotations__</code> attribute of that module or class (mangled if private) as an ordered mapping from names to evaluated annotations.</p>
</blockquote>
<p>and from the <a href="https://docs.python.org/3/reference/simple_stmts.html#annotated-assignment-statements" rel="nofollow noreferrer"><em>Annotated assignment statements</em> section</a> of the Python reference documentation:</p>
<blockquote>
<p>For simple names as assignment targets, if in class or module scope, the annotations are evaluated and stored in a special class or module attribute <code>__annotations__</code> that is a dictionary mapping from variable names (mangled if private) to evaluated annotations. This attribute is writable and is automatically created at the start of class or module body execution, if annotations are found statically.</p>
</blockquote>
<p><code>A.bar</code> is not a simple name, it is an expression, so it is not stored; if you want to retain that information in the <code>__annotations__</code> mapping for runtime access, then manually setting it is the only option.</p>
</div>
<span class="comment-copy">Thanks! It seems you don't get around learning PEP by heart when learning Python ^^</span>
<span class="comment-copy">@Nearoo: actually, this is also properly documented in the Python reference documentation for annotated assigment statements.</span>
<span class="comment-copy">Hm. Never read through the docs. They're down right now, so I can't check. They are really difficult to navigate though, I rarely find such specific pieces of knowledge without reading up on the entire topic.</span>
