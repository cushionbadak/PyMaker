<div class="post-text" itemprop="text">
<p>I want to iterate through a list and sum all the elements. Except, if the number is a 5, I want to skip the number following that 5. So for example:</p>
<p><code>x=[1,2,3,4,5,6,7,5,4,3]   #should results in 30</code>. </p>
<p>I'm just not sure how I can access the index of a tuple, when I use enumerate. What I want to do, is use an if statement, that if the number at the previous index == 5, continue the loop.</p>
<p>Thanks you</p>
</div>
<div class="post-text" itemprop="text">
<p>Not a fan of bug-ridden one-liners that get upvoted. </p>
<p>So here's the answer with a for-loop. </p>
<pre><code>x=[1,2,3,4,5,6,7,5,4,3, 5] #should results in 35. 

s = 0
for i, v in enumerate(x):
    if i != 0 and x[i-1] == 5: 
        continue 
    s += v

print(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> documentation</a> has a recipe for this called <strong><code>pairwise</code></strong>. You can either copy-paste the function or import it from <a href="https://pypi.org/project/more-itertools/" rel="nofollow noreferrer"><code>more_itertools</code></a> (which needs to be installed).</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from more_itertools import pairwise
&gt;&gt;&gt; 
&gt;&gt;&gt; x = [1,2,3,4,5,6,7,5,4,3]
&gt;&gt;&gt; x[0] + sum(m for n, m in pairwise(x) if n != 5)
30
</code></pre>
<p>edit: </p>
<blockquote>
<p><strong>But what if my datastructure is iterable, but does not support indexing?</strong></p>
</blockquote>
<p>In this case, the above solution needs a minor modification.</p>
<pre><code>&gt;&gt;&gt; from itertools import tee
&gt;&gt;&gt; from more_itertools import pairwise
&gt;&gt;&gt; 
&gt;&gt;&gt; x = (n for n in [1,2,3,4,5,6,7,5,4,3]) # generator, no indices!
&gt;&gt;&gt; it1, it2 = tee(x)
&gt;&gt;&gt; next(it1, 0) + sum(m for n, m in pairwise(it2) if n != 5)
30
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>sum</code> with <code>enumerate</code></p>
<p><strong>Ex:</strong></p>
<pre><code>x=[1,2,3,4,5,6,7,5,4,3]
print(sum(v for i, v in enumerate(x) if (i == 0) or (x[i-1] != 5)))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>30
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple, verbose way:</p>
<pre><code>SKIP_PREV = 5
x = [1,2,3,4,5,6,7,5,4,3]
prev = -1
s = 0
for num in x:
    if prev != SKIP_PREV:
        s += num
    prev = num
print(s)
# 30
</code></pre>
<p>Compact, maybe less clear way:</p>
<pre><code>SKIP_PREV = 5
x = [1,2,3,4,5,6,7,5,4,3]
s = sum(num for i, num in enumerate(x) if i == 0 or x[i - 1] != SKIP_PREV)
print(s)
# 30
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are happy to use a 3rd party library, you can use NumPy with integer indexing:</p>
<pre><code>import numpy as np

x = np.array([1,2,3,4,5,6,7,5,4,3])

res = x.sum() - x[np.where(x == 5)[0]+1].sum()  # 30
</code></pre>
<p>See also <a href="https://stackoverflow.com/questions/993984/what-are-the-advantages-of-numpy-over-regular-python-lists">What are the advantages of NumPy over regular Python lists?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can pair the list with a shifted version of itself.  This should work:</p>
<pre><code>sum(val for (prev, val)
    in zip(itertools.chain((None,), x), x)
    if prev != 5 )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The longest code so far. Anyway, it does not need enumerate, it is a simple <a href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="nofollow noreferrer">FSM</a>.</p>
<pre><code>x = [1,2,3,4,5,6,7,5,4,3]
skip = False
s = 0 
for v in x:
    if skip:
        skip = False
    else:
        s += v
        skip = v == 5
print(s)
</code></pre>
</div>
<span class="comment-copy"><code>enumerate</code> gives you the index and the value. <code>for i, value in enumerate(x)</code> where <code>i</code> is the index</span>
<span class="comment-copy">What do you mean you canâ€™t access the index of a triple using enumerate? enumerate returns a generator of (index, value) pairs. Just iterate over that object returned by enumerate using something like <code>for index, value in enumerate(obj)</code></span>
<span class="comment-copy">I would prefer if you commented on each buggy oneliner individually instead of dismissing all of them. But your solution is straight forward and deserves an upvote.</span>
