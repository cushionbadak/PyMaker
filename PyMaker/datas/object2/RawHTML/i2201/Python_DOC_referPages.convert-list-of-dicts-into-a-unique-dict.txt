<div class="post-text" itemprop="text">
<p>I have:</p>
<pre><code>[
  {'id': 1, 'name': 'foo'},
  {'id': 2, 'name': 'bar'},
  {'id': 1, 'name': 'gesiel'}
]
</code></pre>
<p>I want:</p>
<pre><code>{
  1: [
    {'id': 1, 'name': 'foo'},
    {'id': 1, 'name': 'gesiel'}
  ],
  2: [
    {'id': 2, 'name': 'bar'}
  ]
}
</code></pre>
<p>This code does this:</p>
<pre><code>organized = {d['id']:[] for d in data}
[organized[d['id']].append(d) for d in data]
</code></pre>
<p>Is there a more pythonic way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><strong><code>collections.defaultdict</code></strong></a>:</p>
<pre><code>from collections import defaultdict

data = [{'id': 1, 'name': 'foo'}, {'id': 2, 'name': 'bar'}, {'id': 1, 'name': 'gesiel'}]

d = defaultdict(list)

for x in data:
    d[x['id']].append(x)

print(d)
# defaultdict(&lt;class 'list'&gt;, {1: [{'id': 1, 'name': 'foo'}, {'id': 1, 'name': 'gesiel'}], 2: [{'id': 2, 'name': 'bar'}]})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <em>groupby.itertools</em> we can create this <em>dicitonary</em></p>
<pre><code>from itertools import groupby
lista = [{'id': 1, 'name': 'foo'}, {'id': 2, 'name': 'bar'}, {'id': 1, 'name': 'gesiel'}]

d = {}
for k, g in groupby(sorted(lista, key=lambda x: x['id']), key=lambda x: x['id']):
    d[k] = list(g)
# {1: [{'id': 1, 'name': 'foo'}, {'id': 1, 'name': 'gesiel'}], 2: [{'id': 2, 'name': 'bar'}]}
</code></pre>
<p>or using <em>dictionary comprehension</em></p>
<pre><code>d = {k: list(g) for k, g in groupby(sorted(lista, key=lambda x: x['id']), key=lambda x: x['id'])}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is nothing wrong with a 2-pass O(<em>n</em>) solution if you are, as here, working with an in-memory object. The main issue with your code is you are misusing the list comprehension.</p>
<p>A list comprehension should be used to <em>construct</em> a new list, not to process an in-place function or method in a loop. Taking your example, your logic will create a list which looks like:</p>
<pre><code>[None, None, None, ..., None]
</code></pre>
<p>The <em>side-effect</em> of the comprehension means that <code>organized</code> values have items appended to them as required. Instead, you can rewrite using a simple <code>for</code> loop:</p>
<pre><code>organized = {d['id']: [] for d in data}

for d in data:
    organized[d['id']].append(d)
</code></pre>
<p>Your logic can be made more efficient by <em>not</em> adding keys via an initial iteration. This common problem is resolved by <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>, as in <a href="https://stackoverflow.com/a/52679753/9209546">@Austin's solution</a>. This solution gives an empty list for any key which does not exist:</p>
<pre><code>from collections import defaultdict

res = defaultdict(list)

for d in data:
    res[d['i']].append(d)

print(res)

defaultdict(list,
            {1: [{'id': 1, 'name': 'foo'}, {'id': 1, 'name': 'gesiel'}],
             2: [{'id': 2, 'name': 'bar'}]})
</code></pre>
<p>Since <code>defaultdict</code> is a subclass of <code>dict</code>, there's usually no need to convert this back to a regular dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/52679753/5491375">Austin's</a> answer is better, but here method just using <code>dict</code>s</p>
<pre><code>In [175]: data = [{'id': 1, 'name': 'foo'}, {'id': 2, 'name': 'bar'}, {'id': 1, 'name': 'gesiel'}]

In [176]: organised = {}

In [177]: for d in data:
     ...:     if d['id'] in organised:
     ...:         organised[d['id']].append(d)
     ...:     else:
     ...:         organised[d['id']] = [d]
     ...:

In [178]: organised
Out[178]:
{1: [{'id': 1, 'name': 'foo'}, {'id': 1, 'name': 'gesiel'}],
 2: [{'id': 2, 'name': 'bar'}]}
</code></pre>
</div>
<span class="comment-copy">Why is this not a Pythonic way?  I feel like two line solution is pretty legit solution for python.</span>
<span class="comment-copy">the problem is that it does two iterations over data, when just one is required</span>
<span class="comment-copy">The other problem is that it's using list comprehensions for side-effects, which is distinctly anti-Pythonic.</span>
