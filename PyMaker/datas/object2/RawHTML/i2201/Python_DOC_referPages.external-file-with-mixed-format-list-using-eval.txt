<div class="post-text" itemprop="text">
<p>I'm reading, updating and writing the following single line of data to a separate <code>fruit.txt</code> file, in this specific structure and format:</p>
<p><code>[["Peach",0,0,0], ["Banana",0,0,0], ["Apple",0,0,0], ["Pear",0,0,0], ["Mango",0,0,0], ["Orange",0,0,0], ["Apricot",0,0,0]]</code></p>
<p>When I do this at the start of the Python file </p>
<p><code>with open("fruit.txt") as file:
    fruit = file.read()</code></p>
<p>It correctly assigns the data in <code>fruit.txt</code> to the <code>fruit</code> var. When I <code>print(fruit)</code>, it even looks like the intended nested list.</p>
<p>However, when I come to query <code>fruit</code> var e.g. dynamically changing the <code>0</code>'s via other functions, or when I try to sort the nested list, or do anything to alter the data, it always returns various errors. It's as though when it sets the <code>fruit</code> var to the data from the file, it doesn't recognise it as a nested list, but more a string. So therefore I can't operate on that list.</p>
<p>If however I do:</p>
<p><code>with open("fruit.txt") as file:
    fruit_count = file.read()
    fruit = eval(fruit_count)</code></p>
<p>Then the <code>fruit</code> var behaves fine - values update and it writes back to the file ready for further use etc.</p>
<p>I understand <code>eval</code> is theoretically evil (or at least should be avoided under most circumstances) unless you trust the data source (which I do in this instance). But I'm just wondering if there's a different solution?</p>
<p>Ideally I don't want to use any additional modules e.g. <code>ast.literal_eval</code></p>
</div>
<div class="post-text" itemprop="text">
<p>It may not be ideal, but here's how to do it with the <code>json</code> module (even though you don't want to use an additional module):</p>
<pre><code>import json
from pprint import pprint

lists = [["Peach",0,0,0], ["Banana",0,0,0], ["Apple",0,0,0], ["Pear",0,0,0],
         ["Mango",0,0,0], ["Orange",0,0,0], ["Apricot",0,0,0]]

with open("fruits.json", "w") as fp:
    json.dump(lists, fp)

with open("fruits.json", "r") as fp:
    fruits = json.load(fp)

pprint(fruits)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>[['Peach', 0, 0, 0],
 ['Banana', 0, 0, 0],
 ['Apple', 0, 0, 0],
 ['Pear', 0, 0, 0],
 ['Mango', 0, 0, 0],
 ['Orange', 0, 0, 0],
 ['Apricot', 0, 0, 0]]
</code></pre>
<p>Note that the data read back <em>does</em> indeed have the proper data-types in it.</p>
</div>
<span class="comment-copy">If you don't want to use library modules and you don't want to use <code>eval</code>, you're left with writing your own parser. I'd imagine it's easier to just use <code>ast.literal_eval</code> though if you insist on that format.</span>
<span class="comment-copy">If you are willing to use a different storage format, you could probably make manually writing parsing code easier by structuring your text file with two different delimiters for the two layers of nesting instead of the Python list format, or some kind of binary format.</span>
<span class="comment-copy">OK thanks - so is my assessment right that without using eval(), it's simply interpreting the fruit var as a string?</span>
<span class="comment-copy">Even though you don't want to use additional modules, everything would be a lot easier if you saved the initial list-of-lists vwith Python's <a href="https://docs.python.org/3/library/pickle.html#module-pickle" rel="nofollow noreferrer"><code>pickle</code></a> module. See my answer to the question <a href="https://stackoverflow.com/questions/4529815/saving-an-object-data-persistence">Saving an Object (Data persistence)</a> for more information and example code.</span>
<span class="comment-copy">@martineau Can we please not recommend pickle - which comes with a risk of arbitrary code execution - when JSON would be absolutely sufficient?</span>
<span class="comment-copy">Thanks for showing me with JSON. Is there any benefit to using JSON other than avoiding eval()? Although if I'm gonna use JSON then I guess I could just import ast and swap eval() for ast.literal_eval instead?</span>
<span class="comment-copy">@user9099702: The main advantage is that JSON format is an externally defined standard format supported by many computer languages. Data stored via <code>ast</code> is inherently Python-specific and not supported by many (any?) other languages. In both cases, the data in the file would be human-readable, so they're even in that regard (if you even care). Using the <code>pickle</code> module would also be very Python-centeric.</span>
<span class="comment-copy">Got it - thanks!</span>
<span class="comment-copy">json also tends to be faster then <code>ast.literal_eval</code> and <code>eval</code>.</span>
<span class="comment-copy">Nice, thanks avram. Although in this instance I guess speed isn't so much an issue as the external file is only ever gonna be 1 line.</span>
