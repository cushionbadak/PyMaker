<div class="post-text" itemprop="text">
<p>Disclaimer: I am a total beginner in aiohttp</p>
<p>I was experimenting with aiohttp to handle get requests asynchronously but It turned out to be horribly slower than the pool version of gevent.</p>
<p>GEVENT VERSION</p>
<pre><code>import gevent
from gevent import monkey
monkey.patch_all()
from gevent.pool import Pool

import requests
import time

def pooling_task(url):
    requests.get(url)


def pooling_main():
    start = time.time()
    pool = Pool(10)
    urls = [
        "http://google.com",
        "http://yahoo.com",
        "http://linkedin.com",
        "http://shutterfly.com",
        "http://mypublisher.com",
        "http://facebook.com"
    ]
    for url in urls:
        pool.apply_async(pooling_task, args=(url,))

    pool.join()
    end = time.time()
    print("POOL TIME {}".format(end-start))

if __name__ == '__main__':
    print("POOLING VERSION")
    pooling_main()
</code></pre>
<p>OUTPUT - POOL TIME 6.299163818359375</p>
<p>Following is the aiohttp version</p>
<pre><code>import aiohttp
import asyncio
import time
import uvloop

asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())

async def fetch(session, url):
    async with session.get(url) as response:
        return await response.text()


async def main():
    urls = [
        "http://google.com",
        "http://yahoo.com",
        "http://linkedin.com",
        "http://shutterfly.com",
        "http://mypublisher.com",
        "http://facebook.com"]

    async with aiohttp.ClientSession() as session:
        for url in urls:
            await fetch(session, url)

if __name__ == "__main__":
    start = time.time()
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    end = time.time()
    print("Time taken {}".format(end - start))
</code></pre>
<p>OUTPUT - Time taken 15.399710178375244</p>
<p>I really don't understand why aiohttp is so much slower. 
As for gevent version requests.get is still a blocking call , but not for aiohttp.</p>
<p>I expected aiohttp version to be faster.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>for url in urls:
    await fetch(session, url)
</code></pre>
<p><code>await</code> here means that you don't start downloading next url before previous done. To make all downloadings concurrent you should use something like <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="noreferrer">asyncio.gather</a>.</p>
<p>Modify your code like this:</p>
<pre><code>async with aiohttp.ClientSession() as session:
    await asyncio.gather(*[
        fetch(session, url)
        for url
        in urls
    ])
</code></pre>
<p>You'll see huge speedup.</p>
</div>
<span class="comment-copy">Thanks, this implementation works.  But wouldn't await fetch(session,url) be a blocking call , so event loop will get next element from loop and start fetching the next?</span>
<span class="comment-copy">Oh, How stupid I am. When in the for loop, eventloop has noting else to run. But in case of gather, it has other coroutines to go through (the ones which were made by the fetch)</span>
