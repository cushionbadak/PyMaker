<div class="post-text" itemprop="text">
<p>So for example, I have a tuple:</p>
<pre><code>(7, 5, 3, 3, 6, 3, 9)
</code></pre>
<p>and I would want to take out only the first number 3 in that tuple so that it would look like this instead:</p>
<pre><code>(7, 5, 3, 6, 3, 9)
</code></pre>
<p>The code I've written uses the filter tool to take out the 3, however it takes out all the other 3's as well:</p>
<pre><code>def takeOut(k, r):
    newK = tuple(filter(lambda x: x != r, k))
    return newK

print(takeOut((7, 5, 3, 3, 6, 3, 9), 3))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd go with slicing:</p>
<pre><code>def remove_element(seq, element):
    try:
        index = seq.index(element)
        return seq[:index] + seq[index + 1:]
    except ValueError:  # element doesn't exist
        return seq
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason this isn't as straightforward as one might think is that tuples are immutable. </p>
<p>An easy way would be to convert to <code>list</code>, use <code>remove</code> to remove the first instance, and convert back to tuple:</p>
<pre><code>t = (7, 5, 3, 3, 6, 3, 9)

t2 = list(t)
t2.remove(3)
tuple(t2)
# (7, 5, 3, 6, 3, 9)
</code></pre>
<p>As a Function:</p>
<pre><code>def takeOut(k, r):
    k2 = list(k)
    k2.remove(r)
    return tuple(k2)

takeOut((7, 5, 3, 3, 6, 3, 9), 3)
# (7, 5, 3, 6, 3, 9)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can make use of the fact that <code>index</code> only returns the first index of an element, and cast the generator expression back to a tuple:</p>
<pre><code>&gt;&gt;&gt; tuple(e for i, e in enumerate(k) if i != k.index(3))
(7, 5, 3, 6, 3, 9)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The fastest and often the simplest way to do things in Python is to use any built-in methods it has whenever possible. In this case that would be tuple (sequence) methods (see <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow noreferrer">Common Sequence Operations</a> in the documentation for details):</p>
<pre><code>def remove_first_inst(seq, elem):
    try:
        i = seq.index(elem)
    except ValueError:
        return seq  # elem was not in sequence.
    return seq[:i] + seq[i+1:]


t = (7, 5, 3, 3, 6, 3, 9)

print(remove_first_inst(t, 3))  # -&gt; (7, 5, 3, 6, 3, 9)
</code></pre>
<p>Doing it that way in this case means the function would also work with <code>list</code>s, since they're also sequences.</p>
</div>
<div class="post-text" itemprop="text">
<p>Tuples are immutable, which wouldn't really be "removing an object" from the tuple.</p>
<p>When you remove it, you'll be creating a new tuple.
There's probably <em>hundreds</em> of ways to solve this.</p>
<pre><code>def takeOut(k, r):
    first = True
    newK = []
    for item in k:
       if first and item == r:
           first = False
           continue
       newK.append(item)
    return tuple(newK)

print(takeOut((7, 5, 3, 3, 6, 3, 9), 3))
</code></pre>
</div>
<span class="comment-copy">As I'm copying this from my vim.... gj :)</span>
<span class="comment-copy">I had the exact same solution. I'm checking if there are any faster one</span>
<span class="comment-copy">A general solution would be nice to have which removes all similar pairs to just first occurrence...</span>
