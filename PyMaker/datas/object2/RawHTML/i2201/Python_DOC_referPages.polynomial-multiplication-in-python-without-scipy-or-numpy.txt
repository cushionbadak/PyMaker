<div class="post-text" itemprop="text">
<p>I'm trying to write a function that multiplies two polynomials given as input, and I'm facing an issue with ordering the coefficient list.</p>
<p>Suppose, a polynomial can be expressed with two elements: <strong>idx</strong> (exponents) and <strong>coef</strong> (coefficient). Key thing to note is that the idx list is ordered by exponential degree and the coefficients are ordered in corresponding order to the respective exponents.</p>
<p>Take a look at the example below.</p>
<blockquote>
<p>idx1 = [5, 4, 0], coef1 = [1, 2, 3] would represent polynomial1 = x^5+2x^4+3x^0</p>
<p>idx2 = [5, 3], coef2 = [1, 5] would represent polynomial2 = x^5+5x^3</p>
</blockquote>
<p>I want my function mult_coef(idx1, coef1, idx2, coef2) to return two lists: idx_mult and coef_mult, like this: </p>
<blockquote>
<p>ideal output:</p>
<p>idx_mult = [10, 9, 8, 7, 5, 3]</p>
<p>coef_mult = [1, 2, 5, 10, 3, 15]</p>
</blockquote>
<p>I wrote a function to get the idx part:</p>
<pre><code>def mult_idx(idx1, idx2):
    from itertools import combinations, product
    def pairs(*lists):
        for t in combinations(lists, 2):
            for pair in product(*t):
                yield pair

    output = list(set(pairs(idx1,idx2)))
    output = sorted([x+y for x,y in output],reverse=True)
    return sorted(list(set(output)),reverse=True)

#matches ideal idx, but still need coefficients
mult_idx(idx1,idx2) &gt;&gt;&gt; [10, 9, 8, 7, 5, 3]

def mult_coef(idx1, coef1, idx2, coef2):
    coef_output = list(pairs(coef1,coef2))
    coef_output = [x*y for x,y in coef_output]
    return coef_output

#Doesn't match the ideal coefficient output (order is wrong, should be [1, 2, 5, 10, 3, 15])
mult_coef(idx1, coef1, idx2, coef2) &gt;&gt;&gt; [1, 5, 2, 10, 3, 15]
</code></pre>
<p>Any idea how to tackle this problem? Been stuck for too long, and I don't think Scipy or Numpy's poloynomial implementations can handle this case specifically, if not please feel free to use either.</p>
</div>
<div class="post-text" itemprop="text">
<p>you could easily solve that with a <a href="https://docs.python.org/3/library/collections.html?collections.defaultdict#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> (a dict may be a better representation for your polynomials... <code>poly = {exp: coeff}</code>)</p>
<pre><code>from collections import defaultdict

mult = defaultdict(int)  # mult[i] will default to 0

for i1, c1 in zip(idx1, coef1):
    for i2, c2 in zip(idx2, coef2):
        mult[i1 + i2] += c1 * c2
</code></pre>
<p>for your input this gives</p>
<pre><code>mult = defaultdict(&lt;class 'int'&gt;, {10: 1, 8: 5, 9: 2, 7: 10, 5: 3, 3: 15})
</code></pre>
<p>then you can arrange that into the lists you are interested in:</p>
<pre><code>mult_sorted = tuple(sorted(mult.items(), reverse=True))
idx_mult = [item[0] for item in mult_sorted]
# [10, 9, 8, 7, 5, 3]
coeff_mult = [item[1] for item in mult_sorted]
# [1, 2, 5, 10, 3, 15]
</code></pre>
<p>none of this is thoroughly tested!</p>
<hr/>
<p>it may be a bit more elegant to reduce the indentation of the <code>for</code> loops:</p>
<pre><code>from itertools import product

for (i1, c1), (i2, c2) in product(zip(idx1, coef1), zip(idx2, coef2)):
    mult[i1 + i2] += c1 * c2
</code></pre>
</div>
<span class="comment-copy">thank you, such as elegant solution indeed</span>
<span class="comment-copy">you are very welcome! had to implement polynomial multiplication / division / extended euler / ... recently; so i was already very close to your problem.</span>
