<div class="post-text" itemprop="text">
<p>I'm writing a Python3 script with some computationally heavy sections in C, using the Python C API. When dealing with int64s, I can't figure out how to ensure that an input number is an unsigned int64; that is , if it's smaller than 0. As the <a href="https://docs.python.org/3/c-api/arg.html#numbers" rel="nofollow noreferrer">official documentation</a> suggests, I'm using <code>PyArg_ParseTuple()</code> with the formatter <code>K</code> - which does <strong>not</strong> check for overflow. Here is my C code:</p>
<pre><code>static PyObject* from_uint64(PyObject* self, PyObject*){
    uint64_t input;
    PyObject* output;

    if (!PyArg_ParseTuple(args, "K", &amp;input)){
        return PyErr_Format(PyExc_ValueError, "Wrong input: expected unsigned 64-bit integer.");
    }

    return NULL;
}
</code></pre>
<p>However, calling the function with a negative argument throws no error, and the input number is casted to unsigned. E.g., <code>from_uint64(-1)</code> will result in <code>input=2^64-2</code>. As expected, since there's no overflow check. </p>
<p>What would be the correct way of determining whether the input number is negative, possibly before parsing it?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use</p>
<pre><code>unsigned long long input = PyLong_AsUnsignedLongLong(args);
</code></pre>
<p>You can then check with</p>
<pre><code>if (PyErr_Occurred()) {
    // handle out of range here
}
</code></pre>
<p>if the number was unsuitable for an <code>unsigned long long</code>.</p>
<p>See also <a href="https://docs.python.org/3/c-api/long.html" rel="nofollow noreferrer" title="Documentation on Integer Objects">the Python 3 API documentation on Integer Objects</a></p>
</div>
<div class="post-text" itemprop="text">
<p>With a little modification from @Ctx 's answer:</p>
<p>The solution is to first parse the input as an object (so, not directly from <code>args</code>), then check its type:</p>
<pre><code>static PyObject* from_uint64(PyObject* self, PyObject* args){
    PyObject* output;
    PyObject* input_obj;
    if (!PyArg_ParseTuple(args, "O", &amp;input_obj)){
        return PyErr_Format(PyExc_TypeError, "Wrong input: expected py object.");
    }
    unsigned long long input = PyLong_AsUnsignedLongLong(input_obj);
    if(input == -1 &amp;&amp; PyErr_Occurred()) {
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "Parameter must be an unsigned integer type, but got %s", Py_TYPE
        (input_obj)-&gt;tp_name);
    }
</code></pre>
<p>This code, as expected, works on any input in [0, 2^64-1] and throws error on integers outside the boundaries as well as illegal types like float, string, etc.</p>
</div>
<span class="comment-copy">there is no <i>overflow</i> with unsigned integers. C specifies that they follow modulo arithmetic.</span>
<span class="comment-copy">also do note that <code>K</code> <b>does not parse <code>uint64_t</code> but <code>unsigned long long</code></b>, hence it is not strictly correct to assume that <code>uint64_t</code> is the same as unsigned long long.</span>
<span class="comment-copy">@AnttiHaapala thanks for the correction, I will add the proper type.</span>
<span class="comment-copy">Thank you for your answer. The only problem I still have is the case in which the input number is small - e.g. if calling <code>from_uint64(2)</code> now throws an error. Should I do some kind of casting from Python? I want to accept any number in the range [0, 2^64-1].</span>
<span class="comment-copy">@FTeod Which error is thrown? I do not see a reason, why the input <code>2</code>  should be a problem.</span>
<span class="comment-copy">I get <code>TypeError: an integer is required</code>. The code being the three lines above, and inside the <code>if(PyErr_Occurred()) { PyErr_Print(); return NULL;}</code></span>
