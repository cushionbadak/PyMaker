<div class="post-text" itemprop="text">
<p>From <a href="https://stackoverflow.com/a/31464349/5199226">here</a>, i found that when a signal is received, <code>exit_gracefully</code> is called meanwhile the code inside <code>while True</code> is running. At first i thought that handler is running in another thread so i wrote a code to test it out:</p>
<pre><code>import os
import signal
import threading

def sig_handler(signal_frame, num):
    print('handler PID: {}'.format(os.getpid()))
    print('current thread identity: {}'.format(threading.current_thread().ident))

signal.signal(signal.SIGTERM, sig_handler)

try:
    print('main execution PID: {}'.format(os.getpid()))
    print('current thread identity: {}'.format(threading.current_thread().ident))
    while True:
        time.sleep(5)
        print('Hello')
except KeyboardInterrupt:
    print('Good bye')
</code></pre>
<p>I ran the code and first sent a <code>SIGTERM</code> signal (using <code>kill -SIGTERM pid</code> command) and then sent a <code>SIGINT</code> signal. The output was:</p>
<pre><code>main execution PID: 1002
current thread identity: 140284238558976
Hello
Hello
handler PID: 1002
current thread identity: 140284238558976
Hello
Hello
Good bye
</code></pre>
<p>You see that everything is the same, but how it's possible that the handler is running in the same exact context that main code is executing? Shouldn't be in another thread?</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer you're looking for is right in the python <a href="https://docs.python.org/3/library/signal.html#execution-of-python-signal-handlers" rel="nofollow noreferrer">signal documentation</a>:</p>
<blockquote>
<p>Python signal handlers are always executed in the main Python thread, even if the signal was received in another thread.</p>
</blockquote>
<p>Also:</p>
<blockquote>
<p>the low-level signal handler sets a flag which tells the virtual machine to execute the corresponding Python signal handler at a later point</p>
</blockquote>
<p>So when a signal is received, the handler doesn't execute alongside the code in the <code>while</code> loop. Instead, the virtual machine executing your code is told to run the signal handling code 'soon', which could be after X number of bytecode instructions, so essentially your loop goes on pause while the handler code is running. Changing your code a little demonstrates this:</p>
<pre><code>def sig_handler(signal_frame, num):
    print('handler PID: {}'.format(os.getpid()))
    print('current thread identity: {}'.format(threading.current_thread().ident))
    time.sleep(5) # we put a long delay here

signal.signal(signal.SIGTERM, sig_handler)

try:
    print('main execution PID: {}'.format(os.getpid()))
    print('current thread identity: {}'.format(threading.current_thread().ident))
    while True:
        time.sleep(1) # sleep less now
        print('Hello')
except KeyboardInterrupt:
    print('Good bye')
</code></pre>
<p>Now, when you send your SIGTERM, you'll notice the execution of your while loop pauses for 5s.</p>
</div>
