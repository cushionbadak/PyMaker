<div class="post-text" itemprop="text">
<p>I have a function that makes JSON flat:</p>
<pre><code>def flat_json(z, sep):
    val = {}
    for i in z.keys():
        if isinstance(z[i], dict):
            get = flat_json(z[i], sep)
            for j in get.keys():
                val[i + sep + j] = get[j]
        else:
            val[i] = z[i]

    return val


flat_json({"a": "b", "c": {"d": "g"}}, '__')
# returns {'a': 'b', 'c__d': 'g'}
</code></pre>
<p>But I have not yet figured out how to convert the flat JSON back</p>
</div>
<div class="post-text" itemprop="text">
<p>Unflattening back to arbitrarily nested dictionaries requires that you create new dictionaries for arbitrary paths; <code>c__d</code> means that there must be a nested dictionary associated with the <code>c</code> key, so you can set <code>d</code> in there. <code>c__d__e</code> means <code>c</code> is a dictionary with a <code>d</code> key pointing to another dictionary, were <code>e</code> is set, etc. Essentially, everything but the last element in <code>key.split('__')</code> is a key in a dictionary pointing to another dictionary, and you need to create those dictionaries if they have not yet been created, in a loop.</p>
<p>You can use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce()</code></a> to do this, see <a href="https://stackoverflow.com/questions/23011146/recursive-access-to-dictionary-and-modification/23013719#23013719">this previous answer of mine</a> for an explanation of the <code>get_nested_default()</code> and <code>set_nested()</code> functions:</p>
<pre><code>from functools import reduce

def get_nested_default(d, path):
    return reduce(lambda d, k: d.setdefault(k, {}), path, d)

def set_nested(d, path, value):
    get_nested_default(d, path[:-1])[path[-1]] = value

def unflatten(d, separator='__'):
    output = {}
    for k, v in d.items():
        path = k.split(separator)
        set_nested(output, path, v)
    return output
</code></pre>
<p><code>get_nested_default()</code> takes care of creating those nested dictionaries if they don't yet exist, for any number of keys. <code>set_nested()</code> takes care of separating out the last key in a path from the remainder, and setting the value in the innermost dictionary.</p>
<p>This assumes that the input never used <code>__</code> in keys originally, of course. But as long as you pick a path separator that's not used as a substring of any of the keys in the input dictionary, you can un-flatten back to the original form.</p>
<p>Demo on your example:</p>
<pre><code>&gt;&gt;&gt; unflatten({'a': 'b', 'c__d': 'g'})
{'a': 'b', 'c': {'d': 'g'}}
</code></pre>
<p>and a more complex one using a different separator:</p>
<pre><code>&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; flat = {
...     'foo::bar::baz': 'Eric Idle',
...     'foo::bar::spam': 'John Cleese',
...     'foo::spam::ham': 'Terry Gilliam',
...     'spam::ham': 'Vikings singing'
... }
&gt;&gt;&gt; nested = unflatten(flat, '::')
&gt;&gt;&gt; pprint(nested)
{'foo': {'bar': {'baz': 'Eric Idle', 'spam': 'John Cleese'},
         'spam': {'ham': 'Terry Gilliam'}},
 'spam': {'ham': 'Vikings singing'}}
</code></pre>
</div>
<span class="comment-copy">Why do you want to flattent it like this in the first place?</span>
