<div class="post-text" itemprop="text">
<p>In Python 3 I am trying to print the outputs of a <code>**kwargs</code> using a list comprehension. I am unable to do so while using a <code>for</code> loop does print the elements of my list input. Below is the reproducible code:</p>
<p>Using list comprehension:</p>
<pre><code>class Practice(object):
    __acceptable_keys_list = ['Right', 'left']

    def __init__(self, **kwargs):
        temp = ([self.__setattr__(key, kwargs.get(key)) for key in self.__acceptable_keys_list])
        print(temp)
</code></pre>
<p>Output is <code>[None, None]</code>. </p>
<p>Where as using a <code>for</code> loop:</p>
<pre><code>class Practice(object):
    __acceptable_keys_list = ['Right', 'Left']

    def __init__(self, **kwargs):   
         for key in self.__acceptable_keys_list:
             self.__setattr__(key,kwargs.get(key))
             print(key)
</code></pre>
<p>Output is <code>[Right, Left]</code>. </p>
<p>Why the difference ? What am I missing ? Shouldn't list comp and for loops behave in similar manner?</p>
<p><strong>Edit:</strong> Why the downvotes ? I am trying to understand things here.  </p>
</div>
<div class="post-text" itemprop="text">
<h3>Coding Style</h3>
<p>You are abusing a side-effect in a list comprehension. This is <a href="https://stackoverflow.com/questions/5753597/">considered very bad practice</a>.</p>
<h3>Return Value of __setattr__</h3>
<p>Nonetheless, as already mentioned by @Aran-Fey, <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer">__setattr__</a> returns <code>None</code>. Your Code is not equivalent. The following code does the same:</p>
<pre><code>class Practice(object):
    __acceptable_keys_list = ['Right', 'Left']

    def __init__(self, **kwargs):
        # Please do **NOT** do this at home!
        temp = ([self.__setattr__(key, kwargs.get(key)) for key in self.__acceptable_keys_list])
        print(temp)

class Practice(object):
    __acceptable_keys_list = ['Right', 'Left']

    def __init__(self, **kwargs):
         temp = []
         for key in self.__acceptable_keys_list:
             # Use the return value of __setattr__, which is None
             temp.append(self.__setattr__(key,kwargs.get(key)))
         print(temp)
</code></pre>
</div>
<span class="comment-copy"><code>__setattr__</code> returns <code>None</code>.</span>
<span class="comment-copy">Those two aren't equivalent, try using <code>temp=self.__setattr__(key,kwargs.get(key));print(temp)</code> in the second one</span>
<span class="comment-copy">Abusing a list comprehension for its side effect is a big no no: <a href="https://stackoverflow.com/questions/5753597/is-it-pythonic-to-use-list-comprehensions-for-just-side-effects" title="is it pythonic to use list comprehensions for just side effects">stackoverflow.com/questions/5753597/â€¦</a></span>
<span class="comment-copy">The answers <a href="https://stackoverflow.com/questions/26027694/correct-style-for-python-functions-that-mutate-the-argument">here</a> explain why its conventional in Python for mutating methods to return <code>None</code>.</span>
<span class="comment-copy">The second one in your answer makes sense. Looping and appending elements to an empty list. Thank you.</span>
<span class="comment-copy">And what is the "first one"? Do you mean the comment about side effects in list comprehensions? This is <b>really</b> a bad idea.</span>
<span class="comment-copy">@WaterRocket8236 If this is the answer to your question, please mark it accordingly :)</span>
<span class="comment-copy">I meant the list comp as the "first one". Yes i understand thats a bad idea. Just trying stuffs out. Was unaware of <b>setattr</b> return value.</span>
