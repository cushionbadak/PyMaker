<div class="post-text" itemprop="text">
<p>I have a try/except block around a call to an API.  It appears to me that once I get an exception, all valid try cases after that exception will see the same exception.  The only way I have been able to get it to work is to re-start my Python script.  I googled around and found PyErr_clear() but that is for the C-API.  Is there something I can call from plain-old Python that will clear the exception state?</p>
<p>Here is the basic idea of what I am doing:</p>
<pre><code>def get_and_print_data(key):
   try:
      data = get_data_from_some_3rd_party_api(key)
   except Exception as ex:
      print("Failed to get data for",key,": ",str(ex))
      return

   print("data=",data)
</code></pre>
<p>Then in main I have</p>
<pre><code>get_and_print_data("Valid Key")     ## This works
get_and_print_data("INvalid Key")   ## This gets exception, as expected
get_and_print_data("Valid Key")     ## This and all subsequent calls to get_and_print_data() fail with the same exception.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As an example of why I think it's the 3rd party API that is having issues:</p>
<pre><code>def get_data_from_some_3rd_party_api(key):
    if key == "Valid Key":
        return "This is some good data."
    else:
        raise ValueError("Invalid Key")

def get_and_print_data(key):
   try:
      data = get_data_from_some_3rd_party_api(key)
   except Exception as ex:
      print("Failed to get data for",key,": ",str(ex))
      return
   print("data=",data)

get_and_print_data("Valid Key")     ## This works
get_and_print_data("INvalid Key")   ## This gets exception, as expected
get_and_print_data("Valid Key")     ## This works
</code></pre>
<p>Try running this locally, and you should see that the subsequent valid keys still work.</p>
</div>
<span class="comment-copy">Can you show your code? I don't know what you mean by "all valid try cases after that exception will see the same exception".</span>
<span class="comment-copy">The question doesn't make sense without code. It's not a feature of python, it's something you've implemented in code</span>
<span class="comment-copy">Honestly that seems like a problem with <code>get_data_from_some_3rd_party_api(key)</code> failing after receiving an invalid key. I don't expect that behavior from your try/except.</span>
<span class="comment-copy">@Jenner Felton - I was thinking that perhaps something in the 3rd party api needs to be cleared, and that may be so; but then I saw this <a href="https://docs.python.org/3/c-api/exceptions.html" rel="nofollow noreferrer">docs.python.org/3/c-api/exceptions.html</a> which seems to indicate that once set, the exception state stays set until cleared.  I have contacted the owner of the API, but thought I would try here as well (while waiting for a response) in case this is a language feature (I'm a C/C++ coder; new to Python).</span>
<span class="comment-copy">Can I ask which 3rd party API you are using? I'm pretty convinced it's an issue there.</span>
<span class="comment-copy">Thanks.  Ran it.  That's very convincing.  Guess I'll have to wait to hear back from the 3rd party.</span>
<span class="comment-copy">@DanielGoldfarb Is the 3rd party an open source API with documentation? Happy to help there if it is.</span>
<span class="comment-copy">I figured out the problem, thanks to your proof that the issue is definitely not Python.  The api I am calling is get_daily() from alpha_vantage (<a href="https://github.com/RomelTorres/alpha_vantage" rel="nofollow noreferrer">github.com/RomelTorres/alpha_vantage</a>) which is a Python wrapper around the <a href="https://www.alphavantage.co/" rel="nofollow noreferrer">alphavantage.co</a> web API.  The problem is the <i>free version</i> of the web API is limited to 5 requests per minute; and the Python wrapper defaults to 5 retries on a failure, so when sent an invalid key it burned up my 5 requests per minute.  When I set retries=0 everything worked fine.  Thanks for your help!</span>
<span class="comment-copy">@DanielGoldfarb Nice sleuthing and congrats on solving your problem! Glad you figured it out!</span>
<span class="comment-copy">Although you blame the 3rd Party, this also happens if you just use the plain-old C bindings to python. Calling PyErr_Clear() does not seem to actually clear the error. Investigating now.</span>
