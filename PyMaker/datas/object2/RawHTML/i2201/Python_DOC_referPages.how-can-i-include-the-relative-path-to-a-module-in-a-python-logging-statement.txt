<div class="post-text" itemprop="text">
<p>My project has a subpackage nested under the root package like so:</p>
<ul>
<li><code>mypackage/</code>
<ul>
<li><code>__init__.py</code></li>
<li><code>topmodule.py</code></li>
<li><code>subpackage/</code>
<ul>
<li><code>__init__.py</code></li>
<li><code>nested.py</code></li>
</ul></li>
</ul></li>
</ul>
<p>My goal is to get logging records formatted like:</p>
<pre><code>mypackage/topmodule.py:123: First log message
mypackage/subpackage/nested.py:456: Second log message
</code></pre>
<p>so that the paths become clickable in my terminal.</p>
<hr/>
<p>I've tried the following formats.</p>
<ul>
<li><p><code>'%(modulename).pys:%(lineno): %(message)s'</code> isn't clickable (the dots need to be slashes):</p>
<pre><code>mypackage.topmodule.py:123: First log message
mypackage.subpackage.nested.py:456: Second log message
</code></pre></li>
<li><p><code>'mypackage/%(filename)s:%(lineno): %(message)s'</code> doesn't work for subpackages:</p>
<pre><code>mypackage/topmodule.py:123: First log message
mypackage/nested.py:456: Second log message
</code></pre></li>
<li><p><code>'%(pathname)s:%(lineno): %(message)s'</code> produces clickable paths, but they're so long that they cut off the rest of my logging :</p>
<pre><code>/Users/jacebrowning/Documents/mypackage/topmodule.py:123: First log message
/Users/jacebrowning/Documents/mypackage/subpackage/nested.py:456: Second log message
</code></pre></li>
</ul>
<hr/>
<p>Is there a logging pattern I can pass to <code>logging.basicConfig(format='???')</code> that wil produce the logging records I desire?</p>
</div>
<div class="post-text" itemprop="text">
<p>You'd have to do additional processing to get the path that you want here.</p>
<p>You can do such processing and add additional information to log records, including the 'local' path for your own package, by creating a <a href="https://docs.python.org/3/library/logging.html#filter-objects" rel="nofollow noreferrer">custom filter</a>.</p>
<p>Filters don't actually <em>have</em> to do filtering, but they do get access to all log records, so they are a great way of updating records with missing information. Just make sure you return <code>True</code> when done:</p>
<pre><code>import logging
import os
import sys


class PackagePathFilter(logging.Filter):
    def filter(self, record):
        pathname = record.pathname
        record.relativepath = None
        abs_sys_paths = map(os.path.abspath, sys.path)
        for path in sorted(abs_sys_paths, key=len, reverse=True):  # longer paths first
            if not path.endswith(os.sep):
                path += os.sep
            if pathname.startswith(path):
                record.relativepath = os.path.relpath(pathname, path)
                break
        return True
</code></pre>
<p>This finds the <code>sys.path</code> entry that's the parent dir for the <code>pathname</code> on the logrecord and adds a new <code>relativepath</code> entry on the log record. You can then use <code>%(relativepath)s</code> to include it in your log.</p>
<p>Add the filter to any <em>handler</em> that you have configured with your custom formatter:</p>
<pre><code>handler.addFilter(PackagePathFilter())
</code></pre>
<p>and together with <code>'%(relativepath)s:%(lineno)s: %(message)s'</code> as the format your log messages will come out like:</p>
<pre><code>mypackage/topmodule.py:123: First log message
mypackage/subpackage/nested.py:456: Second log message
</code></pre>
<p>(actual output, except I altered the line numbers on that).</p>
</div>
