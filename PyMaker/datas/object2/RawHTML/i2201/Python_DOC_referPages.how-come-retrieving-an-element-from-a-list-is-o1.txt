<div class="post-text" itemprop="text">
<p>Today in class, we learned that retrieving an element from a list is <code>O(1)</code> in Python. Why is this the case? Suppose I have a list of four items, for example:</p>
<pre><code>li = ["perry", 1, 23.5, "s"]
</code></pre>
<p>These items have different sizes in memory. And so it is not possible to take the memory location of <code>li[0]</code> and add three times the size of each element to get the memory location of <code>li[3]</code>. So how does the interpreter know where <code>li[3]</code> is without having to traverse the list in order to retrieve the element?</p>
</div>
<div class="post-text" itemprop="text">
<p>A list in Python is implemented as an array of pointers<sup>1</sup>. So, what's really happening when you create the list:</p>
<pre><code>["perry", 1, 23.5, "s"]
</code></pre>
<p>is that you are actually creating an array of pointers like so:</p>
<pre><code>[0xa3d25342, 0x635423fa, 0xff243546, 0x2545fade]
</code></pre>
<p>Each pointer "points" to the respective objects in memory, so that the string <code>"perry"</code> will be stored at address <code>0xa3d25342</code> and the number <code>1</code> will be stored at <code>0x635423fa</code>, etc. </p>
<p>Since all pointers are the same size, the interpreter <em>can</em> in fact add 3 times the size of an element to the address of <code>li[0]</code> to get to the pointer stored at <code>li[3]</code>. </p>
<hr/>
<p><sup>1</sup> Get more details from: <a href="https://github.com/python/cpython/blob/e42b705188271da108de42b55d9344642170aa2b/Include/listobject.h#L22" rel="noreferrer">the horse's mouth (CPython source code on GitHub)</a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>When you say <code>a = [...]</code>, <code>a</code> is effectively a pointer to a <code>PyObject</code> containing an array of pointers to <code>PyObject</code>s.</p>
<p>When you ask for <code>a[2]</code>, the interpreter first follows the pointer to the list's <code>PyObject</code>, then adds <code>2</code> to the address of the array inside it, then returns that pointer. The same happens if you ask for <code>a[0]</code> or <code>a[9999]</code>.</p>
<p>Basically, all Python objects are accessed by reference instead of by value, even integer literals like <code>2</code>. There are just some tricks in the pointer system to keep this all efficient. And pointers have a known size, so they can be stored conveniently in C-style arrays.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short answer: Python lists are arrays.</p>
<p>Long answer: The computer science term <em>list</em> usually means either a singly-linked list (as used in functional programming) or a doubly-linked list (as used in procedural programming). These data structures support O(1) insertion at either the head of the list (functionally) or at any position that does not need to be searched for (procedurally). A Python ``list'' has none of these characteristics. Instead it supports (amortized) O(1) appending at the end of the list (like a C++ std::vector or Java ArrayList). Python lists are really resizable arrays in CS terms.</p>
<p>The following comment <a href="https://docs.python.org/3.7/tutorial/datastructures.html#using-lists-as-queues" rel="nofollow noreferrer">from the Python documentation</a> explains some of the performance characteristics of Python ``lists'':</p>
<blockquote>
<p>It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, <strong>doing inserts or pops from the beginning of a list is slow</strong> (because all of the other elements have to be shifted by one).</p>
</blockquote>
</div>
<span class="comment-copy">What makes you think that arrays are linearly allocated rather than a list of pointers. - [me confused by your profile description]</span>
<span class="comment-copy">Don't confuse item <b>access</b>, which is <code>O(1)</code>, with item <b>lookup / search</b>, which is <code>O(n)</code>.</span>
<span class="comment-copy">Some relevant reading material: <a href="http://www.laurentluce.com/posts/python-list-implementation/" rel="nofollow noreferrer">Python list implementation</a>, <a href="https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented">How is Python's List Implemented?</a>, <a href="https://stackoverflow.com/questions/914233/what-is-the-underlying-data-structure-for-python-lists">What is the underlying data structure for Python lists?</a>.</span>
<span class="comment-copy">It is not good to ask <a href="https://cs.stackexchange.com/questions/98240/how-come-retrieving-an-element-from-a-list-is-o1">the same question</a> on two different SE sites (when answers will be within the same context).</span>
<span class="comment-copy">Voting to close as off-topic, since this is language-specific and it's already been answered on Stack Overflow.</span>
<span class="comment-copy">@DmitryVerhoturov That's right but makes no practical difference for this answer. References are reference-counted, <a href="https://docs.python.org/3/c-api/structures.html#c.PyVarObject" rel="nofollow noreferrer">docs.python.org/3/c-api/structures.html#c.PyVarObject</a></span>
<span class="comment-copy">Reference is implemented as pointers in every language I know. Semantics may differ slightly (e.g. differences in memory management, or references in C++ being immutable), but in the end they are still pointers.</span>
<span class="comment-copy">@TLW I've never seen those before.  Where'd you find them?</span>
<span class="comment-copy">@Brian Ahh, that makes sense.  If I may expound for those who were as curious as I was, those numbers are useful for firmware designers who are doing combinatorial logic within the chips themselves.  Big-oh analysis is always done with respect to some abstract machine, and when you're doing firmware, modeling time as 'gate depth' or 'wire distance' is reasonable.  For anyone doing software (especially Python and other interpreted languages), it's more useful to do the big-Oh analysis based on an abstract machine where accessing memory takes some fixed number of cycles, hence the O(1)</span>
<span class="comment-copy">@TLW That simplicity is important for developers who will never operate in environments where they are concerned with performance as the working set approaches exabytes, but for which there is a substantial performance difference between an O(n) and O(n log n) algorithm with respect to their simplified computational model.  The simplified model does a good job of focusing attention on the most important aspects of the algorithm.</span>
<span class="comment-copy">what is ''terp''?</span>
<span class="comment-copy">@hkBst I infer that it's short for "interpreter".</span>
<span class="comment-copy">I’ve never heard of singly-linked lists being specifically associated with functional programming, or doubly-linked lists being specifically associated with procedural programming. Both types of list are valid and have their use-cases for both programming paradigms (and other programming paradigms besides). Can you back up that claim? I find it quite dubious.</span>
<span class="comment-copy">@KRyan I'm pretty sure that Lisp, Haskell, Ocaml are all generally using singly-linked lists, especially with the more convenient primitives in the languages. Lisp in particular has a bunch of shorthand like car/cdr for getting the various parts of the list elements. Of course they're used everywhere else, but, Lisp and functional company often makes much heavier use of them. C++'s list, for example is a doubly linked list, and only recently did they get a forward_list(which is singly typed)</span>
<span class="comment-copy">This is a good answer, but I agree that the claim about list implementations in functional vs procedural languages seems to be too general. Whether an abstract list data type is implemented as an array or linked list isn't really a part of the language specification in high level languages, is it? I suppose it's possible to make a Lisp runtime where lists are implemented as arrays, like in cpython?</span>
<span class="comment-copy">@HåkenLid: performance characteristics are often part of the specification of a data type, especially for languages that are more serious about performance. For example <a href="https://stackoverflow.com/questions/181693/what-are-the-complexity-guarantees-of-the-standard-containers">see this Q&amp;A about C++</a>. I am not aware of such an explicit list for Python, but you can get a hint from the interface exposed by the standard ''list'' type: there is <code>append</code> and <code>extend</code> but there is no <code>prepend</code>/<code>cons</code>.</span>
<span class="comment-copy">@HåkenLid: where the docs are silent the fallback position is that the CPython implementation is the de facto specification of Python, although apparently <a href="https://www.python.org/dev/peps/pep-3128/" rel="nofollow noreferrer">other list implementations do get discussed</a>.</span>
