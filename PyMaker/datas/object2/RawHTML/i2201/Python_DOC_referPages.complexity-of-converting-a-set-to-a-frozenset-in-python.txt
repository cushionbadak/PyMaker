<div class="post-text" itemprop="text">
<p>What is the computational complexity of "freezing" a set in Python?</p>
<p>For example, does the second line in</p>
<pre><code>a = {1,2,3}
b = frozenset(a)
</code></pre>
<p>require O(n) time? Or is it simply a "view" created in constant time?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>b</code> is not a view of <code>a</code>. You can check this via <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer"><code>id</code></a>:</p>
<pre><code>a = {1, 2, 3}
b = a

id(a) == id(b)  # True

b = frozenset({1, 2, 3})

id(a) == id(b)  # False
</code></pre>
<p>Hence a change in <code>b</code> will <em>not</em> be reflected in <code>a</code>. You can, of course, test this yourself. Since <code>frozenset</code> takes an iterable as an argument, it must iterate over each argument. This is an O(<em>n</em>) process.</p>
<p>As an aside, there's nothing special about <code>frozenset</code>, even creating a <code>set</code> from a <code>set</code> has O(<em>n</em>) time complexity:</p>
<pre><code>for i in [10**5, 10**6, 10**7]:
    a = set(range(i))
    %timeit set(a)

100 loops, best of 3: 3.33 ms per loop
10 loops, best of 3: 30.2 ms per loop
1 loop, best of 3: 421 ms per loop   
</code></pre>
</div>
<span class="comment-copy">It is not a view, since if you later <code>.add(..)</code> something to <code>a</code>, <code>b</code> is not updated.</span>
<span class="comment-copy">The construction is linear in the number of elements the iterable of the parameter has.</span>
<span class="comment-copy">So construction is <i>O(n)</i>. Insertion can go as bad as <i>O(n)</i> for a single element, but the <i>amoritzed</i>  cost is <i>O(1)</i>.</span>
<span class="comment-copy">Why not simply create a large set and try it?  It should be very obvious from a single test.</span>
