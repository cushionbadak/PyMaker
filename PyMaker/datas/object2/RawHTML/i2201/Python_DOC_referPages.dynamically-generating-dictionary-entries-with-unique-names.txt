<div class="post-text" itemprop="text">
<p>I'm trying to dynamically generate cells. Each cell has a name, defined as a key of a dictionary. The value is an instance of a class, containing three parameters (strength, intelligence, energy).</p>
<pre><code>import random

class Cell:
    def __init__(self, energy, strength, intelligence):
        self.energy = energy
        self.strength = strength
        self.intelligence = intelligence
cells = {}
k = 1
while k &lt; 100:
    key = "a" + str(k)
    print("Generating cell: " + key)
    cells[key] = Cell(random.randint(1, 100),random.randint(1, 100),random.randint(1, 100))
    k += 1  #Generate cells
</code></pre>
<p>My problem is with names. This code was good enough for the first generation of cells, but when I need to make more, the new cells can override old ones due a name conflict. </p>
<p>Is there a way to generate random, but unique cell names to avoid such conflict? I tried to create new names starting with 'a' and the lowest number which doesn't already exist. However, cells die throughout my program. My approach would simply fill in the gaps, which would make it hard to determine which generation the cell is from.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use python's <a href="https://docs.python.org/3/library/uuid.html" rel="nofollow noreferrer"><code>uuid</code></a> library.</p>
<p>Simple example (out of context):</p>
<pre class="lang-py prettyprint-override"><code>import uuid as uuidlib

uuid = str(uuidlib.uuid4())
</code></pre>
<hr/>
<p>In your case:</p>
<pre class="lang-py prettyprint-override"><code>import uuid
import random

class Cell:
    def __init__(self, energy, strength, intelligence):
        self.energy = energy
        self.strength = strength
        self.intelligence = intelligence

cells = {}
k = 1
while k &lt; 100:
    key = str(uuid.uuid4())
    print("Generating cell: " + key)
    cells[key] = Cell(random.randint(1, 100),random.randint(1, 100),random.randint(1, 100))
    k += 1  #Generate cells
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this function to generate random names</p>
<pre><code>import random
def random_string(min_size, max_size):
    import string
    return ''.join(random.choices(string.ascii_uppercase + string.ascii_lowercase + string.digits, k=random.randint(min_size, max_size)))

random_string(7, 15)
</code></pre>
<p>This gives output like
<code>'AvkyCzlN9ggPr'</code> and if you run again it may give <code>'FBPXy5a4Ib'</code>
Also you can add a <code>version</code>/<code>generation</code> field to your cell class in addition to energy, strength, intelligence. You can add a counter to get the current version and increment the version every time the cell is updated.</p>
<p>Based on what your requirements are you can then use it to remove old cells, or keep them as a version history.
To remove old cells, just override a dictionary value with <code>random_string()</code></p>
<p>For eg:- </p>
<pre><code>some_dict = {}
randomstr = random_string(7, 15)
some_dict[random_str] = some_cell(randomstr)
</code></pre>
<p>to override </p>
<pre><code>some_updated_cell = some_cell.update() # decide to increment your version? upto you. 

# If you keep the randomstr same it will override the dict key, else it will not override and you can make (randomstr +"-"+ str(version)) as the key of dict.
some_dict[some_updated_cell.get_randomstr] = some_updated_cell
</code></pre>
<p>to not overwrite and keep track of generation</p>
<pre><code>version = 1 # build a method or autoincrement version.
key = randomstr + "-" + str(version)
</code></pre>
<p>then you can do <code>key.split("-")</code> to get the key and the version from <code>'AvkyCzlN9ggPr-1'</code>.</p>
<p>Another alternative approach would be to use the dictionary values as a list of objects. So instead of replacing the dictionary value, you can append it to the list.</p>
<pre><code>some_dict[randomstr] = []
some_dict[randomstr] = [*some_dict[randomstr], newObject]
</code></pre>
<p>And to access the latest generation just do</p>
<pre><code>some_dict[random_str][-1] # to access the last element of list
</code></pre>
<p>If this does not solve your problem leave a comment and I'll update accordingly :)</p>
</div>
<span class="comment-copy">Have a look at the uuid library.</span>
<span class="comment-copy">You can check in each iteration if <b>key</b> is an existing key.</span>
<span class="comment-copy">I think he also want to be able to keep track of the generation each key is in. I may be wrong, since I don't think I understand what he wants at all.</span>
