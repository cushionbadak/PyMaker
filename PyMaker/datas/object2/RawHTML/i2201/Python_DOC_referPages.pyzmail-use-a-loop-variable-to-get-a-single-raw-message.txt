<div class="post-text" itemprop="text">
<p>First, I should say, I don't really know much about computer programming, but I find Python fairly easy to use for automating simple tasks, thanks to Al Sweigart's book, "Automate the boring stuff."</p>
<p>I want to collect email text bodies. I'm trying to move homework to email to save paper. I thought I could do that by getting the numbers of the unseen mails and just looping through that. If I try that, the IDLE3 shell just becomes unresponsive, ctrl c does nothing, I have to restart the shell.</p>
<p>Question: Why can't I just use a loop variable in server.fetch()??</p>
<pre><code>for msgNum in unseenMessages:
    rawMessage = server.fetch([msgNum], ['BODY[]', 'FLAGS'])
</code></pre>
<p>It seems you need an actual number like 57, not msgNum, in there, or it won't work.</p>
<p>After looking at various questions and answers here on SO, the following works for me. I suppose it collects all the email bodies in one swoop.</p>
<pre><code>import pyzmail
import pprint
from imapclient import IMAPClient

server = IMAPClient('imap.qq.com', use_uid=True, ssl=True)
server.login('myEmail@foxmail.com', 'myIMAPpassword')
select_info = server.select_folder('Inbox')
unseenMessages = server.search(['UNSEEN'])
rawMessage = server.fetch(unseenMessages, ['BODY[]', 'FLAGS']) 
for msgNum in unseenMessages:
    message = pyzmail.PyzMessage.factory(rawMessage[msgNum][b'BODY[]'])
    text = message.text_part.get_payload().decode(message.text_part.charset)
    print('Text' + str(msgNum) + ' = ')
    print(text)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've found this <a href="https://gist.github.com/robulouski/7441883" rel="nofollow noreferrer">gist</a> with nice and clean code and a <a href="https://www.programcreek.com/python/example/2875/imaplib.IMAP4_SSL" rel="nofollow noreferrer">page</a> with many helping examples</p>
<p>The main difference between API of <code>imaplib</code> and <code>pyzmail</code> is pyzmail is all-in-one package with parsing and all client-server communication. But these packages are splitted into different packages in standard library. Basically, they both provided almost the same functionality and with the same methods.</p>
<p>As an additional important note here, <code>pyzmail</code> looks quite abandoned.  </p>
<p>To save a useful code from that gist, I copy it here as it is with very small modifications like extracting <code>main</code> function (note, it's for Python 3):</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python
#
# Very basic example of using Python 3 and IMAP to iterate over emails in a
# gmail folder/label.  This code is released into the public domain.
#
# This script is example code from this blog post:
# http://www.voidynullness.net/blog/2013/07/25/gmail-email-with-python-via-imap/
#
# This is an updated version of the original -- modified to work with Python 3.4.
#
import sys
import imaplib
import getpass
import email
import email.header
import datetime


EMAIL_ACCOUNT = "notatallawhistleblowerIswear@gmail.com"

# Use 'INBOX' to read inbox.  Note that whatever folder is specified, 
# after successfully running this script all emails in that folder 
# will be marked as read.
EMAIL_FOLDER = "Top Secret/PRISM Documents"


def process_mailbox(M):
    """
    Do something with emails messages in the folder.  
    For the sake of this example, print some headers.
    """

    rv, data = M.search(None, "ALL")
    if rv != 'OK':
        print("No messages found!")
        return

    for num in data[0].split():
        rv, data = M.fetch(num, '(RFC822)')
        if rv != 'OK':
            print("ERROR getting message", num)
            return

        msg = email.message_from_bytes(data[0][1])
        hdr = email.header.make_header(email.header.decode_header(msg['Subject']))
        subject = str(hdr)
        print('Message %s: %s' % (num, subject))
        print('Raw Date:', msg['Date'])
        # Now convert to local date-time
        date_tuple = email.utils.parsedate_tz(msg['Date'])
        if date_tuple:
            local_date = datetime.datetime.fromtimestamp(
                email.utils.mktime_tz(date_tuple))
            print ("Local Date:", \
                local_date.strftime("%a, %d %b %Y %H:%M:%S"))

def main(host, login, folder):
    with imaplib.IMAP4_SSL(host) as M:
        rv, data = M.login(login, getpass.getpass())

        print(rv, data)

        rv, mailboxes = M.list()
        if rv == 'OK':
            print("Mailboxes:")
            print(mailboxes)

        rv, data = M.select(folder)
        if rv == 'OK':
            print("Processing mailbox...\n")
            process_mailbox(M)
        else:
            print("ERROR: Unable to open mailbox ", rv)


if __name__ == '__main__':
    try:
        main('imap.gmail.com', EMAIL_ACCOUNT, EMAIL_FOLDER)
    except imaplib.IMAP4.error as e:
        print('Error while processing mailbox:', e)
        sys.exit(1)
</code></pre>
</div>
<span class="comment-copy">pyzmail seems to be outdated and not maintained anymore. Anyway, recent versions of <a href="https://docs.python.org/3/library/imaplib.html" rel="nofollow noreferrer">imaplib</a> standard module works quite well in Python. Could you consider to give it a try?</span>
<span class="comment-copy">I tried with imaplib but it seems more complicated that pyzmail. I am not really a computer person. Could you help me alter my code to use imaplib?</span>
<span class="comment-copy">Sure, I'll write code for you a bit later</span>
<span class="comment-copy">I've found this <a href="https://gist.github.com/robulouski/7441883" rel="nofollow noreferrer">gist</a> with nice and clean code and a <a href="https://www.programcreek.com/python/example/2875/imaplib.IMAP4_SSL" rel="nofollow noreferrer">page</a> with many helping examples.</span>
<span class="comment-copy">The main difference between <code>imaplib</code> and <code>pyzmail</code> is pyzmail is all-in-one package with parsing and all client-server communication. But these packages are splitted into different packages in standard library. Basically, they both provided almost the same functionality and with the same methods.</span>
