<div class="post-text" itemprop="text">
<p>I'm new to coding and am trying to write a simple code that will take a list, say [1,2,3] and cycle the elements n number of times. So if n=1, I should get A=[3,1,2]. If n=2, I should get A=[2,3,1].The code I have written is:</p>
<pre><code>n=1
j=0
A = [1,2,3]
B = [None]*len(A)

while j&lt;=n:
     for i in range(0,len(A)):
         B[i] = A[-1+i]
     j=j+1
print(B)
</code></pre>
<p>The problem is that no matter what the value of n is I get the same answer which is only cycled once. I think the problem is that the loop is cycling through the same B every time, so I need to store the new B as something else and then repeat the loop with new B. But I can't figure out how to do that. Any tips would be appreciated</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you're overcomplicating it. Consider changing it to something like the following:</p>
<pre><code>n = 1
A = [1,2,3]
B = A.copy()

for _ in range(n):
    # Cycle through by concatenating the last element and all other elements together 
    B = [B[-1]]+B[0:-1]

print(B)
</code></pre>
<p>In case of <code>n=1</code>, you get <code>[3, 1, 2]</code>, and <code>n=2</code> gives you <code>[2, 3, 1]</code></p>
<p>Note that what you are trying to do is implemented in <code>numpy.roll</code> (I suppose you're asking about the process, not the result, but just in case)</p>
<pre><code>import numpy as np

&gt;&gt;&gt; np.roll(A,1)
array([3, 1, 2])
&gt;&gt;&gt; np.roll(A,2)
array([2, 3, 1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simpler function for this is:</p>
<pre><code>def roll(L, n):
    n %= len(L)
    return L[-n:] + L[:-n]

A = [1,2,3]
roll(A, 1)   # [3, 1, 2]
roll(A, 2)   # [2, 3, 1]
roll(A, 3)   # [1, 2, 3]
roll(A, 4)   # [3, 1, 2]
</code></pre>
<p>Taking the modulus (<code>n %= len(L)</code>) avoids the need to keep cycling through. We then just concatenate an appropriate-sized slice off the end of the list to the beginning of it.</p>
</div>
<div class="post-text" itemprop="text">
<p>See <a href="https://stackoverflow.com/a/52674611/9209546">@sacul's answer</a> for the problem with your code. But <code>list</code> is not the most appropriate structure for such a requirement as each shift has O(<em>n</em>) complexity.</p>
<p><a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>deque</code></a> ("double-ended queue") from the <code>collections</code> module provides this feature via its <code>rotate</code> method. This method works <em>in-place</em> and has O(<em>k</em>) complexity, where <em>k</em> is argument representing the number of rotations. Here's an example:</p>
<pre><code>from collections import deque

d = deque([1,2,3])
d.rotate(2)

print(d)

deque([2, 3, 1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@sacul's answer works, but you were close! You missed updating <code>A</code> for the next iteration of the while loop after you created your new <code>B</code>.</p>
<pre><code>n=1
j=0
A = [1,2,3]
B = [None]*len(A)

while j&lt;=n:
    for i in range(0,len(A)):
        B[i] = A[-1+i]
    A = B[:] # update A so that next time B works on the new A 
    print('A is now ', A) # to debug
    j=j+1

print(B)
</code></pre>
<p>This results in the following print statements:</p>
<pre><code>A is now  [3, 1, 2]                                                                                                                   
A is now  [2, 3, 1]                                                                                                                   
[2, 3, 1] # this is what finally B is
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An <code>itertools</code> based solution</p>
<pre><code>from itertools import cycle, islice

def roll(x, n):
    start = len(x) - n
    return islice(cycle(x), start, start + len(x))
</code></pre>
<p>If we cycle through the values in x (we'd actually only do this at most twice). Then slice it so that it begins at the element we want and includes the correct number of  elements.</p>
<p>It's probably a little more esoteric than some of the other solutions, but worth throwing into the bag, given there are so many alternatives.</p>
<p><code>itertools.islice</code> returns a generator. If you wanted to print the result you'd need to convert it to <code>list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not going to in depth since someone already answered your question.. But an important property to note here is also that</p>
<pre><code>A = [1, 2, 3] #Assuming that the length of the matrix you want to rotate is of length 3

If you want to cycle/rotate by 3, then you want to actually cycle/rotate by `len(A)%3` = 0
If you want to cycle/rotate by 6, then you want to actually cycle/rotate by `len(A)%6` = 0
If you want to cycle/rotate by 4, then you want to actually cycle/rotate by `len(A)%3` = 1
If you want to cycle/rotate by a number lesser than the length itself.. then just rotate it by that number!

so if you want to cycle by 2, then well.. rotate it by two.. 
</code></pre>
</div>
<span class="comment-copy">The relationship between the two list's indices is <code>j = (j-n)%k</code> where <code>j</code> is the cycled list index and <code>k</code> is the list length. Using arrays this would be very efficient. Indexing the list directly would still be acceptable (in python thinking). However it baffles me that for such a common problem one has to create, join and destroy lists all over the place.</span>
<span class="comment-copy">You can further simplify <code>B[0:-1]</code> to <code>B[:-1]</code></span>
<span class="comment-copy">But this is the wrong outcome for n = 1... set <code>while j&lt;n</code> instead.</span>
<span class="comment-copy">@Stuart What do you mean "wrong"? <code>j = 1</code> can mean 2 iterations; it's just a matter of definition. This is OP's original code only modified slightly to explain where they went wrong.</span>
<span class="comment-copy">Wrong in the sense that it does not provide the output specified by the OP for the given <code>A</code> and <code>n</code>.</span>
<span class="comment-copy">Okay I see now how to update B like I was talking about originally. I had tried to say B=A, but I see if I swap the order I get what one of my issues was</span>
