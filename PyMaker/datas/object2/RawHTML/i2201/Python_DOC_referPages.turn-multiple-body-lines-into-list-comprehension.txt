<div class="post-text" itemprop="text">
<p>I have the following code that I want to write as list comprehension:</p>
<pre><code>word = "in_str"
listc=[]
for i in range(len(list(word))):
    x = []
    x.append(i+1)
    x.append(list(word)[i])
    listc.append(x)
print(listc, end="\n")
</code></pre>
<p>How do I treat the multiple lines in the body?
Basically, I want to transform my <code>"in_str"</code> into the following:</p>
<pre><code>[[1, 'i'], [2, 'n'], [3, '_'], [4, 's'], [5, 't'], [6, 'r']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have a varitey options with this one, and more that arent listed</p>
<pre><code>l = [[idx, item] for idx, item in enumerate(word, 1)]

l = list(map(list, enumerate(word, 1)))

l = list(map(list, zip(range(1, len(word)+1), word)))

l = []
for idx, item in enumerate(word, 1):
    l.append([idx, item])

# [[1, 'i'], [2, 'n'], [3, '_'], [4, 's'], [5, 't'], [6, 'r']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How do I treat the multiple lines in the body</p>
</blockquote>
<p>By simplifying the expression down; you don't need multiple statements to build the nested list:</p>
<pre><code>[i + 1, list(word)[i]]
</code></pre>
<p>gives you the same result as declaring <code>x = []</code> and appending two the results of two expressions.</p>
<p>That would make the list comprehension</p>
<pre><code>[
    [i + 1, list(word)[i]]
    for i in range(len(list(word)))
]
</code></pre>
<p>Next, you don't need to call <code>list(word)</code> to get the length of a string or to address individual characters. Strings are already sequences, so <code>len(word)</code> and <code>word[i]</code> also work:</p>
<pre><code>[
    [i + 1, word[i]]
    for i in range(len(word))
]
</code></pre>
<p>Next, if you used the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate()</code> function</a>, you can generate both a running index to replace the <code>range()</code> loop, <em>and</em> get access to the individual characters of <code>word</code> without having to index; you can start the running index at <code>1</code> with a second argument to <code>enumerate()</code> (the default is to start at <code>0</code>):</p>
<pre><code>[[i, char] for i, char in enumerate(word, 1)]
</code></pre>
<p>If you don't <em>have</em> to have a <em>list</em> for each pair, just use <code>enumerate(word, 1)</code> directly in loops and get tuples:</p>
<pre><code>list(enumerate(word, 1))
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; word = "in_str"
&gt;&gt;&gt; list(enumerate(word, 1))
[(1, 'i'), (2, 'n'), (3, '_'), (4, 's'), (5, 't'), (6, 'r')]
&gt;&gt;&gt; [[i, char] for i, char in enumerate(word, 1)]
[[1, 'i'], [2, 'n'], [3, '_'], [4, 's'], [5, 't'], [6, 'r']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Please try this line:</p>
<pre><code>[(i + 1, l) for i, l in enumerate(word)]
</code></pre>
<p>Or with lists: </p>
<pre><code>[[i + 1, l] for i, l in enumerate(word)]
</code></pre>
<p>or a version from the comments (by @tobias_k): </p>
<pre><code>list(enumerate(word, start=1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would do as such;</p>
<p><code>new_list = [list(x) for x in enumerate(word)]</code></p>
<p>this gives;</p>
<p><code>[[0, 'i'], [1, 'n'], [2, '_'], [3, 's'], [4, 't'], [5, 'r']]</code></p>
<p>EDIT: I see @Chris_Rands beat me to the punch, put it as an answer good sir!</p>
</div>
<span class="comment-copy"><code>list(enumerate(word, 1))</code> or <code>[list(t) for t in enumerate(word, 1)]</code> for a list of lists</span>
<span class="comment-copy">You don't need to use multiple lines at all; <code>listc.append([i + 1, word[i]])</code> can replace your whole loop body; lists don't have to start empty.</span>
<span class="comment-copy"><code>[*map(list, enumerate(word, 1))]</code> ?</span>
<span class="comment-copy">@MartijnPieters I agree with your stance on the enumerate zip combo and took that down, I left one zip example just based on the OP questioning about the zip procedures for this, thank your for help refining this answer</span>
<span class="comment-copy">You could take a look at <a href="https://stackoverflow.com/questions/22171558/what-does-enumerate-mean/22171593#22171593">my answer on <code>enumerate()</code></a>; <code>range()</code> is much more verbose an object here than is needed to re-create <code>enumerate()</code>.</span>
<span class="comment-copy">@MartijnPieters updated ty</span>
<span class="comment-copy">You can use <code>enumerate(word, start=1)</code></span>
<span class="comment-copy">@tobias_k it's  a good point, thanks</span>
<span class="comment-copy">Thanks! I changed to <code>list(x+1)</code> so the index starts at 1</span>
<span class="comment-copy">@rororo <code>list(x+1)</code> does not work, <code>x</code> is a tuple, but you can use the <code>start=1</code> parameter of <code>enumerate</code></span>
<span class="comment-copy">can I also use <code>zip()</code> for this task?</span>
<span class="comment-copy">@rororo You <i>could</i> use <code>zip</code> and a <code>range</code>, but why bother? <code>enumerate</code> already does that for you.</span>
<span class="comment-copy">@rororo: why complicate matters with <code>zip()</code>? <code>enumerate(word, start)</code> is essentially <code>zip(itertools.count(start), word)</code>, but using the latter only causes confusion for future readers of the code, including whomever chose to use the obscure version over the standard library function.</span>
