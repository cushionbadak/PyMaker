<div class="post-text" itemprop="text">
<p>I'm using Python3 <code>argparse</code> for complicated command-line interface. Lots of arguments, some of them are "verbose" to avoid misunderstandings.</p>
<pre><code>parser = argparse.ArgumentParser(description='Command-line interface')
parser.add_argument('--long-param-one',
                    help='Long param one description',
                    dest='lond_param_one',
                    required=True)

parser.add_argument('--long-param-two',
                    help='Long param two description',
                    dest='lond_param_two',
                    required=True)
</code></pre>
<p>When param name is long enough and destination variable long as well, it causes ugly formatting when you calling script with <code>--help</code></p>
<pre><code>Command-line interface

optional arguments:
  -h, --help            show this help message and exit
  --long-param-one LONG_PARAM_ONE
                        Long param one description
  --long-param-two LONG_PARAM_TWO
                        Long param two description
</code></pre>
<p>I mean, parameter and value are on the one string, description is on other, even though there's plenty of space in console to the right so that put it in one line. Like the fisrt param <code>--help</code> does. When you have 30-40 params, command-line help readability is really worsen</p>
</div>
<div class="post-text" itemprop="text">
<p><code>argparse</code> by default limits the maximum space taken for the option+metavar and will write the help message on a separate line, even if the terminal would be big enough to accomodate both.</p>
<p>Consider this example script:</p>
<pre><code>import argparse

parser = argparse.ArgumentParser()
parser.add_argument('--name', help='help help')
parser.add_argument('--parameter', help='help help')
parser.add_argument('--parameter-name', help='help help')
parser.add_argument('--this-parameter-name', help='help help')
parser.add_argument('--this-is-parameter-name', help='help help')
parser.add_argument('--this-is-a-parameter-name', help='help help')
parser.add_argument('--this-is-a-long-parameter-name', help='help help')
parser.add_argument('--this-is-a-very-long-parameter-name', help='help help')
parser.add_argument('--this-is-a-very-very-long-parameter-name', help='help help')
parser.add_argument('--this-is-a-very-very-very-long-parameter-name', help='help help')

parser.parse_args()
</code></pre>
<p>Results in the following output:</p>
<pre><code>usage: a.py [-h] [--name NAME] [--parameter PARAMETER]
            [--parameter-name PARAMETER_NAME]
            [--this-parameter-name THIS_PARAMETER_NAME]
            [--this-is-parameter-name THIS_IS_PARAMETER_NAME]
            [--this-is-a-parameter-name THIS_IS_A_PARAMETER_NAME]
            [--this-is-a-long-parameter-name THIS_IS_A_LONG_PARAMETER_NAME]
            [--this-is-a-very-long-parameter-name THIS_IS_A_VERY_LONG_PARAMETER_NAME]
            [--this-is-a-very-very-long-parameter-name THIS_IS_A_VERY_VERY_LONG_PARAMETER_NAME]
            [--this-is-a-very-very-very-long-parameter-name THIS_IS_A_VERY_VERY_VERY_LONG_PARAMETER_NAME]

optional arguments:
  -h, --help            show this help message and exit
  --name NAME           help help
  --parameter PARAMETER
                        help help
  --parameter-name PARAMETER_NAME
                        help help
  --this-parameter-name THIS_PARAMETER_NAME
                        help help
  --this-is-parameter-name THIS_IS_PARAMETER_NAME
                        help help
  --this-is-a-parameter-name THIS_IS_A_PARAMETER_NAME
                        help help
  --this-is-a-long-parameter-name THIS_IS_A_LONG_PARAMETER_NAME
                        help help
  --this-is-a-very-long-parameter-name THIS_IS_A_VERY_LONG_PARAMETER_NAME
                        help help
  --this-is-a-very-very-long-parameter-name THIS_IS_A_VERY_VERY_LONG_PARAMETER_NAME
                        help help
  --this-is-a-very-very-very-long-parameter-name THIS_IS_A_VERY_VERY_VERY_LONG_PARAMETER_NAME
                        help help
</code></pre>
<p>The simplest way to <em>try</em> to avoid this problem is specifying the <code>metavar</code> explicitly and use a short value, so instead ov <code>THIS_IS_A_VERY_VERY_VERY_LONG_PARAMETER_NAME</code> you can use, say, <code>X</code>. For example:</p>
<pre><code>import argparse

parser = argparse.ArgumentParser()
m = 'X'
parser.add_argument('--name', help='help help', metavar=m)
parser.add_argument('--parameter', help='help help', metavar=m)
parser.add_argument('--parameter-name', help='help help', metavar=m)
parser.add_argument('--this-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-a-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-a-long-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-a-very-long-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-a-very-very-long-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-a-very-very-very-long-parameter-name', help='help help', metavar=m)

parser.parse_args()
</code></pre>
<p>Which results in:</p>
<pre><code>usage: a.py [-h] [--name X] [--parameter X] [--parameter-name X]
            [--this-parameter-name X] [--this-is-parameter-name X]
            [--this-is-a-parameter-name X] [--this-is-a-long-parameter-name X]
            [--this-is-a-very-long-parameter-name X]
            [--this-is-a-very-very-long-parameter-name X]
            [--this-is-a-very-very-very-long-parameter-name X]

optional arguments:
  -h, --help            show this help message and exit
  --name X              help help
  --parameter X         help help
  --parameter-name X    help help
  --this-parameter-name X
                        help help
  --this-is-parameter-name X
                        help help
  --this-is-a-parameter-name X
                        help help
  --this-is-a-long-parameter-name X
                        help help
  --this-is-a-very-long-parameter-name X
                        help help
  --this-is-a-very-very-long-parameter-name X
                        help help
  --this-is-a-very-very-very-long-parameter-name X
                        help help
</code></pre>
<p>this is already way better, but as you can see with very long parameter names it still wont write all the text on one line.</p>
<p>The only way to achieve what you want is to specify a <code>formatter_class</code> and use the <code>max_help_position</code> as described in <a href="https://stackoverflow.com/questions/5462873/control-formatting-of-the-argparse-help-argument-list">this question</a>. This however is not part of the public API of the module. I have no idea when they did not add at least a couple of useful parameters to the public API.</p>
<p>You still probably want to specify a <code>metavar</code>:</p>
<pre><code>import argparse

formatter = lambda prog: argparse.HelpFormatter(prog,max_help_position=52)
parser = argparse.ArgumentParser(formatter_class=formatter)
m = 'X'
parser.add_argument('--name', help='help help', metavar=m)
parser.add_argument('--parameter', help='help help', metavar=m)
parser.add_argument('--parameter-name', help='help help', metavar=m)
parser.add_argument('--this-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-a-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-a-long-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-a-very-long-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-a-very-very-long-parameter-name', help='help help', metavar=m)
parser.add_argument('--this-is-a-very-very-very-long-parameter-name', help='help help', metavar=m)

parser.parse_args()
</code></pre>
<p>The output will be:</p>
<pre><code>usage: a.py [-h] [--name X] [--parameter X] [--parameter-name X]
            [--this-parameter-name X] [--this-is-parameter-name X]
            [--this-is-a-parameter-name X] [--this-is-a-long-parameter-name X]
            [--this-is-a-very-long-parameter-name X]
            [--this-is-a-very-very-long-parameter-name X]
            [--this-is-a-very-very-very-long-parameter-name X]

optional arguments:
  -h, --help                                        show this help message and
                                                    exit
  --name X                                          help help
  --parameter X                                     help help
  --parameter-name X                                help help
  --this-parameter-name X                           help help
  --this-is-parameter-name X                        help help
  --this-is-a-parameter-name X                      help help
  --this-is-a-long-parameter-name X                 help help
  --this-is-a-very-long-parameter-name X            help help
  --this-is-a-very-very-long-parameter-name X       help help
  --this-is-a-very-very-very-long-parameter-name X  help help
</code></pre>
<p>You could probably try to determine the size of the terminal (most terminals provide a <code>WIDTH</code> or <code>COLUMNS</code> env variable that may be useful for that) to decide the value of <code>max_help_position</code> that would be best in that situation.</p>
<hr/>
<p>To have all the parameters help on one line (assuming big enough terminal) you want:</p>
<pre><code>max_help_position &gt;= max(len(param.name)+len(param.metavar) for param in params)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The current <code>HelpFormatter</code> does check <code>os.environ['COLUMNS']</code> for terminal width.  But that does not get updated dynamically, and might not even be set.</p>
<p>There is a patch</p>
<p><a href="https://bugs.python.org/file24602/issue13041.patch" rel="nofollow noreferrer">https://bugs.python.org/file24602/issue13041.patch</a> <code>argparse: terminal width is not detected properly</code></p>
<p>that apparently was recently put into 3.8, that looks at <code>shutil.get_terminal_size().columns</code> instead.</p>
<hr/>
<p>As to why <code>argparse</code> doesn't provide more direct control of this width - the design philosophy has been allow a custom <code>formatter_class</code> specification, rather than a (potentially) large set of formatting parameters.  Most of the parameters to <code>ArgumentParser</code> have to do with parsing, not help formatting.  The goal is to allow complete customization without cluttering the inputs with a lot of rarely used parameters.</p>
<p>The <code>HelpFormatter</code> class does take several keyword parameters:</p>
<pre><code>HelpFormatter.__init__(self, prog, indent_increment=2, max_help_position=24, width=None)
</code></pre>
<p>But the current method of creating a formatter just passes the <code>prog</code> parameter.</p>
<p>Giacomo's answer shows how specify these other parameters:</p>
<pre><code>formatter = lambda prog: argparse.HelpFormatter(prog,max_help_position=52)
</code></pre>
<p>You could also subclass <code>HelpFormatter</code> to customize the formatting.  That's what the alternatives like <code>RawTextHelpFormatter</code> do.</p>
<h2>More on customizing the formatter</h2>
<p>From the argparse documentation:</p>
<blockquote>
<p>formatter_class</p>
<p>ArgumentParser objects allow the help formatting to be customized by specifying an alternate formatting class. Currently, there are four such classes:</p>
</blockquote>
<p>Providing and listing these 4 classes is not meant to be restrictive.  Other customization is allowed, even encouraged.</p>
<p>In <a href="https://bugs.python.org/issue13023" rel="nofollow noreferrer">https://bugs.python.org/issue13023</a>, Steven Bethard, the original author of <code>argparse</code>, advocates writing your own formatter class:</p>
<blockquote>
<p>Your solution is actually the current recommended solution - mix together both classes that you want to combine and pass your subclass as the parameter. This should probably be documented somewhere (and tested more).</p>
</blockquote>
<p>The mixing he's talking about is:</p>
<pre><code>class myFormatter(argparse.RawDescriptionHelpFormatter,
                  argparse.ArgumentDefaultsHelpFormatter):
    pass
</code></pre>
<p>I addressed the use of <code>max_help_position</code> 3 years ago:</p>
<p><a href="https://bugs.python.org/issue25297" rel="nofollow noreferrer">https://bugs.python.org/issue25297</a> <code>max_help_position is not works in argparse library</code></p>
<p>and a SO question:</p>
<p><a href="https://stackoverflow.com/questions/32888815/max-help-position-is-not-works-in-python-argparse-library">max_help_position is not works in python argparse library</a></p>
<p>Other examples in <code>argparse</code> where you are allowed to provide custom classes or functions include:</p>
<p><a href="https://docs.python.org/3/library/argparse.html#action-classes" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#action-classes</a>
<a href="https://docs.python.org/3/library/argparse.html#the-namespace-object" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#the-namespace-object</a>
<a href="https://docs.python.org/3/library/argparse.html#customizing-file-parsing" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#customizing-file-parsing</a>
<a href="https://docs.python.org/3/library/argparse.html#type" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#type</a></p>
<p>I wouldn't worry about the <code>max_help_position</code> parameter disappearing or being disabled.  If I have any say in the matter, any proposed change like that will be rejected on the grounds that it could have backward compatibility issues.</p>
<p>In practice it is easiest to change the documentation to match code, or to better illustrate vague points.  In  this case the <code>lambda</code> call to <code>HelpFormatter</code> could be documented.  I can also imagine defining a small function that does the same thing.  Adding features is easiest when there's no chance of harming existing users.</p>
</div>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/5462873/control-formatting-of-the-argparse-help-argument-list" title="control formatting of the argparse help argument list">stackoverflow.com/questions/5462873/â€¦</a> <code>argparse</code> by default assumes that the terminal is 80 chars wide (widely used convention) so even if you have a 40'' monitor and fullscreen terminal it will still only use 80 columns. There seem to be no public API to change that but the above question points out that there is a private API. Hopefully sometimes in the future the HelpFormatter will have a more customizable public API.</span>
<span class="comment-copy">BTW: one simple way to shorten the line is to use the <code>metavar</code> parameter so that instead of having <code>--long-param-one LONG_PARAM_ONE</code> you get <code>--long-param-one &lt;metavar&gt;</code> where <code>&lt;metavar&gt;</code> is what you have chosen which might be way shorter (like <code>--this-is-a-nice-number N</code>).</span>
<span class="comment-copy">@GiacomoAlzetta I hoped since 2011 some enhancements happen :) I'll appreciate if you provide some code example with metavar</span>
<span class="comment-copy">@GiacomoAlzetta I'm not aware of any proposals to enhance the API for the <code>HelpFormatter</code>.  As you found with the <code>formatter_class</code> parameter you can do almost anything, either with the <code>lambda</code> or subclassing.  So the power is there;   but the question is, which features, if any, should be more accessible to beginning users?</span>
<span class="comment-copy">@hpaulj No you can't. According to the documentation the <i>only</i> officially supported way to give a value to <code>formatter_class</code> is to provide one of the subclasses mentioned in the documentation. <code>max_help_position</code> is already an <i>implementation detail</i> which you shouldn't rely on. There is nothing bout how to customize or create a new <code>HelpFormatter</code> class. I believe they should really try to define an API for <code>HelpFormatter</code> so that people can actually rely on it. At least for simple stuff like <code>max_help_position</code>, maybe not all aspects immediately.</span>
<span class="comment-copy">From what you say and what I understand even in python3.8 there would still be problems because <code>max_help_position</code> is static. The width of the terminal is taken into account only for priting the help messages and usage part but not for the alignment of options &amp; corresponding help text.</span>
<span class="comment-copy">Digging in the bug/issues I found that we did look at <code>max_help_position</code> some 3 years ago.</span>
