<div class="post-text" itemprop="text">
<p>I'm trying to build a algorithmic trading program. The program has execution flow like this:</p>
<pre><code>Server sends data via websocket -&gt; Python program receives it and sends it to C++ program -&gt; C++ program processes the data and sends some data to Python code -&gt; Python code sends packets to Server
</code></pre>
<p>The reason I'm not building the whole thing in C++ is because Broker's API only supports Python and I cannot perform the operations I wish to perform fast enough if I switch to Python. </p>
<p>The frequency of data is going to be at least ~50kb (binary and Json) per second. So far I've found the following alternatives:</p>
<ol>
<li><p>Embed Python in C++ code. 
This seems great, but I'm not sure if would be able to import whole library and use classes/methods (broker's client) in C++. </p></li>
<li><p>Communicate through sending packets (latency is the issue here)</p></li>
<li><p>Put the data received in SQL database and have C++ query it every X ms. (again, latency)</p></li>
</ol>
<p>Is there any better way to do this? </p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using CPython (the most common implementation of python) then you can create a dynamic library that can be used as a python module. There 
<a href="https://www.boost.org/doc/libs/1_68_0/libs/python/doc/html/index.html" rel="nofollow noreferrer">Boost.Python</a></p>
<p>Which can be used as:</p>
<pre><code>#include &lt;boost/python.hpp&gt;
char const* greet()
{
   return "hello, world";
}

BOOST_PYTHON_MODULE(hello_ext)
{
    using namespace boost::python;
    def("greet", greet);
}
</code></pre>
<pre class="lang-python prettyprint-override"><code>&gt; import hello_ext   
&gt; print hello_ext.greet()   
hello, world
</code></pre>
<hr/>
<p>To build with python 3.7 and boost 1.68.0 you can use following CMake file</p>
<pre><code>cmake_minimum_required(VERSION 3.9.0 FATAL_ERROR)

project("boost_python_sample" LANGUAGES CXX)

set(BOOST_ROOT "C:/local/boost_1_68_0")
find_package(Boost REQUIRED COMPONENTS python37)
set(Python3_ROOT_DIR "C:/python37")
find_package(Python3 REQUIRED COMPONENTS Development)

add_library("boost_python_sample" SHARED "main.cpp")
target_link_libraries("boost_python_sample" Boost::python37 Python3::Python)
target_compile_definitions("boost_python_sample" PUBLIC "BOOST_PYTHON_STATIC_LIB")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to exchange data between python and C++ is to use a message queue library. One possible library which is designed to be fast is <a href="http://zeromq.org/" rel="nofollow noreferrer">Ã˜MQ (zeroMQ)</a>. Is this the fastest way? It depends on your use case. It might be worth evaluating. Especially considering the easy to implement part, good documentation and community support.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can implement your C++ code as shared library (so or dll).
Your interface should be <code>extern "C"</code>.
Then you can call your native functions directly in python and pass your data via pointers within the same process and memory.
To call the native functions you can use <a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow noreferrer" title="Python CTypes">Python CTypes</a>.</p>
</div>
<span class="comment-copy">What exactly are your latency requirements?</span>
<span class="comment-copy">Have you considered Cython and/or Numba? You might be able to interface reasonably well with with C using Cython (and you could expose more or less directly the relevant bits of memory), or you could implement whatever algorithm in plain Python and you could let it through a LLVM interpreter (if your constructs are simple enough).</span>
<span class="comment-copy">@norok2 I'll look into Cython/Numba, LLVM thank you.</span>
<span class="comment-copy">@ErikCederstrand since it's a real time application I must process received data ASAP.</span>
<span class="comment-copy">@Yuckfou 50 kb/s is not an impressive throughput, and it is actually slower than typical I/O transfer on modern hardware. In real-time applications, it is far more convenient to think in terms of raster time (e.g. the minimum time required to get enough data to compute the next bit, etc.), and I would check that you first test your timings. Perhaps a Python implementation is fast enough, given that I/O-bound computation can be typically done within Python. (As a side note, "ASAP" is not a real requirement, real-time means you gets control over time, not raw fast FASTER :-) ).</span>
<span class="comment-copy">I like this answer going concrete. Perhaps, it could get even more concrete by adding some comments on the requirements and the compilation steps.</span>
