<div class="post-text" itemprop="text">
<p>I'd like to add a new functionality to an existing awaitable class by subclassing it.</p>
<p>Let's start with a very simple base class creating objects which asynchronously return 99 after a short sleep. The subclass should just add +1 to the result.</p>
<p>I can't find the proper way to use <code>super()</code> to refer to the base class.</p>
<pre><code>import asyncio

class R99:
    def __await__(self):
        loop = asyncio.get_event_loop()
        fut = loop.create_future()
        loop.call_later(0.5, fut.set_result, 99)
        return fut.__await__()

class R100(R99):
    async def add1(self):
        v = await R99()
        #v = await super().__await__()   # &lt;== error
        return v + 1

    def __await__(self):
        return self.add1().__await__()

async def test():
    print(await R99())
    print(await R100())

asyncio.get_event_loop().run_until_complete(test())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/reference/datamodel.html#object.__await__" rel="nofollow noreferrer">await method</a> must return an iterator, so you can make it a generator and use the <a href="https://www.python.org/dev/peps/pep-0380/" rel="nofollow noreferrer">yield from</a> syntax:</p>
<pre><code>class R100(R99):

    def __await__(self):
        v = yield from super().__await__()
        return v + 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are allowed to modify <code>R99</code>, you can make <code>__await__()</code> invoke an actual coroutine, which can chain to <code>super()</code> in the regular way:</p>
<pre><code>import asyncio

class R99:
    async def await_coro(self):
        loop = asyncio.get_event_loop()
        fut = loop.create_future()
        loop.call_later(0.5, fut.set_result, 99)
        return await fut

    def __await__(self):
        return self.await_coro().__await__()

class R100(R99):
    async def await_coro(self):
        v = await super().await_coro()
        return v + 1
</code></pre>
<p>If that is not an option, @Vincent's answer precisely explains how to chain from one <code>__await__</code> to another. Note that you were quite correct in thinking that <code>await</code> is the new <code>yield from</code> - it is, and there is normally no reason to use <code>yield from</code> in newly written asyncio code. (This of course doesn't apply to non-asyncio-related generators that delegate to sub-generators; those are welcome to keep using <code>yield from</code>.)</p>
<p>However, by implementing <code>__await__()</code> you are dropping into the lower-level API which uses generators to implement coroutines. At this level <code>yield</code> suspends the coroutine, returning control to the event loop, and <code>yield from</code> delegates to another generator that implements a coroutine. In new code the only valid purpose for this layer is to implement an awaitable object without using the interpreter, e.g. in Python/C or Cython. This is done by providing an <code>__await__</code> that returns an iterator, as shown <a href="https://stackoverflow.com/a/51115745/1600898">here</a>. The resulting object is equivalent to an <code>async def</code>.</p>
</div>
<span class="comment-copy">And I thought <code>await</code> is the new <code>yield from</code>. Now I see it is not that simple. Thanks.</span>
