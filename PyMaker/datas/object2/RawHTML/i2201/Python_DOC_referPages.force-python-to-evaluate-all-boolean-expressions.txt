<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/12281469/python-avoid-short-circuit-evaluation">Python: Avoid short circuit evaluation</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>Most languages have a way to force 'fail early and often' through forcing all booleans in an if to be evaluate.  </p>
<p>Suppose I have the following if statement in Python:</p>
<pre><code>if(age&gt;100 or patient_is_brain_dead or patient_lacks_left_arm):
    do something...
</code></pre>
<p>The problem is I may have forgotten to set either boolean for 'patient_is_brain_dead or 'has_no_left_arm'. </p>
<p>Since most alive people are under 100, tests 2 and 3 happen rarely since Python, seeing the 'or' coming ahead, stops evaluating if age&lt;100 to save time.</p>
<p>My code is heavily compute-bound, so the overhead of testing all three cases will not degrade performance, but would catch a lot of potential bugs that would happen potentially in one-in-500 cases.  </p>
<p>Is there a way to force Python to evaluate them all?  Don't suggest reversing the order, because any case could be the rare one(s) depending on user input.  </p>
</div>
<div class="post-text" itemprop="text">
<p>In my opinion, you shouldn't <em>want</em> to do this in production code. If a couple of variables <em>should</em> be Boolean and you need to check if either of them are <code>True</code>, you <em>should</em> use short-circuiting logic.</p>
<p>So what are your options if, as you say, you want to make sure your code doesn't fail on edge cases? You can use <a href="https://docs.python.org/3/library/unittest.html" rel="nofollow noreferrer">unit testing</a> to test all viable scenarios. But this may be overkill for your use case. You can just use an <a href="https://docs.python.org/3/reference/simple_stmts.html#assert" rel="nofollow noreferrer"><code>assert</code></a> statement:</p>
<pre><code>assert all(isinstance(i, bool) for i in [patient_is_brain_dead, patient_lacks_left_arm])

if age &gt; 100 or patient_is_brain_dead or patient_lacks_left_arm:
    # do something...
</code></pre>
<p>The benefit of such a solution is it's possible to <a href="https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement" rel="nofollow noreferrer">turn off</a> <code>assert</code> statements via command line <code>-O</code> for production code. While, for testing purposes, you can be sure your variables are of the correct type.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, you will need to explicitly check for <code>None</code>. It is not a "roundabout" way, that is just how the language works.</p>
<p>If you want the conditional to fail if any of the variables are not set, you can use <code>all()</code> to check that they aren't <code>None</code>:</p>
<pre><code>if(all(i is not None for i in [age, patient_is_brain_dead, patient_lacks_left_arm]) and
        (age &gt; 100 or patient_is_brain_dead or patient_lacks_left_arm)):
    do something...
</code></pre>
</div>
<span class="comment-copy">I think <a href="https://docs.python.org/3/library/unittest.html" rel="nofollow noreferrer">unit tests</a> may be useful here.</span>
<span class="comment-copy">...or from explicitly checking that <code>patient_is_brain_dead is not None and patient_lacks_left_arm is not None</code>, a.k.a. "forgotten to set", and raising an Exception then?</span>
<span class="comment-copy">I think that would work but is a rather roundabout method. I thought putting it in parentheses would do the trick, but alas not.</span>
<span class="comment-copy">The brain-dead and left-arm checks usually <i>will</i> happen with the line you wrote, because <code>or</code> has to keep going if the left side is false.</span>
<span class="comment-copy">@eSurfsnake, Is that a typo? Given your description, it seems you want the logic <code>if age &lt; 100 or ... or ...</code>.</span>
<span class="comment-copy">I come from a C systems programming environment.  With compute-intensive code, doing three checks is trivial if what comes next is multiplying two 100 x 100 matrices, or big convolutions with thousands of points.  Better to weed out the user (and programmer) errors, since 99.999% of execution time is not in the redundant checks.</span>
<span class="comment-copy">Yep, so assert will do this for you. I'd say it's also a Pythonic approach.</span>
<span class="comment-copy">that sure is ugly...</span>
<span class="comment-copy">I might say the same about literally any C code ever but we all have our preferences :P</span>
<span class="comment-copy">au, contraire.  C code is usually a lot better looking than this...</span>
