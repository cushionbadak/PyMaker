<div class="post-text" itemprop="text">
<p>I have spent the past 3 hours reading posts here explaining exactly the problem I am having, but none of the solutions are working.</p>
<p>These posts did NOT work:</p>
<p><a href="https://stackoverflow.com/questions/29785084/changing-one-list-unexpectedly-changes-another-too">Changing one list unexpectedly changes another, too</a></p>
<p><a href="https://stackoverflow.com/questions/13498453/changing-one-dict-value-changes-all-values">Changing One dict value changes all values</a></p>
<p>I have a python module where I have have a specific shape of 2D array I need to initialize the entries in a dictionary with. Here is how I have done it:</p>
<pre><code>empty = []
for x in range(2):
    empty.append([])
    for y in range(2):
        empty[x].append(False)

status = {k:[] for k in ["a", "b", "c"]}

status["a"] = list(empty)
status["b"] = list(empty)
status["c"] = list(empty)

print(status)
status["a"][0][0] = True
print(status)
</code></pre>
<p>(Shape of list simplified for example)</p>
<p>This prints:</p>
<pre><code>{'a': [[False, False], [False, False]], 'b': [[False, False], [False, False]], 'c': [[False, False], [False, False]]}
{'a': [[True, False], [False, False]], 'b': [[True, False], [False, False]], 'c': [[True, False], [False, False]]}
</code></pre>
<p>As you can see, setting one of the lists values changes all of the lists. I do not want this, I want them to be separate lists (in one dictionary) with different values. Initially, I thought I had done the old <code>newlist = oldlist</code> blunder where I set newlist to the same object as oldlist, but nope. As you can see in my code, I am making separate lists using <code>newlist = list(oldlist)</code>. I have also tried <code>newlist = oldlist[:]</code>, <code>newlist = oldlist.copy()</code>, etc etc.</p>
<p>What am I missing? Thank you so much for taking the time to look this question over, I appreciate any input.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from copy import deepcopy
empty = []
for x in range(2):
    empty.append([])
    for y in range(2):
        empty[x].append(False)

status = {k:[] for k in ["a", "b", "c"]}

status["a"] = deepcopy(empty)
status["b"] = deepcopy(empty)
status["c"] = deepcopy(empty)

print(status)
status["a"][0][0] = True
print(status)
</code></pre>
<p>you were close with the copy, but you actually neeed a deepcopy</p>
</div>
<div class="post-text" itemprop="text">
<p>As I said earlier, <code>list(empty)</code> <em>does</em> create a new list, but the inner lists of that new list are just references to the same list objects in <code>empty</code>.</p>
<p>You <em>can</em> use <a href="https://docs.python.org/3/library/copy.html#copy.deepcopy" rel="nofollow noreferrer"><code>deepcopy</code></a>, but I think it's simpler just to build new lists when you need them. The <code>deepcopy</code> function jumps through various hoops that are required to copy arbitrarily deep nested objects that can contain anything. But why bother going through all that stuff when you have a structure that's simple to just build from scratch?</p>
<p>Using a list comprehension, your code can be written like this:</p>
<pre><code>status["a"] = [[False] * 2 for _ in range(2)]
status["b"] = [[False] * 2 for _ in range(2)]
#etc
</code></pre>
<p>It's safe to do <code>[False] * 2</code> for the innermost lists: it's always safe to share immutable objects (booleans, integers, strings, etc). The problem only arises when you unexpectedly share a mutatable object and you mutate its value instead of replacing it with a new object. </p>
<p>To avoid re-writing that list comp, you can use a function to build the lists for you. Eg,</p>
<pre><code>def empty(rows, columns):
    return [[False] * columns for _ in range(rows)]

status = {key: empty(2, 2) for key in 'abc'}
print(status)
status["a"][0][0] = True
print(status)
</code></pre>
<p><strong>output</strong></p>
<pre><code>{'a': [[False, False], [False, False]], 'b': [[False, False], [False, False]], 'c': [[False, False], [False, False]]}
{'a': [[True, False], [False, False]], 'b': [[False, False], [False, False]], 'c': [[False, False], [False, False]]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can see that the first element of your <code>empty</code> list is shared across all the values in your dictionary:</p>
<pre><code>&gt;&gt;&gt; id(empty[0]) == id(status['a'][0]) == id(status['b'][0]) == id(status['c'][0])
True
</code></pre>
<p>They each share the same memory location.  The same is also true for the second item in the empty list, <code>id(empty[1]) == id(status['a'][1]) == ...</code></p>
<p>The reason for this is your assignment of your <code>empty</code> list to each value.  You can either perform a deep copy this empty, nested list, or else use a list comprehension to generate new ones for each key in your dictionary.  This list comprehension for the empty list creation is itself done within a dictionary comprehension to generate your <code>status</code> variable for all the required keys.</p>
<pre><code>empty_rows = 2
empty_cols = 2
keys = ['a', 'b', 'c']
status = {k: [[False] * empty_cols 
              for _ in range(empty_rows)] 
          for k in keys}

# Example usage:
status['a'][0][0] = True
&gt;&gt;&gt; status
{'a': [[True, False], [False, False]],
 'b': [[False, False], [False, False]],
 'c': [[False, False], [False, False]]}
</code></pre>
<p>Now you can change any element without it affecting the others.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think what you need is a deep copy, see documentation of <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">copy.deepcopy()</a></p>
<pre><code>import copy
empty = []
for x in range(2):
    empty.append([])
    for y in range(2):
        empty[x].append(False)

status = {k:[] for k in ["a", "b", "c"]}

status["a"] = copy.deepcopy(empty)
status["b"] = copy.deepcopy(empty) 
status["c"] = copy.deepcopy(empty)
status['a'][0][0] = True
print(status)
</code></pre>
</div>
<span class="comment-copy">I guess you've seen <a href="https://stackoverflow.com/questions/240178/list-of-lists-changes-reflected-across-sublists-unexpectedly" title="list of lists changes reflected across sublists unexpectedly">stackoverflow.com/questions/240178/â€¦</a> ?<code>list(empty)</code> <i>does</i> create a new list, but the inner lists of that new list are just references to the same list objects in <code>empty</code>.</span>
<span class="comment-copy">Mandatory reading: <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">nedbatchelder.com/text/names.html</a></span>
<span class="comment-copy">Exactly what I needed! It works! I didn't realize the INNER lists were the same object, too!</span>
<span class="comment-copy">Totally agree.  I believe <code>deepcopy</code> is overkill for this situation.</span>
<span class="comment-copy">+1 for the <code>id()</code> function. I would recommend to the OP to really play around with it and understand what's going on</span>
<span class="comment-copy">How it is different from accepted answer?</span>
<span class="comment-copy">hey, it is not different, I was typing the answer, got busy with other things, and when submitted the previous answers were already there ... (perhaps, the only thing is that I had added a reference to the python docs)</span>
