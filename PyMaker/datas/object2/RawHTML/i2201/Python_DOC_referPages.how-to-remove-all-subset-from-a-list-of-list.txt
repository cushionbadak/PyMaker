<div class="post-text" itemprop="text">
<p>what is the efficient way to clean sublist in list . cause I only want to got the biggest set in list. just like.</p>
<pre><code>b = [[1,2,3], [1,2], [3,5], [2,3,4], [2,3,4], [3,4,5], [1,2,4,6,7]]  
</code></pre>
<p>and I want the output as follow. </p>
<pre><code>result = [[1,2,3], [2,3,4], [3,4,5], [1,2,4,6,7]]
</code></pre>
<p>Cause [1,2] is subset of [1,2,3] and [1,2,4,6,7], [3,5] is subset of [3,4,5], and also [2,3,4] appear 2 times, only want calculate 1 time in final result. I want to based on the subset logical to filter data. </p>
<p>I only think out 2 loops solution to solve this problem, but if there is other efficient way to solve this problem.</p>
<p>what I tried like that: (after I optimising this one more effect, add break and add 1 part not calculate 2 times) </p>
<pre><code>b = [[1,2,3], [1,2], [3,5], [2,3,4], [2,3,4], [3,4,5], [1,2,4,6,7]]
i = 0
record = []
subset_status = False
for index, re in enumerate(b):
    while i &lt;= (len(b)-1):
        if i != index:
            if i not in record:
                if set(re).issubset(b[i]):
                    subset_status = True
                    break
        i += 1
    i = 0
    if subset_status:
        record.append(index)
        subset_status = False
print(record)
&gt;&gt;[1, 2, 3]
</code></pre>
<p>So I got the index in [1,2,3] is the dirty data.
Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>filter</code> your list on condition:</p>
<pre><code>b = [[1,2,3], [1,2], [3,5], [2,3,4],[3,4,5]]

print(list(filter(lambda x: len(x) == 3, b)))
# [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A conditional <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a> is a pythonic, flexible and performant approach. It is usually faster and less error prone to assemble the clean list from scratch than to repeatedly remove elements:</p>
<pre><code>b = [[1, 2, 3], [1, 2], [3, 5], [2, 3, 4],[3, 4, 5]]

cleaned = [x for x in b if clean(x)]  # where clean is your condition
# e.g.
cleaned = [x for x in b if len(x) == 3] 
# [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
</code></pre>
<p>If you need to mutate the original <code>list</code> object, use slice assignment:</p>
<pre><code>b[:] = [x for x in b if clean(x)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to do this is to process the lists in <code>b</code> in order of length, from longest to shortest.</p>
<pre><code>b = [[1,2,3], [1,2], [3,5], [2,3,4], [2,3,4], [3,4,5], [1,2,4,6,7]]
result = []
for u in sorted(map(set, b), key=len, reverse=True):
    if not any(u &lt;= v for v in result):
        result.append(u)
print(result)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[{1, 2, 4, 6, 7}, {1, 2, 3}, {2, 3, 4}, {3, 4, 5}]
</code></pre>
<p>If you need to keep the inner lists as actual lists, and you also need to preserve the order, then we can do that with an additional pass over the data. But instead of using a list for <code>result</code> I'll use a set to make the tests more efficient. And that means turning the sublists into frozensets: plain sets won't work because only hashable objects can be put into a set.</p>
<pre><code>b = [[1,2,3], [1,2], [3,5], [2,3,4], [2,3,4], [3,4,5], [1,2,4,6,7]]
temp = set()
for u in sorted(map(frozenset, b), key=len, reverse=True):
    if not any(u &lt;= v for v in temp): 
        temp.add(u)
newb = []
for u in b: 
    if set(u) in temp and u not in newb:
        newb.append(u)
print(newb)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[[1, 2, 3], [2, 3, 4], [3, 4, 5], [1, 2, 4, 6, 7]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is not very good, but it works:</p>
<pre><code>result = []
for i in b:
    for j in result:
        if all(c in j for c in i):
            break
    else:
        new_list.append(i)

for i in result:
    for j in result:
        if all(c in j for c in i) and result.index(i) != result.index(j):
            del(result[result.index(i)])
            break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <em>tuples</em> and <em>product</em> to detect if item is a sublist, then construct a new list excluding those sublist    </p>
<p><em>list comprehension</em></p>
<pre><code>from itertools import product

b = [[1,2,3], [1,2], [3,5], [2,3,4], [3,4,5], [1,2,4,6,7]]

dirty = [i for i in b for j in b if i != j if tuple(i) in product(j, repeat = len(i))]
clean = [i for i in b if i not in dirty]
</code></pre>
<p>Expanded explanation:</p>
<pre><code>dirty = []
for i in b:
    for j in b:
        if i != j:
            if tuple(i) in product(j, repeat = len(i)):
                dirty.append(i)

clean = [i for i in b if i not in dirty]
</code></pre>
<blockquote>
<pre><code>[[1, 2, 3], [2, 3, 4], [3, 4, 5], [1, 2, 4, 6, 7]]
</code></pre>
</blockquote>
</div>
<span class="comment-copy">What are the conditions for a "clean" list? Has to have 3 elements?</span>
<span class="comment-copy">Why not just initialize b to be what you want? <code>b = [[1,2,3], [2,3,4], [3,4,5]]</code></span>
<span class="comment-copy">@RedCricket this is the other way, but I want to from other angle to solve my problem, so I meet this problem.</span>
<span class="comment-copy">uh â€¦  how is <code>[1,2,4,6,7], [3,5]</code> a subset of` <code>[3,4,5]</code>.</span>
<span class="comment-copy">@RedCricket how about now, I revised my question based on what 'Sayse' remind me.</span>
<span class="comment-copy">Thank you. But I don<code>t by the right way to represent my question, I don</code>t want to based on the length of sublist.</span>
<span class="comment-copy">Thanks, but I do not want to based on length of sublist. The logic I revised in my question. thanks again.</span>
<span class="comment-copy">thanks, but your way can not work for complex situation. if [2,3,4] appear 2 times in b, you can not filter out one of them. and also this one solution till need go through b 2 times. Not more effect as what i use now.  thanks, again</span>
