<div class="post-text" itemprop="text">
<p>For example I type
<code>word = "aaBBaac"</code>
How would I get the output to be</p>
<pre><code>[2,2,3]
</code></pre>
<p>This is what I already have:</p>
<pre><code>word = input()
count = 0
for i in range(0,len(word)):
    if word[i-1].islower()==word[i].islower()==True:
        count+=1
print(count)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would say the accepted answer is <em>certainly</em> the right way to go.  But since it was requested to do it without importing anything, I figured I'd try one.  Here is what I came up with:</p>
<pre><code>my_string = "aaBBaac"
my_list = []

iterate = 0
total = 0

for x in my_string:
    if iterate == len(my_string) - 1:
        #this is for last character in the list
        if (x.isupper() and my_string[iterate - 1].islower()) or (x.islower() and my_string[iterate - 1].isupper()):
            my_list.append(1)
        else:
            total += 1
            my_list.append(total)
    elif (x.islower() and my_string[iterate + 1].islower()) or (x.isupper() and my_string[iterate + 1].isupper()):
        #is the current and next character the same case?
        total += 1
    else:
        #current and next character must be different
        total += 1
        my_list.append(total)
        total = 0
    iterate += 1

print (my_list)
</code></pre>
<p>It's looking at the current character in the string in comparing it to the next one.  If the current and next character are the same case add to <code>total</code> if they are not add the <code>total</code> to <code>my_list</code> and reset total.  The first <code>if</code> is a special case for the last character in the string.</p>
</div>
<div class="post-text" itemprop="text">
<p>you could solve that using <a href="https://docs.python.org/3/library/itertools.html?highlight=itertools#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>from itertools import groupby

word = "aaBBaac"
ret = []
for _key, group in groupby(word, key=lambda x: x.islower()):
    ret.append(len(tuple(group)))
print(ret)  # [2, 2, 3]
</code></pre>
<p><code>groupby</code> emits all the elements for which the <code>key</code> is the same as a <code>group</code>. in this example the <code>key</code> function changes from <code>True</code> to <code>False</code> (or vice versa) every time the case of the letter in question changes.</p>
<p>you could pack this into a list-comprehension: </p>
<pre><code>ret = [sum(1 for item in group)
       for _, group in groupby(word, key=str.islower)]
</code></pre>
<p>(it is probably more efficient and more elegant to use <code>sum(1 for item in group)</code> instead of <code>len(tuple(group))</code>. and <code>key=str.islower</code> instead of the <code>lambda</code> expression i used above).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>word= input() 
consec_cnt_lst = []
idx = 0
</code></pre>
<p>here are two ways in which you can structure the code. 
pay attention on how <code>idx</code> is being incremented.</p>
<p><br/>
1)</p>
<pre><code>while idx &lt; len(word):

    if 'A' &lt;= word[idx] &lt;= 'Z':
        upper_cnt = 0
        while idx &lt; len(word) and 'A' &lt;= word[idx] &lt;= 'Z': 
            upper_cnt +=1
            idx+=1

        consec_cnt_lst.append(upper_cnt)

    elif  'a' &lt;= word[idx] &lt;= 'z':  
        lower_cnt = 0
        while idx &lt; len(word) and 'a' &lt;= word[idx] &lt;= 'z':
            lower_cnt +=1
            idx+=1

        consec_cnt_lst.append(lower_cnt)

    else:
        idx+=1      
</code></pre>
<p><br/>
2)</p>
<pre><code>while idx &lt; len(word):
    upper_cnt = 0
    while idx &lt; len(word) and 64 &lt; ord(word[idx]) &lt; 91: #ASCII value of  A = 65 and Z = 90
        upper_cnt +=1
        idx+=1

    if upper_cnt &gt; 0:
        consec_cnt_lst.append(upper_cnt)
        idx-=1

    lower_cnt = 0
    while idx &lt; len(word) and 96 &lt; ord(word[idx]) &lt; 123: #ASCII value of  a = 97 and Z = 122
        lower_cnt +=1
        idx+=1

    if lower_cnt &gt; 0:
        consec_cnt_lst.append(lower_cnt)
        idx-=1

    idx+=1   
</code></pre>
<p><br/> <code>print(consec_cnt_lst)</code> </p>
<p>output</p>
<pre><code># AAAnnnnZZz --&gt; [3, 4, 2, 1]
# AAAnn23nnZZz --&gt; [3, 2, 2, 2, 1]
# aaaBBaaa --&gt; [3, 2, 3]
</code></pre>
</div>
<span class="comment-copy">What did you try already?</span>
<span class="comment-copy">You'll get the best results if you can show something where you have started.  Even if you are simply stuck on part of it.  Most people on StackOverflow are not just going to want to write it all for you.</span>
<span class="comment-copy">@BoyleChen, edit your questions adding the code instead of posting a comment</span>
<span class="comment-copy">I had problems figuring out how to deal with “is the current and next letter the same case” thanks for providing your solution!</span>
<span class="comment-copy">Is there any way I could do this without importing?</span>
<span class="comment-copy">you could copy-paste the <code>groupby</code> code you find in the doc (follow the link above). where it says <i>groupby() is roughly equivalent to:</i>. but why not import? <code>groupby</code> is in the standard library; i.e. it is available in the python interpreter itself.</span>
<span class="comment-copy">Thanks so much!</span>
