<div class="post-text" itemprop="text">
<p>I'm using pytest to write some unit tests, and wondering what the best approach for testing 'dependent' functions are. Let's say I have two functions:</p>
<pre><code>def set_file(filename, filecontents):
    # stores file as key in memcache

def get_file(filename):
    # returns the contents of the filename if it exists in cache
</code></pre>
<p>Currently, I have a 'happy path' unit test that looks something like this:</p>
<pre><code>def test_happy_path():
    assert not get_file('unit test') # check that return of non-existent file is None
    set_file('unit test', 'test content') # set file contents
    assert get_file('unit test') == 'test content'  # check that return matches input
</code></pre>
<p>My question is whether this approach is valid? Should I be trying to mock data of <code>set_file</code> when testing <code>get_file</code> to have a unit test that has no dependancies created by <code>set file</code>? If so, how would I mock that, especially since <code>set_file</code> is using pymemcached?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your unit test looks perfectly valid. There's no harm in setting files to <code>pymemcache</code> during tests because everything remains in local memory. It's also perfectly ok to have such "setup" dependencies in your tests.</p>
<p>If you notice that you start to have multiple tests dependending on the same setup, you can use <a href="https://docs.pytest.org/en/latest/fixture.html" rel="nofollow noreferrer">pytest fixtures</a> for setting up such setup and teardown dependencies. Example code could look like this:</p>
<pre class="lang-py prettyprint-override"><code>import pytest

FILENAME = "test-file"
TEST_CONTENT = "some content"


@pytest.fixture()
def set_file_contents():
    assert not get_file(FILENAME)
    set_file(FILENAME, TEST_CONTENT)
    yield FILENAME, TEST_CONTENT  # These values are provided to the test
    delete_file(FILENAME)  # This is run after the test
    assert not get_file(FILENAME)


class TestFileContents:

    def test_get_file(self, set_file_contents):
        filename, file_contents = set_file_contents
        assert get_file(filename) == file_contents

</code></pre>
<p>Using fixtures is an overkill in your case but you see the basic idea.</p>
</div>
<span class="comment-copy">As for me, your <code>test_happy_path</code> seems to be valid...</span>
<span class="comment-copy">Great, thanks for the answer and explanation!</span>
<span class="comment-copy">I just realized that if you're connecting to an external <code>memcached</code> database in your code, you definitely need to either mock or use a test database. Mocking should be easy by using <a href="https://pymemcache.readthedocs.io/en/latest/apidoc/pymemcache.test.utils.html#module-pymemcache.test.utils" rel="nofollow noreferrer">MockMemcacheClient</a> from <code>pymemcache</code> in your application code when testing.</span>
