<div class="post-text" itemprop="text">
<p>I have a string. The end is different, such as <code>index.php?test=1&amp;list=UL</code> or <code>index.php?list=UL&amp;more=1</code>. The one thing I'm looking for is <code>&amp;list=</code>.</p>
<p>How can I match it, whether it's in the middle of the string or it's at the end? So far I've got <code>[&amp;|\?]list=.*?([&amp;|$])</code>, but the <code>([&amp;|$])</code> part doesn't actually work; I'm trying to use that to match either <code>&amp;</code> or the end of the string, but the end of the string part doesn't work, so this pattern matches the second example but not the first.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use:</p>
<pre><code>/(&amp;|\?)list=.*?(&amp;|$)/
</code></pre>
<p>Note that when you use a bracket expression, every character within it (with <a href="http://en.wikipedia.org/wiki/Regular_expression#POSIX_Basic_Regular_Expressions" rel="noreferrer">some</a> exceptions) is going to be interpreted literally. In other words, <code>[&amp;|$]</code> matches the <strong>characters</strong> <code>&amp;</code>, <code>|</code>, and <code>$</code>.</p>
</div>
<div class="post-text" itemprop="text">
<h1>In short</h1>
<p>Any zero-width assertions inside <code>[...]</code> lose there meaning of a zero-width assertion. <code>[\b]</code> does not match a word boundary (it matches a backspace, or, in POSIX, <code>\</code> or <code>b</code>), <code>[$]</code> matches a literal <code>$</code> char, <code>[^]</code> is either an error or, as in ECMAScript regex flavor, any char. Same with <code>\z</code>, <code>\Z</code>, <code>\A</code> anchors.</p>
<p>You may solve the problem using any of the below patterns:</p>
<pre><code>[&amp;?]list=([^&amp;]*)
[&amp;?]list=(.*?)(?=&amp;|$)
[&amp;?]list=(.*?)(?![^&amp;])
</code></pre>
<h1>Matching between a char sequence and a single char or end of string (current scenario)</h1>
<p>The <code>.*?([YOUR_SINGLE_CHAR_DELIMITER(S)]|$)</code> pattern (<a href="https://stackoverflow.com/a/12083343/3832970">suggested by João Silva</a>) is rather inefficient since the regex engine checks for the patterns that appear to the right  of the lazy dot pattern first, and only if they do not match does it "expand" the lazy dot pattern.</p>
<p>In these cases it is recommended to use <a href="https://www.regular-expressions.info/charclass.html#negated" rel="nofollow noreferrer"><em>negated character class</em></a> (or <em>bracket expression</em> in the POSIX talk):</p>
<pre><code>[&amp;?]list=([^&amp;]*)
</code></pre>
<p><a href="https://regex101.com/r/ZQb63I/1" rel="nofollow noreferrer">See demo</a>. <strong>Details</strong></p>
<ul>
<li><code>[&amp;?]</code> - a positive character class matching either <code>&amp;</code> or <code>?</code> (note the relationships between chars/char ranges in a character class are OR relationships)</li>
<li><code>list=</code> - a substring, char sequence</li>
<li><code>([^&amp;]*)</code> - Capturing group #1: zero or more (<code>*</code>) chars other than <code>&amp;</code> (<code>[^&amp;]</code>), as many as possible</li>
</ul>
<h1>Checking for the trailing single char delimiter presence without returning it  or end of string</h1>
<p>Most regex flavors (including JavaScript beginning with ECMAScript 2018) support lookarounds, constructs that only return true or false if there patterns match or not. They are crucial in case consecutive matches that may start and end with the same char are expected (see the original pattern, it may match a string starting and ending with <code>&amp;</code>). Although it is not expected in a query string, it is a common scenario.</p>
<p>In that case, you can use two approaches:</p>
<ul>
<li>A positive lookahead with an alternation containing positive character class: <code>(?=[SINGLE_CHAR_DELIMITER(S)]|$)</code></li>
<li>A negative lookahead with just a negative character class: <code>(?![^SINGLE_CHAR_DELIMITER(S)])</code></li>
</ul>
<p>The negative lookahead solution is a bit more efficient because it does not contain an alternation group that adds complexity to matching procedure. The OP solution would look like</p>
<pre><code>[&amp;?]list=(.*?)(?=&amp;|$)
</code></pre>
<p>or</p>
<pre><code>[&amp;?]list=(.*?)(?![^&amp;])
</code></pre>
<p>See <a href="https://regex101.com/r/ZQb63I/2" rel="nofollow noreferrer">this regex demo</a> and <a href="https://regex101.com/r/ZQb63I/3" rel="nofollow noreferrer">another one here</a>.</p>
<p>Certainly, in case the trailing delimiters are multichar sequences, only a positive lookahead solution will work since <code>[^yes]</code> does not negate a sequence of chars, but the chars inside the class (i.e. <code>[^yes]</code> matches any char but <code>y</code>, <code>e</code> and <code>s</code>).</p>
</div>
<span class="comment-copy">Thanks; the "interpreted literally" part I was not aware of for square brackets. Very useful! So in order to use <code>|</code> to separate two or more characters, is <code>()</code> required?</span>
<span class="comment-copy">Yes, indeed, you need to group (<code>()</code>) the alternatives.</span>
<span class="comment-copy"><a href="https://jsfiddle.net/jmqffocL/" rel="nofollow noreferrer">Not working for me.</a></span>
<span class="comment-copy">@DrazenBjelovuk You probably meant <a href="https://jsfiddle.net/jmqffocL/3/" rel="nofollow noreferrer"><code>'SomeText/blahblah'.match(/Some([^\/]*)/)[1]</code></a> (with <code>Text</code> as output). See <a href="https://stackoverflow.com/a/51134786/3832970">my answer</a>, each of the solution contains a <i>capturing group</i> that captures the required submatch that you usually get as the first group after a match is returned.</span>
<span class="comment-copy">@WiktorStribiżew In Hindsight, seems what I meant was <code>string.match(/Some.*?(\/|$)/)[0];</code>. No idea what for at this point though lol.</span>
