<div class="post-text" itemprop="text">
<p>For some unknown reasons ,my browser open test pages of my remote server very slowly. So I am thinking if I can reconnect to the browser after quitting the script but don't execute <code>webdriver.quit()</code> this will leave the browser opened. It is probably kind of HOOK or webdriver handle.
I have looked up the selenium API doc but didn't find any function.
I'm using Chrome 62,x64,windows 7,selenium 3.8.0.
I'll be very appreciated whether the question can be solved or not.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>No</strong>, you can't reconnect to the previous <strong><code>Web Browser</code></strong> session after quiting the script. Even if you are able to extract the <strong><code>Session ID</code></strong>, <strong><code>Cookies</code></strong> and other session attributes from the previous <strong><code>Browsing Session</code></strong> still you won't be able to pass those attributes as a HOOK to the <strong><code>WebDriver</code></strong>.</p>
<p>A cleaner way would be to call <strong><code>webdriver.quit()</code></strong> and then span a new <strong><code>Browsing Session</code></strong>.</p>
<h2>History :</h2>
<p>Previously there had been some discussions and attempts to reconnect <code>WebDriver</code> to an existing running browsing session. You can find the discussions in these QA :</p>
<ul>
<li><a href="https://github.com/seleniumhq/selenium-google-code-issue-archive/issues/18" rel="noreferrer"><strong><code>Allow webdriver to attach to a running browser</code></strong></a></li>
<li><a href="https://github.com/SeleniumHQ/selenium-google-code-issue-archive/issues/2163" rel="noreferrer"><strong><code>[docs] webdriver.firefox.useExisting not implemented</code></strong></a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<h2><strong>Yes</strong>, that's actually quite easy to do.</h2>
<p>A selenium &lt;-&gt; webdriver session is represented by a connection url and session_id, you just reconnect to an existing one.</p>
<p><strong>Disclaimer</strong> - the approach is using selenium internal properties ("private", in a way), which may change in new releases; you'd better not use it for production code; it's better not to be used against remote SE (yours hub, or provider like BrowserStack/Sauce Labs), because of a caveat/resource drainage explained at the end.  </p>
<p>When a webdriver instance is initiated, you need to get the before-mentioned properties; sample:</p>
<pre><code>from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.google.com/')

# now Google is opened, the browser is fully functional; print the two properties
# command_executor._url (it's "private", not for a direct usage), and session_id

print(f'driver.command_executor._url: {driver.command_executor._url}')
print(f'driver.session_id: {driver.session_id}')
</code></pre>
<p>With those two properties now known, another instance can connect; the "trick" is to initiate a <code>Remote</code> driver, and provide the <code>_url</code> above - thus it will connect to that running selenium process:</p>
<pre><code>driver2 = webdriver.Remote(command_executor=the_known_url)  
# when the started selenium is a local one, the url is in the form 'http://127.0.0.1:62526'
</code></pre>
<p>When that is ran, you'll see a new browser window being opened.<br/>
That's because upon initiating the driver, the selenium library automatically starts a new session for it - and now you have 1 webdriver process with 2 sessions (browsers instances).  </p>
<p>If you navigate to an url, you'll see it is executed on that new browser instance, not the one that's left from the previous start - which is not the desired behavior.<br/>
At this point, two things need to be done - a) close the current SE session ("the new one"), and b) switch this instance to the previous session:</p>
<pre><code>if driver2.session_id != the_known_session_id:   # this is pretty much guaranteed to be the case
    driver2.close()   # this closes the session's window - it is currently the only one, thus the session itself will be auto-killed, yet:
    driver2.quit()    # for remote connections (like ours), this deletes the session, but does not stop the SE server

# take the session that's already running
driver2.session_id = the_known_session_id

# do something with the now hijacked session:
driver.get('https://www.bing.com/')
</code></pre>
<p>And, that is it - you're now connected to the previous/already existing session, with all its properties (cookies, LocalStorage, etc).  </p>
<p>By the way, you do not have to provide <code>desired_capabilities</code> when initiating the new remote driver - those are stored and inherited from the existing session you took over.</p>
<hr/>
<p><strong>Caveat</strong> - having a SE process running can lead to some resource drainage in the system. </p>
<p>Whenever one is started and then not closed - like in the first piece of the code - it will stay there until you manually kill it. By this I mean - in Windows for example - you'll see a "chromedriver.exe" process, that you have to terminate manually once you are done with it. It cannot be closed by a driver that has connected to it as to a remote selenium process.<br/>
The reason - whenever you initiate a local browser instance, and then call its <code>quit()</code> method, it has 2 parts in it - the first one is to delete the session from the Selenium instance (what's done in the second code piece up there), and the other is to stop the local service (the chrome/geckodriver) - which generally works ok.</p>
<p>The thing is, for Remote sessions the second piece is missing - your local machine cannot control a remote process, that's the work of that remote's hub. So that 2nd part is literally a <code>pass</code> python statement - a no-op.</p>
<p>If you start too many selenium services on a remote hub, and don't have a control over it - that'll lead to resource drainage from that server. Cloud providers like BrowserStack take measures against this - they are closing services with no activity for the last 60s, etc, yet - this is something you don't want to do.</p>
<p>And as for local SE services - just don't forget to occasionally clean up the OS from orphaned selenium drivers you forgot about :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Without getting into why do you think that leaving an open browser windows will solve the problem of being slow, you don't really need a handle to do that. Just keep running the tests without closing the session or, in other words, without calling <code>driver.quit()</code> as you have mentioned yourself. The question here though framework that comes with its own runner? Like Cucumber?</p>
<p>In any case, you must have some "setup" and "cleanup" code. So what you need to do is to ensure during the "cleanup" phase that the browser is back to its initial state. That means:</p>
<ul>
<li>Blank page is displayed</li>
<li>Cookies are erased for the session</li>
</ul>
</div>
<span class="comment-copy">Where's your code?</span>
<span class="comment-copy">Have you tried reusing the chrome existing user directory by using the option 'user-data-dir' instead of webdriver creating a new one each time. Instead of downloading chrome will use stuff from the cache.</span>
<span class="comment-copy">@Grasshopper What is this black magic? I used this Chromeoption.And it reduced plenty of loading time. I'll lookup for this .Thank you very much.</span>
<span class="comment-copy">It is the cache helping load the page so fast</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/8344776/can-selenium-interact-with-an-existing-browser-session">Can Selenium interact with an existing browser session?</a></span>
<span class="comment-copy">You totally understand and solved my confusion. I'll do cleanup . Thank you very much.</span>
<span class="comment-copy">So in such case, the setup code will open the browser and navigate to this page for you, then you run all your tests and the cleanup part will close the window and the browser. This does not look like a good practice as you are adding possible issues from not having a clean session each time but can work as a workaround. Also not sure how the page will behave if you clear the cookies after teach test.</span>
<span class="comment-copy">The function &lt;code&gt;webdriver.Chrome.get(url)&lt;/code&gt; will wait until the page loads completely.This will take a lot of time  to load the remote page. So  I want to open and load the page once. I think the webdriver is still running background after I quit my script . So I want to find the handle for the webdriver and reconnect to the webdriver to reuse the opened page</span>
<span class="comment-copy">You edited your comment after I posted a reply but have a look at it see if this helps.</span>
<span class="comment-copy">I'm sorry about that .Stackoverflow sets a 5 mintues edit time.And almost every time I make it time out.</span>
<span class="comment-copy">My poor English.It is my bad.</span>
