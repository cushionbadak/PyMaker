<div class="post-text" itemprop="text">
<p>In Python 3, I am trying to generate a sequence in this format from 4 lists</p>
<pre><code>&lt;yyyymmdd&gt;-&lt;1-200&gt;-&lt;1-20&gt;-&lt;1-13000&gt;

20161201-1-1-1
20161201-1-1-2
20161201-1-1-3
..
..
20161201-1-2-1
20161201-1-2-2
..
..
20161201-2-1-1
20161201-2-1-2
..
20161202-1-1-1
20161202-1-1-2
..
..
20190701-200-20-13000
</code></pre>
<p>first list is in a date range of <code>&lt;yyyymmdd to yyyymmdd&gt;</code>, the remaining 3 lists are in ranges <code>&lt;1-200&gt; &lt;1-20&gt; and &lt;1-13000&gt;</code>.</p>
<p>All list values are in str format.</p>
<p>Now I'm trying to this the following:</p>
<pre><code>import itertools
import pandas as pd

all_dates = [d.strftime('%Y%m%d') for d in pd.date_range('20160119','20191226')]
all_users = list(range(0,200))
all_products = list(range(0,15))
all_customers = list(range(0,13000))

date_user_product_map = []
date_user_product_customer_map = []

for pair in itertools.product(all_dates,all_users, all_products):
    date_user_product_map.append('-'.join(pair))

for pair in itertools.product(date_user_product_map,all_customers):
    date_user_product_customer_map.append('-'.join(pair))
</code></pre>
<p>The first concatenation of 3 lists is fast and low on memory.
The second concatenation is just taking up huge memory and is getting killed.</p>
<p>I tried running this on a 48 gig RAM system too but it seems no amount of memory is enough for this to run.</p>
<p>I would like some help on solving this issue and also understanding why this needs so much memory. What am I doing wrong here?</p>
<p><strong>UPDATE:</strong>
<strong>(my requirement)</strong></p>
<p>So, I have couple of dataframes which have few columns whose values in the format of the -&lt;1-200&gt;-&lt;1-20&gt;-&lt;1-13000&gt; which is taking up to much space And hence I want to create the list of all possible values and then enumerate over and create a dictionary like below:</p>
<p>-&lt;1-200&gt;-&lt;1-20&gt;-&lt;1-13000&gt;</p>
<p>20161201-1-1-1 : 0
20161201-1-1-2 : 1
20161201-1-1-3 : 2
..
..
20190701-200-20-12999 : n-1
20190701-200-20-13000 : n</p>
<p>and then replace the values of the dataframes to 1,2... n,n-1.</p>
<p>Is there any other way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use a single generator expression:</p>
<pre><code>sequences = ('-'.join(str(x) for x in p) for p in itertools.product(all_dates,all_users,all_products, all_customers))
</code></pre>
<p>Used like:</p>
<pre><code>&gt;&gt;&gt; for _ in range(10): print(next(sequences))

20160119-0-0-0
20160119-0-0-1
20160119-0-0-2
20160119-0-0-3
20160119-0-0-4
20160119-0-0-5
20160119-0-0-6
20160119-0-0-7
20160119-0-0-8
20160119-0-0-9
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You dont need to convert those ranges into lists.</p>
<p>You should do something like this:</p>
<pre><code>import itertools
import pandas as pd

all_dates = (d.strftime('%Y%m%d') for d in pd.date_range('20160119','20191226'))
all_users = range(0,200)
all_products = range(0,15)
all_customers = range(0,13000)

date_user_product_pairs = ( '-'.join(pair) for pair in itertools.product(all_dates,all_users, all_products))

date_user_product_customer_pairs = ( '-'.join(pair) for pair in itertools.product(date_user_product_map,all_customers))
</code></pre>
<p>then you can use those pair generators to get what you need.</p>
</div>
<span class="comment-copy">There are over 1000 dates in that list, so you seem to be compiling a list of 40 billion+ strings, each of which will take about 30 bytes, so you are getting into the terabyte range. Why not make a generator? Do you really need all those strings in memory at once?</span>
<span class="comment-copy">replace all the lists with generators</span>
<span class="comment-copy">Thanks. I've updated my question with my actual requirement. Please have a look.</span>
<span class="comment-copy">The only purpose of your dictionary seems to be to "enumerate" (assign serial numbers to) the concatenated strings. If this understanding is correct, I suggest you drop the idea of having that dictionary. You can always enumerate on the fly using <code>enumerate()</code>.</span>
<span class="comment-copy">@fountainhead a sample code will help. I want the serial numbers to be same across the data frames for the concatenated values.  i.e. I want to replace all <code>*20161201-1-1-2*</code> in all dataframes to <code>*1*</code>. Similarly replace <code>*20161201-1-1-3*</code> with <code>*2*</code>.  The reason is, I will use this column to merge between the dataframes and also later.</span>
<span class="comment-copy">Thanks. But I don't know how I can use this to solve my purpose. I've updated my question with my actual requirement. Please have a look.</span>
<span class="comment-copy">you can use those pair generator fuctions to make the dict</span>
<span class="comment-copy">But even then, doesn't creating a dictionary later won't have similar memory issues?</span>
<span class="comment-copy">No , you just loop over those two , and write them to file system instead of storing it in memory</span>
<span class="comment-copy">and if you want more computation on that , then load them again using a generator , do the computation in loop and write it back to file system , never store in RAM  in any step</span>
