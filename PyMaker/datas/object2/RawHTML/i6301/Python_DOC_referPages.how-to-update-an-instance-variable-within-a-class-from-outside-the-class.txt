<div class="post-text" itemprop="text">
<p>Here is some example code for the question:
</p>
<pre><code>class Obj():    
    def __init__(self, p):
        self.property = p

    def printProp(self):
        print(self.property)

myVar = 0
myObject = Obj(myVar)

myObject.printProp()
myVar = 1
myObject.printProp()
</code></pre>
<p>When this runs, the parameter is not changed, and 0 is printed twice, because the constructor is only called once. Is there a way to have the property always directly reference the <code>myVar</code> variable?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can access the classes property directly like this: <code>myObject.property = 1</code>. 
Alternatively, you could add a class method to set the property like this:</p>
<pre><code>def setProp(self, val):
    self.property = val
</code></pre>
<p>This is generally better coding practice as class properties should only be modified within the class.</p>
</div>
<span class="comment-copy">"Is there a way to have the property always directly reference the myVar variable?" - no. Variables don't work that way. <code>myObject.property</code> can only refer to an object, not a variable.</span>
<span class="comment-copy">@user2357112, well, there is a nuance: if a variable of a mutable type (dictionary, tuple, list, etc.) and is not redefined, but changed instead, then the above code would work</span>
<span class="comment-copy">Umm... Python best practice is to <i>avoid</i> unnecessary getter/setter functions like this. If the attribute isn't prefixed with an underscore, it's usually considered part of the public API and you're welcome to read or write it as you please (so long as it follows the expected type and contents for the class). The <code>@property</code> decorator exists so such a public attribute can be changed to a seamless use of getter/setter should it stop being a "simple" attribute, and require logic on get and set.</span>
<span class="comment-copy"><a href="https://www.python.org/dev/peps/pep-0008/#designing-for-inheritance" rel="nofollow noreferrer">Per PEP8</a>: "For simple public data attributes, it is best to expose just the attribute name, without complicated accessor/mutator methods. Keep in mind that Python provides an easy path to future enhancement, should you find that a simple data attribute needs to grow functional behavior. In that case, use properties to hide functional implementation behind simple data attribute access syntax."</span>
<span class="comment-copy">Fair enough. Coming from C++ setting class attributes outside of class functions always makes me nervous. If the getter/setting is just getting or settings, then I agree it is unnecessary. I just usually prefer setters to ensure that values are valid.</span>
<span class="comment-copy">@L.MacKenzie <a href="https://www.python-course.eu/python3_properties.php" rel="nofollow noreferrer">don't use getters and setters</a> in python. Python uses <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">properties</a></span>
