<div class="post-text" itemprop="text">
<p>I have a process which generates 2-item lists as <code>[datestamp, timestamp]</code>.</p>
<p>if I put this into a list comprehension as:</p>
<pre><code>[(ds,ts) for ds,ts in process]
</code></pre>
<p>my desired outcome is:</p>
<pre><code>[(ds,ts), (ds,ts), (ds,ts)]
</code></pre>
<p>What I get is <code>ValueError: too many values to unpack</code>.</p>
<p>This is because the <code>for</code> loop iteration into the list returned by the process: </p>
<pre><code>for ds,ts in [datestamp, timestamp]
</code></pre>
<p>does not assign <code>ds=datestamp</code>, <code>ts=timestamp</code>, but rather iterates across each letter ... if this worked it would give <code>(d,t)</code>, <code>(a,i)</code>, <code>(t,m)</code>, <code>(e,e)</code> etc</p>
<p>So I know what's wrong ... but not how to make this work! 
(and yeah, this does feel silly ... I know the answer will be real simple</p>
</div>
<div class="post-text" itemprop="text">
<p>This works:</p>
<pre><code>process = [[1,2],[3,4],[5,6]]
a = []
for ds, ts in process:
    print(ds, ts)
    a.append((ds, ts))
</code></pre>
<p>As well as</p>
<pre><code>z = [(ds, ts) for (ds, ts) in process]
q = [(ds, ts) for ds, ts in process]
</code></pre>
<p>If you are getting a <code>'ValueError: too many values to unpack'</code> exception, process must be producing iterables that have more than two items.</p>
<p>Unwind the list comprehension and <a href="https://docs.python.org/3/tutorial/errors.html#handling-exceptions" rel="nofollow noreferrer">Handle the exception</a> - print something relevant in the except suite to see what might be going wrong, then work backwards to the source. something like</p>
<pre><code>process = [[1,2],[3,4],[5,6], [7,8,9]]

a = []
try:
    for thing in process:
        ds, ts = thing
        a.append((ds, ts))
except ValueError as e:
    print(e, '\t', thing)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to debug. There must be some items in your list that are not pairs as you expect.</p>
<p>One way you can find them would be:</p>
<pre><code>problems = [(idx, value) for idx,value in enumerate(process) if len(value)!=2]
</code></pre>
<p>This will give you a list of the problem indexes and items in your list.</p>
<p>If that gives an error- for example, a <code>TypeError</code> because the <code>value</code> object has no <code>__len__</code> method- then change it to:</p>
<pre><code>problems = [(idx, value) for idx,value in enumerate(process) if not hasattr(value, '__len__')]
</code></pre>
</div>
<span class="comment-copy">Are you after <code>[(x[0],x[1]) for x in process]</code>? on each iteration you have a single list object with 2 items so you just need to index into the list</span>
<span class="comment-copy">So you have a list containing two elements, and want to turn it into a tuple containing two elements? How about <code>my_tuple = tuple(my_list)</code>?</span>
<span class="comment-copy">Please post the contents of <code>process</code>.</span>
<span class="comment-copy">Try <code>[(ds,ts) for ds, ts in zip(datestamp, timestap)]</code></span>
<span class="comment-copy">Thanks for the suggestions. I subsequently decided on a completely different approach not involving this list comprehension issue.</span>
