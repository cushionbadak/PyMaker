<div class="post-text" itemprop="text">
<p>In my test files, I would like to mock a helper function that I have contained within a module.  I am able to 'successfully' (ie no compile or run time errors as everything is linked properly) mock the function, but the mock does not trickle through to the class I am testing.</p>
<p>I have looked into dependency injection, but I am not exactly sure how to inject my module which only has one function mocked for now.  Eventually I plan on mocking almost all of the functions; I just want to get a baseline working first.</p>
<p>Here is what I have so far</p>
<pre><code>class FooTestCase(unittest.TestCase):

    @mock.patch('modules.MyHelperModule.helper_function')
    def test_simple(self, mock_hf):

        my_obj = MyObj()

        # internally, this class imports HelperModule 
        # and the method calls helper_function with 1
        my_obj.do_something()

        mock_hf.helper_function.assert_called_with(1)

        return
</code></pre>
<p>The assert command is failing and reporting that the method was never called. I am assuming the mock never makes it through to my_obj.</p>
<p>I understand that I could create a flag in the init method of MyObj like testing=False and import modules accordingly, but how could I import the module that was mocked only in the test files?  This is the approach I am thinking about right now, but I am open to other implementations that get me the same result.</p>
<p>In response to Daniel Roseman's comment,</p>
<p>In MyOBJ, I have the following line</p>
<pre><code>from modules.HelperModule import helper_function
</code></pre>
<p>However, I am getting the error </p>
<pre><code>ImportError: No module named modules
</code></pre>
<p>My patch line now looks like</p>
<pre><code>@mock.patch('MyObj.modules.HelperModule.helper_function')
</code></pre>
<p>Any help is always appreciated; Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>I guess the problem is that mock_hf is not what you want to patch.
try with:</p>
<pre><code>from unittest.mock import patch
class FooTestCase(unittest.TestCase):


def test_simple(self):
    with patch('modules.MyHelperModule.helper_function') as mock_hf:
        my_obj = MyObj()
        my_obj.do_something()
        mock_hf.assert_called_with(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned in Daniel Roseman's comment to my original post, the issue was with where I was patching.</p>
<p>I should have been patching MyObj.helper_function.  Additionally, I had, in the <strong>init</strong>.py, a from MyObj import MyObj.  This caused me to only be able to reference the MyObj class in my tests, but I needed to overwrite the helper_function for the whole file.  I had to remove that line.</p>
</div>
<span class="comment-copy">Read this: <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">Where to patch</a>.</span>
<span class="comment-copy">Continuing my own research and I just came to the same article!  Thank you.  Do you know a more detailed version than the documentation?</span>
