<div class="post-text" itemprop="text">
<p>Suppose I have a string of the of the format <code>host:port</code>, where <code>:port</code> is optional. How can I reliably extract the two components?</p>
<p>The host can be any of:</p>
<ul>
<li>A hostname (<code>localhost</code>, <code>www.google.com</code>)</li>
<li>An IPv4 literal (<code>1.2.3.4</code>)</li>
<li>An IPv6 literal (<code>[aaaa:bbbb::cccc]</code>).</li>
</ul>
<p>In other words, this is the standard format used across the internet (such as in URIs: complete grammar at <a href="https://tools.ietf.org/html/rfc3986#section-3.2" rel="nofollow noreferrer">https://tools.ietf.org/html/rfc3986#section-3.2</a>, excluding the "User Information" component).</p>
<p>So, some possible inputs, and desired outputs:</p>
<pre><code>'localhost' -&gt; ('localhost', None)
'my-example.com:1234' -&gt; ('my-example.com', 1234)
'1.2.3.4' -&gt; ('1.2.3.4', None)
'[0abc:1def::1234]' -&gt; ('[0abc:1def::1234]', None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should handle the whole parse in a single regex</p>
<pre><code>regex = re.compile(r'''
(                            # first capture group = Addr
  \[                         # literal open bracket                       IPv6
    [:a-fA-F0-9]+            # one or more of these characters
  \]                         # literal close bracket
  |                          # ALTERNATELY
  (?:                        #                                            IPv4
    \d{1,3}\.                # one to three digits followed by a period
  ){3}                       # ...repeated three times
  \d{1,3}                    # followed by one to three digits
  |                          # ALTERNATELY
  [-a-zA-Z0-9.]+              # one or more hostname chars ([-\w\d\.])      Hostname
)                            # end first capture group
(?:                          
  :                          # a literal :
  (                          # second capture group = PORT
    \d+                      # one or more digits
  )                          # end second capture group
 )?                          # ...or not.''', re.X)
</code></pre>
<p>All that's needed then is to cast the second group to int.</p>
<pre><code>def parse_hostport(hp):
    # regex from above should be defined here.
    m = regex.match(hp)
    addr, port = m.group(1, 2)
    try:
        return (addr, int(port))
    except TypeError:
        # port is None
        return (addr, None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's my attempt at this so far:</p>
<pre><code>def parse_hostport(hp):
    """ parse a host:port pair
    """
    # start by special-casing the ipv6 literal case
    x = re.match('^(\[[0-9a-fA-F:]+\])(:(\d+))?$', hp)
    if x is not None:
        return x.group(1, 3)

    # otherwise, just split at the (hopefully only) colon
    splits = hp.split(':')

    if len(splits) == 1:
        return splits + [None,]
    elif len(splits) == 2:
        return splits

    raise ValueError("Invalid host:port input '%s'" % hp)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a terser implementation which relies on attempting to parse the last component as an int:</p>
<pre><code>def parse_hostport(s):
    out = s.rsplit(":", 1)
    try:
        out[1] = int(out[1])
    except (IndexError, ValueError):
        # couldn't parse the last component as a port, so let's
        # assume there isn't a port.
        out = (s, None)
    return out
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def split_host_port(string):
    if not string.rsplit(':', 1)[-1].isdigit():
        return (string, None)

    string = string.rsplit(':', 1)

    host = string[0]  # 1st index is always host
    port = int(string[1])

    return (host, port)
</code></pre>
<p>Actually confused on whether this is what you wanted, but I rewrote it up a bit and it still seems to follow the ideal output:</p>
<pre><code>&gt;&gt;&gt;&gt; split_host_port("localhost")
('localhost', None)
&gt;&gt;&gt;&gt; split_host_port("example.com:1234")
('example.com', 1234)
&gt;&gt;&gt;&gt; split_host_port("1.2.3.4")
('1.2.3.4', None)
&gt;&gt;&gt;&gt; split_host_port("[0abc:1def::1234]")
('[0abc:1def::1234]', None)
&gt;&gt;&gt;&gt; 
</code></pre>
<p>As on the first line I didn't really like the chained function calls e.g. <code>getattr(getattr(getattr(string, 'rsplit')(':', 1), '__getitem__')(-1), 'isdigit')()</code> for the expanded version and then it's repeated again two lines after, perhaps I should make it a variable instead so there's no need for all the calls.</p>
<p>But I'm nitpicking here so feel free to call me out on that, heh.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's my final attempt, with credit to other answerers who provided inspiration:</p>
<pre><code>def parse_hostport(s, default_port=None):
    if s[-1] == ']':
        # ipv6 literal (with no port)
        return (s, default_port)

    out = s.rsplit(":", 1)
    if len(out) == 1:
        # No port
        port = default_port
    else:
        try:
            port = int(out[1])
        except ValueError:
            raise ValueError("Invalid host:port '%s'" % s)

    return (out[0], port)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, this is Python, with batteries included. You have mention that the format is the standard one used in URIs, so how about <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlsplit" rel="nofollow noreferrer"><code>urllib.parse</code></a>?</p>
<pre><code>import urllib.parse

def parse_hostport(hp):
    # urlparse() and urlsplit() insists on absolute URLs starting with "//"
    result = urllib.parse.urlsplit('//' + hp)
    return result.hostname, result.port
</code></pre>
<p>This should handle any valid <code>host:port</code> you can throw at it.</p>
</div>
<span class="comment-copy">What have you tried already? What specifically are you stuck on?</span>
<span class="comment-copy">It's sort-of hard to do this in Python (purely) where the delimiter is a factor inside the actual IPv6 address itself. Could you revise that?</span>
<span class="comment-copy">my best attempt so far is to use a regex to special-case the ipv6 literal case, and otherwise use <code>split</code>.</span>
<span class="comment-copy">клйкбаутоь мажаз вайкукас: well, host:port is a fairly common format, so I can't really change that.</span>
<span class="comment-copy">Well, there we go. Two sets of codez in the answers.</span>
<span class="comment-copy">Sorry, I should have been clearer: the host can be any hostname, not just localhost. Will amend the question.</span>
<span class="comment-copy">Nicely explained with comments on each row. +1</span>
<span class="comment-copy">@richvdh fixed.</span>
<span class="comment-copy">@AdamSmith think you forgot dashes!</span>
<span class="comment-copy">@richvdh I'm not sure what you mean. This code interprets all your test cases correctly. <a href="https://repl.it/NFBd" rel="nofollow noreferrer">Try it here</a></span>
<span class="comment-copy">I'm not a huge fan of this implementation, largely because my instinct is to avoid code which throws exceptions in unexceptional circumstances. Still, I think it's better than the regex version.</span>
<span class="comment-copy">This is interesting because it avoids the need for exceptions. Some ideas for enhancement: * do the <code>isdigit</code> test before the split - if it fails, we just return <code>(string, None)</code> * use `rsplit(':',1) to avoid having to stick the host back together again afterwards.</span>
<span class="comment-copy">Thanks, I'll change it now-- actually never knew <code>str.rsplit</code> existed, would've done some weird code like <code>string[::-1].split(':')</code> and joined it back after doing the necessary stuff, TIL I guess :D</span>
<span class="comment-copy">good idea, although if it's important to detect and reject invalid <code>host:port</code> specifications, this won't cut the mustard</span>
