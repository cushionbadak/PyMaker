<div class="post-text" itemprop="text">
<p>I have a wood sheet and have given N mark on wood sheet.Now i have to cut all the marks on wood sheet such that cost of cutting all the marks in minimum.Now suppose i first cut the i th mark then the cost is given by using two multipliers a and b which are inputs and the cost is a*(left)+b*(right) where left and right are the size of remaining part of the wood after cutting .for example if i have a wood of length 10 and a=3 and b=4 and if i have mark list for ex: [1,3,5,7,10] so i cant cut first and last mark because they are the starting and end point of the wood so suppose if i start with mark 7 first then cost of cutting will be 3*(7-1)+4*(10-7)=18+12=30 and now the wood which i would have is one starting with mark 1 to mark 7 and other would be one with mark 7 to the end of the wood ad i would repeat the process till all of the marks have been cut .</p>
<p>Now after reading the question it immediately came to my mind that in order to cut the wood in minimum cost i first need to find the mid point(median of cut points) and there i should cut the wood and repeat this process again and again till the wood has no cut points left but i am having problem in solving the right wood obtained after cutting  </p>
<p>sample input:wood having cut with [1,3,5,9,16,22] would have minimum cost=163 when we first start with median 9 then we would have wood of mark[1,3,5,9] and [9,16,22] now first solving the left wood we would have [1,3,5][5,9],now again cutting we have [1,3][3,5][5,9] and the one which was left [9,16,22] now on operating this wood we have cut all the marks and the list would be [1,3][3,5][5,9][9,16][16,22] and the cost on this operation would be minimum</p>
<p>here is my code:</p>
<pre><code>for _ in range(int(input())):     #no of test cases 
a,b=map(int,input().split())      #multiplier element of cost ex: 3,4
n=int(input())                    #total number of cuts ex: 6
x=list(map(int,input().split()))  #where the cuts are the wood ex:
                                  #[1,3,5,9,16,22]

lis=[]
cost=0

average=sum(x)/len(x)
median=min(x,key=lambda X:abs(X-average))  #calculated the median 

cost+=a*(median-x[0])+b*(x[-1]-median)  #calculated the cost of cutting 
print(cost)
var=x.index(median)                      #found the index of median
x_left=x[:var+1]                         #split the wood in left and right
x_right=x[var:]
lis.append(x_right)
while(len(x_left)&gt;2):       #done the same process going first on left wood    

    average=sum(x_left)/len(x_left)
    median=min(x_left,key=lambda X:abs(X-average))
    cost+=a*(median-x_left[0])+b*(x_left[-1]-median)
    var=x.index(median)
    x_left=x_left[:var+1]
    x_right=x_left[var:] #this wood would again have right component so 
                         #stored that right side in list named lis
    lis.append(x_right)
print(cost)             #fully solved by moving leftwards
print(lis)
tt=len(lis)
for i in lis:           #but the problem start here i have all the right 
                        #pieces of wood that i had stored in lis but now i 
                        #can't evaluate them
    if(len(i)&lt;3):
        lis.pop(lis.index(i))


    else:
        continue
print(lis)
while(tt!=0):
    xx=lis.pop(0)
    ttt=len(xx)
    if(ttt&gt;2):
        average=sum(xx)/ttt
        median=min(xx,key=lambda X:abs(X-average))
        cost+=a*(median-xx[0])+b*(xx[-1]-median)
        var=x.index(median)
        x_left=xx[:var+1]
        x_right=xx[var:]
        if(len(x_left)&gt;2):
            lis.append(x_left)
        if(len(x_right)&gt;2):
            lis.append(x_right)
print(cost)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, here's a recursive generator <code>solve_gen</code> that checks all the possible cutting sequences and then chooses the minimum one. Although the code is compact, and it runs ok if the number of marks is small, it soon gets rather inefficient as the number of marks increases. I've also included a function <code>apply_cuts</code> that applies a sequence of cuts to a mark sequence, so you can see the cuts happening in that order.</p>
<p><code>solve_gen</code> uses a global <code>count</code> to keep track of the number of recursive calls that get made. <code>count</code> isn't necessary for the operation of the algorithm, but it gives us an indication of how much work the function is doing.</p>
<pre><code>def cost(seq, m):
    return (seq[-1] - seq[0]) * m

def solve_gen(seq):
    global count
    count += 1
    if len(seq) == 2:
        yield 0, ()
        return
    for i in range(1, len(seq)-1):
        left, x, right = seq[:i+1], seq[i], seq[i:]
        val = cost(left, a) + cost(right, b)
        for lval, lcuts in solve_gen(left):
            for rval, rcuts in solve_gen(right):
                yield (val + lval + rval, (x,) + lcuts + rcuts)

def apply_cuts(seq, cuts):
    total = 0
    old = [seq]
    for x in cuts:
        new = []
        for u in old:
            if x in u:
                i = u.index(x)
                left, right = u[:i+1], u[i:]
                val = cost(left, a) + cost(right, b)
                new.extend((left, right))
            else:
                new.append(u)
        print(x, new, val)
        total += val
        old = new[:]
    return total

# Test

# Recursion counter
count = 0

a, b = 3, 4
seq = (1, 3, 5, 9, 16, 22)
print(seq)

results = list(solve_gen(seq))
val, cuts = min(results)
print('Cost: {}, Cuts: {}'.format(val, cuts))
print('Results length: {}, Count: {}'.format(len(results), count))

print('\nCutting sequence')
print(apply_cuts(seq, cuts))
</code></pre>
<p><strong>output</strong></p>
<pre><code>(1, 3, 5, 9, 16, 22)
Cost: 163, Cuts: (9, 5, 3, 16)
Results length: 14, Count: 90

Cutting sequence
9 [(1, 3, 5, 9), (9, 16, 22)] 76
5 [(1, 3, 5), (5, 9), (9, 16, 22)] 28
3 [(1, 3), (3, 5), (5, 9), (9, 16, 22)] 14
16 [(1, 3), (3, 5), (5, 9), (9, 16), (16, 22)] 45
163
</code></pre>
<p>FWIW, here are the results for the same <code>a</code> &amp; <code>b</code> with a longer mark sequence.</p>
<pre><code>(1, 3, 5, 9, 16, 22, 31, 33, 35, 39, 46)
Cost: 497, Cuts: (31, 16, 9, 5, 3, 22, 39, 35, 33)
Results length: 4862, Count: 41990
</code></pre>
<hr/>
<p>We can make this more efficient by finding the minima at each stage of the recursion, rather than finding the minimum of all the possibilities. However, as the algorithm investigates the various cutting options it often repeats calculations that it's done before. So we can make the code much more efficient by using caching, i.e, we store previous results in a dictionary, so if we ever need to make the same cut again we can just look it up in the cache instead of recalculating it. </p>
<p>We could code our own cache, but the <code>functools</code> module provides <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>lru_cache</code></a> which can be used as a decorator. We can also give the <code>cost</code> function a cache, although its calculations are fairly simple, so caching probably doesn't save much time there. A nice feature of <code>lru_cache</code> is that it can also provide cache statistics, which lets us know how useful the cache is.</p>
<pre><code>from functools import lru_cache

@lru_cache(None)
def cost(seq, m):
    return (seq[-1] - seq[0]) * m

@lru_cache(None)
def solve(seq):
    global count
    count += 1
    if len(seq) == 2:
        return 0, ()
    results = []
    for i in range(1, len(seq)-1):
        left, x, right = seq[:i+1], seq[i], seq[i:]
        val = cost(left, a) + cost(right, b)
        lval, lcuts = solve(left)
        rval, rcuts = solve(right)
        results.append((val + lval + rval, (x,) + lcuts + rcuts))
    return min(results)

# Test

# Recursion counter
count = 0

a, b = 3, 4
seq = (1, 3, 5, 9, 16, 22)
print(seq)

val, cuts = solve(seq)
print('Cost: {}, Cuts: {}'.format(val, cuts))
print('Count: {}\n'.format(count))

print('cost cache', cost.cache_info())
print('solve cache', solve.cache_info())
</code></pre>
<p><strong>output</strong></p>
<pre><code>(1, 3, 5, 9, 16, 22)
Cost: 163, Cuts: (9, 5, 3, 16)
Count: 15

cost cache CacheInfo(hits=20, misses=20, maxsize=None, currsize=20)
solve cache CacheInfo(hits=26, misses=15, maxsize=None, currsize=15)
</code></pre>
<p>Fortunately, we get the same results as before. ;) Notice that the recursion count is now much lower. Let's try it with that longer mark sequence.</p>
<pre><code>(1, 3, 5, 9, 16, 22, 31, 33, 35, 39, 46)
Cost: 497, Cuts: (31, 16, 9, 5, 3, 22, 39, 35, 33)
Count: 55

cost cache CacheInfo(hits=240, misses=90, maxsize=None, currsize=90)
solve cache CacheInfo(hits=276, misses=55, maxsize=None, currsize=55)
</code></pre>
<p>The recursion count is a mere 55 compared to the previous 41990; a significant reduction. And we can see that the caches are being well-used.</p>
<hr/>
<p>FWIW, the number of all the possible cutting sequences is given by the <a href="https://en.wikipedia.org/wiki/Catalan_number" rel="nofollow noreferrer">Catalan numbers</a> which often crop up in combinatorial problems.</p>
</div>
<div class="post-text" itemprop="text">
<p>This question requires functions and recursion.  What you want is something like this:</p>
<pre><code>function total_cost(a, b, marks):
    # Do something clever here
</code></pre>
<p>Now you have less than 3 marks, the problem is easy.  No cuts are needed and the cost is 0.</p>
<pre><code>function total_cost(a, b, marks):
    if len(marks) &lt; 3:
        return 0
    else
        # Do something clever here
</code></pre>
<p>If you have more than 2 marks, the cost of cutting at any particular place is the cost of cutting there, plus the cost of cutting the rest.  The cost of cutting is therefore the min or those costs.  That should be enough to fill in the something clever.</p>
<p>This solution will run slowly with many cuts.  To solve that problem, you should look up "memoization".</p>
</div>
<span class="comment-copy">Is this question from a coding contest? Can you please provide a link to the original question?</span>
<span class="comment-copy">Your code is rather messy, and it's not correctly indented at the start. However, it would be better to replace the starting section that reads the data from <code>input</code> with hard-coded data, it's annoying to enter data at the <code>input</code> prompt when you're trying to develop code. You could make your code less messy and reduce the repetition by using functions. Why do you think that cutting at the median will work? It might in some cases, but it doesn't in general. The cutting-point calculation <i>needs</i> to take <code>a</code> and <code>b</code> into account.</span>
<span class="comment-copy">@PM2Ring because if a wood is cut along one side of the end the remaining would have large size and cost would be more.suppose if i had a wood of length 20 and marks on it [1,3,5,7,10,15,17,20] now  suppose i have same a and b then the best way i can reduce the cost is to chose 10 because difference from left end and right end would be the same,if i would have cut the 15 mark although the cost of cutting at first would be same then the remaining would cost would have gone higher.</span>
<span class="comment-copy">@PM2Ring Yeah I know it also depends on a and b but at first i am thinking to solve this problem while considering a and b to be same and then applying an if condition afterwards. This problem is from google interview questions available on carrercup.</span>
<span class="comment-copy">My <code>apply_cuts</code> function is handy for testing theories like that. Given <code>a,b=3,4</code> and <code>seq = (1, 3, 5, 7, 10, 15, 17, 20)</code>, <code>cuts=(10, 5, 3, 7, 15, 17)</code> is a minimal solution with a cost of 180. If we swap a &amp; b, that same <code>cuts</code> will give a minimal solution, but if we change <code>a, b = 2, 5</code> then a minimal solution is <code>(15, 10, 7, 5, 3, 17)</code> with a cost of 174, but if we apply the previous cuts instead the cost goes up to 188.</span>
<span class="comment-copy">Thank you so much! All of my three questions have been answered by you.You're a lifesaver :)</span>
<span class="comment-copy">@Demonking28 My pleasure! You're lucky that I like combinatorial problems. ;)</span>
<span class="comment-copy">def cost(seq, m):     return (seq[-1] - seq[0]) * m what is 'm' here?</span>
<span class="comment-copy">@uitwaa <code>m</code> is the cost <b>m</b>ultiplier, so to get the cost of a left piece we pass <code>a</code> as the <code>m</code> argument, and for a right piece we pass <code>b</code> as the <code>m</code> argument.</span>
<span class="comment-copy">@PM2Ring could you please have a look :<a href="https://stackoverflow.com/questions/47126987/optimization-of-lists-sublist" title="optimization of lists sublist">stackoverflow.com/questions/47126987/â€¦</a></span>
