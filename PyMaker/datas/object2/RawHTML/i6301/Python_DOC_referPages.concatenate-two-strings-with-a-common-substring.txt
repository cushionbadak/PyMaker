<div class="post-text" itemprop="text">
<p>Say I have strings,</p>
<pre><code>string1 = 'Hello how are you'
string2 = 'are you doing now?'
</code></pre>
<p>The result should be something like</p>
<pre><code>Hello how are you doing now?
</code></pre>
<p>I was thinking different ways using <code>re</code> and string search.
(<a href="http://en.wikipedia.org/wiki/Longest_common_substring_problem" rel="nofollow noreferrer">Longest common substring problem</a>)  </p>
<p>But is there any simple way (or library) that does this in python?  </p>
<p>To make things clear i'll add one more set of test strings!</p>
<pre><code>string1 = 'This is a nice ACADEMY'
string2 = 'DEMY you know!'
</code></pre>
<p>the result would be!,</p>
<pre><code>'This is a nice ACADEMY you know!'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should do:</p>
<pre><code>string1 = 'Hello how are you'
string2 = 'are you doing now?'
i = 0
while not string2.startswith(string1[i:]):
    i += 1

sFinal = string1[:i] + string2
</code></pre>
<p><strong>OUTPUT :</strong></p>
<pre><code>&gt;&gt;&gt; sFinal
'Hello how are you doing now?'
</code></pre>
<p>or, make it a function so that you can use it again without rewriting:</p>
<pre><code>def merge(s1, s2):
    i = 0
    while not s2.startswith(s1[i:]):
        i += 1
    return s1[:i] + s2
</code></pre>
<p><strong>OUTPUT :</strong></p>
<pre><code>&gt;&gt;&gt; merge('Hello how are you', 'are you doing now?')
'Hello how are you doing now?'
&gt;&gt;&gt; merge("This is a nice ACADEMY", "DEMY you know!")
'This is a nice ACADEMY you know!'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should do what you want:</p>
<pre><code>def overlap_concat(s1, s2):
    l = min(len(s1), len(s2))
    for i in range(l, 0, -1):
        if s1.endswith(s2[:i]):
            return s1 + s2[i:]
    return s1 + s2
</code></pre>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt; overlap_concat("Hello how are you", "are you doing now?")
'Hello how are you doing now?'
&gt;&gt;&gt; 

&gt;&gt;&gt; overlap_concat("This is a nice ACADEMY", "DEMY you know!")
'This is a nice ACADEMY you know!'
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>str.endswith</code> and <code>enumerate</code>:</p>
<pre><code>def overlap(string1, string2):
    for i, s in enumerate(string2, 1):
         if string1.endswith(string2[:i]):
            break

    return string1 + string2[i:]
</code></pre>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; overlap("Hello how are you", "are you doing now?")
'Hello how are you doing now?'

&gt;&gt;&gt; overlap("This is a nice ACADEMY", "DEMY you know!")
'This is a nice ACADEMY you know!'
</code></pre>
<p>If you were to account for trailing special characters, you'd be wanting to employ some <code>re</code> based substitution.</p>
<pre><code>import re
string1 = re.sub('[^\w\s]', '', string1)
</code></pre>
<p>Although note that this would remove all special characters in the first string.</p>
<hr/>
<p>A modification to the above function which will find the longest matching substring (instead of the shortest) involves traversing <code>string2</code> in reverse.</p>
<pre><code>def overlap(string1, string2):
   for i in range(len(s)):
      if string1.endswith(string2[:len(string2) - i]):
          break

   return string1 + string2[len(string2) - i:]
</code></pre>
<pre><code>&gt;&gt;&gt; overlap('Where did', 'did you go?') 
'Where did you go?'</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Other answers were great guys but it did fail for this input.</p>
<pre><code>string1 = 'THE ACADEMY has'
string2= '.CADEMY has taken'
</code></pre>
<p>output:</p>
<pre><code>&gt;&gt;&gt; merge(string1,string2)
'THE ACADEMY has.CADEMY has taken'
&gt;&gt;&gt; overlap(string1,string2)
'THE ACADEMY has'
</code></pre>
<p>However there's this standard library <a href="https://docs.python.org/3/library/difflib.html#difflib.SequenceMatcher.find_longest_match" rel="nofollow noreferrer"><code>difflib</code></a> which proved to be effective in my case!</p>
<pre><code>match = SequenceMatcher(None, string1,\
                        string2).find_longest_match\
                        (0, len(string1), 0, len(string2))

print(match)  # -&gt; Match(a=0, b=15, size=9)
print(string1[: match.a + match.size]+string2[match.b + match.size:]) 
</code></pre>
<p>output:</p>
<pre><code>Match(a=5, b=1, size=10)
THE ACADEMY has taken
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>which words you want to replace are appearing in the second string so you can try something like :</p>
<pre><code>new_string=[string2.split()]
new=[]
new1=[j for item in new_string for j in item if j not in string1]
new1.insert(0,string1)
print(" ".join(new1))
</code></pre>
<p>with the first test case:</p>
<pre><code>string1 = 'Hello how are you'
string2 = 'are you doing now?'
</code></pre>
<p>output:</p>
<pre><code>Hello how are you doing now?
</code></pre>
<p>second test case:</p>
<pre><code>string1 = 'This is a nice ACADEMY'
string2 = 'DEMY you know!'
</code></pre>
<p>output:</p>
<pre><code>This is a nice ACADEMY you know!
</code></pre>
<blockquote>
<p>Explanation :</p>
</blockquote>
<p>first, we are splitting the second string so we can find which words we have to remove or replace :</p>
<pre><code>new_string=[string2.split()]
</code></pre>
<p>second step we will check each word of this splitter string with string1 , if any word is in that string than choose only first string word , leave that word in second string :</p>
<pre><code>new1=[j for item in new_string for j in item if j not in string1]
</code></pre>
<p>This list comprehension is same as :</p>
<pre><code>new1=[]
for item in new_string:
    for j in item:
        if j not in string1:
            new1.append(j)
</code></pre>
<p>last step combines both string and join the list:</p>
<pre><code>new1.insert(0,string1)
print(" ".join(new1))
</code></pre>
</div>
<span class="comment-copy">what should be the result if <code>string1 = 'Hello how are you now?'</code> ? (<code>now?</code> added)</span>
<span class="comment-copy">got your question now!. that won't be a case actually.</span>
<span class="comment-copy">the result can be <code>'Hello how are you now are you doing now'</code>. Although a string like this won't come most likely!</span>
<span class="comment-copy">Although if the result  is <code>'Hello how are you doing now'</code> would be GREAT even with <code>now?</code> added</span>
<span class="comment-copy"><i>with now? added</i> - but <code>now?</code> is common in that case</span>
<span class="comment-copy">@TomKarzes Saying "it doesn't work" is a bit much, seeing as this can just be fixed by reversing the string before iteration. I'll leave that up to OP, because they have never specified anything of the sort (actually, OP doesn't really know what they want).</span>
<span class="comment-copy">This doesn't work. It finds the smallest non-empty overlap, rather than the largest. For example, for overlap('Where did', 'did you go?') it gives 'Where didid you go?', rather than the desired 'Where did you go?'. It needs to start with the longest possible overlap, not the smallest.</span>
<span class="comment-copy">@TomKarzes Yes, I saw your comment previously, see my reply above.</span>
<span class="comment-copy">Sorry, I deleted my original comment and provided a much more clear-cut example of how this version fails.  If the last character of the first string is the same as first first character of the second string, it will only find a one-character overlap.  I think it's clear that isn't what;s desired.</span>
<span class="comment-copy">@TomKarzes Really that's a special case, and like I mentioned, the fix is simple. Saying "it doesn't work" really is a little unfair.</span>
<span class="comment-copy">your matching rules are somehow arbitrary. <code>ACADEMY</code> overlaps only <code>CADEMY</code> on <code>.CADEMY</code> string so the dot <code>.</code> should remain. I'm sure there could be cases when your <code>SequenceMatcher</code> will also fail</span>
<span class="comment-copy">Here is one fail case using your approach: <code>import difflib  string1 = 'This is a nice ACADEMY' string2 = 'DEMY you know! nice'  match = difflib.SequenceMatcher(None, string1, string2).find_longest_match(0, len(string1), 0, len(string2)) print(string1[: match.a + match.size]+string2[match.b + match.size:])</code> . The output will be: <code>This is a nice</code> .Is it correct? - NOPE</span>
<span class="comment-copy">voting to close the question as too broad</span>
<span class="comment-copy">It would be nice if you'd specify such requirements in your <i>question</i>.</span>
<span class="comment-copy">@RomanPerekhrest With you on that. Also, vishnu, please do not use version specific tags if your question does not pertain to any particular version - that tantamounts to tag spamming, so please do not do it again. I removed them for a reason.</span>
