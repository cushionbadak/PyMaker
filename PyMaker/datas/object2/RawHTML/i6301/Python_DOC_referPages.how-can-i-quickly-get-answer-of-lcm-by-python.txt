<div class="post-text" itemprop="text">
<pre><code>def getLCM(a, b):
    c, d = max(a, b), min(a, b)
    while c != d:
        temp = c - d
        c, d = max(temp, d), min(temp, d)

    return a * b // c


def nlcm(num):
    temp = 1
    while len(num) != 0:
        temp = getLCM(temp, num[-1])
        num.pop()
    return temp

print(nlcm([2,6,8,14,5]));
</code></pre>
<p>I need to "quickly" get answer this problem.
in test case, my code is very slow.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are existing <code>gcd</code> implementations in Python, and LCM is definable in terms of <code>gcd</code>, so you may as well avoid reinventing the wheel. Specifically:</p>
<blockquote>
<p>gcd(a, b) x lcm(a, b) = a x b</p>
</blockquote>
<p>With Python 3.5 and higher, there is an accelerated <code>gcd</code> function on the <code>math</code> module, so <code>lcm</code> can simplify to:</p>
<pre><code>from math import gcd

def getLCM(a, b):
    return a * b // gcd(a, b)
</code></pre>
<p>On older Python, it's not accelerated, but <code>fractions.gcd</code> is a decent implementation provided for you, so you can use it instead, or to use the best possible <code>gcd</code> on whatever version you run on, a nested import attempt works:</p>
<pre><code>try:
    from math import gcd
except ImportError:
    from fractions import gcd
</code></pre>
<p>Your <code>nlcm</code> loop could also be simplified: You don't need to destructively iterate manually, just loop:</p>
<pre><code>def nlcm(num):
    temp = 1
    for x in num:
        temp = getLCM(temp, x)
    return temp
</code></pre>
<p>Or if you want to get clever, use <code>reduce</code> (<code>functools.reduce</code> on Python 3.x) since it does exactly what that simplified loop is already doing:</p>
<pre><code>from functools import reduce

def nlcm(nums):
    return reduce(getLCM, nums, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming the "long execution" is not in the example you provided but rather with bigger inputs, you can add memoization and increate the time <code>getLCM()</code> is calculated in case it's called again with the same numbers:</p>
<pre><code>hash = dict() # we'll save here the calculated results

def getLCM(a, b):
    global hash
    if (a, b) in hash:  # if it was already calculated
        return hash[(a, b)]  # use the cached result
    c, d = max(a, b), min(a, b)
    while c != d:
        temp = c - d
        c, d = max(temp, d), min(temp, d)

    hash[(a, b)] = a * b // c. # cash the result
    return a * b // c
</code></pre>
</div>
<span class="comment-copy">Couldn't you find something else to do in that 0.023 seconds it took to run that program? Maybe grab a coffee or play with the kids :-)</span>
<span class="comment-copy">i am getting an answer instantaneously on my machine.. are you timing in milliseconds?</span>
<span class="comment-copy">Maybe number of num is large, my code is slow. So I need to get fast my code</span>
<span class="comment-copy">Thank you for your answer. thanks to you, I know about the 'reduce'. But in my study class, I can't use function 'gcd'.</span>
<span class="comment-copy">@전현근: Well, you can still use <code>fractions.gcd</code> as a better implementation, since <a href="https://github.com/python/cpython/blob/3.4/Lib/fractions.py#L17" rel="nofollow noreferrer">the code for it is pure Python</a> and can literally be copied; just make sure you understand it. ;-)</span>
<span class="comment-copy">Note: If you're on Python 3.2 or higher, <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a> can give you this caching behavior as a decorator on the original (uncached) function, avoiding the ugliness of mixing the caching logic with the computational logic.</span>
<span class="comment-copy">True, though you have to take into account that this caching is... LRU meaning, remembers only the most recently numbers. And since it's limited in size - you should ensure that it fits your application behavior.</span>
<span class="comment-copy">The name is slightly inaccurate. The <i>default</i> is LRU with a 128 entry bound, but it can be made infinite trivially (you just pass <code>None</code> as the <code>maxsize</code>). It runs faster that way too (no overhead dealing with cache eviction).</span>
<span class="comment-copy">@ShadowRanger thanks I wasn't aware of that!</span>
