<div class="post-text" itemprop="text">
<p><strong>Context</strong></p>
<p>I am trying to write tests for functions that query an external API. These functions send requests to the API, get responses and process them.
In my tests, I want to simulate the external API with a Mock server that is ran locally.
So far, the mock server is ran successfully and responds to custom GET queries.</p>
<p><strong>The problem</strong></p>
<p>The external API responds with objects of type <code>&lt;class 'dict'&gt;</code>, while apparently all I can get from my mock server is a response of type <code>&lt;class 'bytes'&gt;</code>. The mock server is fetching pre-defined data from disk and returning them through a stream. Since I can not simulate the external API, my tests throw error messages because of the wrong types of responses.</p>
<p>Following are snippets of my code with some explanations.</p>
<p><strong>1.</strong> <strong>setUp() function:</strong></p>
<p>The setUp function is ran at the beginning of the test suite. It is responsible of configuring and running the server before running the tests:</p>
<pre><code>def setUp(self):
    self.factory = APIRequestFactory()
    # Configuring the mock server
    self.mock_server_port = get_free_port()
    self.mock_server = HTTPServer(('localhost', self.mock_server_port), MockServerRequestHandler)
    # Run the mock server in a separate thread
    self.mock_server_thread = Thread(target=self.mock_server.serve_forever)
    self.mock_server_thread.setDaemon(True)
    self.mock_server_thread.start()
</code></pre>
<p><strong>2. The MockServerClassHandler:</strong></p>
<pre><code>class MockServerRequestHandler(BaseHTTPRequestHandler):
def do_GET(self):
    if re.search(config.SYSTEM_STATUS_PATTERN, self.path):
        # Response status code
        self.send_response(requests.codes.ok)
        # Response headers
        self.send_header("Content-Type", "application/json; charset=utf-8")
        self.end_headers()
        # Purge response from a file and serve it
        with open('/path/to/my-json-formatted-file') as data_file:
            response_content = json.dumps(json.load(data_file))

        # Writing to a stream that need bytes-like input
        # https://docs.python.org/2/library/basehttpserver.html
        self.wfile.write(response_content.encode('utf-8'))
        return
</code></pre>
<p>To my understanding from the <a href="https://docs.python.org/2/library/basehttpserver.html" rel="nofollow noreferrer">official documentation</a>, a <em>BaseHTTPRequestHandler</em> can only serve the content of his response through writing in a predefined stream (<code>wfile</code>) which needs to be given (and I am quoting an error message) a byte-like variable.</p>
<p>So my questions are:</p>
<ul>
<li>Is there a way to make my mock server respond with other types of content than bytes? (JSON, python dicts ...)</li>
<li>Is it safe to write, in the functions that I test, a piece of code that will convert the bytes variables to Python dicts, just so I can test them with my mock server? Or is this violating some principles of testing?</li>
<li>Is there another way of writing a server that responds with JSON and python dicts?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In the comments, it sounds like you solved your main problem, but you're interested in learning how to mock out the web requests instead of launching a dummy web server.</p>
<p>Here's <a href="https://realpython.com/blog/python/testing-third-party-apis-with-mocks/" rel="nofollow noreferrer">a tutorial</a> on mocking web API requests, and the gory details are in <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">the documentation</a>. If you're using legacy Python, you can install the <code>mock</code> module as a separate package from PyPI.</p>
<p>Here's a snippet from the tutorial:</p>
<pre><code>@patch('project.services.requests.get')
def test_getting_todos_when_response_is_ok(mock_get):
    todos = [{
        'userId': 1,
        'id': 1,
        'title': 'Make the bed',
        'completed': False
    }]

    # Configure the mock to return a response with an OK status code. Also, the mock should have
    # a `json()` method that returns a list of todos.
    mock_get.return_value = Mock(ok=True)
    mock_get.return_value.json.return_value = todos

    # Call the service, which will send a request to the server.
    response = get_todos()

    # If the request is sent successfully, then I expect a response to be returned.
    assert_list_equal(response.json(), todos)
</code></pre>
</div>
<span class="comment-copy"><i>"The external API responds with objects of type <code>&lt;class 'dict'&gt;</code>"</i> - that does not seem likely to be correct. Feasibly it sends a string containing a JSON representation of that dictionary (which would be a sequence of bytes...) Note that if you use <code>requests</code> there's a library named <code>responses</code> designed specifically to allow you to mock out HTTP calls.</span>
<span class="comment-copy">I have been facing this problem for uite some time, now that I wrote a question for it I realize how stupid I was: the literal API call in the function I am testing is wcapi.get("system_status").json()</span>
<span class="comment-copy">So it is converted to a JSON, and inspecting its type after the response reveals that IT IS a Python dict. I had no problem this whole time. Thank you for your response though</span>
<span class="comment-copy">Just adding to this: I would consider whether you need to actually stand up a separate mock server to do the testing. In a lot of cases, testing can be done faster and easier by using regular in-code mocks/patches. It's more parallelizable and can often be better at throwing different types of errors.</span>
<span class="comment-copy">@TAnas You could start with <a href="https://www.youtube.com/watch?v=smPbDqGjFAI" rel="nofollow noreferrer">my video</a> (shameless plug, but it's actually not that great). <a href="https://blog.fugue.co/2016-02-11-python-mocking-101.html" rel="nofollow noreferrer">This blog</a> has a good intro. Then Google.</span>
