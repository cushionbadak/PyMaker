<div class="post-text" itemprop="text">
<p>I have a base class A, inherited by classes B and C, from which I was trying to set an instance variable. Such variable is used by methods from base class A as follows.</p>
<pre><code>class A(object):
    def foo(self):
        print(self.value)

class B(A):
    value = "B"

class C(A):
    value = "C"

&gt;&gt;&gt; b = B()
'B'
&gt;&gt;&gt; c = C()
'C'
</code></pre>
<p>I understand function <code>foo</code> will only be evaluated during execution, which is fine as long as I do not invoke <code>foo</code> straight from an instance of <code>A</code>.
Yet, I fail to grasp how <code>value = "B"</code> and <code>value = "C"</code> <em>manage to become</em> <code>self.value = "B"</code> and <code>self.value = "C"</code>.</p>
<p>Sorry if this is naive question; I have been far from python for quite a while now, and really had not seen anything quite like it. I'm using Python version 2.7.12.</p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot add an instance variable to a base class in Python, because instance variables can only be added to instances, not classes.</p>
<p>In your example, "value" is a class variable.  In Python, when there is no instance variable with a given name, it falls back to the class variable with that name.  However, if you assigned a new value to b.value, that would create an instance variable on b.  B.value would be unaffected, as would any new instances of B.</p>
<p>I didn't find an authoritative reference for the behavior, but here's an article about it.   <a href="https://www.toptal.com/python/python-class-attributes-an-overly-thorough-guide" rel="nofollow noreferrer">https://www.toptal.com/python/python-class-attributes-an-overly-thorough-guide</a></p>
</div>
<span class="comment-copy">They are not instance variables, they are class-level variables being accessed from an instance.</span>
<span class="comment-copy">@juanpa.arrivillaga But should not this access happen through <code>value</code> instead of <code>self.value</code>? Why does <code>self.value</code> work?</span>
<span class="comment-copy">No. <code>value</code> is not defined in any scope. That would raise a <code>NameError</code>. You can use <code>MyClass.value</code> or <code>my_instance.value</code>, but just <code>value</code> will try to find a  local variable or a global variable. When a attribute on an instance is accessed, first it checks the namespace of the instance, if it isn't found, it checks the namespace of the class, and then all the classes in the MRO until the name is resolved or an <code>AttributeError</code> is raised. That's inheritance in a nutshell. See <a href="https://stackoverflow.com/questions/10313471/python-access-class-variables-via-instance">this question</a></span>
<span class="comment-copy">Ah, I really did not know that <i>when there is no instance variable with a given name, it falls back to the class variable with that name</i>. Would you suggest some reference, so I can better understand this default behavior definition? Thank you in advance.</span>
<span class="comment-copy">I didn't find an authoritative reference before my original post, so I didn't include one.  I've updated my answer to include an article.</span>
<span class="comment-copy">@Rubens all the details are in the <a href="https://docs.python.org/3/reference/datamodel.html#" rel="nofollow noreferrer">data model</a>, so for example this snippet: "Custom class types are typically created by class definitions (see section Class definitions). A class has a namespace implemented by a dictionary object. Class attribute references are translated to lookups in this dictionary, e.g., <code>C.x</code> is translated to <code>C.__dict__["x"]</code> (although there are a number of hooks which allow for other means of locating attributes). <b>When the attribute name is not found there, the attribute search continues in the base classes.</b>"</span>
