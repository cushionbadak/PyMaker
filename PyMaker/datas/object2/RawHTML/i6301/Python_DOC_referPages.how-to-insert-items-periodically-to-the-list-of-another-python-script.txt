<div class="post-text" itemprop="text">
<p>I have an issue updating the items of List L[] from another Python script file.
below are the two simple files that I have now,, any help/suggestion/advise will be highly appreciated.</p>
<p>script1.py</p>
<pre><code>import time, threading
L=[]
def first():
    if len(L)!=0:
       x = L.pop()
       print 'The element', x, 'left the list L'
    else:
         print 'L is empty now ...'
    threading.Timer(10, first).start()

first() 
</code></pre>
<p>script2.py</p>
<pre><code>from __main__ import *
import time
import script1
c = 1
def pass_arg():
    global c
    c+=1
    L.append(c)
    print 'will pass value to the list L of script1.py'
    threading.Timer(10, pass_arg).start()

pass_arg()
</code></pre>
<p>The issue that I face is that sript2 could not reach the defined list L of script1. Also, the script2 starts to follow all the running function/s of script1!?</p>
<p>Many thanks in advance,</p>
<p>After editing the previous code based on the recommendations, now I have the following scripts:</p>
<p>script1.py</p>
<pre><code>from __main__ import *
import time, threading

class ListHolder: 
  def __init__(self):
    self.L = [] 

  def first(self):
    if len(self.L)!=0:
       x = self.L .pop()
       print 'The element', x ,'left the list L'
    else:
        print 'L is empty now ...'
    threading.Timer(10, self.first).start()

R = ListHolder()
R.first()
</code></pre>
<p>script2.py</p>
<pre><code>from __main__ import *
import time, threading
from script1 import ListHolder

c = 1

X = ListHolder()

def pass_arg():
    global c
    c+=1
    X.L.append(c)
    print X.L
    print 'will pass value to the list L of script1.py'
    threading.Timer(10, pass_arg).start()

pass_arg()
</code></pre>
<p>The main issue now is that the new added items by script2.py are not passed to script1.py, hence the List in script1.py remains empty all the time and the change is not reflected on the script1 list. Any suggestions? </p>
</div>
<div class="post-text" itemprop="text">
<p>Python doesn't have true global variables, or at least they don't work the way you are using them. For what it's worth there a bunch of other answers on Stack Overflow like <a href="https://stackoverflow.com/questions/423379/using-global-variables-in-a-function-other-than-the-one-that-created-them">Using global variables in a function other than the one that created them</a> that have answers detailing how to get around the default behavior, but it's all kind of hacky and not <em>really</em> what Python wants you to do in most cases. </p>
<p>What you want to do is use a class here. </p>
<pre><code>class ListHolder: 
      self.L=[] 
</code></pre>
<p>Then you will be able to access ListHolder.L without there being any troubles. In the long run you don't want to use global vars anyway, so python is encouraging you to do the right thing here.</p>
<p>If you think that you have code that's self contained, and it should go in it's own file, a class or module is usually the right bet in Python. </p>
<p>Update in Response to OP's Update: 
First, let's go line by line through your scripts and make some comments. </p>
<p>We will start with script2.py </p>
<pre><code>from __main__ import * #Don't need this. 
import time, threading #We don't need threads to do this. 
from script1 import ListHolder #This EXECUTES code in script1.py 

c = 1 #fine

X = ListHolder() #Good 

def pass_arg():
    global c #not necessary 
    c+=1 #fine 
    X.L.append(c) #fine
    print X.L #fine 
    print 'will pass value to the list L of script1.py' #You already did that. 
    threading.Timer(10, pass_arg).start() #You don't need this. 
                                          #furthermore it will execute forever and
                                          #die when it blows the stack. 

pass_arg()  #this is fine 
</code></pre>
<p>Here is Script2.py </p>
<pre><code>from __main__ import * #this is not needed. 
import time, threading #We aren't using threads. Why import threads? 

class ListHolder: 
  def __init__(self):
    self.L = [] #This should be ok, but we could have also have initialized this 
                #in class scope rather than init. 

  def first(self):
    if len(self.L)!=0: 
       x = self.L .pop()
       print 'The element', x ,'left the list L'
    else:
        print 'L is empty now ...'
    threading.Timer(10, self.first).start() #This will execute forever. 

R = ListHolder() #as these are in "file" scope
R.first()  #they will execute when imported! 
</code></pre>
<p>So let's simplify this into a better format. </p>
<pre><code>Script2b.py
from script1b import ListHolder 

c = 1 #fine

X = ListHolder() #Good 

def pass_arg(z): #Functions need arguments. 
    z+=1 #we should use function scope vars 
         #instead of mutating global scope. 
    X.L.append(c) #fine
    print X.L #fine 
    return z #return locally mutated data
             #instead of mutating global scope. 

for x in range(1,10):
  c = pass_arg(c)  #this is fine 

  X.popMe()   
</code></pre>
<p>script1b.py</p>
<pre><code>class ListHolder: 
  def __init__(self):
    self.L = [] #This should be ok, but we could have also have initialized this 
                #in class scope rather than init. 

  def popMe(self):
    if len(self.L)!=0: 
       x = self.L .pop()
       print 'The element', x ,'left the list L'
    else:
        print 'L is empty now ...' 
</code></pre>
<p>Now since you kept trying to use threads, I suspect you are trying to do something a little different than what your post says. I <em>suspect</em> you are under the impression you can run both scripts <em>simultaneously</em> and communicate between the two scripts using the threading interface. </p>
<p>Not so! </p>
<p>A few points to consider: </p>
<p><strong>1) You have written one script with threads.</strong> </p>
<p>This will not result in parallel execution, and the scripts will not operate independent of one another. You are just yielding control between the scripts. Threading is best for asynchronous operations - it does not result in parallel execution or independent state. Think about situations like event handlers and callbacks. </p>
<p><strong>2) Python does not inherently support Parallelism Pe Se:</strong> </p>
<p>Python isn't a great choice for Parallel programming. You can use the "Process" class to kick off independent processes, and then manage them externally. However, "Process" doesn't understand the processes are Python programs, and you wont be able to directly influence their variables. The way you would do this is to run small processes, and return values for the central process to reason about. Think OpenGL shaders. </p>
<p><strong>3) You are not managing state between threads correctly.</strong> </p>
<p>The execution time of threads cannot be guaranteed. Your original script may work sometimes, and not work other times. You need to uses locks/mutexes to prevent data races. If you truly intend to use threads, you need to think hard about how you protect the data from dataraces. If you need help with that you should start a new question focusing on that. </p>
<p><strong>4) You almost certainly don't need threads.</strong> </p>
<p>Based on your level of programming knowledge, I am guessing you don't actually require threads for your task. Most times programmers should avoid using explicit threading until it is absolutely unavoidable. </p>
</div>
<span class="comment-copy">Good answer. One Typo ("ListHolder.L"), and probably one could mention the use of signals (<a href="https://docs.python.org/2/library/signal.html" rel="nofollow noreferrer">Python 2</a>, <a href="https://docs.python.org/3/library/signal.html" rel="nofollow noreferrer">Python 3</a>) as another elegant way to solve this problem.</span>
<span class="comment-copy">I'm not good with Python 2 but shouldn't it be <code>L = []</code> ranther than <code>self.L = []</code>. Also a <code>Queue</code> might be better than a list here.</span>
<span class="comment-copy">A queue might also work, I guess? And no, <code>self.L=[]</code> is correct / necessary when using a class to make the variable "visible" from outside as well as to see it in all functions inside the class.</span>
<span class="comment-copy">@orangeInk why do you think a queue would be better than a list here? He's using a list like a queue as it is.</span>
<span class="comment-copy">Thanks for the attention and contribution, but I tried creating a Class as mentioned, however, the List can not be updated from the script2 program, which means I could not pass the new items of List from script2 to script1. Any suggestions?</span>
