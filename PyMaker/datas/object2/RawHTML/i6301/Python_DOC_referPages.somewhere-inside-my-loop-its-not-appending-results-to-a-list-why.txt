<div class="post-text" itemprop="text">
<p>So I have two files/dictionaries I want to compare, using a binary search implementation (yes, this is very obviously homework).</p>
<p>One file is</p>
<p><strong>american-english</strong></p>
<pre><code>Amazon
Americana
Americanization
Civilization
</code></pre>
<p>And the other file is </p>
<p><strong>british-english</strong></p>
<pre><code>Amazon
Americana
Americanisation
Civilisation
</code></pre>
<p>The code below should be pretty straight forward. Import files, compare them, return differences. However, somewhere near the bottom, where it says <code>entry == found_difference:</code> I feel as if the debugger skips right over, even though I can see the two variables in memory being different, and I only get the final element returned in the end. Where am I going wrong?</p>
<pre><code># File importer
def wordfile_to_list(filename):
    """Converts a list of words to a Python list"""

    wordlist = []

    with open(filename) as f:
        for line in f:
            wordlist.append(line.rstrip("\n"))

    return wordlist

# Binary search algorithm
def binary_search(sorted_list, element):
    """Search for element in list using binary search. Assumes sorted list"""
    matches = []

    index_start = 0
    index_end = len(sorted_list)
    while (index_end - index_start) &gt; 0:
        index_current = (index_end - index_start) // 2 + index_start
        if element == sorted_list[index_current]:
            return True
        elif element &lt; sorted_list[index_current]:
            index_end = index_current
        elif element &gt; sorted_list[index_current]:
            index_start = index_current + 1
        return element


# Check file differences using the binary search algorithm
def wordfile_differences_binarysearch(file_1, file_2):
    """Finds the differences between two plaintext lists,
    using binary search algorithm, and returns them in a new list"""

    wordlist_1 = wordfile_to_list(file_1)
    wordlist_2 = wordfile_to_list(file_2)

    matches = []

    for entry in wordlist_1:
        found_difference = binary_search(sorted_list=wordlist_2, element=entry)
        if entry == found_difference:
            pass
    else:
        matches.append(found_difference)

    return matches


# Check if it works
differences = wordfile_differences_binarysearch(file_1="british-english", file_2="american-english")
print(differences)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't have an <code>else</code> suite for your <code>if</code> statement. Your <code>if</code> statement does nothing (it uses <code>pass</code> when the test is true, skipped otherwise).</p>
<p>You do have an <code>else</code> suite for the <code>for</code> loop:</p>
<pre><code>for entry in wordlist_1:
    # ...
else:
    matches.append(found_difference)
</code></pre>
<p>A <code>for</code> loop can have an <code>else</code> suite <em>as well</em>; it is executed when a loop completes without a <code>break</code> statement. So when your <code>for</code> loop completes, the current value for <code>found_difference</code> is appended; so whatever was assigned last to that name.</p>
<p>Fix your indentation if the <code>else</code> suite was meant to be part of the <code>if</code> test:</p>
<pre><code>for entry in wordlist_1:
    found_difference = binary_search(sorted_list=wordlist_2, element=entry)
    if entry == found_difference:
        pass
    else:
        matches.append(found_difference)
</code></pre>
<p>However, you shouldn't use a <code>pass</code> statement there, just invert the test:</p>
<pre><code>matches = []
for entry in wordlist_1:
    found_difference = binary_search(sorted_list=wordlist_2, element=entry)
    if entry != found_difference:
        matches.append(found_difference)
</code></pre>
<p>Note that the variable name <code>matches</code> feels off here; you are appending words that are missing in the other list, not words that match. Perhaps <code>missing</code> is a better variable name here.</p>
<p>Note that your <code>binary_search()</code> function always returns <code>element</code>, the word you searched on. That'll always be equal to the element you passed in, so you can't use that to detect if a word differed! You need to unindent that last <code>return</code> line and return <code>False</code> instead:</p>
<pre><code>def binary_search(sorted_list, element):
    """Search for element in list using binary search. Assumes sorted list"""
    matches = []

    index_start = 0
    index_end = len(sorted_list)
    while (index_end - index_start) &gt; 0:
        index_current = (index_end - index_start) // 2 + index_start
        if element == sorted_list[index_current]:
            return True
        elif element &lt; sorted_list[index_current]:
            index_end = index_current
        elif element &gt; sorted_list[index_current]:
            index_start = index_current + 1
    return False
</code></pre>
<p>Now you can use a list comprehension in your <code>wordfile_differences_binarysearch()</code> loop:</p>
<pre><code>[entry for entry in wordlist_1 if not binary_search(wordlist_2, entry)]
</code></pre>
<p>Last but not least, you don't have to re-invent the binary seach wheel, just use the <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code> module</a>:</p>
<pre><code>from bisect import bisect_left

def binary_search(sorted_list, element):
    return sorted_list[bisect(sorted_list, element)] == element
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>With sets</h1>
<p>Binary search is used to improve efficiency of an algorithm, and decrease complexity from <code>O(n)</code> to <code>O(log n)</code>.</p>
<p>Since the naive approach would be to check every word in <code>wordlist1</code> for every word in <code>wordlist2</code>, the complexity would be <code>O(n**2)</code>.</p>
<p>Using binary search would help to get <code>O(n * log n)</code>, which is already much better.</p>
<p>Using <a href="https://docs.python.org/2/library/sets.html" rel="nofollow noreferrer">sets</a>, you could get <code>O(n)</code>:</p>
<pre><code>american = """Amazon
Americana
Americanization
Civilization"""

british = """Amazon
Americana
Americanisation
Civilisation"""

american = {line.strip() for line in american.split("\n")}
british = {line.strip() for line in british.split("\n")}
</code></pre>
<p>You could get the american words not present in the british dictionary:</p>
<pre><code>print(american - british)
# {'Civilization', 'Americanization'}
</code></pre>
<p>You could get the british words not present in the american dictionary:</p>
<pre><code>print(british - american)
# {'Civilisation', 'Americanisation'}
</code></pre>
<p>You could get the union of the two last sets. I.e. words that are present in exactly one dictionary:</p>
<pre><code>print(american ^ british)
# {'Americanisation', 'Civilisation', 'Americanization', 'Civilization'}
</code></pre>
<p>This approach is faster and more concise than any binary search implementation. But if you really want to use it, as usual, you cannot go wrong with <a href="https://stackoverflow.com/a/46885272/6419007">@MartijnPieters' answer</a>.</p>
<h1>With two iterators</h1>
<p>Since you know the two lists are sorted, you could simply iterate in parallel over the two sorted lists and look for any difference:</p>
<pre><code>american = """Amazon
Americana
Americanism
Americanization
Civilization"""

british = """Amazon
Americana
Americanisation
Americanism
Civilisation"""

american = [line.strip() for line in american.split("\n")]
british = [line.strip() for line in british.split("\n")]

n1, n2 = len(american), len(british)
i, j = 0, 0

while True:
    try:
        w1 = american[i]
        w2 = british[j]
        if w1 == w2:
            i += 1
            j += 1
        elif w1 &lt; w2:
            print('%s is in american dict only' % w1)
            i += 1
        else:
            print('%s is in british dict only' % w2)
            j += 1
    except IndexError:
        break

for w1 in american[i:]:
    print('%s is in american dict only' % w1)

for w2 in british[j:]:
    print('%s is in british dict only' % w2)
</code></pre>
<p>It outputs:</p>
<pre><code>Americanisation is in british dict only
Americanization is in american dict only
Civilisation is in british dict only
Civilization is in american dict only
</code></pre>
<p>It's <code>O(n)</code> as well.</p>
</div>
<span class="comment-copy">Side notes: using bisection of one file against the other won't let you find the <i>symmetric</i> difference; you'll only find words in <code>wordlist_1</code> that are missing in <code>wordlist_2</code>. Using set operations would let you find the differences trivially (<code>return list(set(wordlist_1 ^ wordlist_2))</code>. I also note that your two examples are ordered and both contain the same words, only differing in spelling, so using <code>zip()</code> over both files would let you compare the paired up words in O(N) time. That's a different test however, and requires that there are no differences that affect the sort order.</span>
<span class="comment-copy">I know I wouldn't have to reinvent the wheel, but as this is homework, I'm expected to do so :)</span>
<span class="comment-copy">@komodovaran_: sure, but then you can use that existing implementation to validate your own, and see where you might have gone wrong. :-) The <a href="https://github.com/python/cpython/blob/3.6/Lib/bisect.py" rel="nofollow noreferrer">source code is available</a>.</span>
<span class="comment-copy">I actually messed it up myself, it seems. I had it with <code>return False</code>, but now I would only get <code>[True, True, False, False]</code>, but this doesn't tell me <i>which</i>  words, so I figured if I just returned the actual false elements only I could easily find them. It doesn't seem to work however..</span>
<span class="comment-copy">@komodovaran_: do not use <code>is False</code>. Use <code>if not found_difference:</code>.</span>
<span class="comment-copy">Many : <code>vimdiff /usr/share/dict/american-english /usr/share/dict/british-english</code> :D So for example : <code>['Americanising', 'Americanism']</code> and <code>['Americanism', 'Americanizing']</code>.</span>
<span class="comment-copy">It's better to use your version here as it illustrates how you'd use this with file data, but for future reference you can also use <code>amercan = set(american.splitlines())</code>; <code>str.splitlines()</code> with no arguments or <code>False</code> removes the line separators.</span>
