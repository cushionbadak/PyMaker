<div class="post-text" itemprop="text">
<p>I am trying to understand how class inheritance works in Python 3, in particular how private fields interact with local and inherited methods. Here are some examples to illustrate the issue.</p>
<p>First, if a variable <code>var</code> in the Superclass is public, then any method in the Subclass will also be able to alter it:</p>
<pre><code>class Superclass:
    var = 1
    def getVar(self):
        print(self.var)

class Subclass(Superclass):
    def __init__(self):
        self.var = 123

my_object = Subclass()
my_object.getVar() # outputs 123
</code></pre>
<p>The same is not true if the variable <code>__var</code> in the Superclass is private, any inherited method will ignore modifications done by the Subclass:</p>
<pre><code>class Superclass:
    __var = 1
    def getVar(self):
        print(self.__var)

class Subclass(Superclass):
    def __init__(self):
        self.__var = 123

my_object = Subclass()
my_object.getVar() # outputs 1!
</code></pre>
<p>Local methods in the Subclass can alter it:</p>
<pre><code>class Superclass:
    __var = 1

class Subclass(Superclass):
    def __init__(self):
        self.__var = 123
    def getVar(self):
        print(self.__var)

my_object = Subclass()
my_object.getVar() # outputs 123
</code></pre>
<p>But in order to use an inherited method with the altered value, I must use <code>self._Superclass__var</code> instead of <code>self.__var</code> in the Subclass:</p>
<pre><code>class Superclass:
    __var = 1
    def getVar(self):
        print(self.__var)

class Subclass(Superclass):
    def __init__(self):
        self._Superclass__var = 123

my_object = Subclass()
my_object.getVar() # outputs 123
</code></pre>
<p>Why is this the case? Are private fields not being inherited by the subclasses and therefore the variable <code>self.__var</code> inside the <code>Subclass</code> is NOT pointing to the same value the variable <code>self.__var</code> inside <code>Superclass</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python doesn't really have private variables, there are two conventions:</p>
<ul>
<li>Variables prefixed with underscore (<code>_var</code>) are used to let you and other people know that it's intended to be private</li>
<li>Variables prefixed with two undersores (<code>__var</code>) are also mangled by python interpreter and also are prefixed by class name, but they are still accessible like <code>self._Superclass__var</code> in your example</li>
</ul>
<p>See also the <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow noreferrer">documentation</a>.</p>
<p>There is one more issue in your code - you are using class variables, not instance variables (this is what usually called static class variables in other languages).</p>
<p>Check this example:</p>
<pre><code>class Superclass:
    var = 1

    def getVar(self):
        print(self.var)

my_object = Superclass()
my_object2 = Superclass()
my_object.getVar()  # outputs 1
my_object2.getVar()  # outputs 1

Superclass.var = 321  # this value is share across all instances
my_object.getVar()  # outputs 321
my_object2.getVar()  # outputs 321
</code></pre>
<p>And when you are doing <code>self.var = xxx</code> assignments in your methods, you just hide the class-level variable and add the new instance-level variable with same name.</p>
<p>See also the documentation: <a href="https://docs.python.org/3.6/tutorial/classes.html#class-and-instance-variables" rel="nofollow noreferrer">https://docs.python.org/3.6/tutorial/classes.html#class-and-instance-variables</a></p>
</div>
<span class="comment-copy">There are no private fields in Python. If you prefix an attribute name with <code>__</code> you invoke name mangling, where the name of the "owning" class is automatically inserted so as to help prevent attribute names from conflicting in subclasses. It doesn't prevent you from accessing it, it just requires that you include the owning class's name. See <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow noreferrer">docs.python.org/3/tutorial/classes.html#private-variables</a></span>
<span class="comment-copy">There <i>are no private fields</i> in Python. That is your fundamental misunderstanding. You are using double-underscore name-mangling, which it to prevent name-collisions in inherited classes, not to prevent access. As an aside, I hope you realize you are defining <i>class level variables</i>, equivalent to "static variables" in other languages, rather than instance variables.</span>
<span class="comment-copy">I think it worth addition this clarification as an answer as it is a good question for people coming with different background.</span>
<span class="comment-copy">thank you all for the comments and clarifications. If @kindall would post his comment as an answer, I would gladly accept it.</span>
<span class="comment-copy">Since the author of those comments did not write an answer that I could select, would you care to add that information to your answer above so I can select it? Because right now, as helpful as your answer is, it is not exactly addressing the issue I raised.</span>
<span class="comment-copy">@gilberto.agostinho.f OK, I updated the answer.</span>
