<div class="post-text" itemprop="text">
<p>I've noticed that the "&amp;&gt;" operator within a subprocess.Popen() call immediately provides a return code, even in scenarios where it intuitively shouldn't be. To illustrate:</p>
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; a = subprocess.Popen("sleep 5 &gt; a.txt", shell = True)
&gt;&gt;&gt; print(a.poll()) # immediately try printing
None
&gt;&gt;&gt; print(a.poll()) # wait 5 seconds
0
&gt;&gt;&gt; a = subprocess.Popen("sleep 5 &amp;&gt; a.txt", shell = True)
&gt;&gt;&gt; print(a.poll()) # immediately try printing
0
&gt;&gt;&gt; a = subprocess.Popen("sleep 5 &gt; a.txt 2&gt;&amp;1", shell = True) # this should be the same as using &amp;&gt;
&gt;&gt;&gt; print(a.poll()) # immediately try printing
None
&gt;&gt;&gt; print(a.poll()) # wait 5 seconds
0
</code></pre>
<p>I'm running this on Python 3.5.2. My machine runs bash by default. </p>
<p>Does anyone know why subprocess isn't supporting the correct "&amp;&gt;" behavior here?</p>
</div>
<div class="post-text" itemprop="text">
<p>That's because <code>&amp;&gt;</code> is a <em>bashism</em>, and <code>Popen</code> by default uses <code>/bin/sh</code> when <code>shell=True</code>.</p>
<p>From the <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="nofollow noreferrer"><code>subprocess.Popen</code> docs</a>:</p>
<blockquote>
<p>The <code>executable</code> argument specifies a replacement program to execute. It is very seldom needed. When <code>shell=False</code>, executable replaces the program to execute specified by args. However, the original args is still passed to the program. Most programs treat the program specified by args as the command name, which can then be different from the program actually executed. On POSIX, the args name becomes the display name for the executable in utilities such as ps. <strong>If <code>shell=True</code>, on POSIX the <code>executable</code> argument specifies a replacement shell for the default <code>/bin/sh</code>.</strong></p>
</blockquote>
<p>The fix is to specify the <code>executable</code> parameter explicitly, like:</p>
<pre><code>subprocess.Popen("sleep 5 &amp;&gt; a.txt", shell=True, executable='/bin/bash')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your default <em>login</em> shell is <code>bash</code>. <code>subprocess.Popen</code>, though, uses the system default shell <code>/bin/sh</code>, which does not recognize the <code>&amp;&gt;</code> operator. If you want to force it to use <code>bash</code>, use the <code>executable</code> option:</p>
<pre><code>a = subprocess.Popen("sleep 5 &amp;&gt; a.txt", shell=True, executable="/bin/bash")
</code></pre>
<p>Alternatively, you can handle the redirection yourself in Python:</p>
<pre><code>with open("a.txt", "w") as fh:
    a = subprocess.Popen(["sleep", "5"], stdout=fh, stderr=fh)
</code></pre>
</div>
<span class="comment-copy">Please follow <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="nofollow noreferrer">the manual</a> and call Popen with an array of args (the command-string splitted) instead of passing one string. Then if you still have issues - update the question. Good luck!</span>
<span class="comment-copy">Running <code>/bin/sh</code> has nothing to do with the system default. It's <a href="https://github.com/python/cpython/blob/master/Lib/subprocess.py#L1215" rel="nofollow noreferrer">hardcoded</a> in Python.</span>
<span class="comment-copy">For POSIX, yes, because <code>/bin/sh</code> is by definition the system shell.</span>
<span class="comment-copy">That may be so, but "Popen uses the system default shell /bin/sh" sounds like Popen actually detects <i>the system default shell</i>, and uses it, whereas it always uses <code>/bin/sh</code> (except on Android).</span>
<span class="comment-copy">In a buggy sense, it does detect the system shell. The problem is that it assumes that <code>sys.platform</code> is going to be either win32 or something else, and it assumes that "something else" will be POSIX-compatible.</span>
