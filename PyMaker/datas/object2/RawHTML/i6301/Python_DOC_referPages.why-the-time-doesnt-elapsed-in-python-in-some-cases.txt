<div class="post-text" itemprop="text">
<p>I run the following python code:</p>
<pre><code>&gt;&gt;&gt; time(),5==25/5,time()
(1508830844.2450676, True, 1508830844.2450676)
&gt;&gt;&gt;
</code></pre>
<p>It seems that the time doesn't elapsed, however using explicit sleep</p>
<pre><code>&gt;&gt;&gt; time(),sleep(1),time()
(1508830151.232, None, 1508830152.246)
&gt;&gt;&gt;
</code></pre>
<p>or using longer tasks</p>
<pre><code>&gt;&gt;&gt; time(),[xi for xi in range(1000000) if xi == 100000],time()
(1508830458.736, [100000], 1508830458.892)
&gt;&gt;&gt;
</code></pre>
<p>behaves as expected, the time has been elapsed.</p>
<p>What is the phenomenon? When I should expect positive result of difference of two time() stamp?
(Tested with python 2.7 and 3.5)</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, you are putting all expressions on the same line, with a an expression that has been constant folded; the division is not calculated between the <code>time()</code> calls:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(compile('time(),5==25/5,time()', '', 'single'))
  1           0 LOAD_NAME                0 (time)
              2 CALL_FUNCTION            0
              4 LOAD_CONST               0 (5)
              6 LOAD_CONST               3 (5.0)
              8 COMPARE_OP               2 (==)
             10 LOAD_NAME                0 (time)
             12 CALL_FUNCTION            0
             14 BUILD_TUPLE              3
             16 PRINT_EXPR
             18 LOAD_CONST               2 (None)
             20 RETURN_VALUE
</code></pre>
<p>Those <code>LOAD_CONST</code> calls and the <code>COMPARE_OP</code> take hardly any time at all.</p>
<p>Next, the <code>time()</code> clock probably doesn't have the resolution required to capture the short amount of time those 3 opcodes inbetween take. From the <a href="https://docs.python.org/3/library/time.html#time.time" rel="nofollow noreferrer"><code>time.time()</code> documentation</a>:</p>
<blockquote>
<p>Note that even though the time is always returned as a floating point number, not all systems provide time with a better precision than 1 second.</p>
</blockquote>
<p>Pick a <a href="https://docs.python.org/3/library/time.html#time.clock_getres" rel="nofollow noreferrer">higher-resolution clock</a>. Or you could use the <a href="https://docs.python.org/3/library/timeit.html#timeit.default_timer" rel="nofollow noreferrer"><code>timeit.default_timer()</code> callable</a>, which should be set to the highest-resolution timer for your platform:</p>
<pre><code>&gt;&gt;&gt; from timeit import default_timer
&gt;&gt;&gt; default_timer(), 5==25/5, default_timer()
(352821.948302353, True, 352821.948304896)
</code></pre>
<p>If you wanted to run time trials on snippets of Python code, to compare their performance, say, then you should be using the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code> module</a> anyway.</p>
</div>
<span class="comment-copy">"Return the time in seconds since the epoch as a floating point number. Note that even though the time is always returned as a floating point number, not all systems provide time with a better precision than 1 second" - From the official documentation on time. So, this could merely be a system issue.</span>
<span class="comment-copy">Try the <code>timeit</code> module.</span>
