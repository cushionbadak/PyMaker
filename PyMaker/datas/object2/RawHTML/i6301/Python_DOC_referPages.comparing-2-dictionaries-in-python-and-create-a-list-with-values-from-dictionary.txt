<div class="post-text" itemprop="text">
<p>I have 2 dictionaries.</p>
<pre><code>dict1={'Name':'','Age':'','Salary':''}
dict2={'Name':'John','Salary':'25k'}
</code></pre>
<p>Required output is a list where if the key is matching the matching key's value will be added to the list. If not matching, a space has to be populated to the list. For example, Age is not available in dict2 and hence the 2nd item in list should be space and the output order should not change. </p>
<pre><code>[John, ,25k]
</code></pre>
<p>So far i tried using a for loop to find matching keys, but not sure how to populate spaces for non-matching values and to maintain the order in dict1.</p>
<p>Any help would be highly appreciated. Thanks in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>You could just use a list comprehension to iterate the keys from <code>dict1</code> and <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><code>get</code></a> the corresponding value from <code>dict2</code> or <code>" "</code> as a default.</p>
<pre><code>&gt;&gt;&gt; dict1={'Name':'','Age':'','Salary':''}
&gt;&gt;&gt; dict2={'Name':'John','Salary':'25k'}
&gt;&gt;&gt; [dict2.get(key, " ") for key in dict1]
['John', '25k', ' ']
</code></pre>
<p>Note: Using Python 3.5 here, so <code>dict1</code>'s order gets messed up. Using <code>OrderedDict</code>:</p>
<pre><code>&gt;&gt;&gt; dict1 = collections.OrderedDict([('Name',''),('Age',''),('Salary','')])
&gt;&gt;&gt; [dict2.get(key, " ") for key in dict1]
['John', ' ', '25k']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>dict1={'Name':'','Age':'','Salary':''}
dict2={'Name':'John','Salary':'25k'}
result = []
common = dict1.keys() &amp; dict2
result = [dict1[k] or dict2[k] for k in common]
result.extend(' ' for k in set(dict1.keys()) - common)
result.extend(' ' for k in set(dict2.keys()) - common)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This code gives us common and uncommon keys between these two dictionaries. You can use them as you want. </p>
<pre><code>dict1= {'Name':'','Age':'','Salary':''}
dict2= {'Name':'John','Salary':'25k'}

common_keys = set(dict1.keys()).intersection(dict2.keys())
un_common_keys = set(dict1.keys()).symmetric_difference(dict2.keys())

print(common_keys) # {'Name', 'Salary'}

print(un_common_keys) # {'Age'}
</code></pre>
<p>For your specific case, you can use one for loop:</p>
<pre><code>all_keys = common_keys.union(un_common_keys)

final_list = []
for key in all_keys:
    if key in common_keys:
        final_list.append(dict2[key])
    else:
        final_list.append(" ")

print(final_list)
</code></pre>
<p>output: </p>
<pre><code>[' ', '25k', 'John']
</code></pre>
<p>If the order is important to you, then you have to use ordered dictionary as mentioned by @tobias_k. </p>
<p>(Using Python 3.5)</p>
</div>
<span class="comment-copy">dictionary keys have no order, unless you're using python 3.6</span>
<span class="comment-copy">Yes..I am using python 3.6</span>
<span class="comment-copy">Even in Python 3.6 the fact that plain dictionaries retain insertion order is an implementation detail that we shouldn't rely on (although that will probably change in some future version). So if you need keys to be in a specific order you need to use an OrderedDict from the collections module. Or you could have a separate list (or tuple) of keys that your code uses to get the correct order.</span>
<span class="comment-copy">Worked Perfectly. Thank you so much.</span>
<span class="comment-copy"><code>common = dict1.keys() &amp; dict2</code> is fine here... (unless we're being 2.x compatible)</span>
<span class="comment-copy">@JonClements thanks, haven't thought about this! Python 2 still complains "TypeError: unsupported operand type(s) for &amp;: 'set' and 'list'", (but OP says 3.6, so I'm changing it).</span>
<span class="comment-copy">Thank you. Since I am using 3.6, the order was not maintained. Let me try with Ordered dictionary and see if it works. Thanks</span>
<span class="comment-copy">Thank you.. Order is important for my scenario and it did work after using ordered dictionary.. Thanks</span>
