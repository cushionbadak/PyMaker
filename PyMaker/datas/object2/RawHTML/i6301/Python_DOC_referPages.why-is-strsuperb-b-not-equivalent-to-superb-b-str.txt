<div class="post-text" itemprop="text">
<ul>
<li><p>Assume <code>A</code> is the parent class of <code>B</code> and <code>b</code> is an instance of <code>B</code>. Then an overriden method of <code>A</code> can be called with <a href="https://docs.python.org/3/library/functions.html#super" rel="noreferrer">super</a>: <code>super(B, b).method()</code>.</p></li>
<li><p>The docs state <a href="https://docs.python.org/3/library/stdtypes.html#str" rel="noreferrer">"<code>str(object)</code> returns <code>object.__str__()</code>"</a> in its basic invocation.</p></li>
</ul>
<p>It should follow that <code>str(super(B, b)) == super(B, b).__str__()</code>, but that's not the case (<a href="https://repl.it/NIfH/2" rel="noreferrer">interactive version</a>):</p>
<pre><code>class A:
    def __str__(self):
        return "A"


class B(A):
    def __str__(self):
        return "B"


b = B()   
b_super = super(B, b) 
print(str(b_super))       # "&lt;super: &lt;class 'B'&gt;, &lt;B object&gt;&gt;"
print(b_super.__str__())  # "A"
</code></pre>
<p>So where did I go wrong? Does the super mechanism not work for magic methods? Does <code>str</code> not invoke <code>__str__</code> in this case? Is it related to this paragraph:</p>
<blockquote>
<p>Note that <code>super()</code> is implemented as part of the binding process for explicit dotted attribute lookups such as <code>super().__getitem__(name)</code>. It does so by implementing its own <code>__getattribute__()</code> method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, <code>super()</code> is undefined for implicit lookups using statements or operators such as <code>super()[name]</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><code>str()</code> doesn't look up the <code>__str__</code> method through the normal attribute lookup procedure. Instead, it performs a direct search for the <code>__str__</code> method in the <code>__dict__</code>s of its argument's class hierarchy, in <a href="https://www.python.org/download/releases/2.3/mro/" rel="nofollow noreferrer">MRO</a> order. This finds <code>super.__str__</code>, which gives <code>"&lt;super: &lt;class 'B'&gt;, &lt;B object&gt;&gt;"</code>.</p>
<p>However, when you look up <code>b_super.__str__</code> manually, that goes through <code>super.__getattribute__</code>, the hook <code>super</code> uses to provide its special attribute lookup behavior. The lookup through <code>__getattribute__</code> will resolve to <code>A.__str__</code> and call that.</p>
<p>Consider this class, which illustrates the difference (I hope):</p>
<pre><code>class B(object):
    def __init__(self, other):
        self.other = other
    def __getattribute__(self, name):
        if name == 'other':
            return object.__getattribute__(self, 'other')
        elif name == '__str__':
            return getattr(self.other, name)
        else:
            return name
    def __str__(self):
        return 'fun'

&gt;&gt;&gt; str(B(1))   # calls B.__str__ because it doesn't invoke __getattribute__
'fun'
&gt;&gt;&gt; B(1).__str__()  # calls B.__getattribute__ to look up the __str__ method which returns (1).__str__
'1'
</code></pre>
<p>The problem in this case and likewise for <code>super</code> is that these are proxies that rely on <code>__getattribute__</code> to forward it. So any function or method that doesn't go through <code>__getattribute__</code> doesn't forward. And <code>str()</code> is such a function.</p>
<hr/>
<p>Just for completeness because it was mentioned in the comments and the other answer.</p>
<p><strong>But <code>str(x)</code> isn't equivalent to <code>type(x).__str__(x)</code></strong> because <code>str()</code> even avoids the normal attribute lookup procedure of the "function on the class". It only checks the <a href="https://docs.python.org/c-api/typeobj.html#c.PyTypeObject.tp_str" rel="nofollow noreferrer"><code>tp_str</code></a> (or if that's NULL the <a href="https://docs.python.org/c-api/typeobj.html#c.PyTypeObject.tp_repr" rel="nofollow noreferrer"><code>tp_repr</code></a>) slot of the class. So it doesn't even invoke <code>__getattribute__</code> of the metaclass, which <code>type(x).__str__(x)</code> would do:</p>
<pre><code>class A(type):
    def __getattribute__(self, name):
        print(name)
        if name == '__str__':
            return lambda self: 'A'
        else:
            return type.__getattribute__(self, name)

class B(metaclass=A):
    def __str__(self):
        return 'B'

&gt;&gt;&gt; b = B()
&gt;&gt;&gt; str(b)
'B'
&gt;&gt;&gt; type(b).__str__(b)
__str__
'A'
</code></pre>
<p>However in the absense of a metaclass it <em>might</em> be helpful to think of <code>str(x)</code> as equivalent to <code>type(x).__str__(x)</code>. But while (potentially) helpful it's not correct.</p>
</div>
<div class="post-text" itemprop="text">
<p>The docs are wrong.</p>
<p><code>str(x)</code> is <em>actually</em> equivalent to <code>type(x).__str__(x)</code>.</p>
<p>If you <code>print(type(b_super).__str__(b_super))</code>, you get the obvious result.</p>
<p>(even this might be oversimplified in the case of weird metaclasses)</p>
</div>
<span class="comment-copy">I believe it's because the <code>super</code> call returns <code>a proxy object that delegates method calls to a parent or sibling class of type</code>, which has its own <code>__str__</code>, not resolving to the 'A'</span>
<span class="comment-copy">Does this also apply to other built-in functions like that (e.g., next)? Can you point me to some docs that elaborate this?</span>
<span class="comment-copy">Also, I guess what I should have really asked: Is there a way around this? So I don't have to call super(B, b).__str__()?</span>
<span class="comment-copy">@tjanson Yes, several builtins bypass <code>__getattribute__</code> (see the note in the docs on <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code></a>). However there's no complete list, it's just mentioned that it does that for "performance reasons".</span>
<span class="comment-copy">@tjanson I don't know if there's a way around that. Probably but that won't be trivial because you have to monkey-patch the built-in <code>str</code> function or otherwise mess with the internals.</span>
<span class="comment-copy">@tjanson  Regarding a way around it: there is a patch <a href="https://bugs.python.org/file1027/abstract2.diff" rel="nofollow noreferrer">here</a> (from Raymond Hettinger) which provides that.  But it never got merged, Guido declared it was better just to document that dunder methods must be called explicitly when working with a <code>super</code> instance.  See <a href="https://bugs.python.org/issue805304" rel="nofollow noreferrer">issue805304</a> for the back and forth.</span>
<span class="comment-copy">Sorry, but <code>str(x)</code> <b>is not</b> equivalent to <code>type(x).__str__(x)</code>. I updated my answer to reflect that (would've been too long for a comment).</span>
