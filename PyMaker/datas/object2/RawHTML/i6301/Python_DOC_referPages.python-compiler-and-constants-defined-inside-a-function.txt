<div class="post-text" itemprop="text">
<p>Does the Python compiler recognize constants defined within a function, such that it only computes their values once regardless of how many times the function is subsequently called in the code?</p>
<p>For example,</p>
<pre><code>def f():
    x = [ 1, 2, 3, 4 ]
    # stuff

for i in range( 100 ):
    f()
</code></pre>
<p>Would <code>x</code> be recalculated the 100 times <code>f()</code> is called?</p>
<p>It is not always possible to define constants outside the function that uses them, and I'm curious if Python has got your back in these situations.</p>
</div>
<div class="post-text" itemprop="text">
<p>(Note that this applies to CPython, and may be different in other implementations)</p>
<p>Python code is parsed and compiled into bytecode. You can see the instructions used with the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> module.</p>
<pre><code>&gt;&gt;&gt; def f(x):
...     x = [1, 2, 3, 4]
&gt;&gt;&gt; dis.dis(f)
  2           0 LOAD_CONST               1 (1)
              2 LOAD_CONST               2 (2)
              4 LOAD_CONST               3 (3)
              6 LOAD_CONST               4 (4)
              8 BUILD_LIST               4
             10 STORE_FAST               0 (x)
             12 LOAD_CONST               0 (None)
             14 RETURN_VALUE

&gt;&gt;&gt; print(dis.Bytecode(f).info())
Name:              f
Filename:          &lt;stdin&gt;
Argument count:    1
Kw-only arguments: 0
Number of locals:  1
Stack size:        4
Flags:             OPTIMIZED, NEWLOCALS, NOFREE
Constants:
   0: None
   1: 1
   2: 2
   3: 3
   4: 4
Variable names:
   0: x
</code></pre>
<p>As you can see, integer literals are constants, but lists have to be built everytime.</p>
<p>This is a relatively fast operation (Probably even quicker than looking up a global, but the time is still negligible)</p>
<p>If you had a function <code>g</code> that used a tuple instead, it is loaded as a constant:</p>
<pre><code>&gt;&gt;&gt; def g(x):
...     x = (1, 2, 3, 4)
&gt;&gt;&gt; dis.dis(g)
  2           0 LOAD_CONST               5 ((1, 2, 3, 4))
              2 STORE_FAST               0 (x)
              4 LOAD_CONST               0 (None)
              6 RETURN_VALUE
&gt;&gt;&gt; print(dis.Bytecode(g).info())
Name:              g
Filename:          &lt;stdin&gt;
Argument count:    1
Kw-only arguments: 0
Number of locals:  1
Stack size:        4
Flags:             OPTIMIZED, NEWLOCALS, NOFREE
Constants:
   0: None
   1: 1
   2: 2
   3: 3
   4: 4
   5: (1, 2, 3, 4)
Variable names:
   0: x
</code></pre>
<p>But this seems like a case of premature optimisation.</p>
<p>The constants stored for a function can be found as <code>function.__code__.co_consts</code>.</p>
<pre><code>&gt;&gt;&gt; g.__code__.co_consts
(None, 1, 2, 3, 4, (1, 2, 3, 4))
</code></pre>
<hr/>
<p>The reason a new list has to be built every time is so that if the list is changed, it won't affect a list that is loaded everytime.</p>
<p>And the tuple optimisation goes away if it isn't a list of constants.</p>
<pre><code>&gt;&gt;&gt; def h(x):
...     x = (1, 2, 3, x)
&gt;&gt;&gt; dis.dis(h)
  2           0 LOAD_CONST               1 (1)
              2 LOAD_CONST               2 (2)
              4 LOAD_CONST               3 (3)
              6 LOAD_FAST                0 (x)
              8 BUILD_TUPLE              4
             10 STORE_FAST               0 (x)
             12 LOAD_CONST               0 (None)
             14 RETURN_VALUE
&gt;&gt;&gt; print(dis.Bytecode(h).info())
Name:              h
Filename:          &lt;stdin&gt;
Argument count:    1
Kw-only arguments: 0
Number of locals:  1
Stack size:        4
Flags:             OPTIMIZED, NEWLOCALS, NOFREE
Constants:
   0: None
   1: 1
   2: 2
   3: 3
Variable names:
   0: x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Short answer</strong>: for <strong>lists</strong>, it <strong>does not</strong>.</p>
<p>If we check the intermediate code after compilation with <code>dis</code>, we see:</p>
<pre><code>&gt;&gt;&gt; dis.dis(f)
  2           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (2)
              6 LOAD_CONST               3 (3)
              9 LOAD_CONST               4 (4)
<b>             12 BUILD_LIST               4</b>
             15 STORE_FAST               0 (x)
             18 LOAD_CONST               0 (None)
             21 RETURN_VALUE</code></pre>
<p>So as you can see the program first loads constants <code>1</code> to <code>4</code> and pushes these on the stack, and the constructs a list with these constants, so that means it constructs a list <strong>each time</strong>.</p>
<p>In case the <strong>list is not mutated</strong>, I propose to <strong>define the constant outside the function</strong>:</p>
<pre><code>some_constant = [1, 2, 3, 4]
def f():
    # use some_constant
    # ...
    pass
</code></pre>
</div>
<span class="comment-copy">Nothing is constant in Python... It is a hyperdynamic language. Even functions, classes and modules can later be patched.</span>
<span class="comment-copy">How would you define <code>x</code> as a constant in python? How would the compiler know that <code>x</code> isn't going to change (in your <code>#stuff</code> section for example)?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow noreferrer">Scopes and Namespaces</a> ... <a href="https://docs.python.org/3/reference/executionmodel.html#naming-and-binding" rel="nofollow noreferrer">Naming and Binding</a></span>
<span class="comment-copy">Note: Also as an implementation detail, <code>list</code>s of constants that are used in a manner that precludes mutation (directly iterated or containment checked without assigning to a named variable, e.g. <code>for x in [1,2,3]:</code> or <code>if x in [1,2,3]:</code>) are compile-time constants; the peephole optimizer replaces them with <code>tuple</code> constants (since, when it's impossible to mutate them and they're used in a few known patterns, a <code>list</code> and <code>tuple</code> behave identically, but the <code>tuple</code> is slightly more efficient to store and constant, making it safe).</span>
<span class="comment-copy">If it's not mutated, and you're not relying on a few <code>list</code> specific behaviors (e.g. equality comparison with another <code>list</code>), using a <code>tuple</code> of constant literals within the function would be faster and avoid scoping issues (avoids some other function/module messing with it by accident), since it can be stored fully constructed in the function's constant table. Each use becomes a simple <code>LOAD_CONST</code> (using the literal directly) or <code>LOAD_FAST</code> (if in a named local) which boil down to C array lookups, rather than a <code>LOAD_GLOBAL</code>, which is (at least) one <code>dict</code> lookup.</span>
<span class="comment-copy">@ShadowRanger: I know that, but a tuple is not a list and vice versa. If you later pass this list to a function that checks <code>isinstance(x, list)</code>, then for a list, it will fail. So we can not assume that it will have completely identical behavior.</span>
<span class="comment-copy">True, but 1. A function that's doing strict type checking like that is usually bad form and 2. The cases where it's not bad form are typically cases where it's mutating the <code>list</code>, so the global wouldn't be safe. You'd need to copy the global on entering the function (<code>x = some_constant[:]</code>) to avoid that risk. Fun alternative: Python 3.5's unpacking generalizations let you have your cake and eat it too. You could do <code>x = [*(1, 2, 3, 4)]</code>, which constructs the <code>list</code> by loading the constant <code>tuple</code>, then performing a single byte code <code>BUILD_LIST_UNPACK</code>.</span>
<span class="comment-copy">The generalized unpacking technique, for a four element <code>tuple</code>-&gt;<code>list</code> is no real improvement on the <code>list</code> literal, but for larger sequences unpacking is faster. They're both faster than slicing a global <code>list</code> to get a shallow copy for any reasonable size <code>list</code> (the slicing approach takes over 33% longer for four elements; slices are weirdly expensive here).</span>
