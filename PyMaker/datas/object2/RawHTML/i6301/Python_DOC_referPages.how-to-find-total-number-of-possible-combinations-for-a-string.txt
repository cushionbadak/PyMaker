<div class="post-text" itemprop="text">
<p>How to find total number of possible sub sequences  for  a string  that start with a particular character say 'a' and end with a particular character say <code>'b'</code> from a given string?</p>
<p>EXAMPLE:<br/>
for a string <code>'aabb'</code> if we want to know the count of how many sub sequences are possible if the sub-sequence must start from character<code>'a'</code> and end with character <code>'b'</code> then valid sub sequences can be from <code>(ab)</code> contributed by index <code>(0,2), (ab)</code> contributed by index <code>(0,3), (ab)</code> contributed by index <code>(1,2), (ab)</code> contributed by index <code>(1,3), (aab)</code> using index <code>(0,1,2) , (aab)</code> using index <code>(0,1,3) ,(abb)</code> using index<code>(0,2,3),(abb)</code> using index<code>(1,2,3)</code> and <code>aabb</code> itself
 so total is 9 .I can solve this for a string of small length but how to solve this for a large string where brute force doesn't work</p>
<blockquote>
<p>Note:We consider two sub strings to be different if they start or end
  at different indices of the given string.</p>
</blockquote>
<pre><code>def count(str,str1 ,str2 ):
l = len(str) 
count=0
for i in range(0, l+1):
    for j in range(i+1, l+1):
        if str[i] == str1 and str[j-1] == str2:
            count+=1
return count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Before I post my main code I'll try to explain how it works. Let the source string be 'a123b'. The valid subsequences consist of all the subsets of '123' prefixed with 'a' and suffixed with 'b'. The set of all subsets is called the <a href="https://en.wikipedia.org/wiki/Power_set" rel="nofollow noreferrer">powerset</a>, and the <code>itertools</code> docs have code showing how to produce the powerset using <code>combinations</code> in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">Itertools Recipes</a> section.</p>
<pre><code># Print all subsequences of '123', prefixed with 'a' and suffixed with 'b'
from itertools import combinations

src = '123'
for i in range(len(src) + 1):
    for s in combinations(src, i):
        print('a' + ''.join(s) + 'b')
</code></pre>
<p><strong>output</strong></p>
<pre><code>ab
a1b
a2b
a3b
a12b
a13b
a23b
a123b
</code></pre>
<p>Here's a brute-force solution which uses that recipe.</p>
<pre><code>from itertools import combinations

def count_bruteforce(src, targets):
    c0, c1 = targets
    count = 0
    for i in range(2, len(src) + 1):
        for t in combinations(src, i):
            if t[0] == c0 and t[-1] == c1:
                count += 1
    return count
</code></pre>
<hr/>
<p>It can be easily shown that <a href="https://en.wikipedia.org/wiki/Power_set#Properties" rel="nofollow noreferrer">the number of subsets of a set of <code>n</code> items is <code>2**n</code></a>. So rather than producing the subsets one by one we can speed up the process by using that formula, which is what my <code>count_fast</code> function does.</p>
<pre><code>from itertools import combinations

def count_bruteforce(src, targets):
    c0, c1 = targets
    count = 0
    for i in range(2, len(src) + 1):
        for t in combinations(src, i):
            if t[0] == c0 and t[-1] == c1:
                count += 1
    return count

def count_fast(src, targets):
    c0, c1 = targets
    # Find indices of the target chars
    idx = {c: [] for c in targets}
    for i, c in enumerate(src):
        if c in targets:
            idx[c].append(i)

    idx0, idx1 = idx[c0], idx[c1]
    count = 0
    for u in idx0:
        for v in idx1:
            if v &lt; u:
                continue
            # Calculate the number of valid subsequences
            # which start at u+1 and end at v-1. 
            n = v - u - 1
            count += 2 ** n
    return count

# Test

funcs = (
    count_bruteforce,
    count_fast,
)

targets = 'ab'

data = (
    'ab', 'aabb', 'a123b', 'aacbb', 'aabbb', 
    'zababcaabb', 'aabbaaabbb',
)

for src in data:
    print(src)
    for f in funcs:
        print(f.__name__, f(src, targets))
    print()
</code></pre>
<p><strong>output</strong></p>
<pre><code>ab
count_bruteforce 1
count_fast 1

aabb
count_bruteforce 9
count_fast 9

a123b
count_bruteforce 8
count_fast 8

aacbb
count_bruteforce 18
count_fast 18

aabbb
count_bruteforce 21
count_fast 21

zababcaabb
count_bruteforce 255
count_fast 255

aabbaaabbb
count_bruteforce 730
count_fast 730
</code></pre>
<p>There <em>may</em> be a way to make this even faster by starting the inner loop at the correct place rather than using <code>continue</code> to skip unwanted indices.</p>
</div>
<div class="post-text" itemprop="text">
<p>Easy, it should just be the number of letters to the power of two. I.e, <code>n^2</code></p>
<p>Python implementation would just be <code>n_substrings = n ** 2</code></p>
</div>
<span class="comment-copy">What value are you wanting at the end of this? Are you wanting the total number of substrings, all indexes of all the substrings, or actually all the substrings?</span>
<span class="comment-copy">@KlausD. tried brute force but that takes a hell lot of time</span>
<span class="comment-copy">@Polymer total number of  substrings</span>
<span class="comment-copy">@Polymer "we want to know the count of how many sub strings are possible"</span>
<span class="comment-copy">You need to show some relevant code, otherwise your question may get closed like <a href="https://stackoverflow.com/questions/46830743/find-valid-strings">this one</a> was.</span>
<span class="comment-copy">could you please have a look at this question:<a href="https://stackoverflow.com/questions/46987669/cutting-cost-algorithm-optimization" title="cutting cost algorithm optimization">stackoverflow.com/questions/46987669/â€¦</a></span>
<span class="comment-copy">I think you misunderstood the question,the substring has to start with a character say  'x' and end with a character say  'y' which will be taken as an input .</span>
