<div class="post-text" itemprop="text">
<p>I have an output string like this:</p>
<pre><code>read : io=131220KB, bw=14016KB/s, iops=3504, runt=  9362msec
</code></pre>
<p>And I want to just extract one of the numerical values for computation, say iops. I'm processing it like this:</p>
<pre><code>        if 'read ' in key:
            my_read_iops = value.split(",")[2].split("=")[1]
            result['test_details']['read'] = my_read_iops
</code></pre>
<p>But there are slight inconsistencies with some of the strings I'm reading in and my code is getting super complicated and verbose. So instead of manually counting the number of commas vs "=" chars, what's a better way to handle this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use regular expression <code>\s*</code> to handle inconsistent spacing, it matches zero or more whitespaces:</p>
<pre><code>import re
s = 'read : io=131220KB, bw=14016KB/s, iops=3504, runt=  9362msec'

for m in re.finditer(r'\s*(?P&lt;name&gt;\w*)\s*=\s*(?P&lt;value&gt;[\w/]*)\s*', s):
    print(m.group('name'), m.group('value'))
# io 131220KB
# bw 14016KB/s
# iops 3504
# runt 9362msec
</code></pre>
<p>Using <a href="https://docs.python.org/3/library/re.html#re.match.group" rel="nofollow noreferrer">group name</a>, you can construct pattern string from a list of column names and do it like:</p>
<pre><code>names = ['io', 'bw', 'iops', 'runt']
name_val_pat = r'\s*{name}\s*=\s*(?P&lt;{group_name}&gt;[\w/]*)\s*'
pattern = ','.join([name_val_pat.format(name=name, group_name=name) for name in names])
# '\s*io\s*=\s*(?P&lt;io&gt;[\w/]*)\s*,\s*bw\s*=\s*(?P&lt;bw&gt;[\w/]*)\s*,\s*iops\s*=\s*(?P&lt;iops&gt;[\w/]*)\s*,\s*runt\s*=\s*(?P&lt;runt&gt;[\w/]*)\s*'

match = re.search(pattern, s)
data_dict = {name: match.group(name) for name in names}
print(data_dict)
# {'io': '131220KB', 'bw': '14016KB/s', 'runt': '9362msec', 'iops': '3504'}
</code></pre>
<p>In this way, you only need to change <code>names</code> and keep the order correct.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I were you,I'd use regex(regular expression) as first choice. </p>
<pre><code>import re
s= "read : io=131220KB, bw=14016KB/s, iops=3504, runt=  9362msec"
re.search(r"iops=(\d+)",s).group(1)
</code></pre>
<p>By this python code, I find the string pattern that starts 'iops=' and continues number expression at least 1 digit.I extract the target string(3504) by using round bracket.
you can find more information about regex from</p>
<p><a href="https://docs.python.org/3.6/library/re.html#module-re" rel="nofollow noreferrer">https://docs.python.org/3.6/library/re.html#module-re</a></p>
<p>regex is powerful language for complex pattern matching with simple syntax.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from re import match
string = 'read : io=131220KB, bw=14016KB/s, iops=3504, runt=  9362msec'
iops = match(r'.+(iops=)([0-9]+)', string).group(2)
iops
'3504'
</code></pre>
</div>
<span class="comment-copy">Regular Expressions come to mind.</span>
<span class="comment-copy">From the OP's example, it looks like whitespace can appear in various places, so you should probably sprinkle some <code>\s*</code> liberally throughout, like <code>re.search(r"iops\s*=\s*(\d+)", s).group(1)</code>.</span>
<span class="comment-copy">I presume that this string message was generated mechanically, and was used for performance log analysis. So I didn't use \s* for my answer because of my expectation of message's stability and performance of pattern matching. Obviously, we should interpose \s* where we need to write if message's expression is too unstable or we don't care about performance.</span>
