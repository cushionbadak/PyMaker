<div class="post-text" itemprop="text">
<p>I know there is <a href="https://stackoverflow.com/questions/1057431/loading-all-modules-in-a-folder-in-python">this question</a>, but not only they're not working, it's not exactly what I want. I'm developing a racing game and want to load all tracks from a folder dynamically (They're stored as .py instead of .json). I don't want to know the names of the tracks, since users can mod/add them at will. I just want to import their data. So, for example:</p>
<pre><code>&gt;tracks 
&gt;&gt;track0.py
&gt;&gt;track1.py
&gt;&gt;track2.py
&gt;&gt;track3.py
&gt;&gt;track4.py
</code></pre>
<p>Inside each track, I have data like this:</p>
<pre><code>track_ground_data = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1],
    [1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1],
    [1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1],
    [1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1],
    [1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1],
    [1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1],
    [1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1],
    [1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1],
    [1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1],
    [1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1],
    [1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1],
    [1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]
</code></pre>
<p>I need to import each track module like this:</p>
<pre><code>loaded_tracks = [t for t in tracks] # Where tracks is the folder.
</code></pre>
<p>And then access a given <code>track_ground_data</code> like this:</p>
<pre><code>loaded_tracks[0].track_ground_data
</code></pre>
<p>If I knew Python was going to be so harsh with its imports, I'd have used json instead .py.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python does <em>not</em> automatically import submodules contained in a package.
Hence <code>import tracks</code> <strong>only</strong> loads <code>tracks/__init__.py</code>.</p>
<p>However you <em>can</em> put code inside the <code>__init__.py</code> file that imports all the modules it finds in that directory.</p>
<p>For example putting something like this in the <code>__init__.py</code>:</p>
<pre><code>import os
import importlib

__globals = globals()

for file in os.listdir(os.path.dirname(__file__)):
    mod_name = file[:-3]   # strip .py at the end
    __globals[mod_name] = importlib.import_module('.' + mod_name, package=__name__)
</code></pre>
<p>Should make your submodules available as <code>tracks.trackX</code> when importing only <code>tracks</code>.</p>
<p>Or you could use <code>exec</code>:</p>
<pre><code>import os
import importlib

for file in os.listdir(os.path.dirname(__file__)):
    mod_name = file[:-3]   # strip .py at the end
    exec('import .' + mod_name)
</code></pre>
<hr/>
<p>A cleaner approach would be to use import hooks or implement your own custom module importer. There are multiple ways to do this using <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow noreferrer"><code>importlib</code></a> see also <a href="https://docs.python.org/3/library/sys.html?highlight=path_hooks#sys.path_hooks" rel="nofollow noreferrer"><code>sys.path_hooks</code></a></p>
</div>
<div class="post-text" itemprop="text">
<p>The problem of dynamically importing modules is faced usually when frameworks have a plug-in or add on system for the community to contribute. Each plug-in or add-on is a module containing classes and functions compliant with the framework's architecture and api.</p>
<p>With that in mind, the solution for "joining the dots" between the framework code and arbitrarily many add-ons is through the <code>importlib</code> present in the python standard library. You seem to face the same structural problem.</p>
<p>Here is a stackoverflow <a href="https://stackoverflow.com/questions/8790003/dynamically-import-a-method-in-a-file-from-a-string">question</a> that was answered with <code>importlib</code>.
And the <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer">documentation</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just for the sake of the good wellfare of future pythoners, I'm posting how I've solved. A friend helped me through it. Coudln't make Bakuriu's solution work, because the modules came empty. Inside <code>__init__.py</code> I've put:</p>
<pre><code>import os

dir = os.path.dirname(os.path.abspath(__file__))
modules = [os.path.splitext(_file)[0] for _file in os.listdir(dir) if not _file.startswith('__')]

tracks = []
for mod in modules:
    exec('from tracks import {}; tracks.append({})'.format(mod, mod))
</code></pre>
<p>And then, on the main file, I've loaded it as:</p>
<pre><code>dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(dir)

from tracks import tracks
</code></pre>
<p>And then:</p>
<pre><code>loaded_tracks = [t for t in tracks]
</code></pre>
<p>That actually solved it quite well. I was almost switching to JSON / giving up.</p>
</div>
<span class="comment-copy">Yes. I've placed that code inside a <code>__init__.py</code> file and when I try to import a track (<code>import tracks</code>): <code>tracks.track0</code>, I get an <code>AttributeError</code>.</span>
<span class="comment-copy">You're right, you probably should have used a file format designed for storing data instead of executable .py files...</span>
<span class="comment-copy">You could do this by adapting <a href="https://stackoverflow.com/a/14428820/355230">my answer</a> to a related question about packages.</span>
<span class="comment-copy">Using python files for tracks is useless if they should only contain <i>static</i> data. However they do allow to put arbitrary code, which may be a feature... for example some track could define some functions that provide specific logic for that particular track, this is way harder to do with a simple json. If you don't need the flexibility just use json files (btw: you could still import them as python modules by using a custom module loader...)</span>
<span class="comment-copy">You'd also want to filter out <code>__init__.py</code>, so only do the last statement if <code>mod_name</code> doesn't match the pattern <code>^__</code>. Something like <code>if not re.match(r'^__', file):</code>.</span>
