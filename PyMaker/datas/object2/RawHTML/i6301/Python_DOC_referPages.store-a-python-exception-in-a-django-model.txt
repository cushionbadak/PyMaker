<div class="post-text" itemprop="text">
<p>What is the <strong>recommended way</strong> to <strong>store a Python exception</strong> – in a structured way that allows access to the different parts of that exception – <strong>in a Django model</strong>?</p>
<p>It is common to design a Django model that records “an event” or “an attempt to do foo”; part of the information to be recorded is “… and the result was this error”. That then becomes a field on the model.</p>
<p>An important aspect of recording the error in the database is to query it in various structured ways: What was the exception type? What was the specific message? What were the other arguments to the exception instance? What was the full traceback?</p>
<p>(I'm aware of services that will let me stream logging or errors to them across the network; that is <em>not</em> what this question asks. I need the structured exception data in the project's own database, for reference directly from other models in the same database.)</p>
<p>The <a href="https://docs.python.org/3/library/exceptions.html" rel="nofollow noreferrer">Python exception object</a> is a data structure that has all of these parts – the exception type, the arguments to the exception instance, the “cause” and “context”, the traceback – available separately, as attributes of the object. The objective of this question is to have the Python exception information stored in the database model, such that they can be queried in an equivalent structured manner.</p>
<p>So it isn't enough to have a free-form TextField to record a string representation of the exception. A structured field or set of fields is needed; perhaps even an entire separate model for storing exception instances.</p>
<p>Of course I could design such a thing myself, and spend time making the same mistakes countless people before me have undoubtedly made in trying to implement something like this. Instead, I want to learn from existing art in solving this problem.</p>
<p>What is a general pattern to <strong>store structured Python exception data in a Django model, preferably in an existing mature general-purpose library</strong> at PyPI that my project can use for its models?</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not that sure that many people had sought a custom way of storing exception data</p>
<p>Ultimately, you have to know what you need. In all projects I had worked so far, the traceback text had contained enough information to dig to the error source. (sometimes, even naively, so that the TB was escaped multipletimes, still it had been enough to "reverse escape" it, and fix the source with only one instance of the error).</p>
<p>Some debugging tools offer live interactive instrospection in each execution frame when an exception happens - but that has to be "live", because you can't ordinarily serialize Python execution frames and store it on the DB.</p>
<p>That said, if the traceback text is not enough for you, you can have the traceback object by calling <code>sys.exc_info()[2]</code>. That allows you to introspect each frame and know for yourself the file, line number, local and global variables as dictionaries.  If you want the variable values to be available on the database, you have to serialize them, but not all values on variables will be easily serializable. So, it is your call to know 'when enough is enough' in this process.</p>
<p>Most modern databases allow for JSON fields, and serializing the exception info to a JSON field restricting data to strings, numbers, bool and None is probably enough. </p>
<p>One way is to run manually each key on the f_globals and f_locals dict for each fame, and try to json.dumps that key's value, and on an exception on the JSON serializtion, use the object's <code>repr</code> instead.  Or you can customize a JSON serializer that could store customized relevant data for datetime and dates, open files, sockets and so on - only you can know your needs.</p>
<p>TL;DR: Use a JSON field, at the except clause get hold of the traceback object by calling <code>sys.last_traceback()</code>,  and have a custom function to serialize what you want from it into the JSON field.</p>
<p>Or, just use <code>traceback.format_tb</code> to save the traceback text - it probably will be enough anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>Most people delegate tasks like this to third-party services like RollBar or LogEntries, or to middleware services running in a VPC like Elastic LogStash.</p>
<p>I'd suggest that the Django ORM is not well suited for this type of storage. Most of the advantage of the ORM is letting you join on relational tables without elaborate SQL and manage schema changes and referential integrity with migrations. These are the problems encountered by the "CRUD" applications Django is designed for — web applications with user accounts, preferences, notification inboxes, etc. The ORM is intended to manage <em>mutable</em> data with more reads than writes.</p>
<p>Your problem, storing Python exceptions that happened in production, is quite different. Your schema needs will almost never change. The data you want to store is never modified at all once written, and all writes are strictly appends. Your data does not contain foreign keys or other fields that would change in a migration. You will almost always query recent data over historical, which will rarely be read outside of offline/bulk analytics.</p>
<p>If you really want to store this information in Django, I'd suggest storing only a rolling window that you periodically rotate into compressed logs on disk. Otherwise you will be maintaining costly indexes in data that is almost never needed. In this case, you should consider constructing your own custom Django model that extracts the Exception metadata you need. You could also put this information into a JSON field that you store as a string as @jsbueno suggests, but this sacrifices indexed selection.</p>
<p>(Note Python exceptions cannot be directly serialized to JSON or pickled. There is a project called <a href="https://github.com/ionelmc/python-tblib" rel="nofollow noreferrer">tblib</a> that enables pickling, which in turn could be stored as BLOB fields in Django, but I have no idea if the performance would be reasonable. My guess is it would not be worth it.)</p>
<p>In recent years there are many alternative DBMS products for log-like, append-only storage with analytic query patterns. But most of this progress is too recent and too "web-scale" to have off-the-shelf integration with Django, which focuses on smaller, more traditional CRUD applications. You should look for solutions that can be integrated with Python more generally, as complex logging/event storage is mostly out-of-scope for Django.</p>
</div>
<span class="comment-copy">So, you are talking about storing the stack trace (traceback)? It is usually printed with the exception but not part of it.</span>
<span class="comment-copy">This seems to me like an atypical thing to do. I did a search for "django log exceptions to database" and a few interesting things popped up. At a glance, it doesn't look like any of the existing libraries are mature, widely used, or even maintained.</span>
