<div class="post-text" itemprop="text">
<p>I'm seeing a behavior that I have no way of explaining...  Here's my simplified setup:</p>
<p>module <code>x</code>:</p>
<pre><code>import logging

logger = logging.getLogger('x')

def test_debugging():
    logger.debug('Debugging')
</code></pre>
<p>test for module <code>x</code>:</p>
<pre><code>import logging
import unittest

from x import test_debugging


class TestX(unittest.TestCase):

    def test_test_debugging(self):
        test_debugging()


if __name__ == '__main__':
    logger = logging.getLogger('x')
    logger.setLevel(logging.DEBUG)
    # logging.debug('another test')
    unittest.main()
</code></pre>
<p>If I uncomment the <code>logging.debug('another test')</code> line I can also see the log from <code>x</code>.  Note, it is not a typo, I'm calling <code>debug</code> on <code>logging</code>, not on the <code>logger</code> from module <code>x</code>.  And if I call <code>debug</code> on <code>logger</code>, I don't see logs.</p>
<p>What is this, I can't even?..</p>
</div>
<div class="post-text" itemprop="text">
<p>In your setup, you didn't actually <em>configure</em> logging. Although the configuration can be pretty complex, it would suffice to set the log level in your example:</p>
<pre><code>if __name__ == '__main__':
    # note I configured logging, setting e.g. the level globally
    logging.basicConfig(level=logging.DEBUG)
    logger = logging.getLogger('x')
    logger.setLevel(logging.DEBUG)
    unittest.main()
</code></pre>
<p>This will create a simple <code>StreamHandler</code> with a predefined output format that prints all the log records to the stdout. I suggest you to quickly look over the <a href="https://docs.python.org/3/library/logging.html#logging.basicConfig" rel="nofollow noreferrer">relevant docs</a> for more info.</p>
<p>Why did it work with the <code>logging.debug</code> call? Because the <code>logging.{info,debug,warn,error}</code> functions all call <code>logging.basicConfig</code> internally, so once you have called <code>logging.debug</code>, you configured logging implicitly.</p>
<hr/>
<p>Edit: let's take a quick look under the hood what is the actual meaning of the <code>logging.{info,debug,error,warning}</code> functions. Let's take the following snippet:</p>
<pre><code>import logging
logger = logging.getLogger('mylogger')
logger.warning('hello world')
</code></pre>
<p>If you run the snippet, <code>hello world</code> will be not printed (and this is correct so!). Why not? It's because you didn't actually specify how the log records should be treated - should they be printed to stdout, or maybe printed to a file, or maybe sent to some server that will email them to the recipients? The logger <code>mylogger</code> <em>will</em> receive the log record <code>hello world</code>, but it doesn't know yet what to do with it. So, to actually print the record, let's do some configuration for the logger:</p>
<pre><code>import logging
logger = logging.getLogger('mylogger')
formatter = logging.Formatter('Logger received message %(message)s at time %(asctime)s')
handler = logging.StreamHandler()
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.warning('hello world')
</code></pre>
<p>We now attached a <code>handler</code> that <em>handles</em> the record by printing it to the stdout in the format specified by <code>formatter</code>. Now the record <code>hello world</code> will be printed to the stdout. We could attach more handlers and the record would be handled by each of the handler. Example: try to attach another <code>StreamHandler</code> and you will notice that the record is now printed twice.</p>
<p>So, what's with the <code>logging</code> functions now? If you have some simple program that has only one logger that should print the messages and that's all, you can replace the manual configuration by using convenience <code>logging</code> functions:</p>
<pre><code>import logging
logging.warning('hello world')
</code></pre>
<p>This will configure the root logger to print the messages to stdout by adding a <code>StreamHandler</code> to it with some default formatter, so you don't have to configure it yourself. After that, it will tell the root logger to process the record <code>hello world</code>. Merely a convenience, nothing more. If you want to explicitly trigger this basic configuration of the root logger, issue</p>
<pre><code>logging.basicConfig()
</code></pre>
<p>with or without the additional configuration parameters.</p>
<p>Now, let's go through my first code snippet once again:</p>
<pre><code>    logging.basicConfig(level=logging.DEBUG)
</code></pre>
<p>After this line, the root logger will print all log records with level <code>DEBUG</code> and higher to the command line.</p>
<pre><code>    logger = logging.getLogger('x')
    logger.setLevel(logging.DEBUG)
</code></pre>
<p>We did not configure this logger explicitly, so why are the records still being printed? This is because by default, any logger will propagate the log records to the root logger. So the logger <code>x</code> does not print the records - it has not been configured for that, but it will pass the record further up to the root logger that knows how to print the records.</p>
</div>
<span class="comment-copy">Why then if I call <code>logger.debug()</code> no configuration happens? This is even more confusing since Vinny claims that whatever <code>logging.getLogger()</code> returns is <i>the same</i> as the logger on which <code>logging</code> operates (i.e. the top-level logger).</span>
<span class="comment-copy">It's because <code>logger</code> is an instance of <i>class</i> <code>Logger</code>, whose <code>debug</code> method does not do any configuration, only output log records if the logging level fits. <code>logging.debug</code>, on the other hand, is a convenience function in <code>logging</code> <i>module</i> that does the simplified configuration for you if you happened to forget it, then takes the root logger and makes him call its <code>Logger.debug</code> method. <code>Logger.debug</code> and <code>logging.debug</code> are two different functions, one doing more than the other, they just happen to be both named the same.</span>
<span class="comment-copy">I think Vinny did not quite understand what your question is about.</span>
<span class="comment-copy">@wxvxw take a look at the edits - does it answer your question?</span>
<span class="comment-copy">OK, I thought that <code>logging.debug</code> is just an alias for <code>&lt;root logger&gt;.debug</code>. I'm scared to think now what would happen if some module, imported earlier than the call to <code>logging.basicConfig</code> also did <code>logging.debug()</code>. <i>sigh</i> But thank you for detailed explanation.</span>
