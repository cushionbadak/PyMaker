<div class="post-text" itemprop="text">
<p>We all know that the common way of executing a statement a certain number of times in Python is to use a <code>for</code> loop.</p>
<p>The general way of doing this is,</p>
<pre><code># I am assuming iterated list is redundant.
# Just the number of execution matters.
for _ in range(count):
    pass
</code></pre>
<p>I believe nobody will argue that the code above is the common implementation, however there is another option. Using the speed of Python list creation by multiplying references.</p>
<pre><code># Uncommon way.
for _ in [0] * count:
    pass
</code></pre>
<p>There is also the old <code>while</code> way.</p>
<pre><code>i = 0
while i &lt; count:
    i += 1
</code></pre>
<p>I tested the execution times of these approaches. Here is the code.</p>
<pre><code>import timeit

repeat = 10
total = 10

setup = """
count = 100000
"""

test1 = """
for _ in range(count):
    pass
"""

test2 = """
for _ in [0] * count:
    pass
"""

test3 = """
i = 0
while i &lt; count:
    i += 1
"""

print(min(timeit.Timer(test1, setup=setup).repeat(repeat, total)))
print(min(timeit.Timer(test2, setup=setup).repeat(repeat, total)))
print(min(timeit.Timer(test3, setup=setup).repeat(repeat, total)))

# Results
0.02238852552017738
0.011760978361696095
0.06971727824807639
</code></pre>
<p>I would not initiate the subject if there was a small difference, however it can be seen that the difference of speed is 100%. Why does not Python encourage such usage if the second method is much more efficient? Is there a better way?</p>
<p>The test is done with <strong>Windows 10</strong> and <strong>Python 3.6</strong>.</p>
<p>Following @Tim Peters' suggestion,</p>
<pre><code>.
.
.
test4 = """
for _ in itertools.repeat(None, count):
    pass
"""
print(min(timeit.Timer(test1, setup=setup).repeat(repeat, total)))
print(min(timeit.Timer(test2, setup=setup).repeat(repeat, total)))
print(min(timeit.Timer(test3, setup=setup).repeat(repeat, total)))
print(min(timeit.Timer(test4, setup=setup).repeat(repeat, total)))

# Gives
0.02306803115612352
0.013021619340942758
0.06400113461638746
0.008105080015739174
</code></pre>
<p>Which offers a much better way, and this pretty much answers my question. </p>
<p>Why is this faster than <code>range</code>, since both are generators. Is it because the value never changes?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using</p>
<pre><code>for _ in itertools.repeat(None, count)
    do something
</code></pre>
<p>is the non-obvious way of getting the best of all worlds: tiny constant space requirement, and no new objects created per iteration. Under the covers, the C code for <code>repeat</code> uses a native C integer type (not a Python integer object!) to keep track of the count remaining.</p>
<p>For that reason, the count needs to fit in the platform C <code>ssize_t</code> type, which is generally at most <code>2**31 - 1</code> on a 32-bit box, and here on a 64-bit box:</p>
<pre><code>&gt;&gt;&gt; itertools.repeat(None, 2**63)
Traceback (most recent call last):
    ...
OverflowError: Python int too large to convert to C ssize_t

&gt;&gt;&gt; itertools.repeat(None, 2**63-1)
repeat(None, 9223372036854775807)
</code></pre>
<p>Which is plenty big for my loops ;-)</p>
</div>
<div class="post-text" itemprop="text">
<p>The first method (in Python 3) creates a range object, which can iterate through the range of values. (It's like a generator object but you can iterate through it several times.) It doesn't take up much memory because it doesn't contain the entire range of values, just a current and a maximum value, where it keeps increasing by the step size (default 1) until it hits or passes the maximum.</p>
<p>Compare the size of <code>range(0, 1000)</code> to the size of <code>list(range(0, 1000))</code>: <a href="https://tio.run/##K6gsycjPM/7/PzO3IL@oRKG4spiroCgzr0QDyNJLTy0pzqxKzU/TyMksLtEoSsxLT9Uw0FEwNAACTSDAqlYBBNDUKmhq/v8PAA" rel="nofollow noreferrer">Try It Online!</a>. The former is very memory efficient; it only takes 48 bytes regardless of the size, whereas the entire list increases linearly in terms of size.</p>
<p>The second method, although faster, takes up that memory I was talking about in the past one. (Also, it seems that although <code>0</code> takes up 24 bytes and <code>None</code> takes 16, arrays of <code>10000</code> of each have the same size. Interesting. Probably because they're pointers)</p>
<p>Interestingly enough, <code>[0] * 10000</code> is smaller than <code>list(range(10000))</code> by about 10000, which kind of makes sense because in the first one, everything is the same primitive value so it can be optimized.</p>
<p>The third one is also nice because it doesn't require another stack value (whereas calling <code>range</code> requires another spot on the call stack), though since it's 6 times slower, it's not worth that.</p>
<p>The last one might be the fastest just because <code>itertools</code> is cool that way :P I think it uses some C-library optimizations, if I remember correctly.</p>
</div>
<div class="post-text" itemprop="text">
<p>The first two methods need to allocate memory blocks for each iteration while the third one would just make a step for each iteration.</p>
<p>Range is a slow function, and I use it only when I have to run small code that doesn't require speed, for example, <code>range(0,50)</code>. I think you can't compare the three methods; they are totally different.</p>
<p>According to a comment below, the first case is only valid for Python 2.7, in Python 3 it works like xrange and doesn't allocate a block for each iteration. I tested it, and he is right.</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer provides a loop construct for convenience. For additional background about looping with <code>itertools.repeat</code> look up Tim Peters' answer <a href="https://stackoverflow.com/a/46996392/9059420">above</a>, Alex Martelli's answer <a href="https://stackoverflow.com/a/818888/9059420">here</a> and Raymond Hettinger's answer <a href="https://stackoverflow.com/a/9098860/9059420">here</a>.</p>
<pre><code># loop.py

"""
Faster for-looping in CPython for cases where intermediate integers
from `range(x)` are not needed.

Example Usage:
--------------

from loop import loop

for _ in loop(10000):
    do_something()

# or:

results = [calc_value() for _ in loop(10000)]
"""

from itertools import repeat
from functools import partial

loop = partial(repeat, None)
</code></pre>
</div>
<span class="comment-copy">One more to try:  <code>for _ in itertools.repeat(None, count)</code>.</span>
<span class="comment-copy">A major problem with the second method is that it allocates storage for the entire throw-away list.</span>
<span class="comment-copy">But in practical code the body of the loop will be more complex, and dominate the over all timing.  If the iteration variable is unimportant you are just spinning wheels.</span>
<span class="comment-copy">@MaxPythone Could you give an example? I find it hard to believe :) (not that I'm an expert though :) )</span>
<span class="comment-copy">@MaxPythone Thank for you answer, but I am still confused. For the fist example, I would think that what dominates the execution is obtaining / saving / checking the video frames you're trying to obtain. Or if you can start directly from a certain frame, no point in running an empty loop. Also for the other example; whatever algorithm you use to benchmark, it will be dominated by what you do in the loop, and not by how you increase the 32 bit counter in the for loop</span>
<span class="comment-copy">That's quite a learning curve!  The source for itertools is at <a href="https://github.com/python/cpython/blob/master/Modules/itertoolsmodule.c" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Modules/itertoolsmodule.c</a>, and the implementation of <code>repeat</code> spans several distinct functions near <code>repeat_new</code>.  How do I know this?  Because I've played with Python's source code for 25 years ;-)</span>
<span class="comment-copy">Well I already knew you took part in the Python project, so I wanted to extract as much as information while you were here :) Your help is appreciated.</span>
<span class="comment-copy">@Beginner, I didn't create Python, but still use it every day, and - yes - believe its creator (Guido van Rossum) has every reason to be proud of it.</span>
<span class="comment-copy">@timPeters On a scale of 1 being golfing to 10 being Pythonic, were would you place this ;-)</span>
<span class="comment-copy">@Paddy3118, it's a mixed bag, really.  The <i>meaning</i> of <code>repeat(None, 100)</code> is quite clear:  it delivers <code>None</code> 100 times.  That the loop doesn't care <i>which</i> value(s) it delivers is a bit clearer that way than via, e.g., a <code>range(100)</code> spelling.  But because it's a novel (rarely seen) spelling, that hurts easy readability.  Nevertheless, it's obvious the second time you see it, so not a big deal.  Overall, on that alone, it's only slightly less Pythonic, to me, than <code>range(100)</code>.  Python has no direct way to say <i>just</i> "do this loop N times", so there is no "truly Pythonic" way to do it.</span>
<span class="comment-copy"><code>range</code> returns a <a href="https://docs.python.org/3/library/stdtypes.html#typesseq-range" rel="nofollow noreferrer"><code>range</code> object</a> in Python 3, not a generator. One specific quality that demonstrates this is that you can iterate over it multiple times, whereas generators are consumed (and therefore empty) once iterated over.</span>
<span class="comment-copy">@jpmc26 Ah yes, thank you for correcting me :)</span>
<span class="comment-copy">Incorrect.  IN Python 3, <code>range</code> produces an iterator.  It is equivalent to Python 2's <code>xrange</code>.  Only the second method has the memory problem.</span>
<span class="comment-copy">@TomKarzes Still incorrect (though more correct). It produces a <a href="https://docs.python.org/3/library/stdtypes.html#typesseq-range" rel="nofollow noreferrer"><code>range</code> object</a>. A range object is not an iterator or generator; it can be iterated over multiple times without being consumed.</span>
<span class="comment-copy">Wouldnt it be even better to make loop a decorator so you can do: <code>@loop(10000) do_something()</code></span>
<span class="comment-copy">@Tweakimp I'm not sure if I understand how you think that should work. Sure you could decorate a <i>specific</i> function to be called 1000 times, but you would lose flexibility in calling that function and it would only work for <i>that</i> decorated function.</span>
<span class="comment-copy">I want to call the function <code>do_something</code> to be called 10000 times and the decorator might change <code>do_something</code> to <code>for _ in loop(10000):     do_something()</code></span>
<span class="comment-copy">@Tweakimp If you always want to call it 10k times it makes certainly sense and using a decorator for that is not unusual. But that's a very specific usecase then where you extend the basic idea here of just finding a "better" for-loop.</span>
