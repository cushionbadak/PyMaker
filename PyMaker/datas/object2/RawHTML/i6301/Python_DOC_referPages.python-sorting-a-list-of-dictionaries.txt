<div class="post-text" itemprop="text">
<p>I am experimenting with a search algorithm, and I am trying to use an A* algorithm to solve the problem.</p>
<p>I am using a list of dictionaries to mantain the internal node structure.
Each node is characterised by a certain state and associated cost.
The selection function should return the node with the lowest cost.
To be able to do this, I am filtering the list every time.
I found this is very fast if the problem is very small,
but in the case the list is very big, this function  uses 84% of the total time of the algorithm.</p>
<p>My question is if there is a more efficient way of doing this.</p>
<pre><code>def select(self, frontier):
    frontier.sort(key = lambda x: x['f_cost'])
    #select the node with the lowest f_cost
    return frontier.pop(0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yeah, don't <code>.pop</code> from the beginning! That is linear-time. <code>.pop</code> from the end is constant, so just do:</p>
<pre><code>def select(self, frontier):
    frontier.sort(key = lambda x: x['f_cost'], reverse=True)
    #select the node with the lowest f_cost
    return frontier.pop()
</code></pre>
<p>You might want to consider alternative data-structures, if you are trying to maintain a sorted sequence. You could look at <code>heapq</code> which is part of the standard-library, although it is pretty bare-bones. You might also consider the <a href="http://www.grantjenks.com/docs/sortedcontainers/" rel="nofollow noreferrer"><code>sortedcontainers</code></a> library, which apparently, is <em>very performant</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use functions like <code>attrgetter</code> or <code>itemgetter</code> for your key instead of lambda function as it is considered to be faster. </p>
<p>Docs: 
<a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer">https://docs.python.org/3/howto/sorting.html</a></p>
<p>For details, have a look at this answer.
<a href="https://stackoverflow.com/questions/17243620/operator-itemgetter-or-lambda">operator.itemgetter or lambda</a></p>
</div>
<span class="comment-copy">You might also want to look into using a priority queue instead. E.g., <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer"><code>heapq</code></a>.</span>
<span class="comment-copy">That "pop from the beginning" (O(n)) is probably not as bad as the sort (O(n log n)), so the second part of the answer (use another data structure) looks more promising.</span>
<span class="comment-copy">@Sebastian True, but keep in mind, timsort is <i>worst case</i> O(n log n), but it is <i>blazingly fast</i> at sorting nearly-sorted lists. That being said, your point still stands.</span>
<span class="comment-copy">@juanpa.arrivillaga It's not blazingly fast compared to popping from the front. It's very slow compared to that. Try it.</span>
<span class="comment-copy">@StefanPochmann sure, I don't disagree ::shrug::</span>
<span class="comment-copy">that would only make a marginal difference.</span>
