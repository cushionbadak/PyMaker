<div class="post-text" itemprop="text">
<p>Hit problem when convert python code to shared object by Cython.</p>
<p>setup file here:</p>
<pre><code>from distutils.core import setup
from Cython.Build import cythonize
setup(
    ext_modules = cythonize("hello.py")
)
</code></pre>
<p>So everything works fine on my Ubuntu desktop util transferred to CentOS.</p>
<p>Got error:</p>
<p>undefined symbol: PyUnicodeUCS4_DecodeUTF8</p>
<p>I googled and find there are many questions on this, but, almost all of them say the root cause is python with UCS2 or UCS4, and I understand this, didn't find one show the way to solve this.</p>
<p>IMO, ways to solve:</p>
<ol>
<li>rebuild python to get the right version by "--enable-unicode=ucs4/ucs2"</li>
</ol>
<p>But I need to reinstall all packages </p>
<ol start="2">
<li>Compile the code from another desktop whose python with the right UCS</li>
</ol>
<p>Now, I wanna if there is way to set Cython to compile with specified UCS mode.</p>
<p>Any suggestions is great appreciated.</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, to answer your actual question:</p>
<blockquote>
<p>I wanna if there is way to set Cython to compile with specified UCS mode.</p>
</blockquote>
<p>You can <a href="https://docs.python.org/3/using/unix.html#building-python" rel="nofollow noreferrer">build a separate python installation from source</a> and link Cython against its headers. To find the headers, you can use the <code>python-config</code> tool (or <code>python3-config</code> for Python 3). It is usually located in the <code>bin</code> directory where the <code>python</code> executable is:</p>
<pre class="lang-sh prettyprint-override"><code>$ # system python on my machine (macos):
$ which python-config
/usr/bin/python-config

$ # python 3 installation
$ which python3-config 
/Library/Frameworks/Python.framework/Versions/3.6/bin/python3-config

$ python-config --cflags
-I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -fno-strict-aliasing -fno-common -dynamic -arch x86_64 -arch i386 -g -Os -pipe -fno-common -fno-strict-aliasing -fwrapv -DENABLE_DTRACE -DMACOSX -DNDEBUG -Wall -Wstrict-prototypes -Wshorten-64-to-32 -DNDEBUG -g -fwrapv -Os -Wall -Wstrict-prototypes -DENABLE_DTRACE
$ python-config --ldflags
-L/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config -lpython2.7 -ldl -framework CoreFoundation
</code></pre>
<p>Copy the output to the <code>setup.py</code>:</p>
<pre><code>from setuptools import setup
from setuptools.extension import Extension
from Cython.Build import cythonize


cflags_ucs4 = [
    '-I/Library/Frameworks/Python.framework/Versions/3.6/include/python3.6m',
    '-I/Library/Frameworks/Python.framework/Versions/3.6/include/python3.6m',
    ...
]
ldflags_ucs4 = [
    '-L/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/config-3.6m-darwin', 
    '-lpython3.6m', 
    ...
]

cflags_ucs4 = [...]
ldflags_ucs2 = [...]


should_build_ucs2 = False  # i.e. could be passed via sys.argv

if should_build_ucs2:
    cflags = cflags_ucs2
    ldflags = ldflags_ucs2
else:
    cflags = cflags_ucs4
    ldflags = ldflags_ucs4

extensions = [
    Extension('hello.py', extra_compile_args=cflags, extra_link_args=ldflags),
]

setup(
    ext_modules = cythonize(extensions)
)
</code></pre>
<hr/>
<p>However, I do not recommend doing that as you won't win anything by doing that - you will still need to build and distribute two separate packages (one for UCS2, another for UCS4) which is messy to maintain.</p>
<p>Instead, if you are building a wheel that should be installable on a wide range of Linux distros (what is most probably your actual goal), I would suggest to make your build compliable with <a href="https://www.python.org/dev/peps/pep-0513/" rel="nofollow noreferrer">PEP 513</a> (<code>manylinux1</code> packages).I suggest you to read it through as it was very helpful for me when I faced the problem of distributing Linux-compliant wheels.</p>
<p>Now, one way to get a <code>manylinux1</code>-compliant wheel is to build the wheel on your machine, then running <code>auditwheel</code> to check for platform-specific issues and trying to resolve them:</p>
<pre class="lang-sh prettyprint-override"><code>$ pip install auditwheel
$ python setup.py bdist_wheel
$ # there should be now a mypkg-myver-cp36-cp36m-linux_x86_64.whl file in your dist directory
$ auditwheel show dist/mypkg-myver-cp36-cp36m-linux_x86_64.whl
$ # check what warnings auditwheel produced
$ # if there are warnings, try to repair them:
$ auditwheel repair dist/mypkg-myver-cp36-cp36m-linux_x86_64.whl
</code></pre>
<p>This should generate a wheel file named <code>mypkg-myver-cp36-cp36m-manylinux1_x86_64.whl</code> in a <code>wheelhouse</code> directory. Check again that everything is fine now by running <code>auditwheel show wheelhouse/mypkg-myver-cp36-cp36m-manylinux1_x86_64.whl</code>. If the wheel is now consistent with <code>manylinux1</code>, you can distribute it and it should work on <em>most</em> Linux distros (at least those with glibc; distros with musl like Alpine won't work, you will need to build a separate wheel if you want to support it).</p>
<p>What should you do if <code>auditwheel</code> can't repair your wheel? The best way is to pull a special docker container provided by PyPA for building <code>manylinux1</code>-compliant wheels (this is what I'm using myself):</p>
<pre class="lang-sh prettyprint-override"><code>$ docker pull https://quay.io/repository/pypa/manylinux1_x86_64
</code></pre>
<p>A wheel built inside this container will work on most of the Linux distros (excluding some exotic ones like Alpine).</p>
</div>
