<div class="post-text" itemprop="text">
<p>Rules in applyRules is going to be asked to users, but it does not work what it should work which is <code>[“character1:substitution”, “character2:substitution”]</code></p>
<p>When user put <code>['b:c','c:d']</code>, it prints <code>c,c</code>. However, it should print <code>d</code> when char is <code>b</code></p>
<p>The function takes a single character and a set of rules as a list.</p>
<p>And this is what I wrote so far</p>
<pre><code>def applyRules(char, rules):
    for rule_list in (rule.split(':') for rule in rules):
        char = char.replace(rule_list[0], rule_list[1])
    return char
</code></pre>
<p>What should I add to make it work appropriately?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have multiple rules, this becomes cumbersome. As long as your replacements are done on single characters, you can make this easy with <code>str.translate</code>. That, however, doesn't solve the problem of chained replacements, so you'll have to make use of a <code>while</code> loop that runs until there are no more changes.</p>
<pre><code>def applyRules(string, rules):
    mapping = str.maketrans(dict(x.split(':') for x in rules))

    while True:
        new = string.translate(mapping)
        if string == new:
            break
        string = new

    return new
</code></pre>
<hr/>
<pre><code>In [1308]: applyRules('bbbbb', ['b:c', 'c:d'])
Out[1308]: 'ddddd'
</code></pre>
<hr/>
<p><strong>Single Character Replacement</strong><br/>
For replacement involving a single character, the solution simplifies. You could use a dictionary with <code>get</code>:</p>
<pre><code>def applyRules(char, rules):
    mapping = dict(x.split(':') for x in rules)

    while True:
        new = mapping.get(char, char)
        if char == new:
            break
        char = new

    return new
</code></pre>
<p>This should be much simpler.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to apply each and every rule and also, preserve the new string at the same time since strings are immutable in python. You can use <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer">translate</a> of <code>str</code> class. Following code works</p>
<pre><code>def applyRules(char, rules):
    modified = char

    for rule in rules:
        r = rule.split(':')
        table = str.maketrans({r[0]:r[1]})
        modified = modified.translate(table)

    return modified

print(applyRules('bbbbb',['b:c','c:d'])) #prints 'ddddd'
print(applyRules('abdecbc',['b:c','c:d'])) #prints 'addeddd'
</code></pre>
</div>
<span class="comment-copy">Is it a single character substitution?</span>
<span class="comment-copy">you should provide an example <i>input</i> to the function and show what the output is vs. what is it you expected it to be.</span>
<span class="comment-copy">@Whitepub This should still work, but you'd see speed gains vs other answers only for strings.</span>
<span class="comment-copy">It works when I write rules in function, but when I ask user like  <code>char = input("What character do you want to put?")     rules = input("Put your rule")     inst = lsystems.applyRules(char, [rules])     print(inst)</code>  It looks like it is not working. How users are supposed to put rules through Python Shell?</span>
<span class="comment-copy">@Whitepub That's an entirely different problem. Ask the input space separated rules like this: <code>"a:b b:c c:d"</code> and then pass <code>rules.split()</code> to your function.</span>
<span class="comment-copy">@Whitepub Also, see edit. I've added a solution which should be <i>much cheaper</i> than translate for a single character.</span>
<span class="comment-copy">I am sorry, since I am new to coding, it is hard for me to understand quickly. How do I ask the input to separate rules and how to pass rules.split()?</span>
<span class="comment-copy">If you replace only one character at a time, you end up with O(n^2) complexity. If you perform replacement with all the rules together (inside a condition controlled while), you end up with something a lot faster.</span>
