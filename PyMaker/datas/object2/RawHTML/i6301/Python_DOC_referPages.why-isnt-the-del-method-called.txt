<div class="post-text" itemprop="text">
<p>In python3's <code>multiprocess</code>,  can't call the <code>__del__</code> method.  </p>
<p>I've read other issues about circular references,but I can't find the situation in <code>multiprocess</code>.  </p>
<p>There is a circular reference in <code>foo</code>, <code>__del__</code> will be called when  <code>foo</code> is called directly,but in <code>multiprocess</code> the <code>__del__</code> will never be called.</p>
<pre><code>import multiprocessing
import weakref


class Foo():
    def __init__(self):
        self.b = []

    def __del__(self):
        print ('del')


def foo():
    print ('call foo')
    f = Foo()
    a = [f]
    # a = [weakref.ref(f)]
    f.b.append(a)


# call foo in other process
p = multiprocessing.Process(target=foo)
p.start()
p.join()


# call foo
foo()
</code></pre>
<p><strong>Output:</strong><br/>
<em>call foo<br/>
call foo<br/>
del</em></p>
<p>why <code>__del__</code> is not called in <code>p</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Forked <code>Process</code> objects terminate after running their task using <a href="https://docs.python.org/3/library/os.html#os._exit" rel="nofollow noreferrer"><code>os._exit()</code></a>, which forcibly terminates the child process <em>without</em> the normal cleanup Python performs on exit. Cyclic garbage isn't cleaned (because the process is terminated without giving the cyclic GC a chance to run), it's just dropped on the floor, leaving the OS to clean up.</p>
<p>This is intentional, since exiting normally (invoking all normal cleanup procedures) would risk stuff like unflushed buffers getting flushed in both parent and child (doubling output), and other weirdness involved when a forked process inherits all the state of the parent but isn't supposed to use it except when told to do so explicitly.</p>
</div>
<div class="post-text" itemprop="text">
<p>The question isn't actually why it <em>isn't</em> called in <code>multiprocess</code>, but why it <em>is</em> called in the other example. And the answer to that is that it isn't called when you call <code>foo</code>. It's called at the end of the program. Since the program is finished, Python knows that anything else can be cleaned up even if it's still referenced, so it cleans up circular references.</p>
<p>If you add a <code>print</code> statement at the end of the script, or call this from the REPL, you can see that <code>__del__</code> still isn't called at your second <code>foo</code> call either, but only at the end of the script.</p>
<p>Given that Python cleans up circular references when the script ends, <a href="https://stackoverflow.com/a/46966357/27302">ShadowRanger's answer</a> explains why that doesn't happen when the multiprocessing function is finished.</p>
</div>
<span class="comment-copy">What do you think <code>weakref</code> does? You mention it in your code, and it's related to this question, but you don't say why you think it's relevant.</span>
<span class="comment-copy">Python cleans circular references intermittently, not just at script termination. Much of the details are documented on <a href="https://docs.python.org/3/library/gc.html" rel="nofollow noreferrer">the <code>gc</code> module</a>, but the short version is it maintains pools of monitored references by age, and cleans the newer pools more frequently, and the older pools less often, with the interval being determined by number of allocations and deallocations performed. That said, as long as one live (non-cyclic) reference exists, the cycle collection doesn't matter (since it's not yet cyclic garbage).</span>
<span class="comment-copy">I was careful not to say it <i>only</i> happened then, but I did sort of imply it. I wasn't sure, but I thought it usually only happened then but there was something you could call in <code>gc</code> if you wanted or it probably checked if you were out of memory. It's good to know it sometimes happens before the end anyway.</span>
