<div class="post-text" itemprop="text">
<p>I have a simple class A that gets the name from users. </p>
<pre><code>class A:
   def __init__(self, name = ''):
       self.name = name
</code></pre>
<p>Then I want to create a class B that prints out this name. I tried:</p>
<pre><code>class B:
    def print_name(printing_name = A.name):
        print(printing_name)
</code></pre>
<p>Then I call these methods:</p>
<pre><code>m1 = A("x")
B.print_name(m1)
</code></pre>
<p>This returns the error</p>
<pre><code>Traceback (most recent call last):
  File "so.py", line 5, in &lt;module&gt;
    class B:
  File "so.py", line 7, in B
    def print_name(printing_name = A.name):
AttributeError: class A has no attribute 'name'
</code></pre>
<p>I know that I did not assign a class variable in the class A, and thus the name attribute goes with specific instances, not the entire class. However, the name attribute has to connect with every specific instance because it changes from the case to case. Then how should I get this name in class B? </p>
</div>
<div class="post-text" itemprop="text">
<p>Change your <code>class B</code> to this:</p>
<pre><code>class B:

    @staticmethod
    def print_name(obj):
        print(obj.name)
</code></pre>
<p>The <code>print_name</code> method probably should be decorated as a <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow noreferrer">"static method"</a>. The property "<code>name</code>" of <code>self</code> is an instance attribute which can not be referred directly from the class itself.</p>
</div>
<div class="post-text" itemprop="text">
<p>That's correct: <strong>name</strong> is an instance attribute, not a class attribute.  IN this case, <strong>m1</strong> has a name, but class <strong>A</strong> does not.  You need to access the name of the input parameter, not attempt to print a class attribute.</p>
<p>You also need to make <strong>B.print_name</strong> a class function, since you're not calling it from an instance of <strong>B</strong>.</p>
<pre><code>class B:

    @staticmethod
    def print_name(inst):
        print(inst.name)
</code></pre>
<p>Output:</p>
<pre><code>x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edit:</strong> The answers suggesting <code>@staticmethod</code> are ideal if you understand what it does.</p>
<pre><code>class A:
    def __init__(self, name = ''):
        self.name = name

class B:
    def __init__(self):
        pass
    def print_name(self, var):
        print (var.name)
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; m1 = A("X")
&gt;&gt;&gt; b = B()
&gt;&gt;&gt; b.print_name(m1)
X
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this instance A is the name of the class, and you should not give it as the default argument for calling the <code>print_name</code> method. Have a look at keyword arguments for Python, and you will see that what you have written actually means that you have the default value set to the <code>.name</code> property of the class A, which does not exist unless the class is instantiated (i.e. an object is created of the class).</p>
<p>Your <code>B</code> class should read:</p>
<pre><code>class B:
    def print_name(printing_object):
        print(printing_object.name)
</code></pre>
</div>
<span class="comment-copy"><code>self.name</code> here is an instance property rather than a class attribute. What did you try to achieve here?</span>
<span class="comment-copy">Got you. Thanks!</span>
<span class="comment-copy">Now I get it. Thank you!</span>
