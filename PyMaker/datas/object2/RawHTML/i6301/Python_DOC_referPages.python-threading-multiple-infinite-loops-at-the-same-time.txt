<div class="post-text" itemprop="text">
<p>In Python I am trying to get one infinite loop to start running parallel at the same time, a simple example would be:</p>
<pre><code>from threading import Thread

def func(argument):
    while True:
        print(argument)

def main():
    Thread(target=func("1")).start()
    Thread(target=func("2")).start()
    Thread(target=func("3")).start()
    Thread(target=func("4")).start()

if __name__ == '__main__':
    main()
</code></pre>
<p>Right now only the first thread runs, so the result is:</p>
<pre><code>1
1
1
1
....
</code></pre>
<p>And it should be:</p>
<pre><code>1
2
3
4
....
</code></pre>
<p>I found several similar questions but none of the provided solutions seem to work for me, including using <code>join</code> on the threads.</p>
<p>So if anyone knows the solution to my problem it would be very much appreciated.</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>The first Thread isn't starting. You are calling the <code>func</code> in <code>main</code> and attempting to set its return value as <code>target</code>, but it runs forever and the first Thread never gets created. You want:</p>
<pre><code>from threading import Thread

def func(argument):
    while True:
        print(argument)

def main():
    Thread(target=func,args=("1",)).start()
    Thread(target=func,args=("2",)).start()
    Thread(target=func,args=("3",)).start()
    Thread(target=func,args=("4",)).start()

if __name__ == '__main__':
    main()
</code></pre>
<p>This will pass <code>func</code> as an object. Starting the thread will call that object with the tuple of args specified. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can define your own thread:</p>
<pre><code>from threading import Thread

class MyThread(Thread):
    def __init__(self,argument, **kwargs):
        super(MyThread, self).__init__(**kwargs)
        self.argument = argument

    def run(self):
        while True:
           print self.argument

if __name__ == '__main__':
    MyThread('1').start()
    MyThread('2').start()
    MyThread('3').start()
    MyThread('4').start()
</code></pre>
</div>
<span class="comment-copy">"In CPython, due to the Global Interpreter Lock, only one thread can execute Python code at once (even though certain performance-oriented libraries might overcome this limitation). If you want your application to make better use of the computational resources of multi-core machines, you are advised to use multiprocessing or concurrent.futures.ProcessPoolExecutor. However, threading is still an appropriate model if you want to run multiple I/O-bound tasks simultaneously." from <a href="https://docs.python.org/3/library/threading.html#module-threading" rel="nofollow noreferrer">the docs</a></span>
<span class="comment-copy">That fixes it! Thanks a ton.</span>
