<div class="post-text" itemprop="text">
<p>I'm iterating over a list of tuples in Python, and am attempting to remove them if they meet certain criteria. </p>
<pre><code>for tup in somelist:
    if determine(tup):
         code_to_remove_tup
</code></pre>
<p>What should I use in place of <code>code_to_remove_tup</code>? I can't figure out how to remove the item in this fashion.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a list comprehension to create a new list containing only the elements you don't want to remove:</p>
<pre><code>somelist = [x for x in somelist if not determine(x)]
</code></pre>
<p>Or, by assigning to the slice <code>somelist[:]</code>, you can mutate the existing list to contain only the items you want:</p>
<pre><code>somelist[:] = [x for x in somelist if not determine(x)]
</code></pre>
<p>This approach could be useful if there are other references to <code>somelist</code> that need to reflect the changes.</p>
<p>Instead of a comprehension, you could also use <code>itertools</code>. In Python 2:</p>
<pre><code>from itertools import ifilterfalse
somelist[:] = ifilterfalse(determine, somelist)
</code></pre>
<p>Or in Python 3:</p>
<pre><code>from itertools import filterfalse
somelist[:] = filterfalse(determine, somelist)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answers suggesting list comprehensions are ALMOST correct -- except that they build a completely new list and then give it the same name the old list as, they do NOT modify the old list in place. That's different from what you'd be doing by selective removal, as in @Lennart's suggestion -- it's faster, but if your list is accessed via multiple references the fact that you're just reseating one of the references and NOT altering the list object itself can lead to subtle, disastrous bugs.</p>
<p>Fortunately, it's extremely easy to get both the speed of list comprehensions AND the required semantics of in-place alteration -- just code:</p>
<pre><code>somelist[:] = [tup for tup in somelist if determine(tup)]
</code></pre>
<p>Note the subtle difference with other answers: this one is NOT assigning to a barename - it's assigning to a list slice that just happens to be the entire list, thereby replacing the list <em>contents</em> <strong>within the same Python list object</strong>, rather than just reseating one reference (from previous list object to new list object) like the other answers.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to take a copy of the list and iterate over it first, or the iteration will fail with what may be unexpected results.</p>
<p>For example (depends on what type of list):</p>
<pre><code>for tup in somelist[:]:
    etc....
</code></pre>
<p>An example:</p>
<pre><code>&gt;&gt;&gt; somelist = range(10)
&gt;&gt;&gt; for x in somelist:
...     somelist.remove(x)
&gt;&gt;&gt; somelist
[1, 3, 5, 7, 9]

&gt;&gt;&gt; somelist = range(10)
&gt;&gt;&gt; for x in somelist[:]:
...     somelist.remove(x)
&gt;&gt;&gt; somelist
[]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>for i in range(len(somelist) - 1, -1, -1):
    if some_condition(somelist, i):
        del somelist[i]
</code></pre>
<p>You need to go backwards otherwise it's a bit like sawing off the tree-branch that you are sitting on :-)</p>
<p>Python 2 users: replace <code>range</code> by <code>xrange</code> to avoid creating a hardcoded list</p>
</div>
<div class="post-text" itemprop="text">
<p>Your best approach for such an example would be a <a href="http://docs.python.org/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a></p>
<pre><code>somelist = [tup for tup in somelist if determine(tup)]
</code></pre>
<p>In cases where you're doing something more complex than calling a <code>determine</code> function, I prefer constructing a new list and simply appending to it as I go.  For example</p>
<pre><code>newlist = []
for tup in somelist:
    # lots of code here, possibly setting things up for calling determine
    if determine(tup):
        newlist.append(tup)
somelist = newlist
</code></pre>
<p>Copying the list using <code>remove</code> might make your code look a little cleaner, as described in one of the answers below.  You should definitely not do this for extremely large lists, since this involves first copying the entire list, and also performing an <code>O(n)</code> <code>remove</code> operation for each element being removed, making this an <code>O(n^2)</code> algorithm.</p>
<pre><code>for tup in somelist[:]:
    # lots of code here, possibly setting things up for calling determine
    if determine(tup):
        newlist.append(tup)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>The <a href="https://docs.python.org/2/tutorial/controlflow.html#for-statements" rel="nofollow noreferrer">official Python 2 tutorial 4.2. "for Statements"</a> says</strong>:</p>
<blockquote>
<p>If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy. The slice notation makes this especially convenient:</p>
<pre><code>&gt;&gt;&gt; for w in words[:]:  # Loop over a slice copy of the entire list.
...     if len(w) &gt; 6:
...         words.insert(0, w)
...
&gt;&gt;&gt; words
['defenestrate', 'cat', 'window', 'defenestrate']
</code></pre>
</blockquote>
<p>which is what was suggested at: <a href="https://stackoverflow.com/a/1207427/895245">https://stackoverflow.com/a/1207427/895245</a></p>
<p><strong>The <a href="https://docs.python.org/2/reference/compound_stmts.html#for" rel="nofollow noreferrer">Python 2 documentation 7.3. "The for statement"</a> gives the same advice</strong>:</p>
<blockquote>
<p>Note: There is a subtlety when the sequence is being modified by the loop (this can only occur for mutable sequences, i.e. lists). An internal counter is used to keep track of which item is used next, and this is incremented on each iteration. When this counter has reached the length of the sequence the loop terminates. This means that if the suite deletes the current (or a previous) item from the sequence, the next item will be skipped (since it gets the index of the current item which has already been treated). Likewise, if the suite inserts an item in the sequence before the current item, the current item will be treated again the next time through the loop. This can lead to nasty bugs that can be avoided by making a temporary copy using a slice of the whole sequence, e.g.,</p>
<pre><code>for x in a[:]:
    if x &lt; 0: a.remove(x)
</code></pre>
</blockquote>
<p>However, I find it is questionable if this is good advice, since <code>.remove()</code> has to iterate the <em>entire list</em> to find the value.</p>
<p>Instead, I recommend either:</p>
<ul>
<li>start a new array from scratch, and <code>.append()</code> back at the end: <a href="https://stackoverflow.com/a/1207460/895245">https://stackoverflow.com/a/1207460/895245</a> which is more time efficient</li>
<li>use <code>del</code>: <a href="https://stackoverflow.com/a/1207485/895245">https://stackoverflow.com/a/1207485/895245</a> which is more space efficient</li>
</ul>
<p>Since CPython lists <a href="https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented">are implemented with dynamic arrays</a>, those two options present a time / space tradeoff. Generally you just want to go for the faster <code>.append()</code> option by default unless memory is a big concern.</p>
<p><strong>Could Python do this better?</strong></p>
<p>It seems like this particular Python API could be improved. Compare it, for instance, with its Java counterpart <a href="https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html" rel="nofollow noreferrer">ListIterator</a>, which makes it crystal clear that you cannot modify a list being iterated except with the iterator itself, and gives you efficient ways to do so without copying the list.</p>
<p>Perhaps the underlying rationale is that Python lists are assumed to be dynamic array backed, and therefore any type of removal will be time inefficient anyways.</p>
<p>There doesn't seem to be an explicit linked list type in the stdlib either: <a href="https://stackoverflow.com/questions/280243/python-linked-list/280286">Python Linked List</a></p>
</div>
<div class="post-text" itemprop="text">
<p>For those that like functional programming:</p>
<pre><code>somelist[:] = filter(lambda tup: not determine(tup), somelist)
</code></pre>
<p>or</p>
<pre><code>from itertools import ifilterfalse
somelist[:] = list(ifilterfalse(determine, somelist))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It might be smart to also just create a new list if the current list item meets the desired criteria. </p>
<p>so:</p>
<pre><code>for item in originalList:
   if (item != badValue):
        newList.append(item)
</code></pre>
<p>and to avoid having to re-code the entire project with the new lists name:</p>
<pre><code>originalList[:] = newList
</code></pre>
<p>note, from Python documentation: </p>
<blockquote>
<p>copy.copy(x) 
  Return a shallow copy of x.</p>
<p>copy.deepcopy(x) 
  Return a deep copy of x.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I needed to do this with a huge list, and duplicating the list seemed expensive, especially since in my case the number of deletions would be few compared to the items that remain. I took this low-level approach.</p>
<pre><code>array = [lots of stuff]
arraySize = len(array)
i = 0
while i &lt; arraySize:
    if someTest(array[i]):
        del array[i]
        arraySize -= 1
    else:
        i += 1
</code></pre>
<p>What I don't know is how efficient a couple of deletes are compared to copying a large list. Please comment if you have any insight.</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer was originally written in response to a question which has since been marked as duplicate:
<a href="https://stackoverflow.com/questions/40175149/removing-coordinates-from-list-on-python">Removing coordinates from list on python</a></p>
<p>There are two problems in your code:</p>
<p>1) When using remove(), you attempt to remove integers whereas you need to remove a tuple.</p>
<p>2) The for loop will skip items in your list.</p>
<p>Let's run through what happens when we execute your code:</p>
<pre><code>&gt;&gt;&gt; L1 = [(1,2), (5,6), (-1,-2), (1,-2)]
&gt;&gt;&gt; for (a,b) in L1:
...   if a &lt; 0 or b &lt; 0:
...     L1.remove(a,b)
... 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 3, in &lt;module&gt;
TypeError: remove() takes exactly one argument (2 given)
</code></pre>
<p>The first problem is that you are passing both 'a' and 'b' to remove(), but remove() only accepts a single argument. So how can we get remove() to work properly with your list? We need to figure out what each element of your list is. In this case, each one is a tuple. To see this, let's access one element of the list (indexing starts at 0):</p>
<pre><code>&gt;&gt;&gt; L1[1]
(5, 6)
&gt;&gt;&gt; type(L1[1])
&lt;type 'tuple'&gt;
</code></pre>
<p>Aha! Each element of L1 is actually a tuple. So that's what we need to be passing to remove(). Tuples in python are very easy, they're simply made by enclosing values in parentheses. "a, b" is not a tuple, but "(a, b)" is a tuple. So we modify your code and run it again:</p>
<pre><code># The remove line now includes an extra "()" to make a tuple out of "a,b"
L1.remove((a,b))
</code></pre>
<p>This code runs without any error, but let's look at the list it outputs: </p>
<pre><code>L1 is now: [(1, 2), (5, 6), (1, -2)]
</code></pre>
<p>Why is (1,-2) still in your list? It turns out modifying the list while using a loop to iterate over it is a very bad idea without special care. The reason that (1, -2) remains in the list is that the locations of each item within the list changed between iterations of the for loop. Let's look at what happens if we feed the above code a longer list:</p>
<pre><code>L1 = [(1,2),(5,6),(-1,-2),(1,-2),(3,4),(5,7),(-4,4),(2,1),(-3,-3),(5,-1),(0,6)]
### Outputs:
L1 is now: [(1, 2), (5, 6), (1, -2), (3, 4), (5, 7), (2, 1), (5, -1), (0, 6)]
</code></pre>
<p>As you can infer from that result, every time that the conditional statement evaluates to true and a list item is removed, the next iteration of the loop will skip evaluation of the next item in the list because its values are now located at different indices.</p>
<p>The most intuitive solution is to copy the list, then iterate over the original list and only modify the copy. You can try doing so like this:</p>
<pre><code>L2 = L1
for (a,b) in L1:
    if a &lt; 0 or b &lt; 0 :
        L2.remove((a,b))
# Now, remove the original copy of L1 and replace with L2
print L2 is L1
del L1
L1 = L2; del L2
print ("L1 is now: ", L1)
</code></pre>
<p>However, the output will be identical to before:</p>
<pre><code>'L1 is now: ', [(1, 2), (5, 6), (1, -2), (3, 4), (5, 7), (2, 1), (5, -1), (0, 6)]
</code></pre>
<p>This is because when we created L2, python did not actually create a new object. Instead, it merely referenced L2 to the same object as L1. We can verify this with 'is' which is different from merely "equals" (==).</p>
<pre><code>&gt;&gt;&gt; L2=L1
&gt;&gt;&gt; L1 is L2
True
</code></pre>
<p>We can make a true copy using copy.copy(). Then everything works as expected:</p>
<pre><code>import copy
L1 = [(1,2), (5,6),(-1,-2), (1,-2),(3,4),(5,7),(-4,4),(2,1),(-3,-3),(5,-1),(0,6)]
L2 = copy.copy(L1)
for (a,b) in L1:
    if a &lt; 0 or b &lt; 0 :
        L2.remove((a,b))
# Now, remove the original copy of L1 and replace with L2
del L1
L1 = L2; del L2
&gt;&gt;&gt; L1 is now: [(1, 2), (5, 6), (3, 4), (5, 7), (2, 1), (0, 6)]
</code></pre>
<p>Finally, there is one cleaner solution than having to make an entirely new copy of L1. The reversed() function:</p>
<pre><code>L1 = [(1,2), (5,6),(-1,-2), (1,-2),(3,4),(5,7),(-4,4),(2,1),(-3,-3),(5,-1),(0,6)]
for (a,b) in reversed(L1):
    if a &lt; 0 or b &lt; 0 :
        L1.remove((a,b))
print ("L1 is now: ", L1)
&gt;&gt;&gt; L1 is now: [(1, 2), (5, 6), (3, 4), (5, 7), (2, 1), (0, 6)]
</code></pre>
<p>Unfortunately, I cannot adequately describe how reversed() works. It returns a 'listreverseiterator' object when a list is passed to it. For practical purposes, you can think of it as creating a reversed copy of its argument. This is the solution I recommend.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to do anything else during the iteration, it may be nice to get both the index (which guarantees you being able to reference it, for example if you have a list of dicts) and the actual list item contents.</p>
<pre><code>inlist = [{'field1':10, 'field2':20}, {'field1':30, 'field2':15}]    
for idx, i in enumerate(inlist):
    do some stuff with i['field1']
    if somecondition:
        xlist.append(idx)
for i in reversed(xlist): del inlist[i]
</code></pre>
<p><code>enumerate</code> gives you access to the item and the index at once. <code>reversed</code> is so that the indices that you're going to later delete don't change on you. </p>
</div>
<div class="post-text" itemprop="text">
<p>You might want to use <code>filter()</code> available as the built-in.</p>
<p>For more details <a href="http://docs.python.org/library/functions.html#filter" rel="nofollow noreferrer">check here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can try for-looping in reverse so for some_list you'll do something like:</p>
<pre><code>list_len = len(some_list)
for i in range(list_len):
    reverse_i = list_len - 1 - i
    cur = some_list[reverse_i]

    # some logic with cur element

    if some_condition:
        some_list.pop(reverse_i)
</code></pre>
<p>This way the index is aligned and doesn't suffer from the list updates (regardless whether you pop cur element or not).</p>
</div>
<div class="post-text" itemprop="text">
<p>One possible solution, useful if you want not only remove some things, but also do something with all elements in a single loop:</p>
<pre><code>alist = ['good', 'bad', 'good', 'bad', 'good']
i = 0
for x in alist[:]:
    if x == 'bad':
        alist.pop(i)
        i -= 1
    # do something cool with x or just print x
    print(x)
    i += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I needed to do something similar and in my case the problem was memory - I needed to merge multiple dataset objects within a list, after doing some stuff with them, as a new object, and needed to get rid of each entry I was merging to avoid duplicating all of them and blowing up memory. In my case having the objects in a dictionary instead of a list worked fine:</p>
<p>```</p>
<pre><code>k = range(5)
v = ['a','b','c','d','e']
d = {key:val for key,val in zip(k, v)}

print d
for i in range(5):
    print d[i]
    d.pop(i)
print d
</code></pre>
<p>```</p>
</div>
<div class="post-text" itemprop="text">
<p>TLDR:</p>
<p>I wrote a library that allows you to do this:</p>
<pre><code>from fluidIter import FluidIterable
fSomeList = FluidIterable(someList)  
for tup in fSomeList:
    if determine(tup):
        # remove 'tup' without "breaking" the iteration
        fSomeList.remove(tup)
        # tup has also been removed from 'someList'
        # as well as 'fSomeList'
</code></pre>
<p>It's best to use another method if possible that doesn't require modifying your iterable while iterating over it, but for some algorithms it might not be that straight forward. And so if you are sure that you really do want the code pattern described in the original question, it is possible.</p>
<p>Should work on all mutable sequences not just lists.</p>
<hr/>
<p>Full answer:</p>
<p>Edit: The last code example in this answer gives a use case for <strong><em>why</em></strong> you might sometimes want to modify a list in place rather than use a list comprehension. The first part of the answers serves as tutorial of <strong><em>how</em></strong> an array can be modified in place.</p>
<p>The solution follows on from <a href="https://stackoverflow.com/a/6260097/4451578">this</a> answer (for a related question) from senderle. Which explains how the the array index is updated while iterating through a list that has been modified. The solution below is designed to correctly track the array index even if the list is modified.</p>
<p>Download <code>fluidIter.py</code> from <a href="https://github.com/alanbacon/FluidIterator" rel="nofollow noreferrer">here</a> <code>https://github.com/alanbacon/FluidIterator</code>, it is just a single file so no need to install git. There is no installer so you will need to make sure that the file is in the python path your self. The code has been written for python 3 and is untested on python 2.</p>
<pre><code>from fluidIter import FluidIterable
l = [0,1,2,3,4,5,6,7,8]  
fluidL = FluidIterable(l)                       
for i in fluidL:
    print('initial state of list on this iteration: ' + str(fluidL)) 
    print('current iteration value: ' + str(i))
    print('popped value: ' + str(fluidL.pop(2)))
    print(' ')

print('Final List Value: ' + str(l))
</code></pre>
<p>This will produce the following output:</p>
<pre><code>initial state of list on this iteration: [0, 1, 2, 3, 4, 5, 6, 7, 8]
current iteration value: 0
popped value: 2

initial state of list on this iteration: [0, 1, 3, 4, 5, 6, 7, 8]
current iteration value: 1
popped value: 3

initial state of list on this iteration: [0, 1, 4, 5, 6, 7, 8]
current iteration value: 4
popped value: 4

initial state of list on this iteration: [0, 1, 5, 6, 7, 8]
current iteration value: 5
popped value: 5

initial state of list on this iteration: [0, 1, 6, 7, 8]
current iteration value: 6
popped value: 6

initial state of list on this iteration: [0, 1, 7, 8]
current iteration value: 7
popped value: 7

initial state of list on this iteration: [0, 1, 8]
current iteration value: 8
popped value: 8

Final List Value: [0, 1]
</code></pre>
<p>Above we have used the <code>pop</code> method on the fluid list object. Other common iterable methods are also implemented such as <code>del fluidL[i]</code>, <code>.remove</code>, <code>.insert</code>, <code>.append</code>, <code>.extend</code>. The list can also be modified using slices (<code>sort</code> and <code>reverse</code> methods are not implemented).</p>
<p>The only condition is that you must only modify the list in place, if at any point <code>fluidL</code> or <code>l</code> were reassigned to a different list object the code would not work. The original <code>fluidL</code> object would still be used by the for loop but would become out of scope for us to modify.</p>
<p>i.e.</p>
<pre><code>fluidL[2] = 'a'   # is OK
fluidL = [0, 1, 'a', 3, 4, 5, 6, 7, 8]  # is not OK
</code></pre>
<p>If we want to access the current index value of the list we cannot use enumerate, as this only counts how many times the for loop has run. Instead we will use the iterator object directly.</p>
<pre><code>fluidArr = FluidIterable([0,1,2,3])
# get iterator first so can query the current index
fluidArrIter = fluidArr.__iter__()
for i, v in enumerate(fluidArrIter):
    print('enum: ', i)
    print('current val: ', v)
    print('current ind: ', fluidArrIter.currentIndex)
    print(fluidArr)
    fluidArr.insert(0,'a')
    print(' ')

print('Final List Value: ' + str(fluidArr))
</code></pre>
<p>This will output the following:</p>
<pre><code>enum:  0
current val:  0
current ind:  0
[0, 1, 2, 3]

enum:  1
current val:  1
current ind:  2
['a', 0, 1, 2, 3]

enum:  2
current val:  2
current ind:  4
['a', 'a', 0, 1, 2, 3]

enum:  3
current val:  3
current ind:  6
['a', 'a', 'a', 0, 1, 2, 3]

Final List Value: ['a', 'a', 'a', 'a', 0, 1, 2, 3]
</code></pre>
<p>The <code>FluidIterable</code> class just provides a wrapper for the original list object. The original object can be accessed as a property of the fluid object like so:</p>
<pre><code>originalList = fluidArr.fixedIterable
</code></pre>
<p>More examples / tests can be found in the <code>if __name__ is "__main__":</code> section at the bottom of <code>fluidIter.py</code>. These are worth looking at because they explain what happens in various situations. Such as: Replacing a large sections of the list using a slice. Or using (and modifying) the same iterable in nested for loops.</p>
<p>As I stated to start with: this is a complicated solution that will hurt the readability of your code and make it more difficult to debug. Therefore other solutions such as the list comprehensions mentioned in David Raznick's <a href="https://stackoverflow.com/a/1207461/4451578">answer</a> should be considered first. That being said, I have found times where this class has been useful to me and has been easier to use than keeping track of the indices of elements that need deleting.</p>
<hr/>
<p>Edit: As mentioned in the comments, this answer does not really present a problem for which this approach provides a solution. I will try to address that here:</p>
<p>List comprehensions provide a way to generate a new list but these approaches tend to look at each element in isolation rather than the current state of the list as a whole.</p>
<p>i.e.</p>
<pre><code>newList = [i for i in oldList if testFunc(i)]
</code></pre>
<p>But what if the result of the <code>testFunc</code> depends on the elements that have been added to <code>newList</code> already? Or the elements still in <code>oldList</code> that might be added next? There might still be a way to use a list comprehension but it will begin to lose it's elegance, and for me it feels easier to modify a list in place.</p>
<p>The code below is one example of an algorithm that suffers from the above problem. The algorithm will reduce a list so that no element is a multiple of any other element.</p>
<pre><code>randInts = [70, 20, 61, 80, 54, 18, 7, 18, 55, 9]
fRandInts = FluidIterable(randInts)
fRandIntsIter = fRandInts.__iter__()
# for each value in the list (outer loop)
# test against every other value in the list (inner loop)
for i in fRandIntsIter:
    print(' ')
    print('outer val: ', i)
    innerIntsIter = fRandInts.__iter__()
    for j in innerIntsIter:
        innerIndex = innerIntsIter.currentIndex
        # skip the element that the outloop is currently on
        # because we don't want to test a value against itself
        if not innerIndex == fRandIntsIter.currentIndex:
            # if the test element, j, is a multiple 
            # of the reference element, i, then remove 'j'
            if j%i == 0:
                print('remove val: ', j)
                # remove element in place, without breaking the
                # iteration of either loop
                del fRandInts[innerIndex]
            # end if multiple, then remove
        # end if not the same value as outer loop
    # end inner loop
# end outerloop

print('')
print('final list: ', randInts)
</code></pre>
<p>The output and the final reduced list are shown below</p>
<pre><code>outer val:  70

outer val:  20
remove val:  80

outer val:  61

outer val:  54

outer val:  18
remove val:  54
remove val:  18

outer val:  7
remove val:  70

outer val:  55

outer val:  9
remove val:  18

final list:  [20, 61, 7, 55, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The other answers are correct that it is usually a bad idea to delete from a list that you're iterating. Reverse iterating avoids the pitfalls, but it is much more difficult to follow code that does that, so usually you're better off using a list comprehension or <code>filter</code>.</p>
<p>There is, however, one case where it is safe to remove elements from a sequence that you are iterating: if you're only removing one item while you're iterating. This can be ensured using a <code>return</code> or a <code>break</code>. For example:</p>
<pre><code>for i, item in enumerate(lst):
    if item % 4 == 0:
        foo(item)
        del lst[i]
        break
</code></pre>
<p>This is often easier to understand than a list comprehension when you're doing some operations with side effects on the first item in a list that meets some condition and then removing that item from the list immediately after.</p>
</div>
<div class="post-text" itemprop="text">
<p>Most of the answers here want you to create a copy of the list. I had a use case where the list was quite long (110K items) and it was smarter to keep reducing the list instead.</p>
<p>First of all you'll need to <strong>replace foreach loop with while loop</strong>,</p>
<pre><code>i = 0
while i &lt; len(somelist):
    if determine(somelist[i]):
         del somelist[i]
    else:
        i += 1
</code></pre>
<p>The value of <code>i</code> is not changed in the if block because you'll want to get value of the new item FROM THE SAME INDEX, once the old item is deleted.</p>
</div>
<div class="post-text" itemprop="text">
<p>The most effective method is list comprehension, many people show their case, of course, it is also a good way to get an <code>iterator</code> through <code>filter</code>.</p>
<blockquote>
<p><code>Filter</code> receives a function and a sequence. <code>Filter</code> applies the passed function to each element in turn, and then decides whether to retain or discard the element depending on whether the function return value is <code>True</code> or <code>False</code>.</p>
</blockquote>
<p>There is an example  (get the odds in the tuple):</p>
<pre><code>list(filter(lambda x:x%2==1, (1, 2, 4, 5, 6, 9, 10, 15)))  
# result: [1, 5, 9, 15]
</code></pre>
<p><strong>Caution: You can also not handle iterators. Iterators are sometimes better than sequences.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>I can think of three approaches to solve your problem. As an example, I will create a random list of tuples <code>somelist = [(1,2,3), (4,5,6), (3,6,6), (7,8,9), (15,0,0), (10,11,12)]</code>. The condition that I choose is <code>sum of elements of a tuple = 15</code>. In the final list we will only have those tuples whose sum is not equal to 15. </p>
<p><em>What I have chosen is a randomly chosen example. <strong>Feel free to change</strong> the <strong>list of tuples</strong> and the <strong>condition</strong> that I have chosen.</em> </p>
<p><strong>Method 1.&gt;</strong> Use the framework that you had suggested (where one fills in a code inside a for loop). I use a small code with <code>del</code> to delete a tuple that meets the said condition. However, this method will miss a tuple (which satisfies the said condition) if two consecutively placed tuples meet the given condition. </p>
<pre><code>for tup in somelist:
    if ( sum(tup)==15 ): 
        del somelist[somelist.index(tup)]

print somelist
&gt;&gt;&gt; [(1, 2, 3), (3, 6, 6), (7, 8, 9), (10, 11, 12)]
</code></pre>
<p><strong>Method 2.&gt;</strong> Construct a new list which contains elements (tuples) where the given condition is not met (this is the same thing as removing elements of list where the given condition is met). Following is the code for that:</p>
<pre><code>newlist1 = [somelist[tup] for tup in range(len(somelist)) if(sum(somelist[tup])!=15)]

print newlist1
&gt;&gt;&gt;[(1, 2, 3), (7, 8, 9), (10, 11, 12)]
</code></pre>
<p><strong>Method 3.&gt;</strong> Find indices where the given condition is met, and then use remove elements (tuples) corresponding to those indices. Following is the code for that.</p>
<pre><code>indices = [i for i in range(len(somelist)) if(sum(somelist[i])==15)]
newlist2 = [tup for j, tup in enumerate(somelist) if j not in indices]

print newlist2
&gt;&gt;&gt;[(1, 2, 3), (7, 8, 9), (10, 11, 12)]
</code></pre>
<p><strong>Method 1 and method 2 are faster than method 3</strong>. Method2 and method3 are more efficient than method1. I <strong>prefer method2</strong>. For the aforementioned example, <code>time(method1) : time(method2) : time(method3) = 1 : 1 : 1.7</code></p>
</div>
<div class="post-text" itemprop="text">
<p>For anything that has the potential to be really big, I use the following. </p>
<pre><code>import numpy as np

orig_list = np.array([1, 2, 3, 4, 5, 100, 8, 13])

remove_me = [100, 1]

cleaned = np.delete(orig_list, remove_me)
print(cleaned)
</code></pre>
<p>That should be significantly faster than anything else. </p>
</div>
<div class="post-text" itemprop="text">
<p>In some situations, where you're doing more than simply filtering a list one item at time, you want your iteration to change while iterating.</p>
<p>Here is an example where copying the list beforehand is incorrect, reverse iteration is impossible and a list comprehension is also not an option.</p>
<pre><code>""" Sieve of Eratosthenes """

def generate_primes(n):
    """ Generates all primes less than n. """
    primes = list(range(2,n))
    idx = 0
    while idx &lt; len(primes):
        p = primes[idx]
        for multiple in range(p+p, n, p):
            try:
                primes.remove(multiple)
            except ValueError:
                pass #EAFP
        idx += 1
        yield p
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Right away you want to create a copy of the list so you can have that as a reference when you are iterating through and deleting tuples in that list that meet a certain criteria.</p>
<p>Then it depends on what type of list you want for the output whether that be a list of the removed tuples or a list of the tuples that are not removed.</p>
<p>As David pointed out, I recommend list comprehension to keep the elements you don't want to remove.</p>
<pre><code>somelist = [x for x in somelist if not determine(x)]
</code></pre>
</div>
<span class="comment-copy">Can you make it faster if you know only a few will be deleted, i.e., only delete those and leave the others in-place rather than re-writing them?</span>
<span class="comment-copy">What if my list is huge and can't afford making a copy?</span>
<span class="comment-copy">@jpcgt You should use <code>somelist[:] = (x for x in somelist if determine(x))</code> this will create generator that may not create any unnecessary copies.</span>
<span class="comment-copy">@RostislavKondratenko: <code>list_ass_slice()</code> function that implements <code>somelist[:]=</code> calls <a href="https://docs.python.org/3/c-api/sequence.html#c.PySequence_Fast" rel="nofollow noreferrer"><code>PySequence_Fast()</code></a> internally. This function always returns a list i.e., <a href="http://stackoverflow.com/a/1208792/4279">@Alex Martelli's solution that already uses a list instead of a generator is most probably more efficient</a></span>
<span class="comment-copy">@CrazyGeek: What do you mean doesn't work?</span>
<span class="comment-copy">How do I do the same sliced assignment with a dict? In Python 2.6?</span>
<span class="comment-copy">@Paul: Since dicts are unordered, slices are meaningless for dicts.  If your want to replace the contents of dict <code>a</code> by the contents of dict <code>b</code>, use <code>a.clear(); a.update(b)</code>.</span>
<span class="comment-copy">Why can 'reseating' one of the references by replacing what the variable refers to cause bugs?  It seems like that would only be a potential problem in multi-threaded applications, not single-threaded.</span>
<span class="comment-copy">@Derek <code>x = ['foo','bar','baz']; y = x; x = [item for item in x if determine(item)];</code> This reassigns <code>x</code> to the result of the list comprehension, but <code>y</code> still refers to the <i>original</i> list <code>['foo','bar','baz']</code>. If you expected <code>x</code> and <code>y</code> to refer to the same list, you may have introduced bugs. You prevent this by assigning to a slice of the entire list, as Alex shows, and I show here: <code>x = ["foo","bar","baz"]; y = x; x[:] = [item for item in x if determine(item)];</code>. The list is modified in place. ensuring that all references to the list (both <code>x</code> and <code>y</code> here) refer to the new list.</span>
<span class="comment-copy">Again Alex to the rescue. He is a machine indeed.</span>
<span class="comment-copy">Zen #3, Simple is better than complex. Gets my vote!</span>
<span class="comment-copy">why the second one works?</span>
<span class="comment-copy">@Zen Because the second one iterates over a copy of the list. So when you modify the original list, you do not modify the copy that you iterate over.</span>
<span class="comment-copy">What's better in doing somelist[:] compared to list(somelist) ?</span>
<span class="comment-copy">Note to anyone reading this, this is VERY slow for lists. <code>remove()</code> has to go over the WHOLE list for every iteration, so it will take forever.</span>
<span class="comment-copy">In recent versions of Python, you can do this even more cleanly by using the <code>reversed()</code> builtin</span>
<span class="comment-copy">reversed() does not create a new list, it creates a reverse iterator over the supplied sequence. Like enumerate(), you have to wrap it in list() to actually get a list out of it.  You may be thinking of sorted(), which <i>does</i> create a new list every time (it has to, so it can sort it).</span>
<span class="comment-copy">@Mauris because <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> returns an iterator and <a href="https://docs.python.org/2/library/functions.html#reversed" rel="nofollow noreferrer"><code>reversed</code></a> expects a sequence. I guess you could do <code>reversed(list(enumerate(somelist)))</code> if you don't mind creating an extra list in memory.</span>
<span class="comment-copy">@SamWatkins Yeah, this answer is for when you're removing a couple of elements from a very large array. Less memory usage, but it can be <code>m</code> times slower.</span>
<span class="comment-copy">Note that in Python 3 <code>xrange</code> was renamed to <code>range</code>.</span>
<span class="comment-copy">1. List comprehension and generator expressions are borrowed from Haskell, a pure functional language; they're exactly as functional as <code>filter</code>, and more Pythonic. 2. If you need a <code>lambda</code> to use <code>map</code> or <code>filter</code>, the list comp or genexpr is <i>always</i> the better option; <code>map</code> and <code>filter</code> can be slightly faster when the transform/predicate function is a Python built-in implemented in C and the iterable is not trivially small, but they're always slower when you need a <code>lambda</code> that the listcomp/genexpr could avoid.</span>
<span class="comment-copy">This adds no new information that wasn't in the accepted answer years earlier.</span>
<span class="comment-copy">It's simple and just another way to look at a problem @MarkAmery. It's less condensed for those people that don't like compressed coding syntax.</span>
<span class="comment-copy"><code>originalList[:] = newList[:]</code> is silly. Unless you are planning to use <code>newList</code> after, you just needlessly shallow copied it. <code>originalList[:] = newList</code> would work just fine and save an extra round of copying.</span>
<span class="comment-copy">I am never good at remembering the different syntax in shallow vs. deep copy. Thank you for reminding me I've mixed it up again @ShadowRanger :). I've updated my response with a more thorough explanation.</span>
<span class="comment-copy">In my case I need to move those 'unwanted' elements into another list. Do you have any new comment about this solution? I also think that it is better to use some deletions instead of duplicate the list.</span>
<span class="comment-copy">This is the right answer if performance is an issue (although same as @Alexey). That said, the choice of <code>list</code> as a data structure in the first place should be carefully considered since removal from the middle of a list takes linear time in the length of the list. If you don't really need random access to k-th sequential item, maybe consider <code>OrderedDict</code>?</span>
<span class="comment-copy">@GVelascoh why not create <code>newlist = []</code>, and then <code>newlist.append(array[i])</code> just before <code>del array[i]</code>?</span>
<span class="comment-copy">Note that this is likely time inefficient: if <code>list()</code> is a linked list, the random access is expensive, if <code>list()</code> is an array, the deletes are expensive because they require to move all following elements forward. A decent iterator could make things good for the linked list implementation. This could however be space efficient.</span>
<span class="comment-copy">Why is getting the index any more relevant in the case where you have a list of dicts than in the case of any other kind of list? This doesn't make sense as far as I can tell.</span>
<span class="comment-copy">Looping over <code>reversed(list(enumerate(some_list)))</code> would be simpler than computing indexes yourself.</span>
<span class="comment-copy">@MarkAmery don't think you can alter the list this way.</span>
<span class="comment-copy">You should really just use comprehensions. They're much easier to understand.</span>
<span class="comment-copy">What if I want to remove <code>bad</code> things, do something with it and also do something with <code>good</code> things in one loop?</span>
<span class="comment-copy">Actually, I realized there's some cleverness here in that you make a copy of the list with an open slice (<code>alist[:]</code>) And since you might be doing something fancy, it actually has a use case. Good revision is good. Take my upvote.</span>
<span class="comment-copy">It's hard to tell whether this is over-engineered because it's unclear what problem it's trying to solve; what does removing elements using this approach achieve that <code>some_list[:] = [x for x in some_list if not some_condition(x)]</code> doesn't achieve? Without an answer to that, why should anyone believe that downloading and using your 600-line library complete with typos and commented-out code is a better solution to their problem than the one-liner? -1.</span>
<span class="comment-copy">@MarkAmery. The main use case for when this is when trying to determine if an item should be removed (or added or moved) based not on just the item itself, but on the state of another item in the list or the state of the list as a whole. For example, it is not possible with list comprehensions to write something like <code>some_list[:] = [x for x in some_list if not some_condition(y)]</code> where <code>y</code> is a different list element from <code>x</code>. Nor would it be possible to write <code>some_list[:] = [x for x in some_list if not some_condition(intermediateStateOf_some_list)]</code>.</span>
