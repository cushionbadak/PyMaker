<div class="post-text" itemprop="text">
<p>I've got a big txt file. Each line looks like this:  </p>
<pre><code>1. 27.01.1957 8,12,31,39,43,45  
2. 03.02.1957 5,10,11,22,25,27  
3. 10.02.1957 18,19,20,26,45,49  
4. 17.02.1957 2,11,14,37,40,45  
5. 24.02.1957 8,10,15,35,39,49  
6. 03.03.1957 24,26,31,35,43,47  
7. 10.03.1957 13,20,23,29,38,44
</code></pre>
<p>I would like to to create a list of list which one line in each list.<br/>
How can I do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the file is truly <em>big</em>, you might want to use a generator to keep memory usage down:</p>
<pre><code>def read_lines_from_big_file(path):
    with open(path) as fp:
        for line in fp:
            parts = line.split()
            yield parts  # -&gt; ['1.', '27.01.1957', '8,12,31,39,43,45']

for split_line in read_lines_from_big_file(path):
    # do something with split_line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To get a lists of lists where each sublist is literally a string that represents each of your file lines you can do this:</p>
<pre><code>data = [];
with open("big_file.txt", 'r') as f:
    for line  in f:
        data.append([line.strip()])
</code></pre>
<p>Here the program reads the file line by line and appends each line from the file as a sublist to the list <code>data</code>.</p>
<p>Alternatively, if you want to have each space-separated element in the sublist as a separate element, use <code>split()</code> in the appending line instead,</p>
<pre><code>data.append(line.split())
</code></pre>
<p>which will split the components by spaces - remove the extra <code>[]</code> too as <code>split()</code> will return sublists anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can define your own delimiters to split your strings by (or file lines in this case) with the module <code>re</code> <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">https://docs.python.org/3/library/re.html</a>. Using <code>with open()</code> means that the file link is closed after the <code>with open()</code> indent in your code has ended. </p>
<p>I use <code>list comprehension</code> here because it's slightly faster than a for loop to construct lists</p>
<pre><code>import re

def return_lines_split_by_choice(delimiters,path):
    re_pattern = '|'.join(map(re.escape,delimiters))
    with open(path) as file_handle:
        return [re.split(re_pattern,line.rstrip()) for line in file_handle]

my_list_of_lists = return_lines_split_by_choice((" ",","),my_filepath)
</code></pre>
<p>Just put your choice of delimiters, or things to split the lines by in here <code>(" ",",")</code></p>
<p>The result is:</p>
<pre><code>for sublist in my_list_of_lists:
    print (sublist)

['1.', '27.01.1957', '8', '12', '31', '39', '43', '45']
['2.', '03.02.1957', '5', '10', '11', '22', '25', '27']
['3.', '10.02.1957', '18', '19', '20', '26', '45', '49']
['4.', '17.02.1957', '2', '11', '14', '37', '40', '45']
['5.', '24.02.1957', '8', '10', '15', '35', '39', '49']
['6.', '03.03.1957', '24', '26', '31', '35', '43', '47']
['7.', '10.03.1957', '13', '20', '23', '29', '38', '44']
</code></pre>
<p>If you just want a list of lines use this function instead:</p>
<pre><code>def list_of_lines(path):
    with open(path) as file_handle:
        return [line.rstrip() for line in file_handle]
</code></pre>
<p>Just run it like this:</p>
<pre><code>my_list_of_lists = list_of_lines(my_filepath)
</code></pre>
<p>If your python program is in the same folder as your txt file then your filepath can just be the name of the file like so <code>"mytxt.txt"</code> else you can use the <code>os</code> module to normalize a filepath for your operating system</p>
</div>
<div class="post-text" itemprop="text">
<p>Learn to make your life much easier and don't use <code>with open</code>. Instead, <a href="https://stackoverflow.com/a/45464707/2437514">learn to use</a> the awesome <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib</code> package</a>. </p>
<p>Using the <code>pathlib.Path.read_text()</code> method, you can load your file into a list of strings, each of which is a line: </p>
<pre><code>import pathlib

text = pathlib.Path('myfile.txt').read_text()
</code></pre>
<p>To make that into into a list of lines, use the <code>split</code> method, splitting at each line break:</p>
<pre><code>lines = text.split('\n')
</code></pre>
<p>Almost there. Now you want to make your list of lists. I am a assuming you want each sublist to be made up of the things between the spaces and the commas. With that in mind, construct your list of lists like this: </p>
<pre><code>listoflists = []
for line in lines:
    listoflists.append(line.replace(',', ' ').split())
</code></pre>
<p>Finally, do it all in one go as follows:</p>
<pre><code>listoflists = [line.replace(",", " ").split() for line in pathlib.Path('myfile.txt').read_text().split("\n")]
</code></pre>
</div>
<span class="comment-copy">What form should the <code>list</code> of <code>list</code>s take? Three elements per line? More? Less? The input you give could validly produce many different outputs.</span>
<span class="comment-copy"><code>.strip().split()</code> is redundant; <code>.split()</code> (with no arguments only) already ignores leading and trailing whitespace.</span>
<span class="comment-copy">That doesn't seem easier than using <code>with</code> to me. Plus it reads the whole file in at once, which might not be suitable if the file is really big.</span>
<span class="comment-copy">@Wyatt irrelevant in this case. The entire file is going to be read into memory anyway. Might as well do it right away. My point here is to evangelize <code>pathlib</code> to a new user a bit, because it is SO MUCH BETTER than every other way of handling text and files.</span>
<span class="comment-copy">It's possible to avoid reading the whole file by using a generator. I agree that for simple cases (and relatively small amounts of data) <code>Path.read_text()</code> might be easier, but not in every case.</span>
