<div class="post-text" itemprop="text">
<p>I have several test cases and test functions, and the list of test cases is different for the different functions. This can be easily done with <code>pytest.mark.parametrize</code>. The extra need I have is to load a resource (a file in my case) and I'd like to have this file only loaded once per test session and cached.</p>
<p>Below an example illustrating what I want. It's working, but I would like to find a way to use pytest fixtures or some other caching mechanism so that I don't have to do the caching myself and have the <code>pars=load_file(pars)</code> line in each test function.</p>
<p>Can someone please explain how to do this with pytest?</p>
<pre><code>import pytest

case_1 = dict(label='case_1', spam=1)
case_2 = dict(label='case_2', spam=2)
case_3 = dict(label='case_3', spam=3)

_cache = {}


def load_file(pars):
    if pars['label'] in _cache:
        print('load_file from cache', pars)
        return _cache[pars['label']]
    else:
        print('load_file loading', pars)
        pars['file'] = pars['label'] + ' spam!'
        _cache[pars['label']] = pars
        return pars


@pytest.mark.parametrize('pars', [case_1, case_2])
def test_a(pars):
    pars = load_file(pars)
    print('test_a', pars)


@pytest.mark.parametrize('pars', [case_2, case_3])
def test_b(pars):
    pars = load_file(pars)
    print('test_b', pars)


@pytest.mark.parametrize('pars', [case1, case_2, case_3])
def test_c(pars):
    pars = load_file(pars)
    print('test_c', pars)

### more tests here for various combinations of test cases
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first and the obvious solution is to use the session-scoped fixtures. However, it requires restructuring the test file, and load all of the known files in advance.</p>
<pre><code>import pytest

@pytest.fixture(scope='session')
def pars_all():
   cache = {}
   for case in [case_1, case_2, case_3]:
       cache[case['label']] = 'case {} content'.format(case)

   yield cache

   # optionally destroy or unload or unlock here.

@pytest.fixture(scope='function')
def pars(request, pars_all):
    label = request.param
    yield pars_all[label]

@pytest.mark.parametrize('pars', ['case_1', 'case_2'], indirect=True)
def test(pars):
    pass
</code></pre>
<p>Please note the indirect parametrisation. It means that the <code>pars</code> fixture will be prepared instead, getting a parameter value in <code>request.param</code>. The parameter name and the fixture must share the same name.</p>
<p>The session-scoped fixture (or module-scoped, or class-scoped if you wish) will be prepared only once for all the tests. It is important to note that the wider-scoped fixtures can be used in the more narrow-scoped or same-scoped fixtures, but not in the opposite direction.</p>
<p>If the cases are not that well-defined, it is the same easy, just the cache is populated on demand:</p>
<pre><code>import pytest

@pytest.fixture(scope='session')
def pars_all():
    yield {}

@pytest.fixture(scope='function')
def pars(request, pars_all):
    label = request.param
    if label not in pars_all:
        print('[[[{}]]]'.format(request.param))
        pars_all[label] = 'content of {}'.format(label)
    yield pars_all[label]

@pytest.mark.parametrize('pars', ['case_1', 'case_2'], indirect=True)
def test_1(pars):
    print(pars)

@pytest.mark.parametrize('pars', ['case_1', 'case_3'], indirect=True)
def test_2(pars):
    print(pars)
</code></pre>
<p>Note, that the <code>{}</code> object is created only once, because it is session-scoped, and is shared among all tests &amp; callspecs. So, if one fixture adds something into it, other fixtures will see it too. You can notice that on how <code>case_1</code> is reused in the <code>test_2</code>:</p>
<pre><code>$ pytest -s -v -ra test_me.py 
======= test session starts ==========
...
collected 4 items                                                                                   

test_me.py::test_1[case_1] [[[case_1]]]
content of case_1
PASSED
test_me.py::test_1[case_2] [[[case_2]]]
content of case_2
PASSED
test_me.py::test_2[case_1] content of case_1
PASSED
test_me.py::test_2[case_3] [[[case_3]]]
content of case_3
PASSED

======== 4 passed in 0.01 seconds ==========
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple use of <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>@lru_cache</code></a> in your file parsing function can also do the caching trick:</p>
<pre><code>@lru_cache(maxsize=3)
def load_file(file_name):
    """ This function loads the file and returns contents"""
    print("loading file " + file_name)
    return "&lt;dummy content for " + file_name + "&gt;"
</code></pre>
<p>You can also reach the same result while making the whole code a bit more readable (?) by separating the test functions from the test cases with <a href="https://smarie.github.io/python-pytest-cases/" rel="nofollow noreferrer">pytest-cases</a> (I'm the author by the way!):</p>
<pre><code>from functools import lru_cache
from pytest_cases import CaseData, cases_data, CaseDataGetter, case_tags


@lru_cache(maxsize=3)
def load_file(file_name):
    """ This function loads the file and returns contents"""
    print("loading file " + file_name)
    return "&lt;dummy content for " + file_name + "&gt;"

def case_1() -&gt; CaseData:
    ins = load_file('file1')
    outs, err = None, None
    return ins, outs, err

def case_2() -&gt; CaseData:
    ins = load_file('file2')
    outs, err = None, None
    return ins, outs, err

def case_3() -&gt; CaseData:
    ins = load_file('file3')
    outs, err = None, None
    return ins, outs, err

@cases_data(cases=[case_1, case_2])
def test_a(case_data: CaseDataGetter):
    # 1- Grab the test case data
    i, expected_o, expected_e = case_data.get()

    # 2- Use it
    # see pytest-cases usage page for suggestions


@cases_data(cases=[case_2, case_3])
def test_b(case_data: CaseDataGetter):
    # 1- Grab the test case data
    i, expected_o, expected_e = case_data.get()

    # 2- Use it
    # see pytest-cases usage page for suggestions


@cases_data(cases=[case_1, case_2, case_3])
def test_c(case_data: CaseDataGetter):
    # 1- Grab the test case data
    i, expected_o, expected_e = case_data.get()

    # 2- Use it
    # see pytest-cases usage page for suggestions
</code></pre>
<p>Yields:</p>
<pre><code>test_memoize.py::test_a[case_1] loading file file1
PASSED
test_memoize.py::test_a[case_2] loading file file2
PASSED
test_memoize.py::test_b[case_2] PASSED
test_memoize.py::test_b[case_3] loading file file3
PASSED
test_memoize.py::test_c[case_1] PASSED
test_memoize.py::test_c[case_2] PASSED
test_memoize.py::test_c[case_3] PASSED
</code></pre>
<p>Finally note that depending on your use case you might wish to switch to a case generator function, that would be far more readable and <a href="https://smarie.github.io/python-pytest-cases/usage/advanced/#caching" rel="nofollow noreferrer">supports caching too</a>. Also look at <a href="https://smarie.github.io/python-pytest-cases/usage/intermediate/#storing-cases-with-different-purposes-in-the-same-file" rel="nofollow noreferrer">tags &amp; filters</a>, if you do not want to hardcode the cases explicitly.</p>
</div>
<span class="comment-copy">Hello, welcome to Stack Overflow! Please just note if you want to promote or recommend your own product/blog, there are some <a href="https://stackoverflow.com/help/promotion">guidelines in place</a> for doing so. Following them will help you avoid giving the impression that you're spamming. Could you please <a href="https://stackoverflow.com/posts/51199035/edit">edit</a> to explicitly state your affiliation? Thanks. (If you're not actually affiliated, it may be worth mentioning that as well.)</span>
