<div class="post-text" itemprop="text">
<p>I am trying to write a program that takes in a dictionary of frequencies and an integer, and returns a list of tuples containing all the words that appear more than min_times.</p>
<pre><code>def words_often(freqs, min_times):
tuple_list = []
for key in freqs:
    word_list = []
    if freqs[key] &gt; min_times:
        store_value = freqs[key]
        for key2 in freqs:
            if freqs[key2] == store_value:
                word_list += [key2]
    if freqs[key] not in tuple_list:
        tuple_list += [(word_list, store_value)]
return tuple_list


#test program
freqs = {'yeah':15, 'one': 1, 'crazy': 3, 'lonely': 1}

print(words_often(freqs, 0))
</code></pre>
<p>There's something wrong however, the return value for the test above, is :</p>
<pre><code>[([‘yeah’], 15), ([‘one’, ‘lonely’], 1), ([‘crazy’], 3), ([‘one’, ‘lonely’], 1)]
</code></pre>
<p>This return value shouldn't have the last entry, because it's a duplicate.</p>
<p>How can I make my code simpler, because a lot is going on and I can't determine the problem. </p>
<p>Edit: I need the words inside the tuples to be grouped in lists. For example the first entry should be (['yeah'], 15) and for words that have the same value (one and lonely), I need them to be grouped like (['one', 'lonely'], 1)</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you want to group keys by values, you could use <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>from itertools import groupby
data = {'yeah':15, 'one': 4, 'crazy': 3, 'lonely': 4}
min_times = 3

get_value = lambda kv: kv[1]
sorted_data = sorted(data.items(), key= get_value, reverse=True)
print(sorted_data)
# [('yeah', 15), ('one', 4), ('lonely', 4), ('crazy', 3)]


print([([v[0] for v in vs], k) for k,vs in groupby(sorted_data, key= get_value) if k &gt; min_times])
# [(['yeah'], 15), (['one', 'lonely'], 4)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">List comprehension</a> may make your code simpler. </p>
<pre><code>from collections import defaultdict

def words_often(freqs, min_times):
    words = [(key, freqs[key]) for key in freqs if freqs[key] &gt;= min_times]
    # words = [('yeah', 15), ('one', 1), ('crazy', 3), ('lonely', 1)]

    d = defaultdict(list)
    for word, freq in words:
        d[freq].append(word)
    # d = {15: ['yeah'], 1: ['one', 'lonely'], 3: ['crazy']}

    return [(d[freq], freq) for freq in d]

# Test
freqs = {'yeah':15, 'one': 1, 'crazy': 3, 'lonely': 1, 'zero':0}
print(words_often(freqs, 1))
# [(['yeah'], 15), (['one', 'lonely'], 1), (['crazy'], 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will return a <code>list</code> of <code>tuples</code> from a given <code>dict</code> if the value in the given <code>dict</code> is greater then the given minimum requirements:</p>
<pre><code>def convert(items, min):
    return [(key, items[key]) for key in items.iterkeys() if items[key] &gt; min]
</code></pre>
<p>For example, with your shown <code>dict</code>:</p>
<pre><code>freqs = {'yeah': 15, 'one': 1, 'crazy': 3, 'lonely': 1}
convert(freqs, 0)
# [('crazy', 3), ('lonely', 1), ('yeah', 15), ('one', 1)]
</code></pre>
<p>This basically does a <code>for loop</code> on a single line that is called a <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer"><code>list comprehension</code></a>. Read about them, they will save your life.</p>
<hr/>
<p>If you want the first value in the <code>tuple</code> to be a <code>list</code>, the simplest way would be to add <code>[]</code> around the insertion of the value:</p>
<pre><code>def convert(items, min):
    return [([key], items[key]) for key in items.iterkeys() if items[key] &gt; min]
</code></pre>
<p>And another example with your given <code>dict</code>:</p>
<pre><code>freqs = {'yeah': 15, 'one': 1, 'crazy': 3, 'lonely': 1}
convert(freqs, 0)
# [(['crazy'], 3), (['lonely'], 1), (['yeah'], 15), (['one'], 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>freqs = {'yeah':15, 'one': 1, 'crazy': 3, 'lonely': 1}
m = 0
from collections import defaultdict
def answer(d, m):
    out = defaultdict(list)
    for e, i in d.items():
        if i &gt; m:
            out[i].append(e)
    return [(e, i) for i, e in out.items()]
</code></pre>
<p>This will work.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use Pandas:</p>
<pre><code>import pandas as pd

[(word, freq) for freq, word in (
    pd.Series(freqs)
      .reset_index()
      .groupby(0, as_index=False)
      .agg(lambda x: list(x))
      .values
)]

# [(['lonely', 'one'], 1), (['crazy'], 3), (['yeah'], 15)]
</code></pre>
<p>Whatever solution you end up going with, it may be helpful to consider that this is a <code>reduce</code> operation on word frequency, and frequency occupies the value slot in your <code>word:freq</code> key:value pairs.  </p>
<p><code>reduce</code> and/or <code>groupby</code> operations work by collapsing on <em>keys</em>, and then creating some aggregation of the associated <em>values</em>.  That's why you see a number of these answers reversing <code>freqs</code> at some point, to get things in shape for the <code>reduce</code> operation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use collections.defaultdict</p>
<pre><code>freqs = {'yeah':15, 'one': 1, 'crazy': 3, 'lonely': 1}
from collections import defaultdict
def words_often(freqs, min_times):
    d_dict = defaultdict(list)
    for k,v in freqs.items():
        d_dict[v].append(k)
    return [(v,k) for k,v in d_dict.items() if k&gt;min_times]

print(words_often(freqs, 0))
</code></pre>
<p>Output:</p>
<pre><code>[(['yeah'], 15), (['one', 'lonely'], 1), (['crazy'], 3)]
</code></pre>
</div>
<span class="comment-copy">@crook Sets/dicts can't, but tuples can.</span>
<span class="comment-copy">yeah my bad . confused with set and tuple. ty</span>
<span class="comment-copy">I am performing research for an article and plan on referencing this question in it. As part of that research, I am wondering if everyone who interacted with this question could message me and let me know how many years they have been coding in python. I would truly appreciate any and all help any of you are willing to provide. Thank you in advance. - Sage</span>
<span class="comment-copy">I understand what you're doing here, but I need the words inside the tuples to be grouped in lists. For example the first entry should be (['yeah'], 15) and for words that have the same value (one and lonely), I need them to be grouped like (['one', 'lonely'], 1)</span>
<span class="comment-copy">@sula7ifa I see. I have updated the answer.</span>
<span class="comment-copy">please check the edit.</span>
<span class="comment-copy">@sula7ifa check this out now.</span>
<span class="comment-copy">But your version doesn't account for min_times</span>
<span class="comment-copy">edited and simplified further</span>
