<div class="post-text" itemprop="text">
<pre><code>In [55]: a = 5

In [56]: b = 6

In [57]: (a, b) = (b, a)

In [58]: a
Out[58]: 6

In [59]: b
Out[59]: 5
</code></pre>
<p>How does this swapping of values of a and b work internally? Its definitely not using a temp variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python separates the right-hand side expression from the left-hand side assignment. First the right-hand side is evaluated, and the result is stored on the stack, and then the left-hand side names are assigned using opcodes that take values <em>from</em> the stack again.</p>
<p>For tuple assignments with 2 or 3 items, Python just uses the stack directly:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def foo(a, b):
...     a, b = b, a
... 
&gt;&gt;&gt; dis.dis(foo)
  2           0 LOAD_FAST                1 (b)
              3 LOAD_FAST                0 (a)
              6 ROT_TWO             
              7 STORE_FAST               0 (a)
             10 STORE_FAST               1 (b)
             13 LOAD_CONST               0 (None)
             16 RETURN_VALUE        
</code></pre>
<p>After the two <a href="http://docs.python.org/2/library/dis.html#opcode-LOAD_FAST" rel="noreferrer"><code>LOAD_FAST</code> opcodes</a> (which push a value from a variable onto the stack), the top of stack holds <code>[a, b]</code>. The <a href="http://docs.python.org/2/library/dis.html#opcode-ROT_TWO" rel="noreferrer"><code>ROT_TWO</code> opcode</a> swaps the top two positions on the stack so the stack now has <code>[b, a]</code> at the top. The two <a href="http://docs.python.org/2/library/dis.html#opcode-STORE_FAST" rel="noreferrer"><code>STORE_FAST</code> opcodes</a> then takes those two values and store them in the names on the left-hand side of the assignment. The first <code>STORE_FAST</code> pops a value of the top of the stack and puts it into <code>a</code>, the next pops again, storing the value in <code>b</code>. The rotation is needed because Python guarantees that assignments in a target list on the left-hand side are done from left to right.</p>
<p>For a 3-name assignment, <a href="http://docs.python.org/2/library/dis.html#opcode-ROT_THREE" rel="noreferrer"><code>ROT_THREE</code></a> followed by <code>ROT_TWO</code> is executed to reverse the top three items on the stack.</p>
<p>For longer left-hand-side assignments, an explicit tuple is built:</p>
<pre><code>&gt;&gt;&gt; def bar(a, b, c, d):
...     d, c, b, a = a, b, c, d
... 
&gt;&gt;&gt; dis.dis(bar)
  2           0 LOAD_FAST                0 (a)
              3 LOAD_FAST                1 (b)
              6 LOAD_FAST                2 (c)
              9 LOAD_FAST                3 (d)
             12 BUILD_TUPLE              4
             15 UNPACK_SEQUENCE          4
             18 STORE_FAST               3 (d)
             21 STORE_FAST               2 (c)
             24 STORE_FAST               1 (b)
             27 STORE_FAST               0 (a)
             30 LOAD_CONST               0 (None)
             33 RETURN_VALUE        
</code></pre>
<p>Here the stack with <code>[d, c, b, a]</code> is used to build a tuple (in reverse order, <a href="http://docs.python.org/2/library/dis.html#opcode-BUILD_TUPLE" rel="noreferrer"><code>BUILD_TUPLE</code></a> pops from the stack again, pushing the resulting tuple onto the stack), and then <a href="http://docs.python.org/2/library/dis.html#opcode-UNPACK_SEQUENCE" rel="noreferrer"><code>UNPACK_SEQUENCE</code></a> pops the tuple from the stack again, pushes all elements back from the tuple back onto the stack again for the <code>STORE_FAST</code> operations.</p>
<p>The latter may seem like a wasteful operation, but the right-hand side of an assignment may be something entirely different, a function call that <em>produces</em> a tuple perhaps, so the Python interpreter makes no assumptions and uses the <code>UNPACK_SEQUENCE</code> opcode always. It does so even for the two and three-name assignment operations, <a href="http://hg.python.org/cpython/file/3696b9ae6b17/Python/peephole.c#l426" rel="noreferrer">but a later (peephole) optimization step</a> replaces a <code>BUILD_TUPLE</code> / <code>UNPACK_SEQUENCE</code> combination with 2 or 3 arguments with the above <code>ROT_TWO</code> and <code>ROT_THREE</code> opcodes for efficiency.</p>
</div>
<span class="comment-copy"><code>Its definitely not using a temp variable?</code> this is a weird question. It sounds like you know it.</span>
<span class="comment-copy">It may interest you to view the disassembly of your code with <a href="http://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a>. Spoliers: the bytecode instruction <a href="http://docs.python.org/2/library/dis.html#opcode-ROT_TWO" rel="nofollow noreferrer"><code>ROT_TWO</code></a> is used.</span>
<span class="comment-copy">@RedX: I wouldn't have asked this question if I knew it. Using a temp variable is a trivial approach to swapping.</span>
<span class="comment-copy">+1 for <b>The rotation is needed because Python guarantees that assignments in a target list on the left-hand side are done from left to right.</b>. I did not know that.</span>
