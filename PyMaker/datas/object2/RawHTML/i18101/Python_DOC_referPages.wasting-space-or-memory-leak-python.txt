<div class="post-text" itemprop="text">
<p>I'm confused about the following situation, and perhaps my vocabulary is wrong here, so apologies.</p>
<p>Say we have a tuple, <code>x = ('a', [])</code> and then we do <code>x = (x[0], [1, 2, 3])</code>. </p>
<p>Since the new tuple is referencing the old tuple we can't delete the old tuple object, but since of that old tuple object we are only using the reference to x[0], we are wasting memory as x[1] of the old tuple object cannot be accessed by anything. </p>
<p>Is this bona-fide case of memory leak; are we wasting memory just so that the new tuple object's references make sense.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're probably coming to Python from a language like C++, where variables are memory locations that values are stored in. In Python, values are stored somewhere that you don't have to worry about, and your variables are just names that reference those values. There is no way to make a variable reference another variable*—you can make it reference the same <em>value</em> as another variable, but that's not a problem.</p>
<hr/>
<p>For example, in C++:</p>
<pre><code>int x[] = {1, 2, 3};
int &amp;y = x[0];
</code></pre>
<p>Here, <code>x</code> is a memory location big enough for three <code>int</code> values, and <code>y</code> is a reference to the first of those locations. So, if <code>x</code> goes away while <code>y</code> is still alive, you'd have a dangling reference, which would be bad. But in Python:</p>
<pre><code>x = [1, 2, 3]
y = x[0]
</code></pre>
<p>Here, <code>x</code> is a name for a <code>list</code> object, whose three positions are names for three different <code>int</code> objects stored elsewhere, and <code>y</code> is just another name for the first <code>int</code> object. If <code>x</code> goes away, Python can free up the <code>list</code>, after which it can free up the <code>2</code> and <code>3</code> objects** (because nobody else refers to them), leaving only the <code>1</code> object behind.</p>
<hr/>
<p>This is also why there are no "copy constructors"*** in Python. In C++, <code>int z = x[0]</code> creates a new memory location, and implicitly copies the <code>int</code> from <code>x[0]</code> into that memory location; in Python, unless you explicitly write something like <code>z = copy.copy(x[0])</code>, you are never copying anything.</p>
<hr/>
<p>* This isn't quite true if you look at how closure cells work under the covers.</p>
<p>** In fact, small integers are usually treated specially, and kept alive forever, but let's ignore that.</p>
<p>*** Much less copy assignment operators, move constructors, and move assignment operators.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an annotated Python session using your example to show what is and isn't currently referenced.</p>
<pre><code>&gt;&gt;&gt; x = ('a', [])
&gt;&gt;&gt; id(x)
4340112344            # The tuple
&gt;&gt;&gt; id(x[0])
4339406128            # The character 'a'
&gt;&gt;&gt; id(x[1])
4340109184            # An empty list
&gt;&gt;&gt; x = (x[0], [1,2,3])
&gt;&gt;&gt; id(x)
4340112488            # x refers to a new object
&gt;&gt;&gt; id(x[0])
4339406128            # The character 'a'. The old tuple is not involved
&gt;&gt;&gt; id(x[1])
4340199576            # A new list.
</code></pre>
<p>The original tuple, object 4340112344, is no longer referenced, so it is free to be garbage collected whenever convenient without affect the new object referenced by <code>x</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Slight logic error.</p>
<p><strike>Python strings are immutable. When you do this:</strike></p>
<pre><code>x = ('a', [])
</code></pre>
<p>and then this:</p>
<pre><code>x = (x[0], [1,2,3])
</code></pre>
<p><code>x[0]</code> is now a new string, i.e., not tied to the original. Therefore the GC is free to collect the original tuple.</p></div>
<span class="comment-copy">You don't reference the whole old tuple <code>x</code> here, only its first element. So, the old <code>x</code> can and will be removed.</span>
<span class="comment-copy">Nothing in the newly created tuple references the original tuple.  When the original tuple is garbage collected, the character <code>'a'</code> will still exist if there are still references to it (so if the newly created tuple is still references it the character sticks around, but the original tuple goes away).</span>
<span class="comment-copy">By the way, if you're not sure about what is and isn't collectable, try playing with the <a href="http://docs.python.org/3/library/gc.html" rel="nofollow noreferrer"><code>gc</code></a> module. Or, alternatively, try creating custom objects with <code>__del__</code> methods. Just be aware that, either way, you can only do so much before you start actually interfering with the normal collection. (For example, you can't view how cycles are broken with <code>__del__</code> methods because they prevent cycles from being broken…)</span>
<span class="comment-copy">@abarnert I've been spooked to touch gc to date, but now I'll start playing with it. Thank you :)</span>
<span class="comment-copy">@EdgarAroutiounian: Remember, if you're just playing around in the interactive interpreter, the worst-case scenario is that you have to quit and relaunch the interpreter, right?</span>
<span class="comment-copy">Fantastic, thank you!</span>
<span class="comment-copy">+1, because this is a very handy way to look at things. But it's not always easy to see that there is nothing left alive whose <code>id</code> equals some old value. And it can be complicated by the fact that Python is free to reuse <code>id</code> values of objects that no longer exist for new objects. (See <a href="http://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">the docs</a> for the rules.)</span>
<span class="comment-copy">x[0] is most certainly the original string, not a new one. The key is that the string is referenced independently of the tuple, so while the string has one reference, the original tuple has zero. Your argument regarding the list is the correct one for the string.</span>
<span class="comment-copy"><code>x[0]</code> could be (but isn't required to be) the same <code>string</code> object that is present in the original tuple. However, keeping a reference to that object is not the same as keeping any reference to the original tuple itself. The tuple itself can be GC'd independently of anything reference to its contents.</span>
<span class="comment-copy">No, <code>x[0]</code> is definitely the same string. There is no operation that could cause a copy to be made. <code>x[0][0]</code> might be a new string (although even that isn't guaranteed, if <code>'a'</code> is interned), but that's a different story.</span>
<span class="comment-copy">I would think that x[0] is the original string, since if I do my tuple examples right after another, CPython will share the same string between objects rather than making a new string.</span>
<span class="comment-copy"><code>x[0]</code> is required to provide a reference to the first element of x, not any new object. There is no special case for strings in this regard.</span>
