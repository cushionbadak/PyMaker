<div class="post-text" itemprop="text">
<p>I have written following class which does the following:</p>
<pre><code>class abc:
    def __init__(self):
        self.Values = []
    def add_code(self):
        lastval = self.Values
        print "self.Values  , ", self.Values
        print "lastval  , ", lastval
        lastval.append(1)
        print "self.Values 1, ", self.Values
        print "lastval 1 , ", lastval

        lastval.append(2)
        print "lastval 2 , ", lastval
        print "self.Values 2 , ", self.Values
        lastval.append(3)
        print "lastval 3 , ", lastval
        print "self.Values 3 , ", self.Values
        lastval.append(4)
        print "last val 4 ", lastval
        print "self.Values 4 , ", self.Values
        lastval = []
        print "last value is emtpy now? , ", lastval
        print "But the self.Values is not", self.Values
        return lastval
</code></pre>
<p>When I run this code I see that the variable <code>lastval</code> gets appended with the values and so does the <code>self.Values</code>
But when I initialize the <code>lastval</code> with empty list, I still see <code>self.Values</code> holds to the values. 
What could be the reason </p>
</div>
<div class="post-text" itemprop="text">
<p>Why would you think otherwise? At first, you assign <code>lastval</code> to point to the same list as <code>self.Values</code>, so mutations to one will be seen in the other. But when you do <code>lastval = []</code> you simply rebind <code>lastval</code> to a new list, you don't affect <code>self.Values</code> at all.</p>
</div>
<div class="post-text" itemprop="text">
<p>After the <code>__init__</code> method has run, we have two objects in memory:</p>
<pre><code>#1 Instance of abc
#2 Array
</code></pre>
<p>They contain:</p>
<pre><code>#1 Instance of abc
    Values : Reference to #2

#2 Array
    [ ]
</code></pre>
<p>Now we call add_code and it runs:</p>
<pre><code>lastval = self.Values
print "self.Values  , ", self.Values
print "lastval  , ", lastval
</code></pre>
<p>At this point, both lastval and self.Values are <em>references</em> to object #2, the array. So we have:</p>
<pre><code>#1 Instance of abc
    Values : Reference to #2

#2 Array
    [ ]

Local variables
    self : Reference to #1
    lastval : Reference to #2
</code></pre>
<p>Continuing...</p>
<pre><code>lastval.append(1)
print "self.Values 1, ", self.Values
print "lastval 1 , ", lastval
</code></pre>
<p>The <code>append</code> method <em>modifies</em> object #2. So now we have:</p>
<pre><code>#1 Instance of abc
    Values : Reference to #2

#2 Array
    [ 1 ]

Local variables
    self : Reference to #1
    lastval : Reference to #2
</code></pre>
<p>This continues similarly...</p>
<pre><code>lastval.append(2)
print "lastval 2 , ", lastval
print "self.Values 2 , ", self.Values
lastval.append(3)
print "lastval 3 , ", lastval
print "self.Values 3 , ", self.Values
lastval.append(4)
print "last val 4 ", lastval
print "self.Values 4 , ", self.Values
</code></pre>
<p>So now we have:</p>
<pre><code>#1 Instance of abc
    Values : Reference to #2

#2 Array
    [ 1, 2, 3, 4 ]

Local variables
    self : Reference to #1
    lastval : Reference to #2
</code></pre>
<p>At this point, we do something different:</p>
<pre><code>lastval = []
</code></pre>
<p>This is an assignment to a local variable. It doesn't do anything to object #2. It creates a new array. So finally we have:</p>
<pre><code>#1 Instance of abc
    Values : Reference to #2

#2 Array
    [ 1, 2, 3, 4 ]

#3 Array
    [ ]

Local variables
    self : Reference to #1
    lastval : Reference to #3
</code></pre>
<p>As you can see, lastval and self.Values now refer to different objects.</p>
<p>The important thing to understand is the difference updating a variable to reference different objects, and mutating an existing object. For an in-depth discussion, see <a href="http://docs.python.org/3/reference/datamodel.html" rel="nofollow">http://docs.python.org/3/reference/datamodel.html</a> (That document is for Python 3, but there is no major difference in these concepts between Python 2 and Python 3.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Classes have nothing (or not much) to do with this.  The underlying effect is that several variables can hold the same list (this happens via assignment).  And if you then change the list, all variables seem to change.</p>
<p>You might want to create copies of the lists to avoid that.</p>
</div>
<span class="comment-copy">That is very detailed explanation... I will make sure to save your response</span>
