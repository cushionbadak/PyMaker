<div class="post-text" itemprop="text">
<p>I was having trouble with Python script opening a file which contained an umlaut character. Naturally I thought I could correct this with a unicode  utf8  fix, but not so...</p>
<p>I ended up using the <strong>mbcs</strong>      ( default is  cp1252) </p>
<p>Then I wrote this statement of which I wish to write MUCH cleaner,  </p>
<pre><code>def len(fname):
i = -1
try:
    with open(fname, encoding='mbcs') as f:
        for i, l in enumerate(f):
            pass
except UnicodeDecodeError:
    try:
        i = -1
        with open(fname, encoding='utf8') as f:
            for i, l in enumerate(f):
                pass
    except UnicodeDecodeError:
        i = -1
        with open(fname) as f:
            for i, l in enumerate(f):
                pass
return i + 2 # 2 because it starts at -1 not 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're almost certainly going about this all wrong, as explained in the comments… but if you really <em>do</em> need to do something like this, here's how to simplify it:</p>
<p>The general solution to avoid repeating yourself is to use a loop. You've got the same code three times, with the only difference being the <code>encoding</code>, so loop over three encodings instead. (In your case, the third loop didn't pass an <code>encoding</code> at all, so you do have to know the default value of the parameter, but <a href="http://docs.python.org/3/library/functions.html#open" rel="nofollow">the docs</a> or <code>help</code> will tell you that.) The only wrinkle is that you apparently don't want to handle exceptions in the third case; the easiest way to do that is to reraise the last exception if they all fail.</p>
<p>While we're at it: There's no need to "declare" <code>i</code> up-front the way you do; the <code>for</code> loop is just going to start at 0 and erase whatever you put there. That also means the <code>+2</code> at the end is wrong. But there's an easier way to get the length of an iterable in the first place: just feed it into something that consumes generator expressions. A custom <code>ilen</code> function written in C would be ideal, but people have tested various different Python implementations, and <code>sum(1 for _ in iterable)</code> is almost as fast as the perfect solution, and dead simple, so it's the most common idiom. If this isn't obvious you to, factor it out as a function and call it <code>lien</code>, and give it a nice docstring and/or comment. Or just <a href="https://github.com/erikrose/more-itertools" rel="nofollow"><code>pip install more-itertools</code></a> and then you can just call <a href="http://pythonhosted.org/more-itertools/api.html#more_itertools.ilen" rel="nofollow"><code>more_itertools.ilen(f)</code></a>.</p>
<p>Anyway, putting it all together:</p>
<pre><code>def len(fname):
    for encoding in 'mbcs', 'utf8', None:
        try:
            with open(fname, encoding=encoding) as f:
                return sum(1 for line in f)
        except UnicodeDecodeError as e:
            pass
    raise e
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It’s not entirely clear to me what you want: if you just want to count the lines, ignore the errors! – This is pretty safe, as practically all encodings use the same ASCII compatible line endings (except UTF-16...).</p>
<p><code>open(fname, errors='ignore')</code></p>
<p>And you never get an exception. Done.</p>
</div>
<span class="comment-copy">What encoding does your file have? Maybe you should simply use that one.</span>
<span class="comment-copy">Seriously, @Hyperboreus is definitely right. Figure out the file's encoding.</span>
<span class="comment-copy">Also this python <a href="http://docs.python.org/2/howto/unicode.html" rel="nofollow noreferrer">unicode page</a> is a great primer in file encoding.</span>
<span class="comment-copy">And btw "mbcs" is not an encoding, but stands for "multi-byte character set". From the docs: "on Windows, Python uses the name “mbcs” to refer to whatever the currently configured encoding is"</span>
<span class="comment-copy">@abarnert The idea that there is wisdom unbeknownst to man, and only known by Windows itself, scares me.</span>
<span class="comment-copy">I had to make a small modification since the raise fails due to the e variable losing scope.   Thus  def len(fname):     encoding = ['mbcs', 'utf8', None]     for enc in encoding:         try:             with open(fname, encoding=enc) as f:                 return sum(1 for line in f)         except UnicodeDecodeError as e:             if enc == encoding[-1]:                 raise e             else:                 pass</span>
<span class="comment-copy">@TomStickel: If you're going to do it that way, just use <code>raise</code> inside the <code>except</code>, not <code>raise e</code>. It's a bit hard to explain why in a comment, but the short version is: if you can re-raise from an except, you should, especially in Python 3 but even in Python 2.</span>
<span class="comment-copy">I still need it to fail for example if a file does not exist.   Or if someone tries to transmit a binary file.</span>
<span class="comment-copy">@TomStickel: What exactly is a "binary file"? That's not a rhetorical question; your existing code (and my answer) says that anything that isn't valid as a text file in the current Windows MBCS codepage, or UTF-8, or the OEM codepage is binary. That means that, e.g., UTF-16 text files (which are pretty common on Windows) will be treated as binary. On the other hand, if the OEM codepage is one of the extended-Latin ones, almost <i>nothing</i> will be treated as binary.</span>
<span class="comment-copy">@TomStickel: 1) It does fail if the files does not exist, of course! 2) so you want to use 3 character encodings to test if it’s a text-file or not??</span>
