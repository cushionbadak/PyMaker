<div class="post-text" itemprop="text">
<p>I want write a function that deletes even numbers from a list (for example xs=[1,2,3,4,5,6]) and then returns the the remaining list. Help needed. Thank you
note: I cant use any built in functions like remove sort etc, but only the delete statement.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you need to return the remaining list, you should not delete but filter instead:</p>
<pre><code>[v for v in xs if v % 2 == 1]
</code></pre>
<p>This creates a list with all the odd numbers:</p>
<pre><code>&gt;&gt;&gt; xs = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; [v for v in xs if v % 2 == 1]
[1, 3, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The obvious way doesn't work:</p>
<pre><code>for index, value in enumerate(xs):
    if not value % 2:
        del xs[index]
</code></pre>
<p>Or, worse, it happens to work in this particular case, but only because you got very lucky (and your teacher may even be counting on you to fall into this trap).</p>
<p>Why? Well, when you <code>del i[0]</code>, that shifts everything else down. So when you next check <code>i[1]</code>, that's not the original <code>i[1]</code>, but the original <code>i[2]</code>. You never check, and therefore can't ever delete, the original <code>i[1]</code>!</p>
<p>This is explained in a big grey note in the documentation for <a href="http://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow"><code>for</code></a>.*</p>
<hr/>
<p>The best solution to this is, as Martijn Pieters says, to not delete in the first place.</p>
<p>If you don't care about mutating the original list (if no other object has a reference to the same list, and your teacher isn't fond of trick questions, you don't care), just create and return a new list, as in his answer. Even if you <em>do</em> need to mutate the original list, <code>xs[:] = [v for v in xs if v % 2 == 1]</code> will do that just as well as deleting in-place.</p>
<p>But if you must delete in-place for some reason (and it sounds like that <em>might</em> be a requirement of your assignment), the easiest way is to work backward from the end:</p>
<pre><code>for index, value in list(enumerate(xs))[::-1]:
    if not value % 2:
        del xs[index]
</code></pre>
<p>Since deleting a value from a list only shifts down the ones after it, going through the list in reverse order means we never get lost and skip over an element we wanted to test.</p>
<hr/>
<p>* The explanation reads like something from Python 1.x; now that the iterator protocol is public, they don't really need to talk about keeping internal counters in some unspecified placeâ€¦</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>xs=[1,2,3,4,5,6]

not_even = []
for i in xs:
    if i%2 != 0:
        not_even.append(i)

print not_even
#output: [1, 3, 5]
</code></pre>
<p>You can also do it using list comprehensions:</p>
<pre><code>[i for i in xs if i%2 != 0]
</code></pre>
</div>
<span class="comment-copy">And? What have you tried so far? Where are you stuck?</span>
<span class="comment-copy">Well, since there is no <code>delete</code> statement, I guess you're going to fail the assignment.</span>
<span class="comment-copy">This is just a much more long-winded version of Martijn Pieters' answer, without the explanation.</span>
