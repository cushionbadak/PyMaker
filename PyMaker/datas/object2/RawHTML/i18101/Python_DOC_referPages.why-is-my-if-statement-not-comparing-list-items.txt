<div class="post-text" itemprop="text">
<pre><code>    alphabet =["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"]
def decoder(input):
    inputlist = list(input)
    inputlength = len(input)
    alphabetlength = len(alphabet)
    result = "Decoded Sentence: "
    for x in range(inputlength):
        for y in range(alphabetlength):
            if inputlist[x] is alphabet[y]:
                print ("hi")
                if y == 24:
                    result += "a"
                if y == 25:
                    result += "b"
                else:
                    result += alphabet[y+2]
            if inputlist[x] is "(":
                result += "("
            if inputlist[x] is ")":
                result += ")"
            if inputlist[x] is ".":
                result += "."
            if inputlist[x] is " ":
                result += " "
    return result
</code></pre>
<p>My code is supposed to increment a sentence's alphabets by 2. ex: a-&gt;c, l-&gt;n
I put the print("hi") statement to check if the if-statement was ever evaluated to be true but it never does. Can someone please tell me why?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>is</code> checks object <em>identity</em>. Since you appear to be testing whether two strings have the same value (not are the same <em>object</em>), you would be better served by <code>==</code>. For example:</p>
<pre><code>if inputlist[x] == alphabet[y]
</code></pre>
<p>You can make the same update for your other <code>if</code> statements as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <code>is</code> compares identity and not equality of strings. Two short strings that are equal <em>may</em> be identical due to some string interning CPython does, but you generally should not build on this behavior. Instead, use <code>==</code> to compare the <em>equality</em> of strings.</p>
<p>Note, that you can do this a lot better using <a href="http://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow"><code>str.translate</code></a>, with a map created by <a href="http://docs.python.org/3/library/stdtypes.html#str.maketrans" rel="nofollow"><code>str.maketrans</code></a>:</p>
<pre><code>&gt;&gt;&gt; table = str.maketrans('abcdefghijklmopqrstuvwxyz', 'cdefghijklmopqrstuvwxyzab')
&gt;&gt;&gt; 'hello world'.translate(table)
'jgooq yqtof'
</code></pre>
<p>You can further use <a href="http://docs.python.org/3/library/string.html#string.ascii_lowercase" rel="nofollow"><code>string.ascii_lowercase</code></a> so you donâ€™t need to type the alphabet yourself; or use <a href="http://docs.python.org/3/library/string.html#string.ascii_letters" rel="nofollow"><code>string.ascii_letters</code></a> for lower and upper case characters:</p>
<pre><code>&gt;&gt;&gt; table = str.maketrans(string.ascii_letters, string.ascii_letters[2:] + string.ascii_letters[:2])
&gt;&gt;&gt; 'Hello World (This works!)'.translate(table)
'Jgnnq Yqtnf (Vjku yqtmu!)'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Besides of the <code>is</code> thin, you have another problem in your code:</p>
<p>As soon as <code>y == 24</code>, it will break: First, <code>a</code> will be added and then <code>alphabet[26]</code> - which results in an error.</p>
<p>So change your logic to</p>
<pre><code>for inp in inputlist:
    if inp in "(). ":
        result += inp
    else: # very important
        for y in range(alphabetlength):
            if inp == alphabet[y]:
                if y == 24:
                    result += "a"
                elif y == 25: # elif instead of if!
                    result += "b"
                else:
                    result += alphabet[y+2]
</code></pre>
<p>This can even improved further:</p>
<p>If you make <code>alphabet = 'abcdefghijklmnopqrstuvwxyz'</code>, you can do</p>
<pre><code>for inp in inputlist:
    if inp in "(). ":
        result += inp
    else: # very important
        idx = alphabet.find(inp)
        if idx &gt;= 0: # found
            result += alphabet[(idx + 2) % len(alphabet)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This might help clear up the "is" keyword. "is" checks the object identity, not the value.</p>
<pre><code>var_1 = ('a', 'b')
var_2 = ('a', 'b') # same content, but different object
var_3 = var_1 # same object
n = lambda v: ' ' if v else ' not '
print('{0} has{2}the same value as {1}'.format('var_1', 'var_2', n(var_1 == var_2)))
print('{0} has{2}the same value as {1}'.format('var_2', 'var_3', n(var_2 == var_3)))
print('{0} has{2}the same value as {1}'.format('var_3', 'var_1', n(var_3 == var_1)))
print('{0} is{2}the same object as {1}'.format('var_1', 'var_2', n(var_1 is var_2)))
print('{0} is{2}the same object as {1}'.format('var_2', 'var_3', n(var_2 is var_3)))
print('{0} is{2}the same object as {1}'.format('var_3', 'var_1', n(var_3 is var_1)))
</code></pre>
<p>Output:</p>
<pre><code>var_1 has the same value as var_2
var_2 has the same value as var_3
var_3 has the same value as var_1
var_1 is not the same object as var_2
var_2 is not the same object as var_3
var_3 is the same object as var_1
</code></pre>
<p>So, all three have the same value, but only 1 and 3 are identical.</p>
</div>
<span class="comment-copy"><b><code>is</code></b> is used for identity check not equality, though that might not be the only issue.</span>
<span class="comment-copy">Just to expand on the above, is checks if they two things are the same object and location in memory. You want to user equality "==" not is.</span>
<span class="comment-copy">Fyi, instead of doing a massive alphabet list, <code>import string</code> and then define alphabet as <code>list(string.lowercase)</code>.</span>
<span class="comment-copy">I changed it to == and it works thanks</span>
<span class="comment-copy">@user2080262: Or, even better, just use <code>string.lowercase</code> directly instead of making a list out of it; he doesn't actually need a list, just an iterable, and a str already works fine.</span>
<span class="comment-copy">No, <a href="http://docs.python.org/2/reference/expressions.html#is" rel="nofollow noreferrer"><code>is</code></a> does <i>not</i> check the memory address; it checks object identity. The CPython implementation happens to do that by comparing two C pointers to see if they point to the same address, but other implementations like Jython and PyPy don't (and, in fact, <i>couldn't</i>, because they're written in languages that don't have pointers or addresses).</span>
<span class="comment-copy">Great clarification. I didn't think about Jython or PyPy.</span>
<span class="comment-copy">@JeremyGranger So why don't you correct your answer? It might get you rid of that -1 or even gain some +1...</span>
<span class="comment-copy">Just done it for you so that the answer is a good one now. @abarnert, If you was the downvoter, you might reconsider removing it. If not, not...</span>
<span class="comment-copy">Thanks, I love the correction.</span>
