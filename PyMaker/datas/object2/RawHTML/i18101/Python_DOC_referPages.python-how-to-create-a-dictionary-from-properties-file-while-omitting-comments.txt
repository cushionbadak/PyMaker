<div class="post-text" itemprop="text">
<p>I've searched for the answer to this here for awhile and haven't found it, so hope this isn't a dupe.  </p>
<p>I have a properties file that mostly contains key=value pairs, but also contains #comments.  I need to put it in a dictionary so I can grab values at will.  In a file without #comments, the following works perfectly.</p>
<pre><code>myprops = dict(line.strip().split('=') for line in open('/Path/filename.properties'))
print myprops['key']
</code></pre>
<p>But not so when there are comments present.  If there's <code>#comment</code> present, dictionary says</p>
<pre><code>"ValueError: dictionary update sequence element #x has length 1, 2 is required"
</code></pre>
<p>I've tried wrapping the dictionary creation in conditionals with</p>
<pre><code>if not line.startswith('#'):
</code></pre>
<p>But I can't seem to get that to work.  Suggestions?  Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>To address your newest constraint about blank lines, I would try something like:</p>
<pre><code>myprops = {}
with open('filename.properties', 'r') as f:
    for line in f:
        line = line.rstrip() #removes trailing whitespace and '\n' chars

        if "=" not in line: continue #skips blanks and comments w/o =
        if line.startswith("#"): continue #skips comments which contain =

        k, v = line.split("=", 1)
        myprops[k] = v
</code></pre>
<p>It's very clear and it's easy to add on extra constraints, whereas using a dict comprehension will get quite bloated.  However, you could always format it nicely</p>
<pre><code>myprops = dict(line.strip().split('=') 
               for line in open('/Path/filename.properties'))
               if ("=" in line and 
                   not line.startswith("#") and
                   &lt;extra constraint&gt; and
                   &lt;another extra constraint&gt;))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should just use the built-in <a href="http://docs.python.org/3/library/configparser.html" rel="nofollow"><code>configparser</code></a> which is made to read ini-style configuration files. It allows comments using <code>;</code> and <code>#</code> by default, so it should work for you.</p>
<p>For <code>.properties</code> files you might need to trick a bit as the configparser generally expects section names. You can do this easily by adding a dummy section while reading it though:</p>
<pre><code>&gt;&gt;&gt; from configparser import ConfigParser
&gt;&gt;&gt; config = ConfigParser()
&gt;&gt;&gt; with open(r'C:\Users\poke\Desktop\test.properties') as f:
        config.read_string('[config]\n' + f.read())

&gt;&gt;&gt; for k, v in config['config'].items():
        print(k, v)

foo bar
bar baz
baz foo
</code></pre>
<p>(Using the same example file as mtitan8)</p>
<p>For Python 2, use <code>from ConfigParser import ConfigParser</code> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>Given a properties file <code>test.txt</code> as you've described:</p>
<pre><code>foo=bar
#skip me
bar=baz
baz=foo
#skip me too!
</code></pre>
<p>You can do the following:</p>
<pre><code>&gt;&gt;&gt; D = dict( l.rstrip().split('=') for l in open("test.txt")
              if not l.startswith("#") )
&gt;&gt;&gt; D
{'baz': 'foo', 'foo': 'bar', 'bar': 'baz'}
</code></pre>
<p>This seems just like the code you said you tried using <code>if not line.startswith('#')</code>, so hopefully this working example will help you pinpoint the bug.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why force this into one line? Two weeks from now a user will put a space somewhere, or want to use quotes and you have to go unwind the code. Just make a function now which handles the input and be done with it. It also means you can use unit tests to ensure it works and stays working.</p>
<p>Given this input:</p>
<pre><code>foo=bar
#skip me

bar=baz
baz=foo

#skip me too!
</code></pre>
<p>The following code will handle it all nicely.</p>
<pre><code>import sys

def parse_line(input):
    key, value = input.split('=')
    key = key.strip()  # handles key = value as well as key=value
    value = value.strip()

    return key, value

if __name__ == '__main__':
    data = {}

    with open(sys.argv[1]) as fp:
        for line in fp:
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            key, value = parse_line(input)
            data[key] = value

    print data
</code></pre>
<p>BTW, I like poke's suggestion of using ConfigParser. But the hack of adding a section may or  may not work for everyone.</p>
<p>If you want to move the comment checking into the parse_line() function you could return None, None and check for that before putting the key/value pair into the dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>shouldn't <code>line.startswith('#')</code> better read <code>line.strip().startswith('#')</code>?</p>
<pre><code>dict(line.strip().split('=') for line in open('/Path/filename.properties') 
                             if not line.strip().startswith('#'))
</code></pre>
</div>
<span class="comment-copy">So to be clear, you've tried <code>dict(line.strip().split('=') for line in open('/Path/filename.properties') if not line.startswith('#'))</code>?</span>
<span class="comment-copy">I didn't try it quite that way and that does work.  thank you!</span>
<span class="comment-copy">I may have spoken too soon.  I'd assumed that error was on account of just the commented lines.  There are blank lines as well.  And It gives the same error on those.  I thought <code>line.strip()</code> was going to skip all the blank lines.</span>
<span class="comment-copy">That worked like a charm.  Thanks, Bill.</span>
<span class="comment-copy">That's cool.  Thanks.  My properties file is not in the windows style with bracketed section names like "[config]".  Can ConfigParser work without those?  Thanks!</span>
<span class="comment-copy">Yeah, that’s basically why I did that in my example code. My <code>test.properties</code> also did not have any sections, so when reading the file, I just add a dummy section at the top of the file, so the configparser won’t complain.</span>
<span class="comment-copy">I have to do <code>import ConfigParser</code>.  <code>from configparser import ConfigParser</code> gives me an import error.  Though, I get an error anyway on the next line <code>config = ConfigParser()</code> stating that 'module' object is not not callable.  I'm on Python 2.7 if it makes a difference in regard to this solution.  THanks.</span>
<span class="comment-copy">Right, you need to do <code>from ConfigParser import ConfigParser</code> in Python 2 because back then the module name was not yet in <a href="http://docs.python.org/2/library/configparser.html" rel="nofollow noreferrer">lowercase</a>.</span>
<span class="comment-copy">This does not provide an answer to the question. To critique or request clarification from an author, leave a comment below their post - you can always comment on your own posts, and once you have sufficient <a href="http://stackoverflow.com/help/whats-reputation">reputation</a> you will be able to <a href="http://stackoverflow.com/help/privileges/comment">comment on any post</a>.</span>
<span class="comment-copy">right, I was trying to improve the answer and I was not allowed to add a comment, so I rather put it out the way I was allowed to instead of not.</span>
