<div class="post-text" itemprop="text">
<p>How do I share a global variable with thread?</p>
<p>My Python code example is:</p>
<pre><code>from threading import Thread
import time
a = 0  #global variable

def thread1(threadname):
    #read variable "a" modify by thread 2

def thread2(threadname):
    while 1:
        a += 1
        time.sleep(1)

thread1 = Thread( target=thread1, args=("Thread-1", ) )
thread2 = Thread( target=thread2, args=("Thread-2", ) )

thread1.join()
thread2.join()
</code></pre>
<p>I don't know how to get the two threads to share one variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>You just need to declare <code>a</code> as a global in <code>thread2</code>, so that you aren't modifying an <code>a</code> that is local to that function.</p>
<pre><code>def thread2(threadname):
    global a
    while True:
        a += 1
        time.sleep(1)
</code></pre>
<p>In <code>thread1</code>, you don't need to do anything special, as long as you don't try to modify the value of <code>a</code> (which would create a local variable that shadows the global one; use <code>global a</code> if you need to)&gt;</p>
<pre><code>def thread1(threadname):
    #global a       # Optional if you treat a as read-only
    while a &lt; 10:
        print a
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In a function:</p>
<pre><code>a += 1
</code></pre>
<p>will be interpreted by the compiler as <code>assign to a =&gt; Create local variable a</code>, which is not what you want. It will probably fail with a <code>a not initialized</code> error since the (local) a has indeed not been initialized:</p>
<pre><code>&gt;&gt;&gt; a = 1
&gt;&gt;&gt; def f():
...     a += 1
... 
&gt;&gt;&gt; f()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in f
UnboundLocalError: local variable 'a' referenced before assignment
</code></pre>
<p>You might get what you want with the (very frowned upon, and for good reasons) <code>global</code> keyword, like so:</p>
<pre><code>&gt;&gt;&gt; def f():
...     global a
...     a += 1
... 
&gt;&gt;&gt; a
1
&gt;&gt;&gt; f()
&gt;&gt;&gt; a
2
</code></pre>
<p>In general however, you should <em>avoid</em> using global variables which become extremely quickly out of hand. And this is especially true for multithreaded programs, where you don't have any synchronization mechanism for your <code>thread1</code> to know when <code>a</code> has been modified. In short: threads are <strong>complicated</strong>, and you cannot expect to have an intuitive understanding of the order in which events are happening when two (or more) threads work on the same value. The language, compiler, OS, processor... can ALL play a role, and decide to modify the order of operations for speed, practicality or any other reason.</p>
<p>The proper way for this kind of thing is to use Python sharing tools (<a href="http://docs.python.org/2/library/threading.html#lock-objects" rel="nofollow noreferrer">locks</a>
 and friends), or better, communicate data via a <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">Queue</a> instead of sharing it, e.g. like this:</p>
<pre><code>from threading import Thread
from queue import Queue
import time

def thread1(threadname, q):
    #read variable "a" modify by thread 2
    while True:
        a = q.get()
        if a is None: return # Poison pill
        print a

def thread2(threadname, q):
    a = 0
    for _ in xrange(10):
        a += 1
        q.put(a)
        time.sleep(1)
    q.put(None) # Poison pill

queue = Queue()
thread1 = Thread( target=thread1, args=("Thread-1", queue) )
thread2 = Thread( target=thread2, args=("Thread-2", queue) )

thread1.start()
thread2.start()
thread1.join()
thread2.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A lock should be considered to use, such as <code>threading.Lock</code>. See <a href="https://docs.python.org/2/library/threading.html#lock-objects" rel="nofollow noreferrer">lock-objects</a> for more info.</p>
<p>The accepted answer CAN print 10 by thread1, which is not what you want. You can run the following code to understand the bug more easily.</p>
<pre><code>def thread1(threadname):
    while True:
      if a % 2 and not a % 2:
          print "unreachable."

def thread2(threadname):
    global a
    while True:
        a += 1
</code></pre>
<p>Using a lock can forbid changing of <code>a</code> while reading more than one time:</p>
<pre><code>def thread1(threadname):
    while True:
      lock_a.acquire()
      if a % 2 and not a % 2:
          print "unreachable."
      lock_a.release()

def thread2(threadname):
    global a
    while True:
        lock_a.acquire()
        a += 1
        lock_a.release()
</code></pre>
<p>If thread using the variable for long time, coping it to a local variable first is a good choice.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, running example:</p>
<p><strong>WARNING! NEVER DO THIS AT HOME/WORK!</strong> Only in classroom ;) </p>
<p>Use semaphores, shared variables, etc. to avoid rush conditions.</p>
<pre><code>from threading import Thread
import time

a = 0  # global variable


def thread1(threadname):
    global a
    for k in range(100):
        print("{} {}".format(threadname, a))
        time.sleep(0.1)
        if k == 5:
            a += 100


def thread2(threadname):
    global a
    for k in range(10):
        a += 1
        time.sleep(0.2)


thread1 = Thread(target=thread1, args=("Thread-1",))
thread2 = Thread(target=thread2, args=("Thread-2",))

thread1.start()
thread2.start()

thread1.join()
thread2.join()
</code></pre>
<p>and the output:</p>
<pre><code>Thread-1 0
Thread-1 1
Thread-1 2
Thread-1 2
Thread-1 3
Thread-1 3
Thread-1 104
Thread-1 104
Thread-1 105
Thread-1 105
Thread-1 106
Thread-1 106
Thread-1 107
Thread-1 107
Thread-1 108
Thread-1 108
Thread-1 109
Thread-1 109
Thread-1 110
Thread-1 110
Thread-1 110
Thread-1 110
Thread-1 110
Thread-1 110
Thread-1 110
Thread-1 110
</code></pre>
<p>If the timing were right, the <code>a += 100</code> operation would be skipped:</p>
<p>Processor executes at T <code>a+100</code> and gets 104. But it stops, and jumps to next thread
Here, At T+1 executes <code>a+1</code> with old value of a, <code>a == 4</code>.  So it computes 5.
Jump back (at T+2), thread 1, and write <code>a=104</code> in memory.
Now back at thread 2, time is T+3 and write <code>a=5</code> in memory.
Voila! The next print instruction will print 5 instead of 104. </p>
<p>VERY nasty bug to be reproduced and caught.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks so much Jason Pan for suggesting that method. The thread1 if statement is not atomic, so that while that statement executes, it's possible for thread2 to intrude on thread1, allowing non-reachable code to be reached. I've organized ideas from the prior posts into a complete demonstration program (below) that I ran with Python 2.7.</p>
<p>With some thoughtful analysis I'm sure we could gain further insight, but for now I think it's important to demonstrate what happens when non-atomic behavior meets threading.</p>
<pre><code># ThreadTest01.py - Demonstrates that if non-atomic actions on
# global variables are protected, task can intrude on each other.
from threading import Thread
import time

# global variable
a = 0; NN = 100

def thread1(threadname):
    while True:
      if a % 2 and not a % 2:
          print("unreachable.")
    # end of thread1

def thread2(threadname):
    global a
    for _ in range(NN):
        a += 1
        time.sleep(0.1)
    # end of thread2

thread1 = Thread(target=thread1, args=("Thread1",))
thread2 = Thread(target=thread2, args=("Thread2",))

thread1.start()
thread2.start()

thread2.join()
# end of ThreadTest01.py
</code></pre>
<p>As predicted, in running the example, the "unreachable" code sometimes is actually reached, producing output.</p>
<p>Just to add, when I inserted a lock acquire/release pair into thread1 I found that the probability of having the "unreachable" message print was greatly reduced. To see the message I reduced the sleep time to 0.01 sec and increased NN to 1000. </p>
<p>With a lock acquire/release pair in thread1 I didn't expect to see the message at all, but it's there. After I inserted a lock acquire/release pair also into thread2, the message no longer appeared. In hind signt, the increment statement in thread2 probably also is non-atomic.</p>
</div>
<span class="comment-copy">This solves a big problem . And seems pretty much the right approach to go abt it.</span>
<span class="comment-copy">This is the way I am using for solving synchronization problem.</span>
<span class="comment-copy">I have some questions.First, If I have multiple variables to share between threads, do I need a separate queue for each variable ? Second, why are the queues in the above program synced ? Shouldn't each act as local copy in each function ?</span>
<span class="comment-copy">This is old, but I answer anyway. The queue itself is not synchronized, no more than the variable <code>a</code>. It's the default blocking behavior of the queue that creates the synchronization.  The statement <code>a = q.get()</code> will block (wait) until a value a is available.  The variable <code>q</code> is local : if you assign a different value to it, it will happen locally only.  But the queue assigned to it in the code is the one that is defined in the main thread.</span>
<span class="comment-copy">It's not always necessary to use a queue to share information information between threads.  The example in chepner answer is perfectly fine.  Also, a queue is not always the right tool. A queue is useful, for example, if you want to block until the value is available. It's useless if the two threads compete on a shared resource.  Finally, global variables are not worst in threads. They can be in fact more natural. For example, your thread might just be a block of code, say a loop,  that needs its own process. The local scope is thus artificially created when you put the loop in a function.</span>
<span class="comment-copy">You need the locks in both threads because these are cooperative, "advisory locks" (not "mandatory"). You're right in that the increment statement is non-atomic.</span>
