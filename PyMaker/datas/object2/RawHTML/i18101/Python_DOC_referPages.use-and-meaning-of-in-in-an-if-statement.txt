<div class="post-text" itemprop="text">
<p>In an example from Zed Shaw's <em>Learn Python the Hard Way</em>, one of the exercises displays the following code:</p>
<pre><code>next = raw_input("&gt; ")
if "0" in next or "1" in next:
    how_much = int(next)
</code></pre>
<p>I'm having a hard time understanding the meaning of <code>in</code> in this statement. I'm used to using <code>if</code> statements, such as in javascript, where the syntax is something like:</p>
<pre><code>var = 5;
if (var &gt; 3) {
    //code  to be executed
}
</code></pre>
<p>Is this <code>if</code> / <code>in</code> statement (in python) the same as <code>if()</code> in javascript?</p>
<p>Finding an answer to this has been tricky because the <code>in</code> is such a short string to narrow down an answer via search engine, and I don't know the proper name for its operation.</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends on what <code>next</code> is.</p>
<p>If it's a string (as in your example), then <code>in</code> checks for substrings.</p>
<pre><code>&gt;&gt;&gt; "in" in "indigo"
True
&gt;&gt;&gt; "in" in "violet"
False
&gt;&gt;&gt; "0" in "10"
True
&gt;&gt;&gt; "1" in "10"
True
</code></pre>
<p>If it's a different kind of iterable (list, tuple, set, dictionary...), then <code>in</code> checks for membership.</p>
<pre><code>&gt;&gt;&gt; "in" in ["in", "out"]
True
&gt;&gt;&gt; "in" in ["indigo", "violet"]
False
</code></pre>
<p>In a dictionary, membership is seen as "being one of the keys":</p>
<pre><code>&gt;&gt;&gt; "in" in {"in": "out"}
True
&gt;&gt;&gt; "in" in {"out": "in"}
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>a in b</code> is simply translates to <code>b.__contains__(a)</code>, which <em>should</em> return if b includes a or not.</p>
<p>But, your example looks a little weird, it takes an input from user and assigns its integer value to <code>how_much</code> variable <strong>if the input contains <code>"0"</code> or <code>"1"</code></strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you claim to be used to JavaScript:</p>
<p>The Python <a href="http://docs.python.org/3/reference/expressions.html#in" rel="noreferrer"><code>in</code></a> operator is similar to the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in" rel="noreferrer"><code>in</code></a> operator.</p>
<p>Here's some JavaScript:</p>
<pre><code>var d = {1: 2, 3: 4};
if (1 in d) {
    alert('true!');
}
</code></pre>
<p>And the equivalent Python:</p>
<pre><code>d = {1: 2, 3: 4}
if 1 in d:
    print('true!')
</code></pre>
<p>With objects/dicts, they're nearly identical, both checking whether <code>1</code> is a key of the object/dict. The big difference, of course, is that JavaScript is sloppily-typed, so <code>'1' in d</code> would be just as true.</p>
<p>With arrays/lists, they're very different. A JS array is an object, and its indexes are the keys, so <code>1 in [3, 4, 5]</code> will be <code>true</code>. A Python list is completely different from a dict, and its <code>in</code> operator checks the <em>values</em>, not the <em>indexes</em>, which tends to be more useful. And Python extends this behavior to all iterables.</p>
<p>With strings, they're even more different. A JS string isn't an object, so you will get a <code>TypeError</code>. But a Python <code>str</code> or <code>unicode</code> will check whether the other operand is a <em>substring</em>. (This means <code>1 in '123'</code> is illegal, because <code>1</code> can't be a substring of anything, but <code>'1' in '123'</code> is true.)</p>
<p>With objects as objects, in JS there is of course no distinction, but in Python, objects are instances of classes, not dicts. So, in JS, <code>1 in d</code> will be true for an object if it has a member or method named <code>'1'</code>, but in Python, it's up to your class what it means—Python will call <code>d.__contains__(1)</code>, then, if that fails, it tries to use your object as an utterable (by calling its <code>__iter__</code>, and, if that fails, by trying to index it with integers starting from <code>0</code>).</p>
<p>Also, note that JS's <code>in</code>, because it's actually checking for object membership, does the usual JS method-resolution-order search, while Python's <code>in</code>, because it's checking for keys of a dict, members of a sequence, etc., does no such thing. So, technically, it's probably a bit closer to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" rel="noreferrer"><code>hasOwnProperty</code></a> method than the <code>in</code> operator.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe these examples will help illustrate what <code>in</code> does. It basically translate to <code>Is this item in this other item?</code></p>
<pre><code>listOfNums = [ 1, 2, 3, 4, 5, 6, 45, 'j' ]

&gt;&gt;&gt; 3 in listOfNums:
&gt;&gt;&gt; True

&gt;&gt;&gt; 'j' in listOfNums:
&gt;&gt;&gt; True

&gt;&gt;&gt; 66 in listOfNums:
&gt;&gt;&gt; False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are used to using the javascript <code>if</code>, and I assume you know how it works.</p>
<p><code>in</code> is a <em>Pythonic</em> way of implementing iteration. It's supposed to be easier for non-programmatic thinkers to adopt, but that can sometimes make it harder for programmatic thinkers, ironically.</p>
<p>When you say <code>if x in y</code>, you are literally saying:</p>
<p>"if <code>x</code> is in <code>y</code>", which assumes that <code>y</code> has an index. In that <code>if</code> statement then, each object at each index in <code>y</code> is checked against the condition.</p>
<p>Similarly,</p>
<p><code>for x in y</code></p>
<p>iterates through <code>x</code>'s in <code>y</code>, where <code>y</code> is that indexable set of items.</p>
<p>Think of the <code>if</code> situation this way (pseudo-code):</p>
<pre><code>for i in next:
    if i == "0" || i == "1":
        how_much = int(next)
</code></pre>
<p>It takes care of the iteration over <code>next</code> for you.</p>
<p>Happy coding!</p>
</div>
<div class="post-text" itemprop="text">
<p>Here <code>raw_input</code> is <code>string</code>, so if you wanted to check, <code>if var&gt;3</code> then you should convert next to double, ie <code>float(next)</code> and do as you would do <code>if float(next)&gt;3</code>:, but in most cases</p>
</div>
<div class="post-text" itemprop="text">
<p>the reserved word "in" is used to look inside an object that can be iterated over.</p>
<pre><code>list_obj = ['a', 'b', 'c']
tuple_obj = ('a', 1, 2.0)
dict_obj = {'a': 1, 'b': 2.0}
obj_to_find = 'c'
if obj_to_find in list_obj:
    print('Object {0} is in {1}'.format(obj_to_find, list_obj))
obj_to_find = 2.0
if obj_to_find in tuple_obj:
    print('Object {0} is in {1}'.format(obj_to_find, tuple_obj))
obj_to_find = 'b'
if obj_to_find in dict_obj:
    print('Object {0} is in {1}'.format(obj_to_find, dict_obj))
</code></pre>
<p>Output:</p>
<pre><code>Object c is in ['a', 'b', 'c']
Object 2.0 is in ('a', 1, 2.0)
Object b is in {'a': 1, 'b': 2.0}
</code></pre>
<p>However </p>
<pre><code>cannot_iterate_over = 5.5
obj_to_find = 5.5
if obj_to_find in cannot_iterate_over:
    print('Object {0} is in {1}'.format(obj_to_find, cannot_iterate_over))
</code></pre>
<p>will throw</p>
<pre><code>Traceback (most recent call last):
File "/home/jgranger/workspace/sandbox/src/csv_file_creator.py", line 43, in &lt;module&gt;
if obj_to_find in cannot_iterate_over:
TypeError: argument of type 'float' is not iterable
</code></pre>
<p>In your case, raw_input("&gt; ") returns iterable object or it will throw TypeError</p>
</div>
<div class="post-text" itemprop="text">
<p>This may be a very late answer. 
<em>in</em> operator checks for memberships. That is, it checks if its left operand is a member of its right operand.  In this case, raw_input() returns an <em>str</em> object of what is supplied by the user at the standard input.  So, the <em>if</em> condition checks whether the input contains substrings "0" or "1". Considering the typecasting (<em>int()</em>) in the following line, the <em>if</em> condition essentially checks if the input contains digits 0 or 1.</p>
</div>
<span class="comment-copy"><a href="http://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange" rel="nofollow noreferrer">docs.python.org/2/library/…</a></span>
<span class="comment-copy">It may also help to search Google using operators-- for example, <code>python "in" operator</code> gives exactly what you would need in its first few results.</span>
<span class="comment-copy">On recent Pythons (2.6+), you should not use <code>next</code> as a variable name. You will overwrite the built-in function <a href="http://docs.python.org/2/library/functions.html#next" rel="nofollow noreferrer">next</a></span>
<span class="comment-copy">If you're used to JavaScript, how could you not know that it also has an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in" rel="nofollow noreferrer"><code>in</code></a> operator?</span>
<span class="comment-copy">@Scherf: Well, it's "connected" to an <code>if</code> statement in the same way that <code>&gt;</code> or any other operator is… and the same way as in JavaScript.</span>
<span class="comment-copy">or a custom classes <code>__contains__</code>  method ;P</span>
<span class="comment-copy">"If the input contains 1 or 2"; why 1 or 2, and not 1 or 0? And for my own sake 'contains' literally means if the string has either number in it, then the expression is true?</span>
<span class="comment-copy">My mistake, I misread those, of course it should be 1 or 0. Actually, contains checks(for strings), if given string is a substring(as others mentioned). There is two calls there: <code>if next.__contains__("0") or next.__contains__("1"):</code>.</span>
<span class="comment-copy">+1: This answer complemenents the accepted one very well. For advanced users, it's better to be told about the implementation details than how to use the implementation.</span>
<span class="comment-copy"><a href="http://docs.python.org/2/library/functions.html#raw_input" rel="nofollow noreferrer"><code>raw_input</code></a> is guaranteed to return a <code>str</code>, which is iterable, so you don't need to guess whether it's returning an iterable object.</span>
