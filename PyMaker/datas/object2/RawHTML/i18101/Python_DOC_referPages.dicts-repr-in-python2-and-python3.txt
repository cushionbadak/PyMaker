<div class="post-text" itemprop="text">
<p>I'm porting a python library from python 2 only to python 2 and 3 in one codebase (2.6, 2.7 and 3.3+). The main problem left is that a lot of tests use something like this:</p>
<pre><code>def test(self):
 example = {u'foo': u'bar'}
 self.assertEqual(str(example), "{u'foo': u'bar'}")
</code></pre>
<p>which works in python 2, but raises an exception in python3:</p>
<pre><code> AssertionError: "{'foo': 'bar'}" != "{u'foo': u'bar'}"
</code></pre>
<p>Is there a standard way of dealing with these problems apart from 'test different'? overloading<code>__repr__</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Get rid of those tests; they are next to useless:</p>
<ul>
<li><p>This tests if the Python implementation of <code>dict.__repr__</code> is working. Python itself already tests for this; focus on the project codebase instead. If Python fails to render a dictionary representation correctly it's not your project's job to fix that.</p></li>
<li><p>Python dictionaries have no fixed ordering; testing if their representation matches a given string is not going to be stable.</p>
<p>Moreover, Python 3.3 introduces hash randomization, meaning that the order of a given dictionary will change from invocation to invocation. See <a href="http://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED"><code>PYTHONHASHSEED</code></a>.</p></li>
</ul>
<p>If you are testing the result of a project API calll, test for dictionary equality using <a href="http://docs.python.org/3/library/unittest.html#unittest.TestCase.assertEqual"><code>self.assertEqual()</code></a> instead; it'll use <a href="http://docs.python.org/3/library/unittest.html#unittest.TestCase.assertDictEqual"><code>assertDictEqual()</code></a> to give you meaningful error messages if the two dictionaries do not match.</p>
<p>Since Python 3.3 interprets <code>u'foo'</code> as a literal for type <code>str</code>, comparing output against <code>{u'foo': u'bar}</code> will work across Python 2.6, 2.7 and 3.3 and newer.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suspect that this isn't your real code, and your real code is doing something slightly less silly: trying to verify that a dictionary matches some expected result.</p>
<p>The way to do this is to compare the dictionaries directly, instead of comparing their string representations:</p>
<pre><code>self.assertEqual(example, {u'foo': u'bar'})
</code></pre>
<p>This will work in both 2.x and 3.x (since you're requiring 3.3+, which means the <code>u</code> prefixes are legal, if unnecessary).</p>
</div>
<span class="comment-copy">Why do you have these tests? What are they attempting to verify? This smells very strongly of an <a href="http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a>.</span>
<span class="comment-copy">to clarify: in the actual code, <i>example</i> is a subclass of dict and is the return value of another function. this subclass has it's own <code>__repr__</code>, wrapping dict's <code>__repr__</code>, but the 'u's are still in there</span>
<span class="comment-copy">That doesn't clarify <i>anything</i>. What are you actually trying to test here? Is the problem that the subclass's <code>__eq__</code> doesn't work right with a base <code>dict</code> object, so you're trying to work around it by comparing their <code>repr</code>? Or…?</span>
<span class="comment-copy">@ChristianGeier: you are comparing against a fixed string; generate the fixed string with or without <code>u</code> prefixes if you <i>have</i> to test the custom <code>__repr__</code>.</span>
<span class="comment-copy">@abarnert <code>__eq__</code> does work, I have no idea why the original author tested via <code>__repr__</code>. I guess I'll just use that and be done with it.</span>
<span class="comment-copy">Also, in python3 strings became unicode by default. That means standard strings don't have thet <code>u</code> prefix anymore.</span>
<span class="comment-copy">Checking <code>self.assertEqual(example, ast.literal_eval({u'foo': u'bar'}))</code> is less impossible, and serves a <i>similar</i> purpose… but I still can't imagine what that purpose might be, so it's hard to say whether it's similar <i>enough</i>.</span>
<span class="comment-copy">@MartijnPieters, to be fair, ordering is irrelevant in <i>this</i> example:  <code>len(example) == 1</code>.</span>
<span class="comment-copy"><code>assertDictEqual</code> doesn't exist in 2.6. And in 2.7 and 3.3, while it does exist, "This method will be used by default to compare dictionaries in calls to <code>assertEqual()</code>", so it doesn't add much.</span>
<span class="comment-copy">@abarnert: Indeed, updated.</span>
