<div class="post-text" itemprop="text">
<p>Is there a standard way (without installing third party libraries) to do cross platform filesystem mocking in Python? If I have to go with a third party library, which library is the standard?</p>
</div>
<div class="post-text" itemprop="text">
<p>The standard mocking framework in Python 3.3+ is <a href="https://docs.python.org/3/library/unittest.mock.html" rel="noreferrer">unittest.mock</a>; you can use this for the filesystem or anything else.</p>
<p>You could also simply hand roll it by mocking via monkey patching:</p>
<p>A trivial example:</p>
<pre><code>import os.path
os.path.isfile = lambda path: path == '/path/to/testfile'
</code></pre>
<p>A bit more full (untested):</p>
<pre><code>import classtobetested                                                                                                                                                                                      
import unittest                                                                                                                                                                                             

import contextlib                                                                                                                                                                                           

@contextlib.contextmanager                                                                                                                                                                                  
def monkey_patch(module, fn_name, patch):                                                                                                                                                                   
    unpatch = getattr(module, fn_name)                                                                                                                                                                      
    setattr(module, fn_name)                                                                                                                                                                                
    try:                                                                                                                                                                                                    
        yield                                                                                                                                                                                               
    finally:                                                                                                                                                                                                
        setattr(module, fn_name, unpatch)                                                                                                                                                                   


class TestTheClassToBeTested(unittest.TestCase):                                                                                                                                                              
    def test_with_fs_mocks(self):                                                                                                                                                                           
        with monkey_patch(classtobetested.os.path,                                                                                                                                                          
                          'isfile',                                                                                                                                                                         
                          lambda path: path == '/path/to/file'):                                                                                                                                            
            self.assertTrue(classtobetested.testable())                 
</code></pre>
<p>In this example, the actual mocks are trivial, but you could back them with something that has state so that can represent filesystem actions, such as save and delete. Yes, this is all a bit ugly since it entails replicating/simulating basic filesystem in code.</p>
<p>Note that you can't monkey patch python builtins. That being said...</p>
<p>For earlier versions, if at all possible use a third party library, I'd go with Michael Foord's awesome <a href="http://www.voidspace.org.uk/python/mock/" rel="noreferrer">Mock</a>, which is now <code>unittest.mock</code> in the standard library since 3.3+ thanks to <a href="http://www.python.org/dev/peps/pep-0417/" rel="noreferrer">PEP 0417</a>, and you can get it on <a href="https://pypi.python.org/pypi/mock" rel="noreferrer">PyPI</a> for Python 2.5+. And, it can mock builtins!</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://pypi.python.org/pypi/pyfakefs" rel="noreferrer">pyfakefs</a> (<a href="https://github.com/jmcgeheeiv/pyfakefs/" rel="noreferrer">homepage</a>) does what you want – a <em>fake</em> filesystem; it’s third-party, though that party is Google. See <a href="https://stackoverflow.com/questions/16468443/how-to-replace-file-access-references-for-a-module-under-test">How to replace file-access references for a module under test</a> for discussion of use.</p>
<p>For <em>mocking</em>, <a href="https://docs.python.org/3/library/unittest.mock.html" rel="noreferrer">unittest.mock</a> is the standard library for Python 3.3+ (<a href="http://legacy.python.org/dev/peps/pep-0417/" rel="noreferrer">PEP 0417</a>); for earlier version see <a href="https://pypi.python.org/pypi/mock" rel="noreferrer">PyPI: mock</a> (for Python 2.5+) (<a href="http://www.voidspace.org.uk/python/mock/" rel="noreferrer">homepage</a>).</p>
<p>Terminology in testing and mocking is inconsistent; using the <a href="http://xunitpatterns.com/Test%20Double.html" rel="noreferrer">Test Double</a> terminology of Gerard Meszaros, you’re asking for a “fake”: something that behaves like a filesystem (you can create, open, and delete files), but isn’t the actual file system (in this case it’s in-memory), so you don’t need to have test files or a temporary directory.</p>
<p>In classic mocking, you would instead <em>mock</em> out the system calls (in Python, mock out functions in the <code>os</code> module, like <code>os.rm</code>  and <code>os.listdir</code>), but that’s much more fiddly.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://pytest.org/latest/" rel="noreferrer">pytest</a> is gaining a lot of traction, and it can do all of this using <a href="http://pytest.org/latest/tmpdir.html" rel="noreferrer">tmpdir</a> and <a href="http://pytest.org/latest/monkeypatch.html" rel="noreferrer">monkeypatching</a> (mocking).</p>
<p>You can use the <code>tmpdir</code> function argument which will provide a temporary directory unique to the test invocation, created in the base temporary directory (which are by default created as sub-directories of the system temporary directory).</p>
<pre><code>import os
def test_create_file(tmpdir):
    p = tmpdir.mkdir("sub").join("hello.txt")
    p.write("content")
    assert p.read() == "content"
    assert len(tmpdir.listdir()) == 1
</code></pre>
<p>The <code>monkeypatch</code> function argument helps you to safely set/delete an attribute, dictionary item or environment variable or to modify <code>sys.path</code> for importing. </p>
<pre><code>import os
def test_some_interaction(monkeypatch):
    monkeypatch.setattr(os, "getcwd", lambda: "/")
</code></pre>
<p>You can also pass it a function instead of using lambda.</p>
<pre><code>import os.path
def getssh(): # pseudo application code
    return os.path.join(os.path.expanduser("~admin"), '.ssh')

def test_mytest(monkeypatch):
    def mockreturn(path):
        return '/abc'
    monkeypatch.setattr(os.path, 'expanduser', mockreturn)
    x = getssh()
    assert x == '/abc/.ssh'

# You can still use lambda when passing arguments, e.g.
# monkeypatch.setattr(os.path, 'expanduser', lambda x: '/abc')
</code></pre>
<p>If your application has a lot of interaction with the file system, then it might be easier to use something like <a href="https://code.google.com/p/pyfakefs/" rel="noreferrer">pyfakefs</a>, as mocking would become tedious and repetitive.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Faking or Mocking?</h2>
<p>Personally, I find that there are a lot of edge cases in filesystem things (like opening the file with the right permissions, string-vs-binary, read/write mode, etc), and using an accurate fake filesystem can find a lot of bugs that you might not find by mocking. In this case, I would check out the <a href="http://docs.pyfilesystem.org/en/latest/memoryfs.html#module-fs.memoryfs" rel="noreferrer"><code>memoryfs</code></a> module of <a href="http://docs.pyfilesystem.org/en/latest/index.html" rel="noreferrer"><code>pyfilesystem</code></a> (it has various concrete implementations of the same interface, so you can swap them out in your code).</p>
<h2>Mocking (and without Monkey Patching!):</h2>
<p>That said, if you really want to mock, you can do that easily with Python's <a href="https://docs.python.org/3/library/unittest.mock.html" rel="noreferrer"><code>unittest.mock</code></a> library:</p>
<pre><code># production code file; note the default parameter
def make_hello_world(path, open_func=open):
    with open_func(path, 'w+') as f:
        f.write('hello, world!')

# test code file
def test_make_hello_world():
    file_mock = unittest.mock.Mock(write=unittest.mock.Mock())
    open_mock = unittest.mock.Mock(return_value=file_mock)

    # When `make_hello_world()` is called
    make_hello_world('/hello/world.txt', open_func=open_mock)

    # Then expect the file was opened and written-to properly
    open_mock.assert_called_once_with('/hello/world.txt', 'w+')
    file_mock.write.assert_called_once_with('hello, world!')
</code></pre>
<p>The above example only demonstrates creating and writing to files via mocking the <code>open()</code> method, but you could just as easily mock any method.</p>
</div>
<span class="comment-copy">The concept <code>filesystem</code> is too broad.  It could be anyting. What exactly do you want?</span>
<span class="comment-copy">@Leonardo.Z: Any interaction with the file system. I am mostly concerned about <b>creating</b>, <b>opening</b> and <b>deleting</b> files and directories. In other languages the whole file-system can be mocked.</span>
<span class="comment-copy">Ah, my answer is definitely missing the mark. Can your tests create the files necessary for the tests? e.g. could you have a testing directory which you create, populate, test within and then delete as part of your tests</span>
<span class="comment-copy">Would the <a href="http://docs.python.org/2/library/tempfile.html" rel="nofollow noreferrer">tempfile</a> module be of help?</span>
