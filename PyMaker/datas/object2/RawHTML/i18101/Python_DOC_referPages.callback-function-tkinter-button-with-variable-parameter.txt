<div class="post-text" itemprop="text">
<pre><code>from tkinter import *

F=Tk()

i=1
while i&lt;10:
    newButton = Button(F,text="Show Number",command=lambda:showNumber(i))
    newButton.pack(side=TOP)
    i+=1

def showNumber(nb):
    print(nb)

F.mainloop()
</code></pre>
<p>All buttons return 10. Why ? <br/>
I want button 1 return 1, button 2 return 2... <br/>
Thank you very much for helping me</p>
</div>
<div class="post-text" itemprop="text">
<p>Your anonymous <code>lambda</code> functions are can be though of as closures (as @abernert points out, they're not <em>actually</em> closures in Python's case) - they "close over" the variable <code>i</code>, to reference it later. However, they don't look up the value at the time of definition, but rather <strong>at the time of calling</strong>, which is some time <em>after</em> the entire <code>while</code> loop is over (at which point, <code>i</code> is equal to 10).</p>
<p>To fix this, you need to re-bind the value of <code>i</code> to a something else for the lambda to use. You can do this in many ways - here's one:</p>
<pre><code>...
i = 1
while i &lt; 10:
    # Give a parameter to the lambda, defaulting to i (function default
    # arguments are bound at time of declaration)
    newButton = Button(F, text="Show Number",
        command=lambda num=i: showNumber(num))
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is explained in the Python FAQ: <a href="http://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" rel="nofollow">Why do lambdas defined in a loop with different values all return the same result?</a>.</p>
<hr/>
<p>Quoting the FAQ answer:</p>
<blockquote>
<p>This happens because x is not local to the lambdas, but is defined in the outer scope, and it is accessed when the lambda is called — not when it is defined…</p>
<p>In order to avoid this, you need to save the values in variables local to the lambdas, so that they don’t rely on the value of the global…</p>
</blockquote>
<p>In other words, your new functions aren't storing the <em>value of <code>i</code></em>, they're storing <em>the variable <code>i</code></em>. And they're all storing the <em>same</em> variable <code>i</code>, which has the value <code>10</code> at the end of your loop. In fact, if you add an <code>i = 'spam'</code> right before <code>F.mainloop()</code>, you'll see that all the buttons now print out the string <code>spam</code> instead of a number.</p>
<p>This is very useful when you're trying to create closures—functions that can affect their defining environment.* But when you're <em>not</em> trying to do so, that can get in the way.</p>
<p>The simplest way around this is to use a parameter with a default value. Default values don't hold variables; just values, which are evaluated at the time the function is defined. So:</p>
<pre><code>newButton = Button(F,text="Show Number", command=lambda num=i: showNumber(num))
</code></pre>
<hr/>
<p>* Note that in this case, there aren't actually any closures involved, because <code>i</code> is a global, rather than a local in the enclosing scope. But really, this is just because Python has special handling for globals and doesn't need a closure here; conceptually, if you think of there being one, you won't get into any trouble unless you start looking at the <code>__closure__</code> or <code>__code__</code> attributes.</p>
</div>
<span class="comment-copy">Thank you very much ! :)</span>
<span class="comment-copy">This isn't quite accurate, because there's <i>not</i> actually a closure here. But it is a conciser explanation than mine, and hopefully easier for a novice to understand.</span>
<span class="comment-copy">@abarnert: Thanks for mentioning it, though - it's little technicalities like that that makes me enjoy StackOverflow, and learn in the process.</span>
<span class="comment-copy">Thank you ! :) It's Work !</span>
<span class="comment-copy">Good point, I wasn't aware that Python handles module-level variables differently.</span>
