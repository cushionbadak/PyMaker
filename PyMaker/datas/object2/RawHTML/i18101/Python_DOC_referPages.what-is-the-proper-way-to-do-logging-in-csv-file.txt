<div class="post-text" itemprop="text">
<p>i want to log some information of every single request send to a busy http server in a formatted form,use log module would create some thing i don't want to:</p>
<pre><code>[I 131104 15:31:29 Sys:34]
</code></pre>
<p>i think of csv format but i don't know how to customize it,and python got csv module,but read the manual </p>
<pre><code>import csv
with open('some.csv', 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerows(someiterable)
</code></pre>
<p>since it would open and close a file each time, i am afraid in this way would slow down the whole server performance, what could i do?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use python's <a href="http://docs.python.org/2/library/logging.html" rel="nofollow noreferrer"><code>logging</code></a> module.</p>
<p>You can adjust the output the way you want; take a look at <a href="http://docs.python.org/2/howto/logging.html#changing-the-format-of-displayed-messages" rel="nofollow noreferrer">Changing the format of displayed messages</a>:</p>
<blockquote>
<p>To change the format which is used to display messages, you need to specify the format you want to use:</p>
<pre><code>import logging
logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)
logging.debug('This message should appear on the console')
logging.info('So should this')
logging.warning('And this, too')
</code></pre>
</blockquote>
<p>and <a href="http://docs.python.org/2/howto/logging.html#formatters" rel="nofollow noreferrer">Formatters</a>:</p>
<blockquote>
<p>Formatter objects configure the final order, structure, and contents of the log message.</p>
</blockquote>
<p>You'll find a list of the attribtus you can use here: <a href="http://docs.python.org/2/library/logging.html#logrecord-attributes" rel="nofollow noreferrer">LogRecord attributes</a>.</p>
<hr/>
<p>If you want to produce a valid csv-file, use python's <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code> module</a>, too.</p>
<p>Here's a simple example:</p>
<pre><code>import logging
import csv
import io

class CsvFormatter(logging.Formatter):
    def __init__(self):
        super().__init__()
        self.output = io.StringIO()
        self.writer = csv.writer(self.output, quoting=csv.QUOTE_ALL)

    def format(self, record):
        self.writer.writerow([record.levelname, record.msg])
        data = self.output.getvalue()
        self.output.truncate(0)
        self.output.seek(0)
        return data.strip()

logging.basicConfig(level=logging.DEBUG)

logger = logging.getLogger(__name__)
logging.root.handlers[0].setFormatter(CsvFormatter())

logger.debug('This message should appear on the console')
logger.info('So should "this", and it\'s using quoting...')
logger.warning('And this, too')
</code></pre>
<p>Output:</p>
<blockquote>
<p>"DEBUG","This message should appear on the console"<br/>
  "INFO","So should ""this"", and it's using quoting..."<br/>
  "WARNING","And this, too"  </p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I would agree that you should use the logging module, but you can't really do it properly with just a format string like some of the other answers show, as they do not address the situation where you log a message that contains a comma.</p>
<p>If you need a solution that will properly escape any special characters in the message (or other fields, I suppose), you would have to write a custom formatter and set it.</p>
<pre><code>logger = logging.getLogger()

formatter = MyCsvFormatter()

handler = logging.FileHandler(filename, "w")
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(level)
</code></pre>
<p>You'll obviously have to implement the MyCsvFormatter class, which should inherit from logging.Formatter and override the format() method</p>
<pre><code>class MyCsvFormatter(logging.Formatter):
    def __init__(self):
        fmt = "%(levelname)s,%(message)s" # Set a format that uses commas, like the other answers
        super(MyCsvFormatter, self).__init__(fmt=fmt)

    def format(self, record):
        msg = record.getMessage()
        # convert msg to a csv compatible string using your method of choice
        record.msg = msg
        return super(MyCsvFormatter, self).format(self, record)
</code></pre>
<p>Note: I've done something like this before, but haven't tested this particular code sample</p>
<p>As far as doing the actual escaping of the message, here's one possible approach:
<a href="https://stackoverflow.com/questions/9157314/python-write-data-into-csv-format-as-string-not-file">Python - write data into csv format as string (not file)</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As sloth suggests, you can easily edit the delimiter of the log to a comma, thus producing a CSV file.</p>
<p>Working example:</p>
<pre><code>import logging

# create logger
lgr = logging.getLogger('logger name')
lgr.setLevel(logging.DEBUG) # log all escalated at and above DEBUG
# add a file handler
fh = logging.FileHandler('path_of_your_log.csv')
fh.setLevel(logging.DEBUG) # ensure all messages are logged to file

# create a formatter and set the formatter for the handler.
frmt = logging.Formatter('%(asctime)s,%(name)s,%(levelname)s,%(message)s')
fh.setFormatter(frmt)

# add the Handler to the logger
lgr.addHandler(fh)

# You can now start issuing logging statements in your code
lgr.debug('a debug message')
lgr.info('an info message')
lgr.warn('A Checkout this warning.')
lgr.error('An error writen here.')
lgr.critical('Something very critical happened.')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think that is the best idea, but it is doable, and quite simple.
Manually buffer your log. Store log entries in some place, and write them to file from time to time. 
If you know that your server will be constantly busy, flush your buffer when it reaches some size. If there may be big gaps in usage, I'd say that new thread (or better process, check yourself why threads suck and slow down apps) with endless (theoretically of course) loop of sleep/flush would be better call.
Also, remember to create some kind of hook that will flush buffer when server is interrupted or fails (maybe signals? or just try/except on main function - there are even more ways to do it), so you don't lose unflushed buffer data on unexpected exit.</p>
<p>I repeat - this is not the best idea, it's the first thing that came to my mind. You may want to consult logging implementations from Flask or some other webapp framework (AFAIR Flask has CSV logging too).</p>
</div>
<span class="comment-copy">You should use a logging.Formatter instance with a format that outputs csv lines.</span>
<span class="comment-copy">This in my opinion should be the accepted answer as it doesn't make assumptions about the content of the log messages—specifically, with this approach one doesn't need to worry about double quotes or commas or newlines garbling the log output.</span>
<span class="comment-copy">is there a way to add a CSV Header Row? (i.e. a first row in the CSV Text File containing the names of the columns?)</span>
<span class="comment-copy">Aye, this might be what you're looking for: <a href="http://stackoverflow.com/questions/27840094/write-a-header-at-every-logfile-that-is-created-with-a-time-rotating-logger" title="write a header at every logfile that is created with a time rotating logger">stackoverflow.com/questions/27840094/…</a></span>
