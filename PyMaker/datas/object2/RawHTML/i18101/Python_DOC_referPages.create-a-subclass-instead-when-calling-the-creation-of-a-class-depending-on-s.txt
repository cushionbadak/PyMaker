<div class="post-text" itemprop="text">
<p><em>The question that I posted initially was lacking so here is an explanation that I hope will satisfy everyone and cancel some down votes that I received on it.</em></p>
<p>I would like to have an intelligence inside a class, that with the creation of an instance, it is decided that the instance would be of a different class, which is one of the subclasses of this class, according to some logic.</p>
<p>More specifically, I am making a <a href="https://en.wikipedia.org/wiki/Magic_square" rel="nofollow">Magic Square</a> solver as a learning exercise and:</p>
<ul>
<li>I want to have a <code>MagicSquare</code> class that will contain the logic of a MagicSquare.</li>
<li>I want to have <code>OddMagicSquare</code> and <code>EvenMagicSquare</code> subclasses of that class that will contain the logics of solving these two types of Magic Squares.</li>
<li>I want to be able to call the creation of a <code>MagicSquare</code>, providing it's size, <code>n</code>, and have the intelligence within <code>MagicSquare</code> determine which subclass to create an instance of, instead of the generic, top, class <code>MagicSquare</code>.</li>
</ul>
<p>I understand that the intelligence to determine which subclass (<code>OddMagicSquare</code>/<code>EvenMagicSquare</code>) to create an instance of <em>can be</em> (and perhaps would be easier to implement if it would be) <strong>outside</strong> of <code>MagicSquare</code>. The reason that I want it to be inside <code>MagicSquare</code> is perhaps a gut feeling. I have a hunch that it would be more clean and tidy this way because the logic of determining which kind of Magic Square a certain Magic Square is, seems to me, to belong in the <code>MagicSquare</code> class.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not every thing have to be a class.<br/>
<a href="http://steve-yegge.blogspot.co.il/2006/03/execution-in-kingdom-of-nouns.html" rel="nofollow">Execution in the Kingdom of Nouns</a><br/>
why not use a factory function ? </p>
<pre><code>class Car(object):
....

class SuperCar(Car):
....

def CarFactory(max_speed):
     if max_speed &gt; 100:
         return SuperCar()
     else: 
         return Car()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, since you didn't give an example, here's the familiar toy minimal class hierarchy:</p>
<pre><code>class Base(object):
    def __init__(self):
        print("I'm a base")

class Child(Base):
    def __init__(self):
        super(Child, self).__init__()
        print("I'm also a child")
</code></pre>
<p>Now, presumably you want to decide whether to be a <code>Child</code> or not in the middle of, or right after, <code>Base.__init__</code>.</p>
<p>The best way to do that is to <em>not</em> do it; just move the choice earlier. Then you don't need to do any re-classing; you just construct the class you actually want, and know it's going to be initialized as appropriate for that class.</p>
<p>You can either use a factory function:</p>
<pre><code>def basefactory(child=False):
    if child:
        return Child()
    else:
        return Base()
</code></pre>
<p>… or an "alternate constructor" method:</p>
<pre><code>class Base(object):
    def __init__(self):
        print("I'm a base")
    @classmethod
    def make(cls, child=False):
        if child:
            return Child()
        else:
            return cls()
</code></pre>
<p>Or a custom <code>__new__</code> method:</p>
<pre><code>class Base(object):
    def __init__(self):
        print("I'm a base")
    def __new__(cls, child=False):
        return super(Base, cls).__new__(Child if child else cls)
</code></pre>
<p>The advantage of all of these mechanisms is that <code>__init__</code> works the way it's supposed to. If someone writes a normal, Pythonic <code>__init__</code> method that correctly calls its superclass, it won't get trapped in an endless loop.</p>
<p>The only reason to re-<code>__class__</code> something in the base <code>__init__</code> would be if you wanted to explicitly <em>prevent</em> the child's <code>__init__</code> getting called. That's a very rare case, but if it's what you actually want, it's easy:</p>
<pre><code>class Base(object):
    def __init__(self, child=False):
        super(Base, self).__init__()
        if child:
            self.__class__ = Child
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Initially I've supplied an answer which is based on changing <code>self.__class__</code> during <code>__init__()</code>. It was explained to me in the comments that this should be avoided.</p>
<p>Now I am providing an answer that that is based on redefining the base class' <code>__new__</code>:</p>
<pre><code>class Car(object):
    """The base class."""

    def __new__(cls, max_speed):
        if cls is Car and max_speed &gt; 100:
            return object.__new__(SuperCar, max_speed)
        else:
            return object.__new__(cls, max_speed)

    def __init__(self, max_speed):
        self.max_speed = max_speed

class SuperCar(Car):
    """The sub class."""

    pass   
</code></pre>
<p>The code responsible for the creation of an instance is in the built in(1) <code>__new__</code> method. It is called when a class is called (e.g. <code>my_car = Car(100)</code>) and passed the arguments that were given in that call.</p>
<p>When the instanciation of a <code>Car</code> or a <code>SuperCar</code> (due to the inheritance of <code>__new__</code>) is called, the redefined <code>__new__</code> checks whether the instance to be created is of <code>cls</code> <code>Car</code> and also has a <code>max_speed</code> greater than 100.</p>
<p>If so, it creates an instance of <code>SuperCar</code>, instead of <code>Car</code>, using <code>object.__new__(SuperCar, max_speed)</code> and returns that.</p>
<p>Otherwise, it calls upon the normal, default, built in, <code>__new__</code> for the creation of this instance, using <code>object.__new__(cls, max_speed)</code> and returns that. This catches the expected case where <code>not max_speed &gt; 100</code> and also the case where this redefined <code>__new__</code> is called by the subclass <code>SuperCar</code> (like in <code>my_ferrari = SuperCar(250)</code>).</p>
<p>For the record, here's my former answer:</p>
<blockquote>
<p>When you want an instance's class to be changed to one of it's
  subclasses, depending on some condition, upon creation of that
  instance, you can use some logic in <code>__init__</code>, like so:</p>
<pre><code>class Car(object):
    def __init__(self, max_speed_kph):
        if self.__class__ == Car:
            if max_speed_kph &gt; 230:
                self.__class__ = SuperCar
                self.__init__()

class SuperCar(Car):
    def __init__(self):
        print 'this car is fast!'
</code></pre>
<p>The <code>self.__init__()</code> is for re-initialisation of the instance as it's
  new class.</p>
</blockquote>
<p>Footnotes:</p>
<ol>
<li>Is this really a built-in? I can't see it in the "Built-in functions" topic of Python Documentation.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>I think you're misusing subclasses here.</p>
<p>A subclass is supposed to represent a subtype—something whose interface is visibly specialized. That isn't true in the case of odd vs. even magic squares. They both have the same methods, and do the same (caller-visible) things in response to those methods, and so on.</p>
<p>If the difference between an odd magic square and an even one is not what they do, but how they do it, then they aren't subclasses, there's just a single class with multiple <em>policies</em>.</p>
<p>There may be a reasonable <code>MagicSquareSolver</code> type, whose user is the <code>MagicSquare</code> type, which has to interact differently with odd and even subtypes. In that case, you want to make the separate policies into separate classes. You could base them on an <a href="http://docs.python.org/3/library/abc.html" rel="nofollow">abstract base class</a> (which is rarely necessary in Python, but I'll show it anyway just for the hell of it):</p>
<pre><code>class MagicSquareSolver(metaclass=abc.ABCMeta:
    def __init__(self, square):
        self.square = square
    @abc.abstractmethod
    def solve(self):
        pass

class OddMagicSquareSolver(MagicSquareSolver):
    def __init__(self, square):
        super().__init__(square)
        do_odd_specific_stuff(self)
    def solve(self):
        do_odd_specific_solution(self)

class EvenMagicSquareSolver(MagicSquareSolver):
    def __init__(self, square):
        super().__init__(square)
        do_even_specific_stuff(self)
    def solve(self):
        do_even_specific_solution(self)

class MagicSquare:
    def __init__(self, n):
        self.n = n
        self.cells = self.make_cells()
        if n % 2:
            self.solver = OddMagicSquareSolver(self)
        else:
            self.solver = EvenMagicSquareSolver(self)
    def solve(self):
        return self.solver.solve()
</code></pre>
<p>However, I think even this is likely overkill. What is the interface to solving a magic square, even from the square's point of view, beyond a single <code>solve</code> method? There <em>might</em> be an answer to that question if, e.g., you're planning to visualize the solution process or turn it into a helper for a GUI game (although even in that case, a <code>solve_one_step</code> method, or a <code>solve</code> generator method, might still be all you need; look at some of the open source Sudoku games for examples). But likely there's nothing.</p>
<p>And this is what yossi's answer (and the rant he linked to) are getting at: if the interface of a class is just a single method named <code>do_it</code> (or a more useful name that has exactly the same information as the class name itself), and there's no state that needs to live outside of an invocation of that method, you don't have a class at all, you have a function, clumsily hidden away. Some languages (notably Java and C#) force you to be clumsy like that, but Python does not; you can just write this:</p>
<pre><code>class MagicSquare:
    def __init__(self, n):
        self.n = n
        self.fill_squares()
        self.cells = self.make_cells()
    def solve(self):
        if n % 2:
            return self._solve_odd()
        else:
            return self._solve_even()
    def _solve_odd(self):
        stuff()
    def _solve_even(self):
        other_stuff()
</code></pre>
</div>
<span class="comment-copy">This smells like an <a href="http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a>. Why do you want to re-class it? Why not use a "factory function" (or, equivalently, a <code>@classmethod</code> as an alternate constructor) that constructs an object of the right class in the first place? Or a <code>__new__</code> method? Why wait until you've gotten to <code>__init__</code> and then change the class?</span>
<span class="comment-copy">@abarnert I don't specifically want to re-class. I want the code that determines which subclass the object will be an instance of to be in the top, <code>Car</code>, class. Is there a reason for it not to be in <code>__init__</code>? Would it be better in <code>__new__</code>?</span>
<span class="comment-copy">Yes, there is a reason for it not to be in <code>__init__</code>. Because by the time you've gotten into the base's <code>__init__</code>, it's obviously too late to just construct the object normally because you're already in the middle of object construction. <code>__new__</code> would probably be better than <code>__init__</code>, but an alternate constructor <code>@classmethod</code> (or some other variation on the theme—a factory, a Cocoa-style "class cluster" constructor, …) would probably be even <i>better</i>.</span>
<span class="comment-copy">Meanwhile, you still haven't told us <i>why</i> you want to do this, or what you're <i>actually</i> trying to do. You're giving us bits and pieces of information that we can use to make wild guesses at what you might actually want, and then asking us which implementation would best fit that unseen design.</span>
<span class="comment-copy">@abarnert, I appreciate your commenting. I've rewritten both my question and my answer. Would you mind sharing your thoughts on them, please?</span>
<span class="comment-copy">Thank you, @yossi, I really do want the logic to re-class to be in the base class. I've rewritten my question.</span>
<span class="comment-copy">Checking <code>self.__class__.__name__</code> is a really bad idea. Why not just check <code>self.__class__ == Car</code>?</span>
<span class="comment-copy">And your second half is also a bad idea. Typically you expect the base class <code>__init__</code> to call the parent class, but in this case that would cause infinite recursion. If you really want to construct a <code>SuperCar</code>, just construct a <code>SuperCar</code>; don't construct a <code>Car</code>, turn it into a <code>SuperCar</code>, and then manually <code>__init__</code> it. The only reason re-classing really makes sense is when you want to <i>avoid</i> the subclass <code>__init__</code>.</span>
<span class="comment-copy">@abarnert I've edited to check <code>self.__class__</code> and not <code>self.__class__.__name__</code> . Can you please rephrase 'Typically you expect the base class <code>__init__</code> to call the parent class' for me? I don't get it because <code>__init__</code> is not a class.</span>
<span class="comment-copy">I actually stated that wrong ("base" and "parent" are the same thing—you want the <i>child</i>'s <code>__init__</code>, not the base's, to call the parent's). But the point is, a typical Python class hierarchy has all of the child classes doing <code>super(Child, self).__init__(some, subset, of, my, args)</code>.</span>
<span class="comment-copy">Oh, and "call the parent class" is a common shortcut for "call <i>the appropriate method on</i> the parent class" (although in Python it's more often put as "call the super" or similar, because it's generally done through <code>super</code>).</span>
