<div class="post-text" itemprop="text">
<p>I would like a way to do <code>for line in file</code> in python, where the end of line is redefined to be any string that I want.  Another way of saying that is I want to read records from file rather than lines; I want it to be equally fast and convenient to do as reading lines.</p>
<p>This is the python equivalent to setting perl's <code>$/</code> input record separator, or using <code>Scanner</code> in java.  This doesn't necessarily have to use <code>for line in file</code> (in particular, the iterator may not be a file object).  Just something equivalent which avoids reading too much data into memory.</p>
<p>See also:
<a href="http://bugs.python.org/issue1152248" rel="noreferrer">Add support for reading records with arbitrary separators to the standard IO stack</a></p>
</div>
<div class="post-text" itemprop="text">
<p>There is nothing in the Python 2.x <code>file</code> object, or the Python 3.3 <code>io</code> classes, that lets you specify a custom delimiter for <code>readline</code>. (The <code>for line in file</code> is ultimately using the same code as <code>readline</code>.)</p>
<p>But it's pretty easy to build it yourself. For example:</p>
<pre><code>def delimited(file, delimiter='\n', bufsize=4096):
    buf = ''
    while True:
        newbuf = file.read(bufsize)
        if not newbuf:
            yield buf
            return
        buf += newbuf
        lines = buf.split(delimiter)
        for line in lines[:-1]:
            yield line
        buf = lines[-1]
</code></pre>
<hr/>
<p>Here's a stupid example of it in action:</p>
<pre><code>&gt;&gt;&gt; s = io.StringIO('abcZZZdefZZZghiZZZjklZZZmnoZZZpqr')
&gt;&gt;&gt; d = delimited(s, 'ZZZ', bufsize=2)
&gt;&gt;&gt; list(d)
['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr']
</code></pre>
<hr/>
<p>If you want to get it right for both binary and text files, especially in 3.x, it's a bit trickier. But if it only has to work for one or the other (and one language or the other), you can ignore that.</p>
<p>Likewise, if you're using Python 3.x (or using <code>io</code> objects in Python 2.x), and want to make use of the buffers that are already being maintained in a <code>BufferedIOBase</code> instead of just putting a buffer on top of the buffer, that's trickier. The <a href="http://docs.python.org/3/library/io.html"><code>io</code></a> docs do explain how to do everything… but I don't know of any simple examples, so you're really going to have to read at least half of that page and skim the rest.  (Of course, you could just use the raw files directly… but not if you want to find unicode delimiters…)</p>
</div>
<span class="comment-copy">After reading through the whole tracker issue the OP linked, it looks like Douglas Alan already posted a very similar recipe <a href="http://bugs.python.org/issue1152248#msg109117" rel="nofollow noreferrer">5 years into the discussion</a>. I like his better because it allows you to transform the input newline into an output newline instead of just discarding it… but rather than edit mine to match, I'll just leave the link.</span>
<span class="comment-copy">Another advantage of the one linked is it returns the remainder of the buffer when the stream is closed.</span>
<span class="comment-copy">@jozxyqk: I'm not sure what you mean by that. This version yields the remainder of the buffer at EOF. (If the file is actually closed out from under you and raised an exception, I assume you want that exception--after all, the whole point is to work like "for line in file:" but with a different delimiter.)</span>
<span class="comment-copy">Aah, my mistake, I should have read more closely. I was testing by reading <code>sys.stdin</code> directly and printing the output, still using <code>\n</code>, and for some reason the remaining characters weren't printing when I hit ctrl-D. Looking at the code again, I'm not sure why and assume I've done something wrong.</span>
<span class="comment-copy">@jozxyqk: Reading from line-buffered stdin has some oddities with ^D which depend on your platform, terminal, and Python version, which can get in the way of testing other things. (See if "for line in sys.stdin():" and "for line in iter(input, ''):" do different things for you...)</span>
