<div class="post-text" itemprop="text">
<p>I am new to Python 3.3 and I am starting to write a little guessing game using sockets. However I keep getting the error <code>ValueError: invalid literal for int() with base 10: ''</code><br/>
I can't see why I get this error in the line <code>currentGuess = int(currentGuess)</code> as I have a similar line earlier in my code. If anyone could help me I would be very grateful. Here is my server and Client code. I have looked at other solutions with similar problems but I can't get any to work for me.</p>
<p>Server</p>
<pre><code>    #!/usr/bin/python
    import random
    import sys
    import math
    import  socket

    l = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    l.bind(("127.0.0.1", 4007))
    l.listen(5)
    print("Waiting...")
    while True:
          (s,  ca) = l.accept()
          print("Connection  from",  ca)

          #Name
          s.send("What is your name?". encode())
          names = s.recv(1024).decode()
          #Guesses

          s.send("How many guesses would you like?".encode())
          guesses = s.recv(1024).decode()
          guesses = int(guesses)
          #Random Number

          correctNumber = random.randrange(0,10)
          print(correctNumber)

          #Make Guesses
          count = 0
          while count &lt; guesses:
                s.send("Take a Guess".encode())
                currentGuess = s.recv(1024).decode()
                currentGuess = int(currentGuess)
                if currentGuess == correctNumber:
                   s.send("You WIN".encode())
                if currentGuess != correctNumber:
                   s.send("Incorrect, Try Again ".encode())
                   count = count + 1

    s.close()
</code></pre>
<p>Client</p>
<pre><code>    #!/usr/bin/python
    import random
    import sys
    import math
    import socket

    s = socket.socket(socket.AF_INET,   
    socket.SOCK_STREAM)
    s.connect(("127.0.0.1", 4007))
    print("Wlcome to the numer guessing game")

    #Name
    print(s.recv(1024).decode())
    name = sys.stdin.readline()
    s.send(name.encode())

    #guesses
    print(s.recv(1024).decode())
    guesses = sys.stdin.readline()
    s.send(guesses.encode())

    #Make Guesses
    print(s.recv(1024).decode())
    currentGuess = sys.stdin.readline()
    s.send(currentGuess.encode())
    print(s.recv(80).decode())
    s.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Getting back an empty string from <code>s.recv()</code> means the other side called <code>close</code> or <code>shutdown</code> on the connection (or it was interrupted in some other way—the other side quit, or someone ripped out the Ethernet cord).</p>
<p>And looking at your server code, if you say you want 3 guesses, it will try to <code>recv</code> 3 times… but the client will only <code>send</code> once, after which it will <code>close</code> the connection. Which means the next <code>recv</code> on the server will return an empty string, which is exactly what you're seeing.</p>
<p>To fix this, you need to send as many guesses as the other side is expecting. Something like this:</p>
<pre><code>#Make Guesses
for i in range(int(guesses)):
    print(s.recv(1024).decode())
    currentGuess = sys.stdin.readline()
    s.send(currentGuess.encode())
    print(s.recv(80).decode())
s.close()
</code></pre>
<hr/>
<p>Meanwhile, although it isn't causing this particular problem, your code can't work reliably. <a href="http://stupidpythonideas.blogspot.com/2013/05/sockets-are-byte-streams-not-message.html" rel="nofollow">Sockets are byte streams, not message streams</a>. There is no guarantee that each <code>send</code> will match up with a <code>recv</code> on the other side. The <code>recv</code> may get half of a <code>send</code>, or two <code>send</code>s bundled up together. On some platforms, when you're using localhost, and sending small messages, and not sending things too quickly, everything just happens to work out all the time. On other platforms, things work most of the time but occasionally don't. On others, they fail frequently.</p>
<p>On top of that, as <a href="http://docs.python.org/3/library/socket.html#socket.socket.send" rel="nofollow">the docs</a> explain, <code>send</code> is never guaranteed to send its entire string; that's why it returns the number of bytes actually sent. You can solve this problem by just using <a href="http://docs.python.org/3/library/socket.html#socket.socket.sendall" rel="nofollow"><code>sendall</code></a>, but that won't help with the other problem.</p>
<p>You have to <em>build</em> a message stream on top of the TCP byte stream, by designing and implementing a protocol. That may sound scary, but a very simple protocol, "All messages end with a newline", can be implemented just by using the <a href="http://docs.python.org/3/library/socket.html#socket.socket.makefile" rel="nofollow"><code>makefile</code></a> method, like this:</p>
<pre><code>s.connect(("127.0.0.1", 4007))
f = s.makefile('r+b')
</code></pre>
<p>Now, each time you were doing either of these:</p>
<pre><code>foo = s.recv(80)
s.send(bar)
</code></pre>
<p>… instead do these:</p>
<pre><code>foo = f.readline().strip()
f.write(bar + '\n')
</code></pre>
<hr/>
<p>One last problem that isn't affecting you, but should be fixed:</p>
<p>Calling <code>encode</code> and <code>decode</code> with no argument is almost always a bad idea, especially with network bytes. You're asking Python to decode the data with whatever happens to be in <code>sys.getdefaultencoding()</code>. Can you be sure that the default encoding is the same on the client and server? Can you be sure that it can handle anything the user might type? On a typical Windows machine, it may be something like <code>'cp1252'</code>, meaning that if the user types a Chinese character, the client will quit with a <code>UnicodeError</code>, which isn't very user-friendly. The right thing to do is to explicitly use <code>'utf-8'</code>. (Which means your protocol is now "All messages are in UTF-8, and end with a newline.")</p>
<p>If you're using <code>makefile</code> as suggested above, you can solve this even more easily by letting the file object do the encoding for you. Just do this:</p>
<pre><code>f = s.makefile('r+', encoding='utf-8')
</code></pre>
<p>Then you can leave out all the <code>decode</code> and <code>encode</code> calls.</p>
</div>
<div class="post-text" itemprop="text">
<p>You get that error when you try to call <code>int</code> on an empty string:</p>
<pre><code>&gt;&gt;&gt; int("")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: invalid literal for int() with base 10: ''
</code></pre>
<p>What this means is that when you do:</p>
<pre><code>currentGuess = s.recv(1024).decode()
currentGuess = int(currentGuess)
</code></pre>
<p><code>currentGuess</code> is being set to <code>''</code>. That is, <code>s.recv(1024)</code> is returning an empty string. This only happens when the connection has closed, so it means the client has stopped sending data to the server.</p>
</div>
<span class="comment-copy">Looks to me like you're only ever sending one guess, so you need a loop in your client code as well.</span>
<span class="comment-copy">Thanks That really helped got my original problem fixed and thanks for the extra tips. Like I said just a beginner so all a learning curve and thanks for the great explanation of things</span>
<span class="comment-copy">@ProgrammingRookie: Nothing wrong with being a beginner. You may have more to learn, but you've also got fewer old-fashioned bad habits to break. :)</span>
