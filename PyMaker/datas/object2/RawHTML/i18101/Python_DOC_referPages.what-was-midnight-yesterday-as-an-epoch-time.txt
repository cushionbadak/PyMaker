<div class="post-text" itemprop="text">
<p>I'm trying to get my head around the datetime module.  I know the time now as an epoch and the time an event last happened (as an epoch time).  What I need to do is figure out whether that event happened between midnight and midnight of yesterday.</p>
<pre><code>t = time.time() # is now
t2 = 1234567890 # some arbitrary time from my log
</code></pre>
<p>24 hours ago is t - 86400, but how can I round that up and down to midnight.  I'm having real trouble finding a way to get timestamps in and out of datetime or then manipulating a datetime to set the time.</p>
</div>
<div class="post-text" itemprop="text">
<h2>In the Middle of the Night</h2>
<p>Generating the last midnight is easy:</p>
<pre><code>from datetime import datetime, time

midnight = datetime.combine(datetime.today(), time.min)
</code></pre>
<p>That combines today's date (you can use <code>date()</code> or a <code>datetime()</code> instance, your pick), together with <a href="http://docs.python.org/3/library/datetime.html#datetime.time.min" rel="noreferrer"><code>time.min</code></a> to form a <code>datetime</code> object at <em>midnight</em>.</p>
<h2>Yesterday</h2>
<p>With a <code>timedelta()</code> you can calculate the <em>previous</em> midnight:</p>
<pre><code>from datetime import timedelta

yesterday_midnight = midnight - timedelta(days=1)
</code></pre>
<h2>That Was Yesterday</h2>
<p>Now test if your timestamp is in between these two points:</p>
<pre><code>timestamp = datetime.fromtimestamp(some_timestamp_from_your_log)
if yesterday_midnight &lt;= timestamp &lt; midnight:
    # this happened between 00:00:00 and 23:59:59 yesterday
</code></pre>
<h2>All Together Now</h2>
<p>Combined into one function:</p>
<pre><code>from datetime import datetime, time, timedelta

def is_yesterday(timestamp):
    midnight = datetime.combine(datetime.today(), time.min)
    yesterday_midnight = midnight - timedelta(days=1)
    return yesterday_midnight &lt;= timestamp &lt; midnight:

if is_yesterday(datetime.fromtimestamp(some_timestamp_from_your_log)):
    # ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given such a timestamp, you can use <code>divmod</code> to compute the number of <em>days</em> since the epoch (which you don't care about), and how many seconds are leftover (which you do):</p>
<pre><code>days_since, remaining_seconds = divmod(t, 24*3600)  # Divide by number of seconds in one day
</code></pre>
<p>Then, you subtract the leftover seconds from your original timestamp, which produces midnight
of the current day.</p>
<pre><code>t -= remaining_seconds
</code></pre>
<p>Rounding up is as simple as shifting your target timestamp forward exactly one day before rounding down.</p>
<pre><code>tomorrow_t = t + 24 * 3600
days_since, remaining_seconds = divmod(tomorrow_t, 24*3600)
t = tomorrow_t - remaining_seconds
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In my estimation, many date and time manipulations are easier to do, and to understand, using the <strong>arrow</strong> library. This is one of them.</p>
<p>Create an arbitrary date and time.</p>
<pre><code>&gt;&gt;&gt; import arrow
&gt;&gt;&gt; arbitrary = arrow.get(2017,8,16,11,5)
</code></pre>
<p>Calculate <code>midnight_yesterday</code>: first, midnight of <code>arbitrary</code> as its 'day' <code>floor</code>; then <code>shift</code> this back by one day. Display the result.</p>
<pre><code>&gt;&gt;&gt; midnight_yesterday = arbitrary.floor('day').shift(days=-1)
&gt;&gt;&gt; midnight_yesterday 
&lt;Arrow [2017-08-15T00:00:00+00:00]&gt;
</code></pre>
<p>Use <code>timestamp</code> for the desired overall result, for Python 3.3+.</p>
<pre><code>&gt;&gt;&gt; midnight_yesterday.datetime.timestamp()
1502755200.0
</code></pre>
<p>Or use this expression for Python 2.7. (Credit: <a href="https://stackoverflow.com/a/11743262/131187">https://stackoverflow.com/a/11743262/131187</a> for the latter two expressions.)</p>
<pre><code>&gt;&gt;&gt; (midnight_yesterday-arrow.get(1970,1,1)).total_seconds()
1502755200.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use this code:</p>
<pre><code>import time

seconds_of_day = 24 * 60 * 60  # 86400
last_midnight = (round(time.time()) // seconds_of_day) * seconds_of_day
yesterday_last_midnight = last_midnight - seconds_of_day
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Midnight at the start of today is:</p>
<pre><code>midnight = (int(time.time() // 86400)) * 86400
</code></pre>
<p>so yesterday's midnight is:</p>
<pre><code>midnight = (int(time.time() // 86400)) * 86400 - 86400
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import time

start_str = time.strftime( "%m/%d/%Y" ) + " 00:00:00"
end_str = time.strftime( "%m/%d/%Y ") + " 23:59:59"
start_ts = int( time.mktime( time.strptime( start_str, "%m/%d/%Y %H:%M:%S" ) ) )
end_ts = int( time.mktime( time.strptime( end_str, "%m/%d/%Y %H:%M:%S" ) ) )

print (start_ts) # timestamp today at 00:00:00
print (end_ts) # timestamp today at 23:59:59
# 1552435200
# 1552521599
</code></pre>
<hr/>
<p>Source <a href="https://obrienlabs.net/code/python-get-unix-epoch-todays-midnight-todays-235959-start-day-end-day/" rel="nofollow noreferrer">Python get unix epoch for today’s midnight and today’s 23:59:59 (start of day, end of day)</a></p>
</div>
<span class="comment-copy">Sounds like you may have to convert it to <i>regular</i> time somewhere in there, since dividers like days/midnight/etc are not a part of epoch times.</span>
<span class="comment-copy">How can you tell when midnight is without specifying the timezone?</span>
<span class="comment-copy">@sdanzig: By default, the <code>datetime</code> module is not timezone aware. It can return local or UTC times, as provided by the OS. This code uses local time.</span>
<span class="comment-copy">In this case it's not an issue as everything runs in UTC.</span>
<span class="comment-copy">If everything runs UTC, then not only is it fine, but there's a smart developer behind it.  Just to be aware though, the concept of "yesterday" will only apply to what England considers yesterday.  If you wanted to do something based on the timing at the site where the logs were written, for instance, you'd have to specify the timezone accordingly.</span>
<span class="comment-copy">I thought about that approach, I was actually just going to mod 86400, but then I remembered leap seconds.</span>
<span class="comment-copy">These timestamps are not affected by leap seconds. When a leap second occurs, the UNIX epoch timestamp simply repeats, so you are guaranteed to have 86400 seconds per day. Repeating a timestamp is just another arbitrary label for the leap second, like <code>23:59:60</code> is an arbitrary label for the leap second between 23:59:59 and 00:00:00 (or whenever leap seconds get applied).</span>
<span class="comment-copy">You must use // instead of %</span>
<span class="comment-copy">Mastisa - many thanks for the correction; I was about to make it myself.</span>
