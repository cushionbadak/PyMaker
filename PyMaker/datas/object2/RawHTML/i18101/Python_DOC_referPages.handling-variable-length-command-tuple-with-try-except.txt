<div class="post-text" itemprop="text">
<p>I'm writing a Python 3 script that does tabulation for forestry timber counts.</p>
<p>The workers will radio the species, diameter, and height in logs of each tree they mark to the computer operator. The computer operator will then enter a command such as this:</p>
<pre><code>OAK 14 2
</code></pre>
<p>which signifies that the program should increment the count of Oak trees of fourteen inches in diameter and two logs in height.</p>
<p>However, the workers also sometimes call in more than one of the same type of tree at a time. So the program must also be able to handle this command:</p>
<pre><code>OAK 16 1 2
</code></pre>
<p>which would signify that we're increasing the count by two.</p>
<p>The way I have the parser set up is thus:</p>
<pre><code>key=cmdtup[0]+"_"+cmdtup[1]+"_"+cmdtup[2]
        try:
            trees[key]=int(trees[key])+int(cmdtup[3])
        except KeyError:
            trees[key]=int(cmdtup[3])
        except IndexError:
            trees[key]=int(trees[key])+1
</code></pre>
<p>If the program is commanded to store a tree it hasn't stored before, a KeyError will go off, and the handler will set the dict entry instead of increasing it. If the third parameter is omitted, an IndexError will be raised, and the handler will treat it as if the third parameter was 1.</p>
<p>Issues occur, however, if we're in both situations at once; the program hasn't heard of Oak trees yet, and the operator hasn't specified a count. KeyError goes off, but then generates an IndexError of its own, and Python doesn't like it when exceptions happen in exception handlers.</p>
<p>I suppose the easiest way would be to simply remove one or the other except and have its functionality be done in another way. I'd like to know if there's a more elegant, Pythonic way to do it, though. Is there?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would do something like this:</p>
<pre><code>def parse(cmd, trees):
    res = cmd.split() # split the string by spaces, yielding a list of strings
    if len(res) == 3: # if we got 3 parameters, set the fourth to 1
        res.append(1)
    for i in range(1,4): # convert parameters 1-3 to integers
        res[i] = int(res[i])
    key = tuple(res[x] for x in range(3)) # convert list to tuple, as lists cannot be dictionary indexes
    trees[key] = trees.get(key,0) + res[3] # increase the number of entries, creating it if needed

trees={}

# test data
parse("OAK 14 2", trees)
parse("OAK 16 1 2", trees)
parse("OAK 14 2", trees)
parse("OAK 14 2", trees)

# print result
for tree in trees:
    print(tree, "=", trees[tree])
</code></pre>
<p>yielding</p>
<pre><code>('OAK', 16, 1) = 2
('OAK', 14, 2) = 3
</code></pre>
<p>Some notes:</p>
<ul>
<li>no error handling here, you should handle the case when a value supposed to be a number isn't or the input is wrong in any other way</li>
<li>instead of strings, I use tuples as a dictionary index</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>collections.Counter</code>, which returns 0 rather than a <code>KeyError</code> if the key isn't in the dictionary.</p>
<p><strong><a href="http://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow">Counter Documentation:</a></strong></p>
<blockquote>
<p><code>Counter</code> objects have a dictionary interface except that they return a zero count for missing items instead of raising a <code>KeyError</code></p>
</blockquote>
<p>Something like this:</p>
<pre><code>from collections import Counter

counts = Counter()

def update_counts(counts, cmd):
    cmd_list = cmd.split()
    if len(cmd_list) == 3:
        tree = tuple(cmd_list)
        n = 1
    else:
       *tree, n = tuple(cmd_list)
    counts[tree] += n
</code></pre>
<p>Same notes apply as in uselpa's answer. Another nice thing with <code>Counter</code> is that if you want to, e.g., look at weekly counts, you just do something like <code>sum(daily_counts)</code>.</p>
<p><code>Counter</code> works even better if you're starting from a list of commands:</p>
<pre><code>from collections import Counter
from itertools import repeat

raw_commands = get_commands() # perhaps read a file
command_lists = [c.split() for c in raw_commands]

counts = Counter(parse(command_lists))

def parse(commands):
    for c in commands:
        if len(c) == 3:
            yield tuple(c)
        elif len(c) == 4
            yield from repeat(tuple(c[0:2]), times=c[3])
</code></pre>
<p>From there you can use the <code>update_counts</code> function above to add new trees, or you can start collecting the commands in another text file and then generate a second <code>Counter</code> object for the next day, the next week, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the end, the best way was to simply remove the IndexError handler, change cmdtup to a list, and insert the following:</p>
<pre><code>if len(cmdtup) &gt;= 3:
    cmdtup.append(1)
</code></pre>
</div>
<span class="comment-copy">Don't bully your program users forcing them to type in input args in cmd.exe for example. That is cruel. Create some frontend.</span>
<span class="comment-copy">It doesn't work by argv. There's an input loop above the bit I posted. Plus, I'm the end user anyway.</span>
<span class="comment-copy">Is there any answer you could accept?</span>
<span class="comment-copy">@uselpa I find the solution I actually ended up implementing was the best, so I've answered the question myself and accepted that.</span>
