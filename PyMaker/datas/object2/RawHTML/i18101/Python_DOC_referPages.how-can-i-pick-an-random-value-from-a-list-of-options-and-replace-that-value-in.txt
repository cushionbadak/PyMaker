<div class="post-text" itemprop="text">
<p>So, the program works just fine, but even after incorporating that last modification suggested by abarnert, it still won't make sure to generate a unique mutation. </p>
<p>This is what I've got so far. I'm sure it's not right, but I don't fully understand how python executes the code written by abarnert below. </p>
<pre><code>a = open (scgenome, 'r')

codon = [ ] 

for line in a:

    data=line.split("\t") 

    codon.append(data[12]) 

import random 

def string_replace(s,index,char):
    return s[:index] + char + s[index+1:]


for x in range(1,1000):
   index = random.randrange(3)
   letter_to_replace = random.choice(list({"A", "G", "T", "C"} - {codon[index]}))
   mutated_codon = [string_replace(codon[x], index, letter_to_replace)]
       for c in mutated_codon: 
             codon_lookup[c]
</code></pre>
<p>I have also tried to write this your way without using range, although I like using the range function so that I can print out 10 or 100 codons and manually check if the output is correct, but then I get a Keyerror: 'r', which didn't occur before when i ran this program before trying to make sure that each substitution is unique: </p>
<pre><code>def string_replace(s,index,char):

    return s[:index] + char + s[index+1:]



def mutate_codon(codon):

  index = random.randrange(3)

  letter_to_replace = random.choice(list({"A", "G", "T", "C"} - {codon[index]}))

  return string_replace(codon, index, letter_to_replace)



 for codon in codons:
   codons = mutate_codon(codon)

   print codons 

   for c in codons:

      codon_lookup[c]

      if codon_lookup[c] == ref_aminoacid[x]:

           print codons, "\t", codon_lookup[c]

      else: 

          print codons, "\t", codon_lookup[c]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The function <a href="http://docs.python.org/3/library/random.html#random.choice" rel="nofollow"><code>random.choice</code></a> picks a random element from a sequence. So:</p>
<pre><code>letter_to_replace = random.choice(['A', 'C', 'G', 'T'])
</code></pre>
<p>To pick a letter from a given codon, you really want to pick an <em>index</em> at random—0, 1, or 2. (After all, for the codon <code>'AAA'</code>, you presumably want to be able to replace any of the three <code>'A'</code> characters, right?) For that, use <code>random.randrange(3)</code>:</p>
<pre><code>for codon in codons:
    index_to_replace = random.randrange(3)
    codon[index_to_replace] = letter_to_replace
</code></pre>
<p>Except that if each <code>codon</code> is a string, of course, you can't mutate it in-place, so you need a function like this:</p>
<pre><code>def string_replace(s, index, char):
    return s[:index] + char + s[index+1:]
</code></pre>
<p>What we're doing here is building a new string out of slices: <code>s[:index]</code> is all of the characters from the start to the <code>index</code>th (remember that Python slicing is half-open: <code>s[i:j]</code> includes <code>i</code>, <code>i+1</code>, …, <code>j-1</code>, but not <code>j</code>), and <code>s[index+1]</code> is all of the characters from the <code>index+1</code>th to the end. So, this is everything before <code>index</code>, <code>char</code> in place of whatever was in <code>index</code>, and then everything after <code>index</code>. This is described in detail in the <a href="http://docs.python.org/2/tutorial/introduction.html#strings" rel="nofollow">Strings</a> section of the tutorial (with a bit of followup in the Lists section of the same chapter).</p>
<p>And while you're already doing things immutably:</p>
<pre><code>codons = [string_replace(codon, random.randrange(3), letter_to_replace)
          for codon in codons]
</code></pre>
<p>This uses a list comprehension: instead of modifying the list of codons in-place, we build a new list of codons. <a href="http://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow">List Comprehensions</a> in the tutorial explains how these work, but a simple example may help:</p>
<pre><code>a = [1, 2, 3, 4]
b = [2 * element for element in a]
assert b == [2, 4, 6, 8]

c = []
for element in a:
    c.append(2 * element)
assert c == b
</code></pre>
<p>You can also filter the list as you build it with <code>if</code> clauses, nest multiple <code>for</code> clauses together, build a <code>set</code> or <code>dict</code>, or a lazy generator, instead of a <code>list</code>… see <a href="http://docs.python.org/2/reference/expressions.html#list-displays" rel="nofollow">the documentation</a> for full details.</p>
<hr/>
<p>Here's how to put it all together, with a few other fixes (using a <code>with</code> to make sure the file gets closed, and some of the stuff I commented on the question):</p>
<pre><code># Read the codons into a list
with open(scgenome) as f:
    codons = [line.split('\t')[12] for line in f]

# Create a new list of mutated codons
def string_replace(s, index, char):
    return s[:index] + char + s[index+1:]
letter_to_replace = random.choice(['A', 'C', 'G', 'T'])
codons = [string_replace(codon, random.randrange(3), letter_to_replace)
          for codon in codons]
</code></pre>
<hr/>
<p>If you want to guarantee a single point mutation in each codon, and you don't need each one to mutate to the same base, you need to rethink things a little. For each codon, pick one of the three positions. Then, instead of picking randomly from all four bases, pick from all of the bases <em>except</em> the one that's already there. So:</p>
<pre><code>def string_replace(s, index, char):
    return s[:index] + char + s[index+1:]

def mutate_codon(codon):
    index = random.randrange(3)        
    new_base = random.choice(list({'A', 'C', 'T', 'G'} - {codon[index]}))
    return string_replace(codon, index, new_base)

codons = [mutate_codon(codon) for codon in codons]
</code></pre>
<p>If that function line is confusing, let me explain: Sets have a nice <code>-</code> operator that computes the set difference—that is, all values in the left set that aren't also in the right set. <code>{'A', 'C', 'T', 'G'} - {'T'}</code> is <code>{'A', 'C', 'G'}</code>. So, I take the set of all four bases, subtract out the one that's already at <code>codon[index]</code>, and randomly choose any of the other three. Since <code>choice</code> only works on sequences, I have to make a list out of the set.</p>
<p>You could, of course, rewrite this to use a list (or even str) in the first place, but then you have to write the "list difference" manually. Not a big deal:</p>
<pre><code>new_base = random.choice([base for base in codon if base != codon[index]])
</code></pre>
</div>
<span class="comment-copy">what do you have so far? what have you tried? what if you get rid of the random element could you do it then? (put the answers in the original question (with edit), dont post a comment with the answers to those questions.)</span>
<span class="comment-copy">So far, this is what I've done: mylist = ["A", "G", "T", "C"]  from random import choice   print choice(mylist)  Even after that, I think the more difficult part is to figure out how to get the program to pick a letter from a given string.</span>
<span class="comment-copy"><code>import random; random.choice("XYZABC")</code> will get you that far</span>
<span class="comment-copy">You should study the <code>random</code> module: <a href="http://docs.python.org/2/library/random.html" rel="nofollow noreferrer">docs.python.org/2/library/random.html</a></span>
<span class="comment-copy">I don't understand. What you've got so far sounds like exactly what you said you didn't know how to do…</span>
<span class="comment-copy">just curious? why did you use an index instead of another random choice?</span>
<span class="comment-copy">I am not sure of OP's intent, but I would guess he might want to check whether the old and new char are same, in that case OP can compare</span>
<span class="comment-copy">@JoranBeasley: How would you use <code>random.choice</code> here? If the codon is, say, <code>'AAA'</code>, that'll just give you <code>'A'</code>, which isn't very useful. (Of course you could use <code>choice(enumerate(codon))</code>, but given that you only need the index, not the value, it doesn't really add anything.)</span>
<span class="comment-copy">@ Joran Beasley, for sure he does not want to replace all the instance of "A", just one of three (I happen to know what these thing are), and depending upon what he wants, he might actually want to replace with other three.</span>
<span class="comment-copy">@JoranBeasley: The fact that he wants to replace "any one of those three letters", and repeats the same thing in different words, makes me pretty confident that he doesn't want to turn<code>"AAA"</code> into <code>"TTT"</code>, but rather <code>"TAA"</code> or <code>"ATA"</code> or <code>"AAT"</code> (with an equal chance of each).</span>
