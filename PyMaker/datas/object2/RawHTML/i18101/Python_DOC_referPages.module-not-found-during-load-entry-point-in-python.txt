<div class="post-text" itemprop="text">
<p>I'm trying to create an entry point for the main method in one of my python modules, and there seems to be trouble importing the module where that function lives.</p>
<p>My setup.py looks like this:</p>
<pre><code>...
setup(name="awesome-tool",
      ...,
      entry_points={
          'console_scripts' : [
              'awesome-tool = awesome_tool.awesome_tool:main'
          ]
      }
)
</code></pre>
<p>The project is organized like this:</p>
<pre><code>awesome_tool
    |__ awesome_tool.py
    |__ __init__.py
</code></pre>
<p>It's <code>awesome_tool.py</code> that contains a function called main() that I want to make available in an executable called <code>awesome-tool</code>. When executing setup.py, all seems to go well. I can start a python prompt and do</p>
<pre><code>&gt; import awesome_tool.awesome_tool
&gt; # (all good here)
</code></pre>
<p>But when I try to invoke <code>awesome-tool</code> from the command-line, this is what happens:</p>
<pre><code>Traceback (most recent call last):
  File ".../virtualenvs/awesome-tool/bin/awesome-tool", line 9, in &lt;module&gt;
    load_entry_point('awesome-tool==1.1.0', 'console_scripts', 'awesome-tool')()
  File "build/bdist.macosx-10.9-intel/egg/pkg_resources.py", line 378, in load_entry_point
    return get_distribution(dist).load_entry_point(group, name)
  File "build/bdist.macosx-10.9-intel/egg/pkg_resources.py", line 2566, in load_entry_point
    return ep.load()
  File "build/bdist.macosx-10.9-intel/egg/pkg_resources.py", line 2260, in load
    entry = __import__(self.module_name, globals(),globals(), ['__name__'])
ImportError: No module named awesome_tool.awesome_tool
</code></pre>
<p>What? Wasn't I just able to import this from the python shell? I suspect that there's something funny going on with the python path, but I haven't been able to diagnose the problem. Any ideas?</p>
<p>The problematic lines in the <code>awesome-tool</code> executable provided by <code>setup.py</code> seem to be the following:</p>
<pre><code>from pkg_resources import load_entry_point
load_entry_point("awesome-tool==1.1.0", "console_scripts", "awesome-tool")()
</code></pre>
<p>Also, I realize that it's very odd to have both a package and module share the same name ("awesome_tool"), but this is code I've inherited and I don't want to break backwards compatibility with renaming, though this may be inevitable in the future. If possible, I'd like to keep the names the way they are for now.</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like you haven't installed the package in any way, so you're relying on it happening to sit in the current working directory, or some other directory you've added to <code>sys.path</code>.</p>
<p>You didn't tell us how you "invoke <code>awesome-tool</code> from the command-line," but my guess is that you're doing it from a different working directory.</p>
<p>For example:</p>
<pre><code>$ cd ~/virtualenvs/awesome-tool
$ python
&gt;&gt;&gt; import awesometool.awesometool
&gt;&gt;&gt; ^D
$ cd ..
$ python
&gt;&gt;&gt; import awesometool.awesometool
ImportError: No module named awesome_tool.awesome_tool
$ cd awesome-tool
$ python ./bin/awesome-tool
&lt;everything works&gt;
$ cd bin
$ python awesome-tool
ImportError: No module named awesome_tool.awesome_tool
</code></pre>
</div>
<span class="comment-copy">How do you "invoke <code>awesome-tool</code> from the command-line"? What's the current working directory when you do so? What was the working directory when you tried just running Python?</span>
<span class="comment-copy">I am invoking <code>awesome-tool</code> one directory above the package contents (i.e. <code>awesome_tool/..</code>) and the python interpreter in the same location, but when I <code>cd</code> to a different directory and try the python interpreter over again, I get the <code>ImportError</code>. That's progress! Thank you.</span>
<span class="comment-copy">I did run <code>setup.py</code>, but after more poking around, I see that the package is installing into my <code>site-packages</code> as <code>awesome-tool</code> (which isn't importable... great). The root of the problem expressed in this question is what you are pointing out here, that invoking python from the directory above the package falsely makes it appear as if the package is correctly installed when it isn't. Thank you.</span>
<span class="comment-copy">@llovett: Yeah, package and module filenames have to be valid identifiers, or they aren't very useful. The usual trick is to substitute <code>_</code> for all non-identifier characters, so, e.g., after you <code>pip install more-itertools config-tree</code> you can <code>import more_itertools, config_tree</code>. I think this is discussed somewhere in the <a href="http://docs.python.org/3/distutils/index.html" rel="nofollow noreferrer">Distributing Python Modules</a> docs or the Hitchhikers' Guide to Packaging, but everyone I know gets bitten by that problem the first time they create a package with a long name.</span>
<span class="comment-copy">I had a similar issue and it ended up being that I hadn't actually installed my package.  Running <code>pip install .</code> fixed it for me.</span>
