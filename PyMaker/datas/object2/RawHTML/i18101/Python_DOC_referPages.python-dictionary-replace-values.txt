<div class="post-text" itemprop="text">
<p>I have a dictionary with 20 000 plus entries with at the moment simply the unique word and the number of times the word was used in the source text (Dante's Divine Comedy in Italian).</p>
<p>I would like to work through all entries replacing the value with an actual definition as I find them. Is there a simple way to iterate through the keywords that have as a value a number in order to replace (as I research the meaning)?</p>
<p>The dictionary starts:</p>
<pre><code>{'corse': 378, 'cielo,': 209, 'mute;': 16, 'torre,': 11, 'corsa': 53, 'assessin': 21, 'corso': 417, 'Tolomea': 21}  # etc.
</code></pre>
<p>Sort of an application that will suggest a keyword to research and define.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a function that will find your key and replace your value.</p>
<pre><code>current_dict = {'corse': 378, 'cielo': 209, 'mute': 16}
print(current_dict)
def replace_value_with_definition(key_to_find, definition):
    for key in current_dict.keys():
        if key == key_to_find:
            current_dict[key] = definition

replace_value_with_definition('corse', 'Definition of "corse"')
print(current_dict)
</code></pre>
<p>The output is:</p>
<pre><code>{'corse': 378, 'cielo': 209, 'mute': 16}
{'corse': 'Definition of "corse"', 'cielo': 209, 'mute': 16}
</code></pre>
<p>If you find it is taking too long to loop through your dictionary try a generator function:</p>
<pre><code>def gen_replace_value_with_definition(key_to_find, definition):
    for key in current_dict.keys():
        if key == key_to_find:
            current_dict[key] = definition
            yield True
    yield False

found = False
while not found:
    found = next(gen_replace_value_with_definition('corse', 'Definition of "corse" via generator'))

print(current_dict)
</code></pre>
<p>Output: </p>
<pre><code>{'corse': 'Definition of "corse" via generator', 'cielo': 209, 'mute': 16}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You cannot select on specific values (or types of values). You'd either make a reverse index (map numbers back to (lists of) keys) or you have to loop through <em>all</em> values every time.</p>
<p>If you are processing numbers in arbitrary order anyway, you may as well loop through all items:</p>
<pre><code>for key, value in inputdict.items():
    # do something with value
    inputdict[key] = newvalue
</code></pre>
<p>otherwise I'd go with the reverse index:</p>
<pre><code>from collections import defaultdict

reverse = defaultdict(list)
for key, value in inputdict.items():
    reverse[value].append(key)
</code></pre>
<p>Now you can look up keys by value:</p>
<pre><code>for key in reverse[value]:
    inputdict[key] = newvalue
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In case you need a <em>declarative</em> solution, you can use <a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="noreferrer"><code>dict.update()</code></a> to change values in a dict.</p>
<pre><code>my_dict.update({'corse': 'my new definition'})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you iterate over a dictionary you get the keys, so assuming your dictionary is in a variable called <code>data</code> and you have some function <code>find_definition()</code> which gets the definition, you can do something like the following:</p>
<pre><code>for word in data:
    data[word] = find_definition(word)
</code></pre>
</div>
<span class="comment-copy">votes vs accepted: segmentation fault</span>
<span class="comment-copy">In Python 2, if iterating over a large dictionary, use <code>iteritems()</code> instead of <code>items()</code> so that the entire dictionary contents aren't loaded into memory. (This doesn't matter for Python 3 since <code>items()</code> basically does what <code>iteritems()</code> did in Python 2.)</span>
<span class="comment-copy">@nofinator: in Python 2, you use <code>iteritems()</code> to prevent the creation of a new list list with len(dictionary) tuples referencing the key-value pairs in the dictionary (rather a waste when only iterating). The dictionary contents themselves are <i>always</i> loaded into memory. Not that this applies here, as the question is tagged Python 3 :-)</span>
<span class="comment-copy">@MartijnPieters can we have the same setting to retrieve the old value somehow? Like if <code>.update()</code> returned the old value, it would have saved me a step of saving the old value and then replacing in case I want to do that</span>
<span class="comment-copy">@VivekKalyanarangan: not sure what you are asking; the question here was about finding a key for a given value, and then using that key to replace something <i>somewhere else</i>. I think you are asking if you can get the old value for a given key, and at the same time put in the new value? There is not, just use two statements: <code>old = d.get(key)</code> in case a missing key is not an error, or use <code>old = d[key]</code> otherwise, and then use <code>d[key] = new</code>.</span>
