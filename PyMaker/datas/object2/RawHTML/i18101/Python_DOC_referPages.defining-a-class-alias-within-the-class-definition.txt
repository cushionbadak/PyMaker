<div class="post-text" itemprop="text">
<p>I'd like to be able to assign aliases to class names, and somehow define the aliases within the class body. So, for example, rather than doing this:</p>
<pre><code>class C(object):
    pass
C1 = C
</code></pre>
<p>I'd like to be able to do this:</p>
<pre><code>class C(object):
    __aliases__ = ['C1']
</code></pre>
<p>or something of the sort. </p>
<p>My objective is to make the information about the aliases contained within the class definition so that auto-completion works in the right environments and any kind of introspection will reveal the class' aliases (so, for example, documentation can be made to include these aliases.)</p>
<p>I'm guessing I can play games with jumping to the containing frame or whatever, but I'd just like to avoid any ugly trickery if that's possible. </p>
<p>The question is, is this possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>Seems like this would be a good job to handle with a metaclass:</p>
<pre><code>class AKA(type):
    """ 'Also Known As' metaclass to create aliases for a class. """
    def __new__(cls, classname, bases, attrs):
        print('in AKA.__new__')
        class_ = type(classname, bases, attrs)
        globals().update({alias: class_ for alias in attrs.get('aliases', [])})
        return class_

class C(object):
    __metaclass__ = AKA
    aliases = 'C1', 'C2'

print(C)          # &lt;class '__main__.C'&gt;
print(C.aliases)  # ('C1', 'C2')
print(C1)         # &lt;class '__main__.C'&gt;
print(C2)         # &lt;class '__main__.C'&gt;
</code></pre>
<p><strong>Note:</strong> In Python 3.x the syntax for specifying a metaclass is different and would need to be:</p>
<pre><code>class C(object, metaclass=AKA):
    aliases = 'C1', 'C2'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's yet another way to do something similar with a class decorator—but the aliases aren't specified within the class body like you wanted. It's <em>very</em> similar to @BrenBarn's <a href="https://stackoverflow.com/a/19651294/355230">answer</a>, except the aliases are decorator arguments—which I think might be more desirable for some types of usage (and it seems more explicit since it makes them more conspicuous that way).</p>
<pre><code>import sys

def aliases(*pseudonyms):
    def aliaser(cls):
        namespace = sys._getframe(1).f_globals  # Caller's globals.
        namespace.update({alias: cls for alias in pseudonyms})
        cls.aliases = pseudonyms
        return cls
    return aliaser

if __name__ == '__main__':
    @aliases('SN', 'FUBAR')
    class LongName(object):
        pass

    print(SN)                # &lt;class '__main__.LongName'&gt;
    print(LongName.aliases)  # ('SN', 'FUBar')
</code></pre>
<p><br/> </p>
</div>
<div class="post-text" itemprop="text">
<p>It's a bad idea, but it can be done with an abuse of class decorators:</p>
<pre><code>def aliaser(cls):
    for alias in cls.aliases:
        globals()[alias] = cls
    return cls

@aliaser
class LongName(object):
    aliases = ['LN', 'Ugh']

&gt;&gt;&gt; LN
&lt;class '__main__.LongName'&gt;
</code></pre>
<p>This is an abuse because the point of decorators is to modify the object they decorate, but this one is used only for its global side-effect of assigning additional names in the global namespace that point to the same class.</p>
<p>Use at your own risk! ;-)</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>Defining a python class “alias” within the class definition</h2>
</blockquote>
<p>I'm just responding to the above problem statement. Martineau's non-accepted answer is close to what I'd do to provide a simple alias. But maybe we don't really want an alias, maybe we really just want to take steps towards getting rid of a bad name.</p>
<p>Naming is hard. Sometimes we wind up with names we'd like to change.</p>
<p>I'm looking at some library code with unfortunately named classes that need deprecation. For example:</p>
<pre><code>class BadC: # Bad name, but changing it could break others!
    """Great implementation!"""
</code></pre>
<p>A multitude of aliases is not helpful, however. Multiple names that point to the same object mean more to learn, and make your code more complex than it needs to be. The bad names need to eventually go away.</p>
<p>I propose the following sort of change as a solution to warn and not break your users:</p>
<pre><code>class GoodC:
    """Great implementation!"""


class BadC(GoodC):
    """deprecated, use GoodC instead!"""
    def __init__(self, *args, **kwargs):
        import warnings
        warnings.warn(
          "BadC is deprecated, import and use GoodC instead!",
          DeprecationWarning)
        return super().__init__(*args, **kwargs)
</code></pre>
<p>Autocomplete will automatically know these names, and introspection (<code>help(BadC)</code>) will immediately reveal that you should stop using <code>BadC</code>.</p>
<p>Now you can start replacing BadC with GoodC in the rest of your code.</p>
<pre><code>&gt;&gt;&gt; GoodC()
&lt;__main__.GoodC object at 0x7f0d0c521c88&gt;
</code></pre>
<p>and when you or your users use BadC, they'll get their warning:</p>
<pre><code>&gt;&gt;&gt; BadC()
__main__:4: UserWarning: The BadC name is deprecated, import and use GoodC instead!
&lt;__main__.BadC object at 0x7f0d0c521cc0&gt;
</code></pre>
<p>And still be able to continue using it:</p>
<pre><code>&gt;&gt;&gt; BadC()
&lt;__main__.BadC object at 0x7f0d0c521c88&gt;
</code></pre>
<p>Tests will usually show these warnings, or users can enable them, <a href="https://docs.python.org/3/library/warnings.html#updating-code-for-new-versions-of-dependencies" rel="nofollow noreferrer">from the docs</a></p>
<blockquote>
<p>In the ideal case, the code will have a suitable test suite, and the test runner will take care of implicitly enabling all warnings when running tests (the test runner provided by the unittest module does this).</p>
<p>In less ideal cases, applications can be checked for use of deprecated interfaces by passing <code>-Wd</code> to the Python interpreter (this is shorthand for <code>-W default</code>) or setting <code>PYTHONWARNINGS=default</code> in the environment. This enables default handling for all warnings, including those that are ignored by default. To change what action is taken for encountered warnings you can change what argument is passed to <code>-W</code> (e.g. <code>-W error</code>). See the <code>-W</code> flag for more details on what is possible.</p>
</blockquote>
</div>
<span class="comment-copy">Why do you need this? Usecase?</span>
<span class="comment-copy">imo the best way to document this would be to not do it in the first place.  why does a class need two names?</span>
<span class="comment-copy">I agree that it's not a good idea. I don't like it either. But I'm writing software some lazy folks. We give descriptive, helpful names for developers and simpler, easier to remember aliases for end-users. One sort of trumped up example might be "FibreChanelOverEthernet" verses "FCoE". Basically, it's a matter of convenience. The reason I'm asking the above question is because I too feel kind of icky about it, but if these aliases can be part of the class definition in the first place, it'll be all self-contained and documented and will be much easier to keep track of and document.</span>
<span class="comment-copy">That sort of alias is called a "title".</span>
<span class="comment-copy">ok +1 for doing most of what I was thinking of but I don't see why you're assigning an <code>aliases</code> attribute and maybe you should accept a <code>globals=globals()</code> keyword argument in the outer decorator so you could define this in a utility module instead.</span>
<span class="comment-copy">@AaronHall: Been a while...you're asking what I was thinking almost five years ago. Anyway I think the <code>aliases</code> attribute is being created to make it produce the same result as my other metaclass-based answer. As for the <code>globals=globals()</code> idea: It doesn't seem like a good idea, I don't think I want the default to be utilities module's namespace. The way it's written, when <code>globals()</code> is called from <code>aliaser()</code>, execution is in the caller's module that's making use of the decorator.</span>
<span class="comment-copy">Well I suppose the user asked for <code>aliases</code>. Default should be globals=None, call should be globals=globals(), the way you wrote it, it only works in the same module in which it was written. functions know the module they're written in, not the one they're called in, unless they do some frame walking...</span>
<span class="comment-copy">@AaronHall: A <code>globals=None</code> is a no-go because in Python 2 you can't have a keyword argument following an <code>*args</code> parameter. Even if it worked, having a argument name collide with a builtin is, well, awkward here because of the potentially the need to call the builtin one. However I do get your point about being able to put it in some other module though, so have modified my answer to reach up through the stack and get the caller's globals automatically. BTW, are you the one down-voted my metaclass answer? If so, I'd like to know why.</span>
<span class="comment-copy">It's hard to know if I should vote this up for being a good answer or down for being a bad idea. Oh, OK, +1 then. :-)</span>
<span class="comment-copy">BrenBarn: I think your notion of the point of class decorators is too narrow—where did you get that idea? Nothing like that is mentioned in the <a href="https://www.python.org/dev/peps/pep-3129/#id10" rel="nofollow noreferrer">Rationale</a> section of PEP 3129.</span>
