<div class="post-text" itemprop="text">
<p>I'm making an algorithm that reads input from keyboard, stores it on a variable called <strong>message</strong> and then write this variable into a file. However, whenever the user is typing, if he hits the ESC key, I'd like the execution to stop without any errors.</p>
<p>Let's say the code is:</p>
<pre><code>message = raw_input()
</code></pre>
<p>What do I have to add? So if I'm in the middle of a sentence like:</p>
<pre><code>My name is th
</code></pre>
<p>And I hit ESC, it stops?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no way to do this with normal input. <code>raw_input</code> reads a whole line at a time.</p>
<p>In some (very few) cases, you can do this:</p>
<pre><code>message = ''
while True:
    ch = sys.stdin.read(1)
    if ch == '\x1b':
        exit(0)
    elif ch == '\n':
        break
    message += ch
</code></pre>
<p>But in general, this won't work. For example, on a typical Unix system, <code>sys.stdin</code> will be line-buffered, and possibly even fed through a library like <code>readline</code> to allow the user to edit as he goes along. Or, if you're running the program inside IDLE, there is no way to read <code>stdin</code> at all; <code>raw_input</code> works around that by popping up a dialog box asking for input, but your code can't do that.</p>
<p>You can work around that in different ways on different platforms in different situations.</p>
<hr/>
<p>On Windows, if you know your input is going to be a "DOS prompt" window (which you can check with <a href="http://docs.python.org/3/library/io.html#io.IOBase.isatty" rel="nofollow"><code>sys.stdin.isatty()</code></a>), you can use the <a href="http://docs.python.org/3/library/msvcrt.html#console-i-o" rel="nofollow"><code>msvcrt</code></a> functions. For example:</p>
<pre><code>import sys, msvcrt
assert sys.stdin.isatty(), "Can't run without a console to run on"
message = u''
while True:
    ch = msvcrt.getwche()
    if ch == u'\x1b':
        exit(0)
    elif ch == u'\n':
        break
    message += ch
</code></pre>
<p>This should work for both 2.6+ and 3.3+, but in 2.x, unlike <code>raw_input</code>, it returns a <code>unicode</code> instead of a <code>str</code>. If you want <code>str</code> here, drop all the <code>u</code> prefixes and use <code>getche</code> instead of <code>getwche</code>.</p>
<hr/>
<p>On most POSIX-like platforms with reasonably-standard <code>termios</code> (including Mac OS X and Linux), if you know your input is going to be a "TTY" (which you can check with <a href="http://docs.python.org/3/library/io.html#io.IOBase.isatty" rel="nofollow"><code>sys.stdin.isatty()</code></a>â€”or, if you prefer, you can just look for a TTY to use instead of stdin, although that doesn't work on quite as many platforms/in quite as many situations), you can use the <code>[termios</code>](<a href="http://docs.python.org/3/library/termios.html" rel="nofollow">http://docs.python.org/3/library/termios.html</a>) or <a href="http://docs.python.org/3/library/tty.html" rel="nofollow"><code>tty</code></a> module to put the input into "raw" mode. In Python 3.x, you will probably have to read directly from <a href="http://docs.python.org/3/library/io.html#io.TextIOBase.buffer" rel="nofollow"><code>sys.stdin.buffer</code></a> instead of <code>sys.stdin</code>, and decode to Unicode manually. So:</p>
<pre><code>import sys, termios, tty
assert sys.stdin.isatty(), "Can't run without a console to run on"
fd = sys.stdin.fileno()
stash = termios.tcgetattr(fd)
try:
    tty.setraw(fd)
    newterm = termios.tcgetattr(fd)
    newterm[tty.LFLAG] |= termios.ECHO
    termios.tcsetattr(fd)
    message = b''
    while True:
        ch = sys.stdin.buffer.read(1)
        if ch == b'\x1b':
            exit(0)
        elif ch == b'\n':
            break
        else:
            message += ch
    message = message.decode(sys.stdin.encoding)
finally:
    termios.tcsetattr(fd, termios.TCSANOW, stash)
</code></pre>
<p>As with the Windows version, this should be 2.6+/3.3+ multi-version-compatible, except for the fact that it always returns <code>unicode</code> while 2.x <code>raw_input</code> would return <code>str</code> (which in this case is all in that one <code>decode</code> line, which you can drop if you don't want it).</p>
<p>Notice that I used both <code>tty</code> and <code>termios</code> here. The <code>tty</code> module is a higher-level wrapper, but it doesn't do everything you want. So, you can use it as far as it goes (to flip whatever switches are needed to get raw mode on your platform, and to let you use cross-platform/readable names for the flagsets and values instead of indices), but you usually still need <code>termios</code> anyway.</p>
<hr/>
<p>On any other platform, you're on your own.</p>
</div>
<span class="comment-copy">raw_input doesnt work like that. It waits until the user presses enter  to pass whatever the user wrote into the variable message. You need something that will monitor every key pressed and then if the key is the ESC key it can do something like exiting the program. take a look at kbhit if you are using linux.</span>
<span class="comment-copy">By the way, is there a reason this is tagged <code>pypy</code>? From what I can tell, PyPy 2.1.0/2.7.3 acts exactly the same as CPython 2.7.3 as far as input goes, and the same for earlier versions. (PyPy3 2.1.0b1/3.2.3 does have a few differences from CPython 3.2.3 on at least one platform, but that's just because it's a beta with a few bugs.)</span>
<span class="comment-copy">I use pypy, because it's faster than CPython, that's why I always use pypy as a tag.</span>
