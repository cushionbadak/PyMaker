<div class="post-text" itemprop="text">
<p>I have list:</p>
<pre><code>k = ["key1", "subkey2", "subsubkey3"]
</code></pre>
<p>I know for certain that <code>d</code> is a dict such that <code>d["key1"]["subkey2"]["subsubkey3"]</code> is valid.</p>
<p>How can I transform list <code>k</code> as a key for dict <code>d</code> so as to return <code>d[k[0]][k[1]]...</code>? </p>
</div>
<div class="post-text" itemprop="text">
<p>You can try using <a href="http://docs.python.org/2/library/functions.html#reduce" rel="nofollow"><code>reduce()</code></a> with <a href="http://docs.python.org/2/library/operator.html#operator.getitem" rel="nofollow"><code>operator.getitem</code></a>:</p>
<pre><code>&gt;&gt;&gt; from operator import getitem
&gt;&gt;&gt; 
&gt;&gt;&gt; d = {'key1': {'subkey2': {'subsubkey3': 'value'}}}
&gt;&gt;&gt; k = ["key1", "subkey2", "subsubkey3"]
&gt;&gt;&gt; 
&gt;&gt;&gt; reduce(getitem, k, d)
'value'
</code></pre>
<p>In Python 3.x, you should use <a href="http://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow"><code>functools.reduce()</code></a>.</p>
<hr/>
<p><code>reduce()</code> simply takes a 2-argument function and applies it to the elements of a list consecutively, accumulating the result. There is also an optional <em>initializer</em> argument, which we have used here. As the docs state, <code>reduce()</code> is roughly equivalent to:</p>
<pre><code>def reduce(function, iterable, initializer=None):
    it = iter(iterable)
    if initializer is None:
        try:
            initializer = next(it)
        except StopIteration:
            raise TypeError('reduce() of empty sequence with no initial value')
    accum_value = initializer
    for x in it:
        accum_value = function(accum_value, x)
    return accum_value
</code></pre>
<p>In our case, we are passing an <code>initializer</code> so it will not be <code>None</code>. Hence what we have is:</p>
<pre><code>def reduce(function, iterable, initializer=None):
    it = iter(iterable)
    accum_value = initializer
    for x in it:
        accum_value = function(accum_value, x)
    return accum_value
</code></pre>
<p>Our <code>function</code> in this case is <code>getitem(a, b)</code> (see link above) which simply returns the <code>a[b]</code>. Moreover, our <code>iterable</code> is <code>k</code> and our <code>initializer</code> is <code>d</code>. So the <code>reduce()</code> call above is equivalent to:</p>
<pre><code>accum_value = d
for x in k:
    accum_value = accum_value[x]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>temp_d = d
for key in k:
 temp_d = temp_d[key]
</code></pre>
<p>After this code finishes temp_d will contain your value</p>
</div>
<div class="post-text" itemprop="text">
<p>This is one of the few times when <code>reduce</code> might be a good idea - what it does is successively apply the same operation on a value.</p>
<pre><code>items = {'foo': {'bar': {'baz': 123}}}
keys = ['foo', 'bar', 'baz']
reduce(lambda d, k: d[k], keys, items) 
</code></pre>
<p>This is equivalent to:</p>
<pre><code>items = {'foo': …}
keys = ['foo', …]

result = items
for k in keys:
    # The RHS here is the function passed to reduce(), applied to the 
    # (intermediate) result and the current step in the loop 
    result = items[k] 
</code></pre>
</div>
<span class="comment-copy">you mean that <code>d[k[0]]</code> is a dictionary containing key <code>k[1]</code> that contains a dictionary with key <code>k[2]</code>?</span>
<span class="comment-copy">besides: have you tried anything?</span>
<span class="comment-copy">Yes, that was I mean.</span>
<span class="comment-copy">@SkyFox Your question is a good one, rephrase it and use codify some parts to make it more readable.</span>
<span class="comment-copy"><code>d[k[0]][k[1]][k[2]]</code></span>
<span class="comment-copy">This was excellent. I learnt something new, thanks. Would you mind explaining it in a bit more detail?</span>
<span class="comment-copy">@GamesBrainiac Sure, see the edit.</span>
