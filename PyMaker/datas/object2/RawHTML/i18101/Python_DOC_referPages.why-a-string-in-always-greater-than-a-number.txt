<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3270680/how-does-python-2-compare-string-and-int-why-do-lists-compare-as-greater-than-n">How does Python 2 compare string and int? Why do lists compare as greater than numbers, and tuples greater than lists?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I just noticed that Python allows you to compare a string value with a number:</p>
<pre><code>&gt;&gt;&gt; '10' &gt; 1000
True
&gt;&gt;&gt; 'a' &gt; 1000
True
&gt;&gt;&gt; 'a' &gt; -1000
True
</code></pre>
<p>Why is any string always greater than any number?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2, <a href="http://docs.python.org/2/library/stdtypes.html" rel="nofollow">§5.3 - Comparisons</a> says:</p>
<blockquote>
<p>Objects of different types, except different numeric types and different string types, never compare equal; <strong>such objects are ordered consistently but arbitrarily</strong> (so that sorting a heterogeneous array yields a consistent result). Furthermore, some types (for example, file objects) support only a degenerate notion of comparison where any two objects of that type are unequal. Again, such objects are ordered arbitrarily but consistently. The <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> operators will raise a TypeError exception when any operand is a complex number.</p>
</blockquote>
<p>In Python 3, <a href="http://docs.python.org/3/library/stdtypes.html#comparisons" rel="nofollow">§4.3 - Comparisons</a> says:</p>
<blockquote>
<p>Objects of different types, except different numeric types, never compare equal. Furthermore, some types (for example, function objects) support only a degenerate notion of comparison where any two objects of that type are unequal. <strong>The <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> operators will raise a TypeError exception</strong> when comparing a complex number with another built-in numeric type, <strong>when the objects are of different types that cannot be compared</strong>, or in other cases where there is no defined ordering.</p>
</blockquote>
</div>
<span class="comment-copy">You're comparing two different types that do not have any meaningful comparison, so it is up to the interpreter's implementation, I believe.</span>
<span class="comment-copy">If you're asking "Why did Python choose this rule" rather than "What is the rule", <a href="http://stackoverflow.com/a/2384139/908494">Alex Martelli's answer</a> on a different dup of the question is probably what you're looking for.</span>
<span class="comment-copy">@abarnert excellent explanation on the why it came to be so, and why this raises an error in Python 3, thanks.</span>
<span class="comment-copy">It's probably worth adding the "CPython implementation detail" below that as well, which explains why he sees that particular "consistent but arbitrary" ordering. (Although it isn't 100% complete; it doesn't explain that <code>None</code> is always less than anything else, and numeric types are always less than anything non-<code>None</code>, or what "numeric" means, or the rules for dealing with pathological subclasses of built-in numeric types, or… But the only place you'll find more explanation is in the source code.)</span>
