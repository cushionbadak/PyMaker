<div class="post-text" itemprop="text">
<p>I see from other discussions that reload is considered an unnecessary operation and a bad way to develop programmes.  People say to use doctest and unittest.  I must be missing something.  To develop a programme I write it in a module, load the module into an eclipse console, experiment in the console by running little samples of code, then I spot an error in the module or decide to change something.  Surely the quickest thing to do is save the module, reload it and carry on working in the console.<br/>
Is there a better way?      </p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a contrived example of how you could use <a href="http://docs.python.org/3/library/doctest.html" rel="nofollow">doctest</a> and test driven development in comparision with testing by entering code at the console, with a recursive factorial function being used as an example:</p>
<p>Console:</p>
<p>First attempt:</p>
<pre><code>def factorial(x)
    pass
</code></pre>
<p>Console:</p>
<pre><code>&gt;&gt;&gt; factorial(7)
SyntaxError: invalid syntax
</code></pre>
<p>Second attempt:</p>
<pre><code>def factorial(x):
    return x*x-1
</code></pre>
<p>Console:</p>
<pre><code>&gt;&gt;&gt; factorial(7)
42
</code></pre>
<p>Third attempt:</p>
<pre><code>def factorial(x):
    return x * factorial(x-1)
</code></pre>
<p>Console:</p>
<pre><code>&gt;&gt;&gt; factorial(7)
RuntimeError: maximum recursion depth reached        # StackOverflow! (basically)
</code></pre>
<p>Fourth attempt:</p>
<pre><code>def factorial(x):
    if x == 0:
        return 1
    else:
        return x * factorial(x-1)
</code></pre>
<p>Console:</p>
<pre><code>&gt;&gt;&gt; factorial(5)
120
</code></pre>
<p>In the end, we get the right answer, but at each stage we have to go back to the console and write the same thing. This is alright for a short program like this, but for a program with many functions, and more complex interactions and possibilities to be tested it would take a very long time. Programming is about automating repetitive tasks, and testing is a repetitive task, so it makes sense to automate it. And in Python, tools to do just this are provided for you.</p>
<p>Behold - the doctest module: (example taken from the docs)</p>
<p>First attempt:</p>
<pre><code>def factorial(n):
    """Return the factorial of n, an exact integer &gt;= 0.

    &gt;&gt;&gt; [factorial(n) for n in range(6)]
    [1, 1, 2, 6, 24, 120]
    &gt;&gt;&gt; factorial(30)
    265252859812191058636308480000000
    &gt;&gt;&gt; factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: n must be &gt;= 0

    Factorials of floats are OK, but the float must be an exact integer:
    &gt;&gt;&gt; factorial(30.1)
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
    &gt;&gt;&gt; factorial(30.0)
    265252859812191058636308480000000

    It must also not be ridiculously large:
    &gt;&gt;&gt; factorial(1e100)
    Traceback (most recent call last):
        ...
    OverflowError: n too large
    """

if __name__ == "__main__":
    import doctest
    doctest.testmod(verbose=True)
</code></pre>
<p>First test (just run the program):</p>
<pre><code>Trying:
    [factorial(n) for n in range(6)]
Expecting:
    [1, 1, 2, 6, 24, 120]
ok
Trying:
    factorial(30)
Expecting:
    265252859812191058636308480000000
ok
Trying:
    factorial(-1)
Expecting:
    Traceback (most recent call last):
        ...
    ValueError: n must be &gt;= 0
ok
Trying:
    factorial(30.1)
Expecting:
    Traceqwrqaeqrback (most recent call last):
        ...
    ValueError: n must be exact integer
**********************************************************************
File "C:/Python33/doctestex.py", line 14, in __main__.factorial
Failed example:
    factorial(30.1)
Exception raised:
    Traceback (most recent call last):
      File "C:\Python33\lib\doctest.py", line 1287, in __run
        compileflags, 1), test.globs)
      File "&lt;doctest __main__.factorial[3]&gt;", line 1, in &lt;module&gt;
        factorial(30.1)
      File "C:/Python33/doctestex.py", line 32, in factorial
        raise ValueError("n must be exact integer")
    ValueError: n must be exact integer
Trying:
    factorial(30.0)
Expecting:
    265252859812191058636308480000000
ok
Trying:
    factorial(1e100)
Expecting:
    Traceback (most recent call last):
        ...
    OverflowError: n too large
ok
1 items had no tests:
    __main__
**********************************************************************
1 items had failures:
   1 of   6 in __main__.factorial
6 tests in 2 items.
5 passed and 1 failed.
***Test Failed*** 1 failures.
&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt; 
Trying:
    [factorial(n) for n in range(6)]
Expecting:
    [1, 1, 2, 6, 24, 120]
**********************************************************************
File "C:/Python33/doctestex.py", line 4, in __main__.factorial
Failed example:
    [factorial(n) for n in range(6)]
Expected:
    [1, 1, 2, 6, 24, 120]
Got:
    [None, None, None, None, None, None]
Trying:
    factorial(30)
Expecting:
    265252859812191058636308480000000
**********************************************************************
File "C:/Python33/doctestex.py", line 6, in __main__.factorial
Failed example:
    factorial(30)
Expected:
    265252859812191058636308480000000
Got nothing
Trying:
    factorial(-1)
Expecting:
    Traceback (most recent call last):
        ...
    ValueError: n must be &gt;= 0
**********************************************************************
File "C:/Python33/doctestex.py", line 8, in __main__.factorial
Failed example:
    factorial(-1)
Expected:
    Traceback (most recent call last):
        ...
    ValueError: n must be &gt;= 0
Got nothing
Trying:
    factorial(30.1)
Expecting:
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
**********************************************************************
File "C:/Python33/doctestex.py", line 14, in __main__.factorial
Failed example:
    factorial(30.1)
Expected:
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
Got nothing
Trying:
    factorial(30.0)
Expecting:
    265252859812191058636308480000000
**********************************************************************
File "C:/Python33/doctestex.py", line 18, in __main__.factorial
Failed example:
    factorial(30.0)
Expected:
    265252859812191058636308480000000
Got nothing
Trying:
    factorial(1e100)
Expecting:
    Traceback (most recent call last):
        ...
    OverflowError: n too large
**********************************************************************
File "C:/Python33/doctestex.py", line 22, in __main__.factorial
Failed example:
    factorial(1e100)
Expected:
    Traceback (most recent call last):
        ...
    OverflowError: n too large
Got nothing
1 items had no tests:
    __main__
**********************************************************************
1 items had failures:
   6 of   6 in __main__.factorial
6 tests in 2 items.
0 passed and 6 failed.
***Test Failed*** 6 failures.
</code></pre>
<p>Then when we finish the program (and at all stages between) we just press one button and that does all our testing for us. If you were working with a team on a bigger project, you could, for instance, write the test data to file and use the failures to see where you need to focus on.</p>
<pre><code>Trying:
    [factorial(n) for n in range(6)]
Expecting:
    [1, 1, 2, 6, 24, 120]
ok
Trying:
    factorial(30)
Expecting:
    265252859812191058636308480000000
ok
Trying:
    factorial(-1)
Expecting:
    Traceback (most recent call last):
        ...
    ValueError: n must be &gt;= 0
ok
Trying:
    factorial(30.1)
Expecting:
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
ok
Trying:
    factorial(30.0)
Expecting:
    265252859812191058636308480000000
ok
Trying:
    factorial(1e100)
Expecting:
    Traceback (most recent call last):
        ...
    OverflowError: n too large
ok
1 items had no tests:
    __main__
1 items passed all tests:
   6 tests in __main__.factorial
6 tests in 2 items.
6 passed and 0 failed.
Test passed.
</code></pre>
<p>And (provided you added all the test cases to the docstring) now you can ship or integrate or whatever the program and it much fewer bugs than it would've if you just tested for the things you thought mattered each time you changed something, rather than the things you thought could possibly ever matter at the start of the development process.</p>
<p>Not to mention you now have the basis for your documentation! Running the program in the console, and then entering <code>help(factorial)</code> will now give you this:</p>
<pre><code>Help on function factorial in module __main__:

factorial(n)
    Return the factorial of n, an exact integer &gt;= 0.

    &gt;&gt;&gt; [factorial(n) for n in range(6)]
    [1, 1, 2, 6, 24, 120]
    &gt;&gt;&gt; factorial(30)
    265252859812191058636308480000000
    &gt;&gt;&gt; factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: n must be &gt;= 0

    Factorials of floats are OK, but the float must be an exact integer:
    &gt;&gt;&gt; factorial(30.1)
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
    &gt;&gt;&gt; factorial(30.0)
    265252859812191058636308480000000

    It must also not be ridiculously large:
    &gt;&gt;&gt; factorial(1e100)
    Traceback (most recent call last):
        ...
    OverflowError: n too large
</code></pre>
<p>You can then use a number of tools (<a href="http://docs.python.org/3/library/pydoc.html" rel="nofollow">pydoc</a> is one in the standard library) to turn the docstrings into formatted HTML helpfiles.</p>
<p>Of course, this is only one of many testing tools you can use with Python. Others include the more powerful <a href="http://docs.python.org/3/library/unittest.html" rel="nofollow">unittest</a> module, and the less powerful technique of adding <code>assert</code> statements into your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Basically instead of trying things out in the console, try things out by writing tests. It's almost the same amount of typing, but repeatable (you can check if things still work after you make changes) and it works as a rudimentary form of documentation.</p>
</div>
<span class="comment-copy">Heard of Test Driven Devlopment which is different from Tickering Driven Programming</span>
<span class="comment-copy">Doctest and unittest are for, well, testing. Running small parts of the code is unlikely to catch all bugs, it isn't thourgh or methodical enough.</span>
<span class="comment-copy">@sweeneyrod I agree that methodical testing has an important place but there are times when I don't want to produce a final piece of code, I just want to experiment.  Even if do want to produce something properly tested, early in programme development, I just want to experiment and try out different ideas.  At that stage I wouldn't have thought doctest will be so useful.  It will just slow me down.</span>
<span class="comment-copy">You can experiment any way you like, there is no "best way" to experiment.</span>
<span class="comment-copy">thanks for this comprehensive discussion.  This is interesting to someone you probably guessed is a noob at python (though not a noob at mathematical programming).  My first approach is to write the function to a file, import, run, edit, reload, run, edit etc.  To check I understand correctly, is the advantage of doctest that it is equally quick to do the same thing and bring additional benefits, or is it slightly slower but considered worth it for the additional rigour?</span>
<span class="comment-copy">@hfffoman I'd say that the benefit of <code>doctest</code> is that you do slightly more work initially, but that then reduces the long write-testing-file-then-run-it cycle, along with other benefits (documentation gets written as you go along). But I think the power of testing tools becomes more obvious the bigger your program gets - you'd never dream of writing a large project (say, Eclipse) without formal testing and tools - probably much more heavy duty than those in the standard library.</span>
<span class="comment-copy">+1 do you mean to write statements in a file and then test run them before making them into a function?  Would the quickest way be then to load (and reload) the test file into a console?</span>
