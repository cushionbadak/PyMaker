<div class="post-text" itemprop="text">
<p>I have <code>dt = datetime(2013,9,1,11)</code>, and I would like to get a Unix timestamp of this datetime object.</p>
<p>When I do <code>dt - datetime(1970,1,1)).total_seconds()</code> I got the timestamp <code>1378033200</code>.</p>
<p>When converting it back using <code>datetime.fromtimestamp</code> I got <code>datetime.datetime(2013, 9, 1, 6, 0)</code>.</p>
<p>The hour doesn't match. What did I miss here?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you missed here is timezones.</p>
<p>Presumably you've five hours off UTC, so 2013-09-01T11:00:00 local and 2013-09-01T06:00:00Z are the same time.</p>
<p>You need to read the top of the <a href="http://docs.python.org/3.3/library/datetime.html"><code>datetime</code></a> docs, which explain about timezones and "naive" and "aware" objects.</p>
<p>If your original naive datetime was UTC, the way to recover it is to use <a href="http://docs.python.org/3.3/library/datetime.html#datetime.datetime.utcfromtimestamp"><code>utcfromtimestamp</code></a> instead of <code>fromtimestamp</code>.</p>
<p>On the other hand, if your original naive datetime was local, you shouldn't have subtracted a UTC timestamp from it in the first place; use <code>datetime.fromtimestamp(0)</code> instead.</p>
<p>Or, if you had an aware datetime object, you need to either use a local (aware) epoch on both sides, or explicitly convert to and from UTC.</p>
<p>If you have, or can upgrade to, Python 3.3 or later, you can avoid all of these problems by just using the <a href="http://docs.python.org/3.3/library/datetime.html#datetime.datetime.timestamp"><code>timestamp</code></a> method instead of trying to figure out how to do it yourself. And even if you don't, you may want to consider <a href="http://hg.python.org/cpython/file/3.3/Lib/datetime.py#l1428">borrowing its source code</a>.</p>
<p>(And if you can wait for Python 3.4, it looks like <a href="http://www.python.org/dev/peps/pep-0431/">PEP 341</a> is likely to make it into the final release, which means all of the stuff J.F. Sebastian and I were talking about in the comments should be doable with just the stdlib, and working the same way on both Unix and Windows.)</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>solution is</strong>
</p>
<pre><code>import time
import datetime
d = datetime.date(2015,1,5)

unixtime = time.mktime(d.timetuple())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rather than this expression to create a POSIX timestamp from <code>dt</code>,</p>
<pre><code>(dt - datetime(1970,1,1)).total_seconds()
</code></pre>
<p>Use this:</p>
<pre><code>int(dt.strftime("%s"))
</code></pre>
<p>I get the right answer in your example using the second method.</p>
<p>EDIT: Some followup... After some comments (see below), I was curious about the lack of support or documentation for <code>%s</code> in <code>strftime</code>. Here's what I found:</p>
<p>In the <a href="https://github.com/python/cpython/blob/master/Modules/timemodule.c">Python source</a> for <code>datetime</code> and <code>time</code>, the string <code>STRFTIME_FORMAT_CODES</code> tells us:</p>
<pre><code>"Other codes may be available on your platform.
 See documentation for the C library strftime function."
</code></pre>
<p>So now if we <code>man strftime</code> (on BSD systems such as Mac OS X), you'll find support for <code>%s</code>:</p>
<pre><code>"%s is replaced by the number of seconds since the Epoch, UTC (see mktime(3))."
</code></pre>
<p>Anyways, that's why <code>%s</code> works on the systems it does.  But there are better solutions to OP's problem (that take timezones into account).  See @abarnert's accepted answer here.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to convert a python datetime to seconds since epoch you should do it explicitly:</p>
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; datetime.datetime(2012,04,01,0,0).strftime('%s')
'1333234800'
&gt;&gt;&gt; (datetime.datetime(2012,04,01,0,0) - datetime.datetime(1970,1,1)).total_seconds()
1333238400.0
</code></pre>
<p>In Python 3.3+ you can use <a href="https://docs.python.org/3/library/datetime.html?highlight=re#datetime.datetime.timestamp" rel="noreferrer"><code>timestamp()</code></a> instead:</p>
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; datetime.datetime(2012,4,1,0,0).timestamp()
1333234800.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your datetime object represents UTC time, don't use time.mktime, as it assumes the tuple is in your local timezone. Instead, use calendar.timegm:</p>
<pre><code>&gt;&gt;&gt; import datetime, calendar
&gt;&gt;&gt; d = datetime.datetime(1970, 1, 1, 0, 1, 0)
&gt;&gt;&gt; calendar.timegm(d.timetuple())
60
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For working with UTC timezones:</p>
<pre><code>time_stamp = calendar.timegm(dt.timetuple())

datetime.utcfromtimestamp(time_stamp)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, when converting TO unix timestamp, python is basically assuming UTC, but while converting back it will give you a date converted to your local timezone.</p>
<p>See this question/answer;
<a href="https://stackoverflow.com/questions/18812638/get-timezone-used-by-datetime-datetime-fromtimestamp">Get timezone used by datetime.datetime.fromtimestamp()</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You've missed the time zone info (already answered, agreed)</p>
<p><strong><a href="https://pypi.org/project/arrow/" rel="nofollow noreferrer"><code>arrow</code></a> package</strong> allows to avoid this torture with datetimes; It is already written, tested, pypi-published, cross-python (2.6 â€” 3.xx). </p>
<p>All you need: <code>pip install arrow</code> (or add to dependencies)</p>
<h3>Solution for your case</h3>
<pre class="lang-python prettyprint-override"><code>dt = datetime(2013,9,1,11)
arrow.get(dt).timestamp
# &gt;&gt;&gt; 1378033200

bc = arrow.get(1378033200).datetime
print(bc)
# &gt;&gt;&gt; datetime.datetime(2013, 9, 1, 11, 0, tzinfo=tzutc())
print(bc.isoformat())
# &gt;&gt;&gt; '2013-09-01T11:00:00+00:00'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def dt2ts(dt, utc=False):
    if utc:
        return calendar.timegm(dt.timetuple())
    if dt.tzinfo is None:
        return int(time.mktime(dt.timetuple()))
    utc_dt = dt.astimezone(tz.tzutc()).timetuple()
    return calendar.timegm(utc_dt)
</code></pre>
<p>If you want UTC timestamp :<code>time.mktime</code> just for <strong>local</strong> dt .Use <code>calendar.timegm</code> is safe but dt must the utc zone so change the zone to utc. If dt in UTC just use <code>calendar.timegm</code>.</p>
</div>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/8777753/4279">Converting datetime.date to UTC timestamp in Python</a></span>
<span class="comment-copy">Where does <code>dt</code> come from? Is it a local time or time in UTC?</span>
<span class="comment-copy">I should mention here that the real solution is to conquer the world and outlaw all timezones. The implementation is left as an exercise for the reader.</span>
<span class="comment-copy">@abarnert I'd also like to submit a request to purge all codepages and unicode symbols, that is, to outlaw all non-ascii and non-default-codepage languages. Paintings of symbols are still allowed.</span>
<span class="comment-copy">@DanielF: Request denied. I'm not interested in creating a one-world language here, and even if we did I wouldn't want to make life impossible for historical linguists and Tolkien scholars. Unicode already solves the problem, except that certain organizations and products (the TRON consortium, Japanese software that uses Shift-JIS over UTF-8, Microsoft still delivering an OS that defaults to cp1252 for user text files, and various SDKs that pretend that UTF-16 is a fixed-width charset and/or the same thing as Unicode) need to be punished to bring them in line.</span>
<span class="comment-copy">if <code>dt</code> is in local timezone then the formula in the question is incorrect <code>datetime.fromtimestamp(0)</code> (epoch in the current timezone) should be used instead of <code>datetime(1970, 1,1)</code> (unix epoch in UTC).</span>
<span class="comment-copy">@J.F.Sebastian: I didn't want to cover all of the three possibilities in detail, but I guess you're right, I should.</span>
<span class="comment-copy">btw, <code>fromtimestamp(0)</code> might fail if the system doesn't store historical timezone information e.g., on Windows. <code>pytz</code> could be used in this case.</span>
<span class="comment-copy">@J.F.Sebastian: But <code>pytz</code> doesn't help unless you already know which timezone you're in; to do that programmatically, you need a different library that gets the current Windows timezone and converts it to a <code>pytz</code> timezone and/or looks it up by name.</span>
<span class="comment-copy">there is <code>tzlocal</code> module that also works on Windows. Here's how you could <a href="http://stackoverflow.com/a/13287083/4279">convert utc time to local time</a>.</span>
<span class="comment-copy">it assumes that <code>d</code> is a naive date/datetime object that represents local time (it may fail for ambiguous times or for past/future dates if OS doesn't provide a historical tz db (UTC offset might have been different in the past in the local timezone)). <a href="http://stackoverflow.com/q/8777753/4279">More options</a>.</span>
<span class="comment-copy">Looks like nobody minds floating-point solution. Is it that obvious for everyone?</span>
<span class="comment-copy">This drops the microseconds.  Might be interesting.</span>
<span class="comment-copy">Only problem is that you don't take timezone into account.</span>
<span class="comment-copy">it shouldn't. If you need to adjust TZ, you need to do that first.</span>
<span class="comment-copy">This is undocumented behaviour (I believe). For example on windows it results in "Invalid format string".</span>
<span class="comment-copy">@CrescentFresh, interesting. You may be right.  While I don't see <code>strftime("%s")</code> in documentation, I did just confirm this to work on Mac and Linux. Thanks.</span>
<span class="comment-copy">Also, %s gives you an integer, so you lose precision.</span>
<span class="comment-copy">apparently it ignores the tzinfo field.</span>
<span class="comment-copy">@DarrenStone: you don't need to read the source. Both <code>time.strftime()</code> and <code>datetime.strftime</code> documentation delegate to the platforms <code>strftime(3)</code> function for unsupported directives. <code>%s</code> may fail even on Mac OS X e.g., <a href="http://bugs.python.org/issue12750" rel="nofollow noreferrer">datetime.strftime('%s') should respect tzinfo</a>.</span>
<span class="comment-copy">Doesn't take timezones into account.</span>
<span class="comment-copy">You do not want to use <code>%s</code>, as it will be localized to the clock of the system you are currently on. You should only ever use <code>.timestamp()</code> to get the correct Epoch/UNIX time.</span>
<span class="comment-copy"><code>%s</code> does not work on Windows systems (<code>ValueError: Invalid format string</code>)</span>
<span class="comment-copy">Hours Place gives error if i put in 08 or 09</span>
<span class="comment-copy">@amitnair92 just put <code>8</code> or <code>9</code></span>
<span class="comment-copy">After an hour of searching, this was the only answer that worked :')</span>
