<div class="post-text" itemprop="text">
<p>I'm looking for an efficient way to check variables of a python function. For example, I'd like to check arguments type and value. Is there a module for this? Or should I use something like decorators, or any specific idiom?</p>
<pre><code>def my_function(a, b, c):
    """an example function I'd like to check the arguments of."""
    # check that a is an int
    # check that 0 &lt; b &lt; 10
    # check that c is not an empty string
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The most Pythonic idiom is to clearly <em>document</em> what the function expects and then just try to use whatever gets passed to your function and either let exceptions propagate or just catch attribute errors and raise a <code>TypeError</code> instead. Type-checking should be avoided as much as possible as it goes against duck-typing. Value testing can be OK – depending on the context.</p>
<p>The only place where validation really makes sense is at system or subsystem entry point, such as web forms, command line arguments, etc. Everywhere else, as long as your functions are properly documented, it's the caller's responsibility to pass appropriate arguments.</p>
</div>
<div class="post-text" itemprop="text">
<p>In this elongated answer, we implement a Python 3.x-specific type checking decorator based on <a href="https://www.python.org/dev/peps/pep-0484" rel="noreferrer">PEP 484</a>-style type hints in less than 275 lines of pure-Python (most of which is explanatory docstrings and comments) – heavily optimized for industrial-strength real-world use complete with a <a href="https://github.com/pytest-dev/pytest" rel="noreferrer"><code>py.test</code></a>-driven test suite exercising all possible edge cases.</p>
<p>Feast on the unexpected awesome of <strong>bear typing</strong>:</p>
<pre><code>&gt;&gt;&gt; @beartype
... def spirit_bear(kermode: str, gitgaata: (str, int)) -&gt; tuple:
...     return (kermode, gitgaata, "Moksgm'ol", 'Ursus americanus kermodei')
&gt;&gt;&gt; spirit_bear(0xdeadbeef, 'People of the Cane')
AssertionError: parameter kermode=0xdeadbeef not of &lt;class "str"&gt;
</code></pre>
<p>As this example suggests, bear typing explicitly supports type checking of parameters and return values annotated as either simple types or tuples of such types. <em>Golly!</em></p>
<p>O.K., that's actually unimpressive. <code>@beartype</code> resembles every <em>other</em> Python 3.x-specific type checking decorator based on <a href="https://www.python.org/dev/peps/pep-0484" rel="noreferrer">PEP 484</a>-style type hints in less than 275 lines of pure-Python. So what's the rub, bub?</p>
<h2>Pure Bruteforce Hardcore Efficiency</h2>
<p>Bear typing is dramatically more efficient in both space and time than all existing implementations of type checking in Python to the best of my limited domain knowledge. (<em>More on that later.</em>)</p>
<p>Efficiency usually doesn't matter in Python, however. If it did, you wouldn't be using Python. Does type checking actually deviate from the well-established norm of avoiding premature optimization in Python? <strong>Yes. Yes, it does.</strong></p>
<p>Consider profiling, which adds unavoidable overhead to each profiled metric of interest (e.g., function calls, lines). To ensure accurate results, this overhead is mitigated by leveraging optimized C extensions (e.g., the <code>_lsprof</code> C extension leveraged by the <code>cProfile</code> module) rather than unoptimized pure-Python (e.g., the <code>profile</code> module). Efficiency really <em>does</em> matter when profiling.</p>
<p>Type checking is no different. Type checking adds overhead to each function call type checked by your application – ideally, <em>all</em> of them. To prevent well-meaning (but sadly small-minded) coworkers from removing the type checking you silently added after last Friday's caffeine-addled allnighter to your geriatric legacy Django web app, <strong>type checking must be fast.</strong> So fast that no one notices it's there when you add it without telling anyone. <sup><em>I do this all the time! Stop reading this if you are a coworker.</em></sup></p>
<p>If even ludicrous speed isn't enough for your gluttenous application, however, bear typing may be globally disabled by enabling Python optimizations (e.g., by passing the <code>-O</code> option to the Python interpreter):</p>
<pre><code>$ python3 -O
# This succeeds only when type checking is optimized away. See above!
&gt;&gt;&gt; spirit_bear(0xdeadbeef, 'People of the Cane')
(0xdeadbeef, 'People of the Cane', "Moksgm'ol", 'Ursus americanus kermodei')
</code></pre>
<p>Just because. Welcome to bear typing.</p>
<h2>What The...? Why "bear"? You're a Neckbeard, Right?</h2>
<p>Bear typing is bare-metal type checking – that is, type checking as close to the manual approach of type checking in Python as feasible. Bear typing is intended to impose <em>no</em> performance penalties, compatibility constraints, or third-party dependencies (over and above that imposed by the manual approach, anyway). Bear typing may be seamlessly integrated into existing codebases and test suites without modification.</p>
<p>Everyone's probably familiar with the manual approach. You manually <code>assert</code> each parameter passed to and/or return value returned from <em>every</em> function in your codebase. What boilerplate could be simpler or more banal? We've all seen it a hundred times a googleplex times, and vomited a little in our mouths everytime we did. Repetition gets old fast. <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noreferrer">DRY</a>, yo.</p>
<p>Get your vomit bags ready. For brevity, let's assume a simplified <code>easy_spirit_bear()</code> function accepting only a single <code>str</code> parameter. Here's what the manual approach looks like:</p>
<pre><code>def easy_spirit_bear(kermode: str) -&gt; str:
    assert isinstance(kermode, str), 'easy_spirit_bear() parameter kermode={} not of &lt;class "str"&gt;'.format(kermode)
    return_value = (kermode, "Moksgm'ol", 'Ursus americanus kermodei')
    assert isinstance(return_value, str), 'easy_spirit_bear() return value {} not of &lt;class "str"&gt;'.format(return_value)
    return return_value
</code></pre>
<p>Python 101, right? Many of us passed that class.</p>
<p>Bear typing extracts the type checking manually performed by the above approach into a dynamically defined wrapper function automatically performing the same checks – with the added benefit of raising granular <code>TypeError</code> rather than ambiguous <code>AssertionError</code> exceptions. Here's what the automated approach looks like:</p>
<pre><code>def easy_spirit_bear_wrapper(*args, __beartype_func=easy_spirit_bear, **kwargs):
    if not (
        isinstance(args[0], __beartype_func.__annotations__['kermode'])
        if 0 &lt; len(args) else
        isinstance(kwargs['kermode'], __beartype_func.__annotations__['kermode'])
        if 'kermode' in kwargs else True):
            raise TypeError(
                'easy_spirit_bear() parameter kermode={} not of {!r}'.format(
                args[0] if 0 &lt; len(args) else kwargs['kermode'],
                __beartype_func.__annotations__['kermode']))

    return_value = __beartype_func(*args, **kwargs)

    if not isinstance(return_value, __beartype_func.__annotations__['return']):
        raise TypeError(
            'easy_spirit_bear() return value {} not of {!r}'.format(
                return_value, __beartype_func.__annotations__['return']))

    return return_value
</code></pre>
<p>It's long-winded. But it's also basically<sup>*</sup> as fast as the manual approach. <sup>* <em>Squinting suggested.</em></sup></p>
<p>Note the complete lack of function inspection or iteration in the wrapper function, which contains a similar number of tests as the original function – albeit with the additional (maybe negligible) costs of testing whether and how the parameters to be type checked are passed to the current function call. You can't win every battle.</p>
<p>Can such wrapper functions <em>actually</em> be reliably generated to type check arbitrary functions in less than 275 lines of pure Python? <a href="https://en.wikipedia.org/wiki/Snake_Plissken" rel="noreferrer">Snake Plisskin</a> says, <em>"True story. Got a smoke?"</em></p>
<p>And, yes. I may have a neckbeard.</p>
<h2>No, Srsly. Why "bear"?</h2>
<p>Bear beats duck. Duck may fly, but bear may throw salmon at duck. <sup><em>In Canada, nature can surprise you.</em></sup></p>
<p>Next question.</p>
<h2>What's So Hot about Bears, Anyway?</h2>
<p>Existing solutions do <em>not</em> perform bare-metal type checking – at least, none I've grepped across. They all iteratively reinspect the signature of the type-checked function on <strong>each function call</strong>. While negligible for a single call, reinspection overhead is usually non-negligible when aggregated over all calls. <em>Really, really</em> non-negligible.</p>
<p>It's not simply efficiency concerns, however. Existing solutions also often fail to account for common edge cases. This includes most if not all toy decorators provided as stackoverflow answers here and elsewhere. Classic failures include:</p>
<ul>
<li>Failing to type check keyword arguments and/or return values (e.g., <a href="https://stackoverflow.com/users/2387370/sweeneyrod">sweeneyrod</a>'s <a href="https://stackoverflow.com/a/19684962/2809027"><code>@checkargs</code> decorator</a>).</li>
<li>Failing to support tuples (i.e., unions) of types accepted by the <code>isinstance()</code> builtin.</li>
<li>Failing to propagate the name, docstring, and other identifying metadata from the original function onto the wrapper function.</li>
<li>Failing to supply at least a semblance of unit tests. (<em>Kind of critical.</em>)</li>
<li>Raising generic <code>AssertionError</code> exceptions rather than specific <code>TypeError</code> exceptions on failed type checks. For granularity and sanity, type checking should <em>never</em> raise generic exceptions.</li>
</ul>
<p>Bear typing succeeds where non-bears fail. All one, all bear!</p>
<h2>Bear Typing Unbared</h2>
<p>Bear typing shifts the space and time costs of inspecting function signatures from function call time to function definition time – that is, from the wrapper function returned by the <code>@beartype</code> decorator into the decorator itself. Since the decorator is only called once per function definition, this optimization yields glee for all.</p>
<p>Bear typing is an attempt to have your type checking cake and eat it, too. To do so, <code>@beartype</code>:</p>
<ol>
<li>Inspects the signature and annotations of the original function.</li>
<li>Dynamically constructs the body of the wrapper function type checking the original function. Thaaat's right. Python code generating Python code.</li>
<li>Dynamically declares this wrapper function via the <code>exec()</code> builtin.</li>
<li>Returns this wrapper function.</li>
</ol>
<p>Shall we? Let's dive into the deep end.</p>
<pre><code># If the active Python interpreter is *NOT* optimized (e.g., option "-O" was
# *NOT* passed to this interpreter), enable type checking.
if __debug__:
    import inspect
    from functools import wraps
    from inspect import Parameter, Signature

    def beartype(func: callable) -&gt; callable:
        '''
        Decorate the passed **callable** (e.g., function, method) to validate
        both all annotated parameters passed to this callable _and_ the
        annotated value returned by this callable if any.

        This decorator performs rudimentary type checking based on Python 3.x
        function annotations, as officially documented by PEP 484 ("Type
        Hints"). While PEP 484 supports arbitrarily complex type composition,
        this decorator requires _all_ parameter and return value annotations to
        be either:

        * Classes (e.g., `int`, `OrderedDict`).
        * Tuples of classes (e.g., `(int, OrderedDict)`).

        If optimizations are enabled by the active Python interpreter (e.g., due
        to option `-O` passed to this interpreter), this decorator is a noop.

        Raises
        ----------
        NameError
            If any parameter has the reserved name `__beartype_func`.
        TypeError
            If either:
            * Any parameter or return value annotation is neither:
              * A type.
              * A tuple of types.
            * The kind of any parameter is unrecognized. This should _never_
              happen, assuming no significant changes to Python semantics.
        '''

        # Raw string of Python statements comprising the body of this wrapper,
        # including (in order):
        #
        # * A "@wraps" decorator propagating the name, docstring, and other
        #   identifying metadata of the original function to this wrapper.
        # * A private "__beartype_func" parameter initialized to this function.
        #   In theory, the "func" parameter passed to this decorator should be
        #   accessible as a closure-style local in this wrapper. For unknown
        #   reasons (presumably, a subtle bug in the exec() builtin), this is
        #   not the case. Instead, a closure-style local must be simulated by
        #   passing the "func" parameter to this function at function
        #   definition time as the default value of an arbitrary parameter. To
        #   ensure this default is *NOT* overwritten by a function accepting a
        #   parameter of the same name, this edge case is tested for below.
        # * Assert statements type checking parameters passed to this callable.
        # * A call to this callable.
        # * An assert statement type checking the value returned by this
        #   callable.
        #
        # While there exist numerous alternatives (e.g., appending to a list or
        # bytearray before joining the elements of that iterable into a string),
        # these alternatives are either slower (as in the case of a list, due to
        # the high up-front cost of list construction) or substantially more
        # cumbersome (as in the case of a bytearray). Since string concatenation
        # is heavily optimized by the official CPython interpreter, the simplest
        # approach is (curiously) the most ideal.
        func_body = '''
@wraps(__beartype_func)
def func_beartyped(*args, __beartype_func=__beartype_func, **kwargs):
'''

        # "inspect.Signature" instance encapsulating this callable's signature.
        func_sig = inspect.signature(func)

        # Human-readable name of this function for use in exceptions.
        func_name = func.__name__ + '()'

        # For the name of each parameter passed to this callable and the
        # "inspect.Parameter" instance encapsulating this parameter (in the
        # passed order)...
        for func_arg_index, func_arg in enumerate(func_sig.parameters.values()):
            # If this callable redefines a parameter initialized to a default
            # value by this wrapper, raise an exception. Permitting this
            # unlikely edge case would permit unsuspecting users to
            # "accidentally" override these defaults.
            if func_arg.name == '__beartype_func':
                raise NameError(
                    'Parameter {} reserved for use by @beartype.'.format(
                        func_arg.name))

            # If this parameter is both annotated and non-ignorable for purposes
            # of type checking, type check this parameter.
            if (func_arg.annotation is not Parameter.empty and
                func_arg.kind not in _PARAMETER_KIND_IGNORED):
                # Validate this annotation.
                _check_type_annotation(
                    annotation=func_arg.annotation,
                    label='{} parameter {} type'.format(
                        func_name, func_arg.name))

                # String evaluating to this parameter's annotated type.
                func_arg_type_expr = (
                    '__beartype_func.__annotations__[{!r}]'.format(
                        func_arg.name))

                # String evaluating to this parameter's current value when
                # passed as a keyword.
                func_arg_value_key_expr = 'kwargs[{!r}]'.format(func_arg.name)

                # If this parameter is keyword-only, type check this parameter
                # only by lookup in the variadic "**kwargs" dictionary.
                if func_arg.kind is Parameter.KEYWORD_ONLY:
                    func_body += '''
    if {arg_name!r} in kwargs and not isinstance(
        {arg_value_key_expr}, {arg_type_expr}):
        raise TypeError(
            '{func_name} keyword-only parameter '
            '{arg_name}={{}} not a {{!r}}'.format(
                {arg_value_key_expr}, {arg_type_expr}))
'''.format(
                        func_name=func_name,
                        arg_name=func_arg.name,
                        arg_type_expr=func_arg_type_expr,
                        arg_value_key_expr=func_arg_value_key_expr,
                    )
                # Else, this parameter may be passed either positionally or as
                # a keyword. Type check this parameter both by lookup in the
                # variadic "**kwargs" dictionary *AND* by index into the
                # variadic "*args" tuple.
                else:
                    # String evaluating to this parameter's current value when
                    # passed positionally.
                    func_arg_value_pos_expr = 'args[{!r}]'.format(
                        func_arg_index)

                    func_body += '''
    if not (
        isinstance({arg_value_pos_expr}, {arg_type_expr})
        if {arg_index} &lt; len(args) else
        isinstance({arg_value_key_expr}, {arg_type_expr})
        if {arg_name!r} in kwargs else True):
            raise TypeError(
                '{func_name} parameter {arg_name}={{}} not of {{!r}}'.format(
                {arg_value_pos_expr} if {arg_index} &lt; len(args) else {arg_value_key_expr},
                {arg_type_expr}))
'''.format(
                    func_name=func_name,
                    arg_name=func_arg.name,
                    arg_index=func_arg_index,
                    arg_type_expr=func_arg_type_expr,
                    arg_value_key_expr=func_arg_value_key_expr,
                    arg_value_pos_expr=func_arg_value_pos_expr,
                )

        # If this callable's return value is both annotated and non-ignorable
        # for purposes of type checking, type check this value.
        if func_sig.return_annotation not in _RETURN_ANNOTATION_IGNORED:
            # Validate this annotation.
            _check_type_annotation(
                annotation=func_sig.return_annotation,
                label='{} return type'.format(func_name))

            # Strings evaluating to this parameter's annotated type and
            # currently passed value, as above.
            func_return_type_expr = (
                "__beartype_func.__annotations__['return']")

            # Call this callable, type check the returned value, and return this
            # value from this wrapper.
            func_body += '''
    return_value = __beartype_func(*args, **kwargs)
    if not isinstance(return_value, {return_type}):
        raise TypeError(
            '{func_name} return value {{}} not of {{!r}}'.format(
                return_value, {return_type}))
    return return_value
'''.format(func_name=func_name, return_type=func_return_type_expr)
        # Else, call this callable and return this value from this wrapper.
        else:
            func_body += '''
    return __beartype_func(*args, **kwargs)
'''

        # Dictionary mapping from local attribute name to value. For efficiency,
        # only those local attributes explicitly required in the body of this
        # wrapper are copied from the current namespace. (See below.)
        local_attrs = {'__beartype_func': func}

        # Dynamically define this wrapper as a closure of this decorator. For
        # obscure and presumably uninteresting reasons, Python fails to locally
        # declare this closure when the locals() dictionary is passed; to
        # capture this closure, a local dictionary must be passed instead.
        exec(func_body, globals(), local_attrs)

        # Return this wrapper.
        return local_attrs['func_beartyped']

    _PARAMETER_KIND_IGNORED = {
        Parameter.POSITIONAL_ONLY, Parameter.VAR_POSITIONAL, Parameter.VAR_KEYWORD,
    }
    '''
    Set of all `inspect.Parameter.kind` constants to be ignored during
    annotation- based type checking in the `@beartype` decorator.

    This includes:

    * Constants specific to variadic parameters (e.g., `*args`, `**kwargs`).
      Variadic parameters cannot be annotated and hence cannot be type checked.
    * Constants specific to positional-only parameters, which apply to non-pure-
      Python callables (e.g., defined by C extensions). The `@beartype`
      decorator applies _only_ to pure-Python callables, which provide no
      syntactic means of specifying positional-only parameters.
    '''

    _RETURN_ANNOTATION_IGNORED = {Signature.empty, None}
    '''
    Set of all annotations for return values to be ignored during annotation-
    based type checking in the `@beartype` decorator.

    This includes:

    * `Signature.empty`, signifying a callable whose return value is _not_
      annotated.
    * `None`, signifying a callable returning no value. By convention, callables
      returning no value are typically annotated to return `None`. Technically,
      callables whose return values are annotated as `None` _could_ be
      explicitly checked to return `None` rather than a none-`None` value. Since
      return values are safely ignorable by callers, however, there appears to
      be little real-world utility in enforcing this constraint.
    '''

    def _check_type_annotation(annotation: object, label: str) -&gt; None:
        '''
        Validate the passed annotation to be a valid type supported by the
        `@beartype` decorator.

        Parameters
        ----------
        annotation : object
            Annotation to be validated.
        label : str
            Human-readable label describing this annotation, interpolated into
            exceptions raised by this function.

        Raises
        ----------
        TypeError
            If this annotation is neither a new-style class nor a tuple of
            new-style classes.
        '''

        # If this annotation is a tuple, raise an exception if any member of
        # this tuple is not a new-style class. Note that the "__name__"
        # attribute tested below is not defined by old-style classes and hence
        # serves as a helpful means of identifying new-style classes.
        if isinstance(annotation, tuple):
            for member in annotation:
                if not (
                    isinstance(member, type) and hasattr(member, '__name__')):
                    raise TypeError(
                        '{} tuple member {} not a new-style class'.format(
                            label, member))
        # Else if this annotation is not a new-style class, raise an exception.
        elif not (
            isinstance(annotation, type) and hasattr(annotation, '__name__')):
            raise TypeError(
                '{} {} neither a new-style class nor '
                'tuple of such classes'.format(label, annotation))

# Else, the active Python interpreter is optimized. In this case, disable type
# checking by reducing this decorator to the identity decorator.
else:
    def beartype(func: callable) -&gt; callable:
        return func
</code></pre>
<p>And <a href="https://stackoverflow.com/users/2809027/cecil-curry">leycec</a> said, Let the  <code>@beartype</code> bring forth type checking fastly: and it was so.</p>
<h2>Caveats, Curses, and Empty Promises</h2>
<p>Nothing is perfect. <em>Even bear typing.</em></p>
<h3>Caveat I: Default Values Unchecked</h3>
<p>Bear typing does <em>not</em> type check unpassed parameters assigned default values. In theory, it could. But not in 275 lines or less and certainly not as a stackoverflow answer.</p>
<p>The safe (...<em>probably totally unsafe</em>) assumption is that function implementers claim they knew what they were doing when they defined default values. Since default values are typically constants (...<em>they'd better be!</em>), rechecking the types of constants that never change on each function call assigned one or more default values would contravene the fundamental tenet of bear typing: "Don't repeat yourself over and <em>oooover</em> and <em>oooo-oooover</em> again."</p>
<p>Show me wrong and I will shower you with upvotes.</p>
<h3>Caveat II: No PEP 484</h3>
<p><a href="https://www.python.org/dev/peps/pep-0484" rel="noreferrer">PEP 484</a> (<em>"Type Hints"</em>) formalized the use of function annotations first introduced by <a href="https://www.python.org/dev/peps/pep-3107/" rel="noreferrer">PEP 3107</a> (<em>"Function Annotations"</em>). Python 3.5 superficially supports this formalization with a new top-level <a href="https://docs.python.org/3/library/typing.html" rel="noreferrer"><code>typing</code> module</a>, a standard API for composing arbitrarily complex types from simpler types (e.g., <code>Callable[[Arg1Type, Arg2Type], ReturnType]</code>, a type describing a function accepting two arguments of type <code>Arg1Type</code> and <code>Arg2Type</code> and returning a value of type <code>ReturnType</code>).</p>
<p>Bear typing supports none of them. In theory, it could. But not in 275 lines or less and certainly not as a stackoverflow answer.</p>
<p>Bear typing does, however, support unions of types in the same way that the <code>isinstance()</code> builtin supports unions of types: <strong>as tuples.</strong> This superficially corresponds to the <code>typing.Union</code> type – with the obvious caveat that <code>typing.Union</code> supports arbitrarily complex types, while tuples accepted by <code>@beartype</code> support <em>only</em> simple classes. In my defense, 275 lines.</p>
<h2>Tests or It Didn't Happen</h2>
<p>Here's the <a href="https://gist.github.com/leycec/3d48cc60e7d5fe8860b077acb067dc54" rel="noreferrer">gist</a> of it. <sup>Get it, <em>gist</em>? I'll stop now.</sup></p>
<p>As with the <code>@beartype</code> decorator itself, these <a href="https://github.com/pytest-dev/pytest" rel="noreferrer"><code>py.test</code></a> tests may be seamlessly integrated into existing test suites without modification. Precious, isn't it?</p>
<p>Now the mandatory neckbeard rant nobody asked for.</p>
<h2>A History of API Violence</h2>
<p>Python 3.5 provides no actual support for using PEP 484 types. <em>wat?</em></p>
<p>It's true: no type checking, no type inference, no type nuthin'. Instead, developers are expected to routinely run their entire codebases through heavyweight third-party CPython interpreter wrappers implementing a facsimile of such support (e.g., <a href="https://github.com/JukkaL/mypy" rel="noreferrer">mypy</a>). Of course, these wrappers impose:</p>
<ul>
<li>A <strong>compatibility penalty.</strong> As the <a href="https://mypy.readthedocs.io/en/latest/faq.html#can-i-use-mypy-to-type-check-my-existing-python-code" rel="noreferrer">official mypy FAQ</a> admits in response to the frequently asked question "Can I use mypy to type check my existing Python code?": "<strong>It depends.</strong> Compatibility is pretty good, but some Python features are not yet implemented or fully supported." A <a href="https://mypy.readthedocs.io/en/latest/faq.html#how-are-mypy-programs-different-from-normal-python" rel="noreferrer">subsequent FAQ response</a> clarifies this incompatibility by stating that:

<ul>
<li>"...your code must make attributes explicit and use a explicit protocol representation." <sup><em>Grammar police see your "a explicit" and raise you an implicit frown.</em></sup></li>
<li>"Mypy will support modular, efficient type checking, and this seems to rule out type checking some language features, such as arbitrary runtime addition of methods. However, it is likely that many of these features will be supported in a restricted form (for example, runtime modification is only supported for classes or methods registered as dynamic or ‘patchable’)."</li>
<li>For a full list of syntactic incompatibilities, see <a href="https://mypy.readthedocs.io/en/latest/common_issues.html#common-issues" rel="noreferrer"><em>"Dealing with common issues"</em></a>.  It's <em>not</em> pretty. You just wanted type checking and now you refactored your entire codebase and broke everyone's build two days from the candidate release and the comely HR midget in casual business attire slips a pink slip through the crack in your cubicle-cum-mancave. Thanks alot, mypy.</li>
</ul></li>
<li>A <strong>performance penalty,</strong> despite interpreting statically typed code. Fourty years of hard-boiled computer science tells us that (...<em>all else being equal</em>) interpreting statically typed code should be faster, not slower, than interpreting dynamically typed code. In Python, up is the new down.</li>
<li>Additional non-trivial dependencies, increasing:

<ul>
<li>The bug-laden fragility of project deployment, especially cross-platform.</li>
<li>The maintenance burden of project development.</li>
<li>Possible attack surface.</li>
</ul></li>
</ul>
<p>I ask Guido: "Why? Why bother inventing an abstract API if you weren't willing to pony up a concrete API actually doing something with that abstraction?" Why leave the fate of a million Pythonistas to the arthritic hand of the free open-source marketplace? Why create yet another techno-problem that could have been trivially solved with a 275-line decorator in the official Python stdlib?</p>
<p>I have no Python and I must scream.</p>
</div>
<div class="post-text" itemprop="text">
<p>Type checking is generally not Pythonic. In Python, it is more usual to use <a href="http://en.wikipedia.org/wiki/Duck_typing" rel="noreferrer">duck typing</a>. Example:</p>
<p>In you code, assume that the argument (in your example <code>a</code>) walks like an <code>int</code> and quacks like an <code>int</code>. For instance:</p>
<pre><code>def my_function(a):
    return a + 7
</code></pre>
<p>This means that not only does your function work with integers, it also works with floats and any user defined class with the <code>__add__</code> method defined, so less (sometimes nothing) has to be done if you, or someone else, want to extend your function to work with something else. However, in some cases you might need an <code>int</code>, so then you could do something like this:</p>
<pre><code>def my_function(a):
    b = int(a) + 7
    c = (5, 6, 3, 123541)[b]
    return c
</code></pre>
<p>and the function still works for any <code>a</code> that defines the <code>__int__</code> method.</p>
<p>In answer to your other questions, I think it is best (as other answers have said to either do this:</p>
<pre><code>def my_function(a, b, c):
    assert 0 &lt; b &lt; 10
    assert c        # A non-empty string has the Boolean value True
</code></pre>
<p>or</p>
<pre><code>def my_function(a, b, c):
    if 0 &lt; b &lt; 10:
        # Do stuff with b
    else:
        raise ValueError
    if c:
        # Do stuff with c
    else:
        raise ValueError
</code></pre>
<p>Some type checking decorators I made:</p>
<pre><code>import inspect

def checkargs(function):
    def _f(*arguments):
        for index, argument in enumerate(inspect.getfullargspec(function)[0]):
            if not isinstance(arguments[index], function.__annotations__[argument]):
                raise TypeError("{} is not of type {}".format(arguments[index], function.__annotations__[argument]))
        return function(*arguments)
    _f.__doc__ = function.__doc__
    return _f

def coerceargs(function):
    def _f(*arguments):
        new_arguments = []
        for index, argument in enumerate(inspect.getfullargspec(function)[0]):
            new_arguments.append(function.__annotations__[argument](arguments[index]))
        return function(*new_arguments)
    _f.__doc__ = function.__doc__
    return _f

if __name__ == "__main__":
    @checkargs
    def f(x: int, y: int):
        """
        A doc string!
        """
        return x, y

    @coerceargs
    def g(a: int, b: int):
        """
        Another doc string!
        """
        return a + b

    print(f(1, 2))
    try:
        print(f(3, 4.0))
    except TypeError as e:
        print(e)

    print(g(1, 2))
    print(g(3, 4.0))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way is to use <code>assert</code>:</p>
<pre><code>def myFunction(a,b,c):
    "This is an example function I'd like to check arguments of"
    assert isinstance(a, int), 'a should be an int'
    # or if you want to allow whole number floats: assert int(a) == a
    assert b &gt; 0 and b &lt; 10, 'b should be betwen 0 and 10'
    assert isinstance(c, str) and c, 'c should be a non-empty string'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use Type Enforcement accept/returns decorators from
<a href="https://wiki.python.org/moin/PythonDecoratorLibrary" rel="noreferrer">PythonDecoratorLibrary</a>
It's very easy and readable:</p>
<pre><code>@accepts(int, int, float)
def myfunc(i1, i2, i3):
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are different ways to check what a variable is in Python. So, to list a few:</p>
<ul>
<li><p><code>isinstance(obj, type)</code> function takes your variable, <code>obj</code> and gives you <code>True</code> is it is the same type of the <code>type</code> you listed.</p></li>
<li><p><code>issubclass(obj, class)</code> function that takes in a variable <code>obj</code>, and gives you <code>True</code> if <code>obj</code> is a subclass of <code>class</code>. So for example <code>issubclass(Rabbit, Animal)</code> would give you a <code>True</code> value</p></li>
<li><p><code>hasattr</code> is another example, demonstrated by this function, <code>super_len</code>:</p></li>
</ul>
<hr/>
<pre><code>def super_len(o):
    if hasattr(o, '__len__'):
        return len(o)

    if hasattr(o, 'len'):
        return o.len

    if hasattr(o, 'fileno'):
        try:
            fileno = o.fileno()
        except io.UnsupportedOperation:
            pass
        else:
            return os.fstat(fileno).st_size

    if hasattr(o, 'getvalue'):
        # e.g. BytesIO, cStringIO.StringI
        return len(o.getvalue())
</code></pre>
<hr/>
<p><code>hasattr</code> leans more towards duck-typing, and something that is usually more <em>pythonic</em> but that term is up opinionated.</p>
<p>Just as a note, <code>assert</code> statements are usually used in testing, otherwise, just use <code>if/else</code> statements.</p>
</div>
<div class="post-text" itemprop="text">
<p>Normally, you do something like this:</p>
<pre><code>def myFunction(a,b,c):
   if not isinstance(a, int):
      raise TypeError("Expected int, got %s" % (type(a),))
   if b &lt;= 0 or b &gt;= 10:
      raise ValueError("Value %d out of range" % (b,))
   if not c:
      raise ValueError("String was empty")

   # Rest of function
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I did quite a bit of investigation on that topic recently since I was not satisfied with the many <a href="https://smarie.github.io/python-valid8/other_libs/" rel="nofollow noreferrer">libraries</a> I found out there.</p>
<p>I ended up developing a library to address this, it is named <a href="https://smarie.github.io/python-valid8/" rel="nofollow noreferrer">valid8</a>. As explained in the documentation, it is for value validation mostly (although it comes bundled with simple type validation functions too), and you might wish to associate it with a PEP484-based type checker such as <a href="https://github.com/RussBaz/enforce" rel="nofollow noreferrer">enforce</a> or <a href="https://github.com/Stewori/pytypes" rel="nofollow noreferrer">pytypes</a>.</p>
<p>This is how you would perform validation with <code>valid8</code> alone (and <a href="https://smarie.github.io/python-mini-lambda/" rel="nofollow noreferrer"><code>mini_lambda</code></a> actually, to define the validation logic - but it is not mandatory) in your case:</p>
<pre><code># for type validation
from numbers import Integral
from valid8 import instance_of

# for value validation
from valid8 import validate_arg
from mini_lambda import x, s, Len

@validate_arg('a', instance_of(Integral))
@validate_arg('b', (0 &lt; x) &amp; (x &lt; 10))
@validate_arg('c', instance_of(str), Len(s) &gt; 0)
def my_function(a: Integral, b, c: str):
    """an example function I'd like to check the arguments of."""
    # check that a is an int
    # check that 0 &lt; b &lt; 10
    # check that c is not an empty string

# check that it works
my_function(0.2, 1, 'r')  # InputValidationError for 'a' HasWrongType: Value should be an instance of &lt;class 'numbers.Integral'&gt;. Wrong value: [0.2].
my_function(0, 0, 'r')    # InputValidationError for 'b' [(x &gt; 0) &amp; (x &lt; 10)] returned [False]
my_function(0, 1, 0)      # InputValidationError for 'c' Successes: [] / Failures: {"instance_of_&lt;class 'str'&gt;": "HasWrongType: Value should be an instance of &lt;class 'str'&gt;. Wrong value: [0]", 'len(s) &gt; 0': "TypeError: object of type 'int' has no len()"}.
my_function(0, 1, '')     # InputValidationError for 'c' Successes: ["instance_of_&lt;class 'str'&gt;"] / Failures: {'len(s) &gt; 0': 'False'}
</code></pre>
<p>And this is the same example leveraging PEP484 type hints and delegating type checking to <code>enforce</code>:</p>
<pre><code># for type validation
from numbers import Integral
from enforce import runtime_validation, config
config(dict(mode='covariant'))  # type validation will accept subclasses too

# for value validation
from valid8 import validate_arg
from mini_lambda import x, s, Len

@runtime_validation
@validate_arg('b', (0 &lt; x) &amp; (x &lt; 10))
@validate_arg('c', Len(s) &gt; 0)
def my_function(a: Integral, b, c: str):
    """an example function I'd like to check the arguments of."""
    # check that a is an int
    # check that 0 &lt; b &lt; 10
    # check that c is not an empty string

# check that it works
my_function(0.2, 1, 'r')  # RuntimeTypeError 'a' was not of type &lt;class 'numbers.Integral'&gt;
my_function(0, 0, 'r')    # InputValidationError for 'b' [(x &gt; 0) &amp; (x &lt; 10)] returned [False]
my_function(0, 1, 0)      # RuntimeTypeError 'c' was not of type &lt;class 'str'&gt;
my_function(0, 1, '')     # InputValidationError for 'c' [len(s) &gt; 0] returned [False].
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This checks the type of input arguments upon calling the function:</p>
<pre><code>def func(inp1:int=0,inp2:str="*"):

    for item in func.__annotations__.keys():
        assert isinstance(locals()[item],func.__annotations__[item])

    return (something)

first=7
second="$"
print(func(first,second))
</code></pre>
<p>Also check with <code>second=9</code> (it must give assertion error)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to check <code>**kwargs</code>, <code>*args</code> as well as normal arguments in one go, you can use the <code>locals()</code> function as the first statement in your function definition to get a dictionary of the arguments.</p>
<p>Then use <code>type()</code> to examine the arguments, for example whilst iterating over the dict.</p>
<pre><code>def myfunc(my, args, to, this, function, **kwargs):
    d = locals()
    assert(type(d.get('x')) == str)
    for x in d:
        if x != 'x':
            assert(type(d[x]) == x
    for x in ['a','b','c']:
        assert(x in d)

    whatever more...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def someFunc(a, b, c):
    params = locals()
    for _item in params:
        print type(params[_item]), _item, params[_item]
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt; someFunc(1, 'asd', 1.0)
&gt;&gt; &lt;type 'int'&gt; a 1
&gt;&gt; &lt;type 'float'&gt; c 1.0
&gt;&gt; &lt;type 'str'&gt; b asd
</code></pre>
<p>more about <a href="http://docs.python.org/2/library/functions.html#locals" rel="nofollow">locals()</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to do the validation for several functions you can add the logic inside a decorator like this:</p>
<pre><code>def deco(func):
     def wrapper(a,b,c):
         if not isinstance(a, int)\
            or not isinstance(b, int)\
            or not isinstance(c, str):
             raise TypeError
         if not 0 &lt; b &lt; 10:
             raise ValueError
         if c == '':
             raise ValueError
         return func(a,b,c)
     return wrapper
</code></pre>
<p>and use it:</p>
<pre><code>@deco
def foo(a,b,c):
    print 'ok!'
</code></pre>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>This is not the solution to you, but if you want to restrict the function calls to some specific parameter types then you must use the PROATOR { The Python Function prototype validator }. you can refer the following link. <a href="https://github.com/mohit-thakur-721/proator" rel="nofollow noreferrer">https://github.com/mohit-thakur-721/proator</a> </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def myFunction(a,b,c):
"This is an example function I'd like to check arguments of"
    if type( a ) == int:
       #dostuff
    if 0 &lt; b &lt; 10:
       #dostuff
    if type( C ) == str and c != "":
       #dostuff
</code></pre>
</div>
<span class="comment-copy">@carmellose: using <code>locals()</code> will probably end up being useless complication - in fact I fail to see a usecase for it, since you already know your named params names (obviously &lt;g&gt;) and can directly access <code>args</code> and <code>kwargs</code> if your function use them. Also, assertion are for debugging mostly. If your function's contract is that arg 'a' MUST be an int between 0 and 10 and argument 'b' MUST be a non-empty string, then raise the appropriate exception types, ie <code>TypeError</code> or <code>ValueError</code> - try <code>int('a')</code> and <code>int(None)</code> in your Python shell.</span>
<span class="comment-copy">As far as I'm concerned I only use assertion for "this cannot possibly happen" cases (which as we all know finally happen one day or another). Note that "optimized" bytecode (.pyo files) skip the assertions so you better not rely on AssertionError for production code &lt;g&gt;.</span>
<span class="comment-copy">It might not be Pythonic but I would encourage enforcing interfaces between modules, especially if you're distributing them. This makes both development and usage so much easier and is true in all languages</span>
<span class="comment-copy">I abhor authoritarian non-answers that reduce to: "Stop trying to do what you want to do, because I know better." This is yet another in a lamentably long line of such answers. There exist numerous valid reasons to check types, several of which this non-answer even alludes to. Under Python 3.x, the optimal (and frankly obvious) answer is <b>decorators plus function annotations.</b> See also <a href="https://stackoverflow.com/users/2387370/sweeneyrod">sweeneyrod</a>'s brilliant <a href="https://stackoverflow.com/a/19684962/2809027"><code>@checkargs</code> decorator</a> below. <i><b>tl;dr</b> Less fundamentalism; more actual answers.</i></span>
<span class="comment-copy">This shouldn't be the accepted answer. One more very important place where the types need to line up are external APIs. Sometimes it's impossible to propagate an error out of such an API, especially a native one, and they just must be called with precise types of arguments. In this case duck typing actively works against you.</span>
<span class="comment-copy">If you are keen on maintaining this style, I wonder if you would consider <a href="https://meta.stackoverflow.com/">asking a Meta question</a> to check with the community? It is rather unusual compared to most other answer posts.</span>
<span class="comment-copy">Keep the meta in meta, please.</span>
<span class="comment-copy">I'd hoped for a semblance of substantive commentary. I'm greeted instead by disciplinary normalization. For the no-holds-barred language principally inspired by the published scripts of “Monty Python's Flying Circus”, the grimy window of acceptable behaviour amongst Pythonistas is surprisingly... <i>narrow.</i> Needless to say, I disagree in the whole: we need substantially <i>more</i> stream-of-consciousness, memes, in-jokes, enlightened gnosis, and noetic poetry. <b>More polysyllabic novelty. Less monosyllabic normalcy.</b></span>
<span class="comment-copy">In particular, I'd hoped for pragmatic suggestions on improving the dynamic definition of the inner function returned by the <code>@beartype</code> decorator. The <code>__beartype_func</code> function parameter is especially kludgy. Without defining a low-level <code>CodeType</code> object (<i>not happening</i>), there appears to be no other means of mimicing closure scope in a dynamically defined function. The <code>compile()</code> builtin and <code>types.FunctionType</code> class are both surprisingly unhelpful here. Since the decorator works perfectly as is, there's not much incentive to improve this kludginess.</span>
<span class="comment-copy">this is an extremely useful decorator - it might be worth hosting on github so we can stay up to date on later enhancements</span>
<span class="comment-copy">@kevinarpe Thanks very much! (Although I'd consider this kind of thing a bit ugly, although I do like the way that this uses function annotations, which I think is much more readable than alternatives.)</span>
<span class="comment-copy">checkargs and coerceargs won't work for functions where not all parameters have default type specified, example: g(a: int, b)</span>
<span class="comment-copy">I don't expect a callable to raise an AssertionError when I don't respect it's contract, and this is not what you'll find in the standard lib.  Try int('a') and int(None) in your Python shell... Yes, <code>ValueError</code> and <code>TypeError</code>.</span>
<span class="comment-copy">thanks, I find assertions convenient. People use Python for different reasons. Some use to write production code, others just use it to prototype. This is a quick way to put constraints on your functions input. If I were writing a function for the standard library, I'd probably be more explicit.</span>
<span class="comment-copy">Assertions should be thought of as a simple option that is often far better than nothing - that causes early failures and can help document code.  I think they have an excellent place in our code.</span>
<span class="comment-copy">+1 for better than nothing, but avoid using them for external input validation, use them for intra-code checks.</span>
<span class="comment-copy">Take care of using <code>assert</code> in production code. It may be ignored depending of which environment your code is being executed. Take a look at this answer: <a href="https://stackoverflow.com/a/1838411/345290">stackoverflow.com/a/1838411/345290</a></span>
<span class="comment-copy">Under Python 3.x, function annotations (e.g., <code>def myfunc(i1: int, i2: int, i3: float)</code>) are a <i>profoundly</i> more Pythonic means of declaring types. See <a href="https://stackoverflow.com/users/2387370/sweeneyrod">sweeneyrod</a>'s <a href="https://stackoverflow.com/a/19684962/2809027"><code>@checkargs</code> decorator</a> for a robust type checking solution with function annotations in less than 10 (!) lines of code.</span>
<span class="comment-copy">The expected exceptions are respectively TypeError and ValueError.</span>
<span class="comment-copy">Right; but the ones used in the answer can be subclassed from these you mentionned.</span>
<span class="comment-copy">Correct, but it was just examples. I'll update the example.</span>
<span class="comment-copy">@MatsKindahl: an error message might be helpful too, ie : <code>raise TypeError("Expected an int, got '%s'" % type(a))</code></span>
<span class="comment-copy">This will only work with Python &gt;= 3</span>
<span class="comment-copy">If you <i>really</i> insist on typechecking, please at least use <code>isinstance</code>, and raise TypeError.</span>
<span class="comment-copy">@brunodesthuilliers thanks for the heads up! I'll edit my answer.</span>
<span class="comment-copy">why not <code>return func(a, b, c)</code>?</span>
<span class="comment-copy">@PauloBu: what glglgl meant was that your rapper should not just call the decorated func, it should return the result of the function call too.</span>
<span class="comment-copy">I am probably going to get in trouble for saying this here but you can also consider using another language if you really need a lot of type checking</span>
