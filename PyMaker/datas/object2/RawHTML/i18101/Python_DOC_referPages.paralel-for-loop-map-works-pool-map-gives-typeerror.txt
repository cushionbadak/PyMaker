<div class="post-text" itemprop="text">
<p>I am making a condensed (only upper right) distance matrix. The calculation of the distance takes some time, so I want to paralelise the for loop. The unparelalised loop looks like</p>
<pre><code>spectra_names, condensed_distance_matrix, index_0 = [], [], 0 
for index_1, index_2 in itertools.combinations(range(len(clusters)), 2):
    if index_0 == index_1:
        index_0 += 1
        spectra_names.append(clusters[index_1].get_names()[0])
    try:
        distance = 1/float(compare_clusters(clusters[index_1], clusters[index_2],maxiter=50))
    except:
        distance = 10
    condensed_distance_matrix.append(distance)
</code></pre>
<p>where clusters is a list of objects to compare, <code>compare_clusters()</code> is a likelihood function and <code>1/compare_clusters()</code> is the distance between two objects.</p>
<p>I tried to paralelise it by moving the distance function out of the loop like so</p>
<pre><code>from multiprocessing import Pool
condensed_distance_matrix = []
spectra_names = []
index_0 = 0
clusters_1 = []
clusters_2 = []
for index_1, index_2 in itertools.combinations(range(len(clusters)), 2):
    if index_0 == index_1:
        index_0 += 1
        spectra_names.append(clusters[index_1].get_names()[0])
    clusters_1.append(clusters[index_1])
    clusters_2.append(clusters[index_2])
pool = Pool()
condensed_distance_matrix_values = pool.map(compare_clusters, clusters_1, clusters_2)

for value in condensed_distance_matrix_values :
    try:
        distance = 1/float(value)
    except:
        distance = 10
    condensed_distance_matrix.append(distance)
</code></pre>
<p>Before paralelising I tried the same code, but with <code>map()</code> instead of <code>pool.map()</code>. This worked as I wanted. However, when using <code>pool.map()</code> I get the error </p>
<pre><code>  File "C:\Python27\lib\multiprocessing\pool.py", line 225, in map
    return self.map_async(func, iterable, chunksize).get()
  File "C:\Python27\lib\multiprocessing\pool.py", line 288, in map_async
    result = MapResult(self._cache, chunksize, len(iterable), callback)
  File "C:\Python27\lib\multiprocessing\pool.py", line 551, in __init__
    self._number_left = length//chunksize + bool(length % chunksize)
TypeError: unsupported operand type(s) for //: 'int' and 'list'
</code></pre>
<p>What am I missing here?</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="http://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map" rel="nofollow"><code>Pool.map</code>'s documentation</a>:</p>
<blockquote>
<p>A parallel equivalent of the map() built-in function (<strong>it supports only one iterable argument though</strong>). It blocks until the result is ready.</p>
</blockquote>
<p>For ordinary <code>map</code>, you can supply multiple iterables. For example,</p>
<pre><code>&gt;&gt;&gt; map(lambda x,y: x+y, "ABC", "DEF")
['AD', 'BE', 'CF']
</code></pre>
<p>But you can't do this with <code>Pool.map</code>. The third argument is interpreted as <code>chunksize</code>. You are giving it a list when it expects an int.</p>
<p>Perhaps you could pass in only a single iterable, by combining your lists:</p>
<pre><code>pool.map(lambda (a,b): compare_clusters(a,b), zip(clusters_1, clusters_2))
</code></pre>
<p>I haven't tested it with <code>pool.map</code>, but this strategy works for ordinary <code>map</code>.</p>
<pre><code>&gt;&gt;&gt; map(lambda (a,b): a+b, zip("ABC", "DEF"))
['AD', 'BE', 'CF']
</code></pre>
</div>
<span class="comment-copy">Ah I missed that. Any idea how this can be paralelised?</span>
<span class="comment-copy">I've got an idea, although I haven't tested it. Edited.</span>
<span class="comment-copy">The edit does not work: PicklingError: Can't pickle &lt;type 'function'&gt;: attribute lookup <b>builtin</b>.function failed. But I think I will ask a new question about this, since this question is answered.</span>
