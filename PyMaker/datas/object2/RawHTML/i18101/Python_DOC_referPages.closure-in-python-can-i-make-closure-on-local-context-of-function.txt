<div class="post-text" itemprop="text">
<p>In javascript I can write function with closure like this</p>
<pre><code>function getUniqueIDfunction() { 
    var id = 0;                          
    return function() { return id++; }; 
};
</code></pre>
<p>And then use it</p>
<pre><code>uniqueID = getUniqueIDfunction();
uniqueID(); //return 0
uniqueID(); //return 1
...
</code></pre>
<p>Can I perform the same in Python (if it depends with different version let me know) ?</p>
<pre><code>def getUniqueIDfunction():
    x = -1
    def foo():
        #And I know that it doesn't work with row bellow and without it    
        #global x  
        x += 1
        return x
    return foo
</code></pre>
<p>It's just a sample. I want know about closure in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 introduced this kind of scoping behavior with <a href="http://www.python.org/dev/peps/pep-3104/" rel="noreferrer">PEP 3104</a> and the <code>nonlocal</code> statement:</p>
<pre><code>&gt;&gt;&gt; def uniqueId ():
        x = -1
        def inner ():
            nonlocal x
            x += 1
            return x
        return inner

&gt;&gt;&gt; f = uniqueId()
&gt;&gt;&gt; f()
0
&gt;&gt;&gt; f()
1
&gt;&gt;&gt; f()
2
</code></pre>
<p>Other than that, in previous versions, closures do exist, but you have only a read-only access. So changing <code>x</code> will not work. What you can do however is use a mutable object, like a list, and change that one:</p>
<pre><code>&gt;&gt;&gt; def uniqueId ():
        x = [-1]
        def inner ():
            x[0] += 1
            return x[0]
        return inner

&gt;&gt;&gt; f = uniqueId()
&gt;&gt;&gt; f()
0
&gt;&gt;&gt; f()
1
</code></pre>
<p>As you can make any kind of object callable, you can also do something more fancy by defining your own type that has a <code>__call__</code> method:</p>
<pre><code>&gt;&gt;&gt; class UniqueId:
        def __init__ (self):
            self.x = -1
        def __call__ (self):
            self.x += 1
            return self.x

&gt;&gt;&gt; f = UniqueId()
&gt;&gt;&gt; f()
0
&gt;&gt;&gt; f()
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If all you want is a unique ID, just use the following:</p>
<pre><code>def uniqueID():
    x = 0
    while True:
        yield x  
        x += 1

id = next(uniqueID)
</code></pre>
<p>You can rewrite this with a closure (as <a href="https://stackoverflow.com/a/19799468/558592">poke mentions in his answer</a>), if you wish to:</p>
<pre><code>def getUniqueIDfunction():
    x = -1
    def uniqueID():
        nonlocal x
        x += 1
        return x
    return uniqueID

uniqueID = getUniqueIDfunction()
id = uniqueID()
</code></pre>
<p>This has the caveat that it only works in Python 3+. For Python 2, you can simulate this behavior by attaching the value <code>x</code> to a class.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works, but doesn't do exactly what you want:</p>
<pre><code>def getUniqueIDfunction():
    x = -1
    def foo(x=x):
        x += 1
        return x
    return foo
f() # returns 0
f() # returns 0 again!
</code></pre>
<p>Because the integer datatype is immutable. If instead you use a mutable datatype:</p>
<pre><code>def counter():
    x = [0]
    def enc():
        x[0] = x[0] + 1
        return x[0]
    return enc
f = counter()
f() # returns 1
f() # returns 2
f() # returns 3
</code></pre>
<p>Another more complicated example from my own usage:</p>
<pre><code>def enumerate_dupes_in_column():
    '''
    provides a dict for counting in the namespace and a function for the
    operation, thus avoiding global variable naming
    '''
    countdict = {}
    def countfunction(arg):
        countdict[arg] = countdict.get(arg, 0) + 1
        if countdict[arg] == 1: 
            return arg
        else: 
            return arg + ', ' + str(countdict[arg])
    return countfunction

f = enumerate_dupes_in_column()
f('foo') # returns foo
f('bar') # returns bar
f('foo') # returns foo, 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to explicitly specify that something is a closure variable, not a local or global, you use the <a href="http://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement" rel="nofollow"><code>nonlocal</code></a> statement. So:</p>
<pre><code>def foo():
    nonlocal x  
    x += 1
    return x
</code></pre>
<p>In Python 2.x, there is no <code>nonlocal</code> statement. Your best bet is to upgrade to a modern version of the language. If you can't do that, there are ways to fake it, which are explained in the FAQ, and in <a href="http://www.python.org/dev/peps/pep-3104/" rel="nofollow">PEP 3104</a> (which introduced <code>nonlocal</code>).</p>
</div>
<span class="comment-copy">For 2.x I like <code>class nonlocal: x=0</code> in the outer function and then do <code>nonlocal.x += 1</code> in the inner function.</span>
