<div class="post-text" itemprop="text">
<p>I have several strings stored in a file one per line like this:</p>
<pre><code>dsfsdfsd/mhgjghj
cvcv/xcvxc
werwr/erewrwer
nbmbn/iuouiouio
...
</code></pre>
<p>As you can see the only character that is always present is the backlash <code>/</code>, the rest being pretty random in its composition. I need to store the first and second part (ie: before and after the backlash respectively) of each line separately, so as to end up with something like this:</p>
<pre><code>first_list = [dsfsdfsd, cvcv, werwr, nbmbn, ...]
secnd_list = [mhgjghj, xcvxc, erewrwer, iuouiouio, ...]
</code></pre>
<p>I could do this in python iterating through each line, checking for the existence of the backlash and storing the contents of each part of the line separately. It would look like this:</p>
<pre><code>first_list, secnd_list = [], []
for line in file:
    for indx, char in enumerate(line):
        if char == '/':
            first_list.append(line[:(indx-1)])
            secnd_list.append(line[(indx-1):])
            break
</code></pre>
<p>I'm looking for a prettier (more pythonic) version of this code.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>split()</code> might come in handy here:</p>
<pre><code>first_list, secnd_list = [], []
for line in file:
    first, second = line.split('/')
    first_list.append(first)
    secnd_list.append(second)
</code></pre>
<p>One of the assumptions made here is that only a single <code>/</code> is present. Knowning that, <code>split('/')</code> will always return a 2-tuple of elements. If this assumption is false, try <code>split('/', 1)</code> instead - it limits the number of splits to 1, counting left-to-right.</p>
</div>
<div class="post-text" itemprop="text">
<p>As well as <code>str.split</code> you could use <code>str.partition</code>:</p>
<pre><code>first_parts = []
second_parts = []
for line in file:
    before, _, after = line.partition('/')
    first_parts.append(before)
    second_parts.append(after)
</code></pre>
<p>An alternative more functional oneliner:</p>
<pre><code>first_parts, _, second_parts = zip(*(line.partition('/') for line in file))
</code></pre>
<p>Explanation for the <code>_</code> in both options - <code>str.partition</code> returns a tuple: <code>(first_part, seperator, last_part)</code>. Here, we don't need the seperator (indeed I can't imagine why you ever would), so we assign it to the throwaway variable <code>_</code>.</p>
<p><a href="http://docs.python.org/3/library/stdtypes.html#str.partition" rel="nofollow">Here</a> are the docs for <code>str.partition</code>, and <a href="http://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow">here</a> are the docs for <code>str.split</code>.</p>
</div>
<span class="comment-copy"><code>someString</code>.split('/')`? Have you tried this?</span>
<span class="comment-copy">@AleksanderLidtke nope, never used that one before as far as I can remember.</span>
<span class="comment-copy">The backslash is <code>`. The </code>/` is <i>slash</i>. It's very important to keep these straight, or you will have serious problems later on.</span>
<span class="comment-copy">The best way to distinguish between a <i>forward slash</i> and a <i>backslash</i>: raise your finger in front of your face <code>o    |</code> (<code>o</code> is your head, <code>|</code> your finger). If you bend your finger <i>forwards</i>, you'll get a <i>forward slash</i> - <code>o     /</code>. If you bend your finger <i>backwards</i>, you'll get a <i>backslash</i> - <code>o    \ </code>.</span>
<span class="comment-copy">Simple as that :)</span>
<span class="comment-copy">A side note, <code>*(line.partition('/') for line in file)</code> will create whole list before passing it to <code>zip</code>.</span>
<span class="comment-copy">it's not about time performance, but memory one - try opening a fresh interpreter session and running <code>func(*xrange(1000000000))</code>. <code>func</code> is a simple <code>def func(*args): pass</code>. On my machine, I've got <code>MemoryError</code>.</span>
<span class="comment-copy">@kroolik I stand corrected!</span>
