<div class="post-text" itemprop="text">
<p>I've been bugging on this issue for some time now. I have two models : Acquisitions and RawDatas.</p>
<p>Each RawData have one Acquisition, but many RawDatas can have the same Acquisition.</p>
<p>I want to create or get the instance of Acquisition automatically when I create my RawDatas. And I want to be able to have all informations using the serializer.</p>
<pre><code>class Acquisitions(models.Model):
    class Meta:
        unique_together = (('implant', 'beg_acq', 'duration_acq'),)

    id = models.AutoField(primary_key=True)
    implant = models.ForeignKey("Patients", on_delete=models.CASCADE)
    beg_acq = models.DateTimeField("Beggining date of the acquisition")
    duration_acq = models.DurationField("Duration of the acquisition")

class RawDatas(models.Model):
    class Meta:
    unique_together = (('acq', 'data_type'),)

    id = models.AutoField(primary_key=True)
    acq = models.ForeignKey("Acquisitions", on_delete=models.CASCADE)
    data_type = models.CharField(max_length=3)
    sampling_freq = models.PositiveIntegerField("Sampling frequency")
    bin_file = models.FileField(db_index=True, upload_to='media')
</code></pre>
<p>And my serializers are these :</p>
<pre><code>class AcquisitionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Acquisitions
        fields = ('id', 'implant', 'beg_acq', 'duration_acq')

class RawDatasSerializer(serializers.ModelSerializer):
    acq = AcquisitionSerializer()

    class Meta:
        model = RawDatas
        fields = ('id', 'data_type', 'sampling_freq', 'bin_file', 'acq')

    def create(self, validated_data):
        acq_data = validated_data.pop('acq')
        acq = Acquisitions.objects.get_or_create(**acq_data)
        RawDatas.objects.create(acq=acq[0], **validated_data)
        return rawdatas
</code></pre>
<p>My problem is that, using this, if my instance of Acquisitions already exists, I get a non_field_errors or another constraint validation error.</p>
<p>I would like to know what is the correct way to handle this please ? </p>
<p>So I can automatically create this using the nested serializer, and when I only want to have informations (such as a GET request), I can have all the field I need (every field of the two models).</p>
<p>Thanks in advance for your help !</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>class AcquisitionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Acquisitions
        fields = ('id', 'implant', 'beg_acq', 'duration_acq')

class RawDatasSerializer(serializers.ModelSerializer):
    class Meta:
        model = RawDatas
        fields = ('id', 'data_type', 'sampling_freq', 'bin_file', 'acq')

    def create(self, validated_data):
        acq_data = validated_data.pop('acq')
        acq = Acquisitions.objects.filter(id=acq_data.get('id')).first()

        if not acq:
            acq = AcquisitionSerializer.create(AcquisitionSerializer(), **acq_data)

        rawdata = RawDatas.objects.create(acq=acq, **validated_data)

        return rawdata
</code></pre>
</div>
<span class="comment-copy">Nice, it works, thanks, but because there is no more the AcquisitionSerializer, when I try to get the information, I just get the acq number, and not all the informations of the acquisition like before, what function should I erase to get those informations ?</span>
<span class="comment-copy">Just add this to your <code>RawDataSerializer</code>: <code>acq = AcquisitionSerializer()</code> just before the <code>class Meta</code>. It should do the trick.</span>
<span class="comment-copy">Yes, it works for get request but I got this : {'acq': {'non_field_errors': [ErrorDetail(string='The fields implant, beg_acq, duration_acq must make a unique set.', code='unique')]}} when trying to add new data with an existing acquisition.</span>
<span class="comment-copy">That is related to your models design. You are creating <code>unique_together</code> constraints that maybe you don't need.</span>
<span class="comment-copy">Yes, I need this constraint to ensure that I can't have two acquisitions with same duration/implant/beginning.</span>
