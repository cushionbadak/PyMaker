<div class="post-text" itemprop="text">
<p>Say you have a specific dict you want to assert against, but you want to have a couple of <strong>specific</strong> values you allow in a given property of that dict, how can you do that?</p>
<pre><code># This is in a separate shared constants file, used by a whole lot of tests
expected_geoip = {
    "country": "Finland",
    # "city" should allow for either "Helsinki" or "Espoo", but nothing else
    "city": ""
}

# class, etc... not relevant

def test_something(self):
    result = something.query("something")
    geoip = result[0]["data"]["geoip"]
    # geoip["city"] can be either "Helsinki" or "Espoo", at random(!) (true story...)
    self.assertEquals(expected_geoip, geoip)
</code></pre>
<p>Obviously I could simply explicitly check something like:<br/>
<code>self.assertTrue(geoip["city"] in ["Helsinki", "Espoo"]</code></p>
<p>But the problem is, I would have to update a huge amount of old tests. It would be much easier with something like:</p>
<pre><code>expected_geoip = {
    "country": "Finland",
    "city": mock.list("Helsinki", "Espoo")
}
</code></pre>
<p>But as far as I can tell from the mock docs at <a href="http://www.voidspace.org.uk/python/mock/helpers.html#any" rel="nofollow noreferrer">http://www.voidspace.org.uk/python/mock/helpers.html#any</a>, there is only a <code>mock.ANY</code>, which is too broad.</p>
<p>It would be optimal if I could add some modification directly to the shared <code>expected_geoip</code> dict, since all tests refer to it in the same manner.</p>
<p>The backstory for this is that our office keeps changing the physical location between two neighbouring cities - at least according to the Maxmind GeoIP response :)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make <code>expected_geoip</code> an instance of a custom class with a suitable <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer"><code>__eq__</code> method</a>. The <code>__eq__</code> method is called whenever an object is compared to another object with <code>==</code>.</p>
<pre><code>class ExpectedGeoIP:
    def __eq__(self, other):
        if not isinstance(other, dict):
            return False

        if other["country"] != "Finland":
            return False

        return other['city'] in {"Helsinki", "Espoo"}

expected_geoip = ExpectedGeoIP()
</code></pre>
<p>Now <code>assertEquals(expected_geoip, geoip)</code> will work the way you want and you don't have to make any changes to existing unit tests.</p>
</div>
<span class="comment-copy">Why not create a class and use a setter? You could set the dict to a private attribute of the class and return it via a getter.</span>
