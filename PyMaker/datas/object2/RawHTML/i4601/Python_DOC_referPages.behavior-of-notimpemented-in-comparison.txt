<div class="post-text" itemprop="text">
<p>I recently found out that python has a special value <a href="https://docs.python.org/3/library/constants.html#NotImplemented" rel="nofollow noreferrer">NotImpemented</a> to be used with respect to binary special methods to indicate that some operation has not been implemented.</p>
<p>The peculiar about this is that when checked in a binary situation it is always equivalent to <code>True</code>.</p>
<p>For example using <code>io.BytesIO</code> (which is a case where <code>__eq__</code> in not implemented for example) for two objects in comparison will virtually return <code>True</code>. As in this <a href="https://stackoverflow.com/q/49533095/3584765">example</a> (<code>encoded_jpg_io1</code> and <code>encoded_jpg_io2</code> are objects of the <code>io.BytesIO</code> class):</p>
<pre><code>if encoded_jpg_io1.__ne__(encoded_jpg_io2):
    print('Equal')
else:
    print('Unequal')
</code></pre>
<blockquote>
<p>Equal</p>
</blockquote>
<pre><code>if encoded_jpg_io1.__eq__(encoded_jpg_io2) == True:
    print('Equal')
else:
    print('Unequal')
</code></pre>
<blockquote>
<p>Unequal</p>
</blockquote>
<p>Since the second style is a bit too verbose and normally not prefered (even my pyCharm suggests to remove the explicit comparison with <code>True</code>) isn't a bit tricky behavior? I wouldn't have noticed it if I haven't explicitly print the result of the Boolean operation (which is not Boolean in this case at all).</p>
<p>I guess suggesting to be considered <code>False</code> would cause the same problem with <code>__ne__</code> so we arew back to step one.</p>
<p>So, the only way to check out for these cases is by doing an  exact comparison with <code>True</code> or <code>False</code> in the opposite case.</p>
<p>I know that <code>NotImpemented</code> is preferred over <code>NotImplementedError</code> for various <a href="https://stackoverflow.com/questions/878943/why-return-notimplemented-instead-of-raising-notimplementederror">reasons</a> so I am not asking for any explanation over why this matter.</p>
</div>
<div class="post-text" itemprop="text">
<p>Per convention, objects that do not define a <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="nofollow noreferrer"><code>__bool__</code> method</a> are considered truthy. From <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>By default, an object is considered true unless its class defines either a <code>__bool__()</code> method that returns <code>False</code> or a <code>__len__()</code> method that returns zero</p>
</blockquote>
<p>This means that most classes, functions, and other builtin singletons are considered true, since they don't go out of their way to specify different behavior. (An exception is <code>None</code>, which is one of the few built-in singletons that <em>does</em> specifically signal it should be considered false):</p>
<pre><code>&gt;&gt;&gt; bool(int)  # the class, not an integer object
True
&gt;&gt;&gt; bool(min)
True
&gt;&gt;&gt; bool(object())
True
&gt;&gt;&gt; bool(...)  # that's the Ellipsis object
True
&gt;&gt;&gt; bool(NotImplemented)
True
</code></pre>
<p>There is no real reason for the <code>NotImplemented</code> object to break this convention. The problem with your code isn't that <code>NotImplemented</code> is considered truthy; the real problem is that <code>x.__eq__(y)</code> is not equivalent to <code>x == y</code>.</p>
<p><strong>If you want to compare two objects for equality, doing it with <code>x.__eq__(y)</code> is incorrect. Using <code>x.__eq__(y) == True</code> instead is still incorrect.</strong></p>
<p>The correct solution is to do comparison with the <code>==</code> operator. If, for whatever reason, you can't use the <code>==</code> operator directly, you should use the <a href="https://docs.python.org/3/library/operator.html#operator.eq" rel="nofollow noreferrer"><code>operator.eq</code></a> function instead.</p>
</div>
<span class="comment-copy"><code>NotImplemented</code> is designed to give the correct results when you use <code>a==b</code>, not <code>a.__eq__(b)</code>. If you opt to call the <code>__eq__</code> and <code>__ne__</code> directly then you have to handle with the added complication of <code>NotImplemented</code> yourself.</span>
<span class="comment-copy">So if you were to rephrase this into an actual question, it might be "Why does Python say that these objects are not equal (<code>!=</code>) instead of raising an exception?"</span>
<span class="comment-copy">@user2357112 Sorry, but I'm not a fan of that edit. That's a bit too technical; I don't want venture that deep into python's inner workings. I think it's enough (and not incorrect) to say that <i>"<code>None</code> is explicitly defined to be falsy"</i>, without going into details about how that's implemented. Whether it has a <code>__bool__</code> method or not is really besides the point. I'm rolling it back.</span>
<span class="comment-copy">Then why bring up the None special case at all? It has no externally visible effect now that <code>None</code> has a <code>__bool__</code> method, and <code>None</code> isn't even the only special-cased object; <a href="https://github.com/python/cpython/blob/v3.6.4/Objects/object.c#L1225" rel="nofollow noreferrer"><code>True</code> and <code>False</code> are also special-cased</a>.</span>
<span class="comment-copy">@user2357112 That's all specifically about CPython's implementation though. The point I'm trying to make is that <code>None</code> is well-defined to be falsy in the python language because it's commonly used in a boolean context, whereas other objects like <code>NotImplemented</code> are <i>not</i> meant or designed to be used in a boolean context and therefore default to the standard behavior of being truthy. (So yes, <code>True</code> and <code>False</code> are also exceptions, but I don't think it's necessary to mention that booleans have a well-defined truth value...)</span>
<span class="comment-copy">None is defined to be false, but not in a way that makes it an exception from the general rules. Your answer acts as if it's an exception.</span>
<span class="comment-copy">@user2357112 Again, it's not about <i>how</i> <code>None</code> gets its truth value. I'm arguing on a higher level here; it's about language semantics. The simple fact that the truth value of <code>None</code> is <i>explicitly</i> stated in the documentation makes it different from <code>NotImplemented</code> or the ellipsis object or <code>int</code> or <code>min</code>.</span>
