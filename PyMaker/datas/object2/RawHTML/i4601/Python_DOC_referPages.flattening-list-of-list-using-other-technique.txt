<div class="post-text" itemprop="text">
<p>I am trying to understand this code for flattening list:</p>
<pre><code>enter codedef flatten(iterable):
"""Recursively iterate lists and tuples.
"""
for elm in iterable:
    if isinstance(elm, (list, tuple)):
        for relm in flatten(elm):
            yield relm
    else:
        yield elm here
</code></pre>
<p>Source: <a href="https://stackoverflow.com/questions/6499839/making-a-flat-list-out-of-a-multi-type-nested-list">Making a flat list out of a multi-type nested list</a></p>
<p>However I am not able to understand recursive statement and how control is flowing. Specially these two lines:</p>
<pre><code>   for relm in flatten(elm):
            yield relm
</code></pre>
<p>Can I get gist of how recursive is working at every iteration, that would be a great help. </p>
<p>And Can we use some other approch to do this problem?</p>
</div>
<div class="post-text" itemprop="text">
<h1>Iterate protocol</h1>
<p>In python there is such a key concept as iteration protocol. Iteration protocol is used every time you:</p>
<ul>
<li>Use a for loop</li>
<li>Unpack/pack a tuple</li>
<li>Use list comprehension</li>
<li>Yield any value</li>
</ul>
<p>Basically iteration protocol is used every time you want to process some sequence of data. Let's use list creation as example. Whenever you call:</p>
<pre><code>my_list=list(x)
</code></pre>
<p>Python interpreter is calling <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="nofollow noreferrer">__next__</a> method on x and then adding result to end of result list (which is empty at the beginning). And it stops when next(x) throws <a href="https://docs.python.org/3/library/exceptions.html#StopIteration" rel="nofollow noreferrer">StopIteration</a>.</p>
<h1>So what with this yields?</h1>
<p><a href="https://docs.python.org/3/reference/expressions.html#yieldexpr" rel="nofollow noreferrer">Yield</a> is pretty similar to return but it does not terminate the function. Result of the function with yields inside is <a href="https://docs.python.org/3/glossary.html#term-generator" rel="nofollow noreferrer">generator</a>. Generators implements <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="nofollow noreferrer">__next__</a> method and they can be used in iterate protocol.
Let's look at this function:</p>
<pre><code>def gen():
    yield 1
    yield 2
    yield 3
</code></pre>
<p>This function will be generator and it will behave like this:</p>
<pre><code>&gt;&gt;&gt;gen()
&lt;generator object a at 0x0000000002A1EAF0&gt;
&gt;&gt;&gt;list(gen())
[1,2,3]
&gt;&gt;&gt;i=gen()
&gt;&gt;&gt;next(i)
1
&gt;&gt;&gt;next(i)
2
&gt;&gt;&gt;next(i)
3
&gt;&gt;&gt;next(i)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>So every time you call next(i) python only execute code till next <a href="https://docs.python.org/3/reference/expressions.html#yieldexpr" rel="nofollow noreferrer">yield</a> and returns it's value.
If you want to learn more about it I recommend <a href="https://www.youtube.com/watch?v=V2PkkMS2Ack" rel="nofollow noreferrer">this</a> lecture or answers to <a href="https://stackoverflow.com/questions/16301253/what-exactly-is-pythons-iterator-protocol">this</a> question. </p>
<h1>P.S</h1>
<p>Instead of this lines: </p>
<pre><code>for relm in flatten(elm):
            yield relm
</code></pre>
<p>you can use:</p>
<pre><code>yield from flatten(elm)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>(I deleted my comment and posted is as answer, because my edit was too long.)</p>
<p>The flow control is as follows:</p>
<ul>
<li><code>iterable</code> is the nested list you have at the beginning,</li>
<li>the <code>for</code> and later <code>if</code> differentiates if the <code>elm</code> (element from <code>iterable</code>) is a <code>list</code> or <code>tuple</code> type,</li>
<li>if yes, then the statement under <code>if</code> makes the recurrence happen and the <code>elm</code> becomes new <code>iterable</code>,</li>
</ul>
<p>...this happens for every element inside the main list until the <code>elm</code> isn't <code>list</code> or <code>tuple</code></p>
<ul>
<li>the function returns <code>generator</code> object, so to get to all outputs you have to call a <code>list</code> on it.</li>
</ul>
<p>What you also can do, is adding <code>print</code> statements to see what is happening; for example:</p>
<pre><code>def flatten(iterable):
    for elm in iterable:
        if isinstance(elm, (list, tuple)):
            print(elm)
            for relm in flatten(elm):
                yield relm
        else:
            print(elm)
            yield elm
</code></pre>
<p>If we input <code>a = [1, 2, 3,[[4, 5], 5, (1, 2, 3)], 2]</code> and say <code>list(flatten(a))</code> we get:</p>
<pre><code>1
2
3
[[4, 5], 5, (1, 2, 3)]
[4, 5]
4
5
5
(1, 2, 3)
1
2
3
2
</code></pre>
<p>This way we can see, what the function was working on in every step.</p>
</div>
<span class="comment-copy">In your example when flatten() is called on elm=[4, 5] then iterable is replaced by elm... Then how flatten() keeps track of [5, (1, 2, 3)] rest elements. In this line: for relm in flatten(elm):</span>
<span class="comment-copy">It keeps track of rest of the elements because of <code>for elm in iterable:</code>. The recursion happens for current element, until it is exhausted. Then the <code>for</code> continues.I think you can try to modify it further to see when the recursion is "inside" a nested list adding more <code>print</code> statements.</span>
<span class="comment-copy">Can you show it in a flow diagram. I am sorry if it's too much to ask but this will help me to understand better.</span>
<span class="comment-copy"><a href="https://imgur.com/a/Q5GOO" rel="nofollow noreferrer">imgur.com/a/Q5GOO</a> It's not the best, especially the second if, but maybe it will help you.</span>
<span class="comment-copy">Thanks. Wonderful Solution!!</span>
