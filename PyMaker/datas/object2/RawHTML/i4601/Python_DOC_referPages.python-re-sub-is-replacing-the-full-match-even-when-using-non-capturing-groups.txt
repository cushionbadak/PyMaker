<div class="post-text" itemprop="text">
<p>I believe that re.sub() is replacing the Full Match, but in this case I only want to replace the matching groups and ignore the non-capturing groups. How can I go about this?</p>
<pre><code>string = 'aBCDeFGH'

print(re.sub('(a)?(?:[A-Z]{3})(e)?(?:[A-Z]{3})', '+', string))
</code></pre>
<p>output is :</p>
<pre><code>+
</code></pre>
<p>Expected output is:</p>
<pre><code>+BCD+FGH
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The general solution for such problems is using a lambda in the replacement:</p>
<pre><code>string = 'aBCDeFGH'

print(re.sub('(a)?([A-Z]{3})(e)?([A-Z]{3})', lambda match: '+%s+%s' % (match.group(2), match.group(4)), string))
</code></pre>
<p>However, as bro-grammer has commented, you can use backreferences in this case:</p>
<pre><code>print(re.sub('(a)?([A-Z]{3})(e)?([A-Z]{3})', r'+\2+\4', string))
</code></pre>
</div>
<span class="comment-copy">Try <a href="http://rextester.com/CUOY83316" rel="nofollow noreferrer"><code>re.sub('[ae]([A-Z]{3})', r'+\1', 'aBCDeFGH')</code></a></span>
<span class="comment-copy">Try <code>re.sub('(a)?([A-Z]{3})(e)?([A-Z]{3})', r'+\2+\4', string)</code></span>
<span class="comment-copy">That's they way <code>re.sub</code> works... if you want to keep portions of the original string you can always put them in the replacement string using groups.</span>
<span class="comment-copy">Also, an alternative is to use lookaheads: <code>re.sub(r'[a-z](?=[A-Z]{3})', '+', string)</code> this will match a single lowercase character, only if it is followed by 3 uppercase ones, and in that case it replaces it with <code>+</code>, which is what you want.</span>
<span class="comment-copy">Thanks! This solved my problem. Python documentation never mentions anything about being able to use lambda function in re.sub():</span>
<span class="comment-copy">@Darwin From <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer">the docs</a>: <i>"repl can be a string or a function"</i>. There's even an example.</span>
<span class="comment-copy">For a fuller answer, another solution would be to use non consuming groups (look aheads and look behinds, as giacomo stated</span>
