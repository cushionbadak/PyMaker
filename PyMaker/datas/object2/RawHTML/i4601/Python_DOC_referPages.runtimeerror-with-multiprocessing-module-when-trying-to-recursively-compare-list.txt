<div class="post-text" itemprop="text">
<p>I'm generating a list filled with sublists of randomly generated 0s and 1s, and then trying to compare each list with every other list to determine their similarity, efficiently.</p>
<p>I know that my code works with a single process (i.e. without involving <code>multiprocessing</code>, but once I start involving <code>multiprocessing.Pool()</code> or  <code>multiprocessing.Process()</code> everything starts to break.</p>
<p>I want to compare how long a single process would take compared to multiple processes. I've tried this with <code>threading</code>, but a single process actually ended up taking less time, probably due to the Global Interpreter Lock.</p>
<p>Here's my code:</p>
<pre><code>import difflib
import secrets
import timeit
import multiprocessing
import numpy

random_lists = [[secrets.randbelow(2) for _ in range(500)] for _ in range(500)]
random_lists_split = numpy.array_split(numpy.array(random_lists), 5)


def get_similarity_value(lists_to_check, sublists_to_check) -&gt; list:
    ratios = []
    matcher = difflib.SequenceMatcher()
    for sublist_major in sublists_to_check:
        try:
            sublist_major = sublist_major.tolist()
        except AttributeError:
            pass
        for sublist_minor in lists_to_check:
            if sublist_major == sublist_minor or [lists_to_check.index(sublist_major), lists_to_check.index(sublist_minor)] in [ratios[i][1] for i in range(len(ratios))] or [lists_to_check.index(sublist_minor), lists_to_check.index(sublist_major)] in [ratios[i][1] for i in range(len(ratios))]:  # or lists_to_check.index(sublist_major.tolist()) &gt; lists_to_check.index(sublist_minor):
                pass
            else:
                matcher.set_seqs(sublist_major, sublist_minor)
                ratios.append([matcher.ratio(), sorted([lists_to_check.index(sublist_major), lists_to_check.index(sublist_minor)])])
    return ratios


def start():
    test = multiprocessing.Pool(4)
    data = [(random_lists, random_lists_split[i]) for i in range(len(random_lists_split))]
    print(test.map(get_similarity_value, data))


statement = timeit.Timer(start)
print(statement.timeit(1))

statement2 = timeit.Timer(lambda: get_similarity_value(random_lists, random_lists))
print(statement2.timeit(1))
</code></pre>
<p>And here's the error:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\spawn.py", line 105, in spawn_main
    exitcode = _main(fd)
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\spawn.py", line 114, in _main
    prepare(preparation_data)
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\spawn.py", line 225, in prepare
    _fixup_main_from_path(data['init_main_from_path'])
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\spawn.py", line 277, in _fixup_main_from_path
    run_name="__mp_main__")
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\runpy.py", line 263, in run_path
    pkg_name=pkg_name, script_name=fname)
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\runpy.py", line 96, in _run_module_code
    mod_name, mod_spec, pkg_name, script_name)
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\runpy.py", line 85, in _run_code
    exec(code, run_globals)
  File "timings.py", line 38, in &lt;module&gt;
    print(statement.timeit(1))
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\timeit.py", line 178, in timeit
    timing = self.inner(it, self.timer)
  File "&lt;timeit-src&gt;", line 6, in inner
  File "timings.py", line 32, in start
    test = multiprocessing.Pool(4)
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\context.py", line 119, in Pool
    context=self.get_context())
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\pool.py", line 174, in __init__
    self._repopulate_pool()
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\pool.py", line 239, in _repopulate_pool
    w.start()
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\process.py", line 105, in start
    self._popen = self._Popen(self)
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\context.py", line 322, in _Popen
    return Popen(process_obj)
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\popen_spawn_win32.py", line 33, in __init__
    prep_data = spawn.get_preparation_data(process_obj._name)
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\spawn.py", line 143, in get_preparation_data
    _check_not_importing_main()
  File "C:\ProgramData\Anaconda3\envs\Computing Coursework\lib\multiprocessing\spawn.py", line 136, in _check_not_importing_main
is not going to be frozen to produce an executable.''')
RuntimeError: 
    An attempt has been made to start a new process before the
    current process has finished its bootstrapping phase.

    This probably means that you are not using fork to start your
    child processes and you have forgotten to use the proper idiom
    in the main module:

        if __name__ == '__main__':
            freeze_support()
            ...

    The "freeze_support()" line can be omitted if the program
    is not going to be frozen to produce an executable.
</code></pre>
<p>N.B. I have tried using <code>multiprocessing.freeze_support()</code> but it results in the same error. The code also seems to be attempting to run indefinitely, as the error appears over and over again.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that your top-level code—including the code that creates the child <code>Process</code>—is not protected from being run in the child processes.</p>
<p>As <a href="https://docs.python.org/3/library/multiprocessing.html#the-spawn-and-forkserver-start-methods" rel="nofollow noreferrer">the docs</a> explain:, if you're not using the <code>fork</code> start method (and since you're on Windows, you're not):</p>
<blockquote>
<p>Make sure that the main module can be safely imported by a new Python interpreter without causing unintended side effects (such a starting a new process).</p>
</blockquote>
<p>In fact, it's nearly identical to the example that follows that warning. You're launching a whole pool of children instead of just one, but it's the same problem. Every child in the pool tries to launch a new pool, and, fortunately, <code>multiprocessing</code> figures out that something bad is going on and fails with a <code>RuntimeError</code> instead of exponentially spawning processes until Windows refuses to spawn anymore or its scheduler just falls down.</p>
<p>As the docs say:</p>
<blockquote>
<p>Instead one should protect the “entry point” of the program by using <code>if __name__ == '__main__'</code>:</p>
</blockquote>
<p>In your case, that means this part:</p>
<pre><code>if __name__ == '__main__':
    statement = timeit.Timer(start)
    print(statement.timeit(1))

    statement2 = timeit.Timer(lambda: get_similarity_value(random_lists, random_lists))
    print(statement2.timeit(1))
</code></pre>
</div>
<span class="comment-copy">I get a different error: <code>TypeError: get_similarity_value() missing 1 required positional argument: 'sublists_to_check'</code> from the print in start</span>
<span class="comment-copy">@Maarten_vd_Sande Weird. The second argument (sublists_to_check) should be passed through as it's part of the list of tuples in the data variable.</span>
<span class="comment-copy">If you take the <code>timeit</code> code out, does the problem go away? Because this seems like the kind of thing that could be caused by both <code>timeit</code> and <code>multiprocessing</code> trying to transparently wrap up the same top-level code in ways that aren't quite transparent.</span>
