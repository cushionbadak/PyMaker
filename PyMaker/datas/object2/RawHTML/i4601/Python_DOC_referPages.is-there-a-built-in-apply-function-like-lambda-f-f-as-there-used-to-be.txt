<div class="post-text" itemprop="text">
<p>Looking at <a href="https://stackoverflow.com/questions/49558133/get-result-from-multiprocessing-process/49559474">this question</a>, I realised that it is kind of awkward to use <code>multiprocessing</code>'s <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map" rel="nofollow noreferrer"><code>Pool.map</code></a> if you want is to run a list of functions in parallel:</p>
<pre><code>from multiprocessing import Pool

def my_fun1(): return 1
def my_fun2(): return 2
def my_fun3(): return 3

with Pool(3) as p:
   one, two, three = p.map(lambda f: f(), [my_fun1, my_fun2, my_fun3])
</code></pre>
<p>I'm not saying it is exactly cryptic, but I think I expected some conventional name for this, even if only within <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer"><code>functools</code></a> or something, similarly to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="nofollow noreferrer"><code>apply</code></a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="nofollow noreferrer"><code>call</code></a> in JavaScript (yes, I know JavaScript didn't have lambdas at the time those functions were defined, and no, I'm not saying JavaScript is an exemplary programming language, just an example). In fact, I definitely think something like this should be present in <a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer"><code>operator</code></a>, but (unless my eyes deceive me) it seems to be absent. I read that <a href="https://stackoverflow.com/questions/8748036/is-there-a-builtin-identity-function-in-python">in the case of the identity function</a> the resolution was to let people define their own trivial functions, and I understand it better in that case because there are a couple of different variations you may want, but this one feels like a missing bit to me.</p>
<p>EDIT: As pointed out in the comments, Python 2 used to have an <a href="https://docs.python.org/2/library/functions.html#apply" rel="nofollow noreferrer"><code>apply</code></a> function for this purpose.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, let's look at the practical question.</p>
<p>For any Python from 2.3 on, you can trivially write not just your no-argument <code>apply</code>, but a perfect-forwarding <code>apply</code>, as a one-liner, as explained in <a href="https://docs.python.org/2/library/functions.html#apply" rel="nofollow noreferrer">the 2.x docs for <code>apply</code></a>:</p>
<blockquote>
<p>The use of <code>apply()</code> is equivalent to <code>function(*args, **keywords)</code></p>
</blockquote>
<p>In other words:</p>
<pre><code>def apply(function, *args, **keywords):
    return function(*args, **keywords)
</code></pre>
<p>… or, as an inline lambda:</p>
<pre><code>lambda f, *a, **k: f(*a, **kw)
</code></pre>
<p>Of course the C implementation was a bit faster, but this is almost never relevant.<sup>1</sup></p>
<p>If you're going to be using this more than once, I think defining the function out-of-line and reusing it by name is probably clearer, but the lamdba version is simple and obvious enough (even more so for your no-args use case) that I can't imagine anyone complaining about it.</p>
<p>Also, notice that this is actually more trivial than <code>identity</code> if you understand what you're doing, not less. With <code>identity</code>, it's ambiguous what you should return with multiple arguments (or keyword arguments), so you have to decide which behavior you want; with <code>apple</code>, there's only one obvious answer, and it's pretty much impossible to get wrong.</p>
<hr/>
<p>As for the history: </p>
<p>Python, like JavaScript, originally had no <code>lambda</code>. It's hard to dig up linkable docs for versions before 2.6, and hard to even find them before 2.3, but I think <code>lambda</code> was added in 1.5, and eventually reached the point where it could be used for perfect forwarding around 2.2. Before then, the docs recommended using <code>apply</code> for forwarding, but after that, the docs recommended using <code>lambda</code> in place of <code>apply</code>. In fact, there was no longer any recommended use of <code>apply</code>.</p>
<p>So in 2.3, the function was deprecated.<sup>2</sup></p>
<p>During the Python-3000 discussions that led to 3.0, Guido suggested that all of the "functional programming" functions except <em>maybe</em> <code>map</code> and <code>filter</code> were unnecessary.<sup>3</sup> Others made good cases for <code>reduce</code> and <code>partial</code>.<sup>4</sup> But a big part of the case was that they're actually not trivial to write (in fully-general form), and easy to get wrong. That isn't true for <code>apply</code>. Also, people were able to find relevant uses of <code>reduce</code> and <code>partial</code> in real-world codebases, but the only uses of <code>apply</code> anyone could find were old pre-2.3 code. In fact, it was so rare that it wasn't even worth making the <code>2to3</code> tool transform calls to <code>apply</code>.</p>
<p>The final rationale for removing it was summarized in <a href="https://www.python.org/dev/peps/pep-3100/#built-in-namespace" rel="nofollow noreferrer">PEP 3100</a>:</p>
<blockquote>
<p><code>apply()</code>: use <code>f(*args, **kw)</code> instead [2]</p>
</blockquote>
<p>That footnote links to an essay by Guido called "Python Regrets", which is now a 404 link. The accompanying PowerPoint presentation is <a href="http://legacy.python.org/doc/essays/ppt/regrets/PythonRegrets.ppt" rel="nofollow noreferrer">still available</a>, however, or you can view <a href="http://online.fliphtml5.com/lpyn/anne/" rel="nofollow noreferrer">an HTML flipbook</a> of the presentation he wrote it for. But all it really says is the same one-liner, and IIRC, the only further discussion was "We already effectively got rid of it in 2.3."</p>
<hr/>
<p><sub>1. In most idiomatic Python code that has to apply a function, the work inside that function is pretty heavy. In your case, of course, the overhead of calling the functions (pickling arguments and passing them over a pipe) is even heavier. The one case where it would matter is when you're doing "Haskell-style functional programming" instead of "Lisp-style"—that is, very few function definitions, and lots of functions made by transforming functions and composing the results. But that's already so slow (and stack-heavy) in Python that it's not a reasonable thing to do. (Flat use of decorators to apply a wrapper or three works great, but a potentially unbounded chain of wrappers will kill your performance.)</sub></p>
<p><sub>2. The formal deprecation mechanism didn't exist yet, so it was just moved to a "Non-essential Built-in Functions" section in the docs. But it was retroactively considered to be deprecated since 2.3, as you can see in the 2.7 docs.</sub></p>
<p><sub>3. Guido originally wanted to get rid of even them; the argument was that list comprehensions can do the same job better, as you can see in the "Regrets" flipbook. But promoting <code>itertools.imap</code> in place of <code>map</code> means it could be made lazy, like the new <code>zip</code>, and therefore better than comprehensions. I'm not sure why Guido didn't just make the same argument with generator expressions.</sub></p>
<p><sub>4. I'm not sure Guido himself was ever convinced for <code>reduce</code>, but the core devs as a whole were.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>It sort of is in <code>operator</code> if you do one line of extra work:</p>
<pre><code>&gt;&gt;&gt; def foo():
...     print 'hi'
... 
&gt;&gt;&gt; from operator import methodcaller
&gt;&gt;&gt; call = methodcaller('__call__')
&gt;&gt;&gt; call(foo)
hi
</code></pre>
<p>Of course, <code>call = lambda f: f()</code> is only one line as well...</p>
</div>
<span class="comment-copy">Python used to have an <code>apply</code> builtin for this—but it was removed. And the reasoning was largely the same as for not adding identity: it’s trivial to write apply and all of its reasonable variations yourself, and rarely used, so if you want it, just write it yourself.</span>
<span class="comment-copy"><code>Pool.async_apply</code> would seem to be useful here.</span>
<span class="comment-copy">@abarnert I see, I never knew (or forgot if I ever did) about <code>apply</code> in Python 2. I still think it would make sense in <code>operator</code> (like <code>reduce</code> was moved to <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer"><code>functools</code></a>), I mean, the same triviality argument applies to about anything in there, but who am I to question BDFL. Anyway, if you don't mind posting an answer with that I'll accept, I think it's the right explanation.</span>
<span class="comment-copy">@jdehesa If you want me to dig up the full history and rationale for an answer, I will. But off the top of my head: Around 2.1, you couldn’t do perfect forwarding (because there was no keyword splat for lambdas), so the recommendation was to use apply. Then 2.2 fixed it, and Python has made sure to always allow perfect forwarding since then. So there were no recommended uses for apply, which opened a discussion that led to it being deprecated in 2.3, with a note showing how to write it (or variations on it) yourself. 3.0, removed it instead of moved to functools because nobody was using it.</span>
<span class="comment-copy">@chepner Yes, but <code>apply_async</code> takes a single function as parameter. You can call with each function, but if you want to extract the results to local function variables it can be weird with callbacks...</span>
<span class="comment-copy">Awesome, this is encyclopedic. I wasn't aware there was such "animosity" against higher-order functions! I'm glad they remained, I still find more idiomatic using <code>map</code> in some cases (less so <code>filter</code>), although I see how it may go against the "one obvious way to do it" zen.</span>
<span class="comment-copy">@jdehesa Guido's position is often overstated. I think the best way to put it is not that he hates HOFs, but that he thinks an ideal language should have syntax that makes the commonly used HOFs unnecessary. And once you discover list comprehensions (and in Haskell, where HOFs are everything), it's not hard to believe that ideal is reachable.</span>
<span class="comment-copy">Right, not sure if one option is better than the other, but it is a nice alternative to the <code>lambda</code>.</span>
