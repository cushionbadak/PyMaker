<div class="post-text" itemprop="text">
<p>Is condition.acquire(threading.Condition()) similar to lock.acquire(threading.Lock). Does both of get access to the lock. Can i use condition.wait,notify with lock.acquire or i have to use condition.wait, notify with condition.acquire.</p>
<pre><code>cond.acquire()  // can i replace with lock.acquire

   while count[ipID]&gt; 1:
      cond.wait()
   if ipID == 0:
      time.sleep(10)


   count[ipID] = count[ipID] + 1


   cond.release() // can i replace with lock.release
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your condition was created like this:</p>
<pre><code>lock = Lock()
cond = Condition(lock)
</code></pre>
<p>… then yes, as <a href="https://docs.python.org/3/library/threading.html#threading.Condition" rel="nofollow noreferrer">the docs</a> explain, <code>cond.acquire()</code> is just calling <code>lock.acquire()</code>, so you could do that instead and get the same effect. And likewise for <code>release</code>. However, it's likely to be misleading to human readers (and maybe to static analysis tools), so unless you have a really good reason, you <em>shouldn't</em> do it.</p>
<hr/>
<p>On the other hand, if they're unrelated objects, created like this:</p>
<pre><code>lock = Lock()
cond = Condition()
</code></pre>
<p>… then no. It is illegal to call <code>cond.wait()</code> if you haven't acquired the lock used by the condition. It's guaranteed to raise a <code>RuntimeError</code>. It doesn't matter if some other <code>Lock</code> object happens to be ensuring that nobody else will access <code>cond</code>; the whole point of <code>cond.wait</code> is that it atomically releases its lock and blocks on <code>notify</code>, so if it's not holding its lock, it's useless as a condition.</p>
<hr/>
<p>As a side note, it's almost always better to acquire both <code>Lock</code>s and <code>Condition</code>s <a href="https://docs.python.org/3/library/threading.html#using-locks-conditions-and-semaphores-in-the-with-statement" rel="nofollow noreferrer">in a <code>with</code> statement</a>:</p>
<pre><code>with cond:
    with count[ipID] &gt; 1:
        cond.wait()
    if ipID == 0:
        time.sleep(10)
    count[ipID] = count[ipID] + 1
</code></pre>
<p>The way you've written things, if anything after that <code>acquire</code> raises an exception, you will never release the condition, so no other thread waiting on it can wake up.</p>
<p>While we're at it, using <code>sleep</code> is almost always a sign of a problem with your threading design. Why can't you just <code>wait(timeout=10)</code> instead? If you have too many spurious <code>notify</code> calls, you should fix that. If <code>count[ipID]</code> is not getting reset properly so the <code>while</code> loop may exit early, that's even more important to fix. Whatever problem you think you're solving with <code>sleep</code>, you're probably just disguising it.</p>
</div>
<div class="post-text" itemprop="text">
<p>The notify part of code is as below.</p>
<pre><code>print "count is %d %s" % (count[ipID],name)

   cond.acquire()

   count[ipID] = count[ipID] - 1
   cond.notifyAll()
   cond.release()
</code></pre>
</div>
<span class="comment-copy">Why do you <i>want</i> to do this?</span>
