<div class="post-text" itemprop="text">
<p>I know that by inheriting the base class. All the functions in base class would be accessible in the derived class as well. But how does it work the other way, meaning can a function that is defined in the child class be accessible in the base class. </p>
<p>I tried the above out with an example. And it works just fine. But how can that be. I am not able to get the logic behind the working. </p>
<pre><code>class fish:

    def color(self):
        # _colour is a property of the child class. How can base class access this?
        return self._colour  


class catfish(fish):

    _colour = "Blue Cat fish"

    def speed(self):
        return "Around 100mph"

    def agility(self):
        return "Low on the agility"

class tunafish(fish):

    _colour = "Yellow Tuna fish"

    def speed(self):
        return "Around 290mph"

    def agility(self):
        return "High on the agility"

catfish_obj = catfish()
tunafish_obj = tunafish()

print(catfish_obj.color())
print(tunafish_obj.color())
</code></pre>
<p>I understand that the instance is being passed and all through self, but the details of the child class should logically not be accessible in the base class, correct?!</p>
</div>
<div class="post-text" itemprop="text">
<p>You are accessing attributes on an instance, <strong>not on a class</strong>. Your <code>self</code> reference is never an instance of the <code>fish</code> class, only of one of the two derived classes, and those derived classes set the <code>_colour</code> attribute.</p>
<p>If you created an instance of <code>fish()</code> itself, you'd get an attribute error, because that instance will not have the attribute set.</p>
<p>You may perhaps think that in base classes, <code>self</code> becomes an instance of the base class; that's not the case.</p>
<p>Instead, attributes on an instance are looked up on the instance directly, <em>and</em> on its class and base classes. So <code>self._colour</code> looks at the instance, at <code>type(instance)</code> and at all further objects in the <code>type(instance).__mro__</code>, the Method Resolution Order that sets all classes in a hierarchy in a linear order.</p>
<p>You could print out the <code>type()</code> of your object:</p>
<pre><code>&gt;&gt;&gt; class fish:
...     def color(self):
...         print(type(self))
...         return self._colour
...
# your other class definitions
&gt;&gt;&gt; print(catfish_obj.color())
&lt;class '__main__.catfish'&gt;
Blue Cat fish
&gt;&gt;&gt; print(tunafish_obj.color())
&lt;class '__main__.tunafish'&gt;
Yellow Tuna fish
</code></pre>
<p>The <code>self</code> references are instances of the derived classes, passed into an inherited method. So <code>self._colour</code> will first look at the attributes directly set on <code>self</code>, then at <code>type(self)</code>, and there <code>_colour</code> is found.</p>
<p>Perhaps it would help to see how Python methods work. Methods are just thin wrappers around functions, created when you look up the attribute on an instance:</p>
<pre><code>&gt;&gt;&gt; tunafish_obj.color  # access the method but not calling it
&lt;bound method fish.color of &lt;__main__.tunafish object at 0x110ba5278&gt;&gt;
&gt;&gt;&gt; tunafish.color      # same attribute name, but on the class
&lt;function fish.color at 0x110ba3510&gt;
&gt;&gt;&gt; tunafish.color.__get__(tunafish_obj, tunafish)  # what tunafish_obj.color actually does
&lt;bound method fish.color of &lt;__main__.tunafish object at 0x110ba5278&gt;&gt;
&gt;&gt;&gt; tunafish_obj.color.__self__   # methods have attributes like __self__
&lt;__main__.tunafish object at 0x110ba5278&gt;
&gt;&gt;&gt; tunafish_obj.color.__func__   # and __func__. Recognise the numbers?
&lt;function fish.color at 0x110ba3510&gt;
</code></pre>
<p>Look closely at the names of the objects I access, and what happens when I call the <code>__get__</code> method on a function. Python uses a process called <em>binding</em> when you access certain attributes on an instance; when you access an attribute this way, and that points to an object with a <code>__get__</code> method, then that object is called a <em>descriptor</em>, and <code>__get__</code> is called to bind the object to whatever you looked the object up on. See the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor howto</a>.</p>
<p>Accessing <code>color</code> on the instance, produces a <em>bound method</em> object, but the description of the object tells us it came from <code>fish</code>, it's named a *bound method <code>fish.color</code> of <em>instance reference</em>. Accessing the same name on the class gives us the <code>fish.color</code> <em>function</em>, and I can manually bind it to create a method again.</p>
<p>Finally, the method has an attribute <code>__self__</code>, which is the original instance, and <code>__func__</code> which is the original function. And there's the magic, when you call a bound method, the method object just calls <code>__func__(__self__, ....)</code>, so passing in the instance it was bound to.</p>
<p>When that function was inherited, (found on the <code>fish</code> class, so <code>fish.color</code>), it is <em>still passed an instance of the derived class</em>, and still has everything the derived class has.</p>
<p>Python is very dynamic, and <em>very</em> flexible. You can take any old function and put it on a class, and it can be bound into a method. Or you can take any unbound function, and manually pass in an object with the right attributes, and it'll <em>just work</em>. Python doesn't care, really. So you can pass in a new, indepdent type of object and still have the <code>fish.color</code> function work:</p>
<pre><code>&gt;&gt;&gt; fish.color  # original, unbound function on the base class
&lt;function fish.color at 0x110ba3510&gt;
&gt;&gt;&gt; class FakeFish:
...     _colour = 'Fake!'
...
&gt;&gt;&gt; fish.color(FakeFish)  # passing in a class! Uh-oh?
&lt;class 'type'&gt;
'Fake!'
</code></pre>
<p>So even passing in a class object, completely unrelated to the <code>fish</code> hierarchy, but with the expected attribute, still works.</p>
<p>To most Python code, if it walks like a duck, and quacks like a duck, the code will <em>accept</em> it as a duck. Call it <a href="https://en.wikipedia.org/wiki/Duck_typing" rel="nofollow noreferrer">duck typing</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <em>methods</em> of a derived class are not available in the base class.  However, the <em>fields</em> are shared for any function operating on a particular object.  <code>self._colour</code> refers to the value of <code>_colour</code> in the object on which you are calling <code>color()</code>, regardless of how <code>_colour</code> was set.</p>
<p><strong>Edit</strong> because you are setting <code>_colour = ...</code> directly in the class, outside of a function, any <code>catfish</code> will have <code>_colour == "Blue Cat fish"</code> and any <code>tunafish</code> will have <code>_colour == "Yellow Tuna fish"</code>.  Those values, although set on the class, are available in every instance.  That is why <code>self._colour</code> works even though you never directly said <code>self._colour = ...</code>.  If you wanted fish-specific colors, you would need to set <code>self._colour</code> in <code>catfish.__init__</code> or <code>tunafish.__init__</code>.</p>
</div>
<span class="comment-copy">No, the methods of a derived class are not available in the base.</span>
<span class="comment-copy">The output of the above program is : Blue Cat fish Yellow Tuna fish. (So this would prove otherwise)</span>
<span class="comment-copy">To clarify Martijn's comment: <code>_colour</code> <i>is</i> an attribute of the class, but it's <i>accessed</i> through an instance, which is why it works.</span>
<span class="comment-copy">Yes, sorry, that comment wasn't helpful. <code>self</code> is never the <code>fish</code> class or an instance of the <code>fish</code> class. It's an instance of <code>catfish</code> or tunafish`, each of which have the required attribute.</span>
