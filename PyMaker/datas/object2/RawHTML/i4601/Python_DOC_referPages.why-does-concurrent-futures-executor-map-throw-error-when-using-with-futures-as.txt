<div class="post-text" itemprop="text">
<p>I am trying to send HTTP requests concurrently. In order to do so, I am using <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">concurrent.futures</a></p>
<p>Here is simple code:</p>
<pre><code>import requests
from concurrent import futures

data = range(10)


def send_request(item):
    requests.get("https://httpbin.org/ip")
    print("Request {} complete.".format(item))


executor = futures.ThreadPoolExecutor(max_workers=25)

futures_ = executor.map(send_request, data)

for f in futures.as_completed(futures_):
    f.result()
</code></pre>
<p>If I run it, I can see requests are sent asynchronously, which is exactly what I want to do. However, when all the requests are complete, I get following error:</p>
<pre><code>Request 0 complete.
Request 6 complete.
...
Request 7 complete.
Request 9 complete.
Request 3 complete.
Traceback (most recent call last):
  File "send_thread.py", line 18, in &lt;module&gt;
    for f in futures.as_completed(futures_):
  File "/usr/local/Cellar/python3/3.6.4/Frameworks/Python.framework/Versions/3.6/lib/python3.6/concurrent/futures/_base.py", line 219, in as_completed
    with _AcquireFutures(fs):
  File "/usr/local/Cellar/python3/3.6.4/Frameworks/Python.framework/Versions/3.6/lib/python3.6/concurrent/futures/_base.py", line 146, in __enter__
    future._condition.acquire()
AttributeError: 'NoneType' object has no attribute '_condition'
</code></pre>
<p>This is quite strange error. Here <code>executor.map</code> seems to be problematic. If I replace map with following line, it works as expected.</p>
<pre><code>futures_ = [executor.submit(send_request, x) for x in data]
</code></pre>
<p>What am I missing? Tried to find difference between two, but can't seem to understand what could cause above issue. Any input would be highly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://github.com/python/cpython/blob/4ca0739c9d97ac7cd45499e0d31be68dc659d0e1/Lib/concurrent/futures/_base.py#L579-L592" rel="nofollow noreferrer"><code>Executor.map</code></a> does not return you a list of futures but a generator of results, so instead of:</p>
<pre><code>futures_ = executor.map(send_request, data)
for f in futures.as_completed(futures_):
    f.result()
</code></pre>
<p>you should run:</p>
<pre><code>results = executor.map(send_request, data)
for r in results:
    print(r)
</code></pre>
</div>
<span class="comment-copy">I see, thank you very much. That raises another question: wouldn't that block if first request in that generator takes longer than others (whereas <code>futures.as_completed</code> processes as they complete)?</span>
<span class="comment-copy">@chhantyal, you are correct, it blocks to return results in the same order corresponding futures were passed (to mimic builtin <code>map</code> function). If you need <code>futures.as_completed</code> behaviour, <code>Executor.map</code> is not appropriate.</span>
<span class="comment-copy">Put a word, <code>concurrent.futures</code> is definitely not a proper way to send HTTP requests concurrently. You may actually want <code>aiohttp</code> lib.</span>
<span class="comment-copy">@skovorodkin #TIL something interesting. Thank you again.</span>
<span class="comment-copy">@Sraw you are right. However, above request is simple example. I am more looking into making IO calls faster in synchronous codebase, thus can't really use aiohttp.</span>
