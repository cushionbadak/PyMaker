<div class="post-text" itemprop="text">
<p>Today, I found a library named <a href="http://trio.readthedocs.io/en/latest/index.html" rel="noreferrer">trio</a> which says itself is an asynchronous API for humans. These words are a little similar with <code>requests</code>'. As <code>requests</code> is really a good library, I am wondering what is the advantages of <code>trio</code>.</p>
<p>There aren't many articles about it, I just find an <a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/#the-curious-effectiveness-of-curio" rel="noreferrer">article</a> discussing <code>curio</code> and <code>asyncio</code>. To my surprise, <code>trio</code> says itself is even better than <code>curio</code>(next-generation curio).</p>
<p>After reading half of the article, I cannot find the core difference between these two asynchronous framework. It just gives some examples that <code>curio</code>'s implementation is more convenient than <code>asyncio</code>'s. But the underlying structure is almost the same(callback-based, I think all asynchronous IO framework are based on callback without any exception.)</p>
<p>So could someone give me a reason I have to accept that <code>trio</code> or <code>curio</code> is better than <code>asyncio</code>? Or explain more about why I should choose <code>trio</code> instead of built-in <code>asyncio</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><em>Where I'm coming from:</em> I'm the primary author of trio. I'm also one of the top contributors to curio (and wrote the article about it that you link to), and a Python core dev who's been heavily involved in discussions about how to improve asyncio.</p>
<p>I'm not sure what you mean about callbacks. In trio (and curio), one of the core design principles is that you never program with callbacks; it feels more like thread-based programming than callback-based programming. I guess if you open up the hood and look at how they're implemented internally, then there are places where they use callbacks, or things that are sorta equivalent to callbacks if you squint. But that's like saying that Python and C are equivalent because the Python interpreter is implemented in C. <em>You</em> never use callbacks.</p>
<p>Anyway:</p>
<h1>Trio vs asyncio</h1>
<h2>Asyncio is more mature</h2>
<p>The first big difference is ecosystem maturity. At the time I'm writing this in <strong>March 2018</strong>, there are <em>many</em> more libraries with asyncio support than trio support. For example, right now there aren't any real HTTP servers with trio support. The <a href="https://pypi.org/search/?c=Framework+%3A%3A+AsyncIO" rel="noreferrer">Framework :: AsyncIO classifier on PyPI</a> currently has 122 libraries in it, while the <a href="https://pypi.org/search/?c=Framework+%3A%3A+Trio" rel="noreferrer">Framework :: Trio classifier</a> only has 8. I'm hoping that this part of the answer will become out of date quickly – for example, <a href="https://twitter.com/kennethreitz/status/974963822682427393" rel="noreferrer">here's Kenneth Reitz experimenting with adding trio support in the next version of requests</a> – but right now, you should expect that if you're trio for anything complicated, then you'll run into missing pieces that you need to fill in yourself instead of grabbing a library from pypi, or that you'll need to use <a href="https://trio-asyncio.readthedocs.io/" rel="noreferrer">the trio-asyncio package that lets you use asyncio libraries in trio programs</a>. (The <a href="https://gitter.im/python-trio/general" rel="noreferrer">trio chat channel</a> is useful for finding out about what's available, and what other people are working on.)</p>
<h2>Trio makes your code simpler</h2>
<p>In terms of the actual libraries, they're also very different. The main argument for trio is that it makes writing concurrent code much, much simpler than using asyncio. Of course, when was the last time you heard someone say that their library makes things harder to use... let me give a concrete example. In <a href="https://www.youtube.com/watch?v=i-R704I8ySE" rel="noreferrer">this talk</a> (<a href="https://github.com/python-trio/trio-talks/tree/master/njsmith-async-concurrency-for-mere-mortals" rel="noreferrer">slides</a>), I use the example of implementing <a href="https://tools.ietf.org/html/rfc8305" rel="noreferrer">RFC 8305 "Happy eyeballs"</a>, which is a simple concurrent algorithm used to efficiently establish a network connection. This is something that <a href="https://stackoverflow.com/users/13564/glyph">Glyph</a> has been thinking about for years, and his latest version for Twisted is ~600 lines long. (Asyncio would be about the same; Twisted and asyncio are very similar architecturally.) In the talk, I teach you everything you need to know to implement it in &lt;40 lines using trio (and we fix a bug in his version while we're at it). So in this example, using trio literally makes our code an order of magnitude simpler.</p>
<p>You might also find these comments from users interesting: <a href="https://github.com/python-trio/pytest-trio/issues/14#issuecomment-350454257" rel="noreferrer">1</a>, <a href="https://github.com/python-trio/trio/issues/449#issuecomment-367796899" rel="noreferrer">2</a>, <a href="https://gitter.im/python-trio/general?at=5ab8242f2b9dfdbc3a1fe9b1" rel="noreferrer">3</a></p>
<h2>There are many many differences in detail</h2>
<p>Why does this happen? That's a much longer answer :-). I'm gradually working on writing up the different pieces in blog posts and talks, and I'll try to remember to update this answer with links as they become available. Basically, it comes down to Trio having a small set of carefully designed primitives that have a few fundamental differences from any other library I know of (though of course build on ideas from lots of places). Here are some random notes to give you some idea:</p>
<p>A very, very common problem in asyncio and related libraries is that you call <code>some_function()</code>, and it returns, so you think it's done – but actually it's still running in the background. This leads to all kinds of tricky bugs, because it makes it difficult to control the order in which things happen, or know when anything has actually finished, and it can directly hide problems because if a background task crashes with an unhandled exception, asyncio will generally just print something to the console and then keep going. In trio, the way we handle task spawning via "nurseries" means that none of these things happen: when a function returns then you know it's done, and Trio's currently the only concurrency library for Python where exceptions always propagate until you catch them.</p>
<p>Trio's way of managing timeouts and cancellations is novel, and I think better than previous state-of-the-art systems like C# and Golang. <a href="https://vorpus.org/blog/timeouts-and-cancellation-for-humans/" rel="noreferrer">I actually did write a whole essay on this,</a> so I won't go into all the details here. But asyncio's cancellation system – or really, systems, it has two of them with slightly different semantics – are based on an older set of ideas than even C# and Golang, and are difficult to use correctly. (For example, it's easy for code to accidentally "escape" a cancellation by spawning a background task; see previous paragraph.)</p>
<p>There's a ton of redundant <em>stuff</em> in asyncio, which <a href="https://wiki.python.org/moin/TOOWTDI" rel="noreferrer">can make it hard to tell which thing to use when</a>. You have futures, tasks, and coroutines, which are all basically used for the same purpose but you need to know the differences between them. If you want to implement a network protocol, you have to pick whether to use the protocols/transports layer or the streams layer, and they both have tricky pitfalls (this is what the first part of <a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/" rel="noreferrer">the essay you linked</a> is about).</p>
<p>Trio's currently the only concurrency library for Python where control-C just works the way you expect (i.e., it raises <code>KeyboardInterrupt</code> where-ever your code is). It's a small thing, but it makes a big difference :-). For various reasons, I don't think this is fixable in asyncio.</p>
<h1>Summing up</h1>
<p>If you need to ship something to production next week, then you should use asyncio (or Twisted or Tornado or gevent, which are even more mature). They have large ecosystems, other people have used them in production before you, and they're not going anywhere.</p>
<p>If trying to use those frameworks leaves you frustrated and confused, or if want to experiment with a different way of doing things, then definitely check out trio – we're friendly :-).</p>
<p>If you want to ship something to production a year from now... then I'm not sure what to tell you. Python concurrency is in flux. Trio has many advantages at the design level, but is that enough to overcome asyncio's head start? Will asyncio being in the standard library be an advantage, or a disadvantage? (Notice how these days everyone uses <code>requests</code>, even though the standard library has <a href="https://docs.python.org/3/library/urllib.html" rel="noreferrer">urllib</a>.) How many of the new ideas in trio can be added to asyncio? No-one knows. I expect that there will be a lot of interesting discussions about this at PyCon this year :-).</p>
</div>
<span class="comment-copy">You don't have to accept that it's better. Who said you did?</span>
<span class="comment-copy">Also, if the library's interface is more convenient for some of the examples (I assume you meant interface, because what would it mean for the implementation to be more convenient?), that's probably exactly the way in which it's better. In the same way that <code>requests</code> makes a lot of things convenient that are doable but painful with <code>urllib</code>. Of course "more convenient" is subjective, but then this question is subjective in the first place.</span>
<span class="comment-copy">AIUI, the main point of curio is that by stripping things down so the public API is just tasks (rather than tasks and coroutines and futures plus an optional callback API), you lose some functionality that's sometimes useful, but make it easier to build a whole bunch of "sugar on top" that adds back in more than you've lost. It looks like <code>trio</code> (which I've never used) is basically that whole bunch of sugar. Which is cool. If you like the <code>curio</code> design but want to compose tasks in ways that take a few lines of non-trivial code, I'd probably use <code>trio</code>. If you want a future, stay away.</span>
<span class="comment-copy">The design principles are right there in the docs you linked to. And I can't see what answer anyone could give beyond linked to those same docs you already have, or adding subjective opinions on top of it, neither of which is appropriate as a SO answer. I don't think the question is downvotable, but I don't think it's answerable, either.</span>
<span class="comment-copy">My reason to choose trio: it's much easier for me to understand and reason about than the transports &amp; protocols soup.</span>
<span class="comment-copy">Thanks a lot. Sorry for late reply as it takes me some time to read your answer and references. Now I think I have understood <code>trio</code> much more, it does have advantages on design principle. In the past, I spent my spare time to understand the API design principle of <code>requests</code>, that helps me a lot on designing APIs related to network communication. Although <code>trio</code> is new-born now, learning it could improve my design on async IO. Thanks again.</span>
<span class="comment-copy">Another advantage of Trio: when you need to convert a synchronous library to Trio, often it's a simple job of sprinkling async/await everywhere you need it until the parts that require async context have it. If things are more complex, add a nursery and a couple of tasks. In my experience, Trio's concepts are easy enough to understand, and debugging Trio code is <i>much</i> easier than wrapping your head around asyncio.</span>
<span class="comment-copy">"You have futures, tasks, and coroutines..." Although I'm using asyncio for more than a year now, this zoo of similar concepts still freaks me out.</span>
<span class="comment-copy">Almost one year since this great answer (+1) - are there any major updates to make me start learning <code>trio</code> as opposed to the built-in <code>asyncio</code>?</span>
<span class="comment-copy">@n1k31t4 Trio has continued to mature, but as of Feb 2019 I think the answer is still basically accurate – Trio has a lot of theoretical advantages, but is still in the "early adopter" phase. This <a href="https://trio.discourse.group/t/priorities-roadmap/34" rel="nofollow noreferrer">recent post on the forum</a> might give you a sense of what we're working on. And for those looking for updates in the future, asking on the forum or <a href="https://gitter.im/python-trio/general" rel="nofollow noreferrer">chat</a> is a quick way to get an update.</span>
