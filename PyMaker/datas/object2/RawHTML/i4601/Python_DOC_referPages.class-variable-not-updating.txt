<div class="post-text" itemprop="text">
<p>I have the following basic class involving a circle.  My question is, when I directly update the diameter with c.diameter(10), how come the radius is updated to 5?  As the output shows, it is still at 4:</p>
<pre><code>from math import pi


class Circle:
    def __init__(self, radius=1):
        self.radius = radius
        self.diameter = self.radius * 2

    def diameter(self, diameter):
        self.diameter = diameter
        self.radius = self.diameter / 2
        return self.radius, self.diameter

    def area(self):
        return self.radius ** 2 * pi


c = Circle(3)
print("c.radius:", c.radius)
print("c.area():", c.area())
c.radius = 4  # change radius
print("c.radius:", c.radius)
print("c.area():", c.area())
c.diameter = 10  # change diameter
print("c.diameter:", c.diameter)
print("c.radius:", c.radius)
</code></pre>
<p>Output:</p>
<pre><code>c.radius: 3
c.area(): 28.274333882308138
c.radius: 4
c.area(): 50.26548245743669
c.diameter: 10
c.radius: 4   &lt;--- Radius should be 5, since the Radius is Diameter / 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have two things named <code>diameter</code>:</p>
<ul>
<li>An attribute on the instance, set with <code>self.diameter</code> in <code>__init__</code> and with <code>c.diameter = 10</code> later on.</li>
<li>A method on the class named <code>diameter</code>. This method is never accessed. You can't access it on the instance, because there the <code>diameter</code> attribute <em>masks</em> the method.</li>
</ul>
<p>On Python classes, methods are still just attributes. <code>c.area</code> returns the method object, and only <code>c.area()</code> actually calls the method.</p>
<p>So, just referencing <code>c.diameter</code> will not actually give you the method, it gives you the attribute on the instance, which is just an integer object.</p>
<p>You have two options:</p>
<ul>
<li>Rename the method, to <code>set_diameter()</code> for example.</li>
<li>Make the <code>diameter</code> attribute a <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer"><em>property</em> object</a>. Properties are used <em>as you would an attribute</em>, but getting or setting the attribute on an instance triggers methods to be called.</li>
</ul>
<p>The latter option is the 'pythonic' option, the method experienced Python developers would use:</p>
<pre><code>class Circle:
    def __init__(self, radius=1):
        self.radius = radius

    @property
    def diameter(self):
        return self.radius * 2

    @diameter.setter
    def diameter(self, value):
        self.radius = value / 2

    def area(self):
        return self.radius ** 2 * pi
</code></pre>
<p>The <code>@property</code> / <code>@diameter.setter</code> pair of decorators define the getter and setter for the property; the first <code>def diameter</code> is called whenever you want to <em>read</em> (<em>get</em>) the value of the attribute, and the second is used when <em>writing</em> called when you try to assign a new value (the <em>setter</em>):</p>
<pre><code>&gt;&gt;&gt; c = Circle(3)
&gt;&gt;&gt; c.diameter
6
&gt;&gt;&gt; c.diameter = 4
&gt;&gt;&gt; c.radius
2.0
&gt;&gt;&gt; c.diameter
4.0
</code></pre>
<p>Note that we never set an attribute named <code>diameter</code> in the setter! The value is instead always calculated when you access <code>c.diameter</code> for reading.</p>
<p>You'll also notice that when you assign an integer to the <code>diameter</code> attribute, that the radius becomes a <code>float</code> value; that's because the <code>/</code> operator always produces a float value, even for integer inputs. Use <code>//</code> (floor division), if you always must have an integer.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way is to use properties with according setters to make sure you update your internal data: </p>
<p>Something like this:</p>
<pre><code>from math import pi


class Circle:
    def __init__(self, radius=1):
        self._radius = radius
        self._diameter = radius * 2

    @property
    def diameter(self):
        return self._diameter

    @diameter.setter
    def diameter(self, diameter):
        self._diameter = diameter
        self._radius = diameter / 2

    @property  
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, radius):
        self._radius = radius
        self._diameter = radius * 2

    def area(self):
        return self.radius ** 2 * pi

if __name__ == "__main__":
    c = Circle(3)
    print("c.radius:", c.radius)
    print("c.area():", c.area())
    c.radius = 4  # change radius
    print("c.radius:", c.radius)
    print("c.area():", c.area())
    c.diameter = 10  # change diameter
    print("c.diameter:", c.diameter)
    print("c.radius:", c.radius)
</code></pre>
</div>
<span class="comment-copy">Why do you have both a method named <code>diameter</code> and an attribute named <code>diameter</code>? The latter will mask the method, you can't have both.</span>
<span class="comment-copy">Flagged as a simple typographical error.</span>
<span class="comment-copy">You should do <code>c.diameter(10)</code> instead of <code>c.diameter = 10</code> (which just updates the <code>diameter</code> attribute and nothing else)</span>
<span class="comment-copy">@Drise: it is not, they have <b>two</b> problems.</span>
<span class="comment-copy">@LaurentH.:  <code>c.diameter(10)</code> instead of <code>c.diameter = 10</code> won't work because the class's diameter method is hidden by the object's attribute of the same name.  He would have to do <code>Circle.diameter(c, 10)</code> to make the call work (which doesn't solve the problem so much as illustrate it).</span>
