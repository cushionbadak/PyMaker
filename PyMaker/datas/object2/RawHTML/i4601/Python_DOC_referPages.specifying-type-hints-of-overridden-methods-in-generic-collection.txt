<div class="post-text" itemprop="text">
<p>I have defined an abstract base class <code>BaseRepository</code> that acts as a collection of items with specified supertype <code>Foo</code>. 
The convenience classmethods in <code>BaseRepository</code> are annotated/type hinted to work with objects of type <code>Foo</code>. Here is a minimal example:</p>
<pre><code>from abc import ABCMeta, abstractmethod
NoReturn = None

class Foo(object):
    pass  # simple data holding object


class BaseRepository(object, metaclass=ABCMeta):

    # May be filled with subtypes of `Foo` later
    _items = None  # type: List[Foo]

    @classmethod
    def get_item(cls) -&gt; Foo:
        return cls._items[0]

    @classmethod
    @abstractmethod
    def _load_items(cls) -&gt; NoReturn:
        pass
</code></pre>
<p>Now there are multiple static implementations (e.g. <code>SubRepository</code>) which are each supposed to work with their own type of items (like <code>Bar</code>), being subclasses of the original generic type <code>Foo</code>.</p>
<pre><code>class Bar(Foo):
    pass  # Must implement Foo in order for BaseRepository's methods to work

def load_some_bars():
    return [Bar(),Bar()]

class SubRepository(BaseRepository):
    # Inherits `get_item` from BaseRepository

    @classmethod
    def _load_items(cls) -&gt; NoReturn:
        cls._items = load_some_bars()
</code></pre>
<p>The repositories are static, meaning that they are not instantiated but rather function as namespaces for proper access to items that I load from YAML configuration files. The main perk is that I can create one of these <code>SubRepositories</code> and simply override the deserialization method <code>_load_items</code>, and the resulting repository will have all convenience methods from the base class. As I need to ensure that all of these <code>SubRepositories</code> work with items <code>Foo</code> that have a specific interface in order for the <code>BaseRepository</code> methods function properly, the <code>SubRepositories</code> must work with items that inherit from <code>Foo</code>.</p>
<p>Strongly-typed languages like Java or C# have the concept of <strong>Generic Collections</strong>, where the elements in the subclassed collections all assume a specific type. 
Is the same possible with type hinting in Python?
In particular, I would like the inherited <code>get_item</code> method in <code>SubRepository</code> to be hinted as <code>Bar</code> with minimal effort (not override it just for the sake of type hints). Optimally, the correct return value should be linted by PyCharm.</p>
<p>Currently, even though <code>SubRepository</code> holds <code>Bar</code> items, my autocompletion in PyCharm only shows me members of <code>Foo</code>. </p>
<p>I read about <code>typing.Generic</code> and <code>TypeVar</code>, but I'm unsure how to use them in this case.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're programming to an interface, so only <code>Foo</code> members are exposed.</p>
<pre><code>from typing import get_type_hints
print(get_type_hints(SubRepository.get_item))
</code></pre>
<p>Output:</p>
<pre><code>{'return': &lt;class '__main__.Foo'&gt;}
</code></pre>
<p>A generic collection will expose the generic type's members.</p>
<pre><code>from typing import TypeVar, Generic, get_type_hints
from abc import ABCMeta, abstractmethod
NoReturn = None

# type variable with an upper bound
T = TypeVar('T', bound=Foo)

class BaseRepository(Generic[T], metaclass=ABCMeta):
    _items = None  # type: List[T]

    @classmethod
    def get_item(cls) -&gt; T:
        return cls._items[0]

    @classmethod
    @abstractmethod
    def _load_items(cls) -&gt; NoReturn:
        pass

class SubRepository(BaseRepository[Bar]):
    # Inherits `get_item` from BaseRepository

    @classmethod
    def _load_items(cls) -&gt; NoReturn:
        cls._items = load_some_bars()
</code></pre>
<p>Return type</p>
<pre><code>print(get_type_hints(SubRepository.get_item))
</code></pre>
<p>Passes the buck</p>
<pre><code>{'return': ~T}
</code></pre>
<p>Autocompletion will now show members of <code>Bar</code>.</p>
</div>
<span class="comment-copy">Can you use Python v3.5+?  You might be able to work something out with the <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">typing</a> module.  I'll let my ignorance show .... Are you trying to force a paradigm from other languages into Python's ?  Do you instantiate your classes or are you using the objects themselves as containers?</span>
<span class="comment-copy">Yes, the typing solution is what I'm looking for. I read about <code>Generic[...]</code> and <code>TypeVar</code>, but am not sure how they help in this context. The objects themselves are static classes with static items, yes, as they represent config values I load from yaml files.</span>
<span class="comment-copy">To be clear,it is too much effort to override the method just for the type hint when the method suite will just be a call to the <code>super</code>'s method?. --&gt; <code>def get_item(cls) -&gt; Bar:  return super().get_item()</code></span>
<span class="comment-copy">Sure, that's my current workaround. I might also look into .pyi files which allow specifying type hints in a separate file, preventing clutter. However, I'm looking for the most idiomatic solution and I'd be amazed if there wasn't a way to get this to work now that we finally have pseudo-strong types in python ðŸ¤”. Thanks for the edits btw, appreciated.</span>
<span class="comment-copy"><code>...So if you really, really want type hints, there's really no alternative to specifying them everywhere you want them.</code> from <a href="https://stackoverflow.com/a/22389249/2823755">stackoverflow.com/a/22389249/2823755</a></span>
<span class="comment-copy">Perfect, thanks a ton! You deserve an extra cup of coffee.</span>
<span class="comment-copy">I don't have an IDE that makes use of the hints.  I didn't know if the correct type would show up for the sub-class - mine just shows <code>~T</code>.</span>
<span class="comment-copy">Works like a charm in PyCharm.</span>
