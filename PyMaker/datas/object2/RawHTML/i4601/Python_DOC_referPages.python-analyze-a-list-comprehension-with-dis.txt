<div class="post-text" itemprop="text">
<p>Recently, I had a <a href="https://stackoverflow.com/q/49408938/6914441">discussion</a> on SO (see it for the context) about the two following pieces of code:</p>
<pre><code>res = [d.get(next((k for k in d if k in s), None), s) for s in lst]
</code></pre>
<p>And:</p>
<pre><code>res = [next((v for k,v in d.items() if k in s), s) for s in lst]
</code></pre>
<p>Both iterate through strings <code>s</code> in a list <code>lst</code> and look for <code>s</code> in a dict <code>d</code>. If <code>s</code> is found, then the associated value is returned, else <code>s</code> is returned. I'm pretty sure the second piece of code is faster than the first, because (for each <code>s</code>) there is no lookup in the dictionary, just an iteration on the (key, value) pairs. </p>
<p><strong>The question is:</strong>
How to check that this is really what happens under the hood?</p>
<p>I tried, for the first time, the <code>dis</code> module, but the result was disappointing (python 3.6.3):</p>
<pre><code>&gt;&gt;&gt; dis.dis("[d.get(next((k for k in d if k in s), None), s) for s in lst]")
  1           0 LOAD_CONST               0 (&lt;code object &lt;listcomp&gt; at 0x7f8e302039c0, file "&lt;dis&gt;", line 1&gt;)
              2 LOAD_CONST               1 ('&lt;listcomp&gt;')
              4 MAKE_FUNCTION            0
              6 LOAD_NAME                0 (lst)
              8 GET_ITER
             10 CALL_FUNCTION            1
             12 RETURN_VALUE
&gt;&gt;&gt; dis.dis("[next((v for k,v in d.items() if k in s), s) for s in lst]")
  1           0 LOAD_CONST               0 (&lt;code object &lt;listcomp&gt; at 0x7f8e302038a0, file "&lt;dis&gt;", line 1&gt;)
              2 LOAD_CONST               1 ('&lt;listcomp&gt;')
              4 MAKE_FUNCTION            0
              6 LOAD_NAME                0 (lst)
              8 GET_ITER
             10 CALL_FUNCTION            1
             12 RETURN_VALUE
</code></pre>
<p>How do I get a more detailed information?</p>
<p><strong>EDIT</strong>
As suggested by @abarnert in the first comment, I tried to <code>timeit</code> both solutions. I played around with the following code:</p>
<pre><code>from faker import Faker
from timeit import timeit

fake = Faker()

d = {fake.word():fake.word() for _ in range(50000)}
lst = fake.words(500000)

def f():return [d.get(next((k for k in d if k in s), None), s) for s in lst]
def g():return [next((v for k,v in d.items() if k in s), s) for s in lst]

print(timeit(f, number=1))
print(timeit(g, number=1))

assert f() == g()
</code></pre>
<p>Maybe I missed something but, to my surprise, the first piece of code (<code>f</code>) was always faster than the second (<code>g</code>). Hence the secondary question: does anyone have an explanation?</p>
<p><strong>EDIT 2</strong> Here are the most interesting parts of the disassembled code (with a little formatting to insert the inner loop).
For <code>f</code>:</p>
<pre><code>2           0 BUILD_LIST               0
          2 LOAD_FAST                0 (.0)
    &gt;&gt;    4 FOR_ITER                36 (to 42)
          6 STORE_DEREF              0 (s)
          8 LOAD_GLOBAL              0 (d)
         10 LOAD_ATTR                1 (get)
         12 LOAD_GLOBAL              2 (next)
         14 LOAD_CLOSURE             0 (s)
         16 BUILD_TUPLE              1
         18 LOAD_CONST               0 (&lt;code object &lt;genexpr&gt; at 0x7ff191b1d8a0, file "test.py", line 2&gt;)
         2           0 LOAD_FAST                0 (.0)
               &gt;&gt;    2 FOR_ITER                18 (to 22)
                     4 STORE_FAST               1 (k)
                     6 LOAD_FAST                1 (k)
                     8 LOAD_DEREF               0 (s)
                    10 COMPARE_OP               6 (in)
                    12 POP_JUMP_IF_FALSE        2
                    14 LOAD_FAST                1 (k)
                    16 YIELD_VALUE
                    18 POP_TOP
                    20 JUMP_ABSOLUTE            2
               &gt;&gt;   22 LOAD_CONST               0 (None)
                    24 RETURN_VALUE
         20 LOAD_CONST               1 ('f.&lt;locals&gt;.&lt;listcomp&gt;.&lt;genexpr&gt;')
         22 MAKE_FUNCTION            8
         24 LOAD_GLOBAL              0 (d)
         26 GET_ITER
         28 CALL_FUNCTION            1
         30 LOAD_CONST               2 (None)
         32 CALL_FUNCTION            2
         34 LOAD_DEREF               0 (s)
         36 CALL_FUNCTION            2
         38 LIST_APPEND              2
         40 JUMP_ABSOLUTE            4
    &gt;&gt;   42 RETURN_VALUE
</code></pre>
<p>For <code>g</code>:</p>
<pre><code>3           0 BUILD_LIST               0
          2 LOAD_FAST                0 (.0)
    &gt;&gt;    4 FOR_ITER                32 (to 38)
          6 STORE_DEREF              0 (s)
          8 LOAD_GLOBAL              0 (next)
         10 LOAD_CLOSURE             0 (s)
         12 BUILD_TUPLE              1
         14 LOAD_CONST               0 (&lt;code object &lt;genexpr&gt; at 0x7ff1905171e0, file "test.py", line 3&gt;)
         3           0 LOAD_FAST                0 (.0)
               &gt;&gt;    2 FOR_ITER                22 (to 26)
                     4 UNPACK_SEQUENCE          2
                     6 STORE_FAST               1 (k)
                     8 STORE_FAST               2 (v)
                    10 LOAD_FAST                1 (k)
                    12 LOAD_DEREF               0 (s)
                    14 COMPARE_OP               6 (in)
                    16 POP_JUMP_IF_FALSE        2
                    18 LOAD_FAST                2 (v)
                    20 YIELD_VALUE
                    22 POP_TOP
                    24 JUMP_ABSOLUTE            2
               &gt;&gt;   26 LOAD_CONST               0 (None)
                    28 RETURN_VALUE
         16 LOAD_CONST               1 ('g.&lt;locals&gt;.&lt;listcomp&gt;.&lt;genexpr&gt;')
         18 MAKE_FUNCTION            8
         20 LOAD_GLOBAL              1 (d)
         22 LOAD_ATTR                2 (items)
         24 CALL_FUNCTION            0
         26 GET_ITER
         28 CALL_FUNCTION            1
         30 LOAD_DEREF               0 (s)
         32 CALL_FUNCTION            2
         34 LIST_APPEND              2
         36 JUMP_ABSOLUTE            4
    &gt;&gt;   38 RETURN_VALUE
</code></pre>
<p>One can see that (again as suggested by @abarnert) the inner loop of <code>g</code> contains some extra cost:</p>
<ol>
<li>(hidden) the construction of the 2-uples by the iterator on <code>d.items()</code></li>
<li>an <code>UNPACK_SEQUENCE 2</code> which unpacks those 2-uples and then puts <code>k</code> and <code>v</code> on the stack</li>
<li>two <code>STORE_FAST</code> which pop <code>k</code> and <code>v</code> from the stack to store them in <code>co_varnames</code>.</li>
</ol>
<p>Before it finally loads <code>k</code> to compare it with <code>s</code> as in <code>f</code>. This inner loop is iterated <code>|lst|*|d|</code> and It seems that those operations make the difference.</p>
<p>If this was optimized as I thought it was, the <code>d.items()</code> iterator would have put first <code>k</code> on the stack to test <code>k in s</code>, and then, only if <code>k in s</code> was true, put <code>v</code> on the stack for the <code>YIELD_VALUE</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You've already got all the detailed information there is about the code that <em>evaluates</em> the list comprehension.</p>
<p>But list comprehensions are equivalent to creating and then calling a function. (This is how they have their own scope, so they don't, e.g., leak loop variables into the outer scope.) So that automatically-generated function named <code>&lt;listcomp&gt;</code> is what you really want to see the code for.</p>
<p>If you want to disassemble it—well, notice that <code>LOAD_CONST 0</code> says it's loading a <code>&lt;code object &lt;listcomp&gt; at 0x7f8e302038a0</code>? That's what you want. But we can't get to it, because all we did was compile a string for the sake of disassembling it, then throw the result away, so the listcomp function isn't around anymore. </p>
<p>But it's pretty easy to see with real code:</p>
<pre><code>&gt;&gt;&gt; def f():
...     return [next((v for k,v in d.items() if k in s), s) for s in lst]
&gt;&gt;&gt; dis.dis(f)
  2           0 LOAD_CONST               1 (&lt;code object &lt;listcomp&gt; at 0x11da9c660, file "&lt;ipython-input-942-698335d58585&gt;", line 2&gt;)
              2 LOAD_CONST               2 ('f.&lt;locals&gt;.&lt;listcomp&gt;')
              4 MAKE_FUNCTION            0
              6 LOAD_GLOBAL              0 (lst)
              8 GET_ITER
             10 CALL_FUNCTION            1
             12 RETURN_VALUE
</code></pre>
<p>There's that code object const again—but now it's not just a const we compiled and immediately threw away, it's part of a function we can access.</p>
<p>How do we access it? Well, this is documented in the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> module docs, which probably isn't the first place you'd look. Functions have a code object in their <code>__code__</code> member, code objects have a sequence of constants in their <code>co_consts</code> member, and we're looking for constant #1, so:</p>
<pre><code>&gt;&gt;&gt; dis.dis(f.__code__.co_consts[1])
  2           0 BUILD_LIST               0
              2 LOAD_FAST                0 (.0)
        &gt;&gt;    4 FOR_ITER                32 (to 38)
              6 STORE_DEREF              0 (s)
              8 LOAD_GLOBAL              0 (next)
             10 LOAD_CLOSURE             0 (s)
             12 BUILD_TUPLE              1
             14 LOAD_CONST               0 (&lt;code object &lt;genexpr&gt; at 0x11dd20030, file "&lt;ipython-input-942-698335d58585&gt;", line 2&gt;)
             16 LOAD_CONST               1 ('f.&lt;locals&gt;.&lt;listcomp&gt;.&lt;genexpr&gt;')
             18 MAKE_FUNCTION            8
             20 LOAD_GLOBAL              1 (d)
             22 LOAD_ATTR                2 (items)
             24 CALL_FUNCTION            0
             26 GET_ITER
             28 CALL_FUNCTION            1
             30 LOAD_DEREF               0 (s)
             32 CALL_FUNCTION            2
             34 LIST_APPEND              2
             36 JUMP_ABSOLUTE            4
        &gt;&gt;   38 RETURN_VALUE
</code></pre>
<p>Of course you have a generator expression nested inside your list comprehension, and, as you can probably guess, that's also equivalent to creating and then calling a generator function. But that generator function's code is just as easy to find (if even more tedious to type out): <code>f.__code__.co_consts[1].co_consts[0]</code>.</p>
</div>
<span class="comment-copy">If you want to know which is faster, working through it in your head is nice, and digging into the compiled implementation is nice, but most important is to come up with some benchmark data (that's relevant to your problem) and <code>timeit</code> the different implementations. If you think you can prove that one is faster, but it turns out to be slower, then your proof is probably wrong. (Or you were right that one is log-linear and the other is linear, but it turns out that a constant factor of 150 is more important than log N for your biggest data…)</span>
<span class="comment-copy">@abarnert I'm mostly interested in the theoretical point of view. As you pointed out, the results of <code>timeit</code> will depend on the data.  But see my edit for the rest of the story.</span>
<span class="comment-copy">You might want to create a separate question to ask why <code>f</code> is faster than <code>g</code> (including a link to this, and a summary of what you found out from <code>timeit</code> and from reading the bytecode). That keeps the question narrowly-focused, and it means people who understand algorithmic questions but don't know bytecode can help answer it. Also, a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> that includes some implementation for <code>Faker</code> would mean others can repeat the test on their systems, step through what's happening, etc.</span>
<span class="comment-copy">I'll do it. Faker is <a href="https://pypi.python.org/pypi/Faker" rel="nofollow noreferrer">pypi.python.org/pypi/Faker</a></span>
<span class="comment-copy">My first guess at the performance difference is that the savings <code>g</code> gets in not doing hash table lookups are wiped out by the cost of building the extra <code>(k,v)</code> tuples. Dict lookups are <code>O(1)</code> in non-pathological cases, and the constant overhead is pretty small (for string keys, except when built with the deprecated C APIs, the hash is cached in the struct).</span>
<span class="comment-copy">Thanks for this answer and for your enlightened comments. Accepted.</span>
