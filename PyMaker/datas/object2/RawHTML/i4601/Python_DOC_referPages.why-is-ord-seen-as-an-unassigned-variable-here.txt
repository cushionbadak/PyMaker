<div class="post-text" itemprop="text">
<p>I hope it's not a duplicate (and at the same time it's difficult to tell, given the amount of questions with such errors, but which are basic mistakes), but I don't understand what happens here.</p>
<pre><code>def f():
    c = ord('a')

f()
</code></pre>
<p>runs, no error (<code>ord</code> converts character to ASCII code, it's a built-in). Now:</p>
<pre><code>if False:
    ord = None
def f():
    c = ord('a')

f()
</code></pre>
<p>Also runs, no error (<code>ord</code> isn't overwritten, condition is always false). Now:</p>
<pre><code>def f():
    if False:
        ord = None
    c = ord('a')

f()
</code></pre>
<p>I get (at line where <code>c = ord('a')</code>)</p>
<pre><code>UnboundLocalError: local variable 'ord' referenced before assignment
</code></pre>
<p>It seems that just referencing a left side operand makes it a local variable, even if the code is not run.</p>
<p>Obviously I can workaround this, but I was <em>very</em> surprised, given that the dynamic aspect of python allows you to define a variable like being an integer, and at the next line define it as a string.</p>
<p>It seems related to <a href="https://stackoverflow.com/questions/2829528/whats-the-scope-of-a-variable-initialized-in-an-if-statement">What's the scope of a variable initialized in an if statement?</a></p>
<p>Apparently the interpreter still takes notes of unreached branches when compiling to bytecode, but what happens exactly?</p>
<p>(tested on Python 2.7 and Python 3.4)</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not about the compiler doing a static analysis based on unrelated branches when compiling to bytecode; it's much simpler.</p>
<p>Python has a rule for distinguishing global, closure, and local variables. All variables that are assigned to in the function (including parameters, which are assigned to implicitly), are local variables (unless they have a <code>global</code> or <code>nonlocal</code> statement). This is explained in <a href="https://docs.python.org/3/reference/executionmodel.html#binding-of-names" rel="noreferrer">Binding and Naming</a> and subsequent sections in the reference documentation.</p>
<p>This isn't about keeping the interpreter simple, it's about keeping the rule simple enough that it's usually intuitive to human readers, and can easily be worked out by humans when it isn't intuitive. (That's especially important for cases like this—the behavior can't be intuitive everywhere, so Python keeps the rule simple enough that, once you learn it, cases like this are still obvious. But you definitely do have to learn the rule before that's true. And, of course, most people learn the rule by being surprised by it the first time…)</p>
<p>Even with an optimizer smart enough to completely remove any bytecode related to <code>if False: ord=None</code>, <code>ord</code> must still be a local variable by the rules of the language semantics.</p>
<p>So: there's an <code>ord =</code> in your function, therefore all references to <code>ord</code> are references to a local variable, not any global or nonlocal that happens to have the same name, and therefore your code is an <code>UnboundLocalError</code>.</p>
<hr/>
<p>Many people get by without knowing the actual rule, and instead use an even simpler rule: a variable is</p>
<ul>
<li>Local if it possibly can be, otherwise</li>
<li>Enclosing if it possibly can be, otherwise</li>
<li>Global if it's in globals, otherwise</li>
<li>Builtin if it's in builtins, otherwise</li>
<li>an error</li>
</ul>
<p>While this works for most cases, it can be a bit misleading in some cases—like this one. A language with LEGB scoping done Lisp-style would see that <code>ord</code> isn't in the local namespace, and therefore return the global, but Python doesn't do that. You could say that <code>ord</code> <em>is</em> in the local namespace, but bound to a special "undefined" value, and that's actually close to what happens under the covers, but that's not what the rules of Python say, and, while it may be more intuitive for simple cases, it's harder to reason through.</p>
<hr/>
<p>If you're curious how this works under the covers:</p>
<p>In CPython, the compiler scans your function to find all assignments with an identifier as a target, and stores them in an array. It removes global and nonlocal variables. This arrays ends up as your code object's <code>co_varnames</code>, so let's say your <code>ord</code> is <code>co_varnames[1]</code>. Every use of that variable then gets compiled to a <code>LOAD_FAST 1</code> or <code>STORE_FAST 1</code>, instead of a <code>LOAD_NAME</code> or <code>STORE_GLOBAL</code> or other operation. That <code>LOAD_FAST 1</code> just loads the frame's <code>f_locals[1]</code> onto the stack when interpreted. That <code>f_locals</code> starts off as an array of NULL pointers instead of pointers to Python objects, and if a <code>LOAD_FAST</code> loads a NULL pointer, it raises <code>UnboundLocalError</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just to demonstrate what's going on with the compiler:</p>
<pre><code>def f():
    if False:
        ord = None
    c = ord('a')

  4           0 LOAD_FAST                0 (ord)
              3 LOAD_CONST               1 ('a')
              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
              9 STORE_FAST               1 (c)
             12 LOAD_CONST               0 (None)
             15 RETURN_VALUE
</code></pre>
<p>Access to <code>a</code> is using <code>LOAD_FAST</code>, which is used for local variables.</p>
<p>If you set <code>ord</code> to None outside your function, <code>LOAD_GLOBAL</code> is used instead:</p>
<pre><code>if False:
    ord = None
def f():
    c = ord('a')

  4           0 LOAD_GLOBAL              0 (ord)
              3 LOAD_CONST               1 ('a')
              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
              9 STORE_FAST               0 (c)
             12 LOAD_CONST               0 (None)
             15 RETURN_VALUE
</code></pre>
</div>
<span class="comment-copy">This has been asked many times.  Local variables are determined statically by the compiler in Python.  Every name that is assigned to is marked as a local variable at compilation time.</span>
<span class="comment-copy">Putting <code>global ord</code> at the front of the function avoids the error.</span>
<span class="comment-copy">@PeterWood I'm not asking how to fix it, I was asking for an explanation.</span>
<span class="comment-copy">@Jean-FrançoisFabre I was adding missing information which goes towards part of the explanation. It's a gift horse.</span>
<span class="comment-copy">thanks anyway. I know you're trying to help.</span>
<span class="comment-copy">The part that makes the rule somewhat unintuitive is that even <code>ord += 1</code> renders <code>ord</code> a local variable, though this never makes sense unless there is yet another assignment to <code>ord</code> in the function.</span>
<span class="comment-copy">@SvenMarnach That's exactly why the "simple enough to be easily worked out in cases where it isn't intuitive" part is so important. You do have to learn the rule, but once you do, it's very hard to get it wrong.</span>
<span class="comment-copy">For what it's worth, I think this rule is necessary since local variables are accessed by index rather than by a dictionary lookup (which is used for global variables).  Otherwise Python could simply do a dynamic lookup – first look in the local scope, then look in the enclosing scopes if the name isn't found.  Since local variables are looked up by index rather than by name, the compiler <i>needs</i> to determine statically what variables are local, since it needs to create different byte code for lookup by index than for lookup by name.</span>
<span class="comment-copy">@SvenMarnach Python isn't actually required to use "fast locals". In fact, in 2.x, the way the <code>locals</code> function is defined, it really <i>can't</i> use "fast locals", and the hacks to make it work anyway (like FastToLocals/LocalsToFast around any <code>exec</code>) don't quite work reliably, so CPython 2.x doesn't really implement the Python 2.x reference. That's why 3.x <code>locals</code> is explicitly limited in its usefulness.</span>
<span class="comment-copy">@SvenMarnach That being said, understanding what CPython does under the covers (and has done since somewhere around 1.something when there was no real reference documentation yet) is definitely helpful, especially to someone coming at this from a Lisp intuition, so I added a section about that.</span>
<span class="comment-copy">I think it would be worth adding an short explanation of what <code>LOAD_FAST</code> vs. <code>LOAD_GLOBAL</code> actually does. I tried to cram one into one sentence in my answer, but your answer, there should be room to do it more clearly. (Also, you can probably write more concisely than me...)</span>
