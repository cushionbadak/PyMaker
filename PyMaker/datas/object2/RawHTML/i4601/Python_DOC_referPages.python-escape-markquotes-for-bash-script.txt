<div class="post-text" itemprop="text">
<p>When using os.system() it's often necessary to escape filenames and other arguments passed as parameters to commands.  How can I do this?  Preferably something that would work on multiple operating systems/shells but in particular for bash.</p>
<p>I'm currently doing the following, but am sure there must be a library function for this, or at least a more elegant/robust/efficient option:</p>
<pre><code>def sh_escape(s):
   return s.replace("(","\\(").replace(")","\\)").replace(" ","\\ ")

os.system("cat %s | grep something | sort &gt; %s" 
          % (sh_escape(in_filename), 
             sh_escape(out_filename)))
</code></pre>
<p><em>Edit:</em> I've accepted the simple answer of using quotes, don't know why I didn't think of that; I guess because I came from Windows where ' and " behave a little differently.</p>
<p>Regarding security, I understand the concern, but, in this case, I'm interested in a quick and easy solution which os.system() provides, and the source of the strings is either not user-generated or at least entered by a trusted user (me).</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what I use:</p>
<pre><code>def shellquote(s):
    return "'" + s.replace("'", "'\\''") + "'"
</code></pre>
<p>The shell will always accept a quoted filename and remove the surrounding quotes before passing it to the program in question. Notably, this avoids problems with filenames that contain spaces or any other kind of nasty shell metacharacter.</p>
<p><strong>Update</strong>: If you are using Python 3.3 or later, use <a href="http://docs.python.org/dev/library/shlex.html#shlex.quote" rel="noreferrer">shlex.quote</a> instead of rolling your own.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/shlex.html#shlex.quote" rel="noreferrer"><code>shlex.quote()</code></a> does what you want since python 3.</p>
<p>(Use <a href="https://docs.python.org/2/library/pipes.html#pipes.quote" rel="noreferrer"><code>pipes.quote</code></a> to support both python 2 and python 3)</p>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps you have a specific reason for using <code>os.system()</code>. But if not you should probably be using the <a href="https://docs.python.org/library/subprocess.html" rel="noreferrer"><code>subprocess</code> module</a>. You can specify the pipes directly and avoid using the shell.</p>
<p>The following is from <a href="http://www.python.org/dev/peps/pep-0324/" rel="noreferrer">PEP324</a>:</p>
<blockquote>
<pre><code>Replacing shell pipe line
-------------------------

output=`dmesg | grep hda`
==&gt;
p1 = Popen(["dmesg"], stdout=PIPE)
p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
output = p2.communicate()[0]
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Maybe <code>subprocess.list2cmdline</code> is a better shot?</p>
</div>
<div class="post-text" itemprop="text">
<p>Note that pipes.quote is actually broken in Python 2.5 and Python 3.1 and not safe to use--It doesn't handle zero-length arguments.</p>
<pre><code>&gt;&gt;&gt; from pipes import quote
&gt;&gt;&gt; args = ['arg1', '', 'arg3']
&gt;&gt;&gt; print 'mycommand %s' % (' '.join(quote(arg) for arg in args))
mycommand arg1  arg3
</code></pre>
<p>See <a href="http://bugs.python.org/issue7476" rel="nofollow noreferrer">Python issue 7476</a>; it has been fixed in Python 2.6 and 3.2 and newer.</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe that os.system just invokes whatever command shell is configured for the user, so I don't think you can do it in a platform independent way.  My command shell could be anything from bash, emacs, ruby, or even quake3.  Some of these programs aren't expecting the kind of arguments you are passing to them and even if they did there is no guarantee they do their escaping the same way.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Notice</strong>: This is an answer for Python 2.7.x.</p>
<p>According to the <a href="https://hg.python.org/cpython/file/2.7/Lib/pipes.py#l262" rel="nofollow noreferrer">source</a>, <code>pipes.quote()</code> is a way to "<em>Reliably quote a string as a single argument for <strong>/bin/sh</strong></em></p></div>
<div class="post-text" itemprop="text">
<p>The function I use is:</p>
<pre><code>def quote_argument(argument):
    return '"%s"' % (
        argument
        .replace('\\', '\\\\')
        .replace('"', '\\"')
        .replace('$', '\\$')
        .replace('`', '\\`')
    )
</code></pre>
<p>that is: I always enclose the argument in double quotes, and then backslash-quote the only characters special inside double quotes.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you do use the system command, I would try and whitelist what goes into the os.system() call.. For example..</p>
<pre><code>clean_user_input re.sub("[^a-zA-Z]", "", user_input)
os.system("ls %s" % (clean_user_input))
</code></pre>
<p>The subprocess module is a better option, and I would recommend trying to avoid using anything like os.system/subprocess wherever possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>The real answer is: Don't use <code>os.system()</code> in the first place. Use <a href="http://docs.python.org/2/library/subprocess.html#subprocess.call" rel="nofollow"><code>subprocess.call</code></a> instead and supply the unescaped arguments.</p>
</div>
<span class="comment-copy">Beware of the security issue! For instance if out_filename is foo.txt; rm -rf / The malicious user can add more command directly interpreted by the shell.</span>
<span class="comment-copy">This is also useful without os.system, in situations where subprocess isn't even an option; e.g. generating shell scripts.</span>
<span class="comment-copy">An ideal <code>sh_escape</code> function would escape out the <code>;</code> and spaces and remove the security problem by simply creating a file called something like <code>foo.txt\;\ rm\ -rf\ /</code>.</span>
<span class="comment-copy">In almost all cases, you should use subprocess, not os.system. Calling os.system is just asking for an injection attack.</span>
<span class="comment-copy">@pixelbeat: which is exactly why he closes his single quotes, adds an escaped literal single quote, and then reopens his single quotes again.</span>
<span class="comment-copy">While this is hardly the responsibility of the shellquote function, it might be interesting to note that this will still fail if an unquoted backslash appears just before the return value of this function. Morale: make sure you use this in code that you can trust as safe - (such as part of hardcoded commands) - don't append it to other unquoted user input.</span>
<span class="comment-copy">Note that unless you absolutely need shell features, you should probably be using Jamie's suggestion instead.</span>
<span class="comment-copy">Something similar to this is now officially available as <a href="http://docs.python.org/dev/library/shlex.html#shlex.quote" rel="nofollow noreferrer">shlex.quote</a>.</span>
<span class="comment-copy">@lhunath completely wrong on both counts. This is the perfect and proper way to escape a word for POSIX shell (note the wording “a word”, the command structure is up to the user, but trivial to do). Passing as list does not help e.g. after an <code>ssh</code> command, since you need to escape multiple levels then…</span>
<span class="comment-copy">There's also <code>commands.mkarg</code>. It also adds a leading space (outside the quotes) which may or may not be desirable.It's interesting how their implementations are quite different from each other, and also much more complicated than Greg Hewgill's answer.</span>
<span class="comment-copy">For some reason, <code>pipes.quote</code> is not mentioned by the <a href="http://docs.python.org/library/pipes.html" rel="nofollow noreferrer">standard library documentation for the pipes module</a></span>
<span class="comment-copy">Both are undocumented; <code>command.mkarg</code> is deprecated and removed in 3.x, while pipes.quote remained.</span>
<span class="comment-copy">Correction: officially documented as <a href="http://docs.python.org/dev/py3k/library/shlex.html#shlex.quote" rel="nofollow noreferrer"><code>shlex.quote()</code></a> in 3.3 , <code>pipes.quote()</code> retained for compatibility.  [<a href="http://bugs.python.org/issue9723]" rel="nofollow noreferrer">bugs.python.org/issue9723]</a></span>
<span class="comment-copy">pipes does NOT work on Windows - adds single quotes insted of double quotes.</span>
<span class="comment-copy"><code>subprocess</code> (especially with <code>check_call</code> etc) is often dramatically superior, but there are a few cases where shell escaping is still useful. The main one I'm running into is when I'm having to invoke ssh remote commands.</span>
<span class="comment-copy">@CraigRinger, yup, ssh remoting is what brought me here.  :P  I wish ssh had something to help here.</span>
<span class="comment-copy">@JürgenA.Erhard It does seem odd that it doesn't have an --execvp-remote option (or work that way by default). Doing everything through the shell seems clumsy and risky. OTOH, ssh is full of weird quirks, often things done in a narrow view of "security" that causes people to come up with way-more-insecure workarounds.</span>
<span class="comment-copy">That looks pretty good. Interesting it isn't documented... (in <a href="http://docs.python.org/library/subprocess.html" rel="nofollow noreferrer">docs.python.org/library/subprocess.html</a> at least)</span>
<span class="comment-copy">It does not properly escape \: <code>subprocess.list2cmdline(["'",'',"\\",'"'])</code> gives <code>' "" \ \"</code></span>
<span class="comment-copy">It does not escape shell expansion symbols</span>
<span class="comment-copy">Is subprocess.list2cmdline() intended only for Windows?</span>
<span class="comment-copy">What version of Python are you using? Version 2.6 seems to produce the correct output: mycommand arg1 '' arg3  (Those are two single-quotes together, though the font on Stack Overflow makes that hard to tell!)</span>
<span class="comment-copy">2.6 works for me (<a href="http://bugs.python.org/issue7476" rel="nofollow noreferrer">bugs.python.org/issue7476</a>), 3.1 returns empty string.</span>
<span class="comment-copy">It's not unreasonable to expect a mostly or fully POSIX-compliant shell (at least everywhere but with Windows, and you know what "shell" you have then, anyway).  os.system doesn't use $SHELL, at least not here.</span>
<span class="comment-copy">Note that you should use '\\"', '\\$' and '\`', otherwise the escaping doesn't happen.</span>
<span class="comment-copy">Additionally, <a href="http://bugs.python.org/issue22187" rel="nofollow noreferrer">there are issues with using double quotes in some (weird) locales</a>; the suggested fix uses <code>pipes.quote</code> which @JohnWiseman pointed out is also broken.  Greg Hewgill’s answer is thus the one to use. (It’s also the one the shells use internally for the regular cases.)</span>
<span class="comment-copy">The question contains an example where subprocess just fails.  If you can use subprocess, you should, sure.  But if you can't... subprocess is not a solution for <i>everything</i>.  Oh, <i>and</i> your answer doesn't answer the question at all.</span>
<span class="comment-copy">@JürgenA.Erhard doesn't the OP's example fail because he wants to use shell pipes? You should always use subprocess <i>because</i> it doesn't use a shell. <a href="http://stackoverflow.com/a/9164238/1695680">This is a bit clumsy of an example</a>, but you can do pipes in native subprocesses, there are a few pypi packages that try to make this easier. I tend to just do the post-processing I need in python as much as possible, You can always make your own StringIO buffers and control things pretty completely with subprocesses.</span>
