<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/47444780/can-a-function-be-static-and-non-static-in-python-2">can a function be static and non-static in python 2</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I have a Python class that I created previously, it looks something like this:</p>
<pre><code>class Foo:
  @classmethod
  def bar(cls, x):
    print(x + 3)

Foo.bar(7)  # prints '10'
</code></pre>
<p>Now I would like to retrofit this interface with some state, so that the caller can create a <code>Foo</code> object, give it some properties, and then call its <code>bar()</code> method, which has access to <code>self</code> and its properties:</p>
<pre><code>class Foo:
  def __init__(self, y=3):
    self.y = y
  def bar(self, x):
    print(x + self.y)

Foo().bar(7)  # prints '10'
Foo(20).bar(7)  # prints '27'
</code></pre>
<p>Unfortunately, this breaks the previous interface - <code>Foo.bar(7)</code> will now give <code>TypeError: bar() missing 1 required positional argument: 'x'</code>, because <code>Foo.bar(...)</code> is a simple function reference.</p>
<p>I can add a <code>@classmethod</code> decorator to get part way there:</p>
<pre><code>class Foo:
  def __init__(self, y=3):
    self.y = y
  @classmethod
  def bar(cls, x):
    self = cls()
    print(x + self.y)

Foo.bar(7)  # prints '10'
Foo().bar(7)  # prints '10'
Foo(20).bar(7)  # prints '10', but I want '27'
</code></pre>
<p>Is it possible to create a <code>@flexmethod</code> decorator that converts the other direction?  Specifically - if called as an instance method like <code>Foo(20).bar(...)</code>, then do nothing; if called as a class method like <code>Foo.bar(...)</code> then create a new <code>Foo</code> object (using no-arg constructor) and pass that as the <code>self</code> argument.</p>
<p>I was going to try this myself by looking at the source for <code>@classmethod</code>, but it looks like it's implemented at the C level.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods" rel="nofollow noreferrer">Descriptor HOWTO</a> has entire section on how <code>@classmethod</code> and <code>@staticmethod</code> work, and how to implement variations on them, including this pure-Python equivalent to <code>classmethod</code>:</p>
<pre><code>class ClassMethod(object):
    "Emulate PyClassMethod_Type() in Objects/funcobject.c"

    def __init__(self, f):
        self.f = f

    def __get__(self, obj, klass=None):
        if klass is None:
            klass = type(obj)
        def newfunc(*args):
            return self.f(klass, *args)
        return newfunc
</code></pre>
<p>If it isn't obvious to you how that works, you probably need to read the whole HOWTO. I've got <a href="http://stupidpythonideas.blogspot.com/2013/06/how-methods-work.html" rel="nofollow noreferrer">a blog post</a> that tries to provide an introduction to the method-related stuff first, which may help get over the abstraction hump of the first part of the HOWTO.</p>
</div>
<span class="comment-copy">The question marked as an "exact duplicate" is not the same - that one is (in my terms) how to get <code>Foo(20).bar(7)</code> and <code>Foo.bar(20, 7)</code> to behave the same, mine is about <code>Foo(20).bar(7)</code> and <code>Foo.bar(7)</code>.  The distinction is important because the whole point is to keep the existing interface <code>Foo.bar(7)</code>.</span>
<span class="comment-copy">Just realized - even though the <i>question</i> isn't the same, @user2357112's solution includes a solution to my problem as well.  I'll give it a shot when I get to work tomorrow.</span>
<span class="comment-copy">Thanks, I'll try to work with that and see if I can come up with something.  If I do, I'll post it as a new answer.</span>
