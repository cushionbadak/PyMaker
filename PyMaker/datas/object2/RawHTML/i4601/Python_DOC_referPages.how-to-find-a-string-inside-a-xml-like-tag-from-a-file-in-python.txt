<div class="post-text" itemprop="text">
<p>I have a RDF document, which looks like as follows:</p>
<pre><code>&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
 xmlns:cd="http:xyz.com#"&gt;

&lt;rdf:Description rdf:about="http:xyz.com#"&gt;
    &lt;cd:algorithmid&gt;DPOT-5ab247867d368&lt;/cd:algorithmid&gt;
    &lt;cd:owner&gt;arun&lt;/cd:owner&gt;
    &lt;cd:acesskey&gt;ACCESS-5ab247867d370&lt;/cd:acesskey&gt;
    &lt;cd:purpose&gt;Research&lt;/cd:purpose&gt;
    &lt;cd:metadata&gt;10&lt;/cd:metadata&gt;
    &lt;cd:completeness&gt;Partial&lt;/cd:completeness&gt;
    &lt;cd:completeness&gt;Yes&lt;/cd:completeness&gt;
    &lt;cd:inclusion_1&gt;age&lt;/cd:inclusion_1&gt;
    &lt;cd:feature_1&gt;Sex&lt;/cd:feature_1&gt;
    &lt;cd:target&gt;Diagnosis&lt;/cd:target&gt;
&lt;/rdf:Description&gt;

&lt;/rdf:RDF&gt; 
</code></pre>
<p>From the above texts, I need to extract the target (i.e. only the value inside the opening and closing "cd:target" tag). The desired output should be 'Diagnosis'. I tried with XML parser but it does not work because of the tree contains ':'. Any better solution, please? </p>
<p>Update: This is the I tried, sorry for naive coding style. </p>
<pre><code>import xml.etree.ElementTree as et

def metadataParser(metadataFile):
    with open(metadataFile, 'r') as m:
        data = m.read() 
        # Load the xml content from a string
        content = et.fromstring(data)       
        description = content.find('rdf:Description')
        target = description.find("cd:target")

    return target   


target = metadataParser('metadata.rdf')
print(target)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>cd:</code> part is a <em>namespace</em>.  They're pretty common in XML, and just about any XML parser has a way to handle them.</p>
<p>Otherwise, if you are just looking for a single item and you don't care about structure, you could just do a simple string search and grab everything between <code>&lt;cd:target&gt;</code> and <code>&lt;/cd:target&gt;</code>, like so:</p>
<pre><code>rdf = '''rdf xml document'''
open_tag = '&lt;cd:target&gt;'
close_tag = '&lt;/cd:target&gt;'
start = rdf.find(open_tag)
end = rdf.find(close_tag)
value = rdf[start + len(open_tag):end]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="nofollow noreferrer"><strong><code>BeautifulSoup</code></strong></a> module with its <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-a-parser" rel="nofollow noreferrer">XML parser</a>.</p>
<pre><code>from bs4 import BeautifulSoup

XML = '''
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
 xmlns:cd="http:xyz.com#"&gt;

&lt;rdf:Description rdf:about="http:xyz.com#"&gt;
    &lt;cd:algorithmid&gt;DPOT-5ab247867d368&lt;/cd:algorithmid&gt;
    &lt;cd:owner&gt;arun&lt;/cd:owner&gt;
    &lt;cd:acesskey&gt;ACCESS-5ab247867d370&lt;/cd:acesskey&gt;
    &lt;cd:purpose&gt;Research&lt;/cd:purpose&gt;
    &lt;cd:metadata&gt;10&lt;/cd:metadata&gt;
    &lt;cd:completeness&gt;Partial&lt;/cd:completeness&gt;
    &lt;cd:completeness&gt;Yes&lt;/cd:completeness&gt;
    &lt;cd:inclusion_1&gt;age&lt;/cd:inclusion_1&gt;
    &lt;cd:feature_1&gt;Sex&lt;/cd:feature_1&gt;
    &lt;cd:target&gt;Diagnosis&lt;/cd:target&gt;
&lt;/rdf:Description&gt;

&lt;/rdf:RDF&gt;'''

soup = BeautifulSoup(XML, 'xml')

target = soup.find('target').text
print(target)
# Diagnosis
</code></pre>
<p>As you can see, it's pretty easy to use.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>rdf:</code> and <code>cd:</code> are namespace tags. They need to be replaced in your search with the actual namespace identifiers, like so:</p>
<pre><code>description = content.find('{http://www.w3.org/1999/02/22-rdf-syntax-ns#}Description')
target = description.find("{http:xyz.com#}target")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the following regex: this will get all the data from within all of the 'cd' tags in your file..</p>
<pre><code>import re

with open("file.rdf", "r") as file:

    for lines in file:
        pattern = "&lt;cd:.*&gt;(.*)&lt;/cd:.*&gt;"
        output = re.findall(pattern, lines)
        if len(output) != 0:
            print(output[0])
</code></pre>
<p>And this outputs:</p>
<pre><code>DPOT-5ab247867d368
arun
ACCESS-5ab247867d370
Research
10
Partial
Yes
age
Sex
Diagnosis
</code></pre>
<p>Explaination of the <code>pattern</code> variable:</p>
<ul>
<li>the first <code>.*</code> tells the script that we want ANY characters that are in this space</li>
<li><code>(.*)</code> tells the script that this is the section we want to capture</li>
<li>And the last <code>.*</code> does pretty much the same as before, searches for ANY character.</li>
</ul>
<p>Note: I have involved a if statement to check if the output (which is in list form) contains any elements, if not, it excludes it from the output. (for example your heading RDF elements will be excluded).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a dictionary holding the namespace mappings seen at the top:</p>
<pre><code>import xml.etree.ElementTree as ET
import csv


tree = ET.parse('input.xml')
ns = {'rdf' : 'http://www.w3.org/1999/02/22-rdf-syntax-ns#', 'cd' : 'http:xyz.com#'}

description = tree.find('rdf:Description', ns)
target = description.find('cd:target', ns)

print(target.text)
</code></pre>
<p>This would display:</p>
<pre><code>Diagnosis
</code></pre>
<p>This approach is described in the Python <a href="https://docs.python.org/3/library/xml.etree.elementtree.html?highlight=xml#parsing-xml-with-namespaces" rel="nofollow noreferrer">xml.etree.ElementTree</a> documentation.</p>
</div>
<span class="comment-copy">Hey, thanks. I will with that.</span>
<span class="comment-copy">The tree containing <code>:</code> doesn’t mean you don’t want an XML parser, it means using an XML parser is even <i>more</i> important. But you need to tell your parser to process the namespace, or manually process it in your head and write explicitly-namespaced queries. Show us a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> that demonstrates which parser you tried to use and how you tried to use it and what “does not work” actually means, and we can explain how to fix your code.</span>
<span class="comment-copy">Also, even if you do want to parse this with simple string operations or regular expressions (which you really don’t want to do(, what does “without a delimiter” mean? Surely you need to split or match on something like (at minimum) <code>target&gt;</code> through the next <code>&lt;/</code> to distinguish the part you’re looking for from other parts. What other rule could make sense?</span>
<span class="comment-copy">Hey, thanks. I can do it with the 'sed' command of UNIX but I need to do the same in Python.</span>
<span class="comment-copy">See my updated answer.</span>
<span class="comment-copy">I never used it, though. But it looks pretty easier and works perfectly! Thanks so much.</span>
<span class="comment-copy">If you want to parse even bigger documents, this module will help you a lot. You won't have to use regex or define custom tags. Just go through the docs (link in answer). Even though the docs are explained with HTML, it's the same for XML.</span>
<span class="comment-copy">Well, in my use case string = "&lt;cd:target&gt;Diagnosis&lt;/cd:target&gt;" is not static but changes each -i.e. the value. Otherwise, I could use this approach too. Anyway, thanks so much.</span>
<span class="comment-copy">Edited. Check my new answer</span>
