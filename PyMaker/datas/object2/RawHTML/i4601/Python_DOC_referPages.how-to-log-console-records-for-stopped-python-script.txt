<div class="post-text" itemprop="text">
<p>I have the following code inside my script to create a log of console records every time the scrip is run:</p>
<pre><code>class Logger(object):
    def __init__(self):
        pathLogs = 'logs/'
        if not os.path.isdir(pathLogs):
            os.makedirs(pathLogs)
        date_stamp = str(datetime.datetime.now()).split('.')[0]
        date_stamp = date_stamp.replace(" ", "_").replace(":", "")
        file_name = pathLogs + date_stamp + ".log"
        self.terminal = sys.stdout
        self.log = open(file_name, "a")

    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)
sys.stdout = Logger()
</code></pre>
<p>It works fine when the script's run finishes by itself, but if you interrupt it, no records that you see in the console get saved in a log file. How can I save records in a log file every time the script is run regardless if it was interrupted or not?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think what you are looking for is the <a href="https://docs.python.org/2/library/signal.html" rel="nofollow noreferrer">signal module</a>.</p>
<p>Let's say you're interrupting your code by pressing CTRL+C. What you need to do to perform anything after the interuption signal is received is the following:</p>
<pre><code>import signal
import sys

def my_callback(signal, frame):

    # Do your stuff...
    print("I have been killed!")
    sys.exit(0)

signal.signal(signal.SIGINT, my_callback)  # this is your handler
</code></pre>
<p>Basically, what happens is, as soon as CTRL+C is received (= the <code>SIGINT</code> signal), your callback is called and does whatever you want it to do.</p>
<p>For more details, as always, the <code>signal</code> <a href="https://docs.python.org/2/library/signal.html" rel="nofollow noreferrer">doc</a> is really clear and helpful.
Hope this helps!</p>
</div>
<span class="comment-copy">Python comes with its own <a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer"><code>logging</code></a> module that probably does everything you want, and has already solved most of the problems you're likely to run into. If there's a reason you can't use it, that's fine, but if you just didn't know about it, you should consider using it instead.</span>
<span class="comment-copy">Meanwhile, normal file I/O is buffered. You probably want to either disable buffering on your logfile, or explicitly <code>flush</code> it after each <code>write</code> (either in your <code>write</code> method, or via a separate API that your calling code can use). This will, however, slow things down. If that's not acceptable, you need to make sure to do it at shutdown—via a <code>__del__</code> method, or an <code>atexit</code> function, or  a signal handler. Or you can just add a <code>close</code> method and have your top-level code ensure that it gets called—e.g., with a <code>try:</code> <code>finally: logger.close()</code> around the main program.</span>
