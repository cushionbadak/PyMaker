<div class="post-text" itemprop="text">
<p>I have a personal project using Raspberry Pi and two condenser mics. I am using the following listeners on each mic:</p>
<pre><code>GPIO.add_event_detect(mic1, GPIO.BOTH, bouncetime=500)
GPIO.add_event_callback(mic1, soundHeard)

GPIO.add_event_detect(mic2, GPIO.BOTH, bouncetime=500)
GPIO.add_event_callback(mic2, soundHeard)
</code></pre>
<p>When a sound is detected (I'm using digital trigger on the mics), the event sends in the pin number to the callback. I use the pin number to run a function. While that function is running, for approximately 10 seconds, I want both events to stop triggering completely until the function hands back control. Currently, the listeners keep sending in events and those events seem to be stacking above the function and then all run serially once the function has finished.</p>
<p>I have tried using global variables with timestamps and various other methods to stop the event listeners to no avail. If I try to turn off the listeners and turn them back on I get Segmentation fault errors. Any help on this appreciated,</p>
<p>cheers,</p>
<p>Wittner</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://sourceforge.net/p/raspberry-gpio-python/wiki/Inputs/" rel="nofollow noreferrer">docs on SOURCE<strong>FORGE</strong></a> (just above the section: <em>Switch Debounce</em>):</p>
<p><em>"Note that in this case, the callback functions are run sequentially, not concurrently. This is because there is only one thread used for callbacks, in which every callback is run, in the order in which they have been defined."</em></p>
<p>I would try to sidestep this behavior by wrapping your callback in a function that creates a new thread to handle each event thereby letting the callback itself return immediately. I would then use a <a href="https://docs.python.org/3/library/threading.html#lock-objects" rel="nofollow noreferrer"><code>threading.Lock</code></a> so that any events triggered during the evaluation of the first event are immediately thrown out instead of trying to unbind and re-bind the callback.</p>
<pre><code>from threading import Thread, Lock

def callback_dispatcher(fun):
    def wrapped(*args):
        t = Thread(target=fun, args=args)
        t.start()
    return wrapped

#lock is defined in main thread so all child threads will have a copy of the same object
soundHeard_lock = Lock()

def soundHeard(channel):
    if soundHeard_lock.acquire(False): #False so Lock.acquire() is non-blocking 
                                       # otherwise calling lock.acquire will wait until the 
                                       # lock is freed by whatever thread currently owns it
        #if the lock is successfully acquired (no other thread has ownership currently
        try:
            #handle event
        finally: #we want to release the lock even if something else goes wrong
            soundHeard_lock.release()
    #else: #do nothing, we didn't get ownership of the lock

GPIO.add_event_detect(mic1, GPIO.BOTH, bouncetime=500)
GPIO.add_event_callback(mic1, callback_dispatcher(soundHeard))

GPIO.add_event_detect(mic2, GPIO.BOTH, bouncetime=500)
GPIO.add_event_callback(mic2, callback_dispatcher(soundHeard))
</code></pre>
<p><strong>**EDIT</strong> for clarity</p>
<p>I made the <code>callback_dispatcher</code> function a little more complex than it needed to be for your situation in favor of making it more general purpose. A simpler version could call your <code>soundHeard</code> function directly with a thread without creating a closure (function defined within a function).</p>
<pre><code>def soundHeard_thread(*args) #replaces callback_dispatcher
    # *args uses tuple packing to pass along any args provided by the event
    #   this is a very powerful tool that you should definitely learn to leverage
    #   if you want to take your python to the next level. A quick google search
    #   gave me this tutorial: https://www.geeksforgeeks.org/packing-and-unpacking-arguments-in-python/
    t = Thread(target=soundHeard, args=args) 
    t.start()

#...

GPIO.add_event_callback(mic1, soundHeard_thread)</code></pre>
</div>
<span class="comment-copy">When you enter your callback, test if the time since the last activation is less than 10s and just return if it is. Else save the current time in a static (persistent) variable as the time of last activation and then do your stuff.</span>
<span class="comment-copy">Hi Mark. Just seeing this comment now. I had doing similar to what you are suggestion and had great trouble with setting globals and because (as I now know) the events were being run on the same thread I could not get it to work. With the threading concept (see Aaron's answer below) it works perfectly so I've used this.</span>
<span class="comment-copy">Just looking at this Aaron thank you. A little bit above my Python pay grade but I think I get the essence. I am back working on the script right now so I'll let you know how it pans out. I'd be happy to mark the question as correct if I understood what I was looking at :)  However, if I can get this to work I'll be straight back to mark it correct.</span>
<span class="comment-copy">@Wittner if you're unfamiliar with multi-threading and concurrency features such as locks, there are probably hundreds of better explanations online than I can give you for a quick jumpstart. I'll edit to give a detailed explanation of what my code does, but I'll leave it up to you to dive deeper on how threads work.</span>
<span class="comment-copy">Thanks Aaron. I actually read the Sourceforge page and my understanding jumped a little :) Also, I re-wrote my code and incorporated your above code and it works perfectly so I'm marking your question as correct straight away. I can kind of see whats happening here with the 'wrapper' function and the lock acquire and release. Thanks so much for the help, Wittner.</span>
