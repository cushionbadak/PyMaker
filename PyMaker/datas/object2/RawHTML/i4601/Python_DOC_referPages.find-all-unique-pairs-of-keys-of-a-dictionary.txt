<div class="post-text" itemprop="text">
<p>If there's a dictionary:  </p>
<pre><code>test_dict = { 'a':1,'b':2,'c':3,'d':4}
</code></pre>
<p>I want to find pairs of keys in list of tuples like:  </p>
<pre><code>[('a','b'),('a','c'),('a','d'),('b','c'),('b','d'),('c','d')]
</code></pre>
<p>I tried with the following double iteration</p>
<pre><code>test_dict = { 'a':1,'b':2,'c':3,'d':4}
result = []
for first_key in test_dict:
    for second_key in test_dict:
        if first_key != second_key:
            pair = (first_key,second_key)
            result.append(pair)
</code></pre>
<p>But it's generating the following result  </p>
<pre><code>[('a', 'c'), ('a', 'b'), ('a', 'd'), ('c', 'a'), ('c', 'b'), ('c', 'd'), ('b', 'a'), ('b', 'c'), ('b', 'd'), ('d', 'a'), ('d', 'c'), ('d', 'b')]
</code></pre>
<p>For my test case ('a','b') and ('b','a') are similar and I just want one of them in the list. I had to run one more loop for getting the unique pairs from the result.  </p>
<p>So is there any efficient way to do it in Python (preferably in 2.x)? I want to remove nested loops.</p>
<p><strong>Update:</strong><br/>
I have checked with the possible <a href="https://stackoverflow.com/questions/464864/how-to-get-all-possible-combinations-of-a-list-s-elements">flagged duplicate</a>, but it's not solving the problem here. It's just providing different combination. I just need the pairs of 2. For that question a tuple of <code>('a','b','c')</code> and <code>('a','b','c','d')</code> are valid, but for me they are not. I hope, this explains the difference.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sounds like a job for <a href="https://docs.python.org/2.7/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a>.</p>
<pre><code>from itertools import combinations
test_dict = {'a':1, 'b':2, 'c':3, 'd':4}
results = list(combinations(test_dict, 2))

[('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'c'), ('b', 'd'), ('c', 'd')]
</code></pre>
<p>I should add that although the output above happens to be sorted, this is not guaranteed. If order is important, you can instead use:</p>
<pre><code>results = sorted(combinations(test_dict, 2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since dictionary keys are unique, this problem becomes equivalent of finding all combinations of the keys of size 2. You can just use <code>itertools</code> for that:</p>
<pre><code>&gt;&gt;&gt; test_dict = { 'a':1,'b':2,'c':3,'d':4}
&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list(itertools.combinations(test_dict, 2))
[('c', 'a'), ('c', 'd'), ('c', 'b'), ('a', 'd'), ('a', 'b'), ('d', 'b')]
</code></pre>
<p>Note, these will come in no particular order, since <code>dict</code> objects are inherently unordered. But you can sort before or after, if you want sorted order:</p>
<pre><code>&gt;&gt;&gt; list(itertools.combinations(sorted(test_dict), 2))
[('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'c'), ('b', 'd'), ('c', 'd')]
&gt;&gt;&gt;
</code></pre>
<p>Note, this algorithm is relatively simple if you are working with sequences like a list:</p>
<pre><code>&gt;&gt;&gt; ks = list(test_dict)
&gt;&gt;&gt; for i, a in enumerate(ks):
...     for b in ks[i+1:]: # this is the important bit
...         print(a, b)
...
c a
c d
c b
a d
a b
d b
</code></pre>
<p>Or more succinctly:</p>
<pre><code>&gt;&gt;&gt; [(a,b) for i, a in enumerate(ks) for b in ks[i+1:]]
[('c', 'a'), ('c', 'd'), ('c', 'b'), ('a', 'd'), ('a', 'b'), ('d', 'b')]
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html?highlight=itertools%20combinations#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> does just what you want:</p>
<pre><code>from itertools import combinations

test_dict = { 'a':1,'b':2,'c':3,'d':4}
keys = tuple(test_dict)
combs = list(combinations(keys, 2))
print(combs)
# [('a', 'd'), ('a', 'b'), ('a', 'c'), ('d', 'b'), ('d', 'c'), ('b', 'c')]
</code></pre>
<p><code>combs = list(combinations(test_dict, 2))</code>  would just do; iterating over a dictionary is just iterating over its keys...</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/464864/how-to-get-all-possible-combinations-of-a-list-s-elements">How to get all possible combinations of a listâ€™s elements?</a></span>
<span class="comment-copy">@Aran-Fey, please check the update. I don't require all of the possible combinations, but a subset of those combinations.</span>
<span class="comment-copy">@noob you require <i>all combinations</i>. Did you actually try that answer? Or looked at the three answers in this question, which all use <code>itertools.combinations(data, 2)</code>?</span>
<span class="comment-copy">I don't see how it's <i>not</i> a duplicate... well, my eyes are deceiving me those days, so I may be wrong.</span>
<span class="comment-copy">@noob Well, the answer uses a loop to generate combinations of increasing length, so it's trivial to apply it to your use case... but maybe you'd be happier with <a href="https://stackoverflow.com/questions/20762574/combinations-with-two-elements">this</a> question?</span>
