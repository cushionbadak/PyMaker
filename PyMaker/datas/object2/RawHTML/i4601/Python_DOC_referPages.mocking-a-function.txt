<div class="post-text" itemprop="text">
<p>i try to figure how to mock a function in a helper.py that use in several methods for a unit test.</p>
<p>I try with patch, @patch('project.helpers.function_0', new=lambda: True) but didn't work.</p>
<p>How is the correct way to do this?</p>
<p>Thank you.</p>
<hr/>
<h2>Update</h2>
<p>I have 1 function and 1 decorator that i need to override for all test set.</p>
<p>helpers.py</p>
<pre><code>def myfunction(asd):
    # ...
    return asd
</code></pre>
<p>decorators.py</p>
<pre><code>def mydecorator(func):
    @wraps(func)
    def _wrapped_func(asd, *args, **kwargs):
        # ...
        return func(asd, *args, **kwargs)
    return _wrapped_func
</code></pre>
<h2>How i resolved</h2>
<p><strong><em>I want to know how do this with mock, thank you!</em></strong></p>
<p>test_base.py</p>
<pre><code>import project.decorators
import project.helpers

def myfunction_mock(asd):
   # ...
   return asd
helpers.myfunction = myfunction_mock

def mydecorator_mock(func):
   # ...
decorators.mydecorator = mydecorator_mock
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some key things going on here.</p>
<ol>
<li>If possible, you should be using <code>unittest.mock</code> (or <code>mock</code> installed via <code>pip</code>).</li>
<li>You are likely patching in the wrong location.</li>
<li>When using <code>mock.patch</code> you probably want to use the <code>new_callable</code> keyword argument, rather than <code>new</code></li>
</ol>
<p>Suppose your production code looks something like this....</p>
<pre><code>#production_module.py
from helpers import myfunction

def some_function(a):
    result = myfunction(a) + 1
    return result
</code></pre>
<p>If you wanted to test <code>some_function</code> from your production code, mocking <code>myfunction</code> your test code should patch <code>production_module.myfunction</code> not <code>helpers.myfunction</code></p>
<p>So your test code may look like this</p>
<pre><code>import mock
from production_module import some_function

def mock_myfunction(*args, **kwargs):
    return 1

@mock.patch('production_module.myfunction', new_callable=mock_myfunction)
def test_some_function(mock_func):
    result = some_function(1) # call the production function
    assert mock_func.called # make sure the mock was actually used
    assert result == 2
</code></pre>
<p>Another way of using <code>mock.patch</code> is as a context manager. So the patch will only apply in that context.</p>
<pre><code>with mock.patch(...) as mock_func:
    some_function(1) # mock_func is called here

some_function(1) # the mock is no longer in place here
</code></pre>
</div>
<span class="comment-copy">The keyword argument you're looking for is <code>new_callable</code>, not <code>new</code>. See <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer">the docs</a></span>
<span class="comment-copy">Doesn't work for me, this way give and extra arg in the test, i need override the function for all the test. The function_0 is called in other methods i call...</span>
<span class="comment-copy">What exactly is not working? Please update your question with your testcase code and describe the unexpected behavior and desired behavior.</span>
<span class="comment-copy">@sytech update with more data the question, thank you for answer.</span>
