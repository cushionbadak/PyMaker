<div class="post-text" itemprop="text">
<p>This is my code:</p>
<pre><code>def inverse_dict(my_dict):
    new_dict = {}
    new_key = ''
    for new_value in my_dict:
        new_list = [new_value]
        new_key = my_dict[new_value]
        if new_key in new_dict:
            new_list.append(new_dict[new_key])
            new_list = sorted(new_list)
        new_dict[new_key] = new_list
    return new_dict
</code></pre>
<p>And my main:</p>
<pre><code>def main():
    print(inverse_dict({'cc': 'dd', 'ab': 'cd', 'bb': 'cd'}))
    print(inverse_dict({'b': 'd', 'c': 'd', 'a': 'd'}))
</code></pre>
<p>I want that my input will be: </p>
<ul>
<li>first line - <code>{'cd': ['ab', 'bb'], 'dd': ['cc']}</code></li>
<li>second line - <code>{'d': ['a', 'b', 'c']}</code> </li>
</ul>
<p>But instead I get error and if I delete the line that i sort my list my input looks like: </p>
<ul>
<li>first line - <code>{'dd': ['cc'], 'cd': ['bb', ['ab']]}</code></li>
<li>second line - <code>{'d': ['a', ['c', ['b']]]}</code></li>
</ul>
<p>what can I do?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use <code>collections.defaultdict</code> for this problem.</p>
<p>The problem with your code is that, to add <em>the elements of a list</em> to another list, you need <code>list.extend</code> instead of <code>list.append</code>. This answer provides more detail:  </p>
<p><a href="https://stackoverflow.com/questions/252703/difference-between-append-vs-extend-list-methods-in-python">Difference between append vs. extend list methods in Python</a></p>
<pre><code>from collections import defaultdict

def inverse_dict(d):
    res = defaultdict(list)
    for k, v in d.items():
        res[v].append(k)

    return res

print(inverse_dict({'cc': 'dd', 'ab': 'cd', 'bb': 'cd'}))
# defaultdict(&lt;class 'list'&gt;, {'dd': ['cc'], 'cd': ['ab', 'bb']})

print(inverse_dict({'b': 'd', 'c': 'd', 'a': 'd'}))
# defaultdict(&lt;class 'list'&gt;, {'d': ['b', 'c', 'a']})
</code></pre>
<p><strong>Explanation for above solution</strong></p>
<ul>
<li><code>collections.defaultdict</code> allows you to specify a default value for arbitrary keys.</li>
<li>In this implementation, the default value is an empty <code>list</code>.</li>
<li>Therefore, we simply loop through the input dictionary and use <code>list.append</code> to add keys from the original dictionary to values set as keys of your new dictionary.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The values of <code>new_dict</code> are lists. When you append a list to another list, you get nested lists. You want to <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer"><code>extend</code></a> the list by another list:</p>
<pre><code>&gt;&gt;&gt; def inverse_dict(my_dict):
...     new_dict = {}
...     new_key = ''
...     for new_value in my_dict:
...         new_list = [new_value]
...         new_key = my_dict[new_value]
...         if new_key in new_dict:
...             new_list.extend(new_dict[new_key])
...             new_list = sorted(new_list)
...         new_dict[new_key] = new_list
...     return new_dict
...
&gt;&gt;&gt; print(inverse_dict({'cc': 'dd', 'ab': 'cd', 'bb': 'cd'}))
{'dd': ['cc'], 'cd': ['ab', 'bb']}
&gt;&gt;&gt; print(inverse_dict({'b': 'd', 'c': 'd', 'a': 'd'}))
{'d': ['a', 'b', 'c']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're appending a list to a list, which nests it inside. You should concatenate them:</p>
<pre><code>new_list += new_dict[new_key]
</code></pre>
<p>But even simpler would be to not create a new list, just append to the list that's in the key.</p>
<pre><code>for new_key, new_value in enumerate(my_dict):
    if new_value in new_dict:
        new_dict[new_value].append(new_key)
        new_dict[new_value] = sorted(new_dict[new_value])
    else
        new_dict[new_value] = [new_key]
</code></pre>
<p>This is also a good use for a <code>defaultdict</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Below function gives correct result:</p>
<pre><code> def inverse_dict(dict_):
        inverse_dict = dict() # Set an empty dictionary
        for key, value in dict_.items():
            try:
                # If list, add key into list; otherwise it will throw exeption
                inverse_dict[value].append(key)
            except AttributeError:
                # AttributeError means value has item but not list
                inverse_dict[value] = [inverse_dict[value], key]
            except KeyError:
                # KeyError means there isn't any item in the new dictionary
                inverse_dict[value] = key
        return inverse_dict
</code></pre>
</div>
<span class="comment-copy">When you try to sort <code>new_list</code> you probably have a mix of strings and lists.</span>
<span class="comment-copy">Use <code>extend</code> instead of <code>append</code>.</span>
<span class="comment-copy">Python 3 doesn't try to guess how you want to compare objects of completely different types. Do you want all of the lists to come before all of the strings? After all of the strings? Or to treat the strings as single-element string lists? Whatever you want, you can write a key function for it and pass that to <code>sorted</code>, but you have to decide what you want first.</span>
<span class="comment-copy">misleading title...</span>
