<div class="post-text" itemprop="text">
<p>Look at this very basic code:</p>
<pre><code>s2 = 'prefixe'
cpt = 1

def test():
    cpt += 1
    str = "%s%d" % (s2,cpt)
    print(str)

test()
</code></pre>
<p>I have an error. It says that cpt is read before assignment.
It is normal to my opinion because cpt should be declared as a global variable:</p>
<pre><code>s2 = 'prefixe'
cpt = 1

def test():
    global cpt
    cpt += 1
    str = "%s%d" % (s2,cpt)
    print(str)

test()
</code></pre>
<p>In this case, i have no error and the program works fine.</p>
<p>But, why there is no error for s2 variable ? This variable should be declared as a global variable too ? Why do not i have error ?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="nofollow noreferrer">Python Docs</a></p>
<blockquote>
<p>In Python, variables that are only referenced inside a function are
  implicitly global. If a variable is assigned a value anywhere within
  the function’s body, it’s assumed to be a local unless explicitly
  declared as global.</p>
</blockquote>
<p>Since <code>s2</code> is only read (not assigned) inside the function it's implicitly global, and there is no error.  However, if you tried to modify <code>s2</code> it would throw an error unless you define it as <code>global</code>, since by default it would assume the variable is local, and there isn't a local variable named <code>s2</code>.</p>
<p>Personally, I agree that this is a bit unintuitive.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can refer this: </p>
<p><a href="https://stackoverflow.com/questions/423379/using-global-variables-in-a-function-other-than-the-one-that-created-them">Using global variables in a function other than the one that created them
</a></p>
<p>You can use a global variable in other functions by declaring it as <code>global</code> in each function that assigns to it:</p>
<pre><code>s2 = 'prefixe'    
cpt = 1

def test():
    global cpt # Needed to modify global copy of cpt
    cpt += 1
    str = "%s%d" % (s2,cpt) # No need for global declaration to read value
    print(str)

test()
</code></pre>
<p>I imagine the reason for it is that, since global variables are so dangerous, Python wants to make sure that you really know that's what you're playing with by explicitly requiring the <code>global</code> keyword.</p>
</div>
<span class="comment-copy">You only need a <code>global</code> declaration to <i>assign</i> to globals.</span>
<span class="comment-copy">This is quite interesting, good answer</span>
<span class="comment-copy">"if you tried to set s2 to something it would throw an error because then python would assume it's a local variable": no it would create a second <code>s2</code>, not modifying the global <code>s2</code>. You probably mean something like <code>s2 += "ddd"</code> (which doesn't work), but <code>s2 = "ddd"</code> doesn't crash. It just doesn't modify the global</span>
<span class="comment-copy">@Jean-FrançoisFabre you are correct, I changed the wording to "modify" instead of set.</span>
<span class="comment-copy">also note that modifying <code>s2</code> internally creates a new reference (but that's transparent. If you write <code>s2 = s2 + "foo"</code> it uses global <code>s2</code> and creates a local <code>s2</code> ... headache :)</span>
<span class="comment-copy">@Jean-FrançoisFabre It is really annoying...  I removed the 'at first' as well since, I agree, it's still unintuitive!</span>
