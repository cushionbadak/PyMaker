<div class="post-text" itemprop="text">
<p>I'm attempting to walk through a directory containing over 650+ directories where each directory has 3 subdirectories, which then contain <code>.png</code> files. So that I have something that resembles:</p>
<pre><code>MAIN
└───folder_01
|   └─subfolder_01
|   | └─12.png
|   └─subfolder_02
|   | └─... .png
|   └─subfolder_03
|     └─cm_12.png   
│
└───folder_02
|   └─subfolder_01
|   | └─34.png
|   └─subfolder_02
|   | └─... .png
|   └─subfolder_03
|     └─cm_34.png   
│
...
</code></pre>
<p>What I'm attempting to do is the extract the path from the <code>.png</code> in <code>subfolder_01</code> and <code>subfolder_03</code>. Both those folders contain a single <code>.png</code> image and the file in <code>subfolder_03</code> has the same name as the file in <code>subfolder_01</code> with the addition of the prefix <code>cm_</code>.</p>
<p>I would like to store the paths in a dictionary where the key is the image  name (without the extension) and the value is a tuple where the first entry is the path of the image found in  <code>subfolder_01</code> and the second entry would be the path to the image found in <code>subfolder_03</code>, so that I have something like:</p>
<pre><code>my_dict = {image 12 name: (path to 12.png, path to cm_12.png,
           image 34 name: (path to 34.png, path to cm_34.png),
           ...}
</code></pre>
<p>to further complicate matters the image files are a 64 length hash. I have some code below, but I ran into a problem because it seems to go to <code>subfolder_03</code> and pick out that image before going to <code>subfolder_01</code>. I've attempted to reverse the order of my <code>if</code> statement which resolves the problem but I'm hoping to find a solution that is a little more general, that is doesn't really depend on the order of the <code>if</code> statement.</p>
<p>For completeness the code:</p>
<pre><code> def get_data(loc: str) -&gt; Dict[str, Directories]:
    """
    Looks through the given directory and returns a dictionary where the
    key is the file name and the values are the locations of the training
    image and the mask
    """
    im_paths = []
    im_imMask = {}

    for root, dirs, files in os.walk(loc):
        # mask_paths = []
        im_combined = ""
        for file in files:
            if file.endswith(".png"):
                im_path = root + "/{}".format(file)
                im_paths.append(im_path)
                # print(root)
                if os.path.basename(root) == "images":
                    key = os.path.splitext(file)[0]
                    im_loc = root + "/{}".format(file)
                elif os.path.basename(root) == "combined":
                    im_combined = root + "/{}".format(file)
                    # mask_paths.append(root + "/{}".format(file))
            im_imMask[key] = (im_loc, im_combined) 

    return im_imMask 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think what you want to do is get an entry like this by the time you're done:</p>
<pre><code>image 12 name: (path to 12.png, path to cm_12.png)
</code></pre>
<p>… no matter which order you visit the two files.</p>
<p>This will be easier if you're willing to have a list of the two files instead of a tuple. Then you can do something like:</p>
<pre><code>key = os.path.splitext(file)[0]
if filename.startswith('cm_'):
    key = key[3:]
    d.setdefault(key, [None, None])[1] = path
else:
    d.setdefault(key, [None, None])[0] = path
</code></pre>
<p>The <code>setdefault</code> will make sure that whichever file you find earlier will create a <code>[None, None]</code> before replacing the first or second element, but whichever one you find later will operate on the already-created pair.</p>
<hr/>
<p>It sounds like you want to wrap up that <code>setdefault</code> so you don't have to repeat yourself. You could refactor it into a function:</p>
<pre><code>def storename(key, idx):
    d.setdefault(key, [None, None])[idx] = path
if filename.startswith('cm_'):
    storename(key[3:], 1)
else:
    storename(key, 0)
</code></pre>
<p>Or you could store the values in variables:</p>
<pre><code>cm = filename.startswith('cm_')
if cm:
    key = [3:]
d.setdefault(key, [None, None])[cm] = path
</code></pre>
<p>(This relies on the fact that <code>True</code> and <code>False</code> are the same as <code>1</code> and <code>0</code>. If that seems mysterious to you, change it to <code>cm = 1 if filename.startswith('cm_') else 0</code>.)</p>
<p>Or you could combine the two.</p>
</div>
<span class="comment-copy">You want to walk the folders is a specific order?</span>
<span class="comment-copy">The documentation for <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow noreferrer"><code>os.walk</code></a> explains that the order is arbitrary (up to your OS) but also explains how to use <code>topdown</code> mode and mutating <code>dirnames</code> to "impose a specific order of visiting".</span>
<span class="comment-copy">If the directories' structure is exactly like what you show, I don't think you need to walk through it. Why cannot you list directories by yourself?</span>
<span class="comment-copy">You're correct that I don't really care which gets seen first as long as the output is as descriped. At the moment I applied the solution under both <code>if os.path.basename(root) == "images":</code> and <code>elif os.path.basename(root) == "combined"</code> is there a way to simply have it apply this solution in one area or does it necessarily need to be contained in both the <code>if</code> and <code>elif</code> conditions?</span>
<span class="comment-copy">@Lukasz I've edited the answer to explain what I think you want to do there.</span>
