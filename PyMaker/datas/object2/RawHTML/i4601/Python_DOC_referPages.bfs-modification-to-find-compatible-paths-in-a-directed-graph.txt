<div class="post-text" itemprop="text">
<p>I have the following directed graph and every node has one or more attributes. I try to modify bfs algorithm to find all possible paths from a starting node until the given attributes are covered. I also want the path that i found to not be a part of a cycle. <a href="https://i.stack.imgur.com/aO76Z.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/aO76Z.png"/></a></p>
<p>For this graph if i start from node 1 and i want to cover attr 4 the paths that my algorithm will find are:</p>
<pre><code>1-2-3
1-2-5-3
1-2-5-6-8
</code></pre>
<p>If i add the edge <code>3-1</code> then the paths <code>1-2-3</code> and <code>1-2-5-3</code> i want not to be accepted because are part of a cycle. So in my algorithm i try to check the neighbors of the last visited node and if the neighbor has already visited then i try to discard this path but my algorithm doesnt work in this case. If i add the edge <code>3-1</code> it returns the same paths. How can i fix this?
Here is my code:</p>
<pre><code>G = nx.DiGraph()

G.add_edge(1,2)
G.add_edge(2,3)
G.add_edge(2,5)
G.add_edge(3,4)
G.add_edge(5,3)
G.add_edge(5,6)
G.add_edge(5,7)
G.add_edge(6,8)
G.add_edge(3,1)

def checkIfRequiredAttrsAreCovered(path, attrsToBeCovered):
    coveredAttrs = []
    counter = 0
    for node in path:
        coveredAttrs.extend(G.node[node]['attrs'])
    for i in attrsToBeCovered:
        if i in coveredAttrs:
            counter = counter + 1
    if counter == len(attrsToBeCovered):
        return True
    else:
        return False


def bfs(G, startingNode, attrsToBeCovered):
    paths = []
    q = queue.Queue()
    q.put([startingNode])
    while not q.empty():
        v = q.get()
        if checkIfRequiredAttrsAreCovered(v, attrsToBeCovered) == True:
            for i in G.neighbors(v[-1]):
                if i in v:
                    break
            paths.append(v) #print(v)
        else:
            for node in G.neighbors(v[-1]):
                if node not in v:
                    path = []
                    path.extend(v)
                    path.append(node)
                    q.put(path)

    print(paths)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'll assume that you don't care if nodes are part of a bigger cycle. E.g. if 4 is connected to 1 and 3 is in a cycle 1-2-3-4. If you want to handle this, you may start a dfs from each matching node, with the current path set as visited.</p>
<p>First, <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">you should use snake case in Python</a> </p>
<p>Second, you should use <code>set</code>s to compare the attributes covered to the attributes to be covered. For a path, compute the set of covered attributes and compare the sets:</p>
<pre><code>def check_if_required_attrs_are_covered(G, path, attrs_to_be_covered): # be sure to pass G as an argument here
    covered_attrs = set([G.node[n]['attrs'] for n in path])
    return covered_attrs &gt;= attrs_to_be_covered
</code></pre>
<p>Third, some remarks on the <code>bfs</code> function:</p>
<ul>
<li>A test <code>if b == True:</code> is equivalent to <code>if b:</code>, because for a boolean <code>b == (b == True)</code> (try with True and False to convince yourself)</li>
<li>The way you append a path to <code>q</code> may be shortened to <code>q.put(v+ [node])</code></li>
<li>You probably do not need a synchonized <code>queue</code>: use a list</li>
<li>Use return instead of print or even better, create a generator that yields paths when they are found.</li>
</ul>
<p>Four: what is the problem? Look at the <code>for i in G.neighbors(v[-1]):</code> loop. 
Whether you <code>break</code> or not, you go to the line <code>paths.append(v)</code>. 
That's why you do not exclude the paths with cycles. You want to distinguish the normal end of the loop from the break. 
That's a perfect case for confidential loop syntax in Python: the <a href="https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops" rel="nofollow noreferrer"><code>for...else</code> loop</a>.
I quote the doc: "a loopâ€™s else clause runs when no <code>break</code> occurs". This gives the following code:</p>
<pre><code>for i in G.neighbors(v[-1]):
    if i in v:
        break
else: # no neighbor from v[-1] in v
    yield v # instead of paths.append(v)
</code></pre>
<p>But you can also use <code>any</code> for a more natural expression:</p>
<pre><code>if not any(i in v for i in G.neighbors(v[-1])):
    yield v # instead of paths.append(v)
</code></pre>
<p>This gives the following code:</p>
<pre><code>def bfs(G, starting_node, attrs_to_be_covered):
    q = [[starting_node]]
    while q:
        v = q.pop()
        if check_if_required_attrs_are_covered(G, v, attrs_to_be_covered): # be sure to pass G as an argument
            if not any(i in v for i in G.neighbors(v[-1])):
                yield v
        else:
            for node in G.neighbors(v[-1]):
                if node not in v:
                    q.append(v+ [node])
</code></pre>
<p>Try it with:</p>
<pre><code>print (list(bfs(G, 1,  set(["attr4"]))))
</code></pre>
</div>
