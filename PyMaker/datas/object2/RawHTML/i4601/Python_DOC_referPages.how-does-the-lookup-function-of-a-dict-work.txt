<div class="post-text" itemprop="text">
<p>It is well known that mutable types cannot be the key of a dictionary.</p>
<p>However if you were using say C++, then regular maps let you use vectors and arrays as map keys because regular maps are implemented as trees.</p>
<p>However, C++ also lets you use an array as the key of an unordered map, which is closer in spirit to a python dictionary because it hashes the keys as long as you provide the hash function for types it doesn't know how to hash.</p>
<p>So I wanted to know if Python would let you do the same as long as you provide an <code>__hash__</code>  method.</p>
<pre><code>In [1]: b = {}

In [2]: class hlist(list):
   ...:     def __hash__(self):
   ...:         temp = []
   ...:         for item in self:
   ...:             print item
   ...:             temp.append(item)
   ...:         return hash(tuple(temp))
   ...:

In [3]: a = hlist([1,2,3,4])

In [4]: c = hlist([1,2,3,4])

In [5]: b[a] = "car"
1
2
3
4

In [6]: b[c]
1
2
3
4
Out[6]: 'car'

In [7]: a.append(5)

In [8]: b[c]
1
2
3
4
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
&lt;ipython-input-8-013e994efe63&gt; in &lt;module&gt;()
----&gt; 1 b[c]

KeyError: [1, 2, 3, 4]
</code></pre>
<p>I added the <code>print</code> inside the <code>__hash__</code> to figure out what is being hashed and when the function is invoked.</p>
<p>Right before the <code>KeyError</code> is thrown, the contents of <code>c</code> are printed, indicated that <code>c</code> was just hashed. Now shouldn't it just check if this hash value if the hash value of one of the keys? Why does it throw a key error?</p>
<p>If it is also hashing all the keys one by one to figure out if one of them hash the same hash value as the query shouldn't the code below work?</p>
<pre><code>In [11]: b[hlist([1,2,3,4,5])]
1
2
3
4
5
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
&lt;ipython-input-11-09593553a69b&gt; in &lt;module&gt;()
----&gt; 1 b[hlist([1,2,3,4,5])]

KeyError: [1, 2, 3, 4, 5]
</code></pre>
<p>If you were determined to have a mutable key with a semi robust hashing function similar to cpp is it possible?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>How are dicts stored in memory?</strong> (simplified version)</p>
<ul>
<li>for each key in the dict, <code>hash</code> is calculated and then both key and value are stored in a place defined by the hash</li>
<li>if multiple keys have the same hash (or have hashes pointing to the same storage destination), there will be a list of key-value pairs in that place</li>
</ul>
<p><strong>How are dict values read from memory?</strong> (simplified version)</p>
<ul>
<li>the <code>hash</code> of the key is calculated and location in memory is calculated from that hash</li>
<li>key-value pairs are read from that location one by one and compared to the sought key using <code>==</code> operator</li>
</ul>
<p><strong>Conclusion</strong></p>
<p>To for a key (call it <code>key1</code>) to be found in the dict, the dict should contain a key (call it <code>key2</code>), for which <code>hash(key1) == hash(key2) and key1 == key2</code>.</p>
<p><strong>So why are mutable keys a bad idea?</strong></p>
<p>Because <code>hash(key)</code> is calculated when key is written into the dict and it matches the value of <code>key</code> at that point in time, but if <code>key</code> is mutable, and you mutate it while it is in the dict, dict will not recalculate <code>hash(key)</code>, so it will no longer be possible to find the key.</p>
</div>
<span class="comment-copy">C++ has <code>const</code>. The keys of a C++ map are <code>const</code>.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__()</code> isn't enough.</a></span>
<span class="comment-copy">@user2357112 that makes sense! @IgnacioVazquez-Abrams aren't the other things like <code>__eq__</code> defined as part of being a subclass of <code>list</code> ?</span>
<span class="comment-copy">Yes, <code>__eq__</code> is defined for your <code>hlist</code> class. But <code>c</code> doesn't compare equal to <code>a</code>, so that's why you get a KeyError. (Keep in mind that the hlist stored in the dict is <code>a</code>, so every key you use is checked for equality against <code>a</code>.)</span>
<span class="comment-copy">Does <a href="https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented">this</a> answer your question? I'm not really sure what you mean by "is it possible?". It's pretty clear that you <i>can</i> have mutable keys with an unstable hash, and that it's a bad idea, isn't it?</span>
