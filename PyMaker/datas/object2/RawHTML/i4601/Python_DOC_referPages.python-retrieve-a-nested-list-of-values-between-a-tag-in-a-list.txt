<div class="post-text" itemprop="text">
<p>I have a list that is:</p>
<pre><code>[2,3,5,"TAG",6,7,3,2,6,"TAG",9,9,8,3]
</code></pre>
<p>I want to return a list containing nested sublists of values that are in between the "TAG"s. </p>
<p>So the resulting list would look like:</p>
<pre><code>[[2,3,5], [6,7,3,2,6], [9,9,8,3]]
</code></pre>
<p>I created a method below that attempts to accomplish this but does not work:</p>
<pre><code>def returnListBetweenTag(lst, tag):
  temp = []
  k = lst.index(tag)
  while lst != []:
      temp.append(lst[0:k])
      del lst[0:k+1]
  return temp
</code></pre>
<p>This prints out:</p>
<pre><code>[[2, 3, 5], [6, 7, 3], [6, 'TAG', 9], [8, 3]]
</code></pre>
<p>Can anyone please help me understand what I am doing wrong, and some suggestions to fix it?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is reasonably straight forward when using a <a href="https://docs.python.org/3/reference/expressions.html#yield-expressions" rel="noreferrer">generator</a> like:</p>
<h3>Code:</h3>
<pre><code>def divide_list(a_list, divider):
    sub_list = []
    for item in a_list:
        if item == divider:
            yield sub_list
            sub_list = []
        else:
            sub_list.append(item)
    yield sub_list
</code></pre>
<h3>Test Code:</h3>
<pre><code>data = [2,3,5,"TAG",6,7,3,2,6,"TAG",9,9,8,3]
print(list(divide_list(data, "TAG")))
</code></pre>
<h3>Results:</h3>
<pre><code>[[2, 3, 5], [6, 7, 3, 2, 6], [9, 9, 8, 3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a way to accomplish this with <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>.</p>
<pre><code>from itertools import groupby

ls = []

for key, group in groupby(lst, lambda x: x != "TAG"):
    if key:
        ls.append(list(group))

print ls
# [[2, 3, 5], [6, 7, 3, 2, 6], [9, 9, 8, 3]]
</code></pre>
<p>This can also be implemented as a comprehension:</p>
<pre><code>ls = [list(group) for key, group in groupby(lst, lambda x: x != "TAG") if key]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is really not a good way to do it, but you <em>can</em> make it work.</p>
<p>First, you never do the <code>k = lst.index(tag)</code> again after the first time.
So, with your list, <code>k</code> turns out to be 3 forever. But you keep taking the first three elements off the list, so first <code>k[0:3]</code> is <code>[2, 3, 5]</code>, then it's <code>[6, 7, 3]</code>, then it's 3, <code>[6, 'TAG', 9]</code>, and so on. You need to keep calling it each time.</p>
<p>Second, what happens when there are no more <code>'TAG'</code>s left in the list? That <code>lst.index</code> will raise an exception. So you need to handle that.</p>
<pre><code>def returnListBetweenTag(lst, tag):
    temp = []
    while lst != []:
        try:
            k = lst.index(tag)
        except ValueError:
            temp.append(lst)
            break
        temp.append(lst[0:k])
        del lst[0:k+1]
    return temp
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Logic is just tracking the 'TAG' keyword and when it found just empty the temp list and start adding from index 0 again. </p>
<p>This will work for you:</p>
<pre><code>data=[2,3,5,"TAG",6,7,3,2,6,"TAG",9,9,8,3]

def values(datae):
    final_values=[]
    store=[]
    for i in data:
        if i!='TAG':
            store.append(i)
        else:
            final_values.append(store)
            store=[]

    final_values.append(store)

    return final_values
print(values(data))
</code></pre>
<p>output:</p>
<pre><code>[[2, 3, 5], [6, 7, 3, 2, 6], [9, 9, 8, 3]]
</code></pre>
</div>
