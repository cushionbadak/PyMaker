<div class="post-text" itemprop="text">
<p>I have a few N-dimensional arrays as below. How can I convert these arrays into tuples?</p>
<pre><code>num = ['1' '2']
letter1 = ['a' 'b' 'c' 'd' 'e' 'f']
letter2 = ['aa' 'bb' 'cc' 'dd' 'ee' 'ff']
</code></pre>
<p>The result I want is:</p>
<pre><code>tuple1 = [(1,a),(1,b),(1,c),(1,d),(1,e),(1,f)]
tuple2 = [(2,aa),(2,bb),(2,cc),(2,dd),(2,ee),(2,ff)]
</code></pre>
<p>I have</p>
<pre><code>tuple1 = tuple(num[0], letter1)
tuple2 = tuple(num[1], letter2)
</code></pre>
<p>But I got an error of <code>TypeError: tuple() takes at most 1 argument (2 given)</code></p>
<p>What would be your approach? Any methods would be appreciated. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><strong><code>zip</code></strong></a> with <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer"><strong><code>itertools.repeat</code></strong></a> to achieve this as:</p>
<pre><code>&gt;&gt;&gt; from itertools import repeat
&gt;&gt;&gt; num = ['1', '2']
&gt;&gt;&gt; letter1 = ['a', 'b', 'c', 'd', 'e', 'f']

&gt;&gt;&gt; tuple1 = list(zip(repeat(num[0]), letter1))
&gt;&gt;&gt; tuple1
[('1', 'a'), ('1', 'b'), ('1', 'c'), ('1', 'd'), ('1', 'e'), ('1', 'f')]
</code></pre>
<p><strong><em>PS:</em></strong> Note the commas <code>,</code> between elements in the above lists. Strings separated without comma are treated as a single string.</p></div>
<div class="post-text" itemprop="text">
<p>You can use <code>iter</code> and <code>next</code>:</p>
<pre><code>num = ['1', '2']
num = iter(num)
letter1 = ['a', 'b', 'c', 'd', 'e', 'f']
letter2 = ['aa', 'bb', 'cc', 'dd', 'ee', 'ff']
tuple1, tuple2 = [list(zip(i, [next(num)]*len(i))) for i in [letter1, letter2]]
</code></pre>
<p>Output:</p>
<pre><code>[('a', '1'), ('b', '1'), ('c', '1'), ('d', '1'), ('e', '1'), ('f', '1')]
[('aa', '2'), ('bb', '2'), ('cc', '2'), ('dd', '2'), ('ee', '2'), ('ff', '2')]
</code></pre>
<p>Without <code>iter</code>:</p>
<pre><code>tuple1, tuple2 = [[(i, h) for i in c] for c, h in zip([letter1, letter2], ['1', '2'])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some good answers already but I'll share an alternative using a list comprehension. It looks like a bit more code, but will work for larger lengths of <code>nums</code> and <code>lists</code> (as long as they are the same length as each other still):</p>
<pre><code>letter1 = ['a', 'b', 'c', 'd', 'e', 'f']
letter2 = ['aa', 'bb', 'cc', 'dd', 'ee', 'ff']
nums = [1, 2]

lists = [letter1, letter2]
tuples = [[(i, x) for x in l] for i, l in zip(nums, lists)]

tuple1, tuple2 = tuples
</code></pre>
<p>Results:</p>
<pre><code>In [1]: tuple1
Out[1]: [(1, 'a'), (1, 'b'), (1, 'c'), (1, 'd'), (1, 'e'), (1, 'f')]

In [2]: tuple2
Out[2]: [(2, 'aa'), (2, 'bb'), (2, 'cc'), (2, 'dd'), (2, 'ee'), (2, 'ff')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Already there are good answers, I just want to give you hint you can tweak your logic a little </p>
<pre><code>num = ['1','2']
letter1 = ['a','b' ,'c', 'd', 'e', 'f']
letter2 = ['aa' ,'bb', 'cc', 'dd' ,'ee' ,'ff']
tuple1 = tuple(zip(*[[int(num[0])]*len(letter1),letter1]))
tuple2 = tuple(zip(*[[int(num[1])]*len(letter2), letter2]))

print(tuple1)
print(tuple2)
</code></pre>
<p>output:</p>
<pre><code>((1, 'a'), (1, 'b'), (1, 'c'), (1, 'd'), (1, 'e'), (1, 'f'))
((2, 'aa'), (2, 'bb'), (2, 'cc'), (2, 'dd'), (2, 'ee'), (2, 'ff'))
</code></pre>
</div>
<span class="comment-copy">Did you try <code>tuple1 = (num[0], letter1)</code>?</span>
<span class="comment-copy">Try <code>itertools.product</code> and/or <code>zip</code> with extension.</span>
<span class="comment-copy">@Graipher, if I remove <code>tuple</code>, it returned <code>('1', array(['a', 'b',        'c', 'd', 'e', 'f'],       dtype=object))</code></span>
<span class="comment-copy">Yes (as expected). It was meant to show why you get a <code>TypeError</code> with that approach (<code>tuple</code> takes an iterable and returns a tuple, it does not take the elements of the tuple).</span>
<span class="comment-copy">It works great! Thank your for your fast response.</span>
<span class="comment-copy">and it doesn't create extra lists. Everything is done with iterables. Welcome back Moinuddin.</span>
<span class="comment-copy">that's why you should always test your answers :)</span>
<span class="comment-copy"><code>[next(num)]*len(i)</code> works but I think something better can be done with <code>itertools.repeat</code>: <code>itertools.repeat(next(num),i)</code>: it avoids creating an extra list.</span>
<span class="comment-copy">and you can even forget about limiting with <code>i</code> since <code>zip</code> stops on the shortest iterable.</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre agreed; however, MoinuddinQuadri's answer already offers a great solution with <code>itertools.repeat</code>, and I thought that plain <code>zip</code> with <code>next</code> would demonstrate a possibility not relying on builtin libraries</span>
<span class="comment-copy">you're right, sometimes it's better to get back to basics.</span>
<span class="comment-copy">I should take note on your method as well. Thanks!</span>
<span class="comment-copy">Ohh I see what you're doing here. I can use <code>zip</code> and <code>len</code> to define the numbers of elements in a tuple too. Great!</span>
