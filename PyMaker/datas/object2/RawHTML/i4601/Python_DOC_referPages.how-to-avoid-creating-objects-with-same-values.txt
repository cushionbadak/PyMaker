<div class="post-text" itemprop="text">
<p>I need to create a class whose instances can't have same values. If you create instance with value that have already been used you'll get old same instance.</p>
<p>I did it using special class method:</p>
<pre><code>class A():
    instances = []

    def __init__(self, val):
        self.val = val

    @classmethod
    def new(cls, val):
        """
        Return instance with same value or create new.
        """
        for ins in cls.instances:
            if ins.val == val:
                return ins
        new_ins = A(val)
        cls.instances.append(new_ins)
        return new_ins

a1 = A.new("x")
a2 = A.new("x")
a3 = A.new("y")

print a1  # &lt;__main__.A instance at 0x05B7FD00&gt; S\   /M\
print a2  # &lt;__main__.A instance at 0x05B7FD00&gt;   \A/   \E
print a3  # &lt;__main__.A instance at 0x05B7FD28&gt;
</code></pre>
<p>Is there a way to do it more elegant, without using <code>.new</code> method?</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be done by overriding the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code> method</a>, which is responsible for creating new instances of a class. Whenever you create a new instance you store it in a dict, and if the dict contains a matching instance then you return it instead of creating a new one:</p>
<pre><code>class A:
    instances = {}

    def __new__(cls, val):
        try:
            return cls.instances[val]
        except KeyError:
            pass

        obj = super().__new__(cls)

        cls.instances[val] = obj

        return obj

    def __init__(self, val):
        self.val = val
</code></pre>
<pre><code>a = A(1)
b = A(2)
c = A(1)

print(a is b)  # False
print(a is c)  # True
</code></pre>
<p>One downside of this solution is that the <code>__init__</code> method will be called regardless of whether the instance is a newly created one or one that's been stored in the dict. This can cause problems if your constructor has undesired side effects:</p>
<pre><code>class A:
    ...

    def __init__(self, val):
        self.val = val
        self.foo = 'foo'


a = A(1)
a.foo = 'bar'
b = A(1)
print(a.foo)  # output: foo
</code></pre>
<p>Notice how <code>a</code>'s <code>foo</code> attribute changed from "bar" to "foo" when <code>b</code> was created.</p>
<hr/>
<p>Another option is to use a <a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python">metaclass</a> and override its <a href="https://docs.python.org/3/reference/datamodel.html#object.__call__" rel="nofollow noreferrer"><code>__call__</code></a> method:</p>
<pre><code>class MemoMeta(type):
    def __new__(mcs, name, bases, attrs):
        cls = super().__new__(mcs, name, bases, attrs)
        cls.instances = {}
        return cls

    def __call__(cls, val):
        try:
            return cls.instances[val]
        except KeyError:
            pass

        obj = super().__call__(val)

        cls.instances[val] = obj

        return obj


class A(metaclass=MemoMeta):
    def __init__(self, val):
        self.val = val
        self.foo = 'foo'
</code></pre>
<p>This bypasses the problem with <code>__init__</code> being called on existing instances:</p>
<pre><code>a = A(1)
a.foo = 'bar'
b = A(1)
print(a.foo)  # output: bar
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a>.</p>
<p>For example:</p>
<pre><code>from functools import lru_cache

class A:

    @lru_cache()
    def __new__(cls, arg):
        return super().__new__(cls)

    def __init__(self, arg):
        self.n = arg
</code></pre>
<p>Sample usage:</p>
<pre><code>&gt;&gt;&gt; a1 = A('1')
&gt;&gt;&gt; a2 = A('1')
&gt;&gt;&gt; a1 is a2
True
&gt;&gt;&gt; a1.n
'1'
&gt;&gt;&gt; a2.n
'1'
</code></pre>
<p>Alternatively you could try building a custom caching class, as pointed out by Raymond Hettinger in this tweet: <a href="https://twitter.com/raymondh/status/977613745634471937" rel="nofollow noreferrer">https://twitter.com/raymondh/status/977613745634471937</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really want to make it more elegant, implement the duplicate check in <code>__new__</code>, so it will be performed when you call <code>A(something)</code>.</p>
<p>Just do it in <code>__new__</code>:</p>
<pre><code>def __new__(cls, val=None):
    for i in cls.instances:
        if val == i.val:
            return i
    return object.__new__(cls)
</code></pre>
</div>
<span class="comment-copy"><code>raise ValueError("Can't have objects with same values")</code></span>
<span class="comment-copy">But, a1 and a2 are essentially two references to <b>the same object</b>, which is unavoidable. Your current code well prevents <b>different objects</b> with same value from being created, but you can't stop an object from having two references.</span>
<span class="comment-copy">Maybe you can do it with <code>__new__</code> or <code>__init__</code>.</span>
<span class="comment-copy">You could do the new method inside <b>init</b></span>
<span class="comment-copy">@iBug, code that "<i>prevents different objects with same value from being created</i>" is what i want. Having several references to the same object is ok.</span>
<span class="comment-copy">Thanks, it worked for me. You mentioned important thing that i missed: <code>Notice how a's foo attribute changed</code>.</span>
<span class="comment-copy">One thing i changed is onelining <code>__call__</code> method: <code>def __call__(cls, arg): return cls.instances.setdefault(arg, super(MemoMeta, cls).__call__(arg))</code></span>
<span class="comment-copy">@dodd0ro That's not a great idea. First of all, it's harder to read if it's a single line, and secondly that will create a new instance <i>every time</i>, and then throw it away. (It creates an instance, that instance is passed to <code>setdefault</code>, and if the key already existed in the dict then the instance is discarded.)</span>
<span class="comment-copy">Oh, so that's how it works...</span>
<span class="comment-copy">It's sad that this module doesn't exists in python's 2.7 functools.</span>
<span class="comment-copy">It's too late in <code>__init__</code>, a new instance of the class has <i>already been created</i>.</span>
<span class="comment-copy">Yes, but this is still a bad answer - just do <i>what</i>, exactly?</span>
<span class="comment-copy">Exactly, I wish I <code>__new__</code> it...</span>
<span class="comment-copy">@jonrsharpe Is it that edit?</span>
<span class="comment-copy">One optimization would be to change <code>instances</code> to a dictionary mapping values to instances since each value should only map to one instance</span>
