<div class="post-text" itemprop="text">
<p>i have a list like</p>
<pre><code>list[0][0]="CatA"
list[0][1]="SubCatA"
list[0][2]="3,4"

list[1][0]="CatB"
list[1][1]="SubCatA"
list[1][2]="1,2"

list[2][0]="CatA"
list[2][1]="SubCatA"
list[2][2]="5,9"

list[3][0]="CatA"
list[3][1]="SubCatB"
list[3][2]="4,7"
</code></pre>
<p>Concat Field list[x][2] if list[x][1] equal and list[x][2] equal
So Result have to be like</p>
<pre><code>list[0][0]="CatA"
list[0][1]="SubCatA"
list[0][2]="3,4,5,9"

list[1][0]="CatB"
list[1][1]="SubCatA"
list[1][2]="1,2"

list[3][0]="CatA"
list[3][1]="SubCatB"
list[3][2]="4,7"
</code></pre>
<p>my code looks like</p>
<pre><code>for y in range(len(arr)):
    print(y)
    print(arr[y])
    for z in range(len(arr)):
        print("{}.{}".format(y,z))
        if (y!=z) and (arr[y][0]!=-1) and (arr[y][0]==arr[z][0]) and (arr[y][1]==arr[z][1]):
            arr[y][2]="{},{}".format(arr[y][2],arr[z][2])
            #arr.pop(z) //first approach but error because cannot delete while iterating
            arr[z][0]=-1

print(arr)

res= []
for y in range(len(arr)):
    if (arr[y][0]==-1):
        print("nothing");
    else:
        res.append(arr[y])

print(res)
</code></pre>
<p>Problem: This is very unefficient on large arr[]. i have arr lists length like &gt;2000 so i need run 2*2000*2000 loop bodys.</p>
<p>Anyone have a better Approach to do the job?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a <code>dict</code> or <code>dict</code>like for efficient lookup:</p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; 
&gt;&gt;&gt; result = []
&gt;&gt;&gt; 
&gt;&gt;&gt; def extend_result():
...     result.append([*record[:2], []])
...     return result[-1][2]
... 
&gt;&gt;&gt; uniquizer = collections.defaultdict(extend_result)
&gt;&gt;&gt; 
&gt;&gt;&gt; for record in arr:
...     uniquizer[tuple(record[:2])].append(record[2])
... 
&gt;&gt;&gt; for record in result:
...     record[2] = ','.join(record[2])
... 
&gt;&gt;&gt; result
[['CatA', 'SubCatA', '3,4,5,9'], ['CatB', 'SubCatA', '1,2'], ['CatA', 'SubCatB', '4,7']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try the manual approach with just one loop :</p>
<pre><code>con_list={}

data_=[['CatA', 'SubCatA', '3,4'], ['CatB', 'SubCatA', '1,2'], ['CatA', 'SubCatA', '5,9'], ['CatA', 'SubCatB', '4,7']]

for i in data_:
    if (i[0],i[1]) not in con_list:
        con_list[(i[0],i[1])]=i
    else:
        con_list[(i[0],i[1])]=[i[0],i[1]]+["".join([con_list[(i[0],i[1])][-1]]+[',']+[i[-1]])]

print(list(con_list.values()))
</code></pre>
<p>output:</p>
<pre><code>[['CatA', 'SubCatB', '4,7'], ['CatA', 'SubCatA', '3,4,5,9'], ['CatB', 'SubCatA', '1,2']]
</code></pre>
</div>
<span class="comment-copy">Sort your list of lists and then use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> for grouping using the selected indices.</span>
<span class="comment-copy">In general if you have <code>range(len(...</code> in your code, you should dive deeper into the topic of iterables and <code>for</code> loops.</span>
