<div class="post-text" itemprop="text">
<p>I have a large collection of functions and methods that normally accept date/time objects. I want to adapt these to also accept string representations of a date/time objects.</p>
<p>Consider the following function, which is a simple case</p>
<pre><code>def days_until(until_date, from_date=None):
    if from_date is None:
        from_date = datetime.datetime.now()
    delta = until_date - from_date
    return delta.days
</code></pre>
<p><a href="https://stackoverflow.com/a/9517287/5747944">Using dateutil</a>, I would approach this by altering the function as follows.</p>
<pre><code>def days_until(until_date, from_date=None):
    if isinstance(until_date, str): # preserve backwards compatibility with datetime objects
        until_date = dateutil.parser.parse(until_date)
    if isinstance(from_date, str):
        from_date = dateutil.parser.parse(from_date)
    # ... rest of function as it was before
</code></pre>
<p>While this works, the code is <strong>very repetitive</strong> and it is tedious to do across a large collection of functions, some of which accept as many as five datetimes.</p>
<p>Is there an automatic/generic way to accomplish this conversion to achieve code that is DRY?</p>
</div>
<div class="post-text" itemprop="text">
<p>One could create a decorator that does this. Here, we just blindly attempt to convert each argument into a date/time. If it works, great, we use the date/time, otherwise just use the object.</p>
<pre><code>import functools
import dateutil.parser

def dt_convert(obj):
    if not isinstance(obj, str):
        return obj
    try:
        return dateutil.parser.parse(obj)
    except TypeError:
        return obj

def parse_dates(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        new_args = map(dt_convert, args)
        new_kwargs = {kw: dt_convert(value) for kw, value in kwargs.items()}
        return func(*new_args, **new_kwargs)
    return wrapper
</code></pre>
<p>Which allows you to simply add the decorator to the existing functions like so</p>
<pre><code>@parse_dates
def days_until(until_date, from_date=None)
    # ... the original function logic

&gt;&gt;&gt; christmas = dateutil.parser.parse('12/25')
&gt;&gt;&gt; day_until(christmas, from_date='12/20')
5
</code></pre>
<p>This works in this particular case. However, in some cases you may have arguments that should actually be strings, but would be converted into datetimes erroneously, if the string happened to be a valid datetime as well.</p>
<p>Take for example the following</p>
<pre><code>@parse_dates
def tricky_case(dt: datetime.datetime, tricky_string: str):
    print(dt, tricky_string)
</code></pre>
<p>The result could potentially be unexpected</p>
<pre><code>&gt;&gt;&gt; tricky_case('12/25', '24')
2018-12-25 00:00:00 2018-03-24 00:00:00
</code></pre>
<p>As a workaround for this, we can have a decorator whose parameters are the names of the arguments we want to convert in the decorated function. This solution cheats a little by using <code>inspect</code> to work with the signature of the decorated function. However, it allows us to bind the signature, appropriately handling positional and keyword arguments.</p>
<pre><code>def parse_dates(*argnames):
    def decorator(func):
        sig = inspect.signature(func)

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            ba = sig.bind(*args, **kwargs)
            for argname in argnames:
                if argname in ba.arguments and isinstance(ba.arguments[argname], str):
                    ba.arguments[argname] = dateutil.parser.parse(ba.arguments[argname])
            return func(*ba.args, **ba.kwargs)

        return wrapper
    return decorator
</code></pre>
<p>Then the problem encountered in the ambiguous case can be avoided by specifically specifying that only <code>dt</code> should be converted.</p>
<pre><code>@parse_dates('dt')
def tricky_case(dt: datetime.datetime, tricky_string: str)
    print(dt, tricky_string)
</code></pre>
<p>Then the result is no longer unexpected</p>
<pre><code>&gt;&gt;&gt; tricky_case('12/25', '24')
2018-12-25 00:00:00 24
</code></pre>
<p>A downside compared to the naive approach is, in this case, you still need to visit each function and identify the datetime argument names. Also, this hack uses a feature of <code>inspect</code> that is not available in Python2.x -- in which case you would need to either rework this using <code>inspect.get_arg_spec</code>, or use a third party module that provides the backport for the legacy version of Python.</p>
</div>
<span class="comment-copy">Hmmm... I don't think decorator was necessary for this case, but it could be a opinion based comment.</span>
<span class="comment-copy">In Python 2 you'd use <a href="https://docs.python.org/2/library/inspect.html#inspect.getargspec" rel="nofollow noreferrer"><code>inspect.get_arg_spec()</code></a> to get argument names; it's doable. I'm actually surprised you don't use the annotations you have in your sample <code>tricky_case()</code> function.</span>
<span class="comment-copy">@MoinuddinQuadri: a decorator is an excellent way to abstract the auto-conversion away from multiple functions. Personally, I'd prefer converting strings to datetime objects <i>as early as possible</i> and not leave them hanging around to have to pollute your codebase with decorators like this.</span>
<span class="comment-copy">@MartijnPieters  The annotation was an attempt to reduce confusion for readers, illustrating the argument was originally intended to be a string. In practice, the functions we were converting do not already have annotations, though I suppose we could (should) have added annotations.</span>
<span class="comment-copy">@sytech: when you add proper <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">type hinting annotations</a> you can validate your code too, <i>and</i> have your decorator pull out the annotations to make such conversion decisions. OTOH a decorator like yours then completely blinds the validator again as the decorator can't declare it's input argument types anymore..</span>
