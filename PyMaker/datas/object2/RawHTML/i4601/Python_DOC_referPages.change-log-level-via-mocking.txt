<div class="post-text" itemprop="text">
<p>I want to change the log-level temporarily.</p>
<p>My current strategy is to use mocking.</p>
<pre><code>with mock.patch(...):
    my_method_which_does_log()
</code></pre>
<p>All <code>logging.info()</code> calls inside the method should get ignored and not logged to the console.</p>
<p>How to implement the <code>...</code> to make logs of level INFO get ignored?</p>
<p>The code is single-process and single-thread and executed during testing only.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I want to change the log-level temporarily.</p>
</blockquote>
<p>A way to do this without mocking is <a href="https://docs.python.org/2/library/logging.html#logging.disable" rel="nofollow noreferrer"><code>logging.disable</code></a></p>
<pre><code>class TestSomething(unittest.TestCase):
    def setUp(self):
        logging.disable(logging.WARNING)

    def tearDown(self):
        logging.disable(logging.NOTSET)
</code></pre>
<p>This example would only show messages of level <code>WARNING</code> and above for each test in the <code>TestSomething</code> class. (You call <code>disable</code> at the start and end of each test as needed. This seems a bit cleaner.)</p>
<p>To unset this temporary throttling, call <code>logging.disable(logging.NOTSET)</code>:</p>
<blockquote>
<p>If <code>logging.disable(logging.NOTSET)</code> is called, it effectively removes this overriding level, so that logging output again depends on the effective levels of individual loggers.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I don't think mocking is going to do what you want. The loggers are presumably already instantiated in this scenario, and <code>level</code> is an instance variable for each of the loggers (and also any of the handlers that each logger has).</p>
<p>You can create a custom context manager. That would look something like this:</p>
<h3>Context Manager</h3>
<pre><code>import logging

class override_logging_level():

    "A context manager for temporarily setting the logging level"

    def __init__(self, level, process_handlers=True):
        self.saved_level      = {}
        self.level            = level
        self.process_handlers = process_handlers

    def __enter__(self):

        # Save the root logger
        self.save_logger('', logging.getLogger())

        # Iterate over the other loggers
        for name, logger in logging.Logger.manager.loggerDict.items():

            self.save_logger(name, logger)

    def __exit__(self, exception_type, exception_value, traceback):

        # Restore the root logger
        self.restore_logger('', logging.getLogger())

        # Iterate over the loggers
        for name, logger in logging.Logger.manager.loggerDict.items():

            self.restore_logger(name, logger)

    def save_logger(self, name, logger):

        # Save off the level
        self.saved_level[name] = logger.level

        # Override the level
        logger.setLevel(self.level)

        if not self.process_handlers:
            return

        # Iterate over the handlers for this logger
        for handler in logger.handlers:

            # No reliable name. Just use the id of the object
            self.saved_level[id(handler)] = handler.level

    def restore_logger(self, name, logger):

        # It's possible that some intervening code added one or more loggers...
        if name not in self.saved_level:
            return

        # Restore the level for the logger
        logger.setLevel(self.saved_level[name])

        if not self.process_handlers:
            return

        # Iterate over the handlers for this logger
        for handler in logger.handlers:

            # Reconstruct the key for this handler
            key = id(handler)

            # Again, we could have possibly added more handlers
            if key not in self.saved_level:
                continue

            # Restore the level for the handler
            handler.setLevel(self.saved_level[key])
</code></pre>
<h3>Test Code</h3>
<pre><code># Setup for basic logging
logging.basicConfig(level=logging.ERROR)

# Create some loggers - the root logger and a couple others
lr = logging.getLogger()
l1 = logging.getLogger('L1')
l2 = logging.getLogger('L2') 

# Won't see this message due to the level
lr.info("lr - msg 1")
l1.info("l1 - msg 1")
l2.info("l2 - msg 1")

# Temporarily override the level
with override_logging_level(logging.INFO):

    # Will see
    lr.info("lr - msg 2")
    l1.info("l1 - msg 2")
    l2.info("l2 - msg 2")

# Won't see, again...
lr.info("lr - msg 3")
l1.info("l1 - msg 3")
l2.info("l2 - msg 3")
</code></pre>
<h3>Results</h3>
<pre><code>$ python ./main.py
INFO:root:lr - msg 2
INFO:L1:l1 - msg 2
INFO:L2:l2 - msg 2
</code></pre>
<h3>Notes</h3>
<ul>
<li>The code would need to be enhanced to support multithreading; for example, <code>logging.Logger.manager.loggerDict</code> is a shared variable that's guarded by locks in the <code>logging</code> code.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Using @cryptoplex's approach of using Context Managers, here's the <a href="https://docs.python.org/2/howto/logging-cookbook.html#using-a-context-manager-for-selective-logging" rel="nofollow noreferrer">official version from the logging cookbook</a>:</p>
<blockquote>
<pre><code>import logging
import sys

class LoggingContext(object):
    def __init__(self, logger, level=None, handler=None, close=True):
        self.logger = logger
        self.level = level
        self.handler = handler
        self.close = close

    def __enter__(self):
        if self.level is not None:
            self.old_level = self.logger.level
            self.logger.setLevel(self.level)
        if self.handler:
            self.logger.addHandler(self.handler)

    def __exit__(self, et, ev, tb):
        if self.level is not None:
            self.logger.setLevel(self.old_level)
        if self.handler:
            self.logger.removeHandler(self.handler)
        if self.handler and self.close:
            self.handler.close()
        # implicit return of None =&gt; don't swallow exceptions
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://en.wikipedia.org/wiki/Dependency_injection" rel="nofollow noreferrer">dependency injection</a> to pass the logger instance to the method you are testing. It is a bit more invasive though since you are changing your method a little, however it gives you more flexibility. </p>
<p>Add the logger parameter to your method signature, something along the lines of:</p>
<pre><code>def my_method( your_other_params, logger):
    pass
</code></pre>
<p>In your unit test file:</p>
<pre><code>if __name__ == "__main__":
    # define the logger you want to use:
    logging.basicConfig( stream=sys.stderr )
    logging.getLogger( "MyTests.test_my_method" ).setLevel( logging.DEBUG )

...

def test_my_method(self):
    test_logger = logging.getLogger( "MyTests.test_my_method" )
    # pass your logger to your method    
    my_method(your_normal_parameters, test_logger)
</code></pre>
<p>python logger docs: <a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer">https://docs.python.org/3/library/logging.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I use this pattern to write all logs to a list. It ignores logs of level INFO and smaller.</p>
<pre><code>logs=[]

import logging
def my_log(logger_self, level, *args, **kwargs):
    if level&gt;logging.INFO:
        logs.append((args, kwargs))

with mock.patch('logging.Logger._log', my_log):
    my_method_which_does_log()
</code></pre>
</div>
<span class="comment-copy">Is your code single-threaded/single-process and should it change logging only from within that <code>with</code> block or for everything called by the code in that <code>with</code> block?</span>
<span class="comment-copy">Could you add more info how you currently log? For example using simple calls to <code>logging.info</code> or using a custom <code>logging.Logger</code>? Also are you using <a href="https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler" rel="nofollow noreferrer">streams for logging</a>? Also what should happen to logging levels below info (<code>logging.debug</code>)? Should they be printed or also hidden? As it currently stands it's too broad because there are a lot (too many) of cases to be considered here.</span>
<span class="comment-copy">Not sure what you mean by <code>How to mock my_method_which_does_log</code>, why would you mock the actual method?</span>
<span class="comment-copy">Are you trying to influence a single logger, e.g. the root logger returned by <code>getLogger()</code>, or multiple loggers, e.g. the called code involves multiple modules and each one does <code>getLogger(__name__)</code>?</span>
<span class="comment-copy">@cryptoplex I want to change the log level of all loggers.</span>
<span class="comment-copy">I am unsure if <code>logging.disable(logging.NOTSET)</code> does a clean reset to the original state. Imagine before <code>logging.disable(logging.ERROR)</code> was called before I disable the logging. Then finally the state would be different. But don't get me wrong. This solution is good, much better then no solution!</span>
<span class="comment-copy">@guettli: <code>logging.NOTSET</code> seems to completely reset the behavior of  individual loggers</span>
<span class="comment-copy">if <code>logging.disable(logging.INFO)</code> was done before my code was called, the after my code the reset does reset too much.</span>
<span class="comment-copy">This looks good. I used the term "mocking", but actually a context-manager does solve this, too. Thank you!</span>
<span class="comment-copy">Hmmm this means I need to change my code an pass around <code>logger</code>, yes this definitely works. But I am unsure if I want to do this.</span>
