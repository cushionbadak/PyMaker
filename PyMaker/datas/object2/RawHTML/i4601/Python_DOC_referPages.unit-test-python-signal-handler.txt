<div class="post-text" itemprop="text">
<p>I have a simple Python service, where there is a loop that performs some action infinitely. On various signals, <code>sys.exit(0)</code> is called, which causes <code>SystemExit</code> to be raised and then some cleanup should happen if it can.</p>
<p>In a test, i.e. standard <code>unittest.TestCase</code>, I would like to test that this cleanup happens and the loop exits. However, I'm stuck on even getting the signal to be triggered / <code>SystemExit</code> to be raised.</p>
<pre><code># service.py
import signal
import sys
import time

def main():

    def signal_handler(signalnum, _):
        # How to get this to block to run in a test?
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    while True:
        try:
            print("Some action here")
            time.sleep(10)
        except SystemExit:
            # How to get this to block to run in a test?
            print("Some cleanup")
            break

if __name__ == '__main__':
    main()
</code></pre>
<p>How can the code enter the <code>SystemExit</code> handler / signal handler in the test environment? An alternative pattern would also be welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's refactor that to make it easier to test:</p>
<pre><code>def loop():
    try:
        print("Some action here")
    except:
        # clean up and re-raise
        print("Some cleanup")
        raise

def main():

    def signal_handler(signalnum, _):
        # How to get this to block to run in a test?
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    while True:
        try:
            loop_body()
            time.sleep(10)
        except SystemExit:
            break

if __name__ == '__main__':
    main()
</code></pre>
<p>This doesn't allow easy testing of the signal handling code though. However, that amount is so small, rarely changed and strongly depends on the environment, that it is possible and perhaps even better to test manually.</p>
<p>For clarity, it could be useful to use a context handler, which is usually a good idea when you have setup/shutdown code. You don't mention the setup code, but my Crystall Ball (tm) tells me it exists. It could then be called like this:</p>
<pre><code>try:
    with my_service() as service:
        while True:
            service.run()
            sleep(10)
except SystemExit:
    # perform graceful shutdown on signal
    pass
</code></pre>
<p>I'll leave the implementation of that context manager to you, but check out <a href="https://docs.python.org/3/library/contextlib.html" rel="nofollow noreferrer">contextlib</a>, which makes it easy and fun.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can trigger a SIGINT (or any signal) from another thread after some delay, which is received in the main thread. You can then assert on its effects just as in any other test, as below.</p>
<pre><code>import os
import signal
import time
import threading
import unittest
from unittest.mock import (
    Mock,
    patch,
)

import service

class TestService(unittest.TestCase):

    @patch('service.print')
    def test_signal_handling(self, mock_print):

        pid = os.getpid()

        def trigger_signal():
            while len(mock_print.mock_calls) &lt; 1:
                time.sleep(0.2)
            os.kill(pid, signal.SIGINT)

        thread = threading.Thread(target=trigger_signal)
        thread.daemon = True
        thread.start()

        service.main()

        self.assertEqual(mock_print.mock_calls[1][1][0], 'Some cleanup')


if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<span class="comment-copy">Two stupid approaches come to mind: First one is to reduce the amount of code that is wrapped with the signal handling as much as possible and then to test that manually. The second one is to simply hot-rig the signal module and replace some parts with mocks.</span>
<span class="comment-copy">@UlrichEckhardt Regarding replacing some of signal with mocks, this crossed my mind, but is there a threading issue? The single thread will be inside the infinite loop, so there will be no way to actually trigger the handler passed to the mock signal once the code is in the loop?</span>
<span class="comment-copy">Mock the threading module, too? :P Seriously, maybe you could structure the code so that it exposes the part that is called in a loop. That way, you could test that in isolation. It's hard to tell though, since I have no idea about your code's structure and whether that isn't a real major rewrite. If it's structured as above, I would move the signal handling code and the loop from <code>main()</code> to the <code>if __name__</code> part. Alternatively, if you really want to keep the latter minimal, extract the loop's body into its own function.</span>
<span class="comment-copy">@UlrichEckhardt Sounds like a reasonable approach...feel free to make an answer!</span>
