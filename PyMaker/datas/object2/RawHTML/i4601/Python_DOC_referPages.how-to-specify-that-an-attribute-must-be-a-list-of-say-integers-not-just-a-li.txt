<div class="post-text" itemprop="text">
<p>Using the <a href="https://pypi.python.org/pypi/attrs" rel="noreferrer">attrs libary</a> and Python 3.6, I thought the following would allow me to specify that <code>x</code> and <code>y</code> can only contain integers:</p>
<pre><code>import attr

@attr.s
class C:
  x : List[int] = attr.ib()   # not working
  y = attr.ib(type=List[int]) # not working either
</code></pre>
<p>Both of the commented lines throw a <code>NameError: name 'List' is not defined</code>.</p>
<p>The reasons I expected that to work are these:</p>
<p>(1) The <a href="http://www.attrs.org/en/stable/examples.html#types" rel="noreferrer">types section of the attr documentation</a> includes the following passage: "<code>attrs</code> also allows you to associate a type with an attribute using either the type argument to attr.ib() or – as of Python 3.6 – using PEP 526-annotations". It then demonstrates both methods:</p>
<pre><code>@attr.s
class C:
    x = attr.ib(type=int)
    y: int = attr.ib()
</code></pre>
<p>(2) <a href="https://www.python.org/dev/peps/pep-0526/" rel="noreferrer">PEP 526</a> states that the following syntax for type annotation is valid: <code>primes: List[int] = []</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <em>syntax</em> is indeed valid. But the generic type annotation objects added by <a href="https://www.python.org/dev/peps/pep-0484/" rel="nofollow noreferrer">PEP 484</a> are not in the builtins namespace, but in the <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer"><code>typing</code></a> module.</p>
<p>So, you need to do what all of the examples in the <code>attrs</code> docs you linked, and PEP 484, <a href="https://www.python.org/dev/peps/pep-0483/" rel="nofollow noreferrer">PEP 483</a>, PEP 526, and the <code>typing</code> docs do:</p>
<pre><code>from typing import List
</code></pre>
<hr/>
<p>Also, note that this is just an annotation. You can still write <code>c = C(x=[], y=[1.0])</code> and you won't get a <code>TypeError</code>. As the docs you linked say:</p>
<blockquote>
<p><code>attrs</code> itself doesn’t have any features that work on top of type metadata yet. However it’s useful for writing your own validators or serialization frameworks.</p>
</blockquote>
<p>It's not at all clear what <code>attrs</code> <em>should</em> do with this metadata. It's a central part of the design of PEP 483/PEP 484 that type annotations are nothing more than annotations are runtime, and do not affect the types of values or what's legal to store where; they're only there to be used by static type checkers and other tools that runs separately from Python.</p>
<p>In particular, Mypy (the reference-standard static type checker), some linters, and some IDEs should flag this as an error. If they don't support <code>attrib</code> annotations yet, they're almost certainly working on it (since they're roughly equivalent to annotated attributes in <a href="https://www.python.org/dev/peps/pep-0557/" rel="nofollow noreferrer">3.7/PEP 557 <code>dataclass</code></a>).</p>
</div>
<span class="comment-copy">Thanks! Now it compiles, but it's still letting me use a list of strings.</span>
<span class="comment-copy">@JeffreyBenjaminBrown Yes, because static type annotations don't affect dynamic types. That's central to the design of PEP 483/PEP 484, and specifically called out in the docs you linked in a big pink box. I'll edit the answer to explain more.</span>
