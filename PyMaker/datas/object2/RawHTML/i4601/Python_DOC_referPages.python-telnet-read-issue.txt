<div class="post-text" itemprop="text">
<p>im trying to read from a telnet server that sends no ending line or special character to tell the python telnet client that the read should be finished. this data is then sent to a tkinter text entry widget where i want it to constantly update with new data sent from the telnet server. the problem in having is i cant find a way "without blocking the loop" to read from the telnet server. thanks</p>
<pre><code>  def Telnet_Client(self):
    HOST = self.TelnetHostIP
    tn = telnetlib.Telnet(HOST)
    tn.write("s")
    tnrecv = tn.read_until("&gt;", timeout=1)
    self.R.insert(tk.END, tnrecv)
    tn.close()
</code></pre>
<p>i have used read_some() but i dont get all the data, and read_until("&gt;", timeout=1) blocks the code becasue it never gets a ending line or command to stop reading</p>
</div>
<div class="post-text" itemprop="text">
<p>The traditional solution to this problem is to spawn a background thread to talk to the socket. That background thread can block on the read, and it won't affect any other threads. However, there is a problem with this: <code>tkinter</code> is not thread-safe, and attempting to update your <code>Entry</code> widget from a background thread will fail. (Depending on your platform, it may crash, block the program, or, worst of all, work intermittently and cause a slew of mysterious bugs.)</p>
<p>There are workarounds you can search for, but none of them are great.</p>
<p>The basic idea is to have the background thread send messages to the main thread—e.g., by posting them on a <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer"><code>queue.Queue</code></a>, which the main thread can check (with a <code>get(block=False)</code>). But checking each time through the event loop may be too often while you're moving the mouse, but not often enough while you're idle—and if you ask tkinter to fire your check every N seconds, that can keep a laptop from going to sleep. Also, getting this right isn't exactly <em>hard</em>, but it's not trivial.</p>
<p>There used to be a nice library that wrapped this all up as well as possible, called <code>mtTkinter</code>, but it was abandoned long ago. I <a href="https://github.com/abarnert/mttkinter" rel="nofollow noreferrer">ported it to Python 3</a> a few years back, but ended up not using it, so that version is effectively abandoned too. It might just work, but I'm not making any promises.</p>
<p>The advantage of this solution is that it's very easy: <code>import mttkinter as tkinter</code>, add a <code>threading.Thread(target=telnet_loop)</code>, a couple more minor changes, and you're done… if it works.</p>
<hr/>
<p>The more modern solution is to use <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a> (or a predecessor like Twisted or a competitor like Curio).</p>
<p>You can drive the <code>asyncio</code> loop from the Tkinter event loop, and it's a lot cleaner than any of the threading workarounds. A there are ready-made libraries to do it for you. (I don't know the current state of things, but I used the original <a href="https://github.com/fluentpython/asyncio-tkinter" rel="nofollow noreferrer"><code>asyncio-tkinter</code></a> a few years back.)</p>
<p>The only problem is that you can't use <code>telnetlib</code>, because it wasn't designed for <code>asyncio</code>. But there are almost certainly more modern Telnet libraries out there that were. (From a quick search, I found <a href="https://pypi.python.org/pypi/telnetlib3" rel="nofollow noreferrer"><code>telnetlib3</code></a>, which looks promising, but I don't know nearly enough to recommend it.)</p>
<p>Of course this solution requires rewriting most of your networking code—but you don't have very much of it, and it's not working, so that doesn't seem like too much of a tragedy. Your tkinter code, meanwhile, should only require a one-line change.</p>
</div>
<span class="comment-copy">why not use threading?</span>
<span class="comment-copy">but how do stop the never ending read process ?</span>
<span class="comment-copy">You don't <i>need</i> to stop the read if it's on a background thread; that's the whole point of using threading—the thread can just block until there's something to read, and your other threads just keep running.</span>
<span class="comment-copy">However, talking to a tkinter GUI from a background thread is impossible, and the workarounds are a bit hairy, so it's not <i>quite</i> as easy as it sounds.</span>
<span class="comment-copy">wow that's a lot. i didn't think it would be this complicated. i was going to switch to python 3 but i was having a telnetlib issue so now it has me wanting to make the change to python 3</span>
