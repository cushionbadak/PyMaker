<div class="post-text" itemprop="text">
<p>For an application I'm working on, I'm searching a directory of files, and expecting to find matching pairs of files to perform some further analysis on.</p>
<p>In this case, a pair is defined as matching on some subset of attributes, but differing in some other attributes.</p>
<p>As part of the error handling/warning, I want to identify any files found that are "incomparable," i.e. files for which the expected "partner" in the pair is not found.</p>
<p>I have a class of objects to store the structured attribute information, and when I read files in the directory, I store each file I find as an element in list of these objects.</p>
<p>Here's a silly simple example</p>
<pre><code>class glove(object):
    def __init__(self, size, color, is_right):
        self.size = size
        self.color = color
        self.is_right = is_right

    def __repr__(self):
        if self.is_right:
            hand = "right"
        else:
            hand = "left"
        s = "{} {} {}".format(self.size, self.color, hand)
        return(s)


gloves = [glove('med', 'black', False),
          glove('med', 'black', True),
          glove('lg', 'black', False),
          glove('lg', 'black', True),
          glove('med', 'brown', False),
          glove('med', 'brown', True),
          glove('lg', 'blue', False),
          glove('med', 'tan', False)]

left_gloves = [x for x in gloves if not x.is_right]
right_gloves = [x for x in gloves if x.is_right]
</code></pre>
<p>Let's assume that there's no duplicate elements in the list, and let's define a "pair" as two <code>glove</code> objects that have matching <code>glove.size</code> and <code>glove.color</code> but different values of <code>glove.is_right</code> (i.e. one is Right and one is Left).</p>
<p>Now I'd like to identify incomplete pairs (perhaps into a list of <code>leftovers</code> so that I could error or warn appropriately, e.g. "No Left lg blue glove found" "No Left med tan glove found."</p>
<p>I've seen <a href="https://stackoverflow.com/a/41125943/1009730">answers</a> that teach how to identify items "missing" from pairs of lists, but my application has a couple of complexities that I couldn't figure out how to address: linking on attributes of an object, and linking on multiple attributes of an object.</p>
<p>I imagine something is possible with for loops and list comprehension, but I can't quite figure out how to link it all together.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's pretty easy if you can implement equality/hash for your class:</p>
<pre><code>class glove(object):
    def __init__(self, size, color, is_right):
        self.size = size
        self.color = color
        self.is_right = is_right

    def __repr__(self):
        if self.is_right:
            hand = "right"
        else:
            hand = "left"
        s = "{} {} {}".format(self.size, self.color, hand)
        return(s)

    def __eq__(self, other):
        return isinstance(other, glove) and \
            other.size == self.size and \
            other.color == self.color \
            and other.is_right == self.is_right

    def __hash__(self):
        return hash((self.size, self.color, self.is_right))


gloves = [glove('med', 'black', False),
          glove('med', 'black', True),
          glove('lg', 'black', False),
          glove('lg', 'black', True),
          glove('med', 'brown', False),
          glove('med', 'brown', True),
          glove('lg', 'blue', False),
          glove('med', 'tan', False)]

gloves_set = set(gloves)
unpaired = [g for g in gloves if glove(g.size, g.color, not g.is_right) not in gloves_set]
print(unpaired)
</code></pre>
<p>Output:</p>
<pre><code>[lg blue left, med tan left]
</code></pre>
<p>You can also consider using <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a>, which actually does these for you.</p>
<hr/>
<p>Here is an alternative that does not require implementing equals and hash, nor creating new objects:</p>
<pre><code>class glove(object):
    def __init__(self, size, color, is_right):
        self.size = size
        self.color = color
        self.is_right = is_right

    def __repr__(self):
        if self.is_right:
            hand = "right"
        else:
            hand = "left"
        s = "{} {} {}".format(self.size, self.color, hand)
        return(s)


gloves = [glove('med', 'black', False),
          glove('med', 'black', True),
          glove('lg', 'black', False),
          glove('lg', 'black', True),
          glove('med', 'brown', False),
          glove('med', 'brown', True),
          glove('lg', 'blue', False),
          glove('med', 'tan', False)]

# With plain dict
glove_search = {}
for g in gloves:
    glove_search.setdefault(g.size, {}).setdefault(g.color, {})[g.is_right] = True
unpaired = [g for g in gloves
            if not glove_search.get(g.size, {}).get(g.color, {}).get(not g.is_right, False)]

# Or, more idiomatically, with defaultdict
from collections import defaultdict
glove_search = defaultdict(lambda: defaultdict(lambda: defaultdict(bool)))
for g in gloves:
    glove_search[g.size][g.color][g.is_right] = True
unpaired = [g for g in gloves if not glove_search[g.size][g.color][not g.is_right]]

print(unpaired)
</code></pre>
<p>Output:</p>
<pre><code>[lg blue left, med tan left]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With no duplicates allowed, the problem is relatively simple.
Concatenate your identifiers: </p>
<pre><code>self.ID = self.size + " " + self.color
</code></pre>
<p>Build left/right subsets on the ID's alone.</p>
<pre><code>left  = {g.ID for g in gloves if not g.is_right)
right = {g.ID for g in gloves if     g.is_right)

unmatched_left  = left - right
unmatched_right = right - left
</code></pre>
<p>Now, simply reverse the key process to get the glove objects:</p>
<pre><code>unmatched = [g for g in glove_set \
             if g.ID in unmatched_left + unmatched_right]
</code></pre>
</div>
<span class="comment-copy">Are the items unique?  Can you have more than one "left med tan" glove, for instance?</span>
<span class="comment-copy">@chrisz I only know I have a missing glove if I find one that is missing a partner. In the above example, per this definition, there are only two known missing gloves.</span>
<span class="comment-copy">@Prune we're assuming no duplicates are allowed, and that there's proper protections in place to guarantee this.</span>
<span class="comment-copy">whoa, this looks really elegant, and introduces some new-to-me concepts that I need to do some reading on</span>
<span class="comment-copy">I just caught that this solution relies on creating a new glove object in the list comprehension line as part of the comparison. Any way to make this approach work if the constructor for glove doesn't actually support creating a glove object by attributes? (my real-life example constructs glove objects by parsing a file)</span>
<span class="comment-copy">@mac Yes, this approach requires having the looked-for object, either created there or through some <code>makePair</code> method or similar. I can try to think of an alternative later...</span>
<span class="comment-copy">@mac I've added another alternative that does not require creating objects.</span>
<span class="comment-copy">Awesome. That will work well for my application. I also appreciate the original answer, I know that will come in handy some day.</span>
