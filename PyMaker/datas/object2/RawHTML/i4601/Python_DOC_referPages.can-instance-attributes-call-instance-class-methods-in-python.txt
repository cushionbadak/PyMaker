<div class="post-text" itemprop="text">
<p>Python noob here, trying to work more with classes and have broken my code down into a more simple example of what I am working with:</p>
<p>Lets say I have a class, with an instance and an attribute associated with that instance</p>
<pre><code>class Foo(object):
    def __init__(self, attribute=None):
        self.attribute = attribute

    def dosomething(self):
        print('I did a thing!')

a = Foo()
a.attribute='bar'
</code></pre>
<p>Now, running the method from the instance 'a' works as expected</p>
<pre><code>a.dosomething()
</code></pre>
<p>Out:</p>
<pre><code>I did a thing!
</code></pre>
<p>However, trying to call the method from an attribute of 'a' results in error</p>
<pre><code>a.attribute='bar'
a.attribute.dosomething()
AttributeError: 'str' object has no attribute 'dosomething'
</code></pre>
<p>This results in an attribute error, which is expected. 'a.attribute' is no longer a class type of 'Foo' but rather a class type of 'str'. My question is, can I do something inside the class to allow the attribute to use the class methods?</p>
<p>Furthermore, since I have not found any results for this during my interwebs searches, Im assuming that it likely is not recommended and probably not pythonic? (just a guess). I am open to suggestions on how to make this better, but ideally, I would like to keep the attribute the way it is while still being able to call the class methods. The dot syntax of attributes for classes really helps me keep things organized, but it is useless to me if it cannot call the methods in the class from which it originates.</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>No, this doesn't work. And it really doesn't make sense if you understand how classes work.</p>
<p>That <code>a.attribute</code> is just a name for the string <code>'bar'</code>. That string doesn't know anything about <code>a</code>, and shouldn't.<sup>1</sup> There could be plenty of other names for the same string. For example:</p>
<pre><code>&gt;&gt;&gt; bar = 'bar'
&gt;&gt;&gt; a.attribute = bar
&gt;&gt;&gt; bar.dosomething()
AttributeError: 'str' object has no attribute 'dosomething'
</code></pre>
<p>That's exactly what you'd expect, right? But…</p>
<pre><code>&gt;&gt;&gt; a.attribute is bar
True
</code></pre>
<p>Since <code>bar</code> is the same object as <code>a.attribute</code>, it clearly has to do the same thing:</p>
<pre><code>&gt;&gt;&gt; a.attribute.dosomething()
AttributeError: 'str' object has no attribute 'dosomething'
</code></pre>
<hr/>
<p><sub>1. There are some special cases where something like this would be useful, but they're solved by having the attribute <em>not</em> just be a string, but instead be some kind of smart object that works kind of like a string but also knows its class, instance, or parent. See the <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer"><code>enum</code></a> module in the stdlib for an example—and click on the <a href="https://github.com/python/cpython/blob/3.6/Lib/enum.py" rel="nofollow noreferrer">source code</a> link to see how it's implemented.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>In this example the attribute is is a string when you execute <code>a.attribute='bar'</code> so if you were to do <code>type(a.attribute)</code> it would return <code>string</code>. So Python is looking for the attribute <code>dosomething()</code> in the <code>str</code> class and not finding it.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you seem to be trying to do doesn't really make sense. At a guess, it seems like you've mixed up some concepts related to <strong>inheritance</strong> with your understanding of python's dot syntax for member reference, when these have nothing to do with each other.</p>
<p>You wrote</p>
<blockquote>
<p>'a.attribute' is no longer a class type of 'Foo' but rather a class type of 'str'.</p>
</blockquote>
<p>and this indicates a fundamental misunderstanding of what is going on. No state has changed – <code>a</code> is still the instance <code>a</code>, of type <code>Foo</code>. It has a member <code>attribute</code>, which is a string. The expression <code>a.attribute</code> is merely <em>pointing to</em> that string. If you need to call a method on <code>a</code>, you can still do so anywhere you were trying to call it on <code>a.attribute</code>:</p>
<pre><code>&gt;&gt;&gt; a.attribute = 'bar'
&gt;&gt;&gt; a.doSomething()
I did a thing!
</code></pre>
<p>The common scenario in which an object of one type invokes a method that is not defined in its class is <strong>inheritance</strong>:</p>
<pre><code>class Foo(object):
  def superclass_method(self):
    print "Hi"

class Bar(Foo):
  pass

b = Bar()
b.superclass_method() # prints "Hi"
</code></pre>
<p>In this case, we say that b, an instance of Bar, <em>is a</em> Foo as well. Therefore any method that Foo defines, a Bar instance has access to.</p>
<p>If you tell us a bit more about what you're trying to accomplish, I can be more specific about whether and how you should be using inheritance. But the dot notation is just a way to talk about values attached to objects. It's literally just looking in the left object's dictionary for a value associated with the name on the right – <code>foo.bar</code> is equivalent to <code>getattr(foo, 'bar')</code>.</p>
</div>
<span class="comment-copy">is your actual attribute another class? Is there a reason for wanting to do a.attr.do() vs simply a.do()?</span>
<span class="comment-copy"><code>dosomething</code> is not a class method, it's an instance method. And what you are trying to do is not pythonic</span>
<span class="comment-copy">You should show some real examples where "the dot syntax of attributes for classes really helps me keep things organized". It's hard to understand what problem you are trying to solve by abusing attributes in this way.</span>
<span class="comment-copy">The real application of this is that I have a class method that queries a pandas dataframe in a more "useful / friendlier" way. (i.e. instead of pd.query('a &lt; b &amp; c &gt; d .... | y == z') i have a method that simplifies this for the end user). I have another method that takes the dataframe associated with the class instance (lets call it 'a.df') and does some calculations to it, and returns the dataframe (lets call it 'a.calculated'). However, I still need 'a.calculated' to be able to use the query method I designed, should the user want to look at a subset of the calculated data.</span>
<span class="comment-copy">use a free function that takes an instance of dataframe and pass a.df into it first, then a.calculated?</span>
<span class="comment-copy">The real application of this is that I have a class method that queries a pandas dataframe in a more "useful / friendlier" way. (i.e. instead of pd.query('a &lt; b &amp; c &gt; d .... | y == z') i have a method that simplifies this for the end user). I have another method that takes the dataframe associated with the class instance (lets call it 'a.df') and does some calculations to it, and returns the dataframe (lets call it 'a.calculated'). However, I still need 'a.calculated' to be able to use the query method I designed, should the user want to look at a subset of the calculated data.</span>
<span class="comment-copy">Well, you could just have them call the same method with <code>a.calculated</code> as the argument instead of <code>a.df</code>. But you could also do it with inheritance – make a subclass of DataFrame that has your new query method, and change it so it wraps the returned DataFrame in a new instance of your subclass.</span>
