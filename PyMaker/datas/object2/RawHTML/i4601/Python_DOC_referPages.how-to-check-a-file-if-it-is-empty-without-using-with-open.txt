<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2104080/how-to-check-file-size-in-python">How to check file size in python?</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<p>I am trying to read text files in a directory. However before doing any action I want to make sure it is not empty. If the text file is empty I need to create that empty file again (<em>in the current directory that is</em>), if not I need to perform some calculations with the each line of the text file and create corresponding file with same name. In short, I need to create as many files as the referred directory (<code>path_in</code>) has.</p>
<p>So to check if the text file is empty I thought I should open it first. I opened it with <code>open</code> and  its handle is <code>filename_handle</code>. I checked if it is empty, but here it raises <code>TypeError: argument should be string, bytes or integer, not _io.TextIOWrapper</code>. I know why this error occured (because <code>filename_handle</code> is object), but I don't know the other way of how I can check if the file is empty.</p>
<p>Can someone help me how to fix this.</p>
<p>Here is my code</p>
<pre><code>import numpy as np
import cv2, os
from glob import glob

path_in = 'C:\\Users\\user\\Desktop\\labels'

for filename in os.listdir(path_in):
    filename_edited = []
    with open(path_in + '\\' +filename) as filename_handle:

        if os.stat(filename_handle).st_size == 0:
            filename_edited.append(filename_handle)
        else:
            for line in filename_handle:
                numericdata = line.split(' ')
                numbers = []
                for i in numericdata:
                    numbers.append(int(i))
                c,x,y = numbers
                edited = [c, y, (19-x)]
                filename_edited.append(edited)
                filename_edited_array = np.array(filename_edited)

        with open(filename , 'wb') as f:
            np.savetxt(f, filename_edited_array,fmt= '%.1i', delimiter=' ', newline='\n', header='', footer='', comments='# ')

        continue
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the os.path.getsize() method to get the size in bytes of the file you pass as argument for it. If the file is empty, it's size will be 0 bytes. So you can use the code below to check it for you:</p>
<pre><code>import os
if os.path.getsize('path/to/file.txt') == 0: # If the file size is 0 bytes
    # Implementation
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/os.html#os.stat" rel="nofollow noreferrer"><code>os.stat</code> takes the file name or the integer file descriptor</a>. It doesn't accept arbitrary file objects.</p>
<p>So you need to either do:</p>
<pre><code>os.stat(filename_handle.fileno()).st_size
</code></pre>
<p>which extracts the file descriptor from the open file, or:</p>
<pre><code>os.stat(path_in + '\\' +filename).st_size
</code></pre>
<p>which stats the file by name, with needing an open file handle. More properly, you should really be using <code>os.path.join</code> to build paths, so <code>os.stat(os.path.join(path_in, filename)).st_size</code> would be the cleaner approach when doing this by name.</p>
</div>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ it is not what I am asking, in that case it reads a file as string and outputs <code>FileNotFoundError</code></span>
<span class="comment-copy">I didn't try it @ShadowRanger, the answerby Ronald Pereira was enough to do the job. Thank you anyway!</span>
<span class="comment-copy">os.scandir() would be more consistent with his program.</span>
<span class="comment-copy">@bitchaser: If you can use it, <code>os.scandir</code> is generally better for <i>every</i> program; it's faster and more convenient in general (if nothing else, it makes it trivial to get either the name or qualified path easily without string manipulation, and lets you process huge directories file by file without minutes long delays accumulating files). I'm leery of recommending stuff only available (built in) in 3.5+ quite yet though, especially when it's quite a tangent from the main question, because invariably the "3.x" ends up being some archaic version like 3.3 or 3.4 that lacks it.</span>
