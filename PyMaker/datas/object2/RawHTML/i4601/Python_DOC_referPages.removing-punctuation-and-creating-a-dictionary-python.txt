<div class="post-text" itemprop="text">
<p>I'm trying to create a function that removes punctuation and lowercases every letter in a string. Then, it should return all this in the form of a dictionary that counts the word frequency in the string.</p>
<p>This is the code I wrote so far:</p>
<pre><code>def word_dic(string):
    string = string.lower()
    new_string = string.split(' ')
    result = {}

    for key in new_string:
        if key in result:
            result[key] += 1
        else:
            result[key] = 1

    for c in result:
        "".join([ c if not c.isalpha() else "" for c in result])

    return result
</code></pre>
<p>But this what i'm getting after executing it:</p>
<pre><code>{'am': 3,
 'god!': 1,
 'god.': 1,
 'i': 2,
 'i?': 1,
 'thanks': 1,
 'to': 1,
 'who': 2}
</code></pre>
<p>I just need to remove he punctuation at the end of the words.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>"".join([ c if not c.isalpha() else "" for c in result])</code> creates a new string without the punctuation, but it doesn't <em>do</em> anything with it; it's thrown away immediately, because you never store the result.</p>
<p>Really, the best way to do this is to normalize your keys <em>before</em> counting them in <code>result</code>. For example, you might do:</p>
<pre><code>for key in new_string:
    # Keep only the alphabetic parts of each key, and replace key for future use
    key = "".join([c for c in key if c.isalpha()])
    if key in result:
        result[key] += 1
    else:
        result[key] = 1
</code></pre>
<p>Now <code>result</code> never has keys with punctuation (and the counts for <code>"god."</code> and <code>"god!"</code> are summed under the key <code>"god"</code> alone), and there is no need for another pass to strip the punctuation after the fact.</p>
<p>Alternatively, if you only care about leading and trailing punctuation on each word (so <code>"it's"</code> should be preserved as is, not converted to <code>"its"</code>), you can simplify a lot further. Simply <code>import string</code>, then change:</p>
<pre><code>    key = "".join([c for c in key if c.isalpha()])
</code></pre>
<p>to:</p>
<pre><code>    key = key.rstrip(string.punctuation)
</code></pre>
<p>This matches what you specifically asked for in your question (remove punctuation at the end of words, but not at the beginning or embedded within the word).</p>
</div>
<div class="post-text" itemprop="text">
<p>Another option is to use that famous Python's <a href="https://en.wikipedia.org/wiki/Batteries_Included" rel="nofollow noreferrer">batteries included</a>.</p>
<pre><code>&gt;&gt;&gt; sentence = 'Is this a test? It could be!'
&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; Counter(re.sub('\W', ' ', sentence.lower()).split())
Counter({'a': 1, 'be': 1, 'this': 1, 'is': 1, 'it': 1, 'test': 1, 'could': 1})
</code></pre>
<p>Leverages <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> for counting words, and <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a> for replacing everything that's not a word character.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>string.punctuation</code> to recognize punctuation and use <code>collections.Counter</code> to count occurence once the string is correctly decomposed.</p>
<pre><code>from collections import Counter
from string import punctuation

line = "It's a test and it's a good ol' one."

Counter(word.strip(punctuation) for word in line.casefold().split())
# Counter({"it's": 2, 'a': 2, 'test': 1, 'and': 1, 'good': 1, 'ol': 1, 'one': 1})
</code></pre>
<p>Using <code>str.strip</code> instead of <code>str.replace</code> allows to preserve words such as <em>It's</em>.</p>
<p>The method <code>str.casefold</code> is simply a more general case of <code>str.lower</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe if you want to reuse the words later, you can store them in a sub-dictionary along with its ocurrences number. Each word will have its place in a dictionary. We can create our own function to remove punctuation, pretty simple.
See if the code bellow serves your needs:</p>
<pre><code>def remove_punctuation(word):
    for c in word:
        if not c.isalpha():
            word = word.replace(c, '')
    return word


def word_dic(s):
    words = s.lower().split(' ')
    result = {}

    for word in words:
        word = remove_punctuation(word)

        if not result.get(word, None):
            result[word] = {
                'word': word,
                'ocurrences': 1,
            }
            continue
        result[word]['ocurrences'] += 1  

    return result


phrase = 'Who am I and who are you? Are we gods? Gods are we? We are what we are!'
print(word_dic(phrase))
</code></pre>
<p>and you'll have an output like this:</p>
<p><code>{
    'who': {
        'word': 'who', 
        'ocurrences': 2}, 
    'am': {
        'word': 'am', 
        'ocurrences': 1}, 
    'i': {
        'word': 'i', 
        'ocurrences': 1}, 
    'and': {
        'word': 'and', 
        'ocurrences': 1}, 
    'are': {
        'word': 'are', 
        'ocurrences': 5}, 
    'you': {
        'word': 'you', 
        'ocurrences': 1}, 
    'we': {
        'word': 'we', 
        'ocurrences': 4}, 
    'gods': {
        'word': 'gods', 
        'ocurrences': 2}, 
    'what': {
        'word': 'what', 
        'ocurrences': 1}
}</code></p>
<p>Then you can easily access each word and its ocurrences simply doing:</p>
<pre><code>word_dict(phrase)['are']['word']       # output: are
word_dict(phrase)['are']['ocurrences'] # output: 5
</code></pre>
</div>
<span class="comment-copy">Upvoted for including options. Defaultdict int would create more compact code right?</span>
<span class="comment-copy">@AntonvBR: Yes. And <code>collections.Counter</code> would be more explanatory (with equivalent behavior). That said, even without <code>defaultdict(int)</code> (or imports of any kind), you could do <code>result[key] = result.get(key, 0) + 1</code> and avoid the LBYL four-liner in favor of a one-liner.</span>
<span class="comment-copy">Hi!! i really apreciated all of your help :) the code provided by ShadowRanger really delivered what i wanted. I feel annoyed because i saw i was near to get it, i just forgot to store the "".join part in a variable. I'll pay more attention the next time.  Thanks a lot guys!!</span>
<span class="comment-copy">Nice (+1) but for readability I'd use more lines and variables.</span>
<span class="comment-copy">Converting non-word characters to spaces, then splitting, is going to make <code>"it's"</code> get treated as the words <code>"it"</code> and <code>"s"</code>. Usually, you want to split on whitespace, then strip punctuation, or strip punctuation and split on whitespace, not convert punctuation to whitespace.</span>
<span class="comment-copy">@ShadowRanger, good point. Although this is just a toy example..</span>
<span class="comment-copy">wow that's some master code!! thanks a lot, this helped and teached me a lot!! :)</span>
<span class="comment-copy">@Miguel2488, no problem.</span>
