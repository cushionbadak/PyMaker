<div class="post-text" itemprop="text">
<p>Write a program to compute the sum of the terms of the series: 4 - 8 + 12 - 16 + 20 -
24 + 28 - 32 + .... +/- n, where n is an input. Consider that n is always valid (which
means it follows the series pattern).</p>
<pre><code>n = int(input("Enter n: "))
sum = 0
for i in range(4,n+4,4):
    sum += i - (i+2)
print("The sum of %s first terms is: %s"%(n,sum))
</code></pre>
<p>Can't seem to find the issues that Ihave</p>
</div>
<div class="post-text" itemprop="text">
<p>How about an explicit formula?</p>
<pre><code>def sumSeries(n):
  if n / 4 % 2 == 0:
    return - n / 2
  else:
    return (n + 4) / 2
</code></pre>
<p>The series doesn't do anything too interesting, it just keeps adding <code>+4</code> every two steps, and flips the sign in even steps:</p>
<pre><code>4               = 4
4 - 8           = -4
4 - 8 + 12      = 8
4 - 8 + 12 - 16 = -8
...
</code></pre>
<p>Some examples:</p>
<pre><code>for n in range(4, 100, 4):
  print("%d -&gt; %d" % (n, sumSeries(n)))
</code></pre>
<p>Output:</p>
<pre><code>4 -&gt; 4
8 -&gt; -4
12 -&gt; 8
16 -&gt; -8
20 -&gt; 12
24 -&gt; -12
28 -&gt; 16
32 -&gt; -16
36 -&gt; 20
40 -&gt; -20
44 -&gt; 24
48 -&gt; -24
52 -&gt; 28
56 -&gt; -28
60 -&gt; 32
64 -&gt; -32
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all, know that your series sum has a closed form.</p>
<pre><code>def series_sum(n):
    sign = 1 if n % 2 else -1
    value = (n - 1) // 2 * 4 + 4
    return sign * value

series_sum(1) # 4
series_sum(2) # -4
series_sum(3) # 8
</code></pre>
<p>But in general, infinite series are a good usecase for generators.</p>
<pre><code>def series():
    value = 0
    sign = -1
    while True:
        value += 4
        sign *= -1
        yield sign * value

s = series()

next(s) # 4
next(s) # -8
next(s) # 12
</code></pre>
<p>Thus for getting the sum you can do this.</p>
<pre><code>s = series()

def sum_series(n, s):
    return sum(next(s) for _ in range(n))

sum_series(5, s) # 12
</code></pre>
<p>An interesting question asked in the comment is also, given some value, how can we recover the sum up until that value is reached in the series. The generator approach is well suited for these kind of problems.</p>
<pre><code>from itertools import takewhile

def sum_until(val):
    return sum(x for x in takewhile(lambda x: -val &lt;= x &lt;= val, series()))

sum_until(12) # 8
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python can be used to easily compute mathematical sequences and series.  </p>
<p>We find the sum of all values computed up to and including <code>n</code></p>
<p><strong>Given</strong></p>
<p>the following mathematical components:</p>
<p><a href="https://i.stack.imgur.com/sNM6z.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/sNM6z.png"/></a></p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Generating_function" rel="nofollow noreferrer">generating function</a> (<code>A</code>)</li>
<li>sample <a href="https://en.wikipedia.org/wiki/Alternating_series" rel="nofollow noreferrer">alternating</a> <a href="https://en.wikipedia.org/wiki/Arithmetic_progression" rel="nofollow noreferrer">arithmetic sequence</a> (<code>B</code>)</li>
<li>summation equation (<code>C</code>)</li>
</ol>
<p>We now implement two approaches <code>A</code> and <code>C</code> verified by <code>B</code>.  </p>
<p><strong>Code</strong></p>
<pre><code>import itertools as it


n = 8
</code></pre>
<p>Generating Function, <code>A</code></p>
<pre><code>seq = [(-1)**(i + 1)*(4 * i) for i in range(1, n + 1)]
sum(seq)
# -16
</code></pre>
<p>Summation Equation, <code>C</code></p>
<pre><code>def f(n):
    if n == 1:
        return 1
    elif n % 2 == 0:
        return -n // 2
    else:
        return (n + 1) // 2


4*f(n)
# -16
</code></pre>
<hr/>
<p><strong>Details</strong></p>
<p><em>Generating Function</em></p>
<p>This first approach simply sums an arithmetic sequence generated by a list comprehension.  The signs of values alternate by the expression <code>(-1)**(i + 1)</code>:</p>
<pre><code>seq
# [4, -8, 12, -16, 20, -24, 28, -32]
</code></pre>
<p>Similarly, an infinite sequence can be made using a generator expression and <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count</code></a>:</p>
<pre><code>inf_seq = ((-1)**(i + 1)*(4 * i) for i in it.count(1))
sum(it.islice(inf_seq, n))
# -16
</code></pre>
<p>Here the sum is returned for a slice of <code>n</code> values.  Note, we can use the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>take</code> itertools recipe</a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate</code></a> to compute some arbitrary number of summations, e.g. 10 sums (see also <a href="https://docs.python.org/3/library/itertools.html#itertools.takewhile" rel="nofollow noreferrer"><code>itertools.takewhile</code></a>).</p>
<pre><code>def take(n, iterable):
    "Return first n items of the iterable as a list"
    return list(it.islice(iterable, n))


inf_seq = ((-1)**(i + 1)*(4 * i) for i in it.count(1))
list(take(10, it.accumulate(inf_seq)))
# [4, -4, 8, -8, 12, -12, 16, -16, 20, -20]
</code></pre>
<p><em>Summation Equation</em></p>
<p>The second approach comes from inspection, where a pattern is determined from the outputs of a sample sequence:</p>
<pre><code> n       4n        f(n)       4f(n)
---     ----       ----       -----
  1        4         1    -&gt;     4
  2       -8        -1    -&gt;    -4
  3       12         2    -&gt;     8
  4      -16        -2    -&gt;    -8
  5       20         3    -&gt;    12
  6      -24        -3    -&gt;   -12
  7       28         4    -&gt;    16
  8      -32        -4    -&gt;   -16
  9       36         5    -&gt;    20
 10      -40        -5    -&gt;   -20
</code></pre>
<p>For an arbitrary final value <code>n</code>, a value of the sequence is generated (<code>4n</code>).  When multiplied with some unknown function, <code>f(n)</code>, a resultant sum is computed  (<code>4f(n)</code>).  We determine a pattern for <code>f(n)</code> by deducing the relationship between the sequence values and expected sums.  Once determined, we directly implement a function that computes our desired sums.</p>
<p><strong>Highlights</strong></p>
<ul>
<li>Mathematical sequences can be generated from list comprehensions.</li>
<li>Infinite sequences can be made from generator expressions.</li>
<li>Mathematical series/generating functions can be computed using reducing functions, e.g. <code>sum()</code>, <code>operator.mul()</code>, etc. applied to sequences.</li>
<li>General summation equations can be implemented as simple Python functions.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>As @John Coleman pointed out, <code>sum += i - (i+2)</code> produces one result not as you expected.</p>
<p>Below is my solution:</p>
<p>Using <code>if else</code> to determinate the sign, then sum up. at last, put it into another loop to create the series you'd like.</p>
<pre><code>n = 9
print('N='+str(n), [sum([index*4 if index%2 else index*-4 for index in range(1, num+1)]) for num in range(1, n+1)])
n = 8
print('N='+str(n), [sum([index*4 if index%2 else index*-4 for index in range(1, num+1)]) for num in range(1, n+1)])
</code></pre>
<p>Output:</p>
<pre><code>N=9 [4, -4, 8, -8, 12, -12, 16, -16, 20]
N=8 [4, -4, 8, -8, 12, -12, 16, -16]
[Finished in 0.178s]
</code></pre>
</div>
<span class="comment-copy"><code>sum += i - (i+2)</code> is equivalent to <code>i -= 2</code>. Alternating sums are typically expressed by giving terms which have a factor like <code>(-1)**i</code> or <code>(-1)**(i+1)</code></span>
<span class="comment-copy">Or you can just sum up the numbers in <code>range(4, n+1, 8)</code> and then subtract out the numbers in <code>range(8, n+1, 8)</code>. Which has the advantage that you can turn it into a simple one-liner. (And the disadvantage that you can't turn this into an infinite partial-sums generator.)</span>
<span class="comment-copy">@abarnert Ugh, ended up deleting my answer, it wasn't mine anymore. Please feel free to answer it.</span>
<span class="comment-copy">can this also be applied for these examples by just changing the range : 1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 or   1 + 2 + 4 + 8 + 16 + 32 + 64</span>
<span class="comment-copy">Is there some neat one-liner that will stop the stream of sequence elements as soon as we find <code>+/-n</code>?</span>
<span class="comment-copy">Yes, there is a closed form as well</span>
<span class="comment-copy">I'm working on the closed form, but what you want for that is itertools.takewhile</span>
<span class="comment-copy">I'm just wondering what the most pythonic way to wrap the generator <code>series()</code> into a method that takes an <code>n</code> as input would be (I'm not the OP, I just look how other people write python, and I find your generator solution interesting, because I come from a language in which such generators and coroutines are less prominent)</span>
<span class="comment-copy">@AndreyTyukin Here, have a look at this!</span>
<span class="comment-copy">sorry, I didn't notice you'd like to generate one series for each n due to my careless. But it will not be hard, just wrap it into another loop. So updated the answer to above codes.</span>
