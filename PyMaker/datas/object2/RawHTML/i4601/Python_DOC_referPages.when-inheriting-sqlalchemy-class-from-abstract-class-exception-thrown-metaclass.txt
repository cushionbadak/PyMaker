<div class="post-text" itemprop="text">
<p>The following code is a very simple implementation of a SqlAlchemy ORM with one simple table. The Mytable class tries to inherit from BaseAbstract.</p>
<p>The code throws the following exception:</p>
<blockquote>
<p>Message: metaclass conflict: the metaclass of a derived class must be
  a (non-strict) subclass of the metaclasses of all its bases</p>
</blockquote>
<pre><code>from abc import ABC
from sqlalchemy import Column, Integer, create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

class BaseAbstract(ABC):
    """description of class"""

SQLALCHEMY_DATABASE_URI =\
   'mssql+pyodbc://(local)/TestDB?driver=SQL+Server+Native+Client+11.0'
SQLALCHEMY_TRACK_MODIFICATIONS = False

engine = create_engine(SQLALCHEMY_DATABASE_URI, echo=True)
Session = sessionmaker(bind=engine)
session = Session()

Base = declarative_base()
metadata = Base.metadata

class Mytable(Base, BaseAbstract):
    __tablename__ = 'myTable'

    id = Column(Integer, primary_key=True)
    firstNum = Column(Integer, nullable=False)
    secondNum = Column(Integer, nullable=False)
</code></pre>
<p>If you change the class declaration line to </p>
<p>class Mytable(Base):</p>
<p>the code will work fine. Also if you change <code>class BaseAbstract(ABC):</code> to <code>class BaseAbstract(object):</code> the code will again work fine.
How do I inherit from an abstract class in SQLAlchemy?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/4651729/metaclass-mixin-or-chaining">Mixing metaclasses is not easy</a> and you should avoid it. SQLAlchemy offers a way to handle <a href="http://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/api.html#abstract" rel="nofollow noreferrer">abstract base classes</a> or <a href="http://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/mixins.html#augmenting-the-base" rel="nofollow noreferrer">augmenting the base</a>, and on the other hand what you're trying to do looks a lot like a <a href="http://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/mixins.html#mixin-and-custom-base-classes" rel="nofollow noreferrer">mixin</a>.</p>
<p>You can instruct SQLAlchemy to skip creating a table and a mapper for a class using <a href="http://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/api.html#abstract" rel="nofollow noreferrer"><code>__abstract__</code></a>:</p>
<pre><code>Base = declarative_base()

class BaseAbstract(Base):
    """description of class"""
    __abstract__ = True

class Mytable(BaseAbstract):
    ...
</code></pre>
<p>You could also <a href="http://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/mixins.html#augmenting-the-base" rel="nofollow noreferrer">augment the <code>Base</code> class</a>:</p>
<pre><code>class BaseAbstract:
    """description of class"""

Base = declarative_base(cls=BaseAbstract)

class Mytable(Base):
    ...
</code></pre>
<p>But in my opinion the easiest solution is to forego using an "abstract base" altogether and think of it as a <a href="http://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/mixins.html#mixin-and-custom-base-classes" rel="nofollow noreferrer">mixin</a>, as you had done already in a way:</p>
<pre><code>class CommonMixin:
    """description of class"""

Base = declarative_base()

class Mytable(CommonMixin, Base):
    ...
</code></pre>
<p>But if you insist on using an actual <code>abc.ABC</code> abstract base class, <a href="https://docs.python.org/3/library/abc.html#abc.ABCMeta.register" rel="nofollow noreferrer">register</a> your model classes as virtual subclasses:</p>
<pre><code>class BaseAbstract(ABC):
    """description of class"""

Base = declarative_base()

@BaseAbstract.register
class Mytable(Base):
    ...
</code></pre>
<p>The downside is that <code>@abc.abstractmethod</code> decorated methods are not checked upon instantiating virtual subclasses.</p>
<p>If the above do not fulfill your needs and you want to use <code>ABC</code> for checking that required methods are implemented, you could try and do as the exception instructed and create a new metaclass that is the combination of <code>DeclarativeMeta</code> and <a href="https://docs.python.org/3/library/abc.html#abc.ABCMeta" rel="nofollow noreferrer"><code>ABCMeta</code></a>:</p>
<pre><code>In [6]: class DeclarativeABCMeta(DeclarativeMeta, abc.ABCMeta):
   ...:     pass
   ...: 

In [7]: Base = declarative_base(metaclass=DeclarativeABCMeta)

In [8]: class BaseAbstract(abc.ABC):
   ...:     @abc.abstractmethod
   ...:     def foo(self):
   ...:         pass
   ...:     

In [13]: class MyTable(Base, BaseAbstract):
    ...:     __tablename__ = 'mytable'
    ...:     id = Column(Integer, primary_key=True)
    ...:     

In [14]: MyTable()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-14-1686a36a17c6&gt; in &lt;module&gt;()
----&gt; 1 MyTable()

TypeError: "Can't instantiate abstract class MyTable with abstract methods foo"

In [18]: class MyOtherTable(Base, BaseAbstract):
    ...:     __tablename__ = 'myothertable'
    ...:     id = Column(Integer, primary_key=True)
    ...:     def foo(self):
    ...:         return 'bar'
    ...:     

In [19]: MyOtherTable()
Out[19]: &lt;__main__.MyOtherTable at 0x7f01b4b592b0&gt;
</code></pre>
<p>I cannot vouch for this, though. It might contain more than a few surprises.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should be able to solve the issue by introducing an intermediate base class for your <code>Mytable</code>. For example:</p>
<pre><code>Base = declarative_base()
metadata = Base.metadata

class IntermediateBase(type(Base), BaseAbstract):
    pass

class Mytable(IntermediateBase):
    __tablename__ = 'myTable'

    id = Column(Integer, primary_key=True)
    firstNum = Column(Integer, nullable=False)
    secondNum = Column(Integer, nullable=False)
</code></pre>
</div>
<span class="comment-copy">The reason I am trying to inherit from an abstract class inheriting from ABC is to use isinstance in a function that takes as an argument an object and if that returns true then do additional processing by calling methods defined in the abstract class. If I do not inherit from ABC, Python will not enforce my need to make sure the inherited class implements all the attributes of the abstract class, and if I have missed some in an implementation, then I will get a run-time exception. I would rather get a build exception. That is what ABC gives me. Is this not a good reason to use ABC?</span>
<span class="comment-copy">I think that the usual answer would be that your tests should catch if a class does not implement a required method. Im not sure, and please correct me if I'm wrong, but I don't think <code>abstractmethod</code> checks call signature, for example.</span>
<span class="comment-copy">You are correct. I come from a C#/Java background. That is how we did it there and I am carrying my habits (the good and maybe the bad) over. I still prefer to rely on abstract methods (interfaces if Python had interfaces), in case I forget to implement a test. The more the ways to enforce the integrity of the application the better. Please clarify if my reaoning is wrong and I am not doing things the Pythonic way.</span>
<span class="comment-copy">I do agree with your reasoning and do miss enforceable interfaces in Python from time to time â€“ esp. since I'm a lazy test writer. I'm just a bit wary about mixing metaclasses, is all, since they might interoperate in surprising ways. As an aside, have you ever run into <a href="https://pypi.python.org/pypi/zope.interface" rel="nofollow noreferrer">zope.interface</a>? They have <a href="https://stackoverflow.com/questions/647110/python-abstract-base-class-and-zopeinterface">some overlap with ABCs</a>.</span>
<span class="comment-copy">I did not really like the zope syntax. It is too complicated. Prefer to stay with the Python Abstract classes.</span>
<span class="comment-copy">I love this. Unfortunately, I am getting this error: "Cannot compile Column object until its 'name' is assigned." trying to figure out why</span>
