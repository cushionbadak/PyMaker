<div class="post-text" itemprop="text">
<p>How to spawn multiple parallel external exe instances from function(generator) <code>for x1 in x:</code> in multiprocessing manner(to keep always one exec running per cpu thread)? If there is no method to do it in current pseudo code below, then what other best/simple solutions would be?</p>
<p>Btw after exec instance exit I'll need to get size of file outputed &amp; delete it. 
Code purpose is to find desirable combination of x/y/z parameters, </p>
<p><code>os.system</code> line syntax is incorrect for better readability. Behind <code>state_x = x1/z1</code> will be more code like exitcode check, getfilesize and compare, so <code>x1</code> <code>x2</code> <code>x3</code> will be not always passed to variables. </p>
<pre><code>x = list(range(1, 300+1))
y = list(range(1, 300+1))
z = list(range(1, 300+1))

state_x = []
state_y = []
state_z = []

import os
for x1 in x:
    for y1 in y:
        for z1 in z:
            os.system("external.exe -x1 -y1 -z1 outfile_x1_y1_z1.out")
            state_x = x1
            state_y = y1
            state_z = z1
</code></pre>
<p><strong>UPDATE1</strong></p>
<p>I simplified code more to be more understandable, replaced <code>os.system("external.exe...</code> with <code>print</code> so that from shell output it would be more clear what code does. </p>
<p>Disregard that <code>state_* = []</code> variables always gets last loop variation from generator, it is just simplified code, and expected result - sign that code works!</p>
<p>Question still same, how to spawn exec/print in multiprocess from looping generator.</p>
<pre><code>x = list(range(1,2+1))
y = list(range(3,4+1))
z = list(range(5,6+1))

state_x = []
state_y = []
state_z = []

import os
for x1 in x:
    for y1 in y:
        for z1 in z:
            print (x1,y1,z1)
            state_x = x1
            state_y = y1
            state_z = z1
</code></pre>
<p>Shell output:</p>
<pre><code>==================== RESTART: D:/Python36-32/myscript5.py ==============
1 3 5
1 3 6
1 4 5
1 4 6
2 3 5
2 3 6
2 4 5
2 4 6
&gt;&gt;&gt; state_x
2
&gt;&gt;&gt; state_y
4
&gt;&gt;&gt; state_z
6
&gt;&gt;&gt; 
</code></pre>
<p><strong>UPDATE2:</strong></p>
<p>This code below starts external exe multiprocessed if run from IDLE, but I don't get variables <code>state_x</code> <code>state_y</code> <code>state_z</code> passed out of function to global variable. After code is finished I type <code>state_x</code> in Python Shell I get returned it empty <code>[]</code>.</p>
<p>code:</p>
<pre><code>import itertools
import multiprocessing
import os

x = list(range(1,2+1))
y = list(range(3,4+1))
z = list(range(5,6+1))

state_x = []
state_y = []
state_z = []

def do_work(x1, y1, z1):
    os.system("ping.exe 127.0.0.1 -n "+str(x1)+"")
    global state_x  
    state_x = x1
    global state_y 
    state_y = y1
    global state_z

if __name__ == "__main__":
    with multiprocessing.Pool() as pool:
        results = pool.starmap(do_work, itertools.product(range(1,3),range(3,5),range(5,7), repeat=1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you want one process per CPU, often the best approach it to use <code>multiprocessing.Pool</code>. I <em>think</em> this should do roughly what you want (the exact details of your code's logic are not obvious, since you're overwriting <code>state_x</code>/<code>y</code>/<code>z</code> on each iteration, to no apparent effect).</p>
<pre><code>import itertools
import multiprocessing

def do_work(x, y, z):
    # do your per-job stuff here, e.g. make the os.system() call, or whatever

    return result # return whatever value you need the worker to send to the main process

if __name__ == "__main__":
    with multiprocessing.Pool() as pool:
        results = pool.starmap(do_work, itertools.product(range(1, 301), repeat=3))

    # do stuff with results here
</code></pre>
<p>A <code>Pool</code> created with no arguments will, by default, create one process per CPU core. You can tell it to use a different number of processes if you prefer, but it shouldn't be necessary in most cases.</p>
</div>
<span class="comment-copy">Have you already read <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">the official docs</a>?</span>
<span class="comment-copy">@Niayesh Isky sure, and hundreds of SO posts &amp; dozen video tutorials, tried asking at other forums and at irc #python channels.</span>
<span class="comment-copy">code is generator, it produces 2.7mil (300*300*300) results, when <code>return result</code> can produce single result so it doesn't fit.  <code>(range(1, 301), repeat=3)</code> will have only 903 repeats... Read last sentence in first post, <code>state_x/y/z</code> won't be overwritten on each iteration.</span>
<span class="comment-copy">I guess I have no idea what you're doing then. My <code>itertools.product</code> output should be exactly equivalent to the nested loop you show. Please give some example code that in some way relates to your actual question.</span>
<span class="comment-copy">@ Blckknght Sorry my beginner mind was confused with that at first, now in a morning it makes sense. <code>product</code> does exactly same loop as <code>for</code> , so it starts exe in multiprocess as expected, at least in IDLE for now, but it doesn't pass local variables from function to global variables &amp; it doesn't run from .py. Please look at UPDATE2 in first post.</span>
<span class="comment-copy">.py started to run without errors from cmd.exe when  I uninstalled Python 2.7. Still trying to figure out why it doesn't pass variables.</span>
