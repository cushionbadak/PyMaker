<div class="post-text" itemprop="text">
<p>For a C# application I have used a backgroundqueue where I could enqueue 'actions' in. I wish to do the same in Python.</p>
<p>The backgroundqueue should 'enqueue' an 'action' which contains a call to a function (with or without variables) and should keep going through the tasks while the main program keeps doing its own function.</p>
<p>I already tried with rq, but that seemed not to work. I would love to hear some suggestions!</p>
<p>Edit:
The code this is about:</p>
<pre><code>class DatabaseHandler:
def __init__(self):
    try:
        self.cnx = mysql.connector.connect(user='root', password='', host='127.0.0.1', database='mydb')
        self.cnx.autocommit = True
        self.loop = asyncio.get_event_loop()
    except mysql.connector.Error as err:
        if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
            print("Something is wrong with your user name or password")
        elif err.errno == errorcode.ER_BAD_DB_ERROR:
            print("Database does not exist")
        else:
            print(err)
    self.get_new_entries(30.0)

    async def get_new_entries(self, delay):
        start_time = t.time()
        while True:
            current_time = datetime.datetime.now() - datetime.timedelta(seconds=delay)
            current_time = current_time.strftime("%Y-%m-%d %H:%M:%S")
            data = current_time
            print(current_time)
            await self.select_latest_entries(data)
            print("###################")
            t.sleep(delay - ((t.time() - start_time) % delay))

    async def select_latest_entries(self, input_data):
        query = """SELECT FILE_NAME FROM `added_files` WHERE CREATION_TIME &gt; %s"""
        cursor = self.cnx.cursor()
        await cursor.execute(query, (input_data,))
        async for file_name in cursor.fetchall():
            file_name_string = ''.join(file_name)
            self.loop.call_soon(None, self.handle_new_file_names, file_name_string)
        cursor.close()

    def handle_new_file_names(self, filename):
        # self.loop.run_in_executor(None, NF.create_new_npy_files, filename)
        # self.loop.run_in_executor(None, self.update_entry, filename)
        create_new_npy_files(filename)
        self.update_entry(filename)

    def update_entry(self, filename):
        print(filename)
        query = """UPDATE `added_files` SET NPY_CREATED_AT=NOW(), DELETED=1 WHERE FILE_NAME=%s"""
        update_cursor = self.cnx.cursor()
        self.cnx.commit()
        update_cursor.execute(query, (filename,))
        update_cursor.close()
</code></pre>
<p>The <code>create_new_npy_files(filename)</code> is a static method from a static class if that makes sense. It is a pretty time consuming function (1-2 sec)</p>
</div>
<div class="post-text" itemprop="text">
<p>If the action to execute is short and non-blocking, you can use <code>call_soon</code>:</p>
<pre><code>loop = asyncio.get_event_loop()
loop.call_soon(action, args...)
</code></pre>
<p>If the action can take longer or can block, use <code>run_in_executor</code> to submit them to a thread pool:</p>
<pre><code>loop = asyncio.get_event_loop()
future = loop.run_in_executor(None, action, args...)
# you can await the future, access its result once ready, etc.
</code></pre>
<p>Note that both above snippets assume that you already use <code>asyncio</code> in your program, based on the <code>python-asyncio</code> tag. This means that your <code>select_statement</code> would look like this:</p>
<pre><code>async def select_statement():
    loop = asyncio.get_event_loop()
    while True:
        # requires an async-aware db module
        await cursor.execute(query, (input_data,))
        async for file_name in cursor.fetchall():
            loop.call_soon(self.handle_new_file_names, file_name_string))
            # or loop.run_in_executor(...)
</code></pre>
</div>
<span class="comment-copy">Look for the <a href="https://docs.python.org/3.5/library/multiprocessing.html" rel="nofollow noreferrer">multiprocessing</a> or the <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">thread</a> package of python.</span>
<span class="comment-copy">I could use this in a while loop? I will edit my question to include a trivial example of where I'd like to use it.</span>
<span class="comment-copy">Yes, definitely. In case of <code>call_soon</code>, the callbacks will be invoked in a FIFO-manner together with other stuff the asyncio event loop is doing. In case of <code>run_in_executor</code>, they will be submitted to a thread pool where they will be processed according to the policy of that thread pool.</span>
<span class="comment-copy">Its probably very easy to implement correctly, but i'm still new to async in Python, Python in general and threading in general</span>
