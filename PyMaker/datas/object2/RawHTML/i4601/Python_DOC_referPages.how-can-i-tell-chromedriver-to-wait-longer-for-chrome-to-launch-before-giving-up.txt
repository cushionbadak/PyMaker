<div class="post-text" itemprop="text">
<h3>Background</h3>
<p>I'm using Selenium and Python to automate display and navigation of a website in Chromium on Ubuntu MATE 16.04 on a Raspberry Pi 3.  (Think unattended digital signage.)  This combination was working great until today when the newest version of Chromium (with matching ChromeDriver) installed via automatic updates.</p>
<p>Because Chromium needed to perform some upgrade housekeeping tasks the next time it started up, it took a little longer than usual.  Keep in mind that this is on a Raspberry Pi, so I/O is severely bottlenecked by the SD card.  Unfortunately, it took long enough that my Python script failed because the ChromeDriver gave up on Chromium ever starting:</p>
<pre><code>Traceback (most recent call last):
  File "call-tracker-start", line 15, in &lt;module&gt;
    browser = webdriver.Chrome(executable_path=chromedriver_path, options=chrome_options)
  File "/home/pi/.local/lib/python3.5/site-packages/selenium/webdriver/chrome/webdriver.py", line 75, in __init__
    desired_capabilities=desired_capabilities)
  File "/home/pi/.local/lib/python3.5/site-packages/selenium/webdriver/remote/webdriver.py", line 154, in __init__
    self.start_session(desired_capabilities, browser_profile)
  File "/home/pi/.local/lib/python3.5/site-packages/selenium/webdriver/remote/webdriver.py", line 243, in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
  File "/home/pi/.local/lib/python3.5/site-packages/selenium/webdriver/remote/webdriver.py", line 312, in execute
    self.error_handler.check_response(response)
  File "/home/pi/.local/lib/python3.5/site-packages/selenium/webdriver/remote/errorhandler.py", line 242, in check_response
    raise exception_class(message, screen, stacktrace)
selenium.common.exceptions.WebDriverException: Message: chrome not reachable
  (Driver info: chromedriver=2.35 (0),platform=Linux 4.4.38-v7+ armv7l)
</code></pre>
<p>Of course, when the script dies after throwing this exception, the Chromium instance is killed before it can finish its housekeeping, which means that next time it has to start over, so it takes just as long as the last time and fails just as hard.</p>
<p>If I then manually intervene and run Chromium as a normal user, I just... wait... a minute... or two, for Chromium to finish its upgrade housekeeping, then it opens its browser window, and then I cleanly quit the application.  Now that the housekeeping is done, Chromium starts up the next time at a more normal speed, so all of the sudden my Python script runs without any error because the ChromeDriver sees Chromium finish launching within its accepted timeout window.</p>
<p>Everything will likely be fine until the next automatic update comes down, and then this same problem will happen all over again.  I don't want to have to manually intervene after every update, nor do I want to disable automatic updates.</p>
<h3>The root of the question</h3>
<p>How can I tell ChromeDriver not to give up so quickly on launching Chromium?</p>
<p>I looked for some sort of timeout value that I could set, but I couldn't find any in the ChromeDriver or Selenium for Python documentation.</p>
<p>Interestingly, there <em>is</em> a <code>timeout</code> argument that can be passed to the Firefox WebDriver, <a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.firefox.webdriver" rel="nofollow noreferrer">as shown in the Selenium for Python API documentation</a>:</p>
<blockquote>
<p><strong>timeout</strong> â€“ Time to wait for Firefox to launch when using the extension connection.</p>
</blockquote>
<p>This parameter is also listed for the Internet Explorer WebDriver, but it's notably absent in the Chrome WebDriver API documentation.</p>
<p>I also wouldn't mind passing something directly to ChromeDriver via <code>service_args</code>, but I couldn't find any relevant options in the ChromeDriver docs.</p>
<h3>Update: found root cause of post-upgrade slowness</h3>
<p>After struggling with finding a way to reproduce this problem in order to test solutions, I was able to pinpoint the reason Chromium takes forever to launch after an upgrade.</p>
<p>It seems that, as part of its post-upgrade housekeeping, Chromium rebuilds the user's font cache.  This is a CPU &amp; I/O intensive process that is especially hard on a Raspberry Pi and its SD card, hence the extreme 2.5 minute launch time whenever the font cache has to be rebuilt.</p>
<p>The problem can be reproduced by purposely deleting the font cache, which forces a rebuild:</p>
<pre class="lang-none prettyprint-override"><code>pi@rpi-dev1:~$ killall chromium-browser
pi@rpi-dev1:~$ time chromium-browser --headless --disable-gpu --dump-dom 'about:blank'
[0405/132706.970822:ERROR:gpu_process_transport_factory.cc(1019)] Lost UI shared context.
&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;

real    0m0.708s
user    0m0.340s
sys     0m0.200s

pi@rpi-dev1:~$ rm -Rf ~/.cache/fontconfig
pi@rpi-dev1:~$ time chromium-browser --headless --disable-gpu --dump-dom 'about:blank'
[0405/132720.917590:ERROR:gpu_process_transport_factory.cc(1019)] Lost UI shared context.
&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;

real    2m9.449s
user    2m8.670s
sys     0m0.590s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are right, there is no option to explicitly set the <code>timeout</code> of the initial driver creation. I would recommend visiting their git page <a href="https://github.com/SeleniumHQ/selenium/wiki/ChromeDriver" rel="nofollow noreferrer">HERE</a> and creating a new issue. It also has the links for the direct ChromeDriver site in case you want to create a bug there. Currently, there is no option to set <strong>timeout</strong> that I could find.</p>
<p>You could try something like this in the meantime though:</p>
<pre><code>import webbrowser
from selenium import webdriver
from selenium.common.exceptions import WebDriverException

try:
    driver = webdriver.Chrome()
except WebDriverException:
    webbrowser.open_new('http://www.Google.com')
# Let this try and get Chrome open, then go back and use webdriver
</code></pre>
<p>Here is the documentation on webbrowser:
<a href="https://docs.python.org/3/library/webbrowser.html" rel="nofollow noreferrer">https://docs.python.org/3/library/webbrowser.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As per your question without your code trial it would be tough to analyze the reason behind the error which you are seeing as :</p>
<pre><code>selenium.common.exceptions.WebDriverException: Message: chrome not reachable
</code></pre>
<p>Perhaps a more details about the <strong>version info</strong> of the binaries you are using would have helped us in someway. </p>
<p>Factually, asking <em>ChromeDriver</em> to wait longer for <em>Chrome</em> to launch before giving up won't help us as the default configuration of <em>ChromeDriver</em> takes care of the optimum needs.</p>
<p>However <strong>WebDriverException: Message: chrome not reachable</strong> is pretty common issue when the binary versions are incompatible. You can find a detailed discussion about this issue at <a href="https://stackoverflow.com/questions/48323856/org-openqa-selenium-webdriverexception-chrome-not-reachable-when-attempting-t/48328964#48328964"><strong>org.openqa.selenium.WebDriverException: chrome not reachable - when attempting to start a new session</strong></a></p>
</div>
<div class="post-text" itemprop="text">
<h2>The bad news</h2>
<p>It turns out that not only is there no <code>timeout</code> option for Selenium to pass to ChromeDriver, but short of recompiling your own custom ChromeDriver, there is currently no way to change this value programmatically whatsoever.  Sadly, <a href="https://cs.chromium.org/chromium/src/chrome/test/chromedriver/chrome_launcher.cc?rcl=c7535dc32337aadba84688689a5c1920ca6973be&amp;l=212" rel="nofollow noreferrer">looking at the source code</a> shows that Google has <em>hard-coded</em> a timeout value of 60 seconds!</p>

from chromium /src/chrome/test/chromedriver/chrome_launcher.cc@208:

<pre class="lang-cpp prettyprint-override"><code>std::unique_ptr&lt;DevToolsHttpClient&gt; client(new DevToolsHttpClient(
    address, context_getter, socket_factory, std::move(device_metrics),
    std::move(window_types), capabilities-&gt;page_load_strategy));
base::TimeTicks deadline =
    base::TimeTicks::Now() + base::TimeDelta::FromSeconds(60);
Status status = client-&gt;Init(deadline - base::TimeTicks::Now());
</code></pre>
<p>Until this code is changed to allow custom deadlines, the only option is a workaround.</p>
<h2>The workaround</h2>
<p>I ended up taking an approach that "primed" Chromium before having Selenium call ChromeDriver.  This gets that one-time, post-upgrade slow start out of the way before ChromeDriver ever begins its countdown.  The answer @PixelEinstein gave helped lead me down the right path, but this solution differs in two ways:</p>
<ol>
<li>The call to open standalone Chromium here is blocking, while <code>webbrowser.open_new()</code> is not.</li>
<li>Standalone Chromium is always launched before ChromeDriver whether it is needed or not.  I did this because waiting one minute for ChromeDriver to timeout, then waiting another 2.5 minutes for Chromium to start, then trying ChromeDriver again created a total delay of just over 3.5 minutes.  Launching Chromium as the <em>first</em> action brings the total wait time down to about 2.5 minutes, as you skip the initial ChromeDriver timeout.  On occasions when the long startup time <em>doesn't</em> occur, then this "double loading" of Chromium is negligible, as the whole process finishes in a matter of seconds.</li>
</ol>
<p>Here's the code snippet:</p>
<pre><code>#!/usr/bin/env python3
import subprocess
from selenium import webdriver

some_site = 'http://www.google.com'
chromedriver_path = '/usr/lib/chromium-browser/chromedriver'

# Block until Chromium finishes launching and self-terminates
subprocess.run(['chromium-browser', '--headless', '--disable-gpu', '--dump-dom', 'about:blank'])

browser = webdriver.Chrome(executable_path=chromedriver_path)
browser.get(some_site)
# Continue on with your Selenium business...
</code></pre>
<p>Before instantiating a <code>webdriver.Chrome()</code> object, this waits for Chromium to finish its post-upgrade housekeeping no matter how long it takes.  Chromium is launched in headless mode where <code>--dump-dom</code> is a one-shot operation that writes the requested web page (in this case <code>about:blank</code>) to stdout, which is ignored.  Chromium self-terminates after completing the operation, which then returns from the <code>subprocess.run()</code> call, unblocking program flow.  After that, it's safe to let ChromeDriver start its countdown, as Chromium will launch in a matter of seconds.</p>
</div>
<span class="comment-copy">Can you update the question with the <i>Selenium</i>, <i>ChromeDriver</i> and <i>Chrome</i> version you are using along with the complete error trace logs and the exact usecase you are looking at along with your <i>code trials</i>?</span>
<span class="comment-copy">This answer was helpful in leading me down the right path, though I didn't find <code>webbrowser.open_new()</code> useful because it returns immediately instead of blocking while Chromium loads.  I'd love to give you a +1, but I'm sorry that I haven't earned enough rep yet to upvote.</span>
<span class="comment-copy">If it were incompatible binaries wouldn't it be consistently causing the <code>chrome not reachable</code>, I have gotten that error after updating Chrome before, but it happened every time. All they are doing is opening Chromium themselves and letting it open <b>once</b> after automatic updates, and it works. I would think that would lead to another problem since they aren't changing their versions but it works after one <b>long running</b> clean open.</span>
<span class="comment-copy">@PixelEinstein See OP's case and your case both have the same trigger <b>newest version of Chromium</b>. For the record <b>Chromium Project</b> clearly provides the dependency in the <b>Release Notes</b> as a heading. Deviation from the recommended configuration/settings are against all the <i>Best Practices</i>.</span>
<span class="comment-copy">I assumed they were running on current versions since they stated they were installing current versions of both Chromedriver and Chromium. It would help if we knew what version of Chromium and Selenium they were running, their chromedriver is <code>2.35</code>, which is <b>not</b> current if Chromium is auto updating. You are probably right.</span>
<span class="comment-copy">Apart from <code>2.35</code> I am more suspicious about the source of the binary as I can see a index <code>(0)</code> as in <code>Driver info: chromedriver=2.35 (0)</code></span>
