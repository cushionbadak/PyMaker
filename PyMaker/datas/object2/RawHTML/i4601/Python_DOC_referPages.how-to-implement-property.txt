<div class="post-text" itemprop="text">
<p>I was comparing three slightly different implementations of <code>@property</code> in python. Python documentation and "Source 1" initialize the private variable, <code>_var_name</code>.  Furthermore, the code from Source 1 has a bug; it doesn't access <code>.setter</code> when initializing.  By contrast, the third example correctly initializes the public variable <code>x</code>.</p>
<p>Is there a good reason to initialize <code>_x</code> in place of <code>x</code> in <code>__init__</code>?  Are there any additional differences between these that I haven't described?</p>
<p>From the <a href="https://docs.python.org/3/library/functions.html?highlight=property#property" rel="nofollow noreferrer">docs</a>:</p>
<pre><code>class C:
    def __init__(self):
        self._x = None

    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x
</code></pre>
<p><a href="https://www.programiz.com/python-programming/property" rel="nofollow noreferrer">Source 1</a>: </p>
<pre><code>class Celsius:
    def __init__(self, temperature = 0):
        self._temperature = temperature

    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32

    @property
    def temperature(self):
        print("Getting value")
        return self._temperature

    @temperature.setter
    def temperature(self, value):
        if value &lt; -273:
            raise ValueError("Temperature below -273 is not possible")
        print("Setting value")
        self._temperature = value
</code></pre>
<p><a href="https://www.python-course.eu/python3_properties.php" rel="nofollow noreferrer">Source 2</a>: </p>
<pre><code>class P:

    def __init__(self,x):
        self.x = x

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, x):
        if x &lt; 0:
            self.__x = 0
        elif x &gt; 1000:
            self.__x = 1000
        else:
            self.__x = x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a good reason to initialize <code>__x</code> or <code>_x</code> in place of <code>x</code> in <code>__init__</code>?</p>
</blockquote>
<p>Properties are often used to transform the input in some way. An internal method (including <code>__init__</code>) often already <em>has</em> the transformed data, and doesn't want it to get transformed again. For example, consider this somewhat silly but obvious example:</p>
<pre><code>class C:
    # ...
    def __init__(self):
        f = open(C.default_filename, 'rb')
        # ...
        self._file = f
    @property
    def file(self):
        return self._file.__name__
    @file.setter
    def file(self, filename):
        self._file = open(f, 'rb')
</code></pre>
<p>Even when you're not doing anything that would be <em>wrong</em> to pass through the setter, internal code often knows about the class invariants, so the checks done by setters may be extra overhead for no benefit. For example, if you wanted a method to set the temperature to 0°C, it could just set <code>self._x = 0</code> instead of <code>self.x = 0</code>, because you know that <code>0</code> doesn't need to be checked.</p>
<p>On the other hand, some internal methods may <em>want</em> to see <code>x</code> the same way the public does. In that case, it should use the property rather than the underlying attribute. In fact, your Source 1 is a perfect example—<code>__init__</code> just saves its parameter directly to <code>_temperature</code>, allowing you to construct temperatures below absolute 0 (which is bad, because that's actually hotter than infinity, and CPUs like to be cold). And it would be silly to repeat the same precondition test in <code>__init__</code> that you already wrote in <code>temperature.setter</code>; in this case, just set <code>self.temperature</code> instead.</p>
<hr/>
<blockquote>
<p>There is additional difference in whether a single or double underscore is used.</p>
</blockquote>
<p>A single underscore makes the attribute "private by convention"; a double underscore goes further and <a href="https://stackoverflow.com/questions/6444576/python-method-name-with-double-underscore-is-overridden">mangles the name</a>, which means it can't be accidentally accessed from outside your class's code.</p>
<p>Using <code>obj._x</code> works on your instances; <code>obj.__x</code> raises <code>AttributeError</code>. But it only prevents <em>accidental</em> access—they can still use <code>obj._C__x</code> if they really want to get at it. The main reason to do this is to protect subclasses or superclasses from accidentally using the same names.</p>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/6444576/python-method-name-with-double-underscore-is-overridden">The double underscore means it's a "private" name, which will be mangled so code in subclasses, etc. cannot accidentally access it; it makes no difference beyond that.</a></span>
<span class="comment-copy">The other difference is that <code>Celsius.temperature</code> is a pretty meaningful name, while <code>P.x</code>, who knows what it means, or why it's bounded to 0-1000. But I'm sure you already knew that.</span>
<span class="comment-copy">Ok. So how would you recommend fixing the problem in the example "Source 1", where <code>c = Celsius(-100)</code> does not call the <code>setter</code>?</span>
<span class="comment-copy">@anon01 As I said in the answer, that is a good case where you probably do want to call the setter—just do <code>self.temperature = temperature</code>. (Although in the answer, I mixed it up and calling it <code>x</code> vs. <code>_x</code> instead of <code>temperature</code> vs. <code>_temperature</code>; I'll fix that…)</span>
