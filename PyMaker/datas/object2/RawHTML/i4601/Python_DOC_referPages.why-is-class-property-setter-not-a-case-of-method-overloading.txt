<div class="post-text" itemprop="text">
<p>Method overloading is not possible in Python!
Can you please explain why <code>Properties.setter</code> in Python is not a case of method overloading?</p>
<pre><code>class newOne():
    def __init__(self):
            self.__x = 0
    @property
    def val(self):
            return self.__x
    @val.setter
    def val(self,value):
            self.__x = value
</code></pre>
<p>In the above code, I have two methods with the same name 'val' (but different set of args) and both behave differently.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, the <code>@property</code> decorator creates a descriptor named <code>val</code> and sets it aside to add to the class once it is defined. Then, the <code>@val.setter</code> decorated takes <em>its</em> function and <strike>simply</strike>effectively adds a reference to it to the <code>val</code> descriptor.</p>
<p>Your code is roughly equivalent to </p>
<pre><code>d = {}

def __init__(self):
    self.__x = 0

d['__init__'] = __init__

def val(self):
    return self.__x

d['val'] = property(val)

def val(self, value):
    self.__x = value

# Not d['val'].__set__ = val, as previously stated
d['val'] = property(fget=d['val'], fset=val)

newOne = type('newOne', (object,), d)

# These are all "local" to, or part of the implementation of,
# the class statement, so they don't stick around in the current
# namespace.
del __init__, val, d  # These are all "local" to or part of the imple
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not method overloading because there aren't two methods with different signatures that can be called. If it was method overloading, you could do something like this:</p>
<pre><code>obj = newOne()

print(obj.val())
obj.val(5)
</code></pre>
<p>But that doesn't work, because <code>val</code> is a <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">property</a> and not an overloaded method.</p>
<hr/>
<p>So what's going on there? Why are we defining two methods with the same name, and what happens to them, if not overloading?</p>
<p>The magic happens in the decorators. As a prerequisite, you have to know that</p>
<pre><code>@deco
def func(...):
    ...
</code></pre>
<p>is equivalent to</p>
<pre><code>def func(...):
    ...

func = deco(func)
</code></pre>
<p>So, the first thing that happens is that the <code>@property</code> decorator turns your getter function into a property with that function as its getter function:</p>
<pre><code>class newOne:
    @property
    def val(self):
        return self.__x

print(newOne.val)
print(newOne.val.fget)
# output:
# &lt;property object at 0x002B1F00&gt;
# &lt;function newOne.val at 0x0052EAE0&gt;
</code></pre>
<p>After this, the <code>@val.setter</code> decorator creates a <em>new</em> property with a getter <em>and</em> setter function:</p>
<pre><code>class newOne:
    @property
    def val(self):
        return self.__x

    @val.setter
    def val(self, value):
        self.__x = value

print(newOne.val)
print(newOne.val.fget)
print(newOne.val.fset)
# output:
# &lt;property object at 0x0221B7B0&gt;
# &lt;function newOne.val at 0x0226EB70&gt;
# &lt;function newOne.val at 0x0226EAE0&gt;
</code></pre>
<p>(The getter and setter functions have the same name because they were both defined as <code>def val(...)</code>, but they're still <em>different</em> functions. That's why they have different ids.)</p>
<p>So in the end you have a <code>val</code> property with a getter and a setter function. You do <em>not</em> have an overloaded method.</p>
<p>For details about how properties work and how the getter and setter functions are called, see the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor documentation</a>.</p>
</div>
<span class="comment-copy">Do you understand that properties are descriptors, and what that means? I'm not going to explain that and it's kind of required knowledge to understand the rest. But basically, properties are somewhat magic and this is a special case, there's no actual method overloading here. The class only has one <code>val</code> attribute.</span>
<span class="comment-copy"><code>class A:def f(): print(1); def f(): print(2); A().f() -&gt; prints 2</code>. The second definition <i>actually</i> overrides the first one. However <code>val.setter</code> in reality is composing the function definition into the <code>property</code> object, thus the first definition is not actually "lost". Then descriptors come into play.</span>
<span class="comment-copy">â€“1  The name is not irrelevant.</span>
<span class="comment-copy">The call to <code>@val.setter</code> is equivalent to <code>d['val'] = property(fget=d['val'], fset=val)</code> rather than <code>d['val'].__set__ = val</code>. That might help explain. Here you could make the names of the getter and setter different and that might make it even clearer. But wim is right than in a class definition like OPs the getter and setter have to have the same name so that ultimately there's only one attribute encompassing both.</span>
<span class="comment-copy">Right; I meant to double check that after I finished the answer. It <i>seems</i> like it should be irrelevant :)</span>
<span class="comment-copy">@AlexHall Does <code>@val.setter</code> really redefine the property, or is that just the closest you can do in this pseudo-Python?</span>
<span class="comment-copy">It actually creates a new property.  Something like <code>type(self)(...)</code>.  I don't really understand why it needs to do this, rather than mutate existing property, but that's what it does.  <i>shrug</i></span>
