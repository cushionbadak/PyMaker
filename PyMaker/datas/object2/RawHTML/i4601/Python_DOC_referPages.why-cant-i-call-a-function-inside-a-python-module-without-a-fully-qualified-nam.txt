<div class="post-text" itemprop="text">
<p>I have been using Python more and more, and I keep seeing the variable <code>__all__</code> set in different <code>__init__.py</code> files.  Can someone explain what this does?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a list of public objects of that module, as interpreted by <code>import *</code>. It overrides the default of hiding everything that begins with an underscore.</p>
</div>
<div class="post-text" itemprop="text">
<p>Linked to, but not explicitly mentioned here, is exactly when <code>__all__</code> is used. It is a list of strings defining what symbols in a module will be exported when <code>from &lt;module&gt; import *</code> is used on the module.</p>
<p>For example, the following code in a <code>foo.py</code> explicitly exports the symbols <code>bar</code> and <code>baz</code>:</p>
<pre><code>__all__ = ['bar', 'baz']

waz = 5
bar = 10
def baz(): return 'baz'
</code></pre>
<p>These symbols can then be imported like so:</p>
<pre><code>from foo import *

print bar
print baz

# The following will trigger an exception, as "waz" is not exported by the module
print waz
</code></pre>
<p>If the <code>__all__</code> above is commented out, this code will then execute to completion, as the default behaviour of <code>import *</code> is to import all symbols that do not begin with an underscore, from the given namespace.</p>
<p>Reference: <a href="https://docs.python.org/3.5/tutorial/modules.html#importing-from-a-package" rel="noreferrer">https://docs.python.org/3.5/tutorial/modules.html#importing-from-a-package</a></p>
<p><strong>NOTE:</strong> <code>__all__</code> affects the <code>from &lt;module&gt; import *</code> behavior only. Members that are not mentioned in <code>__all__</code> are still accessible from outside the module and can be imported with <code>from &lt;module&gt; import &lt;member&gt;</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm just adding this to be precise:</p>
<p>All other answers refer to <em>modules</em>. The original question explicitely mentioned <code>__all__</code> in <code>__init__.py</code> files, so this is about python <em>packages</em>.</p>
<p>Generally, <code>__all__</code> only comes into play when the <code>from xxx import *</code> variant of the <code>import</code> statement is used. This applies to packages as well as to modules.</p>
<p>The behaviour for modules is explained in the other answers. The exact behaviour for packages is described <a href="http://docs.python.org/2/tutorial/modules.html#importing-from-a-package">here</a> in detail.</p>
<p>In short, <code>__all__</code> on package level does approximately the same thing as for modules, except it deals with <em>modules within the package</em>  (in contrast to specifying <em>names within the module</em>). So <code>__all__</code> specifies all modules that shall be loaded and imported into the current namespace when us use <code>from package import *</code>.</p>
<p>The big difference is, that when you <em>omit</em> the declaration of <code>__all__</code> in a package's <code>__init__.py</code>, the statement <code>from package import *</code> will not import anything at all (with exceptions explained in the documentation, see link above). </p>
<p>On the other hand, if you omit <code>__all__</code> in a module, the "starred import" will import all names (not starting with an underscore) defined in the module.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Explain __all__ in Python?</strong></p>
<p>I keep seeing the variable <code>__all__</code> set in different <code>__init__.py</code> files.</p>
<p>What does this do?</p>
</blockquote>
<h1>What does <code>__all__</code> do?</h1>
<p>It declares the semantically "public" names from a module. If there is a name in <code>__all__</code>, users are expected to use it, and they can have the expectation that it will not change. </p>
<p>It also will have programmatic affects:</p>
<h2><code>import *</code></h2>
<p><code>__all__</code> in a module, e.g. <code>module.py</code>:</p>
<pre><code>__all__ = ['foo', 'Bar']
</code></pre>
<p>means that when you <code>import *</code> from the module, only those names in the <code>__all__</code> are imported:</p>
<pre><code>from module import *               # imports foo and Bar
</code></pre>
<h2>Documentation tools</h2>
<p>Documentation and code autocompletion tools may (in fact, should) also inspect the <code>__all__</code> to determine what names to show as available from a module.</p>
<h1><code>__init__.py</code> makes a directory a Python package</h1>
<p>From the <a href="https://docs.python.org/tutorial/modules.html#packages" rel="noreferrer">docs</a>:</p>
<blockquote>
<p>The <code>__init__.py</code> files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path.</p>
<p>In the simplest case, <code>__init__.py</code> can just be an empty file, but it can also execute initialization code for the package or set the <code>__all__</code> variable.</p>
</blockquote>
<p>So the <code>__init__.py</code> can declare the <code>__all__</code> for a <em>package</em>.</p>
<h1>Managing an API:</h1>
<p>A package is typically made up of modules that may import one another, but that are necessarily tied together with an <code>__init__.py</code> file. That file is what makes the directory an actual Python package. For example, say you have the following:</p>
<pre><code> package/
   |-__init__.py # makes directory a Python package
   |-module_1.py
   |-module_2.py
</code></pre>
<p>in the <code>__init__.py</code> you write:</p>
<pre><code>from module_1 import *
from module_2 import *
</code></pre>
<p>and in <code>module_1</code> you have:</p>
<pre><code>__all__ = ['foo',]
</code></pre>
<p>and in <code>module_2</code> you have:</p>
<pre><code>__all__ = ['Bar',]
</code></pre>
<p>And now you have presented a complete api that someone else can use when they import your package, like so: </p>
<pre><code>import package
package.foo()
package.Bar()
</code></pre>
<p>And they won't have all the other names you used when creating your modules cluttering up the <code>package</code> namespace.</p>
<h1><code>__all__</code> in <code>__init__.py</code></h1>
<p>After more work, maybe you've decided that the modules are too big and need to be split up. So you do the following:</p>
<pre><code> package/
   |-__init__.py
   |-module_1/
   |  |-__init__.py
   |  |-foo_implementation.py
   |-module_2/
      |-__init__.py
      |-Bar_implementation.py
</code></pre>
<p>And in each <code>__init__.py</code> you declare an <code>__all__</code>, e.g. in module_1:</p>
<pre><code>from foo_implementation import *
__all__ = ['foo']
</code></pre>
<p>And module_2's <code>__init__.py</code>:</p>
<pre><code>from Bar_implementation import *
__all__ = ['Bar']
</code></pre>
<p>And you can easily add things to your API that you can manage at the subpackage level instead of the subpackage's module level. If you want to add a new name to the API, you simply update the <code>__init__.py</code>, e.g. in module_2:</p>
<pre><code>from Bar_implementation import *
from Baz_implementation import *
__all__ = ['Bar', 'Baz']
</code></pre>
<p>And if you're not ready to publish <code>Baz</code> in the top level API, in your top level <code>__init__.py</code> you could have:</p>
<pre><code>from module_1 import *       # also constrained by __all__'s
from module_2 import *       # in the __init__.py's
__all__ = ['foo', 'Bar']     # further constraining the names advertised
</code></pre>
<p>and if your users are aware of the availability of <code>Baz</code>, they can use it:</p>
<pre><code>import package
package.Baz()
</code></pre>
<p>but if they don't know about it, other tools (like <a href="https://hg.python.org/cpython/file/2.7/Lib/pydoc.py#l173" rel="noreferrer">pydoc</a>) won't inform them.</p>
<p>You can later change that when <code>Baz</code> is ready for prime time:</p>
<pre><code>from module_1 import *
from module_2 import *
__all__ = ['foo', 'Bar', 'Baz']
</code></pre>
<h1>Prefixing <code>_</code> versus <code>__all__</code>:</h1>
<p>By default, Python will export all names that do not start with an <code>_</code>. You certainly <em>could</em> rely on this mechanism. Some packages in the Python standard library, in fact, <em>do</em> rely on this, but to do so, they alias their imports, for example, in <a href="https://hg.python.org/cpython/file/default/Lib/ctypes/__init__.py#l3" rel="noreferrer"><code>ctypes/__init__.py</code></a>:</p>
<pre><code>import os as _os, sys as _sys
</code></pre>
<p>Using the <code>_</code> convention can be more elegant because it removes the redundancy of naming the names again. But it adds the redundancy for imports (if you have a lot of them) and it is <em>easy</em> to forget to do this consistently - and the last thing you want is to have to indefinitely support something you intended to only be an implementation detail, just because you forgot to prefix an <code>_</code> when naming a function.</p>
<p>I personally write an <code>__all__</code> early in my development lifecycle for modules so that others who might use my code know what they should use and not use.</p>
<p>Most packages in the standard library also use <code>__all__</code>.</p>
<h1>When avoiding <code>__all__</code> makes sense</h1>
<p>It makes sense to stick to the <code>_</code> prefix convention in lieu of <code>__all__</code> when:</p>
<ul>
<li>You're still in early development mode and have no users, and are constantly tweaking your API.</li>
<li>Maybe you do have users, but you have unittests that cover the API, and you're still actively adding to the API and tweaking in development.</li>
</ul>
<h1>An <code>export</code> decorator</h1>
<p>The downside of using <code>__all__</code> is that you have to write the names of functions and classes being exported twice - and the information is kept separate from the definitions. We <em>could</em> use a decorator to solve this problem.</p>
<p>I got the idea for such an export decorator from David Beazley's talk on packaging. This implementation seems to work well in CPython's traditional importer. If you have a special import hook or system, I do not guarantee it, but if you adopt it, it is fairly trivial to back out - you'll just need to manually add the names back into the <code>__all__</code></p>
<p>So in, for example, a utility library, you would define the decorator:</p>
<pre><code>import sys

def export(fn):
    mod = sys.modules[fn.__module__]
    if hasattr(mod, '__all__'):
        mod.__all__.append(fn.__name__)
    else:
        mod.__all__ = [fn.__name__]
    return fn
</code></pre>
<p>and then, where you would define an <code>__all__</code>, you do this:</p>
<pre><code>$ cat &gt; main.py
from lib import export
__all__ = [] # optional - we create a list if __all__ is not there.

@export
def foo(): pass

@export
def bar():
    'bar'

def main():
    print('main')

if __name__ == '__main__':
    main()
</code></pre>
<p>And this works fine whether run as main or imported by another function.</p>
<pre><code>$ cat &gt; run.py
import main
main.main()

$ python run.py
main
</code></pre>
<p>And API provisioning with <code>import *</code> will work too:</p>
<pre><code>$ cat &gt; run.py
from main import *
foo()
bar()
main() # expected to error here, not exported

$ python run.py
Traceback (most recent call last):
  File "run.py", line 4, in &lt;module&gt;
    main() # expected to error here, not exported
NameError: name 'main' is not defined
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It also changes what pydoc will show:</p>
<p>module1.py</p>
<pre><code>a = "A"
b = "B"
c = "C"
</code></pre>
<p>module2.py</p>
<pre><code>__all__ = ['a', 'b']

a = "A"
b = "B"
c = "C"
</code></pre>
<p>$ pydoc module1</p>
<pre>
Help on module module1:

<b>NAME</b>
    module1

<b>FILE</b>
    module1.py

<b>DATA</b>
    <b>a</b> = 'A'
    <b>b</b> = 'B'
    <b>c</b> = 'C'
</pre>
<p>$ pydoc module2</p>
<pre>
Help on module module2:

<b>NAME</b>
    module2

<b>FILE</b>
    module2.py

<b>DATA</b>
    <b>__all__</b> = ['a', 'b']
    <b>a</b> = 'A'
    <b>b</b> = 'B'
</pre>
<p>I declare <code>__all__</code> in all my modules, as well as underscore internal details, these really help when using things you've never used before in live interpreter sessions.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="http://effbot.org/pyref/__all__.htm" rel="noreferrer">(An Unofficial) Python Reference Wiki</a>:</p>
<blockquote>
<p>The public names defined by a module are determined by checking the module's namespace for a variable named <code>__all__</code>; if defined, it must be a sequence of strings which are names defined or imported by that module. The names given in <code>__all__</code> are all considered public and are required to exist. If <code>__all__</code> is not defined, the set of public names includes all names found in the module's namespace which do not begin with an underscore character ("_"). <code>__all__</code> should contain the entire public API. It is intended to avoid accidentally exporting items that are not part of the API (such as library modules which were imported and used within the module).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<h1><code>__all__</code> customizes <strong>the asterisk</strong> in <a href="https://docs.python.org/2/tutorial/modules.html#more-on-modules" rel="nofollow noreferrer"><code>from &lt;module&gt; import *</code></a></h1>
<h1><code>__all__</code> customizes <strong>the asterisk</strong> in <a href="https://docs.python.org/2/tutorial/modules.html#importing-from-a-package" rel="nofollow noreferrer"><code>from &lt;package&gt; import *</code></a></h1>
<hr/>
<p>A <a href="https://stackoverflow.com/a/7948504/673991">module</a> is a <code>.py</code> file meant to be imported.</p>
<p>A <a href="https://stackoverflow.com/a/7948504/673991">package</a> is a directory with a <code>__init__.py</code> file. A package usually contains modules.</p>
<hr/>
<h1>MODULES</h1>
<pre><code>""" cheese.py - an example module """

__all__ = ['swiss', 'cheddar']

swiss = 4.99
cheddar = 3.99
gouda = 10.99
</code></pre>
<p><code>__all__</code> lets humans know the "public" features of a <strong>module</strong>.<sup>[<a href="https://stackoverflow.com/a/35710527/673991" title="thanks Aaron Hall">@AaronHall</a>]</sup>  Also, pydoc recognizes them.<sup>[<a href="https://stackoverflow.com/a/2838800/673991" title="thanks @Longpoke">@Longpoke</a>]</sup></p>
<h2>from <em>module</em> import *</h2>
<p>See how <code>swiss</code> and <code>cheddar</code> are brought into the local namespace, but not <code>gouda</code>:</p>
<pre><code>&gt;&gt;&gt; from cheese import *
&gt;&gt;&gt; swiss, cheddar
(4.99, 3.99)
&gt;&gt;&gt; gouda
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'gouda' is not defined
</code></pre>
<p>Without <code>__all__</code>, any symbol (that doesn't start with an underscore) would have been available. </p>
<hr/>
<h1>Imports without <code>*</code> are not affected by <code>__all__</code></h1>
<hr/>
<h2>import <em>module</em></h2>
<pre><code>&gt;&gt;&gt; import cheese
&gt;&gt;&gt; cheese.swiss, cheese.cheddar, cheese.gouda
(4.99, 3.99, 10.99)
</code></pre>
<h2>from <em>module</em> import <em>names</em></h2>
<pre><code>&gt;&gt;&gt; from cheese import swiss, cheddar, gouda
&gt;&gt;&gt; swiss, cheddar, gouda
(4.99, 3.99, 10.99)
</code></pre>
<h2>import <em>module</em> as <em>localname</em></h2>
<pre><code>&gt;&gt;&gt; import cheese as ch
&gt;&gt;&gt; ch.swiss, ch.cheddar, ch.gouda
(4.99, 3.99, 10.99)
</code></pre>
<hr/>
<h1>PACKAGES</h1>
<p>In the <code>__init__.py</code> file of a <strong>package</strong> <code>__all__</code> is a list of strings with the names of public modules or other objects. Those features are available to wildcard imports. As with modules, <code>__all__</code> customizes the <code>*</code> when wildcard-importing from the package.<sup>[<a href="https://stackoverflow.com/a/16595377/673991" title="thanks @MartinStettner">@MartinStettner</a>]</sup> </p>
<p>Here's an excerpt from the <a href="https://dev.mysql.com/doc/connector-python/en/" rel="nofollow noreferrer">Python MySQL Connector</a> <code>__init__.py</code>:</p>
<pre><code>__all__ = [
    'MySQLConnection', 'Connect', 'custom_error_exception',

    # Some useful constants
    'FieldType', 'FieldFlag', 'ClientFlag', 'CharacterSet', 'RefreshOption',
    'HAVE_CEXT',

    # Error handling
    'Error', 'Warning',

    ...etc...

    ]
</code></pre>
<p>The default case, <a href="https://docs.python.org/tutorial/modules.html#importing-from-a-package" rel="nofollow noreferrer">asterisk with no <code>__all__</code> for a package</a>, is complicated, because the obvious behavior would be expensive: to use the file system to search for all modules in the package. Instead, in my reading of the docs, only the objects defined in <code>__init__.py</code> are imported:</p>
<blockquote>
<p>If <code>__all__</code> is not defined, the statement <code>from sound.effects import *</code> does <em>not</em> import all submodules from the package <code>sound.effects</code> into the current namespace; it only ensures that the package <code>sound.effects</code> has been imported (possibly running any initialization code in <code>__init__.py</code>) and then imports whatever names are defined in the package. This includes any names defined (and submodules explicitly loaded) by <code>__init__.py</code>. It also includes any submodules of the package that were explicitly loaded by previous import statements. </p>
</blockquote>
<hr/>
<blockquote>
<p>Wildcard imports ... should be avoided as they [confuse] readers and many automated tools.</p>
</blockquote>
<p><sup>[<a href="https://www.python.org/dev/peps/pep-0008/#imports" rel="nofollow noreferrer" title="see PEP 8, as noted by @ToolmakerSteve">PEP 8</a>, @ToolmakerSteve]</sup></p>
</div>
<div class="post-text" itemprop="text">
<h1>Short answer</h1>
<p><code>__all__</code> affects <code>from &lt;module&gt; import *</code> statements.</p>
<h1>Long answer</h1>
<p>Consider this example:</p>
<pre><code>foo
├── bar.py
└── __init__.py
</code></pre>
<p>In <code>foo/__init__.py</code>:</p>
<ul>
<li><p>(Implicit) If we don't define <code>__all__</code>, then <code>from foo import *</code> will only import names defined in <code>foo/__init__.py</code>.</p></li>
<li><p>(Explicit) If we define <code>__all__ = []</code>, then <code>from foo import *</code> will import nothing.</p></li>
<li><p>(Explicit) If we define <code>__all__ = [ &lt;name1&gt;, ... ]</code>, then <code>from foo import *</code> will only import those names.</p></li>
</ul>
<p>Note that in the implicit case, python won't import names starting with <code>_</code>. However, you can force importing such names using <code>__all__</code>.</p>
<p>You can view the Python document <a href="https://docs.python.org/3/tutorial/modules.html#importing-from-a-package" rel="noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__all__</code> is used to document the public API of a Python module. Although it is optional, <code>__all__</code> should be used.</p>
<p>Here is the relevant excerpt from <a href="https://docs.python.org/3/reference/simple_stmts.html#the-import-statement" rel="noreferrer">the Python language reference</a>:</p>
<blockquote>
<p>The public names defined by a module are determined by checking the module’s namespace for a variable named <code>__all__</code>; if defined, it must be a sequence of strings which are names defined or imported by that module. The names given in <code>__all__</code> are all considered public and are required to exist. If <code>__all__</code> is not defined, the set of public names includes all names found in the module’s namespace which do not begin with an underscore character ('_'). <code>__all__</code> should contain the entire public API. It is intended to avoid accidentally exporting items that are not part of the API (such as library modules which were imported and used within the module).</p>
</blockquote>
<p><a href="https://www.python.org/dev/peps/pep-0008/#public-and-internal-interfaces" rel="noreferrer">PEP 8</a> uses similar wording, although it also makes it clear that imported names are not part of the public API when <code>__all__</code> is absent:</p>
<blockquote>
<p>To better support introspection, modules should explicitly declare the names in their public API using the <code>__all__</code> attribute. Setting <code>__all__</code> to an empty list indicates that the module has no public API.</p>
<p>[...]</p>
<p>Imported names should always be considered an implementation detail. Other modules must not rely on indirect access to such imported names unless they are an explicitly documented part of the containing module's API, such as <code>os.path</code> or a package's <code>__init__</code> module that exposes functionality from submodules.</p>
</blockquote>
<p>Furthermore, as pointed out in other answers, <code>__all__</code> is used to enable <a href="https://docs.python.org/3/tutorial/modules.html#importing-from-a-package" rel="noreferrer">wildcard importing for packages</a>:</p>
<blockquote>
<p>The import statement uses the following convention: if a package’s <code>__init__.py</code> code defines a list named <code>__all__</code>, it is taken to be the list of module names that should be imported when <code>from package import *</code> is encountered.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the existing answers, <code>__all__</code> doesn't have to be a list. As per the documentation on the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-import-statement" rel="nofollow noreferrer"><code>import</code> statement</a>, if defined, <code>__all__</code> must be a <em>sequence of strings</em> which are names defined or imported by the module. So you may as well use a tuple to <a href="https://stackoverflow.com/a/22140115/244297">save</a> some memory and CPU cycles. Just don't forget a comma in case the module defines a single public name:</p>
<p><code>__all__ = ('some_name',)</code></p>
</div>
<span class="comment-copy">Objects that begin with an underscore, or are not mentioned in <code>__all__</code> if <code>__all__</code> is present, are not exactly hidden; they can be seen and accessed perfectly normally if you know their names.  It is only in the case of an "import *", which is not recommended anyway, that the distinction carries any weight.</span>
<span class="comment-copy">@BrandonRhodes: that’s not exactly true either: It’s recommended to only import modules that you know to be designed for <code>import *</code> (like e.g. <code>tk</code>). A good hint if this is the case is the presence of <code>__all__</code> or names starting with underscore in the module’s code.</span>
<span class="comment-copy">Public and internal interfaces - <a href="https://www.python.org/dev/peps/pep-0008/#id50" rel="nofollow noreferrer">python.org/dev/peps/pep-0008/#id50</a>,  To better support introspection, modules should explicitly declare the names in their public API using the __all__ attribute. Setting __all__ to an empty list indicates that the module has no public API.</span>
<span class="comment-copy"><code>from package import *</code> will still import everything defined in <code>__init__.py</code>, even if there is no <code>all</code>. The important difference is that without <code>__all__</code> it will not automatically import any modules defined in package's directory.</span>
<span class="comment-copy">Cross reference: I mentioned your decorator in <a href="http://stackoverflow.com/a/41895257/1468366">this CW answer</a> to the question of how to write an <code>@export</code> decorator.</span>
<span class="comment-copy">This has single handedly been the most helpful answer I have seen in regards to helping a relatively new python developer understand the process of importing modules/packages with <code>__init__.py</code> and the use of <code>__all__</code></span>
<span class="comment-copy">The listed link is dead. but found text verbatim on <a href="https://vdocuments.net/the-python-language-reference-university-of-python-language-reference-release.html" rel="nofollow noreferrer">vdocuments.net/…</a>   &amp; here: <a href="https://dokumen.tips/documents/reference-567bab8d6118a.html" rel="nofollow noreferrer">dokumen.tips/documents/reference-567bab8d6118a.html</a></span>
<span class="comment-copy">I really like this answer, but I'm missing the information on what's the default behavior for <code>from &lt;package&gt; import *</code> without <code>__all__</code> in <code>__init__.py</code> that is <b>not importing any of the modules</b>.</span>
<span class="comment-copy">Thanks @Jatimir, I clarified as best I could without running experiments. I almost wanted to say this case (asterisk without all for a package) behaves the same <b>as if <code>__init__.py</code> were a module</b>. But I'm not sure that's accurate, or in particular if underscore-prefixed objects are excluded. Also, I more clearly separated the sections on MODULES and PACKAGES. Your thoughts?</span>
