<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; a = ['1', '2', '3', '4', '5']
&gt;&gt;&gt; b = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; list(itertools.chain.from_iterable(zip(a,b)))
['1', 'a', '2', 'b', '3', 'c', '4', 'd', '5', 'e']
</code></pre>
<p>As you can see, I have two asymmetrical list and I want to mix them like above. The problem is it ignore the last item.</p>
<p>Expected:
<code>['1', 'a', '2', 'b', '3', 'c', '4', 'd', '5', 'e', 'f']</code></p>
<p>Actual:
<code>['1', 'a', '2', 'b', '3', 'c', '4', 'd', '5', 'e']</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Since you're using <code>itertools</code> in the first place, I assume you want this to work on any iterables, not just lists, and ideally without eagerly listifying them first. Otherwise, just do this:</p>
<pre><code>list(itertools.chain.from_iterable(zip(a,b))) + a[len(b):] + b[len(a):]
</code></pre>
<hr/>
<p>The <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>zip_longest</code></a> function <em>almost</em> does what you want out of the box, but it inserts a <code>fillvalue</code> (default <code>None</code>) for each slot once the shorter iterable runs out. If your values are all truthy, you can just filter those out with <code>if i</code> as in <a href="https://stackoverflow.com/a/49483350/908494">Ajax1234's answer</a>, or <code>filter</code> with <code>None</code> as the predicate, but if your values can be anything in Python, even <code>None</code>, the only way to do it gets pretty clunky:</p>
<pre><code>_sentinel = object()
[elem for elem in itertools.chain.from_iterable(itertools.zip_longest(a, b, fillvalue=_sentinel)) 
 if elem is not _sentinel]
</code></pre>
<hr/>
<p>But you can look at how <code>zip_longest</code> works and do the same thing yourself, only generating "incomplete" tuples instead of "filled-in" tuples, and then call it like this:</p>
<pre><code>list(itertools.chain.from_iterable(zip_longest_nofill(a, b)))
</code></pre>
<p>Although making a variant of the <code>zip_longest</code> code from the docs that's easy enough to explain in an SO answer is a bit challenging, so maybe it's better to use an explicit loop:</p>
<pre><code>def zip_longest_nofill(*args):
    empty = object()
    its = [iter(arg) for arg in args]
    while True:
        vals = (next(it, empty) for it in its)
        tup = tuple(val for val in vals if val is not empty)
        if not tup:
            return
        yield tup
</code></pre>
<p>I think this version is a lot easier to understand (although it was actually a bit harder to write…)</p>
<p>Of course if the only thing you're ever going to use <code>zip_longest_nofill</code> for is to implement your <code>flattened_zip_nofill</code>, it's even easier to just inline it into the flattening part, at which point you end up with basically the two-liner in the last section.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of <code>chain</code>, use <code>zip_longest</code>:</p>
<pre><code>import itertools
a = ['1', '2', '3', '4', '5']
b = ['a', 'b', 'c', 'd', 'e', 'f']
new_results = [i for b in itertools.zip_longest(a, b) for i in b if i is not None]
</code></pre>
<p>Output:</p>
<pre><code>['1', 'a', '2', 'b', '3', 'c', '4', 'd', '5', 'e', 'f']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just manually append the remaining:</p>
<pre><code>def mix(a, b):
    c = list(itertools.chain.from_iterable(zip(a,b)))
    c += a[len(b)] + b[len(a):]
    return c
</code></pre>
<p>One liner:</p>
<pre><code>mix = lambda a, b: list(itertools.chain.from_iterable(zip(a,b))) + a[len(b)] + b[len(a):]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should work but it's not very elegant</p>
<pre><code>lst = []
for i in range(temp = max(len(a), len(b))):
    if i &lt; len(a): lst.append(a[i])
    if i &lt; len(b): lst.append(b[i])

lst
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try itertools zip_longest:</p>
<pre><code>a = ['1', '2', '3', '4', '5']
b = ['a', 'b', 'c', 'd', 'e', 'f']

import itertools

output=[]
for i in itertools.zip_longest(a,b):
    if i[0]==None:
        output.append(i[1])
    else:
        output.extend([i[0],i[1]])

print(output)
</code></pre>
<p>output:</p>
<pre><code>['1', 'a', '2', 'b', '3', 'c', '4', 'd', '5', 'e', 'f']
</code></pre>
</div>
<span class="comment-copy">That will add spurious <code>None</code> values.</span>
<span class="comment-copy">@abarnert yes, however, they can be filtered out of the final result.</span>
<span class="comment-copy">Sure, but if the original lists can have any falsey values like <code>0</code> or <code>''</code> or, worse, <code>None</code>, it'll filter them out too.</span>
<span class="comment-copy">@abarnert Good point, edited.</span>
<span class="comment-copy">You can solve that by using <code>_sentinel=object()</code>, passing <code>fillvalue=_sentinel</code> to <code>zip_longest</code>, and using <code>if i is not _sentinel</code>, but at that point it's not much simpler than just writing a loop…</span>
<span class="comment-copy"><code>mix(b, a)</code> is almost certainly not what he wants. I'm pretty sure you want to remove the <code>if</code> and just do <code>c += b[len(a):] + a[len(b):]</code> or something less terse.</span>
<span class="comment-copy">@abarnert Thanks I didn't realise it.</span>
