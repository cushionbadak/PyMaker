<div class="post-text" itemprop="text">
<p>I'm new to learning Python and have enough under my belt to start attempting a beginner's Tic-Tac-Toe program.</p>
<p>My issue is thus: I want to have a generic input function called getInput() which will get input from the user, strip trailing white space from that input, and THEN, if a function was passed to it via the optional parameter "specialTest", getInput() will run the input through this provided function and return the output which the specialTest function spat out.</p>
<p>Sometimes this specialTest function will need additional arguments besides the user input. Assume for my purposes that the user input will always be the first argument and is required, and that any additional args will come afterwards.</p>
<p>I tried to implement this situation via *args, and I got it working if the specialTest function had no additional arguments. But the first time I try to feed it additional arguments, it fails.</p>
<p>So for example, <strong>getInput("Age?", specialTest=int)</strong> works. It prompts for user input and feeds it through the int() function, finally returning the output as an integer. But when I try to pass getInput() a function which has an additional argument - an ordered dictionary which contains strings as keys and dictionaries as values - the program fails with <strong>TypeTypeError: getInput() got multiple values for argument 'specialTest'</strong>. What needs to be adjusted to get this working as intended?</p>
<p><strong>Code:</strong></p>
<pre><code>import collections


def getInput(msg, specialTest=None, *TestArgs):
    """Get user input and export to the desired format."""
    while True:
        string = input(msg + ' ').strip()

        # If the user passed a function to the SpecialTest parameter,
        # pass the user input through that function and return its value.
        # If the SpecialTest function returns False or we hit an error,
        # that means the input was invalid and we need to keep looping
        # until we get valid input.
        if specialTest:
            try:
                string = specialTest(string, *TestArgs)
                if string is False: continue
            except:
                continue

        return string


def nametoMove(name, board):
    """Convert player's move to an equivalent board location."""
    location = {name: theBoard.get(name)}
    # return false if the location name isn't present on the board
    if location[name] is None:
        return False
    return location


# ---Tic-Tac-Toe routine---

# fill the board
row_name = ('top', 'mid', 'lower')
col_name = ('left', 'center', 'right')

theBoard = collections.OrderedDict()
size = 3  # 3x3 board

for x in range(size):
    for y in range(size):
        key = row_name[x] + ' ' + col_name[y]
        value = {'row': x, 'col': y}
        theBoard.update({key: value})

# get player's desired board symbol
playerSymbol = getInput("X's or O's?")

# get player's age
playerAge = getInput("Age?", specialTest=int)

# get player's move and convert to same format as theBoard object
# e.g., "top left" --&gt; {'top left': {'row': 0, 'col': 0}}
playerMove = getInput("Move?", specialTest=nametoMove, *theBoard)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In order to support supplying the same parameter via a positional or keyword argument, Python <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow noreferrer">converts any keyword arguments that can be</a> into positional arguments.  That creates the conflict in your example.  Syntactically, what you want can be achieved by simply omitting the argument:</p>
<pre><code>playerMove = getInput("Move?", nametoMove, *theBoard)
</code></pre>
<p>Or you can resolve the ambiguity with a “keyword-only” argument:</p>
<pre><code>def getInput(msg, *TestArgs , specialTest=None):
</code></pre>
<p>Then the keyword argument cannot be converted, so there is no collision.  (This can be emulated in Python 2 by using <code>**kw</code> to accept <em>arbitrary</em> keyword arguments and then checking that only the expected one is actually provided.)</p>
<p>But the question you <strong>should</strong> be asking is “How can I preset some arguments to a function used as a callback?”, to which the answer is either a <code>lambda</code>:</p>
<pre><code>playerMove = getInput("Move?", specialTest=lambda s: nametoMove(s, *theBoard))
</code></pre>
<p>or <code>functools.partial</code>:</p>
<pre><code>playerMove = getInput("Move?", specialTest=functools.partial(nametoMove, board=theBoard))
</code></pre>
<p>With either of these, you don’t need <code>TestArgs</code> at all.  The <code>partial</code> approach doesn’t support supplying <em>trailing</em> positional arguments (like varargs), but your <code>nametoMove</code> doesn’t actually want those anyway (as established in the comments).  So in all the approaches above you omit the <code>*</code>.</p>
</div>
<span class="comment-copy">Python doesn't like positional arguments (like <code>*theBoard</code>) after keyword arguments (<code>specialTest=nametoMove</code>). Change <code>specialTest=nametoMove</code> to just <code>nametoMove</code> and it'll work.</span>
<span class="comment-copy">Can you show what you expect the call to <code>specialTest</code> to look like?  That is, do you want it to be <code>specialTest('top', 'left', 2)</code> or what?  It looks like you're trying to pass keyword arguments (since <code>theBoard</code> is a dictionary) but then your keys have spaces in them.</span>
<span class="comment-copy">If you're always going to have a list of arguments that you splat into the call—like that <code>getInput ("Move?", specialTest=nametoMove, *theBoard)</code>—instead of multiple separate values, you probably don't want <code>*args</code> at all. Just take a sequence called, say, <code>specialArgs</code> as a plain-old argument, and pass <code>theBoard</code> as-is instead of <code>*theBoard</code>. (This has the added advantage that you can use <code>specialArgs</code> as a keyword in calling the function.)</span>
<span class="comment-copy">Meanwhile, <code>theBoard</code> is an <code>OrderedDict</code>. While you <i>can</i> splat that with <code>*theBoard</code>, what you're doing is passing just the keys, as positional arguments, not the key-value pairs as keyword arguments. Is that what you wanted?</span>
<span class="comment-copy">@BrenBarn, when I call the actual nametoMove() function, it takes a string, and an ordered dictionary. It then checks to see if the ordered dictionary contains any keys which match the string, and if so, returns that dictionary item. For example, <code>nametoMove("top left", theBoard))</code> will return <code>{'top left': {'row': 0, 'col': 0}}</code> because the value which matches the "top left" key in theBoard dictionary is <code>{'row': 0, 'col': 0}</code></span>
