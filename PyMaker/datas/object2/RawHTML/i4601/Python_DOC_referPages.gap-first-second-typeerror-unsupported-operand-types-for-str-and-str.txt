<div class="post-text" itemprop="text">
<p>I have a tuple of tuples from a MySQL query like this:</p>
<pre><code>T1 = (('13', '17', '18', '21', '32'),
      ('07', '11', '13', '14', '28'),
      ('01', '05', '06', '08', '15', '16'))
</code></pre>
<p>I'd like to convert all the string elements into integers and put them back into a list of lists:</p>
<pre><code>T2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]]
</code></pre>
<p>I tried to achieve it with <code>eval</code> but didn't get any decent result yet.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#int" rel="noreferrer"><code>int()</code></a> is the Python standard built-in function to convert a string into an integer value. You call it with a string containing a number as the argument, and it returns the number converted to an integer:</p>
<pre><code>print (int("1") + 1)
</code></pre>
<p>The above prints <code>2</code>.</p>
<p>If you know the structure of your list, T1 (that it simply contains lists, only one level), you could do this in Python 2:</p>
<pre><code>T2 = [map(int, x) for x in T1]
</code></pre>
<p>In Python 3:</p>
<pre><code>T2 = [list(map(int, x)) for x in T1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with a list comprehension:</p>
<pre><code>T2 = [[int(column) for column in row] for row in T1]
</code></pre>
<p>The inner list comprehension (<code>[int(column) for column in row]</code>) builds a <code>list</code> of <code>int</code>s from a sequence of <code>int</code>-able objects, like decimal strings, in <code>row</code>. The outer list comprehension (<code>[... for row in T1])</code>) builds a list of the results of the inner list comprehension applied to each item in <code>T1</code>.</p>
<p>The code snippet will fail if any of the rows contain objects that can't be converted by <code>int</code>. You'll need a smarter function if you want to process rows containing non-decimal strings.</p>
<p>If you know the structure of the rows, you can replace the inner list comprehension with a call to a function of the row. Eg.</p>
<pre><code>T2 = [parse_a_row_of_T1(row) for row in T1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would rather prefer using only comprehension lists:</p>
<pre><code>[[int(y) for y in x] for x in T1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of putting <code>int( )</code>, put <code>float( )</code> which will let you use decimals along with integers.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would agree with everyones answers so far but the problem is is that if you do not have all integers they will crash.</p>
<p>If you wanted to exclude non-integers then</p>
<pre><code>T1 = (('13', '17', '18', '21', '32'),
      ('07', '11', '13', '14', '28'),
      ('01', '05', '06', '08', '15', '16'))
new_list = list(list(int(a) for a in b) for b in T1 if a.isdigit())
</code></pre>
<p>This yields only actual digits.  The reason I don't use direct list comprehensions is because list comprehension leaks their internal variables.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>T3=[]

for i in range(0,len(T1)):
    T3.append([])
    for j in range(0,len(T1[i])):
        b=int(T1[i][j])
        T3[i].append(b)

print T3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this.</p>
<pre><code>x = "1"
</code></pre>
<p>x is a string because it has quotes around it, but it has a number in it.</p>
<pre><code>x = int(x)
</code></pre>
<p>Since x has the number 1 in it, I can turn it in to a integer.</p>
<p>To see if a string is a number, you can do this.</p>
<pre><code>def is_number(var):
    try:
        if var == int(var):
            return True
    except Exception:
        return False

x = "1"

y = "test"

x_test = is_number(x)

print(x_test)
</code></pre>
<p>It should print to IDLE True because x is a number.</p>
<pre><code>y_test = is_number(y)

print(y_test)
</code></pre>
<p>It should print to IDLE False because y in not a number.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using list comprehensions:</p>
<pre><code>t2 = [map(int, list(l)) for l in t1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.5.1 things like these work:</p>
<pre><code>c = input('Enter number:')
print (int(float(c)))
print (round(float(c)))
</code></pre>
<p>and</p>
<pre><code>Enter number:  4.7
4
5
</code></pre>
<p>George.</p>
</div>
<div class="post-text" itemprop="text">
<p>See this function</p>
<pre><code>def parse_int(s):
    try:
        res = int(eval(str(s)))
        if type(res) == int:
            return res
    except:
        return
</code></pre>
<p>Then</p>
<pre><code>val = parse_int('10')  # Return 10
val = parse_int('0')  # Return 0
val = parse_int('10.5')  # Return 10
val = parse_int('0.0')  # Return 0
val = parse_int('Ten')  # Return None
</code></pre>
<p>You can also check</p>
<pre><code>if val == None:  # True if input value can not be converted
    pass  # Note: Don't use 'if not val:'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yet another functional solution for Python 2:</p>
<pre><code>from functools import partial

map(partial(map, int), T1)
</code></pre>
<p>Python 3 will be a little bit messy though:</p>
<pre><code>list(map(list, map(partial(map, int), T1)))
</code></pre>
<p>we can fix this with a wrapper</p>
<pre><code>def oldmap(f, iterable):
    return list(map(f, iterable))

oldmap(partial(oldmap, int), T1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If it's only a tuple of tuples, something like <code>rows=[map(int, row) for row in rows]</code> will do the trick. (There's a list comprehension and a call to map(f, lst), which is equal to [f(a) for a in lst], in there.)</p>
<p>Eval is <em>not</em> what you want to do, in case there's something like <code>__import__("os").unlink("importantsystemfile")</code> in your database for some reason.
Always validate your input (if with nothing else, the exception int() will raise if you have bad input).</p>
</div>
<div class="post-text" itemprop="text">
<p>I want to share an available option that doesn't seem to be mentioned here yet:</p>
<pre><code>rumpy.random.permutation(x)
</code></pre>
<p>Will generate a random permutation of array x. Not <em>exactly</em> what you asked for, but it is a potential solution to similar questions.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do something like this:</p>
<pre><code>T1 = (('13', '17', '18', '21', '32'),  
     ('07', '11', '13', '14', '28'),  
     ('01', '05', '06', '08', '15', '16'))  
new_list = list(list(int(a) for a in b if a.isdigit()) for b in T1)  
print(new_list)  
</code></pre>
</div>
<span class="comment-copy">Perhaps consider a different database adapter module? I know the PostgreSQL adapter modules will return results like your T2 set.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/379906/parse-string-to-float-or-int">Parse String to Float or Int</a></span>
<span class="comment-copy">please notice: when using map, you will get a list of map objects in python 3 and 3.5. This does it for Python 3.5 as mentioned above. new_list = list(list(int(a) for a in b) for b in T1 if a.isdigit())</span>
<span class="comment-copy">Similar question for a non-nested list: <a href="//stackoverflow.com/q/7368789">Convert all strings in a list to int</a></span>
<span class="comment-copy">Great! Actually, the example given also works for "naked" numbers in the input, but will wrap them in one-element lists.</span>
<span class="comment-copy">@unwind Nice answer</span>
<span class="comment-copy">doesn't work in py3k</span>
<span class="comment-copy">why not <code>T2 = map(lambda lol: map(int, lol), T1)</code>? Either map or list comprehensions, both is silly ;)</span>
<span class="comment-copy">@flyingsheep Double map seems silly to me, this seems just fine.</span>
<span class="comment-copy">Can you explain more details on you answer?</span>
<span class="comment-copy"><code>isdigit</code> is tricky, try it on <code>-1</code>. <code>int(&lt;str&gt;)</code> is the way to check by <code>try</code>/<code>except</code>.</span>
<span class="comment-copy">Welcome to Stack Overflow! Rather than only post a block of code, please explain why this code solves the problem posed. Without an explanation, this is not   an answer.</span>
<span class="comment-copy">Better would be:</span>
<span class="comment-copy">Your is_number function is wrong. '1' is not equal to 1. This is not Perl. :-P</span>
<span class="comment-copy">Donâ€™t reinvent the wheel, use <code>x.isnumeric()</code>.</span>
<span class="comment-copy">in python 3 this returns a list of map objects :(</span>
<span class="comment-copy"><code>eval</code> is evil: you should replace it with <code>ast.literal_eval</code>.</span>
