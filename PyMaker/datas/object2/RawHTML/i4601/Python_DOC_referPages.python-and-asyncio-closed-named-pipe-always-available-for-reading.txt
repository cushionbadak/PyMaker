<div class="post-text" itemprop="text">
<p>I am working on a script that reads data through a named pipe from another piece of software. I would like to read data only when available, and I was trying to use <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.add_reader" rel="nofollow noreferrer"><code>add_reader</code> from <code>asyncio</code></a>.</p>
<p>I noticed that, on Linux, the reader I registered is called continuously after the pipe is closed. On macOS, this doesn't happen.</p>
<p>This puzzles me, because after the writing end of the pipe has hung up, I would not expect the reading end to be available for reading, especially because clearly there can be no data.</p>
<p>This script illustrates the problem:</p>
<pre class="lang-python prettyprint-override"><code>#!/usr/bin/env python3
import os, asyncio, threading, time
NAMED_PIPE = 'write.pipe'

# Setup the named pipe
if os.path.exists(NAMED_PIPE):
    os.unlink(NAMED_PIPE)
os.mkfifo(NAMED_PIPE)

loop = asyncio.get_event_loop()

def simulate_write():
    # Open the pipe for writing and write something into it.
    # This simulates another process
    print('waiting for opening pipe for writing')
    with open(NAMED_PIPE, 'w') as write_stream:
        print('writing pipe opened')
        time.sleep(1)
        print('writing some data')
        print('&lt;some data&gt;', file=write_stream)
        time.sleep(1)
    print('exiting simulated write')


async def open_pipe_for_reading():
    print('waiting for opening pipe for reading')
    # This needs to run asynchronously because open will
    # not reuturn until on the other end, someone tries
    # to write
    return open(NAMED_PIPE)

count = 0
def read_data_block(fd):
    global count
    count += 1
    print('reading data', fd.read())
    if count &gt; 10:
        print('reached maximum number of calls')
        loop.remove_reader(fd.fileno())

# Spawn a thread that will simulate writing
threading.Thread(target=simulate_write).start()
# Get the result of open_pipe_for_reading
stream = loop.run_until_complete(open_pipe_for_reading())
print('reading pipe opened')
# Schedule the reader
loop.add_reader(stream.fileno(), read_data_block, stream)
try:
    loop.run_forever()
except KeyboardInterrupt:
    pass
finally:
    print('closing stream')
    stream.close()
print('removing pipe')
os.unlink(NAMED_PIPE)
</code></pre>
<p>On OSX, this is the behavior I observe:</p>
<pre><code>waiting for opening pipe for writing
waiting for opening pipe for reading
reading pipe opened
writing pipe opened
writing some data
exiting simulated write
reading data &lt;some data&gt;

^Cclosing stream
removing pipe
</code></pre>
<p>While on Linux:</p>
<pre><code>waiting for opening pipe for writing
waiting for opening pipe for reading
reading pipe opened
writing pipe opened
writing some data
exiting simulated write
reading data &lt;some data&gt;

reading data
reading data
reading data
reading data
reading data
reading data
reading data
reading data
reading data
reading data
reached maximum number of calls
^C&lt;closing stream
removing pipe
</code></pre>
<p>So, <strong>why is a closed pipe available for reading although it has no data?</strong></p>
<p>Also, in my understanding, <code>add_reader</code> would trigger when the stream can be read from <em>and</em> there is some data to read; <strong>is this interpretation correct?</strong></p>
<hr/>
<p>Python and OS versions:</p>
<ul>
<li>Python 3.6.4 (MacPorts), macOS High Sierra 10.13.3 (17D102)</li>
<li>Python 3.6.1 (manually compiled) CentOS Linux release 7.4.1708 (Core) </li>
<li>Python 3.5.2 (from repo) Linux Mint 18.2 Sonya</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In python reading an empty data is a sign for socket/pipe closing.</p>
<pre><code>data = fd.read()
if not data:
    return
</code></pre>
<p>Also please switch the pipe to non-blocking mode:</p>
<pre><code>os.set_blocking(fd, False)
</code></pre>
</div>
<span class="comment-copy">Actually if I set it to non-blocking, any time I read when no data is available, I would get empty data, although the pipe is still open (although on Linux that would work for detecting when the pipe is closed and rescheduling the reader). That doesn't explain the rationale behind <code>add_reader</code>, though.</span>
