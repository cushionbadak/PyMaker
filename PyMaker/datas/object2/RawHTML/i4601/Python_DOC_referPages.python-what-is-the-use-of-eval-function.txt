<div class="post-text" itemprop="text">
<p>There is an <code>eval()</code> function in Python I stumbled upon while playing around. I cannot think of a case when this function is needed, except maybe as syntactic sugar. Can anyone give an example?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>eval</code> and <code>exec</code> are handy quick-and-dirty way to get some source code dynamically, maybe munge it a bit, and then execute it -- but they're hardly ever the best way, especially in production code as opposed to "quick-and-dirty" prototypes &amp;c.</p>
<p>For example, if I had to deal with such dynamic Python sources, I'd reach for the <a href="http://docs.python.org/library/ast.html#module-ast" rel="noreferrer">ast</a> module -- <code>ast.literal_eval</code> is MUCH safer than <code>eval</code> (you can call it directly on a string form of the expression, if it's a one-off and relies on simple constants only, or do <code>node = ast.parse(source)</code> first, then keep the <code>node</code> around, perhaps munge it with suitable visitors e.g. for variable lookup, then <code>literal_eval</code> the node) -- or, once having put the node in proper shape and vetted it for security issues, I could <code>compile</code> it (yielding a code object) and build a new function object out of that. Far less simple (except that <code>ast.literal_eval</code> is just as simple as <code>eval</code> for the simplest cases!) but safer and preferable in production-quality code.</p>
<p>For many tasks I've seen people (ab-)use <code>exec</code> and <code>eval</code> for, Python's powerful built-ins, such as <code>getattr</code> and <code>setattr</code>, indexing into <code>globals()</code>, &amp;c, provide preferable and in fact often simpler solutions. For specific uses such as parsing JSON, library modules such as <code>json</code> are better (e.g. see SilentGhost's comment on tinnitus' answer to this very question). Etc, etc...</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://en.wikipedia.org/wiki/Eval#Uses" rel="noreferrer">Wikipedia article on <code>eval</code></a> is pretty informative, and details various uses.</p>
<p>Some of the uses it suggests are:</p>
<ul>
<li>Evaluating mathematical expressions</li>
<li><a href="http://en.wikipedia.org/wiki/Bootstrapping_(compilers)" rel="noreferrer">Compiler bootstrapping</a></li>
<li>Scripting (dynamic languages in general are very suitable to this)</li>
<li>Language tutors</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You may want to use it to allow users to enter their own "scriptlets": <strong>small</strong> expressions (or even small functions), that can be used to customize the behavior of a <strong>complex</strong> system.<br/>
In that context, and if you do not have to care too much for the security implications (e.g. you have an educated userbase), then eval() may be a good choice.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the past I have used eval() to add a debugging interface to my application. I created a telnet service which dropped you into the environment of the running application. Inputs were run through eval() so you can interactively run Python commands in the application.</p>
</div>
<div class="post-text" itemprop="text">
<p>In a program I once wrote, you had an input file where you could specify geometric parameters both as values and as python expressions of the previous values, eg:</p>
<pre><code>a=10.0
b=5.0
c=math.log10(a/b)
</code></pre>
<p>A python parser read this input file and obtained the final data evaluating the values and the expressions using eval().</p>
<p>I don't claim it to be good programming, but I did not have to drive a nuclear reactor.</p>
</div>
<div class="post-text" itemprop="text">
<p>I use it as a quick JSON parser ...</p>
<pre><code>r='''
{
    "glossary": {
        "title": "example glossary"
        }
}
'''

print eval(r)['glossary']['title']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>eval()</code> is not normally very useful. One of the few things I have used it for (well, it was <code>exec()</code> actually, but it's pretty similar) was allowing the user to script an application that I wrote in Python. If it were written in something like C++, I would have to embed a Python interpreter in the application.</p>
</div>
<div class="post-text" itemprop="text">
<p>Eval is a way to interact with the Python interpreter from within a program. You can pass literals to eval and it evaluates them as python expressions.</p>
<p>For example - </p>
<pre><code>print eval("__import__('os').getcwd()")
</code></pre>
<p>would return the current working directory.</p>
<p>cheers</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use eval in a decorator:</p>
<pre><code>#this replaces the original printNumber with a lambda-function,
#which takes no arguments and which calls the old function with
#the number 10
@eval("lambda fun: lambda: fun(10)")
def printNumber(i: int) -&gt; None:
    print("The number is %i", i)

#call
printNumber()
</code></pre>
<p>while you cannot use complex expressions like</p>
<pre><code>@lambda fun: lambda: fun(10)
def ...
</code></pre>
<p>nor</p>
<pre><code>@(lambda fun: lambda: fun(10))
def ...
</code></pre>
<p>You cannot use a lambda-expression there, because the decorator should either be an identifier:</p>
<pre><code>@myModule.functionWithOneArg
</code></pre>
<p>or a function call:</p>
<pre><code>@functionReturningFunctionWithOneArg(any, "args")
</code></pre>
<p>You see that the call of the function eval with a string has valid syntax here, but the lambda-expression not. (-&gt; <a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions" rel="nofollow noreferrer">https://docs.python.org/3/reference/compound_stmts.html#function-definitions</a>)</p>
</div>
<div class="post-text" itemprop="text">
<p>I used it to input variable values to the main program:</p>
<p>test.py var1=2 var2=True</p>
<p>...</p>
<pre><code>var1=0
var2=False
for arg in sys.argv[1:]:
    exec(arg)
</code></pre>
<p>A crude way to allow keyword args in the main program. If there's a better way let me know!</p>
</div>
<div class="post-text" itemprop="text">
<p>eval() is for single sentence, while exec() is for multiple ones.</p>
<p>usually we use them to add or visit some scripts just like bash shell.</p>
<p>because of they can run some byte scripts in the memory, if you have some important data or script you can decode and unzip your 'secret' then do everything you wanna.</p>
</div>
<div class="post-text" itemprop="text">
<p>I just came across a good use of eval. I was writing a test suite for some code, and created a Test class, where every method was a test to be run. I wanted a way so that I could run all the test methods without having to call each method individually. So, I wrote something rather dirty.</p>
<pre><code>class Test:
    def __init__(self, *args):
       #bs

    def test1(self):
       #bs

    def test2(self):
       #bs

if __name__ == "__main__":
    import argparse
    #argparse bs
    test = Test(*bs_args)
    for func in (i for i in dir(test) if i[0] != '_' and i not in test.__dict__):
        print(eval('test.{func}()'.format(func = func)))
</code></pre>
<p>Dynamic evaluation of arbitrary test cases is pretty cool. I just have to write the method, and after saving I can include the method in my test suite. As for the code, I basically just inspect the methods defined in the test object, and make sure they aren't default python "magic" methods or attributes to the Test object. After that I can assume they are methods and can be evaluated.</p>
</div>
<div class="post-text" itemprop="text">
<p>I use <code>exec</code> to create a system of plugins in Python.</p>
<pre>
    try:
        exec ("from " + plugin_name + " import Plugin")
        myplugin = Plugin(module_options, config=config)
    except ImportError, message:
        fatal ("No such module " + plugin_name + \
               " (or no Plugin constructor) in my Python path: " + str(message))
    except Exception:
        fatal ("Module " + plugin_name + " cannot be loaded: " + \
               str(sys.exc_type) + ": " + str(sys.exc_value) + \
               ".\n    May be a missing or erroneous option?")
</pre>
<p>With a plugin like:</p>
<pre>
class Plugin:

    def __init__ (self):
        pass

    def query(self, arg):
         ...
</pre>
<p>You will be able to call it like:</p>
<pre>
    result = myplugin.query("something")
</pre>
<p>I do not think you can have plugins in Python without <code>exec</code>/<code>eval</code>.</p>
</div>
<span class="comment-copy">'as syntactic sugar' - what does this mean?</span>
<span class="comment-copy">I looked at this article and still don't understand... This is rather like a calculate function which calculates an arithmetic expression!</span>
<span class="comment-copy">@ooboo: <code>eval</code> can run <i>any</i> code in theory (hence the security risks pointed out in the article).</span>
<span class="comment-copy">I've done similar scripting the COM interface to Enterprise Architect to try out different queries</span>
<span class="comment-copy">don't do it. <code>eval("""{"glossary": {"death" : false}}""")</code> --&gt; <code>NameError: name 'false' is not defined</code></span>
<span class="comment-copy">@SilentGhost: that's a great point, I've used your example in an answer to a question; <a href="http://stackoverflow.com/questions/1083250/running-json-through-pythons-eval/1083302" title="running json through pythons eval">stackoverflow.com/questions/1083250/â€¦</a></span>
<span class="comment-copy">Using a <i>real</i> JSON parser would be less buggy and more secure.</span>
<span class="comment-copy">Nice idea in general :), could be applied on different things, yet, I won't use it with JSON, there are tools for that.</span>
<span class="comment-copy">Very bad idea...</span>
<span class="comment-copy">nice idea as well :)</span>
<span class="comment-copy">This is not good.  You should use the <code>__import__</code> builtin function, which is called by the <code>from ... import ...</code> statement.</span>
