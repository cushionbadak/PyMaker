<div class="post-text" itemprop="text">
<p>For a test, I need to mock some slow, external calls.</p>
<p>This is my current test setup, which looks bloated and ugly.</p>
<pre><code>my_obj.child_object = mock.Mock()
my_obj.child_object.meth1_call = mock.Mock()
my_obj.child_object.meth1_call().meth2_call = mock.Mock(return_value= [custom_list])
</code></pre>
<p>child_object is not available at test run, but</p>
<pre><code>my_obj.child_object.meth1_call().meth2_call
</code></pre>
<p>has to be called during test and return the custom_list.</p>
<p>Quoting Raymond Hettinger... "there must be a better way!".</p>
<p>Any shortcut or better way compared to above setup?</p>
</div>
<div class="post-text" itemprop="text">
<p>Alternative ugliness with context manager?</p>
<pre><code>my_obj.child_object = mock.Mock()
with mock.patch('__main__.my_obj.child_object.meth1_call().meth2_call')\
    as m:
    m.return_value = [custom_list]
</code></pre>
</div>
<span class="comment-copy">Thanks for you solution, but you name it - it is (almost) equally ugly. Maybe the solution is not on the mocking side, but on the code side, ie maybe the code, which has to be mocked should be refactored, so it can be easier mocked :-) I will have a look at the code when I work on it next time.</span>
<span class="comment-copy">@jugmac00 To recursively create mocks on the fly you can use <code>create_autospec</code> with an object, or a class, as a spec, see <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.create_autospec" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a>, if that helps</span>
