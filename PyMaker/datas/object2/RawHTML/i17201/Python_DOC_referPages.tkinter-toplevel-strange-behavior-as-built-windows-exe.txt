<div class="post-text" itemprop="text">
<p>I'm using tk for a project's GUI. I have some very strange behavior with it, but only as a built executable on windows. Essentially I have a function launches a new process and needs to update some GUI elements after it completes. This works fine on OS X and Windows running interpreted. It works fine as a OS X binary. But as a Windows binary, the code causes a second main window to appear for unknown reason.</p>
<p>The app is launched via:</p>
<pre><code>root = tk.Tk()
root.withdraw()
app = impy()
root.mainloop()
</code></pre>
<p>where</p>
<pre><code>class impy(tk.Toplevel):
</code></pre>
<p>Then sometime later a user clicks a button which causes this to run:</p>
<pre><code>dialog = Progress_Dialog()
dialog.set_text('Implosion generation...')
dialog.update_idletasks()

# Use helper function:
parent_conn, child_conn = Pipe()
p = Process(target=ImplosionRunner.run, args=(child_conn,))
self.processes.append(p)

# start the process and send implosion:
p.start()
try:
    parent_conn.send(self.imp)
except:
    raise Exception('Implosion object passed to ImplosionRunner is not pickleable!')

obj = None
# Loop while the process is active:
def callback():
    nonlocal dialog, p, parent_conn
    if dialog.cancelled:
        dialog.withdraw()
        p.terminate()
        return

    # Try to receive from the Pipe:
    if parent_conn.poll():
        # Update the progress, or end otherwise:
        obj = parent_conn.recv()
        if isinstance(obj, Exception):
            from tkinter.messagebox import showerror
            showerror('Error!', 'A problem occurred generating the implosion (class '+self.imp.name()+')\n'+obj.__str__())
            dialog.withdraw()
            p.terminate()
            return
        elif isinstance(obj, float):
            dialog.set(100*obj)
        elif isinstance(obj, Implosion):
            # Pass info back to the main app:
            self.imp = obj
            self.after(10, self.__postImplosion__)
            dialog.withdraw()
            p.terminate()
            return

    self.after(25, callback)

self.after(10, callback)
</code></pre>
<p>The callback loop eventually completes via the <code>elif isinstance(obj, Implosion)</code> clause. Then those functions are all called. Something that they do causes a second Toplevel window to appear which is essentially a clone of the main window. The UI operations are applied to the clone. The <code>__postImplosion__</code> method is just:</p>
<pre><code>for key in self.modControlChecks.keys():
        self.modControlChecks[key].configure(state=tk.NORMAL)

    # Run any modules that were already checked in refresh mode
    for key in self.modControlChecks.keys():
        self.modRedisplay[key] = (self.modControlVars[key].get() == 1)
    for mod in allModules():
        if self.modRedisplay[mod.name()]:
            self.__runModule__(mod.name())
</code></pre>
<p>it just has to loop over some check boxes and enable them. I'm pretty baffled since this is only a problem with Windows binaries. Any thoughts?</p>
<p><strong>Update:</strong> Some more troubleshooting: The extra main window appears immediately after <code>p.start()</code> is called. So this seems to be some weird behavior. Why can't I launch a process without an extra Tk window appearing?</p>
</div>
<div class="post-text" itemprop="text">
<p>OK, as usual, the solution is that I should have RTFM. According to the <a href="http://docs.python.org/3/library/multiprocessing.html#multiprocessing.freeze_support" rel="nofollow">docs</a> there is a magic function that must be called to fix weird problems with <code>multiprocessing</code> when frozen on Windows.</p>
<pre><code>if __name__ == "__main__":
    freeze_support()
    root = tk.Tk()
    root.withdraw()
    app = impy()
    root.mainloop()
</code></pre>
</div>
<span class="comment-copy">Why not just app.mainloop()? Why create root and then withdraw it?</span>
<span class="comment-copy">This example has the application class based off a Toplevel instead of a Frame. So it doesn't require the default toplevel. Everything is built into the secondary toplevel widget.</span>
