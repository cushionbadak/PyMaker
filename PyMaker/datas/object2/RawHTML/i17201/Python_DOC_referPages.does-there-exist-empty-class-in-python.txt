<div class="post-text" itemprop="text">
<p>Does there exist special class in python to create empty objects? I tried object(), but it didn't allow me to add fields.
I want to use it like this:</p>
<pre><code>obj = EmptyObject()
obj.foo = 'far'
obj.bar = 'boo'
</code></pre>
<p>Should I each time(in several independent scripts) define new class like this?</p>
<pre><code>class EmptyObject:
    pass
</code></pre>
<p>I use python2.7</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="noreferrer"><code>types.SimpleNamespace</code></a> was introduced with Python 3.3 to serve this exact purpose. The documentation also shows a simple way to implement it yourself in Python, so you can add it to your pre-Python 3.3 setup and use it as if it was there (note that the actual implementation is done in C):</p>
<pre><code>class SimpleNamespace (object):
    def __init__ (self, **kwargs):
        self.__dict__.update(kwargs)
    def __repr__ (self):
        keys = sorted(self.__dict__)
        items = ("{}={!r}".format(k, self.__dict__[k]) for k in keys)
        return "{}({})".format(type(self).__name__, ", ".join(items))
    def __eq__ (self, other):
        return self.__dict__ == other.__dict__
</code></pre>
<p>But of course, if you don’t need its few features, a simple <code>class Empty: pass</code> does just the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are looking for a place holder object to which you can add arbitrary static members, then the closest I got is an empty lambda function.</p>
<pre><code>obj = lambda: None    # Dummy function
obj.foo = 'far'
obj.bar = 'boo'

print obj.foo, obj.bar
# far boo
</code></pre>
<p><strong>Remember:</strong> <code>obj</code> is <em>not</em> an object of a class, <em>object</em> doesn't mean <em>class instance</em>, because in Python classes and functions are objects at runtime just like class instances</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no <code>types.SimpleNamespace</code> in Python 2.7, you could use <code>collections.namedtuple()</code> for immutable objects instead:</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; FooBar = namedtuple('FooBar', 'foo bar')
&gt;&gt;&gt; FooBar('bar', 'foo')
FooBar(foo='bar', bar='foo')
</code></pre>
<p>Or <code>argparse.Namespace</code>:</p>
<pre><code>&gt;&gt;&gt; from argparse import Namespace
&gt;&gt;&gt; o = Namespace(foo='bar')
&gt;&gt;&gt; o.bar = 'foo'
&gt;&gt;&gt; o
Namespace(bar='foo', foo='bar')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a new type dynamically with the fields you want it to have using the <code>type</code> function, like this:</p>
<pre><code>x = type('empty', (object,), {'foo': 'bar'})
x.bar = 3
print(x.foo)
</code></pre>
<p>This is not entirely what you want though, since it will have a custom type, not an empty type.</p>
</div>
<span class="comment-copy">It's two lines of fairly self-evident code, I see no problem with repeating it. Even if you had to add a new <code>import</code> to obtain an existing <code>EmptyObject</code>, the net savings would be minor.</span>
<span class="comment-copy">You could even put it on one line, no?</span>
<span class="comment-copy">Have you considered <a href="http://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuple</a>? I have a sense you're reinventing a wheel.</span>
<span class="comment-copy">@kojiro What if OP wants to be able to add attributes dynamically, a la JavaScript objects?</span>
<span class="comment-copy">@2rs2ts so, like <a href="http://stackoverflow.com/a/2597440/418413">Bunch</a>. Which, personally, I think is a great way to generate problems.</span>
<span class="comment-copy">Unfortunately as I've said I use python2.7</span>
<span class="comment-copy">@maggot092 And as I have said, you can easily add the implementation to your Python 2 project and use it as if it was there…</span>
<span class="comment-copy">In this case as you have also said I don't see advantage comparing defining Emty class</span>
<span class="comment-copy">Well, the big advantage would be using a type that does exist in a future Python version, so using an equivalent type will definitely make your intention clear.</span>
<span class="comment-copy">The OP was concerned about having to repeat the trivial two lines in each script. Repeating these 9 lines in every script instead appears like a cure that is worse than the disease.</span>
<span class="comment-copy">Why the argument? You could just as well use <code>lambda: 0</code>. I'd not use it still though, as this makes it hard to figure out why you'd create the <code>lambda</code> in the first place.</span>
<span class="comment-copy">Mhh... While this is certainly interesting, I sure as hell wouldn't want to see this in production code.</span>
<span class="comment-copy">My upvote for originality, but I agree with Lukas Graf, this solution is not for production</span>
<span class="comment-copy">Cool - another reason to use argparse!</span>
<span class="comment-copy">Also, it will create a new type on every invocation, which is fairly expensive.</span>
