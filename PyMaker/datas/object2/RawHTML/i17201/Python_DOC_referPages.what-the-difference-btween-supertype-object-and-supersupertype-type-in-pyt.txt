<div class="post-text" itemprop="text">
<p>Won't <code>super(type, object)</code> and <code>super(supertype, type)</code> all return the object of super class of <code>type(supertype)</code>? What's the difference?</p>
</div>
<div class="post-text" itemprop="text">
<p>The difference is huge; <code>super()</code> with a type (class) second argument instead of an object (instance) gives you unbound methods, not bound methods (just like accessing those methods on a class would).</p>
<p>I'll explain first how <code>super()</code> works with an instance second argument.</p>
<p><code>super()</code> inspects the MRO of <code>self</code>, finds the first argument (<code>type</code> or <code>supertype</code>) in the MRO, then finds the next object that has the requested attribute.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class BaseClass(object):
...     def foo(self): return 'BaseClass foo'
... 
&gt;&gt;&gt; class Intermediary(BaseClass):
...     def foo(self): return 'Intermediary foo'
... 
&gt;&gt;&gt; class Derived(Intermediary):
...     def foo(self): return 'Derived foo'
... 
&gt;&gt;&gt; d = Derived()
&gt;&gt;&gt; d.foo()
'Derived foo'
&gt;&gt;&gt; super(Derived, d).foo
&lt;bound method Derived.foo of &lt;__main__.Derived object at 0x10ef4de90&gt;&gt;
&gt;&gt;&gt; super(Derived, d).foo()
'Intermediary foo'
&gt;&gt;&gt; super(Intermediary, d).foo()
'BaseClass foo'
&gt;&gt;&gt; Derived.__mro__
(&lt;class '__main__.Derived'&gt;, &lt;class '__main__.Intermediary'&gt;, &lt;class '__main__.BaseClass'&gt;, &lt;type 'object'&gt;)
</code></pre>
<p>The MRO of <code>Derived</code> is <code>(Derived, Intermediary, BaseClass)</code>; <code>super()</code> finds this MRO by looking at the second argument, using <code>type(d).__mro__</code>. The search for <code>foo</code> starts at the <em>next</em> class after the first argument given.</p>
<p>The <code>foo()</code> method is bound here, you can just call it.</p>
<p>If you give <code>super()</code> a <em>type</em> as the second argument, then it'll use the MRO of that type, e.g. instead of using <code>type(instance).__mro__</code> it just goes for <code>type.__mro__</code>. However it then has no instance to bind the methods to. <code>super(supertype, type).foo</code> is <strong>unbound</strong>:</p>
<pre><code>&gt;&gt;&gt; super(Intermediary, Derived).foo
&lt;unbound method Derived.foo&gt;
&gt;&gt;&gt; super(Intermediary, Derived).foo()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unbound method foo() must be called with Derived instance as first argument (got nothing instead)
&gt;&gt;&gt; super(Intermediary, Derived).foo(d)
'BaseClass foo'
</code></pre>
<p>To call <code>.foo()</code> I have to explicitly pass in a <code>self</code> argument.</p>
<p>(In Python 3, the above would return the <code>foo</code> function object instead of an unbound method, but the principle is the same).</p>
<p>The method returned is also, again, from the next class in the MRO chain; <code>BaseClass.foo</code> was returned there.</p>
<p>This is down to the <code>function.__get__</code> method (i.e. the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a>, responsible for binding), as it returns an unbound object (an unbound method in Python 2, the function itself in Python 3) when passed a class to bind to. (For <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>classmethod</code> objects</a>, <code>__get__</code> does return a bound object when passed in a class).</p>
<p>So, TL;DR, for methods <code>super(type, object)</code> returns a <em>bound</em> method, <code>super(supertype, type)</code> returns unbound methods. </p>
</div>
<span class="comment-copy">I believe you but I did not find any information about this on official documents.  Is there any official explain about this?</span>
<span class="comment-copy">@KramerLi: It's all covered in the <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super()</code> documentation</a>.</span>
<span class="comment-copy">@KramerLi: I recently 'ported' the implementation to Python to answer another question: <a href="//stackoverflow.com/a/44994572">What is the type of the super object returned by super()?</a>. Would that help in understanding?</span>
<span class="comment-copy">Thanks, your answer here already very clear.  The most important info to me from your answer is that "super() with a type (class) second argument instead of an object (instance) gives you unbound methods".  I think that this is a very important info that the python official documents should mention. But I really did not find this kind of information on the official documents(I also read the link you provided). So I am just wondering did I missed anything from the official doc ?</span>
<span class="comment-copy">@KramerLi: I perhaps put more emphasis on that than needed, but I do see the documentation is not as clear on that the same binding rules apply as normal instance and class attribute access.</span>
