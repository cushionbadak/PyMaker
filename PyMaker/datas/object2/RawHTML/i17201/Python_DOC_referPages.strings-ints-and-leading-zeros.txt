<div class="post-text" itemprop="text">
<p>I need to record SerialNumber(s) on an object. We enter many objects. Most serial numbers are strings - the numbers aren't used numerically, just as unique identifiers - but they are often sequential. Further, leading zeros are important due to unique id status of serial number.</p>
<p>When doing data entry, it's nice to just enter the first "sequential" serial number (eg 000123) and then the number of items (eg 5) to get the desired output - that way we can enter data in bulk see below:</p>
<pre><code>Obj1.serial = 000123
Obj2.serial = 000124
Obj3.serial = 000125
Obj4.serial = 000126
Obj5.serial = 000127
</code></pre>
<p>The problem is that when you take the first number-as-string, turn to integer and increment, you loose the leading zeros.</p>
<p>Not all serials are sequential - not all are even numbers (eg FDM-434\RRTASDVI908)</p>
<p>But those that are, I would like to automate entry. </p>
<p>In python, what is the most elegant way to check for leading zeros (*and, I guess, edge cases like 0009999) in a string before iterating, and then re-application of those zeros after increment?</p>
<p>I have a solution to this problem but it isn't elegant. In fact, it's the most boring and blunt alg possible.</p>
<p>Is there an elegant solution to this problem?</p>
<p>EDIT</p>
<p>To clarify the question, I want the serial to have the same number of digits <em>after</em> the increment. </p>
<p>So, in most cases, this will mean reapplying the same number of leading zeros. BUT in some edge cases the number of leading zeros will be decremented. eg: 009 -&gt; 010; 0099 -&gt; 0100</p>
</div>
<div class="post-text" itemprop="text">
<p>I develop my comment here, <code>Obj1.serial</code> being a string:</p>
<pre><code>Obj1.serial = "000123"

('%0'+str(len(Obj1.serial))+'d') % (1+int(Obj1.serial))
</code></pre>
<p>It's like @owen-s answer <code>'%06d' % n</code>: print the number and pad with leading 0.</p>
<p>Regarding <code>'%d' % n</code>, it's just <a href="https://stackoverflow.com/questions/6960442/difference-between-python-print-format-methods">one way of printing</a>. From <a href="http://docs.python.org/3/whatsnew/2.6.html#pep-3101" rel="nofollow noreferrer">PEP3101</a>: </p>
<blockquote>
<p>In Python 3.0, the % operator is supplemented by a more powerful
  string formatting method, format(). Support for the str.format()
  method has been backported to Python 2.6.</p>
</blockquote>
<p>So you may want to use format instead… Anyway, you have an integer at the right of the <code>%</code> sign, and it will replace the <code>%d</code> inside the left string.</p>
<p><code>'%06d'</code> means print a minimum of 6 (6) digits (d) long, fill with 0 (0) if necessary.</p>
<p>As <code>Obj1.serial</code> is a string, you have to convert it to an integer before the increment: <code>1+int(Obj1.serial)</code>. And because the right side takes an integer, we can leave it like that.</p>
<p>Now, for the left part, as we can't hard code 6, we have to take the length of <code>Obj1.serial</code>. But this is an integer, so we have to convert it back to a string, and concatenate to the rest of the expression <strong>%0</strong> 6 <strong>d</strong> : <code>'%0'+str(len(Obj1.serial))+'d'</code>. Thus</p>
<pre><code>('%0'+str(len(Obj1.serial))+'d') % (1+int(Obj1.serial))
</code></pre>
<p>Now, with format (<a href="http://docs.python.org/3/library/string.html#format-specification-mini-language" rel="nofollow noreferrer">format-specification</a>):</p>
<pre><code>'{0:06}'.format(n)
</code></pre>
<p>is replaced in the same way by </p>
<pre><code>('{0:0'+str(len(Obj1.serial))+'}').format(1+int(Obj1.serial))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try <a href="http://docs.python.org/2/library/stdtypes.html#str.zfill" rel="nofollow"><code>str.zfill()</code></a>:</p>
<pre><code>&gt;&gt;&gt; s = "000123"
&gt;&gt;&gt; i = int(s)
&gt;&gt;&gt; i
123
&gt;&gt;&gt; n = 6
&gt;&gt;&gt; str(i).zfill(n)
'000123'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could check the length of the string ahead of time, then use <code>rjust</code> to pad to the same length afterwards:</p>
<pre><code>&gt;&gt;&gt; s = "000123"
&gt;&gt;&gt; len_s = len(s)
&gt;&gt;&gt; i = int(s)
&gt;&gt;&gt; i
123
&gt;&gt;&gt; str(i).rjust(len_s, "0")
'000123'
</code></pre>
<p>You can check a serial number for all digits using:</p>
<pre><code>if serial.isdigit():
</code></pre>
</div>
<span class="comment-copy">Do you know the length of the field a priori? It sounds like you're trying to calculate it based on one serial number given. If you do know the length of the field you're trying to generate, say 6, then <code>'%06d' % n</code> is hard to beat for elegance.</span>
<span class="comment-copy">If you don't, <code>('%0'+str(len(ser))+'d')% (1+int(ser))</code> is still a oneliner…</span>
<span class="comment-copy">No, unfortunately the length of any particular serial or group of serials is variable.</span>
<span class="comment-copy">I like @fredtantini's answer here - I'll have to check it. Yep, I really like that answer. Can you break it down a little?</span>
<span class="comment-copy">To be fair, I worked it out on my own reading once I settled down - I still see klingon when I read a one liner. I really need to concentrate to break it down.</span>
<span class="comment-copy">Unfortunately, there is no set length for serial numbers. We run a warehouse of items from across the globe. Some serial numbers are 2 digits, some are 15. The field is a 40 char string.</span>
<span class="comment-copy">@datakid: <code>str(i).zfill(len(s))</code>, then.</span>
<span class="comment-copy">" then re-application of those zeros after increment?" I think that <code>009 + 1</code> won't be  <code>0010</code> but <code>010</code>. The increment could change the length of the leading 0…</span>
<span class="comment-copy">You are correct @fredtantini that's why I mentioned the edge cases</span>
<span class="comment-copy">@fredtantini this will keep the field the same length; modification will be required if the OP wants the same <i>number</i> of leading zeros.</span>
<span class="comment-copy">@jonrsharpe you are correct, and I was lazy in my explanation. Your answer is correct in so far as my question was poorly phrased, for which I apologise. My meaning was I wanted the same number of digits, with an appropriate number of leading zeros.</span>
<span class="comment-copy">@datakid no problem; I suggest you update the question with what you think should happen in your edge case, for clarity.</span>
