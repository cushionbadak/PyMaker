<div class="post-text" itemprop="text">
<p>In Python, I run an exe made using FORTRAN. I use the <code>subprocess</code> module. that exe accesses and writes to several files. If I make those files readonly, I see the following trace in my Python console.</p>
<p>I tried by using <code>try</code>, <code>except</code> statements. But I could not capture the error. I also tried using <code>p.stdout.readline()</code>. But was unsuccessful.</p>
<p>Is there a systematic way to capture this sort of errors.</p>
<p>Code:</p>
<pre><code>import subprocess
p = subprocess.Popen('C:\\TGSSR\\test.exe' , shell=True, stdout=subprocess.PIPE)
</code></pre>
<p>Traceback:</p>
<pre><code>forrtl: severe (9): permission to access file denied, unit 6, file C:\test\mar22_SSOUT\RawReadLog.dat

Image              PC        Routine            Line        Source             
test.exe           0116DC40  Unknown               Unknown  Unknown
test.exe           0113D42F  Unknown               Unknown  Unknown
test.exe           0112AE97  Unknown               Unknown  Unknown
test.exe           0112A1DA  Unknown               Unknown  Unknown
test.exe           0110D746  Unknown               Unknown  Unknown
test.exe           0108B9AC  Unknown               Unknown  Unknown
test.exe           01173FE3  Unknown               Unknown  Unknown
test.exe           011588F5  Unknown               Unknown  Unknown
kernel32.dll       76D33677  Unknown               Unknown  Unknown
ntdll.dll          77A39F42  Unknown               Unknown  Unknown
ntdll.dll          77A39F15  Unknown               Unknown  Unknown
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Run the process:</p>
<pre><code>p = subprocess.Popen(['C:\\TGSSR\\test.exe'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
# shell = True is not needed
</code></pre>
<p>To capture the error message:</p>
<pre><code>stdout, stderr = p.communicate()
# stdout = normal output
# stderr = error output
</code></pre>
<p>Check the process return code:</p>
<pre><code>if p.returncode != 0:
    # handle error
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If don't need all of Popen's functionality but just need to fetch stdout, you could also go for:</p>
<pre><code>try:
    output = subprocess.check_output('C:\\TGSSR\\test.exe')
except subprocess.CalledProcessError as e:
    print("Oops... returncode: " + e.returncode + ", output:\n" + e.output)
else:
    print("Everything ok:\n" + output)
</code></pre>
<p>EDIT: As mgilson pointed out in the other answer, this requires a non-zero returncode on failures. If that isn't the case, you could try something along the lines of:</p>
<pre><code>output = subprocess.check_output('C:\\TGSSR\\test.exe')
if "permission to access file denied" in output:
    print("Failed")
</code></pre>
<p>with some string that will only be on stdout in case of an error</p>
</div>
<span class="comment-copy">unrelated: to avoid escaping backslashes, you could use raw-string literals: <code>r'C:\TGSSR\test.exe'</code>. Don't use <code>shell=True</code> on Windows unless you use the shell functionality e.g., to call a builtin shell command such as <code>dir</code>. Don't use <code>stdout=PIPE</code> unless you read from <code>p.stdout</code> later</span>
<span class="comment-copy">Thank you for the comments!</span>
<span class="comment-copy">Sometimes errors are written outside stdout/stderr (directly to the terminal). See <a href="http://stackoverflow.com/q/22250893/4279">Capture “Segmentation fault” message for a crashed subprocess: no out and err after a call to communicate()</a></span>
<span class="comment-copy">While maybe not necessary on windows, if you're going to not use a shell, you should pass the executable as a list:  <code>['C:\\TGSSR\\test.ext']</code>.  Also, the returncode may not be reliable as (to my knowledge), there still isn't a good standardized way to set a process's return code in Fortran.</span>
<span class="comment-copy">in this case p is null in both states (successful or unsuccessful). So I'm unable to rely on that!</span>
<span class="comment-copy">@mgilson: <code>Popen("program")</code> works. It is equivalent to <code>Popen(["program"])</code> on POSIX. On Windows, a string  argument always works.</span>
<span class="comment-copy">@user3161836: <code>p</code> is not null; you might mean <code>p.returncode is None</code>. The latter means that the process is not complete yet. You should check <code>p.returncode</code> <i>after</i> <code>p.communicate()</code> returns (it waits for the process to finish)</span>
<span class="comment-copy">yes that works! thank you for the clarifications!</span>
<span class="comment-copy">it should be <code>subprocess.CalledProcessError</code> in this case</span>
<span class="comment-copy">you're right, I fixed it now</span>
<span class="comment-copy">This works for me.if I just need to run the exe, I think I can go for this option. Am I going to mis any major functionality if I go this way?</span>
<span class="comment-copy">That was probably badly worded, check_output is a convenience function based on Popen which doesn't require handling stdout/stderr yourself (in your first post, you would actually need at least a p.communicate() in order to prevent the stdout pipe buffer from completely filling if you FORTRAN tool outputs a lot which would effectively stall execution). You can however easily switch to Popen. Popen gives more fine-grained control of process creation: <a href="http://docs.python.org/3/library/subprocess.html#popen-constructor" rel="nofollow noreferrer">link</a></span>
