<div class="post-text" itemprop="text">
<p>I am experimenting with the use of <code>multiprocessing</code> module in <code>python</code>. I have the below sample code which executes without any errors in an ipython notebook. But I see that there are additional python processes spawned in the background with each execution of the code block in the notebook. </p>
<pre><code>import multiprocessing as mp

def f(x):
    print "Hello World ", mp.current_process()
    return 1

pool = mp.Pool(3)

data = range(0,10)
pool.map(f, data)
</code></pre>
<p>Whereas when i save the same in a normal .py file and execute, I encounter errors and have to terminate the terminal to stop the program from execution. </p>
<p>I have corrected this by having <code>if __name__ == '__main__':</code> and the creation of pool under this and also using <code>pool.close()</code> to close the pool. </p>
<p>I am curious to know what best practices should one follow when using <code>multiprocessing</code> and the associated functions such as <code>map</code>, <code>apply</code>, <code>apply_async</code> etc? I plan to use this module for reading files in parallel and hopefully apply it to few ML algorithms to speed up the process.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason you have to put it in <code>if __name__</code> ... is because when python spawns a new process, it effectively imports this module - thus trying to run any code not in the <code>if __name__</code> block again and again.</p>
<p>Best practice is to keep things in sensibly named, small, testable functions.  Have a 'main()' function, which you then call from your <code>if __name__</code> block.</p>
<p>Avoid global state (and module level variables).  It just makes things complicated.  Instead, think of passing things to and from your processes.  This can be slow, so thinking first about how to send as little data as possible is useful.  For instance, if you have a large config object, rather than send the whole config object to each process, split your process functions into only requiring the one or two attributes that they actually use, and just send those.</p>
<p>It's a lot easier to test things when it happens serially, so writing things in such a way that it's easy to make it happen sequentially rather than using <code>map</code> or whatever can make it easier.</p>
<p>It's a good idea to profile things, as the whole spawning new process can sometimes end up being slower than doing things all in one thread.  The gevent module is pretty cool too - if your program is network bound, then gevent can sometimes be a lot quicker at doing things in parallel than using multiprocessing.</p>
</div>
<div class="post-text" itemprop="text">
<p>The python docs mentioned are good - check out <a href="https://stackoverflow.com/questions/17172878/using-pythons-multiprocessing-process-class">Using Python's multiprocessing.Process class</a>. That question has some similar ideas. I would also recommend checking out <a href="https://www.ibm.com/developerworks/aix/library/au-multiprocessing/" rel="nofollow noreferrer">https://www.ibm.com/developerworks/aix/library/au-multiprocessing/</a>. It is in python and highlights some nice pythonic approaches to multiprocessing. </p>
</div>
<div class="post-text" itemprop="text">
<p>The official Python documentation has lots of usage examples. It's probably the best way to learn best practices: <a href="http://docs.python.org/2/library/multiprocessing.html" rel="nofollow">http://docs.python.org/2/library/multiprocessing.html</a></p>
</div>
<span class="comment-copy">there are <a href="http://docs.python.org/3/library/multiprocessing.html#programming-guidelines" rel="nofollow noreferrer">programming guidelines in the docs</a></span>
