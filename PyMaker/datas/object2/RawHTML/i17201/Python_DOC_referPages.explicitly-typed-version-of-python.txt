<div class="post-text" itemprop="text">
<p>I rather like Python's syntactic sugar; and standard library functions.</p>
<p>However the one feature which I dislike; is implicit typing.</p>
<p>Is there a distribution of Python with explicit typing; which is still compatible with e.g.: packages on PyPi?</p>
<p>[I was looking into RPython]</p>
</div>
<div class="post-text" itemprop="text">
<p>The short answer is no.  What you are asking for is deeply built into Python, and can't be changed without changing the language so drastically that is wouldn't be Python.</p>
<p>I'm assuming you don't like variables that are re-typed when re-assigned to? You might consider other ways to check for this if this is a problem with your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>From python 3, the ability to use type annotation was introduced into the python standard with <a href="https://www.python.org/dev/peps/pep-3107/" rel="nofollow noreferrer"><strong>PEP 3017</strong></a>. Fast-forward to python 3.5 and <strong><a href="https://www.python.org/dev/peps/pep-0484/" rel="nofollow noreferrer">PEP 0484</a></strong> builds on this to introduce type hinting along with the <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">typing</a> module which enables one to specify the types for a variable or the return type of a function.</p>
<pre><code>from typing import Iterator

def fib(n: int) -&gt; Iterator[int]:
    a, b = 0, 1
    while a &lt; n:
        yield a
        a, b = b, a + b
</code></pre>
<p>Above example taken from <a href="https://pawelmhm.github.io/python/static/typing/type/annotations/2016/01/23/typing-python3.html" rel="nofollow noreferrer"><strong>https://pawelmhm.github.io</strong></a></p>
<p><strong>According to the 484 notes:</strong></p>
<blockquote>
<p>While these annotations are available at runtime through the usual
  __annotations__ attribute, <em>no type checking happens at runtime</em>. Instead, the proposal assumes the existence of a separate off-line
  type checker which users can run over their source code voluntarily.
  Essentially, such a type checker acts as a very powerful linter.
  (While it would of course be possible for individual users to employ a
  similar checker at run time for Design By Contract enforcement or JIT
  optimization, those tools are not yet as mature.)</p>
</blockquote>
<p>What this implies is that although python provides this means of "static typing", it is not enforced at run time i.e. when you run your program, python simply ignores any type specifications you have provided and continues to use duck typing to infer types. Therefore, it is up to you to find a lint checker of sorts which you can run your program through to detect any issues with the types.</p>
<p>The motivation for including typing in the python standard was mostly influenced by <a href="http://mypy-lang.org/examples.html" rel="nofollow noreferrer">mypy</a>, so it might be worth checking them out. They also provide <a href="http://mypy-lang.org/examples.html" rel="nofollow noreferrer">examples</a> which may prove useful.</p>
</div>
<div class="post-text" itemprop="text">
<p>No You can not have cake and eat cake.</p>
<p>Python is great because its dynamically typed! Period. (That's why it have such nice standard library too)</p>
<p>There is only 2 advantages of statically typed languages 1) speed - when algorithms are right to begin with and 2) compilation errors</p>
<p>As for 1)</p>
<ul>
<li>Use PyPi, </li>
<li>Profile,</li>
<li>Use ctype libs for great performance. </li>
</ul>
<p>Its typical to have only 10% or less code that is performance critical. All that other 90%? Enjoy advantages of dynamic typing.</p>
<p>As for 2)</p>
<ul>
<li>Use Classes (And contracts)</li>
<li>Use Unit Testing</li>
<li>Use refactoring</li>
<li>Use good code editor</li>
</ul>
<p>Its typical to have data NOT FITTING into standard data types, which are too strict or too loose in what they allow to be stored in them. Make sure that You validate Your data on Your own. </p>
<p>Unit Testing is must have for algorithm testing, which no compiler can do for You, and should catch any problems arising from wrong data types (and unlike compiler they are as fine grained as you need them to be)</p>
<p>Refactoring solves all those issues when You are not sure if given changes wont break Your code (and again, strongly typed data can not guarantee that either).</p>
<p>And good code editor can solve so many problems... Use Sublime Text for a while. And then You will know what I mean.</p>
<p>(To be sure, I do not give You answer You want to have. But rather I question Your needs, especially those that You did not included in Your question)</p>
</div>
<div class="post-text" itemprop="text">
<p><em>Since comments are limited...</em></p>
<p>As an interpreted language Python is by definition weakly typed. This is not a bad thing more as a control in place for the programmer to preempt potential syntactical bugs, but in truth that won't stop logical bugs from happening any less, and thus makes the point moot.</p>
<p>Even though the <a href="http://www.disi.unige.it/person/AnconaD/papers/Recent_abstracts.html#AACM-DLS07" rel="nofollow">paper on RPython</a> makes it's point, it is focused on Object Oriented Programming. You must bear in mind that Python is more an amalgamation of OOP and Functional Programming, likely others too.</p>
<p>I encourage <a href="https://wiki.python.org/moin/StrongVsWeakTyping" rel="nofollow">reading of this page</a>, it is very informative.</p>
</div>
<span class="comment-copy">Perhaps you mean "dynamically typed"?  You might want to read <a href="https://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language" rel="nofollow noreferrer">wiki.python.org/moin/â€¦</a>.  What you are asking for is not Python and would break much existing code.</span>
<span class="comment-copy">Python <i>isn't</i> weakly typed. <code>1 + '2'</code> will <code>raise TypeError</code>. It is strongly but dynamically typed.</span>
<span class="comment-copy">Thx. Clarified.</span>
<span class="comment-copy">@przemo_li: Explicit typing allows for higher optimised compilers; but my main reason for wanting this; is that I find myself comments what type to give my functions. Then I have unittests which [in some cases] check the types.</span>
<span class="comment-copy">Documenting functions + doc string testing, then? Or better. Unit testing on algorithms and whole function. Cause if it work, who cares what the data type is? (Python explicitly allow for contracts, that is Python care if Object have given function, not if it have proper type)</span>
<span class="comment-copy">@przemo_li: Yeah; that's what I currently have. But it should be more a compile-time language-level feature; which it isn't. One could write a Python-[like] compiler that does this checking; but I do not know of one which exists (thus this question)</span>
<span class="comment-copy">I don't understand the downvote on this.</span>
<span class="comment-copy">By most definitions, Python is <i>not</i> weakly typed.  It is both strongly typed and dynamically typed.  Read through the comments on the page cited.  Read the Wikipedia entry: <a href="http://en.wikipedia.org/wiki/Python_(programming_language)" rel="nofollow noreferrer">en.wikipedia.org/wiki/Python_(programming_language)</a></span>
<span class="comment-copy">"As an interpreted language Python is by definition weakly typed" - what do you mean? Java is (in the standard implementation) interpreted in much the same way as Python, yet it's statically typed.</span>
<span class="comment-copy">I don't know what definition of <code>interpreter language</code> you have in mind, but in my book there is no relation between the type system and whether a language is interpreted or not at all. An interpreter merely executes the program right away instead of translating it to a different language (like a compiler does). For example, Haskell is a statically typed language and yet there are interpreters (e.g. <code>runhaskell</code> or <code>ghci</code>) which execute code as you type it.</span>
