<div class="post-text" itemprop="text">
<p>Consider the following code, why don't I need to pass x to Y?</p>
<pre><code>class X:    
    def __init__(self):
        self.a = 1
        self.b = 2
        self.c = 3

class Y:        
    def A(self):
        print(x.a,x.b,x.c)

x = X()
y = Y()
y.A()
</code></pre>
<hr/>
<p>Thank you to the top answers, they really helped me see what was the problem, namely misunderstanding regarding variable scope.  I wish I could choose both as correct answer as they are enlightening in their own way.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow">The Python Tutorial</a>:</p>
<blockquote>
<p>Although scopes are determined statically, they are used dynamically.
  At any time during execution, there are at least three nested scopes
  whose namespaces are directly accessible:</p>
<ul>
<li>the innermost scope, which is searched first, contains the local names</li>
<li>the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contains non-local, but also</li>
<li>non-global names the next-to-last scope contains the current moduleâ€™s</li>
<li>global names the outermost scope (searched last) is the namespace containing built-in names</li>
</ul>
</blockquote>
<p>In your case <code>x=X()</code> puts <code>x</code> into the global namespace.  Since you did not define <code>x</code> locally in <code>Y.A</code>  (innermost scope), python searches for the variable definition using the above rules and finds that 'x' is defined in the outermost scope.  Therefore when you reference <code>x.a</code> in <code>Y.A</code> it resolves just fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>When python compiles a <code>def</code> into a function, it tries to figure out if the things you are referencing are locals - and if they're not, you must be referring to a global.  For example:</p>
<pre><code>def f():
    print(x)
</code></pre>
<p>Well, you haven't defined <code>x</code> within the scope of <code>f</code>, so you must be referring to a global.</p>
<p>This is all that's happening in your above code.  You haven't defined <code>x</code> within the scope of <code>A</code>, so <code>x</code> must be a global.  As it happens, you define the global:</p>
<pre><code>x = X()
</code></pre>
<p>before you call it:</p>
<pre><code>y = Y()
y.A()
</code></pre>
<p>so everything works out okay.</p>
<p>In case you are going "hm, I'm not sure if I believe you, roippi" just look at the bytecode:</p>
<pre><code>dis.dis(Y.A)
  3           0 LOAD_GLOBAL              0 (print) 
              3 LOAD_GLOBAL              1 (x) # aha
              6 LOAD_ATTR                2 (a) 
              9 LOAD_GLOBAL              1 (x) # aha!
             12 LOAD_ATTR                3 (b) 
             15 LOAD_GLOBAL              1 (x) # aha!!
             18 LOAD_ATTR                4 (c) 
             21 CALL_FUNCTION            3 (3 positional, 0 keyword pair) 
             24 POP_TOP              
             25 LOAD_CONST               0 (None) 
             28 RETURN_VALUE     
</code></pre>
<p>aha.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's because you've instantiated x=X(), so that x.a, x.b, and x.c can be accessed. If you try z=X(), you'll notice it doesn't work.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python looks up variables by first looking in the local scope (i.e. within a function) and if does not find it, it will use the variable from the global scope, if it exists. After that it will look for Python built-in names. </p>
<p>When the statement <code>y = Y()</code> is reached, <code>x</code> has already been declared in the global scope. This means that when the function <code>A(self)</code> is called, <code>x</code> can be looked up in the global scope.</p>
<p>More information about variable scope can be found here: <a href="https://stackoverflow.com/questions/291978/short-description-of-python-scoping-rules">Short Description of the Scoping Rules?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It takes it from current scope. If you remove <code>x = X()</code> it will throw a error.</p>
<p>You can use variables from current scope and variable from all parent scopes inside a function.</p>
<pre><code>def A():
   a = 1

   def B():
       b = 2

       def C():
          c= 3
          print(a,b,c)
</code></pre>
<p>For details on how scope is defined check python language reference on <a href="http://docs.python.org/3/reference/executionmodel.html#naming-and-binding" rel="nofollow">Naming and Binding</a></p>
<p>Also, since you are not changing x it works just fine. But if you would've try to change variable from parent scope it would throw error:</p>
<pre><code>g= 0
def A():
   a = 1
   g = 2 #throws error
   def B():
       b = 2

       def C():
          c= 3
          print(a,b,c,d)
</code></pre>
<p>In such case you need to use <code>global</code> keyword:</p>
<pre><code>g= 0
def A():
   a = 1

   global g
   g = 2 #does not throw error

   print(a,g)


A()
</code></pre>
</div>
