<div class="post-text" itemprop="text">
<p>Docs:</p>
<blockquote>
<p>With three arguments, return a new type object. This is essentially a dynamic form of the class statement. The <em>name</em> string is the class name and becomes the <code>__name__</code> attribute; the <em>bases</em> tuple itemizes the base classes and becomes the <code>__bases__</code> attribute; and the <em>dict</em> dictionary is the namespace containing definitions for class body and becomes the <code>__dict__</code> attribute.</p>
</blockquote>
<p>While learning Python I have come across this use of type as "a dynamic form of the class statement", this seems very interesting and useful and I wish to understand it better.  Can someone clearly explain the role of <code>__name__</code>, <code>__bases__</code>, and <code>__dict__</code> in a class and also give example where <code>type(name, bases, dict)</code> comes into its own right.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you define a class:</p>
<pre><code>class Foo(Base1, Base2):
    bar = 'baz'

    def spam(self):
         return 'ham'
</code></pre>
<p>Python essentially does this:</p>
<pre><code>def spam(self):
    return 'ham'
body = {'bar': 'baz', 'spam': spam}

Foo = type('Foo', (Base1, Base2), body)
</code></pre>
<p>where <code>Foo</code> is then added to the namespace the <code>class</code> statement was defined in.</p>
<p>The block under the <code>class</code> statement is executed as if it was a function with no arguments and the resulting local namespace (a dictionary) forms the class body; in this case a dictionary with <code>'bar'</code> and <code>'spam'</code> keys is formed.</p>
<p>You can achieve the same result by passing a name string, a tuple of base classes and a dictionary with string keys to the <code>type()</code> function.</p>
<p>Once you start exploring metaclasses as well (which are essentially subclasses of <code>type()</code>
, letting you customize how classes are created), you'll find that <code>body</code> doesn't <em>have</em> to be a plain dictionary. <a href="http://www.python.org/dev/peps/pep-3115/" rel="nofollow">PEP 3115 - Metaclasses in Python 3</a> expanded the possible values to anything <em>dict like</em>, letting you implement all sorts of interesting class behaviour by letting you use augmented dictionaries for the class body. The new <a href="http://docs.python.org/3/library/enum.html" rel="nofollow">Python 3.4 <code>enum</code> module</a> for example, uses an <a href="http://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>OrderedDict()</code> instance</a> instead, to preserve attribute ordering.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__name__</code> is a string containing the name of the class.<br/>
<code>__bases__</code> is a tuple of classes from which the current class derives.<br/>
<code>__dict__</code> is a dictionary of all methods and fields defined in the class.  </p>
<p>The use case for <code>type(name, bases, dict)</code> is when you want to dynamically generate classes at runtime.<br/>
Just imagine that you want to create ORM for a database and you want all the classes representing database tables to be generated automatically. You have an idea how these classes should behave but you don't know their names, their fields until you inspect the database schema. Then you can use this function to generate these classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just like </p>
<pre><code>a = Foo()
</code></pre>
<p>creates an instance of <code>Foo</code> and assigns it to <code>a</code>,</p>
<pre><code>Foo = type('Foo', (object,), {})
</code></pre>
<p>creates an instance of <code>type</code> and assigns it to <code>Foo</code>. Not only does this allow you to create classes dynamically (similar to, but not as restricted as, using <code>lambda</code> to create a function), but it lets you (correctly) think of <code>type</code> not as a function, but as a type itself. An instance of <code>type</code> is a class object. <code>type.__new__</code> creates the object, <code>type.__init__</code> initializes it, <code>type.__call__</code> lets you use the class as a callable object (which in turn is how <code>Foo()</code> creates and initializes instances of <code>Foo</code>).</p>
<p>Understanding <code>type</code> is how you understand metaclasses. When you don't specify a metaclass, Python uses <code>type</code> to create the class, as if you had written (in Python 2.x)</p>
<pre><code>class Foo(object):
    __metaclass__ = type
</code></pre>
<p>Just like you can subclass ordinary classes, you can subclass <code>type</code> to create your <em>own</em> metaclass!</p>
<pre><code>class mymetaclass(type):
    def __new__(cls, name, bases, dict):
        print "Creating a subclass of {0} named {1}".format(name, bases)
        print "{0} will have the following attributes:".format(name)
        for key in dict:
            print " * {0}".format(key)

# This class statement is (roughly) identical to:
#
# def foo_init(self, x):
#    self.y = x
#
# Foo = mymetaclass('Foo', (object,), { 'a': 3, '__init__': foo_init })
# (The class statement will also ensure that `__module__` and `__metaclass__`
# are in the dict passed to mymetaclass.__new__.)
class Foo(object):
    __metaclass__ = mymetaclass
    a = 3
    def __init__(self, x):
        self.y = x
</code></pre>
<p>If you run the above, you'll see output that is generate as the <code>class</code> statement is executed, because <code>mymetaclass.__new__</code> is executed when the <code>class</code> statement is executed.</p>
</div>
<span class="comment-copy">I know the point is being simple rather than accurate and hide the gory implementation details, but perhaps you could add a <code>del spam, body</code> as a last line in your example</span>
<span class="comment-copy">@MestreLion: perhaps a different sentence added would help? <i>Where <code>Foo</code> is then added to your namespace</i> rather than imply that <code>spam</code> and <code>body</code> were ever added anywhere.</span>
<span class="comment-copy">Yes, that would be much better than my suggestion, and an improvement to your already great answer :)</span>
