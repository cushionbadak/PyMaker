<div class="post-text" itemprop="text">
<p>I want to get the only Non-None element from this list:</p>
<pre><code>L = [None, [None,None], [None, &lt;__main__.Car object at 0x02A11550&gt;], [None, None, None], None]
</code></pre>
<p>I've tried</p>
<pre><code>L = [x for x in L if x is not None]
</code></pre>
<p>But the result is</p>
<pre><code>[[None, None], [None, &lt;__main__.Car object at 0x02A11550&gt;], [None, None, None]]
</code></pre>
<p>Deleting only the None that are not inside of any list. 
Is there any way to clean the whole list? so the output is</p>
<pre><code>&lt;__main__.Car object at 0x02A11550&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def flatten(lst):
    for element in lst:
        if hasattr(element,"__iter__"):
            yield from flatten(element)
        elif not element is None:
            yield element

new_list = flatten(L)
</code></pre>
<p>I'll break this down for you, first starting with generators. The <code>yield</code> keyword is sister to <code>return</code>, but with much different functionality. Both are used to bring values out of a function into its calling scope, but <code>yield</code> allows you to jump back into the function afterwards! As an example, below is a generator that accepts a list full of numbers and produces the square for each number in the list.</p>
<pre><code>def example_generator(number_list):
    for number in number_list:
        yield number**2

&gt;&gt;&gt; gen = example_generator([1,2,3])
&gt;&gt;&gt; type(gen)
&lt;class 'generator'&gt;
&gt;&gt;&gt; next(gen) # next() is used to get the next value from an iterator
1
&gt;&gt;&gt; next(gen)
4
&gt;&gt;&gt; next(gen)
9
&gt;&gt;&gt; next(gen)
Traceback (most recent call last):
  File "&lt;pyshell#6&gt;", line 1, in &lt;module&gt;
    next(gen)
StopIteration
</code></pre>
<p>Generators are one-time use, however. As you can see, after I reached the end of the generator, it threw an exception <code>StopIteration</code>. If I built it again and ran through it with a loop, then tried to run through it AGAIN...</p>
<pre><code>&gt;&gt;&gt; gen = example_generator([1,2,3]) # remember this is a new generator, we JUST made it
&gt;&gt;&gt; for item in gen:
...     print(item)
1
4
9
&gt;&gt;&gt; for item in gen:
...     print(item)
&gt;&gt;&gt;
</code></pre>
<p>It doesn't do anything the second time. The generator is exhausted. That's the downside -- the upside is that it's generally much faster and more memory-efficient to use generators instead of lists.</p>
<p><code>yield</code> also allows you to use another keyword: <code>from</code>. That's what I did there in case of a nested list (<code>hasattr(element,"__iter__")</code> just means that the element has an attribute <code>.__iter__</code>, which means it can be iterated upon using something like a <code>for</code> loop). You give <code>yield from</code> another generator, and it yields each element from THAT generator in turn. For example:</p>
<pre><code>def flatten_lite(lst):
    for element in lst:
        if type(element) is list: # more readable, IMO
            yield from flatten_lite(element)
        else:
            yield element

a = flatten_lite([1,2,3,[4,5,6,[7],8],9])
</code></pre>
<p>Here's what it does in turn:</p>
<pre><code>for element in [1,2,3,[4,5,6,[7],8],9]:
    # element == 1
    if element is of type list: # it's not, skip this
    else: yield element # which is 1
    :: NEXT ITERATION ::
    # element == 2, same as before
    :: NEXT ITERATION ::
    # element == 3, same as before
    :: NEXT ITERATION ::
    # element == [4,5,6,[7],8]
    if element is of type list: # it is!!
        yield from flatten_lite([4,5,6,[7],8])
        :: STOP EXECUTION UNTIL WE GET A VALUE FROM THAT NEW GENERATOR ::
&gt;&gt;&gt; NEW GENERATOR
for element in [4,5,6,[7],8]:
    # element is 4
    yield 4
        :: THE OUTER GENERATOR YIELDS 4 ::
    :: NEXT ITERATION ::
    # element is 5
    yield 5
        :: THE OUTER GENERATOR YIELDS 4 ::
    :: NEXT ITERATION ::
    # element is 6
    yield 6
        :: THE OUTER GENERATOR YIELDS 4 ::
    :: NEXT ITERATION ::
    # element is [7]
    if element is of type list # [7] is a list!
        yield from flatten_lite([7])
            :: STOP EXECUTION UNTIL WE GET A VALUE FROM THAT NEW GENERATOR ::
            # etc etc
</code></pre>
<p>So basically the code above says (in pseudocode):</p>
<pre><code>flatten is a function that accepts parameter: lst
    for each element in lst:
        if element can be iterated on:
            yield every element in turn from the generator created
              by this function called on the element instead of the
              main list
        if it's not, and isn't None:
            yield element
</code></pre>
<p>When you call it, it builds a generator that can be iterated upon. To make it into a formal list, you'll have to do <code>list(flatten(L))</code>, but in most cases you don't need that.</p>
<p>Is that any clearer?</p>
</div>
<div class="post-text" itemprop="text">
<p>Another slightly more modular approach:</p>
<pre><code>def flatten(l):
    """ http://stackoverflow.com/questions/2158395/flatten-an-irregular-list-of-lists-in-python/2158532#2158532 """
    for el in l:
        if isinstance(el, collections.Iterable) and not isinstance(el, basestring):
            for sub in flatten(el):
                yield sub
        else:
            yield el

filter(None,flatten(L)) #wrap with `list` in python 3.x
</code></pre>
<p>A generic <code>flatten</code> function is something you should keep in your toolbox, since (so far) it's not something you can find in the standard library, and it comes up occasionally.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just for fun, how about:</p>
<pre><code>from itertools import chain, ifilterfalse
result = list(ifilterfalse(lambda x: x is None, chain(*[x for x in L if x is not None])))
</code></pre>
<p>This will return a <code>list</code> with only the <code>Car</code> element present. It will generalize to return a <code>list</code> with any non-<code>None</code> element.</p>
<p>In Python 3.x I think you swap <code>ifilterfalse</code> for <code>filterfalse</code> and it works the same.</p>
<p><code>chain()</code> is designed to flatten a <code>list</code> of <code>list</code>s for iteration. <code>ifilterfalse</code> can work directly on the <code>chain</code> returned. <code>ifilterfalse</code> gets rid of elements that match the predicate specified by the <code>lambda</code> function. </p>
<p>Note that if you have strings in <code>L</code>, <code>chain()</code> will essentially break the strings up into individual elements. If that is a problem for you, see this other <a href="https://stackoverflow.com/questions/5286541/how-can-i-flatten-lists-without-splitting-strings">SO post</a>.</p>
<p>Another implementation which avoids the problem of non-iterables at the base level:</p>
<pre><code>result = list(ifilterfalse(lambda x: x is None, chain(*[x if hasattr(x, '__iter__') else [x] for x in L if x is not None])))
</code></pre>
<p>I'm told this may not work in Python 3 because of how <code>str</code> is implemented there. Anyway I'm only posting these ideas so that you are aware of functionality already available in the Python standard library under <code>itertools</code>. Have fun learning Python!</p>
</div>
<span class="comment-copy">You need to be careful witht his. A <code>str</code> instance has an <code>__iter__</code> method (in Python 3), but you don't want to try recursively flattening it.</span>
<span class="comment-copy">The code works perfectly, but I'm new to python and i don't really understand how it does it, is there any way to make the same thing by using comprehension lists or recursive functions?</span>
<span class="comment-copy">@user3440055 yeah gimme a few and I'll help out.</span>
<span class="comment-copy">@Blckknght a great point! I could maybe use <code>isinstance(element,list)</code> but would miss out on TONS of iterables I want to flatten. Conversely I feel like <code>if hasattr(element,"__iter__") and not isinstance(element,str)</code> includes other string-like objects that can be iterated upon but are not sequences. Is there a superclass for all sequences that should be "flatten-able?"</span>
<span class="comment-copy"><code>yield from iterable</code> <a href="http://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow noreferrer">only works in Python 3.3 and above</a>. See <a href="http://legacy.python.org/dev/peps/pep-0380/" rel="nofollow noreferrer">PEP-380</a> for details.</span>
<span class="comment-copy">If the nested list can contain strings, this will be worse than adsmith's answer, since it will infinitely recurse in both Python 2 and Python 3.</span>
<span class="comment-copy">@Blckknght you're right, I tried to do this one from memory.  The above is the one I have sitting on my HD.  I'm sure I've pulled it from another stackoverflow answer, I'll attribute it.</span>
<span class="comment-copy">I think this will blow up if there's a non-None element at the top level (that is, if you have <code>[None, &lt;Car object at ...&gt;, [None, None]]</code> or similar. I don't know if that's a plausible situation for the questioner, but it could be.</span>
<span class="comment-copy">Ahh yes, you're right. But I'm also not sure if that's plausible for the OP. My assumption was that <code>None</code> appears at the top level because there's no <code>list</code>, otherwise there's a <code>list</code> that may contain <code>None</code> or <code>Car</code> objects. I basically posted to point out <code>itertools</code> functionality, and the other SO post.</span>
