<div class="post-text" itemprop="text">
<p>I have a lists:</p>
<pre><code>nums = [1, 2, 3, 1, 5, 2, 7, 11]
</code></pre>
<p>I am trying to make a function that returns how many times each number appears in the lists. Output may look like:</p>
<pre><code>1 occurred 2 times
2 occurred 2 times
3 occurred 1 time
5 occurred 1 time
...
...
</code></pre>
<p>This is what I have tried so far:<br/>
-Create dictionary for each element in list<br/>
-Have nested loop go through every element and check it against every other element<br/>
-If elements match add one to the dictionary key of that element</p>
<p>The problem:<br/>
Everytime it loops through, it redetects the same elements. Therefore however many of a certain element there is, instead of being added by 1, it is raised by the n power</p>
<pre><code>Enter integers between 1 and 100: 5 2 41 4 5 2 2 4
4 occurs 4 times
2 occurs 9 times
41 occurs 1 times
5 occurs 4 times
</code></pre>
<p>code:</p>
<pre><code>def main():
    original_nums = input("Enter integers between 1 and 100: ")
    nums = [i for i in original_nums.split()]
    my_dict = {}

    for i in nums:
        my_dict[i] = 0

    for i in nums:
        for j in nums:
            if i == j:
                my_dict[i] += 1

    for i in my_dict:
        print(i,"occurs",my_dict[i],"times")



if __name__ == "__main__":
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow">Counter</a> is all you need</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; Counter([1, 2, 3, 1, 5, 2, 7, 11])
Counter({1: 2, 2: 2, 3: 1, 5: 1, 7: 1, 11: 1})
</code></pre>
<p><strong>Or</strong> you can just fix your code like this</p>
<pre><code>def main():
    original_nums = input("Enter integers between 1 and 100: ")
    nums = [i for i in original_nums.split()]
    my_dict = {}

    for i in nums:
        my_dict[i] = my_dict.get(i, 0) + 1
        # or .setdefault(i, 0) instead of .get(i, 0)
        # setdefault is generally faster

    for i in my_dict:
        print(i, 'occurs', my_dict[i], 'times')

if __name__ == '__main__':
    main()
</code></pre>
<p>Runtime:</p>
<pre><code>Enter integers between 1 and 100: 5 5 5 5 1 2 3 3 3 
1 occurs 1 times
2 occurs 1 times
3 occurs 3 times
5 occurs 4 times
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use a <a href="http://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a>, which essentially does what you're trying to do internally:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; 
&gt;&gt;&gt; nums = [1, 2, 3, 1, 5, 2, 7, 11]
&gt;&gt;&gt; 
&gt;&gt;&gt; counts = Counter(nums)
&gt;&gt;&gt; 
&gt;&gt;&gt; for t in counts.iteritems():
...     print '%d occured %d times' % t
... 
1 occured 2 times
2 occured 2 times
3 occured 1 times
5 occured 1 times
7 occured 1 times
11 occured 1 times
</code></pre>
</div>
<span class="comment-copy">Problem with counter is I can't use the sorted function with it, without turning it into a lists</span>
<span class="comment-copy">@chopperdrawlion4 maybe you want to use <a href="http://docs.python.org/3/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">Counter is probably better here. Anyway, the two <code>for i in nums:</code> can be replaced by one with the body <code>my_dic[i] = my_dic.get(i, 0) + 1</code>. The <code>.get</code> returns the value at the key <code>i</code> or the default (here zero).</span>
<span class="comment-copy">@pepr you're right, updated</span>
<span class="comment-copy">The big difference between <code>dict.get</code> and <code>dict.setdefault</code> is that <code>.get</code> does not modify the dictionary. Say, you want to implement a sparse lookup table. The <code>.setdefault</code>, on the other hand, is better when you want to assign mutable object and you want to keep the same instance when modified later -- say <code>dict.setdefaut(k, []).append(value)</code>.</span>
