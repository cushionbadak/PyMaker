<div class="post-text" itemprop="text">
<p>I have produced code to randomly generate random strength and skill values for a character in a game, the code is as follows;</p>
<pre><code>import random
input('Character name 1 ')

print ('Stamina of Character 1  =', (((random.randrange(1,12)//(((random.randrange(1,4)))))))+10)
print ('Strength of Character 1 =', (((random.randrange(1,12)//(((random.randrange(1,4)))))))+10)
input('Character name 2 ')

print ('Stamina of Character 2 =', (((random.randrange(1,12)//(((random.randrange(1,4)))))))+10)
print ('Strength Character 2 =', (((random.randrange(1,12)//(((random.randrange(1,4)))))))+10)
</code></pre>
<p>The code works but I need to be able to save the results of the program to a .txt file that can be opened by the player to see and the strength and skill are saved under the entered characters name. So is there anyway to save what the program prints to the text file or do I have to do something else? All help is appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can write text to files very easily. Have a look at <a href="http://docs.python.org/3.3/tutorial/inputoutput.html#reading-and-writing-files" rel="nofollow">http://docs.python.org/3.3/tutorial/inputoutput.html#reading-and-writing-files</a></p>
<p>Instead of printing to the standard output, you can write to the text file like this:</p>
<pre class="lang-py prettyprint-override"><code>with open('characters.txt', 'w') as f:
    name1 = input('Character name 1:')
    f.write("Character name 1: " + name1)
    stamina = random.randrange(1,12) // (random.randrange(1,4) + 10)
    # stamina is a integer, but we need to write it as a string
    f.write("Stamina of Character 1 = " + str(stamina))

    name2 = input('Character name 2:')
    #Â etc ...
</code></pre>
<p>However, there are many possible improvements to this code. I'll try to explain some of them.</p>
<p>If you're saving the same information for every character, there is no need to write the code more than once. Consider using a function for this:</p>
<pre class="lang-py prettyprint-override"><code>def save_character_stats(f, n=1):
    name = input("Character name {0}: ")
    stamina = random.randrange(1,12) // (random.randrange(1,4) + 10)
    strength = random.randrange(1,12) // (random.randrange(1,4) + 10)
    f.write("Character name {0}: {1}".format(n, name))
    f.write("Stamina: {0}".format(stamina))
    f.write("Strength: {0}".format(strength))
    f.write("\n")


with open('characters.txt', 'w') as f:
    for i in range(2):
        save_character_stats(f, i)
</code></pre>
<p>You don't actually need to write to the file as you compute the values. It's usually clearer if you have one function that provides them, and another that writes to the file:</p>
<pre class="lang-py prettyprint-override"><code>def new_character_stats():

    def random_value():
        return random.randrange(1,12) // (random.randrange(1,4) + 10)

    return {
        'stamina': random_value()
        'strength': random_value()
    }

def save_character_stats(characters=3):
    with open('characters.txt', 'w') as f:
        for i in range(characters):
            name = input("Character name {0}: ".format(i))
            stats = new_character_stats()
            f.write("Character name {0}: {1}".format(n, name))
            f.write("Stamina: {0}".format(stats['stamina']))
            f.write("Strength: {0}".format(stats['strength']))
            f.write("\n")
</code></pre>
<p>Note that in order to have the code that provides the value just once, we've used an additional function.</p>
<p>Other improvements you could look into are</p>
<ul>
<li>writing the content with a simple template. Look for string formatting in the documentation.</li>
<li>using meaningful variable names for the random formula (not usually a good idea to have magic numbers floating around!)</li>
<li>saving the information as a more machine-readable format. Look for the json module in the documentation.</li>
</ul>
<p>Good luck!</p>
</div>
<div class="post-text" itemprop="text">
<p>I would creagte a csv file using csv.DictWriter with the header row containing the appropriate column names. That is 'Name', 'Stamina', 'Strength'. Alternatively, if you want to save exactly what you print, create a long string. and do open, write, close. I have to run now but will expand this later</p>
<p>You should create variables and use them for the print and write. You can use a loop to determine the names and other characteristics. Note that I did not use the with open formulation in order to allow setting up a function and to allow for other processing and writing before the close. If you want to automatically close the file at the end use the </p>
<pre><code>with open('file.txt', 'ab') as f:
</code></pre>
<p>method. This will close the file as soon as you exit the scope (as shown by the indentation)</p>
<pre><code>import random

f = open('file.txt', 'ab')
name = input('Character name: ')
while name != 'done':
    stamina = (((random.randrange(1,12)//(((random.randrange(1,4)))))))+10)
    strength = (((random.randrange(1,12)//(((random.randrange(1,4)))))))+10)
    outline = 'name = ' + name + 'stamina = ' + stamina + 'strength = ' + strength
    print outline
    f.write(outline+'\n')
    name = input('Character name: ')
f.close()
</code></pre>
<p>The 'ab' will create the file if it does not yet exist or append to an already existing file.</p>
<p>For a csv file, you would use</p>
<pre><code>import random

import csv
ofile = open('file.txt', 'ab')
outfields = ['Name', Stamina', Strength]
outfile = csv.DictWriter(ofile, fieldnames=outfields)
outfile.writerow(dict((fn, fn) for fn in outfields))
name = input('Character name: ')
row = {}
while name != 'done':
    row['Name'] = name
    stamina = (((random.randrange(1,12)//(((random.randrange(1,4)))))))+10)
    strength = (((random.randrange(1,12)//(((random.randrange(1,4)))))))+10)
    row['Strength] = strength
    row['Stamina'] = stamina
    print row
    outfile.writerow(row)
    name = input('Character name: ')
ofile.close()
</code></pre>
<p>Of course, you would have to create a python program to read the csv file and process it rather than having the user just bring up the text file in an editor using csv.DictReader. However, this could be part of the game.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answers posted all require you to manually open files and choose to write to them at the same time as printing to the file you want. If you just want to be able to print things to both a file and standard output at the same time, use Python's <a href="http://docs.python.org/3/library/logging.html" rel="nofollow">logging</a> module.</p>
<pre class="lang-python prettyprint-override"><code>import logging
import sys

logging.basicConfig(filename='logfile.txt', filemode='w', level=logging.DEBUG,
        format='%(message)s')

logger = logging.getLogger()
stdout = logging.StreamHandler(stream=sys.stdout)
logger.addHandler(stdout)

logger.info('This is a logged message. It will appear at both the screen'
        + ' and in the logfile.')
</code></pre>
<p>Then when you run this, at the console you will see:</p>
<pre class="lang-none prettyprint-override"><code>$ python3 logger.py
This is a logged message. It will appear at both the screen and in the logfile.
</code></pre>
<p>The output is printed to the screen, but it also goes in a logfile:</p>
<pre class="lang-none prettyprint-override"><code>$ cat logfile.txt 
This is a logged message. It will appear at both the screen and in the logfile.
</code></pre>
<p>Loggers allow you to do much more than just this, but they work for the basics as well. If you need more help, see the <a href="http://docs.python.org/3/howto/logging.html#logging-basic-tutorial" rel="nofollow">basic logging tutorial</a>.</p>
</div>
<span class="comment-copy">Rather than directly print it, assign the result to a name e.g. <code>stamina = ...</code> which you can then save to a file and/or print out. Also, as you do the same thing four times, consider making a function to produce the scores. You could also slim down the parentheses a touch...</span>
