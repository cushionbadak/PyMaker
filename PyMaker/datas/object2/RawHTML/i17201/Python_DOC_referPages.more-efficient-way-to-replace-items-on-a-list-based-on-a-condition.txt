<div class="post-text" itemprop="text">
<p>I have the following piece of code. Basically, I'm trying to replace a word if it matches one of these regex patterns. If the word matches even once, the word should be completely gone from the new list. The code below works, however, I'm wondering if there's a way to implement this so that I can indefinitely add more patterns to the 'pat' list without having to write additional if statements within the for loop. </p>
<p>To clarify, my regex patterns have negative lookaheads and lookbehinds to make sure it's one word. </p>
<pre><code>pat = [r'(?&lt;![a-z][ ])Pacific(?![ ])', r'(?&lt;![a-z][ ])Global(?![ ])']

if isinstance(x, list):
    new = []
    for i in x:
        if re.search(pat[0], i):
            i = re.sub(pat[0], '', i)
        if re.search(pat[1], i):
            i = re.sub(pat[1], '', i)
        if len(i) &gt; 0:
            new.append(i)
    x = new 
else:
    x = x.strip()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just add another <code>for</code> loop:</p>
<pre><code>for patn in pat:
    if re.search(patn, i):
        i  = re.sub(patn, '', i)
if i:
    new.append(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>pat = [r'(?&lt;![a-z][ ])Pacific(?![ ])', r'(?&lt;![a-z][ ])Global(?![ ])']

if isinstance(x, list):
    new = []
    for i in x:
        for p in pat:
            i = re.sub(p, '', i)
        if len(i) &gt; 0:
            new.append(i)
    x = new 
else:
    x = x.strip()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Add another loop:</p>
<pre><code>pat = [r'(?&lt;![a-z][ ])Pacific(?![ ])', r'(?&lt;![a-z][ ])Global(?![ ])']

if isinstance(x, list):
    new = []
    for i in x:
        # iterate through pat list
        for regx in pat:
            if re.search(regx, i):
                i = re.sub(regx, '', i)
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If in your pattern, then changes are only the words, then you can add the words joined with <code>|</code> to make it or. So for your two patterns from the example will become one like below one.</p>
<pre><code>r'(?&lt;![a-z][ ])(?:Pacific|Global)(?![ ])'
</code></pre>
<p>If you need to add more words, just add with a pipe. For example <code>(?:word1|word2|word3)</code></p>
<p>Inside the bracket <code>?:</code> means do not capture the group.</p>
</div>
<div class="post-text" itemprop="text">
<p>something like this:</p>
<pre><code>[word for word in l if not any(re.search(p, word) for p in pat)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I will attempt a guess here; if I am wrong, please skip to the "this is how I'd write it" and modify the code that I provide, according to what you intend to do (which I may have failed to understand).</p>
<p>I am assuming you are trying to eliminate the words "Global" and "Pacific" in a list of phrases that may contain them.
If that is the case, I think your regular expression does not do what you specify.  You probably intended to have something like the following (which does not work as-is!):</p>
<pre><code>pat = [r'(?&lt;=[a-z][ ])Pacific(?=[ ])', r'(?&lt;=[a-z][ ])Global(?=[ ])']
</code></pre>
<p>The difference is in the look-ahead patterns, which are positive (<code>(?=...)</code> and <code>(?&lt;=...)</code>) instead of negative (<code>(?!...)</code> and <code>(?&lt;!...)</code>).</p>
<p>Furthermore, writing your regular expressions like this will not always correctly eliminate white space between your words.</p>
<p><strong>This is how I'd write it:</strong></p>
<pre><code>words = ['Pacific', 'Global']
pat = "|".join(r'\b' + word + r'\b\s*' for word in words)
if isinstance(x, str):
    x = x.strip()        # I don't understand why you don't sub here, anyway!
else:
    x = [s for s in (re.sub(pat, '', s) for s in x) if s != '']
</code></pre>
<p>In the regular expression for patterns, notice (a) <code>\b</code>, standing for "the empty string, but only at the beginning or end of a word" (see the <a href="http://docs.python.org/3/library/re.html" rel="nofollow">manual</a>), (b) the use of <code>|</code> for separating alternative patterns, and (c) <code>\s</code>, standing for "characters considered whitespace".  The latter is what takes care of correctly removing unnecessary space after each eliminated word.</p>
<p>This works correctly in both Python 2 and Python 3.  I think the code is much clearer and, in terms of efficiency, it's best if you leave <code>re</code> to do its work instead of testing each pattern separately.</p>
<p>Given:</p>
<pre><code>x = ["from Global a to Pacific b",
     "Global Pacific",
     "Pacific Global",
     "none",
     "only Global and that's it"]
</code></pre>
<p>this produces:</p>
<pre><code>x = ['from a to b', 'none', "only and that's it"]
</code></pre>
</div>
<span class="comment-copy">for one, you should just do <code>re.sub</code> and skip the <code>re.search</code> step.  If <code>sub</code> can't find a match it won't sub anything.</span>
<span class="comment-copy">you might want to consider compiling your patterns.</span>
<span class="comment-copy">noob question: why does it matter if you compile your patterns or not?</span>
<span class="comment-copy">I think that your negative lookaheads and lookbehinds are wrong, as I explain in my answer.  <code>(?&lt;![a-z][ ])</code> means that the string must not follow a letter-space combination, e.g. "and Pacific" will not match.</span>
<span class="comment-copy">hm... I don't want 'and Pacific' to match. I only want it to match if it's 'Pacific'.</span>
<span class="comment-copy">this answer makes complete sense. i don't know why i kept thinking i needed to append the new word immediately. thanks.</span>
<span class="comment-copy">naming your loop variable <code>re</code> is going to end badly.</span>
<span class="comment-copy">hahaha my bad :D</span>
<span class="comment-copy">Hm, this is a solution that works really easily with the existing code. thanks</span>
<span class="comment-copy">Hm. I keep getting: TypeError: 'NoneType' object is not iterable</span>
<span class="comment-copy">well, there are two things that are being iterated over: l and pat. so one of them is <code>None</code></span>
<span class="comment-copy">unless, somehow, re.search is doing some iteration, but idk.</span>
<span class="comment-copy">This is really useful. thanks! i upvoted your answer. One thing: could you break this list comprehension apart? x = [s for s in (re.sub(pat, '', s) for s in x) if s != '']I don't understand how the for loops work</span>
<span class="comment-copy">It's a nested comprehension: <code>re.sub(pat, '', s) for s in x</code> generates the list of all substitutions and <code>[s for s in (that) if s != '']</code> filters out the empty ones.  You could have written it with a call to <code>filter</code>, if you prefer: <code>filter(lambda s: s != '', [re.sub(pat, '', s) for s in x])</code>.</span>
<span class="comment-copy">great, thanks so much!</span>
