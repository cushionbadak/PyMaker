<div class="post-text" itemprop="text">
<p>I have a string like this:</p>
<pre><code>&lt;foo&gt;&lt;bar&gt;&lt;k2&gt;&lt;v1&gt;aaa&lt;b&gt;bbb&lt;/b&gt;ccc&lt;/v1&gt;&lt;/k2&gt;&lt;/bar&gt;&lt;foo&gt;
</code></pre>
<p>I would like to strip the first 3 opening <em>and</em> the last 3 closing tags from the string. I do not know the tag names in advance.</p>
<p>I can strip the first 3 strings with <code>re.sub(r'&lt;[^&lt;&gt;]+&gt;', '', in_str, 3))</code>. How do I strip the closing tags? What should remain is:</p>
<pre><code>&lt;v1&gt;aaa&lt;b&gt;bbb&lt;/b&gt;ccc&lt;/v1&gt;
</code></pre>
<p>I know I could maybe 'do it right', but I actually do not wish to do xml nor html parsing for my purpose, which is to aid myself visualizing the xml representation of some classes. </p>
<p>Instead, I realized that this problem is interesting. It seems I <a href="https://stackoverflow.com/questions/2355293">cannot</a> simply search backwards with regex, ie. <em>right to left</em>. because that seems <a href="https://mail.python.org/pipermail/tutor/2007-September/057148.html" rel="nofollow noreferrer">unsupported</a>:</p>
<blockquote>
<p>If you  mean, find the right-most match of several (similar to the
  rfind method of a string) then no, it is not directly supported. You
  could use re.findall() and chose the last match but if the matches can
  overlap this may not give the correct result.</p>
</blockquote>
<p>But <code>.rstrip</code> is not good with words, and won't do patterns either.</p>
<p>I looked at <a href="https://stackoverflow.com/questions/753052/strip-html-from-strings-in-python">Strip HTML from strings in Python</a> but I only wish to strip up to <em>3</em> tags.</p>
<p>What approach could be used here? Should I reverse the string (ugly in itself and due to the '&lt;&gt;'s). Do tokenization (why not parse, then?)? Or create static closing tags based on the left-to-right match?</p>
<p>Which strategy to follow to strip the patterns from the end of the string?</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest would be to use old-fashing string splitting and limiting the split:</p>
<pre><code>in_str.split('&gt;', 3)[-1].rsplit('&lt;', 3)[0]
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; in_str = '&lt;foo&gt;&lt;bar&gt;&lt;k2&gt;&lt;v1&gt;aaa&lt;b&gt;bbb&lt;/b&gt;ccc&lt;/v1&gt;&lt;/k2&gt;&lt;/bar&gt;&lt;foo&gt;'
&gt;&gt;&gt; in_str.split('&gt;', 3)[-1].rsplit('&lt;', 3)[0]
'&lt;v1&gt;aaa&lt;b&gt;bbb&lt;/b&gt;ccc&lt;/v1&gt;'
</code></pre>
<p><a href="http://docs.python.org/2/library/stdtypes.html#str.split" rel="nofollow"><code>str.split()</code></a> and <a href="http://docs.python.org/2/library/stdtypes.html#str.rsplit" rel="nofollow"><code>str.rsplit()</code></a> with a limit will split the string from the start or the end up to the limit times, letting you select the remainder unsplit.</p>
</div>
<div class="post-text" itemprop="text">
<p>You've already got practically all the solution. <code>re</code> can't do backwards, but you can:</p>
<pre><code>in_str = '&lt;foo&gt;&lt;bar&gt;&lt;k2&gt;&lt;v1&gt;aaa&lt;b&gt;bbb&lt;/b&gt;ccc&lt;/v1&gt;&lt;/k2&gt;&lt;/bar&gt;&lt;/foo&gt;'
in_str = re.sub(r'&lt;[^&lt;&gt;]+&gt;', '', in_str, 3)
in_str = in_str[::-1]
print in_str
in_str = re.sub(r'&gt;[^&lt;&gt;]+/&lt;', '', in_str, 3)
in_str = in_str[::-1]

print in_str
&lt;v1&gt;aaa&lt;b&gt;bbb&lt;/b&gt;ccc&lt;/v1&gt;
</code></pre>
<p>Note the reversed regex for the reversed string, but then it goes back-to-front.</p>
<p>Of course, as mentioned, this is way easier with a proper parser:</p>
<pre><code>in_str = '&lt;foo&gt;&lt;bar&gt;&lt;k2&gt;&lt;v1&gt;aaa&lt;b&gt;bbb&lt;/b&gt;ccc&lt;/v1&gt;&lt;/k2&gt;&lt;/bar&gt;&lt;/foo&gt;'
from lxml.html import etree
ix = etree.fromstring(in_str)
print etree.tostring(ix[0][0][0])
&lt;v1&gt;aaa&lt;b&gt;bbb&lt;/b&gt;ccc&lt;/v1&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would look into regular expressions and use one such pattern to use a split</p>
<p><a href="http://docs.python.org/3/library/re.html?highlight=regex#re.regex.split" rel="nofollow">http://docs.python.org/3/library/re.html?highlight=regex#re.regex.split</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Sorry, can't comment, but will give it as an answer.</p>
<p><code>in_str.split('&gt;', 3)[-1].rsplit('&lt;', 3)[0]</code> will work for the given example 
<code>&lt;foo&gt;&lt;bar&gt;&lt;k2&gt;&lt;v1&gt;aaa&lt;b&gt;bbb&lt;/b&gt;ccc&lt;/v1&gt;&lt;/k2&gt;&lt;/bar&gt;&lt;/foo&gt;</code>, but not for 
<code>&lt;foo&gt;&lt;bar&gt;&lt;k2&gt;&lt;v1&gt;aaa&lt;b&gt;bbb&lt;/b&gt;ccc&lt;/v1&gt;&lt;/k2&gt;&lt;/bar&gt;&lt;/foo&gt;&lt;another&gt;test&lt;/another&gt;</code>. 
You just should be aware of this.</p>
<p>To solve the counter example provided by me, you will have to track state (or count) of tags and evaluate that you match the correct pairs.</p>
</div>
<span class="comment-copy">But parsing <i>is</i> the right answer to this problem. Why don't you want to do it?</span>
<span class="comment-copy">@DanielRoseman because it is too heavy-weight for <i>this</i> task. This is temporary visualization which will be thrown away. Parsing will do but it's like using a sledgehammer to crack a nut.</span>
<span class="comment-copy">Haha! Gotcha, seems I couldn't see the wood for the trees.</span>
<span class="comment-copy">yeah, this is definitely the best solution for this particular problem.</span>
<span class="comment-copy">+1 Nice back-pattern and the notation for the string reversing. It will solve reverse-matching. Still, for this specific case, Martijn's <a href="http://stackoverflow.com/a/22478982/611007">answer</a> beats it with the simplicity. I think adding the elementTree example makes this the best complementary reference answer.</span>
<span class="comment-copy">hm, yeah, maybe I could split based on the pattern for the last 3 tags.</span>
<span class="comment-copy">yes, thanks! <code>&lt;another&gt;test&lt;/another&gt;</code> is not my case. In my case the format is as in my example. It would constitute just a common corner case to something for what the general answer is indeed parsing. However I was mainly interested in the right-to-left string manipulation aspect.</span>
