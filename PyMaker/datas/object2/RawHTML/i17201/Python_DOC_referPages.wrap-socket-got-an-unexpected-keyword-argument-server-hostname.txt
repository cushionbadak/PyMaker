<div class="post-text" itemprop="text">
<p>I'm trying to use Python to test a web server. I have nearly no experience with Python, but encouraged to use it because its easy to learn and simple to do things with (someone else's opinion, not mine at the moment). The script I am using is:</p>
<pre><code>s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s2 = ssl.wrap_socket(s1,
                     ca_certs="./pki/signing-dss-cert.pem",
                     cert_reqs=ssl.CERT_REQUIRED,
                     ssl_version=ssl.PROTOCOL_TLSv1,
                     server_hostname="localhost")

s2.connect( ("localhost", 8443) )

s2.send("GET / ")
time.sleep(1)
s2.send("HTTP/1.1")
</code></pre>
<p>The error is:</p>
<pre><code>Traceback (most recent call last):
  File "./fetch.sh", line 10, in &lt;module&gt;
    server_hostname="localhost")
TypeError: wrap_socket() got an unexpected keyword argument 'server_hostname'
</code></pre>
<p>I've also tried using <code>servername</code>, <code>name</code>, <code>hostname</code> and <code>sni</code> with no joy.</p>
<p>The Python docs don't mention SNI (<a href="http://docs.python.org/3/library/ssl.html" rel="nofollow">TLS/SSL wrapper for socket objects</a> and <a href="https://wiki.python.org/moin/SSL" rel="nofollow">SSL wiki page</a>). But I know the patch for SNI and <code>server_hostname</code> was incorporated 4 years ago in 2010 (<a href="http://hg.python.org/cpython/rev/846c0e1342d0/" rel="nofollow">Add a *server_hostname* argument to <code>SSLContext.wrap_socket</code></a>, <a href="http://hg.python.org/cpython/rev/846c0e1342d0/" rel="nofollow">changeset 65593:846c0e1342d0</a>).</p>
<p>The equivalent OpenSSL call I need access to is <code>SSL_set_tlsext_host_name</code>.</p>
<p>How do I specify the SNI hostname? (Eventually, I'll need to set it to an arbitrary name because I am testing a proxy).</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://hg.python.org/cpython/rev/846c0e1342d0/" rel="nofollow">patch you're mentioning</a> is for Python 3.2, and you're using Python 2.7. <a href="http://bugs.python.org/issue5639" rel="nofollow">Issue 5639</a> also seems to indicate there is no plan to back-port SNI support for Python 2.7.</p>
<p>You could wrap the socket with pyOpenSSL instead (its <code>Connection</code> class has a <a href="http://pythonhosted.org//pyOpenSSL/api/ssl.html#OpenSSL.SSL.Connection.set_tlsext_host_name" rel="nofollow"><code>set_tlsext_host_name</code></a> since version 0.13. (I'm not sure which version comes with Debian 7.3, you might want to set up a virtualenv and upgrade to a newer version locally, if needed.)</p>
<p>There is an <a href="https://github.com/pyca/pyopenssl/blob/master/examples/sni/client.py" rel="nofollow">SNI example</a> is the pyOpenSSL repository.</p>
<p>If you want your usage of <code>wrap_socket</code> to be more compatible with the trick were you replace the value of <code>sock</code> in an <code>httplib</code> connection, you could have a look at how <a href="https://github.com/shazow/urllib3/blob/master/urllib3/contrib/pyopenssl.py" rel="nofollow">urllib3 does this with pyOpenSSL</a>. Essentially, it creates an <code>OpenSSL.SSL.Connection</code> from an existing socket, but since that connection isn't compatible with a socket, it wraps it into a class that implements the required method.</p>
<p>(By the way, in Python 2.7, <code>urllib</code>, <code>urllib2</code> and <code>httpconnection</code> don't do any certificate verification at all, unless you implement it yourself by wrapping their sockets.)</p>
<p><em>EDIT:</em></p>
<p>Here is a version of your code that should work with Python 3.2. Unfortunately, the <code>server_name</code> parameter isn't in the plain <code>ssl.wrap_socket</code>, only in <code>SSLContext.wrap_socket</code>, but you can use <code>SSLSocket</code> directly.</p>
<pre><code>import socket
import ssl

CA_BUNDLE_FILE="/etc/ssl/certs/ca-certificates.crt"


HOST = "sni.velox.ch"
s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s2 = ssl.SSLSocket(sock=s1, ca_certs=CA_BUNDLE_FILE,
                     cert_reqs=ssl.CERT_REQUIRED,
                     ssl_version=ssl.PROTOCOL_TLSv1,
                     server_hostname=HOST)

s2.connect((HOST, 443))

s2.send(bytes("GET / HTTP/1.1\n", "UTF-8"))
# This might need to be modified when using another port
s2.send(bytes("Host: %s\n" % (HOST,), "UTF-8"))
s2.send(bytes("\n", "UTF-8"))

# Certainly not the best way to read the response, but it works.
while True:
    x = s2.read()
    if not x:
        break
    print(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First connect, then wrap the socket.</p>
<pre><code>import socket, ssl
sock = socket.create_connection( ('localhost', 443) )
sock = ssl.wrap_socket(sock, ca_certs="./pki/signing-dss-cert.pem", cert_reqs=ssl.CERT_REQUIRED, ssl_version=ssl.PROTOCOL_TLSv1)
</code></pre>
<p>In case of python2 I also use the following hack sometimes (because the <code>httplib.HTTPSConnection</code> documentation says that it doesn't perform any kind of checking on the https server cert):</p>
<pre><code>import urllib, httplib, ssl

PATH = urllib.quote(u'/'.encode('utf-8'))
conn = httplib.HTTPConnection('www.google.com', 443)
conn.connect()
try:
    conn.sock = ssl.wrap_socket(conn.sock, cert_reqs=ssl.CERT_REQUIRED, ca_certs=CA_BUNDLE_FILE, ssl_version=VERSION)
    conn.request('GET', PATH)
    resp = conn.getresponse()
    print resp.status
    print resp.read()
finally:
    conn.close()
</code></pre>
<p>Note that if you want to communicate with the server then using a http client is often much easier than playing around with raw sockets.</p>
</div>
<div class="post-text" itemprop="text">
<p>My env is:requests==2.7.0, python-2.7.5-34.el7.x86_64, gevent==1.0.2</p>
<p>Change python version to python-2.7.5-18.el7_1.1.x86_64, problem is solved.</p>
<p>on CentOS:</p>
<pre><code>sudo rpm -Uvh --oldpackage python-devel-2.7.5-18.el7_1.1.x86_64.rpm  python-libs-2.7.5-18.el7_1.1.x86_64.rpm  python-2.7.5-18.el7_1.1.x86_64.rpm
</code></pre>
<p>pakages can search on google.</p>
</div>
<span class="comment-copy">Try to merge my code with yours and try to use the servername instead of <code>"localhost"</code> when you create the connection.</span>
<span class="comment-copy">Which version of Python are you using?</span>
<span class="comment-copy"><code>sys.version_info(major=2, minor=7, micro=3, releaselevel='final', serial=0)</code>. Debian 7.3 (x64), fully patched.</span>
<span class="comment-copy">Thanks Bruno. "If you want your usage of wrap_socket to be more compatible..." - I just want it to work. I wasted about 4 hours on it today because it was supposed to be easier and faster. I think I'm going back to C/C++. C/C++ development is faster for me than trying to unravel everything you said above. And I'm befuddled the latest Debian is using an old, unpatched library. There's a reason I use the latest distros, and its not because I enjoy cutting edge bugs.</span>
<span class="comment-copy">I wouldn't judge Python on this. If you're new to Python and don't have any 2.x legacy code, you could try a Python 3.2+ interpreter. It should be callable using <code>python3.2</code> provided you've installed the package for it.</span>
<span class="comment-copy">Thanks again Bruno. This worked once I downloaded, built and installed Python 3.4.</span>
<span class="comment-copy">Strange you had to get Python 3.4 and build it yourself. I got that to work on a Debian system simply by installing the <code>python3</code> package (and using <code>python3.2</code>). (Just in case you weren't aware of it, on Debian/Ubuntu, Python versions can be installed together (except micro-level number) via normal packages. By default <code>python</code> is still the most recent 2.x interpreter, but you can call the <code>python3.x</code> interpreter explicitly.)</span>
<span class="comment-copy">@noloader I'm afraid this simple ssl implementation does not expose such option.</span>
<span class="comment-copy">Thanks pasztorpisti. the code was changed, but the error persists.</span>
<span class="comment-copy">@noloader I do not see my code anywhere in your post so I'm not surprised that it doesn't work.</span>
<span class="comment-copy">Thanks pasztorpisti. Forgive my ignorance here... It appears the code above does not set the servername, which is what I am trying to accomplish. In the context of your example, imagine you want to connect to <code>google.com</code> but set the TLS servername extension to <code>example.com</code> for testing.</span>
<span class="comment-copy">By the way, I was using code from the Python wiki at <a href="https://wiki.python.org/moin/SSL" rel="nofollow noreferrer">wiki.python.org/moin/SSL</a>.</span>
