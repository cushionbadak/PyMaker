<div class="post-text" itemprop="text">
<p>Im trying to do things concurrently in my program and to throttle the number of processes opened at the same time (10).</p>
<pre><code>from multiprocessing import Process
from threading import BoundedSemaphore

semaphore = BoundedSemaphore(10)
for x in xrange(100000):
  semaphore.acquire(blocking=True)
  print 'new'
  p = Process(target=f, args=(x,))
  p.start()

def f(x):
  ...  # do some work
  semaphore.release()
  print 'done'
</code></pre>
<p>The first 10 processes are launched and they end correctly (I see 10 "new" and "done" on the console), and then nothing. I don't see another "new", the program just hangs there (and Ctrl-C doesn't work either). What's wrong ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is the use of <code>threading.BoundedSemaphore</code> across process boundaries:</p>
<pre><code>import threading
import multiprocessing
import time

semaphore = threading.BoundedSemaphore(10)


def f(x):
  semaphore.release()
  print('done')


semaphore.acquire(blocking=True)
print('new')
print(semaphore._value)
p = multiprocessing.Process(target=f, args=(100,))
p.start()
time.sleep(3)
print(semaphore._value)
</code></pre>
<p>When you create a new process, the child gets a copy of the parent process's memory. Thus the child is decrementing it's semaphore, and the semaphore in the parent is untouched. (Typically, processes are isolated from each other: it takes some extra work to communicate across processes; this is what <code>multiprocessing</code> is for.)</p>
<p>This is opposed to threads, where the two threads share the memory space, and are considered the same process.</p>
<p><code>multiprocessing.BoundedSemaphore</code> is probably what you want. (If you replace <code>threading.BoundedSemaphore</code> with it, and replace <code>semaphore._value</code> with semaphore.get_value()`, you'll see the above's output change.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Your bounded semaphore is not shared properly between the various processes which are being spawned; you might want to switch to using <a href="http://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">multiprocessing.BoundedSemaphore</a>. See the answers to <a href="https://stackoverflow.com/questions/936933/boundedsemaphore-hangs-in-threads-on-keyboardinterrupt">this question</a> for some more details.</p>
</div>
<span class="comment-copy">Why not just use <code>multiprocessing.Pool</code>?</span>
<span class="comment-copy">What makes you think <code>threading.BoundedSemaphore</code>'s <code>release</code> will be seen across process boundaries?</span>
<span class="comment-copy">@Thanatos semaphore is a global object and acquire is supposed to be blocking as said in the doc ; am I missing something ?</span>
<span class="comment-copy">@g.d.d.c Noted, I tried it and Im pretty happy with it, but I am still interested to know why this doesn't work</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/936933/boundedsemaphore-hangs-in-threads-on-keyboardinterrupt">BoundedSemaphore hangs in threads on KeyboardInterrupt</a></span>
<span class="comment-copy">I saw this question which seemed different in the first place. Now with the answer I see that he used <code>threading.</code> instead of <code>multiprocessing.</code> too which is why he asked the question</span>
