<div class="post-text" itemprop="text">
<p>I am working on a class which operates in a multithreaded environment, and looks something like this (with excess noise removed):</p>
<pre><code>class B:

    @classmethod
    def apply(cls, item):
        cls.do_thing(item)

    @classmethod
    def do_thing(cls, item)
        'do something to item'

    def run(self):
        pool = multiprocessing.Pool()
        for list_of_items in self.data_groups:
            pool.map(list_of_items, self.apply)
</code></pre>
<p>My concern is that two threads might call <code>apply</code> or <code>do_thing</code> at the same time, or that a subclass might try to do something stupid with <code>cls</code> in one of these functions.  I could use <code>staticmethod</code> instead of <code>classmethod</code>, but calling <code>do_thing</code> would become a lot more complicated, especially if a subclass reimplements one of these but not the other.  So my question is this:  Is the above class thread-safe, or is there a potential problem with using classmethods like that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Whether a method is thread safe or not depends on what the method does.</p>
<p>Working with local variables only is thread safe. But when you change the same non local variable from different threads, it becomes unsafe.</p>
<p><code>‘do something to item’</code> seems to modify only the given object, which is independent from any other object in the list, so it should be thread safe.</p>
<p>If the same object is in the list several times, you may have to think about making the object thread safe. That can be done by using <code>with self.object_scope_lock:</code> in every method which modifies the object.</p>
<p>Anyway, what you are doing here is using processes instead of threads. In this case the objects are pickled and send through a pipe to the other process, where they are modified and send back. In contrast to threads processes do not share memory. So I don’t think using a lock in the class-method would have an effect.</p>
<p><a href="http://docs.python.org/3/library/threading.html?highlight=threading#module-threading" rel="nofollow">http://docs.python.org/3/library/threading.html?highlight=threading#module-threading</a></p>
</div>
<div class="post-text" itemprop="text">
<p>There's no difference between classmethods and regular functions (and instance methods) in this regard.  Neither is automagically thread-safe.</p>
<p>If one or more classmethods/methods/functions can manipulate data structures simultaneously from different threads, you'd need to add synchronization protection, typically using <code>threading.Lock</code>s.</p>
</div>
<div class="post-text" itemprop="text">
<p>Both other answers are technically correct in that the safety of <code>do_thing()</code> depends on what happens inside the function. </p>
<p>But the more precise answer is that <em>the call itself</em> is safe. In other words if <code>apply()</code>and <code>do_thing()</code>are a <a href="https://en.wikipedia.org/wiki/Pure_function" rel="nofollow noreferrer">pure functions</a>, then your code is safe. Any unsafe-ness would be due to them not being pure functions (e.g. relying on or affecting a shared variable during execution)</p>
<p>As shx2 mentioned, classmethods are only "in" a class visually, for grouping. They have no inherent attachment to any instance of the class. Therefore this code is roughly equivalent in functioning:
</p>
<pre><code>def apply(item):
    do_thing(item)

def do_thing(item)
    'do something to item'

class B:
    def run(self):
        pool = multiprocessing.Pool()
        for list_of_items in self.data_groups:
            pool.map(list_of_items, apply)
</code></pre>
<p>A further note on concurrency given the other answers:</p>
<ol>
<li><code>threading.Lock</code> is easy to understand, but should be your last resort. In naive implementations it is often slower than completely linear processing. Your code will usually be faster if you can use things like <code>threading.Event</code>, <code>queue.Queue</code>, or <code>multiprocessing.Pipe</code> to transfer information instead.</li>
<li><code>asyncio</code> is the new hotness in python3. It's a bit more difficult to get right but is generally the fastest method. </li>
<li>If you want a great walkthrough modern concurrency techniques in python check out core developer <a href="https://www.youtube.com/watch?v=9zinZmE3Ogk" rel="nofollow noreferrer">Raymond Hettinger's Keynote on Concurrency</a>. The whole thing is great, but the downside of <code>lock</code>is highlighted starting at t=<a href="https://youtu.be/9zinZmE3Ogk?t=57m59s" rel="nofollow noreferrer">57:59</a>.</li>
</ol>
</div>
<span class="comment-copy">Thanks for the answer. So then would simply calling <code>cls.do_thing</code> dangerous without a lock? Intuitively I don't think so but I dont have much experience with multithreading.</span>
<span class="comment-copy">that depends on the <code>thing</code> <code>do_thing()</code> does...</span>
