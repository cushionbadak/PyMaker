<div class="post-text" itemprop="text">
<p>I have a python script named <code>sudoserver.py</code> that I start in a <strong>CygWin</strong> shell by doing:</p>
<pre><code>python sudoserver.py
</code></pre>
<p>I am planning to create a shell script (I don't know yet if I will use Windows shell script or a CygWin script) that needs to know if this <code>sudoserver.py</code> python script is running.
But if I do in CygWin (while <code>sudoserver.py</code> is running):</p>
<pre><code>$ ps -e | grep "python" -i
    11020   10112   11020       7160  cons0   1000 00:09:53 /usr/bin/python2.7
</code></pre>
<p>and in <strong>Windows shell</strong>:</p>
<pre><code>C:\&gt;tasklist | find "python" /i
python2.7.exe                 4344 Console                    1    13.172 KB
</code></pre>
<p>So it seems I have no info about the <code>.py</code> file being executed. All I know is that python is running <em>something</em>.<br/>
The <code>-l</code> (long) option for 'ps' on CygWin does not find my <code>.py</code> file. Nor does it the <code>/v</code> (verbose) switch at <code>tasklist</code>.<br/>
What should be the appropriate shell (Windows or CygWin shell would enough; both if possible would be fine) way to programmatically find if an specific python script is executing right now?  </p>
<p>NOTE: The python process could be started by another user. Even from a user not logged in a GUI shell, and, even more, the <strong>"SYSTEM"</strong> (privileged) Windows user.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is a limitation of the platform. </p>
<p>You probably need to use some low level API to retrieve the process info. You can take a look at this one: <a href="https://stackoverflow.com/questions/9589431/getting-the-command-line-arguments-of-another-process-in-windows">Getting the command line arguments of another process in Windows</a></p>
<p>You can probably use win32api module to access these APIs.</p>
<p>(Sorry, away from a Windows PC so I can't try it out)</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>sudoserver.py</code> is your script, you could modify it to create a file in an accessible location when it starts and to delete the file when it finishes. Your shell script can then check for the existence of that file to find out if <code>sudoserver.py</code> is running. </p>
<p>(EDIT)</p>
<p>Thanks to the commenters who suggested that while the presence or absence of the file is an unreliable indicator, a file's lock status is not.</p>
<p>I wrote the following Python script <code>testlock.py</code>:</p>
<pre><code>f = open ("lockfile.lck","w")
for i in range(10000000):
    print (i)
f.close()
</code></pre>
<p>... and ran it in a Cygwin console window on my Windows PC. At the same time, I had another Cygwin console window open in the same directory.</p>
<p>First, after I started <code>testlock.py</code>:</p>
<pre><code>Simon@Simon-PC ~/test/python
$ ls
lockfile.lck  testlock.py

Simon@Simon-PC ~/test/python
$ rm lockfile.lck
rm: cannot remove `lockfile.lck': Device or resource busy
</code></pre>
<p>... then after I had shut down <code>testlock.py</code> by using <code>Ctrl-C</code>:</p>
<pre><code>Simon@Simon-PC ~/test/python
$ rm lockfile.lck

Simon@Simon-PC ~/test/python
$ ls
testlock.py

Simon@Simon-PC ~/test/python
$
</code></pre>
<p>Thus, it appears that Windows is locking the file while the <code>testlock.py</code> script is running but it is unlocked when it is stopped with <code>Ctrl-C</code>. The equivalent test can be carried out in Python with the following script:</p>
<pre><code>import os
try:
    os.remove ("lockfile.lck")
except:
    print ("lockfile.lck in use")
</code></pre>
<p>... which correctly reports:</p>
<pre><code>$ python testaccess.py
lockfile.lck in use
</code></pre>
<p>... when <code>testlock.py</code> is running but successfully removes the locked file when <code>testlock.py</code> has been stopped with a <code>Ctrl-C</code>.</p>
<p>Note that this approach works in Windows but it won't work in Unix because, according to the <a href="http://docs.python.org/3/library/os.html?highlight=file%20object#os.remove" rel="nofollow noreferrer">Python documentation</a>:</p>
<blockquote>
<p>On Windows, attempting to remove a file that is in use causes 
  an exception to be raised; on Unix, the directory entry is removed 
  but the storage allocated to the file is not made available until 
  the original file is no longer in use.</p>
</blockquote>
<p>A platform-independent solution using an additional Python module <a href="https://github.com/dmfrey/FileLock" rel="nofollow noreferrer">FileLock</a> is described in <a href="https://stackoverflow.com/questions/489861/locking-a-file-in-python">Locking a file in Python</a>.</p>
<p>(FURTHER EDIT)</p>
<p>It appears that the OP didn't necessarily want a solution in Python. An alternative would be to do this in <code>bash</code>. Here is <code>testlock.sh</code>:</p>
<pre><code>#!/bin/bash
flock lockfile.lck sequence.sh
</code></pre>
<p>The script <code>sequence.sh</code> just runs a time-consuming operation:</p>
<pre><code>#!/bin/bash
for i in `seq 1 1000000`;
do
    echo $i
done
</code></pre>
<p>Now, while <code>testlock.sh</code> is running, we can test the lock status using another variant on <code>flock</code>:</p>
<pre><code>$ flock -n lockfile.lck echo "Lock acquired" || echo "Could not acquire lock"
Could not acquire lock

$ flock -n lockfile.lck echo "Lock acquired" || echo "Could not acquire lock"
Could not acquire lock

$ flock -n lockfile.lck echo "Lock acquired" || echo "Could not acquire lock"
Lock acquired

$
</code></pre>
<p>The first two attempts to lock the file failed because <code>testlock.sh</code> was still running and so the file was locked. The last attempt succeeded because <code>testlock.sh</code> had finished running.</p>
</div>
<span class="comment-copy">This answers the question that I also initially thought the OP was asking. In fact, however, it appears to me that the question is: "How (whether in Cygwin or Windows shell) can I find out if a specific Python script is running?"</span>
<span class="comment-copy">@Simon You are right. I have proposed another solution</span>
<span class="comment-copy">+1: Better than my answer, which has the flaws that commentators have pointed out when <code>sudoserver.py</code> is terminated in improperly.</span>
<span class="comment-copy">Well, thanks you, @AnthonyKong. I will probably have to add C programming to my script, so it seems there is no way (till we now know) to do it.</span>
<span class="comment-copy">Unless the script dies unexpectedly. Maybe he could use a lock file, as locks are released no matter how the script is terminated. Maybe some adaption of this: <a href="http://stackoverflow.com/questions/6146523/running-python-script-with-cron-only-if-not-running" title="running python script with cron only if not running">stackoverflow.com/questions/6146523/â€¦</a></span>
<span class="comment-copy">That is if file locking works on Windows as one would expect. No idea about Windows.</span>
<span class="comment-copy">Planning to stop something by ^C is not a good thing, because unless you actuall handle the interrupt, i.e. create exit methods, you will hardly ever get a clean exit. As the server probably listens on some port you could just check if that port is currently in use to determine if the server is running. I'd go for the lockfile, though.</span>
<span class="comment-copy">@SopalajodeArrierez The creation of a file must not be unelegant. Other OS (those whose zen is "everything is a file") use pid-files and lock-files as a standard mechanism. You just have to check how fcntl.LOCK_EX and fcntl.LOCK_NB work on your OS and FS.</span>
<span class="comment-copy">@SopalajodeArrierez You said "so deletion of the lock file could be an issue.". This is not an issue. No need to actually delete the file. To check whether the process is running, dont see if the file exists, but see if someone holds a lock over this file. This is how lock files work. Otherwise you have the same unreliable mechanism as proposed by Simon. And locks are released no matter how the process terminated: gracefully, ^C, SIGTERM, kill -9, computer on flames.</span>
