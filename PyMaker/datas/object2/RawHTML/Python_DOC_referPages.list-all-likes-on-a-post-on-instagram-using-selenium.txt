<div class="post-text" itemprop="text">
<p>I am trying to make some tests using selenium based Katalon Studio. In one of my tests I have to write inside a textarea. The problem is that I get the following error: </p>
<pre><code>...Element MyElement is not clickable at point (x, y)... Other element would receive the click...
</code></pre>
<p>In fact my element is place inside some other diva that might hide it but how can I make  the click event hit my textarea?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>Element ... is not clickable at point (x, y). Other element would receive the click"</code> can be caused for different factors. You can address them by either of the following procedures:</p>
<ol>
<li>Element not getting clicked due to JavaScript or AJAX calls present</li>
</ol>
<p>Try to use <code>Actions</code> Class:</p>
<pre><code>WebElement element = driver.findElement(By.id("id1"));
Actions actions = new Actions(driver);
actions.moveToElement(element).click().build().perform();
</code></pre>
<ol start="2">
<li>Element not getting clicked as it is not within <a href="https://www.w3schools.com/css/css_rwd_viewport.asp" rel="noreferrer">Viewport</a></li>
</ol>
<p>Try to use <code>JavascriptExecutor</code> to bring the element within Viewport:</p>
<pre><code>JavascriptExecutor jse1 = (JavascriptExecutor)driver;
jse1.executeScript("scroll(250, 0)"); // if the element is on top.
jse1.executeScript("scroll(0, 250)"); // if the element is at bottom.
</code></pre>
<p>Or</p>
<pre><code>WebElement myelement = driver.findElement(By.id("id1"));
JavascriptExecutor jse2 = (JavascriptExecutor)driver;
jse2.executeScript("arguments[0].scrollIntoView()", myelement); 
</code></pre>
<ol start="3">
<li>The page is getting refreshed before the element gets clickable.</li>
</ol>
<p>In this case induce some <code>wait</code>.</p>
<ol start="4">
<li>Element is present in the DOM but not clickable.</li>
</ol>
<p>In this case add some <code>ExplicitWait</code> for the element to be clickable.</p>
<pre><code>WebDriverWait wait2 = new WebDriverWait(driver, 10);
wait2.until(ExpectedConditions.elementToBeClickable(By.id("id1")));
</code></pre>
<ol start="5">
<li>Element is present but having temporary Overlay.</li>
</ol>
<p>In this case induce <strong><code>ExplicitWait</code></strong> with  <strong><code>ExpectedConditions</code></strong> set to <strong><code>invisibilityOfElementLocated</code></strong> for the Overlay to be invisible.</p>
<pre><code>WebDriverWait wait3 = new WebDriverWait(driver, 10);
wait3.until(ExpectedConditions.invisibilityOfElementLocated(By.xpath("ele_to_inv")));
</code></pre>
<ol start="6">
<li>Element is present but having permanent Overlay.</li>
</ol>
<p>Use <code>JavascriptExecutor</code> to send the click directly on the element.</p>
<pre><code>WebElement ele = driver.findElement(By.xpath("element_xpath"));
JavascriptExecutor executor = (JavascriptExecutor)driver;
executor.executeScript("arguments[0].click();", ele);
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I assume, you've checked already that there is no any other component overlapping here (transparent advertisement-iframes or some other component of the DOM =&gt; seen quite often such things in input/textfield elements) and, when manually (slowly) stepping your code, it's working smoothly, then ajax calls might cause this behaviour.</p>
<p>To avoid thread.sleep, try sticking with EventFiringWebDriver and register a handle to it.
(Depending on your application's techstack you may work it for Angular, JQuery or wicket in the handler, thus requiring different implementations)
(Btw: This approach also got me rid of "StaleElementException" stuff lots of times)</p>
<p>see:
<strong>org.openqa.selenium.support.events.EventFiringWebDriver
org.openqa.selenium.support.events.WebDriverEventListener</strong></p>
<pre><code>driveme = new ChromeDriver();
driver = new EventFiringWebDriver(driveme);
ActivityCapture handle=new ActivityCapture();
driver.register(handle);
</code></pre>
<p>=&gt; ActivityCapture implements WebDriverEventListener
e.g. javascriptExecutor to deal with Ajax calls in a wicket/dojo techstack</p>
<pre><code>    @Override
public void beforeClickOn(WebElement arg0, WebDriver event1) {
    try {
        System.out.println("After click "+arg0.toString());
        //System.out.println("Start afterClickOn - timestamp: System.currentTimeMillis(): " + System.currentTimeMillis());
        JavascriptExecutor executor = (JavascriptExecutor) event1;
        StringBuffer javaScript = new StringBuffer();
        javaScript.append("for (var c in Wicket.channelManager.channels) {");
        javaScript.append(" if (Wicket.channelManager.channels[c].busy) {");
        javaScript.append(" return true;");
        javaScript.append(" }");
        ;
        ;
        ;
        javaScript.append("}");
        javaScript.append("return false;");
        //Boolean result = (Boolean) executor.executeScript(javaScript.toString());
        WebDriverWait wait = new WebDriverWait(event1, 20);
        wait.until(new ExpectedCondition&lt;Boolean&gt;() {
            public Boolean apply(WebDriver driver) {
                return !(Boolean) executor.executeScript(javaScript.toString());
            }
        });
        //System.out.println("End afterClickOn - timestamp: System.currentTimeMillis(): " + System.currentTimeMillis());
    } catch (Exception ex) {
        //ex.printStackTrace();
    }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try Thread.Sleep() </p>
<p><strong>Implicit - Thread.Sleep()</strong></p>
<p>So this isn’t actually a feature of Selenium WebDriver, it’s a common feature in most programming languages though.
But none of that matter.</p>
<p>Thread.Sleep() does exactly what you think it does, it’s sleeps the thread. So when your program runs, in the majority of your cases that program will be some automated checks, they are running on a thread.
So when we call Thread.Sleep we are instructing our program to do absolutely nothing for a period of time, just sleep.
It doesn’t matter what our application under test is up to, we don’t care, our checks are having a nap time!</p>
<p>Depressingly though, it’s fairly common to see a few instances of Thread.Sleep() in Selenium WebDriver GUI check frameworks.
What tends to happen is a script will be failing or failing sporadically, and someone runs it locally and realises there is a race, that sometimes WedDriver is losing. It could be that an application sometimes takes longer to load, perhaps when it has more data, so to fix it they tell WebDriver to take a nap, to ensure that the application is loaded before the check continues.</p>
<p><strong>Thread.sleep(5000);</strong></p>
<p>The value provided is in milliseconds, so this code would sleep the check for 5 seconds.</p>
</div>
<span class="comment-copy">You should get some knowledge about implicit and explicit waits in WebDriver. It will helps you how to deal with visible\not visible elements.</span>
<span class="comment-copy">But I'm not using javascript. I use katalon that uses java.</span>
<span class="comment-copy">I have partially solved the problem by putting a Thread.sleep before the click.</span>
<span class="comment-copy">@nix86 <code>Thread.sleep()</code> degrades your Test performance. So avoid <code>Thread.sleep()</code>. <code>ImplicitlyWait</code> may be discontinued anytime. So try out <code>ExplicitWait</code> as I mentioned in my Answer.</span>
<span class="comment-copy">But how is the driver variable defined?</span>
<span class="comment-copy">@nix86 Can you consider showing us your work please along with the relevant HTML DOM so that we can guide you properly? Thanks</span>
