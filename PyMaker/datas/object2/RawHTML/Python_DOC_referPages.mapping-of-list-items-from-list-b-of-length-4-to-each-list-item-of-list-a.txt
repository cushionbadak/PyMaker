<div class="post-text" itemprop="text">
<p>I had a issue solving the below problem, please check the the below code.</p>
<pre><code>filenamee5 = 'ABC'
counter1 = 1
counter2 = 2          
list1 = []
list2 = range(1000)
for x in list2:
    counter1 = str(counter1)
    full_name5 = (filenamee5 + counter1)
    list1.append(full_name5)
    counter1 = counter2
    counter2 += 1
    numbers_list = []
    level1 = []
    for x in list1:
        numbers_list.append(x)
        ListsOfAll = numbers_list[1:1000]
        for x1 in range(1, len(ListsOfAll), 4):
            level1.append(list(numbers_list[x1:x1 + 4]))
            l1 = level1[0]
            l2 = level1[1:5]
            l3 = level1[5:21]
            l4 = level1[21:85]
            l5 = level1[85:341]
            l6 = level1[341:1365]
            ll2 = []
            for i in range(len(l2)):
                aaa = l1[i], l2[i]
                ll2.append(aaa)
                print(ll2)
                print("the length is:",len(ll2))
</code></pre>
<p>My actual output for only first and second list:</p>
<pre><code>[('ABC2', ['ABC6', 'ABC7', 'ABC8', 'ABC9']),

 ('ABC3', ['ABC10', 'ABC11', 'ABC12', 'ABC13']),

 ('ABC4', ['ABC14', 'ABC15', 'ABC16', 'ABC17']), 

 ('ABC5', ['ABC18', 'ABC19', 'ABC20', 'ABC21'])]

the length is: 4
</code></pre>
<p>Here each list item should contain four items in below list i.e. in the ratio 1:4 group.</p>
<p>Please see the example below to understand my problem:</p>
<pre><code>List1 = ['A','B','C','D']

List2=['E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T']

List3 = ['A',['E','F','G','H'],'B',['I','J','K','L'],'C',['M','N','O','P'],'D',['Q','R','S','T']]
</code></pre>
<p>Kindly please help me with your suggestions, will be appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>I have not the slightest idea why you need this (and I dare to guess that this <em>might</em> be another case of the <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem[xy%20problem]">xy problem</a>...) and I have to state that it's a little odd to add <em>different</em> sample data sets for one problem into one post... However - perhaps you can use this one:<br/>
(I called it "quadratic chaining", because <code>mapping</code> is sth different...)</p>
<p><strong>solution function:</strong></p>
<pre><code>def quadraticChaining(somelists):
    out = []
    for i, e in enumerate(somelists[0]):
        out.append(e)
        for p, sub in enumerate(somelists[1:]):
            L = 4**(p+1)
            out.append(sub[i*L:(i+1)*L])
    return out
</code></pre>
<p>...or if you don't need the whole thing in memory but just want to iterate over it<br/>
<strong>as a generator:</strong></p>
<pre><code>def quadraticChaining(somelists):
    for i, e in enumerate(somelists[0]):
        yield e
        for p, sub in enumerate(somelists[1:]):
            L = 4**(p+1)
            yield sub[i*L:(i+1)*L]
</code></pre>
<hr/>
<p><strong>sample data:</strong></p>
<pre><code>list1 = ['A'+str(i) for i in range(4)]
list2 = ['B'+str(i) for i in range(4**2)]
list3 = ['C'+str(i) for i in range(4**3)]
list4 = ['D'+str(i) for i in range(4**4)]
list5 = ['E'+str(i) for i in range(4**5)]
list6 = ['F'+str(i) for i in range(4**6)]
</code></pre>
<p><strong>function example:</strong></p>
<pre><code>quadraticChaining([list1, list2])

# ['A0',
#  ['B0', 'B1', 'B2', 'B3'],
#  'A1',
#  ['B4', 'B5', 'B6', 'B7'],
#  'A2',
#  ['B8', 'B9', 'B10', 'B11'],
#  'A3',
#  ['B12', 'B13', 'B14', 'B15']]
</code></pre>
<p>or</p>
<pre><code>quadraticChaining([list1, list2, list3])

# ['A0',
#  ['B0', 'B1', 'B2', 'B3'],
#  ['C0',
#   'C1',
#   'C2',
#   'C3',
#   'C4',
#   'C5',
#   'C6',
#   'C7',
#   'C8',
#   'C9',
#   'C10',
#   'C11',
#   'C12',
#   'C13',
#   'C14',
#   'C15'],
#  'A1',
#  ['B4', 'B5', 'B6', 'B7'],
#  ['C16',
#   'C17',
#   'C18',
#   'C19',
#   'C20',
#   'C21',
#   'C22',
#   'C23',
#   'C24',
#   'C25',
#   'C26',
#   'C27',
#   'C28',
#   'C29',
#   'C30',
#   'C31'],
#  'A2',
#  ['B8', 'B9', 'B10', 'B11'],
#  ['C32',
#   'C33',
#   'C34',
#   'C35',
#   'C36',
#   'C37',
#   'C38',
#   'C39',
#   'C40',
#   'C41',
#   'C42',
#   'C43',
#   'C44',
#   'C45',
#   'C46',
#   'C47'],
#  'A3',
#  ['B12', 'B13', 'B14', 'B15'],
#  ['C48',
#   'C49',
#   'C50',
#   'C51',
#   'C52',
#   'C53',
#   'C54',
#   'C55',
#   'C56',
#   'C57',
#   'C58',
#   'C59',
#   'C60',
#   'C61',
#   'C62',
#   'C63']]
</code></pre>
<p><strong>generator example:</strong></p>
<pre><code>L = quadraticChaining([list1, list2, list3])
# &lt;generator object quadraticChaining at 0x0000000009993B88&gt;

next(L)
# 'A0'

next(L)
# ['B0', 'B1', 'B2', 'B3']

next(L)
# ['C0',
#  'C1',
#  'C2',
#  'C3',
#  'C4',
#  'C5',
#  'C6',
#  'C7',
#  'C8',
#  'C9',
#  'C10',
#  'C11',
#  'C12',
#  'C13',
#  'C14',
#  'C15']

next(L)
# 'A1'

...
</code></pre>
</div>
<span class="comment-copy">What is your issue? Do you have any error? Could you describe your problem? It's hard to figure it out from this code and examples (at least describe what is your input/output)</span>
<span class="comment-copy">Don't paste your output as images. It's better to copy/paste it to your answer. It will be easier to find it through search engine.</span>
<span class="comment-copy">yes . i have defined lists where list1 has 4 items, list2 has 16 items and so on upto 4096 items in list 6..but i need an execution result like for each item in list1 has to map 4 consecutive items from list2 so that for each list has to get 4 equal chunks items any items for any list below that.</span>
<span class="comment-copy">the overall picture is like an tree structure , one below four , one below four ...so on !</span>
<span class="comment-copy">But <code>List3</code> contains 8 elements (or 20 depends how you count), not 64.</span>
