<div class="post-text" itemprop="text">
<p>I have the following Python 2.7 dictionary data structure (I do not control source data - comes from another system as is):</p>
<pre>
{112762853378: 
   {'dst': ['10.121.4.136'], 
    'src': ['1.2.3.4'], 
    'alias': ['www.example.com']
   },
 112762853385: 
   {'dst': ['10.121.4.136'], 
    'src': ['1.2.3.4'], 
    'alias': ['www.example.com']
   },
 112760496444: 
   {'dst': ['10.121.4.136'], 
    'src': ['1.2.3.4']
   },
 112760496502: 
   {'dst': ['10.122.195.34'], 
    'src': ['4.3.2.1']
   },
 112765083670: ...
}
</pre>
<p>The dictionary keys will always be unique.  Dst, src, and alias can be duplicates.  All records will always have a dst and src but not every record will necessarily have an alias as seen in the third record.</p>
<p>In the sample data either of the first two records would be removed (doesn't matter to me which one).  The third record would be considered unique since although dst and src are the same it is missing alias.</p>
<p>My goal is to remove all records where the dst, src, and alias have all been duplicated - regardless of the key.</p>
<p>How does this <em>rookie</em> accomplish this?</p>
<p>Also, my limited understanding of Python interprets the data structure as a dictionary with the values stored in dictionaries... a dict of dicts, is this correct?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could go though each of the items (the key value pair) in the dictionary and add them into a result dictionary if the value was not already in the result dictionary.  </p>
<pre><code>input_raw = {112762853378: 
   {'dst': ['10.121.4.136'], 
    'src': ['1.2.3.4'], 
    'alias': ['www.example.com']
   },
 112762853385: 
   {'dst': ['10.121.4.136'], 
    'src': ['1.2.3.4'], 
    'alias': ['www.example.com']
   },
 112760496444: 
   {'dst': ['10.121.4.136'], 
    'src': ['1.2.3.4']
   },
 112760496502: 
   {'dst': ['10.122.195.34'], 
    'src': ['4.3.2.1']
   }
}

result = {}

for key,value in input_raw.items():
    if value not in result.values():
        result[key] = value

print result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One simple approach would be to create a reverse dictionary using the concatenation of the string data in each inner dictionary as a key. So say you have the above data in a dictionary, <code>d</code>:</p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; reverse_d = collections.defaultdict(list)
&gt;&gt;&gt; for key, inner_d in d.iteritems():
...     key_str = ''.join(inner_d[k][0] for k in ['dst', 'src', 'alias'] if k in inner_d)
...     reverse_d[key_str].append(key)
... 
&gt;&gt;&gt; duplicates = [keys for key_str, keys in reverse_d.iteritems() if len(keys) &gt; 1]
&gt;&gt;&gt; duplicates
[[112762853385, 112762853378]]
</code></pre>
<p>If you don't want a list of duplicates or anything like that, but just want to create a duplicate-less dict, you could just use a regular dictionary instead of a <code>defaultdict</code> and re-reverse it like so:</p>
<pre><code>&gt;&gt;&gt; for key, inner_d in d.iteritems():
...     key_str = ''.join(inner_d[k][0] for k in ['dst', 'src', 'alias'] if k in inner_d)
...     reverse_d[key_str] = key
&gt;&gt;&gt; new_d = dict((val, d[val]) for val in reverse_d.itervalues())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>input_raw = {112762853378:  {'dst': ['10.121.4.136'],
                             'src': ['1.2.3.4'],
                             'alias': ['www.example.com']    },
             112762853385:  {'dst': ['10.121.4.136'],
                             'src': ['1.2.3.4'],
                             'alias': ['www.example.com']    },
             112760496444:  {'dst': ['10.121.4.299'],
                             'src': ['1.2.3.4']    },
             112760496502:  {'dst': ['10.122.195.34'],
                             'src': ['4.3.2.1']    },
             112758601487:  {'src': ['1.2.3.4'],
                             'alias': ['www.example.com'],
                             'dst': ['10.121.4.136']},
             112757412898:  {'dst': ['10.122.195.34'],
                             'src': ['4.3.2.1']    },
             112757354733:  {'dst': ['124.12.13.14'],
                             'src': ['8.5.6.0']},             
             }

for x in input_raw.iteritems():
    print x
print '\n---------------------------\n'

seen = []

for k,val in input_raw.items():
    if val in seen:
        del input_raw[k]
    else:
        seen.append(val)


for x in input_raw.iteritems():
    print x
</code></pre>
<p>result</p>
<pre><code>(112762853385L, {'src': ['1.2.3.4'], 'dst': ['10.121.4.136'], 'alias': ['www.example.com']})
(112757354733L, {'src': ['8.5.6.0'], 'dst': ['124.12.13.14']})
(112758601487L, {'src': ['1.2.3.4'], 'dst': ['10.121.4.136'], 'alias': ['www.example.com']})
(112757412898L, {'src': ['4.3.2.1'], 'dst': ['10.122.195.34']})
(112760496502L, {'src': ['4.3.2.1'], 'dst': ['10.122.195.34']})
(112760496444L, {'src': ['1.2.3.4'], 'dst': ['10.121.4.299']})
(112762853378L, {'src': ['1.2.3.4'], 'dst': ['10.121.4.136'], 'alias': ['www.example.com']})

---------------------------

(112762853385L, {'src': ['1.2.3.4'], 'dst': ['10.121.4.136'], 'alias': ['www.example.com']})
(112757354733L, {'src': ['8.5.6.0'], 'dst': ['124.12.13.14']})
(112757412898L, {'src': ['4.3.2.1'], 'dst': ['10.122.195.34']})
(112760496444L, {'src': ['1.2.3.4'], 'dst': ['10.121.4.299']})
</code></pre>
<p>The facts that this solution creates first a list <strong>input_raw.iteritems()</strong> (as in Andrew's Cox's answer) and requires a growing list <strong>seen</strong> are drawbacks.<br/>
But the first can't be avoided (using iteritems() doesn't work) and the second is less heavy than re-creating a list <strong>result.values()</strong> from growing list <strong>result</strong> for each turn of a loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another reverse dict variation:</p>
<pre><code>&gt;&gt;&gt; import pprint
&gt;&gt;&gt; 
&gt;&gt;&gt; data = {
...   112762853378: 
...    {'dst': ['10.121.4.136'], 
...     'src': ['1.2.3.4'], 
...     'alias': ['www.example.com']
...    },
...  112762853385: 
...    {'dst': ['10.121.4.136'], 
...     'src': ['1.2.3.4'], 
...     'alias': ['www.example.com']
...    },
...  112760496444: 
...    {'dst': ['10.121.4.136'], 
...     'src': ['1.2.3.4']
...    },
...  112760496502: 
...    {'dst': ['10.122.195.34'], 
...     'src': ['4.3.2.1']
...    },
... }
&gt;&gt;&gt; 
&gt;&gt;&gt; keep = set({repr(sorted(value.items())):key
...             for key,value in data.iteritems()}.values())
&gt;&gt;&gt; 
&gt;&gt;&gt; for key in data.keys():
...     if key not in keep:
...         del data[key]
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; pprint.pprint(data)
{112760496444L: {'dst': ['10.121.4.136'], 'src': ['1.2.3.4']},
 112760496502L: {'dst': ['10.122.195.34'], 'src': ['4.3.2.1']},
 112762853378L: {'alias': ['www.example.com'],
                 'dst': ['10.121.4.136'],
                 'src': ['1.2.3.4']}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since the way to find uniqueness in correspondences is exactly to use a dictionary, with the desired unique value being the key, the way to go is to create a reversed dict, where your values are composed as the key - then recreate a "de-reversed" dictionary using the intermediate result.</p>
<pre><code>dct = {112762853378: 
   {'dst': ['10.121.4.136'], 
    'src': ['1.2.3.4'], 
    'alias': ['www.example.com']
   },
 112762853385: 
   {'dst': ['10.121.4.136'], 
    'src': ['1.2.3.4'], 
    'alias': ['www.example.com']
   },
 112760496444: 
   {'dst': ['10.121.4.136'], 
    'src': ['1.2.3.4']
   },
 112760496502: 
   {'dst': ['10.122.195.34'], 
    'src': ['4.3.2.1']
   },
   }

def remove_dups (dct):
    reversed_dct = {}
    for key, val in dct.items():
        new_key = tuple(val["dst"]) + tuple(val["src"]) + (tuple(val["alias"]) if "alias" in val else (None,) ) 
        reversed_dct[new_key] = key
    result_dct = {}
    for key, val in reversed_dct.items():
        result_dct[val] = dct[val]
    return result_dct

result = remove_dups(dct)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>dups={}

for key,val in dct.iteritems():
    if val.get('alias') != None:
        ref = "%s%s%s" % (val['dst'] , val['src'] ,val['alias'])# a simple hash
        dups.setdefault(ref,[]) 
        dups[ref].append(key)

for k,v in dups.iteritems():
    if len(v) &gt; 1:
        for key in v:
            del dct[key]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import defaultdict

dups = defaultdict(lambda : defaultdict(list))

for key, entry in data.iteritems():
    dups[tuple(entry.keys())][tuple([v[0] for v in entry.values()])].append(key)

for dup_indexes in dups.values():
    for keys in dup_indexes.values():
        for key in keys[1:]:
            if key in data:
                del data[key]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>example = {
    'id1':  {'name': 'jay','age':22,},
    'id2': {'name': 'salman','age': 52,},
    'id3': {'name':'Ranveer','age' :26,},
    'id4': {'name': 'jay', 'age': 22,},
}
for item in example:
    for value in example:
        if example[item] ==example[value]:
            if item != value:
                 key = value 
                 del example[key]
print "example",example         
</code></pre>
</div>
<span class="comment-copy">This is a good starting point, but I feel compelled to point out that it will be slow for large collections of data, because with every loop, it creates a new list of values and does a linear search over it.</span>
<span class="comment-copy">This worked with simplicity and beauty.</span>
<span class="comment-copy">@senderle: I appreciate your thought and comment regarding the speed and will take thin into consideration if necessary.  Do you care to expand on this answer to increase performance?</span>
<span class="comment-copy">This doesn't answer the question as posed.</span>
<span class="comment-copy">Looks fine to me Joel.  What's wrong with it? <i>edit:</i> I think I see where your concern is, but <code>in</code> will work fine here.</span>
<span class="comment-copy">So much complicated !</span>
<span class="comment-copy">Fine but complicated in my opinion</span>
<span class="comment-copy">Seems like this would count <code>{'src':['1.2.3.4'], 'dst':['10.121.3.1236']}</code> and <code>{'src':['10.121.3.1236'], 'dst':['1.2.3.4']}</code> as duplicates of one another...</span>
<span class="comment-copy">@senderle. Well spotted! Fixed that now, FWIW. I should probably also point out that this solution, although compact, is pretty inefficient compared to some of the others.</span>
<span class="comment-copy">So much complicated</span>
<span class="comment-copy">Had to update this. Should work now, if I understand the question correctly.</span>
<span class="comment-copy">Overcomplicated</span>
<span class="comment-copy">The complexity of this is O(n^3)!</span>
<span class="comment-copy">Please format your answer with the <code>{}</code> button, format matters in Python. And it is a very bad idea to modify lists or dictionaries, while iterating over them. Very bad.</span>
<span class="comment-copy">Welcome to StackOverflow: if you post code, XML or data samples, please highlight those lines in the text editor and click on the "code samples" button ( { } ) on the editor toolbar or using Ctrl+K on your keyboard to nicely format and syntax highlight it!</span>
