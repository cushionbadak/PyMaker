<div class="post-text" itemprop="text">
<p>I have a beautiful soup element result set that contains several  parents elements, each containing inner elements. How would I go about trying to filter these elements based on the text of eachs inner element.</p>
<pre><code>&lt;div class="parent"&gt;
    &lt;div&gt; ... &lt;div&gt;
    &lt;p class="example"&gt; TRUE &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>In the example, say I want to only keep elements that have an inner p element which has a value of 'TRUE'.</p>
</div>
<div class="post-text" itemprop="text">
<p>BeautifulSoup allows you to give a <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/#a-function" rel="nofollow noreferrer"><em>function as filter</em></a>.</p>
<p>You could give a <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow noreferrer">lambda</a> expression like</p>
<pre><code>lambda elem:elem.find('p',text=re.compile('TRUE')
</code></pre>
<p>inside the <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find-all" rel="nofollow noreferrer"><em>find_all()</em></a>. If the child with the text is not available this will return a empty list. Since <a href="https://docs.python.org/2/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer"><em>any empty sequence is considered false</em></a> in python, this will filter out the unwanted elements.</p>
<pre><code>html="""
&lt;div class="parent"&gt;
    &lt;p class="example"&gt; TRUE &lt;/p&gt;
&lt;/div&gt;
&lt;div class="parent"&gt;
    &lt;p class="example"&gt; TRUE &lt;/p&gt;
&lt;/div&gt;
&lt;div class="parent"&gt;
    &lt;p class="example"&gt;FALSE &lt;/p&gt;
&lt;/div&gt;
"""
from bs4 import BeautifulSoup,Tag
import re
soup=BeautifulSoup(html,'html.parser')
print(soup.find_all(lambda elem:elem.find('p',text=re.compile('TRUE'))))
</code></pre>
<p>Outputs:</p>
<pre><code>[&lt;div class="parent"&gt;
&lt;p class="example"&gt; TRUE &lt;/p&gt;
&lt;/div&gt;, &lt;div class="parent"&gt;
&lt;p class="example"&gt; TRUE &lt;/p&gt;
&lt;/div&gt;]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sounds like xpath would work. Something like</p>
<pre><code>//p[contains(@class, 'example') and normalize-space(text()) = 'TRUE']/ancestor::div[@class='parent']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can actually do this using CSS selectors in BeautifulSoup 4.7+.</p>
<p>Here we will target every <code>div</code> which has a direct/immediate child <code>p</code> with class <code>example</code> that contains the text <code>TRUE</code>.</p>
<pre><code>from bs4 import BeautifulSoup,Tag
html="""
&lt;div class="parent"&gt;
    &lt;p class="example"&gt; TRUE &lt;/p&gt;
&lt;/div&gt;
&lt;div class="parent"&gt;
    &lt;p class="example"&gt; TRUE &lt;/p&gt;
&lt;/div&gt;
&lt;div class="parent"&gt;
    &lt;p class="example"&gt;FALSE &lt;/p&gt;
&lt;/div&gt;
"""
soup=BeautifulSoup(html,'html.parser')
print(soup.select('div:has(&gt; p.example:contains(TRUE))'))
</code></pre>
<p>Output</p>
<pre><code>[&lt;div class="parent"&gt;
&lt;p class="example"&gt; TRUE &lt;/p&gt;
&lt;/div&gt;, &lt;div class="parent"&gt;
&lt;p class="example"&gt; TRUE &lt;/p&gt;
&lt;/div&gt;]
</code></pre>
</div>
<span class="comment-copy">So if for example I am originally storing all of the unfiltered parent elements in "results". What would this query look like on that variable?</span>
<span class="comment-copy">I am also getting a syntax error pointing to "parent" at ancestor::div[@class='parent']</span>
