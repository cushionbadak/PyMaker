<div class="post-text" itemprop="text">
<p>I am new to Vectors and making classes. I am trying to construct my own vector class but when i pass it through my code which is:</p>
<p>position += heading*distance_moved</p>
<p>where position and heading are both vectors. heading is normalized. my goal is to repeat my code until position = destination.
What is wrong with this class?</p>
<p>import math</p>
<pre><code>class Vector(object):
    #defaults are set at 0.0 for x and y
    def __init__(self, x=0.0, y=0.0):
        self.x = x
        self.y = y

    #allows us to return a string for print
    def __str__(self):
        return "(%s, %s)"%(self.x, self.y)

    # from_points generates a vector between 2 pairs of (x,y) coordinates
    @classmethod
    def from_points(cls, P1, P2):
        return cls(P2[0] - P1[0], P2[1] - P1[1])

    #calculate magnitude(distance of the line from points a to points b
    def get_magnitude(self):
        return math.sqrt(self.x**2+self.y**2)

    #normalizes the vector (divides it by a magnitude and finds the direction)
    def normalize(self):
        magnitude = self.get_magnitude()
        self.x/= magnitude
        self.y/= magnitude

    #adds two vectors and returns the results(a new line from start of line ab to end of line bc)
    def __add__(self, rhs):
        return Vector(self.x +rhs.x, self.y+rhs.y)

    #subtracts two vectors
    def __sub__(self, rhs):
        return Vector(self.x - rhs.x, self.y-rhs.y)

    #negates or returns a vector back in the opposite direction
    def __neg__(self):
        return Vector(-self.x, -self.y)

    #multiply the vector (scales its size) multiplying by negative reverses the direction
    def __mul__(self, scalar):
        return Vector(self.x*scalar, self.y*scalar)

    #divides the vector (scales its size down)
    def __div__(self, scalar):
        return Vector(self.x/scalar, self.y/scalar)

    #iterator
    def __iter__(self):
        return self

    #next
    def next(self):
        self.current += 1
        return self.current - 1

    #turns a list into a tuple
    def make_tuple(l):
        return tuple(l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I guess you are using python 3.x, because I've got a similar error.
I'm also new on making class, but it would be nice to share what I learned :)</p>
<p>In 3.x, use <code>__next__()</code> instead of <code>next()</code> in the definition of classes.
The error haven't occurred after I renamed it in your code, but I got another problem, "'Vector' object has no attribute 'current'" :)</p>
<p>I think it might be better for you to understand iterators (and class?) more.
A simplest example is:</p>
<pre><code>class Count:
    def __init__(self, n):
        self.max = n

    def __iter__(self):
        self.count = 0
        return self

    def __next__(self):
        if self.count == self.max:
            raise StopIteration
        self.count += 1
        return self.count - 1

if __name__ == '__main__':
    c = Count(4)
    for i in c:
        print(i, end = ',')
</code></pre>
<p>and the outputs are 0,1,2,3,.</p>
<p>With a vector class, I want to iterate the components of the vector. So:</p>
<pre><code>def __iter__(self):
    self.count = 0
    self.list = [self.x, self.y, self.z]  # for three dimension
    return self

def __next__(self):
    if self.count == len(self.list):
        raise StopIteration
    self.count += 1
    return self.list[self.count - 1]
</code></pre>
<p>and the iterator outputs the sequence x, y, z.</p>
<p>Note that the most important feature of iterators is to give the sequence step by step without creating whole list. So it is not very good idea to make <code>self.list</code> if the sequence will be very long.
More details here: <a href="http://docs.python.org/3/tutorial/classes.html#iterators" rel="noreferrer">python tutorial</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The first argument that's being passed into <code>make_tuple</code> is your <code>Vector</code> instance (it's the same <code>self</code> argument that you put everywhere).</p>
<p>You have to pass in <em>what</em> you want to turn into a tuple, which is probably your x and y coordinates:</p>
<pre><code>def make_tuple(self):
    return (self.x, self.y)
</code></pre>
</div>
<span class="comment-copy">Thanks, this did it for me. Now if only the docs weren't so horrendously out of date and incomplete, we might all have avoided this.</span>
