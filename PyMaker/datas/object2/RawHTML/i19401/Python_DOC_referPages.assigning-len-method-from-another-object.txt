<div class="post-text" itemprop="text">
<p>I am going to implement some container object.</p>
<pre><code>class A:
    def __init__(self, L):
        self.L = list(L)
    def __len__(self):
        return len(self.L)

class B:
    def __init__(self, L):
        self.L = list(L)
        self.__len__ = self.L.__len__
</code></pre>
<p>In the first case work both <code>len()</code> and <code>.__len__()</code></p>
<pre><code>&gt;&gt;&gt; a = A(range(10))
&gt;&gt;&gt; a.__len__()
10
&gt;&gt;&gt; len(a)
10
</code></pre>
<p>But in the second case I get error with <code>len()</code>.</p>
<pre><code>&gt;&gt;&gt; b = B(range(10))
&gt;&gt;&gt; b.__len__()
10
&gt;&gt;&gt; len(b)
Traceback (most recent call last):
  File "&lt;pyshell#93&gt;", line 1, in &lt;module&gt;
    len(b)
TypeError: object of type 'B' has no len()
</code></pre>
<ol>
<li>Why <code>len()</code> in second case does not work, whereas <code>.__len__()</code> is defined and works correctly?</li>
<li>Is it OK in general to assign some methods from one object to another object? Like I did with <code>self.L.__len__()</code>.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You cannot do this, special hook methods like <code>__len__</code> are <em>always</em> looked up on the type, not on the instance.</p>
<p>In other words, <code>len(ob)</code> calls <code>type(ob).__len__(ob)</code>, <em>not</em> <code>ob.__len__()</code>.</p>
<p>See the <a href="http://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">Special method lookup documentation</a>; I explained why this is <a href="https://stackoverflow.com/questions/14102407/implementing-getitem-in-new-style-classes/14102566#14102566">in a previous answer</a>.</p>
<p>For methods that are <em>not</em> special hooks (starting and ending with double underscores), you are free to assign methods to your instance, there is no <em>technical</em> reason preventing you from doing that.</p>
<p>If your goal is to provide a <a href="http://en.wikipedia.org/wiki/Facade_pattern" rel="nofollow noreferrer">facade object</a> then by all means, copy over methods. I see no obvious downsides to doing that. Calling the method directly on your instance instead of having to route through a wrapper method would perform slightly better (you save a stack push and pop for the wrapper method).</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/reference/datamodel.html#new-style-special-lookup" rel="nofollow">The fine Python documentation</a> tells us that</p>
<blockquote>
<p>For new-style classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary.</p>
</blockquote>
</div>
<span class="comment-copy">What is this, python 2 or 3? Please don't use both tags unless you can tell us that you tried this on both versions.</span>
<span class="comment-copy">Works on 2.6.6 on Linux</span>
<span class="comment-copy">And on 2.7.1 on Windows</span>
<span class="comment-copy">@DJV Because the OP uses old style classes, which don't exist in 3.x any longer.</span>
<span class="comment-copy">@heisskopf: <code>len(B([])</code> fails on Python 3.3. It fails on 2.7 as well <i>if you derive <code>B</code> from <code>object</code></i> (new-style class).</span>
<span class="comment-copy">Now for question 2 ... Is it a good idea?  Personally, in this case, I'd just inherit from <code>list</code>, but it's hard to say whether that is the appropriate course of action here or not ...</span>
<span class="comment-copy">In general for non-special methods is it a good idea to assign methods to object from some other object? Like <code>c.somemethod = c.L.somemethod</code></span>
<span class="comment-copy">@heisskopf: As I state: technically it works. If your goal is to provide a facade object, proxying for a wrapped object, I see no reason why that would be a <i>bad</i> idea. If you feel it works for your API, I say go for it.</span>
<span class="comment-copy">To my comment above: I am going to call <code>c.somemethod()</code> very frequently. Does it have some performance advantage, rather than explicit method definition?</span>
