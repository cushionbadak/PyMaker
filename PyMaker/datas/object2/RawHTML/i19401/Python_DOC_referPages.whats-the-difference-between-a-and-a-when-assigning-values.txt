<div class="post-text" itemprop="text">
<p>I happen to see this snippet of code:</p>
<pre><code>a = []  
a = [a, a, None]
# makes a = [ [], [], None] when print

a = []
a[:] = [a, a, None]
# makes a = [ [...], [...], None] when print
</code></pre>
<p>It seems the <code>a[:]</code> assignment assigns a pointer but I can't find documents about that. So anyone could give me an explicit explanation?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, <code>a</code> is a name - it points to an object, in this case, a list.</p>
<p>In your first example, <code>a</code> initially points to the empty list, then to a new list.</p>
<p>In your second example, <code>a</code> points to an empty list, then it is <em>updated</em> to contain the values from the new list. This does not change the list <code>a</code> references.</p>
<p>The difference in the end result is that, as the right hand side of an operation is evaluated first, in both cases, <code>a</code> points to the original list. This means that in the first case, it points to the list that used to be <code>a</code>, while in the second case, it points to itself, making a recursive structure.</p>
<p>If you are having trouble understanding this, I recommend taking a look at <a href="http://www.pythontutor.com/visualize.html#code=a+%3D+%5B%5D++%0Aa+%3D+%5Ba,+a,+None%5D%0A%0Aa+%3D+%5B%5D%0Aa%5B%3A%5D+%3D+%5Ba,+a,+None%5D&amp;mode=display&amp;cumulative=false&amp;heapPrimitives=false&amp;drawParentPointers=false&amp;textReferences=false&amp;py=2&amp;curInstr=0">it visualized</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The first will point <code>a</code> to a new object, the second will mutate <code>a</code>, so the list referenced by <code>a</code> is still the same.</p>
<p>For example:</p>
<pre><code>a = [1, 2, 3]
b = a
print b # [1, 2, 3]

a[:] = [3, 2, 1]
print b # [3, 2, 1]
a = [1, 2, 3]
#b still references to the old list
print b # [3, 2, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>More clear example from @pythonm response</p>
<pre><code>&gt;&gt;&gt; a=[1,2,3,4]
&gt;&gt;&gt; b=a
&gt;&gt;&gt; c=a[:]
&gt;&gt;&gt; a.pop()
4
&gt;&gt;&gt; a
[1, 2, 3]
&gt;&gt;&gt; b
[1, 2, 3]
&gt;&gt;&gt; c
[1, 2, 3, 4]
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">The online tutor step 3 shows that the second empty list in <code>a</code> is actually a pointer to the first one. Could you also explain that?</span>
<span class="comment-copy">@can. They are both the same list. When you put <code>a</code> twice in the list, the same object is referenced twice from that list. You need to copy the list if you want it to be a new one with the same elements.</span>
<span class="comment-copy">Then how can I make a copy in this case?</span>
<span class="comment-copy">@can. <a href="http://docs.python.org/3/library/copy.html#copy.copy" rel="nofollow noreferrer"><code>copy.copy()</code></a> (or <a href="http://docs.python.org/3/library/copy.html#copy.deepcopy" rel="nofollow noreferrer"><code>copy.deepcopy()</code></a> if you have nested data structures).</span>
<span class="comment-copy">@pythonm I would recommend <code>new_l = list(old_l)</code> as a more readable alternative than the list slice if you are not going to use <code>copy.copy()</code>.</span>
