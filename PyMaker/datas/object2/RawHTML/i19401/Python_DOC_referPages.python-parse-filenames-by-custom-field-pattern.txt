<div class="post-text" itemprop="text">
<p>Started learning python this week, so I thought I would use it rather than excel to parse some fields out of file paths.</p>
<p>I have about 3000 files that all fit the naming convention.
/Household/LastName.FirstName.Account.Doctype.Date.extension</p>
<p>For example one of these files might be named: Cosby.Bill..Profile.2006.doc
and the fullpath is /Volumes/HD/Organized Files/Cosby, Bill/Cosby.Bill..Profile.2006.doc</p>
<p>In this case: </p>
<p><strong>Cosby, Bill</strong> would be the Household </p>
<p>Where the household (Cosby, Bill) is the enclosing folder for the actual file</p>
<p><strong>Bill</strong> would be the first name</p>
<p><strong>Cosby</strong> would be the last name</p>
<p>The Account field is ommitted</p>
<p><strong>Profile</strong> is the doctype</p>
<p><strong>2006</strong> is the date</p>
<p><strong>doc</strong> is the extension</p>
<p>All of these files are located at this directory /Volumes/HD/Organized Files/ I used terminal and ls to get the list of all the files into a .txt file on my desktop and I am trying to parse the information from the filepaths into categories like in the sample above. Ideally I would like to output to a csv, with a column for each category. Here is my ugly code:    </p>
<pre><code>def main():
    file = open('~/Desktop/client_docs.csv', "rb")
    output = open('~/Desktop/client_docs_parsed.txt', "wb")
    for line in file:
        i = line.find(find_nth(line, '/', 2))
        beghouse = line[i + len(find_nth(line, '/', 2)):]
        endhouse = beghouse.find('/')
        household = beghouse[:endhouse]
        lastn = (line[line.find(household):])[(line[line.find(household):]).find('/') + 1:(line[line.find(household):]).find('.')]
        firstn = line[line.find('.') + 1: line.find('.', line.find('.') + 1)]
        acct = line[line.find('{}.{}.'.format(lastn,firstn)) + len('{}.{}.'.format(lastn,firstn)):line.find('.',line.find('{}.{}.'.format(lastn,firstn)) + len('{}.{}.'.format(lastn,firstn)))]
        doctype_beg = line[line.find('{}.{}.{}.'.format(lastn, firstn, acct)) + len('{}.{}.{}.'.format(lastn, firstn, acct)):]
        doctype = doctype_beg[:doctype_beg.find('.')]
        date_beg = line[line.find('{}/{}.{}.{}.{}.'.format(household,lastn,firstn,acct,doctype)) + len('{}/{}.{}.{}.{}.'.format(household,lastn,firstn,acct,doctype)):]
        date = date_beg[:date_beg.find('.')]
        print '"',household, '"','"',lastn, '"','"',firstn, '"','"',acct, '"','"',doctype, '"','"',date,'"'

def find_nth(body, s_term, n):
    start = body[::-1].find(s_term)
    while start &gt;= 0 and n &gt; 1:
        start = body[::-1].find(s_term, start+len(s_term))
        n -= 1
    return ((body[::-1])[start:])[::-1]

if __name__ == "__main__": main()
</code></pre>
<p>It seems to work ok, but I run into problems when there is another enclosing folder, it then shifts all my fields about.. for example when rather than the file residing at </p>
<p>/Volumes/HD/Organized Files/Cosby, Bill/</p>
<p>its at /Volumes/HD/Organized Files/Resigned/Cosby, Bill/</p>
<p>I know there has got to be a less clunky way to go about this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a tool more practical than your function <code>find_nth()</code> :<br/>
<code>rstrip()</code></p>
<pre><code>def find_nth(body, s_term, n):
    start = body[::-1].find(s_term)
    print '------------------------------------------------'
    print 'body[::-1]\n',body[::-1]
    print '\nstart == %s' % start
    while start &gt;= 0 and n &gt; 1:
        start = body[::-1].find(s_term, start+len(s_term))
        print 'n == %s    start == %s' % (n,start)
        n -= 1
    print '\n (body[::-1])[start:]\n',(body[::-1])[start:]
    print '\n((body[::-1])[start:])[::-1]\n',((body[::-1])[start:])[::-1]
    print '---------------\n'
    return ((body[::-1])[start:])[::-1]


def cool_find_nth(body, s_term, n):
    assert(len(s_term)==1)
    return body.rsplit(s_term,n)[0] + s_term


ss = 'One / Two / Three / Four / Five / Six / End'
print 'the string\n%s\n' % ss

print ('================================\n'
       "find_nth(ss, '/', 3)\n%s" % find_nth(ss, '/', 3) )

print '================================='
print "cool_find_nth(ss, '/', 3)\n%s" % cool_find_nth(ss, '/', 3)
</code></pre>
<p>result</p>
<pre><code>the string
One / Two / Three / Four / Five / Six / End

------------------------------------------------
body[::-1]
dnE / xiS / eviF / ruoF / eerhT / owT / enO

start == 4
n == 3    start == 10
n == 2    start == 17

 (body[::-1])[start:]
/ ruoF / eerhT / owT / enO

((body[::-1])[start:])[::-1]
One / Two / Three / Four /
---------------

================================
find_nth(ss, '/', 3)
One / Two / Three / Four /
=================================
cool_find_nth(ss, '/', 3)
One / Two / Three / Four /
</code></pre>
<h3>EDIT 1</h3>
<p>Here's another very practical tool : regex   </p>
<pre><code>import re

reg = re.compile('/'
                 '([^/.]*?)/'
                 '([^/.]*?)\.'
                 '([^/.]*?)\.'
                 '([^/.]*?)\.'
                 '([^/.]*?)\.'
                 '([^/.]*?)\.'
                 '[^/.]+\Z')

def main():
    #file = open('~/Desktop/client_docs.csv', "rb")
    #output = open('~/Desktop/client_docs_parsed.txt', "wb")
    li = ['/Household/LastName.FirstName.Account.Doctype.Date.extension',
          '- /Volumes/HD/Organized Files/Cosby, Bill/Cosby.Bill..Profile.2006.doc']
    for line in li:
        print "line == %r" % line
        household,lastn,firstn,acct,doctype,date = reg.search(line).groups('')       
        print ('household == %r\n'
               'lastn     == %r\n'
               'firstn    == %r\n'
               'acct      == %r\n'
               'doctype   == %r\n'
               'date      == %r\n'
               % (household,lastn,firstn,acct,doctype,date))

if __name__ == "__main__": main() 
</code></pre>
<p>result</p>
<pre><code>line == '/Household/LastName.FirstName.Account.Doctype.Date.extension'
household == 'Household'
lastn     == 'LastName'
firstn    == 'FirstName'
acct      == 'Account'
doctype   == 'Doctype'
date      == 'Date'

line == '- /Volumes/HD/Organized Files/Cosby, Bill/Cosby.Bill..Profile.2006.doc'
household == 'Cosby, Bill'
lastn     == 'Cosby'
firstn    == 'Bill'
acct      == ''
doctype   == 'Profile'
date      == '2006'
</code></pre>
<h3>EDIT 2</h3>
<p>I wonder where was my brain when I posted my last edit. The following does the job as well:</p>
<pre><code>rig = re.compile('[/.]')
rig.split(line)[-7:-1] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From what I can gather, I believe this will work as a solution, which won't rely on a previously compiled list of files</p>
<pre><code>import csv
import os, os.path

# Replace this with the directory where the household directories are stored.
directory = "home"
output = open("Output.csv", "wb")
csvf = csv.writer(output)

headerRow = ["Household", "Lastname", "Firstname", "Account", "Doctype", 
              "Date", "Extension"]

csvf.writerow(headerRow)

for root, households, files in os.walk(directory):
    for household in households:
        for filename in os.listdir(os.path.join(directory, household)):
            # This will create a record for each filename within the "household"
            # Then will split the filename out, using the "." as a delimiter
            # to get the detail
            csvf.writerow([household] + filename.split("."))
output.flush()
output.close()
</code></pre>
<p>This uses the os library to "walk" the list of households. Then for each "household", it will gather a file listing. It this takes this list, to generate records in a csv file, breaking apart the name of the file, using the period as a delimiter.</p>
<p>It makes use of the csv library to generate the output, which will look somewhat like;</p>
<pre><code>"Household,LastName,Firstname,Account,Doctype,Date,Extension"
</code></pre>
<p>If the extension is not needed, then it can be ommited by changing the line:</p>
<pre><code>csvf.writerow([household] + filename.split("."))
</code></pre>
<p>to</p>
<pre><code>csvf.writerow([household] + filename.split(".")[-1])
</code></pre>
<p>which tells it to only use up until the last part of the filename, then remove the "Extension" string from headerRow.</p>
<p>Hopefully this helps</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a bit unclear what the question is but meanwhile, here is something to get you started:</p>
<pre><code>#!/usr/bin/env python

import os
import csv

with open("f1", "rb") as fin:
    reader = csv.reader(fin, delimiter='.')
    for row in reader:
        # split path
        row = list(os.path.split(row[0])) + row[1:]
        print ','.join(row)
</code></pre>
<p>Output:</p>
<pre><code>/Household,LastName,FirstName,Account,Doctype,Date,extension
</code></pre>
<p>Another interpretation is that you would like to store each field in a parameter
and that an additional path screws things up...</p>
<p>This is what <code>row</code> looks like in the for-loop:</p>
<pre><code>['/Household/LastName', 'FirstName', 'Account', 'Doctype', 'Date', 'extension']
</code></pre>
<p>The solution then might be to work backwards.</p>
<p>Assign <code>row[-1]</code> to <code>extension</code>, <code>row[-2]</code> to <code>date</code> and so on.</p>
</div>
<span class="comment-copy">Hello. I smell here the scent of an XY problem (<a href="http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem" title="what is the xy problem">meta.stackexchange.com/questions/66377/what-is-the-xy-problem</a>) What is your aim ? Getting the right tools to reach your aim is your real (X) problem. Asking this question is the way you try to reach what is your supposed solution (Y)</span>
<span class="comment-copy">You can use <a href="http://docs.python.org/3/library/os.path.html#os.path.basename" rel="nofollow noreferrer">os.path.basename()</a>  to get the base name of a path. Then use <a href="http://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow noreferrer">str.split()</a> to split the name by periods.</span>
<span class="comment-copy">Brandon, I posted an edit yesterday evening. I've also posted a second edit just now. Any news from your side ?</span>
<span class="comment-copy">Just commented on my findings</span>
<span class="comment-copy">The regex solution is along the lines of what I am looking for. However I run into an error when I try to iterate though my file. It seems to not find the pattern and groups() is getting NoneType. Here is an example of some of the files in the txt:</span>
<span class="comment-copy">hello, where is the example , please ?</span>
<span class="comment-copy">-                                                      /Volumes/HD/Organized Files/Cosby, Bill/Cosby.Bill..Profile.2006.doc</span>
<span class="comment-copy">Is <code>- /Volumes/HD/Organized Files/Cosby, Bill/Cosby.Bill..Profile.2006.doc</code> only one filename ? There are two dots in it</span>
<span class="comment-copy">You had written in your question : <i>"files all in the format of: /Household/LastName.FirstName.Account.Doctype.Date.extension"</i> I thought that it was the reason why you used identifiers houshold, firstn, lastn etc . But if the format is variable, you must precise what you want to catch in the filenames and then do with the catched portions</span>
