<div class="post-text" itemprop="text">
<p>In PEP 3107 and <a href="https://stackoverflow.com/a/14379780/455276">this SO answer</a> it is implied that Python3K function annotations and decorators fit hand and glove -- that I should be able to write a decorator that works with function attributes. </p>
<p>I cannot figure how to make them work as I expect however.</p>
<p>Consider:</p>
<pre><code>def verbose(lcls):
    def wrap(f):
        print('inside wrap')
        def wf(*args):
            print('inside wf')
            print('lcls in wf:',lcls)
            print('locals in wf:',locals())
            print('wf annotations:',wf.__annotations__)
            print('xYx annotations:',xXy.__annotations__)
            r=f(*args)
            print('after f(*args)')
            return r
        return wf
    return wrap           

@verbose(locals())    
def xXy(x: 'x in x\'s', y: 'y in Y\'s') -&gt; ('x times y','in x and y units'):
    print('locals in xXy:',locals())
    return x*y

xy=xXy(10,3)    
print(xy)
</code></pre>
<p>Prints:</p>
<pre><code>inside wrap
inside wf
lcls in wf: {'xXy': &lt;function verbose.&lt;locals&gt;.wrap.&lt;locals&gt;.wf at 0x109767ef0&gt;, '__doc__': None, 'verbose': &lt;function verbose at 0x109767050&gt;, '__cached__': None, '__builtins__': &lt;module 'builtins'&gt;, '__package__': None, '__file__': '/private/var/folders/gx/gqtmx9mn7b75pk1gfy0m9w3w0000gp/T/Cleanup At Startup/test-383453350.857.txt', '__loader__': &lt;_frozen_importlib.SourceFileLoader object at 0x10959ac10&gt;, '__name__': '__main__'} 
locals in wf: {'f': &lt;function xXy at 0x109767e60&gt;, 'args': (10, 3), 'lcls': {'xXy': &lt;function verbose.&lt;locals&gt;.wrap.&lt;locals&gt;.wf at 0x109767ef0&gt;, '__doc__': None, 'verbose': &lt;function verbose at 0x109767050&gt;, '__cached__': None, '__builtins__': &lt;module 'builtins'&gt;, '__package__': None, '__file__': '/private/var/folders/gx/gqtmx9mn7b75pk1gfy0m9w3w0000gp/T/Cleanup At Startup/test-383453350.857.txt', '__loader__': &lt;_frozen_importlib.SourceFileLoader object at 0x10959ac10&gt;, '__name__': '__main__'}, 'wf': &lt;function verbose.&lt;locals&gt;.wrap.&lt;locals&gt;.wf at 0x109767ef0&gt;}
wf annotations: {}
xYx annotations: {}
locals in xXy: {'y': 3, 'x': 10}
after f(*args)
30
</code></pre>
<p>What that group of lines shows me is that I cannot see how to access the value of x and y in xXy in the decorator or the function attributes of xXy. </p>
<p>What I would <em>like</em> to do is 1) have a function with annotations as specified in PEP 3107, 2) be able to have a decorator that can access the function annotations and the values the function is called with without just being a clone of of xXy's function signature. </p>
</div>
<div class="post-text" itemprop="text">
<p>New in version 3.3,<a href="http://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow"><code>inspect.signature()</code></a>would allow you get the information you want in a function decorator. Here's an example of using it to print the argument names and values passed on each call to a decorated function as well as access the associated annotations:</p>
<pre><code>import functools
import inspect

def verbose(wrapped):
    @functools.wraps(wrapped)  # optional - make wrapper look like wrapped
    def wrapper(*args):
        print('inside wrapper:')
        fsig = inspect.signature(wrapped)
        parameters = ', '.join('{}={}'.format(*pair)
                               for pair in zip(fsig.parameters, args))
        print('  wrapped call to {}({})'.format(wrapped.__name__, parameters))
        for parameter in fsig.parameters.values():
            print("  {} param's annotation: {!r}".format(parameter.name,
                                                         parameter.annotation))
        result = wrapped(*args)
        print('  returning {!r} with annotation: {!r}'.format(result,
                                                         fsig.return_annotation))
        return result
    return wrapper

@verbose
def xXy(x: 'x in X\'s', y: 'y in Y\'s') -&gt; ('x times y','in X and Y units'):
    return x*y

xy = xXy(10, 3)
print('xXy(10, 3) -&gt; {!r}'.format(xy))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>inside wrapper:
  wrapped call to xXy(x=10, y=3)
  x param's annotation: "x in X's"
  y param's annotation: "y in Y's"
  returning 30 with annotation: ('x times y', 'in X and Y units')
xXy(10, 3) -&gt; 30
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe you are looking for <a href="http://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow"><code>functools.wraps()</code></a>:</p>
<pre><code>def verbose(lcls):
    def wrap(f):
        print('inside wrap')
        @functools.wraps(f)
        def wf(*args):
            print('inside wf')
            print('lcls in wf:',lcls)
            print('locals in wf:',locals())
            print('wf annotations:',wf.__annotations__)
            print('xYx annotations:',xXy.__annotations__)
            r=f(*args)
            print('after f(*args)')
            return r
        return wf
    return wrap       
</code></pre>
<p>This is a simple decorator that ensures that a wrapper function carries the attributes of the function it wraps.</p>
</div>
<span class="comment-copy">Excellent! I was playing with inspect, but I had not quite figured it out yet.</span>
<span class="comment-copy">Just a fyi: <code>inspect.signature</code> was added in Py3.3, so works for the asker. It's not available in Py 3.0-3.2.</span>
<span class="comment-copy">I am working with 3.3, so this works great! Thanks!!</span>
<span class="comment-copy">It only took BDFL <a href="http://www.python.org/dev/peps/pep-0362/#acceptance" rel="nofollow noreferrer">6 years to accept</a> and 1 day to add! :-)</span>
<span class="comment-copy">I love 3.3, it's full of awesome stuff (my personal favourite being <code>yield from</code>).</span>
<span class="comment-copy">That solves the lack of attributes (thanks), but is the value of 'x' and 'y' available in 'wf'? Could I print inside of 'wf' x=10 and y=3?</span>
<span class="comment-copy">@thewolf Yeah, just extract those values from <code>args</code> or change the signature to accept those specific arguments.</span>
