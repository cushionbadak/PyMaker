<div class="post-text" itemprop="text">
<p>I'm quite new to Python and I need to make declare my own data structure, I'm a bit confused on how to do this though. I currently have:</p>
<pre><code>class Particle:

    def __init__(self, mass, position, velocity, force):

        self.mass = mass
        self.position, self.velocity, self.force = position, velocity, force

    def __getitem__(self, mass):
        return self.mass

    def __getitem__(self, position):
        return self.position

    def __getitem__(self, velocity):
        return self.velocity

    def __getitem__(self, force):
        return self.force
</code></pre>
<p>This isn't working, however, when I try to define an instance of the class with:</p>
<pre><code> p1 = Particle(mass, position, velocity, force)
</code></pre>
<p>Every value just ends up as a (0.0, 0.0) (which is the value for velocity and force).</p>
<p>Could someone explain where I'm going wrong, all I need from the data structure is to be able to pull the data out of it, nothing else. (edit: actually, sorry, I will have to change them a bit later on)</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>First off, you should understand that <code>__getitem__</code> is syntactic sugar. It's nice to have, but if you don't need it, don't use it. <code>__getitem__</code> and <code>__setitem__</code> are basically if you want to be able to access items from your object using bracket notation like:</p>
<pre><code>p= Particle(foo)
bar = p[0]
</code></pre>
<p>if you don't need to this, don't worry about it. </p>
<p>Now, onto everything else. It looks like you've got the main characteristics you want your object to carry around in your <code>__init__</code> definition, which is fine. Now you need to actually bind those values onto your object using <code>self</code>:</p>
<pre><code>class Particle:
    def __init__(self, mass, position, velocity, force):
        self.mass = mass
        self.position = position
        self.velocity = velocity
        self.force = force
</code></pre>
<p>That's really it. You can now access these values using dot notation, like so:</p>
<pre><code>mass,pos,vel,f = 0,0,0,0 # just for readability
p = Particle(mass,pos,vel,f)
print p.mass, p.position, p.velocity, p.force
</code></pre>
<p>One of the nice things we get out of this is that if we ask python what <code>p</code> is, it will tell you that it is an instance of the <code>Particle</code> type, like so:</p>
<pre><code>in [1]: p
out[1]: &lt;__main__.Particle instance at 0x03E1fE68&gt;
</code></pre>
<p>In theory, when you work with objects like this you want there to be a "layer of abstraction" between the user and the data such that they don't access or manipulate the data directly. To do this, you create functions (like you tried to do with <code>__getitem__</code>) to mediate interactions between the user and the data through class methods. This is nice, but often not necessary. </p>
<p>In your simpler case, to update the values of these attributes, you can just do it directly the same way we accessed them, with dot notation:</p>
<pre><code>in [2]: p.mass
out[2]: 0

in [3]: p.mass = 2 
in [4]: p.mass
out[4]: 2
</code></pre>
<p>You might have figured this out already, but there's nothing magical about the <code>__init__</code> function, or even the <code>class</code> definition (where you would/should generally be defining most of your class's attributes and methods). Certain kinds of objects are pretty permissive about allowing you to add attributes whenever/wherever you want. This can be convenient, but it's generally very hacky and not good practice. I'm not suggesting that you do this, just showing you that it's possible.</p>
<pre><code>in [5]: p.newattr ='foobar!'
in [6]: p.newattr
out[6]: 'foobar!'
</code></pre>
<p>Weird right? If this makes your skin crawl... well, maybe it should. But it is possible, and who am I to say what you can and can't do. So that's a taste of how classes work.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Particle:
    def __init__(self, mass, position, velocity, force):
        self.mass = mass
        self.position = position
        self.velocity = velocity
        self.force = force

particle = Particle(1, 2, 3, 4)
print(particle.mass)  # 1
</code></pre>
<p>If you want to pretend your class has properties, you can use the <code>@property</code> decorator:</p>
<pre><code>class Particle:
    def __init__(self, mass, position, velocity, force):
        self.mass = mass
        self.position = position
        self.velocity = velocity
        self.force = force

    @property
    def acceleration(self):
        return self.force / self.mass

particle = Particle(2, 3, 3, 8)
print(particle.acceleration)  # 4.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Seems like <code>collections.namedtuple</code> is what you're after:</p>
<pre><code>from collections import namedtuple

Particle = namedtuple('Particle', 'mass position velocity force')
p = Particle(1, 2, 3, 4)
print p.velocity
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can just put this class definition ahead before you use it. If you want to declare it, check this site: <a href="http://www.diveintopython.net/getting_to_know_python/declaring_functions.html" rel="nofollow noreferrer">http://www.diveintopython.net/getting_to_know_python/declaring_functions.html</a></p>
<p>By the way, your question is similar to this post: <a href="https://stackoverflow.com/questions/1590608/is-it-possible-to-forward-declare-a-function-in-python">Is it possible to forward-declare a function in Python?</a>  and also this post: <a href="https://stackoverflow.com/questions/1909325/is-it-possible-to-use-functions-before-declaring-their-body-in-python">Is it possible to use functions before declaring their body in python?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you <strong>just</strong> need to store some attribute values (similar to a C-language <code>struct</code>), you can just do:</p>
<pre><code>class myContainer(object):
    pass  # Do nothing

myContainerObj = myContainer()
myContainerObj.storedAttrib = 5
print myContainerObj.storedAttrib
</code></pre>
</div>
<span class="comment-copy">this works for me as is.</span>
<span class="comment-copy">All of your <code>__getitem__</code> definitions are the same method. You need to check which item is actually being retrieved.</span>
<span class="comment-copy">@askewchan It shouldn't.</span>
<span class="comment-copy">Aside: on dimensional consistency grounds, I'd store acceleration rather than force.</span>
<span class="comment-copy">How do try to access? The way you defined it, <code>p1[&lt;anything&gt;]</code> returns <code>self.force</code>. I'm curious how you imagine to access the different attributes...</span>
<span class="comment-copy">That's great, thanks! Quick follow up question though, how do I change the values after creating an instance of Particle?</span>
<span class="comment-copy">@Incredidave Assignment, as with variables (there are some subtle differences, but most people get along for months without understanding them, so you should be fine ^^): <code>p.mass = new value</code></span>
<span class="comment-copy">@delnan Cool, thanks a lot.</span>
<span class="comment-copy">@Incredidave Updated the post to demo assignment and show you a little black magic</span>
<span class="comment-copy">This is great, thanks. I'm quite new to Python, and I was struggling to find anything decent to describe this. As usual with Python, the answer is simpler than I thought.</span>
<span class="comment-copy">Out of interest, why <i>pretend</i> to have properties, when actually having properties is so easy?</span>
<span class="comment-copy">@delnan Suppose a property is defined by a formula relying on two other properties. If you change one of them (like mass) you'd also have to update acceleration. That probably means buggy or messy code.</span>
<span class="comment-copy">@WaleedKhan I am a Python veteran. When I say "property", I mean the <code>property</code> builtin, preferably used as decorator. Which, as you may or may not know, do exactly that -- just in a better and prettier way.</span>
<span class="comment-copy">@delnan How would I go about making, for example, the above acceleration property using the method you're talking about?</span>
<span class="comment-copy">Only if the attributes don't have to change ever during an object's lifetime, and you're fine with it being a sequence. The neatness of namedtuples also suffers a blow when you need to add methods, or something constructor-like (they're still useful, but require more careful handling and ugly code to make it work well).</span>
<span class="comment-copy">@delnan True, but I'm going by the OP's statement of <code>all I need from the data structure is to be able to pull the data out of it, nothing else.</code></span>
<span class="comment-copy">Yeah, and your answer is alright. It's just that I almost never see those limitations even hinted at, even when important, so I made a habit of mentioning them.</span>
<span class="comment-copy">Ah, crap, I'll change that. I will need to edit them a bit afterwards (my bad!).</span>
<span class="comment-copy">Nah, that's just an awful way to write a dictionary. I am opposed to using the ability to add and remove attributes to objects without very strong reasons. It makes errors harder to spot (sometimes this thing has an attribute, sometimes it hasn't, depending on control flow).</span>
<span class="comment-copy">@delnan I agree in general, but for someone new to Python it's a simple solution and doesn't require an understanding of dictionaries, hashing, and the <code>get()</code> method.  (It's also in the Python tutorial docs: <a href="http://docs.python.org/3/tutorial/classes.html#odds-and-ends" rel="nofollow noreferrer">docs.python.org/3/tutorial/classes.html#odds-and-ends</a>)</span>
<span class="comment-copy">edit: (<i>insert</i>: "<code>get()</code> method to specify a value if the attribute doesn't exist, or some other method to probe if it's been defined").  Personally, I'd rather see a full class with <code>__init__</code> and proper get/set methods for all the properties, but in my (possibly incorrect) opinion, this met the OP's needs.)</span>
