<div class="post-text" itemprop="text">
<p>I'm trying to implement strong type genetic programming in python.</p>
<p>Is there something like these sample?</p>
<pre><code>def funcA(a,b):
  return a + b
return_type(funcA)

output: &lt;class 'Integer'&gt;
</code></pre>
<p>and</p>
<pre><code>def funcA(a,b):
  return a + b
parameter_type(funcA)

output: [&lt;class 'Integer'&gt;,&lt;class 'Integer'&gt;]
</code></pre>
<p>update:</p>
<p>I'm trying to generate python's expression and avoiding something cannot be evaluated like this:</p>
<pre><code>funcA(20, funcA(True, "text"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 introduces function annotations. By themselves they don't do anything, but you can write your own enforcement:</p>
<pre><code>def strict(fun):
    # inspect annotations and check types on call

@strict
def funcA(a: int, b: int) -&gt; int:
    return a + b 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>the best way is to use docstrings to store such information of the function and </p>
<pre><code>In [49]: def funcA(a,b):
   ....:     ''' returns an int '''
   ....:     return int(a+b)
   ....:

In [50]: funcA.__doc__
Out[50]: ' returns an int '
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python return type is not known until the call is performed and <code>return</code> statement is executed. It even can be different in different situations, so a brief answer is "not possible".</p>
<p>If you need to know the return type for certain function, you still may wrap it into some type checking code that also may expose the return type. However, that would be rather unpythonic:</p>
<pre><code>def declare_return_type(t):
    def decorator(f):
        def wrapper(*a, **kw):
            res = f(*a, **kw)
            assert isinstance(res, t)
            return res
        wrapper.return_type = t
        return wrapper
    return decorator

@declare_return_type(int)
def f(a, b):
    return a + b

print f.return_type

print f(1, 2) # ok
f('a', 'b') # Assertion error
</code></pre>
<p><strong>UPD:</strong> You may do the same to parameter types and check them as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, a dynamically and strongly typed language, the type information of a function is required at runtime. In 3.3 and later, you can get the type of a function as follows:</p>
<pre><code>from inspect import signature
def foo(a, *, b:int, **kwargs):
...     pass

sig = signature(foo)

str(sig)
'(a, *, b:int, **kwargs)'

str(sig.parameters['b'])
'b:int'

sig.parameters['b'].annotation
&lt;class 'int'&gt;
</code></pre>
<p>see <a href="https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object" rel="nofollow noreferrer">https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object</a></p>
</div>
<div class="post-text" itemprop="text">
<p>no chance. since python uses duck typing, you could pass parameters of different types, e.g. int and int, str and str, etc. to funcA. there is no chance to tell what return type and parameter type can be without seeing actual parameters</p>
</div>
<div class="post-text" itemprop="text">
<p>This is impossible - your own example proves it, imagine you call it this way:</p>
<pre><code>funcA(1, 2)
</code></pre>
<p>You get <code>3</code>, an Integer, but what about this:</p>
<pre><code>funcA("Test", "Test")
</code></pre>
<p>You get <code>"TestTest"</code>, a string! Python doesn't care about types, and no function is guaranteed to output a single type. This would also produce different results with <code>float</code>s or <code>list</code>s. Beyond that, you could also explicitly return different types of objects.</p>
<p>In general, this is a good thing. It means you don't need to worry about whether or not the type is right, just whether it's possible to do with the things you pass in. This makes Python extremely flexible.</p>
</div>
<span class="comment-copy">Please update your question with the <i>exact problem you are trying to solve, for which you think this is the solution</i>, because in a loosely typed language like Python, this kind of paradigm doesn't make sense. You <i>could</i> do this if you passed around your own objects, but again I wonder the wisdom of such a requirement.</span>
<span class="comment-copy">Again, it's worth noting that type checking is generally a bad idea. It makes your functions less useful, and in general, doesn't really help you. In some, very specific, situations it can be useful, but shouldn't be done as a matter of course - if you want that, write Java instead.</span>
<span class="comment-copy">but It's a good idea for my problem :D It's great to see python can be strong typed, strict typed and dynamic.</span>
<span class="comment-copy">Unfortunately, no check is performed at compilation type, and nothing can be done to it due to nature of the language. I would not say it looks like a classical "strong typed". Of course, you may perform any type checks you would like. But only at execution time.</span>
<span class="comment-copy">@Latty You say type checking is generally a bad idea, but in python isn't duck/polymorphic/lazy typing really popular? Or am I wrong? (Also am I wrong in thinking that duck, polymorphic, and lazy are all synomyms of each other when it comes to typing?)</span>
<span class="comment-copy">@JosieThompson Duck typing means relying on the capabilities of an object (does it have a <code>quack()</code> method?) to determine it's identity (if it does, it's a duck). Type checking is where you check the actual type an object was made from (Is it a <code>Duck</code> object?).</span>
<span class="comment-copy">+1 for docstring, although to be fair you should have <code>return int(a+b)</code>.</span>
<span class="comment-copy">thanks updated :)</span>
<span class="comment-copy">It's worth noting that forcing stuff to be of certain types is a bad idea in Python, as it makes your functions less useful.</span>
