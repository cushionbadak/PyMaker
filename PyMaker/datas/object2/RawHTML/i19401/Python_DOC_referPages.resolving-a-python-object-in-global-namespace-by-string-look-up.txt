<div class="post-text" itemprop="text">
<p>Let's say you want the object at the end of strings of object names: an example string would be <code>'first_class.second_class.third_class.id'</code>, and the list of strings all take the form <code>'X1object.X2object...XNobject.what_you_want_is_here_object'</code>.</p>
<p>In every case, you know that there is an active instance of the X1object, whatever its specific name. With the example string, the code has already called an instance of <code>first_class</code>. You can load <code>first_class</code> with <code>globals['first_class']</code>, and generically load <code>X1object</code> with <code>globals['X1object']</code>.</p>
<p>What you want is the object (usually a value) at then end of the string. So with the example string, you want the value of <code>id = first_class.second_class.third_class.id</code>. Is there an easy way to convert the string so that it fetches its end object?</p>
<p>Below is the code I created to handle this problem, but it seems like a brute force approach that fetches each attribute in turn until it finds the last one.</p>
<pre><code>first_class = FirstClass()
first_class = go_do_something_wild_in_first_class(first_class)
...

attribute = 'first_class.second_class.third_class.id'
attribute_pieces = attribute.split('.')

fetch_attribute = lambda attribute, name: \
    attribute[name] if attribute == globals() else \
    getattr(attribute, name)

for name in attribute_pieces: # I changed the code from using an index to using a name
    if name == attribute_pieces[0]:
        attribute = fetch_attribute(globals(), name)
    else:
        attribute = fetch_attribute(attribute, name)

id = attribute
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/3/library/functions.html#reduce" rel="nofollow"><code>reduce()</code></a>:</p>
<pre><code>def resolve_object(name):
    names = name.split('.')
    return reduce(getattr, names[1:], globals()[names[0]])
</code></pre>
<p>Here we simply look up <code>names[0]</code> as a global, then loop over the rest of the names to do a <code>getattr</code> for each one on the result so far.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class Foo(object): pass
... 
&gt;&gt;&gt; first_class = Foo()
&gt;&gt;&gt; first_class.second_class = Foo()
&gt;&gt;&gt; first_class.second_class.third_class = Foo
&gt;&gt;&gt; first_class.second_class.third_class.id = 'baz'
&gt;&gt;&gt; resolve_object('first_class.second_class.third_class.id')
'baz'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is a Python library called zope.dottedname which does exactly what you want:</p>
<p><a href="https://pypi.python.org/pypi/zope.dottedname" rel="nofollow">https://pypi.python.org/pypi/zope.dottedname</a></p>
<p>It resolves arbitrary strings to corresponding objects in Python namespace, including attributes of objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use <a href="http://docs.python.org/2/library/importlib.html" rel="nofollow">importlib</a></p>
<pre><code>attribute = 'first_class.second_class.third_class.id'
attribute_pieces = attribute.split('.')

id = getattr(importlib.import_module('.'.join(attribute_pieces[:-1]), attribute_pieces[-1])
</code></pre>
</div>
<span class="comment-copy">You want an actual instance of class X? And what is the actual goal? Because there might be an easier solution.</span>
<span class="comment-copy">i have a list of strings like <code>'first_class.second_class.third_class.id'</code>. And I want to iterate over the list and return the final object as if I were writing <code>id = first_class.second_class.third_class.id</code>. The input is a string, and the output is the actual object which would be called.</span>
