<div class="post-text" itemprop="text">
<p>I would like to stop a Python thread when the main program stops. It is for a class that connects to a server. The connection is maintained by the background thread, the foreground thread answers to callbacks. The following is a minimal example. </p>
<pre><code>#!/usr/bin/python
import time, threading
class test():
    running = False
    def __init__(self):
        print "init"
        self.running = True
        self.thread = threading.Thread(target = self.startThread)
        self.thread.start()

    def __del__(self):
        running = False
        print "del"

    def startThread(self):
        print "thread start"
        while self.running:
            time.sleep(1)
            print "thread running"

a = test()
</code></pre>
<p>When the program ends, I would naively expect __del__() to be called so that the background thread can be informed to stop, but i is not called untill after the background thread stops. Explicitly calling some function is not an option since the class is used by other people, whom I do not want to force to use some extra lines of code.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__del__</code> is not called as long as there are references to <code>self</code>, and you have one such reference in the background thread itself: in the <code>self</code> argument of <code>def startThread(self):</code>.</p>
<p>You need to move the function that runs the background thread outside of the class.  And rather than a <code>__del__</code> I would recommend for example using a weakref, as follows.  This code should work without the <code>__del__()</code> method and without using a <code>self.running</code> attribute.</p>
<pre><code>self.thread = threading.Thread(target=run_me, args=(weakref.ref(self),))
...
def run_me(weak_self):
    "Global function"
    while True:
        self = weak_self()
        if self is None: break    # no more reference to self
        ...
        del self        # forget this reference for now
        time.sleep(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I was facing the same problem and finally found the answer to this question in the answer to another <a href="https://stackoverflow.com/a/2564282/3468437">question</a>.</p>
<p>Use the <code>daemon = True</code> flag. Documentation for <a href="https://docs.python.org/3/library/threading.html#threading.Thread.daemon" rel="nofollow noreferrer">3.x</a> and <a href="https://docs.python.org/2/library/threading.html#threading.Thread.daemon" rel="nofollow noreferrer">2.x</a></p>
<p>So your code would be this:</p>
<pre><code>#!/usr/bin/python
import time, threading

class test():
    def __init__(self):
        print "init"
        self.thread = threading.Thread(target = self.startThread)
        self.thread.daemon = True
        self.thread.start()

    def startThread(self):
        print "thread start"
        while True:
            time.sleep(1)
            print("thread running")

a = test()
</code></pre>
<p><strong>Remark</strong>: this is propably not cleanly ending your thread, but it stops it when you exit your program, I guess this is what you were looking for.</p>
</div>
<div class="post-text" itemprop="text">
<p>As per gnibbler's comment, it may be better to use a context manager for explicit resource deallocation.  Opinions appear to vary on whether <code>__del__</code> should be used for resource deallocation.  A couple of good posts on the subject are <a href="http://eli.thegreenplace.net/2009/06/12/safely-using-destructors-in-python/" rel="nofollow">here</a> and <a href="http://www.electricmonk.nl/log/2008/07/07/python-destructor-and-garbage-collection-notes/" rel="nofollow">here</a>.</p>
<p>If you're used to a language like C++ where <a href="http://en.wikipedia.org/wiki/RAII" rel="nofollow">RAII</a> is used, it's sometimes a bit difficult to get accustomed to the idea that destructors in Python may not be called when you expect, if at all, usually because of how reference counting and garbage collection works.</p>
<p>So, the usual approach in Python is to use a context manager which can be used to provide explicit deallocation of resource.</p>
<p>A simple threading example might look like this (untested):</p>
<pre><code>#!/usr/bin/python
import time, threading

class test():
    def __init__(self):
        print "init"
        self.stop_event = threading.Event()
        self.thread = threading.Thread(target = self.startThread)
        self.thread.start()

    def startThread(self):
        print "thread start"
        while not self.stop_event.isSet():
            time.sleep(1)
            print "thread running"

    def close(self):
        # Request thread to stop.
        self.stop_event.set()
        # Wait for thread to exit.
        self.thread.join()

    def __enter__(self):
        # Nothing to do, thread already started.  Could start
        # thread here to enforce use of context manager.

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()
</code></pre>
<p>The <code>test()</code> class is then used like this in a context manager:</p>
<pre><code>with test():
    # Thread will be active here.
    pass

# Thread will have been stopped and joined.
</code></pre>
<p>or, use the Python <a href="http://docs.python.org/2/library/contextlib.html#contextlib.closing" rel="nofollow">contextlib.closing</a> helper function which will ensure that <code>close</code> is called on exit.</p>
<pre><code>import contextlib

with contextlib.closing(test()):
    # Thread will be active here.
# But not here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You forgot to change the "running" variable of your current test() instance, in your <strong>del</strong> function. It should be</p>
<pre><code> def __del__(self):
        self.running = False
        print "del"
</code></pre>
<p>That should do the trick.</p>
</div>
<span class="comment-copy"><code>__del__</code> is not the way to do this. You should use a context manager</span>
<span class="comment-copy">true, but that would require me to change the calling code. Is there a way to do it without changing the calling code (<code>a = test()</code>)</span>
<span class="comment-copy">This helps partly, but it does not do what I wanted it to do.   Although explicitly deleting the instance of the test object <code>del a</code> now stops the code and calls the destructor, the object is not deleted when the program simply reaches the end, and also it still does not respond to ctrl-c.</span>
<span class="comment-copy">This does what I want, but requires the user of my class to put his entire program in a contextmanager block. That is not an option.</span>
<span class="comment-copy">Using a context manager <i>is</i> the correct way to guarantee resource clean up, irrespective of how you want users to use your class.  You are not guaranteed when or if <code>__del__</code> will be called, especially in implementations other than CPython.  There are many posts on SO which provide useful explanations on why.  You could use <code>setDaemon(True)</code> on your thread, but this will not guarantee clean exit of your thread.</span>
<span class="comment-copy">no, it wouldn't. <code>__del__</code> is never called</span>
<span class="comment-copy">Maybe you can call it explicitly?</span>
<span class="comment-copy">@knight Not pythonic, <code>__del__</code> must never be called explicitly, it's an internal Python method.</span>
