<div class="post-text" itemprop="text">
<p>I would like to know what is the python way of initializing a class member but only when accessing it, if accessed.
I tried the code below and it is working but is there something simpler than that?</p>
<pre><code>class MyClass(object):

    _MY_DATA = None

    @staticmethod
    def _retrieve_my_data():
        my_data = ...  # costly database call
        return my_data

    @classmethod
    def get_my_data(cls):
        if cls._MY_DATA is None:
            cls._MY_DATA = MyClass._retrieve_my_data()
        return cls._MY_DATA
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="http://docs.python.org/3/library/functions.html#property" rel="noreferrer"><code>@property</code></a> on <a href="http://docs.python.org/3/reference/datamodel.html#customizing-class-creation" rel="noreferrer">the metaclass</a> instead:</p>
<pre><code>class MyMetaClass(type):
    @property
    def my_data(cls):
        if getattr(cls, '_MY_DATA', None) is None:
            my_data = ...  # costly database call
            cls._MY_DATA = my_data
        return cls._MY_DATA


class MyClass(metaclass=MyMetaClass):
    # ...
</code></pre>
<p>This makes <code>my_data</code> an attribute on the class, so the expensive database call is postponed until you try to access <code>MyClass.my_data</code>. The result of the database call is cached by storing it in <code>MyClass._MY_DATA</code>, the call is only made <em>once</em> for the class.</p>
<p>For Python 2, use <code>class MyClass(object):</code> and add a <a href="https://docs.python.org/2/reference/datamodel.html#metaclasses" rel="noreferrer"><code>__metaclass__ = MyMetaClass</code> attribute</a> in the class definition body to attach the metaclass.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class MyMetaClass(type):
...     @property
...     def my_data(cls):
...         if getattr(cls, '_MY_DATA', None) is None:
...             print("costly database call executing")
...             my_data = 'bar'
...             cls._MY_DATA = my_data
...         return cls._MY_DATA
... 
&gt;&gt;&gt; class MyClass(metaclass=MyMetaClass):
...     pass
... 
&gt;&gt;&gt; MyClass.my_data
costly database call executing
'bar'
&gt;&gt;&gt; MyClass.my_data
'bar'
</code></pre>
<p>This works because a data descriptor like <code>property</code> is looked up on the parent type of an object; for classes that's <code>type</code>, and <code>type</code> can be extended by using metaclasses.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach to make the code cleaner is to write a wrapper function that does the desired logic:</p>
<pre><code>def memoize(f):
    def wrapped(*args, **kwargs):
        if hasattr(wrapped, '_cached_val'):
            return wrapped._cached_val
        result = f(*args, **kwargs)
        wrapped._cached_val = result
        return result
    return wrapped
</code></pre>
<p>You can use it as follows:</p>
<pre><code>@memoize
def expensive_function():
    print "Computing expensive function..."
    import time
    time.sleep(1)
    return 400

print expensive_function()
print expensive_function()
print expensive_function()
</code></pre>
<p>Which outputs:</p>
<pre><code>Computing expensive function...
400
400
400
</code></pre>
<p>Now your classmethod would look as follows, for example:</p>
<pre><code>class MyClass(object):
        @classmethod
        @memoize
        def retrieve_data(cls):
            print "Computing data"
            import time
            time.sleep(1) #costly DB call
            my_data = 40
            return my_data

print MyClass.retrieve_data()
print MyClass.retrieve_data()
print MyClass.retrieve_data()
</code></pre>
<p>Output:</p>
<pre><code>Computing data
40
40
40
</code></pre>
<p>Note that this will cache just one value for any set of arguments to the function, so if you want to compute different values depending on input values, you'll have to make <code>memoize</code> a bit more complicated.</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer is for a typical <strong>instance attribute/method only</strong>, not for a class attribute/<code>classmethod</code>, or <code>staticmethod</code>.</p>
<p>How about using both <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer"><code>property</code></a> and <a href="https://docs.python.org/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>lru_cache</code></a> decorators? The latter memoizes.</p>
<pre><code>from functools import lru_cache

class MyClass:

    @property
    @lru_cache()
    def my_lazy_attr(self):
        print('Initializing and caching attribute, once per class instance.')
        return 7**7**8
</code></pre>
<p>Note that this requires Python â‰¥3.2.</p>
<p>Credit: <a href="https://stackoverflow.com/a/19979379/832230">answer</a> by Maxime R.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider the pip-installable <a href="https://pypi.org/project/Dickens/" rel="nofollow noreferrer"><code>Dickens</code></a> package which is available for Python 3.5+. It has a <code>descriptors</code> package which provides the relevant <strong><code>cachedproperty</code></strong> and <strong><code>cachedclassproperty</code></strong> decorators, the usage of which is shown in the example below. It seems to work as expected.</p>
<pre><code>from descriptors import cachedproperty, classproperty, cachedclassproperty

class MyClass:
    FOO = 'A'

    def __init__(self):
        self.bar = 'B'

    @cachedproperty
    def my_cached_instance_attr(self):
        print('Initializing and caching attribute, once per class instance.')
        return self.bar * 2

    @cachedclassproperty
    def my_cached_class_attr(cls):
        print('Initializing and caching attribute, once per class.')
        return cls.FOO * 3

    @classproperty
    def my_class_property(cls):
        print('Calculating attribute without caching.')
        return cls.FOO + 'C'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>Ring</code> gives <code>lru_cache</code>-like interface but including any kind of descriptor supports: <a href="https://ring-cache.readthedocs.io/en/latest/quickstart.html#method-classmethod-staticmethod" rel="nofollow noreferrer">https://ring-cache.readthedocs.io/en/latest/quickstart.html#method-classmethod-staticmethod</a></p>
<pre><code>class Page(object):
    (...)

    @ring.dict({})
    @classmethod
    def class_content(cls):
        return cls.base_content

    @ring.dict({})
    @staticmethod
    def example_dot_com():
        return requests.get('http://example.com').content
</code></pre>
<p>See the link for more details. Note that the example is not LRU.</p>
</div>
<span class="comment-copy">note that this works at the instance-level, though Etienne wanted something at the class-level. It seems you can't combine properties and classmethods easily.</span>
<span class="comment-copy">@Claudiu: ah, right, that's a challenge.</span>
<span class="comment-copy">Ok, but I don't want to cache the result for a particular instance. Instead, I want to cache the result for the class itself because the value is the same for all instances.</span>
<span class="comment-copy">@EtienneRouxel: updated when I realized my misunderstanding.</span>
<span class="comment-copy">@EtienneRouxel: Exactly, and to make <code>my_data</code> work as an attribute on the class. A property is a <a href="http://docs.python.org/2/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">data descriptor</a> and thus will <i>only</i> work as a class attribute if it is defined on the metaclass.</span>
