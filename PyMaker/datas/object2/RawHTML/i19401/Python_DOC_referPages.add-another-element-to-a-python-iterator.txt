<div class="post-text" itemprop="text">
<p>I get an object <em>oData</em> (classed as an iterable object) in python via some blackbox function:</p>
<pre><code>oData = someFunction()
</code></pre>
<p>When I do this:</p>
<pre><code>HttpResponse( oData )
</code></pre>
<p>I get:</p>
<pre><code>{'A':0.0, 'B':1.0, 'C':1.0 }
</code></pre>
<p>I can't do</p>
<pre><code>HttpResponse( type(oData) ) 
</code></pre>
<p>I just get a 500 server error. Why is this not just a string? How do I get this to output the info I need? Anyway that is secondary. </p>
<p><strong>Ultimately what I want to do is have oData as a dictionary object so I can add one element to it like so:</strong></p>
<pre><code>{ 'A':0.0, 'B':1.0, 'C':1.0, 'New':'myValue' }
</code></pre>
<p><strong>How do I do that?</strong> </p>
<p>----- Edit: just to clarify some things... (and also omitted some irrelevant info above)</p>
<p>oData is indeed an immutable object with a definition for an <code>__iter__()</code> method.
The answer I seek would probably involve cloning its data somehow so that I can append to it.
I've tried this with no luck</p>
<pre><code>oCopy = ( i for i in oData )
</code></pre>
<p>In PHP I would simply gather the key-value pairs and store them into an associative array. </p>
</div>
<div class="post-text" itemprop="text">
<p>When you call <code>type(oData)</code>, you get - unsurprisingly - a <a href="http://docs.python.org/3/library/functions.html#type" rel="nofollow"><code>type</code></a> object, which is not iterable (what would that even mean?).</p>
<p>You want a string representation of that object. Use <a href="http://docs.python.org/3/library/functions.html#str" rel="nofollow"><code>str</code></a> for that:</p>
<pre><code>HttpResponse( str(type(oData)) ) 
</code></pre>
<p>will get you the name of the type, and</p>
<pre><code>oData['New'] = 'myValue'
HttpResponse( str(oData) )
</code></pre>
<p>will return something like</p>
<pre><code>{ 'A':0.0, 'B':1.0, 'C':1.0, 'New':'myValue' }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on your comment on another answer, I'm betting <code>oData</code> is a list of <a href="http://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow"><code>namedtuple</code></a>s and that <code>HttpResponse</code> is doing some kind of magic to convert it to the result you see. Observe this demonstration, which gives the same error you mentioned:</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; X = namedtuple('X', ['A', 'B', 'C'])
&gt;&gt;&gt; x = X(1,2,3)
&gt;&gt;&gt; dict([x])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: dictionary update sequence element #0 has length 3; 2 is required
</code></pre>
<p>That would explain why you can't modify it. Tuples, named or any other kind, are immutable.</p>
<p>The simplest way I can think of to convert it to a <code>dict</code> is to make use of <a href="http://docs.python.org/2/library/functions.html#vars" rel="nofollow"><code>vars</code></a></p>
<pre><code>&gt;&gt;&gt; dict(vars(x))
{'A': 1, 'C': 3, 'B': 2}
</code></pre>
<p>Since <code>someFunction</code> returns an iterable, you'll need to iterate over each element to turn all rows into <code>dict</code>s:</p>
<pre><code>oDataDicts = [dict(vars(r)) for r in oData]
</code></pre>
<p>You could try to extract the first element instead if you expect 1, but that would mean more code handling the case when there's not 1.</p>
<p>Normally, calling <code>vars</code> returns a <code>dict</code>, but for <code>namedtuple</code>, it seems to return an <a href="http://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow"><code>OrderedDict</code></a>. If the <code>OrderedDict</code> doesn't bother you, you can leave off the extra call to <code>dict</code>.</p>
<p>Additionally, I would highly recommend you be a bit more explicit about the output you want to include in your response. Relying on <code>HttpResponse</code>'s behavior will probably make it more difficult to remember what the code is supposed to do later on. If you want to send a JSON response, explicitly converting it to JSON would be a good idea.</p>
</div>
<span class="comment-copy">If you don't understand how the language works, learn. Don't blame the language.</span>
<span class="comment-copy">What do <code>oData</code>, <code>type(oData)</code> and <code>list(oData)</code> look like?</span>
<span class="comment-copy">Awesome. Thanks for the advice. So please teach me.</span>
<span class="comment-copy">@ Blender, I can't print them directly. It is running inside a Django web server. But Print and HttpResponse ought to have the same behaviour, imo.</span>
<span class="comment-copy">@Octopus If you wanted to inspect the result of <code>type(oData)</code> you need to either use the <code>str(...)</code> method to get a string representation of the object, or access the <code>.__name__</code> property to get the type name.</span>
<span class="comment-copy">str(type(oData)) gave me some info i wanted. my question though, is how to i transform the iterable oData at the beginning to the one at the end?</span>
<span class="comment-copy">Sorry, what exactly do you mean with beginning and end? If <code>oData</code> is not a <code>dict</code>, you must either consult its documentation on how to assign values, or call <code>dict(oData)</code> to create a dict from <code>oData</code>s contents.</span>
<span class="comment-copy">oData is actually a set of data as retrieved from a database. in this case it is a single row with three columns. when I go dict(oData) I get: "dictionary update sequence element #0 has length 3; 2 is required", but yes, all i want to do isconvert it to a  dictionary so i can append to it as i would to a dictionary.</span>
<span class="comment-copy">@Octopus Well, can you show us the code or documentation to whatever is generating that set? <code>dict</code> supports a set of tuples, but it looks like that class is something else.</span>
<span class="comment-copy">@Octopus My answer has undergone several revisions. Think I figured out your problem, but I wanted to make sure you got notified in case you looked at an older version.</span>
<span class="comment-copy">@jpmc, I think the magic is not in the HttpResponse method but in the oData object's implementation of an <b>iter</b> function. I have editted the answer somewhat to hopefully make my situation more understandable. I will try dict(vars(oData)) tomorrow from work. It might be the answer I am after.</span>
<span class="comment-copy">That could be the case, but I think it's more likely that the magic is in the definition of the objects contained in the iterable.</span>
<span class="comment-copy">I feel like an idiot. If they're named tuples, they can't have that kind of logic.</span>
