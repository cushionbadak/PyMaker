<div class="post-text" itemprop="text">
<p>I have two lists say </p>
<pre><code>List1 = ['a','c','c']
List2 = ['x','b','a','x','c','y','c']
</code></pre>
<p>Now I want to find out if all elements of List1 are there in List2. In this case all there are. I can't use the subset function because I can have repeated elements in lists. I can use a for loop to count the number of occurrences of each item in List1 and see if it is less than or equal to the number of occurrences in List2. Is there a better way to do this?</p>
<p>Thanks. </p>
</div>
<div class="post-text" itemprop="text">
<p>When number of occurrences doesn't matter, you can still use the subset functionality, by creating a set on the fly:</p>
<pre><code>&gt;&gt;&gt; list1 = ['a', 'c', 'c']
&gt;&gt;&gt; list2 = ['x', 'b', 'a', 'x', 'c', 'y', 'c']
&gt;&gt;&gt; set(list1) &lt; set(list2)
True
</code></pre>
<p>If you need to check if each element shows up at least as many times in the second list as in the first list, you can make use of the Counter type and define your own subset relation:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; def counterSubset(list1, list2):
        c1, c2 = Counter(list1), Counter(list2)
        for k, n in c1.items():
            if n &gt; c2[k]:
                return False
        return True

&gt;&gt;&gt; counterSubset(list1, list2)
True
&gt;&gt;&gt; counterSubset(list1 + ['a'], list2)
False
&gt;&gt;&gt; counterSubset(list1 + ['z'], list2)
False
</code></pre>
<p>If you already have counters (which might be a useful alternative to store your data anyway), you can also just write this as a single line:</p>
<pre><code>&gt;&gt;&gt; all(n &lt;= c2[k] for k, n in c1.items())
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Be aware of the following:</p>
<pre><code>&gt;&gt;&gt;listA = ['a', 'a', 'b','b','b','c']
&gt;&gt;&gt;listB = ['b', 'a','a','b','c','d']
&gt;&gt;&gt;all(item in listB for item in listA)
True
</code></pre>
<p>If you read the "all" line as you would in English, This is not wrong but can be misleading, as listA has a third 'b' but listB does not. </p>
<p>This also has the same issue:</p>
<pre><code>def list1InList2(list1, list2):
    for item in list1:
        if item not in list2:
            return False
    return True
</code></pre>
<p>Just a note. The following does not work:</p>
<pre><code>&gt;&gt;&gt;tupA = (1,2,3,4,5,6,7,8,9)
&gt;&gt;&gt;tupB = (1,2,3,4,5,6,6,7,8,9)
&gt;&gt;&gt;set(tupA) &lt; set(TupB)
False
</code></pre>
<p>If you convert the tuples to lists it still does not work. I don't know why strings work but ints do not.</p>
<p>Works but has same issue of not keeping count of element occurances:</p>
<pre><code>&gt;&gt;&gt;set(tupA).issubset(set(tupB))
True
</code></pre>
<p>Using sets is not a comprehensive solution for multi-occurrance element matching.</p>
<p>But here is a one-liner solution/adaption to shantanoo's answer without try/except:</p>
<pre><code>all(True if sequenceA.count(item) &lt;= sequenceB.count(item) else False for item in sequenceA)
</code></pre>
<p>A builtin function wrapping a list comprehension using a ternary conditional operator. Python is awesome! Note that the "&lt;=" should not be "==".</p>
<p>With this solution sequence A and B can be type tuple and list and other "sequences" with "count" methods. The elements in both sequences can be most types. I would not use this with dicts as it is now, hence the use "sequence" instead of "iterable".</p>
</div>
<div class="post-text" itemprop="text">
<p>A solution using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter</a> and the builtin intersection method (note that <code>-</code> is proper multiset difference, not an element-wise subtraction):</p>
<pre><code>from collections import Counter

def is_subset(l1, l2):
    c1, c2 = Counter(l1), Counter(l2)
    return not c1 - c2
</code></pre>
<p>Test:</p>
<pre><code>&gt;&gt;&gt; List1 = ['a','c','c']
&gt;&gt;&gt; List2 = ['x','b','a','x','c','y','c']
&gt;&gt;&gt; is_subset(List1, List2)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I can't use the subset function because I can have repeated elements in lists.</p>
</blockquote>
<p>What this means is that you want to treat your lists as <a href="https://en.wikipedia.org/wiki/Multiset" rel="nofollow noreferrer"><em>multisets</em></a> rather than <em>sets</em>. The usual way to handle multisets in Python is with <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>:</p>
<blockquote>
<p>A <code>Counter</code> is a dict subclass for counting hashable objects. It is an unordered collection where elements are stored as dictionary keys and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or negative counts. <strong>The <code>Counter</code> class is similar to bags or multisets in other languages.</strong></p>
</blockquote>
<p>And, while you <em>can</em> implement subset for multisets (implemented with <code>Counter</code>) by looping and comparing counts, as in <a href="https://stackoverflow.com/a/15147825/908494">poke's answer</a>, this is unnecessary—just as you <em>can</em> implement subset for sets (implemented with <code>set</code> or <code>frozenset</code>) by looping and testing <code>in</code>, but it's unnecessary.</p>
<p>The <code>Counter</code> type already implements all the set operators extended in the obvious way for multisets.<sup>&lt;1</sup> So you can just write subset in terms of those operators, and it will work for both <code>set</code> and <code>Counter</code> out of the box.</p>
<p>With (multi)set difference:<sup>2</sup></p>
<pre><code>def is_subset(c1, c2):
    return not c1 - c2
</code></pre>
<p>Or with (multi)set intersection:</p>
<pre><code>def is_subset(c1, c2):
    def c1 &amp; c2 == c1
</code></pre>
<hr/>
<p><sub>1. You may be wondering why, if <code>Counter</code> implements the set operators, it doesn't just implement <code>&lt;</code> and <code>&lt;=</code> for proper subset and subset. Although I can't find the email thread, I'm pretty sure this was discussed, and the answer was that "the set operators" are defined as the specific set of operators defined in the initial version of <code>collections.abc.Set</code> (which has since been expanded, IIRC…), not all operators that <code>set</code> happens to include for convenience, in the exact same way that <code>Counter</code> doesn't have named methods like <code>intersection</code> that's friendly to other types than <code>&amp;</code> just because <code>set</code> does.</sub></p>
<p><sub>2. This depends on the fact that collections in Python are expected to be falsey when empty and truthy otherwise. This is documented <a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="nofollow noreferrer">here</a> for the builtin types, and the fact that <code>bool</code> tests fall back to <code>len</code> is explained <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="nofollow noreferrer">here</a>—but it's ultimately just a convention, so that "quasi-collections" like numpy arrays can violate it if they have a good reason. It holds for "real collections" like <code>Counter</code>, <code>OrderedDict</code>, etc. If you're really worried about that, you can write <code>len(c1 - c2) == 0</code>, but note that this is against the spirit of <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP 8</a>.</sub></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def check_subset(list1, list2):
    try:
        [list2.remove(x) for x in list1]
        return 'all elements in list1 are in list2'
    except:
        return 'some elements in list1 are not in list2'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will return true is all the items in List1 are in List2</p>
<pre><code>def list1InList2(list1, list2):
    for item in list1:
        if item not in list2:
            return False
    return True
</code></pre>
</div>
<span class="comment-copy">Hi, the second part is what I was trying to do. Looks like it is the only way to go. Thanks!</span>
<span class="comment-copy">Does it  fails in case of <code>['s','e','r','','','','y']</code> and <code>['','','','y']</code></span>
<span class="comment-copy">@SIslam Depends on the order. The second list is a subset of the former list, so the solution in my answer would correctly recognize it.</span>
<span class="comment-copy">This will return False if the lists are identical. However, set(list1) &lt;= set(list2) will return True if they are equal.</span>
<span class="comment-copy">@Aran-Fey I don't think it's unreadable once you consider that <code>Counter</code>s are multisets. But I think fferri's intersection-based answer is even more obvious as a multiset operation (and I'm not sure why fferri <a href="https://stackoverflow.com/a/50180652/908494">copied my difference answer</a> instead of their own, better, intersection answer, from the duplicate question… but <a href="https://stackoverflow.com/a/50181126/908494">I gave both of them in mine</a>.</span>
<span class="comment-copy">I'm not the downvoter, but you should really take a look at <a href="http://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP 8</a>. Your <code>if</code> syntax is off, you have an unneeded semicolon, and your variable naming style should be reserved for classes.</span>
<span class="comment-copy">Also, this can be reduced to a single line: <code>all(item in List2 for item in List1)</code>.</span>
<span class="comment-copy">I used List1 and List2 as variable names because that's what was in the question, and it has been a while since I've used python so I'll admit the semicolons and parentheses around the if were my bad</span>
<span class="comment-copy">If you are aware of your answer being factually wrong, the sensible thing to do is edit it to correct the mistakes (verify in an interpreter to be on the safe side) - or you could delete your own answer. It's a common theme to actively downvote obvious incorrect answers to prevent other users from wasting time. Take comments as an incentive to improve. Always look at the bright side! ...and: Welcome to SO!</span>
<span class="comment-copy">Thank you, As you've probably noticed I am new to the site so I'll probably be making a few mistakes like not editing (hopefully not more than once)</span>
