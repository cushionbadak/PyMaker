<div class="post-text" itemprop="text">
<p>I understand a few things based on the following link (I could be wrong!):</p>
<p><a href="http://docs.python.org/2/glossary.html#term-bytecode" rel="nofollow">http://docs.python.org/2/glossary.html#term-bytecode</a></p>
<ol>
<li><p><code>.pyc</code> is a cached file and is only generated if the module is imported somewhere else</p></li>
<li><p><code>.pyc</code> is to help loading performance, not execution performance.</p></li>
<li><p>running <code>python foo.py</code> does not generate <code>foo.pyc</code> unless <code>foo</code> is imported somewhere.</p></li>
<li><p>Python has a bytecode compiler (used to generate <code>.pyc</code>)</p></li>
<li><p>Python's virtual machine executes byte-code.</p></li>
</ol>
<p>So, when I run <code>python foo.py</code>, if <code>foo.py</code> is not imported anywhere, does Python actually create an in-memory bytecode?</p>
<p>The missing <code>.pyc</code> seems to break the idea of Python VM.</p>
<p>This question is extended to code execution in Python interpreter (running <code>python</code> in the terminal). I believe CPython (or just about any language implementation) can't do pure interpretation. </p>
<p>I think the core of the question is: Does the VM actually read the <code>.pyc</code> file? I assume VM loads the <code>.pyc</code> into the execution environment.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your points 1 to 5 are correct, with the exception (if we're precise) of the point 4.  The Python interpreter has a part called the bytecode compiler that turns source code into <code>&lt;code object at 0x...&gt;</code>, which you can inspect by typing <code>f.__code__</code> for any function <code>f</code>.  This is the real bytecode that is interpreted.  These code objects may then, as a separate step, be saved inside <code>.pyc</code> files.</p>
<p>Here are the operations in more details.  The bytecode compiler runs only once per module, when you load the <code>foo.py</code> and each of the modules it imports.  It's not a too long operation, but it still takes some time, particularly if your module imports a lot of other modules.  This is where <code>.pyc</code> files enter the picture.  After an <code>import</code> statement has invoked the bytecode compiler, it tries to save the resulting <code>&lt;code object&gt;</code> inside a <code>.pyc</code> file.  The next time, if the <code>.pyc</code> file already exists and the <code>.py</code> file has not been modified, the <code>&lt;code object&gt;</code> is reloaded from there.  This is just an optimization: it avoids the cost of invoking the bytecode compiler.  In both cases the result is the same: a <code>&lt;code object&gt;</code> was created in memory and is going to be interpreted.</p>
<p>It only works for <code>import</code> statements, not for example for the main module (i.e. the <code>foo.py</code> in the command line <code>python foo.py</code>).  The idea is that it should not really matter --- where the bytecode compiler would loose time in a typical medium-to-large program is in compiling all directly and indirectly imported modules, not just compiling <code>foo.py</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Interesting ... the first thing I did was call for <code>--help</code></p>
<pre><code>$ python --help
usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...
Options and arguments (and corresponding environment variables):
-B     : don't write .py[co] files on import; also PYTHONDONTWRITEBYTECODE=x
...
</code></pre>
<p>and the first option I see is to disable automatic pyc and pyo file generation on import, though thats probably cause its alphabetical order.</p>
<p>lets run some tests </p>
<pre><code>$ echo "print 'hello world'" &gt; test.py
$ python test.py 
hello world
$ ls test.py*
test.py
$ python -c "import test"
hello world
$ ls test.py*
test.py     test.pyc
</code></pre>
<p>so it only generated the pyc file when it was imported.</p>
<p>now in order to check which files are being used I'll use OS X dtruss similar to linux truss to do a full trace ... </p>
<pre><code>$ echo '#!/bin/sh 
 python test.py' &gt; test.sh 
$ chmod a+x test.sh
$ sudo dtruss -a ./test.sh 2&gt;&amp;1 | grep "test.py*"
975/0x5713:    244829       6      3 read(0x3, "#!/bin/sh \npython test.py\n\b\0", 0x50)         = 26 0
975/0x5713:    244874       4      2 read(0xFF, "#!/bin/sh \npython test.py\n\b\0", 0x1A)        = 26 0
977/0x5729:    658694       6      2 readlink("test.py\0", 0x7FFF5636E360, 0x400)        = -1 Err#22
977/0x5729:    658726      10      6 getattrlist("/Users/samyvilar/test.py\0", 0x7FFF7C0EE510, 0x7FFF5636C6E0 = 0 0
977/0x5729:    658732       3      1 stat64("test.py\0", 0x7FFF5636DCB8, 0x0)        = 0 0
977/0x5729:    658737       5      3 open_nocancel("test.py\0", 0x0, 0x1B6)      = 3 0
977/0x5729:    658760       4      2 stat64("test.py\0", 0x7FFF5636E930, 0x1)        = 0 0
977/0x5729:    658764       5      2 open_nocancel("test.py\0", 0x0, 0x1B6)      = 3 0
</code></pre>
<p>from the looks of it python did not even touch test.pyc file at all!</p>
<pre><code>$ echo '#!/bin/sh 
 python -c "import test"' &gt; test.sh
$ chmod a+x test.sh
$ sudo dtruss -a ./test.sh 2&gt;&amp;1 | grep "test.py*"
$ sudo dtruss -a ./test.sh 2&gt;&amp;1 | grep "test.py*"
1028/0x5d74:    654642       8      5 open_nocancel("test.py\0", 0x0, 0x1B6)         = 3 0
1028/0x5d74:    654683       8      5 open_nocancel("test.pyc\0", 0x0, 0x1B6)        = 4 0
$
</code></pre>
<p>well thats interesting it looks like it opened test.py then test.pyc </p>
<p>what happens when we delete the pyc file.</p>
<pre><code>$ rm test.pyc
$ sudo dtruss -a ./test.sh 2&gt;&amp;1 | grep "test.py*"
1058/0x5fd6:    654151       7      4 open_nocancel("/Users/samyvilar/test.py\0", 0x0, 0x1B6)        = 3 0
1058/0x5fd6:    654191       6      3 open_nocancel("/Users/samyvilar/test.pyc\0", 0x0, 0x1B6)       = -1 Err#2
1058/0x5fd6:    654234       7      3 unlink("/Users/samyvilar/test.pyc\0", 0x1012B456F, 0x1012B45E0)        = -1 Err#2
1058/0x5fd6:    654400     171    163 open("/Users/samyvilar/test.pyc\0", 0xE01, 0x81A4)         = 4 0
</code></pre>
<p>it first open test.py then it 'tried' to open test.pyc which returned an error then it called unlink and generated the pyc file again ... interesting, I thought it would check.</p>
<p>what if we delete the original py file.</p>
<pre><code>$ sudo dtruss -a ./test.sh 2&gt;&amp;1 | grep "test.py*"
1107/0x670d:    655064       4      1 open_nocancel("test.py\0", 0x0, 0x1B6)         = -1 Err#2
1107/0x670d:    655069       8      4 open_nocancel("test.pyc\0", 0x0, 0x1B6)        = 3 0
</code></pre>
<p>no surprise there it couldn't open test.py but it still continued, to this day Im not sure if this is actually 'ok' python should give out some kind of warning, I've being burned a couple of times by this, accidentally deleting my files, running my tests and feeling a sigh of relief as they pass only to start sweating when I can't seem to find the source code! </p>
<p>After this tests we an assume python only uses pyc files either directly when invoked such as  <code>python test.pyc</code> or indirectly when imported, otherwise it doesn't seem to use them.</p>
<p>Supposedly CPythons compiler was designed to be fairly fast, it doesn't do much type checking and it probably generates very high level byte-code so most of the work load is actually done by the virtual machine ... it probably does a single pass, lexing-&gt;compiler-&gt;byte-code in one go, it does this every time, it reads a python file from the command line or when importing and no pyc file is present in that case it creates it.</p>
<p>this may be why some other implementations are faster since they take more time to compile but generate far rawer byte-codes that can be well optimized.</p>
<p>Its extremely difficult to build a virtual machine to do pure interpretive efficiently ... </p>
<p>Its all about balance, the more powerful your bytecode the simpler your compiler can be but the more complex and slow your virtual machine has to be and vice-versa ...</p>
</div>
<div class="post-text" itemprop="text">
<p>Python is incapable of directly executing source code (unlike some other scripting languages which do ad hoc parsing, e.g. Bash). All Python source code <em>must</em> be compiled to bytecode, no matter what the source is. (This includes e.g. code run through <code>eval</code> and <code>exec</code>). Generating bytecode is rather expensive because it involves running a parser, so caching the bytecode (as .pyc) speeds up module loading by avoiding the parsing phase.</p>
<p>The difference between <code>import foo</code> and <code>python foo.py</code> is simply that the latter doesn't cache the bytecode that is generated.</p>
</div>
<span class="comment-copy">Curious where you read this <code>.pyc is a cached file and is only generated if the module is imported somewhere else</code></span>
<span class="comment-copy">@BurhanKhalid It's in the link.</span>
<span class="comment-copy">Why does it follow from these points, that Python can't compile the file to bytecode? The points only talk about caching generated bytecode in files.</span>
<span class="comment-copy">+1: nice and detailed.</span>
<span class="comment-copy">+1 also. Thanks for taking your time to confirm my thoughts and yes, we should be precise :)</span>
<span class="comment-copy">While this is interesting, most of it could be determined simply by reading the relevant Python documentation. Using <code>dtruss</code> for this purpose seems overkill. (Note, for example, that Python explicitly says that pyc-only distributions are OK, i.e. folders full of .pyc and not .py).</span>
<span class="comment-copy">just wanted to show/teach another way to test/debug what the actually application is doing, if you know something else I can use instead of dtruss I'm wide open, as for the docs, if you can provide a link that would be awesome cause i couldnt find the byte code rules that explicitly state when they are generated and used,  Besides the provided link regarding imports. distributing pyc ... Didn't think of that one, and probably for good reason ...</span>
<span class="comment-copy">Here is some tutorial documentation: <a href="http://docs.python.org/3/tutorial/modules.html#compiled-python-files" rel="nofollow noreferrer">docs.python.org/3/tutorial/modules.html#compiled-python-files</a></span>
<span class="comment-copy">Thanks! I guess I should start going through the v3 docs more often ....</span>
<span class="comment-copy">That particular section has been in the docs <a href="http://docs.python.org/release/1.5.1p1/tut/node43.html" rel="nofollow noreferrer">since at least Python 1.5.1</a>.</span>
<span class="comment-copy">Thanks! Short answer :)))</span>
