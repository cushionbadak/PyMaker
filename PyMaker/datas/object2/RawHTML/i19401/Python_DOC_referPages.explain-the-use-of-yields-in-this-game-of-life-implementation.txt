<div class="post-text" itemprop="text">
<p>In <a href="http://pyvideo.org/video/880/stop-writing-classes" rel="nofollow">this PyCon talk</a>, Jack Diederich shows this "simple" implementation of <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Rules" rel="nofollow">Conway's Game of Life</a>. I am not intimately familiar with either GoL or semi-advanced Python, but the code seems quite easy to grasp, if not for two things:</p>
<ol>
<li>The use of <code>yield</code>. I have seen the use of yield to create generators before, but eight of them in a row is new... Does it return a list of eight generators, or how does this thing work?</li>
<li><code>set(itertools.chain(*map(neighbors, board)))</code>. The star unpacks the resulting list (?) from applying neighbours to board, and ... my mind just blew.</li>
</ol>
<p>Could someone try to explain these two parts for a programmer that is used to hacking together some python code using map, filter and reduce, but that is not using Python on a daily basis? :-)</p>
<pre><code>import itertools

def neighbors(point):
    x, y = point
    yield x + 1, y
    yield x - 1, y
    yield x, y + 1
    yield x, y - 1
    yield x + 1, y + 1
    yield x + 1, y - 1
    yield x - 1, y + 1
    yield x - 1, y - 1

def advance(board):
    newstate = set()
    recalc = board | set(itertools.chain(*map(neighbors, board)))
    for point in recalc:
        count = sum((neigh in board) for neigh in neighbors(point))
        if count == 3 or (count == 2 and point in board):
            newstate.add(point)
    return newstate

glider = set([(0,0), (1,0), (2, 0), (0,1), (1,2)])
for i in range(1000):
    glider = advance(glider)
    print glider
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Generators operate on two principles: they produce a value each time a <code>yield</code> statement is encountered, and unless it is iterated over, their code is <em>paused</em>.</p>
<p>It doesn't matter how many <code>yield</code> statements are used in a generator, the code is still run in normal python ordering. In this case, there is no loop, just a series of <code>yield</code> statements, so each time the generator is advanced, python executes the next line, which is another <code>yield</code> statement.</p>
<p>What happens with the <code>neighbors</code> generator is this:</p>
<ol>
<li><p>Generators always start paused, so calling <code>neighbors(position)</code> returns a generator that hasn't done anything yet.</p></li>
<li><p>When it is advanced (<code>next()</code> is called on it), the code is run until the first <code>yield</code> statement. First <code>x, y = point</code> is executed, then <code>x + 1, y</code> is calculated and yielded. The code pauses again.</p></li>
<li><p>When advanced again, the code runs until the <em>next</em> <code>yield</code> statement is encountered. It yields <code>x - 1, y</code>.</p></li>
<li><p>etc. until the function completes.</p></li>
</ol>
<p>The <code>set(itertools.chain(*map(neighbors, board)))</code> line does:</p>
<ol>
<li><p><code>map(neighbors, board)</code> produces an iterator for each and every position in the <code>board</code> sequence. It simply loops over board, calls <code>neighbors</code> on each value, and returns a new sequence of the results. Each <code>neighbors()</code> function returns a generator.</p></li>
<li><p>The <code>*parameter</code> syntax expands the <code>parameter</code> sequence into a list of parameters, as if the function was called with each element in <code>parameter</code> as a separate positional parameter instead. <code>param = [1, 2, 3]; foo(*param)</code> would translate to <code>foo(1, 2, 3)</code>.</p>
<p><code>itertools.chain(*map(..))</code> takes each and every generator produced by the map, and applies that as a series of positional parameters to <code>itertools.chain()</code>. Looping over the output of chain means that each and every generator for each and every board position is iterated over once, in order.</p></li>
<li><p>All the generated positions are added to a set, essentially removing duplicates</p></li>
</ol>
<p>You could expand the code to:</p>
<pre><code>positions = set()
for board_position in board:
    for neighbor in neighbors(board):
        positions.add(neighbor)
</code></pre>
<p>In python 3, that line could be expressed a little more efficiently still by using <a href="http://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>itertools.chain.from_iterable()</code></a> instead, because <code>map()</code> in Python 3 is a generator too; <code>.from_iterable()</code> doesn't force the <code>map()</code> to be expanded and will instead loop over the <code>map()</code> results one by one as needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Wow, that's a neat implementation, thanks for posting it !</p>
<p>For the <code>yield</code>, there is nothing to add to Martijn's answer.</p>
<p>As for the star : the <code>map</code> returns a generator or a list (depending on python 2 or 3), and each item of this list is a generator (from <code>neighbors</code>), so we have a list of generators.</p>
<p><a href="http://docs.python.org/2/library/itertools.html#itertools.chain" rel="nofollow"><code>chain</code></a> takes many arguments that are iterables and chains them, meaning it returns a single iterable while iterate over all of them in turn.</p>
<p>Because we have a list of generators, and <code>chain</code> takes many arguments, we use a star to convert the list of generator to arguments. We could have done the same with <a href="http://docs.python.org/2/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>chain.from_iterable</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>it just returns a tuple of all cell's neighbours. If you do understand what generators do, it is pretty clear that using generators is a good practice when working with big amount of data. you do not need to store all this in memory, you calculate it only when you need it.</p>
</div>
