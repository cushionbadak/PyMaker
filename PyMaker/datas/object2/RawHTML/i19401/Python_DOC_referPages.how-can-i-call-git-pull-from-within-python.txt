<div class="post-text" itemprop="text">
<p>Using the github webhooks, I would like to be able to pull any changes to a remote development server. At the moment, when in the appropriate directory, <code>git pull</code> gets any changes that need to be made. However, I can't figure out how to call that function from within Python. I have tried the following:</p>
<pre class="lang-python prettyprint-override"><code>import subprocess
process = subprocess.Popen("git pull", stdout=subprocess.PIPE)
output = process.communicate()[0]
</code></pre>
<p>But this results in the following error</p>
<blockquote>
<p>Traceback (most recent call last):   File "", line 1, in
     File "/usr/lib/python2.7/subprocess.py", line 679, in
  <strong>init</strong>
      errread, errwrite)   File "/usr/lib/python2.7/subprocess.py", line 1249, in _execute_child
      raise child_exception OSError: [Errno 2] No such file or directory</p>
</blockquote>
<p>Is there a way that I can call this bash command from within Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Have you considered using GitPython? It's designed to handle all this nonsense for you.</p>
<pre><code>import git 

g = git.cmd.Git(git_dir)
g.pull()
</code></pre>
<p><a href="https://github.com/gitpython-developers/GitPython">https://github.com/gitpython-developers/GitPython</a></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="noreferrer"><code>subprocess.Popen</code></a> expects a list of the program name and arguments. You're passing it a single string, which is (with the default <code>shell=False</code>) equivalent to:</p>
<pre><code>['git pull']
</code></pre>
<p>That means that subprocess tries to find a program named literally <code>git pull</code>, and fails to do so: In Python 3.3, your code raises the exception <code>FileNotFoundError: [Errno 2] No such file or directory: 'git pull'</code>. Instead, pass in a list, like this:</p>
<pre class="lang-py prettyprint-override"><code>import subprocess
process = subprocess.Popen(["git", "pull"], stdout=subprocess.PIPE)
output = process.communicate()[0]
</code></pre>
<p>By the way, in Python 2.7+, you  can simplify this code with the <a href="http://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="noreferrer"><code>check_output</code></a> convenience function:</p>
<pre class="lang-py prettyprint-override"><code>import subprocess
output = subprocess.check_output(["git", "pull"])
</code></pre>
<p>Also, to use git functionality, it's by no way necessary (albeit simple and portable) to call the git binary. Consider using <a href="https://github.com/gitpython-developers/GitPython" rel="noreferrer">git-python</a> or <a href="http://www.samba.org/~jelmer/dulwich/" rel="noreferrer">Dulwich</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a sample recipe, I've been using in one of my projects. Agreed that there are multiple ways to do this though. :)</p>
<pre><code>&gt;&gt;&gt; import subprocess, shlex
&gt;&gt;&gt; git_cmd = 'git status'
&gt;&gt;&gt; kwargs = {}
&gt;&gt;&gt; kwargs['stdout'] = subprocess.PIPE
&gt;&gt;&gt; kwargs['stderr'] = subprocess.PIPE
&gt;&gt;&gt; proc = subprocess.Popen(shlex.split(git_cmd), **kwargs)
&gt;&gt;&gt; (stdout_str, stderr_str) = proc.communicate()
&gt;&gt;&gt; return_code = proc.wait()

&gt;&gt;&gt; print return_code
0

&gt;&gt;&gt; print stdout_str
# On branch dev
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be committed)
#
#   file1
#   file2
nothing added to commit but untracked files present (use "git add" to track)

&gt;&gt;&gt; print stderr_str
</code></pre>
<p>The problem with your code was, you were not passing an array for <code>subprocess.Popen()</code> and hence was trying to run a single binary called <code>git pull</code>. Instead it needs to execute the binary <code>git</code> with the first argument being <code>pull</code> and so on.</p>
</div>
<div class="post-text" itemprop="text">
<p>The accepted answer using <a href="https://github.com/gitpython-developers/GitPython" rel="nofollow noreferrer">GitPython</a> is little better than just using <code>subprocess</code> directly.</p>
<p>The problem with this approach is that if you want to parse the output, you end up looking at the result of a "porcelain" command, <a href="https://stackoverflow.com/a/6978402">which is a bad idea</a></p>
<p>Using GitPython in this way is like getting a shiny new toolbox, and then using it for the pile of screws that hold it together instead of the tools inside. Here's how the API was designed to be used:</p>
<pre><code>import git
repo = git.Repo('Path/to/repo')
repo.remotes.origin.pull()
</code></pre>
<p>If you want to check if something changed, you can use</p>
<pre><code>current = repo.head.commit
repo.remotes.origin.pull()
if current != repo.head.commit:
    print("It changed")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try:</p>
<pre><code>subprocess.Popen("git pull", stdout=subprocess.PIPE, shell=True)
</code></pre>
</div>
<span class="comment-copy">This is a duplicate of <a href="http://stackoverflow.com/questions/4256107/running-bash-commands-in-python" title="running bash commands in python">stackoverflow.com/questions/4256107/…</a></span>
<span class="comment-copy">@Brandon that's not true, there are many other solutions, most better.</span>
<span class="comment-copy">Is the <code>git</code> executable in the PATH?</span>
<span class="comment-copy">@jleahy perhaps, from what I understand celecnius is effectively asking "how do I run a bash command". This has been asked and answered many times.</span>
<span class="comment-copy">git_dir is any source controlled directory you have (which contains the .git folder)</span>
<span class="comment-copy">It is prompting for password.. How can I pass the password for that??</span>
<span class="comment-copy">You can use ssh to establish keys, so no password authentication is requied</span>
<span class="comment-copy"><code>msg = g.pull()</code> tells you what happened. <code>msg</code> is <code>''</code> or <code>'Updating ... Fast-forward README.md | 1 + 1 file changed, 1 insertion(+)'</code> if you pulled successfully and <code>'Already up-to-date.'</code> if you're... already up to date.</span>
<span class="comment-copy">This is a really bad way to use GitPython - it handles barely any of the garbage, and just translates to <code>subprocess.check_output(['git', 'pull'], cwd=git_dir)</code>, leaving you on the own to parse the output of a "git porcelain" command, which you're not supposed to do</span>
<span class="comment-copy">Per documentation: <i>“args should be a sequence of program arguments <b>or else a single string</b>.”</i> (emphasis mine). Are you sure about this, because it works for me?</span>
<span class="comment-copy">@poke Yes, the documentation is a little bit unclear. If you want to pass in a string, you must pass in <code>shell=True</code>.</span>
<span class="comment-copy">Well, as I said, it works for me doing just <code>subprocess.Popen("git pull", stdout=subprocess.PIPE).communicate()</code> (3.3 and 2.7 on Windows). – Well, reading a bit further, the docs explain that this will only work on Unix when not passing any arguments.. Nevermind then ^^</span>
<span class="comment-copy">@poke You were right about the single string case though, my initial explanation was wrong. Turns out, you can pass in a string, but (<a href="http://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer">quoting</a>): <code>If args is a string, the interpretation is platform-dependent</code>. Added more details. In Python 3.3, the error message is much nicer.</span>
<span class="comment-copy">This does not work on windows when autocrlf is needed. Calling git from cmd is not the same like calling git from sh.exe. The automatic crfl replacement is not taken into acoount and that is why git status does not work</span>
<span class="comment-copy">Not that <code>split</code> should really be <a href="http://docs.python.org/2/library/shlex.html#shlex.split" rel="nofollow noreferrer"><code>shlex.split</code></a>, and that code is needlessly complicated - you don't need <code>wait</code> after <code>communicate</code>, and for most usage cases, <a href="http://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer"><code>check_output</code></a> does the right string already.</span>
<span class="comment-copy">I use the wait() to gather the return code of the process, for my needs. It is optional, if the OP is not interested in return code checking. Agreed about using <code>shlex.split</code> though. And yes if you're not interested in grabbing stdout or stderr you can skip those. Nothing wrong in providing alternate solutions which lets you do something more instead of the standard python documentation examples ;)</span>
<span class="comment-copy">And as you mentioned, <code>check_output</code> has been added only since 2.7, I have had the need to run my script in environments with python versions older than that too.</span>
<span class="comment-copy">While <code>wait</code> works, <code>proc.pid</code> is way easier to understand. And since <code>check_output</code> is pure Python, one can simply <a href="http://hg.python.org/cpython/file/acf6ffc57fcf/Lib/subprocess.py#l547" rel="nofollow noreferrer">copy it</a> to have it available on older Python versions as well.</span>
<span class="comment-copy">Oh sweet! yes <code>check_output</code> seems more robust too :)</span>
<span class="comment-copy">This would needlessly spawn a shell though, wouldn't it?</span>
<span class="comment-copy">See the answer <a href="http://stackoverflow.com/a/15315617/679449">above</a></span>
