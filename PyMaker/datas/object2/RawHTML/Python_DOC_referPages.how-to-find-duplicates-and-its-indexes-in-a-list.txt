<div class="post-text" itemprop="text">
<p>I have a list </p>
<pre><code>l=['a','b','c','c','a','d']
</code></pre>
<p>The output should return all the duplicate elements and their indices in the list</p>
<p>Output:</p>
<pre><code>out = {a:['0','4'],c:['2','3']}
</code></pre>
<p>I have tried</p>
<pre><code>def nextDuplicates(c):
    dupl_c = dict()
    sorted_ind_c = sorted(range(len(c)), key=lambda x: c[x])
    for i in xrange(len(c) - 1):
        if c[sorted_ind_c[i]] == c[sorted_ind_c[i+1]]:
            dupl_c[ sorted_ind_c[i] ] = sorted_ind_c[i+1]
    return dupl_c
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>l=['a','b','c','c','a','d']

result = {}

for element in l:
    if element not in result:
         indexes = [i for i, x in enumerate(l) if x == element]

         if len(indexes) &gt; 1:
              result[element] = indexes

print(result)
</code></pre>
<p>Iterate through list and check if element already exista in dictionary. If it doesn't then get all the indexes for that element and append the element in dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>collections.defaultdict</code> + a <code>set</code> iteration for a faster lookup for counts greater than 1:</p>
<pre><code>from collections import defaultdict

l = ['a','b','c','c','a','d']

result = defaultdict(list)

for x in set(l):
    if l.count(x) &gt; 1:
        result[x].extend([i for i, y in enumerate(l) if y == x])

print(result)
# defaultdict(&lt;class 'list'&gt;, {'a': [0, 4], 'c': [2, 3]})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A <code>dict</code> comprehension coupled with a <code>list</code> comprehension would work (even for more than 2 occurences) :</p>
<pre><code>l = ["a", "b", "c", "c", "a", "d"]
out = {el: [i for i, x in enumerate(l) if x == el] for el in l if l.count(el) &gt; 1}
</code></pre>
<p>I saw in your expected output that indexes are strings. I don't understand why, but if you really want them as strings, replace <code>i for i, x</code> with <code>str(i) for i, x</code>.</p>
<p><a href="https://www.pythonforbeginners.com/basics/list-comprehensions-in-python" rel="nofollow noreferrer">More on list comprehensions</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use this dict comprehension</p>
<pre><code>l = ["a", "b", "c", "c", "a", "d"]
out = {ele: [str(i) for i, x in enumerate(l) if x == ele] for ele in set(l) if l.count(ele) &gt; 1}

# Output : {'c': ['2', '3'], 'a': ['0', '4']}
</code></pre>
<p>Rather than iterating over the list itself using the set will give a performance improvement especially if there are many duplicates.</p>
<p>In your expected output you wanted a list of <code>str</code> as the value. If you need int, you can use <code>i</code> instead of <code>str(i)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>l=['a','b','c','c','a','d']
o = {}
for i in range(len(l)):
    if (l[i] in o):
        o[l[i]].append(i)
    else:
        o[l[i]] = [i]
print({key:val for key, val in o.items() if len(val) &gt; 1})
</code></pre>
</div>
<span class="comment-copy">Please show what you have tried.</span>
<span class="comment-copy">I edited my answer. He could also add one more condition.</span>
<span class="comment-copy">This is also accepted answer</span>
<span class="comment-copy">This is also accepted answer</span>
<span class="comment-copy">returns positions of every element in the list</span>
