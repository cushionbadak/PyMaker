<div class="post-text" itemprop="text">
<p>I'm building a class that inherits OrderedDict, in which every key returns a list. I'm looking to overload <strong>setitem</strong> such that if the key doesn't exist, new assignments immediately put the value into a list, otherwise the new value is appended to the list. The following seems to be working:</p>
<pre><code>from collections import OrderedDict

class ListDict(OrderedDict):
    def __init__(self):
        super(ListDict, self).__init__()

    def __setitem__(self, key, value):
        if key in self:
            self[key].append(value)
        else:
            super(ListDict, self).__setitem__(key, [value])

thedict = ListDict()

thedict['a'] = 'first item'
thedict['b'] = 'another first item'
thedict['a'] = 'a second item?'

print thedict
</code></pre>
<p>which prints:</p>
<pre><code>$ python inheritex.py
ListDict([('a', ['first item', 'a second item?']), ('b', ['another first item'])])
</code></pre>
<p>Instead of appending with an assignment operator '=', I would rather have new items be appended with '+=', or even something like:</p>
<pre><code>ListDict['key'] = ListDict['key'] + 'value'
</code></pre>
<p>How would one go about overloading this? Besides being possible to monkey patch an add function, is it even a Pythonic/readable means to alter class behavior, or is this acceptable because the inherited function (OrderedDict) is untouched?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can already use <code>+=</code> on <em>existing</em> keys:</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; thedict = OrderedDict()
&gt;&gt;&gt; thedict['a'] = []  # set initial list
&gt;&gt;&gt; thedict['a'] += ['foo']
&gt;&gt;&gt; thedict['a'] += ['bar']
&gt;&gt;&gt; thedict
OrderedDict([('a', ['foo', 'bar'])])
</code></pre>
<p>Note that <code>+=</code> on a list is basically the same thing as <code>list.extend()</code>, so you need to append lists.</p>
<p>If you want this to work for keys that don't exist yet, implement a <a href="https://docs.python.org/3/reference/datamodel.html#object.__missing__" rel="nofollow"><code>__missing__</code> method</a>, rather than <code>__setitem__</code>:</p>
<pre><code>class ListDict(OrderedDict):
    def __missing__(self, key):
        self[key] = []
        return self[key]
</code></pre>
<p>When a key is missing during <code>dict[key]</code> lookup, <code>__missing__</code> is called and it's return value is returned instead of raising a <code>KeyError</code>.</p>
<p>Now both <code>+</code> and <code>+=</code> work on missing keys too:</p>
<pre><code>&gt;&gt;&gt; thedict = ListDict()
&gt;&gt;&gt; thedict['a'] += ['foo', 'bar']
&gt;&gt;&gt; thedict['b'] = thedict['b'] + ['spam', 'ham']
&gt;&gt;&gt; thedict
ListDict([('a', ['foo', 'bar']), ('b', ['spam', 'ham'])])
</code></pre>
<p>If you concatenation must work without adding lists, you could produce a custom list subclass too:</p>
<pre><code>class ConcatList(list):
    def __add__(self, value):
        return type(self)(super(ContactList, self).__add__([value]))
    def __iadd__(self, value):
        self.append(value)
        return self
</code></pre>
<p>then use that type in <code>__missing__</code> (and convert any new lists set directly in <code>__setitem__</code>):</p>
<pre><code>class ListDict(OrderedDict):
    def __missing__(self, key):
        self[key] = ConcatList()
        return self[key]
    def __setitem__(self, key, value):
        if not isinstance(key, ConcatList):
           value = ConcatList([value])
        super(ListDict, self).__setitem__(key, value)
</code></pre>
<p>after which you can forgo brackets:</p>
<pre><code>&gt;&gt;&gt; thedict = ListDict()
&gt;&gt;&gt; thedict['a'] += 'foo'
&gt;&gt;&gt; thedict['b'] = thedict['b'] + 'bar'
&gt;&gt;&gt; thedict
ListDict([('a', ['foo']), ('b', ['bar'])])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've extended <a href="https://stackoverflow.com/users/100297/martijn-pieters">Martijn's</a> <code>ListDict</code> so you can provide <code>default_factory</code> and have a similar to <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>'s functionality + key ordering:</p>
<pre><code>class OrderedDefaultDict(OrderedDict):
    def __init__(self, default_factory=None):
        self.default_factory = default_factory

    def __missing__(self, key):
        if self.default_factory is None:
            raise KeyError
        self[key] = self.default_factory()
        return self[key]

list_dict = OrderedDefaultDict(list)
list_dict['first'].append(1)
list_dict['second'].append(2)
list_dict['third'].append(3)
assert list(list_dict.keys()) == ['first', 'second', 'third']
assert list(list_dict.values()) == [[1], [2], [3]]

list_dict.move_to_end('first')
assert list(list_dict.keys()) == ['second', 'third', 'first']
</code></pre>
</div>
<span class="comment-copy">FWIW, <code>if key in self</code> is <i>much</i> better than <code>if key in self.keys()</code> :-)</span>
<span class="comment-copy">@mgilson: Ooof you're right. &gt;.&lt; I still see inheritance code with <code>self</code> in it and get woozy and disoriented...</span>
<span class="comment-copy">I suspect you can also use multiple inheritance to combine <code>OrderedDict</code> with <code>defaultdict</code> (you'd just need to overload <code>__init__</code> to pass <code>list</code> as the factory function to the <code>defaultdict</code> class).</span>
<span class="comment-copy">@Blckknght: perhaps, but it is so much easier to just go with a custom <code>__missing__</code> than to have to figure out how to keep <code>defaultdict</code> and <code>OrderedDict</code> initialisers happy.</span>
<span class="comment-copy">Yeah, it seems it doesn't actually work due to some kind of conflict (at least in recent versions of Python. I was exploring it for my own answer when I saw yours cover most of the same material.</span>
<span class="comment-copy">@Blckknght: neither has a cooperative <code>__init__</code>, so you have to call both explicitly.</span>
<span class="comment-copy">@MartijnPieters: <code>__missing__</code> seems a lot more elegant than <code>__setitem__</code>, although I'm not too keen on requiring list brackets every time someone uses <code>+=</code> from a user-input-shell standpoint. Wrapping that in a function should be easy though. Thanks!</span>
