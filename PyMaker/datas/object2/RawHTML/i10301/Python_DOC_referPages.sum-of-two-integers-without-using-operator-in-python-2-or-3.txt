<div class="post-text" itemprop="text">
<pre><code>class Solution(object):
    def getSum(self, a, b):
        if (a == 0):
            return b
        if (b == 0):
            return a;
        while(b != 0):
            _a = a ^ b
            _b = (a &amp; b) &lt;&lt; 1
            a = _a
            b = _b
        return a
</code></pre>
<p>But when one of a, b &lt; 0 or both, how the script should be like?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>+</code> operator internally makes a call to <code>__add__()</code>. So, you may directly call <code>a.__add__(b)</code> to get sum. Below is the modified code:</p>
<pre><code>&gt;&gt;&gt; class Solution(object):
...     def getSum(self, a, b):
...         return a.__add__(b)
... 
&gt;&gt;&gt; s = Solution()
&gt;&gt;&gt; s.getSum(1, 2)
3
</code></pre>
<p><strong>OR</strong>, you may use <a href="https://docs.python.org/2/library/operator.html#operator.add" rel="nofollow"><code>operator.add(a, b)</code></a> as:</p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt; operator.add(1, 2)
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I enjoy solving other people's problems.</p>
<pre><code>class Solution(object):
    def getSum(self, a, b):
        return sum([a, b])
</code></pre>
<p><strong>Edit:</strong> If you are in for some fantasy. You can do operator overloading.</p>
<pre><code>class CrappyInt(int):

    def __init__(self, num):
      self.num = num

    def __eq__(self, a):
      return self.__add__(a)


m = CrappyInt(3)
n = CrappyInt(4)

print m == n
# 7
</code></pre>
<p>This maybe a little hard for you now. But it is fun.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <a href="https://docs.python.org/3/library/operator.html" rel="nofollow"><code>operator</code></a> package</p>
<pre><code>import operator


class Solution(object):
    def getSum(self, a, b):
        return operator.add(a, b)
</code></pre>
<p>And if you want to hassle with binary bitwise operations. Here is first method:</p>
<pre><code>def complex_add_1(x, y):
    while y != 0:
        b = x &amp; y
        x = x ^ y
        y = b &lt;&lt; 1
    return x
</code></pre>
<p>And here is the another one with recursion:</p>
<pre><code>def complex_add_2(x, y):
    if y == 0:
        return x
    else:
        return complex_add_2(x ^ y, (x &amp; y) &lt;&lt; 1)
</code></pre>
<p><strong>Edit</strong>: methods with bitwise operations are working only in Python 3</p>
</div>
<div class="post-text" itemprop="text">
<p>My old highschool program that I found on my usb stick. Yes it's crude but it works.</p>
<pre><code>def s(a,b):
    a = bin(a)[2:]
    b = bin(b)[2:]
    c_in = 0
    value = ''
    if not len(a) == len(b):
        to_fill = abs(len(a) - len(b))

        if len(a) &gt; len(b):
            b = b.zfill(len(a))
        else:
            a = a.zfill(len(b))

    for i,j in zip(reversed(a),reversed(b)):
        i_xor_j = int(i) ^ int(j)
        i_and_j = int(i) and int(j)
        s = int(c_in) ^ int(i_xor_j)
        c_in_and_i_xor_j = int(c_in) and int(i_xor_j)
        c_in = int(i_and_j) or int(c_in_and_i_xor_j)
        value += str(int(s))
    value += str(int(c_in))

    return int(value[::-1],2)

print(s(5,9))
#&gt;&gt; 14
</code></pre>
<p>Or I would have see if I could cheat with <code>sum</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This was kinda fun :) I'm not sure if this is what you're after, but these all should work so long as you're using integers</p>
<pre class="lang-python prettyprint-override"><code>def subtract(a, b):
    if a &lt; 0:
        return negative(add(negative(a), b))
    if b &lt; 0:
        return add(a, negative(b))
    if a &lt; b:
        return negative(subtract(b, a))
    if b == 0:
        return a
    return subtract(a^b, (~a &amp; b) &lt;&lt; 1)

def negative(a):
    if a == 0: return 0
    a = ~a
    b = 1
    while b &gt; 0:
        a, b = a^b, (a&amp;b) &lt;&lt; 1
    return a

def add(a, b):
    if a &lt; 0:
        return negative(subtract(negative(a), b))
    if b &lt; 0:
        return subtract(a, negative(b))
    if b == 0:
        return a
    return add(a^b, (a &amp; b) &lt;&lt; 1)

def multiply(a, b):
    if a == 0 or b == 0:
        return 0
    if b &lt; 0:
        a = negative(a)
        b = negative(b)
    A = 0
    while b &gt; 0:
        A = add(A, a)
        b = subtract(b, 1)
    return A

def div(a, b):
    if b == 0:
        raise ZeroDivisionError
    if a == 0:
        return 0
    if b &lt; 0:
        a = negative(a)
        b = negative(b)
    A = 0
    if a &lt; 0:
        while a &lt; 0:
            a = add(a, b)
            A = subtract(A, 1)
    else:
        while b &lt; a :
            a = subtract(a, b)
            A = add(A, 1)
    return A

def mod(a, b):
    return subtract(a, multiply(div(a, b),b))
</code></pre>
<p>negation by <a href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="nofollow">two's compliment</a> is used to get a function where a and b are both greater than 0 and the correct operation (addition or subtraction) is selected. further with subtraction, care is taken to not yield a negative result. This is done because the recursive definitions of add and subtract hate crossing 0. Also in this case the recursive add and subtract do the exact same thing as your loop. </p>
</div>
<span class="comment-copy">Why on earth would you want to do such a thing?</span>
<span class="comment-copy">It's a leetcode problem, but I cannot get the correct code. (sad face)</span>
<span class="comment-copy">Why not just <code>return a - -b</code>?</span>
<span class="comment-copy">@FredLarson Darn that was better than mine.</span>
<span class="comment-copy">@MarkRansom That is more of a math exercise. So the OP can make <code>range(a)</code> and <code>range(b)</code> and increment a single integer that starts from 0. Which would be the definition of adding. However, boring :D</span>
<span class="comment-copy">Dang it! I was so close...</span>
<span class="comment-copy">oops. It works. But I still want to solve this question.</span>
<span class="comment-copy">I never thought it would so easy. Thank you for all.</span>
<span class="comment-copy">I don't think your bit-wise functions work for negative number</span>
<span class="comment-copy">@galaxyan they work in Python 3, just checked.</span>
<span class="comment-copy">@alex.l i've added two more method with bitwise operations(seems that what you were looking for)</span>
<span class="comment-copy">try one negative one positive complex_add_2(-1,2)</span>
<span class="comment-copy">@galaxyan they work in Python 3 as i said. Python 2, sorry.</span>
<span class="comment-copy">@MarkRansom I hope this made you proud.</span>
<span class="comment-copy">it does help me! thx a lot!</span>
<span class="comment-copy">@alex.l I actually screwed up the <code>negative()</code> function to always return positive values... I fixed it now and added a few more functions for fun</span>
