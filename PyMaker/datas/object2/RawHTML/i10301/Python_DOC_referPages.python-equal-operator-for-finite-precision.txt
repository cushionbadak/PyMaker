<div class="post-text" itemprop="text">
<p>I have been asked to test a library provided by a 3rd party. The library is known to be accurate to <em>n</em> significant figures. Any less-significant errors can safely be ignored. I want to write a function to help me compare the results:</p>
<pre><code>def nearlyequal( a, b, sigfig=5 ):
</code></pre>
<p>The purpose of this function is to determine if two floating-point numbers (a and b) are approximately equal. The function will return True if a==b (exact match) or if a and b have the same value when rounded to <strong>sigfig</strong> significant-figures when written in decimal. </p>
<p>Can anybody suggest a good implementation? I've written a mini unit-test. Unless you can see a bug in my tests then a good implementation should pass the following:</p>
<pre><code>assert nearlyequal(1, 1, 5) 
assert nearlyequal(1.0, 1.0, 5) 
assert nearlyequal(1.0, 1.0, 5) 
assert nearlyequal(-1e-9, 1e-9, 5) 
assert nearlyequal(1e9, 1e9 + 1 , 5) 
assert not nearlyequal( 1e4, 1e4 + 1, 5) 
assert nearlyequal( 0.0, 1e-15, 5 ) 
assert not nearlyequal( 0.0, 1e-4, 6 ) 
</code></pre>
<p>Additional notes:</p>
<ol>
<li>Values a and b might be of type int, float or numpy.float64. Values a and b will always be of the same type. It's vital that conversion does not introduce additional error into the function.</li>
<li>Lets keep this numerical, so functions that convert to strings or use non-mathematical tricks are not ideal. This program will be audited by somebody who is a mathematician who will want to be able to prove that the function does what it is supposed to do.</li>
<li>Speed... I've got to compare a lot of numbers so the faster the better.</li>
<li>I've got numpy, scipy and the standard-library. Anything else will be hard for me to get, especially for such a small part of the project.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>There is a function <code>assert_approx_equal</code> in <code>numpy.testing</code> (source <a href="https://github.com/numpy/numpy/blob/1225aef37298ec82048d0828f6cb7e0be8ed58cc/numpy/testing/utils.py#L513" rel="noreferrer">here) </a>which may be a good starting point. </p>
<pre><code>def assert_approx_equal(actual,desired,significant=7,err_msg='',verbose=True):
    """
    Raise an assertion if two items are not equal up to significant digits.

    .. note:: It is recommended to use one of `assert_allclose`,
              `assert_array_almost_equal_nulp` or `assert_array_max_ulp`
              instead of this function for more consistent floating point
              comparisons.

    Given two numbers, check that they are approximately equal.
    Approximately equal is defined as the number of significant digits
    that agree.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.5, the standard way to do this (using the standard library) is with the <a href="https://docs.python.org/3/library/math.html#math.isclose"><code>math.isclose</code></a> function.</p>
<p>It has the following signature:</p>
<pre><code>isclose(a, b, rel_tol=1e-9, abs_tol=0.0)
</code></pre>
<p>An example of usage with absolute error tolerance:</p>
<pre><code>from math import isclose
a = 1.0
b = 1.00000001
assert isclose(a, b, abs_tol=1e-8)
</code></pre>
<p>If you want it with precision of <strong><em>n</em></strong> significant digits, simply replace the last line with:</p>
<pre><code>assert isclose(a, b, abs_tol=10**-n)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a take.</p>
<pre><code>def nearly_equal(a,b,sig_fig=5):
    return ( a==b or 
             int(a*10**sig_fig) == int(b*10**sig_fig)
           )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe your question is not defined well enough, and the unit-tests you present prove it:</p>
<p>If by 'round to N sig-fig decimal places' you mean 'N decimal places to the right of the decimal point', then the test <code>assert nearlyequal(1e9, 1e9 + 1 , 5)</code> should fail, because even when you round 1000000000 and 1000000001 to 0.00001 accuracy, they are still different.</p>
<p>And if by 'round to N sig-fig decimal places' you mean 'The N most significant digits, regardless of the decimal point', then the test <code>assert nearlyequal(-1e-9, 1e-9, 5)</code> should fail, because 0.000000001 and -0.000000001 are totally different when viewed this way.</p>
<p>If you meant the first definition, then the first answer on this page (by Triptych) is good.
If you meant the second definition, please say it, I promise to think about it :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>There are already plenty of great answers, but here's a think:</p>
<pre><code>def closeness(a, b):
  """Returns measure of equality (for two floats), in unit
     of decimal significant figures."""
  if a == b:
    return float("infinity")
  difference = abs(a - b)
  avg = (a + b)/2
  return math.log10( avg / difference )


if closeness(1000, 1000.1) &gt; 3:
  print "Joy!"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>"Significant figures" in decimal is a matter of adjusting the decimal point and truncating to an integer.  </p>
<pre><code>&gt;&gt;&gt; int(3.1415926 * 10**3)
3141
&gt;&gt;&gt; int(1234567 * 10**-3)
1234
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a fairly common issue with floating point numbers. I solve it based on the discussion in Section 1.5 of Demmel[1]. (1) Calculate the roundoff error. (2) Check that the roundoff error is less than some epsilon. I haven't used python in some time and only have version 2.4.3, but I'll try to get this correct.</p>
<p>Step 1. Roundoff error</p>
<pre><code>def roundoff_error(exact, approximate):
    return abs(approximate/exact - 1.0)
</code></pre>
<p>Step 2. Floating point equality</p>
<pre><code>def float_equal(float1, float2, epsilon=2.0e-9):
    return (roundoff_error(float1, float2) &lt; epsilon)
</code></pre>
<p>There are a couple obvious deficiencies with this code.</p>
<ol>
<li>Division by zero error if the exact value is Zero.</li>
<li>Does not verify that the arguments are floating point values.</li>
</ol>
<p>Revision 1.</p>
<pre><code>def roundoff_error(exact, approximate):
    if (exact == 0.0 or approximate == 0.0):
        return abs(exact + approximate)
    else:
        return abs(approximate/exact - 1.0)

def float_equal(float1, float2, epsilon=2.0e-9):
    if not isinstance(float1,float):
        raise TypeError,"First argument is not a float."
    elif not isinstance(float2,float):
        raise TypeError,"Second argument is not a float."
    else:
        return (roundoff_error(float1, float2) &lt; epsilon)
</code></pre>
<p>That's a little better. If either the exact or the approximate value is zero, than the error is equal to the value of the other. If something besides a floating point value is provided, a TypeError is raised.</p>
<p>At this point, the only difficult thing is setting the correct value for epsilon. I noticed in the documentation for version 2.6.1 that there is an epsilon attribute in sys.float_info, so I would use twice that value as the default epsilon. But the correct value depends on both your application and your algorithm.</p>
<p>[1] James W. Demmel, <em>Applied Numerical Linear Algebra</em>, SIAM, 1997.</p>
</div>
<div class="post-text" itemprop="text">
<p>Oren Shemesh got part of the problem with the problem as stated but there's more:</p>
<p>assert nearlyequal( 0.0, 1e-15, 5 ) </p>
<p>also fails the second definition (and that's the definition I learned in school.)</p>
<p>No matter how many digits you are looking at, 0 will not equal a not-zero.  This could prove to be a headache for such tests if you have a case whose correct answer is zero.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a interesting solution to this by B. Dawson (with C++ code)
at <a href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm" rel="nofollow noreferrer">"Comparing Floating Point Numbers"</a>.  His approach relies on strict IEEE representation of two numbers and the enforced lexicographical ordering when said numbers are represented as unsigned integers.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are lots of ways of comparing two numbers to see if they agree to N significant digits. Roughly speaking you just want to make sure that their difference is less than 10^-N times the largest of the two numbers being compared. That's easy enough.</p>
<p>But, what if one of the numbers is zero? The whole concept of relative-differences or significant-digits falls down when comparing against zero. To handle that case you need to have an absolute-difference as well, which should be specified differently from the relative-difference.</p>
<p>I discuss the problems of comparing floating-point numbers -- including a specific case of handling zero -- in this blog post:</p>
<p><a href="http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/" rel="nofollow">http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/</a></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I have been asked to test a library provided by a 3rd party</p>
</blockquote>
<p>If you are using the default Python <a href="https://docs.python.org/3/library/unittest.html#module-unittest" rel="nofollow noreferrer"><code>unittest</code> framework</a>, you can use <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual" rel="nofollow noreferrer"><code>assertAlmostEqual</code></a></p>
<pre><code>self.assertAlmostEqual(a, b, places=5)
</code></pre>
</div>
<span class="comment-copy"><a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/" rel="nofollow noreferrer">Comparing Floating Point Numbers, 2012 Edition</a></span>
<span class="comment-copy">unittest.assertAlmostEqual() fooled me by ignoring insignificant digits.</span>
<span class="comment-copy">you don't really need that if statement. you can just return result of comparison: it's either True or False, it's shorter and surely more pythonic</span>
<span class="comment-copy">will this work for the <i>nearlyequal((1e9,1+1e9, 5)</i>?</span>
<span class="comment-copy">good point @silentghost.  Made the change.</span>
<span class="comment-copy">This fails nearlyequal(1e9, 1e9 + 1 , 5) - it does not work for big numbers.</span>
<span class="comment-copy">The issue is that "significant figures" depends on whether the number is &gt;1 or &lt;1.  &gt;1 you have to use sig_fig-math.log10(n) to shift "to the right".  If &lt;1 you simple use sig_fig to shift "to the left".</span>
<span class="comment-copy">Actually, you are right about "assert nearlyequal(-1e-9, 1e-9, 5)" - it breaks the rules! +1</span>
<span class="comment-copy">Can you provide an algorithm to do this?</span>
<span class="comment-copy">Different from the code I already posted?  What more do you need to know?</span>
