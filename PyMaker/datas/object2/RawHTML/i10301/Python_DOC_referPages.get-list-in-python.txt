<div class="post-text" itemprop="text">
<pre><code>#ideal nodes list should be
['A','B','C','D','E','F','G','H','I','J','K','L','M','N']
</code></pre>
<p>So I tried to write a definition to read the nodes and edges.Here is my code,but it seems does not work.</p>
<pre><code>""" read nodes"""
def rd_nodes(a):
    nline =[line.split(":")[1].replace(';',',').split(',') for line in a]
    for i in nline:
        return i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow"><code>itertools.combinations</code></a> can help you here.</p>
<p>Try this:</p>
<pre><code>from itertools import combinations

s = """
1:A,B,C,D;E,F
2:G,H;J,K
&amp;:L,M,N
"""

nodes = set()
edges = set()

for line in s.split():
    clusters = line.split(':')[1].split(';')
    for cluster in clusters:
        _nodes = cluster.split(',')
        nodes.update(_nodes)
        edges.update(combinations(_nodes, 2))
</code></pre>
<p>You may use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>collections.OrderedDict</code></a> structure for <code>nodes</code> and <code>edges</code> to maintain order if you want. Just use nodes and edges as dict keys and then at the end of the script get list of the keys.</p>
</div>
<div class="post-text" itemprop="text">
<p>As @skovorodkin has the correct answer, but if you want pure Python version (Though I wonder why) you could use this code</p>
<pre><code>s = """
1:A,B,C,D;E,F
2:G,H;J,K
&amp;:L,M,N
"""
def combinations(nodes):
    if len(nodes) &lt; 2:
        return (tuple(nodes))
    else:
        i = 1
        ret_tuple = []
        for n in nodes:
            rest = nodes[i:]
            for r in rest:
                ret_tuple.append(tuple([n,r]))
            i += 1

        return tuple(ret_tuple)

nodes = set()
edges = set()

for line in s.split():
    clusters = line.split(':')[1].split(';')
    for cluster in clusters:
        _nodes = cluster.split(',')
        nodes.update(_nodes)
        edges.update(combinations(_nodes))

print nodes
print edges
</code></pre>
</div>
<span class="comment-copy">I think you should be using <code>yield</code> and not <code>return</code> in your <code>rd_nodes</code></span>
<span class="comment-copy">Show us the data structure for <code>graph</code></span>
<span class="comment-copy">@PatrickHaugh it seems like yield and return have the same function.but when I tried,it still won't get the right result.</span>
<span class="comment-copy">@PatrickHaugh the graph should be the list with tuple.Check above dataset.</span>
<span class="comment-copy">does it have any way like we don't import any packages,and to write a definition with for loop to get nodes and edges?</span>
<span class="comment-copy">Sure, just check the link to combinations function doc I provided in the post, there's a pure Python version of it.</span>
