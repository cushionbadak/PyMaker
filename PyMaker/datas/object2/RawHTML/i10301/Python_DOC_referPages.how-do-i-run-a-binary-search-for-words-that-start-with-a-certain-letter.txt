<div class="post-text" itemprop="text">
<p>I am asked to binary search a list of names and if these names start with a particular letter, for example A, then I am to print that name.
I can complete this task by doing much more simple code such as</p>
<pre><code>for i in list:
    if i[0] == "A":
        print(i)
</code></pre>
<p>but instead I am asked to use a binary search and I'm struggling to understand the process behind it. We are given base code which can output the position a given string. My problem is not knowing what to edit so that I can achieve the desired outcome</p>
<pre><code>name_list = ["Adolphus of Helborne", "Aldric Foxe", "Amanita Maleficant", "Aphra the Vicious", "Arachne the Gruesome", "Astarte Hellebore", "Brutus the Gruesome", "Cain of Avernus"]


def bin_search(list, item):
    low_b = 0
    up_b = len(list) - 1
    found = False

    while low_b &lt;= up_b and found ==  False:
        midPos = ((low_b + up_b) // 2)
        if list[midPos] &lt; item:
            low_b = midPos + 1
        elif list[midPos] &gt; item:
            up_b = midPos - 1
        else:
            found = True
    if found:
        print("The name is at positon " + str(midPos))
        return midPos
    else:
        print("The name was not in the list.")
</code></pre>
<p>Desired outcome</p>
<pre><code>bin_search(name_list,"A")
</code></pre>
<p>Prints all the names starting with A (Adolphus of HelBorne, Aldric Foxe .... etc)</p>
<p>EDIT:
I was just doing some guess and check and found out how to do it. This is the solution code</p>
<pre><code>def bin_search(list, item):
    low_b = 0
    up_b = len(list) - 1
    true_list = []
    count = 100
    while low_b &lt;= up_b and count &gt; 0:
        midPos = ((low_b + up_b) // 2)
        if list[midPos][0] == item:
            true_list.append(list[midPos])
            list.remove(list[midPos])
            count -= 1
        elif list[midPos] &lt; item:
            low_b = midPos + 1
            count -= 1
        else:
            up_b = midPos - 1
            count -= 1
    print(true_list)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not too sure if this is what you want as it seems inefficient... as you mention it seems a lot more intuitive to just iterate over the entire list but using binary search i found <a href="http://code.activestate.com/recipes/81188-binary-search/" rel="nofollow">here</a> i have:</p>
<pre class="lang-python prettyprint-override"><code>def binary_search(seq, t):
    min = 0
    max = len(seq) - 1
    while True:
        if max &lt; min:
            return -1
        m = (min + max) // 2
        if seq[m][0] &lt; t:
            min = m + 1
        elif seq[m][0] &gt; t:
            max = m - 1
        else:
            return m

index=0
while True:
    index=binary_search(name_list,"A")
    if index!=-1:
        print(name_list[index])
    else:
        break
    del name_list[index]
</code></pre>
<p>Output i get:</p>
<pre><code>Aphra the Vicious
Arachne the Gruesome
Amanita Maleficant
Astarte Hellebore
Aldric Foxe
Adolphus of Helborne
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You just need to found one item starting with the letter, then you need to identify the range. This approach should be fast and memory efficient.</p>
<pre><code>def binary_search(list,item):
    low_b = 0
    up_b = len(list) - 1
    found = False
    midPos = ((low_b + up_b) // 2)
    if list[low_b][0]==item:
        midPos=low_b
        found=True
    elif list[up_b][0]==item:
        midPos = up_b
        found=True
    while True:
        if found:
            break;
        if list[low_b][0]&gt;item:
            break
        if list[up_b][0]&lt;item:
            break
        if up_b&lt;low_b:
            break;
        midPos = ((low_b + up_b) // 2)
        if list[midPos][0] &lt; item:
            low_b = midPos + 1
        elif list[midPos] &gt; item:
            up_b = midPos - 1
        else:
            found = True
            break
    if found:
        while True:
            if midPos&gt;0:
                if list[midPos][0]==item:
                    midPos=midPos-1
                    continue
            break;
        while True:
            if midPos&lt;len(list):
                if list[midPos][0]==item:
                    print list[midPos]
                    midPos=midPos+1
                    continue
            break
    else:
        print("The name was not in the list.")
</code></pre>
<p>the output is</p>
<pre><code>&gt;&gt;&gt; binary_search(name_list,"A")
Adolphus of Helborne
Aldric Foxe
Amanita Maleficant
Aphra the Vicious
Arachne the Gruesome
Astarte Hellebore
</code></pre>
</div>
<span class="comment-copy">First, sort it - <a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer">Sorting HOW TO</a></span>
<span class="comment-copy">sorry I should have mentioned, the list I am given is already sorted so we can skip that part, but yes correct it needs to be sorted</span>
<span class="comment-copy">Do a search for binary search and study how it is supposed to work, Study the code, try to figure out how it works, use print statements to help with <i>visualizing</i>.</span>
<span class="comment-copy">I was hoping for a little more help than telling me to go do some googling which I have already done @wwii</span>
<span class="comment-copy">The function you have been given only returns exact matches. If you want another function to return everything starting with a given letter, you could modify the existing function to return the index of the first element to have a greater value than what you are searching for, and then use that. Then just search for 'A' and 'B', and if that tells you that the first entry that is greater than 'A' is at position 0, and the first that is greater than 'B' is at position 6, then the list of all names starting with 'A' can be found as <code>name_list[0:6]</code>.</span>
<span class="comment-copy">Binary search seems inefficient compared to linear search?  News to me</span>
<span class="comment-copy">Not exactly as clear as you put it the binary search method is repeated several times as it is in a loop</span>
<span class="comment-copy">I see your point, as rather than wanting 1 search OP wants ALL starting with A</span>
