<div class="post-text" itemprop="text">
<p>Reading about <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow">Assignment statements</a> in the Python's docs I found this:</p>
<blockquote>
<p>If the target is an attribute reference: The primary expression in the reference is evaluated. It should yield an object with assignable attributes; if this is not the case, <code>TypeError</code> is raised. That object is then asked to assign the assigned object to the given attribute; if it cannot perform the assignment, it raises an exception (usually but not necessarily <code>AttributeError</code>).</p>
</blockquote>
<p>I'm wondering how to get this <code>TypeError</code>?</p>
<p><strong>What Python's types doesn't have routine for setting attributes?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>This documentation line is just really out of date. It dates back to at least <a href="https://docs.python.org/release/1.4/ref/ref6.html#HDR2" rel="nofollow">Python 1.4</a>, long before type/class unification. I believe back then, trying to do something like</p>
<pre><code>x = 1
x.foo = 3
</code></pre>
<p>would have produced a TypeError, but I wasn't writing Python back then, and I don't have a sufficiently ancient interpreter version to test it.</p>
<p>If you look at the <a href="https://hg.python.org/cpython/file/3.5/Objects/object.c#l914" rel="nofollow">source code</a> for attribute assignment dispatch, you can see that the documented check still exists:</p>
<pre><code>if (tp-&gt;tp_setattro != NULL) {
    ...
    return ...;
}
if (tp-&gt;tp_setattr != NULL) {
    ...
    return ...;
}
Py_DECREF(name);
assert(name-&gt;ob_refcnt &gt;= 1);
if (tp-&gt;tp_getattr == NULL &amp;&amp; tp-&gt;tp_getattro == NULL)
    PyErr_Format(PyExc_TypeError,
                 "'%.100s' object has no attributes "
                 "(%s .%U)",
                 tp-&gt;tp_name,
                 value==NULL ? "del" : "assign to",
                 name);
else
    PyErr_Format(PyExc_TypeError,
                 "'%.100s' object has only read-only attributes "
                 "(%s .%U)",
                 tp-&gt;tp_name,
                 value==NULL ? "del" : "assign to",
                 name);
return -1;
</code></pre>
<p>If an object's type has no routine for setting attributes, Python raises an error, complaining about "no attributes" or "only read-only attributes" depending on whether the type has a routine for getting attributes. I believe in the early days, types like <code>int</code> would have gone down this code path. However, all types now inherit such routines from <code>object</code>, so I don't think this code path is ever taken.</p>
<p>There's a related code path in <a href="https://hg.python.org/cpython/file/3.5/Objects/typeobject.c#l3005" rel="nofollow"><code>type.__setattr__</code></a> that raises a <code>TypeError</code> for setting attributes on types written in C. This code path is still taken, but it's not as general as what the documentation describes:</p>
<pre><code>if (!(type-&gt;tp_flags &amp; Py_TPFLAGS_HEAPTYPE)) {
    PyErr_Format(
        PyExc_TypeError,
        "can't set attributes of built-in/extension type '%s'",
        type-&gt;tp_name);
    return -1;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This code produces a <code>TypeError</code> and it seems like it is what the documentation describes:</p>
<pre><code>&gt;&gt;&gt; def f(): pass
...
&gt;&gt;&gt; f.func_globals = 0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: readonly attribute
</code></pre>
<p>But is this <code>TypeError</code> really raised because the documentation says that? I sincerely doubt it. I guess <code>func_globals</code> implementation simply raises <code>TypeError</code> if you try to assign something to it.</p>
<p><strong>BTW...</strong></p>
<p>I would actually excpect the same in the next example, but it is an <code>AttributeError</code> instead:</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     __slots__ = 'a',
...
&gt;&gt;&gt; A().b = 0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'A' object has no attribute 'b'
</code></pre>
<p><strong>Update (Python 3)</strong></p>
<p>The above was in Python 2.7. In Python 3, there is no <code>func_globals</code>, so this is not applicable (you can assign anything to it).</p>
<p>What attributes function has in Python 3 seem to raise an <code>AttributeError</code> when it is read-only.</p>
<pre><code>&gt;&gt;&gt; f.__globals__ = 0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: readonly attribute
</code></pre>
<p>This makes perfect sense to me. Perhaps this part of the documentation is just a relic as far as Python 3 is concerned.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to raise TypeError in your code:</p>
<pre><code>raise TypeError
</code></pre>
<p>I suggest you read up on exceptions and exception handling in Python for more information. <a href="https://docs.python.org/3/tutorial/errors.html" rel="nofollow">https://docs.python.org/3/tutorial/errors.html</a> </p>
</div>
<span class="comment-copy">I use python approximately 2 years, but have never encountered  such a situation.</span>
<span class="comment-copy">You hint me an answer <code>object.some_attr</code> raises TypeError :)</span>
<span class="comment-copy">I think that can still happen if you explicitly delete <code>__setattr__</code>. I didn't test it though.</span>
<span class="comment-copy">@Kritzefitz No, no you can't <code>del</code>, if you can't assign!</span>
<span class="comment-copy">I slightly modify my question, because you really revealed to me what I was asking about.</span>
<span class="comment-copy">It does not raise an error in my case for <code>f.func_globals</code>. I use Python 3.5.2.</span>
<span class="comment-copy">@godaygo You are right, I used Python 2.7...</span>
