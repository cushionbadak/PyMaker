<div class="post-text" itemprop="text">
<p>In my program I'm trying to find the smallest number that python can give me. When I kept dividing a number by 2, I got 5 x 10^-324 (5e-324). I thought I could divide this by the biggest number I can use in python. I tried to get the biggest number in python by doing this:</p>
<pre><code>z = 1
    while True:
        try:
            z = z+1
        except OverflowError:
            z = z-1
            break
</code></pre>
<hr/>
<p>Here is my full code:</p>
<pre><code>from os import system
x = 76556758478567587
while True:
    x = x/2
    if x/2 == 0.0:
        break

print("Smallest number I can compute:", x)
print()
z = 1
while True:
    try:
        z = z+1
    except OverflowError:
        z = z-1
        break

print(str(x) + " divided by " + str(z) + " is...")
z = x/z
print(z)
system("pause &gt;nul")
</code></pre>
<p>Every time I run this it does nothing. I suddenly recognize it's still trying to solve the problem so I open task manager and Python was eating up my CPU like a pack of wolves eating a dead cow.</p>
<hr/>
<p>I know the smallest number in python would be negative but I want to get the the smallest number <strong>above zero</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may use <code>sys.float_info</code> to get the maximum/minimum representable finite float as:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.float_info.min
2.2250738585072014e-308
&gt;&gt;&gt; sys.float_info.max
1.7976931348623157e+308
</code></pre>
<p>Python uses double-precision floats, which can hold values from about 10 to the -308 to 10 to the 308 power. Below is the experiment from the python prompt:</p>
<pre><code># for maximum
&gt;&gt;&gt; 1e308
1e+308
&gt;&gt;&gt; 1e+309
inf   &lt;-- Infinite
</code></pre>
<p>You may even get numbers smaller than <code>1e-308</code> via <a href="https://en.wikipedia.org/wiki/Denormal_number" rel="nofollow"><code>denormals</code></a>, but there is a significant performance hit to this and such numbers are <em>represented with a loss of precision</em>. I found that Python is able to handle 1e-323 but underflows on 1e-324 and returns 0.0 as the value.</p>
<pre><code># for minimum
&gt;&gt;&gt; 1e-323
1e-323
&gt;&gt;&gt; 1e-324
0.0
</code></pre>
<p>You can get denormalized minimum as <code>sys.float_info.min * sys.float_info.epsilon</code>, which comes as <strong><code>5e-324</code></strong>. </p>
<p>As per the document:</p>
<blockquote>
<p><strong>sys.float_info.max</strong> is maximum representable finite float</p>
<p><strong>sys.float_info.min</strong> is minimum positive normalized float</p>
</blockquote>
<p>To get more information check: <a href="https://docs.python.org/3/library/sys.html#sys.float_info" rel="nofollow"><code>sys.float_info</code></a>:</p>
<blockquote>
<p><strong>sys.float_info</strong> is a struct sequence holding information about the float type. It contains low level information about the precision and internal representation. The values correspond to the various floating-point constants defined in the standard header file float.h for the ‘C’ programming language; see section 5.2.4.2.2 of the 1999 ISO/IEC C standard [C99], ‘Characteristics of floating types’, for details.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The smallest floating point number representable in Python is <code>5e-324</code>, or <code>2.0**-1075</code>.</p>
<p>The other two answers have each given you half of what you need to find this number. It can be found by multiplying <code>sys.float_info.min</code> (<code>2.2250738585072014e-308</code>, the smallest normalized float) by <code>sys.float_info.epsilon</code> (<code>2.220446049250313e-16</code>, the smallest proportion you can modify a number by while still getting a distinct value).</p>
</div>
<div class="post-text" itemprop="text">
<p>The key word that you're apparently missing is "<a href="https://en.wikipedia.org/wiki/Epsilon" rel="nofollow noreferrer">epsilon</a>."  If you search on <strong>Python epsilon value</strong> then it returns a links to <a href="https://stackoverflow.com/a/9528486/149076">StackOverflow: Value for epsilon in Python</a> near the top of the results in Google.</p>
<p>Obviously it helps if you understand how the term is associated with this concept.</p>
</div>
<span class="comment-copy">Find the largest integer first, then take the reciprocal;)</span>
<span class="comment-copy">you first algorithm is log(N)-complex, your second one is N-complex. You should multiply by 2 until you reach overflow THEN work your way down. However I'm sensing that the exercise is pointless.</span>
<span class="comment-copy">What? There is no maximum or minimum number in Python. Python will automagically convert your "int" to a "long" which is actually infinite size (realistically w.e. is allocated by the OS). There is a max 'int', but it's fairly meaningless. If that's not satisfying, check out <a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic" rel="nofollow noreferrer">en.wikipedia.org/wiki/Arbitrary-precision_arithmetic</a> or search for "big number library" for reference impls.</span>
<span class="comment-copy">The interesting thing is that it seems that you <i>can</i> still divide <code>sys.float_info.min</code> ... And I'm not sure <i>why</i>.  Maybe an IEEE guru can enlighten us?</span>
<span class="comment-copy">How do you suppose that 2.2250738585072014e-308 is the smallest available float when the OP has gotten to 5e-324?</span>
<span class="comment-copy">Try: <code>sys.float_info.min*sys.float_info.epsilon</code></span>
<span class="comment-copy">@mgilson isn't this about normalized and unnormalized floats? <code>2.2e-308</code> might be divided into <code>0.000000002e-308</code>, etc?</span>
<span class="comment-copy">@mgilson and I don't even know the terminology, apparently they're called <a href="https://en.wikipedia.org/wiki/Denormal_number" rel="nofollow noreferrer">denormal numbers</a>.</span>
