<div class="post-text" itemprop="text">
<p>I'm running a fortran code from a python script which sometimes takes a while to run. Thus I'm limiting the run time with a code taken from <a href="https://stackoverflow.com/a/13821695/3910261">this link</a>:</p>
<pre><code>def timeout(func, args=(), kwargs={}, timeout_duration=15, default=1):
    import signal

    class TimeoutError(Exception):
        pass

    def handler(signum, frame):
        raise TimeoutError()

    # set the timeout handler
    signal.signal(signal.SIGALRM, handler) 
    signal.alarm(timeout_duration)
    try:
        result = func(*args, **kwargs)
    except TimeoutError as exc:
        result = default
    finally:
        signal.alarm(0)

    return result
</code></pre>
<p>I'm basically putting another function (partly below) in to this one (above) to run fortran code as:</p>
<pre><code>subprocess.check_output('./../bin/SPhenoUMSSM ../UMSSM/LH_out_'+mod+' &gt; SPheno_log_'+mod, shell=True)
</code></pre>
<p>However I realised that when fortran code takes more than 15 seconds, which is the boundary in timeout function, it leaves in the core and executes other one in the for loop which creates dump in my cores. In order to prevent that, I wanted to use <code>subprocess.popen()</code> since it gives me pid to terminate the job in the core, but I need to wait for the process to be executed as well, like <code>subprocess.check_output()</code> does. Thus I was wondaring if there is a way to combine popen and check_output properties to wait until job is done within 15 seconds and if its not just terminates that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not the most sophisticated piece of code in the world but it may be useful.</p>
<pre><code>import subprocess, time
x = subprocess.Popen(['sleep', '15'])
polling = None
i = 0
while polling == None:
    time.sleep(1)
    polling = x.poll()
    i +=1
    if i &gt; 15: break
if polling == None:
    try:
        x.kill()
        print "Time out - process terminated" # process terminated by kill command
    except OSError:
        print "Process completed on time" # process terminated between poll and kill commands
    except Exception as e:
        print "Error "+str(e) # kill command failed due to another exception "e"
else:
    print "Process Completed after "+str(i)+" seconds"
</code></pre>
<p>Edit: Problems with kill not appearing to function.<br/>
Try using <code>os.kill(x.pid, signal.SIGKILL)</code> rather than <code>SIGTERM</code>.<br/>
I believe that <code>SIGTERM</code> asks the process to close down cleanly, rather than terminate immediately. Not knowing what drives the fortran script, it's difficult to know what the terminate signal does. Perhaps the code is doing something.<br/>
For example:<br/>
if I ran a shell script as follows:    </p>
<pre><code>#!/bin/bash
trap "echo signal" 15
sleep 30
</code></pre>
<p>and sent it <code>kill -15 pid_number</code>, it would not print "signal" until the sleep had terminated after 30 seconds, whereas if I issued <code>kill -9 pid_number</code> it would terminate immediately with nothing printed out.   </p>
<p>The short answer, is I don't know but I suspect that the answer lies within the script running the fortran code.</p>
<p>EDIT:</p>
<p>Note: In order to successfully run <code>x.kill()</code> or <code>os.kill()</code> or <code>subprocess.call('kill '+ str(x.pid), shell=True)</code>, <code>shell</code> option in x needs to be False. Thus one can use </p>
<pre><code>import shlex
args = shlex.split(ARGS HERE) 
x = subprocess.Popen(args) # shell=False is default
</code></pre>
<p>But also note that if you want to write the output to a log file by using <code>... &gt;&amp; log_file</code> it wont work since <code>&gt;&amp;</code> is not an valid argument for your script but for your shell environment. Thus one needs to use only arguments that are valid for the script that python runs.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's a timeout argument on check_output, just set it to 15 seconds.</p>
<pre><code>try:
  subprocess.check_output(['arg1', 'arg2'], timeout=15)
except:
  print("Timed out")
</code></pre>
<p>Documentation here <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow">https://docs.python.org/3/library/subprocess.html#subprocess.check_output</a></p>
<p>check_output returns the output as well, so if you care about it just store the result.</p>
<p>There's also a wait function that's useful for more complicated use cases. Both check_output and wait block until the process finishes, or until the timeout is reached.</p>
</div>
<div class="post-text" itemprop="text">
<p>Additional answer to the one above, shell has an internal timeout command as well so it can be used as follows;</p>
<pre><code>timeout &lt;TIME IN SEC&gt; ./blabla &gt; log_file
</code></pre>
<p>I'm using it in python as follows;</p>
<pre><code>try:
    check_output('timeout --signal=SIGKILL 12 ./&lt;COMMAND&gt; &gt; log', shell=True)
    flag = 0
except:
    flag = 1
</code></pre>
<p>Thus one can check if flag is 1 or 0 to understand what happened to the job. Note that <code>--signal=SIGKILL</code> is just written <code>Killed</code> at the end of the run if its terminated. For more signal options one can check <code>kill -l</code>.</p>
</div>
<span class="comment-copy">Interestingly sometimes it works perfectly fine but sometimes it just leaves the program in the background and prints terminated. I tried x.terminate() as well but ended up with the same result. Do you know why it might happen?</span>
<span class="comment-copy">No idea I'm afraid. The documentation does not have any caveats that I can see. However I do not know how your fortran code functions, your OS or indeed, how you have implemented the above code. I would take out the <code>try</code> statement and see if you get an error from the <code>kill()</code> command which points you in the right direction.</span>
<span class="comment-copy">Another thought, too late for an edit. Try <code>poll()</code> again after the <code>kill()</code> just to double check.</span>
<span class="comment-copy">I'm actually running it without try since the beginning and didnt get any error messages. tried <code>os.kill(PID, signal.SIGTERM)</code>, <code>process = psutil.Process(PID) process.terminate()</code>, didnt worked as well. Actually I got an error with <code>os.kill</code> about str object which I do not understand where it found str. my OS is Ubuntu 14.04, python 2.7.6</span>
<span class="comment-copy">See my edit, for what it is worth</span>
<span class="comment-copy">unfortunately I'm using Python 2.7.6, <code>timeout</code> update is for vers 3.3</span>
<span class="comment-copy">You should stop unless your company is forcing it upon you, Python 2 is at EOL and will be fully dead in 2020. A simple Google revealed this though: <a href="http://stackoverflow.com/questions/3733270/python-subprocess-timeout" title="python subprocess timeout">stackoverflow.com/questions/3733270/python-subprocess-timeout</a></span>
