<div class="post-text" itemprop="text">
<p>Is there any difference between using <code>typing.Any</code> as opposed to <code>object</code> in typing? For example:</p>
<pre><code>def get_item(L: list, i: int) -&gt; typing.Any:
    return L[i]
</code></pre>
<p>Compared to:</p>
<pre><code>def get_item(L: list, i: int) -&gt; object:
    return L[i]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, there is a difference. Although in Python 3, all objects are instances of <code>object</code>, including <code>object</code> itself, only <code>Any</code> documents that the return value should be disregarded by the typechecker.</p>
<p>The <code>Any</code> type docstring states that object is a subclass of <code>Any</code> and vice-versa:</p>
<pre><code>&gt;&gt;&gt; import typing
&gt;&gt;&gt; print(typing.Any.__doc__)
Special type indicating an unconstrained type.

    - Any object is an instance of Any.
    - Any class is a subclass of Any.
    - As a special case, Any and object are subclasses of each other.
</code></pre>
<p>However, a proper typechecker (one that goes beyond <code>isinstance()</code> checks, and which inspects how the object is actually <em>used</em> in the function) can readily object to <code>object</code> where <code>Any</code> is always accepted.</p>
<p>From the <a href="https://docs.python.org/3/library/typing.html#the-any-type" rel="noreferrer"><code>Any</code> type documentation</a>:</p>
<blockquote>
<p>Notice that no typechecking is performed when assigning a value of type <code>Any</code> to a more precise type.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>Contrast the behavior of <code>Any</code> with the behavior of <code>object</code>. Similar to <code>Any</code>, every type is a subtype of <code>object</code>. However, unlike <code>Any</code>, the reverse is not true: object is not a subtype of every other type.</p>
<p>That means when the type of a value is <code>object</code>, a type checker will reject almost all operations on it, and assigning it to a variable (or using it as a return value) of a more specialized type is a type error.</p>
</blockquote>
<p>and from the mypy documentation section <a href="http://mypy.readthedocs.io/en/latest/dynamic_typing.html#any-vs-object" rel="noreferrer"><em>Any vs. object</em></a>:</p>
<blockquote>
<p>The type <code>object</code> is another type that can have an instance of arbitrary type as a value. Unlike <code>Any</code>, <code>object</code> is an ordinary static type (it is similar to <code>Object</code> in Java), and only operations valid for all types are accepted for object values.</p>
</blockquote>
<p><code>object</code> can be <a href="http://mypy.readthedocs.io/en/latest/casts.html#casts" rel="noreferrer">cast</a> to a more specific type, while <code>Any</code> really means <em>anything goes</em> and a type checker disengages from any use of the object (even if you later assign such an object to a name that <em>is</em> typechecked).</p>
<p>You already painted your function into a an un-typed corner by accepting <code>list</code>, which comes down to being the same thing as <code>List[Any]</code>. The typechecker <em>disengaged there</em> and the return value no longer matters, but since your function accepts a list containing <code>Any</code> objects, the proper return value would be <code>Any</code> here.</p>
<p>To properly participate in type-checked code, you need to mark your input as <code>List[T]</code> (a genericly typed container) for a typechecker to then be able to care about the return value. Which in your case would be <code>T</code> since you are retrieving a value from the list. Create <code>T</code> from a <code>TypeVar</code>:</p>
<pre><code>from typing import TypeVar, List

T = TypeVar('T')

def get_item(L: List[T], i: int) -&gt; T:
    return L[i]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>Any</code> and <code>object</code> are superficially similar, but in fact are entirely <em>opposite</em> in meaning.</p>
<p><code>object</code> is the <em>root</em> of Python's metaclass hierarchy. Every single class inherits from <code>object</code>. That means that <code>object</code> is in a certain sense the most restrictive type you can give values. If you have a value of type <code>object</code>, the only methods you are permitted to call are ones that are a part of every single object. For example:</p>
<pre><code>foo = 3  # type: object

# Error, not all objects have a method 'hello'
bar = foo.hello()   

# OK, all objects have a __str__ method
print(str(foo))   
</code></pre>
<p>In contrast, <code>Any</code> is an <em>escape hatch</em> meant to allow you to mix together dynamic and statically typed code. <code>Any</code> is the least restrictive type -- any possible method or operation is permitted on a value of type <code>Any</code>. For example:</p>
<pre><code>from typing import Any
foo = 3  # type: Any

# OK, foo could be any type, and that type might have a 'hello' method
# Since we have no idea what hello() is, `bar` will also have a type of Any
bar = foo.hello()

# Ok, for similar reasons
print(str(foo))
</code></pre>
<p>You should generally try and use <code>Any</code> only for cases where...</p>
<ol>
<li>As a way of mixing together dynamic and statically typed code. For example, if you have many dynamic and complex functions, and don't have time to fully statically type all of them, you could settle for just giving them a return type of Any to nominally bring them into the typechecked work. (Or to put it another way, Any is a useful tool for helping migrate an untypechecked codebase to a typed codebase in stages).</li>
<li>As a way of giving a type to an expression that is difficult to type. For example, Python's type annotations currently do not support recursive types, which makes typing things like arbitrary JSON dicts difficult. As a temporary measure, you might want to give your JSON dicts a type of <code>Dict[str, Any]</code>, which is a bit better then nothing.</li>
</ol>
<p>In contrast, use <code>object</code> for cases where you want to indicate in a typesafe way that a value MUST literally work with any possible object in existence.</p>
<p>My recommendation is to avoid using <code>Any</code> except in cases where there is no alternative. <code>Any</code> is a concession -- a mechanism for allowing dynamism where we'd really rather live in a typesafe world.</p>
<p>For more information, see:</p>
<ul>
<li><a href="https://docs.python.org/3/library/typing.html#the-any-type" rel="nofollow">https://docs.python.org/3/library/typing.html#the-any-type</a></li>
<li><a href="http://mypy.readthedocs.io/en/latest/kinds_of_types.html#the-any-type" rel="nofollow">http://mypy.readthedocs.io/en/latest/kinds_of_types.html#the-any-type</a></li>
</ul>
<hr/>
<p>For your particular example, I would use <em>TypeVars</em>, rather then either object or Any. What you want to do is to indicate that you want to return the type of whatever is contained within the list. If the list will always contain the same type (which is typically the case), you would want to do:</p>
<pre><code>from typing import List, TypeVar

T = TypeVar('T')
def get_item(L: List[T], i: int) -&gt; T:
    return L[i]
</code></pre>
<p>This way, your <code>get_item</code> function will return the most precise type as possible.</p>
</div>
<span class="comment-copy">That's interesting, one more special case to the <code>object</code>/<code>type</code> structure. Thanks again Martijn! :)</span>
<span class="comment-copy">Unfortunately, this isn't quite correct -- see my answer below. In particular, the key thing is that <code>Any</code> is meant to be fully unconstrained -- any operation is permitted on a value of type <code>Any</code>. In contrast, object is the most constrained type. If you have a value of type <code>Any</code>, the only operations you're allowed to do are ones that are a part of the <code>object</code> interface (things like <code>__str__</code> and such). The "object is a subclass of Any and vice versa" exists mainly to explain why all values are compatible with <code>Any</code> even though they aren't technically a subclass or superclass of that type.</span>
<span class="comment-copy">@Michael0x2a: right, so from a typing point of view <code>Any</code> 'allows' the function to use <code>object.__missing__</code>, while <code>object</code> would not as that method is optional. In that way <code>Any</code> documents how the function will use the argument rather than just the dryly apply the isinstance test. In practice, the two remain the same because the <code>isinstance()</code> test used in <code>typing</code> will pass either way.</span>
<span class="comment-copy">@MartijnPieters: I'm not sure if I fully agree. From experience, using <code>Any</code> over <code>object</code> ends up having major ramifications due to how it weakens the typesafety of your code. E.g. It would be legal to pass a value of type <code>Any</code> into a function expecting some <code>CustomType</code> even if doing so would ultimately cause a runtime error because literally any operation is allowable with <code>Any</code>. The same isn't true for <code>object</code>. I also think <code>object</code> captures the intent more precisely since it outlines exactly what interface is safe to use on the value rather then leaving it ambiguous.</span>
<span class="comment-copy">@Michael0x2a: Ah, I see what you mean, updated my answer to reflect this. I was purely looking at the <code>typing</code> implementation here.</span>
<span class="comment-copy">Wouldn't <code>List[T]</code> constrict the list to be homogenous, e.g. <code>[None, 1, 'foo']</code> is illegal as there is no <i>one</i> type in that list? By using <code>list</code> as the accepted type, the baby has already been chucked out with the bathwater; no constraint is set on the contained values.</span>
<span class="comment-copy">@MartijnPieters -- not necessarily -- <code>T</code> could be constrained to be either <code>Any</code> or <code>Union[None, int, str]</code>. Both alternatives would make your example of <code>[None, 1, 'foo']</code> typecheck. But yeah, setting the type to <code>list</code> is equivalent to doing <code>List[Any]</code>, as you said.</span>
<span class="comment-copy">Right, a declaration <i>elsewhere</i> where the list originates should properly define the list contents. I do agree it is much better to actually restrict here; <code>Any</code> kills off the typechecker for any subsequent use of the return value of <code>get_item()</code> (you can assign the return value to a variable previously constrained and it'll Just Work, to your peril).</span>
