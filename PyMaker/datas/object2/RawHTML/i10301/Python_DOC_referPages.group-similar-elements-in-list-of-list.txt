<div class="post-text" itemprop="text">
<p>I have a list <code>[ [0], [0,1], [1,2], [3] ]</code>, and I am trying to group similar elements together. I need the output to be <code>[ [0,1,2], [3] ]</code>. This is grouping similar elements in the list of lists. Is there a preferred method to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can loop over each of the items in the input list and construct groups (as needed):</p>
<pre><code>def calculate_groups(data):
    if not data:
        return []
    groups = [set(data[0])]
    for item in data[1:]:
        item_set = set(item)
        for group in groups:
            if any(k in group for k in item):
                group.update(item_set)
                break
        else:
            groups.append(item_set)
    return [list(group) for group in groups]
</code></pre>
<p>This uses <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow">sets</a>, <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow"><code>any</code></a> and a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a> at the end.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; calculate_groups([ [0], [0,1], [1,2] ,[3] ])
[[0, 1, 2], [3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd recommend you to use a list of sets, let's call it <em>results_list</em>, starting from an empty list, and then fill it while traversing your input list of lists: For every item in the sub-list of your input list, you will have to check if they belong to any of the sets in results_list. If none of them belong, you just add a new set with the elements of that sub-list. If they do, you have to modify <em>results_list</em> merging all the sets where at least one of the items is present, including in that set all the items of the sub-list.</p>
<pre><code>def regroup(groups_list):
    results_list = [set(groups_list[0])]
    for sub_list in groups_list[1:]:
        current_items_set = set(sub_list)
        groups_to_merge = []
        for group in results_list:  
            if any(k in group for k in sub_list):
                groups_to_merge.append(group)
        if not groups_to_merge:
            # All of the items are new
            results_list.append(current_items_set)
        elif len(groups_to_merge) == 1:
            # Current items belong only to one of the existing groups
            groups_to_merge[0] = groups_to_merge[0].update(current_items_set)
        else:
            # The items belong to more than one group, merging is needed
            new_set = reduce(lambda x, y: x.union(y), groups_to_merge) or set()
            new_set.update(current_items_set)
            # The new results_list will have the new merged set, excluding the separated ones
            results_list = filter(lambda x: x not in groups_to_merge, results_list) + [new_set]

    return [sorted(x) for x in results_list]
</code></pre>
<p>Examples:</p>
<pre><code>input_list_1 = [[0], [0,1], [1,2], [3]]
regroup(input_list_1)
[[0, 1, 2], [3]]

input_list_2 = [[0], [0,1], [1,2], [3], [0, 3]]
regroup(input_list_2)
[[0, 1, 2, 3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another one. A bit shorter than other solutions.</p>
<pre><code>def get_cliques(groups):
    cliques = {}
    for g in groups:
        g = {*g}.union(*(cliques.get(i, []) for i in g))
        cliques.update({i: g for i in g})
    return {id(c): c for c in cliques.values()}.values()
</code></pre>
<p>The idea behind this code is simple: elements from one clique will always share <code>clique</code> set object. A set will contain all elements that are already known to be in a corresponding clique. So in the end we just need to get unique set objects from <code>cliques</code> dictionary. We employ builtin <code>id</code> function which returns object memory address (in CPython) for that: different elements from the same clique in <code>cliques</code> dictionary contain the same set object, so we can squash <code>cliques</code> dict into a smaller one which values will be unique.</p>
</div>
<span class="comment-copy">You've abstracted your question so much, that there is no clear answer. Can you give an example of what your problem domain is?</span>
<span class="comment-copy">each number represents a name. 0 is bob, 1 is tom, 2 is fred, 3 is robert. That are all linked together except robert.</span>
<span class="comment-copy">In such case i'd say the fact that they're grouped initially is irrelevant, so remove all groups (<code>reduce</code> with <code>append</code>). Then make sure they're unique (or use a set to begin with) and then sort and group. I would personally use a reduce for that as well.</span>
<span class="comment-copy">thats not working for me for some reason</span>
<span class="comment-copy">What makes the elements "similar"?</span>
<span class="comment-copy">You should rename the variable <code>group</code> in the function <code>group</code>...</span>
<span class="comment-copy">@Jasper: that's a good point. I have renamed the function to <code>calculate_groups</code> for clarity.</span>
