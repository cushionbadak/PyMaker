<div class="post-text" itemprop="text">
<p>I have a list of URLs for large files to <strong>download</strong> (e.g. compressed archives), which I want to <strong>process</strong> (e.g. decompress the archives). </p>
<p>Both download and processing take a long time and processing is heavy on disk IO, so I want to have <strong>just one of each to run at a time</strong>. Since the two tasks take about the same time and do not compete for the same resources, I want to download the next file(s) while the last is being processed.</p>
<p>This is a variation of the <strong><a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem" rel="nofollow noreferrer">producer-consumer problem</a></strong>.</p>
<p>The situation is similar to <a href="https://stackoverflow.com/q/12474182/512111">reading and processing images</a> or <a href="https://stackoverflow.com/questions/37825218/fastest-way-to-read-and-process-100-000-urls-in-python">downloading loads of files</a>, but my downloader calls are not (yet) picklable, so I have not been able to use multiprocessing, and both tasks take about the same time.</p>
<p>Here is a dummy example, where both download and processing are blocking:</p>
<pre><code>import time
import posixpath

def download(urls):
    for url in urls:
        time.sleep(3)  # this is the download (more like 1000s) 
        yield posixpath.basename(url)

def process(fname):
    time.sleep(2)  # this is the processing part (more like 600s)

urls = ['a', 'b', 'c']
for fname in download(urls):
    process(fname)
    print(fname)
</code></pre>
<p>How could I make the two tasks concurrent? Can I use <code>yield</code> or <code>yield from</code> <a href="https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3">in a smart way</a>, perhaps in combination with <a href="https://docs.python.org/2/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>deque</code></a>? Or must it be <a href="https://docs.python.org/3.4/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a> with <code>Future</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd simply use <code>threading.Thread(target=process, args=(fname,))</code> and start a new thread for processing.</p>
<p>But before that, end last processing thread :</p>
<pre><code>t = None
for fname in download(urls):
    if t is not None: # wait for last processing thread to end
        t.join()
    t = threading.Thread(target=process, args=(fname,))
    t.start()
    print('[i] thread started for %s' % fname)
</code></pre>
<p>See <a href="https://docs.python.org/3/library/threading.html" rel="nofollow">https://docs.python.org/3/library/threading.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>A year later, we are actually using Python 3's <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a> and <a href="https://pypi.python.org/pypi/aiohttp" rel="nofollow noreferrer"><code>aiohttp</code></a>.</p>
</div>
<span class="comment-copy">Possibly Copy of: <a href="http://stackoverflow.com/questions/16181121/python-very-simple-multithreading-parallel-url-fetching-without-queue" title="python very simple multithreading parallel url fetching without queue">stackoverflow.com/questions/16181121/â€¦</a></span>
<span class="comment-copy">No, not quite. That one is about multiple concurrent downloads. I need only one download at a time and the consumer should be aware of every new file.</span>
<span class="comment-copy">Cool, yes, that should work and is actually quite simple.</span>
<span class="comment-copy">it should indeed, even if I coded that blind and didn't test. Please let me know if there are any issue so I can fix my answer.</span>
<span class="comment-copy">I am quite sure this is a working answer, but the thing is my code is running inside some application (QGIS) that seems not to like when I use python <code>threading</code> (it crashes). I have to investigate the details but a solution based on coroutine might be safer.</span>
<span class="comment-copy">did you import <code>threading</code>?</span>
<span class="comment-copy">I think that a <code>t.join()</code> is missing at the end of the <code>for</code> loop. Add it in a <code>else</code> clause.</span>
