<div class="post-text" itemprop="text">
<p>How can I create a wrapper that makes celery tasks look like <code>asyncio.Task</code>? Or is there a better way to integrate Celery with <code>asyncio</code>?</p>
<p>@asksol, the creator of Celery, <a href="https://news.ycombinator.com/item?id=11870293">said this:</a>:</p>
<blockquote>
<p>It's quite common to use Celery as a distributed layer on top of async I/O frameworks (top tip: routing CPU-bound tasks to a prefork worker means they will not block your event loop).</p>
</blockquote>
<p>But I could not find any code examples specifically for <code>asyncio</code> framework.</p>
</div>
<div class="post-text" itemprop="text">
<p>That will be possible from Celery version 5.0 as stated in the official site:</p>
<p><a href="http://docs.celeryproject.org/en/4.0/whatsnew-4.0.html#preface" rel="nofollow noreferrer">http://docs.celeryproject.org/en/4.0/whatsnew-4.0.html#preface</a></p>
<blockquote>
<ol>
<li>The next major version of Celery will support Python 3.5 only, were we are planning to take advantage of the new asyncio library.</li>
<li>Dropping support for Python 2 will enable us to remove massive amounts of compatibility code, and going with Python 3.5 allows us to take advantage of typing, async/await, asyncio, and similar concepts thereâ€™s no alternative for in older versions.</li>
</ol>
</blockquote>
<p><em>The above were quoted from the previous link.</em></p>
<p>So the best thing to do is wait for <strong>version 5.0</strong> to be distributed!</p>
<p>In the mean time, happy coding :)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can wrap any blocking call into a Task using <code>run_in_executor</code> as described in <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" rel="nofollow noreferrer">documentation</a>, I also added in the example a custom <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for" rel="nofollow noreferrer">timeout</a>:</p>
<pre><code>def run_async_task(
    target,
    *args,
    timeout = 60,
    **keywords
) -&gt; Future:
    loop = asyncio.get_event_loop()
    return asyncio.wait_for(
        loop.run_in_executor(
            executor,
            functools.partial(target, *args, **keywords)
        ),
        timeout=timeout,
        loop=loop
    )
loop = asyncio.get_event_loop()
async_result = loop.run_until_complete(
    run_async_task, your_task.delay, some_arg, some_karg="" 
)
result = loop.run_until_complete(
    run_async_task, async_result.result 
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The cleanest way I've found to do this is to wrap the <code>async</code> function in <code>asgiref.sync.async_to_sync</code> (from <a href="https://github.com/django/asgiref/" rel="nofollow noreferrer"><code>asgiref</code></a>):</p>
<pre><code>from asgiref.sync import async_to_sync
from celery.task import periodic_task


async def return_hello():
    await sleep(1)
    return 'hello'


@periodic_task(
    run_every=2,
    name='return_hello',
)
def task_return_hello():
    async_to_sync(return_hello)()
</code></pre>
<p>I pulled this example from a <a href="https://johnfraney.ca/2018/12/20/writing-unit-tests-celery-tasks-async-functions/" rel="nofollow noreferrer">blog post</a> I wrote.</p>
</div>
<span class="comment-copy">Can you clarify what you mean by 'look like'. I think maybe you misinterpret Asksol's comment - you put celery infront of frameworks such as Rabbit or SQS that is the async manager. As such you could possibly make a broker / plugin for celery which uses asyncio, but the tasks wouldn't "look like" (i.e. have the interface of) asyncio? The point of celery is to abstract the asynchronus methodology used?</span>
