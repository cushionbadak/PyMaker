<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/21680473/how-can-i-open-multiple-files-number-of-files-unknown-beforehand-using-with-o">How can I open multiple files (number of files unknown beforehand) using “with open” statement?</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>Is it possible to <code>with open()</code> all files contained in a list and create file handles for writing?</p>
<p>For example, if my function accepts a list of filenames for data-splitting in a machine learning task, </p>
<p><code>fname_list = ['train_dataset.txt', 'validate_dataset.txt', 'test_dataset.txt']</code></p>
<p>then it would be convenient to be able to do:</p>
<pre><code>with open('source_dataset.txt) as src_file, open(name_list, 'w') as &lt;DONT_KNOW_WHAT_TO_DO_HERE&gt;:
</code></pre>
<p>And perform some data splitting within the block.</p>
<p><strong>Edit: So my question is basically "Is it possible to obtain multiple file handles for a list of files opened with 'with open()'?"</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.3 and higher, <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow"><code>contextlib.ExitStack</code></a> can be used to do this correctly and nicely:</p>
<pre><code>from contextlib import ExitStack

with open('source_dataset.txt') as src_file, ExitStack() as stack:
    files = [stack.enter_context(open(fname, 'w')) for fname in fname_list]
    ... do stuff with src_file and the values in files ...
... src_file and all elements in stack cleaned up on block exit ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can define a class <code>openfiles</code> to support the <code>with</code> statement:</p>
<pre><code>class openfiles:
    def __init__(self, filelist, mode='r'):
        self.fhandles = [open(f, mode) for f in filelist]

    def __enter__(self):
        return self.fhandles

    def __exit__(self, type, value, traceback):
        map(file.close, self.fhandles)
</code></pre>
<p>Then you can:</p>
<pre><code>with openfiles(['file1', 'file2']) as files:
    for f in files:
        print(f.read())
</code></pre>
</div>
<span class="comment-copy">I am not sure about how to create multiple file handles for the list of files. ...open(name_list, 'w') as &lt;DONT_KNOW_WHAT_TO_DO_HERE&gt;:</span>
<span class="comment-copy">Why not iterate over a list of filenames, open and read them, and store the string data for each one in a list to be used later?</span>
<span class="comment-copy">Since a dataset may contain millions of lines, wouldn't doing such increase the overhead to (1 million) x len(list_of_filenames) ?  Or perhaps this is some optimization I should not worry about?</span>
<span class="comment-copy">Well still. Just iterate over the file name list, and open each file. Then do your business with that file. Whether it's reading the text or whatever.</span>
<span class="comment-copy">I see what you meant. Open each file and save respective file handle into a list, perform read and write, and then close all handles in the list?  But I suppose "with open()" cannot be used in this scenario?</span>
<span class="comment-copy"><code>ExitStack</code> is an especially good tool for this because it behaves nicely even if an exception occurs when opening one of the later files (after previous ones were opened successfully). Most naive solutions will leak open files in that situation (until the garbage collector cleans up the file objects).</span>
<span class="comment-copy">@Blckknght: Yup. I didn't want to go into the details for fear of masking the simplicity (the docs link covers it anyway), but yeah, the fact that it does it <i>correctly</i> is not a small thing, as you say.</span>
<span class="comment-copy">Wow! Thats super elegant!</span>
<span class="comment-copy">@LegoStormtroopr: Super elegant, but utterly wrong if the second or subsequent file <code>open</code> fails (also, using <code>map</code> for the <code>close</code> is bad form, creating unnecessary <code>list</code>s of <code>None</code>s, and doesn't even work on Py3). In that case, none of the files opened so far are closed deterministically. It's because it's so easy to get this pattern wrong that <code>ExitStack</code> was created.</span>
<span class="comment-copy">Thanks for the details on that.</span>
