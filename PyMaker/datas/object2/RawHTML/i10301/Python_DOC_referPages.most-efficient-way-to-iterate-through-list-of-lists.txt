<div class="post-text" itemprop="text">
<p>I'm currently collecting data from quandl and is saved as a list of lists. The list looks something like this (Price data):</p>
<pre><code>['2', 1L, datetime.date(1998, 1, 2), datetime.datetime(2016, 9, 26, 1, 35, 3, 830563), datetime.datetime(2016, 9, 26, 1, 35, 3, 830563), '82.1900', '83.6200', '81.7500', '83.5000', '28.5183', 1286500.0]
</code></pre>
<p>This is typically 1 of about 5000 lists, and every once in awhile Quandl will spit back some <code>NaN</code> values that don't like being saved into the database.</p>
<pre><code>['2', 1L, datetime.date(1998, 1, 2), datetime.datetime(2016, 9, 26, 1, 35, 3, 830563), datetime.datetime(2016, 9, 26, 1, 35, 3, 830563), 'nan', 'nan', 'nan', 'nan', 'nan', 0]
</code></pre>
<p>What would be the most efficient way of iterating through the list of lists to change 'nan' values into zeros?</p>
<p>I know I could do something like this, but it seems rather inefficient. This operation will need to be performed on 11 different values * 5000 different dates * 500 companies:</p>
<pre><code>def screen_data(data):
    new_data = []
    for d in data:
        new_list = []
        for x in d:
            new_value = x
            if math.isNan(x):
                new_value = 0
            new_list.append(new_value)

        new_data.append(new_list)
    return new_data
</code></pre>
<p>I would be interested in any solution that could reduce the time. I know DataFrames might work, but not sure how it would solve the NaN issue.</p>
<p>Or if there is a way to include NaN values in an SQLServer5.6 database along with floats, changing the database is also a viable option.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't create a new list - rather, edit the old list in-place:</p>
<pre><code>import math

def screenData(L):
    for subl in L:
        for i,n in enumerate(subl):
            if math.isnan(n): subl[i] = 0
</code></pre>
<p>The only way I can think of, to make this faster, would be with multiprocessing</p>
</div>
<div class="post-text" itemprop="text">
<p>I haven't timed it but have you tried using <a href="https://docs.python.org/3.5/tutorial/datastructures.html#nested-list-comprehensions" rel="nofollow">nested list comprehension</a> with <a href="https://docs.python.org/3.5/reference/expressions.html#conditional-expressions" rel="nofollow">conditional expressions</a>Â ?</p>
<p>For example:</p>
<pre><code>import datetime

data = [
    ['2', 1, datetime.date(1998, 1, 2),
     datetime.datetime(2016, 9, 26, 1, 35, 3, 830563),
     datetime.datetime(2016, 9, 26, 1, 35, 3, 830563),
     '82.1900', '83.6200', '81.7500', '83.5000',
     '28.5183', 1286500.0],
    ['2', 1, datetime.date(1998, 1, 2),
     datetime.datetime(2016, 9, 26, 1, 35, 3, 830563),
     datetime.datetime(2016, 9, 26, 1, 35, 3, 830563),
     'nan', 'nan', 'nan', 'nan', 'nan', 0],
]

new_data = [[y if str(y).lower() != 'nan' else 0 for y in x] for x in data]

print(new_data)
</code></pre>
<p>I did not use <code>math.isnan(y)</code> because you have to be sure that <code>y</code> is a <a href="https://docs.python.org/3.5/library/functions.html#float" rel="nofollow">float number</a> or you'll get an error. This is much more difficult to do while almost everything has a string representation. But I still made sure that I did the lower case comparison to 'nan' (with <a href="https://docs.python.org/3.5/library/stdtypes.html#str.lower" rel="nofollow">.lower()</a>) since 'NaN' or 'Nan' are legal ways to express "Not a Number". </p>
</div>
<div class="post-text" itemprop="text">
<p>how about this</p>
<pre><code>import math

def clean_nan(data_list,value=0):
    for i,x in enumerate(data_list):
        if math.isnan(x):
            data_list[i] = value
    return data_list 
</code></pre>
<p>(the return is optional, as the modification was made in-place, but it is needed if used with <code>map</code> or similar, assuming of course that data_list is well a list or similar container)</p>
<p>depending on how you get your data and how you work with it will determined how to use it, for instance if you do something like this</p>
<pre><code>for data in (my database/Quandl/whatever):
    #do stuff with data
</code></pre>
<p>you can change it to</p>
<pre><code>for data in (my database/Quandl/whatever):
    clean_nan(data)
    #do stuff with data
</code></pre>
<p>or use <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow">map</a> or if you are in python 2 <a href="https://docs.python.org/2.7/library/itertools.html#itertools.imap" rel="nofollow">imap</a></p>
<pre><code>for data in map(clean_nan,(my database/Quandl/whatever)):
    #do stuff with data
</code></pre>
<p>that way you get to work with your data as soon as that arrive from the database/Quandl/whatever, granted if the place where you get the data also work as a generator, that is don't process the whole thing all at once, and if it does, procure to change it to a generator if possible. In either case with this you get to work with your data as soon as possible.</p>
</div>
<span class="comment-copy">This is probably better on codereview.stackexchange.com, but what you've described sounds like you will have to check every value in every list.</span>
<span class="comment-copy">I was thinking of this, too, but you could shore it up even more with a quick check to see if a nested list-comp even needed: <code>new_data = [[0 if element == 'nan' else element for element in L] if 'nan' in L else L for L in data]</code> If <code>"nan"</code> is getting pushed out of a single generator (rather than being entered manually), you probably don't need to check for variations on it.</span>
<span class="comment-copy">Yeah, I didn't thought about it but it would be faster indeed especially if it only happens "every once in awhile" like OP said.</span>
