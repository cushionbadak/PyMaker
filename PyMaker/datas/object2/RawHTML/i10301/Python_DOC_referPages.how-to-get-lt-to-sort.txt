<div class="post-text" itemprop="text">
<pre><code>class City:
    def __init__(self, string):
        self._string = string.split(',')
        self._name = self._string[0]
        self._state = self._string[1]
        self._latitude = self._string[2]
        self._longitude = self._string[3]
        self._location = [self._latitude, self._longitude]

    def name(self):
        return self._name

    def location(self):
        return self._location
        self.hand.sort(key=lambda x: x.longitude)

    def __lt__(self, other):
        if self._longitude &lt; other._longitude:
            return True
        if self._longitude &gt; other._longitude:
            return False
        if self._longitude == other._longitude:
            if self._latitude &lt; other._latitude:
                return True
            if self._latitude &gt; other._latitude:
                return False

citystrings = ["Charleston,WV,38.35,81.63",
              "Charlotte,NC,35.23,80.83",
              "Cheyenne,WY,41.15,104.87",
              "Chicago,IL,41.83,87.62",
              "Cincinnati,OH,39.13,84.50",
              "Cleveland,OH,41.47,81.62",
              "Columbia,SC,34.00,81.03",
              "Columbus,OH,40.00,83.02",
              "Dallas,TX,32.77,96.77",
              "Denver,CO,39.75,105.00"]
westtoeastnames = [
            "Denver",
            "Cheyenne",
            "Dallas",
            "Chicago",
            "Cincinnati",
            "Columbus",
            "Charleston",
            "Cleveland",
            "Columbia",
            "Charlotte",
          ]
cities = [City(s) for s in citystrings]
cities.sort()
sortednames = [c.name() for c in cities]
print(sortednames)
print(westtoeastnames)
['Cheyenne', 'Denver', 'Charlotte', 'Columbia', 'Cleveland', 'Charleston', 'Columbus', 'Cincinnati', 'Chicago', 'Dallas']
['Denver', 'Cheyenne', 'Dallas', 'Chicago', 'Cincinnati', 'Columbus', 'Charleston', 'Cleveland', 'Columbia', 'Charlotte']
</code></pre>
<p>This code tries to use <code>__lt__()</code> to sort the cities by how far they are west and the longitudes are based west of the prime meridian. I wrote an <code>__lt__()</code> method in the class but the <code>citystrings</code> won't sort to the correct order.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are comparing your longitude and latitude as <em>strings</em>, not numbers. They are therefor compared lexicographically, not numerically, so <code>'104'</code> will sort <em>before</em> <code>'80'</code> because <code>'1'</code> comes before <code>'8'</code> in the ASCII table (it doesn't matter what other characters follow).</p>
<p>Convert your values to floating point numbers:</p>
<pre><code>self._latitude = float(self._string[2])
self._longitude = float(self._string[3])
</code></pre>
<p>Your comparison has a small bug; if both longitude and latitude match, you return <code>None</code> instead of <code>False</code>. You <em>may</em> want to test for equality and apply the <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow"><code>@functools.total_ordering()</code> decorator</a> rather than assume that only <code>__lt__()</code> is called.</p>
<p>Cleaning up the code a little (and removing the <code>name()</code> and <code>location()</code> methods, just use <code>name</code> and <code>location</code> attributes):</p>
<pre><code>from functools import total_ordering

@total_ordering
class City:
    def __init__(self, string):
        self.name, self.state, lat, long = string.split(',')
        self.location = (self._latitude, self._longitude) = float(lat), float(long)

    def __lt__(self, other):
        if not isinstance(other, City):
            return NotImplemented
        # tuples defer ordering to the contents; compare them
        # in (longitude, latitude) order so that if longitude is 
        # equal, the outcome is based on latitude.
        return self.location[::-1] &lt; other.location[::-1]

    def __eq__(self, other):
        if not isinstance(other, City):
            return NotImplemented
        return self.location == other.location
</code></pre>
<p>Note that <code>__lt__()</code> really only needs to compare <code>self.location</code>; tuple ordering takes care of the rest:</p>
<pre><code>sortednames = [c.name for c in sorted(map(City, citystrings), reverse=True)]
</code></pre>
<p>Note the <code>reverse=True</code>; you want the larger values (further west from Greenwich) to be listed first.</p>
</div>
<span class="comment-copy">Show how you've tried to sort.</span>
<span class="comment-copy">Could you please write down an example on how are you using this method? And it would also be helpful to see the incorrect output</span>
<span class="comment-copy">If your function is comparing cities and sorting them, I would write the def <b>lt()</b> method outside of the class, as it is an operation on a higher level</span>
<span class="comment-copy">Don't know if it is relevant but the <code>location</code> method has a statement after a <code>return</code> statement - it will never execute.</span>
<span class="comment-copy">Note that <i>numbers</i> have a different order than strings! You should convert latitude/longitude to <code>float</code>s: self._latitude = float(self._string[2])`.</span>
<span class="comment-copy">DING DING DING. Wow thanks, I couldn't understand why it wouldn't work!</span>
