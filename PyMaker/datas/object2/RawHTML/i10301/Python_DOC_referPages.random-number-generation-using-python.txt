<div class="post-text" itemprop="text">
<p>I'm looking to create random numbers since due to circumstances I cannot use the <code>random</code> library. Basically I'd like to be able to replicate the <code>random.randint()</code> and <code>random.random()</code> methods using pure python.</p>
<p>I don't expect anyone to dump an entire code in python (though that would be great), but can someone refer me to a similar C/C++/Java algorithm that can be easily replicated into python?</p>
<p>EDIT: I'm looking for references on how to create random numbers using python code, not reasons why I shouldn't do it myself and find a way to use <code>random</code> or <code>numpy.random</code> at any cost</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you are forced to use on online IDE, I will assume that this is course work and you do not need the latest and greatest and most reliable random number generator.  Instead, you simply need something just adequate for completing ephemeral class assignments.</p>
<p>If that is the case, a common algorithm for generating random numbers is the <em>linear congruential generator</em>.  With typical parameters:</p>
<pre><code>&gt;&gt;&gt; def r(seed=[0], m=2**32, a=1664525, c=1013904223):
...   seed[0] = (a*seed[0] + c) % m
...   return seed[0]
... 
</code></pre>
<p>This algorithm returns supposedly random integers from 0 to (2**32)-1.</p>
<p>Here are some sample results:</p>
<pre><code>&gt;&gt;&gt; r()
1013904223
&gt;&gt;&gt; r()
1196435762
&gt;&gt;&gt; r()
3519870697
</code></pre>
<p>You can read more about this algorithm <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator" rel="nofollow">here</a>.</p>
<p>This algorithm will always start from the same point after the function is defined unless you change the seed.</p>
<p>Again, this is not for serious work for which the quality of the results is important.</p>
<h3>Simulating <code>random.random</code> and <code>random.randint</code></h3>
<p>To return a "random" number between zero and one, <code>[0,1)</code>, and using the above function <code>r</code>:</p>
<pre><code>def random():
    return r() / 2**32
</code></pre>
<p>Likewise for <code>random.randint</code>:</p>
<pre><code>def randint(a, b):
    return int(a + (1 + b - a) * r() / 2**32)
</code></pre>
<p>If the <code>m</code> value in <code>r</code> is changed, then <code>2**32</code> should be changed here as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you can't use <code>random</code>, but you can use <code>os</code>, you could always use <a href="https://docs.python.org/3/library/os.html#os.urandom" rel="nofollow"><code>os.urandom</code></a> to get random bytes, then convert them as needed.</p>
<p>For example, using <code>os.urandom</code>, it's trivial to implement <code>random.random</code>'s 
behavior (and in fact, <a href="https://hg.python.org/cpython/file/3.5/Lib/random.py#l656" rel="nofollow"><code>random.SystemRandom</code> implements it precisely this way</a>):</p>
<pre><code>import os

BPF = 53  # Bit per float
RECIP_BPF = 2**-BPF

def random():
    return (int.from_bytes(os.urandom(7), 'big') &gt;&gt; 3) * RECIP_BPF
</code></pre>
<p>If you click the source link about, you'll note that <code>random.SystemRandom</code> really only implements a couple methods as "core" features, and the rest of its implementation is borrowed from the regular <code>random.Random</code> class; you can always borrow the <code>getrandbits</code> of <code>SystemRandom</code> then use it to implement <code>randrange</code>, <code>randint</code>, etc., the same way Python does it.</p>
</div>
<span class="comment-copy">What sort of random numbers are you generating that can't be encompassed by the <code>random</code> or <code>numpy</code> libraries?</span>
<span class="comment-copy"><a href="https://en.wikipedia.org/wiki/Mersenne_Twister" rel="nofollow noreferrer">Mersenne Twister Wikipedia page</a> has both the algorithm and a Python implementation. In fact, Wikipedia also has a <a href="https://en.wikipedia.org/wiki/List_of_random_number_generators" rel="nofollow noreferrer">list of pseudorandom number generators</a>.</span>
<span class="comment-copy">Just implement a <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator" rel="nofollow noreferrer">linear-congruential prng</a> (few lines) and then implement randint from that.</span>
<span class="comment-copy">If your IDE supports <code>ctypes</code> you may be able to import the libc <code>srand</code> and <code>rand</code> functions and use them.</span>
<span class="comment-copy">@WhiteTiger Did you consider wikipedia? It answers your question about MTs output.</span>
<span class="comment-copy">Time to add the desired randint() function (taking low and max bounds; with good statistical properties). As recognizable by reading my comment above, i also think this approach is the best first step, sticking to a simple, but well-parameterized LCG!</span>
<span class="comment-copy">@sascha OK.  I added code for <code>random.random</code> and <code>random.randint</code>.</span>
<span class="comment-copy">Nice approach, but keep in mind: it's super slow and it's not deterministic/repeatable (which are both important constraints in most non-cryptographic applications of PRNGS).</span>
<span class="comment-copy">@sascha: Slow is relative, dependent on Python and OS version, etc. For most practical purposes, <code>SystemRandom</code>'s <code>random</code> function is fast enough; sure, you can call <code>Random</code>'s <code>random</code> approximately 10x faster (on my Windows Python 3.5 install), but with both times measured in nanoseconds (84 and 805 on my system), unless you need to produce 10,000+ values per second, it would be a small part of your runtime, you're unlikely to notice. Admittedly, the lack of repeatability could be an issue depending on needs, but the OP didn't ask for a <code>seed</code> function, so this is fine if you don't need it.</span>
