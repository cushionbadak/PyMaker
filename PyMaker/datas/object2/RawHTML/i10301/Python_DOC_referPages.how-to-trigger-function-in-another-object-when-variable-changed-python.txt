<div class="post-text" itemprop="text">
<p>As far as I know, this is like an Observer pattern. 
Scenario: <strong>A Center object keeps a list (queue) of all its clients.</strong> I'm using Twisted.</p>
<ol>
<li>One of client objects <strong>changes a variable</strong> in center object OR notify the center to change the variable, </li>
<li>and then the center object <strong>detects the change</strong> immediately; </li>
<li>then as soon as the detection, the center object invoke some function <strong>of next object</strong> in queue</li>
<li>After the client changed the variable, <strong>the client object will be <em>eliminated.</em></strong> The center will take care of next client object. So I imagine there's no any function chain between these objects. So it's a little bit different from observer pattern.  (How to address this issue? Correct me if I'm wrong.)</li>
</ol>
<p>following code is just for demo only:</p>
<pre><code>    class client():
        def change(self):
            self.center.va = 1

        def inqueue(self):
            self.center.queue.enqueue(self)

        def function(self):
            pass

    class center():
        def __init__(self):
            self.queue = None
            self.va = 0

        ####  When the self.va changes, this func will be invoked
        def whenChanged(self):
            next = self.queue.dequeue()
            next.function()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Whenever a property of class is changed, <a href="https://docs.python.org/2/library/functions.html#setattr" rel="nofollow"><code>setattr()</code></a> function is called. You can override this by defining <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow"><code>__setattr__(self, property, value)</code></a> function in your class.</p>
<p>You need to make you required function call within this <code>__ setattr__()</code>. Below is the sample example based on your requirement:</p>
<pre><code>class Centre(object):
    def __init__(self):
        self.queue = None
        self.va = 0

    def whenChanged(self):
        next = self.queue.dequeue()
        next.function()

    def __setattr__(self, key, value):
        self.key = value
        self.whenChanged() &lt;-- Your function
</code></pre>
<p>Whenever you will attempt to change the value of any of class's property, this <code>__settattr__</code> function will be called.</p>
</div>
<div class="post-text" itemprop="text">
<p>Make <code>va</code> a property.</p>
<pre><code>class Center():
    def __init__(self):
        self.queue = None
        self._va = 0

    @property
    def va(self):
        return self._va

    @va.setter
    def va(self, value):
        self._va = value
        self.whenChanged()

    def whenChanged(self):
        next = self.queue.dequeue()
        next.function()
</code></pre>
</div>
<span class="comment-copy">Perhaps define a <a href="http://stackoverflow.com/a/2627034/6779606">setter/getter property</a>.</span>
<span class="comment-copy">I'm using Twisted, and it seems that I cannot use new-style class. Can I still use this?</span>
<span class="comment-copy">It is the part of core Python. You can use it with any flavor of Python. Made an edit with sample code</span>
<span class="comment-copy">you said: " this <code>__settattr__</code> function will be called."  but <code>__setattr__</code> will be called by who?</span>
<span class="comment-copy">Did you checked the document linked to <code>__setattr__()</code>? Whenever a value is assigned to class's property,this function is called. For example, on doing <code>self.va = 9</code>, for assigning the value as <code>9</code>, this function is called</span>
<span class="comment-copy">Yes, I checked that out. So I assume that if I have this assignment: <code>center.va = 9</code> in a <code>client</code> object, then the <code>center</code> object will invoke the <code>__setattr__()</code> and there's no function invocation chain between <code>center</code> object and <code>client</code> object, right?</span>
<span class="comment-copy">I assume that va setter will called in first client, right? So does this solve the issue that the first client will be eliminated before this setter invocation return?</span>
<span class="comment-copy">The setter is invoked immediately upon <code>self.center.va = 1</code>, before <code>client.change</code> exits, so it runs before the client goes away.</span>
<span class="comment-copy">What if the client must leave while or before this invocation chain returns?</span>
<span class="comment-copy">btw, i cannot sue property since I'm inheriting old style class.</span>
<span class="comment-copy">You appear to have left a lot of important context out of your question.</span>
