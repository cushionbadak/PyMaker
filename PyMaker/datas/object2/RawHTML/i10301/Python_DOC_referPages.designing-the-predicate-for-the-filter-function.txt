<div class="post-text" itemprop="text">
<p>I have this in built filter function for my homework.</p>
<pre><code>def filter(pred, seq):
    if seq == ():
        return ()
    elif pred(seq[0]):
        return (seq[0],) filter(pred, seq[1:])
    else:
        return filter(pred, seq[1:])
</code></pre>
<p>We are supposed to convert a give function to one that has only one return line using the designed filter function (which overwrites the more powerful python version). </p>
<p>The code that we are supposed to convert is this: </p>
<pre><code>def lookup_bus_stop_by_road(stops, road):
    matched = ()
    for bus_stop in stops:
        if get_road_name(bus_stop) == road:
            matched = matched + (bus_stop, )
    return matched
</code></pre>
<p>my question is: how am i supposed to convert the predicate for my filter function by adapting from the given lookup_bus_Stop_by_road function? But I have always got the TypeError: bool object not callable. </p>
<p>This is the return line i have put in: </p>
<pre><code>def lookup_bus_stop_by_road(stops, road):
    return filter(get_road_name(bus_stops) == road, stops)
</code></pre>
<p>what is wrong here?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>get_road_name(bus_stops) == road 
</code></pre>
<p>is a boolean value, not a function.  What you want to do is create a function that calls <code>get_road_name</code> and checks if the result is equal to <code>road</code></p>
<pre><code>filter(lambda x: get_road_name(x) == road, stops)
</code></pre>
<p>For more reading on this topic see here: <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow">https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions</a></p>
</div>
<span class="comment-copy">Alright thank you so much! initially i used something like lambda x: road == x[1]. The idea you suggested prevents me from breaking the abstraction</span>
