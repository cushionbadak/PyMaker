<div class="post-text" itemprop="text">
<p>I have a device that returns a UTF-8 encoded string. I can only read from it byte-by-byte and the read is terminated by a byte of value 0x00.</p>
<p>I'm making a Python 2.7 function for others to access my device and return string.</p>
<p>In a previous design when the device just returned ASCII, I used this in a loop:</p>
<pre><code>x = read_next_byte()
if x == 0:
    break
my_string += chr(x)
</code></pre>
<p>Where x is the latest byte value read from the device.</p>
<p>Now the device can return a UTF-8 encoded string, but I'm not sure how to convert the bytes that I get back into a UTF-8 encoded string/unicode. </p>
<p><code>chr(x)</code> understandably causes an error when the x&gt;127, so I thought that using <code>unichr(x)</code> may work, but that assumes the value passed is a full unicode character value, but I only have a part 0-255.</p>
<p>So how can I convert the bytes that I get back from the device into a string that can be used in Python and still handle the full UTF-8 string?</p>
<p>Likewise, if I was given a UTF-8 string in Python, how would I break that down into individual bytes to send to my device and still maintain UTF-8?</p>
</div>
<div class="post-text" itemprop="text">
<p>The correct solution would be to read until you hit the terminating byte, then convert to UTF-8 at that time (so you have all characters):</p>
<pre><code>mybytes = bytearray()
while True:
    x = read_next_byte()
    if x == 0:
        break
    mybytes.append(x)
my_string = mybytes.decode('utf-8')
</code></pre>
<p>The above is the most direct translation of your original code. Interestingly, this is one of those cases where <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow">two arg <code>iter</code></a> can be used to dramatically simplify the code by making your C-style stateful byte reader function into a Python iterator that lets you one-line the work:</p>
<pre><code># If this were Python 3 code, you'd use the bytes constructor instead of bytearray
my_string = bytearray(iter(read_next_byte, 0)).decode('utf-8')
</code></pre>
</div>
<span class="comment-copy">Fantastic. That seems to work great. So to do the opposite and encode a bytearray I could use this right?    <code>my_bytes = bytearray(my_string, 'utf-8')</code>  and just loop over <code>my_bytes</code> to send the individual bytes.</span>
<span class="comment-copy">@Will: Yup. In Py3, it's somewhat more intuitive to do <code>my_string.encode('utf-8')</code> (which gets you <code>bytes</code>, which behave like immutable <code>bytearray</code>s in Py3); in Py2 though, <code>encode</code> gets you <code>str</code>, which iterates by <code>len</code> 1 <code>str</code> of its characters, instead of by <code>int</code>s from 0-255. Either way, you can iterate the result and call a write function: <code>for b in bytearray(my_string, 'utf-8'): write_one_byte(b)</code></span>
