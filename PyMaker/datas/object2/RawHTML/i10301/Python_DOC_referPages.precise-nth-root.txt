<div class="post-text" itemprop="text">
<p>I'm looking for Python Nth root function/algorithm but before you post: NO INTEGER ROOT, HELL!<br/>
Where could I obtain at least a guide how to program <strong>Nth root function that produces precise <code>float</code>/<code>Decimal</code></strong>?<br/>
Such function that <strong>doesn't return <code>1</code> nor <code>0</code> for <code>root(125, 1756482845)</code></strong> (1st argument is the number, 2nd is the root depth (or something)).</p>
<p><strong>EDIT:</strong> So, you were giving me this solution: <code>n ** (1.0 / exp)</code> which I knew when I asked this question, but it just doesn't work for, for example, <code>exp = 3</code>. You can't express <code>1/3</code> in terms of rational numbers, so <code>125 ** (1/3)</code> gives incorrect result <code>4.999999...</code>. I was asking for some "smart" algorithm, which gives correct result for such nice numbers and at least 4-decimal-points-accurate result for rational <code>exp</code>. If there isn't such function or algorithm, I will use this (<code>n ** (1/exp)</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>I would try the <a href="https://pypi.python.org/pypi/gmpy2" rel="noreferrer">gmpy2</a> library.</p>
<pre><code>&gt;&gt;&gt; import gmpy2
&gt;&gt;&gt; gmpy2.root(125,3)
mpfr('5.0')
&gt;&gt;&gt; 
</code></pre>
<p><code>gmpy2</code> uses the <a href="http://www.mpfr.org/" rel="noreferrer">MPFR</a> library to perform correctly rounded floating point operations. The default precision is 53 bits but that can be increased.</p>
<pre><code>&gt;&gt;&gt; gmpy2.root(1234567890123456789**11, 11)
mpfr('1.2345678901234568e+18')  # Last digits are incorrect.
&gt;&gt;&gt; gmpy2.get_context().precision=200
&gt;&gt;&gt; gmpy2.root(1234567890123456789**11, 11)
mpfr('1234567890123456789.0',200)
&gt;&gt;&gt; 
</code></pre>
<p>Disclaimer: I maintain <code>gmpy2</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do a binary search on the answer. If you want to find the X that is equal to the kth root of N, you can do a binary search on X testing for each step of the binary search whether X^k equals N +- some small constant to avoid precision issues.</p>
<p>Here is the code:</p>
<pre><code>import math

N,K = map(float,raw_input().split()) # We want Kth root of N
lo = 0.0
hi = N
while 1:
    mid = (lo+hi)/2
    if math.fabs(mid**K-N) &lt; 1e-9: # mid^K is really close to N, consider mid^K == N
        print mid
        break
    elif mid**K &lt; N: lo = mid
    else: hi = mid
</code></pre>
<p>For (N,K) = (125,3) it prints 5.0, the correct answer. You can make it more precise by changing the 1e-9 constant, but there is a precision limit related to the float variables precision limit in Python</p>
</div>
<div class="post-text" itemprop="text">
<p>You mean something like that:</p>
<pre><code>&gt;&gt;&gt; 125**(1/9.0)
1.7099759466766968
</code></pre>
<p>Something else that might interest you is <a href="https://pythonhosted.org/bigfloat/" rel="nofollow">bigfloat</a> module (haven't used personally just know it exists :) - actually had problem installing it in the past-maybe an OS X fault)</p>
</div>
<div class="post-text" itemprop="text">
<p>In Squeak Smalltalk, there is a <code>nthRoot:</code> message that answers the exact <code>Integer</code> result if ever the Integer receiver is exact nth power of some whole number. However, if the solution is an algebraic root, then the implementation does not fallback to a naive <code>n**(1/exp)</code>; the method rounds to nearest float by appropriate care of residual.</p>
<p>Relevant code (MIT license) is reproduced here. The base algorithm is searching for truncated nth root of an Integer with some Newton-Raphson:</p>
<pre><code>Integer&gt;&gt;nthRootTruncated: aPositiveInteger
    "Answer the integer part of the nth root of the receiver."
    | guess guessToTheNthMinusOne nextGuess |
    self = 0 ifTrue: [^0].
    self negative
        ifTrue:
            [aPositiveInteger even ifTrue: [ ArithmeticError signal: 'Negative numbers don''t have even roots.' ].
            ^(self negated nthRootTruncated: aPositiveInteger) negated].
    guess := 1 bitShift: self highBitOfMagnitude + aPositiveInteger - 1 // aPositiveInteger.
    [
        guessToTheNthMinusOne := guess raisedTo: aPositiveInteger - 1.
        nextGuess := (aPositiveInteger - 1 * guess * guessToTheNthMinusOne + self) // (guessToTheNthMinusOne * aPositiveInteger).
        nextGuess &gt;= guess ] whileFalse:
            [ guess := nextGuess ].
    ( guess raisedTo: aPositiveInteger) &gt; self  ifTrue:
            [ guess := guess - 1 ].
    ^guess
</code></pre>
<p>It's not particularly clever, because convergence can be very slow in case of huge exponent, but well, it works.
Then, the same root rounded away from zero:</p>
<pre><code>Integer&gt;&gt;nthRootRounded: aPositiveInteger
    "Answer the integer nearest the nth root of the receiver."
    | guess |
    self = 0 ifTrue: [^0].
    self negative
        ifTrue:
            [aPositiveInteger even ifTrue: [ ArithmeticError signal: 'Negative numbers don''t have even roots.' ].
            ^(self negated nthRootRounded: aPositiveInteger) negated].
    guess := self nthRootTruncated: aPositiveInteger.
    ^self * 2 &gt; ((guess + 1 raisedTo: aPositiveInteger) + (guess raisedTo: aPositiveInteger))
        ifTrue: [guess + 1]
        ifFalse: [guess]
</code></pre>
<p>Then exactness is tested in nthRoot:</p>
<pre><code>Integer&gt;&gt;nthRoot: aPositiveInteger
    "Answer the nth root of the receiver.
    Answer an Integer if root is exactly this Integer, else answer the Float nearest the exact root."

    | guess excess scaled nBits |
    guess := self nthRootRounded: aPositiveInteger.
    excess := (guess raisedTo: aPositiveInteger) - self.
    excess = 0 ifTrue: [ ^ guess ].

    nBits := Float precision - guess highBitOfMagnitude.
    nBits &lt;= 0 ifTrue: [ ^(Fraction numerator: guess * 4 - excess sign denominator: 4) asFloat].

    scaled := self &lt;&lt; (nBits * aPositiveInteger).
    guess := scaled nthRootRounded: aPositiveInteger.
    excess := (guess raisedTo: aPositiveInteger) - scaled.
    ^(Fraction numerator: guess * 4 - excess sign denominator: 1 &lt;&lt; (nBits + 2)) asFloat
</code></pre>
<p>This could be applied to Fraction too, but the nearest float is a bit more complex, and Squeak implementation is currently naive.</p>
<p>It works for large integers like:</p>
<ul>
<li><code>(10 raisedTo: 600) nthRoot: 300</code> -&gt; <code>100</code> "exact"</li>
<li><code>(10 raisedTo: 600) + 1 nthRoot: 300</code> -&gt; <code>100.0</code> "inexact"</li>
</ul>
<p>If you don't have such expectations, the initial guess could use inexact naive <code>n**(1/exp)</code>.</p>
<p>The code should be easy to port in Python and leaves a lot of place for optimization.</p>
<p>I didn't check what was available in Python, but maybe you'll need correctly rounded LargeInteger -&gt; Float, and Fraction -&gt; Float, like explained here (Smalltalk too, sorry about that, but the language does not really matter).</p>
<ul>
<li><a href="http://smallissimo.blogspot.fr/2011/09/clarifying-and-optimizing.html" rel="nofollow">http://smallissimo.blogspot.fr/2011/09/clarifying-and-optimizing.html</a></li>
<li><a href="http://smallissimo.blogspot.fr/2011/09/reviewing-fraction-asfloat.html" rel="nofollow">http://smallissimo.blogspot.fr/2011/09/reviewing-fraction-asfloat.html</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>It's the function <code>pow</code> of <code>math</code> module.</p>
<pre><code>import math
math.pow(4, 0.5) 
</code></pre>
<p>will return the square root of 4, which is <code>2.0</code>.</p>
<p>For <code>root(125, 1756482845)</code>, what you need to do is</p>
<pre><code>math.pow(125, 1.0 / 1756482845)
</code></pre>
</div>
<span class="comment-copy">I think either using the <code>**</code> operator or <code>math.pow</code> with some type casting will do and that's just as much as you can get from builtin functions in Python. I'm not aware of anything that produces more precise floating-point calculation in the built-in modules and functions of the language and would love to know that.  If you need to compute more precise result, try looking for computation methods to produce the N-th root. A starting point may be Newton's method. The point is you always have to specify your required threshold for absolute/relative error.</span>
<span class="comment-copy">All roots are either integers or irrational numbers. How precise you want the result to be? The decimal (or binary, for that matter) expansion of an irrational number cannot be precisely represented in finite memory.</span>
<span class="comment-copy">For an interesting read on how challenging this problem is, see <a href="http://bugs.python.org/issue27761" rel="nofollow noreferrer">bugs.python.org/issue27761</a></span>
<span class="comment-copy">Note that your question is a generalized version of <a href="http://stackoverflow.com/questions/18063755/computing-a-correctly-rounded-an-almost-correctly-rounded-floating-point-cubic" title="computing a correctly rounded an almost correctly rounded floating point cubic">stackoverflow.com/questions/18063755/â€¦</a> (you ask for any n, it's nontrivial when n is not a power of 2, and the linked question asks about 3). A solution that I did not bother to write up assumes that you have one extra bit of precision available and can compute <code>pow(candidate, n)</code> rounded up or down for final adjustments.</span>
<span class="comment-copy">take a look at <a href="http://stackoverflow.com/a/30962495/2521214">Power by squaring for negative exponents</a> especially bullet <b>#5</b> you can do this on floats/decimals too</span>
<span class="comment-copy"><code>return True if math.fabs(a-b) &lt; 1e-9 else False</code> is a rather verbose way to say <code>return math.fabs(a-b) &lt; 1e-9</code>; that'll return <code>True</code> and <code>False</code> just fine. Also note, as of Python 3.5, there is a more powerful/flexible version of that test available, <a href="https://docs.python.org/3/library/math.html#math.isclose" rel="nofollow noreferrer"><code>math.isclose</code></a>.</span>
<span class="comment-copy">Thank you for the tip! Fixing it</span>
<span class="comment-copy">If the <code>125 ** (1/3)</code> solution to compute the cubic root is not acceptable to the OP because of the approximation in the computation of 1/3, there is no reason that this answer, based on a hardcoded epsilon, would satisfy them. You need a correctly rounded <code>**</code> in either round-upwards or round-downwards at one extra bit of precision to make this work, and not use any epsilon, or you are just making matters worse on average.</span>
<span class="comment-copy">But wait, 1/9.0 isn't even one ninth to begin with, so how precise is this?</span>
<span class="comment-copy">@harold, just said an idea alternative to <code>math.pow</code>, now about how precise this is, this has to do with what you are looking for... I don't know if the OP is ok with the result, but don't forget that in math precision is something really relevant. Anyway do you have anything else to propose?</span>
<span class="comment-copy">@R.O.S.S, check out <code>bigfloat</code> module - maybe that does what you need - have updated the answer with the link</span>
<span class="comment-copy">This isn't precise, see <a href="http://stackoverflow.com/questions/15978781/how-to-find-integer-nth-roots" title="how to find integer nth roots">stackoverflow.com/questions/15978781/â€¦</a> - <code>5 ** 3 = 125</code>, but <code>125 ** (1.0 / 3) = 4</code>.</span>
<span class="comment-copy">I try  math.pow(125, 1.0 / 1756482845) ** 125 which returns 125.00000486047219 on my machine. It depends on what is your accepted level of relative/absolute error. For absolute error of 1e-5 the code words, doesn't it? Maybe you should elaborate your question regarding how precise you want the calculation to be.</span>
<span class="comment-copy"><code>math.pow</code> is pointless; the <code>**</code> operator accomplishes the same result, faster, and even if you wanted a function call, there is already a built-in (no import required) <code>pow</code> function. About the only thing <code>math.pow</code> does is force a <code>float</code> result even if the base and exponent are integer; losing precision unnecessarily isn't much of a selling point.</span>
