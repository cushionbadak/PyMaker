<div class="post-text" itemprop="text">
<p>Hi I'm looking for a way to split a list based on some values, and assuming the list's length equals to sum of some values, e.g.:</p>
<p>list: <code>l = ['a','b','c','d','e','f']</code>
values: <code>v = (1,1,2,2)</code>
so <code>len(l) = sum(v)</code></p>
<p>and I'd like to have a  function to return a tuple or a list, like: <code>(['a'], ['b'], ['c','d'], ['d','e'])</code></p>
<p>currently my code is like:</p>
<pre><code>(list1,list2,list3,list4) = (
    l[0:v[0]], 
    l[v[0]:v[0]+v[1]], 
    l[v[0]+v[1]:v[0]+v[1]+v[2]], 
    l[v[0]+v[1]+v[2]:v[0]+v[1]+v[2]+v[3]])`
</code></pre>
<p>I'm thinking about make this clearer, but closest one I have so far is (note the results are incorrect, not what I wanted)</p>
<pre><code>s=0
[list1,list2,list3,list4] = [l[s:s+i] for i in v]
</code></pre>
<p>the problem is I couldn't increase <code>s</code> at the same time while iterating values in <code>v</code>, I'm hoping to get a better code to do so, any suggestion is appreciated, thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe make a generator of the values in l?</p>
<pre><code>def make_list(l, v):
    g = (x for x in l)
    if len(l) == sum(v):
       return [[next(g) for _ in range(val)] for val in v]
    return None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you weren't stuck on ancient Python, I'd point you to <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow"><code>itertools.accumulate</code></a>. Of course, even on ancient Python, you could use the (roughly) equivalent code provided in the docs I linked to do it. Using either the Py3 code or equivalent, you could do:</p>
<pre><code>from itertools import accumulate  # Or copy accumulate equivalent Python code
from itertools import chain

# Calls could be inlined in listcomp, but easier to read here
starts = accumulate(chain((0,), v))  # Extra value from starts ignored when ends exhausted
ends = accumulate(v)
list1,list2,list3,list4 = [l[s:e] for s, e in zip(starts, ends)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could just write a simple loop to iterate over <code>v</code> to generate a result:</p>
<pre><code>l = ['a','b','c','d','e','f']
v = (1,1,2,2)
result = []
offset = 0

for size in v:
    result.append(l[offset:offset+size])
    offset += size

print result
</code></pre>
<p>Output:</p>
<pre><code>[['a'], ['b'], ['c', 'd'], ['e', 'f']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The idea here is using a nested loop. Assuming that your condition will always holds true, the logic then is to run through <code>v</code> and pick up <code>i</code> elements from <code>l</code> where <code>i</code> is an number from <code>v</code>. </p>
<pre><code>index = 0 # this is the start index
for num in v:
    temp = [] # this is a temp array, to hold individual elements in your result array.
    for j in range(index, index+num): # this loop will pickup the next num elements from l
        temp.append(l[j])
    data.append(temp)
    index += num
</code></pre>
<p>Output:
<code>[['a'], ['b'], ['c', 'd'], ['e', 'f']]</code></p>
<p>The first answer <a href="https://stackoverflow.com/a/39715361/5759063">https://stackoverflow.com/a/39715361/5759063</a> is the most pythonic way to do it. This is just the algorithmic backbone. </p>
</div>
<div class="post-text" itemprop="text">
<p>Best I could find is a two line solution:</p>
<pre><code>breaks=[0]+[sum(v[:i+1]) for i in range(len(v))]  #build a list of section indices
result=[l[breaks[i]:breaks[i+1]] for i in range(len(breaks)-1)]  #split array according to indices
print result
</code></pre>
</div>
<span class="comment-copy">Thanks! Actually I thought about list.popleft() and pop up the number of items I need, but this achieves the same thing for me!</span>
<span class="comment-copy">FYI, it's far more direct to convert <code>l</code> to an iterator with  <code>g = iter(l)</code>. That adds no per-item overhead, where making a generator expression adds per-item overhead.</span>
<span class="comment-copy">This is great! Our entire project is based on python 2.7, that's why I put python-2.7 tag, but still thanks so much for your answer, definitely what i'm looking for, will see if I can get equivalent codes for python 2.7</span>
<span class="comment-copy">Thanks! yes I'm aware of the algorithmic backbone, if I could increase the index then I can get the sublists.</span>
