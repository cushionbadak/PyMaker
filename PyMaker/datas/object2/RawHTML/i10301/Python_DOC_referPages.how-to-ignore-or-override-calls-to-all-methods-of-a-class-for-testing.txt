<div class="post-text" itemprop="text">
<p>I have set up a unit test that looks around like that:</p>
<pre><code>from unittest import TestCase
from . import main
from PIL import Image
class TestTableScreenBased(TestCase):
 def test_get_game_number_on_screen2(self):
        t = main.TableScreenBased()
        t.entireScreenPIL = Image.open('tests/1773793_PreFlop_0.png')
        t.get_dealer_position()
</code></pre>
<p>The function that I want to test is called get_dealer_position. In this function I'm updating some items on my gui which is not initialised for the test, so I get the expected error:<code>NameError: name 'ui_action_and_signals' is not defined</code></p>
<pre><code>def get_dealer_position(self):
    func_dict = self.coo[inspect.stack()[0][3]][self.tbl]
    ui_action_and_signals.signal_progressbar_increase.emit(5)
    ui_action_and_signals.signal_status.emit("Analyse dealer position")
    pil_image = self.crop_image(self.entireScreenPIL, self.tlc[0] + 0, self.tlc[1] + 0,
                                self.tlc[0] +800, self.tlc[1] + 500)
</code></pre>
<p>What is the best way to 'ignore' or override all calls to methods in that class <code>ui_action_and_signals</code>? This class contains plenty of methods (for hundreds of gui items) and I would prefer not to have to override each of them separately. Is there a way to tell the python test that everything related to the ui_action_and_signals should be ignored? Is there any elegant way with monkey patching or mocking that would use application in this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using Python &gt;= 3.3 you can use the built in <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow">unittest.mock</a> module.  If you are using an earlier version of Python you can use the same tools by installing <a href="https://pypi.python.org/pypi/mock" rel="nofollow">the backport</a> using Pip.</p>
<p>You will need to replace your missing dependency with a Mock object - there are many ways to do it, but one way is to use the patch decorator which takes care of removing the Mock object after the test:</p>
<pre><code>from unittest.mock import patch
from unittest import TestCase
from . import main
from PIL import Image
class TestTableScreenBased(TestCase):
    @patch('module.path.of.ui_action_and_signals')
    def test_get_game_number_on_screen2(self, mock_ui_action_and_signals):
        t = main.TableScreenBased()
        t.entireScreenPIL = Image.open('tests/1773793_PreFlop_0.png')
        t.get_dealer_position()
</code></pre>
<p>There is more information about the patch decorator <a href="https://docs.python.org/3/library/unittest.mock-examples.html#patch-decorators" rel="nofollow">in the official documentation</a> including some <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow">hints on where to patch</a> which is sometimes not entirely obvious.</p>
<p>The mock system has many other features which you might want to use, such as duplicating the spec of an existing class, or finding out what calls were made to your Mock object during the test.</p>
</div>
