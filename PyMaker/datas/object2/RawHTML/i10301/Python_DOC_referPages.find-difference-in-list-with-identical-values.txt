<div class="post-text" itemprop="text">
<p>I need to be able to find differences in list that may have identical values to one another besides two added elements</p>
<p>example</p>
<pre><code>a = ['cool task', 'b', 'another task', 'j', 'better task', 'y']
b = ['cool task', 'b', 'a task', 'j', 'another task', 'j', 'better task', 'y']
</code></pre>
<p>How my problem is, both <code>'a task'</code> and <code>'another task'</code> both are followed by a <code>'j'</code></p>
<pre><code>[x for x in b if x not in a]
['a task']
</code></pre>
<p>Because both <code>a</code> and <code>b</code> contain <code>'j'</code>, it is removed from the list.</p>
<p>How would I make so that I end up with </p>
<pre><code>['a task', 'j']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For <strong>simple list</strong> - what you ask is simply searching for that next item in the list:</p>
<pre><code>&gt;&gt;&gt; a = ['cool task', 'b', 'another task', 'j', 'better task', 'y']
&gt;&gt;&gt; b = ['cool task', 'b', 'a task', 'j', 'another task', 'j', 'better task', 'y']
&gt;&gt;&gt; c = [[x, b[b.index(x) + 1]] for x in b if x not in a]
&gt;&gt;&gt; c
[['a task', 'j']]
</code></pre>
<p>But I think you are actually aiming at using dictionary or tuples.</p>
<p><strong>Tuples:</strong></p>
<pre><code>&gt;&gt;&gt; a = [('cool task', 'b'), ('another task', 'j'), ('better task', 'y')]
&gt;&gt;&gt; b = [('cool task', 'b'), ('a task', 'j'), ('another task', 'j'), ('better task', 'y')]
&gt;&gt;&gt; c = [x for x in b if x not in a]
&gt;&gt;&gt; c
[('a task', 'j')]
</code></pre>
<p><strong>Dictionaries:</strong></p>
<pre><code>&gt;&gt;&gt; a = {'cool task': 'b', 'another task': 'j', 'better task': 'y'}
&gt;&gt;&gt; b = {'cool task': 'b', 'a task': 'j', 'another task': 'j', 'better task': 'y'}
&gt;&gt;&gt; c = [(x, b[x]) for x in b if x not in a]
&gt;&gt;&gt; c
[('a task', 'j')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="https://docs.python.org/3/library/difflib.html#sequencematcher-objects" rel="nofollow noreferrer"><code>difflib.SequenceMatcher()</code> class</a> to enumerate added, removed and changed entries:</p>
<pre><code>&gt;&gt;&gt; from difflib import SequenceMatcher
&gt;&gt;&gt; matcher = SequenceMatcher(a=a, b=b)
&gt;&gt;&gt; added = []
&gt;&gt;&gt; for tag, i1, i2, j1, j2 in matcher.get_opcodes():
...     if tag == 'insert':
...         added += b[j1:j2]
...
&gt;&gt;&gt; added
['a task', 'j']
</code></pre>
<p>The above only focuses on added entries; if you need to know about entries that were <em>removed</em> or altered, then there are opcodes for those events too, see the <a href="https://docs.python.org/3/library/difflib.html#difflib.SequenceMatcher.get_opcodes" rel="nofollow noreferrer"><code>SequenceMatcher.get_opcodes()</code> method documentation</a>.</p>
<p>However, if your entries are always <em>paired</em>, then just produce sets with tuples from them (using <a href="https://stackoverflow.com/questions/5389507/iterating-over-every-two-elements-in-a-list">pair-wise iteration</a>); you can then do any set operations on these:</p>
<pre><code>aset = set(zip(*([iter(a)] * 2)))
bset = set(zip(*([iter(b)] * 2)))
difference = bset - aset
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; aset = set(zip(*([iter(a)] * 2)))
&gt;&gt;&gt; bset = set(zip(*([iter(b)] * 2)))
&gt;&gt;&gt; aset
{('another task', 'j'), ('cool task', 'b'), ('better task', 'y')}
&gt;&gt;&gt; bset
{('a task', 'j'), ('another task', 'j'), ('cool task', 'b'), ('better task', 'y')}
&gt;&gt;&gt; bset - aset
{('a task', 'j')}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>it works as you want:</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-


def difference(a, b):
    a, b = (lambda x, y: (y, x) if len(set(x)) &gt; len(set(y)) else (x, y)) (a, b)
    a_result = list(a)
    b_result = list(b)

    for z in range(len(a)):
        if a[z] in b:
            a_result.remove(a[z])
            b_result.remove(a[z])

    return a_result, b_result 
    # or
    # return a_result if len(set(a_result)) &gt; len(set(b_result)) else b_result


def main():
    a = ['cool task', 'b', 'another task', 'j', 'better task', 'y']
    b = ['cool task', 'b', 'a task', 'j', 'another task', 'j', 'better     task', 'y']
    print(difference(a, b))


if __name__ == "__main__":
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Depending on your purposes, you could possibly use <code>Counter</code> from the <a href="https://docs.python.org/3.6/library/collections.html" rel="nofollow">collections module</a>:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; a = Counter(['cool task', 'b', 'another task', 'j', 'better task', 'y'])
&gt;&gt;&gt; b = Counter(['cool task', 'b', 'a task', 'j', 'another task', 'j', 'better task', 'y'])
&gt;&gt;&gt; b-a
Counter({'j': 1, 'a task': 1})
&gt;&gt;&gt; list((b-a).keys())
['j', 'a task']
</code></pre>
</div>
<span class="comment-copy">You want to find the elements in <code>b</code> that appear more often in <code>b</code> than they do in <code>a</code>? (note that appearing once counts as appearing more often than not at all).</span>
<span class="comment-copy">If the even elements are closely linked to the elements that follow in odd indices, you should better define a different data structure that highlights this association.</span>
<span class="comment-copy">Thanks for the edit, I was able to use the first answer by using c[0][then what part I wanted]</span>
<span class="comment-copy">That looks like a useful module. I wasn't aware of it.</span>
