<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2631726/how-to-determine-the-longest-increasing-subsequence-using-dynamic-programming">How to determine the longest increasing subsequence using dynamic programming?</a>
<span class="question-originals-answer-count">
                    14 answers
                </span>
</li>
</ul>
</div>
<p>I need to find the minimum number of deletions required to make string sorted.</p>
<p>Sample Test case:</p>
<pre><code># Given Input:
teststr = "abcb"
# Expected output:
1

# Explanation
# In this test case, if I delete last 'b' from "abcb", 
# then the remaining string "abc" is sorted. 
# That is, a single deletion is required.

# Given Input:
teststr = "vwzyx"
# Expected output:
2

# Explanation
# Here, if I delete 'z' and 'x' from "vwzyx", 
# then the remaining string "vwy" is a sorted string.  
</code></pre>
<p>I tried the following but it gives time limit exceeded error. 
Any other approach to this problem?</p>
<pre><code>    string = input()
    prev_ord = ord(string[0])
    deletion = 0
    for char in string[1:]:
        if ord(char) &gt; prev_ord +1 or ord(char) &lt; prev_ord:
            deletion += 1
            continue
        prev_ord = ord(char)
    print(deletion)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your current algorithm will give incorrect results for many strings.</p>
<p>I suspect that there's a more efficient way to solve this problem, but here's a brute-force solution. It generates subsets of the input string, ordered by length, descending. The elements in the subsets retain the order from the original string. As soon as <code>count_deletions</code> finds an ordered subset it returns it (converted back into a string), as well as the number of deletions. Thus the solution it finds is guaranteed to be no shorter than any other sorted selection of the input string.</p>
<p>Please see the <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code> docs</a> for info about the various <code>itertools</code> functions I've used; the algorithm for generating subsets was derived from the <code>powerset</code> example in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">Recipes</a> section.</p>
<pre><code>from itertools import chain, combinations

def count_deletions(s):
    for t in chain.from_iterable(combinations(s, r) for r in range(len(s), 0, -1)):
        t = list(t)
        if t == sorted(t):
            return ''.join(t), len(s) - len(t)

# Some test data. 
data = [
    "abcdefg",
    "cba",
    "abcb",
    "vwzyx",
    "zvwzyx",
    "adabcef",
    "fantastic",
]

for s in data:
    print(s, count_deletions(s))
</code></pre>
<p><strong>output</strong></p>
<pre><code>abcdefg ('abcdefg', 0)
cba ('c', 2)
abcb ('abc', 1)
vwzyx ('vwz', 2)
zvwzyx ('vwz', 3)
adabcef ('aabcef', 1)
fantastic ('fntt', 5)
</code></pre>
<p>That data set is not really adequate to fully test algorithms designed to solve this problem, but I guess it's an ok starting point. :)</p>
<p><hr/>
<strong>Update</strong></p>
<p>Here's a Python 3 implementation of the algorithm mentioned by Salvador Dali on the linked page. It's <strong>much</strong> faster than my previous brute-force approach, especially for longer strings.</p>
<p>We can find the longest sorted subsequence by sorting a copy of the string and then finding the Longest Common Subsequence (LCS) of the original string &amp; the sorted string. Salvador's version removes duplicate elements from the sorted string because he wants the result to be strictly increasing, but we don't need that here.</p>
<p>This code only returns the number of deletions required, but it's easy enough to modify it to return the actual sorted string.</p>
<p>To make this recursive function more efficient it uses the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow"><code>lru_cache</code></a> decorator from functools.</p>
<pre><code>from functools import lru_cache

@lru_cache(maxsize=None)
def lcs_len(x, y):
    if not x or not y:
        return 0

    xhead, xtail = x[0], x[1:]
    yhead, ytail = y[0], y[1:]
    if xhead == yhead:
        return 1 + lcs_len(xtail, ytail)
    return max(lcs_len(x, ytail), lcs_len(xtail, y))

def count_deletions(s):
    lcs_len.cache_clear()
    return len(s) - lcs_len(s, ''.join(sorted(s)))

data = [
    "abcdefg",
    "cba",
    "abcb",
    "vwzyx",
    "zvwzyx",
    "adabcef",
    "fantastic",
]

for s in data:
    print(s, count_deletions(s))
</code></pre>
<p><strong>output</strong></p>
<pre><code>abcdefg 0
cba 2
abcb 1
vwzyx 2
zvwzyx 3
adabcef 1
fantastic 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Hope it works for all cases :)</p>
<pre><code>s = input()
s_2 = ''.join(sorted(set(s), key=s.index))
sorted_string = sorted(s_2)
str_to_list = list(s_2)
dif = 0

for i in range(len(sorted_string)):
    if sorted_string[i]!=str_to_list[i]:
        dif+=1

print(dif+abs(len(s)-len(s_2)))
</code></pre>
</div>
<span class="comment-copy">There's a pretty good Python implementation of this problem, which is known as the <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" rel="nofollow noreferrer">Longest increasing subsequence</a> problem up (here)[<a href="http://stackoverflow.com/questions/3992697/longest-increasing-subsequence]" title="longest increasing subsequence%5d">stackoverflow.com/questions/3992697/…</a></span>
<span class="comment-copy">Thanks for finding that dupe target, @chthonicdaemon.</span>
<span class="comment-copy">I've added a <i>much</i> more efficient version to my answer.</span>
<span class="comment-copy">any one can help with java version of this</span>
<span class="comment-copy">can u help with java version if possible</span>
<span class="comment-copy">@sagar Sorry, I don't know Java. But if you can read Python it shouldn't be too hard to translate my code into another language. I suggest you give it a try, and if you get stuck, post your code in a new question, maybe linking back to this one, or to the duplicate target shown at the top of this page.</span>
<span class="comment-copy">actually <code>@lru_cache</code> seems to be python specific lib or utility which I can't afford in java and also I need to only use core library.</span>
<span class="comment-copy">@sagar There's some info about doing memoization in Java here <a href="https://stackoverflow.com/questions/3623754/what-are-the-different-techniques-for-memoization-in-java" title="what are the different techniques for memoization in java">stackoverflow.com/questions/3623754/…</a></span>
<span class="comment-copy">I fixed this with LCS in java. There was an algo to that modified it accordingly</span>
<span class="comment-copy">No, that doesn't work. Eg, on 'zvwzyx' it returns 5, but we can produce 'vwz' from that string, so the deletion count is only 3. And on 'adabcef' it should return 1, not 4.</span>
<span class="comment-copy">Yep, you're right</span>
