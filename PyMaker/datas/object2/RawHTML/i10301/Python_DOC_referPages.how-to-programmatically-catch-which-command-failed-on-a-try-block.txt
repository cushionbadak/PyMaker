<div class="post-text" itemprop="text">
<p>I'm trying to get some data from an JSON API. I don't want all the data that the API returns so I wrote a method that reads all the data and returns a dictionary with the relevant fields. Sometimes though, some data are missing and I would like to replace the fields that are missing with an underscore. A sample of the method is like that;  </p>
<pre><code>return {
    'foo': data['foo'],
    'bar': data['bar']
 }
</code></pre>
<p>If a field is missing from the data, this throughs a KeyError. Is it possible to catch programmatically which field produced the error, in a single try-except block and not write a try-except block for every field?</p>
<pre><code>try:
    ret_dict =  {
        'foo': data['foo'],
        'bar': data['bar']
    }
 except KeyError:
    ret_dict[thefailurekey] = '_'
</code></pre>
<p>instead of  </p>
<pre><code>ret_dict = {}
try:
    ret_dict['foo'] = data['foo']
except KeyError:
    ret_dict['foo'] = '_'
try:
    ret_dict['bar'] = data['bar']
except:
    ret_dict['bar'] = '_'
</code></pre>
<p>Thank you</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow"><code>.get</code></a> method of <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow"><code>dict</code></a>:</p>
<pre><code>def get_data(data):
    return {
        # If you want to accept falsy values from API:
        'foo': data.get('foo', '_'),

        # If you want to override falsy values from API:
        'bar': data.get('bar') or '_',
    }
</code></pre>
<p><code>.get</code> returns its second argument (<code>None</code> by default) if a dict doesn't have requested key, so it is always safe to use it in uncertain situations. </p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; data = {'foo': False, 'bar': False}
&gt;&gt;&gt; get_data(data)
{'bar': '_', 'foo': False}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can probably get that information from the members of the <code>KeyError</code> exception object, but a simpler way would be to just use <code>get()</code> that will return a default value if the key is not there.</p>
<pre><code>return {
    'foo': data.get('foo', '_'),
    'bar': data.get('bar', '_'),
 }
</code></pre>
<p>Another reason this is better than handling an exception is that you can only handle one exception. What happens if two keys are missing? And on top of that, <code>ret_dict</code> will not even be defined in your example because the code failed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of using try block, you can use <code>dict.get(key, default_val)</code></p>
<p>For example:</p>
<pre><code>ret_dict = dict(
    foo=data.get('foo', '-'),
    bar=data.get('bar', '-')
)

return ret_dict
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to avoid the repetitiveness of typing <code>.get(attr, '_')</code> for each key, you can use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>defaultdict</code></a>, setting it to return <code>_</code> when a key is trying to be accessed but missing.</p>
<pre><code>from collections import defaultdict

data = {
    'foo': 'foo_value',
}

ret_dict = defaultdict(lambda: '_')
ret_dict.update(data)

print(ret_dict['foo'])  # 'foo_value'
print(ret_dict['bar'])  # '_'
</code></pre>
</div>
<span class="comment-copy">Thank you for your answer. If the field is itself a dictionary, should I use get like that; data.get('foo',{}).get('bar','_') or is there a better-more pythonic way?</span>
<span class="comment-copy">Yes, that's a way to go. Though if you want a more generic method, look at this answer <a href="http://stackoverflow.com/a/36131992/847552">stackoverflow.com/a/36131992/847552</a>.</span>
<span class="comment-copy">Thank you, that's great. Doesn't get more pythonic than that!</span>
<span class="comment-copy">Thank you for your answer. Some fields are themselves dictionaries, which means that I need to do something like data['foo']['bar']. Is there a better solution from data.get('foo',{}).get('bar','_')?</span>
<span class="comment-copy">I haven't seen anything better than that.</span>
<span class="comment-copy">Ok, thanks again!</span>
<span class="comment-copy">Thank you for your answer. If the field is itself a dictionary, is this good practice; data.get('foo',{}).get('bar','_')?</span>
<span class="comment-copy">yes, that would work but a better approach is to use <code>defaultdict</code> for that</span>
<span class="comment-copy">I didn't know about this, I'll check it out. Thanks again!</span>
