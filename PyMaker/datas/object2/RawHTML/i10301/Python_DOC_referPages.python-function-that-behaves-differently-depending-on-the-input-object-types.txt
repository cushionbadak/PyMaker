<div class="post-text" itemprop="text">
<p>In Python, can I write a function that takes objects as inputs and performs different calculations depending on the types of the objects?</p>
<p>For example, say I have two classes: "circle" and "line". I define a circle object A with a radius and centre position, and a circle object B with a different radius and centre position. I then define a line object C with a direction vector and a point along the line.</p>
<p>I would like to write a function that calculates the intersection:</p>
<pre><code>def intersect(obj1,obj2):
    # Returns intersection of two geometric entities
</code></pre>
<p>If I input the two circles A and B, I want the function to return the area of intersection of A and B. But if I input circle A and line C, I want the output to be the points (if any) where the line crosses the circle. So intersect(obj1,obj2) will need to somehow read the class of obj1 and obj2, and act accordingly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can certainly detect the types of your Python objects and execute different behaviour based on that. The built-in <code>type()</code> method will provide the information you need.</p>
<p>I should stress that this is rather reverting to the procedural paradigm whereas what you may be better off doing in looking into object orientation (specifically polymorphism).</p>
<p>You can also return <em>arbitrary types</em> from a function, so returning the two-dimensional intersection of two circles in one case, and two points of intersection between a circle and line in another, is certainly doable as well.</p>
<p>Again, that's addressing the <em>possibility</em>, not the wisdom. It's certainly possible that I could try to cut down a giant Karri tree with a haddock, but the wisdom of such a move would be, at best, dubious.</p>
<p>By way of example, the following program shows how to return a different type of value, based on the type of the parameter passed in:</p>
<pre><code>def fn(x):
    if type(x) is int:
        return 42
    if type(x) is list:
        return [3.14159,2.71828]
    return None

print(fn(1))
print(fn([1,2]))
print(fn(42.7))
</code></pre>
<p>The output is, as expected:</p>
<pre><code>42
[3.14159,2.71828]
None
</code></pre>
</div>
<span class="comment-copy">That's not very smart from a consistent interface perspective. <code>intersect</code> should e.g. return the point(s) of intersection in either case, then have a separate function to get the overlapping area where such a thing makes geometric sense. This will make your code much easier to reason about. In terms of checking types (see <a href="https://docs.python.org/3/glossary.html#term-duck-typing" rel="nofollow noreferrer">duck typing</a> for why you don't normally do this), use <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer"><code>isinstance</code></a>.</span>
<span class="comment-copy">That makes more sense, I'll write it to return the two points where the circles cross</span>
<span class="comment-copy">I think that's wise. Then you can look at e.g. <code>for point in intersect(...):</code> and know it makes sense without having to worry about what types the inputs happen to be at that point.</span>
<span class="comment-copy">Would it be better to just define a separate function for each kind of intersection?</span>
<span class="comment-copy">Screwed that up... I think <a href="http://stackoverflow.com/questions/9225679/how-to-have-different-input-types-for-the-same-function?noredirect=1&amp;lq=1" title="how to have different input types for the same function">stackoverflow.com/questions/9225679/â€¦</a> covers it</span>
<span class="comment-copy">Generally you'd use <code>isinstance(x, int)</code>, to handle subclassing, interface implementation, etc.</span>
