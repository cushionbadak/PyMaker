<div class="post-text" itemprop="text">
<p>I have a list containing synonyms for the word 'Good' (this list here is shortened)</p>
<pre><code>good_synonym = ['Good','good','Well','well']
</code></pre>
<p>And the program asks how the user is feeling</p>
<pre><code>print = 'Hello, ' + name + ', How are you?'
status = raw_input('')
</code></pre>
<p>But sometimes, the user may respond to the question with "I am good" (or similar)</p>
<p>If the answer contains a word in the good synonym list, I want the program to reply</p>
<pre><code>if status contains a word in good_synonym:
    print ('That is good')
else:
    print ('That is not so good')
</code></pre>
<h1>note that the first line is not real python language</h1>
<p>But I don't know which phrase to use to do the action.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are many ways you could try to do this. Since you are a beginner, let's just go for something that will work - efficiency should NOT be your first consideration.</p>
<pre><code>status = status.split() # breaks response into words
if any(s in good_synonyms for s in status):
    print('That is good')
</code></pre>
<p>Of course it won't stop your program from acting as though "not good" is a reply deserving a happy answer, but this is a programming site.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of a list with mixed-case words, use <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow"><em>set</em> objects</a>; sets make membership testing and intersection testing much easier. Store <em>lowercase text</em> only, and simply lowercase the input string:</p>
<pre><code>good_synonym = {'good', 'well'}
# good_synonym = set(['good', 'well'])  # Python 2.6
</code></pre>
<p>Now test if the input string, lowercased and split on whitespace, is a <a href="https://en.wikipedia.org/wiki/Disjoint_sets" rel="nofollow"><em>disjoint set</em></a> with <a href="https://docs.python.org/3/library/stdtypes.html#set.isdisjoint" rel="nofollow"><code>set.isdisjoint()</code></a>. If it is not a disjoint set, there is overlap between the two sets and that means at least <code>'good'</code> or <code>'well'</code> is present:</p>
<pre><code>if not good_synonym.isdisjoint(status.lower().split()):
    print ('That is good')
else:
    print ('That is not so good')
</code></pre>
<p>Testing if a set is disjoint is efficient; it only has to test words up to the first one that is in the <code>good_synonym</code> set to return <code>False</code> quickly. You could calculate the intersection instead, but that would always test <em>all</em> words in the status to build a new set object.</p>
<p>Other solutions you may have seen, use the <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow"><code>any()</code> function</a>; given a <a href="https://docs.python.org/3/tutorial/classes.html#generator-expressions" rel="nofollow">generator expression</a> it too can be efficient as it would return <code>True</code> early if any of the outputs is true:</p>
<pre><code>if any(word in good_synonym for word in status.lower().split()):
</code></pre>
<p>This, however, does all the looping and testing in Python code, while <code>set.isdisjoint()</code> is implemented entirely in C code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simple!</p>
<p>We can iterate over the good_synonyms list and check if <em>any</em> of them are present in the input string.</p>
<pre><code>if any(synonym in status for synonym in good_synonyms):
    print('That is good')
else:
    print('That is not so good')
</code></pre>
<p>PS: To save memory, you could perhaps store the synonyms only in lower-case, as ['good', 'well'], and when you check if these are in the 'status' variable, you could just apply the .lower() on it, which just converts the entire string into lower-case, as:</p>
<pre><code>good_synonyms = ['good', 'well']
if any(synonym in status.lower() for synonym in good_synonyms):
     print('That is good')
</code></pre>
<p>Hope this helps!</p>
<p><strong>Note</strong>: holdenweb's answer works too, but applying the split function on status isn't really required as you can check whether a word is present in a string(provided the words in the string are separated by a space) or not using the 'in' keyword as described above.</p>
</div>
<div class="post-text" itemprop="text">
<p>A short and simple solution would be to use regular expressions for pattern matching like this:</p>
<pre><code>import re

line = "it is good"
good_synonyms = ["good","well"]

line = line.lower()
if any(re.search(synonym,line) for synonym in good_synonyms):
    print "That is good"
else:
    print "nope"
</code></pre>
<p>The <code>search</code> function of <code>re</code> looks for a match of pattern anywhere in the string and returns a boolean which then can be used in an if statement with <code>any</code></p>
</div>
<div class="post-text" itemprop="text">
<p>This is a NLP question, the following code is a simple version of detecting synonym:</p>
<pre><code>def is_contains_synonym(sentence, synonym):
    token = sentence.split(' ')
    return len(filter(lambda x: x in synonym, token)) &gt; 0

if is_contains_synonym(status, good_synonym):
    print ('That is good')
else:
    print ('That is not so good')
</code></pre>
</div>
<span class="comment-copy">What have you tried? Have you looked for info before asking?</span>
<span class="comment-copy">I looked around and found many references to an "any()" command but I don't fully understand its usage.</span>
<span class="comment-copy">this question is barely the same as yours: <a href="http://stackoverflow.com/questions/5319922/python-check-if-word-is-in-a-string" title="python check if word is in a string">stackoverflow.com/questions/5319922/â€¦</a></span>
<span class="comment-copy">Also note @martijn's comments about using sets and preferring lower case.</span>
<span class="comment-copy">Efficiency can be reached simply by using a <code>set</code> or a <code>frozenset</code> instead of a list for <code>good_synonyms</code>.</span>
<span class="comment-copy">When you are learning, no new complication should be regarded as "simple" so I chose to focus on the essentials</span>
<span class="comment-copy">I agree, but it's important to give the way to improvement. Learning is not the end. That's why i write a comment, rather than editing your answer.</span>
<span class="comment-copy">We are both working to the same end. Thanks for the note.</span>
<span class="comment-copy">This question will almost pass as a dupe, but this is a clearly different perspective for handling a case as this. Dang! +1</span>
<span class="comment-copy">I seem to keep getting a syntax error with the separator between words in the set.</span>
<span class="comment-copy">@HarveyFletcher: are you using Python 2.6 perhaps? Then use <code>set(['good', 'well'])</code> to create a set. The curly-brace literal syntax for sets was not introduced until Python 2.7 and 3.</span>
