<div class="post-text" itemprop="text">
<p>I have to create a three new lists of items using two different lists.</p>
<pre><code>list_one = ['one', 'two','three', 'four','five']
list_two = ['blue', 'green', 'white']
</code></pre>
<p>So, <code>len(list_one) != len(list_two)</code></p>
<p>Now I should create an algorithm(a cycle) which can do this: 
<code>[oneblue, twoblue, threeblue, fourblue, fiveblue]</code>. Same for 'green' and 'white'.</p>
<p>I undestand that I should create three cycles but I don't know how.
I've tried to make a function like this but it doesn't works.</p>
<pre><code>def mix():
    i = 0
    for i in range(len(list_one)):
        new_list = list_one[i]+list_two[0]
        i = i+1
        return new_list
</code></pre>
<p>What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you might be looking for <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow">itertools.product</a>:</p>
<pre><code>&gt;&gt;&gt; [b + a for a,b in itertools.product(list_two, list_one)]
['oneblue',
 'twoblue',
 'threeblue',
 'fourblue',
 'fiveblue',
 'onegreen',
 'twogreen',
 'threegreen',
 'fourgreen',
 'fivegreen',
 'onewhite',
 'twowhite',
 'threewhite',
 'fourwhite',
 'fivewhite']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should do this</p>
<pre><code>def cycle(list_one,list_two):
   newList = []
   for el1 in list_two:
      for el2 in list_one:
         newList.append(el2+el1)
   return newList
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are a few problems with your code:</p>
<ol>
<li><p>When you do a for loop <code>for i in ...:</code>, you do not need to initialize <code>i</code> (<code>i = 0</code>) and you should not increment it (<code>i = i + 1</code>) since Python knows that <code>i</code> will take all values specified in the for loop definition.</p></li>
<li><p>If your code indentation (indentation is very important in Python) is truly the one written above, your <code>return</code> statement is inside the for loop. As soon as your function encounters your return statement, your function will exit and return what you specified: in this case, a string.</p></li>
<li><p><code>new_list</code> is not a list but a string.</p></li>
<li><p>In Python, you can loop directly over the list items as opposed to their index (<code>for item in list_one:</code> as opposed to <code>for i in range(len(list_one)):</code></p></li>
</ol>
<p>Here is your code cleaned up:</p>
<pre><code>def mix():
    new_list = []
    for i in list_one:
        new_list.append(list_one[i]+list_two[0])
    return new_list
</code></pre>
<p>This can be rewritten using a list comprehension:</p>
<pre><code>def mix(list_one, list_two):
    return [item+list_two[0] for item in list_one]
</code></pre>
<p>And because <code>list_two</code> has more than one item, you would need to iterate over <code>list_two</code> as well:</p>
<pre><code>def mix(list_one, list_two):
    return [item+item2 for item in list_one for item2 in list_two]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>return should be out of for loop.</li>
<li>No need to initialize <code>i</code> and increment it, since you are using range.</li>
<li>Also, since both list can be of variable length, don't use range. Iterate over the list elements directly.</li>
<li><code>def mix():</code> should be like <code>def mix(l_one,l_two):</code></li>
</ul>
<p>All above in below code:</p>
<pre><code>def mix(l_one,l_two):
    new_list = []
    for x in l_one:
        for y in l_two:
            new_list.append(x+y)
    return new_list

list_one = ['one', 'two','three', 'four','five']
list_two = ['blue', 'green', 'white']
n_list = mix(list_one,list_two)
print n_list
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>C:\Users\dinesh_pundkar\Desktop&gt;python c.py
['oneblue', 'onegreen', 'onewhite', 'twoblue', 'twogreen', 'twowhite', 'threeblu
e', 'threegreen', 'threewhite', 'fourblue', 'fourgreen', 'fourwhite', 'fiveblue'
, 'fivegreen', 'fivewhite']

C:\Users\dinesh_pundkar\Desktop&gt;
</code></pre>
<p>Using List Comprehension, <code>mix()</code> function will look like below:</p>
<pre><code>   def mix(l_one,l_two):
          new_list =[x+y for x in l_one for y in l_two]
          return new_list
</code></pre>
</div>
<span class="comment-copy"><i>What am I doing wrong?</i> - You are returning inside the loop, preventing any iteration beside the first to be executed. - You are returning <code>new_list</code>, but if you look at it you'll see it is just a string. - You are incrementing <code>i</code>, which is the role of the range. - you assume you need 3 cycles, but I don't see where you got that idea.</span>
<span class="comment-copy">Why the inversion? :) <code>[a + b for a,b in itertools.product(list_one, list_two)]</code></span>
<span class="comment-copy">Because the OP wanted list two to be the "outer" loop ...</span>
<span class="comment-copy">great answer but the result should be ['oneblue', 'twoblue', 'threeblue', ..., 'fivewhite']</span>
