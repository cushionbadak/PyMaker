<div class="post-text" itemprop="text">
<p>If I create a python dictionary with a dict comprehension, but there are duplicate keys, am I guaranteed that the last item will the the one that ends up in the final dictionary? It's not clear to me from looking at <a href="https://www.python.org/dev/peps/pep-0274/" rel="noreferrer">https://www.python.org/dev/peps/pep-0274/</a>?</p>
<pre><code>new_dict = {k:v for k,v in [(1,100),(2,200),(3,300),(1,111)]}
new_dict[1] #is this guaranteed to be 111, rather than 100?
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Last item wins. The best documentation I can find for this is in the <a href="https://docs.python.org/3/reference/expressions.html#dictionary-displays" rel="noreferrer">Python 3 language reference, section 6.2.7</a>:</p>
<blockquote>
<p>A dict comprehension, in contrast to list and set comprehensions, needs two expressions separated with a colon followed by the usual “for” and “if” clauses. When the comprehension is run, the resulting key and value elements are inserted in the new dictionary <strong>in the order they are produced</strong>.</p>
</blockquote>
<p>That documentation also explicitly states that the last item wins for comma-separated key-value pairs (<code>{1: 1, 1: 2}</code>) and for dictionary unpacking (<code>{**{1: 1}, **{1: 2}}</code>):</p>
<blockquote>
<p>If a comma-separated sequence of key/datum pairs is given, ... you can specify the same key multiple times in the key/datum list, and the final dictionary’s value for that key will be the last one given.</p>
<p>A double asterisk <code>**</code> denotes <em>dictionary unpacking</em>. Its operand must be a mapping. Each mapping item is added to the new dictionary. Later values replace values already set by earlier key/datum pairs and earlier dictionary unpackings.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>If you mean something like </p>
<pre><code>{key: val for (key, val) in pairs}
</code></pre>
<p>where <code>pairs</code> is an ordered collection (eg, list or tuple) of 2-element lists or tuples then yes, the comprehension will take the collection in order and the last value will "win". </p>
<p>Note that if pairs is a set of pairs, then there is no "last item", so the outcome is not predictable. 
EXAMPLE:</p>
<pre><code>&gt;&gt;&gt; n = 10
&gt;&gt;&gt; pairs = [("a", i) for i in range(n)]
&gt;&gt;&gt; {key:val for (key, val) in pairs}
{'a': 9}
&gt;&gt;&gt; {key:val for (key, val) in set(pairs)}
{'a': 2}
</code></pre>
</div>
<span class="comment-copy">Yes, the last value will be added. if you did it explicitly outside the comprehension <code>new_dict[1]  = 111</code> would you expect 100 or 111? Just because it is in a comprehension does not make the order of inserts different.</span>
<span class="comment-copy">It will always be the last value, it is like overwriting the previous one!</span>
<span class="comment-copy">The last value that the iterable gives the comprehension will be the one that is written last.</span>
