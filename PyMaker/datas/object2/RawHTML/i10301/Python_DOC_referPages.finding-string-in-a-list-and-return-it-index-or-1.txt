<div class="post-text" itemprop="text">
<p>Defining a procedure which return an index of item or -1 if the item not in list</p>
<pre><code>def ser(a,b):
    for j in a:
        if j == b:
            return (a.index(b))
        else:
            return -1

print (ser([1,2,3],3))
</code></pre>
<p>It's always return me -1. If i cut the 'else' part, it works. So why ?</p>
</div>
<div class="post-text" itemprop="text">
<p>That is because the first time you do not match the condition in your loop you immediately return and leave your method. You need to re-think your logic here to determine what it is you want to do when you don't match. Ultimately, you want to continue looping until you have exhausted your checks.</p>
<p>So, simply set your <code>return -1</code> outside of your loop. If you go through your entire loop, you have not found your match, so you can then return -1</p>
<pre><code>def ser(a,b):
    for j in a:
        if j == b:
            return (a.index(b))
    return -1

print (ser([1,2,3],3))
</code></pre>
<p>Alternatively, the loop can be avoided by using <a href="https://docs.python.org/3/reference/expressions.html#in" rel="nofollow">in</a>. So, you can actually re-write your method to this:</p>
<pre><code>def ser(a, b):
    if b in a:
        return a.index(b)
    return -1
</code></pre>
<p>You are checking to see if item <code>b</code> is in list <code>a</code>, if it is, return the index, otherwise return -1</p>
<p>To take the simplification further, you can actually set this in to a single line in your <code>return</code>:</p>
<pre><code>def ser(a, b):
    return a.index(b) if b in a else -1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>else</code> block is executed after the first iteration does not fulfill <code>j == b</code>. </p>
<p>You're better off moving the else block to the <code>for</code> which executes if the item is not found after the <code>for</code> loop is <em>exhausted</em>:</p>
<pre><code>def ser(a,b):
    for j in a:
        if j == b:
            return (a.index(b))
    else: # or put default return on this line
         return -1
</code></pre>
<p>More importantly, You could also check for containment using <code>b in a</code> without needing to iterate through the list.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the first iteration of the for loop, it will test if the first element in the array is equal to b. It is not, so the code returns -1 immediately, without testing the other elements of the array.</p>
<p>For your case, the correct code is:</p>
<pre><code>def ser(a,b):
    for j in a:
        if j == b:
            return (a.index(b))
    return -1
</code></pre>
<p>In this way, the code will try all elements in the array, and will return -1 if none of them is equal to b.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need not to do anything fancy, simple one-liner will work:</p>
<pre><code>def ser(a,b):
    return a.index(b) if b in a else -1

# Example
my_list = [1, 2, 3, 4]
ser(my_list, 2)
# returns: 1

ser(my_list, 8)
# returns: -1
</code></pre>
</div>
<span class="comment-copy">Think about it, what happens if the first element of <code>a</code> doesn't equal <code>b</code>.</span>
<span class="comment-copy">Your function returns -1 after first unsuccessful search.</span>
