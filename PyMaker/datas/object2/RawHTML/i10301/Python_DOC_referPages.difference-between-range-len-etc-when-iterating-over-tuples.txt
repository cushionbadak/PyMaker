<div class="post-text" itemprop="text">
<p>One thing upfront: I am fairly now to the coding world so maybe my question is a bit stupid ... I was trying to write a function that returns the every other element of a tuple. The easiest way obviously is </p>
<pre><code>def oddTuples(aTup):
     return aTup[::2]
</code></pre>
<p>I tried to solve it differently by using the following code</p>
<pre><code>def oddTuples(aTup):
    newTup = ()
    for i in len(aTup):
        if i%2 != 0:
            newTup = newTup + (i,)
    return newTup
</code></pre>
<p>But that doesn't give me back anything at all.</p>
<p>I thought I (if used over <code>len</code>) gives back the position, so if <code>aTup = ((12, 34, 'abc', 'dfdf', 2340))</code> the return would be <code>newTup = ((12, 'abc', 2340))</code>.</p>
<p>What's the <code>i</code> iterating over when used with <code>range</code>, <code>len</code> or -in that case- while iterating over <code>for i in aTup:</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's <code>for</code> loop is a <a href="https://en.wikipedia.org/wiki/Foreach_loop" rel="nofollow"><em>foreach</em> construct</a>; it'll loop over a sequence or iterable and bind the target variable (<code>i</code> in your case) to each element in that sequence one by one.</p>
<p>So for <code>for i in aTuple:</code>, with each iteration, <code>i</code> is bound to the next value from the tuple. If you used a <code>range()</code> object, then looping over that object would produce integers in the range, from start (defaulting to <code>0</code>) up to the end value minus 1 (the end value is excluded).</p>
<p>Your code, however, doesn't loop over <code>range()</code>; you try to loop over the result of <code>len(aTuple)</code>, which will be a <em>single integer</em>. That gives a <code>TypeError: 'int' object is not iterable</code> exception.</p>
<p>If you want to use the <a href="https://docs.python.org/3/library/stdtypes.html#ranges" rel="nofollow"><code>range()</code> type</a>, that's fine, but then you'll have to translate the index back into a value from <code>aTuple</code> by using indexing:</p>
<pre><code>def oddTuples(aTup):
    newTup = ()
    for i in range(len(aTup)):
        if i%2 != 0:
            newTup = newTup + (aTup[i],)
    return newTup
</code></pre>
<p>Here <code>aTup[i]</code> produces the value at index <code>i</code>; where <code>i</code> is so index <code>1</code>, <code>3</code>, etc, so you get every odd element. Note that this <em>differs</em> from <code>aTup[::2]</code>, which starts at <code>0</code> and includes every even-numbered element! Python starts counting at <code>0</code>, so take that into account when counting out elements.</p>
<p>You can avoid having to index back in by using the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate()</code> function</a>; for every element in a sequence it'll produce a tuple with an ever-increasing index number. Let's use that to fix the odd-even issue, mixing in some <code>+=</code> augmented assignment too:</p>
<pre><code>def oddTuples(aTup):
    newTup = ()
    for i, value in enumerate(aTup):
        if i % 2 == 0:
            newTup += value,
    return newTup
</code></pre>
<p>You don't really need the <code>(...)</code> parentheses here either, tuples are formed by commas (except for the empty tuple, and use parentheses when the comma could mean something else, like in a function call).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>newTup = ()
b = True
for i in aTup:
    if b:
        newTup = newTup + (i,)
    b = not b
return newTup
</code></pre>
<p>Try that on for size.  The <code>for</code> statement gives us the tuple values one by one, and the <code>boolean</code> b lets us skip every other one.  </p>
<p>The best way to do this is the way you put at the top of your post. If you don't understand what it's doing, then I suggest researching list slicing.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>for i in len(aTup):
</code></pre>
<p>Will raise an error because <code>len()</code> returns an integer which can not be iterated over in a <code>for</code> loop.</p>
<p>In the case of:</p>
<pre><code>for i in range(len(aTup)):
</code></pre>
<p>In each iteration of the loop <code>i</code> will be an integer starting from 0 and up to the length of your tuple <strong>- 1</strong>.</p>
<p>In the case of:</p>
<pre><code>for i in aTup:
</code></pre>
<p>Each <code>i</code> will be a member of the tuple. The best way to get used to how these things work is to just pop open an interactive interpreter and do some experiments!</p>
<pre><code>&gt;&gt;&gt; aTup = ('hello', 'world')
&gt;&gt;&gt; for i in len(aTup):
...     print i
... 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'int' object is not iterable
&gt;&gt;&gt; for i in range(len(aTup)):
...     print i
... 
0
1
&gt;&gt;&gt; for i in aTup:
...     print i
... 
hello
world
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>i</code> will not give you the index instead it will return the value.</p>
<p>You can solve your problem simply by defining a local variable that can be incriminated for each iteration and use that to get the odd indexed values.</p>
<p>Summery: Use a local variable to act as an index as Python for will return the value.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an example you can use to finish the program.</p>
<pre><code>myTup = (1,2,3,4,5,6,7,8)

for i in range(len(myTup)):
    if i%2 != 0:
        print("Tuple items: " ,myTup[i])
        print("i here is: " , i)
</code></pre>
<p><strong>len</strong> -&gt; gives you the length of a object ; eg. if you say len(myTup). That will be 8</p>
<p><strong>Range</strong> -&gt; is like a range, (number of elements) you will be iterating over. </p>
<p><strong>i</strong> -&gt; is the index. </p>
<p>Here is the output </p>
<pre><code>Tuple items:  2
i here is:  1
Tuple items:  4
i here is:  3
Tuple items:  6
i here is:  5
Tuple items:  8
i here is:  7
</code></pre>
<p>You can get the same output above by running the code without using range and len.</p>
<pre><code>for i in myTup:
    if i%2 != 0:
        print("Tuple items: " ,myTup[i])
        print("i here is: " , i)
</code></pre>
</div>
<span class="comment-copy"><code>for i in len(aTup)</code> will give you a type error: <code>TypeError: 'int' object is not iterable</code></span>
<span class="comment-copy">Did you mean you used <code>for i in range(len(aTup)):</code>, which would create a <code>range()</code> object that generates integers up to <code>len(aTup)</code>? Even with that fix, you'd return <i>integer indices</i>, not the values from <code>aTup</code>.</span>
<span class="comment-copy">Thanks for that incredibly detailed answer. Highly appreciated!</span>
<span class="comment-copy">Thanks for your help, @Mani.</span>
<span class="comment-copy">You are welcome :)</span>
