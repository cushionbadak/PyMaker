<div class="post-text" itemprop="text">
<p>I have two different lists and I need to find the index number of the list have more similar pattern  for example</p>
<pre><code>list_1=['abdsc 23h', 'nis 4hd qad', '234 apple 54f','abdsc 2300h']
list_2=['abdsc 23', 'abdsc 230']
</code></pre>
<p>a comparison is to be done for both the list, if element of <code>list_2</code> matches with <code>list_1</code> then it should return the index of list_1 where that element is present
 1. note: for 2nd element of <code>list_2</code> that is <code>abdsc 230</code> it must return 4 since it has highest match with 4th element of <code>list_1</code></p>
<h1>here is the code I am trying to solve</h1>
<pre><code>from bs4 import BeautifulSoup
import urllib
import pandas as pd
from difflib import SequenceMatcher as SM

def maxmatching_algo2(data, counter):
    data_word=[]
    data_word=str(data).split(" ")
    k=[]
    for i in processsorList_global:
        k+=str(i).split(",")
    temp=0
    rank_list=[]
    while temp&lt;len(k):
        t=[]
        t+=str(k[temp]).split(" ")
        union_set=set(t)&amp;set(data_word)
        rank_list+= [len(union_set)]
        temp+=1
    index= rank_list.index(max(rank_list))
    if index==0:
        df1.ix[counter, cl]="na"
    else:
        df1.ix[counter, cl]=index


def processor_list_online():
    processsorList = []
    url = "http://www.notebookcheck.net/Smartphone-Processors-Benchmark-List.149513.0.html"
    htmlfile = urllib.urlopen(url)
    soup = BeautifulSoup(htmlfile, 'html.parser')
    count = 1
    temp_count=0
    x=str()
    while True:

        if x=="Qualcomm Snapdragon S1 MSM7227":
            break
        else:
            for i in soup.find_all('tr'):
                count+=1
                temp=0
                for j in i.find_all('td', attrs={'class': 'specs'}):
                    if temp==1:
                        processsorList += [j.text]
                        x=j.text
                    temp+=1
                    temp_count+=1


    print temp_count
    return processsorList



###############################################################################################################################

###############################################################################################################################
df1 = pd.read_csv('proddata2.csv')
x = list(df1.columns.values)  #######################     name of column
cl = len(x)  #######################     column Length
rl = len(df1.index)  #######################     row length
df1["Processor Rank"] = ""
counter = 0
count = []

processsorList_global = processor_list_online()
for i in processsorList_global:
    print i

counter=0
while counter &lt; cl:
    if x[counter] == "processor_type":
        count = counter
        break
    counter += 1

counter = 0
data = []
while counter &lt; rl:
    data = df1.ix[counter, count]
    #print data
    if data=="na":
        df1.ix[counter, cl]="na"
    else:
       # maxmatching_algo(data, counter)
        maxmatching_algo2(data, counter)
    counter +=1

#print df1
#df1.to_csv('final_processor_rank.csv', sep=',')
print "process completed"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One approach is to create a function to return position of the sub_string from <code>list_1</code>. And, then call the function on every element of <code>list_2</code> using <code>map()</code></p>
<pre><code>list_1=['abdsc 23h', 'nis 4hd qad', '234 apple 54f','abdsc 2300h']
list_2=['abdsc 23', 'abdsc 230']

def get_position_from_list(item, l):
    for i, val in enumerate(l):
        if item in val:
           return i + 1
    else:
        return None

map(lambda x: get_position_from_list(x, list_1), list_2)
# returns: [1, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You would have to do something like this: </p>
<pre><code>def compare_substrings_in_list(first_list, compared_list):
    for element in first_list:
        last_match = 0
        for idx, compared_list_element in enumerate(compared_list):
            if element in compared_list_element:
                last_match = idx + 1
        return last_match
</code></pre>
<p>Where you iterate over each element of the list of "searches" and try to find matches on each element of the second list using the <a href="https://docs.python.org/3/reference/expressions.html#membership-test-details" rel="nofollow">in operator</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The below solution might work for you. </p>
<pre><code>&gt;&gt;&gt; for i,val in enumerate(sorted(list_2, key= len, reverse = True)):
...     for j,val2 in enumerate(list_1):
...         if val in val2:
...             print j+1
...             exit()
... 
4
</code></pre>
<p>Note that, if you have multiple matches, this solution is't enough. But that entirely depend on your use cases. </p>
<p>For now, this should be okay.  </p>
</div>
<div class="post-text" itemprop="text">
<p>This solves your problem,</p>
<pre><code>list_1=['abdsc 23h', 'nis 4hd qad', '234 apple 54f','abdsc 2300h']
list_2=['abdsc 23', 'abdsc 230']

for strings in list_2:
print "-list1val--",strings
for other in list_1:
    print '--list2val---',other
    occurence = other.find(strings);
    if occurence==0:
        ind = list_1.index(other)
        print "the index of ",strings,"in list_1 is ",ind
        break
</code></pre>
</div>
<span class="comment-copy">it written in Note:</span>
<span class="comment-copy">Did you try to solve this yourself? Please post your attempt as well</span>
<span class="comment-copy">instead of [map(lambda x: get_index_from_list(x, list_1), list_2) ] it should be [map(lambda x: get_position_from_list(x, list_1), list_2) ]</span>
<span class="comment-copy">Updated it. I guess I messed it up with someone else answer. Thanks!</span>
