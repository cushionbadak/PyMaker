<div class="post-text" itemprop="text">
<p>Current code, I am trying to make a linked list and then sort the linked list in ascending order. </p>
<pre><code>import random
random_nums = random.sample(range(100), 10)

class Node:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = None
    def __str__(self):
        return str(self.data)

def insertNode(data, first_node):
  current_node = first_node
  while current_node !=None:
    if data &gt; current_node.data and data &lt;= current_node.next.data:
      new_node = Node(data, current_node.next)
      last_node.next = new_node
      print("Inserting node: " + str(data))

    current_node = current_node.next

first_node = Node(random_nums[0], None)
for i in random_nums[1:]:
  insertNode(i, first_node)

print("Linked list values:")
current_node = first_node
while current_node != None:
    print (str(current_node.data) + " =&gt; ", end="")
    current_node = current_node.next

input()
</code></pre>
<p>Currently getting the error</p>
<blockquote>
<p>File "python", line 25, in 
    File "python", line 16, in insertNode
  AttributeError: 'NoneType' object has no attribute 'data'</p>
</blockquote>
<p>I am really new to python and trying to get this to work, any suggestions?  </p>
</div>
<div class="post-text" itemprop="text">
<p>While the lines of your posted code and error don't quite match, the issue is likely here:</p>
<pre><code>    if data &gt; current_node.data and data &lt;= current_node.next.data:
</code></pre>
<p>While you check that <code>current_node</code> is not <code>None</code>, you never check that <code>current_node.next</code> isn't <code>None</code> either.</p>
<p>There are some other bugs, e.g. <code>last_node</code> is not defined, there is no concept for inserting at the <em>front</em>, and you always go through the entire list. This should work better:</p>
<pre><code>def insertNode(data, first_node):
  current_node = first_node
  new_node = Node(data, current_node.next)
  if data &lt;= current_node.data:
    # insert at start
    first_node = new_node
    new_node.next = first_node
  else:
    while current_node is not None:
      if current_node.next is None:
        # insert at end
        current_node.next = new_node
        break
      elif data &gt; current_node.data and data &lt;= current_node.next.data:
        # insert in-between current and next node
        new_node.next = current_node.next
        current_node.next = new_node
        break
      current_node = current_node.next
  print("Inserting node: " + str(data))
  return first_node  # must return first to avoid global variable!
</code></pre>
<p>To support changing <code>first_node</code>, you have to fill the list like this:</p>
<pre><code>rand_num_iter = iter(random_nums)  # avoids making a copy in [1:]
first_node = Node(next(rand_num_iter), None)
for i in rand_num_iter:
  first_node = insertNode(i, first_node)
</code></pre>
</div>
<span class="comment-copy">Don't reinvent the wheel, look at the <a href="http://stackoverflow.com/questions/280243/python-linked-list">Python linked list question</a>, it's much more cleaner.</span>
<span class="comment-copy">Take note that depending on your use-case (if there is any), using <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer">python's <code>deque</code></a> may be more practical - they are <a href="http://stackoverflow.com/a/6257048/5349916">implemented as linked lists</a>.</span>
