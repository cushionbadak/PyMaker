<div class="post-text" itemprop="text">
<p>I am confused with the behaviour of self when it comes to dealing with static variables in python.From what I understand is that static variables can be accessed by either using <code>classname.variablename</code> or <code>self.variablename</code>. However changing the value of that variable differs. I realized that if i change the static variable value by <code>classname.variablename=SomeValue</code> the instance variable reflects that value however if I change the value of static variable using <code>self.variablename=SomeValue</code> the static variable does not change when access like <code>classname.variablename</code> from what I understand is that when I assign a value like <code>self.variablename=SomeValue</code> then an instance variable is created. Can somebody please shed a little light on this behaviour.</p>
<p>Example 1:</p>
<pre><code>class bean:
    mycar="SomeCar"
    def test(self):
        bean.mycar = "yup"
        print(self.mycar) #prints yup
</code></pre>
<p>Example 2:</p>
<pre><code>class bean:
        mycar="SomeCar"
        def test(self):
            self.mycar = "pup"
            print(bean.mycar) #SomeCar
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Both classes and instances can have attributes.</p>
<p>A class attribute is assigned to a class object. People sometimes call this a <em>"static variable"</em>.</p>
<p>An instance attribute is assigned to an instance (<em>"instance variable"</em>).</p>
<p>When an attribute of an object is <strong>read</strong>, a number of things happen (see <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow">Descriptor HowTo Guide</a>), but the short version is:</p>
<ol>
<li>Try to read the attribute from the instance</li>
<li>If that fails, try to read it from the class</li>
</ol>
<p>When it is <strong>written</strong>, then there is no such mechanism. It is written where it is written ;)</p>
<p>See in example:</p>
<pre><code>class A(object):
    pass

a = A()

print A.value  # fails - there is no "value" attribute
print a.value  # fails - there is no "value" attribute

A.value = 7

print A.value  # prints 7
print a.value  # also prints 7 - there is no attribute on instance, but there is on class

a.value = 11

print A.value  # prints 7
print a.value  # prints 11 - now there is an attribute on the instance

a2 = A()

print a2.value  # prints 7 - this instance has no "value", but the class has
</code></pre>
<p><strong>self?</strong></p>
<p>BTW, the <code>self</code> argument (in the question) is an instance, just like <code>a</code> is here.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>self</code> in python is an ordinary name that binds the reference to the <em>instance</em> calling a class method. It is passed as the first argument to a method and by convention, it is bound to the name 'self'. When <code>self.variable = value</code> is called, you are setting the value of an instance variable; a variable unique to that <em>particular</em> <code>bean</code>. </p>
<p>For example, <code>self.name = "Fred"</code> might name my mother's bean, but I named my own bean "George" when I called <code>self.name</code> from <em>my</em> bean. </p>
<p>On the other hand, <code>bean.name = "Yousef"</code> names <em>all</em> beans. My mother's bean is now named "Yousef", and so is mine. </p>
<p>If my Dad has a bean as well, he'll be surprised to find out that it too, is named "Yousef" when he calls <code>bean.name</code>. But he can still use <code>self.name</code> to give his bean its own (possibly unique) name.</p>
<h2>Example Code:</h2>
<pre><code>class bean:
    name = "Yousef"  # All beans have this name with `bean.name`

moms = bean()
mine = bean()
dads = bean()

beans = [moms, mine, dads]

# Primitive tabular output function
def output(bean_list):
    print("-bean-", "\t", "-self-")
    for b in bean_list:
        print(bean.name, "\t", b.name)
    print("") # Separate output sets with a newline

# Print the names with only the class attribute set
output(beans)

# Python magic using zip to apply names simultaneously
# Mom's bean is "Fred", mine is "George"
# My dad is weird and named his "Ziggaloo"
for b, n in zip(beans, ["Fred", "George", "Ziggaloo"]):
    b.name = n

# Print the names after applying `self.name`
output(beans)
</code></pre>
<h2>Python 3.4 Output:</h2>
<pre><code>-bean-   -self-
Yousef   Yousef
Yousef   Yousef
Yousef   Yousef

-bean-   -self-
Yousef   Fred
Yousef   George
Yousef   Ziggaloo
</code></pre>
</div>
<span class="comment-copy">No no no no. <a href="https://www.toptal.com/python/python-class-attributes-an-overly-thorough-guide" rel="nofollow noreferrer">Read this</a> or something similar: class attributes vs instance attributes.</span>
<span class="comment-copy">You are setting it on the instance with <code>self.variablename = SomeValue</code>.</span>
<span class="comment-copy">@AndrasDeak great link</span>
<span class="comment-copy">Short answer: essentially you are shadowing the class variable with an instance variable of the same name in your second example.</span>
<span class="comment-copy">"<code>self</code> in python is a special keyword" - no, it's just an argument name like any other. Any other variable holding a <code>bean</code> instance would exhibit the same behavior on attribute access and assignment.</span>
<span class="comment-copy">@user2357112 Fair enough. I've edited to correct this, and hopefully it better expresses that <code>self</code> is special in the sense that it is automatically provided, but not special in the sense that it operates like an ordinary variable identifier in python.</span>
<span class="comment-copy">Aaron3468, I still find your phrasing misleading (hence my downvote). I suggest that you make it clear that "self" is in no way special, what matters is the <i>first argument to bound methods</i>. You could call it <code>this</code> or <code>potato</code> if you liked. You probably know this, but your post can be misleading in my opinion. (cc @user2357112)</span>
<span class="comment-copy">@AndrasDeak I've corrected this, and if you find it still misleading, feel free to suggest an edit</span>
<span class="comment-copy">Thanks, it should be clear now:)</span>
