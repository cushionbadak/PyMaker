<div class="post-text" itemprop="text">
<p>I am trying to asynchronously run the Popen command from subprocess, so that I can run other stuff in the background.</p>
<pre><code>import subprocess
import requests
import asyncio
import asyncio.subprocess    

    async def x(message):
        if len(message.content.split()) &gt; 1:
            #output = asyncio.create_subprocess_shell(message.content[3:], shell=True, stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
            output = subprocess.Popen(message.content[3:], shell=True, stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
            return output.communicate()[0].decode('utf-8')
</code></pre>
<p>I have tried to understand <a href="https://docs.python.org/3/library/asyncio-subprocess.html" rel="nofollow">https://docs.python.org/3/library/asyncio-subprocess.html</a> but i am not sure what a protocol factory is.</p>
</div>
<div class="post-text" itemprop="text">
<p>When I came to this question, I expected the answer to really use asyncio for interprocess communication.</p>
<p>I have found the following resource useful:
<a href="https://github.com/python/asyncio/blob/master/examples/child_process.py" rel="nofollow noreferrer">https://github.com/python/asyncio/blob/master/examples/child_process.py</a></p>
<p>and below is my simplified example (using 3.5+ async/await syntax), which reads lines and outputs them sorted:</p>
<pre><code>import asyncio

from subprocess import Popen, PIPE


async def connect_write_pipe(file):
    """Return a write-only transport wrapping a writable pipe"""
    loop = asyncio.get_event_loop()
    transport, _ = await loop.connect_write_pipe(asyncio.Protocol, file)
    return transport


async def connect_read_pipe(file):
    """Wrap a readable pipe in a stream"""
    loop = asyncio.get_event_loop()
    stream_reader = asyncio.StreamReader(loop=loop)

    def factory():
        return asyncio.StreamReaderProtocol(stream_reader)

    transport, _ = await loop.connect_read_pipe(factory, file)
    return stream_reader, transport


async def main(loop):
    # start subprocess and wrap stdin, stdout, stderr
    p = Popen(['/usr/bin/sort'], stdin=PIPE, stdout=PIPE, stderr=PIPE)

    stdin = await connect_write_pipe(p.stdin)
    stdout, stdout_transport = await connect_read_pipe(p.stdout)
    stderr, stderr_transport = await connect_read_pipe(p.stderr)

    # interact with subprocess
    name = {stdout: 'OUT', stderr: 'ERR'}
    registered = {
        asyncio.Task(stderr.read()): stderr,
        asyncio.Task(stdout.read()): stdout
    }

    to_sort = b"one\ntwo\nthree\n"
    stdin.write(to_sort)
    stdin.close()  # this way we tell we do not have anything else

    # get and print lines from stdout, stderr
    timeout = None
    while registered:
        done, pending = await asyncio.wait(
            registered, timeout=timeout,
            return_when=asyncio.FIRST_COMPLETED)
        if not done:
            break
        for f in done:
            stream = registered.pop(f)
            res = f.result()
            if res != b'':
                print(name[stream], res.decode('ascii').rstrip())
                registered[asyncio.Task(stream.read())] = stream
        timeout = 0.0

    stdout_transport.close()
    stderr_transport.close()


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main(loop))
    finally:
        loop.close()
</code></pre>
<p>NB: without taking special measures, the amount of data to be written into the pipe is limited. In my system it was possible to write just over 700000 bytes before using up pipe buffers.</p>
<p>There are also other examples there, using <code>create_subprocess_shell</code>.</p>
<p>I have not yet used asyncio in real projects, so improvements' suggestions in the comments are welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>Tested with python 3.5. Just ask if you have questions.</p>
<pre><code>import threading
import time
import subprocess
import shlex
from sys import stdout


# Only data wihtin a class are actually shared by the threads.
# Let's use a class as communicator (there could be problems if you have more than
# a single thread)
class Communicator(object):
    counter = 0
    stop = False
    arg = None
    result = None

# Here we can define what you want to do. There are other methods to do that
# but this is the one I prefer.
class ThreadedFunction(threading.Thread):

    def run(self, *args, **kwargs):
        super().run()
        command = c.arg

        # Here what you want to do...
        command = shlex.split(command)
        print(time.time()) # this is just to check that the command (sleep 5) is executed
        output = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
        print('\n',time.time())
        c.result = output
        if c.stop: return None # This is useful only within loops within threads

# Create a class instance
c = Communicator()
c.arg = 'time sleep 5' # Here I used the 'time' only to have some output

# Create the thread and start it
t = ThreadedFunction()
t.start() # Start the thread and do something else...

# ...for example count the seconds in the mean time..
try:
    for j in range(100):
        c.counter += 1
        stdout.write('\r{:}'.format(c.counter))
        stdout.flush()
        time.sleep(1)
        if c.result != None:
            print(c.result)
            break
except:
    c.stop = True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This one is much simpler, I found it after the other reply that could, anyway, be interesting... so I left it.</p>
<pre><code>import time
import subprocess
import shlex
from sys import stdout


command = 'time sleep 5' # Here I used the 'time' only to have some output

def x(command):
    cmd = shlex.split(command)
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return p

# Start the subprocess and do something else...
p = x(command)
# ...for example count the seconds in the mean time..

try: # This take care of killing the subprocess if problems occur
    for j in range(100):
        stdout.write('\r{:}'.format(j))
        stdout.flush()
        time.sleep(1)
        if p.poll() != None:
            print(p.communicate())
            break
except:
    p.terminate() # or p.kill()
</code></pre>
<p>The asynchronism is evident from the fact that the python script prints the counter value on the stdout while the background process runs the <code>sleep</code> command. The fact that the python script exit after ~5sec printing the output of the bash <code>time</code> command printing the counter in the meanwhile is an evidence that the script works.</p>
</div>
<div class="post-text" itemprop="text">
<p>I eventually found the answer to my question, which utilizes async.
<a href="http://pastebin.com/Zj8SK1CG" rel="nofollow">http://pastebin.com/Zj8SK1CG</a></p>
</div>
<span class="comment-copy">What is the problem?</span>
<span class="comment-copy">this does not run asynchronously. it waits on this process to be done, but i want it to run other stuff in the meantime. So like if i call this function first, then call another function, this function takes about 20s, the other one, about 2s. The second func will have to wait for 20s before running.</span>
<span class="comment-copy">Do you have reasons to avoid multithreads?</span>
<span class="comment-copy">what do u mean?</span>
<span class="comment-copy">You could do the same using multiprocessing or multithreding, and apparently looks easier...</span>
<span class="comment-copy">how would i get the output from this?</span>
<span class="comment-copy">the output is in <code>c.result</code></span>
<span class="comment-copy">i tried this one, but it doesn't seem to be asynchronous. I had to constantly wait for subprocess to finish.</span>
<span class="comment-copy">@JinyangLiu Once you run <code>p=x(command)</code> then the script can go ahead while the subprocess will run in background. Once you need the output of the background process you can just run <code>p.communicate()</code> and the python script will wait for the end of the command, if not finished yet. At a certain point you need to rejoin the script with the subprocess. If you need to rejoin them before the subprocess finishes the script must wait.</span>
<span class="comment-copy">Yea i see. I Found out the reason it wasn't running asynchronously for me was because of the .communicate() part. If i remove that. It prints out something like this <code>&lt;subprocess.Popen object at 0x7f60b99d8278&gt;</code>. Which doesn't show the output, but lets other programs run asynchronously.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/asyncio-subprocess.html" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-subprocess.html</a>, maybe this could help me? But i don't understand what a protocol factory is.</span>
<span class="comment-copy">@JinyangLiu subprocess works like that: 1. the creation of the Popen start a process in background; 2. you can do what you want while the process in background is running; 3. when you need the result from the process in background you can use communicate (as I did in the last example). 4. if the process in background is not finished yet the communicate will wait until the process finishes.  ---- What I did is an asyncronous background process. What do you need exactly?</span>
<span class="comment-copy">Is exactly the same I gave you...</span>
