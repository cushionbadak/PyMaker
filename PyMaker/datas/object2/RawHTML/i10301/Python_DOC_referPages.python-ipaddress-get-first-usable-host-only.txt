<div class="post-text" itemprop="text">
<p>I am using pythons ipaddress module and im trying to get the first usable host only, not all usable hosts</p>
<p>the below gives me all hosts, and when i try to index it i get the below error.</p>
<p>is is possible any other way to just get the first usable host?</p>
<p>Thanks</p>
<pre><code>n = ipaddress.ip_network(u'10.10.20.0/24')
for ip in n.hosts():
...  print ip
10.10.20.1
10.10.20.2
10.10.20.3
10.10.20.4
...
&gt;&gt;&gt; for ip in n.hosts():
...  print ip[1]
...
Traceback (most recent call last):
  File "&lt;console&gt;", line 2, in &lt;module&gt;
TypeError: 'IPv4Address' object does not support indexing
&gt;&gt;&gt;
</code></pre>
<p>the below is also failing</p>
<pre><code>&gt;&gt;&gt; print n.hosts()[0]
Traceback (most recent call last):
  File "&lt;console&gt;", line 1, in &lt;module&gt;
TypeError: 'generator' object has no attribute '__getitem__'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>hosts()</code> returns a generator object, which does not support indexing. You must iterate through it.</p>
<p>If you only want the first element, just use <code>next()</code>:</p>
<pre><code>n = ipaddress.ip_network(u'10.10.20.0/24')
first_host = next(n.hosts())
</code></pre>
<p>If you want to convert the generator object into a list which supports indexing, you have to call the <code>list()</code> function:</p>
<pre><code>all_hosts = list(n.hosts())
first_host = all_hosts[0]
</code></pre>
<p>You can also loop through a generator object like you would a list, as you did in your first code snippet:</p>
<pre><code>for ip in n.hosts():
    # do something with ip: this is the IP address, so don't try to index into it!
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Short version:</p>
<pre><code>import ipaddress
net=ipaddress.ip_network(u'1.0.0.0/8')
first=str(net[1])
last=str(net[-2])
</code></pre>
<p>Long version:</p>
<p>This shows 3 ways of computing first and last usable IP addresses
in a CIDR block using ipaddress.</p>
<p>It shows the "right" (fast, space efficient way to do this)
and two others using the hosts iterator which turn out to
illustrate a classic space time tradeoff.</p>
<pre><code>import ipaddress
import time
import sys

#
# The fast, memory efficient way
#

start = time.time()

net=ipaddress.ip_network(u'1.0.0.0/8')
first=str(net[1])
last=str(net[-2])

stop = time.time()
seconds=stop-start
size=sys.getsizeof(net)

print("First Host: %s, Last Host: %s, Seconds: %.4f, Size (Mb): %d" % (first,last, seconds, size/(1024**2)))

#
# Space efficient, but slow
#

start = time.time()

net=ipaddress.ip_network(u'1.0.0.0/8')
iterator=ipaddress.ip_network(u'1.0.0.0/8').hosts()
first = last = next(iterator, None)
for last in iterator:
    pass
first=str(first)
last=str(last)

stop = time.time()
seconds=stop-start
size=sys.getsizeof(net)

print("First Host: %s, Last Host: %s, Seconds: %.4f, Size (Mb): %d" % (first,last, seconds, size/(1024**2)))



#
# Memory hog and slow, the worst of both worlds.
#

start = time.time()

hosts=list(ipaddress.ip_network(u'1.0.0.0/8').hosts())
first_host=str(hosts[0])
last_host=str(hosts[-1])
size=sys.getsizeof(hosts)

stop = time.time()
seconds=stop-start
print("First Host: %s, Last Host: %s, Seconds: %.4f, Size (Mb): %d" % (first,last, seconds, size/(1024**2)))

First Host: 1.0.0.1, Last Host: 1.255.255.254, Seconds: 0.0000, Size (Mb): 0
First Host: 1.0.0.1, Last Host: 1.255.255.254, Seconds: 8.0086, Size (Mb): 0
First Host: 1.0.0.1, Last Host: 1.255.255.254, Seconds: 11.8096, Size (Mb): 132
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Alternate way to get the first host address <strong>especially for "big networks" / small prefix values</strong> is:</p>
<pre><code>In [2]: ip_network("10.10.20.0/24")[1]
Out[2]: IPv4Address('10.10.20.1')
</code></pre>
<p>No need to use the hosts() generator at all. See e.g. <a href="https://docs.python.org/3/library/ipaddress.html#networks-as-containers-of-addresses" rel="nofollow noreferrer">https://docs.python.org/3/library/ipaddress.html#networks-as-containers-of-addresses</a> about ipaddress Network objects as "containers of addresses". First address within this address space / "container of addresses" is the network address (index [0]). Last address is the broadcast address (index [-1]). </p>
<p>Or you can use the network address &amp; get the first host address by adding 1:</p>
<pre><code>In [4]: ip_network("10.10.20.0/24").network_address + 1
Out[4]: IPv4Address('10.10.20.1')
</code></pre>
<p>Depending on the prefix / netmask you are using, the <strong>hosts() generator can be slow</strong>. If you use</p>
<pre><code>list(ip_network("10.0.0.0/8").hosts())
</code></pre>
<p>the statement creates a list with 2**(32-8) - 2 = 16777214 entries</p>
<p>If I time this statment, it needs &gt; 10 sec to create this host list:</p>
<pre><code>In [11]: %time len(list(ip_network("10.0.0.0/8").hosts()))
Wall time: 13.6 s
Out[11]: 16777214
</code></pre>
<p>If I compare the time needed to get the first address:</p>
<pre><code>In [15]: %time list(ip_network("10.0.0.0/8").hosts())[0]
Wall time: 13.6 s
Out[15]: IPv4Address('10.0.0.1')
In [13]: %timeit -n10 -r5 ip_network("10.0.0.0/8")[1]
10 loops, best of 5: 11.8 µs per loop
In [17]: %timeit -n10 -r5 ip_network("10.0.0.0/8").network_address + 1
10 loops, best of 5: 9.16 µs per loop
</code></pre>
<p>Results: hosts() needs about 14 sec to finish. The alternatives are +/- 10 µs </p>
<p>timeit for a /24 network:</p>
<pre><code>In [19]: %timeit -n10 -r5 list(ip_network("10.0.0.0/24").hosts())[0]
10 loops, best of 5: 135 µs per loop

In [20]: %timeit -n10 -r5 ip_network("10.0.0.0/24").network_address + 1
10 loops, best of 5: 9.32 µs per loop
</code></pre>
</div>
<span class="comment-copy"><code>ip</code> is already a single IP in the list, what do you expect <code>ip[1]</code> to return?</span>
<span class="comment-copy">perfect! thankyou</span>
