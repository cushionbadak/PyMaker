<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/39618943/why-does-the-floating-point-value-of-40-1-look-nice-in-python-3-but-30-1-doesn">Why does the floating-point value of 4*0.1 look nice in Python 3 but 3*0.1 doesn't?</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>I am newbie to python.
I have one surprise result after executing following mathematical operation:</p>
<pre><code>1.1 + 2.2 
</code></pre>
<p>= <code>3.3000000000000003</code></p>
<p>then 
<code>4 / (2.0 + 3)</code> =  should be <code>0.80000000000000004</code> as per above operation.</p>
<p>but python return <code>0.8</code>.</p>
<p>i am not understanding why this difference is?
<a href="https://i.stack.imgur.com/4kBvV.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/4kBvV.png"/></a></p>
<p>i am using <strong>Python 2.7.6</strong> 
Please see attached image.</p>
<p>i know that if i use <code>print (1/3.0</code>) then it will give <code>3.30</code></p>
<p>My question are
1. why all digits of second operation is not displayed but all digit of first one's displayed?</p>
<ol start="2">
<li>how can we compare floating variables those values are dynamic for accurate result?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Python uses a minimalist <code>repr</code> for <code>float</code>s when possible. That is, it prints a value that is as precise as necessary to reproduce the exact value of the original <code>float</code> if you typed it in directly.</p>
<p>For <code>1.1 + 2.2</code>, the imprecision means it doesn't actually produce <code>3.3</code> precisely (<code>1.1 + 2.2 == 3.3</code> will evaluate to <code>False</code>). By contrast, <code>4 / (2.0 + 3)</code> is exact enough that <code>0.8</code> represents it precisely, (<code>4 / (2.0 + 3) == 0.8</code> evaluates to <code>True</code>) so it doesn't include a whole bunch of <code>0</code>s that aren't required to reproduce the value.</p>
<p>If you want to explicitly print a certain number of places after the decimal, use <code>str</code> formatting to specify, e.g.:</p>
<pre><code>&gt;&gt;&gt; print('{:.16f}'.format(4 / (2.0 + 3)))
0.8000000000000000
</code></pre>
<p>If you formatted it with additional digits, you'd see the <code>4</code>, but that value is still exactly the same as <code>0.8</code>; <code>0.80000000000000004 == 0.8</code> evaluates to <code>True</code>, so Python avoids the verbosity and just gives you shortest of many equivalent representations.</p>
<p>The <a href="https://docs.python.org/3/whatsnew/3.1.html#other-language-changes" rel="nofollow">What's new in Python 3.1 docs (scroll to end of linked section, just before "New, Improved and Deprecated Modules")</a> are a useful explanation for why/when Python 2.7/3.1+ have much shorter <code>float</code> <code>repr</code>s for some values. Straight from the horse's mouth, so to speak.</p>
</div>
<span class="comment-copy"><a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="nofollow noreferrer">What every computer scientist should know about floating-point arithmetic.</a></span>
<span class="comment-copy">And its not only python, try Java and check the results.</span>
<span class="comment-copy">I recall that Python does do something funky with its dealings with floating point. I can't recall what they call it though. I've retracted my dupe close vote since I think it could be important.</span>
<span class="comment-copy">Voted to reopen. The dupe only partially explains Python's output.</span>
<span class="comment-copy"><code>1 / 3.0</code> seriously gives you <code>3.30</code>? Interesting Python you have there :)</span>
<span class="comment-copy">i have updated my question and i dont want to print but  i want to know logic behind it and how to compare these type floating values?</span>
