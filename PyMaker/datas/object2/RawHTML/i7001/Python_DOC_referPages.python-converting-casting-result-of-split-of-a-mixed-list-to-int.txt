<div class="post-text" itemprop="text">
<p>I wonder if there is a more elegant/pythonic way to get the same result as the following code:</p>
<p><code>num1, num2, string = input().split()
    num1 = int(num1)
    num2 = int(num2)</code></p>
<p>where num1 (1 &lt;= num1 &lt;= 15) and num2 (5 &lt;= num2 &lt;= 100) are integer and string is a string consisting of only uppercase letters.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could pre-define the sequence of the respective types and directly cast them using <code>zip</code> (in python 3).</p>
<pre><code>types = (int, int, str)
num1, num2, string = (typ(value) for typ, value in zip(types, input().split()))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With <code>map()</code> and <code>str.isdigit()</code> functions, assuming that input expects only integer and text values in strict order:</p>
<pre><code>num1, num2, str1 = map(lambda x: x if not x.isdigit() else int(x), input().split())
print(type(num1), type(num2), type(str1))
</code></pre>
<p>The output (for input <code>"10 55 hello"</code>):</p>
<pre><code>&lt;class 'int'&gt; &lt;class 'int'&gt; &lt;class 'str'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>input_string = "1 2 rand_string"
num1, num2, string = [ int(i) if i.isdigit() else i for i in input_string.split() ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think this has been said yet - it may be an option to use <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer"><code>argparse</code></a>. For your specific case, this may be a little over the top, and I would recommend using another answer, but for someone with a larger use case this may be useful as it can easily handle many different types and names. It is also shorter if you need to use it many times. This could probably also be extended to some more types - argparse supports file types, for example.</p>
<pre><code>import argparse
import shlex

def build_parser(names):
    parser = argparse.ArgumentParser()
    for name, type_ in names:
        parser.add_argument(name, type=type_)
    def parse(args):
        return parser.parse_args(shlex.split(args))
    return parse

parse = build_parser([("num1", int), ("num2", int), ("string", str)])

result = parse("12 45 foo")
print(result)
print("num2 is {}".format(result.num2))
print("num1 and string are {0.num1}, {0.string}".format(result))

print(parse("1 2 abc"))
print(parse("500 39 'the quick brown fox'"))
</code></pre>
<p>This has the output:</p>
<pre><code>Namespace(num1=12, num2=45, string='foo')
num2 is 45
num1 and string are 12, foo
Namespace(num1=1, num2=2, string='abc')
Namespace(num1=500, num2=39, string='the quick brown fox')
</code></pre>
<p>Here, <code>build_parser</code> takes a list of tuples of the name and type of each variable, and builds a parser, returning a closure that can parse a string into a Namespace object. Namespace object can be used by just using the attribute syntax (like <code>result.num2</code>). You can see also that as I've used shlex.split, it can handle an input like <code>"500 39 'the quick brown fox'"</code></p>
<p>Note that the only way to stop an exception, to my knowledge is to use</p>
<pre><code>try:
    print(parse("1 x 2"))
except SystemExit:
    print("stopped the exception")
</code></pre>
<p>This is slightly dubious as <code>SystemExit</code> may have been for some other, good, reason.</p>
</div>
<span class="comment-copy">num1 is integer so why you used (split())?</span>
<span class="comment-copy">which python version are you using?</span>
<span class="comment-copy">@keyvanvafaee <code>input</code> will return a string. Presumably the expected input is space-separated.</span>
<span class="comment-copy">@MedAli I'm using version 3.5.4</span>
<span class="comment-copy">@Gluglack looking at the answers I think your solution is better... when in doubt just keep it simple... also <code>import this</code></span>
<span class="comment-copy">Why use a list comprehension and not just a generator expression?</span>
<span class="comment-copy">Because I feel like it looks better. No one's asking anyone to use it, just threw out another method. And it's also much easier to read.</span>
<span class="comment-copy">Definitely. Don't judge my preferences.</span>
