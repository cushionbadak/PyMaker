<div class="post-text" itemprop="text">
<p>I try to write a python-parent-script, that collects data from 4 child-scripts. What I got:</p>
<ul>
<li><p>Every child-script reads data from a different sensor and they have to be read continiously. So what I do right now is read them in while True loops.</p></li>
<li><p>Different sensors have different response times, so one child-script is reading with a, lets say, once a second rate while another will read 100 times faster.</p></li>
</ul>
<p>My goal/my struggle:</p>
<ul>
<li>Collect all the child-generated data in one script, in 4 different variables</li>
</ul>
<p>What I acheved yet:</p>
<ul>
<li><p>Child-scripts are doing there work fine and reading the data with no issues</p></li>
<li><p>I could start all 4 child-scripts from terminal as subprocesses but no idea how to collect ther generated data</p></li>
<li><p>Pass data between scripts but never from two scripts at the same time and way to slow, since the 'from script import variable' is as fast as the reading of the sensor.</p></li>
</ul>
<p>Later plans are sending those 4 variables via Bluetooth to my phone, whitch I successed allready with only one sensor.</p>
<p>Since I am quite new to the whole Raspberry/Python community I would firstly say sorry for unspecific explenation. Please feel free to ask for further informations or suggest to solve things differently. And secondly I would appreceate it a lot if you could help me with code-snippets if you like, because again I am quite new and that helps me way more then links to librarys or documenturies that create more questions than answearing them.</p>
<p>Thank you a lot in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way to accomplish this would be using threads, available through the <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">threading class</a>. Collecting data would be as simple as writing to a shared variable (with thread safety of course).</p>
<pre><code>import threading
import time

data1 = []
lock1 = threading.Lock() # Use a lock, mutex, or semaphore to ensure thread safety

def foo():
    while True:
        lock1.acquire()
        data1.append(bar)
        lock1.release()
        time.sleep(10)

 foo_thread = threading.thread(target=foo)
 foo_thread.start()

 while True:
     lock1.acquire()
     # If all values don't need to be held in memory the parent
     # script can implement some kind of queue and delete values 
     # after processing
     do_stuff_with(data)
     lock1.release()
     # Queuing also allows the parent script to run at a much slower rate
     time.sleep(100)
</code></pre>
<p>The example above is a very quick demonstration of threading. There are better data types to implement queuing in, such as <a href="https://docs.python.org/3/library/collections.html?highlight=deque#collections.deque" rel="nofollow noreferrer">collection.deque</a>. </p>
<p>Threading in python does have some caveats though, namely python runs scripts in one single process and there is a Global Interpreter Lock, meaning the threading module provides concurrency, but not parallelism. For only 4 data collections it probably would cause any issues, but if better performance is needed <a href="https://docs.python.org/3/library/multiprocessing.html?highlight=multiprocessing#module-multiprocessing" rel="nofollow noreferrer">multiprocessing</a> provides tools for spawning multiple python processes allowing for true parallelism.</p>
</div>
<span class="comment-copy">Thank you so mutch for the detailled answear an for your effort, I will try  that and get back to you if it worked.</span>
