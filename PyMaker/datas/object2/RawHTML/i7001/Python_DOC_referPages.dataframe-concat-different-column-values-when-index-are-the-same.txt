<div class="post-text" itemprop="text">
<p>I am working on concat multiple DataFrames(DFs) into one DF with Python, after concat some sample DFs as below:</p>
<pre><code>import pandas as pd

df_list = []

df_0 = pd.DataFrame('1.11', index=['SS_0'], columns=['Tx-UDP'])
df_1 = pd.DataFrame('2.22', index=['SS_1'], columns=['Tx-UDP'])
df_2 = pd.DataFrame('3.33', index=['SS_1'], columns=['Tx-TCP'])

df_list.append(df_0)
df_list.append(df_1)
df_list.append(df_2)

df_final = pd.concat(df_list) # type: pd.DataFrame

print(df_final)
</code></pre>
<p>I got results print out as:</p>
<pre><code>     Tx-TCP Tx-UDP
SS_0    NaN   1.11
SS_1    NaN   2.22
SS_1   3.33    NaN
</code></pre>
<p>But what I really want the result is like below format, which based on index content, if index content are the same, the value will be put into same row under each columns, rather than starting a new row and fill in with NaN, i.e. index 'SS_1' in example. If index is unique and no data presenting under certain column, then fill in with 'NaN' is fine, i.e. index 'SS_0'/col 'Tx-TCP'.</p>
<pre><code>     Tx-TCP Tx-UDP
SS_0    NaN   1.11
SS_1   3.33   2.22
</code></pre>
<p>Tried with concat/merge/join/grouby etc., but haven't found a way to do that. 
Please help to advise and Thanks a lot in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Option 1</strong><br/>
You want to iteratively apply the dataframe method <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.combine_first.html" rel="nofollow noreferrer"><strong><code>pd.DataFrame.combine_first</code></strong></a> using <a href="https://docs.python.org/3.0/library/functools.html#functools.reduce" rel="nofollow noreferrer"><strong><code>reduce</code></strong></a> from <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer"><strong><code>functools</code></strong></a></p>
<pre><code>from functools import reduce

reduce(pd.DataFrame.combine_first, df_list)

      Tx-TCP Tx-UDP
SS_0     NaN   1.11
SS_1    3.33   2.22
</code></pre>
<hr/>
<p><strong>Option 2</strong><br/>
My version of a <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.concat.html" rel="nofollow noreferrer"><strong><code>pd.concat</code></strong></a> solution  </p>
<pre><code>pd.concat(df_list).groupby(level=0).first()

     Tx-TCP Tx-UDP
SS_0    NaN   1.11
SS_1   3.33   2.22
</code></pre>
<p>Or</p>
<pre><code>pd.concat(df_list).groupby(level=0).last()

     Tx-TCP Tx-UDP
SS_0    NaN   1.11
SS_1   3.33   2.22
</code></pre>
<hr/>
<p><strong>Experiment A</strong><br/>
playing around</p>
<pre><code>from functools import reduce

idx = reduce(pd.Index.union, [d.index for d in df_list])
col = reduce(pd.Index.union, [d.columns for d in df_list])
tmp = pd.DataFrame(index=idx, columns=col)
reduce(pd.DataFrame.fillna, [tmp] + df_list)

     Tx-TCP Tx-UDP
SS_0    NaN   1.11
SS_1   3.33   2.22
</code></pre>
<hr/>
<p><strong>Experiment B</strong><br/>
playing around</p>
<pre><code>from functools import reduce

idx = reduce(pd.Index.union, [d.index for d in df_list])
col = reduce(pd.Index.union, [d.columns for d in df_list])
tmp = pd.DataFrame(index=idx, columns=col)
[tmp.update(d) for d in df_list];
tmp

     Tx-TCP Tx-UDP
SS_0    NaN   1.11
SS_1   3.33   2.22
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way would be concat the dataframes on axis 1 and consolidate columns using groupby</p>
<pre><code>pd.concat([df_0, df_1,df_2], axis = 1).groupby(level = 0, axis = 1).first()


        Tx-TCP  Tx-UDP
SS_0    NaN     1.11
SS_1    3.33    2.22
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This my additional code to fix your code </p>
<pre><code>df=df.groupby(level=0).bfill()

df.reset_index().drop_duplicates(subset='index', keep='first').set_index('index')

Out[1076]: 
       Tx-TCP  Tx-UDP
index                
SS_0      NaN    1.11
SS_1     3.33    2.22
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>how about this:</p>
<pre><code>pd.concat([df_0,df_1.join(df_2)])
</code></pre>
</div>
<span class="comment-copy"><code>df_final.apply(pd.to_numeric).groupby(level=0).agg(np.nanmean)</code>?</span>
<span class="comment-copy">It seems that you have asked multiple questions and you <a href="https://stackoverflow.com/help/someone-answers">received multiple answers</a>. Please <a href="https://stackoverflow.com/help/accepted-answer">consider accepting</a> answers in case they actually solve your problem. This signals that your problem is solved, furthermore it gives the answerer and yourself reputation.</span>
<span class="comment-copy">Never came across functools, time for more studies :)+1</span>
<span class="comment-copy"><code>reduce</code> was a built-in in python 2.  It was removed in python 3 but still available in <code>functools</code></span>
<span class="comment-copy">Sry PiR I have a question So when we do last(), NaN will fill automatically ?</span>
<span class="comment-copy"><code>last</code> and <code>first</code> in a <code>groupby</code> context get's the last or first non-null value.  It isn't well documented.  Ask a question about it.</span>
<span class="comment-copy">PiR I post a question about it ~</span>
