<div class="post-text" itemprop="text">
<p>I am trying to understand <code>asyncio</code> and port my undestanding of <code>threading</code>. I will take the example of two threads running indefinitely and a non-threaded loop (all of them outputting to the console).</p>
<p>The <code>threading</code> version is </p>
<pre><code>import threading
import time

def a():
    while True:
        time.sleep(1)
        print('a')

def b():
    while True:
        time.sleep(2)
        print('b')

threading.Thread(target=a).start()
threading.Thread(target=b).start()
while True:
        time.sleep(3)
        print('c')
</code></pre>
<p>I now tried to port this to <code>asyncio</code> based on the <a href="https://docs.python.org/3/library/asyncio-task.html#tasks-and-coroutines" rel="noreferrer">documentation</a>.</p>
<p><strong>Problem 1</strong>: I do not understand how to add the non-threaded task as all examples I saw show an ongoing loop at the end of the program which governs the <code>asyncio</code> threads.</p>
<p>I then wanted to have at least the two first threads (<code>a</code> and <code>b</code>) running in parallel (and, worst case, add the third <code>c</code> as a thread as well, abandonning the idea of mixed thread and non-threded operations):</p>
<pre><code>import asyncio
import time

async def a():
    while True:
        await asyncio.sleep(1)
        print('a')

async def b():
    while True:
        await asyncio.sleep(2)
        print('b')

async def mainloop():
    await a()
    await b()

loop = asyncio.get_event_loop()
loop.run_until_complete(mainloop())
loop.close()
</code></pre>
<p><strong>Problem 2</strong>: The output is a sequence of <code>a</code>, suggering that the <code>b()</code> coroutine is not called at all. Isn't <code>await</code> supposed to start <code>a()</code> and come back to the execution (and then start <code>b()</code>)?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>await</code> stops execution at a point, you do <code>await a()</code>, and you have an infinite loop in <code>a()</code>, so it's logical <code>b()</code> doesn't get called. Think about it as if you insert <code>a()</code> in <code>mainloop()</code>.</p>
<p>Consider this example:</p>
<pre><code>async def main():
    while True:
        await asyncio.sleep(1)
        print('in')

    print('out (never gets printed)')
</code></pre>
<p>To achieve what you want you need to create a future which would manage multiple coroutines. <code>asyncio.gather</code> is for that.</p>
<pre><code>import asyncio


async def a():
    while True:
        await asyncio.sleep(1)
        print('a')


async def b():
    while True:
        await asyncio.sleep(2)
        print('b')


async def main():
    await asyncio.gather(a(), b())


loop = asyncio.get_event_loop()
loop.run_until_complete(main())
loop.close()
</code></pre>
</div>
<span class="comment-copy">Thank you Danil. If I get it right, I therefore have to start all my coroutines at the same time (via <code>.gather()</code>) and what was possible with <code>threading</code> (start a thread, do something, start another thread, ...) is not possible anymore with  ` asyncio` ?</span>
<span class="comment-copy">@WoJ, if I understand it right -- then yes, because you pass control over the execution process to the loop in the moment you do <code>await</code></span>
<span class="comment-copy">@WoJ, if it worked for you please mark you question as answered</span>
<span class="comment-copy">Sure, I already upvoted it, waiting a bit in hope that there could be a solution for the separated start of coroutines, otherwise yours is great, thanks.</span>
