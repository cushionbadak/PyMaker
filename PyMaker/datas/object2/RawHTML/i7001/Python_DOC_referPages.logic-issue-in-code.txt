<div class="post-text" itemprop="text">
<p>I have this code, where I am trying to shift p position by value 1 and in cyclic order, for example <code>p[1]=p[0], p[2]=p[1].... till p[4]=p[0]</code>
I applied the following logic, but all I am getting is only p[0] all the time, can anyone please suggest something..</p>
<pre><code>p=[1, 1, 0, 0, 0]


def move(p, U):
    q=[]
    for i in range(len(p)):
        print p[i]
        m=(U+i)%(len(p))
        p[m]=p[i]

    q=p
    return q
print move(p, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>    m=(U+i)%(len(p))
    p[m]=p[i]
</code></pre>
<p>Right here you're modifying your list as you're iterating through it. That's a no-no. Try making a new list first and modifying that.</p>
<pre><code>q = [None for _ in range(len(p))]  # q has length == len(p), filled with None
for i, value in enumerate(p):
    print value
    m = (U+i) % len(p)
    q[m] = value
</code></pre>
<p>I also use <code>enumerate</code> here which is more idiomatic when you need both the index and the value of an iterable.</p>
<hr/>
<p>Note that if you're trying for efficiency here instead of algorithm practice, <a href="https://docs.python.org/3/library/collections.html?highlight=deque#deque-objects" rel="noreferrer"><code>collections.deque</code></a> is your friend. A deque is a double-ended queue, so it supports efficient pops and inserts from the start and the end. It also has a <code>rotate</code> function that does exactly this.</p>
<pre><code>from collections import deque

d = deque(p)
# d = deque([1, 1, 0, 0, 0])
d.rotate(-1)  # rotate left by an index
# d = deque([1, 0, 0, 0, 1])
d.rotate(1)  # rotate right by an index
# d = deque([1, 1, 0, 0, 0])
d.rotate(1)  # rotate right by an index
# d = deque([0, 1, 1, 0, 0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A very simple way to do this:</p>
<pre><code>p.insert(0, p.pop())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with slicing the list.</p>
<p>l = [1, 2, 3, 4, 5]</p>
<pre><code>def move(my_list=None, step=None):
    return my_list[step:] + my_list[:step]
print move(my_list=l, step=1)
print move(my_list=l, step=2)
print move(my_list=l, step=-1)
</code></pre>
<p>Output</p>
<pre><code>[2, 3, 4, 5, 1]
[3, 4, 5, 1, 2]
[5, 1, 2, 3, 4]
</code></pre>
</div>
<span class="comment-copy">Try printing <code>p</code> at every step of your loop to see what's going wrong</span>
<span class="comment-copy">you are rewriting <code>p[m]</code> without saving its old value to reuse it in the next iteration</span>
<span class="comment-copy">Thank you for the help  :)</span>
