<div class="post-text" itemprop="text">
<p>I have been looking into the <a href="https://pypi.python.org/pypi/requests-mock" rel="nofollow noreferrer">requests_mock</a> library in order to check the response. I am just wondering how I can actually 'hijack' the actual request to do a mocked one.</p>
<p>In my <code>test_model.py</code> I will create a new <code>SomeModel</code>. When the SomeModel.objects.create() is done, the signal will be triggered.</p>
<p>The signal is as follow:</p>
<pre><code>@receiver(post_save, sender=SomeModel, dispatch_uid="update_model")
def update_model(sender, instance, created, **kwargs):
    instance.update_status()
</code></pre>
<p>From the <code>update_status</code> function it goes trough one other function where it sets the payload and the URL, and then it actually does the request in the <code>send_model</code> function as follows:</p>
<pre><code>def send_model(url, payload):
    ....
    request.post(url, data=json.dumps(payload), headers=headers)  &lt;- request to be mocked
</code></pre>
<p>My question is, how do I actually mock this request when running the tests?</p>
</div>
<div class="post-text" itemprop="text">
<p>Django has <a href="https://docs.djangoproject.com/en/1.11/topics/testing/advanced/#the-request-factory" rel="nofollow noreferrer"><code>RequestFactory</code></a>:</p>
<blockquote>
<p><a href="https://docs.djangoproject.com/en/1.11/topics/testing/advanced/#the-request-factory" rel="nofollow noreferrer">RequestFactory provides a way to generate a request instance that can
  be used as the first argument to any view.</a></p>
</blockquote>
<pre><code> mock_request = RequestFactory()
 mock_request.get('/url/')
 mock_request.post('/url/', data={'key':'value'})
</code></pre>
<p>Edit:</p>
<p>You can patch a view wit a mock request, take a look at <a href="https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock" rel="nofollow noreferrer">mock</a> library, <code>PropertyMock</code> class; I remember I had the same problem and I did it like this: </p>
<pre><code>import mock
with patch("views.MyView.request", create=True, new_callable=mock.PropertyMock, return_value=mock_request):
    # Run your view, do your test under the `with` statement where the view is patched with the mock_request
    self.assertFalse(True)
</code></pre>
</div>
<span class="comment-copy">I see, but the idea is to check 1. whether the signal for the model is correct and 2. when it goes trough the signal into the final function, if that returns the correct status. The payload for this URL is being built within the functions it goes through, so I cannot just pass this on in the test function itself I assume</span>
<span class="comment-copy">See my edit, I think that is what you are missing.</span>
<span class="comment-copy">I am curios, was it helpfull?</span>
<span class="comment-copy">Well, fact is that I can indeed do all of this in the tests itself, however this function does not take a request directly, and it will not work therefore. It's a complicated test case, and cannot display all of the code here unfortunately. Thanks for the help though!</span>
