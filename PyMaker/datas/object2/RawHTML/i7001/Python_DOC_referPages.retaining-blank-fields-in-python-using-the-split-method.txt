<div class="post-text" itemprop="text">
<p>I have a tab delimited file that has entries that look like this:</p>
<pre><code>strand1       strand2        genename        ID 
AGCTCTG        AGCTGT           Erg1          ENSG010101
</code></pre>
<p>However, some of them have blank fields, for example:</p>
<pre><code>strand1       strand2         genename         ID 
AGCGTGT        AGTTGTT                         ENSG12955729
</code></pre>
<p>When I read in the lines in python:</p>
<pre><code>data = [line.strip().split() for line in filename]
</code></pre>
<p>The second example becomes collapsed into a list of 3 indices:</p>
<pre><code>['AGCGTGT', 'AGTTGTT', 'ENSG12955729'] 
</code></pre>
<p>I would rather that the empty field be retained so that the second example becomes a list of 4 indices:</p>
<pre><code>['AGCGTGT', 'AGTTGTT', '', 'ENSG12955729'] 
</code></pre>
<p>How can I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>As others have stated you can explicitly split on tabs, but you would still need to cleanup the line endings.  </p>
<p>Better would be to use the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code> module</a> which handles delimited files:</p>
<pre><code>import csv
with open('filename.txt', newline='') as f:
    reader = csv.reader(f, delimiter='\t')
    headers = next(reader)
    data = list(reader)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can split explicitly on tab:</p>
<pre><code>&gt;&gt;&gt; "foo\tbar\t\tbaz".split('\t')
['foo', 'bar', '', 'baz']
</code></pre>
<p>By default, <code>split()</code> is going to split on any amount of whitespace.</p>
<p>Unless you can ensure that the first and last columns won't be blank, <code>strip()</code> is going to cause problems. If the data is otherwise well-formatted, this solution will work.</p>
<p>If you know that the only tabs are field delimiters, and you still want to strip other whitespace (spaces) from around individual column values:</p>
<pre><code>map(str.strip, line.split('\t'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you don't give a parameter to the <code>str.split()</code> method, it treats any contiguous sequence of whitespace characters as a single separator.  When you do give it a parameter, <code>.split('\t')</code> perhaps, it treats each individual instance of that string as a separator.</p>
</div>
<div class="post-text" itemprop="text">
<p>Split method without any argument considers continuous stream of spaces as a single character so it splits all amount of whitespaces. You need to specify an argumnet to the method which in your case is \t.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm always looking for puzzles to which I can apply pyparsing, no matter how impractical the results might prove to be. If nothing else, I can always look through my old answers to see what I've tried.</p>
<p>Don't judge me too harshly. :)</p>
<pre><code>import pyparsing as pp
item = pp.Word(pp.alphanums) | pp.Empty().setParseAction(lambda x: '')
TAB = pp.Suppress(r'\t')
process_line = pp.Group(item('item') + TAB + item('item') + TAB + item('item') + TAB + item('item'))

with open('tab_delim.txt', 'rb') as tabbed:
    while True:
        line = tabbed.readline()
        if line:
            line = line.decode().strip().replace('\t', '\\t' )+3*'\\t'
            print (line.replace('\\t', ' '))
            print('\t', process_line.parseWithTabs().parseString(line))
        else:
            break
</code></pre>
<p>Output:</p>
<pre><code>strand1 strand2 genename ID   
     [['strand1', 'strand2', 'genename', 'ID']]
AGCTCTG AGCTGT Erg1 ENSG010101   
     [['AGCTCTG', 'AGCTGT', 'Erg1', 'ENSG010101']]
AGCGTGT AGTTGTT  ENSG12955729   
     [['AGCGTGT', 'AGTTGTT', '', 'ENSG12955729']]
ABC DEF   
     [['ABC', 'DEF', '', '']]
</code></pre>
<p>Edit: Altered the line <code>TAB = pp.Suppress(r'\t')</code> to what was suggested by PaulMcG in a comment (from a construction with a double-slash prior to the 't' in a non-raw string).</p>
</div>
<span class="comment-copy">Yeah, I'll edit to remove the <code>strip()</code> so it's more general-purpose. This is all very dependent on the data being well-formatted, and is not necessary a perfect solution.</span>
<span class="comment-copy">Nice - since tabs are significant here, you can remove them from the default whitespace characters using <code>ParserElement.setDefaultWhitespaceChars(' ')</code>. For strings that contain significant <code>\ </code> characters (that is to suppress the Python interpreter's conversion of '\t' to &lt;TAB&gt;) use raw string literals: <code>r'\t'</code>. These were added to Python to make regex easier to enter but they would work here too. And since I updated to Python 3.5, I've fallen in love with the stdlib's <code>pathlib.Path</code> class for reading/writing short files, composing file references using <code>Path(some_directory) / filename_str</code>.</span>
<span class="comment-copy">I tried various ways of making raw string literals for tab work. Let me just say that success was elusive. :) If you look at some of my answers you'll see that I too have been evangelising for pathlib. Let's end the struggles with <code>listdir</code>, <code>walk</code> and <code>glob</code>! PS: I'd be open to an example for the tabs.</span>
<span class="comment-copy">I was referring to your <code>'\\t'</code> strings, which you could write as <code>r'\t'</code>. I can't envision a way to embed a tab or newline in a raw string literal, since the whole point is to <i>not</i> interpret the backslash but to leave it in verbatim.</span>
<span class="comment-copy">@PaulMcG: Changed according to my understanding of your comment.</span>
