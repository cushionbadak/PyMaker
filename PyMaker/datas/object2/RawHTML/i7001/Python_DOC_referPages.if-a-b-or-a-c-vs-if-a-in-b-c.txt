<div class="post-text" itemprop="text">
<p>In my code I used to have comparisons like <code>if a == b or a == c or a == d:</code> fairly frequently. At some point I discovered that these could easily be shortened to <code>if a in {b, c, d}:</code> or <code>if a in (b, c, d):</code> if the values aren't hashable. However, I have never seen such a construction in anyone else's code. This is probably because either:</p>
<ol>
<li>The <code>==</code> way is slower.</li>
<li>The <code>==</code> way is more pythonic.</li>
<li>They actually do subtly different things.</li>
<li>I have, by chance, not looked at any code which required either.</li>
<li>I have seen it and just ignored or forgotten it.</li>
<li>One shouldn't need to have comparisons like this because one's code sould be better elsewhere.</li>
<li><del>Nobody has thought of the <code>in</code> way except me.</del></li>
</ol>
<p>Which reason, if any, is it?</p>
</div>
<div class="post-text" itemprop="text">
<p>For simple values (i.e. not expressions or <code>NaN</code>s), <code>if a == b or a == c</code> and <code>if a in &lt;iterable of b and c&gt;</code> are equivalent. </p>
<p>If the values are hashable, it's better to use <code>in</code> with a <em>set literal</em> instead of tuple or list literals:</p>
<pre><code>if a in {b, c}: ...
</code></pre>
<p>CPython's <a href="https://github.com/python/cpython/blob/master/Python/peephole.c" rel="nofollow noreferrer">peephole optimiser</a> is often able to replace that with a cached <a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow noreferrer"><code>frozenset()</code></a> object, and membership tests against sets are O(1) operations.</p>
</div>
<div class="post-text" itemprop="text">
<p>Performancewise : "in" is better</p>
<pre><code>timeit.timeit("pub='1'; pub == 1 or pub == '1'")
0.07568907737731934
timeit.timeit("pub='1'; pub in[1, '1']")
0.04272890090942383
timeit.timeit("pub=1; pub == 1 or pub == '1'")
0.07502007484436035
timeit.timeit("pub=1; pub in[1, '1']")
0.07035684585571289
</code></pre>
<p>Also "in" ensures code is not repeating a == 1 or a == 2 is repetition.
And bad to read. "in" just makes it much more easy to understand. This is one of the cases which is simple yet elegant code practice. In short we(should) use "in" more often if we are not already using it.</p>
</div>
<div class="post-text" itemprop="text">
<p>I was curious to know what the timing difference was between straight comparison vs checking in the array. </p>
<p>Conclusion: <strong>The cost of constructing the array is not free and must be taken into account when considering the speed differences.</strong></p>
<p>If the array is being constructed at the time of comparison, it is technically slower than the simple comparison.  So the simple comparison would be faster in or out of a loop.</p>
<p>That said if the array is already constructed then it would be faster to check in the array in a large loop than doing a simple comparison.</p>
<pre><code>$ speed.py
inarray                   x 1000000:  0.277590343844
comparison                x 1000000:  0.347808290754
makearray                 x 1000000:  0.408771123295
</code></pre>
<pre class="lang-py prettyprint-override"><code>import timeit

NUM = 1000000

a = 1
b = 2
c = 3
d = 1

array = {b,c,d}
tup = (b,c,d)
lst = [b,c,d]

def comparison():
    if a == b or a == c or a == d:
        pass

def makearray():
    if a in {b, c, d}:
        pass

def inarray():
    if a in array:
        pass

def maketuple():
    if a in (b,c,d):
        pass

def intuple():
    if a in tup:
        pass

def makelist():
    if a in [b,c,d]:
        pass

def inlist():
    if a in lst:
        pass


def time_all(funcs, params=None):
    timers = []
    for func in funcs:
        if params:
            tx = timeit.Timer(lambda: func(*params))
        else:
            tx = timeit.Timer(lambda: func())
        timers.append([func, tx.timeit(NUM)])

    for func, speed in sorted(timers, key=lambda x: x[1]):
        print "{fn:&lt;25} x {n}: ".format(fn=func.func_name, n=NUM), speed
    print ""
    return

time_all([comparison,
          makearray,
          inarray,
          intuple,
          maketuple,
          inlist,
          makelist
          ], 
         )
</code></pre>
<p>This doesn't quite answer your question as to the reason why you don't often see the comparison using in.  I would be speculating but it's likely a mix of 1,2,4, and the situation where the author needed to write that particular bit of code.</p>
<p>I've personally used both methods depending on the situation.  The choice usually came down to speed or simplicity.</p>
<hr/>
<p>edit:</p>
<p>@bracco23 is right, there are slight differences whereby using tuples vs array vs list will change the timing.</p>
<pre><code>$ speed.py
inarray                   x 1000000:  0.260784980761
intuple                   x 1000000:  0.288696420718
inlist                    x 1000000:  0.311479982167
maketuple                 x 1000000:  0.356532747578
comparison                x 1000000:  0.360010093964
makearray                 x 1000000:  0.41094386108
makelist                  x 1000000:  0.433603059099
</code></pre>
</div>
<span class="comment-copy">you haven't seen <code>if a in (b, c, d):</code>? If not, you haven't seen enough. This is very very common so <b>5</b> or .. well <b>8</b>.</span>
<span class="comment-copy">Point 3 is true, but that's not usually why one is preferred over the other.</span>
<span class="comment-copy">1 might be true, especially for larger sets of values, but I think you meant it the other way 'round.</span>
<span class="comment-copy">As shown by this possible duplicate, its answers, and its linked questions, this is indeed a very common construct and does what you expect.</span>
<span class="comment-copy">@Ev.Kounis also, <code>b</code> and <code>c</code> are guaranteed to be evaluated in case of <code>a in (b,c)</code>, but <code>a==b or a==c</code> might short-circuit.</span>
<span class="comment-copy">Nitpick: they're not quite equivalent, though in many cases that occur in practice they're likely to be interchangeable. Consider the case where <code>a = b = c = float('nan')</code>: <code>a == b or a == c</code> is <code>False</code>, while <code>a in {b, c}</code> is <code>True</code>.</span>
<span class="comment-copy">@MarkDickinson Why is the first one <code>False</code>?</span>
<span class="comment-copy">@Ev.Kounis because of the standard IEE754, NaN is the only element which is not equal to itself, it is exactly how you should test it!</span>
<span class="comment-copy">@Ev.Kounis <code>a = b = c = float('nan') ; print(a == b) ; False</code></span>
<span class="comment-copy">@Ev.Kounis I dont think so, NaN means not a number, it is the same problem than NULL in Database. How could you compare something that you do not know. Therefore it does not compare, but it is handy to have a truth value, so it compare to False instead of raising an error</span>
<span class="comment-copy">Try adding a large <code>number</code> argument to the <code>timeit()</code> function and notice the results start to change.</span>
<span class="comment-copy">I added some tests using tuples instead of arrays. When using an already existent tuple, it performs better than the comparison but worse than an already existent array. When we make the tuple on the fly, it performs better than making the array and more or less like the comparison ( they switched place a couple of times in the ordered list)</span>
<span class="comment-copy">Good call.  I've edited the response to reflect those differences. tuples, list, arrays all have slightly different timings.</span>
<span class="comment-copy">Out of curiosity I modified your test to use a list created with <code>list(range(1,1000)) + [0]</code> and <code>a = 0</code> (so that <code>a</code> is found at the end of the lengthy list); of course, I run it only for (pre-made) list, tuple, set, and frozenset, skipping the <code>or</code>-ed comparison. The results were quite different: frozenset 0.21, set 0.24, tuple 6.72, list 7.15. Apparently Python is doing a linear search in tuple or list, rather than converting it implicitly to a set. For Python3, the difference was even greater (~0.19 vs ~9.8),</span>
<span class="comment-copy">@Błotosmętek I'm seeing slightly different numbers.  set 0.26, frozenset 0.27, tuple 14.49, list 14.72.  Timing differences can be accounted for by CPU but what I don't quite understand is the difference in the order for set vs frozenset between us.  I would think we should be seeing the equivalent timing ratios.</span>
