<div class="post-text" itemprop="text">
<p>My example (list a and b are always the same size):</p>
<pre><code>a = ['12','12','12','12','12','23','24','24','31','31']
b = ['1','2','2','2','2','2','5','5','5','5']
c = a, b
</code></pre>
<p>Here is my code which needs something like an otherwise condition, the c[0] is so that the code only looks through list a rather than both lists and prints out the result of list a and b that fit the condition. <strong>The else condition in this code is wrong and I cant think of an alternative</strong>:</p>
<pre><code>d = list(zip(*[(ai,bi) for ai, bi in zip(a,b) if c[0].count(ai) == 5 else 2]))

e = list(zip(*[(ai,bi) for ai, bi in zip(a,b) if c[0].count(ai) == 7 else 2]))
</code></pre>
<p>Is it possible to change the condition so that it prints only counts of 5 if there are more than 2 counts in my example? Or that it prints only counts of 2 if 7 is the initial count but there are none detected?</p>
<p>My desired outcome:</p>
<pre><code>d = [('12','12','12','12','12',), ('1','2','2','2','2')]

e = [('24','24','31','31'), ('5','5','5','5')]
</code></pre>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to count your elements <strong>first</strong>, then decide which ones you are selecting. Use a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code> object</a> to count elements efficiently, so you can then decide what elements are to be picked:</p>
<pre><code>from collections import Counter

counts = Counter(a)
has_5 = any(c == 5 for c in counts.values())
has_7 = any(c == 7 for c in counts.values())
</code></pre>
<p>Now you know if there is an element that appears 5 times, and if there is an element that appears 7 times. You can now filter those elements by how many times they appear, without re-counting each iteration. Make your pick <em>first</em>, so you don't have to complicate the <code>if</code> logic:</p>
<pre><code>desired_count = 5 if has_5 else 2
d = list(zip(*[(ai,bi) for ai, bi in zip(a,b) if counts[ai] == desired_count]))

desired_count = 7 if has_7 else 2
e = list(zip(*[(ai,bi) for ai, bi in zip(a,b) if counts[ai] == desired_count]))
</code></pre>
<p>So <em>if</em> there is an element that appears 5 times, filter on those, otherwise filter on elements that only appear twice.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; a = ['12','12','12','12','12','23','24','24','31','31']
&gt;&gt;&gt; b = ['1','2','2','2','2','2','5','5','5','5']
&gt;&gt;&gt; counts = Counter(a)
&gt;&gt;&gt; has_5 = any(c == 5 for c in counts.values())
&gt;&gt;&gt; has_7 = any(c == 7 for c in counts.values())
&gt;&gt;&gt; desired_count = 5 if has_5 else 2
&gt;&gt;&gt; list(zip(*[(ai,bi) for ai, bi in zip(a,b) if counts[ai] == desired_count]))
[('12', '12', '12', '12', '12'), ('1', '2', '2', '2', '2')]
&gt;&gt;&gt; desired_count = 7 if has_7 else 2
&gt;&gt;&gt; list(zip(*[(ai,bi) for ai, bi in zip(a,b) if counts[ai] == desired_count]))
[('24', '24', '31', '31'), ('5', '5', '5', '5')]
</code></pre>
</div>
<span class="comment-copy">Why the <code>c[0].count(...)</code> when you just could do <code>a.count(...)</code>?</span>
<span class="comment-copy">Also note that calling <code>count()</code> repeatedly is <i>expensive</i>. Create a <code>Counter()</code> first and use that object instea.</span>
<span class="comment-copy">Hi I mean that the code will look through list a and count if there are 5 repeating numbers. If there are then it will print out the 5 numbers. In another case I want it see if there are 7 repeating numbers. If there are then it will print out the 7 numbers however if there aren't 7, then it will print out only numbers with 2 counts.</span>
<span class="comment-copy">@MartijnPieters is it possible to see an example of your explanation?</span>
<span class="comment-copy">I think I know what you want to do, but that's not how list comprehensions work. You are making a single decision <i>up front</i>, before filtering. If there is an element that appears 5 times exactly, then select those, otherwise select elements that appear 2 times. Count first, then select one or the other subset to filter on.</span>
<span class="comment-copy">thank you for the help and explanation, it is good alternative!</span>
<span class="comment-copy">adding further conditions to that, could use elif before the else condition?</span>
<span class="comment-copy">@F.Lee: no, a <a href="https://docs.python.org/3/reference/expressions.html#conditional-expressions" rel="nofollow noreferrer">conditional expression</a> doesn't have an <code>elif</code> option. Just chain them, or expand to using a full <code>if .. elif .. else</code> statement.</span>
<span class="comment-copy">When you mean chain them, do you mean like 'if has_7 else 5 else 2' ?</span>
<span class="comment-copy">@F.Lee: the part before the <code>if</code> and after the <code>else</code> are themselves expressions, so you can put another conditional expression there <code>7 if has_7 else (5 if has_5 else 2)</code>.</span>
