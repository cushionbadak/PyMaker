<div class="post-text" itemprop="text">
<p>In python (v3.6.1), I am looking to write a class like this:</p>
<pre><code>class SecondClass(FirstClass):
    property = "custom"

print(SecondClass.name) #=&gt; "john"

class SecondClass(FirstClass):
    property = "notcustom"

print(SecondClass.name) #=&gt; "steve"
</code></pre>
<p>I have tried to set up the <code>FirstClass</code> class like this:</p>
<pre><code>class FirstClass:
    if property == "custom":
        name = "john"
    else:
        name = "steve"
</code></pre>
<p>But I don't seem to be able to edit the property of the <code>FirstClass</code> from the SecondClass.</p>
<p>Is this possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you're using Python 3.6, you can accomplish what your asking by using the new <a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__" rel="nofollow noreferrer"><code>__init_subclass__</code></a> method. From the documentation on <code>__init_subclass__</code>:</p>
<blockquote>
<p>This method is called whenever the containing class is subclassed. cls is then the new subclass. If defined as a normal instance method, this method is implicitly converted to a class method.</p>
</blockquote>
<pre><code>class FirstClass:
    def __init_subclass__(cls):
        super().__init_subclass__()
        if cls.property == "custom":
            cls.name = "john"
        else:
            cls.name = "steve"

class SecondClass(FirstClass):
    property = "custom"

print(SecondClass.name)

class SecondClass(FirstClass):
    property = "notcustom"

print(SecondClass.name) 
</code></pre>
<p>For a method that works with Python 3.5  and lower, you can use some Meta class magic:</p>
<pre><code>class FirstClass(type):
    def __init__(cls, name, bases, attrs):
        if cls.property == "custom":
            cls.name = "john"
        else:
            cls.name = "steve"
        super(FirstClass, cls).__init__(name, bases, attrs)

class SecondClass(metaclass=FirstClass):
    property = "custom"

print(SecondClass.name)

class SecondClass(metaclass=FirstClass):
    property = "notcustom"

print(SecondClass.name)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>@classmethod</code> might be your best bet here.</p>
<pre><code>class First:
    @classmethod
    def name(cls):
        return "john" if cls.prop() == "custom" else "steve"

class Second(First):
    @classmethod
    def prop(cls):
        return "custom"

print(Second.name()) # -&gt; john

class Second(First):
    @classmethod
    def prop(cls):
        return "notcustom"

print(Second.name()) # -&gt; steve
</code></pre>
<p>(also, don't use <code>property</code> because that's already a keyword in the language</p>
</div>
<span class="comment-copy">What Python version are you using?</span>
<span class="comment-copy">I've added the version into the question (it's 3.6.1)</span>
<span class="comment-copy"><code>init</code> and <code>self</code> sections is missing, please open any python module for syntax, will be guide you.</span>
<span class="comment-copy">+1 for the pointers and the note on <code>property</code> being a keyword in python, but @Christian Dean's answer was exactly what I was after</span>
