<div class="post-text" itemprop="text">
<p>I know that I can add a new key/value in a python dict by doing </p>
<pre><code>some_dict['absent_key'] = somevalue
</code></pre>
<p>But I don't really understand the internals work.</p>
<p>I used to think dictionaries behaved like C++ maps. Where the <code>[]</code> operator would create the element for the given key if it does not already exist, then return a reference to it so that it can be assigned a value in the same line with operator <code>=</code>.</p>
<p>But that behavior in C++ has the consequence that if we query from a map the value for a key that does not exist, then the element is created for that key, and the default value for the value type will be returned instead of an error. In python, this throws a <code>KeyError</code>.</p>
<p>So what I don't understand is: How, since <code>[]</code> operator must be evaluated before <code>=</code> in python too (I think?), does it behave differently depending if the result will be read or assigned a value (which it should not know about at that point of the expression evaluation)?</p>
<p>Is there a difference in the order in which python evaluates expressions? Or is the interpreter simply smarter since dictionaries hare a hardcoded type so it knows more precisely how it behaves, while std::map are in a 'library' so the compiler can assume less? Or some other reason?</p>
</div>
<div class="post-text" itemprop="text">
<p>The operations:</p>
<pre><code>some_dict[key]
</code></pre>
<p>and </p>
<pre><code>some_dict[key] = value
</code></pre>
<p>and </p>
<pre><code>del some_dict[key]
</code></pre>
<p>use different special methods of the object: <a href="https://docs.python.org/reference/datamodel.html#object.__getitem__" rel="noreferrer"><code>__getitem__</code></a>, <a href="https://docs.python.org/reference/datamodel.html#object.__setitem__" rel="noreferrer"><code>__setitem__</code></a> and <a href="https://docs.python.org/reference/datamodel.html#object.__delitem__" rel="noreferrer"><code>__delitem__</code></a>. So it's not just one operator (<code>[]</code>) that implements them all.</p>
<p>Maybe an example can illustrate that:</p>
<pre><code>class Something(dict):  # subclassing dict
    def __getitem__(self, key):
        print('trying to get', key)
        return super().__getitem__(key)
    def __setitem__(self, key, value):
        print('trying to set', key, 'to', value)
        return super().__setitem__(key, value)
    def __delitem__(self, key):
        print('trying to delete', key)
        return super().__delitem__(key)
</code></pre>
<p>Test:</p>
<pre><code>&gt;&gt;&gt; s = Something({'a': 1, 'b': 2})
&gt;&gt;&gt; s['a']
trying to get a
1

&gt;&gt;&gt; s['c'] = 10
trying to set c to 10

&gt;&gt;&gt; del s['b']
trying to delete b
</code></pre>
<p>So it depends on how they are implemented. In plain Python <code>dict</code>s <code>__getitem__</code> just returns the value for the key or throws if it's not present. </p>
<p>But subclasses could also implement the <a href="https://docs.python.org/reference/datamodel.html#object.__missing__" rel="noreferrer"><code>__missing__</code></a> method - in case they want to customize the behavior if the key wasn't present in the dict (during lookup).</p>
</div>
<div class="post-text" itemprop="text">
<h2>What's going on behind the scenes?</h2>
<p>In Python, When you assign a value to a key:</p>
<pre><code>dictionary[key] = value
</code></pre>
<p>Python translates the above syntactic sugar into:</p>
<pre><code>dictionary.__setitem__(key, value)
</code></pre>
<p>As you can see, behind the scenes Python calls the <code>__setitem__</code> method. The <code>__setitem__</code> method corresponds directly to the operation of indexing a data structure and assigning a new value to said index. It can be overloaded to  customize it's behavior.</p>
<p>The default behavior with <code>__setitem__</code> for Python dictionaries is to change the key's value if it exists, and if not raise a <code>KeyError</code>. To prove this, you can subclass the <code>dict</code> class and overload <code>__setitem__</code> to display it's arguments:</p>
<pre><code>&gt;&gt;&gt; class Dict(dict):
...     def __setitem__(self, key, value):
...         print('Putting "%s" in dict with value of "%s"' % (key, value))
...         super().__setitem__(key, value)
...
&gt;&gt;&gt;
&gt;&gt;&gt; d = Dict()
&gt;&gt;&gt; d['name'] = 'Hammy'
Putting "name" in dict with value of "Hammy"
&gt;&gt;&gt; d['age'] = 25
Putting "age" in dict with value of "25"
&gt;&gt;&gt; d
{'name': 'Hammy', 'age': 25}
</code></pre>
<h2>Does Python have an std::map equivalent?</h2>
<p>Like @MSeifert said, you can customize what happens when a key is not present by overloading the <code>__missing__</code> method.</p>
<p>That is what the <a href="https://docs.python.org/3/library/collections.html?highlight=collections#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> class does in the standard library. It overloads <code>__missing__</code> to create a missing <code>key</code> and map a default value of your choice to it. <a href="https://github.com/python/cpython/blob/6969eaf4682beb01bc95eeb14f5ce6c01312e297/Modules/_collectionsmodule.c#L1982" rel="nofollow noreferrer">Here's the relevant snippet</a> from the CPython source:</p>
<pre class="lang-c prettyprint-override"><code>static PyObject *
defdict_missing(defdictobject *dd, PyObject *key)
{
    PyObject *factory = dd-&gt;default_factory;
    PyObject *value;
    /* ... */
    value = PyEval_CallObject(factory, NULL);
    if (value == NULL)
        return value;
    if (PyObject_SetItem((PyObject *)dd, key, value) &lt; 0) {
        Py_DECREF(value);
        return NULL;
    }
    return value;
}
</code></pre>
<p>Note that <code>defaultdict</code> is implemented in C. Here's an example of the usage:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; map = defaultdict(int)
&gt;&gt;&gt; map['a'] = 1
&gt;&gt;&gt; map['b'] = 2
&gt;&gt;&gt; map['c'] # default factory function `int` called
0
&gt;&gt;&gt; map
defaultdict(&lt;class 'int'&gt;, {'a': 1, 'b': 2, 'c': 0})
</code></pre>
<p><code>defaultdict</code> pretty much matches the  behavior of the std::map::operator[]. If a key is not present when using std::map::operator[], the operator calls a "factory function" that matches the key's value's expected types, and assigns that to the missing key.</p>
<p>So if you want something that behaves like std::map, use <code>defaultdict</code>. Note I said "like", though. That's because C++ and Python are <strong>two complete different languages</strong>. Saying a data structure in one language has an <em>exact</em> equivalent in another is very rarely correct.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>my_dict['key'] = 'value'</code> notation is just sugar for:</p>
<pre><code>my_dict.__setitem__('key', 'value')
</code></pre>
<p>That function does all the work of storing the data. It can be implemented, however, you want. The underlying mechanism python interpreters and libraries use is most often from a faster compiled language like C.</p>
<p>There are more functions like this like, <code>__len__()</code>, <code>__getitem__(x)</code>, and <code>__delitem__(x)</code> which handle all <a href="https://docs.python.org/2.0/ref/sequence-types.html" rel="nofollow noreferrer">the other dict</a> like operations.</p>
</div>
<span class="comment-copy">On the lhs, <code>[]</code> is mapped to <code>__setitem__(key, rhs)</code> on the rhs <code>[]</code> maps to <code>__getitem__(key)</code> - they implement the different logic. In C++ <code>[]</code> is its own operator that returns a reference that can be updated. In python <code>=</code> is a statement and the <code>lhs</code> is not an expression like in <code>C++</code>.</span>
<span class="comment-copy">Side note: the access operator <code>[]</code> is not necessary: you can do <code>dictionary.get(key, some_optional_default_value_if_key_not_found)</code>.</span>
<span class="comment-copy">Cool, so that also means i could subclass dict, and overload __getitem__() to get it to behave like a std::map if i wanted :)</span>
<span class="comment-copy">@bartoli Yes. But I think you don't need to create your own subclass for that: <a href="https://docs.python.org/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> is also available in Pythons standard library. Not sure it's identical to <code>std::map</code> but it's "closer". :)</span>
<span class="comment-copy">@MSeifert I'd say the behavior is <i>very</i> close ;-) See here: <a href="https://stackoverflow.com/questions/10124679/what-happens-if-i-read-a-maps-value-where-the-key-does-not-exist" title="what happens if i read a maps value where the key does not exist">stackoverflow.com/questions/10124679/â€¦</a>.</span>
<span class="comment-copy">@ChristianDean I'm always careful when comparing data structures from different languages. If you use absolutes (a from language A is equivalent to b from language B) someone will poke at it and come up with 100 (some valid some ... not) reasons why it's not equivalent. Just my personal experience.</span>
<span class="comment-copy">@MSeifert I completely agree. That's why I was adding a caveat to my answer. When I said "very close" in my comment, I meant purely the <i>behavior</i> of what happens when a key is missing. In both data structures, an error is not raised. Of course there are still differences such as the "factory function" that is called when a key is missing, so I would never claim them to be identical.</span>
<span class="comment-copy">@MSeifert Thanks for that C code highlighting. I was trying to remember how to do that.</span>
<span class="comment-copy">Gosh, where have you found that Python 2.0 (!!!) documentation link?</span>
