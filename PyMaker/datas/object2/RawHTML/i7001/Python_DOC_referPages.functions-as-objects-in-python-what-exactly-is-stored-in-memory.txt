<div class="post-text" itemprop="text">
<p>I've been using Python for a while now to solve practical problems, but I still don't have a proper theoretical understanding of what's going on behind the hood. For example, I'm struggling to understand how Python manages to treat functions as objects. I know that functions are objects of the class 'function', with a 'call' method, and I am aware that I can make my custom-made classes behave like functions by writing a 'call method' for them. But I can't figure out what precisely gets stored in memory when new functions are created, and how to access the information that gets stored.</p>
<p>To experiment, I wrote a little script that creates lots of function objects and stores them in a list. I noticed that this program used up a lot of memory.</p>
<pre><code>funct_list = []
for i in range(10000000):
    def funct(n):
        return n + i
    funct_list.append(funct)
</code></pre>
<p>My questions are:</p>
<ul>
<li><p>What precisely gets stored in RAM when I define a new function object? Am I storing the details of how the function is to be implemented?</p></li>
<li><p>If so, does my function object have attributes or methods that allow me to "inspect" (or possibly even "alter retrospectively") the way the function behaves?</p></li>
<li><p>Maybe my previous question is circular, because the methods of the function object are functions in their own right...</p></li>
<li><p>In my code above, some of the RAM is used simply to store the "pointers" to my function objects in the list. The rest of the RAM is presumably used to store the interesting stuff about how my function objects actually work. Roughly how is the RAM distributed between these two purposes?</p></li>
<li><p>Suppose I alter the code snippet by making the function do more complicated stuff. Will I use up much more RAM as a consequence? (I would expect so. But when I altered the definition of my function by filling its body with 1000 lines of junk, there didn't appear to be any difference in the amount of RAM used up.)</p></li>
</ul>
<p>I would love to find a comprehensive reference about this. But whatever I type into google, I can't seem to find what I'm looking for!</p>
</div>
<div class="post-text" itemprop="text">
<p>A function object's data is divided into two primary parts. The parts that would be the same for all functions created by the same function definition are stored in the function's <em>code object</em>, while the parts that can change even between functions created from the same function definition are stored in the function object.</p>
<p>The most interesting part of a function is probably its bytecode. This is the core data structure that says what to actually do to execute a function. It's stored as a bytestring in the function's code object, and you can examine it directly:</p>
<pre><code>&gt;&gt;&gt; def fib(i):
...     x, y = 0, 1
...     for _ in range(i):
...         x, y = y, x+y
...     return x
... 
&gt;&gt;&gt; fib.__code__.co_code
b'd\x03\\\x02}\x01}\x02x\x1et\x00|\x00\x83\x01D\x00]\x12}\x03|\x02|\x01|\x02\x17\x00\x02\x00}\x01}\x02q\x1
2W\x00|\x01S\x00'
</code></pre>
<p>...but it's not designed to be human-readable.</p>
<p>With enough knowledge of the implementation details of Python bytecode, you could parse that yourself, but describing all that would take way too long. Instead, we'll use the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> module to disassemble the bytecode for us:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(fib)
  2           0 LOAD_CONST               3 ((0, 1))
              2 UNPACK_SEQUENCE          2
              4 STORE_FAST               1 (x)
              6 STORE_FAST               2 (y)

  3           8 SETUP_LOOP              30 (to 40)
             10 LOAD_GLOBAL              0 (range)
             12 LOAD_FAST                0 (i)
             14 CALL_FUNCTION            1
             16 GET_ITER
        &gt;&gt;   18 FOR_ITER                18 (to 38)
             20 STORE_FAST               3 (_)
  4          22 LOAD_FAST                2 (y)
             24 LOAD_FAST                1 (x)
             26 LOAD_FAST                2 (y)
             28 BINARY_ADD
             30 ROT_TWO
             32 STORE_FAST               1 (x)
             34 STORE_FAST               2 (y)
             36 JUMP_ABSOLUTE           18
        &gt;&gt;   38 POP_BLOCK
  5     &gt;&gt;   40 LOAD_FAST                1 (x)
             42 RETURN_VALUE
</code></pre>
<p>There are a number of columns in the output here, but we're mostly interested in the one with the ALL_CAPS and the columns to the right of that.</p>
<p>The ALL_CAPS column shows the function's bytecode instructions. For example, <code>LOAD_CONST</code> loads a constant value, and <code>BINARY_ADD</code> is the instruction to add two objects with <code>+</code>. The next column, with the numbers, is for bytecode arguments. For example, <code>LOAD_CONST 3</code> says to load the constant at index 3 in the code object's constants. These are always integers, and they're packed into the bytecode string along with the bytecode instructions. The last column mostly provides human-readable explanations of the bytecode arguments, for example, saying that the 3 in <code>LOAD_CONST 3</code> corresponds to the constant <code>(0, 1)</code>, or that the <code>1</code> in <code>STORE_FAST 1</code> corresponds to local variable <code>x</code>. The information in this column doesn't actually come from the bytecode string; it's resolved by examining other parts of the code object.</p>
<hr/>
<p>The rest of a function object's data is primarily stuff needed to resolve bytecode arguments, like the function's closure or its global variable dict, and stuff that just exists because it's handy for introspection, like the function's <code>__name__</code>.</p>
<p>If we take a look at the Python 3.6 <a href="https://github.com/python/cpython/blob/3.6/Include/funcobject.h#L21" rel="nofollow noreferrer">function object struct definition</a> at C level:</p>
<pre class="lang-c prettyprint-override"><code>typedef struct {
    PyObject_HEAD
    PyObject *func_code;    /* A code object, the __code__ attribute */
    PyObject *func_globals; /* A dictionary (other mappings won't do) */
    PyObject *func_defaults;    /* NULL or a tuple */
    PyObject *func_kwdefaults;  /* NULL or a dict */
    PyObject *func_closure; /* NULL or a tuple of cell objects */
    PyObject *func_doc;     /* The __doc__ attribute, can be anything */
    PyObject *func_name;    /* The __name__ attribute, a string object */
    PyObject *func_dict;    /* The __dict__ attribute, a dict or NULL */
    PyObject *func_weakreflist; /* List of weak references */
    PyObject *func_module;  /* The __module__ attribute, can be anything */
    PyObject *func_annotations; /* Annotations, a dict or NULL */
    PyObject *func_qualname;    /* The qualified name */

    /* Invariant:
     *     func_closure contains the bindings for func_code-&gt;co_freevars, so
     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)
     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).
     */
} PyFunctionObject;
</code></pre>
<p>we can see that there's the code object, and then</p>
<ul>
<li>the global variable dict,</li>
<li>the default argument values,</li>
<li>the keyword-only argument default values,</li>
<li>the function's closure cells,</li>
<li>the docstring,</li>
<li>the name,</li>
<li>the <code>__dict__</code>,</li>
<li>the list of weak references to the function,</li>
<li>the <code>__module__</code>,</li>
<li>the annotations, and</li>
<li>the <code>__qualname__</code>, the fully qualified name</li>
</ul>
<p>Inside the <code>PyObject_HEAD</code> macro, there's also the type pointer and some refcount/GC metadata.</p>
<p>We didn't have to go straight to C to examine most of that - we could have looked at the <code>dir</code> and filtered out non-instance attributes, since most of that data is available at Python level - but the struct definition provides a nice, commented, uncluttered list.</p>
<p>You can examine the <a href="https://github.com/python/cpython/blob/3.6/Include/code.h#L20" rel="nofollow noreferrer">code object struct definition</a> too, but the contents aren't as clear if you're not already familiar with code objects, so I'm not going to embed it in the post. I'll just explain code objects.</p>
<p>The core component of a code object is a bytestring of Python bytecode instructions and arguments. We examined one of those earlier. In addition, the code object contains things like a tuple of the constants the function refers to, and a lot of other internal metadata required to figure out how to actually execute each instruction. Not all the metadata - some of it comes from the function object - but a lot of it. Some of it, like that tuple of constants, is fairly easily understandable, and some of it, like <code>co_flags</code> (a bunch of internal flags) or <code>co_stacksize</code> (the size of the stack used for temporary values) is more esoteric.</p>
</div>
<div class="post-text" itemprop="text">
<p>Functions are objects just like any other: they are instances of a type (or class). You can get the type of a function using <code>type(f)</code>, where <code>f</code> is a function, or use the <code>types</code> module (<code>types.FunctionType</code>).</p>
<p>When you define a function, Python builds a function object and assigns a name to it. This machinery is hidden behind the <code>def</code> statement, but it works the same as the instantiation of any other type. </p>
<p>Which means that in Python, <em>function definitions are executed,</em> unlike in some other languages. Among other things, this means that functions don't exist until the flow of code reaches them, so you can't call a function before it has been defined.</p>
<p>The <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> module lets you snoop around inside various kinds of objects. <a href="https://docs.python.org/3/library/inspect.html#types-and-members" rel="nofollow noreferrer">This table</a> in its documentation is useful for seeing what kinds of components functions and related types of objects (such as methods) are made from, and how to get to them.</p>
<p>The actual code inside a function becomes a code object, which contains the byte code that is executed by the Python interpreter. You can see this using the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> module.</p>
<p>Looking at the <code>help()</code> of the types for functions and code objects is interesting, as it shows what arguments you need to pass in to build these objects. It is possible to make new functions from raw byte code, to copy byte code from one function to another but use a different closure, and so on.</p>
<pre><code>help(type(lambda: 0))
help(type((lambda: 0).__code__))
</code></pre>
<p>You can also build code objects using the <a href="https://docs.python.org/3/library/functions.html#compile" rel="nofollow noreferrer"><code>compile()</code></a> function and then build functions out of them.</p>
<h3>Fun Fact</h3>
<p>Any object whose type has a <code>__call__()</code> method is callable. Functions are callable, and their type has a <code>__call__()</code> method. Which is callable. Which means it, too, has a <code>__call__()</code> method, which has a <code>__call__()</code> method, <em>ad nauseam, ad infinitum.</em> </p>
<p>How does a function actually get called, then? Python actually bypasses <code>__call__</code> for objects with <code>__call__</code> implemented in C, such as a Python function's <code>__call__</code> method. Indeed, <code>(lambda: 0).__call__</code> is a <code>method-wrapper</code>, which is used to wrap a C function.</p>
</div>
<span class="comment-copy">function are object in heap,that's all.</span>
