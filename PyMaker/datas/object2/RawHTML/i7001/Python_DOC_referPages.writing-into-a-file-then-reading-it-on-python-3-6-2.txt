<div class="post-text" itemprop="text">
<pre><code>target=open("test.txt",'w+')
target.write('ffff')
print(target.read())
</code></pre>
<p>When running the following python script (test.txt is an empty file), it prints an empty string.</p>
<p>However, when reopening the file, it can read it just fine:</p>
<pre><code>target=open("test.txt",'w+')
target.write('ffff')
target=open("test.txt",'r')
print(target.read())
</code></pre>
<p>This prints out 'ffff' as needed.</p>
<p>Why is this happening? Is 'target' still recognized as having no content, even though I updated it in line 2, and I have to reassign test.txt to it?</p>
</div>
<div class="post-text" itemprop="text">
<p>A file has a read/write position. Writing to the file puts that position at the end of the written text; reading starts from the same position.</p>
<p>Put that position back to the start with the <a href="https://docs.python.org/3/library/io.html#io.IOBase.seek" rel="noreferrer"><code>seek</code> method</a>:</p>
<pre><code>with open("test.txt",'w+') as target:
    target.write('ffff')
    target.seek(0)  # to the start again
    print(target.read())
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; with open("test.txt",'w+') as target:
...     target.write('ffff')
...     target.seek(0)  # to the start again
...     print(target.read())
...
4
0
ffff
</code></pre>
<p>The numbers are the return values of <code>target.write()</code> and <code>target.seek()</code>; they are the number of characters written, and the new position.</p>
</div>
<div class="post-text" itemprop="text">
<p>No need to close and re-open it. You just need to seek back to the file's starting point before reading it:</p>
<pre><code>with open("test.txt",'w+') as f:
    f.write('ffff')
    f.seek(0)
    print(f.read())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try flushing, then seeking the beginning of the file:</p>
<pre><code>f = open(path, 'w+')
f.write('foo')
f.write('bar')
f.flush()
f.seek(0)
print(f.read())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you have to <code>close()</code> the file before reading it. You cannot read and write to a file at the same time. this causes inconsistency.</p>
</div>
<span class="comment-copy">you're forgetting to <code>close()</code> the file. that will flush the data into the file.</span>
<span class="comment-copy">that or you have to rewind the file. Depends on what you want to achieve.</span>
<span class="comment-copy">@Jean-FrançoisFabre: what has flushing got to do with this? It's the same file object, same file handle, same process. Reading will find the data in the buffer if needed.</span>
<span class="comment-copy">@MartijnPieters corrected in the second comment. But it's not clear what OP is trying to do. close and read or rewind and read.</span>
<span class="comment-copy">@Jean-FrançoisFabre: they expected to be able to read the data they have written to the file, without reopening.</span>
<span class="comment-copy">Flushing is <i>not needed</i>. This is the same process, same file handle.</span>
<span class="comment-copy">This is patent nonsense. The file I/O layer knows how to read from the buffer too. All you need to do is understand file positions.</span>
